{
  "metadata": {
    "timestamp": 1736565498214,
    "page": 362,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ReactiveX/RxCpp",
      "stars": 3076,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.14453125,
          "content": "root = true\n \n[*]\nindent_style = space\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.458984375,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.8056640625,
          "content": "#################\n## Visual Studio\n#################\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\n*_i.c\n*_p.c\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.vspscc\n.builds\n*.dotCover\n\n## TODO: If you have NuGet Package Restore enabled, uncomment this\n#packages/\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# Installshield output folder\n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n*.Cache\nClientBin\nstylecop.*\n~$*\n*.dbmdl\nGenerated_Code #added for RIA/Silverlight projects\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\n\n\n\n############\n## Windows\n############\n\n# Windows image file caches\nThumbs.db\n\n# Folder config file\nDesktop.ini\n\n############\n## Mac\n############\n\n.DS_Store\n\n############\n## CMake\n############\n\nbuild/*\ndest/*\n.vscode/*\nnmake/*\nprojects/*\n!projects/CMake/CMakeLists.txt\n!projects/CMake/shared.cmake\n!projects/nuget/rxcpp.autopackage\n!projects/doxygen\n!projects/scripts\nTesting/*\n\nCMakeCache.txt\nCMakeFiles\n*.cmake\n*.log\n*.vcxproj*\n*.sln\nMakefile\n\n############\n## Sublime\n############\n\n*.sublime-*\n\n############\n## Doxygen\n############\n\nprojects/doxygen/*.conf\nprojects/doxygen/html\nRx/v2/examples/doxygen/output.txt\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.087890625,
          "content": "[submodule \"ext/catch\"]\n\tpath = ext/catch\n\turl = https://github.com/philsquared/Catch.git\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 7.7900390625,
          "content": "language: cpp\n\ndist: trusty\nsudo: true\n\nenv:\n  global:\n    secure: FNZOWYO89qsT9kQKngrYbpnqCTMCSCSQ2rnZ3l17KHctOfS554TTDS+dfxPYz2XHm6azYDVcyBSs2gWJ6TmXZZZqEfr3X4VV4ooAa9PoeIkvVlT654zjZwxeXPYXrHFXZh/ImLUGWjsxRaUHYOv5SzyNGcZv07dtLKVd0ykhbH4=\n\nmatrix:\n  include:\n\n  - env: BUILD_TYPE=Debug ASAN=Off RUN_TEST=On EXCEPTIONS=On\n    os: osx\n    osx_image: xcode8\n\n  - env: BUILD_TYPE=Debug ASAN=Off LLVM_VERSION=3.8.0 RUN_TEST=On EXCEPTIONS=On\n    os: linux\n    compiler: clang\n\n  - env: BUILD_TYPE=Release ASAN=Off GCC_VERSION=4.9 RUN_TEST=On EXCEPTIONS=On\n    os: linux\n    compiler: gcc\n    addons:\n      apt:\n        packages:\n        - g++-4.9\n        sources:\n        - ubuntu-toolchain-r-test\n\n  - env: BUILD_TYPE=Release ASAN=Off GCC_VERSION=7 RUN_TEST=On EXCEPTIONS=On\n    os: linux\n    compiler: gcc\n    addons: &gcc7\n      apt:\n        packages:\n          - g++-7\n        sources:\n          - ubuntu-toolchain-r-test\n\n  - env: BUILD_TYPE=Debug ASAN=Off GCC_VERSION=8 RUN_TEST=On EXCEPTIONS=Off\n    os: linux\n    compiler: gcc\n    addons: &gcc8\n      apt:\n        packages:\n          - g++-8\n        sources:\n          - ubuntu-toolchain-r-test\n\n  - env: BUILD_TYPE=Release ASAN=Off GCC_VERSION=8 RUN_TEST=On EXCEPTIONS=On\n    os: linux\n    compiler: gcc\n    addons: &gcc8\n      apt:\n        packages:\n          - g++-8\n        sources:\n          - ubuntu-toolchain-r-test\n\n  - env: BUILD_TYPE=Debug ASAN=Off LLVM_VERSION=3.8.0 RUN_TEST=Off EXCEPTIONS=On PROJECT=doc PUBLISH_DOCS=On DOXYGEN_VERSION=1.8.11\n    os: linux\n    compiler: clang\n    addons:\n      apt:\n        packages:\n        - graphviz\n        sources:\n        - ubuntu-toolchain-r-test\n\ncache:\n  directories:\n    - ${TRAVIS_BUILD_DIR}/deps/llvm-3.8.0\n    - ${TRAVIS_BUILD_DIR}/deps/cmake-3.5.2\n    - ${TRAVIS_BUILD_DIR}/deps/doxygen-1.8.11\n\ninstall:\n  ############################################################################\n  # All the dependencies are installed in ${TRAVIS_BUILD_DIR}/deps/\n  ############################################################################\n  - DEPS_DIR=\"${TRAVIS_BUILD_DIR}/deps\"\n  - mkdir -p ${DEPS_DIR} && cd ${DEPS_DIR}\n\n  ############################################################################\n  # Install Clang, libc++ and libc++abi\n  ############################################################################\n  - |\n    if [[ \"${LLVM_VERSION}\" != \"\" ]]; then\n      LLVM_DIR=${DEPS_DIR}/llvm-${LLVM_VERSION}\n      if [[ -z \"$(ls -A ${LLVM_DIR})\" ]]; then\n        LLVM_URL=\"http://llvm.org/releases/${LLVM_VERSION}/llvm-${LLVM_VERSION}.src.tar.xz\"\n        LIBCXX_URL=\"http://llvm.org/releases/${LLVM_VERSION}/libcxx-${LLVM_VERSION}.src.tar.xz\"\n        LIBCXXABI_URL=\"http://llvm.org/releases/${LLVM_VERSION}/libcxxabi-${LLVM_VERSION}.src.tar.xz\"\n        CLANG_URL=\"http://llvm.org/releases/${LLVM_VERSION}/clang+llvm-${LLVM_VERSION}-x86_64-linux-gnu-ubuntu-14.04.tar.xz\"\n        mkdir -p ${LLVM_DIR} ${LLVM_DIR}/build ${LLVM_DIR}/projects/libcxx ${LLVM_DIR}/projects/libcxxabi ${LLVM_DIR}/clang\n        travis_retry wget --quiet -O - ${LLVM_URL}      | tar --strip-components=1 -xJ -C ${LLVM_DIR}\n        travis_retry wget --quiet -O - ${LIBCXX_URL}    | tar --strip-components=1 -xJ -C ${LLVM_DIR}/projects/libcxx\n        travis_retry wget --quiet -O - ${LIBCXXABI_URL} | tar --strip-components=1 -xJ -C ${LLVM_DIR}/projects/libcxxabi\n        travis_retry wget --quiet -O - ${CLANG_URL}     | tar --strip-components=1 -xJ -C ${LLVM_DIR}/clang\n        (cd ${LLVM_DIR}/build && cmake .. -DCMAKE_INSTALL_PREFIX=${LLVM_DIR}/install -DCMAKE_CXX_COMPILER=clang++)\n        (cd ${LLVM_DIR}/build/projects/libcxx && make install -j2)\n        (cd ${LLVM_DIR}/build/projects/libcxxabi && make install -j2)\n      fi\n      export CXXFLAGS=\"-nostdinc++ -isystem ${LLVM_DIR}/install/include/c++/v1\"\n      export LDFLAGS=\"-L ${LLVM_DIR}/install/lib -l c++ -l c++abi\"\n      export LD_LIBRARY_PATH=\"${LD_LIBRARY_PATH}:${LLVM_DIR}/install/lib\"\n      export PATH=\"${LLVM_DIR}/clang/bin:${PATH}\"\n      $LLVM_DIR/clang/bin/clang++ --version\n    fi\n\n  ############################################################################\n  # Use gcc\n  ############################################################################\n  - |\n    if [ -n \"$GCC_VERSION\" ]; then\n      export CXX=\"g++-${GCC_VERSION}\" CC=\"gcc-${GCC_VERSION}\";\n      g++-${GCC_VERSION} --version\n    fi\n\n  - $CXX --version\n\n  ############################################################################\n  # Install a recent Doxygen\n  ############################################################################\n  - |\n    if [ -n \"$DOXYGEN_VERSION\" ]; then\n      DOXYGEN_DIR=${DEPS_DIR}/doxygen-${DOXYGEN_VERSION}\n      if [[ -z \"$(ls -A ${DOXYGEN_DIR})\" ]]; then\n        DOXYGEN_URL=\"https://downloads.sourceforge.net/doxygen/doxygen-${DOXYGEN_VERSION}.linux.bin.tar.gz\"\n        mkdir -p ${DOXYGEN_DIR} && travis_retry wget --quiet -O - ${DOXYGEN_URL} | tar --strip-components=1 -xz -C ${DOXYGEN_DIR}\n      fi\n      export PATH=${DOXYGEN_DIR}/bin:${PATH}\n      doxygen --version\n    fi\n\n  ############################################################################\n  # Install a recent CMake (unless already installed on OS X)\n  ############################################################################\n  - |\n    if [ -z \"$CMAKE_VERSION\" ]; then\n      CMAKE_VERSION=3.5.2;\n    fi;\n    if [[ \"${TRAVIS_OS_NAME}\" == \"linux\" ]]; then\n      CMAKE_DIR=${DEPS_DIR}/cmake-${CMAKE_VERSION}\n      if [[ -z \"$(ls -A ${CMAKE_DIR})\" ]]; then\n        CMAKE_URL=\"http://www.cmake.org/files/v3.5/cmake-${CMAKE_VERSION}-Linux-x86_64.tar.gz\"\n        mkdir -p ${CMAKE_DIR} && travis_retry wget --no-check-certificate --quiet -O - ${CMAKE_URL} | tar --strip-components=1 -xz -C ${CMAKE_DIR}\n      fi\n      export PATH=${CMAKE_DIR}/bin:${PATH}\n    else\n      if ! brew ls --version cmake &>/dev/null; then brew install cmake; fi\n    fi\n    cmake --version\n\nbefore_script:\n  - |\n    if [ -z \"$BUILD_TYPE\" ]; then\n      BUILD_TYPE=Release;\n    fi;\n    if [ -z \"$EXCEPTIONS\" ]; then\n      EXCEPTIONS=On;\n    fi;\n    if [[ \"${ASAN}\" == \"On\" ]]; then\n      export CXXFLAGS=\"${CXXFLAGS} -fsanitize=address,undefined,integer -fno-omit-frame-pointer -fno-sanitize=unsigned-integer-overflow\";\n    fi;\n    if [ -n \"$LLVM_VERSION\" ]; then\n      export CXXFLAGS=\"${CXXFLAGS} -D__extern_always_inline=inline\";\n    fi;\n\n  ############################################################################\n  # generate build\n  ############################################################################\n  - cd ${TRAVIS_BUILD_DIR}\n  - cmake . -DCMAKE_BUILD_TYPE=${BUILD_TYPE} -DRX_USE_EXCEPTIONS=${EXCEPTIONS}\n\nscript:\n  ############################################################################\n  # Run build\n  ############################################################################\n  - make VERBOSE=1 $PROJECT\n\n  ############################################################################\n  # Test build\n  ############################################################################\n  - cd build/test/\n  - if [[ \"${RUN_TEST}\" == \"On\" ]]; then ctest -V; fi\n  - cd ../../\n\nafter_success:\n  ############################################################################\n  # Publish documentation\n  ############################################################################\n  - |\n    if [[ \"${PUBLISH_DOCS}\" == \"On\" ]]; then\n      sh projects/scripts/travis-doxygen.sh;\n    fi;\n\nbranches:\n  only:\n  - main\n\nnotifications:\n  email:\n    recipients:\n      - kirk.shoop@gmail.com\n    on_success: always\n    on_failure: always\n  slack: reactivex:eq4FFCchRIzufO2ZmpuuiJ9E\n  webhooks:\n    urls:\n      - https://webhooks.gitter.im/e/fcf05f21f5d4102e12e7\ndeploy:\n  - provider: releases\n    api_key:\n      secure: sMyo0U4WxZ0kOlQ9SzKfeuU2/5y0Ngt8A0B0N6bb0TcGIyLhQv2q216Q+T0rkQKc04WnLY0Vr1/q9LonAA46nGq7zAiWcC3TY0zVUKRmKWrotQb/QqW1tvVEARKwG7CO+HCcGT3XCeM69XA/L7WiXRskTxS1+5Vy46/tVZBKofg=\n    file: ''\n    on:\n      tags: true\n      repo: Reactive-Extensions/RxCpp\n"
        },
        {
          "name": "AUTHORS.txt",
          "type": "blob",
          "size": 0.5263671875,
          "content": "List of contributors to the Rx libraries\n\nRx and Ix.NET:\nWes Dyer\nJeffrey van Gogh\nMatthew Podwysocki\nBart de Smet\nDanny van Velzen\nErik Meijer\nBrian Beckman\nAaron Lahman\nGeorgi Chkodrov\nArthur Watson\nGert Drapers\nMark Shields\n\nRx.js and Ix.js:\nMatthew Podwysocki\nJeffrey van Gogh\nBart de Smet\nBrian Beckman\nWes Dyer\nErik Meijer\n\nTx:\nGeorgi Chkodrov\nBart de Smet\nAaron Lahman\nErik Meijer\nBrian Grunkemeyer\nBeysim Sezgin\nTiho Tarnavski\nCollin Meek\nSajay Anthony\nKaren Albrecht\nJohn Allen\nZach Kramer\n\nRx++ and Ix++:\nAaron Lahman\nKirk Shoop\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.1083984375,
          "content": "cmake_minimum_required(VERSION 3.2 FATAL_ERROR)\n\n# define some folders\n\nadd_subdirectory(projects/CMake build)\n"
        },
        {
          "name": "DeveloperManual.md",
          "type": "blob",
          "size": 3.24609375,
          "content": "# Developer Manual\n\n## Some comments on the scheduler system\n\nThe scheduler in rxcpp v2 is based on the scheduler and worker constructs that *RxJava* uses (Eric Meijer was involved) The docs for *RxJava* will have an explanation for ```scheduler``` and ```worker```. RxCpp adds ```schedulable```, ```coordination``` and ```coordinator```.\n\n```scheduler``` owns a timeline that is exposed by the ```now()``` method. ```scheduler``` is also a factory for workers in that timeline. Since a scheduler owns a timeline it is possible to build schedulers that time-travel. The virtual-scheduler is a base for the test-scheduler that uses this to make multi-second tests complete in ms.\n\n```worker``` owns a queue of pending ```schedulable```s for the timeline and has a lifetime. When the time for an ```schedulable``` is reached the ```schedulable``` is run. The queue maintains insertion order so that when N ```schedulable```s have the same target time they are run in the order that they were inserted into the queue. The ```worker``` guarantees that each ```schedulable``` completes before the next ```schedulable``` is started. when the ```worker```'s lifetime is unsubscribed all pending ```schedulable```s are discarded.\n\n```schedulable``` owns a function and has a ```worker``` and a ```lifetime```. When the ```schedulable```'s ```lifetime``` is unsubscribed the ```schedulable``` function will not be called. The ```schedulable``` is passed to the function and allows the function to reschedule itself or schedule something else on the same worker.\n\nThe new concepts are ```coordination``` and ```coordinator```. I added these to simplify operator implementations and to introduce pay-for-use in operator implementations. Specifically, in Rx.NET and RxJava, the operators use atomic operations and synchronization primitives to coordinate messages from multiple streams even when all the streams are on the same thread (like UI events). The ```identity_...``` coordinations in RxCpp are used by default and have no overhead. The ```synchronize_...``` and ```observe_on_...``` coordinations use mutex and queue-onto-a-worker respectively, to interleave multiple streams safely.\n\n```coordination``` is a factory for ```coordinator```s and has a scheduler.\n\n```coordinator``` has a ```worker```, and is a factory for coordinated observables, subscribers and schedulable functions.\n\nAll the operators that take multiple streams or deal in time (even ```subscribe_on``` and ```observe_on```) take a coordination parameter, not scheduler.\n\nHere are some supplied functions that will produce a coordination using a particular scheduler.\n\n* ```identity_immediate()```\n* ```identity_current_thread()```\n* ```identity_same_worker(worker w)```\n* ```serialize_event_loop()```\n* ```serialize_new_thread()```\n* ```serialize_same_worker(worker w)```\n* ```observe_on_event_loop()```\n* ```observe_on_new_thread()```\n\nThere is no thread-pool scheduler yet. A thread-pool scheduler requires taking a dependency on a thread-pool implementation since I do not wish to write a thread-pool. My plan is to make a scheduler for the windows thread-pool and the apple thread-pool and the boost asio executor pool.. One question to answer is whether these platform specific constructs should live in the rxcpp repo or have platform specific repos.\n"
        },
        {
          "name": "Ix",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.052734375,
          "content": "The Reactive Extensions for C++ (__RxCpp__) is a library of algorithms for values-distributed-in-time. The [__Range-v3__](https://github.com/ericniebler/range-v3) library does the same for values-distributed-in-space.\n\nTask    | Status | \n----------- | :------------ |\nrxcpp CI | [![rxcpp CI](https://img.shields.io/github/workflow/status/ReactiveX/RxCpp/rxcpp%20CI/main.svg?event=push&style=flat-square)](https://github.com/ReactiveX/RxCpp/actions/workflows/rxcpp-ci.yml)\n\nSource        | Badges |\n------------- | :--------------- |\nGithub | [![GitHub license](https://img.shields.io/github/license/ReactiveX/RxCpp.svg?style=flat-square)](https://github.com/ReactiveX/RxCpp) <br/> [![GitHub release](https://img.shields.io/github/release/ReactiveX/RxCpp.svg?style=flat-square)](https://github.com/ReactiveX/RxCpp/releases) <br/> [![GitHub commits](https://img.shields.io/github/commits-since/ReactiveX/RxCpp/4.1.0.svg?style=flat-square)](https://github.com/ReactiveX/RxCpp)\nGitter.im | [![Join in on gitter.im](https://img.shields.io/gitter/room/Reactive-Extensions/RxCpp.svg?style=flat-square)](https://gitter.im/ReactiveX/RxCpp?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\nPackages | [![NuGet version](http://img.shields.io/nuget/v/RxCpp.svg?style=flat-square)](http://www.nuget.org/packages/RxCpp/) [![vcpkg port](https://img.shields.io/badge/vcpkg-port-blue.svg?style=flat-square)](https://github.com/Microsoft/vcpkg/tree/master/ports/rxcpp)\nDocumentation | [![rxcpp doxygen documentation](https://img.shields.io/badge/rxcpp-latest-brightgreen.svg?style=flat-square)](http://reactivex.github.io/RxCpp) <br/> [![reactivex intro](https://img.shields.io/badge/reactivex.io-intro-brightgreen.svg?style=flat-square)](http://reactivex.io/intro.html) [![rx marble diagrams](https://img.shields.io/badge/rxmarbles-diagrams-brightgreen.svg?style=flat-square)](http://rxmarbles.com/)\n\n# Usage\n\n__RxCpp__ is a header-only C++ library that only depends on the standard library. The CMake build generates documentation and unit tests. The unit tests depend on a git submodule for the [Catch](https://github.com/philsquared/Catch) library.\n\n# Example\nAdd `Rx/v2/src` to the include paths\n\n[![lines from bytes](https://img.shields.io/badge/blog%20post-lines%20from%20bytes-blue.svg?style=flat-square)](http://kirkshoop.github.io/async/rxcpp/c++/2015/07/07/rxcpp_-_parsing_bytes_to_lines_of_text.html)\n\n```cpp\n#include \"rxcpp/rx.hpp\"\nnamespace Rx {\nusing namespace rxcpp;\nusing namespace rxcpp::sources;\nusing namespace rxcpp::operators;\nusing namespace rxcpp::util;\n}\nusing namespace Rx;\n\n#include <regex>\n#include <random>\nusing namespace std;\nusing namespace std::chrono;\n\nint main()\n{\n    random_device rd;   // non-deterministic generator\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist(4, 18);\n\n    // for testing purposes, produce byte stream that from lines of text\n    auto bytes = range(0, 10) |\n        flat_map([&](int i){\n            auto body = from((uint8_t)('A' + i)) |\n                repeat(dist(gen)) |\n                as_dynamic();\n            auto delim = from((uint8_t)'\\r');\n            return from(body, delim) | concat();\n        }) |\n        window(17) |\n        flat_map([](observable<uint8_t> w){\n            return w |\n                reduce(\n                    vector<uint8_t>(),\n                    [](vector<uint8_t> v, uint8_t b){\n                        v.push_back(b);\n                        return v;\n                    }) |\n                as_dynamic();\n        }) |\n        tap([](const vector<uint8_t>& v){\n            // print input packet of bytes\n            copy(v.begin(), v.end(), ostream_iterator<long>(cout, \" \"));\n            cout << endl;\n        });\n\n    //\n    // recover lines of text from byte stream\n    //\n    \n    auto removespaces = [](string s){\n        s.erase(remove_if(s.begin(), s.end(), ::isspace), s.end());\n        return s;\n    };\n\n    // create strings split on \\r\n    auto strings = bytes |\n        concat_map([](vector<uint8_t> v){\n            string s(v.begin(), v.end());\n            regex delim(R\"/(\\r)/\");\n            cregex_token_iterator cursor(&s[0], &s[0] + s.size(), delim, {-1, 0});\n            cregex_token_iterator end;\n            vector<string> splits(cursor, end);\n            return iterate(move(splits));\n        }) |\n        filter([](const string& s){\n            return !s.empty();\n        }) |\n        publish() |\n        ref_count();\n\n    // filter to last string in each line\n    auto closes = strings |\n        filter(\n            [](const string& s){\n                return s.back() == '\\r';\n            }) |\n        Rx::map([](const string&){return 0;});\n\n    // group strings by line\n    auto linewindows = strings |\n        window_toggle(closes | start_with(0), [=](int){return closes;});\n\n    // reduce the strings for a line into one string\n    auto lines = linewindows |\n        flat_map([&](observable<string> w) {\n            return w | start_with<string>(\"\") | sum() | Rx::map(removespaces);\n        });\n\n    // print result\n    lines |\n        subscribe<string>(println(cout));\n\n    return 0;\n}\n```\n\n# Reactive Extensions\n\n>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays. It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.\n\nCredit [ReactiveX.io](http://reactivex.io/intro.html)\n\n### Other language implementations\n\n* Java: [RxJava](https://github.com/ReactiveX/RxJava)\n* JavaScript: [rxjs](https://github.com/ReactiveX/rxjs)\n* C#: [Rx.NET](https://github.com/Reactive-Extensions/Rx.NET)\n* [More..](http://reactivex.io/languages.html)\n\n### Resources\n\n* [Intro](http://reactivex.io/intro.html)\n* [Tutorials](http://reactivex.io/tutorials.html)\n* [Marble Diagrams](http://rxmarbles.com/)\n* [twitter stream analysis app](https://github.com/kirkshoop/twitter)\n  * [![baldwin pass to wilson](https://img.youtube.com/vi/QkvCzShHyVU/0.jpg)](https://www.youtube.com/watch?v=QkvCzShHyVU)\n* _Algorithm Design For Values Distributed In Time_\n  * [![C++ Russia 2016](https://img.youtube.com/vi/Re6DS5Ff0uE/0.jpg)](https://www.youtube.com/watch?v=Re6DS5Ff0uE)\n  * [![CppCon 2016](https://img.youtube.com/vi/FcQURwM806o/0.jpg)](https://www.youtube.com/watch?v=FcQURwM806o)\n\n# Cloning RxCpp\n\nRxCpp uses a git submodule (in `ext/catch`) for the excellent [Catch](https://github.com/philsquared/Catch) library. The easiest way to ensure that the submodules are included in the clone is to add `--recursive` in the clone command.\n\n```shell\ngit clone --recursive https://github.com/ReactiveX/RxCpp.git\ncd RxCpp\n```\n\n# Installing\n\nTo install RxCpp into your OS you need to follow standart procedure:\n```shell\nmkdir build\ncd build\ncmake ..\nmake install \n```\n\nIf you're using the vcpkg dependency manager, you can install RxCpp using a single one-line command:\n\n```\nvcpkg install rxcpp\n```\n\nVcpkg will acquire RxCpp, build it from source in your computer, and provide CMake integration support for your projects.\n\nSee the [vcpkg repository](https://github.com/Microsoft/vcpkg) for more information.\n\n# Importing\n\nAfter you have successfully installed RxCpp you can import it into any project by simply adding to your CMakeLists.txt:\n```cmake\nfind_package(rxcpp CONFIG)\n``` \n\n# Building RxCpp Unit Tests\n\n* RxCpp is regularly tested on OSX and Windows.\n* RxCpp is regularly built with Clang, Gcc and VC\n* RxCpp depends on the latest compiler releases.\n\nRxCpp uses CMake to create build files for several platforms and IDE's\n\n### ide builds\n\n#### XCode\n```shell\nmkdir projects/build\ncd projects/build\ncmake -G\"Xcode\" -DRXCPP_DISABLE_TESTS_AND_EXAMPLES=0 ../CMake -B.\n```\n\n#### Visual Studio 2017\n```batch\nmkdir projects\\build\ncd projects\\build\ncmake -G \"Visual Studio 15\" -DRXCPP_DISABLE_TESTS_AND_EXAMPLES=0 ..\\CMake\\\nmsbuild Project.sln\n```\n\n### makefile builds\n\n#### OSX\n```shell\nmkdir projects/build\ncd projects/build\ncmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=RelWithDebInfo -DRXCPP_DISABLE_TESTS_AND_EXAMPLES=0 -B. ../CMake\nmake\n```\n\n#### Linux --- Clang\n```shell\nmkdir projects/build\ncd projects/build\ncmake -G\"Unix Makefiles\" -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_EXE_LINKER_FLAGS=\"-stdlib=libc++\" -DRXCPP_DISABLE_TESTS_AND_EXAMPLES=0 -B. ../CMake\nmake\n```\n\n#### Linux --- GCC\n```shell\nmkdir projects/build\ncd projects/build\ncmake -G\"Unix Makefiles\" -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_BUILD_TYPE=RelWithDebInfo -DRXCPP_DISABLE_TESTS_AND_EXAMPLES=0 -B. ../CMake\nmake\n```\n\n#### Windows\n```batch\nmkdir projects\\build\ncd projects\\build\ncmake -G\"NMake Makefiles\" -DCMAKE_BUILD_TYPE=RelWithDebInfo -DRXCPP_DISABLE_TESTS_AND_EXAMPLES=0 -B. ..\\CMake\nnmake\n```\n\nThe build only produces test and example binaries.\n\n# Running tests\n\n* You can use the CMake test runner `ctest`\n* You can run the test binaries directly `rxcpp_test_*`\n* Tests can be selected by name or tag\nExample of by-tag\n\n`rxcpp_test_subscription [perf]`\n\n# Documentation\n\nRxCpp uses Doxygen to generate project [documentation](http://reactivex.github.io/RxCpp).\n\nWhen Doxygen+Graphviz is installed, CMake creates a special build task named `doc`. It creates actual documentation and puts it to `projects/doxygen/html/` folder, which can be published to the `gh-pages` branch. Each merged pull request will build the docs and publish them.\n\n[Developers Material](DeveloperManual.md)\n\n# Contributing Code\n\nBefore submitting a feature or substantial code contribution please  discuss it with the team and ensure it follows the product roadmap. Note that all code submissions will be rigorously reviewed and tested by the Rx Team, and only those that meet an extremely high bar for both quality and design/roadmap appropriateness will be merged into the source.\n\n# Microsoft Open Source Code of Conduct\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments. \n"
        },
        {
          "name": "Readme.html",
          "type": "blob",
          "size": 30.8349609375,
          "content": "<h1>Reactive Extensions</h1>\n\n<p>Reactive Extensions (Rx) is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators.</p>\n<p>Data sequences can take many forms, such as a stream of data from a file or web service, web services requests, system notifications, or a series of events such as user input. </p>\n<p>Reactive Extensions represents all these data sequences as observable sequences. An application can subscribe to these observable sequences to receive asynchronous notifications as new data arrives. The Rx library is available for application development in C++, .NET, Ruby, Python, Silverlight, Windows Phone 7 and JavaScript. For more information on these different platforms, see Differences Between Versions of Rx topic.</p>\n\n<h2>Pulling vs. Pushing Data</h2>\n<p>In interactive programming, the application actively polls a data source for more information by pulling data from a sequence that represents the source. The iterator allows us to get the current item by returning the current property, and determines whether there are more items to iterate (by calling some on_next method). </p>\n<p>The application is active in the data retrieval process, controlling the pace of the retrieval by calling on_next at its own convenience. This pattern is synchronous, which means that the application might be blocked while polling the data source. Such pulling pattern is similar to visiting your library and checking out a book. After you are done with the book, you pay another visit to check out another one.</p>\n<p>On the other hand, in reactive programming, the application is offered more information by subscribing to a data stream (called observable sequence in Rx), and any update is handed to it from the source. The application is passive in the data retrieval process: apart from subscribing to the observable source, it does not actively poll the source, but merely reacts to the data being pushed to it. When the stream has no more data to offer, or when it errs, the source will send a notice to the subscriber. In this way, the application will not be blocked by waiting for the source to update. </p>\n<p>This is the push pattern employed by Reactive Extensions. It is similar to joining a book club in which you register your interest in a particular genre, and books that match your interest are automatically sent to you as they are published. You do not need to stand in line to acquire something that you want. Employing a push pattern is helpful in many scenarios, especially in a UI-heavy environment in which the UI thread cannot be blocked while the application is waiting for some events. In summary, by using Rx, you can make your application more responsive.</p>\n<p>The push model implemented by Rx is represented by the observable pattern of Rx.Observable/Observer. The Rx.Observable will notify all the observers automatically of any state changes. To register an interest through a subscription, you use the subscribe method of Rx.Observable, which takes on an Observer and returns a disposable. This gives you the ability to track and dispose of the subscription. In addition, Rx’s LINQ implementation over observable sequences allows developers to compose complex event processing queries over push-based sequences such as events, APM-based (“AsyncResult”) computations, Task-based computations, and asynchronous workflows. For more information on the Observable/Observer classes, see Exploring The Major Classes in Rx. For tutorials on using the different features in Rx, see Using Rx.</p>\n\n<h1>Getting Started with Rx</h1>\n<p>This section describes in general what Reactive Extensions (Rx) is, and how it can benefit programmers who are creating asynchronous applications.</p>\n\n<h3>In This Section</h3>\n<p>1.\tWhen Will You Use Rx<br />\n2.\tInstalling Rx<br />\n3.\tDifferences Between Versions of Rx</p>\n\n<h3>Related Sections</h3>\n<p>Using Rx<br />\nReactive Extensions on MSDN Developer Center</p>\n\n<h1>When Will You Use Rx</h1>\n<p>This topic describes the advantage of using Rx for users who are currently using the .NET event model for asynchronous programming.</p>\n\n<h2>Advantages of using Rx</h2>\n<p>Whether you are authoring a traditional desktop or web-based application, you have to deal with asynchronous programming from time to time. Desktop applications have I/O or UI threads that might take a long time to complete and potentially block all other active threads. However, a user of the modern asynchronous programming model has to manage exceptions and cancellation of events manually. To compose or filter events, he has to write custom code that is hard to decipher and maintain.</p>\n<p>In addition, if your application interacts with multiple sources of data, the conventional way to manage all of these interactions is to implement separate methods as event handlers for each of these data streams. For example, as soon as a user types a character, a keydown event is pushed to your keydown event handler method. Inside this keydown event handler, you have to provide code to react to this event, or to coordinate between all of the different data streams and process this data into a useable form.</p>\n<p>Using Rx, you can represent multiple asynchronous data streams (that come from diverse sources, e.g., stock quote, tweets, computer events, web service requests, etc.), and subscribe to the event stream using the Observer class. The Observable class maintains a list of dependent Observer threads and notifies them automatically of any state changes. You can query observable sequences using standard LINQ query operators implemented by the Rx.Observable type. Thus you can filter, aggregate, and compose on multiple events easily by using these LINQ operators. Cancellation and exceptions can also be handled gracefully by using extension methods provided by Rx.</p>\n<p>The following example shows how easy it is to implement an observable in C++.</p>\n<pre><code>\n    auto ints = rxcpp::observable&lt;>::create<int>(\n        [](rxcpp::subscriber&lt;int> s){\n            s.on_next(1);\n            s.on_next(2);\n            s.on_completed();\n    });\n\n    ints.\n        subscribe(\n            [](int v){printf(\"OnNext: %d\\n\", v);},\n            [](){printf(\"OnCompleted\\n\");});\n</code></pre>\n<p>You can also use schedulers to control when the subscription starts, and when notifications are pushed to subscribers. For more information on this, see Using Schedulers for Concurrency Control.</p>\n\n<h2>Filtering</h2>\n<p>One drawback of the C++ event model is that your event handler is always called every time an event is raised, and events arrive exactly as they were sent out by the source. To filter out events that you are not interested in, or transform data before your handler is called, you have to add custom filter logic to your handler.</p>\n<p>Take an application that detects mouse-down as an example. In the current event programming model, the application can react to the event raised by displaying a message. In Rx, such mouse-down events are treated as a stream of information about clicks. Whenever you click the mouse, information (e.g., cursor position) about this click appears in a stream, ready to be processed. In this paradigm, events (or event streams) are very similar to lists or other collections. This means that we can use techniques for working with collections to process events.  For example, you can filter out those clicks that appear outside a specific area, and only display a message when the user clicks inside an area. Or you can wait a specific period of time, and inform the user the number of “valid” clicks during this period. Similarly, you can capture a stream of stock ticks and only respond to those ticks that have changed for a specific range during a particular time window. All these can be done easily by using LINQ-query style operators provided by Rx. </p>\n<p>In this way, a function can take an event, process it, and then pass out the processed stream to an application. This gives you flexibility that is not available in the current programming model. Moreover, as Rx is performing all the plumbing work at the background for filtering, synchronizing, and transforming the data, your handler can just react to the data it receives and do something with it. This results in cleaner code that is easier to read and maintain. For more information on filtering, see Querying Observable Collections using LINQ Operators.</p>\n\n<h2>Manipulating Events</h2>\n<p>Rx represents events as a collection of objects: e.g., a OnMouseMove event contains a collection of Point values. Due to the first-class object nature of observables, they can be passed around as function parameters and returns, or stored in a variable.</p>\n\n<h1>Installing Rx</h1>\n<p>This topic describes where you can download the Reactive Extensions (Rx) SDK.</p>\n\n<h2>To download Rx</h2>\n<p>Reactive Extensions is available for different platforms such as C++, Javascript, .NET Framework 3.5, 4.0, 4.5, Silverlight 3 and 4, as well as Windows Phone 7 & 8. You can download the libraries, as well as learn about their prerequisites at the <a href=\"http://msdn.microsoft.com/en-us/data/gg577609\" target=\"_blank\">Rx MSDN Developer Center.</a></p>\n\n<h1>Differences Between Versions of Rx</h1>\n<p>The following topic describes the various platforms for which you can develop solutions using Reactive Extensions.</p>\n<p>To get the latest release of Rx, as well as learn about its prerequisites, please visit the <a href=\"http://msdn.microsoft.com/en-us/data/gg577609\" target=\"_blank\">Rx MSDN Developer Center</a>. </p>\n\n<h2>C++</h2>\n<p>The Reactive Extensions for C++ (RxCpp) is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators in C++.</p>\n\n<h2>Javascript</h2>\n<p>Rx for Javascript (RxJS) allows you to use LINQ operators in JavaScript. It provides easy-to-use conversions from existing DOM, XmlHttpRequest (AJAX), and jQuery events to push-based observable collections, allowing users to seamlessly integrate Rx into their existing JavaScript-based websites. </p>\n<p>RxJS brings similar capabilities to client script and integrates with jQuery events (Rx.Observable.FromJQueryEvent). It also supports Script#.</p>\n\n<h2>Ruby</h2>\n<p>Rx for Ruby (Rx.rb) allows you to use Linq operators to create push-based observable collections in Ruby.</p>\n\n<h2>Python</h2>\n<p>RX for Python (Rx.py) allows you to use Linq operators in Python. Rx.py allows you to implement push-based observable collections, allowing users to seamlessly integrate Rx into their existing Python applications.</p>\n\n<h2>.NET Framework</h2>\n<p>The core Rx interfaces, IObservable<T> and IObserver<T>, ship as part of .NET Framework 4. If you are running on .NET Framework 3.5 SP1, or if you want to take advantage of the LINQ operators implemented in Observable type, as well as many other features such as schedulers, you can download the Rx header-only library in the <a href=\"http://msdn.microsoft.com/en-us/data/gg577609\" target=\"_blank\">Rx MSDN Developer Center</a>.</p>\n\n<h2>Silverlight </h2>\n<p>Silverlight disallows you from making cross-threading calls, thus you cannot use a background thread to update the UI. Instead of writing verbose code using the Dispatcher.BeginInvoke call to explicitly execute code on the main UI thread, you can use the factory Observable.Start method provided by the Rx header-only library to invoke an action asynchronously. Cross-threading is taken care of transparently by Rx under the hood.</p>\n<p>You can also use the various Observable operator overloads that take in a Scheduler, and specify the System.Reactive.Concurrency.DispatcherScheduler to be used.</p>\n\n<h2>Windows Phone</h2>\n<p>Windows Phone 7 ships with a version of the Reactive Extensions baked into the ROM of the device. For more information, see <a href=\"http://msdn.microsoft.com/en-us/library/ff431792(VS.92).aspx\">Reactive Extensions for .NET Overview for Windows Phone</a>. Documentation for this version of the Reactive Extensions can be found in Windows Phone API library at <a href=\"http://msdn.microsoft.com/en-us/library/ff707857(v=VS.92).aspx\">Microsoft.Phone.Reactive Namespace</a>. </p>\n<p>The <a href=\"http://msdn.microsoft.com/en-us/data/gg577609\" target=\"_blank\">Rx MSDN Developer Center</a> also contains an updated version of Rx for WP7, which has new definitions in the System.Reactive.Linq namespace. Note that the new APIs will not clash with the library built in to the phone (nor do they replace the version in the ROM). For more information on the differences of these 2 versions, see this <a href=\"http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-for-windows-phone-7.aspx\">Rx team blog post</a>.</p>\n<p>Rx is available for Windows Phone 8 as well as Windows Phone 7. A .NET portable library is available using Nuget that is useful for developing libraries that work on Windows Phone, Windows Store apps, and in classic Windows desktop or server applications.</p>\n\n<h1>Using Rx</h1>\n<p>This section includes topics that explain how you use Rx to create and subscribe to sequences, bridge existing events and existing asynchronous patterns, as well as using schedulers. It also describes more advanced tasks such as implementing your own operators.</p>\n\n<h3>In This Section</h3>\n<p>1.\tExploring The Major Interfaces in Rx<br />\n2.\tCreating and Querying Event Streams<br />\n3.\tSubjects<br />\n6.\tImplementing your own operators for IObservable<br />\n7.\tUsing Observable Providers</p>\n\n<h1>Exploring The Major Interfaces in Rx</h1>\n<p>This topic describes the major Reactive Extensions (Rx) interfaces used to represent observable sequences and subscribe to them. </p>\n\n<h2>Observable/Observer</h2>\n<p>Rx exposes asynchronous and event-based data sources as push-based, observable sequences. This Observable class represents a data source that can be observed, meaning that it can send data to anyone who is interested. It maintains a list of dependent Observer implementations representing such interested listeners, and notifies them automatically of any state changes.</p>\n<p>As described in What is Rx, the other half of the push model is represented by the Observer class, which represents an observer who registers an interest through a subscription. Items are subsequently handed to the observer from the observable sequence to which it subscribes. </p>\n<p>In order to receive notifications from an observable collection, you use the subscribe method of Observable to hand it an Observer object. In return for this observer, the subscribe method returns a disposable object that acts as a handle for the subscription. This allows you to clean up the subscription after you are done. Calling dispose on this object detaches the observer from the source so that notifications are no longer delivered. As you can infer, in Rx you do not need to explicitly unsubscribe from an event. </p>\n<p>Observers support three publication events, reflected by the interface’s methods. OnNext can be called zero or more times, when the observable data source has data available. For example, an observable data source used for mouse move events can send out a Point object every time the mouse has moved. The other two methods are used to indicate completion or errors.</p>\n<p>The following lists the Observable/Observer definitions.</p>\n<pre><code>\nnamespace rxcpp {\n    template &lt;class T>\n    struct subscriber\n    {\n        // observer&lt;T>\n        void on_next(T);\n        void on_error(std::exception_ptr);\n        void on_completed();\n\n        // composite_subscription\n        bool is_subscribed();\n        void unsubscribe();\n    };\n\n    template &lt;class T>\n    struct observable\n    {\n        composite_subscription subscribe(subscriber&lt;T> out);\n    };\n}\n</code></pre>\n<p>Note that the OnError event returns an exception_ptr type. The example above shows passing the error to a handler function.</p>\n<p>You can treat the observable sequence (such as a sequence of mouse-over events) as if it were a normal collection. Thus you can write LINQ queries over the collection to do things like filtering, grouping, composing, etc. To make observable sequences more useful, the Rx header-only library provides many factory LINQ operators so that you do not need to implement any of these on your own. This will be covered in the Querying Observable Collections using LINQ Operators topic.</p>\n\n<h3>See Also</h3>\nCreating and Subscribing to Simple Observable Sequences\nQuerying Observable Collections using LINQ Operators\n\n<h1>Creating and Querying Observable Sequences</h1>\n<p>This section describes how you can create and subscribe to an observable sequence, convert an existing C++ event into a sequence and query it. </p>\n\n<h3>In This Section</h3>\n<p>Creating and Subscribing to Simple Observable Sequences<br />\nQuerying Observable Collections using LINQ Operators</p>\n\n<h1>Creating and Subscribing to Simple Observable Sequences</h1>\n<p>You do not need to implement the Observable interface manually to create an observable sequences. Similarly, you do not need to implement Observer either to subscribe to a sequence. By installing the Reactive Extension header-only library, you can take advantage of the Observable type which provides many LINQ operators for you to create a simple sequence with zero, one or more elements. In addition, Rx provides Subscribe methods that take various combinations of OnNext, OnError and OnCompleted handlers in terms of delegates.</p>\n\n<h2>Creating and subscribing to a simple sequence</h2>\n<p>The following sample uses the range operator of the Observable type to create a simple observable collection of numbers. The observer subscribes to this collection using the Subscribe method of the Observable class, and provides actions that are delegates which handle OnNext, OnCompleted and OnError. </p>\n<p>The range operator has several overloads. In our example, it creates a sequence of integers that starts with x and produces y sequential numbers afterwards.  </p>\n<p>As soon as the subscription happens, the values are sent to the observer. The OnNext delegate then prints out the values.</p>\n<pre><code>\n    auto values1 = rxcpp::observable&lt;>::range(1, 5);\n    values1.\n        subscribe(\n            [](int v){printf(\"OnNext: %d\\n\", v);},\n            [](){printf(\"OnCompleted\\n\");});\n</code></pre>\n<p>When an observer subscribes to an observable sequence, the thread calling the subscribe method can be different from the thread in which the sequence runs till completion. Therefore, the subscribe call is asynchronous in that the caller is not blocked until the observation of the sequence completes. This will be covered in more details in the Using Schedulers topic.</p>\n<p>Notice that the subscribe method returns a Disposable, so that you can unsubscribe to a sequence and dispose of it easily. When you invoke the Dispose method on the observable sequence, the observer will stop listening to the observable for data. Normally, you do not need to explicitly call Dispose unless you need to unsubscribe early, or when the source observable sequence has a longer life span than the observer. Subscriptions in Rx are designed for fire-and-forget scenarios without the usage of a finalizer. When the Disposable instance is collected by the garbage collector, Rx does not automatically dispose of the subscription. However, note that the default behavior of the Observable operators is to dispose of the subscription as soon as possible (i.e, when an OnCompleted or OnError messages is published). </p>\n<p>In addition to creating an observable sequence from scratch, you can convert existing enumerators, C++ events and asynchronous patterns into observable sequences. The other topics in this section will show you how to do this. </p>\n<p>Notice that this topic only shows you a few operators that can create an observable sequence from scratch. To learn more about other LINQ operators, see Query Observable Collections using LINQ Operators.</p>\n\n<h2>Converting an Enumerable Collection to an Observable Sequence</h2>\n<p>Using the Iterate operator, you can convert an array colection to an observable sequence and subscribe to it. </p>\n<pre><code>\n    std::array&lt; int, 3 > a={{1, 2, 3}};\n    auto values1 = rxcpp::observable&lt;>::iterate(a);\n    values1.\n        subscribe(\n            [](int v){printf(\"OnNext: %d\\n\", v);},\n            [](){printf(\"OnCompleted\\n\");});\n</code></pre>\n\n<h3>See Also</h3>\nQuery Observable Collections using LINQ Operators\n\n<h1>Querying Observable Sequences using LINQ Operators</h1>\n<p>We have converted existing C++ events into observable sequences to subscribe to them. In this topic, we will look at the first-class nature of observable sequences as Observable objects, in which generic LINQ operators are supplied by the Rx header-only library to manipulate these objects. Most operators take an observable sequence and perform some logic on it and output another observable sequence. In addition, as you can see from our code samples, you can even chain multiple operators on a source sequence to tweak the resulting sequence to your exact requirement. </p>\n\n<h2>Using Different Operators</h2>\n<p>We have already used the Create and Generate operators in previous topics to create and return simple sequences. In this topic, we will use other LINQ operators of the Observable type so that you can filter, group and transform data. Such operators take observable sequence(s) as input, and produce observable sequence(s) as output.</p>\n\n<h2>Combining different sequences</h2>\n<p>In this section, we will examine some of the operators that combine various observable sequences into a single observable sequence. Notice that data are not transformed when we combine sequences. </p>\n<p>In the following sample, we use the concat operator to combine two sequences into a single sequence and subscribe to it. </p>\n<pre><code>\n    auto values = rxcpp::observable&lt;>::range(1); // infinite (until overflow) stream of integers\n\n    auto s1 = values.\n        take(3).\n        map([](int prime) { return std::make_tuple(\"1:\", prime);});\n\n    auto s2 = values.\n        take(3).\n        map([](int prime) { return std::make_tuple(\"2:\", prime);});\n\n    s1.\n        concat(s2).\n        subscribe(rxcpp::util::apply_to(\n            [](const char* s, int p) {\n                printf(\"%s %d\\n\", s, p);\n            }));\n</code></pre>\n<p>Notice that the resultant sequence is </p>\n<pre>\n1: 1\n1: 2\n1: 3\n2: 1\n2: 2\n2: 3\n</pre>\n<p>This is because when you use the concat operator, the 2nd sequence (source2) will not be active until after the 1st sequence (source1) has finished pushing all its values. It is only after source1 has completed, then source2 will start to push values to the resultant sequence. The subscriber will then get all the values from the resultant sequence. </p>\n<p>Compare this with the merge operator. If you run the following sample code, you will get </p>\n<pre>\n1: 1\n2: 1\n1: 2\n2: 2\n1: 3\n2: 3\n</pre>\n<p>This is because the two sequences are active at the same time and values are pushed out as they occur in the sources. The resultant sequence only completes when the last source sequence has finished pushing values. </p>\n<p>Notice that for Merge to work, all the source observable sequences need to be of the same type of Observable. The resultant sequence will be of the type Observable. If source1 produces an OnError in the middle of the sequence, then the resultant sequence will complete immediately.</p>\n<pre><code>\n    auto values = rxcpp::observable&lt;>::range(1); // infinite (until overflow) stream of integers\n\n    auto s1 = values.\n        map([](int prime) { return std::make_tuple(\"1:\", prime);});\n\n    auto s2 = values.\n        map([](int prime) { return std::make_tuple(\"2:\", prime);});\n\n    s1.\n        merge(s2).\n        take(6).\n        as_blocking().\n        subscribe(rxcpp::util::apply_to(\n            [](const char* s, int p) {\n                printf(\"%s %d\\n\", s, p);\n            }));\n</code></pre>\n\n<h1>Subjects</h1>\n<p>This section describes the Subject type implemented by Reactive Extensions. It also describes various implementations of Subject which serves different purposes. </p>\n<h3>In This Section</h3>\n<p>1.\tUsing Subjects</p>\n\n<h1>Using Subjects</h1>\n<p>The Subject type implements both Observable and Observer, in the sense that it is both an observer and an observable. You can use a subject to subscribe all the observers, and then subscribe the subject to a backend data source. In this way, the subject can act as a proxy for a group of subscribers and a source. You can use subjects to implement a custom observable with caching, buffering and time shifting. In addition, you can use subjects to broadcast data to multiple subscribers. </p>\n<p>By default, subjects do not perform any synchronization across threads. They do not take a scheduler but rather assume that all serialization and grammatical correctness are handled by the caller of the subject.  A subject simply broadcasts to all subscribed observers in the thread-safe list of subscribers. Doing so has the advantage of reducing overhead and improving performance. If, however, you want to synchronize outgoing calls to observers using a scheduler, you can use the Synchronize method to do so.</p>\n\n<h2>Different types of Subjects</h2>\n<p>The Subject type in the Rx library is a basic implementation of the Subject interface (you can also implement the Subject interface to create your own subject types). There are other implementations of Subject that offer different functionalities. All of these types store some (or all of) values pushed to them via OnNext, and broadcast it back to its observers. This means that if you subscribe to any of these more than once (i.e. subscribe -> unsubscribe -> subscribe again), you will see at least one of the same value again. </p>\n\n<h1>Scheduling and Concurrency</h1>\n<p>This section describes how you can use a scheduler to control when to start a sequence or subscribe to an event. </p>\n\n<h1>Scheduler Types</h1>\n<p>The various Scheduler types provided by Rx are:</p>\n<p>ImmediateScheduler: Default scheduler, pushes notifications as they are recieved.</p>\n<p>EventLoopScheduler: Used when creating a separate thread for Rx sequences.</p>\n\n<h1>Using Schedulers</h1>\n<p>A scheduler controls when a subscription starts and when notifications are published. It consists of three components. It is first a data structure. When you schedule for tasks to be completed, they are put into the scheduler for queueing based on priority or other criteria. It also offers an execution context which denotes where the task is executed (e.g., in the thread pool, current thread, or in another app domain). Lastly, it has a clock which provides a notion of time for itself (by accessing the Now property of a scheduler). Tasks being scheduled on a particular scheduler will adhere to the time denoted by that clock only.</p>\n\n<h2>Using Schedulers</h2>\n<p>You may have already used schedulers in your Rx code without explicitly stating the type of schedulers to be used. This is because all Observable operators that deal with concurrency have multiple overloads. If you do not use the overload which takes a scheduler as an argument, Rx will pick a default scheduler by using the principle of least concurrency. This means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen.  For example, for operators returning an observable with a finite and small number of messages, Rx calls ImmediateScheduler.  For operators returning a potentially large or infinite number of messages, CurrentThread is called.</p>\n<p>In the following example, the source observable sequences are each running in their own threads using EventLoopScheduler.</p>\n<pre><code>\n    auto threads = rxcpp::observe_on_event_loop();\n\n    auto values = rxcpp::observable&lt;>::range(1); // infinite (until overflow) stream of integers\n\n    auto s1 = values.\n        subscribe_on(threads).\n        map([](int prime) { std::this_thread::yield(); return std::make_tuple(\"1:\", prime);});\n\n    auto s2 = values.\n        subscribe_on(threads).\n        map([](int prime) { std::this_thread::yield(); return std::make_tuple(\"2:\", prime);});\n\n    s1.\n        merge(s2).\n        take(6).\n        observe_on(threads).\n        as_blocking().\n        subscribe(rxcpp::util::apply_to(\n            [](const char* s, int p) {\n                printf(\"%s %d\\n\", s, p);\n            }));\n</code></pre>\n<p>This will queue up on the observer quickly. This code by uses the observe_on operator, which allows you to specify the context that you want to use to send pushed notifications (OnNext) to observers. By default, the observe_on operator ensures that OnNext will be called as many times as possible on the current thread. You can use its overloads and redirect the OnNext outputs to a different context. In addition, you can use the subscribe_on operator to return a proxy observable that delegates actions to a specific scheduler. For example, for a UI-intensive application, you can delegate all background operations to be performed on a scheduler running in the background by using subscribe_on and passing to it a Concurrency.EventLoopScheduler. </p>\n<p>You should also note that by using the observe_on operator, an action is scheduled for each message that comes through the original observable sequence. This potentially changes timing information as well as puts additional stress on the system. If you have a query that composes various observable sequences running on many different execution contexts, and you are doing filtering in the query, it is best to place observe_on later in the query. This is because a query will potentially filter out a lot of messages, and placing the observe_on operator earlier in the query would do extra work on messages that would be filtered out anyway. Calling the observe_on operator at the end of the query will create the least performance impact.</p>\n\n<h1>Implementing Your Own Operators for Observable</h1>\n<p>You can extend Rx by adding new operators for operations that are not provided by the LINQ library, or by creating your own implementation of standard query operators to improve readability and performance. Writing a customized version of a standard LINQ operator is useful when you want to operate with in-memory objects and when the intended customization does not require a comprehensive view of the query.</p>\n\n<h2>Creating New Operators</h2>\n<p>LINQ offers a full set of operators that cover most of the possible operations on a set of entities. However, you might need an operator to add a particular semantic meaning to your query—especially if you can reuse that same operator several times in your code. </p>\n<p>By reusing existing LINQ operators when you build a new one, you can take advantage of the existing performance or exception handling capabilities implemented in the Rx libraries.</p>\n<p>When writing a custom operator, it is good practice not to leave any disposables unused; otherwise, you may find that resources could actually be leaked and cancellation may not work correctly.</p>\n\n<h2>Customizing Existing Operators</h2>\n<p>Adding new operators to LINQ is a way to extend its capabilities. However, you can also improve code readability by wrapping existing operators into more specialized and meaningful ones.</p>\n"
        },
        {
          "name": "Rx",
          "type": "tree",
          "content": null
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 1.0439453125,
          "content": "version: 2.2.{build}\n\nbranches:\n# whitelist\n    only:\n        - main\n        - appveyor\n\nimage: Visual Studio 2017\n\nenvironment:\n  matrix:\n  - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015\n    VSVER: Visual Studio 14 2015 Win64\n  - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n    VSVER: Visual Studio 15 2017 Win64\n\nplatform:\n  - x64\n\nconfiguration:\n  - Release\n\ninstall:\n    - cmake --version\n    - git submodule -q update --init\n\nbefore_build:\n    - cmake -G\"%VSVER%\" .\n\nbuild:\n    project: build\\rxcpp.sln\n\ntest_script:\n  - cd build\\test\\\n  - ctest -V -C Release\n  - cd ..\\..\n\nartifacts:\n  - path: Rx\\v2\\src\\\n    name: rxcpp source\n    type: zip\n  - path: Rx\\v2\\examples\\\n    name: rxcpp examples\n    type: zip\n\nnotifications:\n  - provider: Webhook\n    url: https://webhooks.gitter.im/e/4c53c094183ccaa8d059\n    method: POST\n    on_build_success: true\n    on_build_failure: true\n    on_build_status_changed: false\n  - provider: Email\n    to:\n      - kirk.shoop@gmail.com\n    on_build_success: true\n    on_build_failure: true\n    on_build_status_changed: false\n"
        },
        {
          "name": "ext",
          "type": "tree",
          "content": null
        },
        {
          "name": "license.md",
          "type": "blob",
          "size": 11.1171875,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "projects",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}