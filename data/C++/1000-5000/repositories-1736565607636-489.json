{
  "metadata": {
    "timestamp": 1736565607636,
    "page": 489,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "thestinger/termite",
      "stars": 2725,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0234375,
          "content": "*.o\n*.swp\n*.swo\ntermite\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.076171875,
          "content": "[submodule \"util\"]\n\tpath = util\n\turl = https://github.com/thestinger/util.git\n"
        },
        {
          "name": ".ycm_extra_conf.py",
          "type": "blob",
          "size": 2.55859375,
          "content": "import os\nimport ycm_core\nimport subprocess\nfrom clang_helpers import PrepareClangFlags\n\ndatabase = None\n\ndef pkg_config(pkg):\n  def not_whitespace(string):\n    return not (string == '' or string == '\\n')\n  output = subprocess.check_output(['pkg-config', '--cflags', pkg], universal_newlines=True).strip()\n  return filter(not_whitespace, output.split(' '))\n\nflags = [\n  '-Wall',\n  '-Wextra',\n  '-Werror',\n  '-pedantic',\n  '-Winit-self',\n  '-Wshadow',\n  '-Wformat=2',\n  '-Wmissing-declarations',\n  '-Wstrict-overflow=5',\n  '-Wcast-align',\n  '-Wcast-qual',\n  '-Wconversion',\n  '-Wunused-macros',\n  '-Wwrite-strings',\n  '-Wimplicit-fallthrough',\n  '-DNDEBUG',\n  '-DUSE_CLANG_COMPLETER',\n  '-DTERMITE_VERSION=\"ycm\"',\n  '-D_POSIX_C_SOURCE=200809L',\n  '-std=c++11',\n  '-x',\n  'c++'\n]\n\nflags += pkg_config('gtk+-3.0')\nflags += pkg_config('vte-2.91')\n\n\ndef DirectoryOfThisScript():\n  return os.path.dirname( os.path.abspath( __file__ ) )\n\n\ndef MakeRelativePathsInFlagsAbsolute( flags, working_directory ):\n  if not working_directory:\n    return flags\n  new_flags = []\n  make_next_absolute = False\n  path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]\n  for flag in flags:\n    new_flag = flag\n\n    if make_next_absolute:\n      make_next_absolute = False\n      if not flag.startswith( '/' ):\n        new_flag = os.path.join( working_directory, flag )\n\n    for path_flag in path_flags:\n      if flag == path_flag:\n        make_next_absolute = True\n        break\n\n      if flag.startswith( path_flag ):\n        path = flag[ len( path_flag ): ]\n        new_flag = path_flag + os.path.join( working_directory, path )\n        break\n\n    if new_flag:\n      new_flags.append( new_flag )\n  return new_flags\n\n\ndef FlagsForFile( filename ):\n  if database:\n    # Bear in mind that compilation_info.compiler_flags_ does NOT return a\n    # python list, but a \"list-like\" StringVec object\n    compilation_info = database.GetCompilationInfoForFile( filename )\n    final_flags = PrepareClangFlags(\n        MakeRelativePathsInFlagsAbsolute(\n            compilation_info.compiler_flags_,\n            compilation_info.compiler_working_dir_ ),\n        filename )\n\n    # NOTE: This is just for YouCompleteMe; it's highly likely that your project\n    # does NOT need to remove the stdlib flag. DO NOT USE THIS IN YOUR\n    # ycm_extra_conf IF YOU'RE NOT 100% YOU NEED IT.\n    try:\n      final_flags.remove( '-stdlib=libc++' )\n    except ValueError:\n      pass\n  else:\n    relative_to = DirectoryOfThisScript()\n    final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )\n\n  return {\n    'flags': final_flags,\n    'do_cache': True\n  }\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.5,
          "content": "VERSION = $(shell git describe --tags)\nGTK = gtk+-3.0\nVTE = vte-2.91\nPREFIX ?= /usr/local\nBINDIR ?= ${PREFIX}/bin\nDATADIR ?= ${PREFIX}/share\nMANDIR ?= ${DATADIR}/man\nTERMINFO ?= ${DATADIR}/terminfo\n\nCXXFLAGS := -std=c++11 -O3 \\\n\t    -Wall -Wextra -pedantic \\\n\t    -Winit-self \\\n\t    -Wshadow \\\n\t    -Wformat=2 \\\n\t    -Wmissing-declarations \\\n\t    -Wstrict-overflow=5 \\\n\t    -Wcast-align \\\n\t    -Wconversion \\\n\t    -Wunused-macros \\\n\t    -Wwrite-strings \\\n\t    -DNDEBUG \\\n\t    -D_POSIX_C_SOURCE=200809L \\\n\t    -DTERMITE_VERSION=\\\"${VERSION}\\\" \\\n\t    ${shell pkg-config --cflags ${GTK} ${VTE}} \\\n\t    ${CXXFLAGS}\n\nifeq (${CXX}, g++)\n\tCXXFLAGS += -Wno-missing-field-initializers\nendif\n\nifeq (${CXX}, clang++)\n\tCXXFLAGS += -Wimplicit-fallthrough\nendif\n\nLDFLAGS := -s -Wl,--as-needed ${LDFLAGS}\nLDLIBS := ${shell pkg-config --libs ${GTK} ${VTE}}\n\ntermite: termite.cc url_regex.hh util/clamp.hh util/maybe.hh util/memory.hh\n\t${CXX} ${CXXFLAGS} ${LDFLAGS} $< ${LDLIBS} -o $@\n\ninstall: termite termite.desktop termite.terminfo\n\tmkdir -p ${DESTDIR}${TERMINFO}\n\tinstall -Dm755 termite ${DESTDIR}${BINDIR}/termite\n\tinstall -Dm644 config ${DESTDIR}/etc/xdg/termite/config\n\tinstall -Dm644 termite.desktop ${DESTDIR}${DATADIR}/applications/termite.desktop\n\tinstall -Dm644 man/termite.1 ${DESTDIR}${MANDIR}/man1/termite.1\n\tinstall -Dm644 man/termite.config.5 ${DESTDIR}${MANDIR}/man5/termite.config.5\n\ttic -x -o ${DESTDIR}${TERMINFO} termite.terminfo\n\nuninstall:\n\trm -f ${DESTDIR}${BINDIR}/termite\n\nclean:\n\trm termite\n\n.PHONY: clean install uninstall\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 13.7880859375,
          "content": "TERMITE IS OBSOLETED BY ALACRITTY\n=================================\n\nYou should use `Alacritty <https://github.com/alacritty/alacritty>`_ instead\nof Termite. It has a keyboard-based selection mode inspired by Termite and\nAlacritty 0.8 adds a generic regex hints mode comparable to Termite's URL\nhints mode. The user interface is very much in the same spirit as Termite\nincluding a very minimal user interface delegating handling tabs and splits to\na window manager like i3. Alacritty is dramatically faster than VTE along with\nbeing significantly more robust and secure. It's written in a modern, safe\nprogramming language (Rust) and uses OpenGL for efficient rendering.\n\nIf you've packaged Termite in a repository, we would highly appreciate if you\ncould communicate our recommendation to end users as part of phasing out and\nretiring the package. Alacritty is the only proper replacement for Termite and\nit took until the 0.8 release currently available as a release candidate for us\nto be able to wholeheartedly recommend it.\n\nWe strongly recommend against trying to continue the development of Termite\nwith a fork. You should contribute to Alacritty instead. VTE is a terrible base\nfor building a modern, fast and safe terminal emulator. It's slow, brittle and\ndifficult to improve. VTE is treated as simply being the GNOME Terminal widget\nrather than a library truly intended to be useful to others. They've gone out\nof the way to keep useful APIs private due to hostility towards implementing\nany kind of user interface beyond what they provide. In 2012, we submitted a\n`tiny patch exposing the APIs needed for the keyboard text selection, hints\nmode and other features <https://bugzilla.gnome.org/show_bug.cgi?id=679658>`_.\nDespite support from multiple other projects, the patch was rejected. It's now\nalmost a decade later and no progress has been made. There is no implementation\nof these kinds of features in VTE and it's unlikely they'll be provided either\ninternally or as flexible APIs. This is the tip of the iceberg when it comes to\ntheir hostility towards other projects using VTE as a library. GTK and most of\nthe GNOME project are much of the same. Avoid them and don't make the mistake\nof thinking their libraries are meant for others to use.\n\nINTRODUCTION\n============\n\nA keyboard-centric VTE-based terminal, aimed at use within a window manager\nwith tiling and/or tabbing support.\n\nTermite looks for the configuration file in the following order:\n``$XDG_CONFIG_HOME/termite/config``, ``~/.config/termite/config``,\n``$XDG_CONFIG_DIRS/termite/config``, ``/etc/xdg/termite/config``.\n\nTermite's exit status is 1 on a failure, including a termination of the child\nprocess from an uncaught signal. Otherwise the exit status is that of the child\nprocess.\n\nDEPENDENCIES\n============\n\nThe `vte-ng <https://github.com/thestinger/vte-ng>`_ project is required until\nVTE exposes the necessary functions for keyboard text selection and URL hints\n(if ever). A simple patch `has been submitted upstream\n<https://bugzilla.gnome.org/show_bug.cgi?id=679658#c10>`_ but they're unwilling\nto expose functionality that's not required by GNOME Terminal even if there's\nno extra maintenance (it already exists internally) and no additional backwards\ncompatibility hazards.\n\nIf no browser is configured and $BROWSER is unset, xdg-open from xdg-utils is\nused as a fallback.\n\nBUILDING\n========\n::\n\n    git clone --recursive https://github.com/thestinger/termite.git\n    cd termite && make\n\nKEYBINDINGS\n===========\n\nINSERT MODE\n-----------\n\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-x``     | activate url hints mode                     |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-r``     | reload configuration file                   |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-c``     | copy to CLIPBOARD                           |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-v``     | paste from CLIPBOARD                        |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-u``     | unicode input (standard GTK binding)        |\n+----------------------+---------------------------------------------+\n| ``ctrl-tab``         | start scrollback completion                 |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-space`` | start selection mode                        |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-t``     | open terminal in the current directory [1]_ |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-up``    | scroll up a line                            |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-down``  | scroll down a line                          |\n+----------------------+---------------------------------------------+\n| ``shift-pageup``     | scroll up a page                            |\n+----------------------+---------------------------------------------+\n| ``shift-pagedown``   | scroll down a page                          |\n+----------------------+---------------------------------------------+\n| ``ctrl-shift-l``     | reset and clear                             |\n+----------------------+---------------------------------------------+\n| ``ctrl-+``           | increase font size                          |\n+----------------------+---------------------------------------------+\n| ``ctrl--``           | decrease font size                          |\n+----------------------+---------------------------------------------+\n| ``ctrl-=``           | reset font size to default                  |\n+----------------------+---------------------------------------------+\n\n.. [1] The directory can be set by a process running in the terminal. For\n       example, with zsh:\n\n       .. code:: sh\n\n            if [[ $TERM == xterm-termite ]]; then\n              . /etc/profile.d/vte.sh\n              __vte_osc7\n            fi\n       ::\n\n       For example, with bash:\n\n       .. code:: sh\n\n            if [[ $TERM == xterm-termite ]]; then\n              . /etc/profile.d/vte.sh\n              __vte_prompt_command\n            fi\n\nSELECTION MODE\n--------------\n\n+-----------------------------------+-----------------------------------------------------------+\n| ``q`` or ``escape`` or ``ctrl-[`` | enter insert mode                                         |\n+-----------------------------------+-----------------------------------------------------------+\n| ``x``                             | activate url hints mode                                   |\n+-----------------------------------+-----------------------------------------------------------+\n| ``v``                             | visual mode                                               |\n+-----------------------------------+-----------------------------------------------------------+\n| ``V``                             | visual line mode                                          |\n+-----------------------------------+-----------------------------------------------------------+\n| ``ctrl-v``                        | visual block mode                                         |\n+-----------------------------------+-----------------------------------------------------------+\n| ``hjkl`` or arrow keys            | move cursor left/down/up/right                            |\n+-----------------------------------+-----------------------------------------------------------+\n| ``w`` or ``shift-right``          | forward word                                              |\n+-----------------------------------+-----------------------------------------------------------+\n| ``e``                             | forward to end of word                                    |\n+-----------------------------------+-----------------------------------------------------------+\n| ``b`` or ``shift-left``           | backward word                                             |\n+-----------------------------------+-----------------------------------------------------------+\n| ``W`` or ``ctrl-right``           | forward WORD (non-whitespace)                             |\n+-----------------------------------+-----------------------------------------------------------+\n| ``E``                             | forward to end of WORD (non-whitespace)                   |\n+-----------------------------------+-----------------------------------------------------------+\n| ``B`` or ``ctrl-left``            | backward WORD (non-whitespace)                            |\n+-----------------------------------+-----------------------------------------------------------+\n| ``H``                             | jump to the top of the screen                             |\n+-----------------------------------+-----------------------------------------------------------+\n| ``M``                             | jump to the middle of the screen                          |\n+-----------------------------------+-----------------------------------------------------------+\n| ``L``                             | jump to the bottom of the screen                          |\n+-----------------------------------+-----------------------------------------------------------+\n| ``0`` or ``home``                 | move cursor to the first column in the row                |\n+-----------------------------------+-----------------------------------------------------------+\n| ``^``                             | beginning-of-line (first non-blank character)             |\n+-----------------------------------+-----------------------------------------------------------+\n| ``$`` or ``end``                  | end-of-line                                               |\n+-----------------------------------+-----------------------------------------------------------+\n| ``g``                             | jump to start of first row                                |\n+-----------------------------------+-----------------------------------------------------------+\n| ``G``                             | jump to start of last row                                 |\n+-----------------------------------+-----------------------------------------------------------+\n| ``ctrl-u``                        | move cursor a half screen up                              |\n+-----------------------------------+-----------------------------------------------------------+\n| ``ctrl-d``                        | move cursor a half screen down                            |\n+-----------------------------------+-----------------------------------------------------------+\n| ``ctrl-b``                        | move cursor a full screen up (back)                       |\n+-----------------------------------+-----------------------------------------------------------+\n| ``ctrl-f``                        | move cursor a full screen down (forward)                  |\n+-----------------------------------+-----------------------------------------------------------+\n| ``y``                             | copy to CLIPBOARD                                         |\n+-----------------------------------+-----------------------------------------------------------+\n| ``/``                             | forward search                                            |\n+-----------------------------------+-----------------------------------------------------------+\n| ``?``                             | reverse search                                            |\n+-----------------------------------+-----------------------------------------------------------+\n| ``u``                             | forward url search                                        |\n+-----------------------------------+-----------------------------------------------------------+\n| ``U``                             | reverse url search                                        |\n+-----------------------------------+-----------------------------------------------------------+\n| ``o``                             | open the current selection as a url                       |\n+-----------------------------------+-----------------------------------------------------------+\n| ``Return``                        | open the current selection as a url and enter insert mode |\n+-----------------------------------+-----------------------------------------------------------+\n| ``n``                             | next search match                                         |\n+-----------------------------------+-----------------------------------------------------------+\n| ``N``                             | previous search match                                     |\n+-----------------------------------+-----------------------------------------------------------+\n\nDuring scrollback search, the current selection is changed to the search match\nand copied to the PRIMARY clipboard buffer.\n\nWith the text input widget focused, up/down (or tab/shift-tab) cycle through\ncompletions, escape closes the widget and enter accepts the input.\n\nIn hints mode, the input will be accepted as soon as termite considers it a\nunique match.\n\nPADDING\n=======\n\nInternal padding can be added by using CSS to style Termite. Adding\nthe following snippet to ``$XDG_CONFIG_HOME/gtk-3.0/gtk.css`` (or\n``~/.config/gtk-3.0/gtk.css``) will add uniform 2px padding around the edges:\n\n.. code:: css\n\n    .termite {\n        padding: 2px;\n    }\n\nThis can also be used to add varying amounts of padding to each side via\nstandard usage of the CSS padding property.\n\nTERMINFO\n========\n\nWhen working on a remote system with termite's terminfo missing, an error might\noccur:\n\n::\n\n    Error opening terminal: xterm-termite\n\nTo solve this issue, install the termite terminfo on your remote system.\n\nOn Arch Linux:\n\n::\n\n        pacman -S termite-terminfo\n\nOn other systems:\n\n\n::\n\n    wget https://raw.githubusercontent.com/thestinger/termite/master/termite.terminfo\n    tic -x termite.terminfo\n"
        },
        {
          "name": "TODO.rst",
          "type": "blob",
          "size": 0.296875,
          "content": "* smarter ambiguity check for partial hints\n* improved matching capabilities (not just urls)\n* scrollback search needs to be improved upstream [1]_\n* expose keybindings in ``termite.cfg``\n* keyboard selection should handle wrapped lines properly\n\n.. [1] https://bugzilla.gnome.org/show_bug.cgi?id=627886\n"
        },
        {
          "name": "config",
          "type": "blob",
          "size": 1.91796875,
          "content": "[options]\n#allow_bold = true\n#audible_bell = false\n#bold_is_bright = true\n#cell_height_scale = 1.0\n#cell_width_scale = 1.0\n#clickable_url = true\n#dynamic_title = true\nfont = Monospace 9\n#fullscreen = true\n#icon_name = terminal\n#mouse_autohide = false\n#scroll_on_output = false\n#scroll_on_keystroke = true\n# Length of the scrollback buffer, 0 disabled the scrollback buffer\n# and setting it to a negative value means \"infinite scrollback\"\nscrollback_lines = 10000\n#search_wrap = true\n#urgent_on_bell = true\n#hyperlinks = false\n\n# $BROWSER is used by default if set, with xdg-open as a fallback\n#browser = xdg-open\n\n# \"system\", \"on\" or \"off\"\n#cursor_blink = system\n\n# \"block\", \"underline\" or \"ibeam\"\n#cursor_shape = block\n\n# Hide links that are no longer valid in url select overlay mode\n#filter_unmatched_urls = true\n\n# Emit escape sequences for extra modified keys\n#modify_other_keys = false\n\n# set size hints for the window\n#size_hints = false\n\n# \"off\", \"left\" or \"right\"\n#scrollbar = off\n\n[colors]\n# If both of these are unset, cursor falls back to the foreground color,\n# and cursor_foreground falls back to the background color.\n#cursor = #dcdccc\n#cursor_foreground = #dcdccc\n\n#foreground = #dcdccc\n#foreground_bold = #ffffff\n#background = #3f3f3f\n\n# 20% background transparency (requires a compositor)\n#background = rgba(63, 63, 63, 0.8)\n\n# If unset, will reverse foreground and background\nhighlight = #2f2f2f\n\n# Colors from color0 to color254 can be set\ncolor0 = #3f3f3f\ncolor1 = #705050\ncolor2 = #60b48a\ncolor3 = #dfaf8f\ncolor4 = #506070\ncolor5 = #dc8cc3\ncolor6 = #8cd0d3\ncolor7 = #dcdccc\ncolor8 = #709080\ncolor9 = #dca3a3\ncolor10 = #c3bf9f\ncolor11 = #f0dfaf\ncolor12 = #94bff3\ncolor13 = #ec93d3\ncolor14 = #93e0e3\ncolor15 = #ffffff\n\n[hints]\n#font = Monospace 12\n#foreground = #dcdccc\n#background = #3f3f3f\n#active_foreground = #e68080\n#active_background = #3f3f3f\n#padding = 2\n#border = #3f3f3f\n#border_width = 0.5\n#roundness = 2.0\n\n# vim: ft=dosini cms=#%s\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "termite.cc",
          "type": "blob",
          "size": 66.6171875,
          "content": "/*\n * Copyright (C) 2013 Daniel Micay\n *\n * This is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Library General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <functional>\n#include <limits>\n#include <map>\n#include <memory>\n#include <vector>\n#include <set>\n#include <string>\n\n#include <gtk/gtk.h>\n#include <vte/vte.h>\n\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\n\n#ifdef GDK_WINDOWING_X11\n#include <gdk/gdkx.h>\n#endif\n\n#include \"url_regex.hh\"\n#include \"util/clamp.hh\"\n#include \"util/maybe.hh\"\n#include \"util/memory.hh\"\n\nusing namespace std::placeholders;\n\n/* Allow scales a bit smaller and a bit larger than the usual pango ranges */\n#define TERMINAL_SCALE_XXX_SMALL   (PANGO_SCALE_XX_SMALL/1.2)\n#define TERMINAL_SCALE_XXXX_SMALL  (TERMINAL_SCALE_XXX_SMALL/1.2)\n#define TERMINAL_SCALE_XXXXX_SMALL (TERMINAL_SCALE_XXXX_SMALL/1.2)\n#define TERMINAL_SCALE_XXX_LARGE   (PANGO_SCALE_XX_LARGE*1.2)\n#define TERMINAL_SCALE_XXXX_LARGE  (TERMINAL_SCALE_XXX_LARGE*1.2)\n#define TERMINAL_SCALE_XXXXX_LARGE (TERMINAL_SCALE_XXXX_LARGE*1.2)\n#define TERMINAL_SCALE_MINIMUM     (TERMINAL_SCALE_XXXXX_SMALL/1.2)\n#define TERMINAL_SCALE_MAXIMUM     (TERMINAL_SCALE_XXXXX_LARGE*1.2)\n\nstatic const std::vector<double> zoom_factors = {\n    TERMINAL_SCALE_MINIMUM,\n    TERMINAL_SCALE_XXXXX_SMALL,\n    TERMINAL_SCALE_XXXX_SMALL,\n    TERMINAL_SCALE_XXX_SMALL,\n    PANGO_SCALE_XX_SMALL,\n    PANGO_SCALE_X_SMALL,\n    PANGO_SCALE_SMALL,\n    PANGO_SCALE_MEDIUM,\n    PANGO_SCALE_LARGE,\n    PANGO_SCALE_X_LARGE,\n    PANGO_SCALE_XX_LARGE,\n    TERMINAL_SCALE_XXX_LARGE,\n    TERMINAL_SCALE_XXXX_LARGE,\n    TERMINAL_SCALE_XXXXX_LARGE,\n    TERMINAL_SCALE_MAXIMUM\n};\n\nenum class overlay_mode {\n    hidden,\n    search,\n    rsearch,\n    completion,\n    urlselect\n};\n\nenum class vi_mode {\n    insert,\n    command,\n    visual,\n    visual_line,\n    visual_block\n};\n\nstruct select_info {\n    vi_mode mode;\n    long begin_col;\n    long begin_row;\n    long origin_col;\n    long origin_row;\n};\n\nstruct url_data {\n    url_data(char *u, long c, long r) : url(u, g_free), col(c), row(r) {}\n    std::unique_ptr<char, decltype(&g_free)> url;\n    long col, row;\n};\n\nstruct search_panel_info {\n    GtkWidget *entry;\n    GtkWidget *da;\n    overlay_mode mode;\n    std::vector<url_data> url_list;\n    char *fulltext;\n};\n\nstruct hint_info {\n    PangoFontDescription *font;\n    cairo_pattern_t *fg, *bg, *af, *ab, *border;\n    double padding, border_width, roundness;\n};\n\nstruct config_info {\n    hint_info hints;\n    char *browser;\n    gboolean dynamic_title, urgent_on_bell, clickable_url, size_hints;\n    gboolean filter_unmatched_urls, modify_other_keys;\n    gboolean fullscreen;\n    int tag;\n    char *config_file;\n    gdouble font_scale;\n};\n\nstruct keybind_info {\n    GtkWindow *window;\n    VteTerminal *vte;\n    search_panel_info panel;\n    select_info select;\n    config_info config;\n    std::function<void (GtkWindow *)> fullscreen_toggle;\n};\n\nstruct draw_cb_info {\n    VteTerminal *vte;\n    search_panel_info *panel;\n    hint_info *hints;\n    gboolean filter_unmatched_urls;\n};\n\nstatic void launch_browser(char *browser, char *url);\nstatic void window_title_cb(VteTerminal *vte, gboolean *dynamic_title);\nstatic gboolean window_state_cb(GtkWindow *window, GdkEventWindowState *event, keybind_info *info);\nstatic gboolean key_press_cb(VteTerminal *vte, GdkEventKey *event, keybind_info *info);\nstatic gboolean entry_key_press_cb(GtkEntry *entry, GdkEventKey *event, keybind_info *info);\nstatic gboolean position_overlay_cb(GtkBin *overlay, GtkWidget *widget, GdkRectangle *alloc);\nstatic gboolean button_press_cb(VteTerminal *vte, GdkEventButton *event, const config_info *info);\nstatic void bell_cb(GtkWidget *vte, gboolean *urgent_on_bell);\nstatic gboolean focus_cb(GtkWindow *window);\n\nstatic GtkTreeModel *create_completion_model(VteTerminal *vte);\nstatic void search(VteTerminal *vte, const char *pattern, bool reverse);\nstatic void overlay_show(search_panel_info *info, overlay_mode mode, VteTerminal *vte);\nstatic void get_vte_padding(VteTerminal *vte, int *left, int *top, int *right, int *bottom);\nstatic char *check_match(VteTerminal *vte, GdkEventButton *event);\nstatic void load_config(GtkWindow *window, VteTerminal *vte, GtkWidget *scrollbar, GtkWidget *hbox,\n                        config_info *info, char **icon, bool *show_scrollbar);\nstatic void set_config(GtkWindow *window, VteTerminal *vte, GtkWidget *scrollbar, GtkWidget *hbox,\n                       config_info *info, char **icon, bool *show_scrollbar,\n                       GKeyFile *config);\nstatic long first_row(VteTerminal *vte);\n\nstatic std::function<void ()> reload_config;\n\nstatic void override_background_color(GtkWidget *widget, GdkRGBA *rgba) {\n    GtkCssProvider *provider = gtk_css_provider_new();\n\n    gchar *colorstr = gdk_rgba_to_string(rgba);\n    char *css = g_strdup_printf(\"* { background-color: %s; }\", colorstr);\n    gtk_css_provider_load_from_data(provider, css, -1, nullptr);\n    g_free(colorstr);\n    g_free(css);\n\n    gtk_style_context_add_provider(gtk_widget_get_style_context(widget),\n                                   GTK_STYLE_PROVIDER(provider),\n                                   GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);\n    g_object_unref(provider);\n}\n\nstatic const std::map<int, const char *> modify_table = {\n    { GDK_KEY_Tab,        \"\\033[27;5;9~\"  },\n    { GDK_KEY_Return,     \"\\033[27;5;13~\" },\n    { GDK_KEY_apostrophe, \"\\033[27;5;39~\" },\n    { GDK_KEY_comma,      \"\\033[27;5;44~\" },\n    { GDK_KEY_minus,      \"\\033[27;5;45~\" },\n    { GDK_KEY_period,     \"\\033[27;5;46~\" },\n    { GDK_KEY_0,          \"\\033[27;5;48~\" },\n    { GDK_KEY_1,          \"\\033[27;5;49~\" },\n    { GDK_KEY_9,          \"\\033[27;5;57~\" },\n    { GDK_KEY_semicolon,  \"\\033[27;5;59~\" },\n    { GDK_KEY_equal,      \"\\033[27;5;61~\" },\n    { GDK_KEY_exclam,     \"\\033[27;6;33~\" },\n    { GDK_KEY_quotedbl,   \"\\033[27;6;34~\" },\n    { GDK_KEY_numbersign, \"\\033[27;6;35~\" },\n    { GDK_KEY_dollar,     \"\\033[27;6;36~\" },\n    { GDK_KEY_percent,    \"\\033[27;6;37~\" },\n    { GDK_KEY_ampersand,  \"\\033[27;6;38~\" },\n    { GDK_KEY_parenleft,  \"\\033[27;6;40~\" },\n    { GDK_KEY_parenright, \"\\033[27;6;41~\" },\n    { GDK_KEY_asterisk,   \"\\033[27;6;42~\" },\n    { GDK_KEY_plus,       \"\\033[27;6;43~\" },\n    { GDK_KEY_colon,      \"\\033[27;6;58~\" },\n    { GDK_KEY_less,       \"\\033[27;6;60~\" },\n    { GDK_KEY_greater,    \"\\033[27;6;62~\" },\n    { GDK_KEY_question,   \"\\033[27;6;63~\" },\n};\n\nstatic const std::map<int, const char *> modify_meta_table = {\n    { GDK_KEY_Tab,        \"\\033[27;13;9~\"  },\n    { GDK_KEY_Return,     \"\\033[27;13;13~\" },\n    { GDK_KEY_apostrophe, \"\\033[27;13;39~\" },\n    { GDK_KEY_comma,      \"\\033[27;13;44~\" },\n    { GDK_KEY_minus,      \"\\033[27;13;45~\" },\n    { GDK_KEY_period,     \"\\033[27;13;46~\" },\n    { GDK_KEY_0,          \"\\033[27;13;48~\" },\n    { GDK_KEY_1,          \"\\033[27;13;49~\" },\n    { GDK_KEY_9,          \"\\033[27;13;57~\" },\n    { GDK_KEY_semicolon,  \"\\033[27;13;59~\" },\n    { GDK_KEY_equal,      \"\\033[27;13;61~\" },\n    { GDK_KEY_exclam,     \"\\033[27;14;33~\" },\n    { GDK_KEY_quotedbl,   \"\\033[27;14;34~\" },\n    { GDK_KEY_numbersign, \"\\033[27;14;35~\" },\n    { GDK_KEY_dollar,     \"\\033[27;14;36~\" },\n    { GDK_KEY_percent,    \"\\033[27;14;37~\" },\n    { GDK_KEY_ampersand,  \"\\033[27;14;38~\" },\n    { GDK_KEY_parenleft,  \"\\033[27;14;40~\" },\n    { GDK_KEY_parenright, \"\\033[27;14;41~\" },\n    { GDK_KEY_asterisk,   \"\\033[27;14;42~\" },\n    { GDK_KEY_plus,       \"\\033[27;14;43~\" },\n    { GDK_KEY_colon,      \"\\033[27;14;58~\" },\n    { GDK_KEY_less,       \"\\033[27;14;60~\" },\n    { GDK_KEY_greater,    \"\\033[27;14;62~\" },\n    { GDK_KEY_question,   \"\\033[27;14;63~\" },\n};\n\nstatic gboolean modify_key_feed(GdkEventKey *event, keybind_info *info,\n                                const std::map<int, const char *>& table) {\n    if (info->config.modify_other_keys) {\n        unsigned int keyval = gdk_keyval_to_lower(event->keyval);\n        auto entry = table.find((int)keyval);\n\n        if (entry != table.end()) {\n            vte_terminal_feed_child(info->vte, entry->second, -1);\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nvoid launch_browser(char *browser, char *url) {\n    char *browser_cmd[3] = {browser, url, nullptr};\n    GError *error = nullptr;\n\n    if (!browser) {\n        g_printerr(\"browser not set, can't open url\\n\");\n        return;\n    }\n\n    GPid child_pid;\n    if (!g_spawn_async(nullptr, browser_cmd, nullptr, G_SPAWN_SEARCH_PATH,\n                       nullptr, nullptr, &child_pid, &error)) {\n        g_printerr(\"error launching '%s': %s\\n\", browser, error->message);\n        g_error_free(error);\n    }\n    g_spawn_close_pid(child_pid);\n}\n\nstatic void set_size_hints(GtkWindow *window, VteTerminal *vte) {\n    static const GdkWindowHints wh = (GdkWindowHints)(GDK_HINT_RESIZE_INC | GDK_HINT_MIN_SIZE |\n                                                      GDK_HINT_BASE_SIZE);\n    const int char_width = (int)vte_terminal_get_char_width(vte);\n    const int char_height = (int)vte_terminal_get_char_height(vte);\n    int padding_left, padding_top, padding_right, padding_bottom;\n    get_vte_padding(vte, &padding_left, &padding_top, &padding_right, &padding_bottom);\n\n    GdkGeometry hints;\n    hints.base_width = char_width + padding_left + padding_right;\n    hints.base_height = char_height + padding_top + padding_bottom;\n    hints.min_width = hints.base_width;\n    hints.min_height = hints.base_height;\n    hints.width_inc  = char_width;\n    hints.height_inc = char_height;\n\n    gtk_window_set_geometry_hints(GTK_WINDOW(window), NULL, &hints, wh);\n}\n\nstatic void launch_in_directory(VteTerminal *vte) {\n    const char *uri = vte_terminal_get_current_directory_uri(vte);\n    if (!uri) {\n        g_printerr(\"no directory uri set\\n\");\n        return;\n    }\n    auto dir = make_unique(g_filename_from_uri(uri, nullptr, nullptr), g_free);\n    char term[] = \"termite\"; // maybe this should be argv[0]\n    char *cmd[] = {term, nullptr};\n    g_spawn_async(dir.get(), cmd, nullptr, G_SPAWN_SEARCH_PATH, nullptr, nullptr, nullptr, nullptr);\n}\n\nstatic void find_urls(VteTerminal *vte, search_panel_info *panel_info) {\n    GRegex *regex = g_regex_new(url_regex, G_REGEX_CASELESS, G_REGEX_MATCH_NOTEMPTY, nullptr);\n    GArray *attributes = g_array_new(FALSE, FALSE, sizeof(VteCharAttributes));\n    auto content = make_unique(vte_terminal_get_text(vte, nullptr, nullptr, attributes), g_free);\n\n    for (char *s_ptr = content.get(), *saveptr; ; s_ptr = nullptr) {\n        const char *token = strtok_r(s_ptr, \"\\n\", &saveptr);\n        if (!token) {\n            break;\n        }\n\n        GError *error = nullptr;\n        GMatchInfo *info;\n\n        g_regex_match_full(regex, token, -1, 0, (GRegexMatchFlags)0, &info, &error);\n        while (g_match_info_matches(info)) {\n            int pos;\n            g_match_info_fetch_pos(info, 0, &pos, nullptr);\n\n            const long first_row = g_array_index(attributes, VteCharAttributes, 0).row;\n            const auto attr = g_array_index(attributes, VteCharAttributes, token + pos - content.get());\n\n            panel_info->url_list.emplace_back(g_match_info_fetch(info, 0),\n                                              attr.column,\n                                              attr.row - first_row);\n            g_match_info_next(info, &error);\n        }\n\n        g_match_info_free(info);\n\n        if (error) {\n            g_printerr(\"error while matching: %s\\n\", error->message);\n            g_error_free(error);\n        }\n    }\n    g_regex_unref(regex);\n    g_array_free(attributes, TRUE);\n}\n\nstatic void launch_url(char *browser, const char *text, search_panel_info *info) {\n    char *end;\n    errno = 0;\n    unsigned long id = strtoul(text, &end, 10);\n    if (!errno && id && id <= info->url_list.size() && !*end) {\n        launch_browser(browser, info->url_list[id - 1].url.get());\n    } else {\n        g_printerr(\"url hint invalid: %s\\n\", text);\n    }\n}\n\nstatic void draw_rectangle(cairo_t *cr, double x, double y, double height,\n                           double width, double radius) {\n    double a = x, b = x + height, c = y, d = y + width;\n    cairo_arc(cr, a + radius, c + radius, radius, 2*(M_PI/2), 3*(M_PI/2));\n    cairo_arc(cr, b - radius, c + radius, radius, 3*(M_PI/2), 4*(M_PI/2));\n    cairo_arc(cr, b - radius, d - radius, radius, 0*(M_PI/2), 1*(M_PI/2));\n    cairo_arc(cr, a + radius, d - radius, radius, 1*(M_PI/2), 2*(M_PI/2));\n    cairo_close_path(cr);\n}\n\nstatic void draw_marker(cairo_t *cr, const PangoFontDescription *desc,\n                        const hint_info *hints, long x, long y, const char *msg,\n                        bool active) {\n    cairo_text_extents_t ext;\n    int width, height;\n\n    cairo_text_extents(cr, msg, &ext);\n    PangoLayout *layout = pango_cairo_create_layout(cr);\n    pango_layout_set_font_description(layout, desc);\n    pango_layout_set_text(layout, msg, -1);\n    pango_layout_get_size(layout, &width, &height);\n\n    draw_rectangle(cr, static_cast<double>(x), static_cast<double>(y),\n                   static_cast<double>(width / PANGO_SCALE) + hints->padding * 2,\n                   static_cast<double>(height / PANGO_SCALE) + hints->padding * 2,\n                   hints->roundness);\n    cairo_set_source(cr, hints->border);\n    cairo_set_line_width(cr, hints->border_width);\n    cairo_stroke_preserve(cr);\n    cairo_set_source(cr, active ? hints->ab : hints->bg);\n    cairo_fill(cr);\n\n    cairo_new_path(cr);\n    cairo_move_to(cr, static_cast<double>(x) + hints->padding,\n                  static_cast<double>(y) + hints->padding);\n\n    cairo_set_source(cr, active ? hints->af : hints->fg);\n    pango_cairo_update_layout(cr, layout);\n    pango_cairo_layout_path(cr, layout);\n    cairo_fill(cr);\n\n    g_object_unref(layout);\n}\n\nstatic gboolean draw_cb(const draw_cb_info *info, cairo_t *cr) {\n    if (!info->panel->url_list.empty()) {\n        char buffer[std::numeric_limits<unsigned>::digits10 + 1];\n\n        int padding_left, padding_top, padding_right, padding_bottom;\n        const long cw = vte_terminal_get_char_width(info->vte);\n        const long ch = vte_terminal_get_char_height(info->vte);\n        const PangoFontDescription *desc = info->hints->font ?\n            info->hints->font : vte_terminal_get_font(info->vte);\n        size_t len = info->panel->fulltext == nullptr ?\n            0 : strlen(info->panel->fulltext);\n\n        cairo_set_line_width(cr, 1);\n        cairo_set_source_rgb(cr, 0, 0, 0);\n        cairo_stroke(cr);\n\n        get_vte_padding(info->vte, &padding_left, &padding_top, &padding_right, &padding_bottom);\n\n        for (unsigned i = 0; i < info->panel->url_list.size(); i++) {\n            const url_data &data = info->panel->url_list[i];\n            const long x = data.col * cw + padding_left;\n            const long y = data.row * ch + padding_top;\n            bool active = false;\n\n            snprintf(buffer, sizeof(buffer), \"%u\", i + 1);\n            if (len)\n                active = strncmp(buffer, info->panel->fulltext, len) == 0;\n\n            if (!info->filter_unmatched_urls || active || len == 0)\n                draw_marker(cr, desc, info->hints, x, y, buffer, active);\n        }\n    }\n\n    return FALSE;\n}\n\nstatic void update_selection(VteTerminal *vte, const select_info *select) {\n    vte_terminal_unselect_all(vte);\n\n    if (select->mode == vi_mode::command) {\n        return;\n    }\n\n    const long n_columns = vte_terminal_get_column_count(vte);\n    long cursor_col, cursor_row, selection_x_end;\n    vte_terminal_get_cursor_position(vte, &cursor_col, &cursor_row);\n\n    vte_terminal_set_selection_block_mode(vte, select->mode == vi_mode::visual_block);\n\n    if (select->mode == vi_mode::visual) {\n        const long begin = select->begin_row * n_columns + select->begin_col;\n        const long end = cursor_row * n_columns + cursor_col;\n        if (begin < end) {\n            selection_x_end = cursor_col;\n#if VTE_CHECK_VERSION(0, 55, 0)\n            selection_x_end += 1;\n#endif\n            vte_terminal_select_text(vte, select->begin_col, select->begin_row,\n                                     selection_x_end, cursor_row);\n        } else {\n            selection_x_end = select->begin_col;\n#if VTE_CHECK_VERSION(0, 55, 0)\n            selection_x_end += 1;\n#endif\n            vte_terminal_select_text(vte, cursor_col, cursor_row,\n                                     selection_x_end, select->begin_row);\n        }\n    } else if (select->mode == vi_mode::visual_line) {\n        selection_x_end = n_columns - 1;\n#if VTE_CHECK_VERSION(0, 55, 0)\n        selection_x_end += 1;\n#endif\n        vte_terminal_select_text(vte, 0,\n                                 std::min(select->begin_row, cursor_row),\n                                 selection_x_end,\n                                 std::max(select->begin_row, cursor_row));\n    } else if (select->mode == vi_mode::visual_block) {\n        selection_x_end = std::max(select->begin_col, cursor_col);\n#if VTE_CHECK_VERSION(0, 55, 0)\n        selection_x_end += 1;\n#endif\n        vte_terminal_select_text(vte,\n                                 std::min(select->begin_col, cursor_col),\n                                 std::min(select->begin_row, cursor_row),\n                                 selection_x_end,\n                                 std::max(select->begin_row, cursor_row));\n    }\n\n    vte_terminal_copy_primary(vte);\n}\n\nstatic void enter_command_mode(VteTerminal *vte, select_info *select) {\n    vte_terminal_disconnect_pty_read(vte);\n    select->mode = vi_mode::command;\n    vte_terminal_get_cursor_position(vte, &select->origin_col, &select->origin_row);\n    update_selection(vte, select);\n}\n\nstatic void exit_command_mode(VteTerminal *vte, select_info *select) {\n    vte_terminal_set_cursor_position(vte, select->origin_col, select->origin_row);\n    vte_terminal_connect_pty_read(vte);\n    vte_terminal_unselect_all(vte);\n    select->mode = vi_mode::insert;\n}\n\nstatic void toggle_visual(VteTerminal *vte, select_info *select, vi_mode mode) {\n    if (select->mode == mode) {\n        select->mode = vi_mode::command;\n    } else {\n        if (select->mode == vi_mode::command) {\n            vte_terminal_get_cursor_position(vte, &select->begin_col, &select->begin_row);\n        }\n        select->mode = mode;\n    }\n    update_selection(vte, select);\n}\n\nstatic long first_row(VteTerminal *vte) {\n    GtkAdjustment *adjust = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vte));\n    return (long)gtk_adjustment_get_lower(adjust);\n}\n\nstatic long last_row(VteTerminal *vte) {\n    GtkAdjustment *adjust = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vte));\n    return (long)gtk_adjustment_get_upper(adjust) - 1;\n}\n\nstatic long top_row(VteTerminal *vte) {\n    GtkAdjustment *adjust = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vte));\n    return (long)gtk_adjustment_get_value(adjust);\n}\n\nstatic long middle_row(VteTerminal *vte) {\n    GtkAdjustment *adjust = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vte));\n    return (long)gtk_adjustment_get_value(adjust) +\n                (long)vte_terminal_get_row_count(vte) / 2;\n}\n\nstatic long bottom_row(VteTerminal *vte) {\n    GtkAdjustment *adjust = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vte));\n    return (long)gtk_adjustment_get_value(adjust) +\n                (long)vte_terminal_get_row_count(vte) - 1;\n}\n\nstatic void update_scroll(VteTerminal *vte) {\n    GtkAdjustment *adjust = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vte));\n    const double scroll_row = gtk_adjustment_get_value(adjust);\n    const long n_rows = vte_terminal_get_row_count(vte);\n    long cursor_row;\n    vte_terminal_get_cursor_position(vte, nullptr, &cursor_row);\n\n    if ( (double)cursor_row < scroll_row) {\n        gtk_adjustment_set_value(adjust, (double)cursor_row);\n    } else if (cursor_row - n_rows >= (long)scroll_row) {\n        gtk_adjustment_set_value(adjust, (double)(cursor_row - n_rows + 1));\n    }\n}\n\nstatic void move(VteTerminal *vte, select_info *select, long col, long row) {\n    const long end_col = vte_terminal_get_column_count(vte) - 1;\n\n    long cursor_col, cursor_row;\n    vte_terminal_get_cursor_position(vte, &cursor_col, &cursor_row);\n\n    VteCursorBlinkMode mode = vte_terminal_get_cursor_blink_mode(vte);\n    vte_terminal_set_cursor_blink_mode(vte, VTE_CURSOR_BLINK_OFF);\n\n    vte_terminal_set_cursor_position(vte,\n                                     clamp(cursor_col + col, 0l, end_col),\n                                     clamp(cursor_row + row, first_row(vte), last_row(vte)));\n\n    update_scroll(vte);\n    update_selection(vte, select);\n    vte_terminal_set_cursor_blink_mode(vte, mode);\n}\n\nstatic void move_to_row_start(VteTerminal *vte, select_info *select, long row) {\n    vte_terminal_set_cursor_position(vte, 0, row);\n    update_scroll(vte);\n    update_selection(vte, select);\n}\n\nstatic void open_selection(char *browser, VteTerminal *vte) {\n    if (!vte_terminal_get_has_selection(vte)) {\n        g_printerr(\"no selection to open\\n\");\n        return;\n    }\n\n    if (browser) {\n        auto selection = make_unique(vte_terminal_get_selection(vte), g_free);\n        if (selection && *selection) {\n            launch_browser(browser, selection.get());\n        }\n    } else {\n        g_printerr(\"no browser to open url\\n\");\n    }\n}\n\nstatic std::unique_ptr<char, decltype(&g_free)>\nget_text_range(VteTerminal *vte, long start_row, long start_col, long end_row, long end_col) {\n    return {vte_terminal_get_text_range(vte, start_row, start_col, end_row, end_col,\n                                        nullptr, nullptr, nullptr), g_free};\n}\n\nstatic bool is_word_char(gunichar c) {\n    static const char *word_char_ascii_punct = \"-,./?%&#_=+@~\";\n    return g_unichar_isgraph(c) &&\n           (g_unichar_isalnum(c) || (g_unichar_ispunct(c) &&\n                                     (c >= 0x80 || strchr(word_char_ascii_punct, (int)c) != NULL)));\n}\n\ntemplate<typename F>\nstatic void move_backward(VteTerminal *vte, select_info *select, F is_word) {\n    long cursor_col, cursor_row;\n    vte_terminal_get_cursor_position(vte, &cursor_col, &cursor_row);\n\n    auto content = get_text_range(vte, cursor_row, 0, cursor_row, cursor_col);\n\n    if (!content) {\n        return;\n    }\n\n    long length;\n    gunichar *codepoints = g_utf8_to_ucs4(content.get(), -1, nullptr, &length, nullptr);\n\n    if (!codepoints) {\n        return;\n    }\n\n    bool in_word = false;\n\n    for (long i = length - 2; i > 0; i--) {\n        cursor_col--;\n        if (!is_word(codepoints[i - 1])) {\n            if (in_word) {\n                break;\n            }\n        } else {\n            in_word = true;\n        }\n    }\n    vte_terminal_set_cursor_position(vte, cursor_col, cursor_row);\n    update_selection(vte, select);\n\n    g_free(codepoints);\n}\n\nstatic void move_backward_word(VteTerminal *vte, select_info *select) {\n    move_backward(vte, select, is_word_char);\n}\n\nstatic void move_backward_blank_word(VteTerminal *vte, select_info *select) {\n    move_backward(vte, select, std::not1(std::ref(g_unichar_isspace)));\n}\n\ntemplate<typename F>\nvoid move_first(VteTerminal *vte, select_info *select, F is_match) {\n    long cursor_col, cursor_row;\n    vte_terminal_get_cursor_position(vte, &cursor_col, &cursor_row);\n\n    const long end_col = vte_terminal_get_column_count(vte) - 1;\n\n    auto content = get_text_range(vte, cursor_row, cursor_col, cursor_row, end_col);\n\n    if (!content) {\n        return;\n    }\n\n    long length;\n    gunichar *codepoints = g_utf8_to_ucs4(content.get(), -1, nullptr, &length, nullptr);\n\n    if (!codepoints) {\n        return;\n    }\n\n    auto iter = std::find_if(codepoints, codepoints + length, is_match);\n    if (iter != codepoints + length) {\n        vte_terminal_set_cursor_position(vte, iter - codepoints, cursor_row);\n        update_selection(vte, select);\n    }\n\n    g_free(codepoints);\n}\n\nstatic void set_cursor_column(VteTerminal *vte, const select_info *select, long column) {\n    long cursor_row;\n    vte_terminal_get_cursor_position(vte, nullptr, &cursor_row);\n    vte_terminal_set_cursor_position(vte, column, cursor_row);\n    update_selection(vte, select);\n}\n\nstatic void move_to_eol(VteTerminal *vte, select_info *select) {\n    long cursor_row;\n    vte_terminal_get_cursor_position(vte, nullptr, &cursor_row);\n\n    const long end_col = vte_terminal_get_column_count(vte) - 1;\n\n    auto content = get_text_range(vte, cursor_row, 0, cursor_row, end_col);\n\n    if (!content) {\n        return;\n    }\n\n    long length;\n    gunichar *codepoints = g_utf8_to_ucs4(content.get(), -1, nullptr, &length, nullptr);\n\n    if (!codepoints) {\n        return;\n    }\n\n    auto iter = std::find(codepoints, codepoints + length, '\\n');\n    set_cursor_column(vte, select, std::max(iter - codepoints - 1l, 0l));\n\n    g_free(codepoints);\n}\n\ntemplate<typename F>\nstatic void move_forward(VteTerminal *vte, select_info *select, F is_word, bool goto_word_end) {\n    long cursor_col, cursor_row;\n    vte_terminal_get_cursor_position(vte, &cursor_col, &cursor_row);\n\n    const long end_col = vte_terminal_get_column_count(vte) - 1;\n\n    auto content = get_text_range(vte, cursor_row, cursor_col, cursor_row, end_col);\n\n    if (!content) {\n        return;\n    }\n\n    long length;\n    gunichar *codepoints = g_utf8_to_ucs4(content.get(), -1, nullptr, &length, nullptr);\n\n    if (!codepoints) {\n        return;\n    }\n\n    // prevent going past the end (get_text_range adds a \\n)\n    if (codepoints[length - 1] == '\\n') {\n        length--;\n    }\n\n    bool end_of_word = false;\n\n    if (!goto_word_end) {\n        for (long i = 1; i < length; i++) {\n            if (is_word(codepoints[i - 1])) {\n                if (end_of_word) {\n                    break;\n                }\n            } else {\n                end_of_word = true;\n            }\n            cursor_col++;\n        }\n    } else {\n        for (long i = 2; i <= length; i++) {\n            cursor_col++;\n            if (is_word(codepoints[i - 1]) && !is_word(codepoints[i])) {\n                break;\n            }\n        }\n    }\n    vte_terminal_set_cursor_position(vte, cursor_col, cursor_row);\n    update_selection(vte, select);\n\n    g_free(codepoints);\n}\n\nstatic void move_forward_end_word(VteTerminal *vte, select_info *select) {\n    move_forward(vte, select, is_word_char, true);\n}\n\nstatic void move_forward_end_blank_word(VteTerminal *vte, select_info *select) {\n    move_forward(vte, select, std::not1(std::ref(g_unichar_isspace)), true);\n}\n\nstatic void move_forward_word(VteTerminal *vte, select_info *select) {\n    move_forward(vte, select, is_word_char, false);\n}\n\nstatic void move_forward_blank_word(VteTerminal *vte, select_info *select) {\n    move_forward(vte, select, std::not1(std::ref(g_unichar_isspace)), false);\n}\n\n/* {{{ CALLBACKS */\nvoid window_title_cb(VteTerminal *vte, gboolean *dynamic_title) {\n    const char *const title = *dynamic_title ? vte_terminal_get_window_title(vte) : nullptr;\n    gtk_window_set_title(GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(vte))),\n                         title ? title : \"termite\");\n}\n\nstatic void reset_font_scale(VteTerminal *vte, gdouble scale) {\n    vte_terminal_set_font_scale(vte, scale);\n}\n\nstatic void increase_font_scale(VteTerminal *vte) {\n    gdouble scale = vte_terminal_get_font_scale(vte);\n\n    for (auto it = zoom_factors.begin(); it != zoom_factors.end(); ++it) {\n        if ((*it - scale) > 1e-6) {\n            vte_terminal_set_font_scale(vte, *it);\n            return;\n        }\n    }\n}\n\nstatic void decrease_font_scale(VteTerminal *vte) {\n    gdouble scale = vte_terminal_get_font_scale(vte);\n\n    for (auto it = zoom_factors.rbegin(); it != zoom_factors.rend(); ++it) {\n        if ((scale - *it) > 1e-6) {\n            vte_terminal_set_font_scale(vte, *it);\n            return;\n        }\n    }\n}\n\ngboolean window_state_cb(GtkWindow *, GdkEventWindowState *event, keybind_info *info) {\n    if (event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN)\n        info->fullscreen_toggle = gtk_window_unfullscreen;\n    else\n        info->fullscreen_toggle = gtk_window_fullscreen;\n    return FALSE;\n}\n\ngboolean key_press_cb(VteTerminal *vte, GdkEventKey *event, keybind_info *info) {\n    const guint modifiers = event->state & gtk_accelerator_get_default_mod_mask();\n\n    if (info->config.fullscreen && event->keyval == GDK_KEY_F11 && !modifiers) {\n        info->fullscreen_toggle(info->window);\n        return TRUE;\n    }\n\n    if (info->select.mode != vi_mode::insert) {\n        if (modifiers == GDK_CONTROL_MASK) {\n            switch (gdk_keyval_to_lower(event->keyval)) {\n                case GDK_KEY_bracketleft:\n                    exit_command_mode(vte, &info->select);\n                    gtk_widget_hide(info->panel.da);\n                    gtk_widget_hide(info->panel.entry);\n                    info->panel.url_list.clear();\n                    break;\n                case GDK_KEY_v:\n                    toggle_visual(vte, &info->select, vi_mode::visual_block);\n                    break;\n                case GDK_KEY_Left:\n                    move_backward_blank_word(vte, &info->select);\n                    break;\n                case GDK_KEY_Right:\n                    move_forward_blank_word(vte, &info->select);\n                    break;\n                case GDK_KEY_u:\n                    move(vte, &info->select, 0, -(vte_terminal_get_row_count(vte) / 2));\n                    break;\n                case GDK_KEY_d:\n                    move(vte, &info->select, 0, vte_terminal_get_row_count(vte) / 2);\n                    break;\n                case GDK_KEY_b:\n                    move(vte, &info->select, 0, -(vte_terminal_get_row_count(vte) - 1));\n                    break;\n                case GDK_KEY_f:\n                    move(vte, &info->select, 0, vte_terminal_get_row_count(vte) - 1);\n                    break;\n            }\n            return TRUE;\n        }\n        if (modifiers == GDK_SHIFT_MASK) {\n            switch (event->keyval) {\n                case GDK_KEY_Left:\n                    move_backward_word(vte, &info->select);\n                    return TRUE;\n                case GDK_KEY_Right:\n                    move_forward_word(vte, &info->select);\n                    return TRUE;\n            }\n        }\n        switch (event->keyval) {\n            case GDK_KEY_Escape:\n            case GDK_KEY_q:\n                exit_command_mode(vte, &info->select);\n                gtk_widget_hide(info->panel.da);\n                gtk_widget_hide(info->panel.entry);\n                info->panel.url_list.clear();\n                break;\n            case GDK_KEY_Left:\n            case GDK_KEY_h:\n                move(vte, &info->select, -1, 0);\n                break;\n            case GDK_KEY_Down:\n            case GDK_KEY_j:\n                move(vte, &info->select, 0, 1);\n                break;\n            case GDK_KEY_Up:\n            case GDK_KEY_k:\n                move(vte, &info->select, 0, -1);\n                break;\n            case GDK_KEY_Right:\n            case GDK_KEY_l:\n                move(vte, &info->select, 1, 0);\n                break;\n            case GDK_KEY_b:\n                move_backward_word(vte, &info->select);\n                break;\n            case GDK_KEY_B:\n                move_backward_blank_word(vte, &info->select);\n                break;\n            case GDK_KEY_w:\n                move_forward_word(vte, &info->select);\n                break;\n            case GDK_KEY_W:\n                move_forward_blank_word(vte, &info->select);\n                break;\n            case GDK_KEY_e:\n                move_forward_end_word(vte, &info->select);\n                break;\n            case GDK_KEY_E:\n                move_forward_end_blank_word(vte, &info->select);\n                break;\n            case GDK_KEY_0:\n            case GDK_KEY_Home:\n                set_cursor_column(vte, &info->select, 0);\n                break;\n            case GDK_KEY_asciicircum:\n                set_cursor_column(vte, &info->select, 0);\n                move_first(vte, &info->select, std::not1(std::ref(g_unichar_isspace)));\n                break;\n            case GDK_KEY_dollar:\n            case GDK_KEY_End:\n                move_to_eol(vte, &info->select);\n                break;\n            case GDK_KEY_g:\n                move_to_row_start(vte, &info->select, first_row(vte));\n                break;\n            case GDK_KEY_G:\n                move_to_row_start(vte, &info->select, last_row(vte));\n                break;\n            case GDK_KEY_H:\n                move_to_row_start(vte, &info->select, top_row(vte));\n                break;\n            case GDK_KEY_M:\n                move_to_row_start(vte, &info->select, middle_row(vte));\n                break;\n            case GDK_KEY_L:\n                move_to_row_start(vte, &info->select, bottom_row(vte));\n                break;\n            case GDK_KEY_v:\n                toggle_visual(vte, &info->select, vi_mode::visual);\n                break;\n            case GDK_KEY_V:\n                toggle_visual(vte, &info->select, vi_mode::visual_line);\n                break;\n            case GDK_KEY_y:\n#if VTE_CHECK_VERSION(0, 50, 0)\n                vte_terminal_copy_clipboard_format(vte, VTE_FORMAT_TEXT);\n#else\n                vte_terminal_copy_clipboard(vte);\n#endif\n                break;\n            case GDK_KEY_slash:\n                overlay_show(&info->panel, overlay_mode::search, vte);\n                break;\n            case GDK_KEY_question:\n                overlay_show(&info->panel, overlay_mode::rsearch, vte);\n                break;\n            case GDK_KEY_n:\n                vte_terminal_search_find_next(vte);\n                vte_terminal_copy_primary(vte);\n                break;\n            case GDK_KEY_N:\n                vte_terminal_search_find_previous(vte);\n                vte_terminal_copy_primary(vte);\n                break;\n            case GDK_KEY_u:\n                search(vte, url_regex, false);\n                break;\n            case GDK_KEY_U:\n                search(vte, url_regex, true);\n                break;\n            case GDK_KEY_o:\n                open_selection(info->config.browser, vte);\n                break;\n            case GDK_KEY_Return:\n                open_selection(info->config.browser, vte);\n                exit_command_mode(vte, &info->select);\n                break;\n            case GDK_KEY_x:\n                if (!info->config.browser)\n                    break;\n                find_urls(vte, &info->panel);\n                gtk_widget_show(info->panel.da);\n                overlay_show(&info->panel, overlay_mode::urlselect, nullptr);\n                break;\n        }\n        return TRUE;\n    }\n    if (modifiers == (GDK_CONTROL_MASK|GDK_SHIFT_MASK)) {\n        switch (gdk_keyval_to_lower(event->keyval)) {\n            case GDK_KEY_plus:\n                increase_font_scale(vte);\n                return TRUE;\n            case GDK_KEY_equal:\n                reset_font_scale(vte, info->config.font_scale);\n                return TRUE;\n            case GDK_KEY_t:\n                launch_in_directory(vte);\n                return TRUE;\n            case GDK_KEY_space:\n            case GDK_KEY_nobreakspace: // shift-space on some keyboard layouts\n                enter_command_mode(vte, &info->select);\n                return TRUE;\n            case GDK_KEY_x:\n                enter_command_mode(vte, &info->select);\n                find_urls(vte, &info->panel);\n                gtk_widget_show(info->panel.da);\n                overlay_show(&info->panel, overlay_mode::urlselect, nullptr);\n                exit_command_mode(vte, &info->select);\n                return TRUE;\n            case GDK_KEY_c:\n#if VTE_CHECK_VERSION(0, 50, 0)\n                vte_terminal_copy_clipboard_format(vte, VTE_FORMAT_TEXT);\n#else\n                vte_terminal_copy_clipboard(vte);\n#endif\n                return TRUE;\n            case GDK_KEY_v:\n                vte_terminal_paste_clipboard(vte);\n                return TRUE;\n            case GDK_KEY_r:\n                reload_config();\n                return TRUE;\n            case GDK_KEY_l:\n                vte_terminal_reset(vte, TRUE, TRUE);\n                return TRUE;\n            default:\n                if (modify_key_feed(event, info, modify_table))\n                    return TRUE;\n        }\n    } else if ((modifiers == (GDK_CONTROL_MASK|GDK_MOD1_MASK)) ||\n               (modifiers == (GDK_CONTROL_MASK|GDK_MOD1_MASK|GDK_SHIFT_MASK))) {\n        if (modify_key_feed(event, info, modify_meta_table))\n            return TRUE;\n    } else if (modifiers == GDK_CONTROL_MASK) {\n        switch (gdk_keyval_to_lower(event->keyval)) {\n            case GDK_KEY_Tab:\n                overlay_show(&info->panel, overlay_mode::completion, vte);\n                return TRUE;\n            case GDK_KEY_plus:\n            case GDK_KEY_KP_Add:\n                increase_font_scale(vte);\n                return TRUE;\n            case GDK_KEY_minus:\n            case GDK_KEY_KP_Subtract:\n                decrease_font_scale(vte);\n                return TRUE;\n            case GDK_KEY_equal:\n                reset_font_scale(vte, info->config.font_scale);\n                return TRUE;\n            default:\n                if (modify_key_feed(event, info, modify_table))\n                    return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nstatic void synthesize_keypress(GtkWidget *widget, unsigned keyval) {\n    GdkEvent new_event;\n\n    new_event.key.type = GDK_KEY_PRESS;\n    new_event.key.window = gtk_widget_get_parent_window(widget);\n    new_event.key.send_event = TRUE;\n    new_event.key.time = GDK_CURRENT_TIME;\n    new_event.key.keyval = keyval;\n    new_event.key.state = GDK_KEY_PRESS_MASK;\n    new_event.key.length = 0;\n    new_event.key.string = nullptr;\n    new_event.key.hardware_keycode = 0;\n    new_event.key.group = 0;\n\n    gdk_event_put(&new_event);\n}\n\ngboolean entry_key_press_cb(GtkEntry *entry, GdkEventKey *event, keybind_info *info) {\n    const guint modifiers = event->state & gtk_accelerator_get_default_mod_mask();\n    gboolean ret = FALSE;\n\n    if (modifiers == GDK_CONTROL_MASK) {\n        switch (event->keyval) {\n            case GDK_KEY_bracketleft:\n                ret = TRUE;\n                break;\n        }\n    }\n    switch (event->keyval) {\n        case GDK_KEY_BackSpace:\n            if (info->panel.mode == overlay_mode::urlselect && info->panel.fulltext) {\n                size_t slen = strlen(info->panel.fulltext);\n                if (info->panel.fulltext != nullptr && slen > 0)\n                    info->panel.fulltext[slen-1] = '\\0';\n                gtk_widget_queue_draw(info->panel.da);\n            }\n            break;\n        case GDK_KEY_0:\n        case GDK_KEY_1:\n        case GDK_KEY_2:\n        case GDK_KEY_3:\n        case GDK_KEY_4:\n        case GDK_KEY_5:\n        case GDK_KEY_6:\n        case GDK_KEY_7:\n        case GDK_KEY_8:\n        case GDK_KEY_9:\n            if (info->panel.mode == overlay_mode::urlselect) {\n                const char *const text = gtk_entry_get_text(entry);\n                size_t len = strlen(text);\n                free(info->panel.fulltext);\n                info->panel.fulltext = g_strndup(text, len + 1);\n                info->panel.fulltext[len] = (char)event->keyval;\n                size_t urld = static_cast<size_t>(info->panel.url_list.size());\n                size_t textd = strtoul(info->panel.fulltext, nullptr, 10);\n                size_t url_dig = static_cast<size_t>(\n                    log10(static_cast<double>(info->panel.url_list.size())) + 1);\n                size_t text_dig = static_cast<size_t>(\n                    log10(static_cast<double>(textd)) + 1);\n\n                if (url_dig == text_dig ||\n                    textd > static_cast<size_t>(static_cast<double>(urld)/10)) {\n                    launch_url(info->config.browser, info->panel.fulltext, &info->panel);\n                    ret = TRUE;\n                } else {\n                    gtk_widget_queue_draw(info->panel.da);\n                }\n            }\n            break;\n        case GDK_KEY_Tab:\n            synthesize_keypress(GTK_WIDGET(entry), GDK_KEY_Down);\n            return TRUE;\n        case GDK_KEY_ISO_Left_Tab:\n            synthesize_keypress(GTK_WIDGET(entry), GDK_KEY_Up);\n            return TRUE;\n        case GDK_KEY_Down:\n            // this stops the down key from leaving the GtkEntry...\n            event->hardware_keycode = 0;\n            break;\n        case GDK_KEY_Escape:\n            ret = TRUE;\n            break;\n        case GDK_KEY_Return: {\n            const char *const text = gtk_entry_get_text(entry);\n\n            switch (info->panel.mode) {\n                case overlay_mode::search:\n                    search(info->vte, text, false);\n                    break;\n                case overlay_mode::rsearch:\n                    search(info->vte, text, true);\n                    break;\n                case overlay_mode::completion:\n                    vte_terminal_feed_child(info->vte, text, -1);\n                    break;\n                case overlay_mode::urlselect:\n                    launch_url(info->config.browser, text, &info->panel);\n                    break;\n                case overlay_mode::hidden:\n                    break;\n            }\n            ret = TRUE;\n         }\n    }\n\n    if (ret) {\n        if (info->panel.mode == overlay_mode::urlselect) {\n            gtk_widget_hide(info->panel.da);\n            info->panel.url_list.clear();\n            free(info->panel.fulltext);\n            info->panel.fulltext = nullptr;\n        }\n        info->panel.mode = overlay_mode::hidden;\n        gtk_widget_hide(info->panel.entry);\n        gtk_widget_grab_focus(GTK_WIDGET(info->vte));\n    }\n    return ret;\n}\n\ngboolean position_overlay_cb(GtkBin *overlay, GtkWidget *widget, GdkRectangle *alloc) {\n    GtkWidget *vte = gtk_bin_get_child(overlay);\n\n    const int width  = gtk_widget_get_allocated_width(vte);\n    const int height = gtk_widget_get_allocated_height(vte);\n\n    GtkRequisition req;\n    gtk_widget_get_preferred_size(widget, nullptr, &req);\n\n    alloc->x = width - req.width - 40;\n    alloc->y = 0;\n    alloc->width  = std::min(width, req.width);\n    alloc->height = std::min(height, req.height);\n\n    return TRUE;\n}\n\ngboolean button_press_cb(VteTerminal *vte, GdkEventButton *event, const config_info *info) {\n    if (info->clickable_url && event->type == GDK_BUTTON_PRESS) {\n#if VTE_CHECK_VERSION (0, 49, 1)\n        auto match = make_unique(vte_terminal_hyperlink_check_event(vte, (GdkEvent*)event), g_free);\n        if (!match) {\n            match = make_unique(check_match(vte, event), g_free);\n        }\n#else\n        auto match = make_unique(check_match(vte, event), g_free);\n#endif\n        if (!match)\n            return FALSE;\n\n        if (event->button == 1) {\n            launch_browser(info->browser, match.get());\n        } else if (event->button == 3) {\n            GtkClipboard *clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);\n            gtk_clipboard_set_text(clipboard, match.get(), -1);\n        }\n\n        return TRUE;\n    }\n    return FALSE;\n}\n\nstatic void bell_cb(GtkWidget *vte, gboolean *urgent_on_bell) {\n    if (*urgent_on_bell) {\n        gtk_window_set_urgency_hint(GTK_WINDOW(gtk_widget_get_toplevel(vte)), TRUE);\n    }\n}\n\ngboolean focus_cb(GtkWindow *window) {\n    gtk_window_set_urgency_hint(window, FALSE);\n    return FALSE;\n}\n/* }}} */\n\nGtkTreeModel *create_completion_model(VteTerminal *vte) {\n    GtkListStore *store = gtk_list_store_new(1, G_TYPE_STRING);\n\n    long end_row, end_col;\n    vte_terminal_get_cursor_position(vte, &end_col, &end_row);\n    auto content = get_text_range(vte, 0, 0, end_row, end_col);\n\n    if (!content) {\n        g_printerr(\"no content returned for completion\\n\");\n        return GTK_TREE_MODEL(store);\n    }\n\n    auto less = [](const char *a, const char *b) { return strcmp(a, b) < 0; };\n    std::set<const char *, decltype(less)> tokens(less);\n\n    for (char *s_ptr = content.get(), *saveptr; ; s_ptr = nullptr) {\n        const char *token = strtok_r(s_ptr, \" \\n\\t\", &saveptr);\n        if (!token) {\n            break;\n        }\n        tokens.insert(token);\n    }\n\n    for (const char *token : tokens) {\n        GtkTreeIter iter;\n        gtk_list_store_append(store, &iter);\n        gtk_list_store_set(store, &iter, 0, token, -1);\n    }\n\n    return GTK_TREE_MODEL(store);\n}\n\nvoid search(VteTerminal *vte, const char *pattern, bool reverse) {\n    auto terminal_search = reverse ? vte_terminal_search_find_previous : vte_terminal_search_find_next;\n\n    VteRegex *regex = vte_terminal_search_get_regex(vte);\n    if (regex) vte_regex_unref(regex);\n    vte_terminal_search_set_regex(vte,\n                    vte_regex_new_for_search(pattern,\n                                    (gssize) strlen(pattern),\n                                    PCRE2_MULTILINE | PCRE2_CASELESS,\n                                    nullptr), 0);\n\n    if (!terminal_search(vte)) {\n        vte_terminal_unselect_all(vte);\n        terminal_search(vte);\n    }\n\n    vte_terminal_copy_primary(vte);\n}\n\nvoid overlay_show(search_panel_info *info, overlay_mode mode, VteTerminal *vte) {\n    if (vte) {\n        GtkEntryCompletion *completion = gtk_entry_completion_new();\n        gtk_entry_set_completion(GTK_ENTRY(info->entry), completion);\n        g_object_unref(completion);\n\n        GtkTreeModel *completion_model = create_completion_model(vte);\n        gtk_entry_completion_set_model(completion, completion_model);\n        g_object_unref(completion_model);\n\n        gtk_entry_completion_set_inline_selection(completion, TRUE);\n        gtk_entry_completion_set_text_column(completion, 0);\n    }\n\n    gtk_entry_set_text(GTK_ENTRY(info->entry), \"\");\n\n    info->mode = mode;\n    gtk_widget_show(info->entry);\n    gtk_widget_grab_focus(info->entry);\n}\n\nvoid get_vte_padding(VteTerminal *vte, int *left, int *top, int *right, int *bottom) {\n    GtkBorder border;\n    gtk_style_context_get_padding(gtk_widget_get_style_context(GTK_WIDGET(vte)),\n                                  gtk_widget_get_state_flags(GTK_WIDGET(vte)),\n                                  &border);\n    *left = border.left;\n    *right = border.right;\n    *top = border.top;\n    *bottom = border.bottom;\n}\n\nchar *check_match(VteTerminal *vte, GdkEventButton *event) {\n    int tag;\n\n    return vte_terminal_match_check_event(vte, (GdkEvent*) event, &tag);\n}\n\n/* {{{ CONFIG LOADING */\ntemplate<typename T>\nmaybe<T> get_config(T (*get)(GKeyFile *, const char *, const char *, GError **),\n                    GKeyFile *config, const char *group, const char *key) {\n    GError *error = nullptr;\n    maybe<T> value = get(config, group, key, &error);\n    if (error) {\n        g_error_free(error);\n        return {};\n    }\n    return value;\n}\n\nauto get_config_integer(std::bind(get_config<int>, g_key_file_get_integer,\n                                  _1, _2, _3));\nauto get_config_string(std::bind(get_config<char *>, g_key_file_get_string,\n                                 _1, _2, _3));\nauto get_config_double(std::bind(get_config<double>, g_key_file_get_double,\n                                 _1, _2, _3));\n\nstatic maybe<GdkRGBA> get_config_color(GKeyFile *config, const char *section, const char *key) {\n    if (auto s = get_config_string(config, section, key)) {\n        GdkRGBA color;\n        if (gdk_rgba_parse(&color, *s)) {\n            g_free(*s);\n            return color;\n        }\n        g_printerr(\"invalid color string: %s\\n\", *s);\n        g_free(*s);\n    }\n    return {};\n}\n\nstatic maybe<cairo_pattern_t *>\nget_config_cairo_color(GKeyFile *config, const char *group, const char *key) {\n    if (auto color = get_config_color(config, group, key)) {\n        return cairo_pattern_create_rgba(color->red,\n                                         color->green,\n                                         color->blue,\n                                         color->alpha);\n    }\n    return {};\n}\n\nstatic void load_theme(GtkWindow *window, VteTerminal *vte, GKeyFile *config, hint_info &hints) {\n    std::array<GdkRGBA, 256> palette;\n    char color_key[] = \"color000\";\n\n    for (unsigned i = 0; i < palette.size(); i++) {\n        snprintf(color_key, sizeof(color_key), \"color%u\", i);\n        if (auto color = get_config_color(config, \"colors\", color_key)) {\n            palette[i] = *color;\n        } else if (i < 16) {\n            palette[i].blue = (((i & 4) ? 0xc000 : 0) + (i > 7 ? 0x3fff: 0)) / 65535.0;\n            palette[i].green = (((i & 2) ? 0xc000 : 0) + (i > 7 ? 0x3fff : 0)) / 65535.0;\n            palette[i].red = (((i & 1) ? 0xc000 : 0) + (i > 7 ? 0x3fff : 0)) / 65535.0;\n            palette[i].alpha = 0;\n        } else if (i < 232) {\n            const unsigned j = i - 16;\n            const unsigned r = j / 36, g = (j / 6) % 6, b = j % 6;\n            const unsigned red =   (r == 0) ? 0 : r * 40 + 55;\n            const unsigned green = (g == 0) ? 0 : g * 40 + 55;\n            const unsigned blue =  (b == 0) ? 0 : b * 40 + 55;\n            palette[i].red   = (red | red << 8) / 65535.0;\n            palette[i].green = (green | green << 8) / 65535.0;\n            palette[i].blue  = (blue | blue << 8) / 65535.0;\n            palette[i].alpha = 0;\n        } else if (i < 256) {\n            const unsigned shade = 8 + (i - 232) * 10;\n            palette[i].red = palette[i].green = palette[i].blue = (shade | shade << 8) / 65535.0;\n            palette[i].alpha = 0;\n        }\n    }\n\n    vte_terminal_set_colors(vte, nullptr, nullptr, palette.data(), palette.size());\n    if (auto color = get_config_color(config, \"colors\", \"foreground\")) {\n        vte_terminal_set_color_foreground(vte, &*color);\n        vte_terminal_set_color_bold(vte, &*color);\n    }\n    if (auto color = get_config_color(config, \"colors\", \"foreground_bold\")) {\n        vte_terminal_set_color_bold(vte, &*color);\n    }\n    if (auto color = get_config_color(config, \"colors\", \"background\")) {\n        vte_terminal_set_color_background(vte, &*color);\n        override_background_color(GTK_WIDGET(window), &*color);\n    }\n    if (auto color = get_config_color(config, \"colors\", \"cursor\")) {\n        vte_terminal_set_color_cursor(vte, &*color);\n    }\n    if (auto color = get_config_color(config, \"colors\", \"cursor_foreground\")) {\n        vte_terminal_set_color_cursor_foreground(vte, &*color);\n    }\n    if (auto color = get_config_color(config, \"colors\", \"highlight\")) {\n        vte_terminal_set_color_highlight(vte, &*color);\n    }\n\n    if (auto s = get_config_string(config, \"hints\", \"font\")) {\n        hints.font = pango_font_description_from_string(*s);\n        g_free(*s);\n    }\n\n    hints.fg = get_config_cairo_color(config, \"hints\", \"foreground\").get_value_or(cairo_pattern_create_rgb(1, 1, 1));\n    hints.bg = get_config_cairo_color(config, \"hints\", \"background\").get_value_or(cairo_pattern_create_rgb(0, 0, 0));\n    hints.af = get_config_cairo_color(config, \"hints\", \"active_foreground\").get_value_or(cairo_pattern_create_rgb(0.9, 0.5, 0.5));\n    hints.ab = get_config_cairo_color(config, \"hints\", \"active_background\").get_value_or(cairo_pattern_create_rgb(0, 0, 0));\n    hints.border = get_config_cairo_color(config, \"hints\", \"border\").get_value_or(hints.fg);\n    hints.padding = get_config_double(config, \"hints\", \"padding\", 5).get_value_or(2.0);\n    hints.border_width = get_config_double(config, \"hints\", \"border_width\").get_value_or(1.0);\n    hints.roundness = get_config_double(config, \"hints\", \"roundness\").get_value_or(1.5);\n}\n\nstatic void load_config(GtkWindow *window, VteTerminal *vte, GtkWidget *scrollbar,\n                        GtkWidget *hbox, config_info *info, char **icon,\n                        bool *show_scrollbar) {\n    const std::string default_path = \"/termite/config\";\n    GKeyFile *config = g_key_file_new();\n    GError *error = nullptr;\n\n    gboolean loaded = FALSE;\n\n    if (info->config_file) {\n        loaded = g_key_file_load_from_file(config,\n                                           info->config_file,\n                                           G_KEY_FILE_NONE, &error);\n        if (!loaded)\n            g_printerr(\"%s parsing failed: %s\\n\", info->config_file,\n                       error->message);\n    }\n\n    if (!loaded) {\n        loaded = g_key_file_load_from_file(config,\n                                           (g_get_user_config_dir() + default_path).c_str(),\n                                           G_KEY_FILE_NONE, &error);\n        if (!loaded)\n            g_printerr(\"%s parsing failed: %s\\n\", (g_get_user_config_dir() + default_path).c_str(),\n                       error->message);\n    }\n\n    for (const char *const *dir = g_get_system_config_dirs();\n         !loaded && *dir; dir++) {\n        loaded = g_key_file_load_from_file(config, (*dir + default_path).c_str(),\n                                           G_KEY_FILE_NONE, &error);\n        if (!loaded)\n            g_printerr(\"%s parsing failed: %s\\n\", (*dir + default_path).c_str(),\n                       error->message);\n    }\n\n    if (loaded) {\n        set_config(window, vte, scrollbar, hbox, info, icon, show_scrollbar, config);\n    }\n    g_key_file_free(config);\n}\n\nstatic void set_config(GtkWindow *window, VteTerminal *vte, GtkWidget *scrollbar, GtkWidget *hbox,\n                       config_info *info, char **icon, bool *show_scrollbar_ptr,\n                       GKeyFile *config) {\n\n    auto cfg_bool = [config](const char *key, gboolean value) {\n        return get_config<gboolean>(g_key_file_get_boolean,\n                                    config, \"options\", key).get_value_or(value);\n    };\n\n    vte_terminal_set_scroll_on_output(vte, cfg_bool(\"scroll_on_output\", FALSE));\n    vte_terminal_set_scroll_on_keystroke(vte, cfg_bool(\"scroll_on_keystroke\", TRUE));\n    vte_terminal_set_audible_bell(vte, cfg_bool(\"audible_bell\", FALSE));\n    vte_terminal_set_mouse_autohide(vte, cfg_bool(\"mouse_autohide\", FALSE));\n    vte_terminal_set_allow_bold(vte, cfg_bool(\"allow_bold\", TRUE));\n    vte_terminal_search_set_wrap_around(vte, cfg_bool(\"search_wrap\", TRUE));\n#if VTE_CHECK_VERSION (0, 49, 1)\n    vte_terminal_set_allow_hyperlink(vte, cfg_bool(\"hyperlinks\", FALSE));\n#endif\n#if VTE_CHECK_VERSION (0, 51, 2)\n    vte_terminal_set_bold_is_bright(vte, cfg_bool(\"bold_is_bright\", TRUE));\n    vte_terminal_set_cell_height_scale(vte, get_config_double(config, \"options\", \"cell_height_scale\").get_value_or(1.0));\n    vte_terminal_set_cell_width_scale(vte, get_config_double(config, \"options\", \"cell_width_scale\").get_value_or(1.0));\n#endif\n    info->dynamic_title = cfg_bool(\"dynamic_title\", TRUE);\n    info->urgent_on_bell = cfg_bool(\"urgent_on_bell\", TRUE);\n    info->clickable_url = cfg_bool(\"clickable_url\", TRUE);\n    info->size_hints = cfg_bool(\"size_hints\", FALSE);\n    info->filter_unmatched_urls = cfg_bool(\"filter_unmatched_urls\", TRUE);\n    info->modify_other_keys = cfg_bool(\"modify_other_keys\", FALSE);\n    info->fullscreen = cfg_bool(\"fullscreen\", TRUE);\n    info->font_scale = vte_terminal_get_font_scale(vte);\n\n    g_free(info->browser);\n    info->browser = nullptr;\n\n    if (auto s = get_config_string(config, \"options\", \"browser\")) {\n        info->browser = *s;\n    } else {\n        info->browser = g_strdup(g_getenv(\"BROWSER\"));\n    }\n\n    if (!info->browser) {\n        info->browser = g_strdup(\"xdg-open\");\n    }\n\n    if (info->clickable_url) {\n        info->tag = vte_terminal_match_add_regex(vte,\n                vte_regex_new_for_match(url_regex,\n                                        (gssize) strlen(url_regex),\n                                        PCRE2_MULTILINE | PCRE2_NOTEMPTY,\n                                        nullptr),\n                0);\n        vte_terminal_match_set_cursor_name(vte, info->tag, \"hand\");\n    } else if (info->tag != -1) {\n        vte_terminal_match_remove(vte, info->tag);\n        info->tag = -1;\n    }\n\n    if (auto s = get_config_string(config, \"options\", \"font\")) {\n        PangoFontDescription *font = pango_font_description_from_string(*s);\n        vte_terminal_set_font(vte, font);\n        pango_font_description_free(font);\n        g_free(*s);\n    }\n\n    if (auto i = get_config_integer(config, \"options\", \"scrollback_lines\")) {\n        vte_terminal_set_scrollback_lines(vte, *i);\n    }\n\n    if (auto s = get_config_string(config, \"options\", \"cursor_blink\")) {\n        if (!g_ascii_strcasecmp(*s, \"system\")) {\n            vte_terminal_set_cursor_blink_mode(vte, VTE_CURSOR_BLINK_SYSTEM);\n        } else if (!g_ascii_strcasecmp(*s, \"on\")) {\n            vte_terminal_set_cursor_blink_mode(vte, VTE_CURSOR_BLINK_ON);\n        } else if (!g_ascii_strcasecmp(*s, \"off\")) {\n            vte_terminal_set_cursor_blink_mode(vte, VTE_CURSOR_BLINK_OFF);\n        }\n        g_free(*s);\n    }\n\n    if (auto s = get_config_string(config, \"options\", \"cursor_shape\")) {\n        if (!g_ascii_strcasecmp(*s, \"block\")) {\n            vte_terminal_set_cursor_shape(vte, VTE_CURSOR_SHAPE_BLOCK);\n        } else if (!g_ascii_strcasecmp(*s, \"ibeam\")) {\n            vte_terminal_set_cursor_shape(vte, VTE_CURSOR_SHAPE_IBEAM);\n        } else if (!g_ascii_strcasecmp(*s, \"underline\")) {\n            vte_terminal_set_cursor_shape(vte, VTE_CURSOR_SHAPE_UNDERLINE);\n        }\n        g_free(*s);\n    }\n\n    if (icon) {\n        if (auto s = get_config_string(config, \"options\", \"icon_name\")) {\n            *icon = *s;\n        }\n    }\n\n    if (info->size_hints) {\n        set_size_hints(GTK_WINDOW(window), vte);\n    }\n\n    bool show_scrollbar = false;\n    if (auto s = get_config_string(config, \"options\", \"scrollbar\")) {\n        // \"off\" is implicitly handled by default\n        if (!g_ascii_strcasecmp(*s, \"left\")) {\n            show_scrollbar = true;\n            gtk_box_reorder_child(GTK_BOX(hbox), scrollbar, 0);\n        } else if (!g_ascii_strcasecmp(*s, \"right\")) {\n            show_scrollbar = true;\n            gtk_box_reorder_child(GTK_BOX(hbox), scrollbar, -1);\n        }\n        g_free(*s);\n    }\n    if (show_scrollbar) {\n        gtk_widget_show(scrollbar);\n    } else {\n        gtk_widget_hide(scrollbar);\n    }\n    if (show_scrollbar_ptr != nullptr) {\n        *show_scrollbar_ptr = show_scrollbar;\n    }\n\n    load_theme(window, vte, config, info->hints);\n}/*}}}*/\n\nstatic void exit_with_status(VteTerminal *, int status) {\n    gtk_main_quit();\n    exit(WIFEXITED(status) ? WEXITSTATUS(status) : EXIT_FAILURE);\n}\n\nstatic void exit_with_success(VteTerminal *) {\n    gtk_main_quit();\n    exit(EXIT_SUCCESS);\n}\n\nstatic char *get_user_shell_with_fallback() {\n    if (const char *env = g_getenv(\"SHELL\") ) {\n        if (!((env != NULL) && (env[0] == '\\0')))\n            return g_strdup(env);\n    }\n\n    if (char *command = vte_get_user_shell()) {\n        if (!((command != NULL) && (command[0] == '\\0')))\n           return command;\n    }\n\n    return g_strdup(\"/bin/sh\");\n}\n\nstatic void on_alpha_screen_changed(GtkWindow *window, GdkScreen *, void *) {\n    GdkScreen *screen = gtk_widget_get_screen(GTK_WIDGET(window));\n    GdkVisual *visual = gdk_screen_get_rgba_visual(screen);\n\n    if (!visual)\n        visual = gdk_screen_get_system_visual(screen);\n\n    gtk_widget_set_visual(GTK_WIDGET(window), visual);\n}\n\nint main(int argc, char **argv) {\n    GError *error = nullptr;\n    const char *const term = \"xterm-termite\";\n    char *directory = nullptr;\n    gboolean version = FALSE, hold = FALSE;\n\n    GOptionContext *context = g_option_context_new(nullptr);\n    char *role = nullptr, *execute = nullptr, *config_file = nullptr;\n    char *title = nullptr, *icon = nullptr;\n    bool show_scrollbar = false;\n    const GOptionEntry entries[] = {\n        {\"version\", 'v', 0, G_OPTION_ARG_NONE, &version, \"Version info\", nullptr},\n        {\"exec\", 'e', 0, G_OPTION_ARG_STRING, &execute, \"Command to execute\", \"COMMAND\"},\n        {\"role\", 'r', 0, G_OPTION_ARG_STRING, &role, \"The role to use\", \"ROLE\"},\n        {\"title\", 't', 0, G_OPTION_ARG_STRING, &title, \"Window title\", \"TITLE\"},\n        {\"directory\", 'd', 0, G_OPTION_ARG_STRING, &directory, \"Change to directory\", \"DIRECTORY\"},\n        {\"hold\", 0, 0, G_OPTION_ARG_NONE, &hold, \"Remain open after child process exits\", nullptr},\n        {\"config\", 'c', 0, G_OPTION_ARG_STRING, &config_file, \"Path of config file\", \"CONFIG\"},\n        {\"icon\", 'i', 0, G_OPTION_ARG_STRING, &icon, \"Icon\", \"ICON\"},\n        {nullptr, 0, 0, G_OPTION_ARG_NONE, nullptr, nullptr, nullptr}\n    };\n    g_option_context_add_main_entries(context, entries, nullptr);\n    g_option_context_add_group(context, gtk_get_option_group(TRUE));\n\n    if (!g_option_context_parse(context, &argc, &argv, &error)) {\n        g_printerr(\"option parsing failed: %s\\n\", error->message);\n        g_clear_error (&error);\n        return EXIT_FAILURE;\n    }\n\n    g_option_context_free(context);\n\n    if (version) {\n        g_print(\"termite %s\\n\", TERMITE_VERSION);\n        return EXIT_SUCCESS;\n    }\n\n    if (directory) {\n        if (chdir(directory) == -1) {\n            perror(\"chdir\");\n            return EXIT_FAILURE;\n        }\n        g_free(directory);\n    }\n\n    GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n\n    GtkWidget *panel_overlay = gtk_overlay_new();\n    GtkWidget *hint_overlay = gtk_overlay_new();\n\n    GtkWidget *vte_widget = vte_terminal_new();\n    VteTerminal *vte = VTE_TERMINAL(vte_widget);\n\n    GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);\n    gtk_style_context_add_class(gtk_widget_get_style_context(hbox),\"termite\");\n    GtkWidget *scrollbar = gtk_scrollbar_new(GTK_ORIENTATION_VERTICAL, gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vte_widget)));\n    gtk_box_pack_start(GTK_BOX(hbox), hint_overlay, TRUE, TRUE, 0);\n    gtk_box_pack_start(GTK_BOX(hbox), scrollbar, FALSE, FALSE, 0);\n\n    if (role) {\n        gtk_window_set_role(GTK_WINDOW(window), role);\n        g_free(role);\n    }\n\n    char **command_argv;\n    char *default_argv[2] = {nullptr, nullptr};\n\n    if (execute) {\n        int argcp;\n        char **argvp;\n        g_shell_parse_argv(execute, &argcp, &argvp, &error);\n        if (error) {\n            g_printerr(\"failed to parse command: %s\\n\", error->message);\n            return EXIT_FAILURE;\n        }\n        command_argv = argvp;\n    } else {\n        default_argv[0] = get_user_shell_with_fallback();\n        command_argv = default_argv;\n    }\n\n    keybind_info info {\n        GTK_WINDOW(window), vte,\n        {gtk_entry_new(),\n         gtk_drawing_area_new(),\n         overlay_mode::hidden,\n         std::vector<url_data>(),\n         nullptr},\n        {vi_mode::insert, 0, 0, 0, 0},\n        {{nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0, 0, 0},\n         nullptr, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, -1, config_file, 0},\n        gtk_window_fullscreen\n    };\n\n    load_config(GTK_WINDOW(window), vte, scrollbar, hbox, &info.config,\n                icon ? nullptr : &icon, &show_scrollbar);\n\n    reload_config = [&]{\n        load_config(GTK_WINDOW(window), vte, scrollbar, hbox, &info.config,\n                    nullptr, nullptr);\n    };\n    signal(SIGUSR1, [](int){ reload_config(); });\n\n    GdkRGBA transparent {0, 0, 0, 0};\n\n    override_background_color(hint_overlay, &transparent);\n    override_background_color(info.panel.da, &transparent);\n\n    gtk_widget_set_halign(info.panel.da, GTK_ALIGN_FILL);\n    gtk_widget_set_valign(info.panel.da, GTK_ALIGN_FILL);\n    gtk_overlay_add_overlay(GTK_OVERLAY(hint_overlay), info.panel.da);\n\n    gtk_widget_set_margin_start(info.panel.entry, 5);\n    gtk_widget_set_margin_end(info.panel.entry, 5);\n    gtk_widget_set_margin_top(info.panel.entry, 5);\n    gtk_widget_set_margin_bottom(info.panel.entry, 5);\n    gtk_overlay_add_overlay(GTK_OVERLAY(panel_overlay), info.panel.entry);\n\n    gtk_widget_set_halign(info.panel.entry, GTK_ALIGN_START);\n    gtk_widget_set_valign(info.panel.entry, GTK_ALIGN_END);\n\n    gtk_container_add(GTK_CONTAINER(panel_overlay), hbox);\n    gtk_container_add(GTK_CONTAINER(hint_overlay), vte_widget);\n    gtk_container_add(GTK_CONTAINER(window), panel_overlay);\n\n    if (!hold) {\n        g_signal_connect(vte, \"child-exited\", G_CALLBACK(exit_with_status), nullptr);\n    }\n    g_signal_connect(window, \"destroy\", G_CALLBACK(exit_with_success), nullptr);\n    g_signal_connect(vte, \"key-press-event\", G_CALLBACK(key_press_cb), &info);\n    g_signal_connect(info.panel.entry, \"key-press-event\", G_CALLBACK(entry_key_press_cb), &info);\n    g_signal_connect(panel_overlay, \"get-child-position\", G_CALLBACK(position_overlay_cb), nullptr);\n    g_signal_connect(vte, \"button-press-event\", G_CALLBACK(button_press_cb), &info.config);\n    g_signal_connect(vte, \"bell\", G_CALLBACK(bell_cb), &info.config.urgent_on_bell);\n    draw_cb_info draw_cb_info{vte, &info.panel, &info.config.hints, info.config.filter_unmatched_urls};\n    g_signal_connect_swapped(info.panel.da, \"draw\", G_CALLBACK(draw_cb), &draw_cb_info);\n\n    g_signal_connect(window, \"focus-in-event\",  G_CALLBACK(focus_cb), nullptr);\n    g_signal_connect(window, \"focus-out-event\", G_CALLBACK(focus_cb), nullptr);\n\n    on_alpha_screen_changed(GTK_WINDOW(window), nullptr, nullptr);\n    g_signal_connect(window, \"screen-changed\", G_CALLBACK(on_alpha_screen_changed), nullptr);\n\n    if (info.config.fullscreen) {\n        g_signal_connect(window, \"window-state-event\", G_CALLBACK(window_state_cb), &info);\n    }\n\n    if (title) {\n        info.config.dynamic_title = FALSE;\n        gtk_window_set_title(GTK_WINDOW(window), title);\n        g_free(title);\n    } else {\n        g_signal_connect(vte, \"window-title-changed\", G_CALLBACK(window_title_cb),\n                         &info.config.dynamic_title);\n        if (execute) {\n            gtk_window_set_title(GTK_WINDOW(window), execute);\n        } else {\n            window_title_cb(vte, &info.config.dynamic_title);\n        }\n    }\n\n    if (icon) {\n        gtk_window_set_icon_name(GTK_WINDOW(window), icon);\n        g_free(icon);\n    }\n\n    gtk_widget_grab_focus(vte_widget);\n    gtk_widget_show_all(window);\n    gtk_widget_hide(info.panel.entry);\n    gtk_widget_hide(info.panel.da);\n    if (!show_scrollbar) {\n        gtk_widget_hide(scrollbar);\n    }\n\n    char **env = g_get_environ();\n\n#ifdef GDK_WINDOWING_X11\n    if (GDK_IS_X11_SCREEN(gtk_widget_get_screen(window))) {\n        GdkWindow *gdk_window = gtk_widget_get_window(window);\n        if (!gdk_window) {\n            g_printerr(\"no window\\n\");\n            return EXIT_FAILURE;\n        }\n        char xid_s[std::numeric_limits<long unsigned>::digits10 + 1];\n        snprintf(xid_s, sizeof(xid_s), \"%lu\", GDK_WINDOW_XID(gdk_window));\n        env = g_environ_setenv(env, \"WINDOWID\", xid_s, TRUE);\n    }\n#endif\n\n    env = g_environ_setenv(env, \"TERM\", term, TRUE);\n\n    GPid child_pid;\n    if (vte_terminal_spawn_sync(vte, VTE_PTY_DEFAULT, nullptr, command_argv, env,\n                                G_SPAWN_SEARCH_PATH, nullptr, nullptr, &child_pid, nullptr,\n                                &error)) {\n        vte_terminal_watch_child(vte, child_pid);\n    } else {\n        g_printerr(\"the command failed to run: %s\\n\", error->message);\n        return EXIT_FAILURE;\n    }\n\n    int width, height, padding_left, padding_top, padding_right, padding_bottom;\n    const long char_width = vte_terminal_get_char_width(vte);\n    const long char_height = vte_terminal_get_char_height(vte);\n\n    gtk_window_get_size(GTK_WINDOW(window), &width, &height);\n    get_vte_padding(vte, &padding_left, &padding_top, &padding_right, &padding_bottom);\n    vte_terminal_set_size(vte,\n                          (width - padding_left - padding_right) / char_width,\n                          (height - padding_top - padding_bottom) / char_height);\n\n    g_strfreev(env);\n\n    gtk_main();\n    return EXIT_FAILURE; // child process did not cause termination\n}\n\n// vim: et:sts=4:sw=4:cino=(0:cc=100\n"
        },
        {
          "name": "termite.desktop",
          "type": "blob",
          "size": 0.1669921875,
          "content": "[Desktop Entry]\nName=Termite\nComment=Use the command line\nExec=termite\nIcon=utilities-terminal\nType=Application\nCategories=GTK;System;TerminalEmulator;\nStartupNotify=true\n"
        },
        {
          "name": "termite.terminfo",
          "type": "blob",
          "size": 2.9482421875,
          "content": "# vim: noet:ts=8:sw=8:sts=0\nxterm-termite|VTE-based terminal,\n\tam,\n\tbce,\n\tccc,\n\tkm,\n\tmc5i,\n\tmir,\n\tmsgr,\n\tnpc,\n\txenl,\n\tcolors#256,\n\tcols#80,\n\tit#8,\n\tlines#24,\n\tpairs#32767,\n\tU8#1,\n\tacsc=++\\,\\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,\n\tbel=^G,\n\tbold=\\E[1m,\n\tcbt=\\E[Z,\n\tcivis=\\E[?25l,\n\tclear=\\E[H\\E[2J,\n\tcnorm=\\E[?12l\\E[?25h,\n\tcr=^M,\n\tcsr=\\E[%i%p1%d;%p2%dr,\n\tcub=\\E[%p1%dD,\n\tcub1=^H,\n\tcud=\\E[%p1%dB,\n\tcud1=^J,\n\tcuf=\\E[%p1%dC,\n\tcuf1=\\E[C,\n\tcup=\\E[%i%p1%d;%p2%dH,\n\tcuu=\\E[%p1%dA,\n\tcuu1=\\E[A,\n\tcvvis=\\E[?12;25h,\n\tdch=\\E[%p1%dP,\n\tdch1=\\E[P,\n\tdim=\\E[2m,\n\tdl=\\E[%p1%dM,\n\tdl1=\\E[M,\n\tech=\\E[%p1%dX,\n\ted=\\E[J,\n\tel=\\E[K,\n\tel1=\\E[1K,\n\tflash=\\E[?5h$<100/>\\E[?5l,\n\thome=\\E[H,\n\thpa=\\E[%i%p1%dG,\n\tht=^I,\n\thts=\\EH,\n\tich=\\E[%p1%d@,\n\til=\\E[%p1%dL,\n\til1=\\E[L,\n\tind=^J,\n\tindn=\\E[%p1%dS,\n\tinitc=\\E]4;%p1%d;rgb\\:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\\E\\\\,\n\tinvis=\\E[8m,\n\tis2=\\E[!p\\E[?3;4l\\E[4l\\E>,\n\tkDC=\\E[3;2~,\n\tkEND=\\E[1;2F,\n\tkHOM=\\E[1;2H,\n\tkIC=\\E[2;2~,\n\tkLFT=\\E[1;2D,\n\tkNXT=\\E[6;2~,\n\tkPRV=\\E[5;2~,\n\tkRIT=\\E[1;2C,\n\tkb2=\\EOE,\n\tkbs=\\177,\n\tkcbt=\\E[Z,\n\tkcub1=\\EOD,\n\tkcud1=\\EOB,\n\tkcuf1=\\EOC,\n\tkcuu1=\\EOA,\n\tkdch1=\\E[3~,\n\tkend=\\EOF,\n\tkent=\\EOM,\n\tkf1=\\EOP,\n\tkf10=\\E[21~,\n\tkf11=\\E[23~,\n\tkf12=\\E[24~,\n\tkf13=\\E[1;2P,\n\tkf14=\\E[1;2Q,\n\tkf15=\\E[1;2R,\n\tkf16=\\E[1;2S,\n\tkf17=\\E[15;2~,\n\tkf18=\\E[17;2~,\n\tkf19=\\E[18;2~,\n\tkf2=\\EOQ,\n\tkf20=\\E[19;2~,\n\tkf21=\\E[20;2~,\n\tkf22=\\E[21;2~,\n\tkf23=\\E[23;2~,\n\tkf24=\\E[24;2~,\n\tkf25=\\E[1;5P,\n\tkf26=\\E[1;5Q,\n\tkf27=\\E[1;5R,\n\tkf28=\\E[1;5S,\n\tkf29=\\E[15;5~,\n\tkf3=\\EOR,\n\tkf30=\\E[17;5~,\n\tkf31=\\E[18;5~,\n\tkf32=\\E[19;5~,\n\tkf33=\\E[20;5~,\n\tkf34=\\E[21;5~,\n\tkf35=\\E[23;5~,\n\tkf36=\\E[24;5~,\n\tkf37=\\E[1;6P,\n\tkf38=\\E[1;6Q,\n\tkf39=\\E[1;6R,\n\tkf4=\\EOS,\n\tkf40=\\E[1;6S,\n\tkf41=\\E[15;6~,\n\tkf42=\\E[17;6~,\n\tkf43=\\E[18;6~,\n\tkf44=\\E[19;6~,\n\tkf45=\\E[20;6~,\n\tkf46=\\E[21;6~,\n\tkf47=\\E[23;6~,\n\tkf48=\\E[24;6~,\n\tkf49=\\E[1;3P,\n\tkf5=\\E[15~,\n\tkf50=\\E[1;3Q,\n\tkf51=\\E[1;3R,\n\tkf52=\\E[1;3S,\n\tkf53=\\E[15;3~,\n\tkf54=\\E[17;3~,\n\tkf55=\\E[18;3~,\n\tkf56=\\E[19;3~,\n\tkf57=\\E[20;3~,\n\tkf58=\\E[21;3~,\n\tkf59=\\E[23;3~,\n\tkf6=\\E[17~,\n\tkf60=\\E[24;3~,\n\tkf61=\\E[1;4P,\n\tkf62=\\E[1;4Q,\n\tkf63=\\E[1;4R,\n\tkf7=\\E[18~,\n\tkf8=\\E[19~,\n\tkf9=\\E[20~,\n\tkhome=\\EOH,\n\tkich1=\\E[2~,\n\tkind=\\E[1;2B,\n\tkmous=\\E[M,\n\tknp=\\E[6~,\n\tkpp=\\E[5~,\n\tkri=\\E[1;2A,\n\tmc0=\\E[i,\n\tmc4=\\E[4i,\n\tmc5=\\E[5i,\n\tmeml=\\El,\n\tmemu=\\Em,\n\top=\\E[39;49m,\n\trc=\\E8,\n\trev=\\E[7m,\n\tri=\\EM,\n\trin=\\E[%p1%dT,\n\trmacs=\\E(B,\n\trmam=\\E[?7l,\n\trmcup=\\E[?1049l,\n\trmir=\\E[4l,\n\trmkx=\\E[?1l\\E>,\n\trmm=\\E[?1034l,\n\trmso=\\E[27m,\n\trmul=\\E[24m,\n\trs1=\\Ec,\n\trs2=\\E[!p\\E[?3;4l\\E[4l\\E>,\n\tsc=\\E7,\n\tsetab=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,\n\tsetaf=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,\n\tsgr=%?%p9%t\\E(0%e\\E(B%;\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m,\n\tsgr0=\\E(B\\E[m,\n\tsmacs=\\E(0,\n\tsmam=\\E[?7h,\n\tsmcup=\\E[?1049h,\n\tsmir=\\E[4h,\n\tsmkx=\\E[?1h\\E=,\n\tsmm=\\E[?1034h,\n\tsmso=\\E[7m,\n\tsmul=\\E[4m,\n\ttbc=\\E[3g,\n\tu6=\\E[%i%d;%dR,\n\tu7=\\E[6n,\n\tu8=\\E[?1;2c,\n\tu9=\\E[c,\n\tvpa=\\E[%i%p1%dd,\n\ths,\n\ttsl=\\E]2;,\n\tfsl=^G,\n\tdsl=\\E]2;\\007,\n\tsitm=\\E[3m,\n\tritm=\\E[23m,\n"
        },
        {
          "name": "url_regex.hh",
          "type": "blob",
          "size": 0.6279296875,
          "content": "#ifndef URL_REGEX_HH\n#define URL_REGEX_HH\n\n#define USERCHARS       \"-[:alnum:]\"\n#define USERCHARS_CLASS \"[\" USERCHARS \"]\"\n#define PASSCHARS_CLASS \"[-[:alnum:]\\\\Q,?;.!%$^*&~\\\"#'\\\\E]\"\n#define HOSTCHARS_CLASS \"[-[:alnum:]]\"\n#define HOST            \"(?:\" HOSTCHARS_CLASS \"+(\\\\.\" HOSTCHARS_CLASS \"+)*)?\"\n#define PORT            \"(?:\\\\:[[:digit:]]{1,5})?\"\n#define SCHEME          \"(?:[[:alpha:]][+-.[:alnum:]]*:)\"\n#define USERPASS        USERCHARS_CLASS \"+(?:\\\\:\" PASSCHARS_CLASS \"+)?\"\n#define URLPATH         \"(?:/[[:alnum:]\\\\Q-_.!~*'();/?:@&=+$,#%\\\\E]*)?\"\n\nconst char * const url_regex = SCHEME \"//(?:\" USERPASS \"\\\\@)?\" HOST PORT URLPATH;\n\n#endif\n"
        },
        {
          "name": "util",
          "type": "commit",
          "content": null
        }
      ]
    }
  ]
}