{
  "metadata": {
    "timestamp": 1736565517748,
    "page": 388,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/nsjail",
      "stars": 3025,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.28515625,
          "content": "BasedOnStyle: Google\nColumnLimit: 100\nIndentWidth: 8\nUseTab: Always\n---\nLanguage: Cpp\nAlignAfterOpenBracket: DontAlign\nAlignEscapedNewlines: Right\nAlignOperands: true\nAllowShortFunctionsOnASingleLine: false\nAlwaysBreakBeforeMultilineStrings: false\nIndentCaseLabels: false\n---\nLanguage: Proto\n"
        },
        {
          "name": ".clangd",
          "type": "blob",
          "size": 0.1240234375,
          "content": "CompileFlags:\n  Add: [-std=c++17, -Ikafel/include, -I/usr/include/libnl3, -fno-exceptions, -Wno-unused, -Wno-unused-parameter]\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.03515625,
          "content": "*.o\nconfig.pb.h\nconfig.pb.cc\nnsjail\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0751953125,
          "content": "[submodule \"kafel\"]\n\tpath = kafel\n\turl = https://github.com/google/kafel.git\n"
        },
        {
          "name": "CONTRIBUTING",
          "type": "blob",
          "size": 1.3623046875,
          "content": "Want to contribute? Great! First, read this page (including the small print at the end).\n\n### Before you contribute\nBefore we can use your code, you must sign the\n[Google Individual Contributor License Agreement](https://developers.google.com/open-source/cla/individual?csw=1)\n(CLA), which you can do online. The CLA is necessary mainly because you own the\ncopyright to your changes, even after your contribution becomes part of our\ncodebase, so we need your permission to use and distribute your code. We also\nneed to be sure of various other thingsâ€”for instance that you'll tell us if you\nknow that your code infringes on other people's patents. You don't have to sign\nthe CLA until after you've submitted your code for review and a member has\napproved it, but you must do it before we can put your code into our codebase.\nBefore you start working on a larger contribution, you should get in touch with\nus first through the issue tracker with your idea so that we can help out and\npossibly guide you. Coordinating up front makes it much easier to avoid\nfrustration later on.\n\n### Code reviews\nAll submissions, including submissions by project members, require review. We\nuse Github pull requests for this purpose.\n\n### The small print\nContributions made by corporations are covered by a different agreement than\nthe one above, the Software Grant and Corporate Contributor License Agreement.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.640625,
          "content": "FROM debian:bookworm-slim AS base\n\n# Install run-time dependencies in base image\nRUN apt-get -y update && apt-get install -y \\\n    libc6 \\\n    libstdc++6 \\\n    libprotobuf32 \\\n    libnl-route-3-200\n\nFROM base AS build\n\n# Install build dependencies only in builder image\nRUN apt-get install -y \\\n    autoconf \\\n    bison \\\n    flex \\\n    gcc \\\n    g++ \\\n    git \\\n    libprotobuf-dev \\\n    libnl-route-3-dev \\\n    libtool \\\n    make \\\n    pkg-config \\\n    protobuf-compiler\n\nCOPY . /nsjail\n\nRUN cd /nsjail && make clean && make\n\nFROM base AS run\n\n# Copy over build result and trim image\nRUN rm -rf /var/lib/apt/lists/*\nCOPY --from=build /nsjail/nsjail /bin\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.2451171875,
          "content": "#\n#   nsjail - Makefile\n#   -----------------------------------------\n#\n#   Copyright 2014 Google Inc. All Rights Reserved.\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n\nPKG_CONFIG=$(shell command -v pkg-config 2> /dev/null)\nifeq ($(PKG_CONFIG),)\n$(error \"Install pkg-config to make it work\")\nendif\n\nCC ?= gcc\nCXX ?= g++\n\nCOMMON_FLAGS += -O2 -c \\\n\t-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 \\\n\t-fPIE \\\n\t-Wformat -Wformat-security -Wno-format-nonliteral \\\n\t-Wall -Wextra -Werror \\\n\t-Ikafel/include\n\nCXXFLAGS += $(USER_DEFINES) $(COMMON_FLAGS) $(shell pkg-config --cflags protobuf) \\\n\t-std=c++17 -fno-exceptions -Wno-unused -Wno-unused-parameter\nLDFLAGS += -pie -Wl,-z,noexecstack -lpthread $(shell pkg-config --libs protobuf)\n\nBIN = nsjail\nLIBS = kafel/libkafel.a\nSRCS_CXX = caps.cc cgroup.cc cgroup2.cc cmdline.cc config.cc contain.cc cpu.cc logs.cc mnt.cc net.cc nsjail.cc pid.cc sandbox.cc subproc.cc uts.cc user.cc util.cc\nSRCS_H = $(SRCS_CXX:.cc=.h) macros.h\nSRCS_PROTO = config.proto\nSRCS_PB_CXX = $(SRCS_PROTO:.proto=.pb.cc)\nSRCS_PB_H = $(SRCS_PROTO:.proto=.pb.h)\nSRCS_PB_O = $(SRCS_PROTO:.proto=.pb.o)\nOBJS = $(SRCS_CXX:.cc=.o) $(SRCS_PB_CXX:.cc=.o)\n\nifdef DEBUG\n\tCXXFLAGS += -g -ggdb -gdwarf-4\nendif\n\nNL3_EXISTS := $(shell pkg-config --exists libnl-route-3.0 && echo yes)\nifeq ($(NL3_EXISTS), yes)\n\tCXXFLAGS += $(shell pkg-config --cflags libnl-route-3.0)\n\tLDFLAGS += $(shell pkg-config --libs libnl-route-3.0)\nendif\n\n.PHONY: all clean depend indent\n\n.o: %.cc\n\t$(CXX) $(CXXFLAGS) $< -o $@\n\nall: $(BIN)\n\n$(BIN): $(LIBS) $(OBJS)\nifneq ($(NL3_EXISTS), yes)\n\t$(warning \"============================================================\")\n\t$(warning \"You probably miss libnl3(-dev)/libnl-route-3(-dev) libraries\")\n\t$(warning \"============================================================\")\nendif\n\t$(CXX) -o $(BIN) $(OBJS) $(LIBS) $(LDFLAGS)\n\n.PHONY: kafel_init\nkafel_init:\nifeq (\"$(wildcard kafel/Makefile)\",\"\")\n\tgit submodule update --init\nendif\n\nkafel/include/kafel.h: kafel_init\n# LDFLAGS is unset as a workaround for Kafel using the parent LDFLAGS\n# incorrectly.\nkafel/libkafel.a: kafel_init\n\tLDFLAGS=\"\" CFLAGS=-fPIE $(MAKE) -C kafel\n\n# Sequence of proto deps, which doesn't fit automatic make rules\n$(SRCS_PB_O): $(SRCS_PB_H) $(SRCS_PB_CXX)\n$(SRCS_PB_CXX) $(SRCS_PB_H): $(SRCS_PROTO)\n\tprotoc --cpp_out=. $(SRCS_PROTO)\n\n.PHONY: clean\nclean:\n\t$(RM) core Makefile.bak $(OBJS) $(SRCS_PB_CXX) $(SRCS_PB_H) $(SRCS_PB_O) $(BIN)\nifneq (\"$(wildcard kafel/Makefile)\",\"\")\n\t$(MAKE) -C kafel clean\nendif\n\n.PHONY: depend\ndepend: all\n\tmakedepend -Y -Ykafel/include -- -- $(SRCS_CXX) $(SRCS_PB_CXX)\n\n.PHONY: indent\nindent:\n\tclang-format -i -sort-includes $(SRCS_H) $(SRCS_CXX) $(SRCS_PROTO) configs/*.json\n\n# DO NOT DELETE THIS LINE -- make depend depends on it.\n\ncaps.o: caps.h nsjail.h logs.h macros.h util.h\ncgroup.o: cgroup.h nsjail.h logs.h util.h\ncgroup2.o: cgroup2.h nsjail.h logs.h util.h\ncmdline.o: cmdline.h nsjail.h caps.h config.h logs.h macros.h mnt.h user.h\ncmdline.o: util.h\nconfig.o: config.h nsjail.h caps.h cmdline.h config.pb.h logs.h macros.h\nconfig.o: mnt.h user.h util.h\ncontain.o: contain.h nsjail.h caps.h cgroup.h cpu.h logs.h macros.h mnt.h\ncontain.o: net.h pid.h user.h util.h uts.h\ncpu.o: cpu.h nsjail.h logs.h util.h\nlogs.o: logs.h macros.h util.h nsjail.h\nmnt.o: mnt.h nsjail.h logs.h macros.h subproc.h util.h\nnet.o: net.h nsjail.h logs.h subproc.h\nnsjail.o: nsjail.h cgroup2.h cmdline.h logs.h macros.h net.h sandbox.h\nnsjail.o: subproc.h util.h\npid.o: pid.h nsjail.h logs.h subproc.h\nsandbox.o: sandbox.h nsjail.h kafel/include/kafel.h logs.h util.h\nsubproc.o: subproc.h nsjail.h cgroup.h cgroup2.h contain.h logs.h macros.h\nsubproc.o: net.h sandbox.h user.h util.h\nuts.o: uts.h nsjail.h logs.h\nuser.o: user.h nsjail.h logs.h macros.h subproc.h util.h\nutil.o: util.h nsjail.h logs.h macros.h\nconfig.pb.o: config.pb.h\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 28.478515625,
          "content": "- [Overview](#overview)\n- [What forms of isolation does it provide](#what-forms-of-isolation-does-it-provide)\n- Which use-cases are supported\n  * [Isolation of network services (inetd style)](#isolation-of-network-services-inetd-style)\n  * [Isolation with access to a private, cloned interface (requires root/setuid)](#isolation-with-access-to-a-private-cloned-interface-requires-rootsetuid)\n  * [Isolation of local processes](#isolation-of-local-processes)\n  * [Isolation of local processes (and re-running them, if necessary)](#isolation-of-local-processes-and-re-running-them-if-necessary)\n- Examples of use\n  * [Bash in a minimal file-system with uid==0 and access to /dev/urandom only](#bash-in-a-minimal-file-system-with-uid0-and-access-to-devurandom-only)\n  * [/usr/bin/find in a minimal file-system (only /usr/bin/find accessible from /usr/bin)](#usrbinfind-in-a-minimal-file-system-only-usrbinfind-accessible-from-usrbin)\n  * [Using /etc/subuid](#using-etcsubuid)\n  * [Even more contrained shell (with seccomp-bpf policies)](#even-more-contrained-shell-with-seccomp-bpf-policies)\n- [Configuration file](#configuration-file)\n- [More info](#more-info)\n- [Launching in Docker](#launching-in-docker)\n- [Contact](#contact)\n\n***\nThis is NOT an official Google product.\n\n***\n\n### Overview\nNsJail is a process isolation tool for Linux. It utilizes Linux namespace subsystem, resource limits, and the seccomp-bpf syscall filters of the Linux kernel.\n\nIt can help you with (among other things):\n  * Isolating __networking services__ (e.g. web, time, DNS), by isolating them from the rest of the OS\n  * Hosting computer security challenges (so-called __CTFs__)\n  * Containing invasive syscall-level OS __fuzzers__\n\nFeatures:\n  - [x]  Offers three __distinct operational modes__. See [this section](#which-use-cases-are-supported) for more info.\n  - [x]  Utilizes [kafel seccomp-bpf configuration language](https://github.com/google/kafel/) for __flexible syscall policy definitions__.\n  - [x]  Uses expressive, ProtoBuf-based [configuration file](#configuration-file)\n  - [x]  It's __rock-solid__.\n\n***\n### What forms of isolation does it provide\n1. Linux __namespaces__: UTS (hostname), MOUNT (chroot), PID (separate PID tree), IPC, NET (separate networking context), USER, CGROUPS\n2. __FS constraints__: chroot(), pivot_root(), RO-remounting, custom ```/proc``` and ```tmpfs``` mount points\n3. __Resource limits__ (wall-time/CPU time limits, VM/mem address space limits, etc.)\n4. Programmable seccomp-bpf __syscall filters__ (through the [kafel language](https://github.com/google/kafel/))\n5. Cloned and isolated __Ethernet interfaces__\n6. __Cgroups__ for memory and PID utilization control\n\n***\n### Which use-cases are supported\n#### Isolation of network services (inetd style)\n\n_PS: You'll need to have a valid file-system tree in ```/chroot```. If you don't have it, change ```/chroot``` to ```/```_\n\n+ Server:\n<pre>\n $ ./nsjail -Ml --port 9000 --chroot /chroot/ --user 99999 --group 99999 -- /bin/sh -i\n</pre>\n\n+ Client:\n<pre>\n $ nc 127.0.0.1 9000\n / $ ifconfig\n / $ ifconfig -a\n lo    Link encap:Local Loopback\n       LOOPBACK  MTU:65536  Metric:1\n       RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n       TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0\n       RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n / $ ps wuax\n PID   USER     COMMAND\n 1 99999    /bin/sh -i\n 3 99999    {busybox} ps wuax\n / $\n\n</pre>\n\n#### Isolation with access to a private, cloned interface (requires root/setuid)\n\n_PS: You'll need to have a valid file-system tree in ```/chroot```. If you don't have it, change ```/chroot``` to ```/```_\n\n<pre>\n$ sudo ./nsjail --user 9999 --group 9999 --macvlan_iface eth0 --chroot /chroot/ -Mo --macvlan_vs_ip 192.168.0.44 --macvlan_vs_nm 255.255.255.0 --macvlan_vs_gw 192.168.0.1 -- /bin/sh -i\n/ $ id\nuid=9999 gid=9999\n/ $ ip addr sh\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: vs: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue \n    link/ether ca:a2:69:21:33:66 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.0.44/24 brd 192.168.0.255 scope global vs\n       valid_lft forever preferred_lft forever\n    inet6 fe80::c8a2:69ff:fe21:cd66/64 scope link \n       valid_lft forever preferred_lft forever\n/ $ nc 217.146.165.209 80\nGET / HTTP/1.0\n\nHTTP/1.0 302 Found\nCache-Control: private\nContent-Type: text/html; charset=UTF-8\nLocation: https://www.google.ch/?gfe_rd=cr&ei=cEzWVrG2CeTI8ge88ofwDA\nContent-Length: 258\nDate: Wed, 02 Mar 2016 02:14:08 GMT\n\n...\n...\n/ $ \n</pre>\n\n#### Isolation of local processes\n\n_PS: You'll need to have a valid file-system tree in ```/chroot```. If you don't have it, change ```/chroot``` to ```/```_\n\n<pre>\n $ ./nsjail -Mo --chroot /chroot/ --user 99999 --group 99999 -- /bin/sh -i\n / $ ifconfig -a\n lo    Link encap:Local Loopback\n       LOOPBACK  MTU:65536  Metric:1\n       RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n       TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0\n       RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n / $ id\n uid=99999 gid=99999\n / $ ps wuax\n PID   USER     COMMAND\n 1 99999    /bin/sh -i\n 4 99999    {busybox} ps wuax\n / $exit\n $\n</pre>\n\n#### Isolation of local processes (and re-running them, if necessary)\n\n_PS: You'll need to have a valid file-system tree in ```/chroot```. If you don't have it, change ```/chroot``` to ```/```_\n\n<pre>\n $ ./nsjail -Mr --chroot /chroot/ --user 99999 --group 99999 -- /bin/sh -i\n BusyBox v1.21.1 (Ubuntu 1:1.21.0-1ubuntu1) built-in shell (ash)\n Enter 'help' for a list of built-in commands.\n / $ ps wuax\n PID   USER     COMMAND\n 1 99999    /bin/sh -i\n 2 99999    {busybox} ps wuax\n / $ exit\n BusyBox v1.21.1 (Ubuntu 1:1.21.0-1ubuntu1) built-in shell (ash)\n Enter 'help' for a list of built-in commands.\n / $ ps wuax\n PID   USER     COMMAND\n 1 99999    /bin/sh -i\n 2 99999    {busybox} ps wuax\n / $\n</pre>\n\n### Bash in a minimal file-system with uid==0 and access to /dev/urandom only\n\n<pre>\n$ ./nsjail -Mo --user 0 --group 99999 -R /bin/ -R /lib -R /lib64/ -R /usr/ -R /sbin/ -T /dev -R /dev/urandom --keep_caps -- /bin/bash -i\n[2017-05-24T17:08:02+0200] Mode: STANDALONE_ONCE\n[2017-05-24T17:08:02+0200] Jail parameters: hostname:'NSJAIL', chroot:'(null)', process:'/bin/bash', bind:[::]:0, max_conns_per_ip:0, time_limit:0, personality:0, daemonize:false, clone_newnet:true, clone_newuser:true, clone_newns:true, clone_newpid:true, clone_newipc:true, clonew_newuts:true, clone_newcgroup:false, keep_caps:true, tmpfs_size:4194304, disable_no_new_privs:false, pivot_root_only:false\n[2017-05-24T17:08:02+0200] Mount point: src:'none' dst:'/' type:'tmpfs' flags:MS_RDONLY|0 options:'' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'none' dst:'/proc' type:'proc' flags:MS_RDONLY|0 options:'' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'/bin/' dst:'/bin/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'/lib' dst:'/lib' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'/lib64/' dst:'/lib64/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'/usr/' dst:'/usr/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'/sbin/' dst:'/sbin/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'none' dst:'/dev' type:'tmpfs' flags:0 options:'size=4194304' isDir:True\n[2017-05-24T17:08:02+0200] Mount point: src:'/dev/urandom' dst:'/dev/urandom' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:False\n[2017-05-24T17:08:02+0200] Uid map: inside_uid:0 outside_uid:69664\n[2017-05-24T17:08:02+0200] Gid map: inside_gid:99999 outside_gid:5000\n[2017-05-24T17:08:02+0200] Executing '/bin/bash' for '[STANDALONE_MODE]'\nbash: cannot set terminal process group (-1): Inappropriate ioctl for device\nbash: no job control in this shell\nbash-4.3# ls -l\ntotal 28\ndrwxr-xr-x   2 65534 65534  4096 May 15 14:04 bin\ndrwxrwxrwt   2     0 99999    60 May 24 15:08 dev\ndrwxr-xr-x  28 65534 65534  4096 May 15 14:10 lib\ndrwxr-xr-x   2 65534 65534  4096 May 15 13:56 lib64\ndr-xr-xr-x 391 65534 65534     0 May 24 15:08 proc\ndrwxr-xr-x   2 65534 65534 12288 May 15 14:16 sbin\ndrwxr-xr-x  17 65534 65534  4096 May 15 13:58 usr\nbash-4.3# id\nuid=0 gid=99999 groups=65534,99999\nbash-4.3# exit\nexit\n[2017-05-24T17:08:05+0200] PID: 129839 exited with status: 0, (PIDs left: 0)\n</pre>\n\n### /usr/bin/find in a minimal file-system (only /usr/bin/find accessible from /usr/bin)\n\n<pre>\n$ ./nsjail -Mo --user 99999 --group 99999 -R /lib/x86_64-linux-gnu/ -R /lib/x86_64-linux-gnu -R /lib64 -R /usr/bin/find -R /dev/urandom --keep_caps -- /usr/bin/find / | wc -l\n[2017-05-24T17:04:37+0200] Mode: STANDALONE_ONCE\n[2017-05-24T17:04:37+0200] Jail parameters: hostname:'NSJAIL', chroot:'(null)', process:'/usr/bin/find', bind:[::]:0, max_conns_per_ip:0, time_limit:0, personality:0, daemonize:false, clone_newnet:true, clone_newuser:true, clone_newns:true, clone_newpid:true, clone_newipc:true, clonew_newuts:true, clone_newcgroup:false, keep_caps:true, tmpfs_size:4194304, disable_no_new_privs:false, pivot_root_only:false\n[2017-05-24T17:04:37+0200] Mount point: src:'none' dst:'/' type:'tmpfs' flags:MS_RDONLY|0 options:'' isDir:True\n[2017-05-24T17:04:37+0200] Mount point: src:'none' dst:'/proc' type:'proc' flags:MS_RDONLY|0 options:'' isDir:True\n[2017-05-24T17:04:37+0200] Mount point: src:'/lib/x86_64-linux-gnu/' dst:'/lib/x86_64-linux-gnu/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:04:37+0200] Mount point: src:'/lib/x86_64-linux-gnu' dst:'/lib/x86_64-linux-gnu' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:04:37+0200] Mount point: src:'/lib64' dst:'/lib64' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:04:37+0200] Mount point: src:'/usr/bin/find' dst:'/usr/bin/find' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:False\n[2017-05-24T17:04:37+0200] Mount point: src:'/dev/urandom' dst:'/dev/urandom' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:False\n[2017-05-24T17:04:37+0200] Uid map: inside_uid:99999 outside_uid:69664\n[2017-05-24T17:04:37+0200] Gid map: inside_gid:99999 outside_gid:5000\n[2017-05-24T17:04:37+0200] Executing '/usr/bin/find' for '[STANDALONE_MODE]'\n/usr/bin/find: `/proc/tty/driver': Permission denied\n2289\n[2017-05-24T17:04:37+0200] PID: 129525 exited with status: 1, (PIDs left: 0)\n</pre>\n\n### Using /etc/subuid\n\n<pre>\n$ tail -n1 /etc/subuid\nuser:10000000:1\n$ ./nsjail -R /lib -R /lib64/ -R /usr/lib -R /usr/bin/ -R /usr/sbin/ -R /bin/ -R /sbin/ -R /dev/null -U 0:10000000:1 -u 0 -R /tmp/ -T /tmp/ -- /bin/ls -l /usr/\n[2017-05-24T17:12:31+0200] Mode: STANDALONE_ONCE\n[2017-05-24T17:12:31+0200] Jail parameters: hostname:'NSJAIL', chroot:'(null)', process:'/bin/ls', bind:[::]:0, max_conns_per_ip:0, time_limit:0, personality:0, daemonize:false, clone_newnet:true, clone_newuser:true, clone_newns:true, clone_newpid:true, clone_newipc:true, clonew_newuts:true, clone_newcgroup:false, keep_caps:false, tmpfs_size:4194304, disable_no_new_privs:false, pivot_root_only:false\n[2017-05-24T17:12:31+0200] Mount point: src:'none' dst:'/' type:'tmpfs' flags:MS_RDONLY|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'none' dst:'/proc' type:'proc' flags:MS_RDONLY|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/lib' dst:'/lib' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/lib64/' dst:'/lib64/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/usr/lib' dst:'/usr/lib' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/usr/bin/' dst:'/usr/bin/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/usr/sbin/' dst:'/usr/sbin/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/bin/' dst:'/bin/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/sbin/' dst:'/sbin/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'/dev/null' dst:'/dev/null' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:False\n[2017-05-24T17:12:31+0200] Mount point: src:'/tmp/' dst:'/tmp/' type:'' flags:MS_RDONLY|MS_BIND|MS_REC|0 options:'' isDir:True\n[2017-05-24T17:12:31+0200] Mount point: src:'none' dst:'/tmp/' type:'tmpfs' flags:0 options:'size=4194304' isDir:True\n[2017-05-24T17:12:31+0200] Uid map: inside_uid:0 outside_uid:69664\n[2017-05-24T17:12:31+0200] Gid map: inside_gid:5000 outside_gid:5000\n[2017-05-24T17:12:31+0200] Newuid mapping: inside_uid:'0' outside_uid:'10000000' count:'1'\n[2017-05-24T17:12:31+0200] Executing '/bin/ls' for '[STANDALONE_MODE]'\ntotal 120\ndrwxr-xr-x   5 65534 65534 77824 May 24 12:25 bin\ndrwxr-xr-x 210 65534 65534 20480 May 22 16:11 lib\ndrwxr-xr-x   4 65534 65534 20480 May 24 00:24 sbin\n[2017-05-24T17:12:31+0200] PID: 130841 exited with status: 0, (PIDs left: 0)\n</pre>\n\n### Even more contrained shell (with seccomp-bpf policies)\n\n<pre>\n$ ./nsjail --chroot / --seccomp_string 'ALLOW { write, execve, brk, access, mmap, open, openat, newfstat, close, read, mprotect, arch_prctl, munmap, getuid, getgid, getpid, rt_sigaction, geteuid, getppid, getcwd, getegid, ioctl, fcntl, newstat, clone, wait4, rt_sigreturn, exit_group } DEFAULT KILL' -- /bin/sh -i\n[2017-01-15T21:53:08+0100] Mode: STANDALONE_ONCE\n[2017-01-15T21:53:08+0100] Jail parameters: hostname:'NSJAIL', chroot:'/', process:'/bin/sh', bind:[::]:0, max_conns_per_ip:0, uid:(ns:1000, global:1000), gid:(ns:1000, global:1000), time_limit:0, personality:0, daemonize:false, clone_newnet:true, clone_newuser:true, clone_newns:true, clone_newpid:true, clone_newipc:true, clonew_newuts:true, clone_newcgroup:false, keep_caps:false, tmpfs_size:4194304, disable_no_new_privs:false, pivot_root_only:false\n[2017-01-15T21:53:08+0100] Mount point: src:'/' dst:'/' type:'' flags:0x5001 options:''\n[2017-01-15T21:53:08+0100] Mount point: src:'(null)' dst:'/proc' type:'proc' flags:0x0 options:''\n[2017-01-15T21:53:08+0100] PID: 18873 about to execute '/bin/sh' for [STANDALONE_MODE]\n/bin/sh: 0: can't access tty; job control turned off\n$ set\nIFS='\n'\nOPTIND='1'\nPATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\nPPID='0'\nPS1='$ '\nPS2='> '\nPS4='+ '\nPWD='/'\n$ id\nBad system call\n$ exit\n[2017-01-15T21:53:17+0100] PID: 18873 exited with status: 159, (PIDs left: 0)\n</pre>\n\n***\n### Configuration file\n\nYou will also find all examples in the [configs](https://github.com/google/nsjail/blob/master/configs) directory.\n\n***\n\n[config.proto](https://github.com/google/nsjail/blob/master/config.proto) contains ProtoBuf schema for nsjail's configuration format.\n\n***\n\nYou can examine an example config file in [configs/bash-with-fake-geteuid.cfg](https://github.com/google/nsjail/blob/master/configs/bash-with-fake-geteuid.cfg).\n\nUsage:\n<pre>\n$ ./nsjail --config configs/bash-with-fake-geteuid.cfg\n</pre>\n\nYou can also override certain options with command-line options. Here, the executed binary (_/bin/bash_) is overriden with _/usr/bin/id_, yet options from _configs/bash-with-fake-geteuid.cfg_ still apply\n<pre>\n$ ./nsjail --config configs/bash-with-fake-geteuid.cfg -- /usr/bin/id\n...\n[INSIDE-JAIL]: id\nuid=999999 gid=999998 euid=4294965959 groups=999998,65534\n[INSIDE-JAIL]: exit\n[2017-05-27T18:45:40+0200] PID: 16579 exited with status: 0, (PIDs left: 0)\n</pre>\n\n***\n\nYou might also want to try using [configs/home-documents-with-xorg-no-net.cfg](https://github.com/google/nsjail/blob/master/configs/home-documents-with-xorg-no-net.cfg).\n\n<pre>\n$ ./nsjail --config configs/home-documents-with-xorg-no-net.cfg -- /usr/bin/evince /user/Documents/doc.pdf\n$ ./nsjail --config configs/home-documents-with-xorg-no-net.cfg -- /usr/bin/geeqie /user/Documents/\n$ ./nsjail --config configs/home-documents-with-xorg-no-net.cfg -- /usr/bin/gv /user/Documents/doc.pdf\n$ ./nsjail --config configs/home-documents-with-xorg-no-net.cfg -- /usr/bin/mupdf /user/Documents/doc.pdf\n</pre>\n\n***\n\nThe [configs/firefox-with-net.cfg](https://github.com/google/nsjail/blob/master/configs/firefox-with-net.cfg)\nconfig file will allow you to run firefox inside a sandboxed environment:\n\n<pre>\n$ ./nsjail --config configs/firefox-with-net.cfg\n</pre>\n\nA more complex setup, which utilizes virtualized (cloned) Ethernet\ninterfaces (to separate it from the main network namespace), can be\nfound in [configs/firefox-with-cloned-net.cfg](https://github.com/google/nsjail/blob/master/configs/firefox-with-cloned-net.cfg).\nRemember to change relevant UIDs and Ethernet interface names before use.\n\nAs using cloned Ethernet interfaces (MACVTAP) required root privileges, you'll\nhave to run it under sudo:\n\n<pre>\n$ sudo ./nsjail --config configs/firefox-with-cloned-net.cfg\n</pre>\n\n***\n### More info\n\nThe command-line options should be self-explanatory, while the proto-buf config options are described in [config.proto](https://github.com/google/nsjail/blob/master/config.proto)\n\n<pre>\n./nsjail --help\n</pre>\n\n<pre>\n Usage: ./nsjail [options] -- path_to_command [args]\n Options:\n  --help|-h \n \tHelp plz..\n  --mode|-M VALUE\n \tExecution mode (default: 'o' [MODE_STANDALONE_ONCE]):\n\tl: Wait for connections on a TCP port (specified with --port) [MODE_LISTEN_TCP]\n\to: Launch a single process on the console using clone/execve [MODE_STANDALONE_ONCE]\n\te: Launch a single process on the console using execve [MODE_STANDALONE_EXECVE]\n\tr: Launch a single process on the console with clone/execve, keep doing it forever [MODE_STANDALONE_RERUN]\n  --config|-C VALUE\n \tConfiguration file in the config.proto ProtoBuf format (see configs/ directory for examples)\n  --exec_file|-x VALUE\n \tFile to exec (default: argv[0])\n  --execute_fd \n \tUse execveat() to execute a file-descriptor instead of executing the binary path. In such case argv[0]/exec_file denotes a file path before mount namespacing\n  --chroot|-c VALUE\n \tDirectory containing / of the jail (default: none)\n  --no_pivotroot \n \tWhen creating a mount namespace, use mount(MS_MOVE) and chroot rather than pivot_root. Usefull when pivot_root is disallowed (e.g. initramfs). Note: escapable is some configuration\n  --rw \n \tMount chroot dir (/) R/W (default: R/O)\n  --user|-u VALUE\n \tUsername/uid of processes inside the jail (default: your current uid). You can also use inside_ns_uid:outside_ns_uid:count convention here. Can be specified multiple times\n  --group|-g VALUE\n \tGroupname/gid of processes inside the jail (default: your current gid). You can also use inside_ns_gid:global_ns_gid:count convention here. Can be specified multiple times\n  --hostname|-H VALUE\n \tUTS name (hostname) of the jail (default: 'NSJAIL')\n  --cwd|-D VALUE\n \tDirectory in the namespace the process will run (default: '/')\n  --port|-p VALUE\n \tTCP port to bind to (enables MODE_LISTEN_TCP) (default: 0)\n  --bindhost VALUE\n \tIP address to bind the port to (only in [MODE_LISTEN_TCP]), (default: '::')\n  --max_conns VALUE\n \tMaximum number of connections across all IPs (only in [MODE_LISTEN_TCP]), (default: 0 (unlimited))\n  --max_conns_per_ip|-i VALUE\n \tMaximum number of connections per one IP (only in [MODE_LISTEN_TCP]), (default: 0 (unlimited))\n  --log|-l VALUE\n \tLog file (default: use log_fd)\n  --log_fd|-L VALUE\n \tLog FD (default: 2)\n  --time_limit|-t VALUE\n \tMaximum time that a jail can exist, in seconds (default: 600)\n  --max_cpus VALUE\n \tMaximum number of CPUs a single jailed process can use (default: 0 'no limit')\n  --daemon|-d \n \tDaemonize after start\n  --verbose|-v \n \tVerbose output\n  --quiet|-q \n \tLog warning and more important messages only\n  --really_quiet|-Q \n \tLog fatal messages only\n  --keep_env|-e \n \tPass all environment variables to the child process (default: all envars are cleared)\n  --env|-E VALUE\n \tAdditional environment variable (can be used multiple times). If the envar doesn't contain '=' (e.g. just the 'DISPLAY' string), the current envar value will be used\n  --keep_caps \n \tDon't drop any capabilities\n  --cap VALUE\n \tRetain this capability, e.g. CAP_PTRACE (can be specified multiple times)\n  --silent \n \tRedirect child process' fd:0/1/2 to /dev/null\n  --stderr_to_null \n \tRedirect child process' fd:2 (STDERR_FILENO) to /dev/null\n  --skip_setsid \n \tDon't call setsid(), allows for terminal signal handling in the sandboxed process. Dangerous\n  --pass_fd VALUE\n \tDon't close this FD before executing the child process (can be specified multiple times), by default: 0/1/2 are kept open\n  --disable_no_new_privs \n \tDon't set the prctl(NO_NEW_PRIVS, 1) (DANGEROUS)\n  --rlimit_as VALUE\n \tRLIMIT_AS in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 4096)\n  --rlimit_core VALUE\n \tRLIMIT_CORE in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 0)\n  --rlimit_cpu VALUE\n \tRLIMIT_CPU, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 600)\n  --rlimit_fsize VALUE\n \tRLIMIT_FSIZE in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 1)\n  --rlimit_nofile VALUE\n \tRLIMIT_NOFILE, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 32)\n  --rlimit_nproc VALUE\n \tRLIMIT_NPROC, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\n  --rlimit_stack VALUE\n \tRLIMIT_STACK in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\n  --rlimit_memlock VALUE\n \tRLIMIT_MEMLOCK in KB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\n  --rlimit_rtprio VALUE\n \tRLIMIT_RTPRIO, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\n  --rlimit_msgqueue VALUE\n \tRLIMIT_MSGQUEUE in bytes, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\n  --disable_rlimits \n \tDisable all rlimits, default to limits set by parent\n  --persona_addr_compat_layout \n \tpersonality(ADDR_COMPAT_LAYOUT)\n  --persona_mmap_page_zero \n \tpersonality(MMAP_PAGE_ZERO)\n  --persona_read_implies_exec \n \tpersonality(READ_IMPLIES_EXEC)\n  --persona_addr_limit_3gb \n \tpersonality(ADDR_LIMIT_3GB)\n  --persona_addr_no_randomize \n \tpersonality(ADDR_NO_RANDOMIZE)\n  --disable_clone_newnet|-N \n \tDon't use CLONE_NEWNET. Enable global networking inside the jail\n  --disable_clone_newuser \n \tDon't use CLONE_NEWUSER. Requires euid==0\n  --disable_clone_newns \n \tDon't use CLONE_NEWNS\n  --disable_clone_newpid \n \tDon't use CLONE_NEWPID\n  --disable_clone_newipc \n \tDon't use CLONE_NEWIPC\n  --disable_clone_newuts \n \tDon't use CLONE_NEWUTS\n  --disable_clone_newcgroup \n \tDon't use CLONE_NEWCGROUP. Might be required for kernel versions < 4.6\n  --enable_clone_newtime \n \tUse CLONE_NEWTIME. Supported with kernel versions >= 5.3\n  --uid_mapping|-U VALUE\n \tAdd a custom uid mapping of the form inside_uid:outside_uid:count. Setting this requires newuidmap (set-uid) to be present\n  --gid_mapping|-G VALUE\n \tAdd a custom gid mapping of the form inside_gid:outside_gid:count. Setting this requires newgidmap (set-uid) to be present\n  --bindmount_ro|-R VALUE\n \tList of mountpoints to be mounted --bind (ro) inside the container. Can be specified multiple times. Supports 'source' syntax, or 'source:dest'\n  --bindmount|-B VALUE\n \tList of mountpoints to be mounted --bind (rw) inside the container. Can be specified multiple times. Supports 'source' syntax, or 'source:dest'\n  --tmpfsmount|-T VALUE\n \tList of mountpoints to be mounted as tmpfs (R/W) inside the container. Can be specified multiple times. Supports 'dest' syntax. Alternatively, use '-m none:dest:tmpfs:size=8388608'\n  --mount|-m VALUE\n \tArbitrary mount, format src:dst:fs_type:options\n  --symlink|-s VALUE\n \tSymlink, format src:dst\n  --disable_proc \n \tDisable mounting procfs in the jail\n  --proc_path VALUE\n \tPath used to mount procfs (default: '/proc')\n  --proc_rw \n \tIs procfs mounted as R/W (default: R/O)\n  --seccomp_policy|-P VALUE\n \tPath to file containing seccomp-bpf policy (see kafel/)\n  --seccomp_string VALUE\n \tString with kafel seccomp-bpf policy (see kafel/)\n  --seccomp_log \n \tUse SECCOMP_FILTER_FLAG_LOG. Log all actions except SECCOMP_RET_ALLOW). Supported since kernel version 4.14\n  --nice_level VALUE\n \tSet jailed process niceness (-20 is highest -priority, 19 is lowest). By default, set to 19\n  --cgroup_mem_max VALUE\n \tMaximum number of bytes to use in the group (default: '0' - disabled)\n  --cgroup_mem_memsw_max VALUE\n \tMaximum number of memory+swap bytes to use (default: '0' - disabled)\n  --cgroup_mem_swap_max VALUE\n \tMaximum number of swap bytes to use (default: '-1' - disabled)\n  --cgroup_mem_mount VALUE\n \tLocation of memory cgroup FS (default: '/sys/fs/cgroup/memory')\n  --cgroup_mem_parent VALUE\n \tWhich pre-existing memory cgroup to use as a parent (default: 'NSJAIL')\n  --cgroup_pids_max VALUE\n \tMaximum number of pids in a cgroup (default: '0' - disabled)\n  --cgroup_pids_mount VALUE\n \tLocation of pids cgroup FS (default: '/sys/fs/cgroup/pids')\n  --cgroup_pids_parent VALUE\n \tWhich pre-existing pids cgroup to use as a parent (default: 'NSJAIL')\n  --cgroup_net_cls_classid VALUE\n \tClass identifier of network packets in the group (default: '0' - disabled)\n  --cgroup_net_cls_mount VALUE\n \tLocation of net_cls cgroup FS (default: '/sys/fs/cgroup/net_cls')\n  --cgroup_net_cls_parent VALUE\n \tWhich pre-existing net_cls cgroup to use as a parent (default: 'NSJAIL')\n  --cgroup_cpu_ms_per_sec VALUE\n \tNumber of milliseconds of CPU time per second that the process group can use (default: '0' - no limit)\n  --cgroup_cpu_mount VALUE\n \tLocation of cpu cgroup FS (default: '/sys/fs/cgroup/cpu')\n  --cgroup_cpu_parent VALUE\n \tWhich pre-existing cpu cgroup to use as a parent (default: 'NSJAIL')\n  --cgroupv2_mount VALUE\n \tLocation of cgroupv2 directory (default: '/sys/fs/cgroup')\n  --use_cgroupv2 \n \tUse cgroup v2\n  --detect_cgroupv2 \n \tUse cgroupv2, if it is available. (Specify instead of use_cgroupv2)\n  --iface_no_lo \n \tDon't bring the 'lo' interface up\n  --iface_own VALUE\n \tMove this existing network interface into the new NET namespace. Can be specified multiple times\n  --macvlan_iface|-I VALUE\n \tInterface which will be cloned (MACVLAN) and put inside the subprocess' namespace as 'vs'\n  --macvlan_vs_ip VALUE\n \tIP of the 'vs' interface (e.g. \"192.168.0.1\")\n  --macvlan_vs_nm VALUE\n \tNetmask of the 'vs' interface (e.g. \"255.255.255.0\")\n  --macvlan_vs_gw VALUE\n \tDefault GW for the 'vs' interface (e.g. \"192.168.0.1\")\n  --macvlan_vs_ma VALUE\n \tMAC-address of the 'vs' interface (e.g. \"ba:ad:ba:be:45:00\")\n  --macvlan_vs_mo VALUE\n \tMode of the 'vs' interface. Can be either 'private', 'vepa', 'bridge' or 'passthru' (default: 'private')\n  --disable_tsc \n \tDisable rdtsc and rdtscp instructions. WARNING: To make it effective, you also need to forbid `prctl(PR_SET_TSC, PR_TSC_ENABLE, ...)` in seccomp rules! (x86 and x86_64 only). Dynamic binaries produced by GCC seem to rely on RDTSC, but static ones should work.\n  --forward_signals \n \tForward fatal signals to the child process instead of always using SIGKILL.\n \n Examples: \n  Wait on a port 31337 for connections, and run /bin/sh\n   nsjail -Ml --port 31337 --chroot / -- /bin/sh -i\n  Re-run echo command as a sub-process\n   nsjail -Mr --chroot / -- /bin/echo \"ABC\"\n  Run echo command once only, as a sub-process\n   nsjail -Mo --chroot / -- /bin/echo \"ABC\"\n  Execute echo command directly, without a supervising process\n   nsjail -Me --chroot / --disable_proc -- /bin/echo \"ABC\"\n</pre>\n\n***\n### Launching in Docker\n\nTo launch nsjail in a docker container clone the repository and build the docker image:\n<pre>\ndocker build -t nsjailcontainer .\n</pre>\n\nThis will build up an image containing nsjail and kafel.\n\nFrom now you can either use it in another Dockerfile (`FROM nsjailcontainer`) or directly:\n<pre>\ndocker run --privileged --rm -it nsjailcontainer nsjail --user 99999 --group 99999 --disable_proc --chroot / --time_limit 30 /bin/bash\n</pre>\n\n***\n### Contact\n\n  * User mailing list: [nsjail@googlegroups.com](mailto:nsjail@googlegroups.com), sign up with this [link](https://groups.google.com/forum/#!forum/nsjail)\n"
        },
        {
          "name": "caps.cc",
          "type": "blob",
          "size": 8.3271484375,
          "content": "/*\n\n   nsjail - capability-related operations\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"caps.h\"\n\n#include <linux/capability.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <cerrno>\n#include <string>\n\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"util.h\"\n\n#if !defined(CAP_AUDIT_READ)\n#define CAP_AUDICAP_AUDIT_READ 37\n#endif /* !defined(CAP_AUDIT_READ) */\n#if !defined(CAP_PERFMON)\n#define CAP_PERFMON 38\n#endif /* !defined(CAP_PERFMON) */\n#if !defined(CAP_BPF)\n#define CAP_BPF 39\n#endif /* !defined(CAP_BPF) */\n#if !defined(CAP_CHECKPOINT_RESTORE)\n#define CAP_CHECKPOINT_RESTORE 40\n#endif /* !defined(CAP_CHECKPOINT_RESTORE) */\n\nnamespace caps {\n\nstruct {\n\tconst int val;\n\tconst char* const name;\n} static const capNames[] = {\n    NS_VALSTR_STRUCT(CAP_CHOWN),\n    NS_VALSTR_STRUCT(CAP_DAC_OVERRIDE),\n    NS_VALSTR_STRUCT(CAP_DAC_READ_SEARCH),\n    NS_VALSTR_STRUCT(CAP_FOWNER),\n    NS_VALSTR_STRUCT(CAP_FSETID),\n    NS_VALSTR_STRUCT(CAP_KILL),\n    NS_VALSTR_STRUCT(CAP_SETGID),\n    NS_VALSTR_STRUCT(CAP_SETUID),\n    NS_VALSTR_STRUCT(CAP_SETPCAP),\n    NS_VALSTR_STRUCT(CAP_LINUX_IMMUTABLE),\n    NS_VALSTR_STRUCT(CAP_NET_BIND_SERVICE),\n    NS_VALSTR_STRUCT(CAP_NET_BROADCAST),\n    NS_VALSTR_STRUCT(CAP_NET_ADMIN),\n    NS_VALSTR_STRUCT(CAP_NET_RAW),\n    NS_VALSTR_STRUCT(CAP_IPC_LOCK),\n    NS_VALSTR_STRUCT(CAP_IPC_OWNER),\n    NS_VALSTR_STRUCT(CAP_SYS_MODULE),\n    NS_VALSTR_STRUCT(CAP_SYS_RAWIO),\n    NS_VALSTR_STRUCT(CAP_SYS_CHROOT),\n    NS_VALSTR_STRUCT(CAP_SYS_PTRACE),\n    NS_VALSTR_STRUCT(CAP_SYS_PACCT),\n    NS_VALSTR_STRUCT(CAP_SYS_ADMIN),\n    NS_VALSTR_STRUCT(CAP_SYS_BOOT),\n    NS_VALSTR_STRUCT(CAP_SYS_NICE),\n    NS_VALSTR_STRUCT(CAP_SYS_RESOURCE),\n    NS_VALSTR_STRUCT(CAP_SYS_TIME),\n    NS_VALSTR_STRUCT(CAP_SYS_TTY_CONFIG),\n    NS_VALSTR_STRUCT(CAP_MKNOD),\n    NS_VALSTR_STRUCT(CAP_LEASE),\n    NS_VALSTR_STRUCT(CAP_AUDIT_WRITE),\n    NS_VALSTR_STRUCT(CAP_AUDIT_CONTROL),\n    NS_VALSTR_STRUCT(CAP_SETFCAP),\n    NS_VALSTR_STRUCT(CAP_MAC_OVERRIDE),\n    NS_VALSTR_STRUCT(CAP_MAC_ADMIN),\n    NS_VALSTR_STRUCT(CAP_SYSLOG),\n    NS_VALSTR_STRUCT(CAP_WAKE_ALARM),\n    NS_VALSTR_STRUCT(CAP_BLOCK_SUSPEND),\n    NS_VALSTR_STRUCT(CAP_AUDIT_READ),\n    NS_VALSTR_STRUCT(CAP_PERFMON),\n    NS_VALSTR_STRUCT(CAP_BPF),\n    NS_VALSTR_STRUCT(CAP_CHECKPOINT_RESTORE),\n};\n\nint nameToVal(const char* name) {\n\tfor (const auto& cap : capNames) {\n\t\tif (util::StrEq(name, cap.name)) {\n\t\t\treturn cap.val;\n\t\t}\n\t}\n\tLOG_W(\"Unknown capability: '%s'\", name);\n\treturn -1;\n}\n\nstatic const std::string capToStr(int val) {\n\tfor (const auto& cap : capNames) {\n\t\tif (val == cap.val) {\n\t\t\treturn cap.name;\n\t\t}\n\t}\n\n\tstd::string res;\n\tres.append(\"CAP_UNKNOWN(\").append(std::to_string(val)).append(\")\");\n\treturn res;\n}\n\nstatic cap_user_data_t getCaps() {\n\tstatic __thread struct __user_cap_data_struct cap_data[_LINUX_CAPABILITY_U32S_3];\n\tconst struct __user_cap_header_struct cap_hdr = {\n\t    .version = _LINUX_CAPABILITY_VERSION_3,\n\t    .pid = 0,\n\t};\n\tif (util::syscall(__NR_capget, (uintptr_t)&cap_hdr, (uintptr_t)&cap_data) == -1) {\n\t\tPLOG_W(\"capget() failed\");\n\t\treturn nullptr;\n\t}\n\treturn cap_data;\n}\n\nstatic bool setCaps(const cap_user_data_t cap_data) {\n\tconst struct __user_cap_header_struct cap_hdr = {\n\t    .version = _LINUX_CAPABILITY_VERSION_3,\n\t    .pid = 0,\n\t};\n\tif (util::syscall(__NR_capset, (uintptr_t)&cap_hdr, (uintptr_t)cap_data) == -1) {\n\t\tPLOG_W(\"capset() failed\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void clearInheritable(cap_user_data_t cap_data) {\n\tfor (size_t i = 0; i < _LINUX_CAPABILITY_U32S_3; i++) {\n\t\tcap_data[i].inheritable = 0U;\n\t}\n}\n\nstatic bool getPermitted(cap_user_data_t cap_data, unsigned int cap) {\n\tsize_t off_byte = CAP_TO_INDEX(cap);\n\tunsigned mask = CAP_TO_MASK(cap);\n\treturn cap_data[off_byte].permitted & mask;\n}\n\nstatic bool getEffective(cap_user_data_t cap_data, unsigned int cap) {\n\tsize_t off_byte = CAP_TO_INDEX(cap);\n\tunsigned mask = CAP_TO_MASK(cap);\n\treturn cap_data[off_byte].effective & mask;\n}\n\nstatic bool getInheritable(cap_user_data_t cap_data, unsigned int cap) {\n\tsize_t off_byte = CAP_TO_INDEX(cap);\n\tunsigned mask = CAP_TO_MASK(cap);\n\treturn cap_data[off_byte].inheritable & mask;\n}\n\nstatic void setInheritable(cap_user_data_t cap_data, unsigned int cap) {\n\tsize_t off_byte = CAP_TO_INDEX(cap);\n\tunsigned mask = CAP_TO_MASK(cap);\n\tcap_data[off_byte].inheritable |= mask;\n}\n\n#if !defined(PR_CAP_AMBIENT)\n#define PR_CAP_AMBIENT 47\n#define PR_CAP_AMBIENT_RAISE 2\n#define PR_CAP_AMBIENT_CLEAR_ALL 4\n#endif /* !defined(PR_CAP_AMBIENT) */\nstatic bool initNsKeepCaps(cap_user_data_t cap_data) {\n\t/* Copy all permitted caps to the inheritable set */\n\tstd::string dbgmsg1;\n\tfor (const auto& i : capNames) {\n\t\tif (getPermitted(cap_data, i.val)) {\n\t\t\tutil::StrAppend(&dbgmsg1, \" %s\", i.name);\n\t\t\tsetInheritable(cap_data, i.val);\n\t\t}\n\t}\n\tLOG_D(\"Adding the following capabilities to the inheritable set:%s\", dbgmsg1.c_str());\n\n\tif (!setCaps(cap_data)) {\n\t\treturn false;\n\t}\n\n\t/* Make sure the inheritable set is preserved across execve via the ambient set */\n\tstd::string dbgmsg2;\n\tfor (const auto& i : capNames) {\n\t\tif (!getPermitted(cap_data, i.val)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, (unsigned long)i.val, 0UL, 0UL) ==\n\t\t    -1) {\n\t\t\tPLOG_W(\"prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, %s)\", i.name);\n\t\t} else {\n\t\t\tutil::StrAppend(&dbgmsg2, \" %s\", i.name);\n\t\t}\n\t}\n\tLOG_D(\"Added the following capabilities to the ambient set:%s\", dbgmsg2.c_str());\n\n\treturn true;\n}\n\nbool initNs(nsjconf_t* nsjconf) {\n\tcap_user_data_t cap_data = getCaps();\n\tif (cap_data == nullptr) {\n\t\treturn false;\n\t}\n\n\t/* Let's start with an empty inheritable set to avoid any mistakes */\n\tclearInheritable(cap_data);\n\t/*\n\t * Remove all capabilities from the ambient set first. It works with newer kernel versions\n\t * only, so don't panic() if it fails\n\t */\n\tif (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_CLEAR_ALL, 0UL, 0UL, 0UL) == -1) {\n\t\tPLOG_W(\"prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_CLEAR_ALL)\");\n\t}\n\n\tif (nsjconf->keep_caps) {\n\t\treturn initNsKeepCaps(cap_data);\n\t}\n\n\t/* Set all requested caps in the inheritable set if these are present in the permitted set\n\t */\n\tstd::string dbgmsg;\n\tfor (const auto& cap : nsjconf->caps) {\n\t\tif (!getPermitted(cap_data, cap)) {\n\t\t\tLOG_W(\"Capability %s is not permitted in the namespace\",\n\t\t\t    capToStr(cap).c_str());\n\t\t\treturn false;\n\t\t}\n\t\tdbgmsg.append(\" \").append(capToStr(cap));\n\t\tsetInheritable(cap_data, cap);\n\t}\n\tLOG_D(\"Adding the following capabilities to the inheritable set:%s\", dbgmsg.c_str());\n\n\tif (!setCaps(cap_data)) {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Make sure all other caps (those which were not explicitly requested) are removed from the\n\t * bounding set. We need to have CAP_SETPCAP to do that now\n\t */\n\tdbgmsg.clear();\n\tif (getEffective(cap_data, CAP_SETPCAP)) {\n\t\tfor (const auto& i : capNames) {\n\t\t\tif (getInheritable(cap_data, i.val)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prctl(PR_CAPBSET_READ, (unsigned long)i.val, 0UL, 0UL, 0UL) == -1 &&\n\t\t\t    errno == EINVAL) {\n\t\t\t\tLOG_D(\"Skipping unsupported capability: %s\", i.name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdbgmsg.append(\" \").append(i.name);\n\t\t\tif (prctl(PR_CAPBSET_DROP, (unsigned long)i.val, 0UL, 0UL, 0UL) == -1) {\n\t\t\t\tPLOG_W(\"prctl(PR_CAPBSET_DROP, %s)\", i.name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tLOG_D(\n\t\t    \"Dropped the following capabilities from the bounding set:%s\", dbgmsg.c_str());\n\t}\n\n\t/* Make sure inheritable set is preserved across execve via the modified ambient set */\n\tdbgmsg.clear();\n\tfor (const auto& cap : nsjconf->caps) {\n\t\tif (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, (unsigned long)cap, 0UL, 0UL) ==\n\t\t    -1) {\n\t\t\tPLOG_W(\"prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, %s)\",\n\t\t\t    capToStr(cap).c_str());\n\t\t} else {\n\t\t\tdbgmsg.append(\" \").append(capToStr(cap));\n\t\t}\n\t}\n\tLOG_D(\"Added the following capabilities to the ambient set:%s\", dbgmsg.c_str());\n\n\treturn true;\n}\n\n}  // namespace caps\n"
        },
        {
          "name": "caps.h",
          "type": "blob",
          "size": 0.90625,
          "content": "/*\n\n   nsjail - capability-related operations\n   -----------------------------------------\n\n   Copyright 2017 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_CAPS_H\n#define NS_CAPS_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"nsjail.h\"\n\nnamespace caps {\n\nint nameToVal(const char* name);\nbool initNs(nsjconf_t* nsjconf);\n\n}  // namespace caps\n\n#endif /* NS_CAPS_H */\n"
        },
        {
          "name": "cgroup.cc",
          "type": "blob",
          "size": 6.5087890625,
          "content": "/*\n\n   nsjail - cgroup namespacing\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"cgroup.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <sstream>\n\n#include \"logs.h\"\n#include \"util.h\"\n\nnamespace cgroup {\n\nstatic bool createCgroup(const std::string& cgroup_path, pid_t pid) {\n\tLOG_D(\"Create %s for pid=%d\", QC(cgroup_path), (int)pid);\n\tif (mkdir(cgroup_path.c_str(), 0700) == -1 && errno != EEXIST) {\n\t\tPLOG_W(\"mkdir(%s, 0700) failed\", QC(cgroup_path));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool writeToCgroup(\n    const std::string& cgroup_path, const std::string& value, const std::string& what) {\n\tLOG_D(\"Setting %s to '%s'\", QC(cgroup_path), value.c_str());\n\tif (!util::writeBufToFile(\n\t\tcgroup_path.c_str(), value.c_str(), value.length(), O_WRONLY | O_CLOEXEC)) {\n\t\tLOG_W(\"Could not update %s\", what.c_str());\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool addPidToTaskList(const std::string& cgroup_path, pid_t pid) {\n\tstd::string pid_str = std::to_string(pid);\n\tstd::string tasks_path = cgroup_path + \"/tasks\";\n\tLOG_D(\"Adding pid='%s' to %s\", pid_str.c_str(), QC(tasks_path));\n\treturn writeToCgroup(tasks_path, pid_str, \"'\" + tasks_path + \"' task list\");\n}\n\nstatic bool initNsFromParentMem(nsjconf_t* nsjconf, pid_t pid) {\n\tsize_t memsw_max = nsjconf->cgroup_mem_memsw_max;\n\tif (nsjconf->cgroup_mem_swap_max >= (ssize_t)0) {\n\t\tmemsw_max = nsjconf->cgroup_mem_swap_max + nsjconf->cgroup_mem_max;\n\t}\n\n\tif (nsjconf->cgroup_mem_max == (size_t)0 && memsw_max == (size_t)0) {\n\t\treturn true;\n\t}\n\n\tstd::string mem_cgroup_path = nsjconf->cgroup_mem_mount + '/' + nsjconf->cgroup_mem_parent +\n\t\t\t\t      \"/NSJAIL.\" + std::to_string(pid);\n\tRETURN_ON_FAILURE(createCgroup(mem_cgroup_path, pid));\n\n\t/*\n\t * Use OOM-killer instead of making processes hang/sleep\n\t */\n\tRETURN_ON_FAILURE(writeToCgroup(\n\t    mem_cgroup_path + \"/memory.oom_control\", \"0\", \"memory cgroup oom control\"));\n\n\tif (nsjconf->cgroup_mem_max > (size_t)0) {\n\t\tstd::string mem_max_str = std::to_string(nsjconf->cgroup_mem_max);\n\t\tRETURN_ON_FAILURE(writeToCgroup(mem_cgroup_path + \"/memory.limit_in_bytes\",\n\t\t    mem_max_str, \"memory cgroup max limit\"));\n\t}\n\n\tif (memsw_max > (size_t)0) {\n\t\tstd::string mem_memsw_max_str = std::to_string(memsw_max);\n\t\tRETURN_ON_FAILURE(writeToCgroup(mem_cgroup_path + \"/memory.memsw.limit_in_bytes\",\n\t\t    mem_memsw_max_str, \"memory+Swap cgroup max limit\"));\n\t}\n\n\treturn addPidToTaskList(mem_cgroup_path, pid);\n}\n\nstatic bool initNsFromParentPids(nsjconf_t* nsjconf, pid_t pid) {\n\tif (nsjconf->cgroup_pids_max == 0U) {\n\t\treturn true;\n\t}\n\n\tstd::string pids_cgroup_path = nsjconf->cgroup_pids_mount + '/' +\n\t\t\t\t       nsjconf->cgroup_pids_parent + \"/NSJAIL.\" +\n\t\t\t\t       std::to_string(pid);\n\tRETURN_ON_FAILURE(createCgroup(pids_cgroup_path, pid));\n\n\tstd::string pids_max_str = std::to_string(nsjconf->cgroup_pids_max);\n\tRETURN_ON_FAILURE(\n\t    writeToCgroup(pids_cgroup_path + \"/pids.max\", pids_max_str, \"pids cgroup max limit\"));\n\n\treturn addPidToTaskList(pids_cgroup_path, pid);\n}\n\nstatic bool initNsFromParentNetCls(nsjconf_t* nsjconf, pid_t pid) {\n\tif (nsjconf->cgroup_net_cls_classid == 0U) {\n\t\treturn true;\n\t}\n\n\tstd::string net_cls_cgroup_path = nsjconf->cgroup_net_cls_mount + '/' +\n\t\t\t\t\t  nsjconf->cgroup_net_cls_parent + \"/NSJAIL.\" +\n\t\t\t\t\t  std::to_string(pid);\n\tRETURN_ON_FAILURE(createCgroup(net_cls_cgroup_path, pid));\n\n\tstd::string net_cls_classid_str;\n\t{\n\t\tstd::stringstream ss;\n\t\tss << \"0x\" << std::hex << nsjconf->cgroup_net_cls_classid;\n\t\tnet_cls_classid_str = ss.str();\n\t}\n\tRETURN_ON_FAILURE(writeToCgroup(net_cls_cgroup_path + \"/net_cls.classid\",\n\t    net_cls_classid_str, \"net_cls cgroup classid\"));\n\n\treturn addPidToTaskList(net_cls_cgroup_path, pid);\n}\n\nstatic bool initNsFromParentCpu(nsjconf_t* nsjconf, pid_t pid) {\n\tif (nsjconf->cgroup_cpu_ms_per_sec == 0U) {\n\t\treturn true;\n\t}\n\n\tstd::string cpu_cgroup_path = nsjconf->cgroup_cpu_mount + '/' + nsjconf->cgroup_cpu_parent +\n\t\t\t\t      \"/NSJAIL.\" + std::to_string(pid);\n\tRETURN_ON_FAILURE(createCgroup(cpu_cgroup_path, pid));\n\n\tRETURN_ON_FAILURE(\n\t    writeToCgroup(cpu_cgroup_path + \"/cpu.cfs_period_us\", \"1000000\", \"cpu period\"));\n\n\tstd::string cpu_ms_per_sec_str = std::to_string(nsjconf->cgroup_cpu_ms_per_sec * 1000U);\n\tRETURN_ON_FAILURE(\n\t    writeToCgroup(cpu_cgroup_path + \"/cpu.cfs_quota_us\", cpu_ms_per_sec_str, \"cpu quota\"));\n\n\treturn addPidToTaskList(cpu_cgroup_path, pid);\n}\n\nbool initNsFromParent(nsjconf_t* nsjconf, pid_t pid) {\n\tRETURN_ON_FAILURE(initNsFromParentMem(nsjconf, pid));\n\tRETURN_ON_FAILURE(initNsFromParentPids(nsjconf, pid));\n\tRETURN_ON_FAILURE(initNsFromParentNetCls(nsjconf, pid));\n\treturn initNsFromParentCpu(nsjconf, pid);\n}\n\nstatic void removeCgroup(const std::string& cgroup_path) {\n\tLOG_D(\"Remove %s\", QC(cgroup_path));\n\tif (rmdir(cgroup_path.c_str()) == -1) {\n\t\tPLOG_W(\"rmdir(%s) failed\", QC(cgroup_path));\n\t}\n}\n\nvoid finishFromParent(nsjconf_t* nsjconf, pid_t pid) {\n\tif (nsjconf->cgroup_mem_max != (size_t)0 || nsjconf->cgroup_mem_memsw_max != (size_t)0) {\n\t\tstd::string mem_cgroup_path = nsjconf->cgroup_mem_mount + '/' +\n\t\t\t\t\t      nsjconf->cgroup_mem_parent + \"/NSJAIL.\" +\n\t\t\t\t\t      std::to_string(pid);\n\t\tremoveCgroup(mem_cgroup_path);\n\t}\n\tif (nsjconf->cgroup_pids_max != 0U) {\n\t\tstd::string pids_cgroup_path = nsjconf->cgroup_pids_mount + '/' +\n\t\t\t\t\t       nsjconf->cgroup_pids_parent + \"/NSJAIL.\" +\n\t\t\t\t\t       std::to_string(pid);\n\t\tremoveCgroup(pids_cgroup_path);\n\t}\n\tif (nsjconf->cgroup_net_cls_classid != 0U) {\n\t\tstd::string net_cls_cgroup_path = nsjconf->cgroup_net_cls_mount + '/' +\n\t\t\t\t\t\t  nsjconf->cgroup_net_cls_parent + \"/NSJAIL.\" +\n\t\t\t\t\t\t  std::to_string(pid);\n\t\tremoveCgroup(net_cls_cgroup_path);\n\t}\n\tif (nsjconf->cgroup_cpu_ms_per_sec != 0U) {\n\t\tstd::string cpu_cgroup_path = nsjconf->cgroup_cpu_mount + '/' +\n\t\t\t\t\t      nsjconf->cgroup_cpu_parent + \"/NSJAIL.\" +\n\t\t\t\t\t      std::to_string(pid);\n\t\tremoveCgroup(cpu_cgroup_path);\n\t}\n}\n\nbool initNs(void) {\n\treturn true;\n}\n\n}  // namespace cgroup\n"
        },
        {
          "name": "cgroup.h",
          "type": "blob",
          "size": 0.962890625,
          "content": "/*\n\n   nsjail - cgroup namespacing\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_CGROUP_H\n#define NS_CGROUP_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n#include \"nsjail.h\"\n\nnamespace cgroup {\n\nbool initNsFromParent(nsjconf_t* nsjconf, pid_t pid);\nbool initNs(void);\nvoid finishFromParent(nsjconf_t* nsjconf, pid_t pid);\n\n}  // namespace cgroup\n\n#endif /* _CGROUP_H */\n"
        },
        {
          "name": "cgroup2.cc",
          "type": "blob",
          "size": 8.76953125,
          "content": "/*\n\n   nsjail - cgroup2 namespacing\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"cgroup2.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/magic.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n\n#include \"logs.h\"\n#include \"util.h\"\n\nnamespace cgroup2 {\n\nstatic bool addPidToProcList(const std::string &cgroup_path, pid_t pid) {\n\tstd::string pid_str = std::to_string(pid);\n\n\tLOG_D(\"Adding pid='%s' to cgroup.procs\", pid_str.c_str());\n\tif (!util::writeBufToFile((cgroup_path + \"/cgroup.procs\").c_str(), pid_str.c_str(),\n\t\tpid_str.length(), O_WRONLY)) {\n\t\tLOG_W(\"Could not update cgroup.procs\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic std::string getCgroupPath(nsjconf_t *nsjconf, pid_t pid) {\n\treturn nsjconf->cgroupv2_mount + \"/NSJAIL.\" + std::to_string(pid);\n}\nstatic std::string getJailCgroupPath(nsjconf_t *nsjconf) {\n\treturn nsjconf->cgroupv2_mount + \"/NSJAIL_SELF.\" + std::to_string(getpid());\n}\n\nstatic bool createCgroup(const std::string &cgroup_path, pid_t pid) {\n\tLOG_D(\"Create '%s' for pid=%d\", cgroup_path.c_str(), (int)pid);\n\tif (mkdir(cgroup_path.c_str(), 0700) == -1 && errno != EEXIST) {\n\t\tPLOG_W(\"mkdir('%s', 0700) failed\", cgroup_path.c_str());\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool moveSelfIntoChildCgroup(nsjconf_t *nsjconf) {\n\t/*\n\t * Move ourselves into another group to avoid the 'No internal processes' rule\n\t * https://unix.stackexchange.com/a/713343\n\t */\n\tstd::string jail_cgroup_path = getJailCgroupPath(nsjconf);\n\tLOG_I(\"nsjail is moving itself to a new child cgroup: %s\\n\", jail_cgroup_path.c_str());\n\tRETURN_ON_FAILURE(createCgroup(jail_cgroup_path, getpid()));\n\tRETURN_ON_FAILURE(addPidToProcList(jail_cgroup_path, 0));\n\treturn true;\n}\n\nstatic bool enableCgroupSubtree(nsjconf_t *nsjconf, const std::string &controller, pid_t pid) {\n\tstd::string cgroup_path = nsjconf->cgroupv2_mount;\n\tLOG_D(\"Enable cgroup.subtree_control +'%s' to '%s' for pid=%d\", controller.c_str(),\n\t    cgroup_path.c_str(), pid);\n\tstd::string val = \"+\" + controller;\n\n\t/*\n\t * Try once without moving the nsjail process and if that fails then try moving the nsjail\n\t * process into a child cgroup before trying a second time.\n\t */\n\tif (util::writeBufToFile((cgroup_path + \"/cgroup.subtree_control\").c_str(), val.c_str(),\n\t\tval.length(), O_WRONLY, false)) {\n\t\treturn true;\n\t}\n\tif (errno == EBUSY) {\n\t\tRETURN_ON_FAILURE(moveSelfIntoChildCgroup(nsjconf));\n\t\tif (util::writeBufToFile((cgroup_path + \"/cgroup.subtree_control\").c_str(),\n\t\t\tval.c_str(), val.length(), O_WRONLY)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tLOG_E(\n\t    \"Could not apply '%s' to cgroup.subtree_control in '%s'. nsjail MUST be run from root \"\n\t    \"and the cgroup mount path must refer to the root/host cgroup to use cgroupv2. If you \"\n\t    \"use Docker, you may need to run the container with --cgroupns=host so that nsjail can\"\n\t    \" access the host/root cgroupv2 hierarchy. An alternative is mounting (or remounting) \"\n\t    \"the cgroupv2 filesystem but using the flag is just simpler.\",\n\t    val.c_str(), cgroup_path.c_str());\n\treturn false;\n}\n\nstatic bool writeToCgroup(\n    const std::string &cgroup_path, const std::string &resource, const std::string &value) {\n\tLOG_I(\"Setting '%s' to '%s'\", resource.c_str(), value.c_str());\n\n\tif (!util::writeBufToFile(\n\t\t(cgroup_path + \"/\" + resource).c_str(), value.c_str(), value.length(), O_WRONLY)) {\n\t\tLOG_W(\"Could not update %s\", resource.c_str());\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void removeCgroup(const std::string &cgroup_path) {\n\tLOG_D(\"Remove '%s'\", cgroup_path.c_str());\n\tif (rmdir(cgroup_path.c_str()) == -1) {\n\t\tPLOG_W(\"rmdir('%s') failed\", cgroup_path.c_str());\n\t}\n}\n\nstatic bool needMemoryController(nsjconf_t *nsjconf) {\n\t/*\n\t * Check if we need 'memory'\n\t * This matches the check in initNsFromParentMem()\n\t */\n\tssize_t swap_max = nsjconf->cgroup_mem_swap_max;\n\tif (nsjconf->cgroup_mem_memsw_max > (size_t)0) {\n\t\tswap_max = nsjconf->cgroup_mem_memsw_max - nsjconf->cgroup_mem_max;\n\t}\n\tif (nsjconf->cgroup_mem_max == (size_t)0 && swap_max < (ssize_t)0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool needPidsController(nsjconf_t *nsjconf) {\n\treturn nsjconf->cgroup_pids_max != 0;\n}\n\nstatic bool needCpuController(nsjconf_t *nsjconf) {\n\treturn nsjconf->cgroup_cpu_ms_per_sec != 0U;\n}\n\n/*\n * We will use this buf to read from cgroup.subtree_control to see if\n * the root cgroup has the necessary controllers listed\n */\n#define SUBTREE_CONTROL_BUF_LEN 0x40\n\nbool setup(nsjconf_t *nsjconf) {\n\t/*\n\t * Read from cgroup.subtree_control in the root to see if\n\t * the controllers we need are there.\n\t */\n\tauto p = nsjconf->cgroupv2_mount + \"/cgroup.subtree_control\";\n\tchar buf[SUBTREE_CONTROL_BUF_LEN];\n\tint read = util::readFromFile(p.c_str(), buf, SUBTREE_CONTROL_BUF_LEN - 1);\n\tif (read < 0) {\n\t\tLOG_W(\"cgroupv2 setup: Could not read root subtree_control\");\n\t\treturn false;\n\t}\n\tbuf[read] = 0;\n\n\t/* Are the controllers we need there? */\n\tbool subtree_ok = (!needMemoryController(nsjconf) || strstr(buf, \"memory\")) &&\n\t\t\t  (!needPidsController(nsjconf) || strstr(buf, \"pids\")) &&\n\t\t\t  (!needCpuController(nsjconf) || strstr(buf, \"cpu\"));\n\tif (!subtree_ok) {\n\t\t/* Now we can write to the root cgroup.subtree_control */\n\t\tif (needMemoryController(nsjconf)) {\n\t\t\tRETURN_ON_FAILURE(enableCgroupSubtree(nsjconf, \"memory\", getpid()));\n\t\t}\n\n\t\tif (needPidsController(nsjconf)) {\n\t\t\tRETURN_ON_FAILURE(enableCgroupSubtree(nsjconf, \"pids\", getpid()));\n\t\t}\n\n\t\tif (needCpuController(nsjconf)) {\n\t\t\tRETURN_ON_FAILURE(enableCgroupSubtree(nsjconf, \"cpu\", getpid()));\n\t\t}\n\t}\n\treturn true;\n}\n\nbool detectCgroupv2(nsjconf_t *nsjconf) {\n\t/*\n\t * Check cgroupv2_mount, if it is a cgroup2 mount, use it.\n\t */\n\tstruct statfs buf;\n\tif (statfs(nsjconf->cgroupv2_mount.c_str(), &buf)) {\n\t\tLOG_D(\"statfs %s failed with %d\", nsjconf->cgroupv2_mount.c_str(), errno);\n\t\tnsjconf->use_cgroupv2 = false;\n\t\treturn false;\n\t}\n\tnsjconf->use_cgroupv2 = (buf.f_type == CGROUP2_SUPER_MAGIC);\n\treturn true;\n}\n\nstatic bool initNsFromParentMem(nsjconf_t *nsjconf, pid_t pid) {\n\tssize_t swap_max = nsjconf->cgroup_mem_swap_max;\n\tif (nsjconf->cgroup_mem_memsw_max > (size_t)0) {\n\t\tswap_max = nsjconf->cgroup_mem_memsw_max - nsjconf->cgroup_mem_max;\n\t}\n\n\tif (nsjconf->cgroup_mem_max == (size_t)0 && swap_max < (ssize_t)0) {\n\t\treturn true;\n\t}\n\n\tstd::string cgroup_path = getCgroupPath(nsjconf, pid);\n\tRETURN_ON_FAILURE(createCgroup(cgroup_path, pid));\n\tRETURN_ON_FAILURE(addPidToProcList(cgroup_path, pid));\n\n\tif (nsjconf->cgroup_mem_max > (size_t)0) {\n\t\tRETURN_ON_FAILURE(writeToCgroup(\n\t\t    cgroup_path, \"memory.max\", std::to_string(nsjconf->cgroup_mem_max)));\n\t}\n\n\tif (swap_max >= (ssize_t)0) {\n\t\tRETURN_ON_FAILURE(\n\t\t    writeToCgroup(cgroup_path, \"memory.swap.max\", std::to_string(swap_max)));\n\t}\n\n\treturn true;\n}\n\nstatic bool initNsFromParentPids(nsjconf_t *nsjconf, pid_t pid) {\n\tif (nsjconf->cgroup_pids_max == 0U) {\n\t\treturn true;\n\t}\n\tstd::string cgroup_path = getCgroupPath(nsjconf, pid);\n\tRETURN_ON_FAILURE(createCgroup(cgroup_path, pid));\n\tRETURN_ON_FAILURE(addPidToProcList(cgroup_path, pid));\n\treturn writeToCgroup(cgroup_path, \"pids.max\", std::to_string(nsjconf->cgroup_pids_max));\n}\n\nstatic bool initNsFromParentCpu(nsjconf_t *nsjconf, pid_t pid) {\n\tif (nsjconf->cgroup_cpu_ms_per_sec == 0U) {\n\t\treturn true;\n\t}\n\n\tstd::string cgroup_path = getCgroupPath(nsjconf, pid);\n\tRETURN_ON_FAILURE(createCgroup(cgroup_path, pid));\n\tRETURN_ON_FAILURE(addPidToProcList(cgroup_path, pid));\n\n\t/*\n\t * The maximum bandwidth limit in the format: `$MAX $PERIOD`.\n\t * This indicates that the group may consume up to $MAX in each $PERIOD\n\t * duration.\n\t */\n\tstd::string cpu_ms_per_sec_str = std::to_string(nsjconf->cgroup_cpu_ms_per_sec * 1000U);\n\tcpu_ms_per_sec_str += \" 1000000\";\n\treturn writeToCgroup(cgroup_path, \"cpu.max\", cpu_ms_per_sec_str);\n}\n\nbool initNsFromParent(nsjconf_t *nsjconf, pid_t pid) {\n\tRETURN_ON_FAILURE(initNsFromParentMem(nsjconf, pid));\n\tRETURN_ON_FAILURE(initNsFromParentPids(nsjconf, pid));\n\treturn initNsFromParentCpu(nsjconf, pid);\n}\n\nvoid finishFromParent(nsjconf_t *nsjconf, pid_t pid) {\n\tif (nsjconf->cgroup_mem_max != (size_t)0 || nsjconf->cgroup_pids_max != 0U ||\n\t    nsjconf->cgroup_cpu_ms_per_sec != 0U) {\n\t\tremoveCgroup(getCgroupPath(nsjconf, pid));\n\t}\n}\n\n}  // namespace cgroup2\n"
        },
        {
          "name": "cgroup2.h",
          "type": "blob",
          "size": 1.0400390625,
          "content": "/*\n\n   nsjail - cgroup2 namespacing\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_CGROUP2_H\n#define NS_CGROUP2_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n#include \"nsjail.h\"\n\nnamespace cgroup2 {\n\nbool initNsFromParent(nsjconf_t* nsjconf, pid_t pid);\nbool initNs(void);\nvoid finishFromParent(nsjconf_t* nsjconf, pid_t pid);\nbool setup(nsjconf_t* nsjconf);\nbool detectCgroupv2(nsjconf_t* nsjconf);\n\n}  // namespace cgroup2\n\n#endif /* _CGROUP2_H */\n"
        },
        {
          "name": "cmdline.cc",
          "type": "blob",
          "size": 39.62109375,
          "content": "/*\n\n   nsjail - cmdline parsing\n\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"cmdline.h\"\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <grp.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/mount.h>\n#include <sys/personality.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <cstddef>\n#include <memory>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#include \"caps.h\"\n#include \"config.h\"\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"mnt.h\"\n#include \"user.h\"\n#include \"util.h\"\n\nnamespace cmdline {\n\n#define _LOG_DEFAULT_FILE \"/var/log/nsjail.log\"\n\nstruct custom_option {\n\tconst struct option opt;\n\tconst char *const descr;\n};\n\n// clang-format off\nstatic const struct custom_option custom_opts[] = {\n    { { \"help\", no_argument, nullptr, 'h' }, \"Help plz..\" },\n    { { \"mode\", required_argument, nullptr, 'M' },\n        \"Execution mode (default: 'o' [MODE_STANDALONE_ONCE]):\\n\"\n        \"  l: [MODE_LISTEN_TCP]\\n\\tWait for connections on a TCP port (specified with --port)\\n\"\n        \"  o: [MODE_STANDALONE_ONCE]\\n\\tLaunch a single process on the console using clone/execve\\n\"\n        \"  e: [MODE_STANDALONE_EXECVE]\\n\\tLaunch a single process on the console using execve\\n\"\n        \"  r: [MODE_STANDALONE_RERUN]\\n\\tLaunch a single process on the console with clone/execve, keep doing it forever\" },\n    { { \"config\", required_argument, nullptr, 'C' }, \"Configuration file in the config.proto ProtoBuf format (see configs/ directory for examples)\" },\n    { { \"exec_file\", required_argument, nullptr, 'x' }, \"File to exec (default: argv[0])\" },\n    { { \"execute_fd\", no_argument, nullptr, 0x0607 }, \"Use execveat() to execute a file-descriptor instead of executing the binary path. In such case argv[0]/exec_file denotes a file path before mount namespacing\" },\n    { { \"chroot\", required_argument, nullptr, 'c' }, \"Directory containing / of the jail (default: none)\" },\n    { { \"no_pivotroot\", no_argument, nullptr, 0x600 }, \"When creating a mount namespace, use mount(MS_MOVE) and chroot rather than pivot_root. Usefull when pivot_root is disallowed (e.g. initramfs). Note: escapable is some configuration\" },\n    { { \"rw\", no_argument, nullptr, 0x601 }, \"Mount chroot dir (/) R/W (default: R/O)\" },\n    { { \"user\", required_argument, nullptr, 'u' }, \"Username/uid of processes inside the jail (default: your current uid). You can also use inside_ns_uid:outside_ns_uid:count convention here. Can be specified multiple times\" },\n    { { \"group\", required_argument, nullptr, 'g' }, \"Groupname/gid of processes inside the jail (default: your current gid). You can also use inside_ns_gid:global_ns_gid:count convention here. Can be specified multiple times\" },\n    { { \"hostname\", required_argument, nullptr, 'H' }, \"UTS name (hostname) of the jail (default: 'NSJAIL')\" },\n    { { \"cwd\", required_argument, nullptr, 'D' }, \"Directory in the namespace the process will run (default: '/')\" },\n    { { \"port\", required_argument, nullptr, 'p' }, \"TCP port to bind to (enables MODE_LISTEN_TCP) (default: 0)\" },\n    { { \"bindhost\", required_argument, nullptr, 0x604 }, \"IP address to bind the port to (only in [MODE_LISTEN_TCP]), (default: '::')\" },\n    { { \"max_conns\", required_argument, nullptr, 0x608 }, \"Maximum number of connections across all IPs (only in [MODE_LISTEN_TCP]), (default: 0 (unlimited))\" },\n    { { \"max_conns_per_ip\", required_argument, nullptr, 'i' }, \"Maximum number of connections per one IP (only in [MODE_LISTEN_TCP]), (default: 0 (unlimited))\" },\n    { { \"log\", required_argument, nullptr, 'l' }, \"Log file (default: use log_fd)\" },\n    { { \"log_fd\", required_argument, nullptr, 'L' }, \"Log FD (default: 2)\" },\n    { { \"time_limit\", required_argument, nullptr, 't' }, \"Maximum time that a jail can exist, in seconds (default: 600)\" },\n    { { \"max_cpus\", required_argument, nullptr, 0x508 }, \"Maximum number of CPUs a single jailed process can use (default: 0 'no limit')\" },\n    { { \"daemon\", no_argument, nullptr, 'd' }, \"Daemonize after start\" },\n    { { \"verbose\", no_argument, nullptr, 'v' }, \"Verbose output\" },\n    { { \"quiet\", no_argument, nullptr, 'q' }, \"Log warning and more important messages only\" },\n    { { \"really_quiet\", no_argument, nullptr, 'Q' }, \"Log fatal messages only\" },\n    { { \"keep_env\", no_argument, nullptr, 'e' }, \"Pass all environment variables to the child process (default: all envars are cleared)\" },\n    { { \"env\", required_argument, nullptr, 'E' }, \"Additional environment variable (can be used multiple times). If the envar doesn't contain '=' (e.g. just the 'DISPLAY' string), the current envar value will be used\" },\n    { { \"keep_caps\", no_argument, nullptr, 0x0501 }, \"Don't drop any capabilities\" },\n    { { \"cap\", required_argument, nullptr, 0x0509 }, \"Retain this capability, e.g. CAP_PTRACE (can be specified multiple times)\" },\n    { { \"silent\", no_argument, nullptr, 0x0502 }, \"Redirect child process' fd:0/1/2 to /dev/null\" },\n    { { \"stderr_to_null\", no_argument, nullptr, 0x0503 }, \"Redirect child process' fd:2 (STDERR_FILENO) to /dev/null\" },\n    { { \"skip_setsid\", no_argument, nullptr, 0x0504 }, \"Don't call setsid(), allows for terminal signal handling in the sandboxed process. Dangerous\" },\n    { { \"pass_fd\", required_argument, nullptr, 0x0505 }, \"Don't close this FD before executing the child process (can be specified multiple times), by default: 0/1/2 are kept open\" },\n    { { \"disable_no_new_privs\", no_argument, nullptr, 0x0507 }, \"Don't set the prctl(NO_NEW_PRIVS, 1) (DANGEROUS)\" },\n    { { \"rlimit_as\", required_argument, nullptr, 0x0201 }, \"RLIMIT_AS in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 4096)\" },\n    { { \"rlimit_core\", required_argument, nullptr, 0x0202 }, \"RLIMIT_CORE in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 0)\" },\n    { { \"rlimit_cpu\", required_argument, nullptr, 0x0203 }, \"RLIMIT_CPU, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 600)\" },\n    { { \"rlimit_fsize\", required_argument, nullptr, 0x0204 }, \"RLIMIT_FSIZE in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 1)\" },\n    { { \"rlimit_nofile\", required_argument, nullptr, 0x0205 }, \"RLIMIT_NOFILE, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 32)\" },\n    { { \"rlimit_nproc\", required_argument, nullptr, 0x0206 }, \"RLIMIT_NPROC, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\" },\n    { { \"rlimit_stack\", required_argument, nullptr, 0x0207 }, \"RLIMIT_STACK in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\" },\n    { { \"rlimit_memlock\", required_argument, nullptr, 0x0209 }, \"RLIMIT_MEMLOCK in KB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\" },\n    { { \"rlimit_rtprio\", required_argument, nullptr, 0x0210 }, \"RLIMIT_RTPRIO, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\" },\n    { { \"rlimit_msgqueue\", required_argument, nullptr, 0x0211 }, \"RLIMIT_MSGQUEUE in bytes, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM64_INFINITY (default: 'soft')\" },\n    { { \"disable_rlimits\", no_argument, nullptr, 0x0208 }, \"Disable all rlimits, default to limits set by parent\" },\n    { { \"persona_addr_compat_layout\", no_argument, nullptr, 0x0301 }, \"personality(ADDR_COMPAT_LAYOUT)\" },\n    { { \"persona_mmap_page_zero\", no_argument, nullptr, 0x0302 }, \"personality(MMAP_PAGE_ZERO)\" },\n    { { \"persona_read_implies_exec\", no_argument, nullptr, 0x0303 }, \"personality(READ_IMPLIES_EXEC)\" },\n    { { \"persona_addr_limit_3gb\", no_argument, nullptr, 0x0304 }, \"personality(ADDR_LIMIT_3GB)\" },\n    { { \"persona_addr_no_randomize\", no_argument, nullptr, 0x0305 }, \"personality(ADDR_NO_RANDOMIZE)\" },\n    { { \"disable_clone_newnet\", no_argument, nullptr, 'N' }, \"Don't use CLONE_NEWNET. Enable global networking inside the jail\" },\n    { { \"disable_clone_newuser\", no_argument, nullptr, 0x0402 }, \"Don't use CLONE_NEWUSER. Requires euid==0\" },\n    { { \"disable_clone_newns\", no_argument, nullptr, 0x0403 }, \"Don't use CLONE_NEWNS\" },\n    { { \"disable_clone_newpid\", no_argument, nullptr, 0x0404 }, \"Don't use CLONE_NEWPID\" },\n    { { \"disable_clone_newipc\", no_argument, nullptr, 0x0405 }, \"Don't use CLONE_NEWIPC\" },\n    { { \"disable_clone_newuts\", no_argument, nullptr, 0x0406 }, \"Don't use CLONE_NEWUTS\" },\n    { { \"disable_clone_newcgroup\", no_argument, nullptr, 0x0407 }, \"Don't use CLONE_NEWCGROUP. Might be required for kernel versions < 4.6\" },\n    { { \"enable_clone_newtime\", no_argument, nullptr, 0x0408 }, \"Use CLONE_NEWTIME. Supported with kernel versions >= 5.3\" },\n    { { \"uid_mapping\", required_argument, nullptr, 'U' }, \"Add a custom uid mapping of the form inside_uid:outside_uid:count. Setting this requires newuidmap (set-uid) to be present\" },\n    { { \"gid_mapping\", required_argument, nullptr, 'G' }, \"Add a custom gid mapping of the form inside_gid:outside_gid:count. Setting this requires newgidmap (set-uid) to be present\" },\n    { { \"bindmount_ro\", required_argument, nullptr, 'R' }, \"List of mountpoints to be mounted --bind (ro) inside the container. Can be specified multiple times. Supports 'source' syntax, or 'source:dest'\" },\n    { { \"bindmount\", required_argument, nullptr, 'B' }, \"List of mountpoints to be mounted --bind (rw) inside the container. Can be specified multiple times. Supports 'source' syntax, or 'source:dest'\" },\n    { { \"tmpfsmount\", required_argument, nullptr, 'T' }, \"List of mountpoints to be mounted as tmpfs (R/W) inside the container. Can be specified multiple times. Supports 'dest' syntax. Alternatively, use '-m none:dest:tmpfs:size=8388608'\" },\n    { { \"mount\", required_argument, nullptr, 'm' }, \"Arbitrary mount, format src:dst:fs_type:options\" },\n    { { \"symlink\", required_argument, nullptr, 's' }, \"Symlink, format src:dst\" },\n    { { \"disable_proc\", no_argument, nullptr, 0x0603 }, \"Disable mounting procfs in the jail\" },\n    { { \"proc_path\", required_argument, nullptr, 0x0605 }, \"Path used to mount procfs (default: '/proc')\" },\n    { { \"proc_rw\", no_argument, nullptr, 0x0606 }, \"Is procfs mounted as R/W (default: R/O)\" },\n    { { \"seccomp_policy\", required_argument, nullptr, 'P' }, \"Path to file containing seccomp-bpf policy (see kafel/)\" },\n    { { \"seccomp_string\", required_argument, nullptr, 0x0901 }, \"String with kafel seccomp-bpf policy (see kafel/)\" },\n    { { \"seccomp_log\", no_argument, nullptr, 0x0902 }, \"Use SECCOMP_FILTER_FLAG_LOG. Log all actions except SECCOMP_RET_ALLOW). Supported since kernel version 4.14\" },\n    { { \"nice_level\", required_argument, nullptr, 0x0903 }, \"Set jailed process niceness (-20 is highest -priority, 19 is lowest). By default, set to 19\" },\n    { { \"cgroup_mem_max\", required_argument, nullptr, 0x0801 }, \"Maximum number of bytes to use in the group (default: '0' - disabled)\" },\n    { { \"cgroup_mem_memsw_max\", required_argument, nullptr, 0x0804 }, \"Maximum number of memory+swap bytes to use (default: '0' - disabled)\" },\n    { { \"cgroup_mem_swap_max\", required_argument, nullptr, 0x0805 }, \"Maximum number of swap bytes to use (default: '-1' - disabled)\" },\n    { { \"cgroup_mem_mount\", required_argument, nullptr, 0x0802 }, \"Location of memory cgroup FS (default: '/sys/fs/cgroup/memory')\" },\n    { { \"cgroup_mem_parent\", required_argument, nullptr, 0x0803 }, \"Which pre-existing memory cgroup to use as a parent (default: 'NSJAIL')\" },\n    { { \"cgroup_pids_max\", required_argument, nullptr, 0x0811 }, \"Maximum number of pids in a cgroup (default: '0' - disabled)\" },\n    { { \"cgroup_pids_mount\", required_argument, nullptr, 0x0812 }, \"Location of pids cgroup FS (default: '/sys/fs/cgroup/pids')\" },\n    { { \"cgroup_pids_parent\", required_argument, nullptr, 0x0813 }, \"Which pre-existing pids cgroup to use as a parent (default: 'NSJAIL')\" },\n    { { \"cgroup_net_cls_classid\", required_argument, nullptr, 0x0821 }, \"Class identifier of network packets in the group (default: '0' - disabled)\" },\n    { { \"cgroup_net_cls_mount\", required_argument, nullptr, 0x0822 }, \"Location of net_cls cgroup FS (default: '/sys/fs/cgroup/net_cls')\" },\n    { { \"cgroup_net_cls_parent\", required_argument, nullptr, 0x0823 }, \"Which pre-existing net_cls cgroup to use as a parent (default: 'NSJAIL')\" },\n    { { \"cgroup_cpu_ms_per_sec\", required_argument, nullptr, 0x0831 }, \"Number of milliseconds of CPU time per second that the process group can use (default: '0' - no limit)\" },\n    { { \"cgroup_cpu_mount\", required_argument, nullptr, 0x0832 }, \"Location of cpu cgroup FS (default: '/sys/fs/cgroup/cpu')\" },\n    { { \"cgroup_cpu_parent\", required_argument, nullptr, 0x0833 }, \"Which pre-existing cpu cgroup to use as a parent (default: 'NSJAIL')\" },\n    { { \"cgroupv2_mount\", required_argument, nullptr, 0x0834}, \"Location of cgroupv2 directory (default: '/sys/fs/cgroup')\"},\n    { { \"use_cgroupv2\", no_argument, nullptr, 0x0835}, \"Use cgroup v2\"},\n    { { \"detect_cgroupv2\", no_argument, nullptr, 0x0836}, \"Use cgroupv2, if it is available. (Specify instead of use_cgroupv2)\"},\n    { { \"iface_no_lo\", no_argument, nullptr, 0x700 }, \"Don't bring the 'lo' interface up\" },\n    { { \"iface_own\", required_argument, nullptr, 0x704 }, \"Move this existing network interface into the new NET namespace. Can be specified multiple times\" },\n    { { \"macvlan_iface\", required_argument, nullptr, 'I' }, \"Interface which will be cloned (MACVLAN) and put inside the subprocess' namespace as 'vs'\" },\n    { { \"macvlan_vs_ip\", required_argument, nullptr, 0x701 }, \"IP of the 'vs' interface (e.g. \\\"192.168.0.1\\\")\" },\n    { { \"macvlan_vs_nm\", required_argument, nullptr, 0x702 }, \"Netmask of the 'vs' interface (e.g. \\\"255.255.255.0\\\")\" },\n    { { \"macvlan_vs_gw\", required_argument, nullptr, 0x703 }, \"Default GW for the 'vs' interface (e.g. \\\"192.168.0.1\\\")\" },\n    { { \"macvlan_vs_ma\", required_argument, nullptr, 0x705 }, \"MAC-address of the 'vs' interface (e.g. \\\"ba:ad:ba:be:45:00\\\")\" },\n    { { \"macvlan_vs_mo\", required_argument, nullptr, 0x706 }, \"Mode of the 'vs' interface. Can be either 'private', 'vepa', 'bridge' or 'passthru' (default: 'private')\" },\n    { { \"disable_tsc\", no_argument, nullptr, 0x707 }, \"Disable rdtsc and rdtscp instructions. WARNING: To make it effective, you also need to forbid `prctl(PR_SET_TSC, PR_TSC_ENABLE, ...)` in seccomp rules! (x86 and x86_64 only). Dynamic binaries produced by GCC seem to rely on RDTSC, but static ones should work.\" },\n    { { \"forward_signals\", no_argument, nullptr, 0x708 }, \"Forward fatal signals to the child process instead of always using SIGKILL.\" },\n};\n// clang-format on\n\nstatic const char *logYesNo(bool yes) {\n\treturn (yes ? \"true\" : \"false\");\n}\n\nsize_t GetConsoleLength(const std::string &str) {\n\tint result = 0;\n\tfor (char c : str) {\n\t\tif (c == '\\t') {\n\t\t\tresult += 8;\n\t\t} else {\n\t\t\t++result;\n\t\t}\n\t}\n\treturn result;\n}\n\nstd::string FormatLine(const std::string &line, size_t max_len = 80) {\n\tstd::string indent = line.substr(0, line.find_first_not_of(\" \\t\"));\n\tsize_t indent_len = GetConsoleLength(indent);\n\tsize_t cursor = 0;\n\tstd::string formatted;\n\tstd::vector<std::string> words = util::strSplit(line.c_str(), ' ');\n\tfor (const auto &word : words) {\n\t\tsize_t wlen = GetConsoleLength(word);\n\t\tstd::string separator = cursor == 0 ? \"\" : \" \";\n\t\tsize_t slen = GetConsoleLength(separator);\n\t\tif (cursor != 0 && cursor + slen + wlen >= max_len) {\n\t\t\tutil::StrAppend(&formatted, \"\\n\");\n\t\t\tcursor = 0;\n\t\t\tseparator = indent;\n\t\t\tslen = indent_len;\n\t\t}\n\t\tutil::StrAppend(&formatted, \"%s%s\", separator.c_str(), word.c_str());\n\t\tcursor += slen + wlen;\n\t}\n\treturn formatted;\n}\n\nstd::string FormatDescription(const char *descr) {\n\tstd::string formatted;\n\tstd::vector<std::string> lines = util::strSplit(descr, '\\n');\n\n\tfor (const auto &line : lines) {\n\t\tutil::StrAppend(&formatted, \"%s\\n\", FormatLine(std::string(\"\\t\") + line).c_str());\n\t}\n\treturn formatted;\n}\n\nstatic void cmdlineOptUsage(const struct custom_option *option) {\n\tif (option->opt.val < 0x80) {\n\t\tLOG_HELP_BOLD(\" --%s%s%c %s\", option->opt.name, \"|-\", option->opt.val,\n\t\t    option->opt.has_arg == required_argument ? \"VALUE\" : \"\");\n\t} else {\n\t\tLOG_HELP_BOLD(\" --%s %s\", option->opt.name,\n\t\t    option->opt.has_arg == required_argument ? \"VALUE\" : \"\");\n\t}\n\tLOG_HELP(\"%s\", FormatDescription(option->descr).c_str());\n}\n\nstatic void cmdlineUsage(const char *pname) {\n\tLOG_HELP_BOLD(\"Usage: %s [options] -- path_to_command [args]\", pname);\n\tLOG_HELP_BOLD(\"Options:\");\n\tfor (size_t i = 0; i < ARR_SZ(custom_opts); i++) {\n\t\tcmdlineOptUsage(&custom_opts[i]);\n\t}\n\tLOG_HELP_BOLD(\"\\n Examples: \");\n\tLOG_HELP(\" Wait on a port 31337 for connections, and run /bin/sh\");\n\tLOG_HELP_BOLD(\"  nsjail -Ml --port 31337 --chroot / -- /bin/sh -i\");\n\tLOG_HELP(\" Re-run echo command as a sub-process\");\n\tLOG_HELP_BOLD(\"  nsjail -Mr --chroot / -- /bin/echo \\\"ABC\\\"\");\n\tLOG_HELP(\" Run echo command once only, as a sub-process\");\n\tLOG_HELP_BOLD(\"  nsjail -Mo --chroot / -- /bin/echo \\\"ABC\\\"\");\n\tLOG_HELP(\" Execute echo command directly, without a supervising process\");\n\tLOG_HELP_BOLD(\"  nsjail -Me --chroot / --disable_proc -- /bin/echo \\\"ABC\\\"\");\n}\n\nvoid addEnv(nsjconf_t *nsjconf, const std::string &env) {\n\tif (env.find('=') != std::string::npos) {\n\t\tnsjconf->envs.push_back(env);\n\t\treturn;\n\t}\n\tchar *e = getenv(env.c_str());\n\tif (!e) {\n\t\tLOG_W(\"Requested to use the %s envar, but it's not set. It'll be ignored\", QC(env));\n\t\treturn;\n\t}\n\tnsjconf->envs.push_back(std::string(env).append(\"=\").append(e));\n}\n\nvoid logParams(nsjconf_t *nsjconf) {\n\tswitch (nsjconf->mode) {\n\tcase MODE_LISTEN_TCP:\n\t\tLOG_I(\"Mode: LISTEN_TCP\");\n\t\tbreak;\n\tcase MODE_STANDALONE_ONCE:\n\t\tLOG_I(\"Mode: STANDALONE_ONCE\");\n\t\tbreak;\n\tcase MODE_STANDALONE_EXECVE:\n\t\tLOG_I(\"Mode: STANDALONE_EXECVE\");\n\t\tbreak;\n\tcase MODE_STANDALONE_RERUN:\n\t\tLOG_I(\"Mode: STANDALONE_RERUN\");\n\t\tbreak;\n\tdefault:\n\t\tLOG_F(\"Mode: UNKNOWN\");\n\t\tbreak;\n\t}\n\n\tLOG_I(\"Jail parameters: hostname:'%s', chroot:%s, process:'%s', \"\n\t      \"bind:[%s]:%d, \"\n\t      \"max_conns:%u, max_conns_per_ip:%u, time_limit:%\" PRId64\n\t      \", personality:%#lx, daemonize:%s, clone_newnet:%s, \"\n\t      \"clone_newuser:%s, clone_newns:%s, clone_newpid:%s, clone_newipc:%s, \"\n\t      \"clone_newuts:%s, \"\n\t      \"clone_newcgroup:%s, clone_newtime:%s, keep_caps:%s, \"\n\t      \"disable_no_new_privs:%s, \"\n\t      \"max_cpus:%zu\",\n\t    nsjconf->hostname.c_str(), QC(nsjconf->chroot),\n\t    nsjconf->exec_file.empty() ? nsjconf->argv[0].c_str() : nsjconf->exec_file.c_str(),\n\t    nsjconf->bindhost.c_str(), nsjconf->port, nsjconf->max_conns, nsjconf->max_conns_per_ip,\n\t    nsjconf->tlimit, nsjconf->personality, logYesNo(nsjconf->daemonize),\n\t    logYesNo(nsjconf->clone_newnet), logYesNo(nsjconf->clone_newuser),\n\t    logYesNo(nsjconf->clone_newns), logYesNo(nsjconf->clone_newpid),\n\t    logYesNo(nsjconf->clone_newipc), logYesNo(nsjconf->clone_newuts),\n\t    logYesNo(nsjconf->clone_newcgroup), logYesNo(nsjconf->clone_newtime),\n\t    logYesNo(nsjconf->keep_caps), logYesNo(nsjconf->disable_no_new_privs),\n\t    nsjconf->max_cpus);\n\n\tfor (const auto &p : nsjconf->mountpts) {\n\t\tLOG_I(\n\t\t    \"%s: %s\", p.is_symlink ? \"Symlink\" : \"Mount\", mnt::describeMountPt(p).c_str());\n\t}\n\tfor (const auto &uid : nsjconf->uids) {\n\t\tLOG_I(\"Uid map: inside_uid:%lu outside_uid:%lu count:%zu newuidmap:%s\",\n\t\t    (unsigned long)uid.inside_id, (unsigned long)uid.outside_id, uid.count,\n\t\t    uid.is_newidmap ? \"true\" : \"false\");\n\t\tif (uid.outside_id == 0 && nsjconf->clone_newuser) {\n\t\t\tLOG_W(\"Process will be UID/EUID=0 in the global user namespace, and \"\n\t\t\t      \"will \"\n\t\t\t      \"have user root-level access to files\");\n\t\t}\n\t}\n\tfor (const auto &gid : nsjconf->gids) {\n\t\tLOG_I(\"Gid map: inside_gid:%lu outside_gid:%lu count:%zu newgidmap:%s\",\n\t\t    (unsigned long)gid.inside_id, (unsigned long)gid.outside_id, gid.count,\n\t\t    gid.is_newidmap ? \"true\" : \"false\");\n\t\tif (gid.outside_id == 0 && nsjconf->clone_newuser) {\n\t\t\tLOG_W(\"Process will be GID/EGID=0 in the global user namespace, and \"\n\t\t\t      \"will \"\n\t\t\t      \"have group root-level access to files\");\n\t\t}\n\t}\n}\n\nuint64_t parseRLimit(int res, const char *optarg, unsigned long mul) {\n\tif (strcasecmp(optarg, \"inf\") == 0) {\n\t\treturn RLIM64_INFINITY;\n\t}\n\tstruct rlimit64 cur;\n\tif (util::getrlimit(res, &cur) == -1) {\n\t\tPLOG_F(\"getrlimit(%d)\", res);\n\t}\n\tif (strcasecmp(optarg, \"def\") == 0 || strcasecmp(optarg, \"soft\") == 0) {\n\t\treturn cur.rlim_cur;\n\t}\n\tif (strcasecmp(optarg, \"max\") == 0 || strcasecmp(optarg, \"hard\") == 0) {\n\t\treturn cur.rlim_max;\n\t}\n\tif (!util::isANumber(optarg)) {\n\t\tLOG_F(\n\t\t    \"RLIMIT %s (%d) needs a numeric value or 'max'/'hard'/'def'/'soft'/'inf' value \"\n\t\t    \"(%s provided)\",\n\t\t    util::rLimName(res).c_str(), res, QC(optarg));\n\t}\n\terrno = 0;\n\tuint64_t val = strtoull(optarg, NULL, 0);\n\tif (val == ULLONG_MAX && errno != 0) {\n\t\tPLOG_F(\"strtoull('%s', 0)\", optarg);\n\t}\n\treturn val * mul;\n}\n\nstatic std::string argFromVec(const std::vector<std::string> &vec, size_t pos) {\n\tif (pos >= vec.size()) {\n\t\treturn \"\";\n\t}\n\treturn vec[pos];\n}\n\nstatic bool setupArgv(nsjconf_t *nsjconf, int argc, char **argv, int optind) {\n\t/*\n\t * If user provided cmdline via nsjail [opts] -- [cmdline], then override\n\t * the one from the config file\n\t */\n\tif (optind < argc) {\n\t\tnsjconf->argv.clear();\n\t\tfor (int i = optind; i < argc; i++) {\n\t\t\tnsjconf->argv.push_back(argv[i]);\n\t\t}\n\t}\n\tif (nsjconf->exec_file.empty() && !nsjconf->argv.empty()) {\n\t\tnsjconf->exec_file = nsjconf->argv[0];\n\t}\n\tif (nsjconf->exec_file.empty()) {\n\t\tcmdlineUsage(argv[0]);\n\t\tLOG_E(\"No command-line provided\");\n\t\treturn false;\n\t}\n\n\tif (nsjconf->use_execveat) {\n#if !defined(__NR_execveat)\n\t\tLOG_E(\"Your nsjail is compiled without support for the execveat() \"\n\t\t      \"syscall, \"\n\t\t      \"yet you \"\n\t\t      \"specified the --execute_fd flag\");\n\t\treturn false;\n#endif /* !defined(__NR_execveat) */\n\t\tif ((nsjconf->exec_fd = TEMP_FAILURE_RETRY(\n\t\t\t open(nsjconf->exec_file.c_str(), O_RDONLY | O_PATH | O_CLOEXEC))) == -1) {\n\t\t\tPLOG_W(\"Couldn't open %s file\", QC(nsjconf->exec_file));\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool setupMounts(nsjconf_t *nsjconf) {\n\tif (!(nsjconf->chroot.empty())) {\n\t\tif (!mnt::addMountPtHead(nsjconf, nsjconf->chroot, \"/\", /* fstype= */ \"\",\n\t\t\t/* options= */ \"\",\n\t\t\tnsjconf->is_root_rw ? (MS_BIND | MS_REC | MS_PRIVATE)\n\t\t\t\t\t    : (MS_BIND | MS_REC | MS_PRIVATE | MS_RDONLY),\n\t\t\t/* is_dir= */ mnt::NS_DIR_YES,\n\t\t\t/* is_mandatory= */ true, /* src_env= */ \"\",\n\t\t\t/* dst_env= */ \"\", /* src_content= */ \"\",\n\t\t\t/* is_symlink= */ false)) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!mnt::addMountPtHead(nsjconf, /* src= */ \"\", \"/\", \"tmpfs\",\n\t\t\t/* options= */ \"\", nsjconf->is_root_rw ? 0 : MS_RDONLY,\n\t\t\t/* is_dir= */ mnt::NS_DIR_YES,\n\t\t\t/* is_mandatory= */ true, /* src_env= */ \"\", /* dst_env= */ \"\",\n\t\t\t/* src_content= */ \"\", /* is_symlink= */ false)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!nsjconf->proc_path.empty()) {\n\t\tif (!mnt::addMountPtTail(nsjconf, /* src= */ \"\", nsjconf->proc_path, \"proc\",\n\t\t\t/* options= */ \"\", nsjconf->is_proc_rw ? 0 : MS_RDONLY,\n\t\t\t/* is_dir= */ mnt::NS_DIR_YES,\n\t\t\t/* is_mandatory= */ true, /* src_env= */ \"\",\n\t\t\t/* dst_env= */ \"\", /* src_content= */ \"\",\n\t\t\t/* is_symlink= */ false)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid setupUsers(nsjconf_t *nsjconf) {\n\tif (nsjconf->uids.empty()) {\n\t\tidmap_t uid;\n\t\tuid.inside_id = getuid();\n\t\tuid.outside_id = getuid();\n\t\tuid.count = 1U;\n\t\tuid.is_newidmap = false;\n\t\tnsjconf->uids.push_back(uid);\n\t}\n\tif (nsjconf->gids.empty()) {\n\t\tidmap_t gid;\n\t\tgid.inside_id = getgid();\n\t\tgid.outside_id = getgid();\n\t\tgid.count = 1U;\n\t\tgid.is_newidmap = false;\n\t\tnsjconf->gids.push_back(gid);\n\t}\n}\n\nstd::string parseMACVlanMode(const char *optarg) {\n\tif (strcasecmp(optarg, \"private\") != 0 && strcasecmp(optarg, \"vepa\") != 0 &&\n\t    strcasecmp(optarg, \"bridge\") != 0 && strcasecmp(optarg, \"passthru\") != 0) {\n\t\tLOG_F(\"macvlan mode can only be one of the values: \"\n\t\t      \"'private'/'vepa'/'bridge'/'passthru' ('%s' \"\n\t\t      \"provided).\",\n\t\t    optarg);\n\t}\n\treturn std::string(optarg);\n}\n\nstd::unique_ptr<nsjconf_t> parseArgs(int argc, char *argv[]) {\n\tstd::unique_ptr<nsjconf_t> nsjconf(new nsjconf_t);\n\n\tnsjconf->use_execveat = false;\n\tnsjconf->exec_fd = -1;\n\tnsjconf->hostname = \"NSJAIL\";\n\tnsjconf->cwd = \"/\";\n\tnsjconf->port = 0;\n\tnsjconf->bindhost = \"::\";\n\tnsjconf->daemonize = false;\n\tnsjconf->tlimit = 0;\n\tnsjconf->max_cpus = 0;\n\tnsjconf->keep_env = false;\n\tnsjconf->keep_caps = false;\n\tnsjconf->disable_no_new_privs = false;\n\tnsjconf->rl_as = 4096ULL * (1024ULL * 1024ULL);\n\tnsjconf->rl_core = 0ULL;\n\tnsjconf->rl_cpu = 600ULL;\n\tnsjconf->rl_fsize = 1ULL * (1024ULL * 1024ULL);\n\tnsjconf->rl_nofile = 32ULL;\n\tnsjconf->rl_nproc = parseRLimit(RLIMIT_NPROC, \"soft\", 1);\n\tnsjconf->rl_stack = parseRLimit(RLIMIT_STACK, \"soft\", 1);\n\tnsjconf->rl_mlock = parseRLimit(RLIMIT_MEMLOCK, \"soft\", 1);\n\tnsjconf->rl_rtpr = parseRLimit(RLIMIT_RTPRIO, \"soft\", 1);\n\tnsjconf->rl_msgq = parseRLimit(RLIMIT_MSGQUEUE, \"soft\", 1);\n\tnsjconf->disable_rl = false;\n\tnsjconf->personality = 0;\n\tnsjconf->clone_newnet = true;\n\tnsjconf->clone_newuser = true;\n\tnsjconf->clone_newns = true;\n\tnsjconf->no_pivotroot = false;\n\tnsjconf->clone_newpid = true;\n\tnsjconf->clone_newipc = true;\n\tnsjconf->clone_newuts = true;\n\tnsjconf->clone_newcgroup = true;\n\tnsjconf->clone_newtime = false;\n\tnsjconf->mode = MODE_STANDALONE_ONCE;\n\tnsjconf->is_root_rw = false;\n\tnsjconf->is_silent = false;\n\tnsjconf->stderr_to_null = false;\n\tnsjconf->skip_setsid = false;\n\tnsjconf->max_conns = 0;\n\tnsjconf->max_conns_per_ip = 0;\n\tnsjconf->proc_path = \"/proc\";\n\tnsjconf->is_proc_rw = false;\n\tnsjconf->cgroup_mem_mount = \"/sys/fs/cgroup/memory\";\n\tnsjconf->cgroup_mem_parent = \"NSJAIL\";\n\tnsjconf->cgroup_mem_max = (size_t)0;\n\tnsjconf->cgroup_mem_memsw_max = (size_t)0;\n\tnsjconf->cgroup_mem_swap_max = (ssize_t)-1;\n\tnsjconf->cgroup_pids_mount = \"/sys/fs/cgroup/pids\";\n\tnsjconf->cgroup_pids_parent = \"NSJAIL\";\n\tnsjconf->cgroup_pids_max = 0U;\n\tnsjconf->cgroup_net_cls_mount = \"/sys/fs/cgroup/net_cls\";\n\tnsjconf->cgroup_net_cls_parent = \"NSJAIL\";\n\tnsjconf->cgroup_net_cls_classid = 0U;\n\tnsjconf->cgroup_cpu_mount = \"/sys/fs/cgroup/cpu\";\n\tnsjconf->cgroup_cpu_parent = \"NSJAIL\";\n\tnsjconf->cgroup_cpu_ms_per_sec = 0U;\n\tnsjconf->cgroupv2_mount = \"/sys/fs/cgroup\";\n\tnsjconf->use_cgroupv2 = false;\n\tnsjconf->detect_cgroupv2 = false;\n\tnsjconf->iface_lo = true;\n\tnsjconf->iface_vs_ip = \"0.0.0.0\";\n\tnsjconf->iface_vs_nm = \"255.255.255.0\";\n\tnsjconf->iface_vs_gw = \"0.0.0.0\";\n\tnsjconf->iface_vs_ma = \"\";\n\tnsjconf->iface_vs_mo = \"private\";\n\tnsjconf->disable_tsc = false;\n\tnsjconf->forward_signals = false;\n\tnsjconf->orig_uid = getuid();\n\tnsjconf->orig_euid = geteuid();\n\tnsjconf->seccomp_fprog.filter = NULL;\n\tnsjconf->seccomp_fprog.len = 0;\n\tnsjconf->seccomp_log = false;\n\tnsjconf->nice_level = 19;\n\n\tnsjconf->openfds.push_back(STDIN_FILENO);\n\tnsjconf->openfds.push_back(STDOUT_FILENO);\n\tnsjconf->openfds.push_back(STDERR_FILENO);\n\n\t/* Generate options array for getopt_long. */\n\tsize_t options_length = ARR_SZ(custom_opts) + 1;\n\tstruct option opts[options_length];\n\tfor (unsigned i = 0; i < ARR_SZ(custom_opts); i++) {\n\t\topts[i] = custom_opts[i].opt;\n\t}\n\t/* Lastly, NULL option as a terminator */\n\tstruct option terminator = {NULL, 0, NULL, 0};\n\tmemcpy(&opts[options_length - 1].name, &terminator, sizeof(terminator));\n\n\tint opt_index = 0;\n\tfor (;;) {\n\t\tint c = getopt_long(argc, argv,\n\t\t    \"x:H:D:C:c:p:i:u:g:l:L:t:M:NdvqQeh?E:R:B:T:m:s:P:I:U:G:\", opts, &opt_index);\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (c) {\n\t\tcase 'x':\n\t\t\tnsjconf->exec_file = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tnsjconf->hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tnsjconf->cwd = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tif (!config::parseFile(nsjconf.get(), optarg)) {\n\t\t\t\tLOG_F(\"Couldn't parse configuration from %s file\", QC(optarg));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tnsjconf->chroot = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (!util::isANumber(optarg)) {\n\t\t\t\tLOG_E(\"Couldn't parse TCP port '%s'\", optarg);\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t\tnsjconf->port = strtoumax(optarg, NULL, 0);\n\t\t\tnsjconf->mode = MODE_LISTEN_TCP;\n\t\t\tbreak;\n\t\tcase 0x604:\n\t\t\tnsjconf->bindhost = optarg;\n\t\t\tbreak;\n\t\tcase 0x608:\n\t\t\tnsjconf->max_conns = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tnsjconf->max_conns_per_ip = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogs::logFile(optarg, STDERR_FILENO);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tlogs::logFile(\"\", std::strtol(optarg, NULL, 0));\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tnsjconf->daemonize = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tlogs::setLogLevel(logs::DEBUG);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tlogs::setLogLevel(logs::WARNING);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tlogs::setLogLevel(logs::FATAL);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tnsjconf->keep_env = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tnsjconf->tlimit = (uint64_t)strtoull(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'h': /* help */\n\t\t\tlogs::logFile(\"\", STDOUT_FILENO);\n\t\t\tcmdlineUsage(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 0x0201:\n\t\t\tnsjconf->rl_as = parseRLimit(RLIMIT_AS, optarg, (1024 * 1024));\n\t\t\tbreak;\n\t\tcase 0x0202:\n\t\t\tnsjconf->rl_core = parseRLimit(RLIMIT_CORE, optarg, (1024 * 1024));\n\t\t\tbreak;\n\t\tcase 0x0203:\n\t\t\tnsjconf->rl_cpu = parseRLimit(RLIMIT_CPU, optarg, 1);\n\t\t\tbreak;\n\t\tcase 0x0204:\n\t\t\tnsjconf->rl_fsize = parseRLimit(RLIMIT_FSIZE, optarg, (1024 * 1024));\n\t\t\tbreak;\n\t\tcase 0x0205:\n\t\t\tnsjconf->rl_nofile = parseRLimit(RLIMIT_NOFILE, optarg, 1);\n\t\t\tbreak;\n\t\tcase 0x0206:\n\t\t\tnsjconf->rl_nproc = parseRLimit(RLIMIT_NPROC, optarg, 1);\n\t\t\tbreak;\n\t\tcase 0x0207:\n\t\t\tnsjconf->rl_stack = parseRLimit(RLIMIT_STACK, optarg, (1024 * 1024));\n\t\t\tbreak;\n\t\tcase 0x0209:\n\t\t\tnsjconf->rl_mlock = parseRLimit(RLIMIT_MEMLOCK, optarg, 1024);\n\t\t\tbreak;\n\t\tcase 0x0210:\n\t\t\tnsjconf->rl_rtpr = parseRLimit(RLIMIT_RTPRIO, optarg, 1);\n\t\t\tbreak;\n\t\tcase 0x0211:\n\t\t\tnsjconf->rl_msgq = parseRLimit(RLIMIT_MSGQUEUE, optarg, 1);\n\t\t\tbreak;\n\t\tcase 0x0208:\n\t\t\tnsjconf->disable_rl = true;\n\t\t\tbreak;\n\t\tcase 0x0301:\n\t\t\tnsjconf->personality |= ADDR_COMPAT_LAYOUT;\n\t\t\tbreak;\n\t\tcase 0x0302:\n\t\t\tnsjconf->personality |= MMAP_PAGE_ZERO;\n\t\t\tbreak;\n\t\tcase 0x0303:\n\t\t\tnsjconf->personality |= READ_IMPLIES_EXEC;\n\t\t\tbreak;\n\t\tcase 0x0304:\n\t\t\tnsjconf->personality |= ADDR_LIMIT_3GB;\n\t\t\tbreak;\n\t\tcase 0x0305:\n\t\t\tnsjconf->personality |= ADDR_NO_RANDOMIZE;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tnsjconf->clone_newnet = false;\n\t\t\tbreak;\n\t\tcase 0x0402:\n\t\t\tnsjconf->clone_newuser = false;\n\t\t\tbreak;\n\t\tcase 0x0403:\n\t\t\tnsjconf->clone_newns = false;\n\t\t\tbreak;\n\t\tcase 0x0404:\n\t\t\tnsjconf->clone_newpid = false;\n\t\t\tbreak;\n\t\tcase 0x0405:\n\t\t\tnsjconf->clone_newipc = false;\n\t\t\tbreak;\n\t\tcase 0x0406:\n\t\t\tnsjconf->clone_newuts = false;\n\t\t\tbreak;\n\t\tcase 0x0407:\n\t\t\tnsjconf->clone_newcgroup = false;\n\t\t\tbreak;\n\t\tcase 0x0408:\n\t\t\tnsjconf->clone_newtime = true;\n\t\t\tbreak;\n\t\tcase 0x0501:\n\t\t\tnsjconf->keep_caps = true;\n\t\t\tbreak;\n\t\tcase 0x0502:\n\t\t\tnsjconf->is_silent = true;\n\t\t\tbreak;\n\t\tcase 0x0503:\n\t\t\tnsjconf->stderr_to_null = true;\n\t\t\tbreak;\n\t\tcase 0x0504:\n\t\t\tnsjconf->skip_setsid = true;\n\t\t\tbreak;\n\t\tcase 0x0505:\n\t\t\tnsjconf->openfds.push_back((int)strtol(optarg, NULL, 0));\n\t\t\tbreak;\n\t\tcase 0x0507:\n\t\t\tnsjconf->disable_no_new_privs = true;\n\t\t\tbreak;\n\t\tcase 0x0508:\n\t\t\tnsjconf->max_cpus = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 0x0509: {\n\t\t\tint cap = caps::nameToVal(optarg);\n\t\t\tif (cap == -1) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t\tnsjconf->caps.push_back(cap);\n\t\t} break;\n\t\tcase 0x0600:\n\t\t\tnsjconf->no_pivotroot = true;\n\t\t\tbreak;\n\t\tcase 0x0601:\n\t\t\tnsjconf->is_root_rw = true;\n\t\t\tbreak;\n\t\tcase 0x0603:\n\t\t\tnsjconf->proc_path.clear();\n\t\t\tbreak;\n\t\tcase 0x0605:\n\t\t\tnsjconf->proc_path = optarg;\n\t\t\tbreak;\n\t\tcase 0x0606:\n\t\t\tnsjconf->is_proc_rw = true;\n\t\t\tbreak;\n\t\tcase 0x0607:\n\t\t\tnsjconf->use_execveat = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\taddEnv(nsjconf.get(), optarg);\n\t\t\tbreak;\n\t\tcase 'u': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string i_id = argFromVec(subopts, 0);\n\t\t\tstd::string o_id = argFromVec(subopts, 1);\n\t\t\tstd::string cnt = argFromVec(subopts, 2);\n\t\t\tsize_t count = strtoul(cnt.c_str(), nullptr, 0);\n\t\t\tif (!user::parseId(nsjconf.get(), i_id, o_id, count,\n\t\t\t\t/* is_gid= */ false,\n\t\t\t\t/* is_newidmap= */ false)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t} break;\n\t\tcase 'g': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string i_id = argFromVec(subopts, 0);\n\t\t\tstd::string o_id = argFromVec(subopts, 1);\n\t\t\tstd::string cnt = argFromVec(subopts, 2);\n\t\t\tsize_t count = strtoul(cnt.c_str(), nullptr, 0);\n\t\t\tif (!user::parseId(nsjconf.get(), i_id, o_id, count,\n\t\t\t\t/* is_gid= */ true,\n\t\t\t\t/* is_newidmap= */ false)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t} break;\n\t\tcase 'U': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string i_id = argFromVec(subopts, 0);\n\t\t\tstd::string o_id = argFromVec(subopts, 1);\n\t\t\tstd::string cnt = argFromVec(subopts, 2);\n\t\t\tsize_t count = strtoul(cnt.c_str(), nullptr, 0);\n\t\t\tif (!user::parseId(nsjconf.get(), i_id, o_id, count,\n\t\t\t\t/* is_gid= */ false,\n\t\t\t\t/* is_newidmap= */ true)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t} break;\n\t\tcase 'G': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string i_id = argFromVec(subopts, 0);\n\t\t\tstd::string o_id = argFromVec(subopts, 1);\n\t\t\tstd::string cnt = argFromVec(subopts, 2);\n\t\t\tsize_t count = strtoul(cnt.c_str(), nullptr, 0);\n\t\t\tif (!user::parseId(nsjconf.get(), i_id, o_id, count,\n\t\t\t\t/* is_gid= */ true,\n\t\t\t\t/* is_newidmap= */ true)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t} break;\n\t\tcase 'R': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string src = argFromVec(subopts, 0);\n\t\t\tstd::string dst = argFromVec(subopts, 1);\n\t\t\tif (dst.empty()) {\n\t\t\t\tdst = src;\n\t\t\t}\n\t\t\tif (!mnt::addMountPtTail(nsjconf.get(), src, dst, /* fstype= */ \"\",\n\t\t\t\t/* options= */ \"\", MS_BIND | MS_REC | MS_PRIVATE | MS_RDONLY,\n\t\t\t\t/* is_dir= */ mnt::NS_DIR_MAYBE, /* is_mandatory= */ true,\n\t\t\t\t/* src_env= */ \"\", /* dst_env= */ \"\", /* src_content= */ \"\",\n\t\t\t\t/* is_symlink= */ false)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t}; break;\n\t\tcase 'B': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string src = argFromVec(subopts, 0);\n\t\t\tstd::string dst = argFromVec(subopts, 1);\n\t\t\tif (dst.empty()) {\n\t\t\t\tdst = src;\n\t\t\t}\n\t\t\tif (!mnt::addMountPtTail(nsjconf.get(), src, dst, /* fstype= */ \"\",\n\t\t\t\t/* options= */ \"\", MS_BIND | MS_REC | MS_PRIVATE,\n\t\t\t\t/* is_dir= */ mnt::NS_DIR_MAYBE, /* is_mandatory= */ true,\n\t\t\t\t/* src_env= */ \"\", /* dst_env= */ \"\", /* src_content= */ \"\",\n\t\t\t\t/* is_symlink= */ false)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t}; break;\n\t\tcase 'T': {\n\t\t\tif (!mnt::addMountPtTail(nsjconf.get(), \"\", optarg, /* fstype= */ \"tmpfs\",\n\t\t\t\t/* options= */ \"size=4194304\", 0,\n\t\t\t\t/* is_dir= */ mnt::NS_DIR_YES, /* is_mandatory= */ true,\n\t\t\t\t/* src_env= */ \"\", /* dst_env= */ \"\", /* src_content= */ \"\",\n\t\t\t\t/* is_symlink= */ false)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t}; break;\n\t\tcase 'm': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string src = argFromVec(subopts, 0);\n\t\t\tstd::string dst = argFromVec(subopts, 1);\n\t\t\tif (dst.empty()) {\n\t\t\t\tdst = src;\n\t\t\t}\n\t\t\tstd::string fs_type = argFromVec(subopts, 2);\n\t\t\tstd::stringstream optionsStream;\n\t\t\toptionsStream << argFromVec(subopts, 3);\n\t\t\tfor (std::size_t i = 4; i < subopts.size(); ++i) {\n\t\t\t\toptionsStream << \":\" << subopts[i];\n\t\t\t}\n\t\t\tstd::string options = optionsStream.str();\n\t\t\tif (!mnt::addMountPtTail(nsjconf.get(), src, dst, /* fstype= */ fs_type,\n\t\t\t\t/* options= */ options, /* flags= */ 0,\n\t\t\t\t/* is_dir= */ mnt::NS_DIR_MAYBE, /* is_mandatory= */ true,\n\t\t\t\t/* src_env= */ \"\", /* dst_env= */ \"\", /* src_content= */ \"\",\n\t\t\t\t/* is_symlink= */ false)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t}; break;\n\t\tcase 's': {\n\t\t\tstd::vector<std::string> subopts = util::strSplit(optarg, ':');\n\t\t\tstd::string src = argFromVec(subopts, 0);\n\t\t\tstd::string dst = argFromVec(subopts, 1);\n\t\t\tif (!mnt::addMountPtTail(nsjconf.get(), src, dst, /* fstype= */ \"\",\n\t\t\t\t/* options= */ \"\", /* flags= */ 0,\n\t\t\t\t/* is_dir= */ mnt::NS_DIR_NO, /* is_mandatory= */ true,\n\t\t\t\t/* src_env= */ \"\", /* dst_env= */ \"\", /* src_content= */ \"\",\n\t\t\t\t/* is_symlink= */ true)) {\n\t\t\t\treturn nullptr;\n\t\t\t}\n\t\t}; break;\n\t\tcase 'M':\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase 'l':\n\t\t\t\tnsjconf->mode = MODE_LISTEN_TCP;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tnsjconf->mode = MODE_STANDALONE_ONCE;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tnsjconf->mode = MODE_STANDALONE_EXECVE;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tnsjconf->mode = MODE_STANDALONE_RERUN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_E(\"Modes supported: -M l - MODE_LISTEN_TCP (default)\");\n\t\t\t\tLOG_E(\"                 -M o - MODE_STANDALONE_ONCE\");\n\t\t\t\tLOG_E(\"                 -M r - MODE_STANDALONE_RERUN\");\n\t\t\t\tLOG_E(\"                 -M e - MODE_STANDALONE_EXECVE\");\n\t\t\t\tcmdlineUsage(argv[0]);\n\t\t\t\treturn nullptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x700:\n\t\t\tnsjconf->iface_lo = false;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tnsjconf->iface_vs = optarg;\n\t\t\tbreak;\n\t\tcase 0x701:\n\t\t\tnsjconf->iface_vs_ip = optarg;\n\t\t\tbreak;\n\t\tcase 0x702:\n\t\t\tnsjconf->iface_vs_nm = optarg;\n\t\t\tbreak;\n\t\tcase 0x703:\n\t\t\tnsjconf->iface_vs_gw = optarg;\n\t\t\tbreak;\n\t\tcase 0x704:\n\t\t\tnsjconf->ifaces.push_back(optarg);\n\t\t\tbreak;\n\t\tcase 0x705:\n\t\t\tnsjconf->iface_vs_ma = optarg;\n\t\t\tbreak;\n\t\tcase 0x706:\n\t\t\tnsjconf->iface_vs_mo = parseMACVlanMode(optarg);\n\t\t\tbreak;\n\t\tcase 0x707:\n\t\t\tnsjconf->disable_tsc = true;\n\t\t\tbreak;\n\t\tcase 0x708:\n\t\t\tnsjconf->forward_signals = true;\n\t\t\tbreak;\n\t\tcase 0x801:\n\t\t\tnsjconf->cgroup_mem_max = (size_t)strtoull(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 0x802:\n\t\t\tnsjconf->cgroup_mem_mount = optarg;\n\t\t\tbreak;\n\t\tcase 0x803:\n\t\t\tnsjconf->cgroup_mem_parent = optarg;\n\t\t\tbreak;\n\t\tcase 0x804:\n\t\t\tnsjconf->cgroup_mem_memsw_max = (size_t)strtoull(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 0x805:\n\t\t\tnsjconf->cgroup_mem_swap_max = (ssize_t)strtoll(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 0x811:\n\t\t\tnsjconf->cgroup_pids_max = (unsigned int)strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 0x812:\n\t\t\tnsjconf->cgroup_pids_mount = optarg;\n\t\t\tbreak;\n\t\tcase 0x813:\n\t\t\tnsjconf->cgroup_pids_parent = optarg;\n\t\t\tbreak;\n\t\tcase 0x821:\n\t\t\tnsjconf->cgroup_net_cls_classid = (unsigned int)strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 0x822:\n\t\t\tnsjconf->cgroup_net_cls_mount = optarg;\n\t\t\tbreak;\n\t\tcase 0x823:\n\t\t\tnsjconf->cgroup_net_cls_parent = optarg;\n\t\t\tbreak;\n\t\tcase 0x831:\n\t\t\tnsjconf->cgroup_cpu_ms_per_sec = (unsigned int)strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 0x832:\n\t\t\tnsjconf->cgroup_cpu_mount = optarg;\n\t\t\tbreak;\n\t\tcase 0x833:\n\t\t\tnsjconf->cgroup_cpu_parent = optarg;\n\t\t\tbreak;\n\t\tcase 0x834:\n\t\t\tnsjconf->cgroupv2_mount = optarg;\n\t\t\tbreak;\n\t\tcase 0x835:\n\t\t\tnsjconf->use_cgroupv2 = true;\n\t\t\tbreak;\n\t\tcase 0x836:\n\t\t\tnsjconf->detect_cgroupv2 = true;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tnsjconf->kafel_file_path = optarg;\n\t\t\tbreak;\n\t\tcase 0x901:\n\t\t\tnsjconf->kafel_string = optarg;\n\t\t\tbreak;\n\t\tcase 0x902:\n\t\t\tnsjconf->seccomp_log = true;\n\t\t\tbreak;\n\t\tcase 0x903:\n\t\t\tnsjconf->nice_level = (int)strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmdlineUsage(argv[0]);\n\t\t\treturn nullptr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nsjconf->daemonize && !logs::logSet()) {\n\t\tlogs::logFile(_LOG_DEFAULT_FILE, STDERR_FILENO);\n\t}\n\tif (!setupMounts(nsjconf.get())) {\n\t\treturn nullptr;\n\t}\n\tif (!setupArgv(nsjconf.get(), argc, argv, optind)) {\n\t\treturn nullptr;\n\t}\n\tsetupUsers(nsjconf.get());\n\n\tif (nsjconf->cgroup_mem_memsw_max > (size_t)0 &&\n\t    nsjconf->cgroup_mem_swap_max >= (ssize_t)0) {\n\t\tLOG_F(\"cannot set both cgroup_mem_memsw_max and cgroup_mem_swap_max\");\n\t}\n\n\treturn nsjconf;\n}\n\n}  // namespace cmdline\n"
        },
        {
          "name": "cmdline.h",
          "type": "blob",
          "size": 1.076171875,
          "content": "/*\n\n   nsjail - cmdline parsing\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_CMDLINE_H\n#define NS_CMDLINE_H\n\n#include <stdint.h>\n\n#include <memory>\n#include <string>\n\n#include \"nsjail.h\"\n\nnamespace cmdline {\n\nuint64_t parseRLimit(int res, const char* optarg, unsigned long mul);\nvoid logParams(nsjconf_t* nsjconf);\nvoid addEnv(nsjconf_t* nsjconf, const std::string& env);\nstd::unique_ptr<nsjconf_t> parseArgs(int argc, char* argv[]);\n\n}  // namespace cmdline\n\n#endif /* _CMDLINE_H */\n"
        },
        {
          "name": "config.cc",
          "type": "blob",
          "size": 11.494140625,
          "content": "/*\n\n   nsjail - config parsing\n   -----------------------------------------\n\n   Copyright 2017 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"config.h\"\n\n#include <fcntl.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include <google/protobuf/text_format.h>\n#include <google/protobuf/util/json_util.h>\n#include <stdio.h>\n#include <sys/mount.h>\n#include <sys/personality.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <list>\n#include <string>\n\n#include \"caps.h\"\n#include \"cmdline.h\"\n#include \"config.pb.h\"\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"mnt.h\"\n#include \"user.h\"\n#include \"util.h\"\n\nnamespace config {\n\nstatic uint64_t adjustRLimit(\n    int res, const nsjail::RLimit& rl, const uint64_t val, unsigned long mul = 1UL) {\n\tif (rl == nsjail::RLimit::VALUE) {\n\t\treturn (val * mul);\n\t}\n\tif (rl == nsjail::RLimit::SOFT) {\n\t\treturn cmdline::parseRLimit(res, \"soft\", mul);\n\t}\n\tif (rl == nsjail::RLimit::HARD) {\n\t\treturn cmdline::parseRLimit(res, \"hard\", mul);\n\t}\n\tif (rl == nsjail::RLimit::INF) {\n\t\treturn RLIM64_INFINITY;\n\t}\n\tLOG_F(\"Unknown rlimit value type for rlimit:%d\", res);\n\tabort();\n}\n\nstatic bool parseInternal(nsjconf_t* nsjconf, const nsjail::NsJailConfig& njc) {\n\tswitch (njc.mode()) {\n\tcase nsjail::Mode::LISTEN:\n\t\tnsjconf->mode = MODE_LISTEN_TCP;\n\t\tbreak;\n\tcase nsjail::Mode::ONCE:\n\t\tnsjconf->mode = MODE_STANDALONE_ONCE;\n\t\tbreak;\n\tcase nsjail::Mode::RERUN:\n\t\tnsjconf->mode = MODE_STANDALONE_RERUN;\n\t\tbreak;\n\tcase nsjail::Mode::EXECVE:\n\t\tnsjconf->mode = MODE_STANDALONE_EXECVE;\n\t\tbreak;\n\tdefault:\n\t\tLOG_E(\"Unknown running mode: %d\", njc.mode());\n\t\treturn false;\n\t}\n\tnsjconf->hostname = njc.hostname();\n\tnsjconf->cwd = njc.cwd();\n\tnsjconf->port = njc.port();\n\tnsjconf->bindhost = njc.bindhost();\n\tnsjconf->max_conns = njc.max_conns();\n\tnsjconf->max_conns_per_ip = njc.max_conns_per_ip();\n\tnsjconf->tlimit = njc.time_limit();\n\tnsjconf->max_cpus = njc.max_cpus();\n\tnsjconf->daemonize = njc.daemon();\n\n\tif (njc.has_log_fd()) {\n\t\tlogs::logFile(\"\", njc.log_fd());\n\t}\n\tif (njc.has_log_file()) {\n\t\tlogs::logFile(njc.log_file(), STDERR_FILENO);\n\t}\n\n\tif (njc.has_log_level()) {\n\t\tswitch (njc.log_level()) {\n\t\tcase nsjail::LogLevel::DEBUG:\n\t\t\tlogs::setLogLevel(logs::DEBUG);\n\t\t\tbreak;\n\t\tcase nsjail::LogLevel::INFO:\n\t\t\tlogs::setLogLevel(logs::INFO);\n\t\t\tbreak;\n\t\tcase nsjail::LogLevel::WARNING:\n\t\t\tlogs::setLogLevel(logs::WARNING);\n\t\t\tbreak;\n\t\tcase nsjail::LogLevel::ERROR:\n\t\t\tlogs::setLogLevel(logs::ERROR);\n\t\t\tbreak;\n\t\tcase nsjail::LogLevel::FATAL:\n\t\t\tlogs::setLogLevel(logs::FATAL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_E(\"Unknown log_level: %d\", njc.log_level());\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tnsjconf->keep_env = njc.keep_env();\n\tfor (ssize_t i = 0; i < njc.envar_size(); i++) {\n\t\tcmdline::addEnv(nsjconf, njc.envar(i));\n\t}\n\n\tnsjconf->keep_caps = njc.keep_caps();\n\tfor (ssize_t i = 0; i < njc.cap_size(); i++) {\n\t\tint cap = caps::nameToVal(njc.cap(i).c_str());\n\t\tif (cap == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tnsjconf->caps.push_back(cap);\n\t}\n\n\tnsjconf->is_silent = njc.silent();\n\tnsjconf->skip_setsid = njc.skip_setsid();\n\n\tfor (ssize_t i = 0; i < njc.pass_fd_size(); i++) {\n\t\tnsjconf->openfds.push_back(njc.pass_fd(i));\n\t}\n\n\tnsjconf->stderr_to_null = njc.stderr_to_null();\n\tnsjconf->disable_no_new_privs = njc.disable_no_new_privs();\n\n\tnsjconf->rl_as =\n\t    adjustRLimit(RLIMIT_AS, njc.rlimit_as_type(), njc.rlimit_as(), 1024UL * 1024UL);\n\tnsjconf->rl_core =\n\t    adjustRLimit(RLIMIT_CORE, njc.rlimit_core_type(), njc.rlimit_core(), 1024UL * 1024UL);\n\tnsjconf->rl_cpu = adjustRLimit(RLIMIT_CPU, njc.rlimit_cpu_type(), njc.rlimit_cpu());\n\tnsjconf->rl_fsize = adjustRLimit(\n\t    RLIMIT_FSIZE, njc.rlimit_fsize_type(), njc.rlimit_fsize(), 1024UL * 1024UL);\n\tnsjconf->rl_nofile =\n\t    adjustRLimit(RLIMIT_NOFILE, njc.rlimit_nofile_type(), njc.rlimit_nofile());\n\tnsjconf->rl_nproc = adjustRLimit(RLIMIT_NPROC, njc.rlimit_nproc_type(), njc.rlimit_nproc());\n\tnsjconf->rl_stack = adjustRLimit(\n\t    RLIMIT_STACK, njc.rlimit_stack_type(), njc.rlimit_stack(), 1024UL * 1024UL);\n\tnsjconf->rl_mlock =\n\t    adjustRLimit(RLIMIT_MEMLOCK, njc.rlimit_memlock_type(), njc.rlimit_memlock(), 1024UL);\n\tnsjconf->rl_rtpr =\n\t    adjustRLimit(RLIMIT_RTPRIO, njc.rlimit_rtprio_type(), njc.rlimit_rtprio());\n\tnsjconf->rl_msgq =\n\t    adjustRLimit(RLIMIT_MSGQUEUE, njc.rlimit_msgqueue_type(), njc.rlimit_msgqueue());\n\n\tnsjconf->disable_rl = njc.disable_rl();\n\n\tif (njc.persona_addr_compat_layout()) {\n\t\tnsjconf->personality |= ADDR_COMPAT_LAYOUT;\n\t}\n\tif (njc.persona_mmap_page_zero()) {\n\t\tnsjconf->personality |= MMAP_PAGE_ZERO;\n\t}\n\tif (njc.persona_read_implies_exec()) {\n\t\tnsjconf->personality |= READ_IMPLIES_EXEC;\n\t}\n\tif (njc.persona_addr_limit_3gb()) {\n\t\tnsjconf->personality |= ADDR_LIMIT_3GB;\n\t}\n\tif (njc.persona_addr_no_randomize()) {\n\t\tnsjconf->personality |= ADDR_NO_RANDOMIZE;\n\t}\n\n\tnsjconf->clone_newnet = njc.clone_newnet();\n\tnsjconf->clone_newuser = njc.clone_newuser();\n\tnsjconf->clone_newns = njc.clone_newns();\n\tnsjconf->clone_newpid = njc.clone_newpid();\n\tnsjconf->clone_newipc = njc.clone_newipc();\n\tnsjconf->clone_newuts = njc.clone_newuts();\n\tnsjconf->clone_newcgroup = njc.clone_newcgroup();\n\tnsjconf->clone_newtime = njc.clone_newtime();\n\n\tnsjconf->no_pivotroot = njc.no_pivotroot();\n\n\tfor (ssize_t i = 0; i < njc.uidmap_size(); i++) {\n\t\tif (!user::parseId(nsjconf, njc.uidmap(i).inside_id(), njc.uidmap(i).outside_id(),\n\t\t\tnjc.uidmap(i).count(), false /* is_gid */, njc.uidmap(i).use_newidmap())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (ssize_t i = 0; i < njc.gidmap_size(); i++) {\n\t\tif (!user::parseId(nsjconf, njc.gidmap(i).inside_id(), njc.gidmap(i).outside_id(),\n\t\t\tnjc.gidmap(i).count(), true /* is_gid */, njc.gidmap(i).use_newidmap())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!njc.mount_proc()) {\n\t\tnsjconf->proc_path.clear();\n\t}\n\tfor (ssize_t i = 0; i < njc.mount_size(); i++) {\n\t\tstd::string src = njc.mount(i).src();\n\t\tstd::string src_env = njc.mount(i).prefix_src_env();\n\t\tstd::string dst = njc.mount(i).dst();\n\t\tstd::string dst_env = njc.mount(i).prefix_dst_env();\n\t\tstd::string fstype = njc.mount(i).fstype();\n\t\tstd::string options = njc.mount(i).options();\n\n\t\tuintptr_t flags = (!njc.mount(i).rw()) ? MS_RDONLY : 0;\n\t\tflags |= njc.mount(i).is_bind() ? (MS_BIND | MS_REC | MS_PRIVATE) : 0;\n\t\tflags |= njc.mount(i).nosuid() ? MS_NOSUID : 0;\n\t\tflags |= njc.mount(i).nodev() ? MS_NODEV : 0;\n\t\tflags |= njc.mount(i).noexec() ? MS_NOEXEC : 0;\n\t\tbool is_mandatory = njc.mount(i).mandatory();\n\t\tbool is_symlink = njc.mount(i).is_symlink();\n\t\tstd::string src_content = njc.mount(i).src_content();\n\n\t\tmnt::isDir_t is_dir = mnt::NS_DIR_MAYBE;\n\t\tif (njc.mount(i).has_is_dir()) {\n\t\t\tis_dir = njc.mount(i).is_dir() ? mnt::NS_DIR_YES : mnt::NS_DIR_NO;\n\t\t}\n\n\t\tif (!mnt::addMountPtTail(nsjconf, src, dst, fstype, options, flags, is_dir,\n\t\t\tis_mandatory, src_env, dst_env, src_content, is_symlink)) {\n\t\t\tLOG_E(\"Couldn't add mountpoint for src:%s dst:%s\", QC(src), QC(dst));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (njc.has_seccomp_policy_file()) {\n\t\tnsjconf->kafel_file_path = njc.seccomp_policy_file();\n\t}\n\tfor (ssize_t i = 0; i < njc.seccomp_string().size(); i++) {\n\t\tnsjconf->kafel_string += njc.seccomp_string(i);\n\t\tnsjconf->kafel_string += '\\n';\n\t}\n\tnsjconf->seccomp_log = njc.seccomp_log();\n\tnsjconf->nice_level = njc.nice_level();\n\n\tnsjconf->cgroup_mem_max = njc.cgroup_mem_max();\n\tnsjconf->cgroup_mem_memsw_max = njc.cgroup_mem_memsw_max();\n\tnsjconf->cgroup_mem_swap_max = njc.cgroup_mem_swap_max();\n\tnsjconf->cgroup_mem_mount = njc.cgroup_mem_mount();\n\tnsjconf->cgroup_mem_parent = njc.cgroup_mem_parent();\n\tnsjconf->cgroup_pids_max = njc.cgroup_pids_max();\n\tnsjconf->cgroup_pids_mount = njc.cgroup_pids_mount();\n\tnsjconf->cgroup_pids_parent = njc.cgroup_pids_parent();\n\tnsjconf->cgroup_net_cls_classid = njc.cgroup_net_cls_classid();\n\tnsjconf->cgroup_net_cls_mount = njc.cgroup_net_cls_mount();\n\tnsjconf->cgroup_net_cls_parent = njc.cgroup_net_cls_parent();\n\tnsjconf->cgroup_cpu_ms_per_sec = njc.cgroup_cpu_ms_per_sec();\n\tnsjconf->cgroup_cpu_mount = njc.cgroup_cpu_mount();\n\tnsjconf->cgroup_cpu_parent = njc.cgroup_cpu_parent();\n\tnsjconf->cgroupv2_mount = njc.cgroupv2_mount();\n\tnsjconf->use_cgroupv2 = njc.use_cgroupv2();\n\tnsjconf->detect_cgroupv2 = njc.detect_cgroupv2();\n\n\tnsjconf->iface_lo = !(njc.iface_no_lo());\n\tfor (ssize_t i = 0; i < njc.iface_own().size(); i++) {\n\t\tnsjconf->ifaces.push_back(njc.iface_own(i));\n\t}\n\tif (njc.has_macvlan_iface()) {\n\t\tnsjconf->iface_vs = njc.macvlan_iface();\n\t}\n\tnsjconf->iface_vs_ip = njc.macvlan_vs_ip();\n\tnsjconf->iface_vs_nm = njc.macvlan_vs_nm();\n\tnsjconf->iface_vs_gw = njc.macvlan_vs_gw();\n\tnsjconf->iface_vs_ma = njc.macvlan_vs_ma();\n\tnsjconf->iface_vs_mo = njc.macvlan_vs_mo();\n\n\tnsjconf->disable_tsc = njc.disable_tsc();\n\n\tnsjconf->forward_signals = njc.forward_signals();\n\n\tif (njc.has_exec_bin()) {\n\t\tif (njc.exec_bin().has_path()) {\n\t\t\tnsjconf->exec_file = njc.exec_bin().path();\n\t\t\tnsjconf->argv.push_back(njc.exec_bin().path());\n\t\t}\n\t\tfor (ssize_t i = 0; i < njc.exec_bin().arg().size(); i++) {\n\t\t\tnsjconf->argv.push_back(njc.exec_bin().arg(i));\n\t\t}\n\t\tif (njc.exec_bin().has_arg0()) {\n\t\t\tnsjconf->argv[0] = njc.exec_bin().arg0();\n\t\t}\n\t\tnsjconf->use_execveat = njc.exec_bin().exec_fd();\n\t}\n\n\treturn true;\n}\n\nstatic std::list<std::string> error_messages;\n\nstatic void logHandler(\n    google::protobuf::LogLevel level, const char* filename, int line, const std::string& message) {\n\terror_messages.push_back(message);\n}\n\nstatic void flushLog() {\n\tfor (auto message : error_messages) {\n\t\tLOG_W(\"ProtoTextFormat: %s\", message.c_str());\n\t}\n\terror_messages.clear();\n}\n\nbool parseFile(nsjconf_t* nsjconf, const char* file) {\n\tLOG_D(\"Parsing configuration from %s\", QC(file));\n\n\tstd::string conf;\n\tif (!util::readFromFileToStr(file, &conf)) {\n\t\tLOG_E(\"Couldn't read config file %s\", QC(file));\n\t\treturn false;\n\t}\n\tif (conf.empty()) {\n\t\tLOG_E(\"Config file %s is empty\", QC(file));\n\t\treturn false;\n\t}\n\n\t/* Use static so we can get c_str() pointers, and copy them into the nsjconf struct */\n\tstatic nsjail::NsJailConfig json_nsc;\n\tstatic nsjail::NsJailConfig text_nsc;\n\n\tgoogle::protobuf::SetLogHandler(logHandler);\n\tauto json_status = google::protobuf::util::JsonStringToMessage(conf, &json_nsc);\n\tbool text_parsed = google::protobuf::TextFormat::ParseFromString(conf, &text_nsc);\n\n\tif (json_status.ok() && text_parsed) {\n\t\tLOG_W(\"Config file %s ambiguously parsed as TextProto and ProtoJSON\", QC(file));\n\t\treturn false;\n\t}\n\n\tif (!json_status.ok() && !text_parsed) {\n\t\tLOG_E(\"Config file %s failed to parse as either TextProto or ProtoJSON\", QC(file));\n\t\tflushLog();\n\t\tLOG_W(\"ProtoJSON parse status: '%s'\", json_status.ToString().c_str());\n\t\treturn false;\n\t}\n\n\tif (json_status.ok() && !text_parsed) {\n\t\tif (!parseInternal(nsjconf, json_nsc)) {\n\t\t\tLOG_W(\"Couldn't parse the ProtoJSON from %s\", QC(file));\n\t\t\treturn false;\n\t\t}\n\t\tLOG_D(\n\t\t    \"Parsed JSON config from %s:\\n'%s'\", QC(file), json_nsc.DebugString().c_str());\n\t\treturn true;\n\t}\n\n\tif (text_parsed && !json_status.ok()) {\n\t\tif (!parseInternal(nsjconf, text_nsc)) {\n\t\t\tLOG_W(\"Couldn't parse the TextProto from %s\", QC(file));\n\t\t\treturn false;\n\t\t}\n\t\tLOG_D(\"Parsed TextProto config from %s:\\n'%s'\", QC(file),\n\t\t    text_nsc.DebugString().c_str());\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n}  // namespace config\n"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 0.87109375,
          "content": "/*\n\n   nsjail - config parsing\n   -----------------------------------------\n\n   Copyright 2017 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_CONFIG_H\n#define NS_CONFIG_H\n\n#include <stdbool.h>\n\n#include \"nsjail.h\"\n\nnamespace config {\n\nbool parseFile(nsjconf_t* nsjconf, const char* file);\n\n}  // namespace config\n\n#endif /*  NS_CONFIG_H */\n"
        },
        {
          "name": "config.proto",
          "type": "blob",
          "size": 12.1875,
          "content": "syntax = \"proto2\";\n\npackage nsjail;\n\nenum Mode {\n\tLISTEN = 0; /* Listening on a TCP port */\n\tONCE = 1;   /* Running the command once only */\n\tRERUN = 2;  /* Re-executing the command (forever) */\n\tEXECVE = 3; /* Executing command w/o the supervisor */\n}\n/* Should be self explanatory */\nenum LogLevel {\n\tDEBUG = 0;   /* Equivalent to the '-v' cmd-line option */\n\tINFO = 1;    /* Default level */\n\tWARNING = 2; /* Equivalent to the '-q' cmd-line option */\n\tERROR = 3;\n\tFATAL = 4;\n}\nmessage IdMap {\n\t/* Empty string means \"current uid/gid\" */\n\toptional string inside_id = 1 [default = \"\"];\n\toptional string outside_id = 2 [default = \"\"];\n\t/* See 'man user_namespaces' for the meaning of count */\n\toptional uint32 count = 3 [default = 1];\n\t/* Does this map use /usr/bin/new[u|g]idmap binary? */\n\toptional bool use_newidmap = 4 [default = false];\n}\nmessage MountPt {\n\t/* Can be skipped for filesystems like 'proc' */\n\toptional string src = 1 [default = \"\"];\n\t/* Should 'src' path be prefixed with this envar? */\n\toptional string prefix_src_env = 2 [default = \"\"];\n\t/* If specified, contains buffer that will be written to the dst file */\n\toptional bytes src_content = 3 [default = \"\"];\n\t/* Mount point inside jail */\n\trequired string dst = 4 [default = \"\"];\n\t/* Should 'dst' path be prefixed with this envar? */\n\toptional string prefix_dst_env = 5 [default = \"\"];\n\t/* Can be empty for mount --bind mounts */\n\toptional string fstype = 6 [default = \"\"];\n\t/* E.g. size=5000000 for 'tmpfs' */\n\toptional string options = 7 [default = \"\"];\n\t/* Is it a 'mount --bind src dst' type of mount? */\n\toptional bool is_bind = 8 [default = false];\n\t/* Is it a R/W mount? */\n\toptional bool rw = 9 [default = false];\n\t/* Is it a directory? If not specified an internal\n\t   heuristics will be used to determine that */\n\toptional bool is_dir = 10;\n\t/* Should the sandboxing fail if we cannot mount this resource? */\n\toptional bool mandatory = 11 [default = true];\n\t/* Is it a symlink (instead of real mount point)? */\n\toptional bool is_symlink = 12 [default = false];\n\t/* Is it a nosuid mount */\n\toptional bool nosuid = 13 [default = false];\n\t/* Is it a nodev mount */\n\toptional bool nodev = 14 [default = false];\n\t/* Is it a noexec mount */\n\toptional bool noexec = 15 [default = false];\n}\nenum RLimit {\n\tVALUE = 0; /* Use the provided value */\n\tSOFT = 1;  /* Use the current soft rlimit */\n\tHARD = 2;  /* Use the current hard rlimit */\n\tINF = 3;   /* Use RLIM64_INFINITY */\n}\nmessage Exe {\n\t/* Will be used both as execv's path and as argv[0] */\n\trequired string path = 1;\n\t/* This will be argv[1] and so on.. */\n\trepeated string arg = 2;\n\t/* Override argv[0] */\n\toptional string arg0 = 3;\n\t/* Should execveat() be used to execute a file-descriptor instead? */\n\toptional bool exec_fd = 4 [default = false];\n}\nmessage NsJailConfig {\n\t/* Optional name and description for this config */\n\toptional string name = 1 [default = \"\"];\n\trepeated string description = 2;\n\n\t/* Execution mode: see 'msg Mode' description for more */\n\toptional Mode mode = 3 [default = ONCE];\n\t/* Hostname inside jail */\n\toptional string hostname = 4 [default = \"NSJAIL\"];\n\t/* Initial current working directory for the binary */\n\toptional string cwd = 5 [default = \"/\"];\n\n\t/* Defines whether to use switch_root or pivot_root */\n\toptional bool no_pivotroot = 6 [default = false];\n\n\t/* TCP port to listen to. Valid with mode=LISTEN only */\n\toptional uint32 port = 7 [default = 0];\n\t/* Host to bind to for mode=LISTEN. Must be in IPv6 format */\n\toptional string bindhost = 8 [default = \"::\"];\n\t/* For mode=LISTEN, maximum number of connections across all IPs */\n\toptional uint32 max_conns = 9 [default = 0];\n\t/* For mode=LISTEN, maximum number of connections from a single IP */\n\toptional uint32 max_conns_per_ip = 10 [default = 0];\n\n\t/* Wall-time time limit for commands */\n\toptional uint32 time_limit = 11 [default = 600];\n\t/* Should nsjail go into background? */\n\toptional bool daemon = 12 [default = false];\n\t/* Maximum number of CPUs to use: 0 - no limit */\n\toptional uint32 max_cpus = 13 [default = 0];\n\t/* Niceness level of the jailed process */\n\toptional int32 nice_level = 14 [default = 19];\n\n\t/* FD to log to. */\n\toptional int32 log_fd = 15;\n\t/* File to save logs to. */\n\toptional string log_file = 16;\n\t/* Minimum log level displayed.\n\t   See 'msg LogLevel' description for more */\n\toptional LogLevel log_level = 17;\n\n\t/* Should the current environment variables be kept\n\t   when executing the binary */\n\toptional bool keep_env = 18 [default = false];\n\t/* EnvVars to be set before executing binaries. If the envar doesn't contain '='\n\t   (e.g. just the 'DISPLAY' string), the current envar value will be used */\n\trepeated string envar = 19;\n\n\t/* Should capabilities be preserved or dropped */\n\toptional bool keep_caps = 20 [default = false];\n\t/* Which capabilities should be preserved if keep_caps == false.\n\t   Format: \"CAP_SYS_PTRACE\" */\n\trepeated string cap = 21;\n\t/* Should nsjail close FD=0,1,2 before executing the process */\n\toptional bool silent = 22 [default = false];\n\t/* Should the child process have control over terminal?\n\t   Can be useful to allow /bin/sh to provide\n\t   job control / signals. Dangerous, can be used to put\n\t   characters into the controlling terminal back */\n\toptional bool skip_setsid = 23 [default = false];\n\t/* Redirect sdterr of the process to /dev/null instead of the socket or original TTY */\n\toptional bool stderr_to_null = 24 [default = false];\n\t/* Which FDs should be passed to the newly executed process\n\t   By default only FD=0,1,2 are passed */\n\trepeated int32 pass_fd = 25;\n\t/* Setting it to true will allow to have set-uid binaries\n\t   inside the jail */\n\toptional bool disable_no_new_privs = 26 [default = false];\n\t/* Set this to true to forward fatal signals to the child process instead\n\t * of always using SIGKILL. */\n\toptional bool forward_signals = 27 [default = false];\n\t/* Disable rdtsc and rdtscp instructions. WARNING: To make it effective, you also need to\n\t * forbid `prctl(PR_SET_TSC, PR_TSC_ENABLE, ...)` in seccomp rules! (x86 and x86_64 only).\n\t * Dynamic binaries produced by GCC seem to rely on RDTSC, but static ones should work. */\n\toptional bool disable_tsc = 28 [default = false];\n\n\t/* Various rlimits, the rlimit_as/rlimit_core/... are used only if\n\t   rlimit_as_type/rlimit_core_type/... are set to RLimit::VALUE */\n\toptional uint64 rlimit_as = 29 [default = 4096]; /* In MiB */\n\toptional RLimit rlimit_as_type = 30 [default = VALUE];\n\toptional uint64 rlimit_core = 31 [default = 0]; /* In MiB */\n\toptional RLimit rlimit_core_type = 32 [default = VALUE];\n\toptional uint64 rlimit_cpu = 33 [default = 600]; /* In seconds */\n\toptional RLimit rlimit_cpu_type = 34 [default = VALUE];\n\toptional uint64 rlimit_fsize = 35 [default = 1]; /* In MiB */\n\toptional RLimit rlimit_fsize_type = 36 [default = VALUE];\n\toptional uint64 rlimit_nofile = 37 [default = 32];\n\toptional RLimit rlimit_nofile_type = 38 [default = VALUE];\n\t/* RLIMIT_NPROC is system-wide - tricky to use; use the soft limit value by\n\t * default here */\n\toptional uint64 rlimit_nproc = 39 [default = 1024];\n\toptional RLimit rlimit_nproc_type = 40 [default = SOFT];\n\t/* In MiB, use the soft limit value by default */\n\toptional uint64 rlimit_stack = 41 [default = 8];\n\toptional RLimit rlimit_stack_type = 42 [default = SOFT];\n\t/* In KB, use the soft limit value by default */\n\toptional uint64 rlimit_memlock = 43 [default = 64];\n\toptional RLimit rlimit_memlock_type = 44 [default = SOFT];\n\toptional uint64 rlimit_rtprio = 45 [default = 0];\n\toptional RLimit rlimit_rtprio_type = 46 [default = SOFT];\n\toptional uint64 rlimit_msgqueue = 47 [default = 1024]; /* In bytes */\n\toptional RLimit rlimit_msgqueue_type = 48 [default = SOFT];\n\n\t/* Disable all rlimits, default to limits set by parent */\n\toptional bool disable_rl = 49 [default = false];\n\n\t/* See 'man personality' for more */\n\toptional bool persona_addr_compat_layout = 50 [default = false];\n\toptional bool persona_mmap_page_zero = 51 [default = false];\n\toptional bool persona_read_implies_exec = 52 [default = false];\n\toptional bool persona_addr_limit_3gb = 53 [default = false];\n\toptional bool persona_addr_no_randomize = 54 [default = false];\n\n\t/* Which name-spaces should be used? */\n\toptional bool clone_newnet = 55 [default = true];\n\toptional bool clone_newuser = 56 [default = true];\n\toptional bool clone_newns = 57 [default = true];\n\toptional bool clone_newpid = 58 [default = true];\n\toptional bool clone_newipc = 59 [default = true];\n\toptional bool clone_newuts = 60 [default = true];\n\t/* Disable for kernel versions < 4.6 as it's not supported there */\n\toptional bool clone_newcgroup = 61 [default = true];\n\t/* Supported with kernel versions >= 5.3 */\n\toptional bool clone_newtime = 62 [default = false];\n\n\t/* Mappings for UIDs and GIDs. See the description for 'msg IdMap'\n\t   for more */\n\trepeated IdMap uidmap = 63;\n\trepeated IdMap gidmap = 64;\n\n\t/* Should /proc be mounted (R/O)? This can also be added in the 'mount'\n\t   section below */\n\toptional bool mount_proc = 65 [default = false];\n\t/* Mount points inside the jail. See the description for 'msg MountPt'\n\t   for more */\n\trepeated MountPt mount = 66;\n\n\t/* Kafel seccomp-bpf policy file or a string:\n\t   Homepage of the project: https://github.com/google/kafel */\n\toptional string seccomp_policy_file = 67;\n\trepeated string seccomp_string = 68;\n\t/* Setting it to true makes audit write seccomp logs to dmesg */\n\toptional bool seccomp_log = 69 [default = false];\n\n\t/* If > 0, maximum cumulative size of RAM used inside any jail */\n\toptional uint64 cgroup_mem_max = 70 [default = 0]; /* In bytes */\n\t/* If > 0, maximum cumulative size of RAM + swap used inside any jail */\n\toptional uint64 cgroup_mem_memsw_max = 71 [default = 0]; /* In bytes */\n\t/* If >= 0, maximum cumulative size of swap used inside any jail */\n\toptional int64 cgroup_mem_swap_max = 72 [default = -1]; /* In bytes */\n\t/* Mount point for cgroups-memory in your system */\n\toptional string cgroup_mem_mount = 73 [default = \"/sys/fs/cgroup/memory\"];\n\t/* Writeable directory (for the nsjail user) under cgroup_mem_mount */\n\toptional string cgroup_mem_parent = 74 [default = \"NSJAIL\"];\n\n\t/* If > 0, maximum number of PIDs (threads/processes) inside jail */\n\toptional uint64 cgroup_pids_max = 75 [default = 0];\n\t/* Mount point for cgroups-pids in your system */\n\toptional string cgroup_pids_mount = 76 [default = \"/sys/fs/cgroup/pids\"];\n\t/* Writeable directory (for the nsjail user) under cgroup_pids_mount */\n\toptional string cgroup_pids_parent = 77 [default = \"NSJAIL\"];\n\n\t/* If > 0, Class identifier of network packets inside jail */\n\toptional uint32 cgroup_net_cls_classid = 78 [default = 0];\n\t/* Mount point for cgroups-net-cls in your system */\n\toptional string cgroup_net_cls_mount = 79 [default = \"/sys/fs/cgroup/net_cls\"];\n\t/* Writeable directory (for the nsjail user) under cgroup_net_mount */\n\toptional string cgroup_net_cls_parent = 80 [default = \"NSJAIL\"];\n\n\t/* If > 0, number of milliseconds of CPU time per second that jailed processes can use */\n\toptional uint32 cgroup_cpu_ms_per_sec = 81 [default = 0];\n\t/* Mount point for cgroups-cpu in your system */\n\toptional string cgroup_cpu_mount = 82 [default = \"/sys/fs/cgroup/cpu\"];\n\t/* Writeable directory (for the nsjail user) under cgroup_cpu_mount */\n\toptional string cgroup_cpu_parent = 83 [default = \"NSJAIL\"];\n\n\t/* Mount point for cgroup v2 in your system */\n\toptional string cgroupv2_mount = 84 [default = \"/sys/fs/cgroup\"];\n\t/* Use cgroup v2 */\n\toptional bool use_cgroupv2 = 85 [default = false];\n\t/* Check whether cgroupv2 is available, and use it if available. */\n\toptional bool detect_cgroupv2 = 86 [default = false];\n\n\t/* Should the 'lo' interface be brought up (active) inside this jail? */\n\toptional bool iface_no_lo = 87 [default = false];\n\n\t/* Put this interface inside the jail */\n\trepeated string iface_own = 88;\n\n\t/* Parameters for the cloned MACVLAN interface inside jail */\n\toptional string macvlan_iface = 89; /* Interface to be cloned, eg 'eth0' */\n\toptional string macvlan_vs_ip = 90 [default = \"192.168.0.2\"];\n\toptional string macvlan_vs_nm = 91 [default = \"255.255.255.0\"];\n\toptional string macvlan_vs_gw = 92 [default = \"192.168.0.1\"];\n\toptional string macvlan_vs_ma = 93 [default = \"\"];\n\toptional string macvlan_vs_mo = 94 [default = \"private\"];\n\n\t/* Binary path (with arguments) to be executed. If not specified here, it\n\t   can be specified with cmd-line as \"-- /path/to/command arg1 arg2\" */\n\toptional Exe exec_bin = 95;\n}\n"
        },
        {
          "name": "configs",
          "type": "tree",
          "content": null
        },
        {
          "name": "contain.cc",
          "type": "blob",
          "size": 9.896484375,
          "content": "/*\n\n   nsjail - isolating the binary\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"contain.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/personality.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <unistd.h>\n\n#include <algorithm>\n\n#include \"caps.h\"\n#include \"cgroup.h\"\n#include \"cpu.h\"\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"mnt.h\"\n#include \"net.h\"\n#include \"pid.h\"\n#include \"user.h\"\n#include \"util.h\"\n#include \"uts.h\"\n\nnamespace contain {\n\nstatic bool containUserNs(nsjconf_t* nsjconf) {\n\treturn user::initNsFromChild(nsjconf);\n}\n\nstatic bool containInitPidNs(nsjconf_t* nsjconf) {\n\treturn pid::initNs(nsjconf);\n}\n\nstatic bool containInitNetNs(nsjconf_t* nsjconf) {\n\treturn net::initNsFromChild(nsjconf);\n}\n\nstatic bool containInitUtsNs(nsjconf_t* nsjconf) {\n\treturn uts::initNs(nsjconf);\n}\n\nstatic bool containInitCgroupNs(void) {\n\treturn cgroup::initNs();\n}\n\nstatic bool containDropPrivs(nsjconf_t* nsjconf) {\n#ifndef PR_SET_NO_NEW_PRIVS\n#define PR_SET_NO_NEW_PRIVS 38\n#endif\n\tif (!nsjconf->disable_no_new_privs) {\n\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1UL, 0UL, 0UL, 0UL) == -1) {\n\t\t\t/* Only new kernels support it */\n\t\t\tPLOG_W(\"prctl(PR_SET_NO_NEW_PRIVS, 1)\");\n\t\t}\n\t}\n\n\tif (!caps::initNs(nsjconf)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool containPrepareEnv(nsjconf_t* nsjconf) {\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0) == -1) {\n\t\tPLOG_E(\"prctl(PR_SET_PDEATHSIG, SIGKILL)\");\n\t\treturn false;\n\t}\n\tif (nsjconf->personality && personality(nsjconf->personality) == -1) {\n\t\tPLOG_E(\"personality(%lx)\", nsjconf->personality);\n\t\treturn false;\n\t}\n\tLOG_D(\"setpriority(%d)\", nsjconf->nice_level);\n\terrno = 0;\n\tif (setpriority(PRIO_PROCESS, 0, nsjconf->nice_level) == -1 && errno != 0) {\n\t\tPLOG_W(\"setpriority(%d)\", nsjconf->nice_level);\n\t}\n\tif (!nsjconf->skip_setsid) {\n\t\tsetsid();\n\t}\n\treturn true;\n}\n\nstatic bool containInitMountNs(nsjconf_t* nsjconf) {\n\treturn mnt::initNs(nsjconf);\n}\n\nstatic bool containCPU(nsjconf_t* nsjconf) {\n\treturn cpu::initCpu(nsjconf);\n}\n\nstatic bool containTSC(nsjconf_t* nsjconf) {\n\tif (nsjconf->disable_tsc) {\n#if defined(__x86_64__) || defined(__i386__)\n\t\tif (prctl(PR_SET_TSC, PR_TSC_SIGSEGV, 0, 0, 0) == -1) {\n\t\t\tPLOG_E(\"prctl(PR_SET_TSC, PR_TSC_SIGSEGV)\");\n\t\t\treturn false;\n\t\t}\n#else  /* defined(__x86_64__) || defined(__i386__) */\n\t\tLOG_W(\"prctl(PR_SET_TSC, PR_TSC_SIGSEGV) requested, but it's supported under \"\n\t\t      \"x86/x86-64 CPU architectures only. Ignoring it!\");\n#endif /* defined(__x86_64__) || defined(__i386__) */\n\t}\n\treturn true;\n}\n\nstatic bool containSetLimits(nsjconf_t* nsjconf) {\n\tif (nsjconf->disable_rl) {\n\t\treturn true;\n\t}\n\n\tstruct rlimit64 rl;\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_as;\n\tif (util::setrlimit(RLIMIT_AS, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_AS, %\" PRIu64 \")\", nsjconf->rl_as);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_core;\n\tif (util::setrlimit(RLIMIT_CORE, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_CORE, %\" PRIu64 \")\", nsjconf->rl_core);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_cpu;\n\tif (util::setrlimit(RLIMIT_CPU, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_CPU, %\" PRIu64 \")\", nsjconf->rl_cpu);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_fsize;\n\tif (util::setrlimit(RLIMIT_FSIZE, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_FSIZE, %\" PRIu64 \")\", nsjconf->rl_fsize);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_nofile;\n\tif (util::setrlimit(RLIMIT_NOFILE, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_NOFILE, %\" PRIu64 \")\", nsjconf->rl_nofile);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_nproc;\n\tif (util::setrlimit(RLIMIT_NPROC, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_NPROC, %\" PRIu64 \")\", nsjconf->rl_nproc);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_stack;\n\tif (util::setrlimit(RLIMIT_STACK, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_STACK, %\" PRIu64 \")\", nsjconf->rl_stack);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_mlock;\n\tif (util::setrlimit(RLIMIT_MEMLOCK, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_MEMLOCK, %\" PRIu64 \")\", nsjconf->rl_mlock);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_rtpr;\n\tif (util::setrlimit(RLIMIT_RTPRIO, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_RTPRIO, %\" PRIu64 \")\", nsjconf->rl_rtpr);\n\t\treturn false;\n\t}\n\trl.rlim_cur = rl.rlim_max = nsjconf->rl_msgq;\n\tif (util::setrlimit(RLIMIT_MSGQUEUE, rl) == -1) {\n\t\tPLOG_E(\"util::setrlimit(0, RLIMIT_MSGQUEUE , %\" PRIu64 \")\", nsjconf->rl_msgq);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool containPassFd(nsjconf_t* nsjconf, int fd) {\n\treturn (std::find(nsjconf->openfds.begin(), nsjconf->openfds.end(), fd) !=\n\t\tnsjconf->openfds.end());\n}\n\nstatic bool containMakeFdsCOENaive(nsjconf_t* nsjconf) {\n\t/*\n\t * Don't use getrlimit(RLIMIT_NOFILE) here, as it can return an artifically small value\n\t * (e.g. 32), which could be smaller than a maximum assigned number to file-descriptors\n\t * in this process. Just use some reasonably sane value (e.g. 1024)\n\t */\n\tfor (unsigned fd = 0; fd < 1024; fd++) {\n\t\tint flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFD, 0));\n\t\tif (flags == -1 && errno == EBADF) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags == -1) {\n\t\t\tPLOG_E(\"Couldn't get flags for fd=%d\", fd)\n\t\t\treturn false;\n\t\t}\n\t\tif (containPassFd(nsjconf, fd)) {\n\t\t\tLOG_D(\"fd=%d will be passed to the child process\", fd);\n\t\t\tif (TEMP_FAILURE_RETRY(fcntl(fd, F_SETFD, flags & ~(FD_CLOEXEC))) == -1) {\n\t\t\t\tPLOG_E(\"Could not set FD_CLOEXEC for fd=%d\", fd);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (TEMP_FAILURE_RETRY(fcntl(fd, F_SETFD, flags | FD_CLOEXEC)) == -1) {\n\t\t\t\tPLOG_E(\"Could not set FD_CLOEXEC for fd=%d\", fd);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool containMakeFdsCOEProc(nsjconf_t* nsjconf) {\n\tint dirfd = open(\"/proc/self/fd\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\tif (dirfd == -1) {\n\t\tPLOG_D(\"open('/proc/self/fd', O_DIRECTORY|O_RDONLY|O_CLOEXEC)\");\n\t\treturn false;\n\t}\n\tDIR* dir = fdopendir(dirfd);\n\tif (dir == nullptr) {\n\t\tPLOG_W(\"fdopendir(fd=%d)\", dirfd);\n\t\tclose(dirfd);\n\t\treturn false;\n\t}\n\t/* Make all fds above stderr close-on-exec */\n\tfor (;;) {\n\t\terrno = 0;\n\t\tstruct dirent* entry = readdir(dir);\n\t\tif (entry == nullptr && errno != 0) {\n\t\t\tPLOG_D(\"readdir('/proc/self/fd')\");\n\t\t\tclosedir(dir);\n\t\t\treturn false;\n\t\t}\n\t\tif (entry == nullptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif (util::StrEq(\".\", entry->d_name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (util::StrEq(\"..\", entry->d_name)) {\n\t\t\tcontinue;\n\t\t}\n\t\terrno = 0;\n\t\tint fd = strtoimax(entry->d_name, NULL, 10);\n\t\tif (errno != 0) {\n\t\t\tPLOG_W(\"Cannot convert /proc/self/fd/%s to a number\", entry->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tint flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFD, 0));\n\t\tif (flags == -1) {\n\t\t\tPLOG_D(\"fcntl(fd=%d, F_GETFD, 0)\", fd);\n\t\t\tclosedir(dir);\n\t\t\treturn false;\n\t\t}\n\t\tif (containPassFd(nsjconf, fd)) {\n\t\t\tLOG_D(\"fd=%d will be passed to the child process\", fd);\n\t\t\tif (TEMP_FAILURE_RETRY(fcntl(fd, F_SETFD, flags & ~(FD_CLOEXEC))) == -1) {\n\t\t\t\tPLOG_E(\"Could not clear FD_CLOEXEC for fd=%d\", fd);\n\t\t\t\tclosedir(dir);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_D(\"fd=%d will be closed before execve()\", fd);\n\t\t\tif (TEMP_FAILURE_RETRY(fcntl(fd, F_SETFD, flags | FD_CLOEXEC)) == -1) {\n\t\t\t\tPLOG_E(\"Could not set FD_CLOEXEC for fd=%d\", fd);\n\t\t\t\tclosedir(dir);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(dir);\n\treturn true;\n}\n\nstatic bool containMakeFdsCOE(nsjconf_t* nsjconf) {\n\tif (containMakeFdsCOEProc(nsjconf)) {\n\t\treturn true;\n\t}\n\tif (containMakeFdsCOENaive(nsjconf)) {\n\t\treturn true;\n\t}\n\tLOG_E(\"Couldn't mark relevant file-descriptors as close-on-exec with any known method\");\n\treturn false;\n}\n\nbool setupFD(nsjconf_t* nsjconf, int fd_in, int fd_out, int fd_err) {\n\tif (nsjconf->stderr_to_null) {\n\t\tLOG_D(\"Redirecting fd=2 (STDERR_FILENO) to /dev/null\");\n\t\tif ((fd_err = TEMP_FAILURE_RETRY(open(\"/dev/null\", O_RDWR))) == -1) {\n\t\t\tPLOG_E(\"open('/dev/null', O_RDWR\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (nsjconf->is_silent) {\n\t\tLOG_D(\"Redirecting fd=0-2 (STDIN/OUT/ERR_FILENO) to /dev/null\");\n\t\tif (TEMP_FAILURE_RETRY(fd_in = fd_out = fd_err = open(\"/dev/null\", O_RDWR)) == -1) {\n\t\t\tPLOG_E(\"open('/dev/null', O_RDWR)\");\n\t\t\treturn false;\n\t\t}\n\t}\n\t/* Set stdin/stdout/stderr to the net */\n\tif (fd_in != STDIN_FILENO && TEMP_FAILURE_RETRY(dup2(fd_in, STDIN_FILENO)) == -1) {\n\t\tPLOG_E(\"dup2(%d, STDIN_FILENO)\", fd_in);\n\t\treturn false;\n\t}\n\tif (fd_out != STDOUT_FILENO && TEMP_FAILURE_RETRY(dup2(fd_out, STDOUT_FILENO)) == -1) {\n\t\tPLOG_E(\"dup2(%d, STDOUT_FILENO)\", fd_out);\n\t\treturn false;\n\t}\n\tif (fd_err != STDERR_FILENO && TEMP_FAILURE_RETRY(dup2(fd_err, STDERR_FILENO)) == -1) {\n\t\tPLOG_E(\"dup2(%d, STDERR_FILENO)\", fd_err);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool containProc(nsjconf_t* nsjconf) {\n\tRETURN_ON_FAILURE(containUserNs(nsjconf));\n\tRETURN_ON_FAILURE(containInitPidNs(nsjconf));\n\tRETURN_ON_FAILURE(containInitMountNs(nsjconf));\n\tRETURN_ON_FAILURE(containInitNetNs(nsjconf));\n\tRETURN_ON_FAILURE(containInitUtsNs(nsjconf));\n\tRETURN_ON_FAILURE(containInitCgroupNs());\n\tRETURN_ON_FAILURE(containDropPrivs(nsjconf));\n\t;\n\t/* */\n\t/* As non-root */\n\tRETURN_ON_FAILURE(containCPU(nsjconf));\n\tRETURN_ON_FAILURE(containTSC(nsjconf));\n\tRETURN_ON_FAILURE(containSetLimits(nsjconf));\n\tRETURN_ON_FAILURE(containPrepareEnv(nsjconf));\n\tRETURN_ON_FAILURE(containMakeFdsCOE(nsjconf));\n\n\treturn true;\n}\n\n}  // namespace contain\n"
        },
        {
          "name": "contain.h",
          "type": "blob",
          "size": 0.9326171875,
          "content": "/*\n\n   nsjail - isolating the binary\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_CONTAIN_H\n#define NS_CONTAIN_H\n\n#include <stdbool.h>\n\n#include \"nsjail.h\"\n\nnamespace contain {\n\nbool setupFD(nsjconf_t* nsjconf, int fd_in, int fd_out, int fd_err);\nbool containProc(nsjconf_t* nsjconf);\n\n}  // namespace contain\n\n#endif /* NS_CONTAIN_H */\n"
        },
        {
          "name": "cpu.cc",
          "type": "blob",
          "size": 3.9296875,
          "content": "/*\n\n   nsjail - CPU affinity\n   -----------------------------------------\n\n   Copyright 2017 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"cpu.h\"\n\n#include <inttypes.h>\n#include <sched.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <memory>\n\n#include \"logs.h\"\n#include \"util.h\"\n\nnamespace cpu {\n\nstatic const std::string listCpusInSet(cpu_set_t* mask) {\n\tstd::string ret;\n\tfor (size_t i = 0; i < CPU_SETSIZE; i++) {\n\t\tif (CPU_ISSET(i, mask)) {\n\t\t\tif (!ret.empty()) {\n\t\t\t\tret.append(\",\");\n\t\t\t}\n\t\t\tret.append(std::to_string(i));\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic size_t getNthOnlineCpu(cpu_set_t* mask, size_t n) {\n\tfor (size_t i = 0, j = 0; i < CPU_SETSIZE; i++) {\n\t\tif (CPU_ISSET(i, mask)) {\n\t\t\tif (j == n) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\tLOG_F(\"No CPU #%zu found, yet there should be %zu left in the mask [%s]\", n,\n\t    (size_t)CPU_COUNT(mask), listCpusInSet(mask).c_str());\n\treturn 0;\n}\n\nstatic void setRandomCpu(cpu_set_t* orig_mask, cpu_set_t* new_mask, size_t available_cpus) {\n\tif (available_cpus == 0) {\n\t\tLOG_F(\"There are no more CPUs left to use, and there should be at least 1 left\");\n\t}\n\n\tsize_t n = util::rnd64() % available_cpus;\n\tn = getNthOnlineCpu(orig_mask, n);\n\n\tCPU_SET(n, new_mask);\n\tLOG_D(\"Add CPU #%zu from the original mask=[%s] (size=%zu, available_cpus=%zu), new \"\n\t      \"mask=[%s] (size=%zu)\",\n\t    n, listCpusInSet(orig_mask).c_str(), (size_t)CPU_COUNT(orig_mask), available_cpus,\n\t    listCpusInSet(new_mask).c_str(), (size_t)CPU_COUNT(new_mask));\n\tCPU_CLR(n, orig_mask);\n}\n\nbool initCpu(nsjconf_t* nsjconf) {\n\tif (nsjconf->max_cpus == 0) {\n\t\tLOG_D(\"No max_cpus limit set\");\n\t\treturn true;\n\t}\n\n\tstd::unique_ptr<cpu_set_t> orig_mask(new cpu_set_t);\n\tif (!orig_mask) {\n\t\tPLOG_W(\"Failure allocating cpu_set_t\");\n\t\treturn false;\n\t}\n\tif (sched_getaffinity(0, CPU_ALLOC_SIZE(CPU_SETSIZE), orig_mask.get()) == -1) {\n\t\tPLOG_W(\"sched_getaffinity(0, mask_size=%zu)\", (size_t)CPU_ALLOC_SIZE(CPU_SETSIZE));\n\t\treturn false;\n\t}\n\tsize_t available_cpus = CPU_COUNT(orig_mask.get());\n\n\tLOG_D(\"Original CPU set: [%s], with %zu allowed CPUs\",\n\t    listCpusInSet(orig_mask.get()).c_str(), available_cpus);\n\n\tif (nsjconf->max_cpus > available_cpus) {\n\t\tLOG_W(\n\t\t    \"Number of requested CPUs is bigger than number of available CPUs (%zu > %zu)\",\n\t\t    nsjconf->max_cpus, available_cpus);\n\t\treturn true;\n\t}\n\tif (nsjconf->max_cpus == available_cpus) {\n\t\tLOG_D(\"All CPUs requested (%zu of %zu)\", nsjconf->max_cpus, available_cpus);\n\t\treturn true;\n\t}\n\n\tstd::unique_ptr<cpu_set_t> new_mask(new cpu_set_t);\n\tif (!new_mask) {\n\t\tPLOG_W(\"Failure allocating cpu_set_t\");\n\t\treturn false;\n\t}\n\tCPU_ZERO(new_mask.get());\n\n\tfor (size_t i = 0; i < nsjconf->max_cpus; i++) {\n\t\tsetRandomCpu(orig_mask.get(), new_mask.get(), available_cpus);\n\t\tavailable_cpus--;\n\t}\n\n\tLOG_D(\"Setting new CPU mask=[%s] with %zu allowed CPUs (max_cpus=%zu), %zu CPUs \"\n\t      \"(CPU_COUNT=%zu) left mask=[%s]\",\n\t    listCpusInSet(new_mask.get()).c_str(), nsjconf->max_cpus,\n\t    (size_t)CPU_COUNT(new_mask.get()), available_cpus, (size_t)CPU_COUNT(orig_mask.get()),\n\t    listCpusInSet(orig_mask.get()).c_str());\n\n\tif (sched_setaffinity(0, CPU_ALLOC_SIZE(CPU_SETSIZE), new_mask.get()) == -1) {\n\t\tPLOG_W(\"sched_setaffinity(mask=%s size=%zu max_cpus=%zu (CPU_COUNT=%zu)) failed\",\n\t\t    listCpusInSet(new_mask.get()).c_str(), (size_t)CPU_ALLOC_SIZE(CPU_SETSIZE),\n\t\t    nsjconf->max_cpus, (size_t)CPU_COUNT(new_mask.get()));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n}  // namespace cpu\n"
        },
        {
          "name": "cpu.h",
          "type": "blob",
          "size": 0.833984375,
          "content": "/*\n\n   nsjail - CPU affinity\n   -----------------------------------------\n\n   Copyright 2017 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_CPU_H\n#define NS_CPU_H\n\n#include <stdbool.h>\n\n#include \"nsjail.h\"\n\nnamespace cpu {\n\nbool initCpu(nsjconf_t* nsjconf);\n\n}  // namespace cpu\n\n#endif /* NS_CPU_H */\n"
        },
        {
          "name": "kafel",
          "type": "commit",
          "content": null
        },
        {
          "name": "logs.cc",
          "type": "blob",
          "size": 4.0107421875,
          "content": "/*\n\n   nsjail - logging\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"logs.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"macros.h\"\n#include \"util.h\"\n\nnamespace logs {\n\nstatic int _log_fd = STDERR_FILENO;\nstatic bool _log_fd_isatty = true;\nstatic enum llevel_t _log_level = INFO;\nstatic bool _log_set = false;\n\nstatic void setDupLogFdOr(int fd, int orfd) {\n\tint saved_errno = errno;\n\t_log_fd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n\tif (_log_fd == -1) {\n\t\t_log_fd = fcntl(orfd, F_DUPFD_CLOEXEC, 0);\n\t}\n\tif (_log_fd == -1) {\n\t\t_log_fd = orfd;\n\t}\n\t_log_fd_isatty = (isatty(_log_fd) == 1);\n\tif (getenv(\"NO_COLOR\")) {\n\t\t_log_fd_isatty = false;\n\t}\n\terrno = saved_errno;\n}\n\n/*\n * Log to stderr by default. Use a dup()d fd, because in the future we'll associate the\n * connection socket with fd (0, 1, 2).\n */\n__attribute__((constructor)) static void log_init(void) {\n\tsetDupLogFdOr(STDERR_FILENO, STDERR_FILENO);\n}\n\nbool logSet() {\n\treturn _log_set;\n}\n\nvoid setLogLevel(enum llevel_t ll) {\n\t_log_level = ll;\n}\n\nenum llevel_t getLogLevel(void) {\n\treturn _log_level;\n}\n\nvoid logFile(const std::string& log_file, int log_fd) {\n\t_log_set = true;\n\tint newlogfd = -1;\n\tif (!log_file.empty()) {\n\t\tnewlogfd = TEMP_FAILURE_RETRY(\n\t\t    open(log_file.c_str(), O_CREAT | O_RDWR | O_APPEND | O_CLOEXEC, 0640));\n\t\tif (newlogfd == -1) {\n\t\t\tPLOG_W(\"Couldn't open('%s')\", log_file.c_str());\n\t\t}\n\t}\n\t/* Close previous log_fd */\n\tif (_log_fd > STDERR_FILENO) {\n\t\tclose(_log_fd);\n\t}\n\tsetDupLogFdOr(newlogfd, log_fd);\n\tclose(newlogfd);\n}\n\nvoid logMsg(enum llevel_t ll, const char* fn, int ln, bool perr, const char* fmt, ...) {\n\tif (ll < _log_level) {\n\t\treturn;\n\t}\n\n\tchar strerr[512];\n\tif (perr) {\n\t\tsnprintf(strerr, sizeof(strerr), \"%s\", strerror(errno));\n\t}\n\tstruct {\n\t\tconst char* const descr;\n\t\tconst char* const prefix;\n\t\tconst bool print_funcline;\n\t\tconst bool print_time;\n\t} static const logLevels[] = {\n\t    {\"D\", \"\\033[0;4m\", true, true},\n\t    {\"I\", \"\\033[1m\", false, true},\n\t    {\"W\", \"\\033[0;33m\", true, true},\n\t    {\"E\", \"\\033[1;31m\", true, true},\n\t    {\"F\", \"\\033[7;35m\", true, true},\n\t    {\"HR\", \"\\033[0m\", false, false},\n\t    {\"HB\", \"\\033[1m\", false, false},\n\t};\n\n\t/* Start printing logs */\n\tstd::string msg;\n\tif (_log_fd_isatty) {\n\t\tmsg.append(logLevels[ll].prefix);\n\t}\n\tif (ll != HELP && ll != HELP_BOLD) {\n\t\tmsg.append(\"[\").append(logLevels[ll].descr).append(\"]\");\n\t}\n\tif (logLevels[ll].print_time) {\n\t\tmsg.append(\"[\").append(util::timeToStr(time(NULL))).append(\"]\");\n\t}\n\tif (logLevels[ll].print_funcline) {\n\t\tmsg.append(\"[\")\n\t\t    .append(std::to_string(getpid()))\n\t\t    .append(\"] \")\n\t\t    .append(fn)\n\t\t    .append(\"():\")\n\t\t    .append(std::to_string(ln));\n\t}\n\n\tchar* strp;\n\tva_list args;\n\tva_start(args, fmt);\n\tint ret = vasprintf(&strp, fmt, args);\n\tva_end(args);\n\tif (ret == -1) {\n\t\tmsg.append(\" [logs internal]: MEMORY ALLOCATION ERROR\");\n\t} else {\n\t\tmsg.append(\" \").append(strp);\n\t\tfree(strp);\n\t}\n\tif (perr) {\n\t\tmsg.append(\": \").append(strerr);\n\t}\n\tif (_log_fd_isatty) {\n\t\tmsg.append(\"\\033[0m\");\n\t}\n\tmsg.append(\"\\n\");\n\t/* End printing logs */\n\n\tTEMP_FAILURE_RETRY(write(_log_fd, msg.c_str(), msg.size()));\n\n\tif (ll == FATAL) {\n\t\texit(0xff);\n\t}\n}\n\nvoid logStop(int sig) {\n\tLOG_I(\"Server stops due to fatal signal (%d) caught. Exiting\", sig);\n}\n\n}  // namespace logs\n"
        },
        {
          "name": "logs.h",
          "type": "blob",
          "size": 4.234375,
          "content": "/*\n\n   nsjail - logging\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_LOGS_H\n#define NS_LOGS_H\n\n#include <getopt.h>\n#include <stdbool.h>\n\n#include <string>\n\nnamespace logs {\n\n#define LOG_HELP(...) logs::logMsg(logs::HELP, __FUNCTION__, __LINE__, false, __VA_ARGS__);\n#define LOG_HELP_BOLD(...)                                                                         \\\n\tlogs::logMsg(logs::HELP_BOLD, __FUNCTION__, __LINE__, false, __VA_ARGS__);\n\n#define LOG_D(...)                                                                                 \\\n\tif (logs::getLogLevel() <= logs::DEBUG) {                                                  \\\n\t\tlogs::logMsg(logs::DEBUG, __FUNCTION__, __LINE__, false, __VA_ARGS__);             \\\n\t}\n#define LOG_I(...)                                                                                 \\\n\tif (logs::getLogLevel() <= logs::INFO) {                                                   \\\n\t\tlogs::logMsg(logs::INFO, __FUNCTION__, __LINE__, false, __VA_ARGS__);              \\\n\t}\n#define LOG_W(...)                                                                                 \\\n\tif (logs::getLogLevel() <= logs::WARNING) {                                                \\\n\t\tlogs::logMsg(logs::WARNING, __FUNCTION__, __LINE__, false, __VA_ARGS__);           \\\n\t}\n#define LOG_E(...)                                                                                 \\\n\tif (logs::getLogLevel() <= logs::ERROR) {                                                  \\\n\t\tlogs::logMsg(logs::ERROR, __FUNCTION__, __LINE__, false, __VA_ARGS__);             \\\n\t}\n#define LOG_F(...)                                                                                 \\\n\tif (logs::getLogLevel() <= logs::FATAL) {                                                  \\\n\t\tlogs::logMsg(logs::FATAL, __FUNCTION__, __LINE__, false, __VA_ARGS__);             \\\n\t}\n\n#define PLOG_D(...)                                                                                \\\n\tif (logs::getLogLevel() <= logs::DEBUG) {                                                  \\\n\t\tlogs::logMsg(logs::DEBUG, __FUNCTION__, __LINE__, true, __VA_ARGS__);              \\\n\t}\n#define PLOG_I(...)                                                                                \\\n\tif (logs::getLogLevel() <= logs::INFO) {                                                   \\\n\t\tlogs::logMsg(logs::INFO, __FUNCTION__, __LINE__, true, __VA_ARGS__);               \\\n\t}\n#define PLOG_W(...)                                                                                \\\n\tif (logs::getLogLevel() <= logs::WARNING) {                                                \\\n\t\tlogs::logMsg(logs::WARNING, __FUNCTION__, __LINE__, true, __VA_ARGS__);            \\\n\t}\n#define PLOG_E(...)                                                                                \\\n\tif (logs::getLogLevel() <= logs::ERROR) {                                                  \\\n\t\tlogs::logMsg(logs::ERROR, __FUNCTION__, __LINE__, true, __VA_ARGS__);              \\\n\t}\n#define PLOG_F(...)                                                                                \\\n\tif (logs::getLogLevel() <= logs::FATAL) {                                                  \\\n\t\tlogs::logMsg(logs::FATAL, __FUNCTION__, __LINE__, true, __VA_ARGS__);              \\\n\t}\n\nenum llevel_t {\n\tDEBUG = 0,\n\tINFO,\n\tWARNING,\n\tERROR,\n\tFATAL,\n\tHELP,\n\tHELP_BOLD,\n};\n\nvoid logMsg(enum llevel_t ll, const char* fn, int ln, bool perr, const char* fmt, ...)\n    __attribute__((format(printf, 5, 6)));\nvoid logStop(int sig);\nvoid setLogLevel(enum llevel_t ll);\nenum llevel_t getLogLevel(void);\nvoid logFile(const std::string& log_file, int log_fd);\nbool logSet();\n\n}  // namespace logs\n\n#endif /* NS_LOGS_H */\n"
        },
        {
          "name": "macros.h",
          "type": "blob",
          "size": 1.5107421875,
          "content": "/*\n\n   nsjail - common macros\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_COMMON_H\n#define NS_COMMON_H\n\n#include <unistd.h>\n\n#if !defined(TEMP_FAILURE_RETRY)\n#define TEMP_FAILURE_RETRY(expression)                                                             \\\n\t(__extension__({                                                                           \\\n\t\tlong int __result;                                                                 \\\n\t\tdo __result = (long int)(expression);                                              \\\n\t\twhile (__result == -1L && errno == EINTR);                                         \\\n\t\t__result;                                                                          \\\n\t}))\n#endif /* !defined(TEMP_FAILURE_RETRY) */\n\n#if !defined(ARR_SZ)\n#define ARR_SZ(array) (sizeof(array) / sizeof(*array))\n#endif /* !defined(ARR_SZ) */\n\n#define NS_VALSTR_STRUCT(x) {(uint64_t)x, #x}\n\n#endif /* NS_COMMON_H */\n"
        },
        {
          "name": "mnt.cc",
          "type": "blob",
          "size": 17.353515625,
          "content": "/*\n\n   nsjail - CLONE_NEWNS routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"mnt.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <memory>\n#include <string>\n\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"subproc.h\"\n#include \"util.h\"\n\nnamespace mnt {\n\n#if !defined(MS_LAZYTIME)\n#define MS_LAZYTIME (1 << 25)\n#endif /* if !defined(MS_LAZYTIME) */\n\nstatic const std::string flagsToStr(unsigned long flags) {\n\tstd::string res;\n\n\tstruct {\n\t\tconst unsigned long flag;\n\t\tconst char* const name;\n\t} static const mountFlags[] = {\n\t    NS_VALSTR_STRUCT(MS_RDONLY),\n\t    NS_VALSTR_STRUCT(MS_NOSUID),\n\t    NS_VALSTR_STRUCT(MS_NODEV),\n\t    NS_VALSTR_STRUCT(MS_NOEXEC),\n\t    NS_VALSTR_STRUCT(MS_SYNCHRONOUS),\n\t    NS_VALSTR_STRUCT(MS_REMOUNT),\n\t    NS_VALSTR_STRUCT(MS_MANDLOCK),\n\t    NS_VALSTR_STRUCT(MS_DIRSYNC),\n\t    NS_VALSTR_STRUCT(MS_NOATIME),\n\t    NS_VALSTR_STRUCT(MS_NODIRATIME),\n\t    NS_VALSTR_STRUCT(MS_BIND),\n\t    NS_VALSTR_STRUCT(MS_MOVE),\n\t    NS_VALSTR_STRUCT(MS_REC),\n\t    NS_VALSTR_STRUCT(MS_SILENT),\n\t    NS_VALSTR_STRUCT(MS_POSIXACL),\n\t    NS_VALSTR_STRUCT(MS_UNBINDABLE),\n\t    NS_VALSTR_STRUCT(MS_PRIVATE),\n\t    NS_VALSTR_STRUCT(MS_SLAVE),\n\t    NS_VALSTR_STRUCT(MS_SHARED),\n\t    NS_VALSTR_STRUCT(MS_RELATIME),\n\t    NS_VALSTR_STRUCT(MS_KERNMOUNT),\n\t    NS_VALSTR_STRUCT(MS_I_VERSION),\n\t    NS_VALSTR_STRUCT(MS_STRICTATIME),\n\t    NS_VALSTR_STRUCT(MS_LAZYTIME),\n#if defined(MS_ACTIVE)\n\t    NS_VALSTR_STRUCT(MS_ACTIVE),\n#endif /* defined(MS_ACTIVE) */\n#if defined(MS_NOUSER)\n\t    NS_VALSTR_STRUCT(MS_NOUSER),\n#endif /* defined(MS_NOUSER) */\n\t};\n\n\tunsigned knownFlagMask = 0U;\n\tfor (const auto& i : mountFlags) {\n\t\tif (flags & i.flag) {\n\t\t\tif (!res.empty()) {\n\t\t\t\tres.append(\"|\");\n\t\t\t}\n\t\t\tres.append(i.name);\n\t\t}\n\t\tknownFlagMask |= i.flag;\n\t}\n\n\tif (flags & ~(knownFlagMask)) {\n\t\tutil::StrAppend(&res, \"|%#lx\", flags & ~(knownFlagMask));\n\t}\n\n\treturn res;\n}\n\nstatic bool isDir(const char* path) {\n\t/*\n\t *  If the source dir is NULL, we assume it's a dir (for /proc and tmpfs)\n\t */\n\tif (path == nullptr) {\n\t\treturn true;\n\t}\n\tstruct stat st;\n\tif (stat(path, &st) == -1) {\n\t\tPLOG_D(\"stat(%s)\", QC(path));\n\t\treturn false;\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int mountRWIfPossible(mount_t* mpt, const char* src, const char* dst) {\n\tint res =\n\t    mount(src, dst, mpt->fs_type.c_str(), mpt->flags & ~(MS_RDONLY), mpt->options.c_str());\n\tif ((mpt->flags & MS_RDONLY) && res == -1 && errno == EPERM) {\n\t\tLOG_W(\"mount(%s) src:%s dstpath:%s could not mount read-write, falling \"\n\t\t      \"back to mounting read-only directly\",\n\t\t    describeMountPt(*mpt).c_str(), QC(src), QC(dst));\n\t\tres = mount(src, dst, mpt->fs_type.c_str(), mpt->flags, mpt->options.c_str());\n\t}\n\treturn res;\n}\n\nstatic bool mountPt(mount_t* mpt, const char* newroot, const char* tmpdir) {\n\tLOG_D(\"Mounting %s\", describeMountPt(*mpt).c_str());\n\n\tchar dstpath[PATH_MAX];\n\tsnprintf(dstpath, sizeof(dstpath), \"%s/%s\", newroot, mpt->dst.c_str());\n\n\tchar srcpath[PATH_MAX];\n\tif (!mpt->src.empty()) {\n\t\tsnprintf(srcpath, sizeof(srcpath), \"%s\", mpt->src.c_str());\n\t} else {\n\t\tsnprintf(srcpath, sizeof(srcpath), \"none\");\n\t}\n\n\tif (!util::createDirRecursively(dstpath)) {\n\t\tLOG_W(\"Couldn't create upper directories for '%s'\", dstpath);\n\t\treturn false;\n\t}\n\n\tif (mpt->is_symlink) {\n\t\tLOG_D(\"symlink(%s, %s)\", util::StrQuote(srcpath).c_str(),\n\t\t    util::StrQuote(dstpath).c_str());\n\t\tif (symlink(srcpath, dstpath) == -1) {\n\t\t\tif (mpt->is_mandatory) {\n\t\t\t\tPLOG_E(\"symlink('%s', '%s')\", util::StrQuote(srcpath).c_str(),\n\t\t\t\t    util::StrQuote(dstpath).c_str());\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tPLOG_W(\"symlink('%s', '%s'), but it's not mandatory, continuing\",\n\t\t\t\t    util::StrQuote(srcpath).c_str(),\n\t\t\t\t    util::StrQuote(dstpath).c_str());\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (mpt->is_dir) {\n\t\tif (mkdir(dstpath, 0711) == -1 && errno != EEXIST) {\n\t\t\tPLOG_W(\"mkdir(%s)\", QC(dstpath));\n\t\t}\n\t} else {\n\t\tint fd = TEMP_FAILURE_RETRY(open(dstpath, O_CREAT | O_RDONLY | O_CLOEXEC, 0644));\n\t\tif (fd >= 0) {\n\t\t\tclose(fd);\n\t\t} else {\n\t\t\tPLOG_W(\"open(%s, O_CREAT|O_RDONLY|O_CLOEXEC, 0644)\", QC(dstpath));\n\t\t}\n\t}\n\n\tif (!mpt->src_content.empty()) {\n\t\tstatic uint64_t df_counter = 0;\n\t\tsnprintf(\n\t\t    srcpath, sizeof(srcpath), \"%s/dynamic_file.%\" PRIu64, tmpdir, ++df_counter);\n\t\tint fd = TEMP_FAILURE_RETRY(\n\t\t    open(srcpath, O_CREAT | O_EXCL | O_CLOEXEC | O_WRONLY, 0644));\n\t\tif (fd < 0) {\n\t\t\tPLOG_W(\"open(srcpath, O_CREAT|O_EXCL|O_CLOEXEC|O_WRONLY, 0644) failed\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!util::writeToFd(fd, mpt->src_content.data(), mpt->src_content.length())) {\n\t\t\tLOG_W(\n\t\t\t    \"Writing %zu bytes to '%s' failed\", mpt->src_content.length(), srcpath);\n\t\t\tclose(fd);\n\t\t\treturn false;\n\t\t}\n\t\tclose(fd);\n\t\tmpt->flags |= (MS_BIND | MS_REC | MS_PRIVATE);\n\t}\n\n\t/*\n\t * Initially mount it as RW, it will be remounted later on if needed\n\t */\n\tif (mountRWIfPossible(mpt, srcpath, dstpath) == -1) {\n\t\tif (errno == EACCES) {\n\t\t\tPLOG_W(\"mount('%s') src:'%s' dstpath:'%s' failed. \"\n\t\t\t       \"Try fixing this problem by applying 'chmod o+x' to the '%s' \"\n\t\t\t       \"directory and its ancestors\",\n\t\t\t    describeMountPt(*mpt).c_str(), srcpath, dstpath, srcpath);\n\t\t} else {\n\t\t\tPLOG_W(\"mount('%s') src:'%s' dstpath:'%s' failed\",\n\t\t\t    describeMountPt(*mpt).c_str(), srcpath, dstpath);\n\t\t\tif (mpt->fs_type.compare(\"proc\") == 0) {\n\t\t\t\tPLOG_W(\"procfs can only be mounted if the original /proc doesn't \"\n\t\t\t\t       \"have any other file-systems mounted on top of it (e.g. \"\n\t\t\t\t       \"/dev/null on top of /proc/kcore)\");\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else {\n\t\tmpt->mounted = true;\n\t}\n\n\tif (!mpt->src_content.empty() && unlink(srcpath) == -1) {\n\t\tPLOG_W(\"unlink('%s')\", srcpath);\n\t}\n\treturn true;\n}\n\nstatic bool remountPt(const mount_t& mpt) {\n\tif (!mpt.mounted) {\n\t\treturn true;\n\t}\n\tif (mpt.is_symlink) {\n\t\treturn true;\n\t}\n\n\tstruct statvfs vfs;\n\tif (TEMP_FAILURE_RETRY(statvfs(mpt.dst.c_str(), &vfs)) == -1) {\n\t\tPLOG_W(\"statvfs('%s')\", mpt.dst.c_str());\n\t\treturn false;\n\t}\n\n\tstruct {\n\t\tconst unsigned long mount_flag;\n\t\tconst unsigned long vfs_flag;\n\t} static const mountPairs[] = {\n\t    {MS_NOSUID, ST_NOSUID},\n\t    {MS_NODEV, ST_NODEV},\n\t    {MS_NOEXEC, ST_NOEXEC},\n\t    {MS_SYNCHRONOUS, ST_SYNCHRONOUS},\n\t    {MS_MANDLOCK, ST_MANDLOCK},\n\t    {MS_NOATIME, ST_NOATIME},\n\t    {MS_NODIRATIME, ST_NODIRATIME},\n\t    {MS_RELATIME, ST_RELATIME},\n\t};\n\n\tconst unsigned long per_mountpoint_flags =\n\t    MS_LAZYTIME | MS_MANDLOCK | MS_NOATIME | MS_NODEV | MS_NODIRATIME | MS_NOEXEC |\n\t    MS_NOSUID | MS_RELATIME | MS_RDONLY | MS_SYNCHRONOUS;\n\tunsigned long new_flags = MS_REMOUNT | MS_BIND | (mpt.flags & per_mountpoint_flags);\n\tfor (const auto& i : mountPairs) {\n\t\tif (vfs.f_flag & i.vfs_flag) {\n\t\t\tnew_flags |= i.mount_flag;\n\t\t}\n\t}\n\n\tLOG_D(\"Re-mounting '%s' (flags:%s)\", mpt.dst.c_str(), flagsToStr(new_flags).c_str());\n\tif (mount(mpt.dst.c_str(), mpt.dst.c_str(), NULL, new_flags, 0) == -1) {\n\t\tPLOG_W(\"mount('%s', flags:%s)\", mpt.dst.c_str(), flagsToStr(new_flags).c_str());\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mkdirAndTest(const std::string& dir) {\n\tif (mkdir(dir.c_str(), 0755) == -1 && errno != EEXIST) {\n\t\tPLOG_D(\"Couldn't create '%s' directory\", dir.c_str());\n\t\treturn false;\n\t}\n\tif (access(dir.c_str(), R_OK) == -1) {\n\t\tPLOG_W(\"access('%s', R_OK)\", dir.c_str());\n\t\treturn false;\n\t}\n\tLOG_D(\"Created accessible directory in '%s'\", dir.c_str());\n\treturn true;\n}\n\nstatic std::unique_ptr<std::string> getDir(nsjconf_t* nsjconf, const char* name) {\n\tstd::unique_ptr<std::string> dir(new std::string);\n\n\tdir->assign(\"/run/user/\").append(std::to_string(nsjconf->orig_uid)).append(\"/nsjail\");\n\tif (mkdirAndTest(*dir)) {\n\t\tdir->append(\"/\").append(name);\n\t\tif (mkdirAndTest(*dir)) {\n\t\t\treturn dir;\n\t\t}\n\t}\n\tdir->assign(\"/run/user/\")\n\t    .append(\"/nsjail.\")\n\t    .append(std::to_string(nsjconf->orig_uid))\n\t    .append(\".\")\n\t    .append(name);\n\tif (mkdirAndTest(*dir)) {\n\t\treturn dir;\n\t}\n\tdir->assign(\"/tmp/nsjail.\")\n\t    .append(std::to_string(nsjconf->orig_uid))\n\t    .append(\".\")\n\t    .append(name);\n\tif (mkdirAndTest(*dir)) {\n\t\treturn dir;\n\t}\n\tconst char* tmp = getenv(\"TMPDIR\");\n\tif (tmp) {\n\t\tdir->assign(tmp)\n\t\t    .append(\"/\")\n\t\t    .append(\"nsjail.\")\n\t\t    .append(std::to_string(nsjconf->orig_uid))\n\t\t    .append(\".\")\n\t\t    .append(name);\n\t\tif (mkdirAndTest(*dir)) {\n\t\t\treturn dir;\n\t\t}\n\t}\n\tdir->assign(\"/dev/shm/nsjail.\")\n\t    .append(std::to_string(nsjconf->orig_uid))\n\t    .append(\".\")\n\t    .append(name);\n\tif (mkdirAndTest(*dir)) {\n\t\treturn dir;\n\t}\n\tdir->assign(\"/tmp/nsjail.\")\n\t    .append(std::to_string(nsjconf->orig_uid))\n\t    .append(\".\")\n\t    .append(name)\n\t    .append(\".\")\n\t    .append(std::to_string(util::rnd64()));\n\tif (mkdirAndTest(*dir)) {\n\t\treturn dir;\n\t}\n\n\tLOG_E(\"Couldn't create tmp directory of type '%s'\", QC(name));\n\treturn nullptr;\n}\n\nstatic bool initNoCloneNs(nsjconf_t* nsjconf) {\n\t/*\n\t * If CLONE_NEWNS is not used, we would be changing the global mount namespace, so simply\n\t * use --chroot in this case\n\t */\n\tif (nsjconf->chroot.empty()) {\n\t\treturn true;\n\t}\n\tif (chroot(nsjconf->chroot.c_str()) == -1) {\n\t\tPLOG_E(\"chroot(%s)\", QC(nsjconf->chroot));\n\t\treturn false;\n\t}\n\tif (chdir(\"/\") == -1) {\n\t\tPLOG_E(\"chdir('/')\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool initCloneNs(nsjconf_t* nsjconf) {\n\tif (chdir(\"/\") == -1) {\n\t\tPLOG_E(\"chdir('/')\");\n\t\treturn false;\n\t}\n\n\tstd::unique_ptr<std::string> destdir = getDir(nsjconf, \"root\");\n\tif (!destdir) {\n\t\tLOG_E(\"Couldn't obtain root mount directories\");\n\t\treturn false;\n\t}\n\n\t/* Make changes to / (recursively) private, to avoid changing the global mount ns */\n\tif (mount(\"/\", \"/\", NULL, MS_REC | MS_PRIVATE, NULL) == -1) {\n\t\tPLOG_E(\"mount('/', '/', NULL, MS_REC|MS_PRIVATE, NULL)\");\n\t\treturn false;\n\t}\n\tif (mount(NULL, destdir->c_str(), \"tmpfs\", 0, \"size=16777216\") == -1) {\n\t\tPLOG_E(\"mount(%s, 'tmpfs')\", QC(*destdir));\n\t\treturn false;\n\t}\n\n\tstd::unique_ptr<std::string> tmpdir = getDir(nsjconf, \"tmp\");\n\tif (!tmpdir) {\n\t\tLOG_E(\"Couldn't obtain temporary mount directories\");\n\t\treturn false;\n\t}\n\tif (mount(NULL, tmpdir->c_str(), \"tmpfs\", 0, \"size=16777216\") == -1) {\n\t\tPLOG_E(\"mount(%s, 'tmpfs')\", QC(*tmpdir));\n\t\treturn false;\n\t}\n\n\tfor (auto& p : nsjconf->mountpts) {\n\t\tif (!mountPt(&p, destdir->c_str(), tmpdir->c_str()) && p.is_mandatory) {\n\t\t\tLOG_E(\"Couldn't mount %s\", QC(p.dst));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (umount2(tmpdir->c_str(), MNT_DETACH) == -1) {\n\t\tPLOG_E(\"umount2(%s, MNT_DETACH)\", QC(*tmpdir));\n\t\treturn false;\n\t}\n\n\tif (!nsjconf->no_pivotroot) {\n\t\t/*\n\t\t * This requires some explanation: It's actually possible to pivot_root('/', '/').\n\t\t * After this operation has been completed, the old root is mounted over the new\n\t\t * root, and it's OK to simply umount('/') now, and to have new_root as '/'. This\n\t\t * allows us not care about providing any special directory for old_root, which is\n\t\t * sometimes not easy, given that e.g. /tmp might not always be present inside\n\t\t * new_root\n\t\t */\n\t\tif (util::syscall(__NR_pivot_root, (uintptr_t)destdir->c_str(),\n\t\t\t(uintptr_t)destdir->c_str()) == -1) {\n\t\t\tPLOG_E(\"pivot_root(%s, %s)\", QC(*destdir), QC(*destdir));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (umount2(\"/\", MNT_DETACH) == -1) {\n\t\t\tPLOG_E(\"umount2('/', MNT_DETACH)\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * pivot_root would normally un-mount the old root, however in certain cases this\n\t\t * operation is forbidden. There are systems (mainly embedded) that keep their root\n\t\t * file system in RAM, when initially loaded by the kernel (e.g. initramfs),\n\t\t * and there is no other file system that is mounted on top of it.In such systems,\n\t\t * there is no option to pivot_root!\n\t\t * For more information, see\n\t\t * kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt. switch_root\n\t\t * alternative: Innstead of un-mounting the old rootfs, it is over mounted by moving\n\t\t * the new root to it.\n\t\t */\n\n\t\t/* NOTE: Using mount move and chroot allows escaping back into the old root when\n\t\t * proper capabilities are kept in the user namespace. It can be acheived by\n\t\t * unmounting the new root and using setns to re-enter the mount namespace.\n\t\t */\n\t\tLOG_W(\"Using no_pivotroot is escapable when user posseses relevant capabilities, \"\n\t\t      \"Use it with care!\");\n\n\t\tif (chdir(destdir->c_str()) == -1) {\n\t\t\tPLOG_E(\"chdir(%s)\", QC(*destdir));\n\t\t\treturn false;\n\t\t}\n\n\t\t/* mount moving the new root on top of '/'. This operation is atomic and doesn't\n\t\tinvolve un-mounting '/' at any stage */\n\t\tif (mount(\".\", \"/\", NULL, MS_MOVE, NULL) == -1) {\n\t\t\tPLOG_E(\"mount('/', %s, NULL, MS_MOVE, NULL)\", QC(*destdir));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (chroot(\".\") == -1) {\n\t\t\tPLOG_E(\"chroot(%s)\", QC(*destdir));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const auto& p : nsjconf->mountpts) {\n\t\tif (!remountPt(p) && p.is_mandatory) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool initNsInternal(nsjconf_t* nsjconf) {\n\tif (nsjconf->clone_newns) {\n\t\tif (!initCloneNs(nsjconf)) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!initNoCloneNs(nsjconf)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (chdir(nsjconf->cwd.c_str()) == -1) {\n\t\tPLOG_E(\"chdir(%s)\", QC(nsjconf->cwd));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/*\n * With mode MODE_STANDALONE_EXECVE it's required to mount /proc inside a new process,\n * as the current process is still in the original PID namespace (man pid_namespaces)\n */\nbool initNs(nsjconf_t* nsjconf) {\n\tif (nsjconf->mode != MODE_STANDALONE_EXECVE) {\n\t\treturn initNsInternal(nsjconf);\n\t}\n\n\tpid_t pid = subproc::cloneProc(CLONE_FS, SIGCHLD);\n\tif (pid == -1) {\n\t\treturn false;\n\t}\n\n\tif (pid == 0) {\n\t\texit(initNsInternal(nsjconf) ? 0 : 0xff);\n\t}\n\n\tint status;\n\twhile (wait4(pid, &status, 0, NULL) != pid);\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool addMountPt(mount_t* mnt, const std::string& src, const std::string& dst,\n    const std::string& fstype, const std::string& options, uintptr_t flags, isDir_t is_dir,\n    bool is_mandatory, const std::string& src_env, const std::string& dst_env,\n    const std::string& src_content, bool is_symlink) {\n\tif (!src_env.empty()) {\n\t\tconst char* e = getenv(src_env.c_str());\n\t\tif (e == nullptr) {\n\t\t\tLOG_W(\"No such envar:%s\", QC(src_env));\n\t\t\treturn false;\n\t\t}\n\t\tmnt->src = e;\n\t}\n\tmnt->src.append(src);\n\n\tif (!dst_env.empty()) {\n\t\tconst char* e = getenv(dst_env.c_str());\n\t\tif (e == nullptr) {\n\t\t\tLOG_W(\"No such envar:%s\", QC(dst_env));\n\t\t\treturn false;\n\t\t}\n\t\tmnt->dst = e;\n\t}\n\tmnt->dst.append(dst);\n\n\tmnt->fs_type = fstype;\n\tmnt->options = options;\n\tmnt->flags = flags;\n\tmnt->is_symlink = is_symlink;\n\tmnt->is_mandatory = is_mandatory;\n\tmnt->mounted = false;\n\tmnt->src_content = src_content;\n\n\tswitch (is_dir) {\n\tcase NS_DIR_YES:\n\t\tmnt->is_dir = true;\n\t\tbreak;\n\tcase NS_DIR_NO:\n\t\tmnt->is_dir = false;\n\t\tbreak;\n\tcase NS_DIR_MAYBE: {\n\t\tif (!src_content.empty()) {\n\t\t\tmnt->is_dir = false;\n\t\t} else if (mnt->src.empty()) {\n\t\t\tmnt->is_dir = true;\n\t\t} else if (mnt->flags & MS_BIND) {\n\t\t\tmnt->is_dir = mnt::isDir(mnt->src.c_str());\n\t\t} else {\n\t\t\tmnt->is_dir = true;\n\t\t}\n\t} break;\n\tdefault:\n\t\tLOG_E(\"Unknown is_dir value: %d\", is_dir);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool addMountPtHead(nsjconf_t* nsjconf, const std::string& src, const std::string& dst,\n    const std::string& fstype, const std::string& options, uintptr_t flags, isDir_t is_dir,\n    bool is_mandatory, const std::string& src_env, const std::string& dst_env,\n    const std::string& src_content, bool is_symlink) {\n\tmount_t mnt;\n\tif (!addMountPt(&mnt, src, dst, fstype, options, flags, is_dir, is_mandatory, src_env,\n\t\tdst_env, src_content, is_symlink)) {\n\t\treturn false;\n\t}\n\tnsjconf->mountpts.insert(nsjconf->mountpts.begin(), mnt);\n\treturn true;\n}\n\nbool addMountPtTail(nsjconf_t* nsjconf, const std::string& src, const std::string& dst,\n    const std::string& fstype, const std::string& options, uintptr_t flags, isDir_t is_dir,\n    bool is_mandatory, const std::string& src_env, const std::string& dst_env,\n    const std::string& src_content, bool is_symlink) {\n\tmount_t mnt;\n\tif (!addMountPt(&mnt, src, dst, fstype, options, flags, is_dir, is_mandatory, src_env,\n\t\tdst_env, src_content, is_symlink)) {\n\t\treturn false;\n\t}\n\tnsjconf->mountpts.push_back(mnt);\n\treturn true;\n}\n\nconst std::string describeMountPt(const mount_t& mpt) {\n\tstd::string descr;\n\n\tdescr.append(mpt.src.empty() ? \"\" : QC(mpt.src))\n\t    .append(mpt.src.empty() ? \"\" : \" -> \")\n\t    .append(QC(mpt.dst))\n\t    .append(\" flags:\")\n\t    .append(flagsToStr(mpt.flags))\n\t    .append(\" type:\")\n\t    .append(QC(mpt.fs_type))\n\t    .append(\" options:\")\n\t    .append(QC(mpt.options));\n\n\tif (mpt.is_dir) {\n\t\tdescr.append(\" dir:true\");\n\t} else {\n\t\tdescr.append(\" dir:false\");\n\t}\n\tif (!mpt.is_mandatory) {\n\t\tdescr.append(\" mandatory:false\");\n\t}\n\tif (!mpt.src_content.empty()) {\n\t\tdescr.append(\" src_content_len:\").append(std::to_string(mpt.src_content.length()));\n\t}\n\tif (mpt.is_symlink) {\n\t\tdescr.append(\" symlink:true\");\n\t}\n\n\treturn descr;\n}\n\n}  // namespace mnt\n"
        },
        {
          "name": "mnt.h",
          "type": "blob",
          "size": 1.6171875,
          "content": "/*\n\n   nsjail - CLONE_NEWNS routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_MNT_H\n#define NS_MNT_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include <string>\n\n#include \"nsjail.h\"\n\nnamespace mnt {\n\ntypedef enum {\n\tNS_DIR_NO = 0x100,\n\tNS_DIR_YES,\n\tNS_DIR_MAYBE,\n} isDir_t;\n\nbool initNs(nsjconf_t* nsjconf);\nbool addMountPtHead(nsjconf_t* nsjconf, const std::string& src, const std::string& dst,\n    const std::string& fstype, const std::string& options, uintptr_t flags, isDir_t is_dir,\n    bool is_mandatory, const std::string& src_env, const std::string& dst_env,\n    const std::string& src_content, bool is_symlink);\nbool addMountPtTail(nsjconf_t* nsjconf, const std::string& src, const std::string& dst,\n    const std::string& fstype, const std::string& options, uintptr_t flags, isDir_t is_dir,\n    bool is_mandatory, const std::string& src_env, const std::string& dst_env,\n    const std::string& src_content, bool is_symlink);\nconst std::string describeMountPt(const mount_t& mpt);\n\n}  // namespace mnt\n\n#endif /* NS_MNT_H */\n"
        },
        {
          "name": "net.cc",
          "type": "blob",
          "size": 11.8388671875,
          "content": "/*\n\n   nsjail - networking routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"net.h\"\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <net/if.h>\n#include <net/route.h>\n#include <netinet/in.h>\n#include <netinet/ip6.h>\n#include <netinet/tcp.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <string>\n\n#include \"logs.h\"\n#include \"subproc.h\"\n\nextern char** environ;\n\nnamespace net {\n\n#define IFACE_NAME \"vs\"\n\n#include <netlink/route/link.h>\n#include <netlink/route/link/macvlan.h>\n\nstatic bool cloneIface(\n    nsjconf_t* nsjconf, struct nl_sock* sk, struct nl_cache* link_cache, int pid) {\n\tstruct rtnl_link* rmv = rtnl_link_macvlan_alloc();\n\tif (rmv == nullptr) {\n\t\tLOG_E(\"rtnl_link_macvlan_alloc()\");\n\t\treturn false;\n\t}\n\n\tint err;\n\tint master_index = rtnl_link_name2i(link_cache, nsjconf->iface_vs.c_str());\n\tif (!master_index) {\n\t\tLOG_E(\"rtnl_link_name2i(): Did not find '%s' interface\", nsjconf->iface_vs.c_str());\n\t\trtnl_link_put(rmv);\n\t\treturn false;\n\t}\n\n\trtnl_link_set_name(rmv, IFACE_NAME);\n\trtnl_link_set_link(rmv, master_index);\n\trtnl_link_set_ns_pid(rmv, pid);\n\n\tif (nsjconf->iface_vs_ma != \"\") {\n\t\tstruct nl_addr* nladdr = nullptr;\n\t\tif ((err = nl_addr_parse(nsjconf->iface_vs_ma.c_str(), AF_LLC, &nladdr)) < 0) {\n\t\t\tLOG_E(\"nl_addr_parse('%s', AF_LLC) failed: %s\",\n\t\t\t    nsjconf->iface_vs_ma.c_str(), nl_geterror(err));\n\t\t\treturn false;\n\t\t}\n\t\trtnl_link_set_addr(rmv, nladdr);\n\t\tnl_addr_put(nladdr);\n\t}\n\n\tif ((err = rtnl_link_macvlan_set_mode(\n\t\t rmv, rtnl_link_macvlan_str2mode(nsjconf->iface_vs_mo.c_str()))) < 0) {\n\t\tLOG_E(\"rtnl_link_macvlan_set_mode(mode:'%s') failed: %s\",\n\t\t    nsjconf->iface_vs_mo.c_str(), nl_geterror(err));\n\t}\n\n\tif ((err = rtnl_link_add(sk, rmv, NLM_F_CREATE)) < 0) {\n\t\tLOG_E(\"rtnl_link_add(name:'%s' link:'%s'): %s\", IFACE_NAME,\n\t\t    nsjconf->iface_vs.c_str(), nl_geterror(err));\n\t\trtnl_link_put(rmv);\n\t\treturn false;\n\t}\n\n\trtnl_link_put(rmv);\n\treturn true;\n}\n\nstatic bool moveToNs(\n    const std::string& iface, struct nl_sock* sk, struct nl_cache* link_cache, pid_t pid) {\n\tLOG_D(\"Moving interface '%s' into netns=%d\", iface.c_str(), (int)pid);\n\n\tstruct rtnl_link* orig_link = rtnl_link_get_by_name(link_cache, iface.c_str());\n\tif (!orig_link) {\n\t\tLOG_E(\"Couldn't find interface '%s'\", iface.c_str());\n\t\treturn false;\n\t}\n\tstruct rtnl_link* new_link = rtnl_link_alloc();\n\tif (!new_link) {\n\t\tLOG_E(\"Couldn't allocate new link\");\n\t\trtnl_link_put(orig_link);\n\t\treturn false;\n\t}\n\n\trtnl_link_set_ns_pid(new_link, pid);\n\n\tint err = rtnl_link_change(sk, orig_link, new_link, RTM_SETLINK);\n\tif (err < 0) {\n\t\tLOG_E(\"rtnl_link_change(): set NS of interface '%s' to pid=%d: %s\", iface.c_str(),\n\t\t    (int)pid, nl_geterror(err));\n\t\trtnl_link_put(new_link);\n\t\trtnl_link_put(orig_link);\n\t\treturn false;\n\t}\n\n\trtnl_link_put(new_link);\n\trtnl_link_put(orig_link);\n\treturn true;\n}\n\nbool initNsFromParent(nsjconf_t* nsjconf, int pid) {\n\tif (!nsjconf->clone_newnet) {\n\t\treturn true;\n\t}\n\tstruct nl_sock* sk = nl_socket_alloc();\n\tif (!sk) {\n\t\tLOG_E(\"Could not allocate socket with nl_socket_alloc()\");\n\t\treturn false;\n\t}\n\n\tint err;\n\tif ((err = nl_connect(sk, NETLINK_ROUTE)) < 0) {\n\t\tLOG_E(\"Unable to connect socket: %s\", nl_geterror(err));\n\t\tnl_socket_free(sk);\n\t\treturn false;\n\t}\n\n\tstruct nl_cache* link_cache;\n\tif ((err = rtnl_link_alloc_cache(sk, AF_UNSPEC, &link_cache)) < 0) {\n\t\tLOG_E(\"rtnl_link_alloc_cache(): %s\", nl_geterror(err));\n\t\tnl_socket_free(sk);\n\t\treturn false;\n\t}\n\n\tfor (const auto& iface : nsjconf->ifaces) {\n\t\tif (!moveToNs(iface, sk, link_cache, pid)) {\n\t\t\tnl_cache_free(link_cache);\n\t\t\tnl_socket_free(sk);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!nsjconf->iface_vs.empty() && !cloneIface(nsjconf, sk, link_cache, pid)) {\n\t\tnl_cache_free(link_cache);\n\t\tnl_socket_free(sk);\n\t\treturn false;\n\t}\n\n\tnl_cache_free(link_cache);\n\tnl_socket_free(sk);\n\treturn true;\n}\n\nstatic bool isSocket(int fd) {\n\tint optval;\n\tsocklen_t optlen = sizeof(optval);\n\tint ret = getsockopt(fd, SOL_SOCKET, SO_TYPE, &optval, &optlen);\n\tif (ret == -1) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool limitConns(nsjconf_t* nsjconf, int connsock) {\n\t/* 0 means 'unlimited' */\n\tif (nsjconf->max_conns != 0 && nsjconf->pids.size() >= nsjconf->max_conns) {\n\t\tLOG_W(\"Rejecting connection, max_conns limit reached: %u\", nsjconf->max_conns);\n\t\treturn false;\n\t}\n\n\t/* 0 means 'unlimited' */\n\tif (nsjconf->max_conns_per_ip == 0) {\n\t\treturn true;\n\t}\n\n\tstruct sockaddr_in6 addr = {};\n\tauto connstr = connToText(connsock, true /* remote */, &addr);\n\n\tunsigned cnt = 0;\n\tfor (const auto& pid : nsjconf->pids) {\n\t\tif (memcmp(addr.sin6_addr.s6_addr, pid.second.remote_addr.sin6_addr.s6_addr,\n\t\t\tsizeof(pid.second.remote_addr.sin6_addr.s6_addr)) == 0) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif (cnt >= nsjconf->max_conns_per_ip) {\n\t\tLOG_W(\"Rejecting connection from '%s', max_conns_per_ip limit reached: %u\",\n\t\t    connstr.c_str(), nsjconf->max_conns_per_ip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint getRecvSocket(const char* bindhost, int port) {\n\tif (port < 0 || port > 65535) {\n\t\tLOG_F(\"TCP port %d out of bounds (0 <= port <= 65535), specify one with --port \"\n\t\t      \"<port>\",\n\t\t    port);\n\t}\n\n\tchar bindaddr[128];\n\tsnprintf(bindaddr, sizeof(bindaddr), \"%s\", bindhost);\n\tstruct in_addr in4a;\n\tif (inet_pton(AF_INET, bindaddr, &in4a) == 1) {\n\t\tsnprintf(bindaddr, sizeof(bindaddr), \"::ffff:%s\", bindhost);\n\t\tLOG_D(\"Converting bind IPv4:'%s' to IPv6:'%s'\", bindhost, bindaddr);\n\t}\n\n\tstruct in6_addr in6a;\n\tif (inet_pton(AF_INET6, bindaddr, &in6a) != 1) {\n\t\tPLOG_E(\n\t\t    \"Couldn't convert '%s' (orig:'%s') into AF_INET6 address\", bindaddr, bindhost);\n\t\treturn -1;\n\t}\n\n\tint sockfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (sockfd == -1) {\n\t\tPLOG_E(\"socket(AF_INET6)\");\n\t\treturn -1;\n\t}\n\tif (fcntl(sockfd, F_SETFL, O_NONBLOCK)) {\n\t\tPLOG_E(\"fcntl(%d, F_SETFL, O_NONBLOCK)\", sockfd);\n\t\treturn -1;\n\t}\n\tint so = 1;\n\tif (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &so, sizeof(so)) == -1) {\n\t\tPLOG_E(\"setsockopt(%d, SO_REUSEADDR)\", sockfd);\n\t\treturn -1;\n\t}\n\tstruct sockaddr_in6 addr = {\n\t    .sin6_family = AF_INET6,\n\t    .sin6_port = htons(port),\n\t    .sin6_flowinfo = 0,\n\t    .sin6_addr = in6a,\n\t    .sin6_scope_id = 0,\n\t};\n\tif (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {\n\t\tclose(sockfd);\n\t\tPLOG_E(\"bind(host:[%s] (orig:'%s'), port:%d)\", bindaddr, bindhost, port);\n\t\treturn -1;\n\t}\n\tif (listen(sockfd, SOMAXCONN) == -1) {\n\t\tclose(sockfd);\n\t\tPLOG_E(\"listen(%d)\", SOMAXCONN);\n\t\treturn -1;\n\t}\n\n\tauto connstr = connToText(sockfd, false /* remote */, nullptr);\n\tLOG_I(\"Listening on %s\", connstr.c_str());\n\n\treturn sockfd;\n}\n\nint acceptConn(int listenfd) {\n\tstruct sockaddr_in6 cli_addr = {};\n\tsocklen_t socklen = sizeof(cli_addr);\n\tint connfd = accept4(listenfd, (struct sockaddr*)&cli_addr, &socklen, SOCK_NONBLOCK);\n\tif (connfd == -1) {\n\t\tif (errno != EINTR) {\n\t\t\tPLOG_E(\"accept(%d)\", listenfd);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tauto connremotestr = connToText(connfd, true /* remote */, nullptr);\n\tauto connlocalstr = connToText(connfd, false /* remote */, nullptr);\n\tLOG_I(\"New connection from: %s on: %s\", connremotestr.c_str(), connlocalstr.c_str());\n\n\treturn connfd;\n}\n\nconst std::string connToText(int fd, bool remote, struct sockaddr_in6* addr_or_null) {\n\tstd::string res;\n\n\tif (!isSocket(fd)) {\n\t\treturn \"[STANDALONE MODE]\";\n\t}\n\n\tstruct sockaddr_in6 addr;\n\tsocklen_t addrlen = sizeof(addr);\n\tif (remote) {\n\t\tif (getpeername(fd, (struct sockaddr*)&addr, &addrlen) == -1) {\n\t\t\tPLOG_W(\"getpeername(%d)\", fd);\n\t\t\treturn \"[unknown]\";\n\t\t}\n\t} else {\n\t\tif (getsockname(fd, (struct sockaddr*)&addr, &addrlen) == -1) {\n\t\t\tPLOG_W(\"getsockname(%d)\", fd);\n\t\t\treturn \"[unknown]\";\n\t\t}\n\t}\n\n\tif (addr_or_null) {\n\t\tmemcpy(addr_or_null, &addr, sizeof(*addr_or_null));\n\t}\n\n\tchar addrstr[128];\n\tif (!inet_ntop(AF_INET6, addr.sin6_addr.s6_addr, addrstr, sizeof(addrstr))) {\n\t\tPLOG_W(\"inet_ntop()\");\n\t\tsnprintf(addrstr, sizeof(addrstr), \"[unknown](%s)\", strerror(errno));\n\t}\n\n\tres.append(\"[\");\n\tres.append(addrstr);\n\tres.append(\"]:\");\n\tres.append(std::to_string(ntohs(addr.sin6_port)));\n\treturn res;\n}\n\nstatic bool ifaceUp(const char* ifacename) {\n\tint sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);\n\tif (sock == -1) {\n\t\tPLOG_E(\"socket(AF_INET, SOCK_STREAM, IPPROTO_IP)\");\n\t\treturn false;\n\t}\n\n\tstruct ifreq ifr = {};\n\tsnprintf(ifr.ifr_name, IF_NAMESIZE, \"%s\", ifacename);\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tPLOG_E(\"ioctl(iface='%s', SIOCGIFFLAGS, IFF_UP)\", ifacename);\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\n\tifr.ifr_flags |= (IFF_UP | IFF_RUNNING);\n\n\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {\n\t\tPLOG_E(\"ioctl(iface='%s', SIOCSIFFLAGS, IFF_UP|IFF_RUNNING)\", ifacename);\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\n\tclose(sock);\n\treturn true;\n}\n\nstatic bool ifaceConfig(const std::string& iface, const std::string& ip, const std::string& mask,\n    const std::string& gw) {\n\tint sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);\n\tif (sock == -1) {\n\t\tPLOG_E(\"socket(AF_INET, SOCK_STREAM, IPPROTO_IP)\");\n\t\treturn false;\n\t}\n\n\tstruct in_addr addr;\n\tif (inet_pton(AF_INET, ip.c_str(), &addr) != 1) {\n\t\tPLOG_E(\"Cannot convert '%s' into an IPv4 address\", ip.c_str());\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\tif (addr.s_addr == INADDR_ANY) {\n\t\tLOG_D(\"IPv4 address for interface '%s' not set\", iface.c_str());\n\t\tclose(sock);\n\t\treturn true;\n\t}\n\n\tstruct ifreq ifr = {};\n\tsnprintf(ifr.ifr_name, IF_NAMESIZE, \"%s\", iface.c_str());\n\tstruct sockaddr_in* sa = (struct sockaddr_in*)(&ifr.ifr_addr);\n\tsa->sin_family = AF_INET;\n\tsa->sin_addr = addr;\n\tif (ioctl(sock, SIOCSIFADDR, &ifr) == -1) {\n\t\tPLOG_E(\"ioctl(iface='%s', SIOCSIFADDR, '%s')\", iface.c_str(), ip.c_str());\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\n\tif (inet_pton(AF_INET, mask.c_str(), &addr) != 1) {\n\t\tPLOG_E(\"Cannot convert '%s' into a IPv4 netmask\", mask.c_str());\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\tsa->sin_family = AF_INET;\n\tsa->sin_addr = addr;\n\tif (ioctl(sock, SIOCSIFNETMASK, &ifr) == -1) {\n\t\tPLOG_E(\"ioctl(iface='%s', SIOCSIFNETMASK, '%s')\", iface.c_str(), mask.c_str());\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\n\tif (!ifaceUp(iface.c_str())) {\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\n\tif (inet_pton(AF_INET, gw.c_str(), &addr) != 1) {\n\t\tPLOG_E(\"Cannot convert '%s' into a IPv4 GW address\", gw.c_str());\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\tif (addr.s_addr == INADDR_ANY) {\n\t\tLOG_D(\"Gateway address for '%s' is not set\", iface.c_str());\n\t\tclose(sock);\n\t\treturn true;\n\t}\n\n\tstruct rtentry rt = {};\n\tstruct sockaddr_in* sdest = (struct sockaddr_in*)(&rt.rt_dst);\n\tstruct sockaddr_in* smask = (struct sockaddr_in*)(&rt.rt_genmask);\n\tstruct sockaddr_in* sgate = (struct sockaddr_in*)(&rt.rt_gateway);\n\tsdest->sin_family = AF_INET;\n\tsdest->sin_addr.s_addr = INADDR_ANY;\n\tsmask->sin_family = AF_INET;\n\tsmask->sin_addr.s_addr = INADDR_ANY;\n\tsgate->sin_family = AF_INET;\n\tsgate->sin_addr = addr;\n\n\trt.rt_flags = RTF_UP | RTF_GATEWAY;\n\tchar rt_dev[IF_NAMESIZE];\n\tsnprintf(rt_dev, sizeof(rt_dev), \"%s\", iface.c_str());\n\trt.rt_dev = rt_dev;\n\n\tif (ioctl(sock, SIOCADDRT, &rt) == -1) {\n\t\tPLOG_E(\"ioctl(SIOCADDRT, '%s')\", gw.c_str());\n\t\tclose(sock);\n\t\treturn false;\n\t}\n\n\tclose(sock);\n\treturn true;\n}\n\nbool initNsFromChild(nsjconf_t* nsjconf) {\n\tif (!nsjconf->clone_newnet) {\n\t\treturn true;\n\t}\n\tif (nsjconf->iface_lo && !ifaceUp(\"lo\")) {\n\t\treturn false;\n\t}\n\tif (!nsjconf->iface_vs.empty() && !ifaceConfig(IFACE_NAME, nsjconf->iface_vs_ip,\n\t\t\t\t\t      nsjconf->iface_vs_nm, nsjconf->iface_vs_gw)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n}  // namespace net\n"
        },
        {
          "name": "net.h",
          "type": "blob",
          "size": 1.1484375,
          "content": "/*\n\n   nsjail - networking routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_NET_H\n#define NS_NET_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n#include <string>\n\n#include \"nsjail.h\"\n\nnamespace net {\n\nbool limitConns(nsjconf_t* nsjconf, int connsock);\nint getRecvSocket(const char* bindhost, int port);\nint acceptConn(int listenfd);\nconst std::string connToText(int fd, bool remote, struct sockaddr_in6* addr_or_null);\nbool initNsFromParent(nsjconf_t* nsjconf, int pid);\nbool initNsFromChild(nsjconf_t* nsjconf);\n\n}  // namespace net\n\n#endif /* _NET_H */\n"
        },
        {
          "name": "nsjail.1",
          "type": "blob",
          "size": 10.4091796875,
          "content": ".TH NSJAIL \"1\" \"August 2017\" \"nsjail\" \"User Commands\"\n\\\"\n.SH NAME\nnsjail \\- process isolation tool for linux\n\\\"\n.SH SYNOPSIS\n\\fInsjail\\fP [options] \\fB\\-\\-\\fR path_to_command [args]\n\\\"\n.SH DESCRIPTION\nNsJail is a process isolation tool for Linux. It utilizes Linux namespace subsystem, resource limits, and the seccomp-bpf syscall filters of the Linux kernel\n\\\"\n.SH Options\n.TP\n\\fB\\-\\-help\\fR|\\fB\\-h\\fR Help plz..\n.TP\n\\fB\\-\\-mode\\fR|\\fB\\-M\\fR VALUE\nExecution mode (default: o [MODE_STANDALONE_ONCE]):\n.IP\n\\fBl\\fR: Wait for connections on a TCP port (specified with \\fB\\-\\-port\\fR) [MODE_LISTEN_TCP]\n.PP\n.IP\n\\fBo\\fR: Launch a single process on the console using clone/execve [MODE_STANDALONE_ONCE]\n.PP\n.IP\n\\fBe\\fR: Launch a single process on the console using execve [MODE_STANDALONE_EXECVE]\n.PP\n.IP\n\\fBr\\fR: Launch a single process on the console with clone/execve, keep doing it forever [MODE_STANDALONE_RERUN]\n.PP\n.TP\n\\fB\\-\\-config\\fR|\\fB\\-C\\fR VALUE\nConfiguration file in the config.proto ProtoBuf format (see configs/ directory for examples)\n.TP\n\\fB\\-\\-exec_file\\fR|\\fB\\-x\\fR VALUE\nFile to exec (default: argv[0])\n.TP\n\\fB\\-\\-execute_fd\\fR\nUse execveat() to execute a file-descriptor instead of executing the binary path. In such case argv[0]/exec_file denotes a file path before mount namespacing\n.TP\n\\fB\\-\\-chroot\\fR|\\fB\\-c\\fR VALUE\nDirectory containing / of the jail (default: none)\n.TP\n\\fB\\-\\-rw\\fR\nMount chroot dir (/) R/W (default: R/O)\n.TP\n\\fB\\-\\-user\\fR|\\fB\\-u\\fR VALUE\nUsername/uid of processes inside the jail (default: your current uid). You can also use inside_ns_uid:outside_ns_uid:count convention here. Can be specified multiple times\n.TP\n\\fB\\-\\-group\\fR|\\fB\\-g\\fR VALUE\nGroupname/gid of processes inside the jail (default: your current gid). You can also use inside_ns_gid:global_ns_gid:count convention here. Can be specified multiple times\n.TP\n\\fB\\-\\-hostname\\fR|\\fB\\-H\\fR VALUE\nUTS name (hostname) of the jail (default: 'NSJAIL')\n.TP\n\\fB\\-\\-cwd\\fR|\\fB\\-D\\fR VALUE\nDirectory in the namespace the process will run (default: '/')\n.TP\n\\fB\\-\\-port\\fR|\\fB\\-p\\fR VALUE\nTCP port to bind to (enables MODE_LISTEN_TCP) (default: 0)\n.TP\n\\fB\\-\\-bindhost\\fR VALUE\nIP address to bind the port to (only in [MODE_LISTEN_TCP]), (default: '::')\n.TP\n\\fB\\-\\-max_conns\\fR VALUE\nMaximum number of connections across all IPs (only in [MODE_LISTEN_TCP]), (default: 0 (unlimited))\n.TP\n\\fB\\-\\-max_conns_per_ip\\fR|\\fB\\-i\\fR VALUE\nMaximum number of connections per one IP (only in [MODE_LISTEN_TCP]), (default: 0 (unlimited))\n.TP\n\\fB\\-\\-log\\fR|\\fB\\-l\\fR VALUE\nLog file (default: use log_fd)\n.TP\n\\fB\\-\\-log_fd\\fR|\\fB\\-L\\fR VALUE\nLog FD (default: 2)\n.TP\n\\fB\\-\\-time_limit\\fR|\\fB\\-t\\fR VALUE\nMaximum time that a jail can exist, in seconds (default: 600)\n.TP\n\\fB\\-\\-max_cpus\\fR VALUE\nMaximum number of CPUs a single jailed process can use (default: 0 'no limit')\n.TP\n\\fB\\-\\-daemon\\fR|\\fB\\-d\\fR\nDaemonize after start\n.TP\n\\fB\\-\\-verbose\\fR|\\fB\\-v\\fR\nVerbose output\n.TP\n\\fB\\-\\-quiet\\fR|\\fB\\-q\\fR\nLog warning and more important messages only\n.TP\n\\fB\\-\\-really_quiet\\fR|\\fB\\-Q\\fR\nLog fatal messages only\n.TP\n\\fB\\-\\-keep_env\\fR|\\fB\\-e\\fR\nPass all environment variables be passed process (default: all envars are cleared)\n.TP\n\\fB\\-\\-env\\fR|\\fB\\-E\\fR VALUE\nAdditional environment variable (can be used multiple times). If the envar doesn't contain '=' (e.g. just the 'DISPLAY' string), the current envar value will be used\n.TP\n\\fB\\-\\-keep_caps\\fR\nDon't drop any capabilities\n.TP\n\\fB\\-\\-cap\\fR VALUE\nRetain this capability, e.g. CAP_PTRACE (can be specified multiple times)\n.TP\n\\fB\\-\\-silent\\fR\nRedirect child process' fd:0/1/2 to /dev/null\n.TP\n\\fB\\-\\-stderr_to_null\\fR\nRedirect FD=2 (STDERR_FILENO) to /dev/null\n.TP\n\\fB\\-\\-skip_setsid\\fR\nDon't call setsid(), allows for terminal signal handling in the sandboxed process. Dangerous\n.TP\n\\fB\\-\\-pass_fd\\fR VALUE\nDon't close this FD before executing the child process (can be specified multiple times), by default: 0/1/2 are kept open\n.TP\n\\fB\\-\\-disable_no_new_privs\\fR\nDon't set the prctl(NO_NEW_PRIVS, 1) (DANGEROUS)\n.TP\n\\fB\\-\\-rlimit_as\\fR VALUE\nRLIMIT_AS in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM_INFINITY (default: 4096)\n.TP\n\\fB\\-\\-rlimit_core\\fR VALUE\nRLIMIT_CORE in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current limit, 'inf' for RLIM_INFINITY (default: 0)\n.TP\n\\fB\\-\\-rlimit_cpu\\fR VALUE\nRLIMIT_CPU, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM_INFINITY (default: 600)\n.TP\n\\fB\\-\\-rlimit_fsize\\fR VALUE\nRLIMIT_FSIZE in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM_INFINITY (default: 1)\n.TP\n\\fB\\-\\-rlimit_nofile\\fR VALUE\nRLIMIT_NOFILE, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current limit, 'inf' for RLIM_INFINITY (default: 32)\n.TP\n\\fB\\-\\-rlimit_nproc\\fR VALUE\nRLIMIT_NPROC, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM_INFINITY (default: 'soft')\n.TP\n\\fB\\-\\-rlimit_stack\\fR VALUE\nRLIMIT_STACK in MB, 'max' or 'hard' for the current hard limit, 'def' or 'soft' for the current soft limit, 'inf' for RLIM_INFINITY (default: 'soft')\n.TP\n\\fB\\-\\-disable_rlimits\\fR\nDisable all rlimits, default to limits set by parent\n.TP\n\\fB\\-\\-persona_addr_compat_layout\\fR\npersonality(ADDR_COMPAT_LAYOUT)\n.TP\n\\fB\\-\\-persona_mmap_page_zero\\fR\npersonality(MMAP_PAGE_ZERO)\n.TP\n\\fB\\-\\-persona_read_implies_exec\\fR\npersonality(READ_IMPLIES_EXEC)\n.TP\n\\fB\\-\\-persona_addr_limit_3gb\\fR\npersonality(ADDR_LIMIT_3GB)\n.TP\n\\fB\\-\\-persona_addr_no_randomize\\fR\npersonality(ADDR_NO_RANDOMIZE)\n.TP\n\\fB\\-\\-disable_clone_newnet\\fR|\\-N\nDon't use CLONE_NEWNET. Enable global networking inside the jail\n.TP\n\\fB\\-\\-disable_clone_newuser\\fR\nDon't use CLONE_NEWUSER. Requires euid==0\n.TP\n\\fB\\-\\-disable_clone_newns\\fR\nDon't use CLONE_NEWNS\n.TP\n\\fB\\-\\-disable_clone_newpid\\fR\nDon't use CLONE_NEWPID\n.TP\n\\fB\\-\\-disable_clone_newipc\\fR\nDon't use CLONE_NEWIPC\n.TP\n\\fB\\-\\-disable_clone_newuts\\fR\nDon't use CLONE_NEWUTS\n.TP\n\\fB\\-\\-disable_clone_newcgroup\\fR\nDon't use CLONE_NEWCGROUP. Might be required for kernel versions < 4.6\n.TP\n\\fB\\-\\-uid_mapping\\fR|\\fB\\-U\\fR VALUE\nAdd a custom uid mapping of the form inside_uid:outside_uid:count. Setting this requires newuidmap (set-uid) to be present\n.TP\n\\fB\\-\\-gid_mapping\\fR|\\fB\\-G\\fR VALUE\nAdd a custom gid mapping of the form inside_gid:outside_gid:count. Setting this requires newgidmap (set-uid) to be present\n.TP\n\\fB\\-\\-bindmount_ro\\fR|\\fB\\-R\\fR VALUE\nList of mountpoints to be mounted \\fB\\-\\-bind\\fR (ro) inside the container. Can be specified multiple times. Supports 'source' syntax, or 'source:dest'\n.TP\n\\fB\\-\\-bindmount\\fR|\\fB\\-B\\fR VALUE\nList of mountpoints to be mounted \\fB\\-\\-bind\\fR (rw) inside the container. Can be specified multiple times. Supports 'source' syntax, or 'source:dest'\n.TP\n\\fB\\-\\-tmpfsmount\\fR|\\fB\\-T\\fR VALUE\nList of mountpoints to be mounted as tmpfs (R/W) inside the container. Can be specified multiple times. Supports 'dest' syntax. Alternatively, use '-m none:dest:tmpfs:size=8388608'\n.TP\n\\fB\\-\\-mount\\fR|\\fB\\-m\\fR VALUE\nArbitrary mount, format src:dst:fs_type:options\n.TP\n\\fB\\-\\-symlink\\fR|\\f\\B\\-s\\fR VALUE\nSymlink, format src:dst\n.TP\n\\fB\\-\\-disable_proc\\fR\nDisable mounting procfs in the jail\n.TP\n\\fB\\-\\-proc_path\\fR VALUE\nPath used to mount procfs (default: '/proc')\n.TP\n\\fB\\-\\-proc_rw\\fR\nIs procfs mounted as R/W (default: R/O)\n.TP\n\\fB\\-\\-seccomp_policy\\fR|\\fB\\-P\\fR VALUE\nPath to file containing seccomp\\-bpf policy (see kafel/)\n.TP\n\\fB\\-\\-seccomp_string\\fR VALUE\nString with kafel seccomp\\-bpf policy (see kafel/)\n.TP\n\\fB\\-\\-seccomp_log\\fR\nUse SECCOMP_FILTER_FLAG_LOG. Log all actions except SECCOMP_RET_ALLOW. Supported since kernel version 4.14\n.TP\n\\fB\\-\\-cgroup_mem_max\\fR VALUE\nMaximum number of bytes to use in the group (default: '0' \\- disabled)\n.TP\n\\fB\\-\\-cgroup_mem_memsw_max\\fR VALUE\nMaximum number of memory+Swap bytes to use in the group (default: '0' \\- disabled)\n.TP\n\\fB\\-\\-cgroup_mem_swap_max\\fR VALUE\nMaximum number of swap bytes to use in the group (default: '-1' \\- disabled)\n.TP\n\\fB\\-\\-cgroup_mem_mount\\fR VALUE\nLocation of memory cgroup FS (default: '/sys/fs/cgroup/memory')\n.TP\n\\fB\\-\\-cgroup_mem_parent\\fR VALUE\nWhich pre\\-existing memory cgroup to use as a parent (default: 'NSJAIL')\n.TP\n\\fB\\-\\-cgroup_pids_max\\fR VALUE\nMaximum number of pids in a cgroup (default: '0' \\- disabled)\n.TP\n\\fB\\-\\-cgroup_pids_mount\\fR VALUE\nLocation of pids cgroup FS (default: '/sys/fs/cgroup/pids')\n.TP\n\\fB\\-\\-cgroup_pids_parent\\fR VALUE\nWhich pre\\-existing pids cgroup to use as a parent (default: 'NSJAIL')\n.TP\n\\fB\\-\\-cgroup_net_cls_classid\\fR VALUE\nClass identifier of network packets in the group (default: '0' \\- disabled)\n.TP\n\\fB\\-\\-cgroup_net_cls_mount\\fR VALUE\nLocation of net_cls cgroup FS (default: '/sys/fs/cgroup/net_cls')\n.TP\n\\fB\\-\\-cgroup_net_cls_parent\\fR VALUE\nWhich pre\\-existing net_cls cgroup to use as a parent (default: 'NSJAIL')\n.TP\n\\fB\\-\\-cgroup_cpu_ms_per_sec\\fR VALUE\nNumber of milliseconds of CPU time per second that the process group can use (default: '0' - no limit)\n.TP\n\\fB\\-\\-cgroup_cpu_mount\\fR VALUE\nLocation of cpu cgroup FS (default: '/sys/fs/cgroup/net_cls')\n.TP\n\\fB\\-\\-cgroup_cpu_parent\\fR VALUE\nWhich pre-existing cpu cgroup to use as a parent (default: 'NSJAIL')\n.TP\n\\fB\\-\\-cgroupv2_mount\\fR VALUE\nLocation of cgroup v2 directory (default: '/sys/fs/cgroup')\n.TP\n\\fB\\-\\-use_cgroupv2\\fR\nUse cgroup v2\n.TP\n\\fB\\-\\-iface_no_lo\\fR\nDon't bring the 'lo' interface up\n.TP\n\\fB\\-\\-iface_own\\fR VALUE\nMove this existing network interface into the new NET namespace. Can be specified multiple times\n.TP\n\\fB\\-\\-macvlan_iface\\fR|\\fB\\-I\\fR VALUE\nInterface which will be cloned (MACVLAN) and put inside the subprocess' namespace as 'vs'\n.TP\n\\fB\\-\\-macvlan_vs_ip\\fR VALUE\nIP of the 'vs' interface (e.g. \"192.168.0.1\")\n.TP\n\\fB\\-\\-macvlan_vs_nm\\fR VALUE\nNetmask of the 'vs' interface (e.g. \"255.255.255.0\")\n.TP\n\\fB\\-\\-macvlan_vs_gw\\fR VALUE\nDefault GW for the 'vs' interface (e.g. \"192.168.0.1\")\n.TP\n\\fB\\-\\-macvlan_vs_ma\\fR VALUE\nMAC-address of the 'vs' interface (e.g. \"ba:ad:ba:be:45:00\")\n\\\"\n.SH Examples\n.PP\nWait on a port 31337 for connections, and run /bin/sh:\n.IP\nnsjail \\-Ml \\-\\-port 31337 \\-\\-chroot / \\-\\- /bin/sh \\-i\n.PP\nRe\\-run echo command as a sub\\-process:\n.IP\nnsjail \\-Mr \\-\\-chroot / \\-\\- /bin/echo \"ABC\"\n.PP\nRun echo command once only, as a sub\\-process:\n.IP\nnsjail \\-Mo \\-\\-chroot / \\-\\- /bin/echo \"ABC\"\n.PP\nExecute echo command directly, without a supervising process:\n.IP\nnsjail \\-Me \\-\\-chroot / \\-\\-disable_proc \\-\\- /bin/echo \"ABC\"\n\\\"\n"
        },
        {
          "name": "nsjail.cc",
          "type": "blob",
          "size": 8.7001953125,
          "content": "/*\n\n   nsjail\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"nsjail.h\"\n\n#include <fcntl.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <atomic>\n#include <cerrno>\n#include <memory>\n#include <vector>\n\n#include \"cgroup2.h\"\n#include \"cmdline.h\"\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"net.h\"\n#include \"sandbox.h\"\n#include \"subproc.h\"\n#include \"util.h\"\n\nnamespace nsjail {\n\nstatic __thread std::atomic<int> sigFatal(0);\nstatic __thread std::atomic<bool> showProc(false);\n\nstatic void sigHandler(int sig) {\n\tif (sig == SIGALRM || sig == SIGCHLD || sig == SIGPIPE) {\n\t\treturn;\n\t}\n\tif (sig == SIGUSR1 || sig == SIGQUIT) {\n\t\tshowProc = true;\n\t\treturn;\n\t}\n\tsigFatal = sig;\n}\n\nstatic bool setSigHandler(int sig) {\n\tLOG_D(\"Setting sighandler for signal %s (%d)\", util::sigName(sig).c_str(), sig);\n\n\tsigset_t smask;\n\tsigemptyset(&smask);\n\n\tstruct sigaction sa;\n\tsa.sa_handler = sigHandler;\n\tsa.sa_mask = smask;\n\tsa.sa_flags = 0;\n\tsa.sa_restorer = NULL;\n\n\tif (sig == SIGTTIN || sig == SIGTTOU) {\n\t\tsa.sa_handler = SIG_IGN;\n\t}\n\tif (sigaction(sig, &sa, NULL) == -1) {\n\t\tPLOG_E(\"sigaction(%d)\", sig);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool setSigHandlers(void) {\n\tfor (const auto& i : nssigs) {\n\t\tif (!setSigHandler(i)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool setTimer(nsjconf_t* nsjconf) {\n\tif (nsjconf->mode == MODE_STANDALONE_EXECVE) {\n\t\treturn true;\n\t}\n\n\tstruct itimerval it = {\n\t    .it_interval =\n\t\t{\n\t\t    .tv_sec = 1,\n\t\t    .tv_usec = 0,\n\t\t},\n\t    .it_value =\n\t\t{\n\t\t    .tv_sec = 1,\n\t\t    .tv_usec = 0,\n\t\t},\n\t};\n\tif (setitimer(ITIMER_REAL, &it, NULL) == -1) {\n\t\tPLOG_E(\"setitimer(ITIMER_REAL)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool pipeTraffic(nsjconf_t* nsjconf, int listenfd) {\n\tstd::vector<struct pollfd> fds;\n\tfds.reserve(nsjconf->pipes.size() * 3 + 1);\n\tfor (const auto& p : nsjconf->pipes) {\n\t\tfds.push_back({\n\t\t    .fd = p.sock_fd,\n\t\t    .events = POLLIN | POLLOUT,\n\t\t    .revents = 0,\n\t\t});\n\t\tfds.push_back({\n\t\t    .fd = p.pipe_in,\n\t\t    .events = POLLOUT,\n\t\t    .revents = 0,\n\t\t});\n\t\tfds.push_back({\n\t\t    .fd = p.pipe_out,\n\t\t    .events = POLLIN,\n\t\t    .revents = 0,\n\t\t});\n\t}\n\tfds.push_back({\n\t    .fd = listenfd,\n\t    .events = POLLIN,\n\t    .revents = 0,\n\t});\n\tLOG_D(\"Waiting for fd activity\");\n\twhile (poll(fds.data(), fds.size(), -1) > 0) {\n\t\tif (sigFatal > 0 || showProc) {\n\t\t\treturn false;\n\t\t}\n\t\tif (fds.back().revents != 0) {\n\t\t\tLOG_D(\"New connection ready\");\n\t\t\treturn true;\n\t\t}\n\t\tbool cleanup = false;\n\t\tfor (size_t i = 0; i < fds.size() - 1; ++i) {\n\t\t\tif (fds[i].revents & POLLIN) {\n\t\t\t\tfds[i].events &= ~POLLIN;\n\t\t\t}\n\t\t\tif (fds[i].revents & POLLOUT) {\n\t\t\t\tfds[i].events &= ~POLLOUT;\n\t\t\t}\n\t\t}\n\t\tfor (size_t i = 0; i < fds.size() - 3; i += 3) {\n\t\t\tconst size_t pipe_no = i / 3;\n\t\t\tint in, out;\n\t\t\tconst char* direction;\n\t\t\tbool closed = false;\n\t\t\tstd::tuple<int, int, const char*> direction_map[] = {\n\t\t\t    std::make_tuple(i, i + 1, \"in\"),\n\t\t\t    std::make_tuple(i + 2, i, \"out\"),\n\t\t\t};\n\t\t\tfor (const auto& entry : direction_map) {\n\t\t\t\tstd::tie(in, out, direction) = entry;\n\t\t\t\tbool in_ready = (fds[in].events & POLLIN) == 0 ||\n\t\t\t\t\t\t(fds[in].revents & POLLIN) == POLLIN;\n\t\t\t\tbool out_ready = (fds[out].events & POLLOUT) == 0 ||\n\t\t\t\t\t\t (fds[out].revents & POLLOUT) == POLLOUT;\n\t\t\t\tif (in_ready && out_ready) {\n\t\t\t\t\tLOG_D(\"#%zu piping data %s\", pipe_no, direction);\n\t\t\t\t\tssize_t rv = splice(fds[in].fd, nullptr, fds[out].fd,\n\t\t\t\t\t    nullptr, 4096, SPLICE_F_NONBLOCK);\n\t\t\t\t\tif (rv == -1 && errno != EAGAIN) {\n\t\t\t\t\t\tPLOG_E(\"splice fd pair #%zu {%d, %d}\\n\", pipe_no,\n\t\t\t\t\t\t    fds[in].fd, fds[out].fd);\n\t\t\t\t\t}\n\t\t\t\t\tif (rv == 0) {\n\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t}\n\t\t\t\t\tfds[in].events |= POLLIN;\n\t\t\t\t\tfds[out].events |= POLLOUT;\n\t\t\t\t}\n\t\t\t\tif ((fds[in].revents & (POLLERR | POLLHUP)) != 0 ||\n\t\t\t\t    (fds[out].revents & (POLLERR | POLLHUP)) != 0) {\n\t\t\t\t\tclosed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (closed) {\n\t\t\t\tLOG_D(\"#%zu connection closed\", pipe_no);\n\t\t\t\tcleanup = true;\n\t\t\t\tclose(nsjconf->pipes[pipe_no].sock_fd);\n\t\t\t\tclose(nsjconf->pipes[pipe_no].pipe_in);\n\t\t\t\tclose(nsjconf->pipes[pipe_no].pipe_out);\n\t\t\t\tif (nsjconf->pipes[pipe_no].pid > 0) {\n\t\t\t\t\tkill(nsjconf->pipes[pipe_no].pid, SIGKILL);\n\t\t\t\t}\n\t\t\t\tnsjconf->pipes[pipe_no] = {};\n\t\t\t}\n\t\t}\n\t\tif (cleanup) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tnsjconf->pipes.erase(std::remove(nsjconf->pipes.begin(), nsjconf->pipes.end(), pipemap_t{}),\n\t    nsjconf->pipes.end());\n\treturn false;\n}\n\nstatic int listenMode(nsjconf_t* nsjconf) {\n\tint listenfd = net::getRecvSocket(nsjconf->bindhost.c_str(), nsjconf->port);\n\tif (listenfd == -1) {\n\t\treturn EXIT_FAILURE;\n\t}\n\tfor (;;) {\n\t\tif (sigFatal > 0) {\n\t\t\tsubproc::killAndReapAll(\n\t\t\t    nsjconf, nsjconf->forward_signals ? sigFatal.load() : SIGKILL);\n\t\t\tlogs::logStop(sigFatal);\n\t\t\tclose(listenfd);\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tif (showProc) {\n\t\t\tshowProc = false;\n\t\t\tsubproc::displayProc(nsjconf);\n\t\t}\n\t\tif (pipeTraffic(nsjconf, listenfd)) {\n\t\t\tint connfd = net::acceptConn(listenfd);\n\t\t\tif (connfd >= 0) {\n\t\t\t\tint in[2];\n\t\t\t\tint out[2];\n\t\t\t\tif (pipe(in) != 0 || pipe(out) != 0) {\n\t\t\t\t\tPLOG_E(\"pipe\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tpid_t pid =\n\t\t\t\t    subproc::runChild(nsjconf, connfd, in[0], out[1], out[1]);\n\n\t\t\t\tclose(in[0]);\n\t\t\t\tclose(out[1]);\n\n\t\t\t\tif (pid <= 0) {\n\t\t\t\t\tclose(in[1]);\n\t\t\t\t\tclose(out[0]);\n\t\t\t\t\tclose(connfd);\n\t\t\t\t} else {\n\t\t\t\t\tnsjconf->pipes.push_back({\n\t\t\t\t\t    .sock_fd = connfd,\n\t\t\t\t\t    .pipe_in = in[1],\n\t\t\t\t\t    .pipe_out = out[0],\n\t\t\t\t\t    .pid = pid,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubproc::reapProc(nsjconf);\n\t}\n}\n\nstatic int standaloneMode(nsjconf_t* nsjconf) {\n\tfor (;;) {\n\t\tif (subproc::runChild(nsjconf, /* netfd= */ -1, STDIN_FILENO, STDOUT_FILENO,\n\t\t\tSTDERR_FILENO) == -1) {\n\t\t\tLOG_E(\"Couldn't launch the child process\");\n\t\t\treturn 0xff;\n\t\t}\n\t\tfor (;;) {\n\t\t\tint child_status = subproc::reapProc(nsjconf);\n\t\t\tif (subproc::countProc(nsjconf) == 0) {\n\t\t\t\tif (nsjconf->mode == MODE_STANDALONE_ONCE) {\n\t\t\t\t\treturn child_status;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (showProc) {\n\t\t\t\tshowProc = false;\n\t\t\t\tsubproc::displayProc(nsjconf);\n\t\t\t}\n\t\t\tif (sigFatal > 0) {\n\t\t\t\tsubproc::killAndReapAll(\n\t\t\t\t    nsjconf, nsjconf->forward_signals ? sigFatal.load() : SIGKILL);\n\t\t\t\tlogs::logStop(sigFatal);\n\t\t\t\treturn (128 + sigFatal);\n\t\t\t}\n\t\t\tpause();\n\t\t}\n\t}\n\t// not reached\n}\n\nstd::unique_ptr<struct termios> getTC(int fd) {\n\tstd::unique_ptr<struct termios> trm(new struct termios);\n\n\tif (ioctl(fd, TCGETS, trm.get()) == -1) {\n\t\tPLOG_D(\"ioctl(fd=%d, TCGETS) failed\", fd);\n\t\treturn nullptr;\n\t}\n\tLOG_D(\"Saved the current state of the TTY\");\n\treturn trm;\n}\n\nvoid setTC(int fd, const struct termios* trm) {\n\tif (!trm) {\n\t\treturn;\n\t}\n\tif (ioctl(fd, TCSETS, trm) == -1) {\n\t\tPLOG_W(\"ioctl(fd=%d, TCSETS) failed\", fd);\n\t\treturn;\n\t}\n\tif (tcflush(fd, TCIFLUSH) == -1) {\n\t\tPLOG_W(\"tcflush(fd=%d, TCIFLUSH) failed\", fd);\n\t\treturn;\n\t}\n}\n\n}  // namespace nsjail\n\nint main(int argc, char* argv[]) {\n\tstd::unique_ptr<nsjconf_t> nsjconf = cmdline::parseArgs(argc, argv);\n\tstd::unique_ptr<struct termios> trm = nsjail::getTC(STDIN_FILENO);\n\n\tif (!nsjconf) {\n\t\tLOG_F(\"Couldn't parse cmdline options\");\n\t}\n\tif (nsjconf->daemonize && (daemon(/* nochdir= */ 1, /* noclose= */ 0) == -1)) {\n\t\tPLOG_F(\"daemon\");\n\t}\n\tcmdline::logParams(nsjconf.get());\n\tif (!nsjail::setSigHandlers()) {\n\t\tLOG_F(\"nsjail::setSigHandlers() failed\");\n\t}\n\tif (!nsjail::setTimer(nsjconf.get())) {\n\t\tLOG_F(\"nsjail::setTimer() failed\");\n\t}\n\n\tif (nsjconf->detect_cgroupv2) {\n\t\tcgroup2::detectCgroupv2(nsjconf.get());\n\t\tLOG_I(\"Detected cgroups version: %d\", nsjconf->use_cgroupv2 ? 2 : 1);\n\t}\n\n\tif (nsjconf->use_cgroupv2) {\n\t\tif (!cgroup2::setup(nsjconf.get())) {\n\t\t\tLOG_E(\"Couldn't setup parent cgroup (cgroupv2)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!sandbox::preparePolicy(nsjconf.get())) {\n\t\tLOG_F(\"Couldn't prepare sandboxing policy\");\n\t}\n\n\tint ret = 0;\n\tif (nsjconf->mode == MODE_LISTEN_TCP) {\n\t\tret = nsjail::listenMode(nsjconf.get());\n\t} else {\n\t\tret = nsjail::standaloneMode(nsjconf.get());\n\t}\n\n\tsandbox::closePolicy(nsjconf.get());\n\t/* Try to restore the underlying console's params in case some program has changed it */\n\tif (!nsjconf->daemonize) {\n\t\tnsjail::setTC(STDIN_FILENO, trm.get());\n\t}\n\n\tLOG_D(\"Returning with %d\", ret);\n\treturn ret;\n}\n"
        },
        {
          "name": "nsjail.h",
          "type": "blob",
          "size": 3.9072265625,
          "content": "/*\n\n   nsjail\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n   Copyright 2016 Sergiusz Bazanski. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_NSJAIL_H\n#define NS_NSJAIL_H\n\n#include <linux/filter.h>\n#include <netinet/ip6.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <map>\n#include <string>\n#include <vector>\n\nstatic const int nssigs[] = {\n    SIGINT,\n    SIGQUIT,\n    SIGUSR1,\n    SIGALRM,\n    SIGCHLD,\n    SIGTERM,\n    SIGTTIN,\n    SIGTTOU,\n    SIGPIPE,\n};\n\nstruct pids_t {\n\ttime_t start;\n\tstd::string remote_txt;\n\tstruct sockaddr_in6 remote_addr;\n\tint pid_syscall_fd;\n};\n\nstruct mount_t {\n\tstd::string src;\n\tstd::string src_content;\n\tstd::string dst;\n\tstd::string fs_type;\n\tstd::string options;\n\tuintptr_t flags;\n\tbool is_dir;\n\tbool is_symlink;\n\tbool is_mandatory;\n\tbool mounted;\n};\n\nstruct idmap_t {\n\tuid_t inside_id;\n\tuid_t outside_id;\n\tsize_t count;\n\tbool is_newidmap;\n};\n\nenum ns_mode_t {\n\tMODE_LISTEN_TCP = 0,\n\tMODE_STANDALONE_ONCE,\n\tMODE_STANDALONE_EXECVE,\n\tMODE_STANDALONE_RERUN\n};\n\nstruct pipemap_t {\n\tint sock_fd;\n\tint pipe_in;\n\tint pipe_out;\n\tpid_t pid;\n\tbool operator==(const pipemap_t& o) {\n\t\treturn sock_fd == o.sock_fd && pipe_in == o.pipe_in && pipe_out == o.pipe_out;\n\t}\n};\n\nstruct nsjconf_t {\n\tstd::string exec_file;\n\tbool use_execveat;\n\tint exec_fd;\n\tstd::vector<std::string> argv;\n\tstd::string hostname;\n\tstd::string cwd;\n\tstd::string chroot;\n\tint port;\n\tstd::string bindhost;\n\tbool daemonize;\n\tuint64_t tlimit;\n\tsize_t max_cpus;\n\tbool keep_env;\n\tbool keep_caps;\n\tbool disable_no_new_privs;\n\tuint64_t rl_as;\n\tuint64_t rl_core;\n\tuint64_t rl_cpu;\n\tuint64_t rl_fsize;\n\tuint64_t rl_nofile;\n\tuint64_t rl_nproc;\n\tuint64_t rl_stack;\n\tuint64_t rl_mlock;\n\tuint64_t rl_rtpr;\n\tuint64_t rl_msgq;\n\tbool disable_rl;\n\tunsigned long personality;\n\tbool clone_newnet;\n\tbool clone_newuser;\n\tbool clone_newns;\n\tbool no_pivotroot;\n\tbool clone_newpid;\n\tbool clone_newipc;\n\tbool clone_newuts;\n\tbool clone_newcgroup;\n\tbool clone_newtime;\n\tenum ns_mode_t mode;\n\tbool is_root_rw;\n\tbool is_silent;\n\tbool stderr_to_null;\n\tbool skip_setsid;\n\tunsigned int max_conns;\n\tunsigned int max_conns_per_ip;\n\tstd::string proc_path;\n\tbool is_proc_rw;\n\tbool iface_lo;\n\tstd::string iface_vs;\n\tstd::string iface_vs_ip;\n\tstd::string iface_vs_nm;\n\tstd::string iface_vs_gw;\n\tstd::string iface_vs_ma;\n\tstd::string iface_vs_mo;\n\tbool disable_tsc;\n\tbool forward_signals;\n\tstd::string cgroup_mem_mount;\n\tstd::string cgroup_mem_parent;\n\tsize_t cgroup_mem_max;\n\tsize_t cgroup_mem_memsw_max;\n\tssize_t cgroup_mem_swap_max;\n\tstd::string cgroup_pids_mount;\n\tstd::string cgroup_pids_parent;\n\tunsigned int cgroup_pids_max;\n\tstd::string cgroup_net_cls_mount;\n\tstd::string cgroup_net_cls_parent;\n\tunsigned int cgroup_net_cls_classid;\n\tstd::string cgroup_cpu_mount;\n\tstd::string cgroup_cpu_parent;\n\tunsigned int cgroup_cpu_ms_per_sec;\n\tstd::string cgroupv2_mount;\n\tbool use_cgroupv2;\n\tbool detect_cgroupv2;\n\tstd::string kafel_file_path;\n\tstd::string kafel_string;\n\tstruct sock_fprog seccomp_fprog;\n\tbool seccomp_log;\n\tint nice_level;\n\tuid_t orig_uid;\n\tuid_t orig_euid;\n\tstd::vector<mount_t> mountpts;\n\tstd::map<pid_t, pids_t> pids;\n\tstd::vector<idmap_t> uids;\n\tstd::vector<idmap_t> gids;\n\tstd::vector<std::string> envs;\n\tstd::vector<int> openfds;\n\tstd::vector<int> caps;\n\tstd::vector<std::string> ifaces;\n\tstd::vector<pipemap_t> pipes;\n};\n\n#endif /* _NSJAIL_H */\n"
        },
        {
          "name": "pid.cc",
          "type": "blob",
          "size": 2.1767578125,
          "content": "/*\n\n   nsjail - CLONE_PID routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"pid.h\"\n\n#include <linux/sched.h>\n#include <sched.h>\n#include <signal.h>\n#include <stddef.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n\n#include \"logs.h\"\n#include \"subproc.h\"\n\nnamespace pid {\n\nbool initNs(nsjconf_t* nsjconf) {\n\tif (nsjconf->mode != MODE_STANDALONE_EXECVE) {\n\t\treturn true;\n\t}\n\tif (!nsjconf->clone_newpid) {\n\t\treturn true;\n\t}\n\n\tLOG_D(\"Creating a dummy 'init' process\");\n\n\t/*\n\t * If -Me is used then we need to create permanent init inside PID ns, otherwise only the\n\t * first clone/fork will work, and the rest will fail with ENOMEM (see 'man pid_namespaces'\n\t * for details on this behavior)\n\t */\n\tpid_t pid = subproc::cloneProc(CLONE_FS, 0);\n\tif (pid == -1) {\n\t\tPLOG_E(\"Couldn't create a dummy init process\");\n\t\treturn false;\n\t}\n\tif (pid > 0) {\n\t\tLOG_D(\"Created a dummy 'init' process with PID=%d\", pid);\n\t\treturn true;\n\t}\n\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0UL, 0UL, 0UL) == -1) {\n\t\tPLOG_W(\"(prctl(PR_SET_PDEATHSIG, SIGKILL) failed\");\n\t}\n\tif (prctl(PR_SET_NAME, \"ns-init\", 0UL, 0UL, 0UL) == -1) {\n\t\tPLOG_W(\"(prctl(PR_SET_NAME, 'init') failed\");\n\t}\n\tif (prctl(PR_SET_DUMPABLE, 0UL, 0UL, 0UL, 0UL) == -1) {\n\t\tPLOG_W(\"(prctl(PR_SET_DUMPABLE, 0) failed\");\n\t}\n\n\t/* Act sort-a like a init by reaping zombie processes */\n\tstruct sigaction sa = {};\n\tsa.sa_handler = SIG_DFL;\n\tsa.sa_flags = SA_NOCLDWAIT | SA_NOCLDSTOP;\n\tsa.sa_restorer = NULL;\n\tsigemptyset(&sa.sa_mask);\n\n\tif (sigaction(SIGCHLD, &sa, NULL) == -1) {\n\t\tPLOG_W(\"Couldn't set sighandler for SIGCHLD\");\n\t}\n\n\tfor (;;) {\n\t\tpause();\n\t}\n}\n\n}  // namespace pid\n"
        },
        {
          "name": "pid.h",
          "type": "blob",
          "size": 0.8388671875,
          "content": "/*\n\n   nsjail - CLONE_PID routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_PID_H\n#define NS_PID_H\n\n#include <stdbool.h>\n\n#include \"nsjail.h\"\n\nnamespace pid {\n\nbool initNs(nsjconf_t* nsjconf);\n\n}  // namespace pid\n\n#endif /* NS_PID_H */\n"
        },
        {
          "name": "sandbox.cc",
          "type": "blob",
          "size": 3.720703125,
          "content": "/*\n\n   nsjail - seccomp-bpf sandboxing\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"sandbox.h\"\n\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n\nextern \"C\" {\n#include \"kafel.h\"\n}\n#include \"logs.h\"\n#include \"util.h\"\n\nnamespace sandbox {\n\n#ifndef PR_SET_NO_NEW_PRIVS /* in prctl.h since Linux 3.5 */\n#define PR_SET_NO_NEW_PRIVS 38\n#endif /* PR_SET_NO_NEW_PRIVS */\n\n#ifndef SECCOMP_FILTER_FLAG_TSYNC\n#define SECCOMP_FILTER_FLAG_TSYNC (1UL << 0)\n#endif /* SECCOMP_FILTER_FLAG_TSYNC */\n\n#ifndef SECCOMP_FILTER_FLAG_LOG\n#define SECCOMP_FILTER_FLAG_LOG (1UL << 1)\n#endif /* SECCOMP_FILTER_FLAG_LOG */\n\nstatic bool prepareAndCommit(nsjconf_t* nsjconf) {\n\tif (nsjconf->kafel_file_path.empty() && nsjconf->kafel_string.empty()) {\n\t\treturn true;\n\t}\n\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tPLOG_W(\"prctl(PR_SET_NO_NEW_PRIVS, 1) failed\");\n\t\treturn false;\n\t}\n\tif (nsjconf->seccomp_log) {\n#ifndef __NR_seccomp\n\t\tLOG_E(\"The __NR_seccomp is not defined with this kernel's header files (kernel \"\n\t\t      \"headers too old?)\");\n\t\treturn false;\n#else\n\t\tif (util::syscall(__NR_seccomp, (uintptr_t)SECCOMP_SET_MODE_FILTER,\n\t\t\t(uintptr_t)(SECCOMP_FILTER_FLAG_TSYNC | SECCOMP_FILTER_FLAG_LOG),\n\t\t\t(uintptr_t)&nsjconf->seccomp_fprog) == -1) {\n\t\t\tPLOG_E(\"seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC | \"\n\t\t\t       \"SECCOMP_FILTER_FLAG_LOG) failed\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n#endif /* __NR_seccomp */\n\t}\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &nsjconf->seccomp_fprog, 0UL, 0UL)) {\n\t\tPLOG_W(\"prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER) failed\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool applyPolicy(nsjconf_t* nsjconf) {\n\treturn prepareAndCommit(nsjconf);\n}\n\nbool preparePolicy(nsjconf_t* nsjconf) {\n\tif (nsjconf->kafel_file_path.empty() && nsjconf->kafel_string.empty()) {\n\t\treturn true;\n\t}\n\tif (!nsjconf->kafel_file_path.empty() && !nsjconf->kafel_string.empty()) {\n\t\tLOG_W(\"You specified both kafel seccomp policy, and kafel seccomp file. Specify \"\n\t\t      \"one only\");\n\t\treturn false;\n\t}\n\n\tkafel_ctxt_t ctxt = kafel_ctxt_create();\n\n\tif (!nsjconf->kafel_file_path.empty()) {\n\t\tFILE* f = fopen(nsjconf->kafel_file_path.c_str(), \"r\");\n\t\tif (!f) {\n\t\t\tPLOG_W(\"Couldn't open the kafel seccomp policy file '%s'\",\n\t\t\t    nsjconf->kafel_file_path.c_str());\n\t\t\tkafel_ctxt_destroy(&ctxt);\n\t\t\treturn false;\n\t\t}\n\t\tLOG_D(\"Compiling seccomp policy from file: '%s'\", nsjconf->kafel_file_path.c_str());\n\t\tkafel_set_input_file(ctxt, f);\n\t}\n\tif (!nsjconf->kafel_string.empty()) {\n\t\tLOG_D(\"Compiling seccomp policy from string: '%s'\", nsjconf->kafel_string.c_str());\n\t\tkafel_set_input_string(ctxt, nsjconf->kafel_string.c_str());\n\t}\n\n\tif (kafel_compile(ctxt, &nsjconf->seccomp_fprog) != 0) {\n\t\tLOG_W(\"Could not compile policy: %s\", kafel_error_msg(ctxt));\n\t\tkafel_ctxt_destroy(&ctxt);\n\t\treturn false;\n\t}\n\tkafel_ctxt_destroy(&ctxt);\n\treturn true;\n}\n\nvoid closePolicy(nsjconf_t* nsjconf) {\n\tif (!nsjconf->seccomp_fprog.filter) {\n\t\treturn;\n\t}\n\tfree(nsjconf->seccomp_fprog.filter);\n\tnsjconf->seccomp_fprog.filter = nullptr;\n\tnsjconf->seccomp_fprog.len = 0;\n}\n\n}  // namespace sandbox\n"
        },
        {
          "name": "sandbox.h",
          "type": "blob",
          "size": 0.943359375,
          "content": "/*\n\n   nsjail - seccomp-bpf sandboxing\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_SANDBOX_H\n#define NS_SANDBOX_H\n\n#include <stdbool.h>\n\n#include \"nsjail.h\"\n\nnamespace sandbox {\n\nbool applyPolicy(nsjconf_t* nsjconf);\nbool preparePolicy(nsjconf_t* nsjconf);\nvoid closePolicy(nsjconf_t* nsjconf);\n\n}  // namespace sandbox\n\n#endif /* NS_SANDBOX_H */\n"
        },
        {
          "name": "subproc.cc",
          "type": "blob",
          "size": 18.234375,
          "content": "/*\n\n   nsjail - subprocess management\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"subproc.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/sched.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <string>\n#include <vector>\n\n#include \"cgroup.h\"\n#include \"cgroup2.h\"\n#include \"contain.h\"\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"net.h\"\n#include \"sandbox.h\"\n#include \"user.h\"\n#include \"util.h\"\n\nnamespace subproc {\n\n#if !defined(CLONE_NEWCGROUP)\n#define CLONE_NEWCGROUP 0x02000000\n#endif /* !defined(CLONE_NEWCGROUP) */\n#if !defined(CLONE_NEWTIME)\n#define CLONE_NEWTIME 0x00000080\n#endif /* !defined(CLONE_NEWTIME) */\n\nstatic const std::string cloneFlagsToStr(uint64_t flags) {\n\tstd::string res;\n\n\tstruct {\n\t\tconst uint64_t flag;\n\t\tconst char* const name;\n\t} static const cloneFlags[] = {\n\t    NS_VALSTR_STRUCT(CLONE_NEWTIME),\n\t    NS_VALSTR_STRUCT(CLONE_VM),\n\t    NS_VALSTR_STRUCT(CLONE_FS),\n\t    NS_VALSTR_STRUCT(CLONE_FILES),\n\t    NS_VALSTR_STRUCT(CLONE_SIGHAND),\n#if !defined(CLONE_PIDFD)\n#define CLONE_PIDFD 0x00001000\n#endif\n\t    NS_VALSTR_STRUCT(CLONE_PIDFD),\n\t    NS_VALSTR_STRUCT(CLONE_PTRACE),\n\t    NS_VALSTR_STRUCT(CLONE_VFORK),\n\t    NS_VALSTR_STRUCT(CLONE_PARENT),\n\t    NS_VALSTR_STRUCT(CLONE_THREAD),\n\t    NS_VALSTR_STRUCT(CLONE_NEWNS),\n\t    NS_VALSTR_STRUCT(CLONE_SYSVSEM),\n\t    NS_VALSTR_STRUCT(CLONE_SETTLS),\n\t    NS_VALSTR_STRUCT(CLONE_PARENT_SETTID),\n\t    NS_VALSTR_STRUCT(CLONE_CHILD_CLEARTID),\n\t    NS_VALSTR_STRUCT(CLONE_DETACHED),\n\t    NS_VALSTR_STRUCT(CLONE_UNTRACED),\n\t    NS_VALSTR_STRUCT(CLONE_CHILD_SETTID),\n\t    NS_VALSTR_STRUCT(CLONE_NEWCGROUP),\n\t    NS_VALSTR_STRUCT(CLONE_NEWUTS),\n\t    NS_VALSTR_STRUCT(CLONE_NEWIPC),\n\t    NS_VALSTR_STRUCT(CLONE_NEWUSER),\n\t    NS_VALSTR_STRUCT(CLONE_NEWPID),\n\t    NS_VALSTR_STRUCT(CLONE_NEWNET),\n\t    NS_VALSTR_STRUCT(CLONE_IO),\n#if !defined(CLONE_CLEAR_SIGHAND)\n#define CLONE_CLEAR_SIGHAND 0x100000000ULL\n#endif /* !defined(CLONE_CLEAR_SIGHAND) */\n\t    NS_VALSTR_STRUCT(CLONE_CLEAR_SIGHAND),\n#if !defined(CLONE_INTO_CGROUP)\n#define CLONE_INTO_CGROUP 0x200000000ULL\n#endif /* !defined(CLONE_INTO_CGROUP) */\n\t    NS_VALSTR_STRUCT(CLONE_INTO_CGROUP),\n\t};\n\n\tuint64_t knownFlagMask = 0;\n\tfor (const auto& i : cloneFlags) {\n\t\tif (flags & i.flag) {\n\t\t\tif (!res.empty()) {\n\t\t\t\tres.append(\"|\");\n\t\t\t}\n\t\t\tres.append(i.name);\n\t\t}\n\t\tknownFlagMask |= i.flag;\n\t}\n\n\tif (flags & ~(knownFlagMask)) {\n\t\tutil::StrAppend(&res, \"|%#\" PRIx64, flags & ~(knownFlagMask));\n\t}\n\treturn res;\n}\n\n/* Reset the execution environment for the new process */\nstatic bool resetEnv(void) {\n\t/* Set all previously changed signals to their default behavior */\n\tfor (const auto& sig : nssigs) {\n\t\tif (signal(sig, SIG_DFL) == SIG_ERR) {\n\t\t\tPLOG_W(\"signal(%s, SIG_DFL)\", util::sigName(sig).c_str());\n\t\t\treturn false;\n\t\t}\n\t}\n\t/* Unblock all signals */\n\tsigset_t sset;\n\tsigemptyset(&sset);\n\tif (sigprocmask(SIG_SETMASK, &sset, NULL) == -1) {\n\t\tPLOG_W(\"sigprocmask(SIG_SET, empty)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char kSubprocDoneChar = 'D';\nstatic const char kSubprocErrorChar = 'E';\n\nstatic const std::string concatArgs(const std::vector<const char*>& argv) {\n\tstd::string ret;\n\tfor (const auto& s : argv) {\n\t\tif (s) {\n\t\t\tif (!ret.empty()) {\n\t\t\t\tret.append(\", \");\n\t\t\t}\n\t\t\tret.append(util::StrQuote(s));\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void newProc(nsjconf_t* nsjconf, int netfd, int fd_in, int fd_out, int fd_err, int pipefd) {\n\tif (!contain::setupFD(nsjconf, fd_in, fd_out, fd_err)) {\n\t\treturn;\n\t}\n\tif (!resetEnv()) {\n\t\treturn;\n\t}\n\n\tif (pipefd == -1) {\n\t\tif (!user::initNsFromParent(nsjconf, getpid())) {\n\t\t\tLOG_E(\"Couldn't initialize net user namespace\");\n\t\t\treturn;\n\t\t}\n\t\tif (nsjconf->use_cgroupv2) {\n\t\t\tif (!cgroup2::initNsFromParent(nsjconf, getpid())) {\n\t\t\t\tLOG_E(\"Couldn't initialize net user namespace\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (!cgroup::initNsFromParent(nsjconf, getpid())) {\n\t\t\tLOG_E(\"Couldn't initialize net user namespace\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tchar doneChar;\n\t\tif (util::readFromFd(pipefd, &doneChar, sizeof(doneChar)) != sizeof(doneChar)) {\n\t\t\treturn;\n\t\t}\n\t\tif (doneChar != kSubprocDoneChar) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!contain::containProc(nsjconf)) {\n\t\treturn;\n\t}\n\tif (!nsjconf->keep_env) {\n\t\tclearenv();\n\t}\n\tfor (const auto& env : nsjconf->envs) {\n\t\tputenv(const_cast<char*>(env.c_str()));\n\t}\n\n\tauto connstr = net::connToText(netfd, /* remote= */ true, NULL);\n\tLOG_I(\"Executing %s for '%s'\", QC(nsjconf->exec_file), connstr.c_str());\n\n\tstd::vector<const char*> argv;\n\tfor (const auto& s : nsjconf->argv) {\n\t\targv.push_back(s.c_str());\n\t}\n\targv.push_back(nullptr);\n\n\tLOG_D(\"Exec: %s, Args: [%s]\", QC(nsjconf->exec_file), concatArgs(argv).c_str());\n\n\t/* Should be the last one in the sequence */\n\tif (!sandbox::applyPolicy(nsjconf)) {\n\t\treturn;\n\t}\n\n\tif (nsjconf->use_execveat) {\n#if defined(__NR_execveat)\n\t\tutil::syscall(__NR_execveat, nsjconf->exec_fd, (uintptr_t)\"\",\n\t\t    (uintptr_t)argv.data(), (uintptr_t)environ, AT_EMPTY_PATH);\n#else  /* defined(__NR_execveat) */\n\t\tLOG_E(\"Your system doesn't support execveat() syscall\");\n\t\treturn;\n#endif /* defined(__NR_execveat) */\n\t} else {\n\t\texecv(nsjconf->exec_file.c_str(), (char* const*)argv.data());\n\t}\n\n\tPLOG_E(\"execve(%s) failed\", QC(nsjconf->exec_file));\n}\n\nstatic void addProc(nsjconf_t* nsjconf, pid_t pid, int sock) {\n\tpids_t p;\n\n\tp.start = time(NULL);\n\tp.remote_txt = net::connToText(sock, /* remote= */ true, &p.remote_addr);\n\n\tchar fname[PATH_MAX];\n\tsnprintf(fname, sizeof(fname), \"/proc/%d/syscall\", (int)pid);\n\tp.pid_syscall_fd = TEMP_FAILURE_RETRY(open(fname, O_RDONLY | O_CLOEXEC));\n\n\tif (nsjconf->pids.find(pid) != nsjconf->pids.end()) {\n\t\tLOG_F(\"pid=%d already exists\", pid);\n\t}\n\tnsjconf->pids.insert(std::make_pair(pid, p));\n\n\tLOG_D(\"Added pid=%d with start time %u to the queue for IP: '%s'\", pid,\n\t    (unsigned int)p.start, p.remote_txt.c_str());\n}\n\nstatic void removeProc(nsjconf_t* nsjconf, pid_t pid) {\n\tif (nsjconf->pids.find(pid) == nsjconf->pids.end()) {\n\t\tLOG_W(\"pid=%d doesn't exist ?\", pid);\n\t\treturn;\n\t}\n\n\tconst auto& p = nsjconf->pids[pid];\n\tLOG_D(\"Removed pid=%d from the queue (IP:'%s', start time:'%s')\", pid, p.remote_txt.c_str(),\n\t    util::timeToStr(p.start).c_str());\n\n\tclose(p.pid_syscall_fd);\n\tnsjconf->pids.erase(pid);\n}\n\nint countProc(nsjconf_t* nsjconf) {\n\treturn nsjconf->pids.size();\n}\n\nvoid displayProc(nsjconf_t* nsjconf) {\n\tLOG_I(\"Total number of spawned namespaces: %d\", countProc(nsjconf));\n\ttime_t now = time(NULL);\n\tfor (const auto& pid : nsjconf->pids) {\n\t\ttime_t diff = now - pid.second.start;\n\t\tuint64_t left = nsjconf->tlimit ? nsjconf->tlimit - (uint64_t)diff : 0;\n\t\tLOG_I(\"pid=%d, Remote host: %s, Run time: %ld sec. (time left: %s s.)\", pid.first,\n\t\t    pid.second.remote_txt.c_str(), (long)diff,\n\t\t    nsjconf->tlimit ? std::to_string(left).c_str() : \"unlimited\");\n\t}\n}\n\nstatic void seccompViolation(nsjconf_t* nsjconf, siginfo_t* si) {\n\tLOG_W(\"pid=%d committed a syscall/seccomp violation and exited with SIGSYS\", si->si_pid);\n\n\tconst auto& p = nsjconf->pids.find(si->si_pid);\n\tif (p == nsjconf->pids.end()) {\n\t\tLOG_W(\"pid=%d SiStatus:%d SiUid:%d SiUtime:%ld SiStime:%ld (If \"\n\t\t      \"SiStatus==31 (SIGSYS), then see 'dmesg' or 'journalctl -ek' for possible \"\n\t\t      \"auditd report with more data)\",\n\t\t    (int)si->si_pid, si->si_status, si->si_uid, (long)si->si_utime,\n\t\t    (long)si->si_stime);\n\t\tLOG_E(\"Couldn't find pid element in the subproc list for pid=%d\", (int)si->si_pid);\n\t\treturn;\n\t}\n\n\tchar buf[4096];\n\tssize_t rdsize = util::readFromFd(p->second.pid_syscall_fd, buf, sizeof(buf) - 1);\n\tif (rdsize < 1) {\n\t\tLOG_W(\"pid=%d SiStatus:%d SiUid:%d SiUtime:%ld SiStime:%ld (If \"\n\t\t      \"SiStatus==31 (SIGSYS), then see 'dmesg' or 'journalctl -ek' for possible \"\n\t\t      \"auditd report with more data)\",\n\t\t    (int)si->si_pid, si->si_status, si->si_uid, (long)si->si_utime,\n\t\t    (long)si->si_stime);\n\t\treturn;\n\t}\n\tbuf[rdsize - 1] = '\\0';\n\n\tuintptr_t arg1, arg2, arg3, arg4, arg5, arg6, sp, pc;\n\tptrdiff_t sc;\n\tint ret = sscanf(buf, \"%td %tx %tx %tx %tx %tx %tx %tx %tx\", &sc, &arg1, &arg2, &arg3,\n\t    &arg4, &arg5, &arg6, &sp, &pc);\n\tif (ret == 9) {\n\t\tLOG_W(\"pid=%d, Syscall number:%td, Arguments:%#tx, %#tx, %#tx, %#tx, %#tx, %#tx, \"\n\t\t      \"SP:%#tx, PC:%#tx, si_status:%d\",\n\t\t    (int)si->si_pid, sc, arg1, arg2, arg3, arg4, arg5, arg6, sp, pc, si->si_status);\n\t} else if (ret == 3) {\n\t\tLOG_W(\"pid=%d SiStatus:%d SiUid:%d SiUtime:%ld SiStime:%ld SP:%#tx, PC:%#tx (If \"\n\t\t      \"SiStatus==31 (SIGSYS), then see 'dmesg' or 'journalctl -ek' for possible \"\n\t\t      \"auditd report with more data)\",\n\t\t    (int)si->si_pid, si->si_status, si->si_uid, (long)si->si_utime,\n\t\t    (long)si->si_stime, arg1, arg2);\n\t\treturn;\n\t} else {\n\t\tLOG_W(\"pid=%d SiStatus:%d SiUid:%d SiUtime:%ld SiStime:%ld (If \"\n\t\t      \"SiStatus==31 (SIGSYS), then see 'dmesg' or 'journalctl -ek' for possible \"\n\t\t      \"auditd report with more data)\",\n\t\t    (int)si->si_pid, si->si_status, si->si_uid, (long)si->si_utime,\n\t\t    (long)si->si_stime);\n\t}\n}\n\nstatic int reapProc(nsjconf_t* nsjconf, pid_t pid, bool should_wait = false) {\n\tint status;\n\n\tif (wait4(pid, &status, should_wait ? 0 : WNOHANG, NULL) == pid) {\n\t\tif (nsjconf->use_cgroupv2) {\n\t\t\tcgroup2::finishFromParent(nsjconf, pid);\n\t\t} else {\n\t\t\tcgroup::finishFromParent(nsjconf, pid);\n\t\t}\n\n\t\tstd::string remote_txt = \"[UNKNOWN]\";\n\t\tconst auto& p = nsjconf->pids.find(pid);\n\t\tif (p != nsjconf->pids.end()) {\n\t\t\tremote_txt = p->second.remote_txt;\n\t\t}\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tLOG_I(\"pid=%d (%s) exited with status: %d, (PIDs left: %d)\", pid,\n\t\t\t    remote_txt.c_str(), WEXITSTATUS(status), countProc(nsjconf) - 1);\n\t\t\tremoveProc(nsjconf, pid);\n\t\t\treturn WEXITSTATUS(status);\n\t\t}\n\t\tif (WIFSIGNALED(status)) {\n\t\t\tLOG_I(\"pid=%d (%s) terminated with signal: %s (%d), (PIDs left: %d)\", pid,\n\t\t\t    remote_txt.c_str(), util::sigName(WTERMSIG(status)).c_str(),\n\t\t\t    WTERMSIG(status), countProc(nsjconf) - 1);\n\t\t\tremoveProc(nsjconf, pid);\n\t\t\treturn 128 + WTERMSIG(status);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint reapProc(nsjconf_t* nsjconf) {\n\tint rv = 0;\n\tsiginfo_t si;\n\n\tfor (;;) {\n\t\tsi.si_pid = 0;\n\t\tif (waitid(P_ALL, 0, &si, WNOHANG | WNOWAIT | WEXITED) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (si.si_pid == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (si.si_code == CLD_KILLED && si.si_status == SIGSYS) {\n\t\t\tseccompViolation(nsjconf, &si);\n\t\t}\n\t\trv = reapProc(nsjconf, si.si_pid);\n\t}\n\n\ttime_t now = time(NULL);\n\tfor (const auto& p : nsjconf->pids) {\n\t\tif (nsjconf->tlimit == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tpid_t pid = p.first;\n\t\ttime_t diff = now - p.second.start;\n\t\tif ((uint64_t)diff >= nsjconf->tlimit) {\n\t\t\tLOG_I(\"pid=%d run time >= time limit (%ld >= %\" PRIu64 \") (%s). Killing it\",\n\t\t\t    pid, (long)diff, nsjconf->tlimit, p.second.remote_txt.c_str());\n\t\t\t/*\n\t\t\t * Probably a kernel bug - some processes cannot be killed with KILL if\n\t\t\t * they're namespaced, and in a stopped state\n\t\t\t */\n\t\t\tkill(pid, SIGCONT);\n\t\t\tLOG_D(\"Sent SIGCONT to pid=%d\", pid);\n\t\t\tkill(pid, SIGKILL);\n\t\t\tLOG_D(\"Sent SIGKILL to pid=%d\", pid);\n\t\t}\n\t}\n\treturn rv;\n}\n\nvoid killAndReapAll(nsjconf_t* nsjconf, int signal) {\n\twhile (!nsjconf->pids.empty()) {\n\t\tpid_t pid = nsjconf->pids.begin()->first;\n\t\tif (kill(pid, signal) == 0) {\n\t\t\treapProc(nsjconf, pid, true);\n\t\t} else {\n\t\t\tremoveProc(nsjconf, pid);\n\t\t}\n\t}\n}\n\nstatic bool initParent(nsjconf_t* nsjconf, pid_t pid, int pipefd) {\n\tif (!net::initNsFromParent(nsjconf, pid)) {\n\t\tLOG_E(\"Couldn't initialize net namespace for pid=%d\", pid);\n\t\treturn false;\n\t}\n\n\tif (nsjconf->use_cgroupv2) {\n\t\tif (!cgroup2::initNsFromParent(nsjconf, pid)) {\n\t\t\tLOG_E(\"Couldn't initialize cgroup 2 user namespace for pid=%d\", pid);\n\t\t\texit(0xff);\n\t\t}\n\t} else if (!cgroup::initNsFromParent(nsjconf, pid)) {\n\t\tLOG_E(\"Couldn't initialize cgroup user namespace for pid=%d\", pid);\n\t\texit(0xff);\n\t}\n\n\tif (!user::initNsFromParent(nsjconf, pid)) {\n\t\tLOG_E(\"Couldn't initialize user namespace for pid=%d\", pid);\n\t\treturn false;\n\t}\n\tif (!util::writeToFd(pipefd, &kSubprocDoneChar, sizeof(kSubprocDoneChar))) {\n\t\tLOG_E(\"Couldn't signal the new process via a socketpair\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\npid_t runChild(nsjconf_t* nsjconf, int netfd, int fd_in, int fd_out, int fd_err) {\n\tif (!net::limitConns(nsjconf, netfd)) {\n\t\treturn 0;\n\t}\n\tuint64_t flags = 0UL;\n\tflags |= (nsjconf->clone_newnet ? CLONE_NEWNET : 0);\n\tflags |= (nsjconf->clone_newuser ? CLONE_NEWUSER : 0);\n\tflags |= (nsjconf->clone_newns ? CLONE_NEWNS : 0);\n\tflags |= (nsjconf->clone_newpid ? CLONE_NEWPID : 0);\n\tflags |= (nsjconf->clone_newipc ? CLONE_NEWIPC : 0);\n\tflags |= (nsjconf->clone_newuts ? CLONE_NEWUTS : 0);\n\tflags |= (nsjconf->clone_newcgroup ? CLONE_NEWCGROUP : 0);\n\tflags |= (nsjconf->clone_newtime ? CLONE_NEWTIME : 0);\n\n\tif (nsjconf->mode == MODE_STANDALONE_EXECVE) {\n\t\tLOG_D(\"unshare(flags: %s)\", cloneFlagsToStr(flags).c_str());\n\t\tif (unshare(flags) == -1) {\n\t\t\tPLOG_F(\"unshare(%s)\", cloneFlagsToStr(flags).c_str());\n\t\t}\n\t\tnewProc(nsjconf, netfd, fd_in, fd_out, fd_err, -1);\n\t\tLOG_F(\"Launching new process failed\");\n\t}\n\n\tLOG_D(\"Creating new process with clone flags:%s and exit_signal:SIGCHLD\",\n\t    cloneFlagsToStr(flags).c_str());\n\n\tint sv[2];\n\tif (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, sv) == -1) {\n\t\tPLOG_E(\"socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC) failed\");\n\t\treturn -1;\n\t}\n\tint child_fd = sv[0];\n\tint parent_fd = sv[1];\n\n\tpid_t pid = cloneProc(flags, SIGCHLD);\n\tif (pid == 0) {\n\t\tclose(parent_fd);\n\t\tnewProc(nsjconf, netfd, fd_in, fd_out, fd_err, child_fd);\n\t\tutil::writeToFd(child_fd, &kSubprocErrorChar, sizeof(kSubprocErrorChar));\n\t\tLOG_F(\"Launching child process failed\");\n\t}\n\tclose(child_fd);\n\tif (pid == -1) {\n\t\tauto saved_errno = errno;\n\t\tPLOG_W(\"clone(flags=%s) failed\", cloneFlagsToStr(flags).c_str());\n\t\tclose(parent_fd);\n\t\terrno = saved_errno;\n\t\treturn pid;\n\t}\n\taddProc(nsjconf, pid, netfd);\n\n\tif (!initParent(nsjconf, pid, parent_fd)) {\n\t\tclose(parent_fd);\n\t\treturn -1;\n\t}\n\n\tchar rcvChar;\n\tif (util::readFromFd(parent_fd, &rcvChar, sizeof(rcvChar)) == sizeof(rcvChar) &&\n\t    rcvChar == kSubprocErrorChar) {\n\t\tLOG_W(\"Received error message from the child process before it has been executed\");\n\t\tclose(parent_fd);\n\t\treturn -1;\n\t}\n\n\tclose(parent_fd);\n\treturn pid;\n}\n\n/*\n * Will be used inside the child process only, so it's safe to have it in BSS.\n * Some CPU archs (e.g. aarch64) must have it aligned. Size: 128 KiB (/2)\n */\nstatic uint8_t cloneStack[128 * 1024] __attribute__((aligned(__BIGGEST_ALIGNMENT__)));\n/* Cannot be on the stack, as the child's stack pointer will change after clone() */\nstatic __thread jmp_buf env;\n\n[[noreturn]] static int cloneFunc([[maybe_unused]] void* arg) {\n\tlongjmp(env, 1);\n\tLOG_F(\"Execution past longjmp\");\n}\n\n/*\n * Avoid problems with caching of PID/TID in glibc - when using syscall(__NR_clone) glibc doesn't\n * update the internal PID/TID caches, what can lead to invalid values being returned by getpid()\n * or incorrect PID/TIDs used in raise()/abort() functions\n */\npid_t cloneProc(uint64_t flags, int exit_signal) {\n\texit_signal &= CSIGNAL;\n\n\tif (flags & CLONE_VM) {\n\t\tLOG_E(\"Cannot use clone(flags & CLONE_VM)\");\n\t\terrno = 0;\n\t\treturn -1;\n\t}\n\n\tif (flags & CLONE_NEWTIME) {\n\t\tLOG_W(\"CLONE_NEWTIME reuqested, but it's only supported with the unshare() mode \"\n\t\t      \"(-Me)\");\n\t}\n\n#if defined(__NR_clone3)\n\tstruct clone_args ca = {};\n\tca.exit_signal = (uint64_t)exit_signal;\n\n\tca.flags = flags | CLONE_CLEAR_SIGHAND;\n\tpid_t ret = util::syscall(__NR_clone3, (uintptr_t)&ca, sizeof(ca));\n\tif (ret != -1) {\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now try without CLONE_CLEAR_SIGHAND as it's supported since Linux 5.5, while clone3\n\t * appeared in Linux 5.3\n\t */\n\tca.flags = flags;\n\tret = util::syscall(__NR_clone3, (uintptr_t)&ca, sizeof(ca));\n\tif (ret != -1 || errno != ENOSYS) {\n\t\treturn ret;\n\t}\n#endif /* defined(__NR_clone3) */\n\n\tif (flags & CLONE_NEWTIME) {\n\t\tLOG_E(\"CLONE_NEWTIME was requested but clone3() is not supported\");\n\t\terrno = 0;\n\t\treturn -1;\n\t}\n\n\tif (setjmp(env) == 0) {\n\t\tLOG_D(\"Cloning process with flags:%s\", cloneFlagsToStr(flags).c_str());\n\t\t/*\n\t\t * Avoid the problem of the stack growing up/down under different CPU architectures,\n\t\t * by using middle of the static stack buffer (which is temporary, and used only\n\t\t * inside of the cloneFunc()\n\t\t */\n\t\tvoid* stack = &cloneStack[sizeof(cloneStack) / 2];\n\t\t/* Parent */\n\t\treturn clone(cloneFunc, stack, (int)flags | exit_signal, NULL, NULL, NULL);\n\t}\n\t/* Child */\n\treturn 0;\n}\n\nint systemExe(const std::vector<std::string>& args, char** env) {\n\tbool exec_failed = false;\n\n\tstd::vector<const char*> argv;\n\tfor (const auto& a : args) {\n\t\targv.push_back(a.c_str());\n\t}\n\targv.push_back(nullptr);\n\n\tint sv[2];\n\tif (pipe2(sv, O_CLOEXEC) == -1) {\n\t\tPLOG_W(\"pipe2(sv, O_CLOEXEC\");\n\t\treturn -1;\n\t}\n\n\tpid_t pid = fork();\n\tif (pid == -1) {\n\t\tPLOG_W(\"fork()\");\n\t\tclose(sv[0]);\n\t\tclose(sv[1]);\n\t\treturn -1;\n\t}\n\n\tif (pid == 0) {\n\t\tclose(sv[0]);\n\t\texecve(argv[0], (char* const*)argv.data(), (char* const*)env);\n\t\tPLOG_W(\"execve('%s')\", argv[0]);\n\t\tutil::writeToFd(sv[1], \"A\", 1);\n\t\texit(0);\n\t}\n\n\tclose(sv[1]);\n\tchar buf[1];\n\tif (util::readFromFd(sv[0], buf, sizeof(buf)) > 0) {\n\t\texec_failed = true;\n\t\tLOG_W(\"Couldn't execute '%s'\", argv[0]);\n\t}\n\tclose(sv[0]);\n\n\tfor (;;) {\n\t\tint status;\n\t\tint ret = wait4(pid, &status, __WALL, NULL);\n\t\tif (ret == -1 && errno == EINTR) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret == -1) {\n\t\t\tPLOG_W(\"wait4(pid=%d)\", pid);\n\t\t\treturn -1;\n\t\t}\n\t\tif (WIFEXITED(status)) {\n\t\t\tint exit_code = WEXITSTATUS(status);\n\t\t\tLOG_D(\"pid=%d exited with exit code: %d\", pid, exit_code);\n\t\t\tif (exec_failed) {\n\t\t\t\treturn -1;\n\t\t\t} else if (exit_code == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (WIFSIGNALED(status)) {\n\t\t\tint exit_signal = WTERMSIG(status);\n\t\t\tLOG_W(\"pid=%d killed by signal: %d (%s)\", pid, exit_signal,\n\t\t\t    util::sigName(exit_signal).c_str());\n\t\t\treturn 2;\n\t\t}\n\t\tLOG_W(\"Unknown exit status: %d\", status);\n\t}\n}\n\n}  // namespace subproc\n"
        },
        {
          "name": "subproc.h",
          "type": "blob",
          "size": 1.380859375,
          "content": "/*\n\n   nsjail - subprocess management\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_PROC_H\n#define NS_PROC_H\n\n#include <inttypes.h>\n#include <stdbool.h>\n#include <unistd.h>\n\n#include <string>\n#include <vector>\n\n#include \"nsjail.h\"\n\nnamespace subproc {\n\n/* 0 - network connection limit reached, -1 - error */\npid_t runChild(nsjconf_t* nsjconf, int listen_fd, int fd_in, int fd_out, int fd_err);\nint countProc(nsjconf_t* nsjconf);\nvoid displayProc(nsjconf_t* nsjconf);\nvoid killAndReapAll(nsjconf_t* nsjconf, int signal);\n/* Returns the exit code of the first failing subprocess, or 0 if none fail */\nint reapProc(nsjconf_t* nsjconf);\nint systemExe(const std::vector<std::string>& args, char** env);\npid_t cloneProc(uint64_t flags, int exit_signal);\n\n}  // namespace subproc\n\n#endif /* NS_PROC_H */\n"
        },
        {
          "name": "user.cc",
          "type": "blob",
          "size": 9.5380859375,
          "content": "/*\n\n   nsjail - CLONE_NEWUSER routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"user.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <limits.h>\n#include <linux/securebits.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"logs.h\"\n#include \"macros.h\"\n#include \"subproc.h\"\n#include \"util.h\"\n\n#define STR_(x) #x\n#define STR(x) STR_(x)\n\nconstexpr char kNewUidPath[] =\n#ifdef NEWUIDMAP_PATH\n    STR(NEWUIDMAP_PATH);\n#else\n    \"/usr/bin/newuidmap\";\n#endif\nconstexpr char kNewGidPath[] =\n#ifdef NEWGIDMAP_PATH\n    STR(NEWGIDMAP_PATH);\n#else\n    \"/usr/bin/newgidmap\";\n#endif\n\nnamespace user {\n\nstatic bool setResGid(gid_t gid) {\n\tLOG_D(\"setresgid(%d)\", gid);\n#if defined(__NR_setresgid32)\n\tif (util::syscall(__NR_setresgid32, (uintptr_t)gid, (uintptr_t)gid, (uintptr_t)gid) == -1) {\n\t\tPLOG_W(\"setresgid32(%d)\", (int)gid);\n\t\treturn false;\n\t}\n#else  /* defined(__NR_setresgid32) */\n\tif (util::syscall(__NR_setresgid, (uintptr_t)gid, (uintptr_t)gid, (uintptr_t)gid) == -1) {\n\t\tPLOG_W(\"setresgid(%d)\", gid);\n\t\treturn false;\n\t}\n#endif /* defined(__NR_setresuid32) */\n\treturn true;\n}\n\nstatic bool setResUid(uid_t uid) {\n\tLOG_D(\"setresuid(%d)\", uid);\n#if defined(__NR_setresuid32)\n\tif (util::syscall(__NR_setresuid32, (uintptr_t)uid, (uintptr_t)uid, (uintptr_t)uid) == -1) {\n\t\tPLOG_W(\"setresuid32(%d)\", (int)uid);\n\t\treturn false;\n\t}\n#else  /* defined(__NR_setresuid32) */\n\tif (util::syscall(__NR_setresuid, (uintptr_t)uid, (uintptr_t)uid, (uintptr_t)uid) == -1) {\n\t\tPLOG_W(\"setresuid(%d)\", uid);\n\t\treturn false;\n\t}\n#endif /* defined(__NR_setresuid32) */\n\treturn true;\n}\n\nstatic bool hasGidMapSelf(nsjconf_t* nsjconf) {\n\tfor (const auto& gid : nsjconf->gids) {\n\t\tif (!gid.is_newidmap) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool setGroupsDeny(nsjconf_t* nsjconf, pid_t pid) {\n\t/*\n\t * No need to write 'deny' to /proc/pid/setgroups if our euid==0, as writing to\n\t * uid_map/gid_map will succeed anyway\n\t */\n\tif (!nsjconf->clone_newuser || nsjconf->orig_euid == 0 || !hasGidMapSelf(nsjconf)) {\n\t\treturn true;\n\t}\n\n\tchar fname[PATH_MAX];\n\tsnprintf(fname, sizeof(fname), \"/proc/%d/setgroups\", pid);\n\tconst char* const denystr = \"deny\";\n\tif (!util::writeBufToFile(fname, denystr, strlen(denystr), O_WRONLY | O_CLOEXEC)) {\n\t\tLOG_E(\"util::writeBufToFile('%s', '%s') failed\", fname, denystr);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool uidMapSelf(nsjconf_t* nsjconf, pid_t pid) {\n\tstd::string map;\n\tfor (const auto& uid : nsjconf->uids) {\n\t\tif (uid.is_newidmap) {\n\t\t\tcontinue;\n\t\t}\n\t\tmap.append(std::to_string(uid.inside_id));\n\t\tmap.append(\" \");\n\t\tmap.append(std::to_string(uid.outside_id));\n\t\tmap.append(\" \");\n\t\tmap.append(std::to_string(uid.count));\n\t\tmap.append(\"\\n\");\n\t}\n\tif (map.empty()) {\n\t\treturn true;\n\t}\n\n\tchar fname[PATH_MAX];\n\tsnprintf(fname, sizeof(fname), \"/proc/%d/uid_map\", pid);\n\tLOG_D(\"Writing '%s' to '%s'\", map.c_str(), fname);\n\tif (!util::writeBufToFile(fname, map.data(), map.length(), O_WRONLY | O_CLOEXEC)) {\n\t\tLOG_E(\"util::writeBufToFile('%s', '%s') failed\", fname, map.c_str());\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool gidMapSelf(nsjconf_t* nsjconf, pid_t pid) {\n\tstd::string map;\n\tfor (const auto& gid : nsjconf->gids) {\n\t\tif (gid.is_newidmap) {\n\t\t\tcontinue;\n\t\t}\n\t\tmap.append(std::to_string(gid.inside_id));\n\t\tmap.append(\" \");\n\t\tmap.append(std::to_string(gid.outside_id));\n\t\tmap.append(\" \");\n\t\tmap.append(std::to_string(gid.count));\n\t\tmap.append(\"\\n\");\n\t}\n\tif (map.empty()) {\n\t\treturn true;\n\t}\n\n\tchar fname[PATH_MAX];\n\tsnprintf(fname, sizeof(fname), \"/proc/%d/gid_map\", pid);\n\tLOG_D(\"Writing '%s' to '%s'\", map.c_str(), fname);\n\tif (!util::writeBufToFile(fname, map.data(), map.length(), O_WRONLY | O_CLOEXEC)) {\n\t\tLOG_E(\"util::writeBufToFile('%s', '%s') failed\", fname, map.c_str());\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* Use newgidmap for writing the gid map */\nstatic bool gidMapExternal(nsjconf_t* nsjconf, pid_t pid) {\n\tbool use = false;\n\n\tstd::vector<std::string> argv = {kNewGidPath, std::to_string(pid)};\n\tfor (const auto& gid : nsjconf->gids) {\n\t\tif (!gid.is_newidmap) {\n\t\t\tcontinue;\n\t\t}\n\t\tuse = true;\n\n\t\targv.push_back(std::to_string(gid.inside_id));\n\t\targv.push_back(std::to_string(gid.outside_id));\n\t\targv.push_back(std::to_string(gid.count));\n\t}\n\tif (!use) {\n\t\treturn true;\n\t}\n\tif (subproc::systemExe(argv, environ) != 0) {\n\t\tLOG_E(\"'%s' failed\", kNewGidPath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* Use newuidmap for writing the uid map */\nstatic bool uidMapExternal(nsjconf_t* nsjconf, pid_t pid) {\n\tbool use = false;\n\n\tstd::vector<std::string> argv = {kNewUidPath, std::to_string(pid)};\n\tfor (const auto& uid : nsjconf->uids) {\n\t\tif (!uid.is_newidmap) {\n\t\t\tcontinue;\n\t\t}\n\t\tuse = true;\n\n\t\targv.push_back(std::to_string(uid.inside_id));\n\t\targv.push_back(std::to_string(uid.outside_id));\n\t\targv.push_back(std::to_string(uid.count));\n\t}\n\tif (!use) {\n\t\treturn true;\n\t}\n\tif (subproc::systemExe(argv, environ) != 0) {\n\t\tLOG_E(\"'%s' failed\", kNewUidPath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool uidGidMap(nsjconf_t* nsjconf, pid_t pid) {\n\tRETURN_ON_FAILURE(gidMapSelf(nsjconf, pid));\n\tRETURN_ON_FAILURE(gidMapExternal(nsjconf, pid));\n\tRETURN_ON_FAILURE(uidMapSelf(nsjconf, pid));\n\tRETURN_ON_FAILURE(uidMapExternal(nsjconf, pid));\n\n\treturn true;\n}\n\nbool initNsFromParent(nsjconf_t* nsjconf, pid_t pid) {\n\tif (!setGroupsDeny(nsjconf, pid)) {\n\t\treturn false;\n\t}\n\tif (!nsjconf->clone_newuser) {\n\t\treturn true;\n\t}\n\tif (!uidGidMap(nsjconf, pid)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool initNsFromChild(nsjconf_t* nsjconf) {\n\tif (!nsjconf->clone_newuser && nsjconf->orig_euid != 0) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Make sure all capabilities are retained after the subsequent setuid/setgid, as they will\n\t * be needed for privileged operations: mounts, uts change etc.\n\t */\n\tif (prctl(PR_SET_SECUREBITS, SECBIT_KEEP_CAPS | SECBIT_NO_SETUID_FIXUP, 0UL, 0UL, 0UL) ==\n\t    -1) {\n\t\tPLOG_E(\"prctl(PR_SET_SECUREBITS, SECBIT_KEEP_CAPS | SECBIT_NO_SETUID_FIXUP)\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * Best effort because of /proc/self/setgroups. We deny\n\t * setgroups(2) calls only if user namespaces are in use.\n\t */\n\tstd::vector<gid_t> groups;\n\tstd::string groupsString = \"[\";\n\tif (!nsjconf->clone_newuser && nsjconf->gids.size() > 1) {\n\t\tfor (auto it = nsjconf->gids.begin() + 1; it != nsjconf->gids.end(); it++) {\n\t\t\tgroups.push_back(it->inside_id);\n\t\t\tgroupsString += std::to_string(it->inside_id);\n\t\t\tif (it < nsjconf->gids.end() - 1) groupsString += \", \";\n\t\t}\n\t}\n\tgroupsString += \"]\";\n\n\tif (!setResGid(nsjconf->gids[0].inside_id)) {\n\t\tPLOG_E(\"setresgid(%lu)\", (unsigned long)nsjconf->gids[0].inside_id);\n\t\treturn false;\n\t}\n\n\tLOG_D(\"setgroups(%zu, %s)\", groups.size(), groupsString.c_str());\n\tif (setgroups(groups.size(), groups.data()) == -1) {\n\t\t/* Indicate error if specific groups were requested */\n\t\tif (groups.size() > 0) {\n\t\t\tPLOG_E(\"setgroups(%zu, %s) failed\", groups.size(), groupsString.c_str());\n\t\t\treturn false;\n\t\t}\n\t\tPLOG_D(\"setgroups(%zu, %s) failed\", groups.size(), groupsString.c_str());\n\t}\n\n\tif (!setResUid(nsjconf->uids[0].inside_id)) {\n\t\tPLOG_E(\"setresuid(%lu)\", (unsigned long)nsjconf->uids[0].inside_id);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Disable securebits again to avoid spawned programs\n\t * unexpectedly retaining capabilities after a UID/GID\n\t * change.\n\t */\n\tif (prctl(PR_SET_SECUREBITS, 0UL, 0UL, 0UL, 0UL) == -1) {\n\t\tPLOG_E(\"prctl(PR_SET_SECUREBITS, 0)\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic uid_t parseUid(const std::string& id) {\n\tif (id.empty()) {\n\t\treturn getuid();\n\t}\n\tstruct passwd* pw = getpwnam(id.c_str());\n\tif (pw != nullptr) {\n\t\treturn pw->pw_uid;\n\t}\n\tif (util::isANumber(id.c_str())) {\n\t\treturn (uid_t)strtoimax(id.c_str(), NULL, 0);\n\t}\n\treturn (uid_t)-1;\n}\n\nstatic gid_t parseGid(const std::string& id) {\n\tif (id.empty()) {\n\t\treturn getgid();\n\t}\n\tstruct group* gr = getgrnam(id.c_str());\n\tif (gr != nullptr) {\n\t\treturn gr->gr_gid;\n\t}\n\tif (util::isANumber(id.c_str())) {\n\t\treturn (gid_t)strtoimax(id.c_str(), NULL, 0);\n\t}\n\treturn (gid_t)-1;\n}\n\nbool parseId(nsjconf_t* nsjconf, const std::string& i_id, const std::string& o_id, size_t cnt,\n    bool is_gid, bool is_newidmap) {\n\tif (cnt < 1) {\n\t\tcnt = 1;\n\t}\n\n\tuid_t inside_id;\n\tuid_t outside_id;\n\n\tif (is_gid) {\n\t\tinside_id = parseGid(i_id);\n\t\tif (inside_id == (uid_t)-1) {\n\t\t\tLOG_W(\"Cannot parse '%s' as GID\", i_id.c_str());\n\t\t\treturn false;\n\t\t}\n\t\toutside_id = parseGid(o_id);\n\t\tif (outside_id == (uid_t)-1) {\n\t\t\tLOG_W(\"Cannot parse '%s' as GID\", o_id.c_str());\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tinside_id = parseUid(i_id);\n\t\tif (inside_id == (uid_t)-1) {\n\t\t\tLOG_W(\"Cannot parse '%s' as UID\", i_id.c_str());\n\t\t\treturn false;\n\t\t}\n\t\toutside_id = parseUid(o_id);\n\t\tif (outside_id == (uid_t)-1) {\n\t\t\tLOG_W(\"Cannot parse '%s' as UID\", o_id.c_str());\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tidmap_t id;\n\tid.inside_id = inside_id;\n\tid.outside_id = outside_id;\n\tid.count = cnt;\n\tid.is_newidmap = is_newidmap;\n\n\tif (is_gid) {\n\t\tnsjconf->gids.push_back(id);\n\t} else {\n\t\tnsjconf->uids.push_back(id);\n\t}\n\n\treturn true;\n}\n\n}  // namespace user\n"
        },
        {
          "name": "user.h",
          "type": "blob",
          "size": 1.0556640625,
          "content": "/*\n\n   nsjail - CLONE_NEWUSER routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_USER_H\n#define NS_USER_H\n\n#include <stdbool.h>\n\n#include <string>\n\n#include \"nsjail.h\"\n\nnamespace user {\n\nbool initNsFromParent(nsjconf_t* nsjconf, pid_t pid);\nbool initNsFromChild(nsjconf_t* nsjconf);\nbool parseId(nsjconf_t* nsjconf, const std::string& i_id, const std::string& o_id, size_t cnt,\n    bool is_gid, bool is_newidmap);\n\n}  // namespace user\n\n#endif /* NS_USER_H */\n"
        },
        {
          "name": "util.cc",
          "type": "blob",
          "size": 9.623046875,
          "content": "/*\n\n   nsjail - useful procedures\n   -----------------------------------------\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"util.h\"\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <fstream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#include \"logs.h\"\n#include \"macros.h\"\n\nnamespace util {\n\nssize_t readFromFd(int fd, void* buf, size_t len) {\n\tuint8_t* charbuf = (uint8_t*)buf;\n\n\tsize_t readSz = 0;\n\twhile (readSz < len) {\n\t\tssize_t sz = TEMP_FAILURE_RETRY(read(fd, &charbuf[readSz], len - readSz));\n\t\tif (sz <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\treadSz += sz;\n\t}\n\treturn readSz;\n}\n\nssize_t readFromFile(const char* fname, void* buf, size_t len) {\n\tint fd = TEMP_FAILURE_RETRY(open(fname, O_RDONLY | O_CLOEXEC));\n\tif (fd == -1) {\n\t\tLOG_E(\"open(%s, O_RDONLY|O_CLOEXEC)\", QC(fname));\n\t\treturn -1;\n\t}\n\tssize_t ret = readFromFd(fd, buf, len);\n\tclose(fd);\n\treturn ret;\n}\n\nbool writeToFd(int fd, const void* buf, size_t len) {\n\tconst uint8_t* charbuf = (const uint8_t*)buf;\n\n\tsize_t writtenSz = 0;\n\twhile (writtenSz < len) {\n\t\tssize_t sz = TEMP_FAILURE_RETRY(write(fd, &charbuf[writtenSz], len - writtenSz));\n\t\tif (sz < 0) {\n\t\t\treturn false;\n\t\t}\n\t\twrittenSz += sz;\n\t}\n\treturn true;\n}\n\nbool readFromFileToStr(const char* fname, std::string* str) {\n\tstd::fstream fs(fname, std::ios::in | std::ios::binary);\n\tif (!fs.is_open()) {\n\t\tPLOG_W(\"Couldn't open file %s\", QC(fname));\n\t\treturn false;\n\t}\n\n\tstr->clear();\n\n\twhile (fs) {\n\t\tchar buf[4096];\n\t\tfs.read(buf, sizeof(buf));\n\t\tstd::streamsize sz = fs.gcount();\n\t\tif (sz > 0) {\n\t\t\tstr->append(buf, sz);\n\t\t}\n\t\tif (fs.eof()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (fs.bad() || fs.fail()) {\n\t\t\tPLOG_W(\"Reading from %s failed\", QC(fname));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool writeBufToFile(\n    const char* filename, const void* buf, size_t len, int open_flags, bool log_errors) {\n\tint fd;\n\tTEMP_FAILURE_RETRY(fd = open(filename, open_flags, 0644));\n\tif (fd == -1) {\n\t\tif (log_errors) {\n\t\t\tPLOG_E(\"Couldn't open %s for writing\", QC(filename));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!writeToFd(fd, buf, len)) {\n\t\tif (log_errors) {\n\t\t\tPLOG_E(\"Couldn't write '%zu' bytes to file %s (fd='%d')\", len, QC(filename),\n\t\t\t    fd);\n\t\t}\n\t\tclose(fd);\n\t\tif (open_flags & O_CREAT) {\n\t\t\tunlink(filename);\n\t\t}\n\t\treturn false;\n\t}\n\n\tLOG_D(\"Written '%zu' bytes to %s\", len, QC(filename));\n\n\tclose(fd);\n\treturn true;\n}\n\nbool createDirRecursively(const char* dir) {\n\tif (dir[0] != '/') {\n\t\tLOG_W(\"The directory path must start with '/': '%s' provided\", dir);\n\t\treturn false;\n\t}\n\n\tint prev_dir_fd = TEMP_FAILURE_RETRY(open(\"/\", O_RDONLY | O_CLOEXEC | O_DIRECTORY));\n\tif (prev_dir_fd == -1) {\n\t\tPLOG_W(\"open('/', O_RDONLY | O_CLOEXEC)\");\n\t\treturn false;\n\t}\n\n\tchar path[PATH_MAX];\n\tsnprintf(path, sizeof(path), \"%s\", dir);\n\tchar* curr = path;\n\tfor (;;) {\n\t\twhile (*curr == '/') {\n\t\t\tcurr++;\n\t\t}\n\n\t\tchar* next = strchr(curr, '/');\n\t\tif (next == nullptr) {\n\t\t\tclose(prev_dir_fd);\n\t\t\treturn true;\n\t\t}\n\t\t*next = '\\0';\n\n\t\tif (mkdirat(prev_dir_fd, curr, 0755) == -1 && errno != EEXIST) {\n\t\t\tPLOG_W(\"mkdir(%s, 0755)\", QC(curr));\n\t\t\tclose(prev_dir_fd);\n\t\t\treturn false;\n\t\t}\n\n\t\tint dir_fd = TEMP_FAILURE_RETRY(openat(prev_dir_fd, curr, O_DIRECTORY | O_CLOEXEC));\n\t\tif (dir_fd == -1) {\n\t\t\tPLOG_W(\"openat('%d', %s, O_DIRECTORY | O_CLOEXEC)\", prev_dir_fd, QC(curr));\n\t\t\tclose(prev_dir_fd);\n\t\t\treturn false;\n\t\t}\n\t\tclose(prev_dir_fd);\n\t\tprev_dir_fd = dir_fd;\n\t\tcurr = next + 1;\n\t}\n}\n\nstd::string* StrAppend(std::string* str, const char* format, ...) {\n\tchar* strp;\n\n\tva_list args;\n\tva_start(args, format);\n\tint ret = vasprintf(&strp, format, args);\n\tva_end(args);\n\n\tif (ret == -1) {\n\t\tPLOG_E(\"Memory allocation failed during asprintf()\");\n\t\tstr->append(\" [ERROR: mem_allocation_failed] \");\n\t\treturn str;\n\t}\n\n\tstr->append(strp, ret);\n\tfree(strp);\n\treturn str;\n}\n\nstd::string StrPrintf(const char* format, ...) {\n\tchar* strp;\n\n\tva_list args;\n\tva_start(args, format);\n\tint ret = vasprintf(&strp, format, args);\n\tva_end(args);\n\n\tif (ret == -1) {\n\t\tPLOG_E(\"Memory allocation failed during asprintf()\");\n\t\treturn \"[ERROR: mem_allocation_failed]\";\n\t}\n\n\tstd::string str(strp, ret);\n\tfree(strp);\n\treturn str;\n}\n\nconst std::string StrQuote(const std::string& str) {\n\tstd::ostringstream ss;\n\tss << std::quoted(str, '\\'');\n\treturn ss.str();\n}\n\nbool isANumber(const char* s) {\n\tfor (size_t i = 0; s[i]; s++) {\n\t\tif (!isdigit(s[i]) && s[i] != 'x') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool StrEq(const std::string_view& s1, const std::string_view& s2) {\n\treturn (s1 == s2);\n}\n\nstatic __thread pthread_once_t rndThreadOnce = PTHREAD_ONCE_INIT;\nstatic __thread uint64_t rndX;\n\n/* MMIX LCG PRNG */\nstatic const uint64_t a = 6364136223846793005ULL;\nstatic const uint64_t c = 1442695040888963407ULL;\n\nstatic void rndInitThread(void) {\n#if defined(__NR_getrandom)\n\tif (TEMP_FAILURE_RETRY(util::syscall(__NR_getrandom, (uintptr_t)&rndX, sizeof(rndX), 0)) ==\n\t    sizeof(rndX)) {\n\t\treturn;\n\t}\n#endif /* defined(__NR_getrandom) */\n\tint fd = TEMP_FAILURE_RETRY(open(\"/dev/urandom\", O_RDONLY | O_CLOEXEC));\n\tif (fd == -1) {\n\t\tPLOG_D(\"Couldn't open /dev/urandom for reading. Using gettimeofday \"\n\t\t       \"fall-back\");\n\t\tstruct timeval tv;\n\t\tgettimeofday(&tv, NULL);\n\t\trndX = tv.tv_usec + ((uint64_t)tv.tv_sec << 32);\n\t\treturn;\n\t}\n\tif (readFromFd(fd, (uint8_t*)&rndX, sizeof(rndX)) != sizeof(rndX)) {\n\t\tPLOG_F(\"Couldn't read '%zu' bytes from /dev/urandom\", sizeof(rndX));\n\t\tclose(fd);\n\t}\n\tclose(fd);\n}\n\nuint64_t rnd64(void) {\n\tpthread_once(&rndThreadOnce, rndInitThread);\n\trndX = a * rndX + c;\n\treturn rndX;\n}\n\nconst std::string sigName(int signo) {\n\tstd::string res;\n\n\tstruct {\n\t\tconst int signo;\n\t\tconst char* const name;\n\t} static const sigNames[] = {\n\t    NS_VALSTR_STRUCT(SIGHUP),\n\t    NS_VALSTR_STRUCT(SIGINT),\n\t    NS_VALSTR_STRUCT(SIGQUIT),\n\t    NS_VALSTR_STRUCT(SIGILL),\n\t    NS_VALSTR_STRUCT(SIGTRAP),\n\t    NS_VALSTR_STRUCT(SIGABRT),\n\t    NS_VALSTR_STRUCT(SIGIOT),\n\t    NS_VALSTR_STRUCT(SIGBUS),\n\t    NS_VALSTR_STRUCT(SIGFPE),\n\t    NS_VALSTR_STRUCT(SIGKILL),\n\t    NS_VALSTR_STRUCT(SIGUSR1),\n\t    NS_VALSTR_STRUCT(SIGSEGV),\n\t    NS_VALSTR_STRUCT(SIGUSR2),\n\t    NS_VALSTR_STRUCT(SIGPIPE),\n\t    NS_VALSTR_STRUCT(SIGALRM),\n\t    NS_VALSTR_STRUCT(SIGTERM),\n\t    NS_VALSTR_STRUCT(SIGSTKFLT),\n\t    NS_VALSTR_STRUCT(SIGCHLD),\n\t    NS_VALSTR_STRUCT(SIGCONT),\n\t    NS_VALSTR_STRUCT(SIGSTOP),\n\t    NS_VALSTR_STRUCT(SIGTSTP),\n\t    NS_VALSTR_STRUCT(SIGTTIN),\n\t    NS_VALSTR_STRUCT(SIGTTOU),\n\t    NS_VALSTR_STRUCT(SIGURG),\n\t    NS_VALSTR_STRUCT(SIGXCPU),\n\t    NS_VALSTR_STRUCT(SIGXFSZ),\n\t    NS_VALSTR_STRUCT(SIGVTALRM),\n\t    NS_VALSTR_STRUCT(SIGPROF),\n\t    NS_VALSTR_STRUCT(SIGWINCH),\n\t    NS_VALSTR_STRUCT(SIGPOLL),\n\t    NS_VALSTR_STRUCT(SIGPWR),\n\t    NS_VALSTR_STRUCT(SIGSYS),\n\t};\n\n\tfor (const auto& i : sigNames) {\n\t\tif (signo == i.signo) {\n\t\t\tres.append(i.name);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tif (signo >= SIGRTMIN) {\n\t\tres.append(\"SIG\");\n\t\tres.append(std::to_string(signo));\n\t\tres.append(\"-RTMIN+\");\n\t\tres.append(std::to_string(signo - SIGRTMIN));\n\t\treturn res;\n\t}\n\n\tres.append(\"SIGUNKNOWN(\");\n\tres.append(std::to_string(signo));\n\tres.append(\")\");\n\treturn res;\n}\n\nconst std::string rLimName(int res) {\n\tstd::string ret;\n\n\tstruct {\n\t\tconst int res;\n\t\tconst char* const name;\n\t} static const rLimNames[] = {\n\t    NS_VALSTR_STRUCT(RLIMIT_CPU),\n\t    NS_VALSTR_STRUCT(RLIMIT_FSIZE),\n\t    NS_VALSTR_STRUCT(RLIMIT_DATA),\n\t    NS_VALSTR_STRUCT(RLIMIT_STACK),\n\t    NS_VALSTR_STRUCT(RLIMIT_CORE),\n\t    NS_VALSTR_STRUCT(RLIMIT_RSS),\n\t    NS_VALSTR_STRUCT(RLIMIT_NOFILE),\n\t    NS_VALSTR_STRUCT(RLIMIT_AS),\n\t    NS_VALSTR_STRUCT(RLIMIT_NPROC),\n\t    NS_VALSTR_STRUCT(RLIMIT_MEMLOCK),\n\t    NS_VALSTR_STRUCT(RLIMIT_LOCKS),\n\t    NS_VALSTR_STRUCT(RLIMIT_SIGPENDING),\n\t    NS_VALSTR_STRUCT(RLIMIT_MSGQUEUE),\n\t    NS_VALSTR_STRUCT(RLIMIT_NICE),\n\t    NS_VALSTR_STRUCT(RLIMIT_RTPRIO),\n\t    NS_VALSTR_STRUCT(RLIMIT_RTTIME),\n\t};\n\n\tfor (const auto& i : rLimNames) {\n\t\tif (res == i.res) {\n\t\t\tret.append(i.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret.append(\"RLIMITUNKNOWN(\");\n\tret.append(std::to_string(res));\n\tret.append(\")\");\n\treturn ret;\n}\n\nconst std::string timeToStr(time_t t) {\n\tchar timestr[128];\n\tstruct tm utctime;\n\tlocaltime_r(&t, &utctime);\n\tif (strftime(timestr, sizeof(timestr) - 1, \"%FT%T%z\", &utctime) == 0) {\n\t\treturn \"[Time conv error]\";\n\t}\n\treturn timestr;\n}\n\nstd::vector<std::string> strSplit(const std::string str, char delim) {\n\tstd::vector<std::string> vec;\n\tstd::istringstream stream(str);\n\tfor (std::string word; std::getline(stream, word, delim);) {\n\t\tvec.push_back(word);\n\t}\n\treturn vec;\n}\n\nlong syscall(long sysno, uintptr_t a0, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4,\n    uintptr_t a5) {\n\treturn ::syscall(sysno, a0, a1, a2, a3, a4, a5);\n}\n\nlong setrlimit(int res, const struct rlimit64& newlim) {\n\treturn util::syscall(__NR_prlimit64, 0, res, (uintptr_t)&newlim, (uintptr_t)nullptr);\n}\n\nlong getrlimit(int res, struct rlimit64* curlim) {\n\t*curlim = {};\n\treturn util::syscall(__NR_prlimit64, 0, res, (uintptr_t)nullptr, (uintptr_t)curlim);\n}\n\n}  // namespace util\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 2.744140625,
          "content": "/*\n\n   nsjail - useful procedures\n   -----------------------------------------\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_UTIL_H\n#define NS_UTIL_H\n\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/resource.h>\n\n#include <string>\n#include <vector>\n\n#include \"nsjail.h\"\n\n#define RETURN_ON_FAILURE(expr)                                                                    \\\n\tdo {                                                                                       \\\n\t\tif (!(expr)) {                                                                     \\\n\t\t\treturn false;                                                              \\\n\t\t}                                                                                  \\\n\t} while (0)\n\n#define QC(x) (util::StrQuote(x).c_str())\n\n#if !defined(RLIM64_INFINITY)\n#define RLIM64_INFINITY (~0ULL)\nstruct rlimit64 {\n\tuint64_t rlim_cur;\n\tuint64_t rlim_max;\n};\n#endif /* !defined(RLIM64_INFINITY) */\n\nnamespace util {\n\nssize_t readFromFd(int fd, void* buf, size_t len);\nssize_t readFromFile(const char* fname, void* buf, size_t len);\nbool readFromFileToStr(const char* fname, std::string* str);\nbool writeToFd(int fd, const void* buf, size_t len);\nbool writeBufToFile(\n    const char* filename, const void* buf, size_t len, int open_flags, bool log_errors = true);\nbool createDirRecursively(const char* dir);\nstd::string* StrAppend(std::string* str, const char* format, ...)\n    __attribute__((format(printf, 2, 3)));\nstd::string StrPrintf(const char* format, ...) __attribute__((format(printf, 1, 2)));\nconst std::string StrQuote(const std::string& str);\nbool StrEq(const std::string_view& s1, const std::string_view& s2);\nbool isANumber(const char* s);\nuint64_t rnd64(void);\nconst std::string sigName(int signo);\nconst std::string rLimName(int res);\nconst std::string timeToStr(time_t t);\nstd::vector<std::string> strSplit(const std::string str, char delim);\nlong syscall(long sysno, uintptr_t a0 = 0, uintptr_t a1 = 0, uintptr_t a2 = 0, uintptr_t a3 = 0,\n    uintptr_t a4 = 0, uintptr_t a5 = 0);\nlong setrlimit(int res, const struct rlimit64& newlim);\nlong getrlimit(int res, struct rlimit64* curlim);\n\n}  // namespace util\n\n#endif /* NS_UTIL_H */\n"
        },
        {
          "name": "uts.cc",
          "type": "blob",
          "size": 1.099609375,
          "content": "/*\n\n   nsjail - CLONE_NEWUTS routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"uts.h\"\n\n#include <string.h>\n#include <unistd.h>\n\n#include \"logs.h\"\n\nnamespace uts {\n\nbool initNs(nsjconf_t* nsjconf) {\n\tif (!nsjconf->clone_newuts) {\n\t\treturn true;\n\t}\n\n\tLOG_D(\"Setting hostname to '%s'\", nsjconf->hostname.c_str());\n\tif (sethostname(nsjconf->hostname.data(), nsjconf->hostname.length()) == -1) {\n\t\tPLOG_E(\"sethostname('%s')\", nsjconf->hostname.c_str());\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n}  // namespace uts\n"
        },
        {
          "name": "uts.h",
          "type": "blob",
          "size": 0.841796875,
          "content": "/*\n\n   nsjail - CLONE_NEWUTS routines\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#ifndef NS_UTS_H\n#define NS_UTS_H\n\n#include <stdbool.h>\n\n#include \"nsjail.h\"\n\nnamespace uts {\n\nbool initNs(nsjconf_t* nsjconf);\n\n}  // namespace uts\n\n#endif /* NS_UTS_H */\n"
        }
      ]
    }
  ]
}