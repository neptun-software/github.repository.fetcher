{
  "metadata": {
    "timestamp": 1736565697682,
    "page": 598,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rbock/sqlpp11",
      "stars": 2496,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 0.5537109375,
          "content": "os:\n  - Visual Studio 2015\n  - Visual Studio 2017\n\nplatform:\n  - x64\n\nconfiguration:\n  #- Debug\n  - Release\n\nmatrix:\n  fast_finish: true\n\nbuild_script:\n  - CD\n  - cd ..\n  - CD\n  - git clone https://github.com/HowardHinnant/date\n  - cd date\n  - git checkout tags/v2.4\n  - cd ..\n  - cd sqlpp11\n  - CD\n  - echo %configuration%\n  - mkdir build\n  - cd build\n  - cmake --version\n  - cmake .. -DCMAKE_CXX_FLAGS=\"/EHsc /wd4503\" -DCMAKE_PREFIX_PATH=\"C:\\projects\\date\"\n  - cmake --build . --config %configuration%\n  - ctest . --build-config %configuration% --output-on-failure\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 1.68359375,
          "content": "Language:        Cpp\nAccessModifierOffset: -2\nConstructorInitializerIndentWidth: 4\nAlignEscapedNewlinesLeft: true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: None\nAlwaysBreakTemplateDeclarations: true\nAlwaysBreakBeforeMultilineStrings: false\nBreakBeforeBinaryOperators: false\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBinPackParameters: false\nColumnLimit:     120\nConstructorInitializerAllOnOneLineOrOnePerLine: true\nDerivePointerAlignment: false\nExperimentalAutoDetectBinPacking: false\nIndentCaseLabels: true\nIndentWrappedFunctionNames: false\nIndentFunctionDeclarationAfterType: false\nMaxEmptyLinesToKeep: 1\nKeepEmptyLinesAtTheStartOfBlocks: false\nNamespaceIndentation: All\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: false\nPenaltyBreakBeforeFirstCallParameter: 1\nPenaltyBreakComment: 300\nPenaltyBreakString: 1000\nPenaltyBreakFirstLessLess: 120\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 200\nPointerAlignment: Left\nSpacesBeforeTrailingComments: 2\nCpp11BracedListStyle: true\nStandard:        Cpp11\nIndentWidth:     2\nTabWidth:        2\nUseTab:          Never\nBreakBeforeBraces: Allman\nSpacesInParentheses: false\nSpacesInAngles:  false\nSpaceInEmptyParentheses: false\nSpacesInCStyleCastParentheses: false\nSpacesInContainerLiterals: true\nSpaceBeforeAssignmentOperators: true\nContinuationIndentWidth: 4\nCommentPragmas:  '^ IWYU pragma:'\nForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]\nSpaceBeforeParens: ControlStatements\nDisableFormat:   false\nSortIncludes: false\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.025390625,
          "content": ".idea\nCMakeLists.txt.user\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.822265625,
          "content": "language: cpp\n\nos:\n  - linux\n\ndist: focal\nsudo: required\n\nservices:\n  - mysql\n\naddons:\n  apt:\n    packages:\n    - sqlite3\n    - libboost-dev\n    - python-pyparsing\n\ncompiler:\n  - clang\n  - gcc\n\nenv:\n  - CONFIG=Release\n  - CONFIG=Release TESTS_CXX_STD=17\n  #- CONFIG=Debug\n\nnotifications:\n email:\n   on_success: change\n   on_failure: always\n\nbefore_script:\n   - mysql --version\n   - (while !  mysqladmin -u root status ; do sleep 1; done) # wait for mysql to start\n   - mysqladmin -u root create sqlpp_mysql\n   - if [[ \"$CXX\" = \"g++\" && \"$CONFIG\" = \"Debug\" && \"$TRAVIS_OS_NAME\" = \"linux\" ]]; then export CXXFLAGS=\"--coverage\"; fi\n   - cmake -B build -DCMAKE_BUILD_TYPE=$CONFIG -DBUILD_MYSQL_CONNECTOR=ON -DBUILD_SQLITE3_CONNECTOR=ON\n\nscript:\n   - cmake --build . --config $CONFIG\n   - ctest --output-on-failure\n\nafter_script:\n  - ../coveralls\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 5.2666015625,
          "content": "# Copyright (c) 2013-2021, Roland Bock\n# Copyright (c) 2016 Christian DÃ¡vid\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification,\n# are permitted provided that the following conditions are met:\n#\n#   Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n#   Redistributions in binary form must reproduce the above copyright notice, this\n#   list of conditions and the following disclaimer in the documentation and/or\n#   other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n### Preamble\ncmake_minimum_required(VERSION 3.14)\nproject(sqlpp11 VERSION 0.1 LANGUAGES CXX)\n\n### Project Wide Setup\nlist(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)\nlist(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake/modules)\n\ninclude(GNUInstallDirs)\ninclude(CTest)\n\noption(BUILD_MYSQL_CONNECTOR \"Build MySQL Connector\" OFF)\noption(BUILD_MARIADB_CONNECTOR \"Build MariaDB Connector\" OFF)\noption(BUILD_POSTGRESQL_CONNECTOR \"Build PostgreSQL Connector\" OFF)\noption(BUILD_SQLITE3_CONNECTOR \"Build SQLite3 Connector\" OFF)\noption(BUILD_SQLCIPHER_CONNECTOR \"Build SQLite3 Connector with SQLCipher\" OFF)\n\noption(DEPENDENCY_CHECK \"Check for dependencies of connector and the library\" ON)\n\noption(USE_SYSTEM_DATE \"\\\n    Use find_package to find installed HowardHinnant's \\\n    date library instead of fetching it from github\" OFF\n)\n\nset(SQLPP11_INSTALL_CMAKEDIR ${CMAKE_INSTALL_LIBDIR}/cmake/Sqlpp11 CACHE STRING \"Path to sqlpp11 cmake files\")\n\n### Dependencies\nif(DEPENDENCY_CHECK AND BUILD_MYSQL_CONNECTOR)\n    find_package(MySQL REQUIRED)\nendif()\n\nif(DEPENDENCY_CHECK AND BUILD_MARIADB_CONNECTOR)\n    find_package(MariaDB REQUIRED)\nendif()\n\nif(DEPENDENCY_CHECK AND BUILD_POSTGRESQL_CONNECTOR)\n    find_package(PostgreSQL REQUIRED)\nendif()\n\nif(DEPENDENCY_CHECK AND BUILD_SQLITE3_CONNECTOR)\n    find_package(SQLite3 REQUIRED)\nendif()\n\nif(DEPENDENCY_CHECK AND BUILD_SQLCIPHER_CONNECTOR)\n    find_package(SQLCipher REQUIRED)\nendif()\n\nif(DEPENDENCY_CHECK AND USE_SYSTEM_DATE)\n    find_package(date REQUIRED)\nendif()\n\nadd_subdirectory(dependencies)\n\n### Core targets\ninclude(Sqlpp11TargetHelper)\n\nadd_library(sqlpp11 INTERFACE)\nadd_library(sqlpp11::sqlpp11 ALIAS sqlpp11)\n\ntarget_link_libraries(sqlpp11 INTERFACE date::date)\ntarget_include_directories(sqlpp11 INTERFACE\n    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>\n)\ntarget_compile_features(sqlpp11 INTERFACE cxx_std_11)\n\n\nif(BUILD_SQLITE3_CONNECTOR)\n    add_component(NAME sqlite3 DEPENDENCIES SQLite::SQLite3)\nendif()\n\nif(BUILD_SQLCIPHER_CONNECTOR)\n    add_component(NAME sqlcipher DEPENDENCIES SQLCipher::SQLCipher)\n    target_compile_definitions(sqlpp11_sqlcipher INTERFACE SQLPP_USE_SQLCIPHER)\nendif()\n\nif(BUILD_MYSQL_CONNECTOR)\n    add_component(NAME mysql DEPENDENCIES MySQL::MySQL)\nendif()\n\nif(BUILD_MARIADB_CONNECTOR)\n    add_component(NAME mariadb DEPENDENCIES MariaDB::MariaDB)\nendif()\n\nif(BUILD_POSTGRESQL_CONNECTOR)\n    add_component(NAME postgresql DEPENDENCIES PostgreSQL::PostgreSQL)\nendif()\n\n### Packaging\ninstall(PROGRAMS ${PROJECT_SOURCE_DIR}/scripts/ddl2cpp\n    RENAME sqlpp11-ddl2cpp\n    DESTINATION ${CMAKE_INSTALL_BINDIR}\n)\n\nwrite_basic_package_version_file(Sqlpp11ConfigVersion.cmake\n    COMPATIBILITY SameMajorVersion\n    ARCH_INDEPENDENT\n)\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/Sqlpp11ConfigVersion.cmake\n    DESTINATION ${SQLPP11_INSTALL_CMAKEDIR}\n)\n\ninstall_component(NAME Sqlpp11 TARGETS sqlpp11 DIRECTORY)\n\nif(BUILD_SQLITE3_CONNECTOR)\n    install_component(NAME Sqlpp11SQLite3 TARGETS sqlpp11_sqlite3 DIRECTORY sqlite3)\nendif()\n\nif(BUILD_SQLCIPHER_CONNECTOR)\n    install_component(NAME Sqlpp11SQLCipher TARGETS sqlpp11_sqlcipher DIRECTORY sqlite3)\n\n    install(FILES ${PROJECT_SOURCE_DIR}/cmake/modules/FindSQLCipher.cmake\n        DESTINATION ${SQLPP11_INSTALL_CMAKEDIR}\n    )\nendif()\n\nif(BUILD_MYSQL_CONNECTOR)\n    install_component(NAME Sqlpp11MySQL TARGETS sqlpp11_mysql DIRECTORY mysql)\n\n    install(FILES ${PROJECT_SOURCE_DIR}/cmake/modules/FindMySQL.cmake\n        DESTINATION ${SQLPP11_INSTALL_CMAKEDIR}\n    )\nendif()\n\nif(BUILD_MARIADB_CONNECTOR)\n    install_component(NAME Sqlpp11MariaDB TARGETS sqlpp11_mariadb DIRECTORY mysql)\n\n    install(FILES ${PROJECT_SOURCE_DIR}/cmake/modules/FindMariaDB.cmake\n        DESTINATION ${SQLPP11_INSTALL_CMAKEDIR}\n    )\nendif()\n\nif(BUILD_POSTGRESQL_CONNECTOR)\n    install_component(NAME Sqlpp11PostgreSQL TARGETS sqlpp11_postgresql DIRECTORY postgresql)\nendif()\n\n\n### Tests\nif(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME AND BUILD_TESTING)\n    add_subdirectory(tests)\nendif()\n"
        },
        {
          "name": "CREDITS",
          "type": "blob",
          "size": 0.6669921875,
          "content": "Credits:\n========\nThis library evolved through several stages and would probably not exist without input from other people:\n\n  * Michael Gmelin: Interface and requirements discussions\n  * Paul KÃ¶rbitz:   Feedback and extensions\n  * Peter Knoblach: Initial ideas\n  * Ulrich KÃ¼ttler: Feedback and extensions\n  * Daniel Pfeifer: Buildsystem, Travis, Coveralls\n\n\n  * Metafeed GmbH: Production code using a forerunner version\n  * PPRO Financial Ltd: Production code using sqlpp11 and a forerunner version\n  * The boost community: Invaluable suggestions and critiques\n\n  * Meeting C++ Munich: Hosted the first talk about sqlpp11\n\n\nIf you miss your name of this list, please let me know.\n"
        },
        {
          "name": "ChangeLog.md",
          "type": "blob",
          "size": 3.8779296875,
          "content": "Important changes in sqlpp11\n============================\n\nBreaking changes in 0.36:\n-------------------------\n__Abstract__:\n\nOne of the main motivations of sqlpp11 is to prevent SQL programming mistakes at compile time. The following changes prevent reported mishaps.\n  * `from(a,b)` not allowed anymore, please use explicit joins\n  * `where(true)` not allowed anymore, please use `.unconditionally()` or sqlpp::value(true)\n  * `some_sql_expression and true` not allowed anymore, please use `tab.col == sqlpp::value(true)` if you really want to express this.\n  * `having(expression)` requires `expression` to be made of aggregates, e.g. columns named in `group_by()` or aggregate functions like `count()` or constant values.\n  * `where()` and `having` accept only one parameter\n\n__Explicit joins required__:\n\nUp until sqlpp11-0.35 you could write something like\n\n```\nauto result = db(select(all_of(a), all_of(b))\n                 .from(a,b)\n                 .where(someCondition));\n```\n\nUsing this syntax in `from()`, it was expected to have the join condition implicitly in the `where()` call.\nBut there is no reliable way to tell whether or not that condition is there. Or, if there definitely is none, whether\nit was omitted on purpose or by accident.\nIn one case, an accidentally omitted join condition in the `where()` brought a production system to a screeching halt.\n\nIn order to prevent this in the future, sqlpp11 now requires you to join table explicitly, including an explicit join condition, e.g.\n\n```\nauto result = db(select(all_of(a), all_of(b))\n                 .from(a.join(b).on(a.b == b.id))\n                 .where(someCondition));\n```\n\nMost joins, (`join`/`inner_join`, `left_outer_join`, `right_outer_join` and `outer_join`) require a join condition to given via `on()`.\nThe join condition has to be some sqlpp11 boolean expression.\n\nIn those rare cases, when you really need a cross join, you can also use `cross_join()` which has no join condition, of course.\n\n```\nauto result = db(select(all_of(a), all_of(b))\n                 .from(a.cross_join(b))\n                 .where(someCondition));\n```\n\n__Use `.unconditionally()`__\n\nIf you want to select/update/remove all rows, earlier versions of sqlpp11 required the use of `where(true)`. Since version 0.36, use `unconditionally()`, for instance:\n```\nauto result = db(select(all_of(t)).from(t).unconditionally());\n```\n\n__Use `sqlpp::value()` to wrap bool values in boolean expressions__\n\nLets say you had\n\n```\nstruct X\n{\n    int a;\n    int b;\n};\nauto x = X{};\n```\n\nThen earlier versions of sqlpp11 would compile the following expression:\n\n```\nselect(all_of(t)).from(t).where(x.a == x.a or t.b == t.b);\n```\n\nWhat you probably meant was:\n\n```\nselect(all_of(t)).from(t).where(t.a == x.a and t.b == x.b);\n```\n\nIn order to prevent this kind of mistake, boolean operators in sql expressions require sqlpp boolean expressions as operators.\nThe library also requires the types of the left/right hand side operands of a comparison to be different, so that `t.a < t.a` does not compile any more.\n\nIn the rare case you really have a bool value that you want to use a boolean sql expression, you have to wrap it in sqlpp::value(x), e.g.\n\n```\nselect(all_of(t)).from(t).where(sqlpp::value(x.a == 17) and t.b == x.b);\n```\n\n__`having()` requires aggregate expressions__\n\nIn older versions, the following code was allowed:\n\n```\nselect(all_of(t)).from(t).where(t.a > 7).having(t.b != \"\");\n```\n\nAs of sqlpp11-0.36, the having argument must be made of aggregate columns or functions, e.g.\n\n```\nselect(all_of(t)).from(t).unconditionally().group_by(t.b).having(t.b != \"\", avg(t.c) < 42);\n```\n\n__`where()` and `having` accept only one expression__\n\nIn older versions, `where()` and `having()` would accept more than one argument and combine those arguments with `and`.\nI am not sure this was ever used. So it just made life harder for the compiler.\n\nAs of version 0.36, `where()` and `having()` accept only one parameter.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2734375,
          "content": "Copyright (c) 2013-2016, Roland Bock\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this\n   list of conditions and the following disclaimer in the documentation and/or\n   other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.2041015625,
          "content": "sqlpp11\n=======\nA type safe embedded domain specific language for SQL queries and results in C++.\n\n```diff\n!If you are a tenured user of sqlpp11, please note that\n!  - with 0.61 the connector libraries for mysql/sqlite/postgresql got merged into the main repo.\n!  - master has been renamed to main and is now the default branch\n```\n\nDocumentation is found in [docs](docs/Home.md).\n\nSo what is this about?\n----------------------\nSQL and C++ are both strongly typed languages. Still, most C/C++ interfaces to SQL are based on constructing queries as strings and on interpreting arrays or maps of strings as results.\n\nsqlpp11 is a templated library representing an embedded domain specific language (EDSL) that allows you to\n\n  * define types representing tables and columns,\n  * construct type safe queries checked at compile time for syntax errors, type errors, name errors and even some semantic errors,\n  * interpret results by iterating over query-specific structs with appropriately named and typed members.\n\nThis results in several benefits, e.g.\n\n  * the library user operates comfortably on structs and functions,\n  * the compiler reports many kinds of errors long before the code enters unit testing or production,\n  * the library hides the gory details of string construction for queries and interpreting results returned by select calls.\n\nThe library supports both static and dynamic queries. The former offers greater benefit in terms of type and consistency checking. The latter makes it easier to construct queries in flight.\n\nsqlpp11âs core is vendor-neutral.\nSpecific traits of databases (e.g. unsupported or non-standard features) are handled by connector libraries.\nConnector libraries can inform the developer of missing features at compile time.\nThey also interpret expressions specifically where needed.\nFor example, the connector could use the operator|| or the concat method for string concatenation without the developer being required to change the statement.\n\nConnectors for MariaDB, MySQL, PostgreSQL, sqlite3, sqlcipher are included in this repository.\n\nThe library is already used in production but it is certainly not complete yet. Feature requests, bug reports, contributions to code or documentation are most welcome.\n\nExamples:\n---------\nFor the examples, lets assume you have a table class representing something like\n\n```SQL\nCREATE TABLE foo (\n    id bigint,\n    name varchar(50),\n    hasFun bool\n);\n```\n\nAnd we assume to have a database connection object:\n\n```C++\nTabFoo foo;\nDb db(/* some arguments*/);\n\n// selecting zero or more results, iterating over the results\nfor (const auto& row : db(select(foo.name, foo.hasFun).from(foo).where(foo.id > 17 and foo.name.like(\"%bar%\"))))\n{\n    if (row.name.is_null())\n        std::cerr << \"name is null, will convert to empty string\" << std::endl;\n    std::string name = row.name;   // string-like fields are implicitly convertible to string\n    bool hasFun = row.hasFun;          // bool fields are implicitly convertible to bool\n}\n\n// selecting ALL columns of a table\nfor (const auto& row : db(select(all_of(foo)).from(foo).where(foo.hasFun or foo.name == \"joker\")))\n{\n    int64_t id = row.id; // numeric fields are implicitly convertible to numeric c++ types\n}\n\n// selecting zero or one row, showing off with an alias:\nSQLPP_ALIAS_PROVIDER(cheese);\nif (const auto& row = db(select(foo.name.as(cheese)).from(foo).where(foo.id == 17)))\n{\n    std::cerr << \"found: \" << row.cheese << std::endl;\n}\n\n// selecting a single row with a single result:\nreturn db(select(count(foo.id)).from(foo).unconditionally()).front().count;\n\nOf course there are joins and subqueries, more functions, order_by, group_by etc.\nThese will be documented soon.\n\n// A sample insert\ndb(insert_into(foo).set(foo.id = 17, foo.name = \"bar\", foo.hasFun = true));\n\n// A sample update\ndb(update(foo).set(foo.hasFun = not foo.hasFun).where(foo.name != \"nobody\"));\n\n// A sample delete\ndb(remove_from(foo).where(not foo.hasFun));\n```\n\nLicense:\n-------------\nsqlpp11 is distributed under the [BSD 2-Clause License](https://github.com/rbock/sqlpp11/blob/master/LICENSE).\n\nStatus:\n-------\nBranch / Compiler | clang,  gcc |  MSVC  | Test Coverage\n------------------|-------------|--------|---------------\nmaster | [![Build Status](https://travis-ci.com/rbock/sqlpp11.svg?branch=master)](https://travis-ci.com/rbock/sqlpp11?branch=master) | [![Build status](https://ci.appveyor.com/api/projects/status/eid7mwqgavo0h61h/branch/master?svg=true)](https://ci.appveyor.com/project/rbock/sqlpp11/branch/master) | [![Coverage Status](https://coveralls.io/repos/rbock/sqlpp11/badge.svg?branch=master)](https://coveralls.io/r/rbock/sqlpp11?branch=master)\ndevelop | [![Build Status](https://travis-ci.com/rbock/sqlpp11.svg?branch=develop)](https://travis-ci.com/rbock/sqlpp11?branch=develop) | [![Build status](https://ci.appveyor.com/api/projects/status/eid7mwqgavo0h61h/branch/develop?svg=true)](https://ci.appveyor.com/project/rbock/sqlpp11/branch/develop) | [![Coverage Status](https://coveralls.io/repos/rbock/sqlpp11/badge.svg?branch=develop)](https://coveralls.io/r/rbock/sqlpp11?branch=develop)\n\nAdditional information available:\n---------------------------------\nPast talks about sqlpp11 and some coding concepts used within the library:\n\n  * [CppCast:](http://cppcast.com)\n   * 2015-05-07: http://cppcast.com/2015/05/roland-bock/\n  * [CppCon:](http://cppcon.org)\n   * 2015-09-24: [Pruning Error Messages From Your C++ Template Code](https://www.youtube.com/watch?v=2ISqFW9fRws), with examples from sqlpp11\n   * 2014-09-11: [sqlpp11, An SQL Library Worthy Of Modern C++](https://www.youtube.com/watch?v=cJPAjhBm-HQ)\n  * [Meeting C++:](http://meetingcpp.com)\n   * 2014-12-05: [sqlpp11, An EDSL For Type-Safe SQL In C++11](https://www.youtube.com/watch?v=9Hjfg9IfzhU)\n  * [MUC++:](http://www.meetup.com/MUCplusplus/)\n   * 2014-02-27: [Selected C++11 Template Toffees From sqlpp11, Part1](https://www.youtube.com/watch?v=hXnGFYNbmXg), [Part2](https://www.youtube.com/watch?v=WPCV6dvxZ_U), [Part 3](https://www.youtube.com/watch?v=eB7hd_KjTig), [Part 4](https://www.youtube.com/watch?v=NBfqzcN0_EQ)\n\n\nRequirements:\n-------------\n__Compiler:__\nsqlpp11 makes heavy use of C++11 and requires a recent compiler and STL. The following compilers are known to compile the test programs:\n\n  * clang-3.4+ on Ubuntu-12.4\n  * g++-4.8+ on Ubuntu-12.4\n  * g++-4.8+ on cygwin 64bit\n  * g++-4.9+ on Debian Unstable\n  * Xcode-7 on OS X\n  * MSVC 2015 Update 1 on Windows Server 2012\n\n__Database Connector:__\nsqlpp11 requires a certain api in order to connect with the database, see database/api.h.\n\nThis repository includes the following connectors:\n\n* MySQL\n* MariaDB\n* SQLite3\n* SQLCipher\n* PostgreSQL\n\nOther connectors can be found here:\n\n  * ODBC: https://github.com/Erroneous1/sqlpp11-connector-odbc (experimental)\n\n__Date Library:__\nsqlpp11 requires [Howard Hinnantâs date library](https://github.com/HowardHinnant/date) for `date` and `date_time` data types. By default, sqlpp11 uses FetchContent to pull the library automatically in the project. If you want to use an already installed version of the library with `find_package`, set `USE_SYSTEM_DATE` option to `ON`.\n\nBuild and Install\n-----------------\n\n**Note**: Depending on how you use the lib, you might not need to install it (see Basic Usage)\n\n__Build from Source:__\n\nDownload and unpack the latest release from https://github.com/rbock/sqlpp11/releases or clone the repository. Inside the directory run the following commands:\n\n```bash\ncmake -B build\ncmake --build build --target install\n```\n\nThe last step will build the library and install it system wide, therefore it might need admins rights.\n\nBy default only the core library will be installed. To also install connectors set the appropriate variable to `ON`: \n\n* `BUILD_MYSQL_CONNECTOR`\n* `BUILD_MARIADB_CONNECTOR`\n* `BUILD_POSTGRESQL_CONNECTOR`\n* `BUILD_SQLITE3_CONNECTOR`\n* `BUILD_SQLCIPHER_CONNECTOR`\n\nThe library will check if all required dependencies are installed on the system. If connectors should be installed even if the dependencies are not yet available on the system, set `DEPENDENCY_CHECK` to `OFF`. \n\nExample: Install the core library, sqlite3 connector and postgresql connector. Donât check if the dependencies such as Sqlite3 are installed and donât build any tests:\n\n```bash\ncmake -B build -DBUILD_POSTGRESQL_CONNECTOR=ON -DBUILD_SQLITE3_CONNECTOR=ON -DDEPENDENCY_CHECK=OFF -DBUILD_TESTING=OFF\ncmake --build build --target install\n```\n\n__Install via Homebrew (MacOS):__\n\n```bash\nbrew install marvin182/zapfhahn/sqlpp11\n```\n\nSome connectors can be installed with the formula. See `brew info marvin182/zapfhahn/sqlpp11` for available options.\n\n__Build via vcpkg:__\n\nYou can download and install sqlpp11 using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n\n```bash\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install 'sqlpp11[mysql]' # or other database feature\n```\n\nThe sqlpp11 port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\nBasic usage:\n-------------\n__Use with cmake__:\nThe library officially supports two ways how it can be used with cmake. \nYou can find examples for both methods in the examples folder. \n\n1. FetchContent (Recommended, no installation required)\n1. FindPackage (installation required, see above)\n\nBoth methods will provide the `sqlpp11::sqlpp11` target as well as targets for each connector: \n\n* sqlpp11::mysql\n* sqlpp11::mariadb\n* sqlpp11::sqlite3\n* sqlpp11::sqlcipher\n* sqlpp11::postgresql\n\nThese targets will make sure all required dependencies are available and correctly linked and include directories are set correctly.\n\n__Create DDL files__:\n``` \nmysql: 'show create table MyDatabase.MyTable' #or\nmysqldump --no-data MyDatabase > MyDatabase.sql\n\n```\nCreate headers for them with provided Python script:\n```\n%sqlpp11_dir%/scripts/ddl2cpp ~/temp/MyTable.ddl  ~/temp/MyTable %DatabaseNamespaceForExample%\n```\n\nIn case youâre getting notes about unsupported column type consider:\n  - Take a look at the other datatypes in sqlpp11/data_types. They are not hard to implement.\n  - Use the `--datatype-file` command line argument as described below.\n\nInclude generated header (MyTable.h), thatâs all.\n\nIf you prefer Ruby over Python, you might want to take a look at https://github.com/douyw/sqlpp11gen\n\nUnsupported column types:\n-------------\n__Map unsupported column types to supported column types with a csv file__:\n\nOne can use the `--datatype-file` command line argument for the ddl2cpp script to map unsupported column types to supported column types.\n\nThe format of the csv file is:\n```\n<dataType>, <col_type1>, <col_type2>\n<dataType>, <col_type3>\n```\n\nWhere `<dataType>` is one or more of the following internal types:\n\n  - `Boolean`\n  - `Integer`\n  - `Serial`\n  - `FloatingPoint`\n  - `Text`\n  - `Blob`\n  - `Date`\n  - `DateTime`\n  - `Time`\n\nExample:\n\n```\nBoolean, one_or_zero\nText, url, uuid\n```\n\nContact:\n--------\n  * Issues at https://github.com/rbock/sqlpp11/issues\n  * email at rbock at eudoxos dot de\n  * [![Join the chat at https://gitter.im/sqlpp11/Lobby](https://badges.gitter.im/sqlpp11/Lobby.svg)](https://gitter.im/sqlpp11/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.0263671875,
          "content": "theme: jekyll-theme-minimal"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "connector_api",
          "type": "tree",
          "content": null
        },
        {
          "name": "coveralls",
          "type": "blob",
          "size": 0.8623046875,
          "content": "#!/bin/bash\n\nif [ 0 -eq $(find -iname *.gcda | wc -l) ]\nthen\n  exit 0\nfi\n\ngcov --source-prefix ${TRAVIS_BUILD_DIR} --preserve-paths --relative-only $(find -iname *.gcda) 1>/dev/null || exit 0\n\ncat >coverage.json <<EOF\n{\n  \"service_job_id\": \"${TRAVIS_JOB_ID}\",\n  \"service_name\": \"travis-ci\",\n  \"source_files\": [\nEOF\n\nfor file in include*.gcov\ndo\n  path=$(echo ${file} | sed -re 's%#%\\/%g; s%.gcov$%%')\n  cat >>coverage.json <<EOF\n    {\n      \"name\": \"${path}\",\n      \"source_digest\": \"$(md5sum ${TRAVIS_BUILD_DIR}/${path} | awk '{ print $1 }')\",\n      \"coverage\": [$(tail -n +3 ${file} | cut -d ':' -f 1 | sed -re 's%^ +%%g; s%-%null%g; s%^[#=]+$%0%;' | tr $'\\n' ',' | sed -re 's%,$%%')]\n    },\nEOF\ndone\n\nmv coverage.json coverage.json.tmp\ncat >coverage.json <(head -n -1 coverage.json.tmp) <(echo -e \"    }\\n  ]\\n}\")\ncurl -F json_file=@coverage.json https://coveralls.io/api/v1/jobs\n"
        },
        {
          "name": "dependencies",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "pre-commit",
          "type": "blob",
          "size": 2.41015625,
          "content": "#!/usr/bin/env python3\nimport functools\nimport os\nfrom pprint import pprint\nimport re\nimport subprocess\nimport sys\n\nclass ValidationError(Exception): pass\n\ndef check_output(cmd, expect_process_error=False):\n    try:\n        return subprocess.check_output(cmd)\n    except Exception as e:\n        if not expect_process_error or not isinstance(e, subprocess.CalledProcessError):\n            print('Exception while running cmd %s' % (cmd,))\n        raise\n\ndef changes():\n    return check_output(('git', 'diff', '--no-ext-diff', '--cached', '-U0'))\n\ndef toplevel():\n    return check_output(('git', 'rev-parse', '--show-toplevel')).strip(b'\\n').decode('utf-8')\n\ndef toList(fn):\n    return functools.wraps(fn)(lambda *args, **kwargs: list(fn(*args, **kwargs)))\n\ntop = toplevel()\n\nclangformat = \"/usr/local/clang_3_6_0/bin/clang-format\"\n\n### CLANG-FORMAT BEGIN\nif os.path.exists(os.path.join(top, '.clang-format')):\n    reformatted_files = []\n    files_had_unstaged_edits = []\n    for filename in check_output(['git', 'diff-index', '--cached', '--name-only', 'HEAD']).decode('utf-8').splitlines():\n        if any(filename.endswith(ext) for ext in ('.cpp', '.h', '.hpp')):\n            file_path = os.path.join(top, filename)\n\n            with open(file_path, 'rb') as f:\n                staged = f.read()\n            formatted = check_output([clangformat, file_path])\n\n            if staged == formatted:\n                continue\n\n            try:\n                check_output(['git', 'diff', '--exit-code', file_path], expect_process_error=True)\n            except subprocess.CalledProcessError:\n                files_had_unstaged_edits.append(filename)\n\n            check_output([clangformat, '-i', file_path])\n\n            try:\n                check_output(['git', 'diff', '--exit-code', file_path], expect_process_error=True)\n            except subprocess.CalledProcessError:\n                reformatted_files.append(filename)\n\n    if reformatted_files:\n        print('These files were reformatted with clang-format, please stage the changes first:\\n- %s'\n              % '\\n- '.join(reformatted_files), file=sys.stderr)\n    if files_had_unstaged_edits:\n        print('\\nThese files had unstaged edits before clang-format reformatting. Please stage desired parts and confirm the commit again.\\n- %s'\n              % '\\n- '.join(files_had_unstaged_edits), file=sys.stderr)\n    if reformatted_files or files_had_unstaged_edits:\n        exit(1)\n### CLANG-FORMAT END\n\nexit(0)\n\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "wishlist.md",
          "type": "blob",
          "size": 2.7451171875,
          "content": "If you want to help with the development of the library, you might want to consider one of these items:\n\n# Better documentation\nThe documentation in the Wiki is incomplete and outdated. It is also not part of source control, which makes it a bit harder to contribute. \nIt might make sense to write a couple of markdown files here.\n\nThrow in chapters of how to add features and how to write connector libraries.\n\n## Better tests and examples\nMany of the current tests were born when the library was in infant state. Often they test implementation details. And they often just print stuff, instead of checking said stuff.\n\n# Connectors\n## Merge stable connectors into sqlpp11\nHaving all connector libraries in place, makes maintenance considerably simpler, see #174.\nIt would also reduce the cognitive overhead for newcomers.\n\n## New connectors\nThere are a couple of connector libraries already. Here are some that have been requested in the past\n\n- Sybase\n- Oracle\n- SQL Server\n- Google Spanner\n\n## More special functions and types for connectors\nGROUP CONCAT or JSON support for mysql, for instance\nINSERT OR UPDATE for postgresl and mysql\nINSERT INTO ... SELECT ... for postgresql\nCREATE TABLE for all of them, including PPGEN\n\nException types that carry more specific error information, e.g. the native error code, see #227\n\nFind a way to handle column names that are keywords in the vendor's dialect, see #199\n\nHandle specific data types, including JSON for the connectors.\n\nMore test cases for DDL files.\n\n# EDSL features\nMulti-line insert in prepared statements, see #68\n\n## optional std::optional support\nInstead of sqlpp::value_or_null, std::optional would be nice, see #238\n\n## Converter to and from SQL to C++ structs, to allow for more ORM like code\nAssuming that you have converter functions from struct to sqlpp11 and back, we could have something like this:\n```C++\nstruct Person;\ninsert_into(tab).set(Person{});\nupdate(tab).set(Person{});\nfor (const auto& person : db(select(Person{}).from(tab).unconditionally()))\n{\n  // ...\n}\n```\n\n# Runtime improvements\n## Connection pools and caching interface \nIn order to support high load scenarios, \n  - connection pools (to avoid creating and destroying connections)\n  - caching (hash the query and answer it from the cache for some time), see #86\n\n## Async support\nObtain results in an asynchronous fashion, see #35, for instance.\n\n# Compile time improvements\n## Simplify code\nSee Seventeenification talk. Some of the simplifications can be ported back easily.\n\n## Suppress export of symbols\nSome compilers tend to export all the generated symbols, which is a bit annoying in case of template-heavy libraries like sqlpp11 (leads to larger files and longer compile/link/startup times, I believe).\nThere are ways to suppress this in most compilers, afaik.\n\n"
        }
      ]
    }
  ]
}