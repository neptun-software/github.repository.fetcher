{
  "metadata": {
    "timestamp": 1736565714766,
    "page": 621,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "liu-jianhao/Cpp-Design-Patterns",
      "stars": 2446,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Abstract Factory",
          "type": "tree",
          "content": null
        },
        {
          "name": "Adapter",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bridge",
          "type": "tree",
          "content": null
        },
        {
          "name": "Builder",
          "type": "tree",
          "content": null
        },
        {
          "name": "Chain of Resposibility",
          "type": "tree",
          "content": null
        },
        {
          "name": "Command-Pattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "Command",
          "type": "tree",
          "content": null
        },
        {
          "name": "Composite",
          "type": "tree",
          "content": null
        },
        {
          "name": "Decorator-Pattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "Decorator",
          "type": "tree",
          "content": null
        },
        {
          "name": "Facade",
          "type": "tree",
          "content": null
        },
        {
          "name": "Factory Method",
          "type": "tree",
          "content": null
        },
        {
          "name": "Factory-Pattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "Flyweight",
          "type": "tree",
          "content": null
        },
        {
          "name": "Interpreter",
          "type": "tree",
          "content": null
        },
        {
          "name": "Iterator",
          "type": "tree",
          "content": null
        },
        {
          "name": "Mediator",
          "type": "tree",
          "content": null
        },
        {
          "name": "Memento",
          "type": "tree",
          "content": null
        },
        {
          "name": "Observer-Pattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "Observer",
          "type": "tree",
          "content": null
        },
        {
          "name": "Prototype",
          "type": "tree",
          "content": null
        },
        {
          "name": "Proxy",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.7197265625,
          "content": "# C++设计模式\n\n## 什么是设计模式\n“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。\n——Christopher Alexander\n\n## 如何解决复杂性？\n+ 分解\n  + 人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。\n+ 抽象\n  + 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。\n  \n  \n## 面向对象设计原则\n1. 依赖倒置原则（DIP）\n  + 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。\n  + 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。\n2. 开放封闭原则（OCP）\n  + 对扩展开放，对更改封闭。\n  + 类模块应该是可扩展的，但是不可修改。\n3. 单一职责原则（SRP）\n  + 一个类应该仅有一个引起它变化的原因。\n  + 变化的方向隐含着类的责任。\n4. Liskov 替换原则（LSP）\n  + 子类必须能够替换它们的基类(IS-A)。\n  + 继承表达类型抽象。\n5. 接口隔离原则（ISP）\n  + 不应该强迫客户程序依赖它们不用的方法。\n  + 接口应该小而完备。\n6. 优先使用对象组合，而不是类继承\n  + 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。\n  + 继承在某种程度上破坏了封装性，子类父类耦合度高。\n  + 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。\n7. 封装变化点\n  + 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。\n8. 针对接口编程，而不是针对实现编程\n  + 不将变量类型声明为某个特定的具体类，而是声明为某个接口。\n  + 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。\n  + 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。\n\n## 从封装变化角度对模式分类\n### 组件协作：\n+ [Template Method](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Template%20Method)\n+ [Template-Pattern(Head-First版)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Template-Pattern)\n+ [Observer/Event](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Observer)\n+ [Observer(Head-First版)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Observer-Pattern)\n+ [Strategy](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Strategy)\n+ [Strategy(Head-First版)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Strategy-Pattern)\n### 单一职责：\n+ [Decorator](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Decorator)\n+ [Decorator(Head-First版)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Decorator-Pattern)\n+ [Bridge](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Bridge)\n### 对象创建:\n+ [Factory Method](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Factory%20Method)\n+ [Factory(Head-First版)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Factory-Pattern)\n+ [Bridge](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Bridge)\n+ [Abstract Factory](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Abstract%20Factory)\n+ [Prototype](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Prototype)\n+ [Builder](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Builder)\n### 对象性能：\n+ [Singleton](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Singleton)\n+ [Flyweight(享元模式)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Flyweight)\n### 接口隔离:\n+ [Façade(门面模式)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Facade)\n+ [Proxy](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Proxy)\n+ [Mediator(中介者)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Mediator)\n+ [Adapter](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Adapter)\n### 状态变化：\n+ [Memento(备忘录)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Memento)\n+ [State](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/State)\n### 数据结构：\n+ [Composite(组合模式)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Composite)\n+ [Iterator](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Iterator)\n+ [Chain of Resposibility(职责链)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Chain%20of%20Resposibility)\n### 行为变化：\n+ [Command](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Command)\n+ [Command(Head-First版)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Command-Pattern)\n+ [Visitor](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Visitor)\n### 领域问题：\n+ [Interpreter](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Interpreter)\n\n\n## 总结\n### 现代较少用的模式\n+ Builder\n+ Mediator\n+ Memento\n+ Iterator\n+ Chain of Resposibility\n+ Command\n+ Visitor\n+ Interpreter\n\n感谢赞助！如果此项目对您有帮助，请作者喝一杯奶茶~~ （开心一整天😊😊）\n![image](https://github.com/user-attachments/assets/00b1ffbd-b63a-40f5-8f68-a870d3a9aeeb)\n![image](https://github.com/user-attachments/assets/6f8c0492-ace7-4679-b5ea-ed9029efb192)\n\n"
        },
        {
          "name": "Singleton",
          "type": "tree",
          "content": null
        },
        {
          "name": "State",
          "type": "tree",
          "content": null
        },
        {
          "name": "Strategy-Pattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "Strategy",
          "type": "tree",
          "content": null
        },
        {
          "name": "Template Method",
          "type": "tree",
          "content": null
        },
        {
          "name": "Template-Pattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "Visitor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}