{
  "metadata": {
    "timestamp": 1736565952341,
    "page": 931,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "plv8/plv8",
      "stars": 1940,
      "defaultBranch": "r3.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0986328125,
          "content": ".gitattributes export-ignore\n.github export-ignore\n.gitignore export-ignore\n.gitmodules export-ignore"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.701171875,
          "content": "# Generate source files\n/coffee-script.cc\n/livescript.cc\n/plv8_config.h\n\n# Generated test and install files\n/plcoffee--*.sql\n/plcoffee.control\n/plls--*.sql\n/plls.control\n/plv8--*.sql\n/plv8.control\n\n# Generic build files\n*.o\n*.so\n*.bc\n\n# For static build\n/build\n\n# Test results\n/results\n\n# For packaging\nplv8-*.zip\n\n# Web\n/contrib/web/node_modules\n/contrib/web/index.html\n\n# For MSVC\n/windows/*.vcxproj\n/windows/*.vcxproj.filters\n/windows/*.sln\n/windows/CMakeCache.txt\n/windows/CMakeFiles\n/windows/Release\n/windows/cmake_install.cmake\n/windows/libplv8.dir\n/windows/vendor\n/windows/x64\n/windows/CPackConfig.cmake\n/windows/CPackSourceConfig.cmake\n/windows/_CPack_Packages\n/windows/install_manifest.txt\n/windows/plv8*.zip\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.09765625,
          "content": "[submodule \"deps/v8-cmake\"]\n\tpath = deps/v8-cmake\n\turl = https://github.com/bnoordhuis/v8-cmake.git\n"
        },
        {
          "name": "COPYRIGHT",
          "type": "blob",
          "size": 0.990234375,
          "content": "Copyright (c) 2009-2022, the PLV8JS Development Group.\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose, without fee, and without a written agreement\nis hereby granted, provided that the above copyright notice and this\nparagraph and the following two paragraphs appear in all copies.\n\nIN NO EVENT SHALL the PLV8JS Development Group BE LIABLE TO ANY PARTY FOR\nDIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\nLOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\nDOCUMENTATION, EVEN IF the PLV8JS Development Group HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\nThe PLV8JS Development Group SPECIFICALLY DISCLAIMS ANY WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS\nON AN \"AS IS\" BASIS, AND the PLV8JS Development Group HAS NO OBLIGATIONS TO\nPROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n"
        },
        {
          "name": "Changes",
          "type": "blob",
          "size": 6.953125,
          "content": "Revision history for plv8\n\n3.2.3       2024-09-08\n            - automatic pgxn builds and pushes\n            - postgres 17 support\n\n3.2.2       2024-01-21\n            - proper termination in cursors\n\n3.2.1       2023-12-17\n            - fix upgrade script installation\n            - fix build issue on fresh checkout\n            - fix crash with plv8_info()\n            - fix memory allocator statistics\n            - fix scalar jsonb issue\n\n3.2.0       2023-08-01\n            - fix for GUC upgrade issue\n            - better postgres 16 support\n            - windows support removed (for now at least)\n\n3.2alpha    2023-07-14\n            - remove coffeejs and livescript\n            - switch to v8-cmake build syste,\n            - update v8 to v8 11.5\n            - remove ancient pg version support (9.x)\n\n3.1.10      2024-01-21\n            - proper termination in cursors\n            \n3.1.9       2023-12-17\n            - fix plv8_info()\n            - fix upgrade script installation\n            - fix jsonb arguments\n            - fix allocator tracking\n\n3.1.8       2023-08-01\n            - force v8 to compile in release mode\n\n3.1.7       2023-06-26\n            - fix byteoffset issue with arraybuffers\n            - support postgres 16 beta\n\n3.1.6       2023-04-08\n            - fix crash issue on fetch apply\n            - fix interrupt issue\n\n3.1.5       2023-01-24\n            - better older version migration support\n            - fix postgres 15 naming conflict\n            - fix plv8_context memory clearing\n            - docker updates and fixes\n\n3.1.4       2022-08-21\n            - more signal management fixes\n            - support postgres 15 beta\n\n3.1.3       2022-08-07\n            - fix makefile for some linux systems\n            - better signal management\n\n3.1.2       2022-04-02\n            - update jinja2 for python 3.10\n\n3.1.1       2022-03-29\n            - fix makefile defines for execution timeout\n\n3.1.0       2022-03-17\n            - new build system\n            - update to v8 9.7\n            - fix aws arm64 compilation issues with new v8\n            - fix issues cancelling\n\n3.0.0       2021-05-31\n            - update to v8 8.6.405\n            - support postgres 14\n\n3.0alpha\n            - update to v8 7.4\n            - add Bigint support\n            - add BigInt64Array support\n            - add direct JSONB conversion to and from v8 objects\n            - add plv8.memory_usage()\n            - support postgres 13\n            - SPI fixes\n            - add per user v8 isolates\n            - fix outstanding BYTEA bug\n\n2.3.12      2019-06-28\n            - support postgres 12\n\n2.3.11\t    2019-03-24\n            - add permissions check for find-function\n            - add better upgrade script\n\n2.3.10      2019-03-23\n            - add direct jsonb conversion option\n            - add memory context for jsonb conversion\n\n2.3.9       2018-12-09\n            - work around pg11 forced filename endings\n\n2.3.8       2018-09-28\n            - earlier cleanup of spi\n            - support in v8 of xcode 10\n\n2.3.7       2018-07-13\n            - support pg 11\n            - support procedures\n\n2.3.6       2018-06-21\n            - change v8 to use its default array buffer allocator rather than\n              using pg's memory contexts\n\n2.3.5       2018-06-13\n            - better bytea handling for arrays\n\n2.3.4       2018-05-07\n            - add execution timeout support to windows\n            - add automatic creation of update files on macos/linux/unix\n            - add automatic creation of setup files on windows\n\n2.3.3       2018-04-27\n            - added upgrade scripts\n            - added cancelling signal support on macos/linux/unix\n\n2.3.2       2018-04-13\n            - moved permissions check into a PG_TRY/PG_CATCH block\n            - updated external startup compilation to include v8 >= 5.0\n\n2.3.1       2018-03-07\n            - add optional functionality for execution timeouts\n\n2.3.0       2018-02-12\n            - track v8 6.4.388.40\n            - change build system\n            - force static to be default build\n\n2.1.0       2017-07-05\n            - track v8 5.8.301\n            - better error handling\n\n2.0.0       2017-02-02\n            - track v8 5.4.500.43\n\n2.0.0-dev\n            - track v8 4.4-4.10\n            - add plv8_version()\n\n1.5.1       2016-03-27\n            - add fix for current resource owner\n\n1.5.0       2016-02-26\n            - Adaptions for current V8 version, e.g. 4.1.0.x - 4.3.66\n              (see http://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/\n              for an overview of the V8 changes which break existing code bases)\n            - GUC plv8.v8_flags for V8 engine initialization flags\n            - Fixed crash in ArrayBuffer\n            - Fixed encoding issues with elog\n            - Fixed memory leak in cursor fetch\n            - Errors return full error context as an object now\n            - Fixed crash bug in cursor fetch\n\n1.4.4       2015-05-26\n            - Add jsonb type coercion in function boundary.\n            - Fix crash related to FLEXIBLE_ARRAY_MEMBER changes.\n\n1.4.3       2015-02-02\n            - Fix compilation for 9.4\n            - Fix off-by-one in variadic .execute handling\n            - Add .gitignore\n            - Fix incorrect code in return_next\n            - Mark NULL in converter even for dropped columns to prevent crash.\n\n1.4.2       2014-02-20\n            - Fix CREATE FUNCTION in startup procedure.\n            - Fix dropped column case.\n            - Accept non-array parameters to execute().\n            - Prevent privilege escalation in explicit calls to validators.\n\n1.4.1       2013-05-14\n            - Fix compilation with v8 3.18.x\n\n1.4.0       2013-04-29\n            - Implement fetch(n) and move(n).\n            - Fix a bug around type conversion.\n            - Support recent version of v8.\n            - Disallow use of plv8.execute() when outside of transaction.\n            - Fix some memory leaks.\n            - Remove use of gettext().\n            - Upgrade LiveScript to 1.1.1.\n\n1.3.0       2012-12-08\n            - Make two dialects (plcoffee, plls) official sub-extensions.\n            - Implement builtin json type conversion.\n            - Static build and automatic v8 build via 'static' target.\n            - Implement v8's remote debugger if enabled.\n            - Implement bytea type conversion and typed array.\n            - Allow polymorphic and internal types in argument and return types.\n            - Support user defined window functions.\n            - Potential bug fixes.\n\n1.2.1       2012-12-08\n            - Fix a crash in returning array value from array-return function.\n            - Fix trigger so that returned NULL can be handled correctly.\n\n1.2.0       2012-07-20\n            - Check the field names match for SRFs.\n            - Fix EpochToDate to handle non integer timestamp case.\n            - Let parser deduce parameter types in SPI queries.\n\n1.1.0       2012-06-07\n            - Add plv8.version string.\n            - Fix a bug around name[] conversion from/to SQL.\n\n1.1.0beta1  2012-05-13\n            - Initial public beta.\n"
        },
        {
          "name": "META.json",
          "type": "blob",
          "size": 1.4130859375,
          "content": "{\n    \"name\": \"plv8\",\n    \"abstract\": \"A procedural language in JavaScript powered by V8\",\n    \"description\": \"plv8 is a trusted procedural language that is safe to use, fast to run and easy to develop.\",\n    \"version\": \"3.2.3\",\n    \"maintainer\": [\n        \"Jerry Sievert <code@legitimatesounding.com>\"\n    ],\n    \"license\": {\n        \"PostgreSQL\": \"http://www.postgresql.org/about/licence\"\n    },\n    \"release_status\": \"stable\",\n    \"prereqs\": {\n        \"runtime\": {\n            \"requires\": {\n                \"PostgreSQL\": \"13.11.0\"\n            },\n            \"recommends\": {\n                \"PostgreSQL\": \"15.3.0\"\n            }\n        }\n    },\n    \"provides\": {\n        \"plv8\": {\n            \"file\": \"plv8--3.2.3.sql\",\n            \"docfile\": \"docs/PGXN.md\",\n            \"version\": \"3.2.3\",\n            \"abstract\": \"A procedural language in JavaScript\"\n        }\n    },\n    \"no_index\": {\n        \"directory\": [ \"deps\" ]\n    },\n    \"resources\": {\n        \"homepage\": \"https://plv8.github.io/\",\n        \"bugtracker\": {\n            \"web\": \"https://github.com/plv8/plv8/issues\"\n        },\n        \"repository\": {\n            \"url\": \"https://github.com/plv8/plv8\",\n            \"web\": \"https://github.com/plv8/plv8.git\",\n            \"type\": \"git\"\n        }\n    },\n    \"meta-spec\": {\n        \"version\": \"1.0.0\",\n        \"url\": \"http://pgxn.org/meta/spec.txt\"\n    },\n    \"tags\": [\n        \"PL\",\n        \"JavaScript\",\n        \"v8\",\n        \"plv8\"\n    ]\n}"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.185546875,
          "content": "\nPLV8_VERSION = 3.2.3\n\nCP := cp\nPG_CONFIG = pg_config\nPGXS := $(shell $(PG_CONFIG) --pgxs)\nSHLIB_LINK += -std=c++17\nPG_CPPFLAGS := -fPIC -Wall -Wno-register -xc++\nPG_LDFLAGS := -std=c++17\n\nSRCS = plv8.cc plv8_type.cc plv8_func.cc plv8_param.cc plv8_allocator.cc plv8_guc.cc\nOBJS = $(SRCS:.cc=.o)\nMODULE_big = plv8-$(PLV8_VERSION)\nEXTENSION = plv8\nPLV8_DATA = plv8.control plv8--$(PLV8_VERSION).sql\n\nifeq ($(OS),Windows_NT)\n\t# noop for now\nelse\n\tSHLIB_LINK += -Ldeps/v8-cmake/build\n\tUNAME_S := $(shell uname -s)\n\tifeq ($(UNAME_S),Darwin)\n\t\tCCFLAGS += -stdlib=libc++\n\t\tSHLIB_LINK += -stdlib=libc++ -std=c++17 -lc++\n\t\tNUMPROC := $(shell sysctl hw.ncpu | awk '{print $$2}')\n\tendif\n\tifeq ($(UNAME_S),Linux)\n\t\tSHLIB_LINK += -lrt -std=c++17\n\t\tNUMPROC := $(shell grep -c ^processor /proc/cpuinfo)\n\tendif\nendif\n\nifeq ($(NUMPROC),0)\n\tNUMPROC = 1\nendif\n\nSHLIB_LINK += -Ldeps/v8-cmake/build\n\nall: v8 $(OBJS)\n\n# For some reason, this solves parallel make dependency.\nplv8_config.h plv8.so: v8\n\ndeps/v8-cmake/README.md:\n\t@git submodule update --init --recursive\n\ndeps/v8-cmake/build/libv8_libbase.a: deps/v8-cmake/README.md\n\t@cd deps/v8-cmake && mkdir -p build && cd build && cmake -Denable-fPIC=ON -DCMAKE_BUILD_TYPE=Release ../ && make -j $(NUMPROC)\n\nv8: deps/v8-cmake/build/libv8_libbase.a\n\n# enable direct jsonb conversion by default\nCCFLAGS += -DJSONB_DIRECT_CONVERSION\n\nCCFLAGS += -Ideps/v8-cmake/v8/include -std=c++17\n\nifdef EXECUTION_TIMEOUT\n\tCCFLAGS += -DEXECUTION_TIMEOUT\nendif\n\nifdef BIGINT_GRACEFUL\n\tCCFLAGS += -DBIGINT_GRACEFUL\nendif\n\nDATA = $(PLV8_DATA)\nDATA_built = plv8.sql\nREGRESS = init-extension plv8 plv8-errors scalar_args inline json startup_pre startup varparam json_conv \\\n\t\t  jsonb_conv window guc es6 arraybuffer composites currentresource startup_perms bytea find_function_perms \\\n\t\t  memory_limits reset show array_spread regression procedure\n\nifndef BIGINT_GRACEFUL\n\tREGRESS += bigint\nelse\n\tREGRESS += bigint_graceful\nendif\n\nSHLIB_LINK += -lv8_base_without_compiler -lv8_compiler -lv8_snapshot -lv8_inspector -lv8_libplatform -lv8_base_without_compiler -lv8_libsampler -lv8_torque_generated -lv8_libbase\n\nOPTFLAGS = -std=c++17 -fno-rtti -O2\nCCFLAGS += -Wall $(OPTFLAGS)\n\ngenerate_upgrades:\n\t@mkdir -p upgrade\n\t@./generate_upgrade.sh $(PLV8_VERSION)\n\t$(eval PLV8_DATA +=  $(wildcard upgrade/*.sql))\n\nall: generate_upgrades\n\nplv8_config.h: plv8_config.h.in Makefile\n\tsed -e 's/^#undef PLV8_VERSION/#define PLV8_VERSION \"$(PLV8_VERSION)\"/' $< > $@\n\n%.o : %.cc plv8_config.h plv8.h\n\t$(CXX) $(CCFLAGS) $(CPPFLAGS) -fPIC -c -o $@ $<\n\nCOMPILE.cxx.bc = $(CLANG) -xc++ -Wno-ignored-attributes $(BITCODE_CXXFLAGS) $(CCFLAGS) $(CPPFLAGS) -emit-llvm -c\n\n%.bc : %.cc\n\t$(COMPILE.cxx.bc) $(CCFLAGS) $(CPPFLAGS) -fPIC -c -o $@ $<\n\t$(LLVM_BINPATH)/opt -module-summary -f $@ -o $@\n\nDATA_built =\n\nall: $(DATA)\n\n%--$(PLV8_VERSION).sql: plv8.sql.common\n\tsed -e 's/@LANG_NAME@/$*/g' $< | sed -e 's/@PLV8_VERSION@/$(PLV8_VERSION)/g' | $(CC) -E -P $(CPPFLAGS) -DLANG_$* - > $@\n\n%.control: plv8.control.common\n\tsed -e 's/@PLV8_VERSION@/$(PLV8_VERSION)/g' $< | $(CXX) -E -P -DLANG_$* - > $@\n\nsubclean:\n\trm -f plv8_config.h $(DATA)\n\nclean: subclean\n\ndistclean: clean\n\t@cd deps/v8-cmake/build && make clean\n\n.PHONY: subclean all clean installcheck\n\ninclude $(PGXS)\nCC=$(CXX)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.7958984375,
          "content": "# PLV8 - A Procedural Language in Javascript powered by V8\n\nPLV8 is a shared library that provides a PostgreSQL procedural language powered\nby V8 Javascript Engine. With this program you can write in Javascript your\nfunction that is callable from SQL.\n\n## Support\n\nThere is a [Discord](https://discord.gg/XYGSCfVNBC) available for general questions and support. Please\nask there before opening an issue.\n\n## Build Requirements\n\nNote that as PLV8 3.2, build requirements have again changed.\n\n### Linux\n\nThe following packages must be installed to build on Ubuntu or Debian:\n\n- `libtinfo5`\n- `build-essential`\n- `pkg-config`\n- `libstdc++-12-dev` (depending on version, may be 10 instead of 12)\n- `cmake`\n- `git`\n\nThe following packages must be installed to build on EL9 or EL8:\n\n- 'development tools' - via groupinstall\n- `cmake`\n- `git`\n\n### MacOS\n\nThe following packages must be install to build on MacOS:\n\n- `XCode` - and the command line tools\n- `cmake`\n\n## Building\n\nBuilding plv8 needs to have all build requirements fulfilled before building.\nYou must make sure that `pg_config` is in your path. It should share the same\ninstallation directory as `psql` and `postgres`.\n\n```sh\nmake\n```\n\n### Installing\n\nThis should install plv8 as an available extension into Postgres.\n\n```sh\nmake install\n```\n\n### Run Tests\n\nPostgres features a test runner, and plv8 includes a number of tests that can be\nrun.\n\n```sh\nmake installcheck\n```\n\n## Running\n\n    =# CREATE EXTENSION plv8;\n\nThis will install PLV8 into your database if it exists as an available extension.\n\n## Testing\n\nTo test, you can execute:\n\n    =# DO $$ plv8.elog(NOTICE, \"hello there!\"); $$ LANGUAGE plv8;\n\nFor full documentation, see [https://plv8.github.io/](https://plv8.github.io/).\n\n## Docker\n\nFor Docker support, see [./platforms/Docker/README.md](./platforms/Docker/README.md)\n"
        },
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "deps",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "expected",
          "type": "tree",
          "content": null
        },
        {
          "name": "generate_upgrade.sh",
          "type": "blob",
          "size": 0.85546875,
          "content": "#!/usr/bin/env bash\n\n# version is the first argument, passed in from Makefile\nVERSION=$1\n\nolder_versions=(1.5.0 1.5.1 1.5.2 1.5.3 1.5.4 1.5.5 1.5.6 1.5.7 2.0.0 2.0.1 2.0.3 2.1.0 2.1.2 2.3.0 2.3.1 2.3.2 2.3.3 2.3.4 2.3.5 2.3.6 2.3.7 2.3.8 2.3.9 2.3.10 2.3.11 2.3.12 2.3.13 2.3.14 2.3.15 3.0.0 3.0.1 3.1.0 3.1.1 3.1.2 3.1.3 3.1.4 3.1.5 3.1.6 3.1.7 3.1.8 3.2.0 3.2.1 3.2.2)\n\nfor i in ${older_versions[@]}; do\ncat > upgrade/plv8--${i}--$VERSION.sql << EOF\nCREATE OR REPLACE FUNCTION plv8_version ( )\nRETURNS TEXT AS\n\\$\\$\n\treturn \"$VERSION\";\n\\$\\$ LANGUAGE plv8;\n\nCREATE OR REPLACE FUNCTION plv8_call_handler() RETURNS language_handler\n AS 'MODULE_PATHNAME' LANGUAGE C;\nCREATE OR REPLACE FUNCTION plv8_inline_handler(internal) RETURNS void\n AS 'MODULE_PATHNAME' LANGUAGE C;\nCREATE OR REPLACE FUNCTION plv8_call_validator(oid) RETURNS void\n AS 'MODULE_PATHNAME' LANGUAGE C;\nEOF\ndone\n"
        },
        {
          "name": "package.sh",
          "type": "blob",
          "size": 0.6591796875,
          "content": "#!/bin/sh\n\nORIG=`pwd`\nV8DIR=`dirname $0`\n\nif [ -z $1 ]; then\n    echo \"usage: $0 tagname\"\n    exit\nfi\nTAG=$1\n\ncd $V8DIR\n\nGITHEAD=`git symbolic-ref --short HEAD`\necho GITHEAD = $GITHEAD\n\ngit checkout $TAG\n\nif [ $? -ne 0 ]; then\n    echo \"failed to checkout: $TAG\"\n    exit\nfi\n\nV8VER=`v8 -e 'print(JSON.parse(read(\"META.json\")).version)' 2>/dev/null`\nif [ -z \"$V8VER\" ] ; then\n    V8VER=`d8 -e 'print(JSON.parse(read(\"META.json\")).version)'`\nfi\nif [ -z \"$V8VER\" ] ; then\n    echo \"Could not get version for plv8\"\n    exit 1\nfi\n\ngit archive --output $ORIG/plv8-$V8VER.zip \\\n            --prefix=plv8-$V8VER/ \\\n            --format=zip \\\n            $TAG\n\ngit checkout $GITHEAD\n\n"
        },
        {
          "name": "patches",
          "type": "tree",
          "content": null
        },
        {
          "name": "platforms",
          "type": "tree",
          "content": null
        },
        {
          "name": "plv8.cc",
          "type": "blob",
          "size": 66.880859375,
          "content": "/*-------------------------------------------------------------------------\n *\n * plv8.cc : PL/v8 handler routines.\n *\n * Copyright (c) 2009-2012, the PLV8JS Development Group.\n *-------------------------------------------------------------------------\n */\n#include \"plv8.h\"\n\n#ifdef _MSC_VER\n#undef open\n#endif\n\n#include \"libplatform/libplatform.h\"\n#include \"plv8_allocator.h\"\n\n\nextern \"C\" {\n#if PG_VERSION_NUM >= 90300\n#include \"access/htup_details.h\"\n#endif\n#include \"access/xact.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_type.h\"\n#include \"commands/trigger.h\"\n#include \"executor/spi.h\"\n#include \"funcapi.h\"\n#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/guc.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/syscache.h\"\n\n#if PG_VERSION_NUM >= 120000\n#include \"catalog/pg_database.h\"\n#endif\n\n#if PG_VERSION_NUM >= 130000\n#include \"common/hashfn.h\"\n#endif\n\n#include <signal.h>\n\n#ifdef EXECUTION_TIMEOUT\n#ifdef _MSC_VER\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n#endif\n\nPG_MODULE_MAGIC;\n\nPGDLLEXPORT Datum\tplv8_call_handler(PG_FUNCTION_ARGS);\nPGDLLEXPORT Datum\tplv8_call_validator(PG_FUNCTION_ARGS);\nPGDLLEXPORT Datum\tplv8_reset(PG_FUNCTION_ARGS);\nPGDLLEXPORT Datum\tplv8_info(PG_FUNCTION_ARGS);\n\nPG_FUNCTION_INFO_V1(plv8_call_handler);\nPG_FUNCTION_INFO_V1(plv8_call_validator);\nPG_FUNCTION_INFO_V1(plv8_reset);\nPG_FUNCTION_INFO_V1(plv8_info);\n\n\nPGDLLEXPORT void _PG_init(void);\n\n#if PG_VERSION_NUM >= 90000\nPGDLLEXPORT Datum\tplv8_inline_handler(PG_FUNCTION_ARGS);\n\nPG_FUNCTION_INFO_V1(plv8_inline_handler);\n#endif\n} // extern \"C\"\n\nusing namespace v8;\n\ntypedef struct plv8_proc_cache\n{\n\tOid\t\t\t\t\t\tfn_oid;\n\n\tPersistent<Function>\tfunction;\n\tchar\t\t\t\t\tproname[NAMEDATALEN];\n\tchar\t\t\t\t   *prosrc;\n\n\tTransactionId\t\t\tfn_xmin;\n\tItemPointerData\t\t\tfn_tid;\n\tOid\t\t\t\t\t\tuser_id;\n\n\tint\t\t\t\t\t\tnargs;\n\tbool\t\t\t\t\tretset;\t\t/* true if SRF */\n\tOid\t\t\t\t\t\trettype;\n\tOid\t\t\t\t\t\targtypes[FUNC_MAX_ARGS];\n} plv8_proc_cache;\n\nplv8_context *current_context = nullptr;\nsize_t plv8_memory_limit = 0;\nsize_t plv8_last_heap_size = 0;\n\n/*\n * The function and context are created at the first invocation.  Their\n * lifetime is same as plv8_proc, but they are not palloc'ed memory,\n * so we need to clear them at the end of transaction.\n */\ntypedef struct plv8_exec_env\n{\n\tIsolate \t\t\t   *isolate;\n\tPersistent<Object>\t\trecv;\n\tPersistent<Context>\t\tcontext;\n\tLocal<Context> localContext() { return Local<Context>::New(isolate, context) ; }\n\tstruct plv8_exec_env   *next;\n} plv8_exec_env;\n\n/*\n * We cannot cache plv8_type inter executions because it has FmgrInfo fields.\n * So, we cache rettype and argtype in fn_extra only during one execution.\n */\ntypedef struct plv8_proc\n{\n\tplv8_proc_cache\t\t   *cache;\n\tplv8_exec_env\t\t   *xenv;\n\tTypeFuncClass\t\t\tfunctypclass;\t\t\t/* For SRF */\n\tplv8_type\t\t\t\trettype;\n\tplv8_type\t\t\t\targtypes[FUNC_MAX_ARGS];\n} plv8_proc;\n\nstatic HTAB *plv8_proc_cache_hash = NULL;\n\nstatic plv8_exec_env\t\t   *exec_env_head = NULL;\n\nstatic void killPlv8Context(plv8_context *ctx);\n\n/*\n * lower_case_functions are postgres-like C functions.\n * They could raise errors with elog/ereport(ERROR).\n */\nstatic plv8_proc *plv8_get_proc(Oid fn_oid, FunctionCallInfo fcinfo,\n\t\tbool validate, char ***argnames) throw();\nstatic void plv8_xact_cb(XactEvent event, void *arg);\n\n/*\n * CamelCaseFunctions are C++ functions.\n * They could raise errors with C++ throw statements, or never throw exceptions.\n */\nstatic plv8_exec_env *CreateExecEnv(Handle<Function> function, plv8_context *context);\nstatic plv8_exec_env *CreateExecEnv(Persistent<Function>& function, plv8_context *context);\nstatic plv8_proc *Compile(Oid fn_oid, FunctionCallInfo fcinfo,\n\t\t\t\t\tbool validate, bool is_trigger);\nstatic Local<Function> CompileFunction(plv8_context *global_context,\n\t\t\t\t\tconst char *proname, int proarglen,\n\t\t\t\t\tconst char *proargs[], const char *prosrc,\n\t\t\t\t\tbool is_trigger, bool retset);\nstatic Datum CallFunction(PG_FUNCTION_ARGS, plv8_exec_env *xenv,\n\t\tint nargs, plv8_type argtypes[], plv8_type *rettype);\nstatic Datum CallSRFunction(PG_FUNCTION_ARGS, plv8_exec_env *xenv,\n\t\tint nargs, plv8_type argtypes[], plv8_type *rettype);\nstatic Datum CallTrigger(PG_FUNCTION_ARGS, plv8_exec_env *xenv);\nstatic plv8_context *GetPlv8Context();\nstatic Local<ObjectTemplate> GetGlobalObjectTemplate(Isolate *isolate);\nstatic void CreateIsolate(plv8_context *context);\n\n/* A GUC to specify a custom start up function to call */\nstatic char *plv8_start_proc = NULL;\n\n/* A GUC to specify V8 flags (e.g. --es_staging) */\nstatic char *plv8_v8_flags = NULL;\n\n/* A GUC to specify the ICU data directory */\nstatic char *plv8_icu_data = NULL;\n\n/* A GUC to specify the remote debugger port */\nstatic int plv8_debugger_port;\n\n#ifdef EXECUTION_TIMEOUT\nstatic int plv8_execution_timeout = 300;\n#endif\n\nstatic std::unique_ptr<v8::Platform> v8_platform = NULL;\n\n/*\n * We use vector instead of hash since the size of this array\n * is expected to be short in most cases.\n */\nstatic std::vector<plv8_context *> ContextVector;\n\n#ifdef ENABLE_DEBUGGER_SUPPORT\nv8::Persistent<v8::Context> debug_message_context;\n\nvoid DispatchDebugMessages() {\n  // We are in some random thread. We should already have v8::Locker acquired\n  // (we requested this when registered this callback). We was called\n  // because new debug messages arrived; they may have already been processed,\n  // but we shouldn't worry about this.\n  //\n  // All we have to do is to set context and call ProcessDebugMessages.\n  //\n  // We should decide which V8 context to use here. This is important for\n  // \"evaluate\" command, because it must be executed some context.\n  // In our sample we have only one context, so there is nothing really to\n  // think about.\n  v8::Context::Scope scope(debug_message_context);\n\n  v8::Debug::ProcessDebugMessages();\n}\n#endif  // ENABLE_DEBUGGER_SUPPORT\n\nvoid OOMErrorHandler(const char* location, const v8::OOMDetails &) {\n\tIsolate *isolate = Isolate::GetCurrent();\n\tisolate->TerminateExecution();\n\t// set it to kill the user context and isolate\n\tcurrent_context->is_dead = true;\n\telog(ERROR, \"Out of memory error\");\n}\n\nvoid GCEpilogueCallback(Isolate* isolate, GCType type, GCCallbackFlags /* flags */) {\n\tHeapStatistics heap_statistics;\n\tisolate->GetHeapStatistics(&heap_statistics);\n\t//elog(NOTICE, \"Current memory: %lld => %lld\", heap_statistics.used_heap_size(), plv8_memory_limit * 1_MB);\n\tif (type != GCType::kGCTypeIncrementalMarking\n\t\t&& heap_statistics.used_heap_size() > plv8_memory_limit * 1_MB) {\n\t\t//elog(NOTICE, \"Terminating\");\n\t\tconst char *error_message = \"Out of memory\";\n\t\tLocal<v8::String>\tresult = ToString(error_message, 13);\n\t\tisolate->ThrowException(result);\n\t\t//isolate->setData(MEM_SOFTLIMIT_REACHED);\n\t\tisolate->TerminateExecution();\n\t}\n\tif (heap_statistics.used_heap_size() > plv8_memory_limit * 1_MB / 0.9\n\t\t&& plv8_last_heap_size < plv8_memory_limit * 1_MB / 0.9) {\n\t\tisolate->LowMemoryNotification();\n\t}\n\tplv8_last_heap_size = heap_statistics.used_heap_size();\n}\n\nsize_t NearHeapLimitHandler(void* data, size_t current_heap_limit,\n\t\t\t\t\t\t\t\tsize_t initial_heap_limit) {\n\tIsolate *isolate = Isolate::GetCurrent();\n\tisolate->TerminateExecution();\n\t// need to give back more space\n\t// to make sure it can unwind the stack and process exceptions\n\treturn current_heap_limit + 1_MB;\n}\n\nvoid PromiseRejectCB(PromiseRejectMessage rejection) {\n\tauto event = rejection.GetEvent();\n\tif (event == kPromiseRejectAfterResolved || event == kPromiseResolveAfterResolved)\n\t\treturn;\n\tauto\tpromise = rejection.GetPromise();\n\tauto\tisolate = promise->GetIsolate();\n\n\tif (rejection.GetEvent() == v8::kPromiseHandlerAddedAfterReject) {\n\t\tif (current_context->ignore_unhandled_promises) return;\n\t\t// Remove handled promises from the list\n\t\tauto& unhandled_promises = current_context->unhandled_promises;\n\t\tfor (auto it = unhandled_promises.begin(); it != unhandled_promises.end(); ++it) {\n\t\t\tauto unhandled_promise = std::get<0>(*it).Get(isolate);\n\t\t\tif (unhandled_promise == promise) {\n\t\t\t\tunhandled_promises.erase(it--);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tauto exception = rejection.GetValue();\n\tLocal<Message> message;\n\t// Assume that all objects are stack-traces.\n\tif (exception->IsObject()) {\n\t\tmessage = Exception::CreateMessage(isolate, exception);\n\t}\n\tif (!exception->IsNativeError() &&\n\t\t(message.IsEmpty() || message->GetStackTrace().IsEmpty())) {\n\t\t// If there is no real Error object, manually throw and catch a stack trace.\n\t\tTryCatch try_catch(isolate);\n\t\ttry_catch.SetVerbose(true);\n\t\tisolate->ThrowException(Exception::Error(\n\t\t\t\tv8::String::NewFromUtf8Literal(isolate, \"Unhandled Promise.\")));\n\t\tmessage = try_catch.Message();\n\t\texception = try_catch.Exception();\n\t}\n\tif (current_context->ignore_unhandled_promises) return;\n\tcurrent_context->unhandled_promises.emplace_back(\n\t\t\tv8::Global<v8::Promise>(isolate, promise),\n\t\t\tv8::Global<v8::Message>(isolate, message),\n\t\t\tv8::Global<v8::Value>(isolate, exception));\n}\n\nvoid HandleUnhandledPromiseRejections() {\n\t// Avoid recursive calls to HandleUnhandledPromiseRejections.\n\tauto isolate = current_context->isolate;\n\tif (current_context->ignore_unhandled_promises) return;\n\tcurrent_context->ignore_unhandled_promises = true;\n\tHandleScope scope(isolate);\n\t// Ignore promises that get added during error reporting.\n\tsize_t i = 0;\n\tauto& unhandled_promises = current_context->unhandled_promises;\n\tfor (; i < unhandled_promises.size(); i++) {\n\t\tconst auto& tuple = unhandled_promises[i];\n\t\tLocal<v8::Message> message = std::get<1>(tuple).Get(isolate);\n\t\tLocal<v8::Value> exception = std::get<2>(tuple).Get(isolate);\n\t\tjs_error error(isolate, exception, message);\n\t\terror.log(WARNING, \"Unhandled Promise rejection: %s\");\n\t}\n\tunhandled_promises.clear();\n\tcurrent_context->ignore_unhandled_promises = false;\n}\n\nstatic void\nCreateIsolate(plv8_context *context) {\n\tIsolate *isolate;\n\tIsolate::CreateParams params;\n\tparams.array_buffer_allocator = new ArrayAllocator(plv8_memory_limit * 1_MB);\n\t//params.array_buffer_allocator =\n  //    v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n\tResourceConstraints rc;\n\trc.ConfigureDefaults(plv8_memory_limit * 1_MB * 2, plv8_memory_limit * 1_MB * 2);\n\tparams.constraints = rc;\n\tisolate = Isolate::New(params);\n\tisolate->SetOOMErrorHandler(OOMErrorHandler);\n\tisolate->AddGCEpilogueCallback(GCEpilogueCallback);\n\tisolate->AddNearHeapLimitCallback(NearHeapLimitHandler, NULL);\n\tisolate->SetPromiseRejectCallback(PromiseRejectCB);\n\tcontext->isolate = isolate;\n\tcontext->array_buffer_allocator = params.array_buffer_allocator;\n}\n\nvoid\n_PG_init(void)\n{\n\tHASHCTL    hash_ctl = { 0 };\n\n\thash_ctl.keysize = sizeof(Oid);\n\thash_ctl.entrysize = sizeof(plv8_proc_cache);\n\thash_ctl.hash = oid_hash;\n\tplv8_proc_cache_hash = hash_create(\"PLv8 Procedures\", 32,\n\t\t\t\t\t\t\t\t\t   &hash_ctl, HASH_ELEM | HASH_FUNCTION);\n\n    config_generic *guc_value;\n\n#define START_PROC_VAR \"plv8.start_proc\"\n    guc_value = plv8_find_option(START_PROC_VAR);\n    if (guc_value != NULL) {\n        plv8_start_proc = plv8_string_option(guc_value);\n    } else {\n        DefineCustomStringVariable(START_PROC_VAR,\n                                   gettext_noop(\"PLV8 function to run once when PLV8 is first used.\"),\n                                   NULL,\n                                   &plv8_start_proc,\n                                   NULL,\n                                   PGC_USERSET, 0,\n#if PG_VERSION_NUM >= 90100\n                                   NULL,\n#endif\n                                   NULL,\n                                   NULL);\n    }\n#undef START_PROC_VAR\n\n#define ICU_DATA_VAR \"plv8.icu_data\"\n    guc_value = plv8_find_option(ICU_DATA_VAR);\n    if (guc_value != NULL) {\n        plv8_start_proc = plv8_string_option(guc_value);\n    } else {\n        DefineCustomStringVariable(ICU_DATA_VAR,\n                                   gettext_noop(\"ICU data file directory.\"),\n                                   NULL,\n                                   &plv8_icu_data,\n                                   NULL,\n                                   PGC_USERSET, 0,\n#if PG_VERSION_NUM >= 90100\n                                   NULL,\n#endif\n                                   NULL,\n                                   NULL);\n    }\n#undef ICU_DATA_VAR\n\n#define V8_FLAGS_VAR \"plv8.v8_flags\"\n    guc_value = plv8_find_option(V8_FLAGS_VAR);\n    if (guc_value != NULL) {\n        plv8_start_proc = plv8_string_option(guc_value);\n    } else {\n        DefineCustomStringVariable(V8_FLAGS_VAR,\n                                   gettext_noop(\"V8 engine initialization flags (e.g. --harmony for all current harmony features).\"),\n                                   NULL,\n                                   &plv8_v8_flags,\n                                   NULL,\n                                   PGC_USERSET, 0,\n#if PG_VERSION_NUM >= 90100\n                                   NULL,\n#endif\n                                   NULL,\n                                   NULL);\n    }\n#undef V8_FLAGS_VAR\n\n#define DEBUGGER_PORT_VAR \"plv8.debugger_port\"\n    guc_value = plv8_find_option(DEBUGGER_PORT_VAR);\n    if (guc_value != NULL) {\n        plv8_debugger_port = plv8_int_option(guc_value);\n    } else {\n        DefineCustomIntVariable(DEBUGGER_PORT_VAR,\n                                gettext_noop(\"V8 remote debug port.\"),\n                                gettext_noop(\"The default value is 35432.  \"\n                                             \"This is effective only if PLV8 is built with ENABLE_DEBUGGER_SUPPORT.\"),\n                                &plv8_debugger_port,\n                                35432, 0, 65536,\n                                PGC_USERSET, 0,\n#if PG_VERSION_NUM >= 90100\n                                NULL,\n#endif\n                                NULL,\n                                NULL);\n    }\n#undef DEBUGGER_PORT_VAR\n\n#ifdef EXECUTION_TIMEOUT\n#define EXECUTION_TIMEOUT_VAR \"plv8.execution_timeout\"\n\tguc_value = plv8_find_option(EXECUTION_TIMEOUT_VAR);\n\tif (guc_value != NULL) {\n\t\tplv8_execution_timeout = plv8_int_option(guc_value);\n\t} else {\n        DefineCustomIntVariable(EXECUTION_TIMEOUT_VAR,\n                                gettext_noop(\"V8 execution timeout.\"),\n                                gettext_noop(\"The default value is 300 seconds.  \"\n                                             \"This allows you to override the default execution timeout.\"),\n                                &plv8_execution_timeout,\n                                300, 1, 65536,\n                                PGC_USERSET, 0,\n#if PG_VERSION_NUM >= 90100\n                                NULL,\n#endif\n                                NULL,\n                                NULL);\n    }\n#undef EXECUTION_TIMEOUT_VAR\n#endif\n\n#define MEMORY_LIMIT_VAR \"plv8.memory_limit\"\n    guc_value = plv8_find_option(MEMORY_LIMIT_VAR);\n    if (guc_value != NULL) {\n        plv8_memory_limit = plv8_int_option(guc_value);\n    } else {\n        DefineCustomIntVariable(MEMORY_LIMIT_VAR,\n                                gettext_noop(\"Per-isolate memory limit in MBytes\"),\n                                gettext_noop(\"The default value is 256 MB\"),\n                                (int *) &plv8_memory_limit,\n                                256, 256, 3096, // hardcoded v8 limits for isolates\n                                PGC_SUSET, 0,\n#if PG_VERSION_NUM >= 90100\n                                NULL,\n#endif\n                                NULL,\n                                NULL);\n    }\n#undef MEMORY_LIMIT_VAR\n\n\tRegisterXactCallback(plv8_xact_cb, NULL);\n\n\tEmitWarningsOnPlaceholders(\"plv8\");\n\n\tif (plv8_icu_data == NULL) {\n\t\telog(DEBUG1, \"no icu dir\");\n\t\tV8::InitializeICU();\n\t} else {\n\t\telog(DEBUG1, \"init icu data %s\", plv8_icu_data);\n\t\tV8::InitializeICU(plv8_icu_data);\n\t}\n\n#if (V8_MAJOR_VERSION == 4 && V8_MINOR_VERSION >= 6) || V8_MAJOR_VERSION >= 5\n\tV8::InitializeExternalStartupData(\"plv8\");\n#endif\n\tif (!v8_platform) {\n\t\tv8_platform = platform::NewDefaultPlatform();\n\t}\n\n\tif (plv8_v8_flags != NULL) {\n\t\tV8::SetFlagsFromString(plv8_v8_flags);\n\t}\n\n\tV8::InitializePlatform(v8_platform.get());\n\n\tV8::Initialize();\n}\n\nstatic void\nplv8_xact_cb(XactEvent event, void *arg)\n{\n\tplv8_exec_env\t   *env = exec_env_head;\n\n\twhile (env)\n\t{\n\t\tif (!env->recv.IsEmpty())\n\t\t{\n\t\t\tenv->recv.Reset();\n\t\t}\n\t\tenv = env->next;\n\t\t/*\n\t\t * Each item was allocated in TopTransactionContext, so\n\t\t * it will be freed eventually.\n\t\t */\n\t}\n\texec_env_head = NULL;\n}\n\nstatic inline plv8_exec_env *\nplv8_new_exec_env(Isolate *isolate)\n{\n\tplv8_exec_env\t   *xenv = (plv8_exec_env *)\n\t\tMemoryContextAllocZero(TopTransactionContext, sizeof(plv8_exec_env));\n\n\tnew(&xenv->context) Persistent<Context>();\n\tnew(&xenv->recv) Persistent<Object>();\n\txenv->isolate = isolate;\n\n\t/*\n\t * Add it to the list, which will be freed in the end of top transaction.\n\t */\n\txenv->next = exec_env_head;\n\texec_env_head = xenv;\n\n\treturn xenv;\n}\n\nDatum\nplv8_call_handler(PG_FUNCTION_ARGS)\n{\n\tcurrent_context = GetPlv8Context();\n\tOid\t\tfn_oid = fcinfo->flinfo->fn_oid;\n\tbool\tis_trigger = CALLED_AS_TRIGGER(fcinfo);\n\n\ttry\n\t{\n#ifdef ENABLE_DEBUGGER_SUPPORT\n\t\tLocker\t\t\t\tlock;\n#endif  // ENABLE_DEBUGGER_SUPPORT\n\t\tIsolate::Scope\tscope(current_context->isolate);\n\t\tHandleScope\thandle_scope(current_context->isolate);\n\n\t\tif (!fcinfo->flinfo->fn_extra)\n\t\t{\n\t\t\tplv8_proc\t   *proc = Compile(fn_oid, fcinfo,\n\t\t\t\t\t\t\t\t\t\t   false, is_trigger);\n\t\t\tproc->xenv = CreateExecEnv(proc->cache->function, current_context);\n\t\t\tfcinfo->flinfo->fn_extra = proc;\n\t\t}\n\n\t\tplv8_proc *proc = (plv8_proc *) fcinfo->flinfo->fn_extra;\n\t\tplv8_proc_cache *cache = proc->cache;\n\n\t\tif (is_trigger)\n\t\t\treturn CallTrigger(fcinfo, proc->xenv);\n\t\telse if (cache->retset)\n\t\t\treturn CallSRFunction(fcinfo, proc->xenv,\n\t\t\t\t\t\tcache->nargs, proc->argtypes, &proc->rettype);\n\t\telse\n\t\t\treturn CallFunction(fcinfo, proc->xenv,\n\t\t\t\t\t\tcache->nargs, proc->argtypes, &proc->rettype);\n\t}\n\tcatch (js_error& e)\t{ e.rethrow(); }\n\tcatch (pg_error& e)\t{ e.rethrow(); }\n\n\treturn (Datum) 0;\t// keep compiler quiet\n}\n\n\nstatic void killPlv8Context(plv8_context *ctx) {\n\tHASH_SEQ_STATUS\t\tstatus;\n\tplv8_proc_cache*\tcache;\n\n\t// need to search and reset all the user functions which were created in the old context\n\thash_seq_init(&status, plv8_proc_cache_hash);\n\tcache = (plv8_proc_cache *) hash_seq_search(&status);\n\twhile (cache != nullptr) {\n\t\tif (cache->user_id == ctx->user_id) {\n\t\t\tif (cache->prosrc)\n\t\t\t{\n\t\t\t\tpfree(cache->prosrc);\n\t\t\t\tcache->prosrc = NULL;\n\t\t\t}\n\t\t\tcache->function.Reset();\n\t\t}\n\t\tcache = (plv8_proc_cache *) hash_seq_search(&status);\n\t}\n\tctx->isolate->Dispose();\n\tdelete ctx->array_buffer_allocator;\n}\n\nDatum\nplv8_reset(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\t\t\tuser_id = GetUserId();\n\tunsigned long\t\ti;\n\n\tfor (i = 0; i < ContextVector.size(); i++)\n\t{\n\t\tif (ContextVector[i]->user_id == user_id)\n\t\t{\n\t\t\tplv8_context * context = ContextVector[i];\n\t\t\tContextVector.erase(ContextVector.begin() + i);\n\t\t\tkillPlv8Context(context);\n\t\t\tpfree(context);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (Datum) 0;\n}\n\nDatum\nplv8_info(PG_FUNCTION_ARGS)\n{\n\tunsigned long\t\ti;\n\tunsigned long \t\tsize = ContextVector.size();\n\tchar \t\t\t\t**infos = nullptr;\n\tsize_t \t\t\t\t*lengths = nullptr;\n\tsize_t \t\t\t\ttotal_length = 3; // length of \"[]\\0\"\n\n\tMemoryContext execution_context, old_context;\n\n\tif (size == 0)\n\t{\n\t\tPG_RETURN_NULL();\n\t}\n\n#if PG_VERSION_NUM < 110000\n        execution_context = AllocSetContextCreate(\n                                                CurrentMemoryContext,\n                                                \"plv8_info Context\",\n                                                ALLOCSET_SMALL_MINSIZE,\n                                                ALLOCSET_SMALL_INITSIZE,\n                                                ALLOCSET_SMALL_MAXSIZE);\n#else\n        execution_context = AllocSetContextCreate(CurrentMemoryContext,\n                                                \"plv8_info Context\",\n                                                ALLOCSET_SMALL_SIZES);\n#endif\n\n\told_context = MemoryContextSwitchTo(execution_context);\n\n\tinfos = (char **) palloc(sizeof(char *) * size);\n\tlengths = (size_t *) palloc(sizeof(size_t) * size);\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tIsolate \t   \t   *isolate = ContextVector[i]->isolate;\n\t\tIsolate::Scope\t\tscope(isolate);\n\t\tHandleScope\t\t\thandle_scope(isolate);\n\t\tLocal<Context>\t\tcontext = ContextVector[i]->localContext();\n\t\tContext::Scope\t\tcontext_scope(context);\n\t\tJSONObject \t\t\tJSON;\n\t\tLocal<v8::Value>\tresult;\n\t\tLocal<v8::Object>   obj = v8::Object::New(isolate);\n\n#if PG_VERSION_NUM >= 90500\n\t\tchar \t\t\t   *username = GetUserNameFromId(ContextVector[i]->user_id, false);\n#else\n\t\tchar \t\t\t   *username = GetUserNameFromId(ContextVector[i]->user_id);\n#endif\n\t\tobj->Set(context, v8::String::NewFromUtf8Literal(isolate, \"user\"),\n           v8::String::NewFromUtf8(isolate, username).ToLocalChecked()).Check();\n\t\tGetMemoryInfo(obj);\n\n\t\tresult = JSON.Stringify(obj);\n\t\tCString str(result);\n\n\t\tinfos[i] = pstrdup(str.str());\n\t\tlengths[i] = strlen(infos[i]);\n\t\ttotal_length += lengths[i] + 1; // add 1 byte for ','\n\t}\n\n\tchar *out = (char *) palloc0(total_length);\n\tout[0] = '[';\n\tsize_t current = 0;\n\tfor (i = 0; i < size; i++)\n\t{\n\t\t++current;\n\t\tstrcpy(out + current, infos[i]);\n\t\tcurrent += lengths[i];\n\t\tif (i != size - 1)\n\t\t{\n\t\t\tout[current] = ',';\n\t\t}\n\t}\n\n\tout[current] = ']';\n\tout[current + 1] = '\\0';\n\n\tMemoryContextSwitchTo(old_context);\n\n\treturn CStringGetTextDatum(out);\n}\n\n#if PG_VERSION_NUM >= 90000\nDatum\nplv8_inline_handler(PG_FUNCTION_ARGS)\n{\n\tInlineCodeBlock *codeblock = (InlineCodeBlock *) DatumGetPointer(PG_GETARG_DATUM(0));\n\n\tAssert(IsA(codeblock, InlineCodeBlock));\n\n\ttry\n\t{\n#ifdef ENABLE_DEBUGGER_SUPPORT\n\t\tLocker\t\t\t\tlock;\n#endif  // ENABLE_DEBUGGER_SUPPORT\n\t\tcurrent_context = GetPlv8Context();\n\t\tIsolate::Scope\t\tscope(current_context->isolate);\n\t\tHandleScope\t\t\thandle_scope(current_context->isolate);\n\t\tchar\t\t\t   *source_text = codeblock->source_text;\n\t\tPersistent<Context> global_context;\n\t\tglobal_context.Reset(current_context->isolate, current_context->context);\n\n\t\tLocal<Function>\tfunction = CompileFunction(current_context,\n\t\t\t\t\t\t\t\t\t\tNULL, 0, NULL,\n\t\t\t\t\t\t\t\t\t\tsource_text, false, false);\n\t\tplv8_exec_env\t   *xenv = CreateExecEnv(function, current_context);\n\t\treturn CallFunction(fcinfo, xenv, 0, NULL, NULL);\n\t}\n\tcatch (js_error& e)\t{ e.rethrow(); }\n\tcatch (pg_error& e)\t{ e.rethrow(); }\n\n\treturn (Datum) 0;\t// keep compiler quiet\n}\n\n#endif\n\n#ifdef EXECUTION_TIMEOUT\n/*\n * Breakout -- break out of a Call, with a thread\n *\n * This function breaks out of a javascript execution context.\n */\n#ifdef _MSC_VER // windows\nDWORD WINAPI\nBreakout (LPVOID lpParam)\n{\n\tIsolate *isolate = (Isolate *) lpParam;\n\tSleep(plv8_execution_timeout * 1000);\n\tisolate->TerminateExecution();\n\n\treturn 0;\n}\n#else // posix\nvoid *\nBreakout (void *d)\n{\n\tauto *isolate = (Isolate *) d;\n\tsleep(plv8_execution_timeout);\n\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n\tisolate->TerminateExecution();\n\n\treturn NULL;\n}\n#endif\n#endif\nvoid *int_handler = NULL;\nvoid *term_handler = NULL;\nvoid *abt_handler = NULL;\n\n/*\n * signal handler\n *\n * This function kills the execution of the v8 process if a signal is called\n */\nvoid\nsignal_handler (int sig) {\n\telog(DEBUG1, \"cancelling execution\");\n\tauto running_context = GetPlv8Context();\n\trunning_context->interrupted = true;\n\trunning_context->isolate->TerminateExecution();\n\n\t// call the old handler if it exists\n\tswitch(sig) {\n\t\tcase SIGINT:\n\t\t\tif (int_handler != NULL) {\n\t\t\t\t((void (*)(int)) int_handler)(sig);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIGTERM:\n\t\t\tif (term_handler != NULL) {\n\t\t\t\t((void (*)(int)) term_handler)(sig);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIGABRT:\n\t\t\tif (abt_handler != NULL) {\n\t\t\t\t((void (*)(int)) abt_handler)(sig);\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\n/*\n * DoCall -- Call a JS function with SPI support.\n *\n * This function could throw C++ exceptions, but must not throw PG exceptions.\n */\nstatic Local<v8::Value>\nDoCall(Local<Context> ctx, Handle<Function> fn, Handle<Object> receiver,\n\tint nargs, Handle<v8::Value> args[], bool nonatomic)\n{\n\tIsolate \t   *isolate = ctx->GetIsolate();\n\tTryCatch\t\ttry_catch(isolate);\n\n\tif (isolate->IsExecutionTerminating() || current_context->interrupted) {\n\t\tisolate->CancelTerminateExecution();\n\t\tif (current_context->interrupted) {\n\t\t\tcurrent_context->interrupted = false;\n\t\t}\n\t}\n\n#if PG_VERSION_NUM >= 110000\n\tif (SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0) != SPI_OK_CONNECT)\n\t\tthrow js_error(\"could not connect to SPI manager\");\n#else\n\tif (SPI_connect() != SPI_OK_CONNECT)\n\t\tthrow js_error(\"could not connect to SPI manager\");\n#endif\n\n\t// set up the signal handlers\n\tif (int_handler == NULL) {\n\t\tint_handler = (void *) signal(SIGINT, signal_handler);\n\t}\n\n\tif (term_handler == NULL) {\n\t\tterm_handler = (void *) signal(SIGTERM, signal_handler);\n\t}\n\n\tif (abt_handler == NULL) {\n\t\tabt_handler = (void *) signal(SIGABRT, signal_handler);\n\t}\n\n#ifdef EXECUTION_TIMEOUT\n\tbool timeout = false;\n#ifdef _MSC_VER // windows\n\tHANDLE  hThread;\n\tDWORD dwThreadId;\n\thThread = CreateThread(NULL, 0, Breakout, isolate, 0, &dwThreadId);\n#else\n\tpthread_t breakout_thread;\n\t// set up the thread to break out the execution if needed\n\tpthread_create(&breakout_thread, NULL, Breakout, isolate);\n#endif\n#endif\n\n\ttry {\n\tMaybeLocal<v8::Value> result = fn->Call(ctx, receiver, nargs, args);\n\tint\tstatus = SPI_finish();\n\n#ifdef EXECUTION_TIMEOUT\n#ifdef _MSC_VER\n\tif (TerminateThread(hThread, NULL) == 0) {\n\t\ttimeout = true;\n\t}\n#else\n\tvoid *thread_result;\n\tpthread_cancel(breakout_thread);\n\tpthread_join(breakout_thread, &thread_result);\n\tif (thread_result == NULL) {\n\t\ttimeout = true;\n\t}\n#endif\n#endif\n\n\t// reset signal handlers\n\tsignal(SIGINT, (void (*)(int)) int_handler);\n\tsignal(SIGTERM, (void (*)(int)) term_handler);\n\tsignal(SIGABRT, (void (*)(int)) abt_handler);\n\n\tHandleUnhandledPromiseRejections();\n\n\tif (result.IsEmpty()) {\n\t\tif (isolate->IsExecutionTerminating() || current_context->interrupted) {\n\t\t\tisolate->CancelTerminateExecution();\n\t\t\tif (current_context->interrupted) {\n\t\t\t\tcurrent_context->interrupted = false;\n\t\t\t\tthrow js_error(\"Signal caught: interrupted\");\n\t\t\t}\n#ifdef EXECUTION_TIMEOUT\n\t\t\tif (timeout) {\n\t\t\t\tthrow js_error(\"execution timeout exceeded\");\n\t\t\t}\n#endif\n\t\t\tthrow js_error(\"Out of memory error\");\n\t\t}\n\t\tthrow js_error(try_catch);\n\t}\n\n\tif (status < 0)\n\t\tthrow js_error(FormatSPIStatus(status));\n\n\treturn result.ToLocalChecked();\n\t} catch (int err) {\n\t\telog(NOTICE, \"Error caught\");\n\t}\n\n\treturn Local<v8::Value>::New(isolate, Null(isolate));\n}\n\nstatic Datum\nCallFunction(PG_FUNCTION_ARGS, plv8_exec_env *xenv,\n\tint nargs, plv8_type argtypes[], plv8_type *rettype)\n{\n\tLocal<Context>\t\tcontext = xenv->localContext();\n\tContext::Scope\t\tcontext_scope(context);\n\tHandle<v8::Value>\targs[FUNC_MAX_ARGS];\n\n#if PG_VERSION_NUM >= 110000\n\tbool nonatomic = fcinfo->context &&\n\t\tIsA(fcinfo->context, CallContext) &&\n\t\t!castNode(CallContext, fcinfo->context)->atomic;\n#else\n  bool nonatomic = false;\n#endif\n\n\tWindowFunctionSupport support(context, fcinfo);\n\n\t/*\n\t * In window function case, we cannot see the argument datum\n\t * in fcinfo.  Instead, get them by WinGetFuncArgCurrent().\n\t */\n\tif (support.IsWindowCall())\n\t{\n\t\tWindowObject winobj = support.GetWindowObject();\n\t\tfor (int i = 0; i < nargs; i++)\n\t\t{\n\t\t\tbool isnull;\n\t\t\tDatum arg = WinGetFuncArgCurrent(winobj, i, &isnull);\n\t\t\targs[i] = ToValue(arg, isnull, &argtypes[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < nargs; i++) {\n#if PG_VERSION_NUM < 120000\n\t\t\targs[i] = ToValue(fcinfo->arg[i], fcinfo->argnull[i], &argtypes[i]);\n#else\n\t\t\targs[i] = ToValue(fcinfo->args[i].value, fcinfo->args[i].isnull, &argtypes[i]);\n#endif\n\t\t}\n\t}\n\n\tLocal<Object> recv = Local<Object>::New(xenv->isolate, xenv->recv);\n\tLocal<Function>\t\tfn =\n\t\tLocal<Function>::Cast(recv->GetInternalField(0));\n\t\n\tLocal<v8::Value> result =\n\t\tDoCall(context, fn, recv, nargs, args, nonatomic);\n\n\tif (rettype)\n\t\treturn ToDatum(result, &fcinfo->isnull, rettype);\n\telse\n\t\tPG_RETURN_VOID();\n}\n\nstatic Tuplestorestate *\nCreateTupleStore(PG_FUNCTION_ARGS, TupleDesc *tupdesc)\n{\n\tTuplestorestate\t   *tupstore;\n\n\tPG_TRY();\n\t{\n\t\tReturnSetInfo  *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo;\n\t\tMemoryContext\tper_query_ctx;\n\t\tMemoryContext\toldcontext;\n\t\tplv8_proc\t   *proc = (plv8_proc *) fcinfo->flinfo->fn_extra;\n\n\t\t/* check to see if caller supports us returning a tuplestore */\n\t\tif (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"set-valued function called in context that cannot accept a set\")));\n\t\tif (!(rsinfo->allowedModes & SFRM_Materialize))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"materialize mode required, but it is not \" \\\n\t\t\t\t\t\t\t\"allowed in this context\")));\n\n\t\tif (!proc->functypclass)\n\t\t\tproc->functypclass = get_call_result_type(fcinfo, NULL, NULL);\n\n\t\tper_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\n\t\toldcontext = MemoryContextSwitchTo(per_query_ctx);\n\n\t\ttupstore = tuplestore_begin_heap(true, false, work_mem);\n\t\trsinfo->returnMode = SFRM_Materialize;\n\t\trsinfo->setResult = tupstore;\n\t\t/* Build a tuple descriptor for our result type */\n\t\tif (proc->rettype.typid == RECORDOID)\n\t\t{\n\t\t\tif (proc->functypclass != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\")));\n\t\t}\n\t\tif (!rsinfo->setDesc)\n\t\t{\n\t\t\t*tupdesc = CreateTupleDescCopy(rsinfo->expectedDesc);\n\t\t\trsinfo->setDesc = *tupdesc;\n\t\t}\n\t\telse\n\t\t\t*tupdesc = rsinfo->setDesc;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\treturn tupstore;\n}\n\nstatic Datum\nCallSRFunction(PG_FUNCTION_ARGS, plv8_exec_env *xenv,\n\tint nargs, plv8_type argtypes[], plv8_type *rettype)\n{\n\tplv8_proc\t\t   *proc = (plv8_proc *) fcinfo->flinfo->fn_extra;\n\tTupleDesc\t\t\ttupdesc;\n\tTuplestorestate\t   *tupstore;\n\n#if PG_VERSION_NUM >= 110000\n\tbool nonatomic = fcinfo->context &&\n\t\tIsA(fcinfo->context, CallContext) &&\n\t\t!castNode(CallContext, fcinfo->context)->atomic;\n#else\n  bool nonatomic = false;\n#endif\n\n\ttupstore = CreateTupleStore(fcinfo, &tupdesc);\n\n\tHandle<Context>\t\tcontext = xenv->localContext();\n\tContext::Scope\t\tcontext_scope(context);\n\tConverter\t\t\tconv(tupdesc, proc->functypclass == TYPEFUNC_SCALAR);\n\tHandle<v8::Value>\targs[FUNC_MAX_ARGS + 1];\n\n\t/*\n\t * In case this is nested via SPI, stash pre-registered converters\n\t * for the previous SRF.\n\t */\n\tSRFSupport support(context, &conv, tupstore);\n\n\tfor (int i = 0; i < nargs; i++) {\n#if PG_VERSION_NUM < 120000\n\t\targs[i] = ToValue(fcinfo->arg[i], fcinfo->argnull[i], &argtypes[i]);\n#else\n\t\targs[i] = ToValue(fcinfo->args[i].value, fcinfo->args[i].isnull, &argtypes[i]);\n#endif\n\t}\n\n\tLocal<Object> recv = Local<Object>::New(xenv->isolate, xenv->recv);\n\tLocal<Function>\t\tfn =\n\t\tLocal<Function>::Cast(recv->GetInternalField(0));\n\n\tHandle<v8::Value> result = DoCall(context, fn, recv, nargs, args, nonatomic);\n\n\tif (result->IsUndefined())\n\t{\n\t\t// no additional values\n\t}\n\telse if (result->IsArray())\n\t{\n\t\tHandle<Array> array = Handle<Array>::Cast(result);\n\t\t// return an array of records.\n\t\tint\tlength = array->Length();\n\t\tfor (int i = 0; i < length; i++)\n\t\t\tconv.ToDatum(array->Get(context, i).ToLocalChecked(), tupstore);\n\t}\n\telse\n\t{\n\t\t// return a record or a scalar\n\t\tconv.ToDatum(result, tupstore);\n\t}\n\n\treturn (Datum) 0;\n}\n\nstatic Datum\nCallTrigger(PG_FUNCTION_ARGS, plv8_exec_env *xenv)\n{\n\t// trigger arguments are:\n\t//\t0: NEW\n\t//\t1: OLD\n\t//\t2: TG_NAME\n\t//\t3: TG_WHEN\n\t//\t4: TG_LEVEL\n\t//\t5: TG_OP\n\t//\t6: TG_RELID\n\t//\t7: TG_TABLE_NAME\n\t//\t8: TG_TABLE_SCHEMA\n\t//\t9: TG_ARGV\n\tTriggerData\t\t   *trig = (TriggerData *) fcinfo->context;\n\tRelation\t\t\trel = trig->tg_relation;\n\tTriggerEvent\t\tevent = trig->tg_event;\n\tHandle<v8::Value>\targs[10];\n\tDatum\t\t\t\tresult = (Datum) 0;\n\n#if PG_VERSION_NUM >= 110000\n\tbool nonatomic = fcinfo->context &&\n\t\tIsA(fcinfo->context, CallContext) &&\n\t\t!castNode(CallContext, fcinfo->context)->atomic;\n#else\n  bool nonatomic = false;\n#endif\n\n\tHandle<Context>\t\tcontext = xenv->localContext();\n\tContext::Scope\t\tcontext_scope(context);\n\n\tif (TRIGGER_FIRED_FOR_ROW(event))\n\t{\n\t\tTupleDesc\t\ttupdesc = RelationGetDescr(rel);\n\t\tConverter\t\tconv(tupdesc);\n\n\t\tif (TRIGGER_FIRED_BY_INSERT(event))\n\t\t{\n\t\t\tresult = PointerGetDatum(trig->tg_trigtuple);\n\t\t\t// NEW\n\t\t\targs[0] = conv.ToValue(trig->tg_trigtuple);\n\t\t\t// OLD\n\t\t\targs[1] = Undefined(xenv->isolate);\n\t\t}\n\t\telse if (TRIGGER_FIRED_BY_DELETE(event))\n\t\t{\n\t\t\tresult = PointerGetDatum(trig->tg_trigtuple);\n\t\t\t// NEW\n\t\t\targs[0] = Undefined(xenv->isolate);\n\t\t\t// OLD\n\t\t\targs[1] = conv.ToValue(trig->tg_trigtuple);\n\t\t}\n\t\telse if (TRIGGER_FIRED_BY_UPDATE(event))\n\t\t{\n\t\t\tresult = PointerGetDatum(trig->tg_newtuple);\n\t\t\t// NEW\n\t\t\targs[0] = conv.ToValue(trig->tg_newtuple);\n\t\t\t// OLD\n\t\t\targs[1] = conv.ToValue(trig->tg_trigtuple);\n\t\t}\n\t}\n\telse\n\t{\n\t\targs[0] = args[1] = Undefined(xenv->isolate);\n\t}\n\n\t// 2: TG_NAME\n\targs[2] = ToString(trig->tg_trigger->tgname);\n\n\t// 3: TG_WHEN\n\tif (TRIGGER_FIRED_BEFORE(event))\n\t\targs[3] = v8::String::NewFromUtf8Literal(xenv->isolate, \"BEFORE\");\n\telse\n\t\targs[3] = v8::String::NewFromUtf8Literal(xenv->isolate, \"AFTER\");\n\n\t// 4: TG_LEVEL\n\tif (TRIGGER_FIRED_FOR_ROW(event))\n\t\targs[4] = v8::String::NewFromUtf8Literal(xenv->isolate, \"ROW\");\n\telse\n\t\targs[4] = v8::String::NewFromUtf8Literal(xenv->isolate, \"STATEMENT\");\n\n\t// 5: TG_OP\n\tif (TRIGGER_FIRED_BY_INSERT(event))\n\t\targs[5] = v8::String::NewFromUtf8Literal(xenv->isolate, \"INSERT\");\n\telse if (TRIGGER_FIRED_BY_DELETE(event))\n\t\targs[5] = v8::String::NewFromUtf8Literal(xenv->isolate, \"DELETE\");\n\telse if (TRIGGER_FIRED_BY_UPDATE(event))\n\t\targs[5] = v8::String::NewFromUtf8Literal(xenv->isolate, \"UPDATE\");\n#ifdef TRIGGER_FIRED_BY_TRUNCATE\n\telse if (TRIGGER_FIRED_BY_TRUNCATE(event))\n\t\targs[5] = v8::String::NewFromUtf8Literal(xenv->isolate, \"TRUNCATE\");\n#endif\n\telse\n\t\targs[5] = v8::String::NewFromUtf8Literal(xenv->isolate, \"?\");\n\n\t// 6: TG_RELID\n\targs[6] = Uint32::New(xenv->isolate, RelationGetRelid(rel));\n\n\t// 7: TG_TABLE_NAME\n\targs[7] = ToString(RelationGetRelationName(rel));\n\n\t// 8: TG_TABLE_SCHEMA\n\targs[8] = ToString(get_namespace_name(RelationGetNamespace(rel)));\n\n\t// 9: TG_ARGV\n\tHandle<Array> tgargs = Array::New(xenv->isolate, trig->tg_trigger->tgnargs);\n\tfor (int i = 0; i < trig->tg_trigger->tgnargs; i++)\n\t\ttgargs->Set(context, i, ToString(trig->tg_trigger->tgargs[i])).Check();\n\targs[9] = tgargs;\n\n\tTryCatch\t\t\ttry_catch(xenv->isolate);\n\tLocal<Object> recv = Local<Object>::New(xenv->isolate, xenv->recv);\n\tLocal<Function>\t\tfn =\n\t\tLocal<Function>::Cast(recv->GetInternalField(0));\n\tHandle<v8::Value> newtup =\n\t\tDoCall(context, fn, recv, lengthof(args), args, nonatomic);\n\n\tif (newtup.IsEmpty())\n\t\tthrow js_error(try_catch);\n\n\t/*\n\t * If the function specifically returned null, return NULL to\n\t * tell executor to skip the operation.  Otherwise, the function\n\t * result is the tuple to be returned.\n\t */\n\tif (newtup->IsNull() || !TRIGGER_FIRED_FOR_ROW(event))\n\t{\n\t\tresult = PointerGetDatum(NULL);\n\t}\n\telse if (!newtup->IsUndefined())\n\t{\n\t\tTupleDesc\t\ttupdesc = RelationGetDescr(rel);\n\t\tConverter\t\tconv(tupdesc);\n\t\tHeapTupleHeader\theader;\n\n\t\theader = DatumGetHeapTupleHeader(conv.ToDatum(newtup));\n\n\t\t/* We know it's there; heap_form_tuple stores with this layout. */\n\t\tresult = PointerGetDatum((char *) header - HEAPTUPLESIZE);\n\t}\n\n\treturn result;\n}\n\nDatum\nplv8_call_validator(PG_FUNCTION_ARGS)\n{\n\tcurrent_context = GetPlv8Context();\n\tOid\t\t\t\tfn_oid = PG_GETARG_OID(0);\n\tHeapTuple\t\ttuple;\n\tForm_pg_proc\tproc;\n\tchar\t\t\tfunctyptype;\n\tbool\t\t\tis_trigger = false;\n\tIsolate::Scope  scope(current_context->isolate);\n\n\tif (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, fn_oid))\n\t\tPG_RETURN_VOID();\n\n\t/* Get the new function's pg_proc entry */\n\ttuple = SearchSysCache(PROCOID, ObjectIdGetDatum(fn_oid), 0, 0, 0);\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", fn_oid);\n\tproc = (Form_pg_proc) GETSTRUCT(tuple);\n\n\tfunctyptype = get_typtype(proc->prorettype);\n\n\t/* Disallow pseudotype result */\n\t/* except for TRIGGER, RECORD, INTERNAL, VOID or polymorphic types */\n\tif (functyptype == TYPTYPE_PSEUDO)\n\t{\n#if PG_VERSION_NUM >= 130000\n                if (proc->prorettype == TRIGGEROID)\n#else\n                /* we assume OPAQUE with no arguments means a trigger */\n                if (proc->prorettype == TRIGGEROID ||\n                        (proc->prorettype == OPAQUEOID && proc->pronargs == 0))\n#endif\n\t\t\tis_trigger = true;\n\t\telse if (proc->prorettype != RECORDOID &&\n\t\t\tproc->prorettype != VOIDOID &&\n\t\t\tproc->prorettype != INTERNALOID &&\n\t\t\t!IsPolymorphicType(proc->prorettype))\n\t\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"PL/v8 functions cannot return type %s\",\n\t\t\t\t\t\tformat_type_be(proc->prorettype))));\n\t}\n\n\tReleaseSysCache(tuple);\n\n\ttry\n\t{\n#ifdef ENABLE_DEBUGGER_SUPPORT\n\t\tLocker\t\t\t\tlock;\n#endif  // ENABLE_DEBUGGER_SUPPORT\n\t\t/* Don't use validator's fcinfo */\n\t\tplv8_proc\t   *proc = Compile(fn_oid, NULL,\n\t\t\t\t\t\t\t\t\t   true, is_trigger);\n\t\t(void) CreateExecEnv(proc->cache->function, current_context);\n\t\t/* the result of a validator is ignored */\n\t\tPG_RETURN_VOID();\n\t}\n\tcatch (js_error& e)\t{ e.rethrow(); }\n\tcatch (pg_error& e)\t{ e.rethrow(); }\n\n\treturn (Datum) 0;\t// keep compiler quiet\n}\n\nstatic plv8_proc *\nplv8_get_proc(Oid fn_oid, FunctionCallInfo fcinfo, bool validate, char ***argnames) throw()\n{\n\tHeapTuple\t\t\tprocTup;\n\tplv8_proc_cache\t   *cache;\n\tbool\t\t\t\tfound;\n\tbool\t\t\t\tisnull;\n\tDatum\t\t\t\tprosrc;\n\tOid\t\t\t\t   *argtypes;\n\tchar\t\t\t   *argmodes;\n\tMemoryContext\t\toldcontext;\n\n\tprocTup = SearchSysCache(PROCOID, ObjectIdGetDatum(fn_oid), 0, 0, 0);\n\tif (!HeapTupleIsValid(procTup))\n\t\telog(ERROR, \"cache lookup failed for function %u\", fn_oid);\n\n\tcache = (plv8_proc_cache *)\n\t\thash_search(plv8_proc_cache_hash,&fn_oid, HASH_ENTER, &found);\n\n\tif (found)\n\t{\n\t\tbool\tuptodate;\n\n\t\t/*\n\t\t * We need to check user id and dispose it if it's different from\n\t\t * the previous cache user id, as the V8 function is associated\n\t\t * with the context where it was generated.  In most cases,\n\t\t * we can expect this doesn't affect runtime performance.\n\t\t */\n\t\tuptodate = (!cache->function.IsEmpty() &&\n\t\t\tcache->fn_xmin == HeapTupleHeaderGetXmin(procTup->t_data) &&\n\t\t\tItemPointerEquals(&cache->fn_tid, &procTup->t_self) &&\n\t\t\tcache->user_id == GetUserId());\n\n\t\tif (!uptodate)\n\t\t{\n\t\t\tif (cache->prosrc)\n\t\t\t{\n\t\t\t\tpfree(cache->prosrc);\n\t\t\t\tcache->prosrc = NULL;\n\t\t\t}\n\t\t\tcache->function.Reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tReleaseSysCache(procTup);\n\t\t}\n\t}\n\telse\n\t{\n\t\tnew(&cache->function) Persistent<Function>();\n\t\tcache->prosrc = NULL;\n\t}\n\n\tif (cache->function.IsEmpty())\n\t{\n\t\tForm_pg_proc\tprocStruct;\n\n\t\tprocStruct = (Form_pg_proc) GETSTRUCT(procTup);\n\n\t\tprosrc = SysCacheGetAttr(PROCOID, procTup, Anum_pg_proc_prosrc, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null prosrc\");\n\n\t\tcache->retset = procStruct->proretset;\n\t\tcache->rettype = procStruct->prorettype;\n\n\t\tstrlcpy(cache->proname, NameStr(procStruct->proname), NAMEDATALEN);\n\t\tcache->fn_xmin = HeapTupleHeaderGetXmin(procTup->t_data);\n\t\tcache->fn_tid = procTup->t_self;\n\t\tcache->user_id = GetUserId();\n\n\t\tint nargs = get_func_arg_info(procTup, &argtypes, argnames, &argmodes);\n\n\t\tif (validate)\n\t\t{\n\t\t\t/*\n\t\t\t * Disallow non-polymorphic pseudotypes in arguments\n\t\t\t * (either IN or OUT).  Internal type is used to declare\n\t\t\t * js functions for find_function().\n\t\t\t */\n\t\t\tfor (int i = 0; i < nargs; i++)\n\t\t\t{\n\t\t\t\tif (get_typtype(argtypes[i]) == TYPTYPE_PSEUDO &&\n\t\t\t\t\t\targtypes[i] != INTERNALOID &&\n\t\t\t\t\t\t!IsPolymorphicType(argtypes[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"PL/v8 functions cannot accept type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(argtypes[i]))));\n\t\t\t}\n\t\t}\n\n\t\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\t\tcache->prosrc = TextDatumGetCString(prosrc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tReleaseSysCache(procTup);\n\n\t\tint\tinargs = 0;\n\t\tfor (int i = 0; i < nargs; i++)\n\t\t{\n\t\t\tOid\t\targtype = argtypes[i];\n\t\t\tchar\targmode = argmodes ? argmodes[i] : PROARGMODE_IN;\n\n\t\t\tswitch (argmode)\n\t\t\t{\n\t\t\tcase PROARGMODE_IN:\n\t\t\tcase PROARGMODE_INOUT:\n\t\t\tcase PROARGMODE_VARIADIC:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*argnames)\n\t\t\t\t(*argnames)[inargs] = (*argnames)[i];\n\t\t\tcache->argtypes[inargs] = argtype;\n\t\t\tinargs++;\n\t\t}\n\t\tcache->nargs = inargs;\n\t}\n\n\tMemoryContext mcxt = CurrentMemoryContext;\n\tif (fcinfo)\n\t\tmcxt = fcinfo->flinfo->fn_mcxt;\n\n\tplv8_proc *proc = (plv8_proc *) MemoryContextAllocZero(mcxt,\n\t\toffsetof(plv8_proc, argtypes) + sizeof(plv8_type) * cache->nargs);\n\n\tproc->cache = cache;\n\tfor (int i = 0; i < cache->nargs; i++)\n\t{\n\t\tOid\t\targtype = cache->argtypes[i];\n\t\t/* Resolve polymorphic types, if this is an actual call context. */\n\t\tif (fcinfo && IsPolymorphicType(argtype))\n\t\t\targtype = get_fn_expr_argtype(fcinfo->flinfo, i);\n\t\tplv8_fill_type(&proc->argtypes[i], argtype, mcxt);\n\t}\n\n\tOid\t\trettype = cache->rettype;\n\t/* Resolve polymorphic return type if this is an actual call context. */\n\tif (fcinfo && IsPolymorphicType(rettype))\n\t\trettype = get_fn_expr_rettype(fcinfo->flinfo);\n\tplv8_fill_type(&proc->rettype, rettype, mcxt);\n\n\treturn proc;\n}\n\nstatic plv8_exec_env *\nCreateExecEnv(Persistent<Function>& function, plv8_context *context)\n{\n\tplv8_exec_env\t   *xenv;\n\tHandleScope\t\t\thandle_scope(context->isolate);\n\n\tPG_TRY();\n\t{\n\t\txenv = plv8_new_exec_env(context->isolate);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\txenv->context.Reset(context->isolate, context->context);\n\tLocal<Context>\t\tctx = xenv->localContext();\n\tContext::Scope\t\tscope(ctx);\n\n\tLocal<ObjectTemplate> templ = Local<ObjectTemplate>::New(context->isolate, context->recv_templ);\n\tLocal<Object> obj = templ->NewInstance(ctx).ToLocalChecked();\n\tLocal<Function> f = Local<Function>::New(context->isolate, function);\n\tobj->SetInternalField(0, f);\n\txenv->recv.Reset(context->isolate, obj);\n\n\n\treturn xenv;\n}\n\nstatic plv8_exec_env *\nCreateExecEnv(Handle<Function> function, plv8_context *context)\n{\n\tIsolate::Scope\t    iscope(context->isolate);\n\tplv8_exec_env\t   *xenv;\n\tHandleScope\t\t\thandle_scope(context->isolate);\n\n\tPG_TRY();\n\t{\n\t\txenv = plv8_new_exec_env(context->isolate);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\txenv->context.Reset(context->isolate, context->context);\n\tLocal<Context>\t\tctx = xenv->localContext();\n\tContext::Scope\t\tscope(ctx);\n\n\tLocal<ObjectTemplate> templ = Local<ObjectTemplate>::New(context->isolate, context->recv_templ);\n\tLocal<Object> obj = templ->NewInstance(ctx).ToLocalChecked();\n\tLocal<Function> f = Local<Function>::New(context->isolate, function);\n\tobj->SetInternalField(0, f);\n\txenv->recv.Reset(context->isolate, obj);\n\n\n\treturn xenv;\n}\n\n/*\n * fcinfo should be passed if this is an actual function call context, where\n * we can resolve polymorphic types and use function's memory context.\n */\nstatic plv8_proc *\nCompile(Oid fn_oid, FunctionCallInfo fcinfo, bool validate, bool is_trigger)\n{\n\tplv8_proc  *proc;\n\tchar\t  **argnames;\n\n\tPG_TRY();\n\t{\n\t\tproc = plv8_get_proc(fn_oid, fcinfo, validate, &argnames);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tplv8_proc_cache *cache = proc->cache;\n\n\tif (cache->function.IsEmpty())\n\t{\n\t\t/*\n\t\t * We need to create global context before entering CompileFunction\n\t\t * because GetPlv8Context could call startup procedure, which\n\t\t * could be this cache->function itself.  In this scenario,\n\t\t * Compile is called recursively and plv8_get_proc tries to refresh\n\t\t * cache because cache->function is still not yet ready at this\n\t\t * point.  Then some pointers of cache will become stale by pfree\n\t\t * and CompileFunction ends up compiling freed function source.\n\t\t */\n\t\tcurrent_context = GetPlv8Context();\n\t\tIsolate::Scope\tscope(current_context->isolate);\n\t\tHandleScope\t\thandle_scope(current_context->isolate);\n\t\tPersistent<Context>\tglobal_context;\n\t\tglobal_context.Reset(current_context->isolate, current_context->context);\n\t\tcache->function.Reset(current_context->isolate, CompileFunction(\n\t\t\t\t\t\tcurrent_context,\n\t\t\t\t\t\tcache->proname,\n\t\t\t\t\t\tcache->nargs,\n\t\t\t\t\t\t(const char **) argnames,\n\t\t\t\t\t\tcache->prosrc,\n\t\t\t\t\t\tis_trigger,\n\t\t\t\t\t\tcache->retset));\n\t}\n\n\treturn proc;\n}\n\nstatic Local<Function>\nCompileFunction(\n\tplv8_context *global_context,\n\tconst char *proname,\n\tint proarglen,\n\tconst char *proargs[],\n\tconst char *prosrc,\n\tbool is_trigger,\n\tbool retset)\n{\n\tIsolate\t\t\t\t\t   *isolate = Isolate::GetCurrent();\n\tEscapableHandleScope\t\thandle_scope(isolate);\n\tStringInfoData\tsrc;\n\n\tinitStringInfo(&src);\n\n\tappendStringInfo(&src, \"(function (\");\n\tif (is_trigger)\n\t{\n\t\tif (proarglen != 0)\n\t\t\tthrow js_error(\"trigger function cannot have arguments\");\n\t\t// trigger function has special arguments.\n\t\tappendStringInfo(&src,\n\t\t\t\"NEW, OLD, TG_NAME, TG_WHEN, TG_LEVEL, TG_OP, \"\n\t\t\t\"TG_RELID, TG_TABLE_NAME, TG_TABLE_SCHEMA, TG_ARGV\");\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < proarglen; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t\tappendStringInfoChar(&src, ',');\n\t\t\tif (proargs && proargs[i])\n\t\t\t\tappendStringInfoString(&src, proargs[i]);\n\t\t\telse\n\t\t\t\tappendStringInfo(&src, \"$%d\", i + 1);\t// unnamed argument to $N\n\t\t}\n\t}\n\n\tappendStringInfo(&src, \"){\\n%s\\n})\", prosrc);\n\n\tHandle<v8::Value> name;\n\tif (proname)\n\t\tname = ToString(proname);\n\telse\n\t\tname = Undefined(isolate);\n\tLocal<v8::String> source = ToString(src.data, src.len);\n\tpfree(src.data);\n\n\tLocal<Context> context = Local<Context>::New(isolate, global_context->context);\n\tContext::Scope\tcontext_scope(context);\n\tTryCatch\t\ttry_catch(isolate);\n\tv8::ScriptOrigin origin(isolate, name);\n\n\t// set up the signal handlers\n\tif (int_handler == NULL) {\n\t\tint_handler = (void *) signal(SIGINT, signal_handler);\n\t}\n\n\tif (term_handler == NULL) {\n\t\tterm_handler = (void *) signal(SIGTERM, signal_handler);\n\t}\n\n#ifdef EXECUTION_TIMEOUT\n\tbool timeout = false;\n#ifdef _MSC_VER // windows\n\tHANDLE  hThread;\n\tDWORD dwThreadId;\n\thThread = CreateThread(NULL, 0, Breakout, isolate, 0, &dwThreadId);\n#else\n\tpthread_t breakout_thread;\n\t// set up the thread to break out the execution if needed\n\tpthread_create(&breakout_thread, NULL, Breakout, isolate);\n#endif\n#endif\n\n\tv8::Local<v8::Script> script;\n\tv8::Local<v8::Value> result;\n\tif (current_context->interrupted) {\n\t\tisolate->CancelTerminateExecution();\n\t\tcurrent_context->interrupted = false;\n\t}\n\tif (Script::Compile(isolate->GetCurrentContext(), source, &origin).ToLocal(&script)) {\n\t\tif (!script.IsEmpty()) {\n\t\t\tif (!script->Run(isolate->GetCurrentContext()).ToLocal(&result))\n\t\t\t\tthrow js_error(try_catch);\n\t\t}\n\t}\n\n#ifdef EXECUTION_TIMEOUT\n#ifdef _MSC_VER\n\tif (TerminateThread(hThread, NULL) == 0) {\n\t\ttimeout = true;\n\t}\n#else\n\tvoid *thread_result;\n\tpthread_cancel(breakout_thread);\n\tpthread_join(breakout_thread, &thread_result);\n\tif (thread_result == NULL) {\n\t\ttimeout = true;\n\t}\n#endif\n#endif\n\tsignal(SIGINT, (void (*)(int)) int_handler);\n\tsignal(SIGTERM, (void (*)(int)) term_handler);\n\n\tHandleUnhandledPromiseRejections();\n\n\tif (result.IsEmpty()) {\n\t\tif (isolate->IsExecutionTerminating()  || current_context->interrupted) {\n\t\t\tisolate->CancelTerminateExecution();\n\t\t\tif (current_context->interrupted) {\n\t\t\t\tcurrent_context->interrupted = false;\n\t\t\t\tthrow js_error(\"Signal caught: interrupted\");\n\t\t\t}\n#ifdef EXECUTION_TIMEOUT\n\t\t\tif (timeout) {\n\t\t\t\tthrow js_error(\"compiler timeout exceeded\");\n\t\t\t}\n#endif\n\t\t\tthrow js_error(\"Script is out of memory\");\n\t\t}\n\t\tthrow js_error(try_catch);\n\t}\n\n\treturn handle_scope.Escape(Local<Function>::Cast(result));\n}\n\nLocal<Function>\nfind_js_function(Oid fn_oid)\n{\n\tHeapTuple\t\ttuple;\n\tForm_pg_proc\tproc;\n\tOid\t\t\t\tprolang;\n\tNameData\t\tlangnames[] = { {\"plv8\"} };\n\tint\t\t\t\tlangno;\n\tint\t\t\t\tlanglen = sizeof(langnames) / sizeof(NameData);\n\tLocal<Function> func;\n\tIsolate\t\t\t*isolate = Isolate::GetCurrent();\n\n\ttuple = SearchSysCache(PROCOID, ObjectIdGetDatum(fn_oid), 0, 0, 0);\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", fn_oid);\n\tproc = (Form_pg_proc) GETSTRUCT(tuple);\n\tprolang = proc->prolang;\n\tReleaseSysCache(tuple);\n\n\t/* Should not happen? */\n\tif (!OidIsValid(prolang))\n\t\treturn func;\n\n\t/* See if the function language is a compatible one */\n\tfor (langno = 0; langno < langlen; langno++)\n\t{\n\t\ttuple = SearchSysCache(LANGNAME, NameGetDatum(&langnames[langno]), 0, 0, 0);\n\t\tif (HeapTupleIsValid(tuple))\n\t\t{\n#if PG_VERSION_NUM < 120000\n\t\t\tOid langtupoid = HeapTupleGetOid(tuple);\n#else\n\t\t\tForm_pg_database datForm = (Form_pg_database) GETSTRUCT(tuple);\n\t\t\tOid langtupoid = datForm->oid;\n#endif\n\t\t\tReleaseSysCache(tuple);\n\t\t\tif (langtupoid == prolang)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not found or non-JS function */\n\tif (langno >= langlen)\n\t\treturn func;\n\n\ttry\n\t{\n\t\tplv8_proc\t\t   *proc = Compile(fn_oid, NULL,\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\tTryCatch\t\t\ttry_catch(isolate);\n\n\t\tfunc = Local<Function>::New(isolate, proc->cache->function);\n\t}\n\tcatch (js_error& e) { e.rethrow(); }\n\tcatch (pg_error& e) { e.rethrow(); }\n\n\treturn func;\n}\n\n/*\n * NOTICE: the returned buffer could be an internal static buffer.\n */\nconst char *\nFormatSPIStatus(int status) throw()\n{\n\tstatic char\tprivate_buf[1024];\n\n\tif (status > 0)\n\t\treturn \"OK\";\n\n\tswitch (status)\n\t{\n\t\tcase SPI_ERROR_CONNECT:\n\t\t\treturn \"SPI_ERROR_CONNECT\";\n\t\tcase SPI_ERROR_COPY:\n\t\t\treturn \"SPI_ERROR_COPY\";\n\t\tcase SPI_ERROR_OPUNKNOWN:\n\t\t\treturn \"SPI_ERROR_OPUNKNOWN\";\n\t\tcase SPI_ERROR_UNCONNECTED:\n\t\tcase SPI_ERROR_TRANSACTION:\n\t\t\treturn \"current transaction is aborted, \"\n\t\t\t\t   \"commands ignored until end of transaction block\";\n\t\tcase SPI_ERROR_CURSOR:\n\t\t\treturn \"SPI_ERROR_CURSOR\";\n\t\tcase SPI_ERROR_ARGUMENT:\n\t\t\treturn \"SPI_ERROR_ARGUMENT\";\n\t\tcase SPI_ERROR_PARAM:\n\t\t\treturn \"SPI_ERROR_PARAM\";\n\t\tcase SPI_ERROR_NOATTRIBUTE:\n\t\t\treturn \"SPI_ERROR_NOATTRIBUTE\";\n\t\tcase SPI_ERROR_NOOUTFUNC:\n\t\t\treturn \"SPI_ERROR_NOOUTFUNC\";\n\t\tcase SPI_ERROR_TYPUNKNOWN:\n\t\t\treturn \"SPI_ERROR_TYPUNKNOWN\";\n\t\tdefault:\n\t\t\tsnprintf(private_buf, sizeof(private_buf),\n\t\t\t\t\"SPI_ERROR: %d\", status);\n\t\t\treturn private_buf;\n\t}\n}\n\nstatic text *\ncharToText(char *string)\n{\n\tint len = strlen(string);\n\ttext *result = (text *) palloc(len + 1 + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), string, len + 1);\n\n\treturn result;\n}\n\nstatic plv8_context*\nGetPlv8Context() {\n\tOid\t\t\t\t\tuser_id = GetUserId();\n\tunsigned int\t\ti;\n\tplv8_context\t\t*my_context = nullptr;\n\n\tfor (i = 0; i < ContextVector.size(); i++)\n\t{\n\t\tif (ContextVector[i]->user_id == user_id)\n\t\t{\n\t\t\tmy_context = ContextVector[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (my_context && (my_context->is_dead || (my_context->isolate && my_context->isolate->IsDead()))) {\n\t\t// the isolate is dead because of OOM, kill it and dispose\n\t\tchar *username = GetUserNameFromId(my_context->user_id, false);\n\t\telog(LOG_SERVER_ONLY, \"Disposing of a dead isolate for: %s\", username);\n\t\tContextVector.erase(ContextVector.begin() + i);\n\t\tif (my_context->isolate && my_context->isolate->IsInUse()) {\n\t\t\tmy_context->isolate->Exit();\n\t\t}\n\t\tkillPlv8Context(my_context);\n\t\tpfree(my_context);\n\t\tmy_context = nullptr;\n\t}\n\tif (!my_context)\n\t{\n\t\tmy_context = (plv8_context *) MemoryContextAllocZero(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sizeof(plv8_context));\n\t\tmy_context->is_dead = false;\n\t\tmy_context->interrupted = false;\n\t\tmy_context->ignore_unhandled_promises = false;\n\t\tCreateIsolate(my_context);\n\t\tIsolate \t\t\t   *isolate = my_context->isolate;\n\t\tIsolate::Scope\t\t\tscope(isolate);\n\t\tHandleScope\t\t\t\thandle_scope(isolate);\n\n\t\tLocal<ObjectTemplate>\tglobal = Local<ObjectTemplate>::New(isolate, GetGlobalObjectTemplate(isolate));\n\n\t\tnew(&my_context->context) Persistent<Context>();\n\t\tmy_context->context.Reset(isolate, Context::New(isolate, NULL, global));\n\t\tmy_context->user_id = user_id;\n\n\t\tnew(&my_context->recv_templ) Persistent<ObjectTemplate>();\n\t\tLocal<ObjectTemplate> templ = ObjectTemplate::New(isolate);\n\t\ttempl->SetInternalFieldCount(1);\n\t\tmy_context->recv_templ.Reset(isolate, templ);\n\n\t\tnew(&my_context->compile_context) Persistent<Context>();\n\t\tLocal<Context> ctx = Context::New(isolate, (ExtensionConfiguration*)NULL);\n\t\tmy_context->compile_context.Reset(isolate, ctx);\n\n\t\tauto toStringAttr = static_cast<PropertyAttribute>(v8::ReadOnly | v8::DontEnum);\n\t\tauto toStringSymbol = v8::Symbol::GetToStringTag(isolate);\n\n\t\tnew(&my_context->plan_template) Persistent<ObjectTemplate>();\n\t\tLocal<FunctionTemplate> base = FunctionTemplate::New(isolate);\n\t\tLocal<v8::String> planClassName = v8::String::NewFromUtf8Literal(isolate, \"PreparedPlan\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NewStringType::kInternalized);\n\t\tbase->SetClassName(planClassName);\n\t\tbase->PrototypeTemplate()->Set(toStringSymbol, planClassName, toStringAttr);\n\t\ttempl = base->InstanceTemplate();\n\t\tSetupPrepFunctions(templ);\n\t\tmy_context->plan_template.Reset(isolate, templ);\n\n\t\tnew(&my_context->cursor_template) Persistent<ObjectTemplate>();\n\t\tbase = FunctionTemplate::New(isolate);\n\t\tLocal<v8::String> cursorClassName = v8::String::NewFromUtf8Literal(isolate, \"Cursor\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NewStringType::kInternalized);\n\t\tbase->SetClassName(cursorClassName);\n\t\tbase->PrototypeTemplate()->Set(toStringSymbol, cursorClassName, toStringAttr);\n\t\ttempl = base->InstanceTemplate();\n\t\tSetupCursorFunctions(templ);\n\t\tmy_context->cursor_template.Reset(isolate, templ);\n\n\t\tnew(&my_context->window_template) Persistent<ObjectTemplate>();\n\t\tbase = FunctionTemplate::New(isolate);\n\t\tLocal<v8::String> windowClassName = v8::String::NewFromUtf8Literal(isolate, \"WindowObject\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NewStringType::kInternalized);\n        base->SetClassName(windowClassName);\n\t\tbase->PrototypeTemplate()->Set(toStringSymbol, windowClassName, toStringAttr);\n\t\ttempl = base->InstanceTemplate();\n\t\tSetupWindowFunctions(templ);\n\t\tmy_context->window_template.Reset(isolate, templ);\n\t\t/*\n\t\t * Need to register it before running any code, as the code\n\t\t * recursively may want to the global context.\n\t\t */\n\t\tContextVector.push_back(my_context);\n\n\t\t/*\n\t\t * Run the start up procedure if configured.\n\t\t */\n\t\tif (plv8_start_proc != NULL)\n\t\t{\n\t\t\tLocal<Function>\t\tfunc;\n\n\t\t\tHandleScope\t\t\thandle_scope(isolate);\n\t\t\tLocal<Context>\t\tcontext = my_context->localContext();\n\t\t\tContext::Scope\t\tcontext_scope(context);\n\t\t\tTryCatch\t\t\ttry_catch(isolate);\n\t\t\tMemoryContext\t\tctx = CurrentMemoryContext;\n\t\t\ttext *arg;\n#if PG_VERSION_NUM < 120000\n\t\t\tFunctionCallInfoData fake_fcinfo;\n#else\n\t\t\t// Stack-allocate FunctionCallInfoBaseData with\n\t\t\t// space for 2 arguments:\n\t\t\tLOCAL_FCINFO(fake_fcinfo, 2);\n#endif\n\t\t\tFmgrInfo\tflinfo;\n\n\t\t\tchar perm[16];\n\t\t\tstrcpy(perm, \"EXECUTE\");\n\t\t\targ = charToText(perm);\n\n\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tOid funcoid = DatumGetObjectId(DirectFunctionCall1(regprocin, CStringGetDatum(plv8_start_proc)));\n#if PG_VERSION_NUM < 120000\n\t\t\t\t\t\tMemSet(&fake_fcinfo, 0, sizeof(fake_fcinfo));\n\t\t\t\t\t\tMemSet(&flinfo, 0, sizeof(flinfo));\n\t\t\t\t\t\tfake_fcinfo.flinfo = &flinfo;\n\t\t\t\t\t\tflinfo.fn_oid = InvalidOid;\n\t\t\t\t\t\tflinfo.fn_mcxt = CurrentMemoryContext;\n\t\t\t\t\t\tfake_fcinfo.nargs = 2;\n\t\t\t\t\t\tfake_fcinfo.arg[0] = ObjectIdGetDatum(funcoid);\n\t\t\t\t\t\tfake_fcinfo.arg[1] = CStringGetDatum(arg);\n\t\t\t\t\t\tDatum ret = has_function_privilege_id(&fake_fcinfo);\n#else\n\t\t\t\t\t\tMemSet(&flinfo, 0, sizeof(flinfo));\n\t\t\t\t\t\tfake_fcinfo->flinfo = &flinfo;\n\t\t\t\t\t\tflinfo.fn_oid = InvalidOid;\n\t\t\t\t\t\tflinfo.fn_mcxt = CurrentMemoryContext;\n\t\t\t\t\t\tfake_fcinfo->nargs = 2;\n\t\t\t\t\t\tfake_fcinfo->args[0].value = ObjectIdGetDatum(funcoid);\n\t\t\t\t\t\tfake_fcinfo->args[1].value = PointerGetDatum(arg);\n\t\t\t\t\t\tDatum ret = has_function_privilege_id(fake_fcinfo);\n#endif\n\n\t\t\t\t\t\tif (ret == 0) {\n\t\t\t\t\t\t\telog(WARNING, \"failed to find js function %s\", plv8_start_proc);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (DatumGetBool(ret)) {\n\t\t\t\t\t\t\t\tfunc = find_js_function(funcoid);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telog(WARNING, \"no permission to execute js function %s\", plv8_start_proc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tErrorData\t   *edata;\n\n\t\t\t\t\t\tMemoryContextSwitchTo(ctx);\n\t\t\t\t\t\tedata = CopyErrorData();\n\t\t\t\t\t\telog(WARNING, \"failed to find js function %s\", edata->message);\n\t\t\t\t\t\tFlushErrorState();\n\t\t\t\t\t\tFreeErrorData(edata);\n\t\t\t\t\t}\n\t\t\tPG_END_TRY();\n\n\t\t\tpfree(arg);\n\n\t\t\tif (!func.IsEmpty())\n\t\t\t{\n\t\t\t\tHandle<v8::Value>\tresult =\n\t\t\t\t\t\tDoCall(context, func, my_context->localContext()->Global(), 0, NULL, false);\n\t\t\t\tif (result.IsEmpty())\n\t\t\t\t\tthrow js_error(try_catch);\n\t\t\t}\n\t\t}\n\n#ifdef ENABLE_DEBUGGER_SUPPORT\n\t\tdebug_message_context = v8::Persistent<v8::Context>::New(global_context);\n\n\t\tv8::Locker locker;\n\n\t\tv8::Debug::SetDebugMessageDispatchHandler(DispatchDebugMessages, true);\n\n\t\tv8::Debug::EnableAgent(\"plv8\", plv8_debugger_port, false);\n#endif  // ENABLE_DEBUGGER_SUPPORT\n\t}\n\treturn my_context;\n}\n\nstatic Local<ObjectTemplate>\nGetGlobalObjectTemplate(Isolate *isolate)\n{\n\tPersistent<ObjectTemplate>\tglobal;\n\n\tif (global.IsEmpty())\n\t{\n\t\tHandleScope\t\t\t\thandle_scope(isolate);\n\n\t\tLocal<ObjectTemplate> templ = ObjectTemplate::New(isolate);\n\t\t// ERROR levels for elog\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"DEBUG5\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, DEBUG5));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"DEBUG4\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, DEBUG4));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"DEBUG3\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, DEBUG3));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"DEBUG2\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, DEBUG2));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"DEBUG1\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, DEBUG1));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"DEBUG\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, DEBUG5));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"LOG\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, LOG));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"INFO\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, INFO));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"NOTICE\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, NOTICE));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"WARNING\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, WARNING));\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"ERROR\", NewStringType::kInternalized),\n\t\t\t\t   Int32::New(isolate, ERROR));\n\t\tglobal.Reset(isolate, templ);\n\n\t\tLocal<ObjectTemplate> plv8 = ObjectTemplate::New(isolate);\n\n\t\tSetupPlv8Functions(plv8);\n\t\tplv8->Set(v8::String::NewFromUtf8Literal(isolate, \"version\", NewStringType::kInternalized),\n\t\t\t\t  v8::String::NewFromUtf8Literal(isolate, PLV8_VERSION));\n\t\tplv8->Set(v8::String::NewFromUtf8Literal(isolate, \"v8_version\", NewStringType::kInternalized),\n\t\t\t\t  v8::String::NewFromUtf8Literal(isolate, V8_VERSION_STRING));\n\n\t\ttempl->Set(v8::String::NewFromUtf8Literal(isolate, \"plv8\", NewStringType::kInternalized), plv8);\n\t}\n\treturn Local<ObjectTemplate>::New(isolate, global);\n}\n\n/*\n * Accessor to plv8_type stored in fcinfo.\n */\nplv8_type *\nget_plv8_type(PG_FUNCTION_ARGS, int argno)\n{\n\tplv8_proc *proc = (plv8_proc *) fcinfo->flinfo->fn_extra;\n\treturn &proc->argtypes[argno];\n}\n\nConverter::Converter(TupleDesc tupdesc) :\n\tm_tupdesc(tupdesc),\n\tm_colnames(tupdesc->natts),\n\tm_coltypes(tupdesc->natts),\n\tm_is_scalar(false),\n\tm_memcontext(NULL)\n{\n\tInit();\n}\n\nConverter::Converter(TupleDesc tupdesc, bool is_scalar) :\n\tm_tupdesc(tupdesc),\n\tm_colnames(tupdesc->natts),\n\tm_coltypes(tupdesc->natts),\n\tm_is_scalar(is_scalar),\n\tm_memcontext(NULL)\n{\n\tInit();\n}\n\nConverter::~Converter()\n{\n\tif (m_memcontext != NULL)\n\t{\n\t\tMemoryContext ctx = CurrentMemoryContext;\n\n\t\tPG_TRY();\n\t\t{\n\t\t\tMemoryContextDelete(m_memcontext);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\tErrorData\t   *edata;\n\n\t\t\tMemoryContextSwitchTo(ctx);\n\t\t\t// don't throw out from deconstructor\n\t\t\tedata = CopyErrorData();\n\t\t\telog(WARNING, \"~Converter: %s\", edata->message);\n\t\t\tFlushErrorState();\n\t\t\tFreeErrorData(edata);\n\t\t}\n\t\tPG_END_TRY();\n\t\tm_memcontext = NULL;\n\t}\n}\n\nvoid\nConverter::Init()\n{\n\tfor (int c = 0; c < m_tupdesc->natts; c++)\n\t{\n\t\tif (TupleDescAttr(m_tupdesc, c)->attisdropped)\n\t\t\tcontinue;\n\n\t\tm_colnames[c] = ToString(NameStr(TupleDescAttr(m_tupdesc, c)->attname));\n\n\t\tPG_TRY();\n\t\t{\n\t\t\tif (m_memcontext == NULL)\n#if PG_VERSION_NUM < 110000\n\t\t\t\tm_memcontext = AllocSetContextCreate(\n\t\t\t\t\t\t\t\t\tCurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"ConverterContext\",\n\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_MINSIZE,\n\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_INITSIZE,\n\t\t\t\t\t\t\t\t\tALLOCSET_SMALL_MAXSIZE);\n\t\t\tplv8_fill_type(&m_coltypes[c],\n\t\t\t\t\t\t   m_tupdesc->attrs[c]->atttypid,\n\t\t\t\t\t\t   m_memcontext);\n#else\n\t\t\t\tm_memcontext = AllocSetContextCreate(\n\t\t\t\t\t\t\t\t\tCurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"ConverterContext\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\t\t\tplv8_fill_type(&m_coltypes[c],\n\t\t\t\t\t\t   m_tupdesc->attrs[c].atttypid,\n\t\t\t\t\t\t   m_memcontext);\n#endif\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\tthrow pg_error();\n\t\t}\n\t\tPG_END_TRY();\n\t}\n}\n\n// TODO: use prototype instead of per tuple fields to reduce\n// memory consumption.\nLocal<Object>\nConverter::ToValue(HeapTuple tuple)\n{\n\tIsolate\t\t   *isolate = Isolate::GetCurrent();\n    Local<Context>  context = isolate->GetCurrentContext();\n\tLocal<Object>\tobj = Object::New(isolate);\n\n\tfor (int c = 0; c < m_tupdesc->natts; c++)\n\t{\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\n\t\tif (TupleDescAttr(m_tupdesc, c)->attisdropped)\n\t\t\tcontinue;\n\n#if PG_VERSION_NUM >= 90000\n\t\tdatum = heap_getattr(tuple, c + 1, m_tupdesc, &isnull);\n#else\n\t\t/*\n\t\t * Due to the difference between C and C++ rules,\n\t\t * we cannot call heap_getattr from < 9.0 unfortunately.\n\t\t */\n\t\tdatum = nocachegetattr(tuple, c + 1, m_tupdesc, &isnull);\n#endif\n\n\t\tobj->Set(context, m_colnames[c], ::ToValue(datum, isnull, &m_coltypes[c])).Check();\n\t}\n\n\treturn obj;\n}\n\nDatum\nConverter::ToDatum(Handle<v8::Value> value, Tuplestorestate *tupstore)\n{\n\tIsolate\t\t   *isolate = Isolate::GetCurrent();\n    Local<Context>  context = isolate->GetCurrentContext();\n\tDatum\t\t\tresult;\n\tTryCatch\t\ttry_catch(isolate);\n\tHandle<Object>\tobj;\n\n\tif (!m_is_scalar)\n\t{\n\t\tif (!value->IsObject())\n\t\t\tthrow js_error(\"argument must be an object\");\n\t\tobj = Handle<Object>::Cast(value);\n\t\tif (obj.IsEmpty())\n\t\t\tthrow js_error(try_catch);\n\t}\n\n\t/*\n\t * Use vector<char> instead of vector<bool> because <bool> version is\n\t * s specialized and different from bool[].\n\t */\n\tDatum  *values = (Datum *) palloc(sizeof(Datum) * m_tupdesc->natts);\n\tbool   *nulls = (bool *) palloc(sizeof(bool) * m_tupdesc->natts);\n\n\tif (!m_is_scalar)\n\t{\n\t\tHandle<Array> names = obj->GetPropertyNames(isolate->GetCurrentContext()).ToLocalChecked();\n\n\t\tfor (int c = 0; c < m_tupdesc->natts; c++)\n\t\t{\n\t\t\tif (TupleDescAttr(m_tupdesc, c)->attisdropped)\n\t\t\t\tcontinue;\n\n\t\t\tbool found = false;\n\t\t\tCString  colname(m_colnames[c]);\n\t\t\tfor (int d = 0; d < m_tupdesc->natts; d++)\n\t\t\t{\n\t\t\t\tCString fname(names->Get(context, d).ToLocalChecked());\n\t\t\t\tif (strcmp(colname, fname) == 0)\n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tthrow js_error(\"field name / property name mismatch\");\n\t\t}\n\t}\n\n\tfor (int c = 0; c < m_tupdesc->natts; c++)\n\t{\n\t\t/* Make sure dropped columns are skipped by backend code. */\n#if PG_VERSION_NUM < 110000\n\t\tif (m_tupdesc->attrs[c]->attisdropped)\n#else\n\t\tif (m_tupdesc->attrs[c].attisdropped)\n#endif\n\t\t{\n\t\t\tnulls[c] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tHandle<v8::Value> attr = m_is_scalar ? value : obj->Get(context, m_colnames[c]).ToLocalChecked();\n\t\tif (attr.IsEmpty() || attr->IsUndefined() || attr->IsNull())\n\t\t\tnulls[c] = true;\n\t\telse\n\t\t\tvalues[c] = ::ToDatum(attr, &nulls[c], &m_coltypes[c]);\n\t}\n\n\tif (tupstore)\n\t{\n\t\ttuplestore_putvalues(tupstore, m_tupdesc, values, nulls);\n\t\tresult = (Datum) 0;\n\t}\n\telse\n\t{\n\t\tresult = HeapTupleGetDatum(heap_form_tuple(m_tupdesc, values, nulls));\n\t}\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}\n\njs_error::js_error() noexcept\n\t: m_msg(nullptr), m_code(0), m_detail(nullptr), m_hint(nullptr), m_context(nullptr)\n{\n}\n\njs_error::js_error(const char *msg) noexcept : js_error()\n{\n\tm_msg = pstrdup(msg);\n}\n\njs_error::js_error(Isolate *isolate, v8::Local<v8::Value> exception, v8::Local<v8::Message> message) noexcept : js_error() {\n\tinit(isolate, exception, message);\n}\n\njs_error::js_error(v8::TryCatch &try_catch) noexcept : js_error() {\n\tIsolate\t\t   \t\t*isolate = Isolate::GetCurrent();\n\tHandleScope\t\t\thandle_scope(isolate);\n\n\tinit(isolate, try_catch.Exception(), try_catch.Message());\n}\n\nvoid\njs_error::init(Isolate *isolate, v8::Local<v8::Value> exception, v8::Local<Message> message) noexcept\n{\n\tHandleScope\t\t\thandle_scope(isolate);\n\tv8::String::Utf8Value\terr_message(isolate, exception);\n\tLocal<Context>      context = isolate->GetCurrentContext();\n\n\ttry\n\t{\n\t\tm_msg = ToCStringCopy(err_message);\n        StringInfoData\tdetailStr;\n        StringInfoData\thintStr;\n        StringInfoData\tcontextStr;\n        initStringInfo(&detailStr);\n        initStringInfo(&hintStr);\n        initStringInfo(&contextStr);\n\t\tHandle<v8::Object> err;\n\t\tif (exception->ToObject(context).ToLocal(&err))\n        {\n            if (!err.IsEmpty())\n            {\n                v8::Local<v8::Value> errCode;\n                if (err->Get(context,\n                             v8::String::NewFromUtf8Literal(isolate, \"code\")).ToLocal(&errCode))\n                {\n                    if (!errCode->IsUndefined() && !errCode->IsNull())\n                    {\n                        int32_t code = errCode->Int32Value(context).FromJust();\n                        m_code = code;\n                    }\n                }\n\n                v8::Local<v8::Value> errDetail;\n                if (err->Get(context,\n                             v8::String::NewFromUtf8Literal(isolate, \"detail\")).ToLocal(&errDetail))\n                {\n                    if (!errDetail->IsUndefined() && !errDetail->IsNull())\n                    {\n                        CString detail(errDetail);\n                        appendStringInfo(&detailStr, \"%s\", detail.str(\"?\"));\n                        m_detail = detailStr.data;\n                    }\n                }\n\n                v8::Local<v8::Value> errHint;\n                if (err->Get(context,\n                             v8::String::NewFromUtf8Literal(isolate, \"hint\")).ToLocal(&errHint))\n                {\n                    if (!errHint->IsUndefined() && !errHint->IsNull())\n                    {\n                        CString hint(errHint);\n                        appendStringInfo(&hintStr, \"%s\", hint.str(\"?\"));\n                        m_hint = hintStr.data;\n                    }\n                }\n\n                v8::Local<v8::Value> errContext;\n                if (err->Get(context, v8::String::NewFromUtf8Literal(isolate, \"context\")).ToLocal(&errContext))\n                    if (!errContext->IsUndefined() && !errContext->IsNull())\n                    {\n                        CString str_context(errContext);\n                        appendStringInfo(&contextStr, \"%s\\n\", str_context.str(\"?\"));\n                    }\n            }\n        }\n\n\t\tif (!message.IsEmpty())\n\t\t{\n\t\t\tCString\t\tscript(message->GetScriptResourceName());\n\t\t\tint\t\tlineno = message->GetLineNumber(context).FromJust();\n\t\t\tCString\t\tsource(message->GetSourceLine(context).ToLocalChecked());\n\t\t\t// TODO: Get stack trace?\n\t\t\t//Handle<StackTrace> stackTrace(message->GetStackTrace());\n\n\t\t\t/*\n\t\t\t * Report lineno - 1 because \"function _(...){\" was added\n\t\t\t * at the first line to the javascript code.\n\t\t\t */\n\t\t\tif (strstr(m_msg, \"Error: \") == m_msg)\n\t\t\t\tm_msg += 7;\n\n\t\t\tappendStringInfo(&contextStr, \"%s() LINE %d: %s\",\n\t\t\t\tscript.str(\"?\"), lineno - 1, source.str(\"?\"));\n\t\t}\n\n\t\tm_context = contextStr.data;\n\t}\n\tcatch (...)\n\t{\n\t\t// nested error, keep quiet.\n\t}\n}\n\nLocal<v8::Value>\njs_error::error_object()\n{\n\tchar *msg = pstrdup(m_msg ? m_msg : \"unknown exception\");\n\t/*\n\t * Trim leading \"Error: \", in case the message is generated from\n\t * another Error.\n\t */\n\tif (strstr(msg, \"Error: \") == msg)\n\t\tmsg += 7;\n\tLocal<v8::String> message = ToString(msg);\n\treturn Exception::Error(message);\n}\n\nvoid\njs_error::log(int elevel, const char *msg_format) noexcept {\n\tif (elevel >= ERROR) {\n\t\treturn rethrow(msg_format);\n\t}\n\tereport(elevel,\n\t\t\t(\n\t\t\t\t\tm_code ? errcode(m_code): 0,\n\t\t\t\t\tm_msg ? errmsg((msg_format ? msg_format : \"%s\"), m_msg) : 0,\n\t\t\t\t\tm_detail ? errdetail(\"%s\", m_detail) : 0,\n\t\t\t\t\tm_hint ? errhint(\"%s\", m_hint) : 0,\n\t\t\t\t\tm_context ? errcontext(\"%s\", m_context) : 0\n\t\t\t));\n}\n\n__attribute__((noreturn))\nvoid\njs_error::rethrow(const char *msg_format) noexcept\n{\n\tereport(ERROR,\n\t\t\t(\n\t\t\t\t\tm_code ? errcode(m_code): 0,\n\t\t\t\t\tm_msg ? errmsg((msg_format ? msg_format : \"%s\"), m_msg) : 0,\n\t\t\t\t\tm_detail ? errdetail(\"%s\", m_detail) : 0,\n\t\t\t\t\tm_hint ? errhint(\"%s\", m_hint) : 0,\n\t\t\t\t\tm_context ? errcontext(\"%s\", m_context) : 0\n\t\t\t));\n\texit(0);\t// keep compiler quiet\n}\n\n__attribute__((noreturn))\nvoid\npg_error::rethrow() throw()\n{\n\tPG_RE_THROW();\n\texit(0);\t// keep compiler quiet\n}\n"
        },
        {
          "name": "plv8.control.common",
          "type": "blob",
          "size": 0.1943359375,
          "content": "comment = 'PL/JavaScript (v8) trusted procedural language'\ndefault_version = '@PLV8_VERSION@'\nmodule_pathname = '$libdir/plv8-@PLV8_VERSION@'\nrelocatable = false\nschema = pg_catalog\nsuperuser = true\n"
        },
        {
          "name": "plv8.h",
          "type": "blob",
          "size": 9.251953125,
          "content": "/*-------------------------------------------------------------------------\n *\n * plv8.h\n *\n * Copyright (c) 2009-2012, the PLV8JS Development Group.\n *-------------------------------------------------------------------------\n */\n#ifndef _PLV8_\n#define _PLV8_\n\n#include \"plv8_config.h\"\n#include <v8.h>\n#ifdef ENABLE_DEBUGGER_SUPPORT\n#include <v8-debug.h>\n#endif  // ENABLE_DEBUGGER_SUPPORT\n#include <v8-version-string.h>\n#include <vector>\n\nextern \"C\" {\n#include \"postgres.h\"\n\n#include \"access/htup.h\"\n#include \"fmgr.h\"\n#include \"mb/pg_wchar.h\"\n#include \"utils/tuplestore.h\"\n#include \"windowapi.h\"\n}\n#include <string>\n\n#ifdef _MSC_VER\n#define __attribute__(what)\t\t__declspec what\n#elif !defined(__GNUC__)\n#define __attribute__(what)\n#endif\n\n/* numbers for plv8 object internal field */\n/* Converter for SRF */\n#define PLV8_INTNL_CONV\t\t\t1\n/* Tuplestore for SRF */\n#define PLV8_INTNL_TUPSTORE\t\t2\n/* FunctionCallInfo for window functions */\n#define PLV8_INTNL_FCINFO\t\t3\n#define PLV8_INTNL_MAX\t\t\t4\n\nenum Dialect{ PLV8_DIALECT_NONE, PLV8_DIALECT_COFFEE, PLV8_DIALECT_LIVESCRIPT };\n\n/* js_error represents exceptions in JavaScript. */\nclass js_error\n{\nprivate:\n\tchar\t   *m_msg;\n\tint\t   m_code;\n\tchar\t   *m_detail;\n\tchar\t   *m_hint;\n\tchar\t   *m_context;\n\tvoid init(v8::Isolate *isolate, v8::Local<v8::Value> exception, v8::Local<v8::Message> message) noexcept;\n\npublic:\n\tjs_error() noexcept;\n\texplicit js_error(const char *msg) noexcept;\n\texplicit js_error(v8::Isolate *isolate, v8::Local<v8::Value> exception, v8::Local<v8::Message> message) noexcept;\n\texplicit js_error(v8::TryCatch &try_catch) noexcept;\n\tv8::Local<v8::Value> error_object();\n\t__attribute__((noreturn)) void rethrow(const char *msg_format = nullptr) noexcept;\n\tvoid log(int elevel, const char *msg_format = nullptr) noexcept;\n};\n\n/*\n * pg_error represents ERROR in postgres.\n * Instances of the class should be thrown only in PG_CATCH block.\n */\nclass pg_error\n{\npublic:\n\t__attribute__((noreturn)) void rethrow() throw();\n};\n\ntypedef enum plv8_external_array_type\n{\n\tkExternalByteArray = 1,\n\tkExternalUnsignedByteArray,\n\tkExternalShortArray,\n\tkExternalUnsignedShortArray,\n\tkExternalIntArray,\n\tkExternalUnsignedIntArray,\n\tkExternalFloatArray,\n\tkExternalDoubleArray,\n\tkExternalUnsignedInt64Array,\n\tkExternalInt64Array\n} plv8_external_array_type;\n\n/*\n * When TYPCATEGORY_ARRAY, other fields are for element types.\n *\n * Note that postgres doesn't support type modifiers for arguments and result types.\n */\ntypedef struct plv8_type\n{\n\tOid\t\t\ttypid;\n\tOid\t\t\tioparam;\n\tint16\t\tlen;\n\tbool\t\tbyval;\n\tchar\t\talign;\n\tchar\t\tcategory;\n\tbool\t\tis_composite;\n\tFmgrInfo\tfn_input;\n\tFmgrInfo\tfn_output;\n\tplv8_external_array_type ext_array;\n} plv8_type;\n\n/*\n * For the security reasons, the global context is separated\n * between users and it's associated with user id.\n */\ntypedef struct plv8_context\n{\n\tv8::Isolate\t\t\t\t   \t   \t   *isolate;\n\tv8::ArrayBuffer::Allocator\t   \t   *array_buffer_allocator;\n\tv8::Persistent<v8::Context>\t\t\tcontext;\n\tv8::Persistent<v8::ObjectTemplate>\trecv_templ;\n\tv8::Persistent<v8::Context>\t\t\tcompile_context;\n\tv8::Persistent<v8::ObjectTemplate>  plan_template;\n\tv8::Persistent<v8::ObjectTemplate>  cursor_template;\n\tv8::Persistent<v8::ObjectTemplate>  window_template;\n\tv8::Local<v8::Context> localContext() { return v8::Local<v8::Context>::New(isolate, context) ; }\n\tbool \t\t\t\t\t\tis_dead;\n\tbool\t\t\t\t\t\tinterrupted;\n\tOid\t\t\t\t\t\t\tuser_id;\n\tstd::vector<std::tuple<v8::Global<v8::Promise>, v8::Global<v8::Message>, v8::Global<v8::Value>>> unhandled_promises;\n\tbool \t\t\t\t\t\tignore_unhandled_promises;\n} plv8_context;\n\n/*\n * A multibyte string in the database encoding. It works more effective\n * when the encoding is UTF8.\n */\nclass CString\n{\nprivate:\n\tv8::String::Utf8Value\tm_utf8;\n\tchar\t\t\t\t   *m_str;\n\npublic:\n\texplicit CString(v8::Handle<v8::Value> value);\n\t~CString();\n\toperator char* ()\t\t\t\t{ return m_str; }\n\toperator const char* () const\t{ return m_str; }\n\tconst char* str(const char *ifnull = NULL) const\n\t{ return m_str ? m_str : ifnull; }\n\n    static bool toStdString(v8::Handle<v8::Value> value, std::string &out);\n\nprivate:\n\tCString(const CString&);\n\tCString& operator = (const CString&);\n};\n\n/*\n * Records in postgres to JSON in v8 converter.\n */\nclass Converter\n{\nprivate:\n\tTupleDesc\t\t\t\t\t\t\t\tm_tupdesc;\n\tstd::vector< v8::Handle<v8::String> >\tm_colnames;\n\tstd::vector< plv8_type >\t\t\t\tm_coltypes;\n\tbool\t\t\t\t\t\t\t\t\tm_is_scalar;\n\tMemoryContext\t\t\t\t\t\t\tm_memcontext;\n\npublic:\n\tConverter(TupleDesc tupdesc);\n\tConverter(TupleDesc tupdesc, bool is_scalar);\n\t~Converter();\n\tv8::Local<v8::Object> ToValue(HeapTuple tuple);\n\tDatum\tToDatum(v8::Handle<v8::Value> value, Tuplestorestate *tupstore = NULL);\n\nprivate:\n\tConverter(const Converter&);\n\tConverter& operator = (const Converter&);\n\tvoid\tInit();\n};\n\n/*\n * Provide JavaScript JSON object functionality.\n */\nclass JSONObject\n{\nprivate:\n\tv8::Handle<v8::Object> m_json;\n\npublic:\n\tJSONObject();\n\tv8::Handle<v8::Value> Parse(v8::Handle<v8::Value> str);\n\tv8::Handle<v8::Value> Stringify(v8::Handle<v8::Value> val);\n};\n\n/*\n * Check if this is a window function call.  If so, we store fcinfo\n * in plv8 object for API to use it.  It would be possible to do it\n * in the normal function cases, but currently nobody is using it\n * and probably adds overhead.  We need a class because the destructor\n * makes sure the restore happens.\n */\nclass WindowFunctionSupport\n{\nprivate:\n\tWindowObject\t\t\tm_winobj;\n\tv8::Handle<v8::Object>\tm_plv8obj;\n\tv8::Handle<v8::Value>\tm_prev_fcinfo;\n\npublic:\n\tWindowFunctionSupport(v8::Handle<v8::Context> context,\n\t\t\t\t\t\tFunctionCallInfo fcinfo)\n\t{\n\t\tm_winobj = PG_WINDOW_OBJECT();\n\t\tif (WindowObjectIsValid(m_winobj))\n\t\t{\n\t\t\tm_plv8obj = v8::Handle<v8::Object>::Cast(\n\t\t\t\t\tcontext->Global()->Get(context, v8::String::NewFromUtf8Literal(\n\t\t\t\t\t\tcontext->GetIsolate(),\n\t\t\t\t\t\t\"plv8\",\n\t\t\t\t\t\tv8::NewStringType::kInternalized)).ToLocalChecked());\n\t\t\tif (m_plv8obj.IsEmpty())\n\t\t\t\tthrow js_error(\"plv8 object not found\");\n\t\t\t/* Stash the current item, just in case of nested call */\n\t\t\tm_prev_fcinfo = m_plv8obj->GetInternalField(PLV8_INTNL_FCINFO);\n\t\t\tm_plv8obj->SetInternalField(PLV8_INTNL_FCINFO,\n\t\t\t\t\tv8::External::New(context->GetIsolate(), fcinfo));\n\t\t}\n\t}\n\tbool IsWindowCall() { return WindowObjectIsValid(m_winobj); }\n\tWindowObject GetWindowObject() { return m_winobj; }\n\t~WindowFunctionSupport()\n\t{\n\t\t/* Restore the previous fcinfo if we saved. */\n\t\tif (WindowObjectIsValid(m_winobj))\n\t\t{\n\t\t\tm_plv8obj->SetInternalField(PLV8_INTNL_FCINFO, m_prev_fcinfo);\n\t\t}\n\t}\n};\n\n/*\n * In case this is nested via SPI, stash pre-registered converters\n * for the previous SRF.  We need a class because the destructor makes\n * sure the restore happens.\n */\nclass SRFSupport\n{\nprivate:\n\tv8::Handle<v8::Object> m_plv8obj;\n\tv8::Handle<v8::Value> m_prev_conv, m_prev_tupstore;\n\npublic:\n\tSRFSupport(v8::Handle<v8::Context> context,\n\t\t\t   Converter *conv, Tuplestorestate *tupstore)\n\t{\n\t    v8::Local<v8::Value> m_val;\n\t    if (!context->Global()->Get(context, v8::String::NewFromUtf8Literal(\n                context->GetIsolate(),\n                \"plv8\",\n                v8::NewStringType::kInternalized)).ToLocal(&m_val))\n            throw js_error(\"plv8 object not found\");\n\t    m_plv8obj = v8::Handle<v8::Object>::Cast(m_val);\n\t\tm_prev_conv = m_plv8obj->GetInternalField(PLV8_INTNL_CONV);\n\t\tm_prev_tupstore = m_plv8obj->GetInternalField(PLV8_INTNL_TUPSTORE);\n\t\tm_plv8obj->SetInternalField(PLV8_INTNL_CONV,\n\t\t\t\t\t\t\t\t\tv8::External::New(context->GetIsolate(), conv));\n\t\tm_plv8obj->SetInternalField(PLV8_INTNL_TUPSTORE,\n\t\t\t\t\t\t\t\t\tv8::External::New(context->GetIsolate(), tupstore));\n\t}\n\t~SRFSupport()\n\t{\n\t\t/* Restore the previous items. */\n\t\tm_plv8obj->SetInternalField(PLV8_INTNL_CONV, m_prev_conv);\n\t\tm_plv8obj->SetInternalField(PLV8_INTNL_TUPSTORE, m_prev_tupstore);\n\t}\n};\n\nextern plv8_context* current_context;\nextern v8::Local<v8::Function> find_js_function(Oid fn_oid);\nextern v8::Local<v8::Function> find_js_function_by_name(const char *signature);\nextern const char *FormatSPIStatus(int status) throw();\nextern plv8_type *get_plv8_type(PG_FUNCTION_ARGS, int argno);\n\n// plv8_type.cc\nextern void plv8_fill_type(plv8_type *type, Oid typid, MemoryContext mcxt = NULL);\nextern Oid inferred_datum_type(v8::Handle<v8::Value> value);\nextern Datum ToDatum(v8::Handle<v8::Value> value, bool *isnull, plv8_type *type);\nextern v8::Local<v8::Value> ToValue(Datum datum, bool isnull, plv8_type *type);\nextern v8::Local<v8::String> ToString(Datum value, plv8_type *type);\nextern v8::Local<v8::String> ToString(const char *str, int len = -1, int encoding = GetDatabaseEncoding());\nextern char *ToCString(const v8::String::Utf8Value &value);\nextern char *ToCStringCopy(const v8::String::Utf8Value &value);\n\n// plv8_func.cc\nextern v8::Handle<v8::Function> CreateYieldFunction(Converter *conv, Tuplestorestate *tupstore);\nextern void Subtransaction(const v8::FunctionCallbackInfo<v8::Value>& info) throw();\n\nextern void SetupPlv8Functions(v8::Handle<v8::ObjectTemplate> plv8);\nextern void SetupPrepFunctions(v8::Handle<v8::ObjectTemplate> templ);\nextern void SetupCursorFunctions(v8::Handle<v8::ObjectTemplate> templ);\nextern void SetupWindowFunctions(v8::Handle<v8::ObjectTemplate> templ);\n\nextern void HandleUnhandledPromiseRejections();\n\nextern void GetMemoryInfo(v8::Local<v8::Object> obj);\n\nextern struct config_generic *plv8_find_option(const char *name);\nchar *plv8_string_option(struct config_generic * record);\nint plv8_int_option(struct config_generic * record);\n\n#endif\t// _PLV8_\n"
        },
        {
          "name": "plv8.sql.common",
          "type": "blob",
          "size": 1.1875,
          "content": "#include \"pg_config.h\"\n#if PG_VERSION_NUM < 90100\n-- adjust this setting to control where the objects get created.\nSET search_path = public;\n\nBEGIN;\n#endif\n\nCREATE FUNCTION plv8_call_handler() RETURNS language_handler\n\tAS 'MODULE_PATHNAME' LANGUAGE C;\n\n#if PG_VERSION_NUM >= 90000\nCREATE FUNCTION plv8_inline_handler(internal) RETURNS void\n\tAS 'MODULE_PATHNAME' LANGUAGE C;\n#endif\n\nCREATE FUNCTION plv8_call_validator(oid) RETURNS void\n\tAS 'MODULE_PATHNAME' LANGUAGE C;\n\nCREATE TRUSTED LANGUAGE @LANG_NAME@\n\tHANDLER plv8_call_handler\n#if PG_VERSION_NUM >= 90000\n\tINLINE plv8_inline_handler\n#endif\n\tVALIDATOR plv8_call_validator;\n\n#ifdef LANG_plv8\nCREATE DOMAIN plv8_int2array AS int2[];\nCREATE DOMAIN plv8_int4array AS int4[];\nCREATE DOMAIN plv8_float4array AS float4[];\nCREATE DOMAIN plv8_float8array AS float8[];\nCREATE DOMAIN plv8_int8array AS int8[];\n\nCREATE OR REPLACE FUNCTION plv8_version ( )\nRETURNS TEXT AS\n$$\n\treturn \"@PLV8_VERSION@\";\n$$ LANGUAGE plv8;\n\nCREATE FUNCTION plv8_reset() RETURNS void\n\tAS 'MODULE_PATHNAME' LANGUAGE C;\n\nCREATE FUNCTION plv8_info() RETURNS JSON\n\tAS 'MODULE_PATHNAME' LANGUAGE C;\nREVOKE ALL ON FUNCTION plv8_info() FROM PUBLIC;\n\n#endif\n\n\n#if PG_VERSION_NUM < 90100\nCOMMIT;\n#endif\n"
        },
        {
          "name": "plv8_allocator.cc",
          "type": "blob",
          "size": 2.015625,
          "content": "#include \"plv8_allocator.h\"\n\n#define RECHECK_INCREMENT 1_MB\n\nsize_t operator\"\"_MB( unsigned long long const x ) { return 1024L * 1024L * x; }\n\nArrayAllocator::ArrayAllocator(size_t limit) : heap_limit(limit),\n\t\t\t\t\t\t\t\t\t\t\t   heap_size(RECHECK_INCREMENT),\n\t\t\t\t\t\t\t\t\t\t\t   next_size(RECHECK_INCREMENT),\n\t\t\t\t\t\t\t\t\t\t\t   allocated(0),\n\t\t\t\t\t\t\t\t\t\t\t\t allocator(v8::ArrayBuffer::Allocator::NewDefaultAllocator()) {}\n\nArrayAllocator::~ArrayAllocator() {\n\tdelete this->allocator;\n}\n\nbool ArrayAllocator::check(const size_t length) {\n\tif (heap_size + allocated + length > next_size) {\n\t\tv8::Isolate* isolate = v8::Isolate::GetCurrent();\n\t\tv8::HeapStatistics heap_statistics;\n\t\tisolate->GetHeapStatistics(&heap_statistics);\n\t\theap_size = heap_statistics.used_heap_size();\n\t\tif (heap_size + allocated + length > heap_limit) {\n\t\t\treturn false;\n\t\t\t// we need to force GC here,\n\t\t\t// otherwise the next allocation will fail even if there is a space for it\n\t\t\tisolate->LowMemoryNotification();\n\t\t\tisolate->GetHeapStatistics(&heap_statistics);\n\t\t\theap_size = heap_statistics.used_heap_size();\n\t\t\tif (heap_size + allocated + length > heap_limit) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tnext_size = heap_size + allocated + length + RECHECK_INCREMENT;\n\t}\n\treturn heap_size + allocated + length <= heap_limit;\n}\n\nvoid* ArrayAllocator::Allocate(size_t length) {\n\tif (check(length)) {\n\t\tallocated += length;\n\t\treturn this->allocator->Allocate(length);\n\t} else {\n\t\treturn nullptr;\n\t}\n}\n\nvoid* ArrayAllocator::AllocateUninitialized(size_t length) {\n\tif (check(length)) {\n\t\tallocated += length;\n\t\treturn std::malloc(length);\n\t} else {\n\t\treturn nullptr;\n\t}\n}\n\nvoid ArrayAllocator::Free(void* data, size_t length) {\n\tallocated -= length;\n\tnext_size -= length;\n\tthis->allocator->Free(data, length);\n}\n\nvoid* ArrayAllocator::Reallocate(void *data, size_t old_length, size_t new_length) {\n\tssize_t delta = static_cast<ssize_t>(new_length) - static_cast<ssize_t>(old_length);\n\tif (delta > 0) {\n\t\tif (!check(delta)) {\n\t\t\treturn nullptr;\n\t\t}\n\t}\n\treturn this->allocator->Reallocate(data, old_length, new_length);\n}\n"
        },
        {
          "name": "plv8_allocator.h",
          "type": "blob",
          "size": 0.6796875,
          "content": "#ifndef PLV8_PLV8_ALLOCATOR_H\n#define PLV8_PLV8_ALLOCATOR_H\n\n#include <v8.h>\n#include \"plv8.h\"\n\nsize_t operator\"\"_MB( unsigned long long x );\n\nclass ArrayAllocator : public v8::ArrayBuffer::Allocator {\nprivate:\n\tsize_t heap_limit;\n\tsize_t heap_size;\n\tstd::atomic<size_t> next_size;\n\tstd::atomic<size_t> allocated;\n\tv8::ArrayBuffer::Allocator* allocator;\n\n\tbool check(size_t length);\n\npublic:\n\texplicit ArrayAllocator(size_t limit);\n\t~ArrayAllocator();\n\tvoid* Allocate(size_t length) final;\n\tvoid* AllocateUninitialized(size_t length) final;\n\tvoid Free(void* data, size_t length) final;\n\tvoid* Reallocate(void *data, size_t old_length, size_t new_length) final;\n};\n\n#endif //PLV8_PLV8_ALLOCATOR_H\n"
        },
        {
          "name": "plv8_config.h.in",
          "type": "blob",
          "size": 0.0478515625,
          "content": "#ifndef _PLV8_CONFIG_\n#undef PLV8_VERSION\n#endif\n"
        },
        {
          "name": "plv8_func.cc",
          "type": "blob",
          "size": 44.3515625,
          "content": "/*-------------------------------------------------------------------------\n *\n * plv8_func.cc : PL/v8 built-in functions.\n *\n * Copyright (c) 2009-2012, the PLV8JS Development Group.\n *-------------------------------------------------------------------------\n */\n#include \"plv8.h\"\n#include \"plv8_param.h\"\n#include <string>\n\nextern \"C\" {\n#include \"access/xact.h\"\n#include \"catalog/pg_type.h\"\n#include \"executor/spi.h\"\n#include \"parser/parse_type.h\"\n#include \"utils/builtins.h\"\n#include \"utils/lsyscache.h\"\n#include \"nodes/memnodes.h\"\n} // extern \"C\"\n\nusing namespace v8;\n\nstatic void plv8_FunctionInvoker(const FunctionCallbackInfo<v8::Value>& args) throw();\nstatic void plv8_Elog(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_Execute(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_Prepare(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_PlanCursor(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_PlanExecute(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_PlanFree(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_CursorFetch(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_CursorMove(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_CursorClose(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_ReturnNext(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_Subtransaction(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_FindFunction(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_GetWindowObject(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinGetPartitionLocal(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinSetPartitionLocal(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinGetCurrentPosition(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinGetPartitionRowCount(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinSetMarkPosition(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinRowsArePeers(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinGetFuncArgInPartition(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinGetFuncArgInFrame(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_WinGetFuncArgCurrent(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_QuoteLiteral(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_QuoteNullable(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_QuoteIdent(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_MemoryUsage(const FunctionCallbackInfo<v8::Value>& args);\n\n#if PG_VERSION_NUM >= 110000\nstatic void plv8_Commit(const FunctionCallbackInfo<v8::Value>& args);\nstatic void plv8_Rollback(const FunctionCallbackInfo<v8::Value>& args);\n#endif\n\n/*\n * Window function API allows to store partition-local memory, but\n * the allocation is only once per partition.  maxlen represents\n * the allocated size for this partition (if it's zero, the allocation\n * has just happened).  Also v8 doesn't provide vaule serialization,\n * so currently the object is JSON-ized and stored as a string.\n */\ntypedef struct window_storage\n{\n\tsize_t\t\tmaxlen;\t\t\t/* allocated memory */\n\tsize_t\t\tlen;\t\t\t/* the byte size of data */\n\tchar\t\tdata[1];\t\t/* actual string (without null-termination */\n} window_storage;\n\n#if PG_VERSION_NUM < 90100\n/*\n * quote_literal_cstr -\n *\t  returns a properly quoted literal\n */\nstatic char *\nquote_literal_cstr(const char *rawstr)\n{\n\treturn TextDatumGetCString(\n\t\t\tDirectFunctionCall1(quote_literal, CStringGetTextDatum(rawstr)));\n}\n#endif\n\nstatic inline Local<v8::Value>\nWrapCallback(FunctionCallback func)\n{\n\tIsolate* isolate = Isolate::GetCurrent();\n\treturn External::New(isolate,\n\t\t\treinterpret_cast<void *>(\n\t\t\t\treinterpret_cast<uintptr_t>(func)));\n}\n\nstatic inline FunctionCallback\nUnwrapCallback(Handle<v8::Value> value)\n{\n\treturn reinterpret_cast<FunctionCallback>(\n\t\t\treinterpret_cast<uintptr_t>(External::Cast(*value)->Value()));\n}\n\nstatic inline void\nSetCallback(Handle<ObjectTemplate> obj, const char *name,\n\t\t\tFunctionCallback func, PropertyAttribute attr = None)\n{\n\tIsolate* isolate = Isolate::GetCurrent();\n\tobj->Set(isolate, name,\n\t\t\t\tFunctionTemplate::New(isolate, plv8_FunctionInvoker,\n\t\t\t\t\tWrapCallback(func)));\n}\n\nclass SubTranBlock\n{\nprivate:\n\tResourceOwner\t\tm_resowner;\n\tMemoryContext\t\tm_mcontext;\npublic:\n\tSubTranBlock();\n\tvoid enter();\n\tvoid exit(bool success);\n};\n\nstatic text *\ncharToText(char *string)\n{\n\tint len = strlen(string);\n\ttext *result = (text *) palloc(len + 1 + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), string, len + 1);\n\n\treturn result;\n}\n\n\nstatic Handle<v8::Value>\nSPIResultToValue(int status)\n{\n\tIsolate* isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\tLocal<v8::Value>\tresult;\n\n\tif (status < 0) {\n\t\tisolate->ThrowException(v8::String::NewFromUtf8(isolate, FormatSPIStatus(status)).ToLocalChecked());\n\t\treturn result;\n\t}\n\n\tswitch (status)\n\t{\n\tcase SPI_OK_UTILITY:\n\tcase SPI_OK_REWRITTEN:\n\t{\n\t\tif (SPI_tuptable == NULL) {\n\t\t\tresult = Int32::New(isolate, SPI_processed);\n\t\t\tbreak;\n\t\t}\n\t\t// will fallthrough here to the \"SELECT\" logic below\n\t}\n\tcase SPI_OK_SELECT:\n\tcase SPI_OK_INSERT_RETURNING:\n\tcase SPI_OK_DELETE_RETURNING:\n\tcase SPI_OK_UPDATE_RETURNING:\n\t{\n\t\tint\t\t\t\tnrows = SPI_processed;\n\t\tConverter\t\tconv(SPI_tuptable->tupdesc);\n\t\tLocal<Array>\trows = Array::New(isolate, nrows);\n\n\t\tfor (int r = 0; r < nrows; r++)\n\t\t\trows->Set(context, r, conv.ToValue(SPI_tuptable->vals[r])).Check();\n\n\t\tresult = rows;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tresult = Int32::New(isolate, SPI_processed);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nSubTranBlock::SubTranBlock()\n{}\n\nvoid\nSubTranBlock::enter()\n{\n\n\tif (!IsTransactionOrTransactionBlock())\n\t\tthrow js_error(\"out of transaction\");\n\n\tm_resowner = CurrentResourceOwner;\n\tm_mcontext = CurrentMemoryContext;\n\tBeginInternalSubTransaction(NULL);\n\tMemoryContextSwitchTo(m_mcontext);\n}\n\nvoid\nSubTranBlock::exit(bool success)\n{\n\n\tif (success)\n\t\tReleaseCurrentSubTransaction();\n\telse\n\t\tRollbackAndReleaseCurrentSubTransaction();\n\n\tMemoryContextSwitchTo(m_mcontext);\n\tCurrentResourceOwner = m_resowner;\n}\n\nJSONObject::JSONObject()\n{\n\tIsolate* isolate = v8::Isolate::GetCurrent();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tHandle<Object> global = context->Global();\n\tMaybeLocal<v8::Object> maybeJson = global->Get(context, v8::String::NewFromUtf8(isolate, \"JSON\").ToLocalChecked()).ToLocalChecked()->ToObject(isolate->GetCurrentContext());\n\tif (maybeJson.IsEmpty())\n\t\tthrow js_error(\"JSON not found\");\n\tm_json = maybeJson.ToLocalChecked();\n}\n\n/*\n * Call JSON.parse().  Currently this supports only one argument.\n */\nHandle<v8::Value>\nJSONObject::Parse(Handle<v8::Value> str)\n{\n\tIsolate* isolate = v8::Isolate::GetCurrent();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tHandle<Function> parse_func =\n\t\tHandle<Function>::Cast(m_json->Get(context, v8::String::NewFromUtf8(isolate, \"parse\").ToLocalChecked()).ToLocalChecked());\n\n\tif (parse_func.IsEmpty())\n\t\tthrow js_error(\"JSON.parse() not found\");\n\n\tTryCatch try_catch(isolate);\n\tMaybeLocal<v8::Value> value = parse_func->Call(context, m_json, 1, &str);\n\tif (value.IsEmpty())\n\t\tthrow js_error(try_catch);\n\treturn value.ToLocalChecked();\n}\n\n/*\n * Call JSON.stringify().  Currently this supports only one argument.\n */\nHandle<v8::Value>\nJSONObject::Stringify(Handle<v8::Value> val)\n{\n\tIsolate* isolate = v8::Isolate::GetCurrent();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tHandle<Function> stringify_func =\n\t\tHandle<Function>::Cast(m_json->Get(context, v8::String::NewFromUtf8(isolate, \"stringify\").ToLocalChecked()).ToLocalChecked());\n\n\tif (stringify_func.IsEmpty())\n\t\tthrow js_error(\"JSON.stringify() not found\");\n\n\tTryCatch try_catch(isolate);\n\tMaybeLocal<v8::Value> value = stringify_func->Call(isolate->GetCurrentContext(), m_json, 1, &val);\n\tif (value.IsEmpty())\n\t\tthrow js_error(try_catch);\n\treturn value.ToLocalChecked();\n}\n\nvoid\nSetupPlv8Functions(Handle<ObjectTemplate> plv8)\n{\n\tPropertyAttribute\tattrFull =\n\t\tPropertyAttribute(ReadOnly | DontEnum | DontDelete);\n\n\tSetCallback(plv8, \"elog\", plv8_Elog, attrFull);\n\tSetCallback(plv8, \"execute\", plv8_Execute, attrFull);\n\tSetCallback(plv8, \"prepare\", plv8_Prepare, attrFull);\n\tSetCallback(plv8, \"return_next\", plv8_ReturnNext, attrFull);\n\tSetCallback(plv8, \"subtransaction\", plv8_Subtransaction, attrFull);\n\tSetCallback(plv8, \"find_function\", plv8_FindFunction, attrFull);\n\tSetCallback(plv8, \"get_window_object\", plv8_GetWindowObject, attrFull);\n\tSetCallback(plv8, \"quote_literal\", plv8_QuoteLiteral, attrFull);\n\tSetCallback(plv8, \"quote_nullable\", plv8_QuoteNullable, attrFull);\n\tSetCallback(plv8, \"quote_ident\", plv8_QuoteIdent, attrFull);\n\tSetCallback(plv8, \"memory_usage\", plv8_MemoryUsage, attrFull);\n\n#if PG_VERSION_NUM >= 110000\n\tSetCallback(plv8, \"rollback\", plv8_Rollback, attrFull);\n\tSetCallback(plv8, \"commit\", plv8_Commit, attrFull);\n#endif\n\tplv8->SetInternalFieldCount(PLV8_INTNL_MAX);\n}\n\nvoid\nSetupPrepFunctions(Handle<ObjectTemplate> templ)\n{\n\ttempl->SetInternalFieldCount(2);\n\tSetCallback(templ, \"cursor\", plv8_PlanCursor);\n\tSetCallback(templ, \"execute\", plv8_PlanExecute);\n\tSetCallback(templ, \"free\", plv8_PlanFree);\n}\n\nvoid\nSetupCursorFunctions(Handle<ObjectTemplate> templ)\n{\n\ttempl->SetInternalFieldCount(1);\n\tSetCallback(templ, \"fetch\", plv8_CursorFetch);\n\tSetCallback(templ, \"move\", plv8_CursorMove);\n\tSetCallback(templ, \"close\", plv8_CursorClose);\n}\n\nvoid\nSetupWindowFunctions(Handle<ObjectTemplate> templ)\n{\n\tIsolate *isolate = Isolate::GetCurrent();\n\n\t/* We store fcinfo here. */\n\ttempl->SetInternalFieldCount(1);\n\n\t/* Functions. */\n\tSetCallback(templ, \"get_partition_local\", plv8_WinGetPartitionLocal);\n\tSetCallback(templ, \"set_partition_local\", plv8_WinSetPartitionLocal);\n\tSetCallback(templ, \"get_current_position\", plv8_WinGetCurrentPosition);\n\tSetCallback(templ, \"get_partition_row_count\", plv8_WinGetPartitionRowCount);\n\tSetCallback(templ, \"set_mark_position\", plv8_WinSetMarkPosition);\n\tSetCallback(templ, \"rows_are_peers\", plv8_WinRowsArePeers);\n\tSetCallback(templ, \"get_func_arg_in_partition\", plv8_WinGetFuncArgInPartition);\n\tSetCallback(templ, \"get_func_arg_in_frame\", plv8_WinGetFuncArgInFrame);\n\tSetCallback(templ, \"get_func_arg_current\", plv8_WinGetFuncArgCurrent);\n\n\t/* Constants for get_func_in_XXX() */\n\ttempl->Set(v8::String::NewFromUtf8(isolate, \"SEEK_CURRENT\").ToLocalChecked(), Int32::New(isolate, WINDOW_SEEK_CURRENT));\n\ttempl->Set(v8::String::NewFromUtf8(isolate, \"SEEK_HEAD\").ToLocalChecked(), Int32::New(isolate, WINDOW_SEEK_HEAD));\n\ttempl->Set(v8::String::NewFromUtf8(isolate, \"SEEK_TAIL\").ToLocalChecked(), Int32::New(isolate, WINDOW_SEEK_TAIL));\n}\n\n/*\n * v8 is not exception-safe! We cannot throw C++ exceptions over v8 functions.\n * So, we catch C++ exceptions and convert them to JavaScript ones.\n */\nstatic void\nplv8_FunctionInvoker(const FunctionCallbackInfo<v8::Value> &args) throw()\n{\n\tIsolate *\t\tisolate = args.GetIsolate();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tHandleScope\t\thandle_scope(isolate);\n\tMemoryContext\tctx = CurrentMemoryContext;\n\tFunctionCallback\tfn = UnwrapCallback(args.Data());\n\n\ttry\n\t{\n\t\treturn fn(args);\n\t}\n\tcatch (js_error& e)\n\t{\n\t\targs.GetReturnValue().Set(isolate->ThrowException(e.error_object()));\n\t}\n\tcatch (pg_error& e)\n\t{\n\t\tMemoryContextSwitchTo(ctx);\n\t\tErrorData *edata = CopyErrorData();\n\n\t\tHandle<v8::String> message = ToString(edata->message);\n\t\tHandle<v8::String> sqlerrcode = ToString(unpack_sql_state(edata->sqlerrcode));\n#if PG_VERSION_NUM >= 90300\n\t\tHandle<v8::Value> schema_name = edata->schema_name ?\n\t\t\tHandle<Primitive>(ToString(edata->schema_name)) : Null(isolate);\n\t\tHandle<Primitive> table_name = edata->table_name ?\n\t\t\tHandle<Primitive>(ToString(edata->table_name)) : Null(isolate);\n\t\tHandle<Primitive> column_name = edata->column_name ?\n\t\t\tHandle<Primitive>(ToString(edata->column_name)) : Null(isolate);\n\t\tHandle<Primitive> datatype_name = edata->datatype_name ?\n\t\t\tHandle<Primitive>(ToString(edata->datatype_name)) : Null(isolate);\n\t\tHandle<Primitive> constraint_name = edata->constraint_name ?\n\t\t\tHandle<Primitive>(ToString(edata->constraint_name)) : Null(isolate);\n\t\tHandle<Primitive> detail = edata->detail ?\n\t\t\tHandle<Primitive>(ToString(edata->detail)) : Null(isolate);\n\t\tHandle<Primitive> hint = edata->hint ?\n\t\t\tHandle<Primitive>(ToString(edata->hint)) : Null(isolate);\n\t\tHandle<Primitive> sql_context = edata->context ?\n\t\t\tHandle<Primitive>(ToString(edata->context)) : Null(isolate);\n\t\tHandle<Primitive> internalquery = edata->internalquery ?\n\t\t\tHandle<Primitive>(ToString(edata->internalquery)) : Null(isolate);\n\t\tHandle<v8::Integer> code = Uint32::New(isolate, edata->sqlerrcode);\n\n#endif\n\n\t\tFlushErrorState();\n\t\tFreeErrorData(edata);\n\n\t\tHandle<v8::Object> err = Exception::Error(message)->ToObject(isolate->GetCurrentContext()).ToLocalChecked();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"sqlerrcode\").ToLocalChecked(), sqlerrcode).Check();\n#if PG_VERSION_NUM >= 90300\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"schema_name\").ToLocalChecked(), schema_name).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"table_name\").ToLocalChecked(), table_name).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"column_name\").ToLocalChecked(), column_name).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"datatype_name\").ToLocalChecked(), datatype_name).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"constraint_name\").ToLocalChecked(), constraint_name).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"detail\").ToLocalChecked(), detail).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"hint\").ToLocalChecked(), hint).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"context\").ToLocalChecked(), sql_context).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"internalquery\").ToLocalChecked(), internalquery).Check();\n\t\terr->Set(context, v8::String::NewFromUtf8(isolate, \"code\").ToLocalChecked(), code).Check();\n#endif\n\n\t\targs.GetReturnValue().Set(isolate->ThrowException(err));\n\t}\n}\n\n/*\n * plv8.elog(elevel, str)\n */\nstatic void\nplv8_Elog(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tMemoryContext\tctx = CurrentMemoryContext;\n\tIsolate *\t\tisolate = args.GetIsolate();\n\n\tif (args.Length() < 2) {\n\t\targs.GetReturnValue().Set(isolate->ThrowException(v8::String::NewFromUtf8(args.GetIsolate(), \"usage: plv8.elog(elevel, ...)\").ToLocalChecked()));\n\t\treturn;\n\t}\n\n\tint\televel = args[0]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tswitch (elevel)\n\t{\n\tcase DEBUG5:\n\tcase DEBUG4:\n\tcase DEBUG3:\n\tcase DEBUG2:\n\tcase DEBUG1:\n\tcase LOG:\n\tcase INFO:\n\tcase NOTICE:\n\tcase WARNING:\n\tcase ERROR:\n\t\tbreak;\n\tdefault:\n\t\targs.GetReturnValue().Set(isolate->ThrowException(v8::String::NewFromUtf8(args.GetIsolate(), \"invalid error level\").ToLocalChecked()));\n\t\treturn;\n\t}\n\n\tstd::string msg;\n\tstd::string buf;\n\tfor (int i = 1; i < args.Length(); i++)\n\t{\n\t\tif (i > 1){\n\t\t\tmsg += \" \";\n\t\t}\n\t\t//elog(NOTICE, \"msg -> %s\", msg.c_str());\n\t\t//elog(NOTICE, \"buf -> %s\", buf.c_str());\n\n\t\tif (!CString::toStdString(args[i],buf)){\n\t\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tCString::toStdString(args[i],buf);\n\t\tmsg += buf;\n\t}\n\n\tconst char\t*message = msg.c_str();\n\n\tif (elevel != ERROR)\n\t{\n\t\telog(elevel, \"%s\", message);\n\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\n\t/* ERROR case */\n\tPG_TRY();\n\t{\n\t\telog(elevel, \"%s\", message);\n\t}\n\tPG_CATCH();\n\t{\n\t\tMemoryContextSwitchTo(ctx);\n\t\tErrorData *edata = CopyErrorData();\n\t\tLocal<v8::String> message = ToString(edata->message);\n\t\tFlushErrorState();\n\t\tFreeErrorData(edata);\n\n\t\targs.GetReturnValue().Set(isolate->ThrowException(Exception::Error(message)));\n\t\treturn;\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(Undefined(isolate));\n}\n\nstatic Datum\nvalue_get_datum(Handle<v8::Value> value, Oid typid, char *isnull)\n{\n\tif (value->IsUndefined() || value->IsNull())\n\t{\n\t\t*isnull = 'n';\n\t\treturn (Datum) 0;\n\t}\n\telse\n\t{\n\t\tplv8_type\ttypinfo = { 0 };\n\t\tbool\t\tIsNull;\n\t\tDatum\t\tdatum;\n\n\t\tplv8_fill_type(&typinfo, typid);\n\t\ttry\n\t\t{\n\t\t\tdatum = ToDatum(value, &IsNull, &typinfo);\n\t\t}\n\t\tcatch (js_error& e){ e.rethrow(); }\n\t\tcatch (pg_error& e){ e.rethrow(); }\n\t\t*isnull = (IsNull ?  'n' : ' ');\n\t\treturn datum;\n\t}\n}\n\nstatic int\nplv8_execute_params(const char *sql, Handle<Array> params)\n{\n\tAssert(!params.IsEmpty());\n\n\tint\t\t\t\tstatus;\n\tint\t\t\t\tnparam = params->Length();\n\tDatum\t\t   *values = (Datum *) palloc(sizeof(Datum) * nparam);\n\tchar\t\t   *nulls = (char *) palloc(sizeof(char) * nparam);\n\tIsolate *isolate = Isolate::GetCurrent();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\n/*\n * Since 9.0, SPI may have the parser deduce the parameter types.  In prior\n * versions, we infer the types from the input JS values.\n */\n#if PG_VERSION_NUM >= 90000\n\tSPIPlanPtr\t\tplan;\n\tplv8_param_state parstate = {0};\n\tParamListInfo\tparamLI;\n\n\tparstate.memcontext = CurrentMemoryContext;\n\tplan = SPI_prepare_params(sql, plv8_variable_param_setup,\n\t\t\t\t\t\t\t  &parstate, 0);\n\tif (parstate.numParams != nparam)\n\t\telog(ERROR, \"parameter numbers mismatch: %d != %d\",\n\t\t\t\tparstate.numParams, nparam);\n\tfor (int i = 0; i < nparam; i++)\n\t{\n\t\tHandle<v8::Value>\tparam = params->Get(context, i).ToLocalChecked();\n\t\tvalues[i] = value_get_datum(param,\n\t\t\t\t\t\t\t\t  parstate.paramTypes[i], &nulls[i]);\n\t}\n\tparamLI = plv8_setup_variable_paramlist(&parstate, values, nulls);\n\tstatus = SPI_execute_plan_with_paramlist(plan, paramLI, false, 0);\n#else\n\tOid\t\t\t   *types = (Oid *) palloc(sizeof(Oid) * nparam);\n\n\tfor (int i = 0; i < nparam; i++)\n\t{\n\t\tHandle<v8::Value>\tparam = params->Get(context, i);\n\n\t\ttypes[i] = inferred_datum_type(param);\n\t\tif (types[i] == InvalidOid)\n\t\t\telog(ERROR, \"parameter[%d] cannot translate to a database type\", i);\n\n\t\tvalues[i] = value_get_datum(param, types[i], &nulls[i]);\n\t}\n\tstatus = SPI_execute_with_args(sql, nparam, types, values, nulls, false, 0);\n\n\tpfree(types);\n#endif\n\n\tpfree(values);\n\tpfree(nulls);\n\treturn status;\n}\n\nstatic Handle<Array>\nconvertArgsToArray(const FunctionCallbackInfo<v8::Value> &args, int start, int downshift)\n{\n\tIsolate *isolate = Isolate::GetCurrent();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tLocal<Array> result = Array::New(args.GetIsolate(), args.Length() - start);\n\tfor (int i = start; i < args.Length(); i++)\n\t{\n\t\tresult->Set(context, i - downshift, args[i]).Check();\n\t}\n\treturn result;\n}\n\n/*\n * plv8.execute(statement, [param, ...])\n */\nstatic void\nplv8_Execute(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tint\t\t\t\tstatus;\n\n\tif (args.Length() < 1) {\n\t\targs.GetReturnValue().Set(Undefined(args.GetIsolate()));\n\t\treturn;\n\t}\n\n\tCString\t\t\tsql(args[0]);\n\tHandle<Array>\tparams;\n\n\tif (args.Length() >= 2)\n\t{\n\t\tif (args[1]->IsArray())\n\t\t\tparams = Handle<Array>::Cast(args[1]);\n\t\telse /* Consume trailing elements as an array. */\n\t\t\tparams = convertArgsToArray(args, 1, 1);\n\t}\n\n\tint\t\t\t\tnparam = params.IsEmpty() ? 0 : params->Length();\n\n\n\tSubTranBlock\tsubtran;\n\tPG_TRY();\n\t{\n\t\tsubtran.enter();\n\t\tif (nparam == 0)\n\t\t\tstatus = SPI_exec(sql, 0);\n\t\telse\n\t\t\tstatus = plv8_execute_params(sql, params);\n\t}\n\tPG_CATCH();\n\t{\n\t\tsubtran.exit(false);\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tsubtran.exit(true);\n\targs.GetReturnValue().Set(SPIResultToValue(status));\n}\n\n/*\n * plv8.prepare(statement, args...)\n */\nstatic void\nplv8_Prepare(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tIsolate *\t\tisolate = args.GetIsolate();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tSPIPlanPtr\t\tinitial = NULL, saved;\n\tCString\t\t\tsql(args[0]);\n\tHandle<Array>\tarray;\n\tint\t\t\t\tarraylen = 0;\n\tOid\t\t\t   *types = NULL;\n\tplv8_param_state *parstate = NULL;\n\n\tif (args.Length() > 1)\n\t{\n\t\tif (args[1]->IsArray())\n\t\t\tarray = Handle<Array>::Cast(args[1]);\n\t\telse /* Consume trailing elements as an array. */\n\t\t\tarray = convertArgsToArray(args, 1, 0);\n\t\tarraylen = array->Length();\n\t\ttypes = (Oid *) palloc(sizeof(Oid) * arraylen);\n\t}\n\n\tfor (int i = 0; i < arraylen; i++)\n\t{\n\t\tCString\t\t\ttypestr(array->Get(context, i).ToLocalChecked());\n\t\tint32\t\t\ttypemod;\n\n#if PG_VERSION_NUM >= 90400\n#if PG_VERSION_NUM >= 160000\n\t\tparseTypeString(typestr, &types[i], &typemod, NULL);\n#else\n\t\tparseTypeString(typestr, &types[i], &typemod, false);\n#endif\n#else\n\t\tparseTypeString(typestr, &types[i], &typemod);\n#endif\n\t}\n\n\tPG_TRY();\n\t{\n#if PG_VERSION_NUM >= 90000\n\t\tif (args.Length() == 1)\n\t\t{\n\t\t\tparstate =\n\t\t\t\t(plv8_param_state *) palloc0(sizeof(plv8_param_state));\n\t\t\tparstate->memcontext = CurrentMemoryContext;\n\t\t\tinitial = SPI_prepare_params(sql, plv8_variable_param_setup,\n\t\t\t\t\t\t\t\t\t\t parstate, 0);\n\t\t}\n\t\telse\n#endif\n\t\t\tinitial = SPI_prepare(sql, arraylen, types);\n\t\tsaved = SPI_saveplan(initial);\n\t\tSPI_freeplan(initial);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tLocal<ObjectTemplate> templ = Local<ObjectTemplate>::New(isolate, current_context->plan_template);\n\n\tLocal<v8::Object> result = templ->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();\n\tresult->SetInternalField(0, External::New(isolate, saved));\n\tresult->SetInternalField(1, External::New(isolate, parstate));\n\n\targs.GetReturnValue().Set(result);\n}\n\n/*\n * plan.cursor(args, ...)\n */\nstatic void\nplv8_PlanCursor(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tIsolate *\t\t\tisolate = args.GetIsolate();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tHandle<v8::Object>\tself = args.This();\n\tSPIPlanPtr\t\t\tplan;\n\tDatum\t\t\t   *values = NULL;\n\tchar\t\t\t   *nulls = NULL;\n\tint\t\t\t\t\tnparam = 0, argcount;\n\tHandle<Array>\t\tparams;\n\tPortal\t\t\t\tcursor;\n\tplv8_param_state   *parstate = NULL;\n\n\tplan = static_cast<SPIPlanPtr>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(0))->Value());\n\n\tif (plan == NULL) {\n\t\tStringInfoData\tbuf;\n\n\t\tinitStringInfo(&buf);\n\t\tappendStringInfo(&buf,\n\t\t\t\t\"plan unexpectedly null\");\n\t\tthrow js_error(pstrdup(buf.data));\n\t}\n\t/* XXX: Add plan validation */\n\n\tif (args.Length() > 0)\n\t{\n\t\tif (args[0]->IsArray())\n\t\t\tparams = Handle<Array>::Cast(args[0]);\n\t\telse\n\t\t\tparams = convertArgsToArray(args, 0, 0);\n\t\tnparam = params->Length();\n\t}\n\n\t/*\n\t * If the plan has the variable param info, use it.\n\t */\n\tparstate = static_cast<plv8_param_state *>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(1))->Value());\n\n\tif (parstate)\n\t\targcount = parstate->numParams;\n\telse\n\t\targcount = SPI_getargcount(plan);\n\n\tif (argcount != nparam)\n\t{\n\t\tStringInfoData\tbuf;\n\n\t\tinitStringInfo(&buf);\n\t\tappendStringInfo(&buf,\n\t\t\t\t\"plan expected %d argument(s), given is %d\", argcount, nparam);\n\t\tthrow js_error(pstrdup(buf.data));\n\t}\n\n\tif (nparam > 0)\n\t{\n\t\tvalues = (Datum *) palloc(sizeof(Datum) * nparam);\n\t\tnulls = (char *) palloc(sizeof(char) * nparam);\n\t}\n\n\tfor (int i = 0; i < nparam; i++)\n\t{\n\t\tHandle<v8::Value>\tparam = params->Get(context, i).ToLocalChecked();\n\t\tOid\t\t\t\t\ttypid;\n\n\t\tif (parstate)\n\t\t\ttypid = parstate->paramTypes[i];\n\t\telse\n\t\t\ttypid = SPI_getargtypeid(plan, i);\n\n\t\tvalues[i] = value_get_datum(param, typid, &nulls[i]);\n\t}\n\n\tPG_TRY();\n\t{\n#if PG_VERSION_NUM >= 90000\n\t\tif (parstate)\n\t\t{\n\t\t\tParamListInfo\tparamLI;\n\n\t\t\tparamLI = plv8_setup_variable_paramlist(parstate, values, nulls);\n\t\t\tcursor = SPI_cursor_open_with_paramlist(NULL, plan, paramLI, false);\n\t\t}\n\t\telse\n#endif\n\t\t\tcursor = SPI_cursor_open(NULL, plan, values, nulls, false);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tHandle<v8::String> cname = ToString(cursor->name, strlen(cursor->name));\n\tLocal<ObjectTemplate> templ = Local<ObjectTemplate>::New(isolate, current_context->cursor_template);\n\n\tLocal<v8::Object> result = templ->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();\n\tresult->SetInternalField(0, cname);\n\n\targs.GetReturnValue().Set(result);\n}\n\n/*\n * plan.execute(args, ...)\n */\nstatic void\nplv8_PlanExecute(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tHandle<v8::Object>\tself = args.This();\n\tSPIPlanPtr\t\t\tplan;\n\tDatum\t\t\t   *values = NULL;\n\tchar\t\t\t   *nulls = NULL;\n\tint\t\t\t\t\tnparam = 0, argcount;\n\tHandle<Array>\t\tparams;\n\tSubTranBlock\t\tsubtran;\n\tint\t\t\t\t\tstatus;\n\tplv8_param_state   *parstate = NULL;\n\tIsolate *\t\tisolate = args.GetIsolate();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\n\n\tplan = static_cast<SPIPlanPtr>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(0))->Value());\n\t/* XXX: Add plan validation */\n\n\tif (args.Length() > 0)\n\t{\n\t\tif (args[0]->IsArray())\n\t\t\tparams = Handle<Array>::Cast(args[0]);\n\t\telse\n\t\t\tparams = convertArgsToArray(args, 0, 0);\n\t\tnparam = params->Length();\n\t}\n\n\t/*\n\t * If the plan has the variable param info, use it.\n\t */\n\tparstate = static_cast<plv8_param_state *>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(1))->Value());\n\n\tif (parstate)\n\t\targcount = parstate->numParams;\n\telse\n\t\targcount = SPI_getargcount(plan);\n\n\tif (argcount != nparam)\n\t{\n\t\tStringInfoData\tbuf;\n\n\t\tinitStringInfo(&buf);\n\t\tappendStringInfo(&buf,\n\t\t\t\t\"plan expected %d argument(s), given is %d\", argcount, nparam);\n\t\tthrow js_error(pstrdup(buf.data));\n\t}\n\n\tif (nparam > 0)\n\t{\n\t\tvalues = (Datum *) palloc(sizeof(Datum) * nparam);\n\t\tnulls = (char *) palloc(sizeof(char) * nparam);\n\t}\n\n\tfor (int i = 0; i < nparam; i++)\n\t{\n\t\tHandle<v8::Value>\tparam = params->Get(context, i).ToLocalChecked();\n\t\tOid\t\t\t\t\ttypid;\n\n\t\tif (parstate)\n\t\t\ttypid = parstate->paramTypes[i];\n\t\telse\n\t\t\ttypid = SPI_getargtypeid(plan, i);\n\n\t\tvalues[i] = value_get_datum(param, typid, &nulls[i]);\n\t}\n\n\tPG_TRY();\n\t{\n\t\tsubtran.enter();\n#if PG_VERSION_NUM >= 90000\n\t\tif (parstate)\n\t\t{\n\t\t\tParamListInfo\tparamLI;\n\n\t\t\tparamLI = plv8_setup_variable_paramlist(parstate, values, nulls);\n\t\t\tstatus = SPI_execute_plan_with_paramlist(plan, paramLI, false, 0);\n\t\t}\n\t\telse\n#endif\n\t\t\tstatus = SPI_execute_plan(plan, values, nulls, false, 0);\n\t}\n\tPG_CATCH();\n\t{\n\t\tsubtran.exit(false);\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tsubtran.exit(true);\n\n\targs.GetReturnValue().Set(SPIResultToValue(status));\n\tSPI_freetuptable(SPI_tuptable);\n}\n\n/*\n * plan.free()\n */\nstatic void\nplv8_PlanFree(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tIsolate *\t\t\tisolate = args.GetIsolate();\n\tHandle<v8::Object>\tself = args.This();\n\tSPIPlanPtr\t\t\tplan;\n\tplv8_param_state   *parstate;\n\tint\t\t\t\t\tstatus = 0;\n\n\tplan = static_cast<SPIPlanPtr>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(0))->Value());\n\n\tif (plan)\n\t\tstatus = SPI_freeplan(plan);\n\n\tself->SetInternalField(0, External::New(isolate, 0));\n\n\tparstate = static_cast<plv8_param_state *>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(1))->Value());\n\n\tif (parstate)\n\t\tpfree(parstate);\n\tself->SetInternalField(1, External::New(isolate, 0));\n\n\targs.GetReturnValue().Set(Int32::New(isolate, status));\n}\n\n/*\n * cursor.fetch([n])\n */\nstatic void\nplv8_CursorFetch(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tIsolate*\t\t\tisolate = args.GetIsolate();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\tHandle<v8::Object>\tself = args.This();\n\n\tif (self->InternalFieldCount() == 0) {\n\t\tthrow js_error(\"cannot find cursor\");\n\t}\n\n\tCString\t\t\t\tcname(self->GetInternalField(0));\n\tPortal\t\t\t\tcursor = SPI_cursor_find(cname);\n\tint\t\t\t\t\tnfetch = 1;\n\tbool\t\t\t\tforward = true, wantarray = false;\n\n\tif (!cursor)\n\t\tthrow js_error(\"cannot find cursor\");\n\n\tif (args.Length() >= 1)\n\t{\n\t\twantarray = true;\n\t\tnfetch = args[0]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\n\t\tif (nfetch < 0)\n\t\t{\n\t\t\tnfetch = -nfetch;\n\t\t\tforward = false;\n\t\t}\n\t}\n\tPG_TRY();\n\t{\n\t\tSPI_cursor_fetch(cursor, forward, nfetch);\n\t}\n\tPG_CATCH();\n\t{\n\t\tSPI_rollback();\n\t\tSPI_finish();\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tif (SPI_processed > 0)\n\t{\n\t\tConverter\t\t\tconv(SPI_tuptable->tupdesc);\n\n\t\tif (!wantarray)\n\t\t{\n\t\t\tHandle<v8::Object>\tresult = conv.ToValue(SPI_tuptable->vals[0]);\n\t\t\targs.GetReturnValue().Set(result);\n\t\t\tSPI_freetuptable(SPI_tuptable);\n\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tHandle<Array> array = Array::New(isolate);\n\t\t\tfor (unsigned int i = 0; i < SPI_processed; i++)\n\t\t\t\tarray->Set(context, i, conv.ToValue(SPI_tuptable->vals[i])).Check();\n\t\t\targs.GetReturnValue().Set(array);\n\t\t\tSPI_freetuptable(SPI_tuptable);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\targs.GetReturnValue().Set(Undefined(isolate));\n}\n\n/*\n * cursor.move(n)\n */\nstatic void\nplv8_CursorMove(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\t\tisolate = args.GetIsolate();\n\tHandle<v8::Object>\tself = args.This();\n\tCString\t\t\t\tcname(self->GetInternalField(0));\n\tPortal\t\t\t\tcursor = SPI_cursor_find(cname);\n\tint\t\t\t\t\tnmove = 1;\n\tbool\t\t\t\tforward = true;\n\n\tif (!cursor)\n\t\tthrow js_error(\"cannot find cursor\");\n\n\tif (args.Length() < 1) {\n\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\n\tnmove = args[0]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tif (nmove < 0)\n\t{\n\t\tnmove = -nmove;\n\t\tforward = false;\n\t}\n\n\tPG_TRY();\n\t{\n\t\tSPI_cursor_move(cursor, forward, nmove);\n\t}\n\tPG_CATCH();\n\t{\n\t\tSPI_rollback();\n\t\tSPI_finish();\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(Undefined(isolate));\n}\n\n/*\n * cursor.close()\n */\nstatic void\nplv8_CursorClose(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tHandle<v8::Object>\tself = args.This();\n\tCString\t\t\t\tcname(self->GetInternalField(0));\n\tPortal\t\t\t\tcursor = SPI_cursor_find(cname);\n\n\tif (!cursor)\n\t\tthrow js_error(\"cannot find cursor\");\n\n\tPG_TRY();\n\t{\n\t\tSPI_cursor_close(cursor);\n\t}\n\tPG_CATCH();\n\t{\n\t\tSPI_rollback();\n\t\tSPI_finish();\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(Int32::New(args.GetIsolate(), cursor ? 1 : 0));\n}\n\n/*\n * plv8.return_next(retval)\n */\nstatic void\nplv8_ReturnNext(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tHandle<v8::Object>\tself = args.This();\n\tHandle<v8::Value>\tconv_value = self->GetInternalField(PLV8_INTNL_CONV);\n\n\tif (!conv_value->IsExternal())\n\t\tthrow js_error(\"return_next called in context that cannot accept a set\");\n\n\tConverter *conv = static_cast<Converter *>(\n\t\t\tHandle<External>::Cast(conv_value)->Value());\n\n\tTuplestorestate *tupstore = static_cast<Tuplestorestate *>(\n\t\t\tHandle<External>::Cast(\n\t\t\t\tself->GetInternalField(PLV8_INTNL_TUPSTORE))->Value());\n\n\tconv->ToDatum(args[0], tupstore);\n\n\targs.GetReturnValue().Set(Undefined(args.GetIsolate()));\n}\n\n/*\n * plv8.subtransaction(func(){ ... })\n */\nstatic void\nplv8_Subtransaction(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate *\t\tisolate = args.GetIsolate();\n\n\tif (args.Length() < 1) {\n\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\tif (!args[0]->IsFunction()) {\n\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\tHandle<Function>\tfunc = Handle<Function>::Cast(args[0]);\n\tSubTranBlock\t\tsubtran;\n\n\tsubtran.enter();\n\n\tHandle<v8::Value> emptyargs[1] = {};\n\tTryCatch try_catch(isolate);\n\tMaybeLocal<v8::Value> result = func->Call(isolate->GetCurrentContext(), func, 0, emptyargs);\n\n\tsubtran.exit(!result.IsEmpty());\n\n\tif (result.IsEmpty())\n\t\tthrow js_error(try_catch);\n\targs.GetReturnValue().Set(result.ToLocalChecked());\n}\n\n/*\n * plv8.find_function(\"signature\")\n */\nstatic void\nplv8_FindFunction(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate\t\t\t    *isolate = Isolate::GetCurrent();\n\tif (args.Length() < 1) {\n\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\tCString\t\t\t\tsignature(args[0]);\n\tLocal<Function>\t\tfunc;\n#if PG_VERSION_NUM < 120000\n\tFunctionCallInfoData fake_fcinfo;\n#else\n\t// Stack-allocate FunctionCallInfoBaseData with\n\t// space for 2 arguments:\n\tLOCAL_FCINFO(fake_fcinfo, 2);\n#endif\n\tFmgrInfo\tflinfo;\n\ttext *arg;\n\n\tchar perm[16];\n\tstrcpy(perm, \"EXECUTE\");\n\targ = charToText(perm);\n\tOid funcoid;\n\n\tPG_TRY();\n\t{\n\t\tif (strchr(signature, '(') == NULL)\n\t\t\tfuncoid = DatumGetObjectId(\n\t\t\t\t\tDirectFunctionCall1(regprocin, CStringGetDatum(signature.str())));\n\t\telse\n\t\t\tfuncoid = DatumGetObjectId(\n\t\t\t\t\tDirectFunctionCall1(regprocedurein, CStringGetDatum(signature.str())));\n\n#if PG_VERSION_NUM < 120000\n\t\tMemSet(&fake_fcinfo, 0, sizeof(fake_fcinfo));\n\t\tMemSet(&flinfo, 0, sizeof(flinfo));\n\t\tfake_fcinfo.flinfo = &flinfo;\n\t\tflinfo.fn_oid = InvalidOid;\n\t\tflinfo.fn_mcxt = CurrentMemoryContext;\n\t\tfake_fcinfo.nargs = 2;\n\t\tfake_fcinfo.arg[0] = ObjectIdGetDatum(funcoid);\n\t\tfake_fcinfo.arg[1] = CStringGetDatum(arg);\n\t\tDatum ret = has_function_privilege_id(&fake_fcinfo);\n#else\n\t\tMemSet(&flinfo, 0, sizeof(flinfo));\n\t\tfake_fcinfo->flinfo = &flinfo;\n\t\tflinfo.fn_oid = InvalidOid;\n\t\tflinfo.fn_mcxt = CurrentMemoryContext;\n\t\tfake_fcinfo->nargs = 2;\n\t\tfake_fcinfo->args[0].value = ObjectIdGetDatum(funcoid);\n\t\tfake_fcinfo->args[1].value = PointerGetDatum(arg);\n\t\tDatum ret = has_function_privilege_id(fake_fcinfo);\n#endif\n\n\t\tif (ret == 0) {\n\t\t\telog(WARNING, \"failed to find or no permission for js function %s\", signature.str());\n\t\t} else {\n\t\t\tif (DatumGetBool(ret)) {\n\t\t\t\tfunc = find_js_function(funcoid);\n\t\t\t\tif (func.IsEmpty())\n\t\t\t\t\telog(ERROR, \"javascript function is not found for \\\"%s\\\"\", signature.str());\n\t\t\t} else {\n\t\t\t\telog(WARNING, \"no permission to execute js function %s\", signature.str());\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(func);\n}\n\n/*\n * plv8.get_window_object()\n * Returns window object in window functions, which provides window function API.\n */\nstatic void\nplv8_GetWindowObject(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\t\tisolate = args.GetIsolate();\n\tHandle<v8::Object>\tself = args.This();\n\tHandle<v8::Value>\tfcinfo_value =\n\t\t\tself->GetInternalField(PLV8_INTNL_FCINFO);\n\n\tif (!fcinfo_value->IsExternal())\n\t\tthrow js_error(\"get_window_object called in wrong context\");\n\tLocal<ObjectTemplate> templ = Local<ObjectTemplate>::New(isolate, current_context->window_template);\n\n\tLocal<v8::Object> js_winobj = templ->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();\n\tjs_winobj->SetInternalField(0, fcinfo_value);\n\n\targs.GetReturnValue().Set(js_winobj);\n}\n\n/*\n * Short-cut routine for window function API\n */\nstatic inline WindowObject\nplv8_MyWindowObject(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tHandle<v8::Object>\tself = args.This();\n\t/* fcinfo is embedded in the internal field.  See plv8_GetWindowObject() */\n\tFunctionCallInfo fcinfo = static_cast<FunctionCallInfo>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(0))->Value());\n\n\tif (fcinfo == NULL)\n\t\tthrow js_error(\"window function api called with wrong object\");\n\n\tWindowObject winobj = PG_WINDOW_OBJECT();\n\n\tif (!winobj)\n\t\tthrow js_error(\"window function api called with wrong object\");\n\treturn winobj;\n}\n\n/*\n * Short-cut routine for window function API\n * Unfortunately, in the JS functino level we don't know the plv8 function\n * argument information enough.  Thus, we obtain it from function expression.\n */\nstatic inline plv8_type *\nplv8_MyArgType(const FunctionCallbackInfo<v8::Value>& args, int argno)\n{\n\tHandle<v8::Object>\tself = args.This();\n\tFunctionCallInfo fcinfo = static_cast<FunctionCallInfo>(\n\t\t\tHandle<External>::Cast(self->GetInternalField(0))->Value());\n\n\tif (fcinfo == NULL)\n\t\tthrow js_error(\"window function api called with wrong object\");\n\n\t/* This is safe to call in C++ context (without PG_TRY). */\n\treturn get_plv8_type(fcinfo, argno);\n}\n\n/*\n * winobj.get_partition_local([size])\n * The default allocation size is 1K, but the caller can override this value\n * by the argument at the first call.\n */\nstatic void\nplv8_WinGetPartitionLocal(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\tisolate = args.GetIsolate();\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\tsize_t\t\t\tsize;\n\twindow_storage *storage;\n\n\tif (args.Length() < 1)\n\t\tsize = 1000; /* default 1K */\n\telse\n\t\tsize = args[0]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\n\tsize += sizeof(size_t) * 2;\n\n\tPG_TRY();\n\t{\n\t\tstorage = (window_storage *) WinGetPartitionLocalMemory(winobj, size);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\t/* If it's new, store the maximum size. */\n\tif (storage->maxlen == 0)\n\t\tstorage->maxlen = size;\n\n\t/* If nothing is stored, undefined is returned. */\n\tif (storage->len == 0) {\n\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\n\t/*\n\t * Currently we support only serializable JSON object to be stored.\n\t */\n\tJSONObject JSON;\n\tHandle<v8::Value> value = ToString(storage->data, storage->len);\n\n\targs.GetReturnValue().Set(JSON.Parse(value));\n}\n\n/*\n * winobj.set_partition_local(obj)\n * If the storage has not been allocated, it's allocated based on the\n * size of JSON-ized input string.\n */\nstatic void\nplv8_WinSetPartitionLocal(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\tisolate = args.GetIsolate();\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\n\tif (args.Length() < 1) {\n\t\targs.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\n\tJSONObject JSON;\n\tHandle<v8::Value> value = JSON.Stringify(args[0]);\n\tCString str(value);\n\tsize_t str_size = strlen(str);\n\tsize_t size = str_size + sizeof(size_t) * 2;\n\twindow_storage *storage;\n\n\tPG_TRY();\n\t{\n\t\tstorage = (window_storage *) WinGetPartitionLocalMemory(winobj, size);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tif (storage->maxlen != 0 && storage->maxlen < size)\n\t{\n\t\tthrow js_error(\"window local memory overflow\");\n\t}\n\telse if (storage->maxlen == 0)\n\t{\n\t\t/* new allocation */\n\t\tstorage->maxlen = size;\n\t}\n\tstorage->len = str_size;\n\tmemcpy(storage->data, str, str_size);\n\n\targs.GetReturnValue().Set(Undefined(isolate));\n}\n\n/*\n * winobj.get_current_position()\n */\nstatic void\nplv8_WinGetCurrentPosition(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\tint64\t\t\tpos = 0;\n\n\tPG_TRY();\n\t{\n\t\tpos = WinGetCurrentPosition(winobj);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(v8::Integer::New(args.GetIsolate(), pos));\n}\n\n/*\n * winobj.get_partition_row_count()\n */\nstatic void\nplv8_WinGetPartitionRowCount(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\tint64\t\t\tpos = 0;\n\n\tPG_TRY();\n\t{\n\t\tpos = WinGetPartitionRowCount(winobj);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(v8::Integer::New(args.GetIsolate(), pos));\n}\n\n/*\n * winobj.set_mark_pos(pos)\n */\nstatic void\nplv8_WinSetMarkPosition(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\tisolate = args.GetIsolate();\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\tif (args.Length() < 1) {\n                args.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n        }\n\tint64\t\tmarkpos = args[0]->IntegerValue(isolate->GetCurrentContext()).ToChecked();\n\n\tPG_TRY();\n\t{\n\t\tWinSetMarkPosition(winobj, markpos);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n        args.GetReturnValue().Set(Undefined(isolate));\n}\n\n/*\n * winobj.rows_are_peers(pos1, pos2)\n */\nstatic void\nplv8_WinRowsArePeers(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\tisolate = args.GetIsolate();\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\tif (args.Length() < 2) {\n                args.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\tint64\t\tpos1 = args[0]->IntegerValue(isolate->GetCurrentContext()).ToChecked();\n\tint64\t\tpos2 = args[1]->IntegerValue(isolate->GetCurrentContext()).ToChecked();\n\tbool\t\tres = false;\n\n\tPG_TRY();\n\t{\n\t\tres = WinRowsArePeers(winobj, pos1, pos2);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(v8::Boolean::New(isolate, res));\n}\n\n/*\n * winobj.get_func_arg_in_partition(argno, relpos, seektype, set_mark)\n */\nstatic void\nplv8_WinGetFuncArgInPartition(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\tisolate = args.GetIsolate();\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\t/* Since we return undefined in \"isout\" case, throw if arg isn't enough. */\n\tif (args.Length() < 4)\n\t\tthrow js_error(\"argument not enough\");\n\tint\t\t\targno = args[0]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tint\t\t\trelpos = args[1]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tint\t\t\tseektype = args[2]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tbool\t\tset_mark = args[3]->BooleanValue(isolate);\n\tbool\t\tisnull, isout;\n\tDatum\t\tres;\n\n\tPG_TRY();\n\t{\n\t\tres = WinGetFuncArgInPartition(winobj,\n\t\t\t\t\t\t\t\t\t   argno,\n\t\t\t\t\t\t\t\t\t   relpos,\n\t\t\t\t\t\t\t\t\t   seektype,\n\t\t\t\t\t\t\t\t\t   set_mark,\n\t\t\t\t\t\t\t\t\t   &isnull,\n\t\t\t\t\t\t\t\t\t   &isout);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\t/* Return undefined to tell it's out of partition. */\n\tif (isout) {\n                args.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\n\tplv8_type *type = plv8_MyArgType(args, argno);\n\n\targs.GetReturnValue().Set(ToValue(res, isnull, type));\n}\n\n/*\n * winobj.get_func_arg_in_frame(argno, relpos, seektype, set_mark)\n */\nstatic void\nplv8_WinGetFuncArgInFrame(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\tisolate = args.GetIsolate();\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\t/* Since we return undefined in \"isout\" case, throw if arg isn't enough. */\n\tif (args.Length() < 4)\n\t\tthrow js_error(\"argument not enough\");\n\tint\t\t\targno = args[0]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tint\t\t\trelpos = args[1]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tint\t\t\tseektype = args[2]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tbool\t\tset_mark = args[3]->BooleanValue(isolate);\n\tbool\t\tisnull, isout;\n\tDatum\t\tres;\n\n\tPG_TRY();\n\t{\n\t\tres = WinGetFuncArgInFrame(winobj,\n\t\t\t\t\t\t\t\t   argno,\n\t\t\t\t\t\t\t\t   relpos,\n\t\t\t\t\t\t\t\t   seektype,\n\t\t\t\t\t\t\t\t   set_mark,\n\t\t\t\t\t\t\t\t   &isnull,\n\t\t\t\t\t\t\t\t   &isout);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\t/* Return undefined to tell it's out of frame. */\n\tif (isout) {\n                args.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n\t}\n\n\tplv8_type *type = plv8_MyArgType(args, argno);\n\n\targs.GetReturnValue().Set(ToValue(res, isnull, type));\n}\n\n/*\n * winobj.get_func_arg_current(argno)\n */\nstatic void\nplv8_WinGetFuncArgCurrent(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tIsolate*\t\tisolate = args.GetIsolate();\n\tWindowObject\twinobj = plv8_MyWindowObject(args);\n\tif (args.Length() < 1) {\n                args.GetReturnValue().Set(Undefined(isolate));\n\t\treturn;\n        }\n\tint\t\t\targno = args[0]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n\tbool\t\tisnull;\n\tDatum\t\tres;\n\n\tPG_TRY();\n\t{\n\t\tres = WinGetFuncArgCurrent(winobj,\n\t\t\t\t\t\t\t\t   argno,\n\t\t\t\t\t\t\t\t   &isnull);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tplv8_type *type = plv8_MyArgType(args, argno);\n\n\targs.GetReturnValue().Set(ToValue(res, isnull, type));\n}\n\n/*\n * plv8.quote_literal(str)\n */\nstatic void\nplv8_QuoteLiteral(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tif (args.Length() < 1) {\n                args.GetReturnValue().Set(Undefined(args.GetIsolate()));\n\t\treturn;\n\t}\n\tCString\t\t\tinstr(args[0]);\n\tchar\t\t   *result;\n\n\tPG_TRY();\n\t{\n\t\tresult = quote_literal_cstr(instr);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(ToString(result));\n}\n\n/*\n * plv8.quote_nullable(str)\n */\nstatic void\nplv8_QuoteNullable(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tif (args.Length() < 1) {\n                args.GetReturnValue().Set(Undefined(args.GetIsolate()));\n\t\treturn;\n\t}\n\tCString\t\t\tinstr(args[0]);\n\tchar\t\t   *result;\n\n\tif (args[0]->IsNull() || args[0]->IsUndefined()) {\n\t\targs.GetReturnValue().Set(ToString(\"NULL\"));\n\t\treturn;\n\t}\n\n\tPG_TRY();\n\t{\n\t\tresult = quote_literal_cstr(instr);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(ToString(result));\n}\n\n/*\n * plv8.quote_ident(str)\n */\nstatic void\nplv8_QuoteIdent(const FunctionCallbackInfo<v8::Value>& args)\n{\n\tif (args.Length() < 1) {\n                args.GetReturnValue().Set(Undefined(args.GetIsolate()));\n\t\treturn;\n\t}\n\tCString\t\t\tinstr(args[0]);\n\tconst char\t   *result;\n\n\tPG_TRY();\n\t{\n\t\tresult = quote_identifier(instr);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\targs.GetReturnValue().Set(ToString(result));\n}\n\nstatic void\nplv8_MemoryUsage(const FunctionCallbackInfo<v8::Value>& args)\n{\n\t// V8 memory usage\n  \tHeapStatistics v8_heap_stats;\n\tIsolate *\t\tisolate = args.GetIsolate();\n\tisolate->GetHeapStatistics(&v8_heap_stats);\n\n\tLocal<v8::Value>\tresult;\n\tLocal<v8::Object>\tobj = v8::Object::New(isolate);\n\n\tGetMemoryInfo(obj);\n\tresult = obj;\n\targs.GetReturnValue().Set(result);\n}\n\nvoid GetMemoryInfo(v8::Local<v8::Object> obj) {\n\tHeapStatistics  \tv8_heap_stats;\n\tIsolate \t\t   *isolate = obj->GetIsolate();\n\tHandle<Context> context = isolate->GetCurrentContext();\n\n\tisolate->GetHeapStatistics(&v8_heap_stats);\n\n\tLocal<v8::Value> total = Local<v8::Value>::New(isolate, Number::New(isolate, v8_heap_stats.total_heap_size()));\n\tLocal<v8::Value> used = Local<v8::Value>::New(isolate, Number::New(isolate, v8_heap_stats.used_heap_size()));\n\tLocal<v8::Value> external = Local<v8::Value>::New(isolate, Number::New(isolate, v8_heap_stats.external_memory()));\n\n\tobj->Set(context, v8::String::NewFromUtf8(isolate, \"total_heap_size\").ToLocalChecked(), total).Check();\n\tobj->Set(context, v8::String::NewFromUtf8(isolate, \"used_heap_size\").ToLocalChecked(), used).Check();\n\tobj->Set(context, v8::String::NewFromUtf8(isolate, \"external_memory\").ToLocalChecked(), external).Check();\n}\n\n#if PG_VERSION_NUM >= 110000\n\nstatic void\nplv8_Commit(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tPG_TRY();\n\t{\n\t\tHoldPinnedPortals();\n\t\tSPI_commit();\n\t\tSPI_start_transaction();\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n}\n\nstatic void\nplv8_Rollback(const FunctionCallbackInfo<v8::Value> &args)\n{\n\tPG_TRY();\n\t{\n\t\tHoldPinnedPortals();\n\t\tSPI_rollback();\n\t\tSPI_start_transaction();\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n}\n\n#endif\n"
        },
        {
          "name": "plv8_guc.cc",
          "type": "blob",
          "size": 3.7265625,
          "content": "/*\n * This code was copied from postgres:src/backend/utils/misc/guc.c (with some changes)\n * because public postgresql headers do not expose it for some reason\n * there is GetConfigOptionName(), GetConfigOption(), GetConfigOptionFlags()\n * unfortunately none of these answer a simple question: does GUC variable exist?\n * and all of them fail hard if not provided with \"missing_ok = true\"\n */\n\n#include \"plv8.h\"\n\nextern \"C\" {\n#include \"utils/guc.h\"\n#include \"utils/guc_tables.h\"\n}\n\n/*\n * To allow continued support of obsolete names for GUC variables, we apply\n * the following mappings to any unrecognized name.  Note that an old name\n * should be mapped to a new one only if the new variable has very similar\n * semantics to the old.\n */\nstatic const char *const map_old_guc_names[] = {\n\t\t/* The format is\n \t\t * \"old_name\", \"new_name\",\n \t\t */\n\t\tNULL\n};\n\nstatic int plv8_guc_name_compare(const char *, const char *);\nstatic int plv8_guc_var_compare(const void *, const void *);\n\nchar *\nplv8_string_option(struct config_generic *record) {\n\tif (record->vartype != PGC_STRING)\n\t\telog(ERROR, \"'%s' is not a string\", record->name);\n\n\tauto *conf = (struct config_string *) record;\n\tif (*conf->variable && **conf->variable)\n\t\treturn *conf->variable;\n\treturn pstrdup(\"\");\n}\n\nint\nplv8_int_option(struct config_generic *record) {\n\tif (record->vartype != PGC_INT)\n\t\telog(ERROR, \"'%s' is not an int\", record->name);\n\n\tauto *conf = (struct config_int *) record;\n\treturn *conf->variable;\n}\n\n/*\n * Look up option NAME.  If it exists, return a pointer to its record,\n * else return NULL.\n */\nstruct config_generic *\nplv8_find_option(const char *name)\n{\n\tconst char **key = &name;\n\tstruct config_generic **res, **guc_vars;\n\tint\t\t\ti;\n\tint numOpts;\n\n#if PG_VERSION_NUM < 160000\n\tguc_vars = get_guc_variables();\n\tnumOpts = GetNumConfigOptions();\n#else\n\tguc_vars = get_guc_variables(&numOpts);\n#endif\n\n\t/*\n\t * By equating const char ** with struct config_generic *, we are assuming\n\t * the name field is first in config_generic.\n\t */\n\tres = (struct config_generic **) bsearch((void *) &key,\n\t\t\t\t\t\t\t\t\t\t\t (void *) guc_vars,\n\t\t\t\t\t\t\t\t\t\t\t numOpts,\n\t\t\t\t\t\t\t\t\t\t\t sizeof(struct config_generic *),\n\t\t\t\t\t\t\t\t\t\t\t plv8_guc_var_compare);\n\t/*\n\t * Return NULL for placeholders,\n\t * these can be safely overwritten by DefineCustomTYPEVariable() functions\n\t */\n\tif (res) {\n\t\tif ((*res)->flags & GUC_CUSTOM_PLACEHOLDER)\n\t\t\treturn NULL;\n\t\treturn *res;\n\t}\n\n\t/*\n\t * See if the name is an obsolete name for a variable.  We assume that the\n\t * set of supported old names is short enough that a brute-force search is\n\t * the best way.\n\t */\n\tfor (i = 0; map_old_guc_names[i] != NULL; i += 2)\n\t{\n\t\tif (plv8_guc_name_compare(name, map_old_guc_names[i]) == 0)\n\t\t\treturn plv8_find_option(map_old_guc_names[i + 1]);\n\t}\n\n\t/* Unknown name */\n\treturn NULL;\n}\n\n\n/*\n * comparator for qsorting and bsearching guc_variables array\n */\nstatic int\nplv8_guc_var_compare(const void *a, const void *b)\n{\n\tconst struct config_generic *confa = *(struct config_generic *const *) a;\n\tconst struct config_generic *confb = *(struct config_generic *const *) b;\n\n\treturn plv8_guc_name_compare(confa->name, confb->name);\n}\n\n/*\n * the bare comparison function for GUC names\n */\nstatic int\nplv8_guc_name_compare(const char *namea, const char *nameb)\n{\n\t/*\n\t * The temptation to use strcasecmp() here must be resisted, because the\n\t * array ordering has to remain stable across setlocale() calls. So, build\n\t * our own with a simple ASCII-only downcasing.\n\t */\n\twhile (*namea && *nameb)\n\t{\n\t\tchar\t\tcha = *namea++;\n\t\tchar\t\tchb = *nameb++;\n\n\t\tif (cha >= 'A' && cha <= 'Z')\n\t\t\tcha += 'a' - 'A';\n\t\tif (chb >= 'A' && chb <= 'Z')\n\t\t\tchb += 'a' - 'A';\n\t\tif (cha != chb)\n\t\t\treturn cha - chb;\n\t}\n\tif (*namea)\n\t\treturn 1;\t\t\t\t/* a is longer */\n\tif (*nameb)\n\t\treturn -1;\t\t\t\t/* b is longer */\n\treturn 0;\n}\n"
        },
        {
          "name": "plv8_param.cc",
          "type": "blob",
          "size": 5.77734375,
          "content": "/*-------------------------------------------------------------------------\n *\n * plv8_param.cc : PL/v8 parameter handling.\n *\n * Copyright (c) 2009-2012, the PLV8JS Development Group.\n *-------------------------------------------------------------------------\n */\n#include \"plv8_param.h\"\n#include <limits.h>\n\n/*\n * Variable SPI parameter is since 9.0.  Avoid include files in prior versions,\n * as they contain C++ keywords.\n */\n#if PG_VERSION_NUM >= 90000\n\nextern \"C\" {\n\n#include \"catalog/pg_type.h\"\n#include \"utils/builtins.h\"\n#include \"utils/lsyscache.h\"\n\n} // extern \"C\"\n\n\n/*\n * In the varparams case, the caller-supplied OID array (if any) can be\n * re-palloc'd larger at need.  A zero array entry means that parameter number\n * hasn't been seen, while UNKNOWNOID means the parameter has been used but\n * its type is not yet known.\n */\n\nstatic Node *plv8_variable_paramref_hook(ParseState *pstate, ParamRef *pref);\nstatic Node *plv8_variable_coerce_param_hook(ParseState *pstate, Param *param,\n\t\t\t\t\t\t   Oid targetTypeId, int32 targetTypeMod,\n\t\t\t\t\t\t   int location);\n\nvoid\nplv8_variable_param_setup(ParseState *pstate, void *arg)\n{\n\tplv8_param_state *parstate = (plv8_param_state *) arg;\n\n\tpstate->p_ref_hook_state = (void *) parstate;\n\tpstate->p_paramref_hook = plv8_variable_paramref_hook;\n\tpstate->p_coerce_param_hook = plv8_variable_coerce_param_hook;\n}\n\nstatic Node *\nplv8_variable_paramref_hook(ParseState *pstate, ParamRef *pref)\n{\n\tplv8_param_state *parstate = (plv8_param_state *) pstate->p_ref_hook_state;\n\tint\t\t\tparamno = pref->number;\n\tOid\t\t   *pptype;\n\tParam\t   *param;\n\n\t/* Check parameter number is in range */\n\tif (paramno <= 0 || paramno > (int) (INT_MAX / sizeof(Oid)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t errmsg(\"there is no parameter $%d\", paramno),\n\t\t\t\t parser_errposition(pstate, pref->location)));\n\tif (paramno > parstate->numParams)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(parstate->memcontext);\n\t\t/* Need to enlarge param array */\n\t\tif (parstate->paramTypes)\n\t\t\tparstate->paramTypes = (Oid *) repalloc(parstate->paramTypes,\n\t\t\t\t\t\t\t\t\t\t\t\t\tparamno * sizeof(Oid));\n\t\telse\n\t\t\tparstate->paramTypes = (Oid *) palloc(paramno * sizeof(Oid));\n\t\t/* Zero out the previously-unreferenced slots */\n\t\tMemSet(parstate->paramTypes + parstate->numParams,\n\t\t\t   0,\n\t\t\t   (paramno - parstate->numParams) * sizeof(Oid));\n\t\tparstate->numParams = paramno;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Locate param's slot in array */\n\tpptype = &(parstate->paramTypes)[paramno - 1];\n\n\t/* If not seen before, initialize to UNKNOWN type */\n\tif (*pptype == InvalidOid)\n\t\t*pptype = UNKNOWNOID;\n\n\tparam = makeNode(Param);\n\tparam->paramkind = PARAM_EXTERN;\n\tparam->paramid = paramno;\n\tparam->paramtype = *pptype;\n\tparam->paramtypmod = -1;\n#if PG_VERSION_NUM >= 90100\n\tparam->paramcollid = get_typcollation(param->paramtype);\n#endif\n\tparam->location = pref->location;\n\n\treturn (Node *) param;\n}\n\nstatic Node *\nplv8_variable_coerce_param_hook(ParseState *pstate, Param *param,\n\t\t\t\t\t\t\t   Oid targetTypeId, int32 targetTypeMod,\n\t\t\t\t\t\t\t   int location)\n{\n\tif (param->paramkind == PARAM_EXTERN && param->paramtype == UNKNOWNOID)\n\t{\n\t\t/*\n\t\t * Input is a Param of previously undetermined type, and we want to\n\t\t * update our knowledge of the Param's type.\n\t\t */\n\t\tplv8_param_state *parstate =\n\t\t\t(plv8_param_state *) pstate->p_ref_hook_state;\n\t\tOid\t\t   *paramTypes = parstate->paramTypes;\n\t\tint\t\t\tparamno = param->paramid;\n\n\t\tif (paramno <= 0 ||\t\t/* shouldn't happen, but... */\n\t\t\tparamno > parstate->numParams)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t\t errmsg(\"there is no parameter $%d\", paramno),\n\t\t\t\t\t parser_errposition(pstate, param->location)));\n\n\t\tif (paramTypes[paramno - 1] == UNKNOWNOID)\n\t\t{\n\t\t\t/* We've successfully resolved the type */\n\t\t\tparamTypes[paramno - 1] = targetTypeId;\n\t\t}\n\t\telse if (paramTypes[paramno - 1] == targetTypeId)\n\t\t{\n\t\t\t/* We previously resolved the type, and it matches */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Ooops */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_AMBIGUOUS_PARAMETER),\n\t\t\t\t\t errmsg(\"inconsistent types deduced for parameter $%d\",\n\t\t\t\t\t\t\tparamno),\n\t\t\t\t\t errdetail(\"%s versus %s\",\n\t\t\t\t\t\t\t   format_type_be(paramTypes[paramno - 1]),\n\t\t\t\t\t\t\t   format_type_be(targetTypeId)),\n\t\t\t\t\t parser_errposition(pstate, param->location)));\n\t\t}\n\n\t\tparam->paramtype = targetTypeId;\n\n\t\t/*\n\t\t * Note: it is tempting here to set the Param's paramtypmod to\n\t\t * targetTypeMod, but that is probably unwise because we have no\n\t\t * infrastructure that enforces that the value delivered for a Param\n\t\t * will match any particular typmod.  Leaving it -1 ensures that a\n\t\t * run-time length check/coercion will occur if needed.\n\t\t */\n\t\tparam->paramtypmod = -1;\n\n#if PG_VERSION_NUM >= 90100\n\t\t/*\n\t\t * This module always sets a Param's collation to be the default for\n\t\t * its datatype.  If that's not what you want, you should be using the\n\t\t * more general parser substitution hooks.\n\t\t */\n\t\tparam->paramcollid = get_typcollation(param->paramtype);\n#endif\n\n\t\t/* Use the leftmost of the param's and coercion's locations */\n\t\tif (location >= 0 &&\n\t\t\t(param->location < 0 || location < param->location))\n\t\t\tparam->location = location;\n\n\t\treturn (Node *) param;\n\t}\n\n\t/* Else signal to proceed with normal coercion */\n\treturn NULL;\n}\n\nParamListInfo\nplv8_setup_variable_paramlist(plv8_param_state *parstate,\n\t\t\t\t\t\t\t  Datum *values, char *nulls)\n{\n\tParamListInfo\t\tparamLI;\n\n\tparamLI = (ParamListInfo) palloc0(offsetof(ParamListInfoData, params) +\n\t\t\t\t\t\t\tsizeof(ParamExternData) * parstate->numParams);\n\tparamLI->numParams = parstate->numParams;\n\tfor(int i = 0; i < parstate->numParams; i++)\n\t{\n\t\tParamExternData\t   *param = &paramLI->params[i];\n\n\t\tparam->value = values[i];\n\t\tparam->isnull = nulls[i] == 'n';\n\t\tparam->pflags = PARAM_FLAG_CONST;\n\t\tparam->ptype = parstate->paramTypes[i];\n\t}\n\n\treturn paramLI;\n}\n#endif\t// PG_VERSION_NUM >= 90000\n"
        },
        {
          "name": "plv8_param.h",
          "type": "blob",
          "size": 1.015625,
          "content": "#ifndef _PLV8_PARAM_H_\n#define _PLV8_PARAM_H_\n\nextern \"C\" {\n#include \"postgres.h\"\n\n/*\n * Variable SPI parameter is since 9.0.  Avoid include files in prior versions,\n * as they contain C++ keywords.\n */\n#include \"nodes/params.h\"\n#if PG_VERSION_NUM >= 90000\n#include \"parser/parse_node.h\"\n#endif\t// PG_VERSION_NUM >= 90000\n\n} // extern \"C\"\n\n/*\n * In variable paramter case for SPI, the type information is filled by\n * the parser in paramTypes and numParams.  MemoryContext should be given\n * by the caller to allocate the paramTypes in the right context.\n */\ntypedef struct plv8_param_state\n{\n\tOid\t\t   *paramTypes;\t\t/* array of parameter type OIDs */\n\tint\t\t\tnumParams;\t\t/* number of array entries */\n\tMemoryContext\tmemcontext;\n} plv8_param_state;\n\n#if PG_VERSION_NUM >= 90000\n// plv8_param.cc\nextern void plv8_variable_param_setup(ParseState *pstate, void *arg);\nextern ParamListInfo plv8_setup_variable_paramlist(plv8_param_state *parstate,\n\t\t\t\t\t\t\t  Datum *values, char *nulls);\n#endif\t// PG_VERSION_NUM >= 90000\n\n#endif\t// _PLV8_PARAM_H_\n"
        },
        {
          "name": "plv8_type.cc",
          "type": "blob",
          "size": 36.6259765625,
          "content": "/*-------------------------------------------------------------------------\n *\n * plv8_type.cc : Postgres from/to v8 data converters.\n *\n * Copyright (c) 2009-2012, the PLV8JS Development Group.\n *-------------------------------------------------------------------------\n */\n#include \"plv8.h\"\n\nextern \"C\" {\n#if JSONB_DIRECT_CONVERSION\n#include <time.h>\n#endif\n#if PG_VERSION_NUM >= 90300\n#include \"access/htup_details.h\"\n#endif\n#include \"catalog/pg_type.h\"\n#include \"parser/parse_coerce.h\"\n#include \"utils/array.h\"\n#include \"utils/date.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#if PG_VERSION_NUM >= 90400\n#include \"utils/jsonb.h\"\n#endif\n#include \"utils/lsyscache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"nodes/memnodes.h\"\n#include \"utils/memutils.h\"\n#include \"fmgr.h\"\n} // extern \"C\"\n\n\nusing namespace v8;\n\nstatic Datum ToScalarDatum(Handle<v8::Value> value, bool *isnull, plv8_type *type);\nstatic Datum ToArrayDatum(Handle<v8::Value> value, bool *isnull, plv8_type *type);\nstatic Datum ToRecordDatum(Handle<v8::Value> value, bool *isnull, plv8_type *type);\nstatic Local<v8::Value> ToScalarValue(Datum datum, bool isnull, plv8_type *type);\nstatic Local<v8::Value> ToArrayValue(Datum datum, bool isnull, plv8_type *type);\nstatic Local<v8::Value> ToRecordValue(Datum datum, bool isnull, plv8_type *type);\nstatic double TimestampTzToEpoch(TimestampTz tm);\nstatic Datum EpochToTimestampTz(double epoch);\nstatic double DateToEpoch(DateADT date);\nstatic Datum EpochToDate(double epoch);\n\nvoid\nplv8_fill_type(plv8_type *type, Oid typid, MemoryContext mcxt)\n{\n\tbool    ispreferred;\n\n\tif (!mcxt)\n\t\tmcxt = CurrentMemoryContext;\n\n\ttype->typid = typid;\n\ttype->fn_input.fn_mcxt = type->fn_output.fn_mcxt = mcxt;\n\tget_type_category_preferred(typid, &type->category, &ispreferred);\n\ttype->is_composite = (type->category == TYPCATEGORY_COMPOSITE);\n\tget_typlenbyvalalign(typid, &type->len, &type->byval, &type->align);\n\n\tif (get_typtype(typid) == TYPTYPE_DOMAIN)\n\t{\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n#if PG_VERSION_NUM < 90100\n\t\ttp = SearchSysCache(TYPEOID, ObjectIdGetDatum(typid), 0, 0, 0);\n#else\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n#endif\n\t\tif (HeapTupleIsValid(tp))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if the type is the external array types.\n\t\t\t */\n\t\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\t\tif (strcmp(NameStr(typtup->typname),\n\t\t\t\t\t\t\"plv8_int2array\") == 0)\n\t\t\t{\n\t\t\t\ttype->ext_array = kExternalShortArray;\n\t\t\t}\n\t\t\telse if (strcmp(NameStr(typtup->typname),\n\t\t\t\t\t\t\"plv8_int4array\") == 0)\n\t\t\t{\n\t\t\t\ttype->ext_array = kExternalIntArray;\n\t\t\t}\n\t\t\telse if (strcmp(NameStr(typtup->typname),\n\t\t\t\t\t\t\"plv8_float4array\") == 0)\n\t\t\t{\n\t\t\t\ttype->ext_array = kExternalFloatArray;\n\t\t\t}\n\t\t\telse if (strcmp(NameStr(typtup->typname),\n\t\t\t\t\t\t\"plv8_float8array\") == 0)\n\t\t\t{\n\t\t\t\ttype->ext_array = kExternalDoubleArray;\n\t\t\t}\n\t\t\telse if (strcmp(NameStr(typtup->typname),\n\t\t\t\t\t\t\"plv8_int8array\") == 0)\n\t\t\t{\n\t\t\t\ttype->ext_array = kExternalInt64Array;\n\t\t\t}\n\n\t\t\tReleaseSysCache(tp);\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"cache lookup failed for type %d\", typid);\n\n\t\tif (type->ext_array)\n\t\t\treturn;\n\n\t\t/* If not, do as usual. */\n\t}\n\n\tif (type->category == TYPCATEGORY_ARRAY)\n\t{\n\t\tOid      elemid = get_element_type(typid);\n\n\t\tif (elemid == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"cannot determine element type of array: %u\", typid)));\n\n\t\ttype->typid = elemid;\n\t\ttype->is_composite = (TypeCategory(elemid) == TYPCATEGORY_COMPOSITE);\n\t\tget_typlenbyvalalign(type->typid, &type->len, &type->byval, &type->align);\n\t}\n}\n\n/*\n * Return the database type inferred by the JS value type.\n * If none looks appropriate, InvalidOid is returned (currently,\n * objects and arrays are in this case).\n */\nOid\ninferred_datum_type(Handle<v8::Value> value)\n{\n\tif (value->IsUndefined() || value->IsNull())\n\t\treturn TEXTOID;\n\tif (value->IsBoolean())\n\t\treturn BOOLOID;\n\telse if (value->IsInt32())\n\t\treturn INT4OID;\n\telse if (value->IsUint32())\n\t\treturn INT8OID;\n\telse if (value->IsBigInt())\n\t\treturn INT8OID;\n\telse if (value->IsNumber())\n\t\treturn FLOAT8OID;\n\telse if (value->IsString())\n\t\treturn TEXTOID;\n\telse if (value->IsDate())\n\t\treturn TIMESTAMPOID;\n/*\n\telse if (value->IsObject())\n\telse if (value->IsArray())\n*/\n\n\treturn InvalidOid;\n}\n\n#if PG_VERSION_NUM >= 90400 && JSONB_DIRECT_CONVERSION\n\n// jsonb types moved in pg10\n#if PG_VERSION_NUM < 100000\n#define jbvString JsonbValue::jbvString\n#define jbvNumeric JsonbValue::jbvNumeric\n#define jbvBool JsonbValue::jbvBool\n#define jbvObject JsonbValue::jbvObject\n#define jbvArray JsonbValue::jbvArray\n#define jbvNull JsonbValue::jbvNull\n#endif\n\nstatic Local<v8::Value>\nGetJsonbValue(JsonbValue *scalarVal) {\n  Isolate *isolate = Isolate::GetCurrent();\n\n  if (scalarVal->type == jbvNull) {\n\t\treturn Local<v8::Value>::New(isolate, Null(isolate));\n  } else if (scalarVal->type == jbvString) {\n    char t[ scalarVal->val.string.len + 1 ];\n    strncpy(t, scalarVal->val.string.val, scalarVal->val.string.len);\n    t[ scalarVal->val.string.len ] = '\\0';\n\n\t\treturn Local<v8::Value>::New(isolate, v8::String::NewFromUtf8(isolate, t).ToLocalChecked());\n  } else if (scalarVal->type == jbvNumeric) {\n\t\treturn Local<v8::Value>::New(isolate, Number::New(isolate, DatumGetFloat8(DirectFunctionCall1(numeric_float8, PointerGetDatum(scalarVal->val.numeric)))));\n  } else if (scalarVal->type == jbvBool) {\n\t\treturn Local<v8::Value>::New(isolate, v8::Boolean::New(isolate, scalarVal->val.boolean));\n  } else {\n    elog(ERROR, \"unknown jsonb scalar type\");\n    return Local<v8::Value>::New(isolate, Null(isolate));\n  }\n}\n\nstatic Local<v8::Object>\nJsonbIterate(JsonbIterator **it, Local<v8::Object> container) {\n  Isolate *isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n  JsonbValue val;\n\tint32 count = 0;\n  JsonbIteratorToken token;\n\tLocal<v8::Value> key;\n\tLocal<v8::Object> obj;\n\n  token = JsonbIteratorNext(it, &val, false);\n  while (token != WJB_DONE) {\n    switch (token) {\n    case WJB_BEGIN_OBJECT:\n\t\t\tobj = v8::Object::New(isolate);\n\t\t\tif (container->IsArray()) {\n\t\t\t\tcontainer->Set(context, count, JsonbIterate(it, obj)).Check();\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tcontainer->Set(context, key, JsonbIterate(it, obj)).Check();\n\t\t\t}\n      break;\n\n    case WJB_END_OBJECT:\n      return container;\n\n      break;\n\n    case WJB_BEGIN_ARRAY:\n\t\t\tobj = v8::Array::New(isolate);\n\t\t\tif (container->IsArray()) {\n\t\t\t\tcontainer->Set(context, count, JsonbIterate(it, obj)).Check();\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tcontainer->Set(context, key, JsonbIterate(it, obj)).Check();\n\t\t\t}\n      break;\n\n    case WJB_END_ARRAY:\n      return container;\n\n      break;\n\n    case WJB_KEY:\n\t\t\tkey = GetJsonbValue(&val);\n\n      break;\n\n    case WJB_VALUE:\n      // object value\n\t\t\tcontainer->Set(context, key, GetJsonbValue(&val)).Check();\n      break;\n\n    case WJB_ELEM:\n      // array element\n\t\t\tcontainer->Set(context, count, GetJsonbValue(&val)).Check();\n\t\t\tcount++;\n      break;\n\n    case WJB_DONE:\n      return container;\n      break;\n\n    default:\n      elog(ERROR, \"unknown jsonb iterator value\");\n    }\n\n    token = JsonbIteratorNext(it, &val, false);\n  }\n\n  return container;\n}\n\nstatic Local<Object>\nConvertJsonb(JsonbContainer *in) {\n\tIsolate *isolate = Isolate::GetCurrent();\n\tJsonbValue val;\n\tJsonbIterator *it = JsonbIteratorInit(in);\n\tJsonbIteratorToken token = JsonbIteratorNext(&it, &val, false);\n\n\tLocal<Object> container;\n\n\tif (token == WJB_BEGIN_ARRAY) {\n\t\tcontainer = v8::Array::New(isolate);\n\t} else {\n\t\tcontainer = v8::Object::New(isolate);\n\t}\n\n\treturn JsonbIterate(&it, container);\n}\n\nstatic JsonbValue *\nJsonbObjectFromObject(JsonbParseState **pstate, Local<v8::Object> object);\nstatic JsonbValue *\nJsonbArrayFromArray(JsonbParseState **pstate, Local<v8::Object> object);\n\nstatic void LogType(Local<v8::Value> val, bool asError = true) {\n\tif( val->IsUndefined() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Undefined\");\n\tif( val->IsNull() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Null\");\n\tif( val->IsTrue() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: True\");\n\tif( val->IsFalse() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: False\");\n\tif( val->IsName() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Name\");\n\tif( val->IsString() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: String\");\n\tif( val->IsSymbol() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Symbol\");\n\tif( val->IsFunction() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Function\");\n\tif( val->IsArray() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Array\");\n\tif( val->IsObject() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Object\");\n\tif( val->IsBoolean() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Boolean\");\n\tif( val->IsNumber() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Number\");\n\tif( val->IsExternal() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: External\");\n\tif( val->IsInt32() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Int32\");\n\tif( val->IsUint32() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Uint32\");\n\tif( val->IsDate() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Date\");\n\tif( val->IsArgumentsObject() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Arguments Object\");\n\tif( val->IsBooleanObject() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Boolean Object\");\n\tif( val->IsNumberObject() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Number Object\");\n\tif( val->IsStringObject() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: String Object\");\n\tif( val->IsSymbolObject() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Symbol Object\");\n\tif( val->IsNativeError() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Native Error\");\n\tif( val->IsRegExp() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: RegExp\");\n\tif( val->IsGeneratorFunction() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Generator Function\");\n\tif( val->IsGeneratorObject() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Generator Object\");\n\tif( val->IsPromise() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Promise\");\n\tif( val->IsMap() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Map\");\n\tif( val->IsSet() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Set\");\n\tif( val->IsMapIterator() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Map Iterator\");\n\tif( val->IsSetIterator() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Set Iterator\");\n\tif( val->IsWeakMap() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Weak Map\");\n\tif( val->IsWeakSet() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Weak Set\");\n\tif( val->IsArrayBuffer() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Array Buffer\");\n\tif( val->IsArrayBufferView() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Array Buffer View\");\n\tif( val->IsTypedArray() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Typed Array\");\n\tif( val->IsUint8Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Uint8 Array\");\n\tif( val->IsUint8ClampedArray() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Uint8 Clamped Array\");\n\tif( val->IsInt8Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Int8 Array\");\n\tif( val->IsUint16Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Uint16 Array\");\n\tif( val->IsInt16Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Int16 Array\");\n\tif( val->IsUint32Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Uint32 Array\");\n\tif( val->IsInt32Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Int32 Array\");\n\tif( val->IsFloat32Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Float32 Array\");\n\tif( val->IsFloat64Array() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Float64 Array\");\n\tif( val->IsDataView() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Data View\");\n\tif( val->IsSharedArrayBuffer() )\n\t  elog((asError ? ERROR : NOTICE), \"Unaccounted for type: Shared Buffer Array\");\n}\n\nstatic char *\nTimeAs8601 (double millis) {\n\tchar tmp[100];\n\tchar *buf = (char *)palloc(25);\n\n\ttime_t t = (time_t) (millis / 1000);\n\tstrftime (tmp, 25, \"%Y-%m-%dT%H:%M:%S\", gmtime(&t));\n\n\tdouble integral;\n\tdouble fractional = modf(millis / 1000, &integral);\n\n\tsprintf(buf, \"%s.%03dZ\", tmp, (int) (fractional * 1000));\n\n\treturn buf;\n}\n\nstatic JsonbValue *\nJsonbFromValue(JsonbParseState **pstate, Local<v8::Value> value, JsonbIteratorToken type) {\n\tIsolate *isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\tJsonbValue val;\n\n\t// if the token type is a key, the only valid value is jbvString\n\tif (type == WJB_KEY) {\n\t\tval.type = jbvString;\n\t\tv8::String::Utf8Value utf8(isolate, value->ToString(context).ToLocalChecked());\n\t\tval.val.string.val = ToCStringCopy(utf8);\n\t\tval.val.string.len = utf8.length();\n\t} else {\n\t\tif (value->IsBoolean()) {\n\t\t\tval.type = jbvBool;\n\t\t\tval.val.boolean = value->BooleanValue(isolate);\n\t\t} else if (value->IsNull()) {\n\t\t\tval.type = jbvNull;\n\t\t} else if (value->IsUndefined()) {\n\t\t\treturn NULL;\n\t\t} else if (value->IsString()) {\n\t\t\tval.type = jbvString;\n\t\t\tv8::String::Utf8Value utf8(isolate, value->ToString(context).ToLocalChecked());\n\t\t\tval.val.string.val = ToCStringCopy(utf8);\n\t\t\tval.val.string.len = utf8.length();\n\t\t} else if (value->IsNumber()) {\n\t\t\tif (value->IsInt32()) {\n\t\t\t\tint32 iv = value->Int32Value(context).ToChecked();\n\t\t\t\tval.val.numeric = DatumGetNumeric(DirectFunctionCall1(int4_numeric, Int32GetDatum(iv)));\n\t\t\t\tval.type = jbvNumeric;\n\t\t\t} else if (value->IsUint32()) {\n\t\t\t\tint64 iv = (int64) value->Uint32Value(context).ToChecked();\n\t\t\t\tval.val.numeric = DatumGetNumeric(DirectFunctionCall1(int8_numeric, Int64GetDatum(iv)));\n\t\t\t\tval.type = jbvNumeric;\n\t\t\t} else {\n\t\t\t\tfloat8 fv = (float8) value->NumberValue(context).ToChecked();\n\n\t\t\t\tval.val.numeric = DatumGetNumeric(DirectFunctionCall1(float8_numeric, Float8GetDatum(fv)));\n\t\t\t\tval.type = jbvNumeric;\n\t\t\t}\n\t\t} else if (value->IsDate()) {\n\t\t\tdouble t = value->NumberValue(context).ToChecked();\n\t\t\tif (isnan(t)) {\n\t\t\t\tval.type = jbvNull;\n\t\t\t} else {\n\t\t\t\tval.val.string.val = TimeAs8601(t);\n\t\t\t\tval.val.string.len = 24;\n\t\t\t\tval.type = jbvString;\n\t\t\t}\n\t\t} else {\n\t\t\tLogType(value, false);\n\t\t\tval.type = jbvString;\n\t\t\tv8::String::Utf8Value utf8(isolate, value->ToString(context).ToLocalChecked());\n\t\t\tval.val.string.val = ToCStringCopy(utf8);\n\t\t\tval.val.string.len = utf8.length();\n\t\t}\n\t}\n\n\treturn pushJsonbValue(pstate, type, &val);\n}\n\nstatic JsonbValue *\nJsonbArrayFromArray(JsonbParseState **pstate, Local<v8::Object> object) {\n\tIsolate *isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\tJsonbValue *val = pushJsonbValue(pstate, WJB_BEGIN_ARRAY, NULL);\n\tLocal<v8::Array> a = Local<v8::Array>::Cast(object);\n\tfor (size_t i = 0; i < a->Length(); i++) {\n\t\tLocal<v8::Value> o = a->Get(context, i).ToLocalChecked();\n\n\t\tif (o->IsArray()) {\n\t\t\tval = JsonbArrayFromArray(pstate, Local<v8::Array>::Cast(o));\n\t\t} else if (o->IsObject()) {\n\t\t\tval = JsonbObjectFromObject(pstate, Local<v8::Object>::Cast(o));\n\t\t} else {\n\t\t\tval = JsonbFromValue(pstate, o, WJB_ELEM);\n\t\t}\n\t}\n\n\tval = pushJsonbValue(pstate, WJB_END_ARRAY, NULL);\n\n\treturn val;\n}\n\nstatic JsonbValue *\nJsonbObjectFromObject(JsonbParseState **pstate, Local<v8::Object> object) {\n\tIsolate *isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\tJsonbValue *val = pushJsonbValue(pstate, WJB_BEGIN_OBJECT, NULL);\n\tLocal<Array> arr = object->GetOwnPropertyNames(context).ToLocalChecked();\n\n\tfor (size_t i = 0; i < arr->Length(); i++) {\n\t\tLocal<v8::Value> v = arr->Get(context, i).ToLocalChecked();\n\t\tval = JsonbFromValue(pstate, v, WJB_KEY);\n\t\tLocal<v8::Value> o = object->Get(context, v).ToLocalChecked();\n\n\t\tif (o->IsDate()) {\n\t\t\tval = JsonbFromValue(pstate, o, WJB_VALUE);\n\t\t} else if (o->IsArray()) {\n\t\t\tval = JsonbArrayFromArray(pstate, Local<v8::Array>::Cast(o));\n\t\t} else if (o->IsObject()) {\n\t\t\tval = JsonbObjectFromObject(pstate, Local<v8::Object>::Cast(o));\n\t\t} else {\n\t\t\tval = JsonbFromValue(pstate, o, WJB_VALUE);\n\t\t}\n\t}\n\tval = pushJsonbValue(pstate, WJB_END_OBJECT, NULL);\n\treturn val;\n}\n\nstatic Jsonb *\nConvertObject(Local<v8::Object> object) {\n\t// create a new memory context for conversion\n\tMemoryContext oldcontext = CurrentMemoryContext;\n\tMemoryContext conversion_context;\n\n#if PG_VERSION_NUM < 110000\n\tconversion_context = AllocSetContextCreate(\n\t\t\t\t\t\tCurrentMemoryContext,\n\t\t\t\t\t\t\"JSONB Conversion Context\",\n\t\t\t\t\t\tALLOCSET_SMALL_MINSIZE,\n\t\t\t\t\t\tALLOCSET_SMALL_INITSIZE,\n\t\t\t\t\t\tALLOCSET_SMALL_MAXSIZE);\n#else\n\tconversion_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\"JSONB Conversion Context\",\n\t\t\t\t\t\tALLOCSET_SMALL_SIZES);\n#endif\n\n\tMemoryContextSwitchTo(conversion_context);\n\n  JsonbParseState *pstate = NULL;\n  JsonbValue *val;\n\n\tif (object->IsArray()) {\n\t\tval = JsonbArrayFromArray(&pstate, object);\n\t} else if (object->IsObject()) {\n\t\tval = JsonbObjectFromObject(&pstate, object);\n\t} else {\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, NULL);\n\t\tJsonbFromValue(&pstate, object, WJB_ELEM);\n\t\tval = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n                val->val.array.rawScalar = true;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tJsonb *ret = JsonbValueToJsonb(val);\n\tMemoryContextDelete(conversion_context);\n  return ret;\n}\n#endif\n\nstatic Local<Object>\nCreateExternalArray(void *data, plv8_external_array_type array_type,\n\t\t\t\t\tint byte_size, Datum datum)\n{\n\tIsolate* isolate = Isolate::GetCurrent();\n\tLocal<v8::ArrayBuffer> buffer;\n\tLocal<v8::TypedArray> array;\n\n\tbuffer = v8::ArrayBuffer::New(isolate, byte_size);\n\tif (buffer.IsEmpty())\n\t{\n\t\treturn {};\n\t}\n\n\tswitch (array_type)\n\t{\n\tcase kExternalByteArray:\n\t\tarray = v8::Int8Array::New(buffer, 0, byte_size);\n\t\tbreak;\n\tcase kExternalUnsignedByteArray:\n\t\tarray = v8::Uint8Array::New(buffer, 0, byte_size);\n\t\tbreak;\n\tcase kExternalShortArray:\n\t\tarray = v8::Int16Array::New(buffer, 0, byte_size / sizeof(int16));\n\t\tbreak;\n\tcase kExternalUnsignedShortArray:\n\t\tarray = v8::Uint16Array::New(buffer, 0, byte_size / sizeof(int16));\n\t\tbreak;\n\tcase kExternalIntArray:\n\t\tarray = v8::Int32Array::New(buffer, 0, byte_size / sizeof(int32));\n\t\tbreak;\n\tcase kExternalUnsignedIntArray:\n\t\tarray = v8::Uint32Array::New(buffer, 0, byte_size / sizeof(int32));\n\t\tbreak;\n\tcase kExternalFloatArray:\n\t\tarray = v8::Float32Array::New(buffer, 0, byte_size / sizeof(float4));\n\t\tbreak;\n\tcase kExternalDoubleArray:\n\t\tarray = v8::Float64Array::New(buffer, 0, byte_size / sizeof(float8));\n\t\tbreak;\n\tcase kExternalInt64Array:\n\t\tarray = v8::BigInt64Array::New(buffer, 0, byte_size / sizeof(int64));\n\tdefault:\n\t\tthrow js_error(\"unexpected array type\");\n\t}\n\tarray->SetInternalField(0, External::New(isolate, DatumGetPointer(datum)));\n\n\t// needs to be a copy, as the data could go away\n\tmemcpy(buffer->GetBackingStore()->Data(), data, byte_size);\n\n\treturn array;\n}\n\nstatic void *\nExtractExternalArrayDatum(Handle<v8::Value> value)\n{\n\tif (value->IsUndefined() || value->IsNull()) {\n\t\treturn NULL;\n\t}\n\n\tif (value->IsTypedArray())\n\t{\n\t\tHandle<Object> object = Handle<Object>::Cast(value);\n\t\treturn Handle<External>::Cast(object->GetInternalField(0))->Value();\n\t}\n\n\treturn NULL;\n}\n\nDatum\nToDatum(Handle<v8::Value> value, bool *isnull, plv8_type *type)\n{\n\tif (type->category == TYPCATEGORY_ARRAY)\n\t\treturn ToArrayDatum(value, isnull, type);\n\telse\n\t\treturn ToScalarDatum(value, isnull, type);\n}\n\nstatic Datum\nToScalarDatum(Handle<v8::Value> value, bool *isnull, plv8_type *type)\n{\n\tIsolate* isolate = Isolate::GetCurrent();\n\tif (type->category == TYPCATEGORY_COMPOSITE)\n\t\treturn ToRecordDatum(value, isnull, type);\n\n\tif (value->IsUndefined() || value->IsNull())\n\t{\n\t\t*isnull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t*isnull = false;\n\tswitch (type->typid)\n\t{\n\tcase OIDOID:\n\t\tif (value->IsNumber())\n\t\t\treturn ObjectIdGetDatum(value->Uint32Value(isolate->GetCurrentContext()).ToChecked());\n\t\tbreak;\n\tcase BOOLOID:\n\t\tif (value->IsBoolean())\n\t\t\treturn BoolGetDatum(value->BooleanValue(isolate));\n\t\tbreak;\n\tcase INT2OID:\n\t\tif (value->IsNumber())\n#ifdef CHECK_INTEGER_OVERFLOW\n\t\t\treturn DirectFunctionCall1(int82,\n\t\t\t\t\tInt64GetDatum(value->IntegerValue()));\n#else\n\t\t\treturn Int16GetDatum((int16) value->Int32Value(isolate->GetCurrentContext()).ToChecked());\n#endif\n\t\tbreak;\n\tcase INT4OID:\n\t\tif (value->IsNumber())\n#ifdef CHECK_INTEGER_OVERFLOW\n\t\t\treturn DirectFunctionCall1(int84,\n\t\t\t\t\tInt64GetDatum(value->IntegerValue()));\n#else\n\t\t\treturn Int32GetDatum((int32) value->Int32Value(isolate->GetCurrentContext()).ToChecked());\n#endif\n\t\tbreak;\n\tcase INT8OID:\n\t\tif (value->IsBigInt()) {\n\t\t\tBigInt *b = BigInt::Cast(*value);\n\t\t\treturn Int64GetDatum((int64) b->Int64Value());\n\t\t}\n\t\tif (value->IsNumber())\n\t\t\treturn Int64GetDatum((int64) value->IntegerValue(isolate->GetCurrentContext()).ToChecked());\n\t\tbreak;\n\tcase FLOAT4OID:\n\t\tif (value->IsNumber())\n\t\t\treturn Float4GetDatum((float4) value->NumberValue(isolate->GetCurrentContext()).ToChecked());\n\t\tbreak;\n\tcase FLOAT8OID:\n\t\tif (value->IsNumber())\n\t\t\treturn Float8GetDatum((float8) value->NumberValue(isolate->GetCurrentContext()).ToChecked());\n\t\tbreak;\n\tcase NUMERICOID:\n\t\tif (value->IsBigInt()) {\n\t\t\tv8::String::Utf8Value utf8(isolate, value->ToString(isolate->GetCurrentContext()).ToLocalChecked());\n\t\t\treturn DirectFunctionCall3(numeric_in, (Datum) *utf8, ObjectIdGetDatum(InvalidOid), Int32GetDatum((int32) -1));\n\t\t}\n\t\tif (value->IsNumber())\n\t\t\treturn DirectFunctionCall1(float8_numeric,\n\t\t\t\t\tFloat8GetDatum((float8) value->NumberValue(isolate->GetCurrentContext()).ToChecked()));\n\t\tbreak;\n\tcase DATEOID:\n\t\tif (value->IsDate())\n\t\t\treturn EpochToDate(value->NumberValue(isolate->GetCurrentContext()).ToChecked());\n\t\tbreak;\n\tcase TIMESTAMPOID:\n\tcase TIMESTAMPTZOID:\n\t\tif (value->IsDate())\n\t\t\treturn EpochToTimestampTz(value->NumberValue(isolate->GetCurrentContext()).ToChecked());\n\t\tbreak;\n\tcase BYTEAOID:\n\t\t{\n\t\t\tif (value->IsUint8Array() || value->IsInt8Array()) {\n\t\t\t\tv8::Handle<v8::Uint8Array> array = v8::Handle<v8::Uint8Array>::Cast(value);\n\t\t\t\tvoid *data = array->Buffer()->GetBackingStore()->Data();\n\t\t\t\tsize_t    offset = array->ByteOffset();\n\t\t\t\tsize_t\t\tlen = array->Length();\n\t\t\t\tsize_t\t\tsize = len + VARHDRSZ;\n\t\t\t\tvoid\t   *result = (void *) palloc(size);\n\n\t\t\t\tSET_VARSIZE(result, size);\n\t\t\t\tchar *local = (char *) data;\n\t\t\t\tmemcpy(VARDATA(result), &local[offset], len);\n\t\t\t\treturn PointerGetDatum(result);\n\t\t\t}\n\n\t\t\tif (value->IsUint16Array() || value->IsInt16Array()) {\n\t\t\t\tv8::Handle<v8::Uint16Array> array = v8::Handle<v8::Uint16Array>::Cast(value);\n\t\t\t\tint *data = (int *) array->Buffer()->GetBackingStore()->Data();\n\n\t\t\t\tsize_t    offset = array->ByteOffset();\n\t\t\t\tsize_t    len = array->ByteLength();\n\t\t\t\tsize_t    size = len + VARHDRSZ;\n\t\t\t\tvoid\t   *result = (void *) palloc(size);\n\n\t\t\t\tSET_VARSIZE(result, size);\n\t\t\t\tchar *local = (char *) data;\n\t\t\t\tmemcpy(VARDATA(result), &local[offset], len);\n\t\t\t\treturn PointerGetDatum(result);\n\t\t\t}\n\n\t\t\tif (value->IsUint32Array() || value->IsInt32Array()) {\n\t\t\t\tv8::Handle<v8::Uint32Array> array = v8::Handle<v8::Uint32Array>::Cast(value);\n\t\t\t\tvoid *data = array->Buffer()->GetBackingStore()->Data();\n\t\t\t\tsize_t    offset = array->ByteOffset();\n\t\t\t\tsize_t    len = array->ByteLength();\n\t\t\t\tsize_t    size = len + VARHDRSZ;\n\t\t\t\tvoid\t   *result = (void *) palloc(size);\n\n\t\t\t\tSET_VARSIZE(result, size);\n\t\t\t\tchar *local = (char *) data;\n\t\t\t\tmemcpy(VARDATA(result), &local[offset], len);\n\t\t\t\treturn PointerGetDatum(result);\n\t\t\t}\n\n\t\t\tif (value->IsArrayBuffer()) {\n\t\t\t\tv8::Handle<v8::ArrayBuffer> array = v8::Handle<v8::ArrayBuffer>::Cast(value);\n\t\t\t\tvoid *data = array->GetBackingStore()->Data();\n\t\t\t\tint\t\tlen = array->ByteLength();\n\t\t\t\tsize_t\t\tsize = len + VARHDRSZ;\n\t\t\t\tvoid\t   *result = (void *) palloc(size);\n\n\t\t\t\tSET_VARSIZE(result, size);\n\t\t\t\tmemcpy(VARDATA(result), data, len);\n\t\t\t\treturn PointerGetDatum(result);\n\t\t\t}\n\n\t\t\tvoid *datum_p = ExtractExternalArrayDatum(value);\n\n\t\t\tif (datum_p)\n\t\t\t{\n\t\t\t\treturn PointerGetDatum(datum_p);\n\t\t\t}\n\t\t}\n\t\tbreak;\n#if PG_VERSION_NUM >= 90400\n\tcase JSONBOID:\n#if JSONB_DIRECT_CONVERSION\n\t\t{\n\t\t\tJsonb *obj = ConvertObject(Local<v8::Object>::Cast(value));\n#if PG_VERSION_NUM < 110000\n\t\t\tPG_RETURN_JSONB(DatumGetJsonb(obj));\n#else\n\t\t\tPG_RETURN_JSONB_P(DatumGetJsonbP((unsigned long)obj));\n#endif // PG_VERSION_NUM < 110000\n\t\t}\n#else // JSONB_DIRECT_CONVERSION\n\t\tif (value->IsObject() || value->IsArray())\n\t\t{\n\t\t\tJSONObject JSON;\n\n\t\t\tHandle<v8::Value> result = JSON.Stringify(value);\n\t\t\tCString str(result);\n\n#if PG_VERSION_NUM < 110000\n\t\t\t// lots of casting, but it ends up working - there is no CStringGetJsonb exposed\n\t\t\treturn (Datum) DatumGetJsonb(DirectFunctionCall1(jsonb_in, (Datum) (char *) str));\n#else\n\t\t\treturn (Datum) DatumGetJsonbP(DirectFunctionCall1(jsonb_in, (Datum) (char *) str));\n#endif\n\t\t}\n#endif // JSONB_DIRECT_CONVERSION\n\t\tbreak;\n#endif\n#if PG_VERSION_NUM >= 90200\n\tcase JSONOID:\n\t\tif (value->IsObject() || value->IsArray())\n\t\t{\n\t\t\tJSONObject JSON;\n\n\t\t\tHandle<v8::Value> result = JSON.Stringify(value);\n\t\t\tCString str(result);\n\n\t\t\treturn CStringGetTextDatum(str);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\t/* Use lexical cast for non-numeric types. */\n\tCString\t\tstr(value);\n\tDatum\t\tresult;\n\n\tPG_TRY();\n\t{\n\t\tif (type->fn_input.fn_addr == NULL)\n\t\t{\n\t\t\tOid    input_func;\n\n\t\t\tgetTypeInputInfo(type->typid, &input_func, &type->ioparam);\n\t\t\tfmgr_info_cxt(input_func, &type->fn_input, type->fn_input.fn_mcxt);\n\t\t}\n\t\tresult = InputFunctionCall(&type->fn_input, str, type->ioparam, -1);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\treturn result;\n}\n\nstatic Datum\nToArrayDatum(Handle<v8::Value> value, bool *isnull, plv8_type *type)\n{\n\tint\t\t\tlength;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t\tndims[1];\n\tint\t\t\tlbs[] = {1};\n\tArrayType  *result;\n\tIsolate *isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\n\tif (value->IsUndefined() || value->IsNull())\n\t{\n\t\t*isnull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\tvoid *datum_p = ExtractExternalArrayDatum(value);\n\tif (datum_p)\n\t{\n\t\t*isnull = false;\n\t\treturn PointerGetDatum(datum_p);\n\t}\n\n\tHandle<Array> array(Handle<Array>::Cast(value));\n\tif (array.IsEmpty() || !array->IsArray())\n\t\tthrow js_error(\"value is not an Array\");\n\n\tlength = array->Length();\n\tvalues = (Datum *) palloc(sizeof(Datum) * length);\n\tnulls = (bool *) palloc(sizeof(bool) * length);\n\tndims[0] = length;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (type->is_composite)\n\t\t{\n\t\t\tvalues[i] = ToRecordDatum(array->Get(context, i).ToLocalChecked(), &nulls[i], type);\n\t\t} else {\n\t\t\tvalues[i] = ToScalarDatum(array->Get(context, i).ToLocalChecked(), &nulls[i], type);\n\t\t}\n\t}\n\n\tresult = construct_md_array(values, nulls, 1, ndims, lbs,\n\t\t\t\ttype->typid, type->len, type->byval, type->align);\n\tpfree(values);\n\tpfree(nulls);\n\n\t*isnull = false;\n\treturn PointerGetDatum(result);\n}\n\nstatic Datum\nToRecordDatum(Handle<v8::Value> value, bool *isnull, plv8_type *type)\n{\n\tDatum\t\tresult;\n\tTupleDesc\ttupdesc;\n\n\tif (value->IsUndefined() || value->IsNull())\n\t{\n\t\t*isnull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\tPG_TRY();\n\t{\n\t\ttupdesc = lookup_rowtype_tupdesc(type->typid, -1);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tConverter\tconv(tupdesc);\n\n\tresult = conv.ToDatum(value);\n\n\tReleaseTupleDesc(tupdesc);\n\n\t*isnull = false;\n\treturn result;\n}\n\nLocal<v8::Value>\nToValue(Datum datum, bool isnull, plv8_type *type)\n{\n\tIsolate* isolate = Isolate::GetCurrent();\n\tif (isnull)\n\t\treturn Local<v8::Value>::New(isolate, Null(isolate));\n\telse if (type->category == TYPCATEGORY_ARRAY || type->typid == RECORDARRAYOID)\n\t\treturn ToArrayValue(datum, isnull, type);\n\telse if (type->category == TYPCATEGORY_COMPOSITE || type->typid == RECORDOID)\n\t\treturn ToRecordValue(datum, isnull, type);\n\telse\n\t\treturn ToScalarValue(datum, isnull, type);\n}\n\nstatic Local<v8::Value>\nToScalarValue(Datum datum, bool isnull, plv8_type *type)\n{\n\tIsolate* isolate = Isolate::GetCurrent();\n\tswitch (type->typid)\n\t{\n\tcase OIDOID:\n\t\treturn Uint32::New(isolate, DatumGetObjectId(datum));\n\tcase BOOLOID:\n\t\treturn v8::Boolean::New(isolate, DatumGetBool(datum));\n\tcase INT2OID:\n\t\treturn Int32::New(isolate, DatumGetInt16(datum));\n\tcase INT4OID:\n\t\treturn Int32::New(isolate, DatumGetInt32(datum));\n\tcase INT8OID: {\n#if BIGINT_GRACEFUL\n\t\tint64 v = DatumGetInt64(datum);\n\n\t\tif (v > INT32_MAX || v < INT32_MIN)\n\t\t\treturn BigInt::New(isolate, v);\n\t\treturn Number::New(isolate, v);\n#else\n\t\treturn BigInt::New(isolate, DatumGetInt64(datum));\n#endif\n\t}\n\tcase FLOAT4OID:\n\t\treturn Number::New(isolate, DatumGetFloat4(datum));\n\tcase FLOAT8OID:\n\t\treturn Number::New(isolate, DatumGetFloat8(datum));\n\tcase NUMERICOID:\n\t\treturn Number::New(isolate, DatumGetFloat8(\n\t\t\tDirectFunctionCall1(numeric_float8, datum)));\n\tcase DATEOID:\n\t\treturn Date::New(isolate->GetCurrentContext(), DateToEpoch(DatumGetDateADT(datum))).ToLocalChecked();\n\tcase TIMESTAMPOID:\n\tcase TIMESTAMPTZOID:\n\t\treturn Date::New(isolate->GetCurrentContext(), TimestampTzToEpoch(DatumGetTimestampTz(datum))).ToLocalChecked();\n\tcase TEXTOID:\n\tcase VARCHAROID:\n\tcase BPCHAROID:\n\tcase XMLOID:\n\t{\n\t\tvoid\t   *p = PG_DETOAST_DATUM_PACKED(datum);\n\t\tconst char *str = VARDATA_ANY(p);\n\t\tint\t\t\tlen = VARSIZE_ANY_EXHDR(p);\n\n\t\tLocal<v8::String>\tresult = ToString(str, len);\n\n\t\tif (p != DatumGetPointer(datum))\n\t\t\tpfree(p);\t// free if detoasted\n\t\treturn result;\n\t}\n\tcase BYTEAOID:\n\t{\n\t\tvoid\t   *p = PG_DETOAST_DATUM_COPY(datum);\n\n\t\treturn CreateExternalArray(VARDATA_ANY(p),\n\t\t\t\t\t\t\t\t   kExternalUnsignedByteArray,\n\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(p),\n\t\t\t\t\t\t\t\t   PointerGetDatum(p));\n\t}\n#if PG_VERSION_NUM >= 90200\n\tcase JSONOID:\n\t{\n\t\tvoid\t   *p = PG_DETOAST_DATUM_PACKED(datum);\n\t\tconst char *str = VARDATA_ANY(p);\n\t\tint\t\t\tlen = VARSIZE_ANY_EXHDR(p);\n\n\t\tLocal<v8::Value>\tjsonString = ToString(str, len);\n\t\tJSONObject JSON;\n\t\tLocal<v8::Value> result = Local<v8::Value>::New(isolate, JSON.Parse(jsonString));\n\n\t\tif (p != DatumGetPointer(datum))\n\t\t\tpfree(p);\t// free if detoasted\n\t\treturn result;\n\t}\n#endif\n#if PG_VERSION_NUM >= 90400\n\tcase JSONBOID:\n\t{\n#if JSONB_DIRECT_CONVERSION\n\t\tJsonb *jsonb = (Jsonb *) PG_DETOAST_DATUM(datum);\n\t\tLocal<v8::Value> result;\n\t\tif (JB_ROOT_IS_SCALAR(jsonb)) {\n\t\t\tJsonbValue  jb;\n\t\t\tJsonbExtractScalar(&jsonb->root, &jb);\n\t\t\tresult = GetJsonbValue(&jb);\n\t\t} else {\n\t\t\tresult = ConvertJsonb(&jsonb->root);\n\t\t}\n#else\n\t\tLocal<v8::Value>\tjsonString = ToString(datum, type);\n\t\tJSONObject JSON;\n\t\tLocal<v8::Value> result = Local<v8::Value>::New(isolate, JSON.Parse(jsonString));\n#endif\n\n\t\treturn result;\n\t}\n#endif\n\tdefault:\n\t\treturn ToString(datum, type);\n\t}\n}\n\nstatic Local<v8::Value>\nToArrayValue(Datum datum, bool isnull, plv8_type *type)\n{\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tIsolate *isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\n\t/*\n\t * If we can use an external array, do it instead.\n\t */\n\tif (type->ext_array)\n\t{\n\t\tArrayType   *array = DatumGetArrayTypePCopy(datum);\n\n\t\t/*\n\t\t * We allow only non-NULL, 1-dim array.\n\t\t */\n\t\tif (!ARR_HASNULL(array) && ARR_NDIM(array) <= 1)\n\t\t{\n\t\t\tint\t\t\tdata_bytes = ARR_SIZE(array) -\n\t\t\t\t\t\t\t\t\t\tARR_OVERHEAD_NONULLS(1);\n\t\t\treturn CreateExternalArray(ARR_DATA_PTR(array),\n\t\t\t\t\t\t\t\t\t   type->ext_array,\n\t\t\t\t\t\t\t\t\t   data_bytes,\n\t\t\t\t\t\t\t\t\t   PointerGetDatum(array));\n\t\t}\n\n\t\tthrow js_error(\"NULL element, or multi-dimension array not allowed\"\n\t\t\t\t\t\t\" in external array type\");\n\t}\n\n\tdeconstruct_array(DatumGetArrayTypeP(datum),\n\t\t\t\t\t\ttype->typid, type->len, type->byval, type->align,\n\t\t\t\t\t\t&values, &nulls, &nelems);\n\tLocal<Array>  result = Array::New(Isolate::GetCurrent(), nelems);\n\tplv8_type base = { 0 };\n\tbool    ispreferred;\n\n\tbase.typid = type->typid;\n\tif (base.typid == RECORDARRAYOID)\n\t\tbase.typid = RECORDOID;\n\n\tbase.fn_input.fn_mcxt = base.fn_output.fn_mcxt = type->fn_input.fn_mcxt;\n\tget_type_category_preferred(base.typid, &(base.category), &ispreferred);\n\tget_typlenbyvalalign(base.typid, &(base.len), &(base.byval), &(base.align));\n\n\tfor (int i = 0; i < nelems; i++)\n\t\tresult->Set(context, i, ToValue(values[i], nulls[i], &base)).Check();\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}\n\nstatic Local<v8::Value>\nToRecordValue(Datum datum, bool isnull, plv8_type *type)\n{\n\tHeapTupleHeader\trec = DatumGetHeapTupleHeader(datum);\n\tOid\t\t\t\ttupType;\n\tint32\t\t\ttupTypmod;\n\tTupleDesc\t\ttupdesc;\n\tHeapTupleData\ttuple;\n\n\tPG_TRY();\n\t{\n\t\t/* Extract type info from the tuple itself */\n\t\ttupType = HeapTupleHeaderGetTypeId(rec);\n\t\ttupTypmod = HeapTupleHeaderGetTypMod(rec);\n\t\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tConverter\tconv(tupdesc);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(rec);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = rec;\n\n\tLocal<v8::Value> result = conv.ToValue(&tuple);\n\n\tReleaseTupleDesc(tupdesc);\n\n\treturn result;\n}\n\nLocal<v8::String>\nToString(Datum value, plv8_type *type)\n{\n\tint\t\tencoding = GetDatabaseEncoding();\n\tchar   *str;\n\n\tPG_TRY();\n\t{\n\t\tif (type->fn_output.fn_addr == NULL)\n\t\t{\n\t\t\tOid\t\toutput_func;\n\t\t\tbool\tisvarlen;\n\n\t\t\tgetTypeOutputInfo(type->typid, &output_func, &isvarlen);\n\t\t\tfmgr_info_cxt(output_func, &type->fn_output, type->fn_output.fn_mcxt);\n\t\t}\n\t\tstr = OutputFunctionCall(&type->fn_output, value);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tLocal<v8::String>\tresult =\n\t\tencoding == PG_UTF8\n\t\t\t? v8::String::NewFromUtf8(Isolate::GetCurrent(), str).ToLocalChecked()\n\t\t\t: ToString(str, strlen(str), encoding);\n\tpfree(str);\n\n\treturn result;\n}\n\nLocal<v8::String>\nToString(const char *str, int len, int encoding)\n{\n\tchar\t\t   *utf8;\n\tIsolate\t\t   *isolate = Isolate::GetCurrent();\n\n\tif (str == NULL) {\n\t\treturn v8::String::NewFromUtf8(isolate, \"(null)\", NewStringType::kNormal, 6).ToLocalChecked();\n\t}\n\tif (len < 0)\n\t\tlen = strlen(str);\n\n\tPG_TRY();\n\t{\n\t\tutf8 = (char *) pg_do_encoding_conversion(\n\t\t\t\t\t(unsigned char *) str, len, encoding, PG_UTF8);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\tif (utf8 != str)\n\t\tlen = strlen(utf8);\n\tLocal<v8::String> result = v8::String::NewFromUtf8(isolate, utf8, NewStringType::kNormal, len).ToLocalChecked();\n\tif (utf8 != str)\n\t\tpfree(utf8);\n\treturn result;\n}\n\n/*\n * Convert utf8 text to database encoded text.\n * The result could be same as utf8 input, or palloc'ed one.\n */\nchar *\nToCString(const v8::String::Utf8Value &value)\n{\n\tchar *str = const_cast<char *>(*value);\n\tif (str == NULL)\n\t\treturn NULL;\n\n\tint    encoding = GetDatabaseEncoding();\n\tif (encoding == PG_UTF8)\n\t\treturn str;\n\n\tPG_TRY();\n\t{\n\t\tstr = (char *) pg_do_encoding_conversion(\n\t\t\t\t(unsigned char *) str, strlen(str), PG_UTF8, encoding);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\treturn str;\n}\n\n/*\n * Convert utf8 text to database encoded text.\n * The result is always palloc'ed one.\n */\nchar *\nToCStringCopy(const v8::String::Utf8Value &value)\n{\n\tchar *str;\n\tconst char *utf8 = *value;\n\tif (utf8 == NULL)\n\t\treturn NULL;\n\n\tPG_TRY();\n\t{\n\t\tint\tencoding = GetDatabaseEncoding();\n\t\tstr = (char *) pg_do_encoding_conversion(\n\t\t\t\t(unsigned char *) utf8, strlen(utf8), PG_UTF8, encoding);\n\t\tif (str == utf8)\n\t\t\tstr = pstrdup(utf8);\n\t}\n\tPG_CATCH();\n\t{\n\t\tthrow pg_error();\n\t}\n\tPG_END_TRY();\n\n\treturn str;\n}\n\n/*\n * Since v8 represents a Date object using a double value in msec from unix epoch,\n * we need to shift the epoch and adjust the time unit.\n */\nstatic double\nTimestampTzToEpoch(TimestampTz tm)\n{\n\tdouble\t\tepoch;\n\n\t// TODO: check if TIMESTAMP_NOBEGIN or NOEND\n#ifdef HAVE_INT64_TIMESTAMP\n\tepoch = (double) tm / 1000.0;\n#else\n\tepoch = (double) tm * 1000.0;\n#endif\n\n\treturn epoch + (POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * 86400000.0;\n}\n\nstatic Datum\nEpochToTimestampTz(double epoch)\n{\n\tepoch -= (POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * 86400000.0;\n\n#ifdef HAVE_INT64_TIMESTAMP\n\treturn Int64GetDatum((int64) epoch * 1000);\n#else\n\treturn Float8GetDatum(epoch / 1000.0);\n#endif\n}\n\nstatic double\nDateToEpoch(DateADT date)\n{\n\tdouble\t\tepoch;\n\n\t// TODO: check if DATE_NOBEGIN or NOEND\n#ifdef HAVE_INT64_TIMESTAMP\n\tepoch = (double) date * USECS_PER_DAY / 1000.0;\n#else\n\tepoch = (double) date * SECS_PER_DAY * 1000.0;\n#endif\n\n\treturn epoch + (POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * 86400000.0;\n}\n\nstatic Datum\nEpochToDate(double epoch)\n{\n\tepoch -= (POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * 86400000.0;\n\n#ifdef HAVE_INT64_TIMESTAMP\n\tepoch = (epoch * 1000) / USECS_PER_DAY;\n#else\n    epoch = (epoch / 1000) / SECS_PER_DAY;\n#endif\n\tPG_RETURN_DATEADT((DateADT) epoch);\n}\n\nCString::CString(Handle<v8::Value> value) : m_utf8(Isolate::GetCurrent(), value)\n{\n\tm_str = ToCString(m_utf8);\n}\n\nCString::~CString()\n{\n\tif (m_str != *m_utf8)\n\t\tpfree(m_str);\n}\n\nbool CString::toStdString(v8::Handle<v8::Value> value, std::string &out)\n{\n\tif(value.IsEmpty()) {\n\t\treturn false;\n\t}\n\tIsolate* isolate = Isolate::GetCurrent();\n\tLocal<Context>\t\tcontext = isolate->GetCurrentContext();\n\n\t// this is kind of gross, but there's a potential for IsEmpty() to be false\n\t// and the MaybeLocal version of ToString() to be empty\n\tMaybeLocal<v8::String> val2 = value->ToString(context);\n\n\tif (val2.IsEmpty()) {\n\t\treturn false;\n\t}\n\n\tv8::String::Utf8Value utf8(isolate, val2.ToLocalChecked());\n\n\tif(*utf8) {\n\t\tout = *utf8;\n\t\treturn true;\n\t}\n\treturn false;\n}\n"
        },
        {
          "name": "sql",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}