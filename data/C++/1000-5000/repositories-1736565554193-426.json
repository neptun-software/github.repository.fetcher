{
  "metadata": {
    "timestamp": 1736565554193,
    "page": 426,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "steveicarus/iverilog",
      "stars": 2909,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0615234375,
          "content": "# gperf in MSYS chokes on DOS line endings\n*.gperf text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.55078125,
          "content": "# Lines that start with '#' are comments.\n#\n# This file is for the development branch of Icarus Verilog.\n#\n# The following files will be ignored by git.\n\n# Normal editor rules\n*.swp\n*~\n\n# Top level generic files\ntags\nTAGS\ncscope.*\n*.patch\n*.orig\n\n# Object files and libraries\n*.[oa]\n*.so\n\ngmon*.out\ngmon*.txt\n\n# From autoconf\nconfigure\nconfig.log\nconfig.status\nMakefile\n\n/_pli_types.h\nconfig.h\n/tgt-pcb/pcb_config.h\n/tgt-pcb/fp.cc\n/tgt-pcb/fp.h\n/tgt-pcb/fp.output\n/tgt-pcb/fp_lex.cc\n/tgt-vvp/vvp_config.h\n/tgt-vhdl/vhdl_config.h\n/vpi/vpi_config.h\nstamp-*-h\n/version.h\n/version_tag.h\n\n# Directories\nautom4te.cache\ndep\n\n# Compiler back end and library files\n/tgt-vvp/*.conf\n*.tgt\n*.vpi\n/cadpli/cadpli.vpl\n\n/tgt-blif/Makefile\n\n# lex, yacc and gperf output\n/driver/cflexor.c\n/driver/cfparse.c\n/driver/cfparse.h\n/driver/cfparse.output\n\n/ivlpp/lexor.c\n\n/vhdlpp/lexor.cc\n/vhdlpp/lexor_keyword.cc\n/vhdlpp/parse.cc\n/vhdlpp/parse.h\n/vhdlpp/parse.output\n/vhdlpp/vhdlpp_config.h\n/vhdlpp/vhdlpp\n\n/lexor.cc\n/lexor_keyword.cc\n/parse.cc\n/parse.h\n/parse.output\n/syn-rules.cc\n/syn-rules.output\n\n/vpi/sdf_lexor.c\n/vpi/sdf_parse.c\n/vpi/sdf_parse.h\n/vpi/sdf_parse.output\n/vpi/sys_readmem_lex.c\n/vpi/table_mod_lexor.c\n/vpi/table_mod_parse.c\n/vpi/table_mod_parse.h\n/vpi/table_mod_parse.output\n\n/vvp/dump.*\n/vvp/lexor.cc\n/vvp/parse.cc\n/vvp/parse.h\n/vvp/parse.output\n\n# Program created files\n/vvp/tables.cc\n\n/iverilog-vpi.man\n/driver-vpi/res.rc\n/driver/iverilog.man\n/vvp/vvp.man\n\n# The executables.\n*.exe\n/driver/iverilog\n/iverilog-vpi\n/ivl\n/ivlpp/ivlpp\n/vvp/vvp\n\n/ivl.exp\n/vvp/vvp.exp\n\n# Check output\n/check.vvp\n"
        },
        {
          "name": "AStatement.cc",
          "type": "blob",
          "size": 1.0341796875,
          "content": "/*\n * Copyright (c) 2008 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"AStatement.h\"\n\nAContrib::AContrib(PExpr*lv, PExpr*rv)\n: lval_(lv), rval_(rv)\n{\n}\n\nAContrib::~AContrib()\n{\n      delete lval_;\n      delete rval_;\n}\n\nAProcess::~AProcess()\n{\n}\n"
        },
        {
          "name": "AStatement.h",
          "type": "blob",
          "size": 2.3671875,
          "content": "#ifndef IVL_AStatement_H\n#define IVL_AStatement_H\n/*\n * Copyright (c) 2008-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <map>\n# include  \"ivl_target.h\"\n# include  \"StringHeap.h\"\n# include  \"LineInfo.h\"\n# include  \"Statement.h\"\n# include  \"PExpr.h\"\n\nclass PExpr;\nclass NetAnalog;\nclass NetScope;\nclass Design;\n\n/*\n * A contribution statement is like an assignment: there is an l-value\n * expression and an r-value expression. The l-value is a branch probe\n * expression.\n */\nclass AContrib : public Statement {\n\n    public:\n      AContrib(PExpr*lval, PExpr*rval);\n      ~AContrib();\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n\n    private:\n      PExpr*lval_;\n      PExpr*rval_;\n};\n\n/*\n * An analog process is not a statement, but contains an analog\n * statement. The process is where we attach process characteristics\n * such as initial vs. always, attributes....\n */\nclass AProcess : public LineInfo {\n\n    public:\n      AProcess(ivl_process_type_t t, Statement*st)\n      : type_(t), statement_(st) { }\n\n      ~AProcess();\n\n      bool elaborate(Design*des, NetScope*scope) const;\n\n      ivl_process_type_t type() const { return type_; }\n      Statement*statement() { return statement_; }\n\n      std::map<perm_string,PExpr*> attributes;\n\n\t// Dump the analog process\n      void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      ivl_process_type_t type_;\n      Statement*statement_;\n\n    private: // not implemented\n      AProcess(const AProcess&);\n      AProcess& operator= (const AProcess&);\n};\n\n#endif /* IVL_AStatement_H */\n"
        },
        {
          "name": "Attrib.cc",
          "type": "blob",
          "size": 2.2490234375,
          "content": "/*\n * Copyright (c) 2000-2010 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"Attrib.h\"\n# include  <cassert>\n\nAttrib::Attrib()\n{\n      nlist_ = 0;\n      list_ = 0;\n}\n\nAttrib::~Attrib()\n{\n      delete[] list_;\n}\n\n\nconst verinum& Attrib::attribute(perm_string key) const\n{\n      for (unsigned idx = 0 ;  idx < nlist_ ;  idx += 1) {\n\n\t    if (key == list_[idx].key)\n\t\t  return list_[idx].val;\n      }\n\n      static const verinum null;\n      return null;\n}\n\nvoid Attrib::attribute(perm_string key, const verinum&value)\n{\n      unsigned idx;\n\n      for (idx = 0 ; idx < nlist_ ;  idx += 1) {\n\t    if (key == list_[idx].key) {\n\t\t  list_[idx].val = value;\n\t\t  return;\n\t    }\n      }\n\n      struct cell_*tmp = new struct cell_[nlist_+1];\n      for (idx = 0 ;  idx < nlist_ ;  idx += 1)\n\t    tmp[idx] = list_[idx];\n\n      tmp[nlist_].key = key;\n      tmp[nlist_].val = value;\n\n      nlist_ += 1;\n      delete[]list_;\n      list_ = tmp;\n}\n\nbool Attrib::has_compat_attributes(const Attrib&that) const\n{\n      unsigned idx;\n\n      for (idx = 0 ;  idx < that.nlist_ ;  idx += 1) {\n\n\t    verinum tmp = attribute(that.list_[idx].key);\n\t    if (tmp != that.list_[idx].val)\n\t\t  return false;\n      }\n\n      return true;\n}\n\nunsigned Attrib::attr_cnt() const\n{\n      return nlist_;\n}\n\nperm_string Attrib::attr_key(unsigned idx) const\n{\n      assert(idx < nlist_);\n      return list_[idx].key;\n}\n\nconst verinum& Attrib::attr_value(unsigned idx) const\n{\n      assert(idx < nlist_);\n      return list_[idx].val;\n}\n"
        },
        {
          "name": "Attrib.h",
          "type": "blob",
          "size": 1.75390625,
          "content": "#ifndef IVL_Attrib_H\n#define IVL_Attrib_H\n/*\n * Copyright (c) 2000-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"StringHeap.h\"\n# include  \"verinum.h\"\n\n/*\n * This class keeps a map of key/value pairs. The map can be set from\n * an STL map, or by setting individual mappings.\n */\nclass Attrib {\n\n    public:\n      Attrib();\n      virtual ~Attrib();\n\n      const verinum&attribute(perm_string key) const;\n      void attribute(perm_string key, const verinum&value);\n      bool has_compat_attributes(const Attrib&that) const;\n\n\n\t/* Provide a means of iterating over the entries in the map. */\n      unsigned       attr_cnt() const;\n      perm_string    attr_key(unsigned idx) const;\n      const verinum& attr_value(unsigned idx) const;\n\n\n    private:\n      struct cell_ {\n\t    perm_string  key;\n\t    verinum val;\n      };\n\n      unsigned nlist_;\n      struct cell_*list_;\n\n    private: // not implemented\n      Attrib(const Attrib&);\n      Attrib& operator= (const Attrib&);\n};\n\n#endif /* IVL_Attrib_H */\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "Documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "HName.cc",
          "type": "blob",
          "size": 2.8291015625,
          "content": "/*\n * Copyright (c) 2001-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"HName.h\"\n# include  <iostream>\n# include  <cstring>\n# include  <cstdlib>\n\nusing namespace std;\n\nhname_t::hname_t()\n{\n}\n\nhname_t::hname_t(perm_string text)\n: name_(text)\n{\n}\n\nhname_t::hname_t(perm_string text, int num)\n: name_(text), number_(1)\n{\n      number_[0] = num;\n}\n\nhname_t::hname_t(perm_string text, const vector<int>&nums)\n: name_(text), number_(nums)\n{\n}\n\nhname_t::hname_t(const hname_t&that)\n: name_(that.name_), number_(that.number_)\n{\n}\n\nhname_t& hname_t::operator = (const hname_t&that)\n{\n      name_ = that.name_;\n      number_ = that.number_;\n      return *this;\n}\n\nbool hname_t::operator < (const hname_t&r) const\n{\n      int cmp = strcmp(name_, r.name_);\n      if (cmp < 0) return true;\n      if (cmp > 0) return false;\n\n\t// The text parts are equal, so compare then number\n\t// parts. Finish as soon as we find one to be less or more\n\t// than the other.\n      size_t idx = 0;\n      while (number_.size() > idx || r.number_.size() > idx) {\n\n\t      // Ran out of l numbers, so less.\n\t    if (number_.size() <= idx)\n\t\t  return true;\n\n\t      // Ran out of r numbers, so greater.\n\t    if (r.number_.size() <= idx)\n\t\t  return false;\n\n\t    if (number_[idx] < r.number_[idx])\n\t\t  return true;\n\n\t    if (number_[idx] > r.number_[idx])\n\t\t  return false;\n\n\t    idx += 1;\n      }\n\n\t// Fall-through means that we are equal, including all the\n\t// number parts, so not less.\n      return false;\n}\n\nbool hname_t::operator == (const hname_t&r) const\n{\n      if (name_ == r.name_) {\n\t    if (number_.size() != r.number_.size())\n\t\t  return false;\n\n\t    for (size_t idx = 0 ; idx < number_.size() ; idx += 1)\n\t\t  if (number_[idx] != r.number_[idx]) return false;\n\n\t    return true;\n      }\n\n      return false;\n}\n\nostream& operator<< (ostream&out, const hname_t&that)\n{\n      if (that.peek_name() == 0) {\n\t    out << \"\";\n\t    return out;\n      }\n\n      out << that.peek_name();\n      for (size_t idx = 0 ; idx < that.number_.size() ; idx += 1)\n\t    out << \"[\" << that.number_[idx] << \"]\";\n\n      return out;\n}\n"
        },
        {
          "name": "HName.h",
          "type": "blob",
          "size": 3.0234375,
          "content": "#ifndef IVL_HName_H\n#define IVL_HName_H\n/*\n * Copyright (c) 2001-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <iostream>\n# include  <list>\n# include  <vector>\n# include  \"StringHeap.h\"\n\n# include  <cassert>\n\n/*\n * This class represents a component of a Verilog hierarchical name. A\n * hierarchical component contains a name string (represented here\n * with a perm_string) and an optional signed number. This signed\n * number is used if the scope is part of an array, for example an\n * array of module instances or a loop generated scope.\n */\n\nclass hname_t {\n\n      friend std::ostream& operator<< (std::ostream&out, const hname_t&that);\n\n    public:\n      hname_t ();\n      explicit hname_t (perm_string text);\n      explicit hname_t (perm_string text, int num);\n      explicit hname_t (perm_string text, const std::vector<int>&nums);\n      hname_t (const hname_t&that);\n      ~hname_t();\n\n      hname_t& operator= (const hname_t&);\n\n      bool operator == (const hname_t&that) const;\n      bool operator <  (const hname_t&that) const;\n\n\t// Return the string part of the hname_t.\n      perm_string peek_name(void) const;\n\n      size_t has_numbers() const;\n      int peek_number(size_t idx) const;\n      const std::vector<int>&peek_numbers() const;\n\n    private:\n      perm_string name_;\n\t// If this vector has size, then the numbers all together make\n\t// up part of the hierarchical name.\n      std::vector<int> number_;\n\n    private: // not implemented\n};\n\ninline hname_t::~hname_t()\n{\n}\n\ninline perm_string hname_t::peek_name(void) const\n{\n      return name_;\n}\n\ninline int hname_t::peek_number(size_t idx) const\n{\n      assert(number_.size() > idx);\n      return number_[idx];\n}\n\ninline const std::vector<int>& hname_t::peek_numbers(void) const\n{\n      return number_;\n}\n\ninline size_t hname_t::has_numbers() const\n{\n      return number_.size();\n}\n\nextern std::ostream& operator<< (std::ostream&, const hname_t&);\n\ninline bool operator != (const hname_t&l, const hname_t&r)\n{ return ! (l == r); }\n\ninline std::ostream& operator<< (std::ostream&out, const std::list<hname_t>&ll)\n{\n      std::list<hname_t>::const_iterator cur = ll.begin();\n      out << *cur;\n      ++ cur;\n      while (cur != ll.end()) {\n\t    out << \".\" << *cur;\n\t    ++ cur;\n      }\n      return out;\n}\n\n#endif /* IVL_HName_H */\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 7.828125,
          "content": "Basic Installation\n==================\n\n   These are generic installation instructions, with minor updates\nfor the `iverilog` project.\n\n   Instructions in the `README` are more concise for this project.\n\n   The `configure` shell script attempts to guess correct values for\nvarious system-dependent variables used during compilation.  It uses\nthose values to create a `Makefile` in each directory of the package.\nIt may also create one or more `.h` files containing system-dependent\ndefinitions.  Finally, it creates a shell script `config.status` that\nyou can run in the future to recreate the current configuration, a file\n`config.cache` that saves the results of its tests to speed up\nreconfiguring, and a file `config.log` containing compiler output\n(useful mainly for debugging `configure`).\n\n   If you need to do unusual things to compile the package, please try\nto figure out how `configure` could check whether to do them, and mail\ndiffs or instructions to the address given in the `README` so they can\nbe considered for the next release.  If at some point `config.cache`\ncontains results you don't want to keep, you may remove or edit it.\n\n   The file `configure.ac` is used to create `configure` by a program\ncalled `autoconf`.  You only need `configure.ac` if you want to change\nit or regenerate `configure` using a newer version of `autoconf`.\n\nThe simplest way to compile this package is:\n\n  1. `cd` to the directory containing the package's source code.\n\n  2. Run `sh autoconf.sh`, if building from source (and not a release).\n     If you're building from a release, skip this step.\n\n  3. Run `./configure` to configure the package for your system.  If you're\n     using `csh` on an old version of System V, you might need to type\n     `sh ./configure` instead to prevent `csh` from trying to execute\n     `configure` itself.\n\n     Running `configure` takes awhile.  While running, it prints some\n     messages telling which features it is checking for.\n\n  4. Type `make` to compile the package.\n\n  5. Optionally, type `make check` to run any self-tests that come with\n     the package.\n\n  6. Type `make install` to install the programs and any data files and\n     documentation. You may need to use `sudo`.\n\n  7. You can remove the program binaries and object files from the\n     source code directory by typing `make clean`.  To also remove the\n     files that `configure` created (so you can compile the package for\n     a different kind of computer), type `make distclean`.  There is\n     also a `make maintainer-clean` target, but that is intended mainly\n     for the package's developers.  If you use it, you may have to get\n     all sorts of other programs in order to regenerate files that came\n     with the distribution.\n\nCompilers and Options\n=====================\n\n   Some systems require unusual options for compilation or linking that\nthe `configure` script does not know about.  You can give `configure`\ninitial values for variables by setting them in the environment.  Using\na Bourne-compatible shell, you can do that on the command line like\nthis:\n\n```bash\n     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure\n```\n\nOr on systems that have the `env` program, you can do it like this:\n```bash\n     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure\n```\n\nCompiling For Multiple Architectures\n====================================\n\n   You can compile the package for more than one kind of computer at the\nsame time, by placing the object files for each architecture in their\nown directory.  To do this, you must use a version of `make` that\nsupports the `VPATH` variable, such as GNU `make`.  `cd` to the\ndirectory where you want the object files and executables to go and run\nthe `configure` script.  `configure` automatically checks for the\nsource code in the directory that `configure` is in and in `..`.\n\n   If you have to use a `make` that does not supports the `VPATH`\nvariable, you have to compile the package for one architecture at a time\nin the source code directory.  After you have installed the package for\none architecture, use `make distclean` before reconfiguring for another\narchitecture.\n\nInstallation Names\n==================\n\n   By default, `make install` will install the package's files in\n`/usr/local/bin`, `/usr/local/man`, etc.  You can specify an\ninstallation prefix other than `/usr/local` by giving `configure` the\noption `--prefix=PATH`.\n\n   You can specify separate installation prefixes for\narchitecture-specific files and architecture-independent files.  If you\ngive `configure` the option `--exec-prefix=PATH`, the package will use\nPATH as the prefix for installing programs and libraries.\nDocumentation and other data files will still use the regular prefix.\n\n   In addition, if you use an unusual directory layout you can give\noptions like `--bindir=PATH` to specify different values for particular\nkinds of files.  Run `configure --help` for a list of the directories\nyou can set and what kinds of files go in them.\n\n   If the package supports it, you can cause programs to be installed\nwith an extra prefix or suffix on their names by giving `configure` the\noption `--program-prefix=PREFIX` or `--program-suffix=SUFFIX`.\n\nOptional Features\n=================\n\n   Some packages pay attention to `--enable-FEATURE` options to\n`configure`, where FEATURE indicates an optional part of the package.\nThey may also pay attention to `--with-PACKAGE` options, where PACKAGE\nis something like `gnu-as` or `x` (for the X Window System).  The\n`README` should mention any `--enable-` and `--with-` options that the\npackage recognizes.\n\n   For packages that use the X Window System, `configure` can usually\nfind the X include and library files automatically, but if it doesn't,\nyou can use the `configure` options `--x-includes=DIR` and\n`--x-libraries=DIR` to specify their locations.\n\nSpecifying the System Type\n==========================\n\n   There may be some features `configure` can not figure out\nautomatically, but needs to determine by the type of host the package\nwill run on.  Usually `configure` can figure that out, but if it prints\na message saying it can not guess the host type, give it the\n`--host=TYPE` option.  TYPE can either be a short name for the system\ntype, such as `sun4`, or a canonical name with three fields:\n     `CPU-COMPANY-SYSTEM`\n\nSee the file `config.sub` for the possible values of each field.  If\n`config.sub` isn't included in this package, then this package doesn't\nneed to know the host type.\n\n   If you are building compiler tools for cross-compiling, you can also\nuse the `--target=TYPE` option to select the type of system they will\nproduce code for and the `--build=TYPE` option to select the type of\nsystem on which you are compiling the package.\n\nSharing Defaults\n================\n\n   If you want to set default values for `configure` scripts to share,\nyou can create a site shell script called `config.site` that gives\ndefault values for variables like `CC`, `cache_file`, and `prefix`.\n`configure` looks for `PREFIX/share/config.site` if it exists, then\n`PREFIX/etc/config.site` if it exists.  Or, you can set the\n`CONFIG_SITE` environment variable to the location of the site script.\nA warning: not all `configure` scripts look for a site script.\n\nOperation Controls\n==================\n\n   `configure` recognizes the following options to control how it\noperates.\n\n`--cache-file=FILE`\n     Use and save the results of the tests in FILE instead of\n     `./config.cache`.  Set FILE to `/dev/null` to disable caching, for\n     debugging `configure`.\n\n`--help`\n     Print a summary of the options to `configure`, and exit.\n\n`--quiet`\n`--silent`\n`-q`\n     Do not print messages saying which checks are being made.\n\n`--srcdir=DIR`\n     Look for the package's source code in directory DIR.  Usually\n     `configure` can determine that directory automatically.\n\n`--version`\n     Print the version of Autoconf used to generate the `configure`\n     script, and exit.\n\n`configure` also accepts some other, not widely useful, options.\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 13.4580078125,
          "content": "#\n#    This source code is free software; you can redistribute it\n#    and/or modify it in source code form under the terms of the GNU\n#    Library General Public License as published by the Free Software\n#    Foundation; either version 2 of the License, or (at your option)\n#    any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU Library General Public License for more details.\n#\n#    You should have received a copy of the GNU Library General Public\n#    License along with this program; if not, write to the Free\n#    Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#    Boston, MA 02110-1301, USA.\n#\nSHELL = /bin/sh\n\n# The interesting make targets are:\n#\n#   make version\n#      Force the version_tag.h file to be rebuilt. Otherwise, it will only\n#      be built if it is missing.\n#\n#   make all\n#   make install\n#\n# The \"suffix\" is used as an installation suffix. It modifies certain\n# key install paths/files such that a build and install of Icarus Verilog\n# with the same $(prefix) but a different $(suffix) will not interfere.\n# The normal configuration leaves suffix empty\nsuffix = @install_suffix@\n\nprefix = @prefix@\nexec_prefix = @exec_prefix@\nsrcdir = @srcdir@\ndatarootdir = @datarootdir@\n\nSUBDIRS = ivlpp vhdlpp vvp vpi libveriuser cadpli tgt-null tgt-stub tgt-vvp \\\n          tgt-vhdl tgt-vlog95 tgt-pcb tgt-blif tgt-sizer driver\n# Only run distclean for these directories.\nNOTUSED = tgt-fpga tgt-pal tgt-verilog\n\nifeq (@MINGW32@,yes)\nSUBDIRS += driver-vpi\nelse\nNOTUSED += driver-vpi\nendif\n\n# To get the version headers to build correctly we only want to look\n# for C++ files in the source directory. All other files will require\n# an explicit $(srcdir). The one exception to this is if we need to\n# rebuild the lexor_keyword.cc file. If we do, then we want to use the\n# local version instead of the one is $(srcdir).\nvpath lexor_keyword.cc .\nvpath %.cc $(srcdir)/libmisc\nvpath %.cc $(srcdir)\n\nbindir = @bindir@\nlibdir = @libdir@\n# This is actually the directory where we install our own header files.\n# It is a little different from the generic includedir.\nincludedir = @includedir@/iverilog$(suffix)\nmandir = @mandir@\npdfdir = @docdir@\n\ndllib=@DLLIB@\n\n# For a cross compile these defines will need to be set accordingly.\nHOSTCC = @CC@\nHOSTCFLAGS = @WARNING_FLAGS@ @WARNING_FLAGS_CC@ @CFLAGS@\n\nBUILDCC = @CC_FOR_BUILD@\nBUILDEXT = @BUILD_EXEEXT@\nCXX = @CXX@\nDLLTOOL = @DLLTOOL@\nINSTALL = @INSTALL@\nINSTALL_SCRIPT = @INSTALL_SCRIPT@\nINSTALL_PROGRAM = @INSTALL_PROGRAM@\nINSTALL_DATA = @INSTALL_DATA@\nLEX = @LEX@\nYACC = @YACC@\nMAN = @MAN@\nPS2PDF = @PS2PDF@\nGIT = @GIT@\n\nifeq (@srcdir@,.)\nINCLUDE_PATH = -I. -Ilibmisc\nelse\nINCLUDE_PATH = -I. -I$(srcdir) -I$(srcdir)/libmisc\nendif\n\nCPPFLAGS = @DEFS@ $(INCLUDE_PATH) @CPPFLAGS@\nCFLAGS = @WARNING_FLAGS@ @WARNING_FLAGS_CC@ @CFLAGS@\nCXXFLAGS = @WARNING_FLAGS@ @WARNING_FLAGS_CXX@ @CXXFLAGS@\nPICFLAGS = @PICFLAG@\nLDFLAGS = @rdynamic@ @LDFLAGS@\nCTARGETFLAGS = @CTARGETFLAGS@\n\n# Source files in the libmisc directory\nM = LineInfo.o StringHeap.o\n\nTT = t-dll.o t-dll-api.o t-dll-expr.o t-dll-proc.o t-dll-analog.o\nFF = cprop.o exposenodes.o nodangle.o synth.o synth2.o syn-rules.o\n\nO = main.o async.o design_dump.o discipline.o dup_expr.o elaborate.o \\\n    elab_expr.o elaborate_analog.o elab_lval.o elab_net.o \\\n    elab_scope.o elab_sig.o elab_sig_analog.o elab_type.o \\\n    emit.o eval_attrib.o \\\n    eval_tree.o expr_synth.o functor.o lexor.o lexor_keyword.o link_const.o \\\n    load_module.o netlist.o netmisc.o nettypes.o net_analog.o net_assign.o \\\n    net_design.o netclass.o netdarray.o \\\n    netenum.o netparray.o netqueue.o netscalar.o netstruct.o netvector.o \\\n    net_event.o net_expr.o net_func.o \\\n    net_func_eval.o net_link.o net_modulo.o \\\n    net_nex_input.o net_nex_output.o net_proc.o net_scope.o net_tran.o \\\n    net_udp.o map_named_args.o \\\n    pad_to_width.o parse.o parse_misc.o pform.o pform_analog.o \\\n    pform_disciplines.o pform_dump.o pform_package.o pform_pclass.o \\\n    pform_types.o \\\n    symbol_search.o sync.o sys_funcs.o verinum.o verireal.o vpi_modules.o target.o \\\n    Attrib.o HName.o Module.o PClass.o PDelays.o PEvent.o PExpr.o PFunction.o \\\n    PGate.o PGenerate.o PModport.o PNamedItem.o PPackage.o PScope.o PSpec.o PTimingCheck.o \\\n    PTask.o PUdp.o PWire.o Statement.o AStatement.o $M $(FF) $(TT)\n\nall: dep config.h _pli_types.h version_tag.h ivl@EXEEXT@ version.exe iverilog-vpi.man\n\t$(foreach dir,$(SUBDIRS),$(MAKE) -C $(dir) $@ && ) true\n\n# In the windows world, the installer will need a dosify program to\n# dosify text files.\nifeq (@MINGW32@,yes)\nall: dosify$(BUILDEXT)\ndosify$(BUILDEXT): $(srcdir)/dosify.c\n\t$(BUILDCC) $(CFLAGS) -o dosify$(BUILDEXT) $(srcdir)/dosify.c\nendif\n\n# This rule rules the compiler in the trivial hello.vl program to make\n# sure the basics were compiled properly.\ncheck: all\n\t$(foreach dir,$(SUBDIRS),$(MAKE) -C $(dir) $@ && ) true\n\ttest -r check.conf || cp $(srcdir)/check.conf .\n\tdriver/iverilog -B. -BMvpi -BPivlpp -tcheck -ocheck.vvp $(srcdir)/examples/hello.vl\nifeq (@WIN32@,yes)\nifeq (@install_suffix@,)\n\tvvp/vvp -M- -M./vpi ./check.vvp | grep 'Hello, World'\nelse\n\t# On Windows if we have a suffix we must run the vvp part of\n\t# the test with a suffix since it was built/linked that way.\n\tln vvp/vvp.exe vvp/vvp$(suffix).exe\n\tvvp/vvp$(suffix) -M- -M./vpi ./check.vvp | grep 'Hello, World'\n\trm vvp/vvp$(suffix).exe\nendif\nelse\n\tvvp/vvp -M- -M./vpi ./check.vvp | grep 'Hello, World'\nendif\n\nclean:\n\t$(foreach dir,$(SUBDIRS),$(MAKE) -C $(dir) $@ && ) true\n\trm -f *.o parse.cc parse.h lexor.cc\n\trm -f ivl.exp iverilog-vpi.man iverilog-vpi.pdf iverilog-vpi.ps\n\trm -f parse.output syn-rules.output dosify$(BUILDEXT) ivl@EXEEXT@ check.vvp\n\trm -f lexor_keyword.cc libivl.a libvpi.a iverilog-vpi syn-rules.cc\n\trm -rf dep\n\trm -f version.exe\n\ndistclean: clean\n\t$(foreach dir,$(SUBDIRS),$(MAKE) -C $(dir) $@ && ) true\n\t$(foreach dir,$(NOTUSED),$(MAKE) -C $(dir) $@ && ) true\n\trm -f Makefile config.status config.log config.cache\n\trm -f stamp-config-h config.h\n\trm -f stamp-_pli_types-h _pli_types.h\nifneq (@srcdir@,.)\n\trm -f version_tag.h check.conf\n\trmdir $(SUBDIRS) $(NOTUSED)\nendif\n\trm -rf autom4te.cache\n\ncppcheck: $(O:.o=.cc) $(srcdir)/dosify.c $(srcdir)/version.c\n\tcppcheck --enable=all --std=c99 --std=c++11 -f \\\n\t         --suppressions-list=$(srcdir)/cppcheck.sup \\\n\t         -UYYPARSE_PARAM -UYYPRINT -Ushort -Usize_t -Uyyoverflow \\\n\t         -UYYTYPE_INT8 -UYYTYPE_INT16 -UYYTYPE_UINT8 -UYYTYPE_UINT16 \\\n\t         -UYYSTYPE -U__SIZE_TYPE__ -Umalloc -Ufree  \\\n\t         --relative-paths=$(srcdir) $(INCLUDE_PATH) $^\n\ncppcheck-all:\n\t$(foreach dir,$(SUBDIRS),$(MAKE) -C $(dir) cppcheck && ) true\n\t$(foreach dir,$(NOTUSED),$(MAKE) -C $(dir) cppcheck && ) true\n\t$(MAKE) cppcheck\n\nMakefile: $(srcdir)/Makefile.in config.status\n\t./config.status --file=$@\n\ndep:\n\tmkdir dep\n\nstamp-config-h: $(srcdir)/config.h.in config.status\n\t@rm -f $@\n\t./config.status config.h\nconfig.h: stamp-config-h\n\nstamp-_pli_types-h: $(srcdir)/_pli_types.h.in config.status\n\t@rm -f $@\n\t./config.status _pli_types.h\n_pli_types.h: stamp-_pli_types-h\n\n$(srcdir)/configure: $(srcdir)/configure.ac $(srcdir)/aclocal.m4\n\tcd $(srcdir) && autoconf\n\nconfig.status: $(srcdir)/configure\n\t./config.status --recheck\n\t./config.status\n\nifeq (@WIN32@,yes)\n# Under Windows (mingw) I need to make the ivl.exe in two steps.\n# The first step makes an ivl.exe that dlltool can use to make an\n# export and import library, and the last link makes a, ivl.exe\n# that really exports the things that the import library imports.\nivl@EXEEXT@: $O $(srcdir)/ivl.def\n\t$(CXX) -o ivl@EXEEXT@ $O $(dllib) @EXTRALIBS@\n\t$(DLLTOOL) --dllname ivl@EXEEXT@ --def $(srcdir)/ivl.def \\\n\t\t--output-lib libivl.a --output-exp ivl.exp\n\t$(CXX) $(LDFLAGS) -o ivl@EXEEXT@ ivl.exp $O $(dllib) @EXTRALIBS@\nelse\nivl@EXEEXT@: $O\n\t$(CXX) $(LDFLAGS) -o ivl@EXEEXT@ $O $(dllib)\nendif\n\nifeq (@MINGW32@,no)\nall: iverilog-vpi\n\niverilog-vpi: $(srcdir)/iverilog-vpi.sh Makefile\n\tsed -e 's;@SHARED@;@shared@;' -e 's;@PIC@;@PICFLAG@;' \\\n\t    -e 's;@SUFFIX@;$(suffix);' \\\n\t    -e 's;@IVCC@;$(CC);' \\\n\t    -e 's;@IVCXX@;$(CXX);' \\\n\t    -e 's;@IVCFLAGS@;$(CFLAGS);' \\\n\t    -e 's;@IVCXXFLAGS@;$(CXXFLAGS);' \\\n\t    -e 's;@IVCTARGETFLAGS@;$(CTARGETFLAGS);' \\\n\t    -e 's;@INCLUDEDIR@;$(includedir);' \\\n\t    -e 's;@LIBDIR@;@libdir@;' $< > $@\n\tchmod +x $@\nendif\n\nversion.exe: $(srcdir)/version.c $(srcdir)/version_base.h version_tag.h\n\t$(BUILDCC) $(CFLAGS) -o version.exe -I. -I$(srcdir) $(srcdir)/version.c\n\n%.o: %.cc config.h\n\t$(CXX) $(CPPFLAGS) $(CXXFLAGS) @DEPENDENCY_FLAG@ -c $< -o $*.o\n\tmv $*.d dep/$*.d\n\n# Here are some explicit dependencies needed to get things going.\nmain.o: main.cc version_tag.h\n\nlexor.o: lexor.cc parse.h\n\nparse.o: parse.cc\n\n# Use pattern rules to avoid parallel build issues (see pr3462585)\nparse%cc parse%h: $(srcdir)/parse%y\n\t$(YACC) --verbose -t -p VL --defines=parse.h -o parse.cc $<\n\nsyn-rules.cc: $(srcdir)/syn-rules.y\n\t$(YACC) --verbose -t -p syn_ -o $@ $<\n\nlexor.cc: $(srcdir)/lexor.lex\n\t$(LEX) -s -t $< > $@\n\nlexor_keyword.o: lexor_keyword.cc parse.h\n\nlexor_keyword.cc: $(srcdir)/lexor_keyword.gperf\n\tgperf -o -i 7 -C -k 1-4,6,9,$$ -H keyword_hash -N check_identifier -t $(srcdir)/lexor_keyword.gperf > lexor_keyword.cc || (rm -f lexor_keyword.cc ; false)\n\niverilog-vpi.man: $(srcdir)/iverilog-vpi.man.in version.exe\n\t./version.exe `head -1 $(srcdir)/iverilog-vpi.man.in`'\\n' > $@\n\ttail -n +2 $(srcdir)/iverilog-vpi.man.in >> $@\n\niverilog-vpi.ps: iverilog-vpi.man\n\t$(MAN) -t ./iverilog-vpi.man > iverilog-vpi.ps\n\niverilog-vpi.pdf: iverilog-vpi.ps\n\t$(PS2PDF) iverilog-vpi.ps iverilog-vpi.pdf\n\n# For VERSION_TAG in driver/main.c, first try git-describe, then look for a\n# release_tag.h file in the source tree (included in snapshots and releases),\n# and finally use nothing.\n\n# \"true\" and \"false\" in the next few lines are Unix shell command names\nifeq ($(GIT),none)\nGIT_PRESENT = false\nelse\nGIT_PRESENT = true\nendif\nversion_tag.h version:\n\t@if $(GIT_PRESENT) && test -d $(srcdir)/.git; then \\\n\t    echo \"Using git-describe for VERSION_TAG\"; \\\n\t    tmp=`(cd $(srcdir) && $(GIT) describe --always --dirty) \\\n\t\t   | sed -e 's;\\(.*\\);#define VERSION_TAG \"\\1\";'`; \\\n\t    echo \"$$tmp\" | diff - version_tag.h > /dev/null 2>&1 || echo \"$$tmp\" > version_tag.h || exit 1; \\\n\telif test -r $(srcdir)/release_tag.h; then \\\n\t    echo \"Using $(srcdir)/release_tag.h for VERSION_TAG\"; \\\n\t    diff $(srcdir)/release_tag.h version_tag.h > /dev/null 2>&1 || cp $(srcdir)/release_tag.h version_tag.h; \\\n\telse \\\n\t    echo \"Using empty VERSION_TAG\"; \\\n\t    echo '#define VERSION_TAG \"\"' > version_tag.h; \\\n\tfi\n\nifeq (@MINGW32@,yes)\nifeq ($(MAN),none)\nINSTALL_DOC = installman\nINSTALL_PDFDIR = $(prefix)\nelse\nifeq ($(PS2PDF),none)\nINSTALL_DOC = installman\nINSTALL_PDFDIR = $(prefix)\nelse\nINSTALL_DOC = installpdf installman\nINSTALL_PDFDIR = $(pdfdir)\nall: dep iverilog-vpi.pdf\nendif\nendif\nINSTALL_DOCDIR = $(mandir)/man1\nelse\nINSTALL_DOC = installman\nINSTALL_DOCDIR = $(mandir)/man1\nINSTALL_PDFDIR = $(prefix)\nendif\n\nifeq (@MINGW32@,yes)\nWIN32_INSTALL =\nelse\nWIN32_INSTALL = installwin32\nendif\n\ninstall: all installdirs installfiles\n\t$(foreach dir,$(SUBDIRS),$(MAKE) -C $(dir) $@ && ) true\n\nF = ./ivl@EXEEXT@ \\\n\t$(srcdir)/constants.vams \\\n\t$(srcdir)/disciplines.vams \\\n\t$(srcdir)/ivl_target.h \\\n\t./_pli_types.h \\\n\t$(srcdir)/sv_vpi_user.h \\\n\t$(srcdir)/vpi_user.h \\\n\t$(srcdir)/acc_user.h \\\n\t$(srcdir)/veriuser.h \\\n\t$(INSTALL_DOC) \\\n\t$(WIN32_INSTALL)\n\ninstallwin32: ./iverilog-vpi installdirs\n\t$(INSTALL_SCRIPT) ./iverilog-vpi \"$(DESTDIR)$(bindir)/iverilog-vpi$(suffix)\"\n\ninstallman: iverilog-vpi.man installdirs\n\t$(INSTALL_DATA) iverilog-vpi.man \"$(DESTDIR)$(mandir)/man1/iverilog-vpi$(suffix).1\"\n\ninstallpdf: iverilog-vpi.pdf installdirs\n\t$(INSTALL_DATA) iverilog-vpi.pdf \"$(DESTDIR)$(pdfdir)/iverilog-vpi$(suffix).pdf\"\n\ninstallfiles: $(F) | installdirs\n\t$(INSTALL_PROGRAM) ./ivl@EXEEXT@ \"$(DESTDIR)$(libdir)/ivl$(suffix)/ivl@EXEEXT@\"\n\t$(INSTALL_DATA) $(srcdir)/constants.vams \"$(DESTDIR)$(libdir)/ivl$(suffix)/include/constants.vams\"\n\t$(INSTALL_DATA) $(srcdir)/disciplines.vams \"$(DESTDIR)$(libdir)/ivl$(suffix)/include/disciplines.vams\"\n\t$(INSTALL_DATA) $(srcdir)/ivl_target.h \"$(DESTDIR)$(includedir)/ivl_target.h\"\n\t$(INSTALL_DATA) ./_pli_types.h \"$(DESTDIR)$(includedir)/_pli_types.h\"\n\t$(INSTALL_DATA) $(srcdir)/sv_vpi_user.h \"$(DESTDIR)$(includedir)/sv_vpi_user.h\"\n\t$(INSTALL_DATA) $(srcdir)/vpi_user.h \"$(DESTDIR)$(includedir)/vpi_user.h\"\n\t$(INSTALL_DATA) $(srcdir)/acc_user.h \"$(DESTDIR)$(includedir)/acc_user.h\"\n\t$(INSTALL_DATA) $(srcdir)/veriuser.h \"$(DESTDIR)$(includedir)/veriuser.h\"\n\ninstalldirs: $(srcdir)/mkinstalldirs\n\t$(srcdir)/mkinstalldirs \"$(DESTDIR)$(bindir)\" \\\n\t    \"$(DESTDIR)$(includedir)\" \\\n\t    \"$(DESTDIR)$(libdir)/ivl$(suffix)\" \\\n\t    \"$(DESTDIR)$(libdir)/ivl$(suffix)/include\" \\\n\t    \"$(DESTDIR)$(INSTALL_DOCDIR)\" \\\n\t    \"$(DESTDIR)$(INSTALL_PDFDIR)\"\n\nuninstall:\n\t$(foreach dir,$(SUBDIRS),$(MAKE) -C $(dir) $@ && ) true\n\tfor f in ivl@EXEEXT@ include/constants.vams include/disciplines.vams; \\\n\t    do rm -f \"$(DESTDIR)$(libdir)/ivl$(suffix)/$$f\"; done\n\t-rmdir \"$(DESTDIR)$(libdir)/ivl$(suffix)/include\"\n\t-rmdir \"$(DESTDIR)$(libdir)/ivl$(suffix)\"\n\tfor f in verilog$(suffix) iverilog-vpi$(suffix) gverilog$(suffix)@EXEEXT@; \\\n\t    do rm -f \"$(DESTDIR)$(bindir)/$$f\"; done\n\tfor f in ivl_target.h vpi_user.h _pli_types.h sv_vpi_user.h acc_user.h veriuser.h; \\\n\t    do rm -f \"$(DESTDIR)$(includedir)/$$f\"; done\n\t-test X$(suffix) = X || rmdir \"$(DESTDIR)$(includedir)\"\n\trm -f \"$(DESTDIR)$(mandir)/man1/iverilog-vpi$(suffix).1\" \\\n\t      \"$(DESTDIR)$(pdfdir)/iverilog-vpi$(suffix).pdf\"\n\n\n-include $(patsubst %.o, dep/%.d, $O)\n"
        },
        {
          "name": "Module.cc",
          "type": "blob",
          "size": 4.0341796875,
          "content": "/*\n * Copyright (c) 1998-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"Module.h\"\n# include  \"PGate.h\"\n# include  \"PWire.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nlist<Module::named_expr_t> Module::user_defparms;\n\n/* n is a permallocated string. */\nModule::Module(LexicalScope*parent, perm_string n)\n: PScopeExtra(n, parent)\n{\n      library_flag = false;\n      is_cell = false;\n      is_interface = false;\n      program_block = false;\n      uc_drive = UCD_NONE;\n}\n\nModule::~Module()\n{\n}\n\nvoid Module::add_gate(PGate*gate)\n{\n      gates_.push_back(gate);\n}\n\nunsigned Module::port_count() const\n{\n      return ports.size();\n}\n\n/*\n * Return the array of PEIdent object that are at this port of the\n * module. If the port is internally unconnected, return an empty\n * array.\n */\nconst vector<PEIdent*>& Module::get_port(unsigned idx) const\n{\n      ivl_assert(*this, idx < ports.size());\n      static const vector<PEIdent*> zero;\n\n      if (ports[idx])\n\t    return ports[idx]->expr;\n      else\n\t    return zero;\n}\n\nunsigned Module::find_port(const char*name) const\n{\n      ivl_assert(*this, name != 0);\n      for (unsigned idx = 0 ;  idx < ports.size() ;  idx += 1) {\n\t    if (ports[idx] == 0) {\n\t\t    /* It is possible to have undeclared ports. These\n\t\t       are ports that are skipped in the declaration,\n\t\t       for example like so: module foo(x ,, y); The\n\t\t       port between x and y is unnamed and thus\n\t\t       inaccessible to binding by name. */\n\t\t  continue;\n\t    }\n\t    ivl_assert(*this, ports[idx]);\n\t    if (ports[idx]->name == name)\n\t\t  return idx;\n      }\n\n      return ports.size();\n}\n\nperm_string Module::get_port_name(unsigned idx) const\n{\n\n      ivl_assert(*this, idx < ports.size());\n      if (ports[idx] == 0 || ports[idx]->name.str() == 0) {\n              /* It is possible to have undeclared ports. These\n                 are ports that are skipped in the declaration,\n                 for example like so: module foo(x ,, y); The\n                 port between x and y is unnamed and thus\n                 inaccessible to binding by name. Port references\n\t\t that aren't simple or escaped identifiers are\n\t\t also inaccessible to binding by name. */\n            return perm_string::literal(\"unnamed\");\n      }\n      return ports[idx]->name;\n}\n\nPExpr* Module::get_port_default_value(unsigned idx) const\n{\n      ivl_assert(*this, idx < ports.size());\n      return ports[idx] ? ports[idx]->default_value : 0;\n}\n\n\nPGate* Module::get_gate(perm_string name)\n{\n      for (list<PGate*>::iterator cur = gates_.begin()\n\t\t ; cur != gates_.end() ; ++ cur ) {\n\n\t    if ((*cur)->get_name() == name)\n\t\t  return *cur;\n      }\n\n      return 0;\n}\n\nconst list<PGate*>& Module::get_gates() const\n{\n      return gates_;\n}\n\nPNamedItem::SymbolType Module::symbol_type() const\n{\n      if (program_block)\n            return PROGRAM;\n      if (is_interface)\n            return INTERFACE;\n\n      return MODULE;\n}\n\nbool Module::can_be_toplevel() const\n{\n      // Don't choose library modules.\n      if (library_flag)\n\t    return false;\n\n      // Don't choose modules with parameters without default value\n      for (std::map<perm_string,param_expr_t*>::const_iterator cur =\n\t    parameters.begin(); cur != parameters.end(); ++cur) {\n\t    if (cur->second->expr == 0)\n\t\t  return false;\n      }\n\n      return true;\n}\n"
        },
        {
          "name": "Module.h",
          "type": "blob",
          "size": 6.1064453125,
          "content": "#ifndef IVL_Module_H\n#define IVL_Module_H\n/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n\n# include  <list>\n# include  <map>\n# include  <vector>\n# include  <utility>\n# include  \"StringHeap.h\"\n# include  \"HName.h\"\n# include  \"named.h\"\n# include  \"PScope.h\"\n# include  \"PNamedItem.h\"\n# include  \"netlist.h\"\n# include  \"pform_types.h\"\nclass PExpr;\nclass PEIdent;\nclass PGate;\nclass PGenerate;\nclass PModport;\nclass PSpecPath;\nclass PTimingCheck;\nclass PTask;\nclass PFunction;\nclass PWire;\nclass PProcess;\nclass Design;\nclass NetScope;\n\n/*\n * A module is a named container and scope. A module holds a bunch of\n * semantic quantities such as wires and gates. The module is\n * therefore the handle for grasping the described circuit.\n *\n * SystemVerilog introduces program blocks and interfaces. These have\n * much in common with modules, so the Module class is used to represent\n * these containers as well.\n */\n\nclass Module : public PScopeExtra, public PNamedItem {\n\n\t/* The module ports are in general a vector of port_t\n\t   objects. Each port has a name and an ordered list of\n\t   wires. The name is the means that the outside uses to\n\t   access the port, the wires are the internal connections to\n\t   the port. In SystemVerilog, input ports may also have a\n\t   default value. */\n    public:\n      struct port_t {\n\t    perm_string name;\n\t    std::vector<PEIdent*> expr;\n\t    PExpr*default_value;\n      };\n\n    public:\n\t/* The name passed here is the module name, not the instance\n\t   name. This name must be a permallocated string. */\n      explicit Module(LexicalScope*parent, perm_string name);\n      ~Module();\n\n\t/* Initially false. This is set to true if the module has been\n\t   declared as a library module. This makes the module\n\t   ineligible for being chosen as an implicit root. It has no\n\t   other effect. */\n      bool library_flag;\n\n      bool is_cell;\n\n\t/* This is true if the module represents a program block\n\t   instead of a module/cell. Program blocks have content\n\t   restrictions and slightly modify scheduling semantics. */\n      bool program_block;\n\n\t/* This is true if the module represents a interface\n\t   instead of a module/cell. Interfaces have different\n\t   content restrictions and some extra allowed items. */\n      bool is_interface;\n\n      enum UCDriveType { UCD_NONE, UCD_PULL0, UCD_PULL1 };\n      UCDriveType uc_drive;\n\n\t/* specparams are simpler than other parameters, in that they\n\t   can have a range, but not an explicit type. The restrictions\n\t   are enforced by the parser. */\n      std::map<perm_string,param_expr_t*>specparams;\n\n\t/* The module also has defparam assignments which don't create\n\t   new parameters within the module, but may be used to set\n\t   values within this module (when instantiated) or in other\n\t   instantiated modules. */\n      typedef std::pair<pform_name_t,PExpr*> named_expr_t;\n      std::list<named_expr_t>defparms;\n      static std::list<named_expr_t>user_defparms;\n\n        /* Parameters may be overridden at instantiation time;\n           the overrides do not contain explicit parameter names,\n           but rather refer to parameters in the order they\n           appear in the instantiated module.  Therefore a\n           list of names in module-order is needed to pass from\n           a parameter-index to its name. */\n      std::list<perm_string> param_names;\n\n\t/* This is an array of port descriptors, which is in turn a\n\t   named array of PEident pointers. */\n      std::vector<port_t*> ports;\n\n      std::map<perm_string,PExpr*> attributes;\n\n\t/* The module has a list of generate schemes that appear in\n\t   the module definition. These are used at elaboration time. */\n      std::list<PGenerate*> generate_schemes;\n\n\t/* Nested modules are placed here, and are not elaborated\n\t   unless they are instantiated, implicitly or explicitly. */\n      std::map<perm_string,Module*> nested_modules;\n\n\t/* An interface can contain one or more named modport lists.\n           The parser will ensure these don't appear in modules or\n           program blocks. */\n      std::map<perm_string,PModport*> modports;\n\n\t/* List for specify paths and timing checks */\n      std::list<PSpecPath*> specify_paths;\n      std::list<PTimingCheck*> timing_checks;\n\n\t// The mod_name() is the name of the module type.\n      perm_string mod_name() const { return pscope_name(); }\n\n      void add_gate(PGate*gate);\n\n      unsigned port_count() const;\n      const std::vector<PEIdent*>& get_port(unsigned idx) const;\n      unsigned find_port(const char*name) const;\n\n      // Return port name (\"\" for undeclared port)\n      perm_string get_port_name(unsigned idx) const;\n\n      PExpr* get_port_default_value(unsigned idx) const;\n\n      PGate* get_gate(perm_string name);\n\n      const std::list<PGate*>& get_gates() const;\n\n      void dump(std::ostream&out) const;\n      bool elaborate(Design*, NetScope*scope) const;\n\n      typedef std::map<perm_string,PExpr*> replace_t;\n      bool elaborate_scope(Design*, NetScope*scope, const replace_t&rep);\n\n      bool elaborate_sig(Design*, NetScope*scope) const;\n\n      SymbolType symbol_type() const;\n\n      bool can_be_toplevel() const;\n\n    private:\n      void dump_specparams_(std::ostream&out, unsigned indent) const;\n      void dump_timingchecks_(std::ostream&out, unsigned indent) const;\n      std::list<PGate*> gates_;\n\n    private: // Not implemented\n      Module(const Module&);\n      Module& operator= (const Module&);\n};\n\n#endif /* IVL_Module_H */\n"
        },
        {
          "name": "PClass.cc",
          "type": "blob",
          "size": 1.0478515625,
          "content": "/*\n * Copyright (c) 2012-2019 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PClass.h\"\n\nPClass::PClass(perm_string name, LexicalScope*parent)\n: PScopeExtra(name, parent), type(0)\n{\n}\n\n\nPClass::~PClass()\n{\n}\n\nPNamedItem::SymbolType PClass::symbol_type() const\n{\n      return CLASS;\n}\n"
        },
        {
          "name": "PClass.h",
          "type": "blob",
          "size": 1.4521484375,
          "content": "#ifndef IVL_PClass_H\n#define IVL_PClass_H\n/*\n * Copyright (c) 2012-2019 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PScope.h\"\n# include  \"PNamedItem.h\"\n# include  \"StringHeap.h\"\n# include  <iostream>\n\nclass PChainConstructor;\n\n/*\n * SystemVerilog supports class declarations with their own lexical\n * scope, etc. The parser arranges for these to be created and\n * collected.\n */\n\nclass PClass : public PScopeExtra, public PNamedItem {\n\n    public:\n      explicit PClass (perm_string name, LexicalScope*parent);\n      ~PClass();\n\n      void dump(std::ostream&out, unsigned indent) const;\n\n      SymbolType symbol_type() const;\n\n    public:\n      class_type_t*type;\n};\n\n#endif /* IVL_PClass_H */\n"
        },
        {
          "name": "PDelays.cc",
          "type": "blob",
          "size": 4.6240234375,
          "content": "/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  \"PDelays.h\"\n# include  \"PExpr.h\"\n# include  \"verinum.h\"\n# include  \"netmisc.h\"\n\nusing namespace std;\n\nPDelays::PDelays()\n{\n      delete_flag_ = true;\n      for (unsigned idx = 0 ;  idx < 3 ;  idx += 1)\n\t    delay_[idx] = 0;\n}\n\nPDelays::~PDelays()\n{\n      if (delete_flag_) {\n\t    for (unsigned idx = 0 ;  idx < 3 ;  idx += 1)\n\t\t  delete delay_[idx];\n      }\n}\n\nvoid PDelays::set_delay(PExpr*del)\n{\n      assert(del);\n      assert(delay_[0] == 0);\n      delay_[0] = del;\n      delete_flag_ = true;\n}\n\n\nvoid PDelays::set_delays(const list<PExpr*>*del, bool df)\n{\n      assert(del);\n      assert(del->size() <= 3);\n\n      list<PExpr*>::const_iterator cur = del->begin();\n      for (unsigned idx = 0 ;  cur != del->end() ;  idx += 1, ++cur)\n\t    delay_[idx] = *cur;\n\n      delete_flag_ = df;\n}\n\nunsigned PDelays::delay_count() const\n{\n      unsigned dly_cnt = 0;\n      for (unsigned idx = 0 ;  idx < 3 ;  idx += 1)\n\t    if (delay_[idx]) dly_cnt += 1;\n\n      return dly_cnt;\n}\n\nstatic NetExpr*calculate_val(Design*des, NetScope*scope, PExpr*expr)\n{\n      NetExpr*dex = elab_and_eval(des, scope, expr, -1);\n\n      check_for_inconsistent_delays(scope);\n\n\t/* If the delay expression is a real constant or vector\n\t   constant, then evaluate it, scale it to the local time\n\t   units, and return an adjusted value. */\n\n      if (NetECReal*tmp = dynamic_cast<NetECReal*>(dex)) {\n\t    uint64_t delay = get_scaled_time_from_real(des, scope, tmp);\n\n\t    delete tmp;\n\t    NetEConst*tmp2 = new NetEConst(verinum(delay, 64));\n\t    tmp2->set_line(*expr);\n\t    return tmp2;\n      }\n\n\n      if (NetEConst*tmp = dynamic_cast<NetEConst*>(dex)) {\n\t    verinum fn = tmp->value();\n\t    uint64_t delay = des->scale_to_precision(fn.as_ulong64(), scope);\n\n\t    delete tmp;\n\t    NetEConst*tmp2 = new NetEConst(verinum(delay, 64));\n\t    tmp2->set_line(*expr);\n\t    return tmp2;\n      }\n\n\t/* Oops, cannot evaluate down to a constant. */\n      return dex;\n}\n\nstatic NetExpr* make_delay_nets(Design*des, NetScope*scope, NetExpr*expr)\n{\n      if (expr == 0)\n            return 0;\n\n      if (dynamic_cast<NetESignal*> (expr))\n\t    return expr;\n\n      if (dynamic_cast<NetEConst*> (expr))\n\t    return expr;\n\n      NetNet*sig = expr->synthesize(des, scope, expr);\n      if (sig == 0) {\n\t    cerr << expr->get_fileline() << \": error: Expression \" << *expr\n\t\t << \" is not suitable as a delay expression.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      expr = new NetESignal(sig);\n      return expr;\n}\n\nstatic NetExpr* calc_decay_time(NetExpr *rise, NetExpr *fall)\n{\n      NetEConst *c_rise = dynamic_cast<NetEConst*>(rise);\n      NetEConst *c_fall = dynamic_cast<NetEConst*>(fall);\n      if (c_rise && c_fall) {\n\t    if (c_rise->value() < c_fall->value()) return rise;\n\t    else return fall;\n      }\n\n      return 0;\n}\n\nvoid PDelays::eval_delays(Design*des, NetScope*scope,\n\t\t\t  NetExpr*&rise_time,\n\t\t\t  NetExpr*&fall_time,\n\t\t\t  NetExpr*&decay_time,\n\t\t\t  bool as_nets_flag) const\n{\n      assert(scope);\n\n\n      if (delay_[0]) {\n\t    rise_time = calculate_val(des, scope, delay_[0]);\n\t    if (as_nets_flag)\n\t\t  rise_time = make_delay_nets(des, scope, rise_time);\n\n\t    if (delay_[1]) {\n\t\t  fall_time = calculate_val(des, scope, delay_[1]);\n\t\t  if (as_nets_flag)\n\t\t\tfall_time = make_delay_nets(des, scope, fall_time);\n\n\t\t  if (delay_[2]) {\n\t\t\tdecay_time = calculate_val(des, scope, delay_[2]);\n\t\t\tif (as_nets_flag)\n\t\t\t      decay_time = make_delay_nets(des, scope,\n\t\t\t                                   decay_time);\n\n\t\t  } else {\n\t\t\t// If this is zero then we need to do the min()\n\t\t\t// at run time.\n\t\t\tdecay_time = calc_decay_time(rise_time, fall_time);\n\t\t  }\n\t    } else {\n\t\t  assert(delay_[2] == 0);\n\t\t  fall_time = rise_time;\n\t\t  decay_time = rise_time;\n\t    }\n      } else {\n\t    rise_time = 0;\n\t    fall_time = 0;\n\t    decay_time = 0;\n      }\n}\n"
        },
        {
          "name": "PDelays.h",
          "type": "blob",
          "size": 1.9765625,
          "content": "#ifndef IVL_PDelays_H\n#define IVL_PDelays_H\n/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <string>\n# include  <list>\n# include  <iostream>\n\nclass Design;\nclass NetScope;\nclass NetExpr;\nclass PExpr;\n\n/*\n * Various PForm objects can carry delays. These delays include rise,\n * fall and decay times. This class arranges to carry the triplet.\n */\nclass PDelays {\n\n    public:\n      PDelays();\n      ~PDelays();\n\n\t/* Set the delay expressions. If the delete_flag is true, then\n\t   this object takes ownership of the expressions, and will\n\t   delete it in the destructor. */\n      void set_delay(PExpr*);\n      void set_delays(const std::list<PExpr*>*del, bool delete_flag=true);\n\n      unsigned delay_count() const;\n\n      void eval_delays(Design*des, NetScope*scope,\n\t\t       NetExpr*&rise_time,\n\t\t       NetExpr*&fall_time,\n\t\t       NetExpr*&decay_time,\n\t\t       bool as_nets_flag =false) const;\n\n      void dump_delays(std::ostream&out) const;\n\n    private:\n      PExpr* delay_[3];\n      bool delete_flag_;\n\n    private: // not implemented\n      PDelays(const PDelays&);\n      PDelays& operator= (const PDelays&);\n};\n\nstd::ostream& operator << (std::ostream&o, const PDelays&);\n\n#endif /* IVL_PDelays_H */\n"
        },
        {
          "name": "PEvent.cc",
          "type": "blob",
          "size": 1.125,
          "content": "/*\n * Copyright (c) 2004-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"PEvent.h\"\n\nPEvent::PEvent(perm_string n, unsigned lexical_pos)\n: name_(n), lexical_pos_(lexical_pos)\n{\n}\n\nPEvent::~PEvent()\n{\n}\n\nperm_string  PEvent::name() const\n{\n      return name_;\n}\n\nPNamedItem::SymbolType PEvent::symbol_type() const\n{\n      return EVENT;\n}\n"
        },
        {
          "name": "PEvent.h",
          "type": "blob",
          "size": 1.779296875,
          "content": "#ifndef IVL_PEvent_H\n#define IVL_PEvent_H\n/*\n * Copyright (c) 2000-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PNamedItem.h\"\n# include  \"StringHeap.h\"\n# include  <string>\n\nclass Design;\nclass NetScope;\n\n/*\n * The PEvent class represents event objects. These are things that\n * are declared in Verilog as ``event foo;'' The name passed to the\n * constructor is the \"foo\" part of the declaration.\n */\nclass PEvent : public PNamedItem {\n\n    public:\n\t// The name is a perm-allocated string. It is the simple name\n\t// of the event, without any scope.\n      explicit PEvent(perm_string name, unsigned lexical_pos);\n      ~PEvent();\n\n      perm_string name() const;\n\n      unsigned lexical_pos() const { return lexical_pos_; }\n\n      void elaborate_scope(Design*des, NetScope*scope) const;\n\n      SymbolType symbol_type() const;\n\n    private:\n      perm_string name_;\n      unsigned lexical_pos_;\n\n    private: // not implemented\n      PEvent(const PEvent&);\n      PEvent& operator= (const PEvent&);\n};\n\n#endif /* IVL_PEvent_H */\n"
        },
        {
          "name": "PExpr.cc",
          "type": "blob",
          "size": 12.5146484375,
          "content": "/*\n * Copyright (c) 1998-2024 Stephen Williams <steve@icarus.com>\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  \"compiler.h\"\n# include  \"PExpr.h\"\n# include  \"PWire.h\"\n# include  \"Module.h\"\n# include  \"ivl_assert.h\"\n# include  \"netmisc.h\"\n# include  \"util.h\"\n# include  <typeinfo>\n\nusing namespace std;\n\nPExpr::PExpr()\n: expr_type_(IVL_VT_NO_TYPE)\n{\n      expr_width_  = 0;\n      min_width_   = 0;\n      signed_flag_ = false;\n}\n\nPExpr::~PExpr()\n{\n}\n\nvoid PExpr::declare_implicit_nets(LexicalScope*, NetNet::Type)\n{\n}\n\nbool PExpr::has_aa_term(Design*, NetScope*) const\n{\n      return false;\n}\n\nNetNet* PExpr::elaborate_lnet(Design*, NetScope*) const\n{\n      cerr << get_fileline() << \": error: \"\n           << \"expression not valid in assign l-value: \"\n           << *this << endl;\n      return 0;\n}\n\nNetNet* PExpr::elaborate_bi_net(Design*, NetScope*) const\n{\n      cerr << get_fileline() << \": error: \"\n           << \"expression not valid as argument to inout port: \"\n           << *this << endl;\n      return 0;\n}\n\nbool PExpr::is_collapsible_net(Design*, NetScope*, NetNet::PortType) const\n{\n      return false;\n}\n\n\nconst char* PExpr::width_mode_name(width_mode_t mode)\n{\n      switch (mode) {\n          case PExpr::SIZED:\n            return \"sized\";\n          case PExpr::UNSIZED:\n            return \"unsized\";\n          case PExpr::EXPAND:\n            return \"expand\";\n          case PExpr::LOSSLESS:\n            return \"lossless\";\n          case PExpr::UPSIZE:\n            return \"upsize\";\n          default:\n            return \"??\";\n      }\n}\n\nPEAssignPattern::PEAssignPattern()\n{\n}\n\nPEAssignPattern::PEAssignPattern(const list<PExpr*>&p)\n: parms_(p.begin(), p.end())\n{\n}\n\nPEAssignPattern::~PEAssignPattern()\n{\n}\n\nPEBinary::PEBinary(char op, PExpr*l, PExpr*r)\n: op_(op), left_(l), right_(r)\n{\n}\n\nPEBinary::~PEBinary()\n{\n}\n\nvoid PEBinary::declare_implicit_nets(LexicalScope*scope, NetNet::Type type)\n{\n      if (left_) left_->declare_implicit_nets(scope, type);\n      if (right_) right_->declare_implicit_nets(scope, type);\n}\n\nbool PEBinary::has_aa_term(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, left_ && right_);\n      return left_->has_aa_term(des, scope) || right_->has_aa_term(des, scope);\n}\n\nPECastSize::PECastSize(PExpr*si, PExpr*b)\n: size_(si), base_(b)\n{\n}\n\nPECastSize::~PECastSize()\n{\n}\n\nbool PECastSize::has_aa_term(Design *des, NetScope *scope) const\n{\n\treturn base_->has_aa_term(des, scope);\n}\n\nPECastType::PECastType(data_type_t*t, PExpr*b)\n: target_(t), base_(b)\n{\n}\n\nPECastType::~PECastType()\n{\n}\n\nbool PECastType::has_aa_term(Design *des, NetScope *scope) const\n{\n\treturn base_->has_aa_term(des, scope);\n}\n\nPECastSign::PECastSign(bool signed_flag, PExpr *base)\n: base_(base)\n{\n    signed_flag_ = signed_flag;\n}\n\nbool PECastSign::has_aa_term(Design *des, NetScope *scope) const\n{\n\treturn base_->has_aa_term(des, scope);\n}\n\nPEBComp::PEBComp(char op, PExpr*l, PExpr*r)\n: PEBinary(op, l, r)\n{\n      l_width_ = 0;\n      r_width_ = 0;\n}\n\nPEBComp::~PEBComp()\n{\n}\n\nPEBLogic::PEBLogic(char op, PExpr*l, PExpr*r)\n: PEBinary(op, l, r)\n{\n      ivl_assert(*this, op == 'a' || op == 'o' || op == 'q' || op == 'Q');\n}\n\nPEBLogic::~PEBLogic()\n{\n}\n\nPEBLeftWidth::PEBLeftWidth(char op, PExpr*l, PExpr*r)\n: PEBinary(op, l, r)\n{\n}\n\nPEBLeftWidth::~PEBLeftWidth()\n{\n}\n\nPEBPower::PEBPower(char op, PExpr*l, PExpr*r)\n: PEBLeftWidth(op, l, r)\n{\n}\n\nPEBPower::~PEBPower()\n{\n}\n\nPEBShift::PEBShift(char op, PExpr*l, PExpr*r)\n: PEBLeftWidth(op, l, r)\n{\n}\n\nPEBShift::~PEBShift()\n{\n}\n\nPECallFunction::PECallFunction(const pform_name_t &n, const vector<named_pexpr_t> &parms)\n: path_(n), parms_(parms), is_overridden_(false)\n{\n}\n\nPECallFunction::PECallFunction(PPackage *pkg, const pform_name_t &n, const vector<named_pexpr_t> &parms)\n: path_(pkg, n), parms_(parms), is_overridden_(false)\n{\n}\n\nstatic pform_name_t pn_from_ps(perm_string n)\n{\n      name_component_t tmp_name (n);\n      pform_name_t tmp;\n      tmp.push_back(tmp_name);\n      return tmp;\n}\n\nPECallFunction::PECallFunction(PPackage *pkg, const pform_name_t &n, const list<named_pexpr_t> &parms)\n: path_(pkg, n), parms_(parms.begin(), parms.end()), is_overridden_(false)\n{\n}\n\nPECallFunction::PECallFunction(perm_string n, const vector<named_pexpr_t> &parms)\n: path_(pn_from_ps(n)), parms_(parms), is_overridden_(false)\n{\n}\n\nPECallFunction::PECallFunction(perm_string n)\n: path_(pn_from_ps(n)), is_overridden_(false)\n{\n}\n\n// NOTE: Anachronism. Try to work all use of svector out.\nPECallFunction::PECallFunction(const pform_name_t &n, const list<named_pexpr_t> &parms)\n: path_(n), parms_(parms.begin(), parms.end()), is_overridden_(false)\n{\n}\n\nPECallFunction::PECallFunction(perm_string n, const list<named_pexpr_t> &parms)\n: path_(pn_from_ps(n)), parms_(parms.begin(), parms.end()), is_overridden_(false)\n{\n}\n\nPECallFunction::~PECallFunction()\n{\n}\n\nvoid PECallFunction::declare_implicit_nets(LexicalScope*scope, NetNet::Type type)\n{\n      for (const auto &parm : parms_) {\n\t    if (parm.parm)\n\t\t  parm.parm->declare_implicit_nets(scope, type);\n      }\n}\n\nbool PECallFunction::has_aa_term(Design*des, NetScope*scope) const\n{\n      bool flag = false;\n      for (const auto &parm : parms_) {\n\t    if (parm.parm)\n\t\t  flag |= parm.parm->has_aa_term(des, scope);\n      }\n      return flag;\n}\n\nPEConcat::PEConcat(const list<PExpr*>&p, PExpr*r)\n: parms_(p.begin(), p.end()), width_modes_(SIZED, p.size()), repeat_(r)\n{\n      tested_scope_ = 0;\n      repeat_count_ = 1;\n}\n\nPEConcat::~PEConcat()\n{\n      delete repeat_;\n}\n\nvoid PEConcat::declare_implicit_nets(LexicalScope*scope, NetNet::Type type)\n{\n      for (unsigned idx = 0 ; idx < parms_.size() ; idx += 1) {\n\t    parms_[idx]->declare_implicit_nets(scope, type);\n      }\n}\n\nbool PEConcat::has_aa_term(Design*des, NetScope*scope) const\n{\n      bool flag = false;\n      for (unsigned idx = 0 ; idx < parms_.size() ; idx += 1) {\n\t    flag = parms_[idx]->has_aa_term(des, scope) || flag;\n      }\n      if (repeat_)\n            flag = repeat_->has_aa_term(des, scope) || flag;\n\n      return flag;\n}\n\nPEEvent::PEEvent(PEEvent::edge_t t, PExpr*e)\n: type_(t), expr_(e)\n{\n}\n\nPEEvent::~PEEvent()\n{\n}\n\nPEEvent::edge_t PEEvent::type() const\n{\n      return type_;\n}\n\nbool PEEvent::has_aa_term(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, expr_);\n      return expr_->has_aa_term(des, scope);\n}\n\nPExpr* PEEvent::expr() const\n{\n      return expr_;\n}\n\nPENull::PENull(void)\n{\n}\n\nPENull::~PENull()\n{\n}\n\nPEFNumber::PEFNumber(verireal*v)\n: value_(v)\n{\n}\n\nPEFNumber::~PEFNumber()\n{\n      delete value_;\n}\n\nconst verireal& PEFNumber::value() const\n{\n      return *value_;\n}\n\nPEIdent::PEIdent(const pform_name_t&that, unsigned lexical_pos)\n: path_(that), lexical_pos_(lexical_pos), no_implicit_sig_(false)\n{\n}\n\nPEIdent::PEIdent(perm_string s, unsigned lexical_pos, bool no_implicit_sig)\n: lexical_pos_(lexical_pos), no_implicit_sig_(no_implicit_sig)\n{\n      path_.name.push_back(name_component_t(s));\n}\n\nPEIdent::PEIdent(PPackage*pkg, const pform_name_t&that, unsigned lexical_pos)\n: path_(pkg, that), lexical_pos_(lexical_pos), no_implicit_sig_(true)\n{\n}\n\nPEIdent::~PEIdent()\n{\n}\n\nstatic bool find_enum_constant(LexicalScope*scope, perm_string name)\n{\n      for (vector<enum_type_t*>::const_iterator cur = scope->enum_sets.begin() ;\n           cur != scope->enum_sets.end() ; ++ cur) {\n\t    for (list<named_pexpr_t>::const_iterator idx = (*cur)->names->begin() ;\n                 idx != (*cur)->names->end() ; ++ idx) {\n                  if (idx->name == name) return true;\n            }\n      }\n      return false;\n}\n\nvoid PEIdent::declare_implicit_nets(LexicalScope*scope, NetNet::Type type)\n{\n        /* We create an implicit wire if:\n\t   - this is a simple identifier\n           - an identifier of that name has not already been declared in\n             any enclosing scope.\n\t   - this is not an implicit named port connection */\n     if (no_implicit_sig_)\n\t    return;\n     if (path_.package)\n\t    return;\n     if (path_.name.size() == 1 && path_.name.front().index.empty()) {\n            perm_string name = path_.name.front().name;\n            LexicalScope*ss = scope;\n            while (ss) {\n                  if (ss->wires.find(name) != ss->wires.end())\n                        return;\n                  if (ss->parameters.find(name) != ss->parameters.end())\n                        return;\n                  if (ss->genvars.find(name) != ss->genvars.end())\n                        return;\n                  if (ss->events.find(name) != ss->events.end())\n                        return;\n                  if (find_enum_constant(ss, name))\n                        return;\n                  /* Strictly speaking, we should also check for name clashes\n                     with tasks, functions, named blocks, module instances,\n                     and generate blocks. However, this information is not\n                     readily available. As these names would not be legal in\n                     this context, we can declare implicit nets here and rely\n                     on later checks for name clashes to report the error. */\n\n                  ss = ss->parent_scope();\n            }\n            PWire*net = new PWire(name, lexical_pos_, type, NetNet::NOT_A_PORT);\n            net->set_file(get_file());\n            net->set_lineno(get_lineno());\n            scope->wires[name] = net;\n            if (warn_implicit) {\n                  cerr << get_fileline() << \": warning: implicit \"\n                       \"definition of wire '\" << name << \"'.\" << endl;\n            }\n      }\n}\n\nbool PEIdent::has_aa_term(Design*des, NetScope*scope) const\n{\n      symbol_search_results sr;\n      if (!symbol_search(this, des, scope, path_, lexical_pos_, &sr))\n\t    return false;\n\n      // Class properties are not considered automatic since a non-blocking\n      // assignment to an object stored in an automatic variable is supposed to\n      // capture a reference to the object, not the variable.\n      if (!sr.path_tail.empty() && sr.net && sr.net->class_type())\n\t    return false;\n\n      return sr.scope->is_auto();\n}\n\nPENewArray::PENewArray(PExpr*size_expr, PExpr*init_expr)\n: size_(size_expr), init_(init_expr)\n{\n}\n\nPENewArray::~PENewArray()\n{\n      delete size_;\n}\n\nPENewClass::PENewClass(void)\n{\n}\n\nPENewClass::PENewClass(const list<named_pexpr_t> &p, data_type_t *class_type)\n: parms_(p.begin(), p.end()), class_type_(class_type)\n{\n}\n\nPENewClass::~PENewClass()\n{\n}\n\nPENewCopy::PENewCopy(PExpr*src)\n: src_(src)\n{\n}\n\nPENewCopy::~PENewCopy()\n{\n}\n\nPENumber::PENumber(verinum*vp)\n: value_(vp)\n{\n      ivl_assert(*this, vp);\n}\n\nPENumber::~PENumber()\n{\n      delete value_;\n}\n\nconst verinum& PENumber::value() const\n{\n      return *value_;\n}\n\nPEString::PEString(char*s)\n: text_(s)\n{\n}\n\nPEString::~PEString()\n{\n      delete[]text_;\n}\n\nstring PEString::value() const\n{\n      return text_;\n}\n\nPETernary::PETernary(PExpr*e, PExpr*t, PExpr*f)\n: expr_(e), tru_(t), fal_(f)\n{\n}\n\nPETernary::~PETernary()\n{\n}\n\nvoid PETernary::declare_implicit_nets(LexicalScope*scope, NetNet::Type type)\n{\n      ivl_assert(*this, expr_ && tru_ && fal_);\n      expr_->declare_implicit_nets(scope, type);\n      tru_->declare_implicit_nets(scope, type);\n      fal_->declare_implicit_nets(scope, type);\n}\n\nbool PETernary::has_aa_term(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, expr_ && tru_ && fal_);\n      return expr_->has_aa_term(des, scope)\n           || tru_->has_aa_term(des, scope)\n           || fal_->has_aa_term(des, scope);\n}\n\nPETypename::PETypename(data_type_t*dt)\n: data_type_(dt)\n{\n}\n\nPETypename::~PETypename()\n{\n}\n\nPEUnary::PEUnary(char op, PExpr*ex)\n: op_(op), expr_(ex)\n{\n}\n\nPEUnary::~PEUnary()\n{\n}\n\nvoid PEUnary::declare_implicit_nets(LexicalScope*scope, NetNet::Type type)\n{\n      ivl_assert(*this, expr_);\n      expr_->declare_implicit_nets(scope, type);\n}\n\nbool PEUnary::has_aa_term(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, expr_);\n      return expr_->has_aa_term(des, scope);\n}\n\nPEVoid::PEVoid()\n{\n}\n\nPEVoid::~PEVoid()\n{\n}\n"
        },
        {
          "name": "PExpr.h",
          "type": "blob",
          "size": 35.12890625,
          "content": "#ifndef IVL_PExpr_H\n#define IVL_PExpr_H\n/*\n * Copyright (c) 1998-2024 Stephen Williams <steve@icarus.com>\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <string>\n# include  <vector>\n# include  <valarray>\n# include  <memory>\n# include  \"netlist.h\"\n# include  \"verinum.h\"\n# include  \"LineInfo.h\"\n# include  \"pform_types.h\"\n\nclass Design;\nclass Module;\nclass LexicalScope;\nclass NetNet;\nclass NetExpr;\nclass NetScope;\nclass PPackage;\nstruct symbol_search_results;\n\n/*\n * The PExpr class hierarchy supports the description of\n * expressions. The parser can generate expression objects from the\n * source, possibly reducing things that it knows how to reduce.\n */\n\nclass PExpr : public LineInfo {\n\n    public:\n\t// Mode values used by test_width() (see below for description).\n      enum width_mode_t { SIZED, UNSIZED, EXPAND, LOSSLESS, UPSIZE };\n\n        // Flag values that can be passed to elaborate_expr().\n      static const unsigned NO_FLAGS     = 0x0;\n      static const unsigned NEED_CONST   = 0x1;\n      static const unsigned SYS_TASK_ARG = 0x2;\n      static const unsigned ANNOTATABLE  = 0x4;\n\n\t// Convert width mode to human-readable form.\n      static const char*width_mode_name(width_mode_t mode);\n\n      PExpr();\n      virtual ~PExpr();\n\n      virtual void dump(std::ostream&) const;\n\n        // This method tests whether the expression contains any identifiers\n        // that have not been previously declared in the specified scope or\n        // in any containing scope. Any such identifiers are added to the\n        // specified scope as scalar nets of the specified type.\n        //\n        // This operation must be performed by the parser, to ensure that\n        // subsequent declarations do not affect the decision to create an\n        // implicit net.\n      virtual void declare_implicit_nets(LexicalScope*scope, NetNet::Type type);\n\n        // This method tests whether the expression contains any\n        // references to automatically allocated variables.\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n\t// This method tests the type and width that the expression wants\n\t// to be. It should be called before elaborating an expression to\n\t// figure out the type and width of the expression. It also figures\n\t// out the minimum width that can be used to evaluate the expression\n\t// without changing the result. This allows the expression width to\n\t// be pruned when not all bits of the result are used.\n\t//\n\t// Normally mode should be initialized to SIZED before starting to\n\t// test the width of an expression. In SIZED mode the expression\n\t// width will be calculated strictly according to the IEEE standard\n\t// rules for expression width.\n\t//\n\t// If the expression is found to contain an unsized literal number\n\t// and gn_strict_expr_width_flag is set, mode will be changed to\n\t// UNSIZED. In UNSIZED mode the expression width will be calculated\n\t// exactly as in SIZED mode - the change in mode simply flags that\n\t// the expression contains an unsized numbers.\n\t//\n\t// If the expression is found to contain an unsized literal number\n\t// and gn_strict_expr_width_flag is not set, mode will be changed\n\t// to LOSSLESS. In LOSSLESS mode the expression width will be\n\t// calculated as the minimum width necessary to avoid arithmetic\n\t// overflow or underflow.\n\t//\n\t// Once in LOSSLESS mode, if the expression is found to contain\n\t// an operation that coerces a vector operand to a different type\n\t// (signed <-> unsigned), mode will be changed to UPSIZE. UPSIZE\n\t// mode is the same as LOSSLESS, except that the final expression\n\t// width will be forced to be at least integer_width. This is\n\t// necessary to ensure compatibility with the IEEE standard, which\n\t// requires unsized numbers to be treated as having the same width\n\t// as an integer. The lossless width calculation is inadequate in\n\t// this case because coercing an operand to a different type means\n\t// that the expression no longer obeys the normal rules of arithmetic.\n\t//\n\t// If mode is initialized to EXPAND instead of SIZED, the expression\n\t// width will be calculated as the minimum width necessary to avoid\n\t// arithmetic overflow or underflow, even if it contains no unsized\n\t// literals. mode will be changed LOSSLESS or UPSIZE as described\n\t// above. This supports a non-standard mode of expression width\n\t// calculation.\n\t//\n\t// When the final value of mode is UPSIZE, the width returned by\n\t// this method is the calculated lossless width, but the width\n\t// returned by a subsequent call to the expr_width method will be\n\t// the final expression width.\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n\t// After the test_width method is complete, these methods\n\t// return valid results.\n      ivl_variable_type_t expr_type() const { return expr_type_; }\n      unsigned expr_width() const           { return expr_width_; }\n      unsigned min_width() const            { return min_width_; }\n      bool has_sign() const                 { return signed_flag_; }\n\n        // This method allows the expression type (signed/unsigned)\n        // to be propagated down to any context-dependant operands.\n      void cast_signed(bool flag) { signed_flag_ = flag; }\n\n\t// This is the more generic form of the elaborate_expr method\n\t// below. The plan is to replace the simpler elaborate_expr\n\t// method with this version, which can handle more advanced\n\t// types. But for now, this is only implemented in special cases.\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n\t// Procedural elaboration of the expression. The expr_width is\n\t// the required width of the expression.\n\t//\n\t// The sys_task_arg flag is true if expressions are allowed to\n\t// be incomplete.\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n\n\t// This method elaborates the expression as gates, but\n\t// restricted for use as l-values of continuous assignments.\n      virtual NetNet* elaborate_lnet(Design*des, NetScope*scope) const;\n\n\t// This is similar to elaborate_lnet, except that the\n\t// expression is evaluated to be bi-directional. This is\n\t// useful for arguments to inout ports of module instances and\n\t// ports of tran primitives.\n      virtual NetNet* elaborate_bi_net(Design*des, NetScope*scope) const;\n\n\t// Expressions that can be in the l-value of procedural\n\t// assignments can be elaborated with this method. If the\n\t// is_cassign or is_force flags are true, then the set of\n\t// valid l-value types is slightly modified to accommodate\n\t// the Verilog procedural continuous assignment statements.\n      virtual NetAssign_* elaborate_lval(Design*des,\n\t\t\t\t\t NetScope*scope,\n\t\t\t\t\t bool is_cassign,\n\t\t\t\t\t bool is_force,\n\t\t\t\t\t bool is_init = false) const;\n\n\t// This method returns true if the expression represents a\n        // structural net that can have multiple drivers. This is\n        // used to test whether an input port connection can be\n        // collapsed to a single wire.\n      virtual bool is_collapsible_net(Design*des, NetScope*scope,\n                                      NetNet::PortType port_type) const;\n\n    protected:\n      unsigned fix_width_(width_mode_t mode);\n\n\t// The derived class test_width methods should fill these in.\n      ivl_variable_type_t expr_type_;\n      unsigned expr_width_;\n      unsigned min_width_;\n      bool signed_flag_;\n\n    private: // not implemented\n      PExpr(const PExpr&);\n      PExpr& operator= (const PExpr&);\n};\n\nstd::ostream& operator << (std::ostream&, const PExpr&);\n\nclass PEAssignPattern : public PExpr {\n    public:\n      explicit PEAssignPattern();\n      explicit PEAssignPattern(const std::list<PExpr*>&p);\n      ~PEAssignPattern();\n\n      void dump(std::ostream&) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope, width_mode_t&mode);\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n    private:\n      NetExpr* elaborate_expr_packed_(Design *des, NetScope *scope,\n\t\t\t\t      ivl_variable_type_t base_type,\n\t\t\t\t      unsigned int width,\n\t\t\t\t      const netranges_t &dims,\n\t\t\t\t      unsigned int cur_dim,\n\t\t\t\t      bool need_const) const;\n      NetExpr* elaborate_expr_struct_(Design *des, NetScope *scope,\n\t\t\t\t      const netstruct_t *struct_type,\n\t\t\t\t      bool need_const) const;\n      NetExpr* elaborate_expr_array_(Design *des, NetScope *scope,\n\t\t\t\t     const netarray_t *array_type,\n\t\t\t\t     bool need_const, bool up) const;\n      NetExpr* elaborate_expr_uarray_(Design *des, NetScope *scope,\n\t\t\t\t      const netuarray_t *uarray_type,\n\t\t\t\t      const netranges_t &dims,\n\t\t\t\t      unsigned int cur_dim,\n\t\t\t\t      bool need_const) const;\n\n    private:\n      std::vector<PExpr*>parms_;\n};\n\nclass PEConcat : public PExpr {\n\n    public:\n      explicit PEConcat(const std::list<PExpr*>&p, PExpr*r =0);\n      ~PEConcat();\n\n      virtual void dump(std::ostream&) const;\n\n      virtual void declare_implicit_nets(LexicalScope*scope, NetNet::Type type);\n\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      virtual NetNet* elaborate_lnet(Design*des, NetScope*scope) const;\n      virtual NetNet* elaborate_bi_net(Design*des, NetScope*scope) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n      virtual NetAssign_* elaborate_lval(Design*des,\n\t\t\t\t\t NetScope*scope,\n\t\t\t\t\t bool is_cassign,\n\t\t\t\t\t bool is_force,\n\t\t\t\t\t bool is_init = false) const;\n      virtual bool is_collapsible_net(Design*des, NetScope*scope,\n                                      NetNet::PortType port_type) const;\n    private:\n      NetNet* elaborate_lnet_common_(Design*des, NetScope*scope,\n\t\t\t\t     bool bidirectional_flag) const;\n    private:\n      std::vector<PExpr*>parms_;\n      std::valarray<width_mode_t>width_modes_;\n\n      PExpr*repeat_;\n      NetScope*tested_scope_;\n      unsigned repeat_count_;\n};\n\n/*\n * Event expressions are expressions that can be combined with the\n * event \"or\" operator. These include \"posedge foo\" and similar, and\n * also include named events. \"edge\" events are associated with an\n * expression, whereas named events simply have a name, which\n * represents an event variable.\n */\nclass PEEvent : public PExpr {\n\n    public:\n      enum edge_t {ANYEDGE, POSEDGE, NEGEDGE, EDGE, POSITIVE};\n\n\t// Use this constructor to create events based on edges or levels.\n      PEEvent(edge_t t, PExpr*e);\n\n      ~PEEvent();\n\n      edge_t type() const;\n      PExpr* expr() const;\n\n      virtual void dump(std::ostream&) const;\n\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n    private:\n      edge_t type_;\n      PExpr *expr_;\n};\n\n/*\n * This holds a floating point constant in the source.\n */\nclass PEFNumber : public PExpr {\n\n    public:\n      explicit PEFNumber(verireal*vp);\n      ~PEFNumber();\n\n      const verireal& value() const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n\n      virtual void dump(std::ostream&) const;\n\n    private:\n      verireal*value_;\n};\n\nclass PEIdent : public PExpr {\n\n    public:\n      explicit PEIdent(perm_string, unsigned lexical_pos, bool no_implicit_sig=false);\n      explicit PEIdent(PPackage*pkg, const pform_name_t&name, unsigned lexical_pos);\n      explicit PEIdent(const pform_name_t&, unsigned lexical_pos);\n      ~PEIdent();\n\n\t// Add another name to the string of hierarchy that is the\n\t// current identifier.\n      void append_name(perm_string);\n\n      virtual void dump(std::ostream&) const;\n\n      virtual void declare_implicit_nets(LexicalScope*scope, NetNet::Type type);\n\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n\t// Identifiers are allowed (with restrictions) is assign l-values.\n      virtual NetNet* elaborate_lnet(Design*des, NetScope*scope) const;\n\n      virtual NetNet* elaborate_bi_net(Design*des, NetScope*scope) const;\n\n\t// Identifiers are also allowed as procedural assignment l-values.\n      virtual NetAssign_* elaborate_lval(Design*des,\n\t\t\t\t\t NetScope*scope,\n\t\t\t\t\t bool is_cassign,\n\t\t\t\t\t bool is_force,\n\t\t\t\t\t bool is_init = false) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n\n\t// Elaborate the PEIdent as a port to a module. This method\n\t// only applies to Ident expressions.\n      NetNet* elaborate_subport(Design*des, NetScope*sc) const;\n\n\t// Elaborate the identifier allowing for unpacked arrays. This\n\t// method only applies to Ident expressions because only Ident\n\t// expressions can can be unpacked arrays.\n      NetNet* elaborate_unpacked_net(Design*des, NetScope*sc) const;\n\n      virtual bool is_collapsible_net(Design*des, NetScope*scope,\n                                      NetNet::PortType port_type) const;\n\n      const pform_scoped_name_t& path() const { return path_; }\n\n      unsigned lexical_pos() const { return lexical_pos_; }\n\n    private:\n      pform_scoped_name_t path_;\n      unsigned lexical_pos_;\n      bool no_implicit_sig_;\n\n    private:\n\t// Common functions to calculate parts of part/bit\n\t// selects. These methods return true if the expressions\n\t// elaborate/calculate, or false if there is some sort of\n\t// source error.\n\n      bool calculate_bits_(Design*, NetScope*, long&msb, bool&defined) const;\n\n\t// The calculate_parts_ method calculates the range\n\t// expressions of a part select for the current object. The\n\t// part select expressions are elaborated and evaluated, and\n\t// the values written to the msb/lsb arguments. If there are\n\t// invalid bits (xz) in either expression, then the defined\n\t// flag is set to *false*.\n      bool calculate_parts_(Design*, NetScope*, long&msb, long&lsb, bool&defined) const;\n      NetExpr* calculate_up_do_base_(Design*, NetScope*, bool need_const) const;\n\n      bool calculate_up_do_width_(Design*, NetScope*, unsigned long&wid) const;\n\n\t// Evaluate the prefix indices. All but the final index in a\n\t// chain of indices must be a single value and must evaluate\n\t// to constants at compile time. For example:\n\t//    [x]          - OK\n\t//    [1][2][x]    - OK\n\t//    [1][x:y]     - OK\n\t//    [2:0][x]     - BAD\n\t//    [y][x]       - BAD\n\t// Leave the last index for special handling.\n      bool calculate_packed_indices_(Design*des, NetScope*scope, NetNet*net,\n\t\t\t\t     std::list<long>&prefix_indices) const;\n\n    private:\n\n      void report_mixed_assignment_conflict_(const char*category) const;\n\n      NetAssign_ *elaborate_lval_array_(Design *des, NetScope *scope,\n\t\t\t\t        bool is_force, NetNet *reg) const;\n      NetAssign_ *elaborate_lval_var_(Design *des, NetScope *scope,\n\t\t\t\t      bool is_force, bool is_cassign,\n\t\t\t\t      NetNet *reg, ivl_type_t data_type,\n\t\t\t\t      pform_name_t tail_path) const;\n      NetAssign_*elaborate_lval_net_word_(Design*, NetScope*, NetNet*,\n\t\t\t\t\t  bool need_const_idx, bool is_force) const;\n      bool elaborate_lval_net_bit_(Design*, NetScope*, NetAssign_*,\n\t\t\t\t   bool need_const_idx, bool is_force) const;\n      bool elaborate_lval_net_part_(Design*, NetScope*, NetAssign_*,\n\t\t\t\t    bool is_force) const;\n      bool elaborate_lval_net_idx_(Design*, NetScope*, NetAssign_*,\n                                   index_component_t::ctype_t,\n\t\t\t\t   bool need_const_idx, bool is_force) const;\n      NetAssign_*elaborate_lval_net_class_member_(Design*, NetScope*,\n\t\t\t\t\t\t   const netclass_t *class_type,\n\t\t\t\t\t\t   NetNet*,\n\t\t\t\t\t\t   pform_name_t) const;\n      bool elaborate_lval_net_packed_member_(Design*, NetScope*,\n\t\t\t\t\t     NetAssign_*,\n\t\t\t\t\t     pform_name_t member_path, bool is_force) const;\n      bool elaborate_lval_darray_bit_(Design*, NetScope*,\n\t\t\t\t      NetAssign_*, bool is_force) const;\n\n    private:\n      NetExpr* elaborate_expr_(Design *des, NetScope *scope,\n\t\t\t      unsigned expr_wid, unsigned flags) const;\n\n      NetExpr*elaborate_expr_param_or_specparam_(Design*des,\n\t\t\t\t\t\t NetScope*scope,\n\t\t\t\t\t\t const NetExpr*par,\n\t\t\t\t\t\t NetScope*found_in,\n\t\t\t\t\t\t ivl_type_t par_type,\n\t\t\t\t\t\t unsigned expr_wid,\n\t\t\t\t\t\t unsigned flags) const;\n      NetExpr*elaborate_expr_param_(Design*des,\n\t\t\t\t    NetScope*scope,\n\t\t\t\t    const NetExpr*par,\n\t\t\t\t    const NetScope*found_in,\n\t\t\t\t    ivl_type_t par_type,\n\t\t\t\t    unsigned expr_wid,\n                                    unsigned flags) const;\n      NetExpr*elaborate_expr_param_bit_(Design*des,\n\t\t\t\t\tNetScope*scope,\n\t\t\t\t\tconst NetExpr*par,\n\t\t\t\t\tconst NetScope*found_in,\n\t\t\t\t\tivl_type_t par_type,\n                                        bool need_const) const;\n      NetExpr*elaborate_expr_param_part_(Design*des,\n\t\t\t\t\t NetScope*scope,\n\t\t\t\t\t const NetExpr*par,\n\t\t\t\t\t const NetScope*found_in,\n\t\t\t\t\t ivl_type_t par_type,\n\t\t\t\t         unsigned expr_wid) const;\n      NetExpr*elaborate_expr_param_idx_up_(Design*des,\n\t\t\t\t\t   NetScope*scope,\n\t\t\t\t\t   const NetExpr*par,\n\t\t\t\t\t   const NetScope*found_in,\n\t\t\t\t\t   ivl_type_t par_type,\n                                           bool need_const) const;\n      NetExpr*elaborate_expr_param_idx_do_(Design*des,\n\t\t\t\t\t   NetScope*scope,\n\t\t\t\t\t   const NetExpr*par,\n\t\t\t\t\t   const NetScope*found_in,\n\t\t\t\t\t   ivl_type_t par_type,\n                                           bool need_const) const;\n      NetExpr*elaborate_expr_net(Design*des,\n\t\t\t\t NetScope*scope,\n\t\t\t\t NetNet*net,\n\t\t\t\t NetScope*found,\n\t\t\t\t unsigned expr_wid,\n\t\t\t\t unsigned flags) const;\n      NetExpr*elaborate_expr_net_word_(Design*des,\n\t\t\t\t       NetScope*scope,\n\t\t\t\t       NetNet*net,\n\t\t\t\t       NetScope*found,\n\t\t\t\t       unsigned expr_wid,\n\t\t\t\t       unsigned flags) const;\n      NetExpr*elaborate_expr_net_part_(Design*des,\n\t\t\t\t       NetScope*scope,\n\t\t\t\t       NetESignal*net,\n\t\t\t\t       NetScope*found,\n\t\t\t\t       unsigned expr_wid) const;\n      NetExpr*elaborate_expr_net_idx_up_(Design*des,\n\t\t\t\t         NetScope*scope,\n\t\t\t\t         NetESignal*net,\n\t\t\t\t         NetScope*found,\n                                         bool need_const) const;\n      NetExpr*elaborate_expr_net_idx_do_(Design*des,\n\t\t\t\t         NetScope*scope,\n\t\t\t\t         NetESignal*net,\n\t\t\t\t         NetScope*found,\n                                         bool need_const) const;\n      NetExpr*elaborate_expr_net_bit_(Design*des,\n\t\t\t\t      NetScope*scope,\n\t\t\t\t      NetESignal*net,\n\t\t\t\t      NetScope*found,\n                                      bool need_const) const;\n      NetExpr*elaborate_expr_net_bit_last_(Design*des,\n\t\t\t\t\t   NetScope*scope,\n\t\t\t\t\t   NetESignal*net,\n\t\t\t\t\t   NetScope*found,\n\t\t\t\t\t   bool need_const) const;\n\n      NetExpr *elaborate_expr_class_field_(Design*des, NetScope*scope,\n\t\t\t\t\t   const symbol_search_results &sr,\n\t\t\t\t\t   unsigned expr_wid,\n\t\t\t\t\t   unsigned flags) const;\n\n      unsigned test_width_parameter_(const NetExpr *par, width_mode_t&mode);\n\n      ivl_type_t resolve_type_(Design *des, const symbol_search_results &sr,\n\t\t\t       unsigned int &index_depth) const;\n\n    private:\n      NetNet* elaborate_lnet_common_(Design*des, NetScope*scope,\n\t\t\t\t     bool bidirectional_flag) const;\n\n\n      bool eval_part_select_(Design*des, NetScope*scope, NetNet*sig,\n\t\t\t     long&midx, long&lidx) const;\n};\n\nclass PENewArray : public PExpr {\n\n    public:\n      explicit PENewArray (PExpr*s, PExpr*i);\n      ~PENewArray();\n\n      virtual void dump(std::ostream&) const;\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n\n    private:\n      PExpr*size_;\n      PExpr*init_;\n};\n\nclass PENewClass : public PExpr {\n\n    public:\n\t// New without (or with default) constructor\n      explicit PENewClass ();\n\t// New with constructor arguments\n      explicit PENewClass (const std::list<named_pexpr_t> &p,\n\t\t\t   data_type_t *class_type = nullptr);\n\n      ~PENewClass();\n\n      virtual void dump(std::ostream&) const;\n\t// Class objects don't have a useful width, but the expression\n\t// is IVL_VT_CLASS.\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\t// Note that class (new) expressions only appear in context\n\t// that uses this form of the elaborate_expr method. In fact,\n\t// the type argument is going to be a netclass_t object.\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n    private:\n      NetExpr* elaborate_expr_constructor_(Design*des, NetScope*scope,\n\t\t\t\t\t   const netclass_t*ctype,\n\t\t\t\t\t   NetExpr*obj, unsigned flags) const;\n\n    private:\n      std::vector<named_pexpr_t> parms_;\n      data_type_t *class_type_;\n};\n\nclass PENewCopy : public PExpr {\n    public:\n      explicit PENewCopy(PExpr*src);\n      ~PENewCopy();\n\n      virtual void dump(std::ostream&) const;\n\t// Class objects don't have a useful width, but the expression\n\t// is IVL_VT_CLASS.\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\t// Note that class (new) expressions only appear in context\n\t// that uses this form of the elaborate_expr method. In fact,\n\t// the type argument is going to be a netclass_t object.\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n    private:\n      PExpr*src_;\n};\n\nclass PENull : public PExpr {\n    public:\n      explicit PENull();\n      ~PENull();\n\n      virtual void dump(std::ostream&) const;\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n};\n\nclass PENumber : public PExpr {\n\n    public:\n      explicit PENumber(verinum*vp);\n      ~PENumber();\n\n      const verinum& value() const;\n\n      virtual void dump(std::ostream&) const;\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      virtual NetExpr  *elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t       ivl_type_t type, unsigned flags) const;\n      virtual NetEConst*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t       unsigned expr_wid, unsigned) const;\n      virtual NetAssign_* elaborate_lval(Design*des,\n\t\t\t\t\t NetScope*scope,\n\t\t\t\t\t bool is_cassign,\n\t\t\t\t\t bool is_force,\n\t\t\t\t\t bool is_init = false) const;\n\n    private:\n      verinum*const value_;\n};\n\n/*\n * This represents a string constant in an expression.\n *\n * The s parameter to the PEString constructor is a C string that this\n * class instance will take for its own. The caller should not delete\n * the string, the destructor will do it.\n */\nclass PEString : public PExpr {\n\n    public:\n      explicit PEString(char*s);\n      ~PEString();\n\n      std::string value() const;\n      virtual void dump(std::ostream&) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      virtual NetEConst*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t       ivl_type_t type, unsigned flags) const;\n\n      virtual NetEConst*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t       unsigned expr_wid, unsigned) const;\n\n    private:\n      char*text_;\n};\n\nclass PETypename : public PExpr {\n    public:\n      explicit PETypename(data_type_t*data_type);\n      ~PETypename();\n\n      virtual void dump(std::ostream&) const;\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n      inline data_type_t* get_type() const { return data_type_; }\n\n    private:\n      data_type_t*data_type_;\n};\n\nclass PEUnary : public PExpr {\n\n    public:\n      explicit PEUnary(char op, PExpr*ex);\n      ~PEUnary();\n\n      virtual void dump(std::ostream&out) const;\n\n      virtual void declare_implicit_nets(LexicalScope*scope, NetNet::Type type);\n\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n\n    public:\n      inline char get_op() const { return op_; }\n      inline PExpr*get_expr() const { return expr_; }\n\n    private:\n      NetExpr* elaborate_expr_bits_(NetExpr*operand, unsigned expr_wid) const;\n\n    private:\n      char op_;\n      PExpr*expr_;\n};\n\nclass PEBinary : public PExpr {\n\n    public:\n      explicit PEBinary(char op, PExpr*l, PExpr*r);\n      ~PEBinary();\n\n      virtual void dump(std::ostream&out) const;\n\n      virtual void declare_implicit_nets(LexicalScope*scope, NetNet::Type type);\n\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n\n    protected:\n      char op_;\n      PExpr*left_;\n      PExpr*right_;\n\n      NetExpr*elaborate_expr_base_(Design*, NetExpr*lp, NetExpr*rp,\n\t\t\t\t   unsigned expr_wid) const;\n      NetExpr*elaborate_eval_expr_base_(Design*, NetExpr*lp, NetExpr*rp,\n\t\t\t\t\tunsigned expr_wid) const;\n\n      NetExpr*elaborate_expr_base_bits_(Design*, NetExpr*lp, NetExpr*rp,\n                                        unsigned expr_wid) const;\n      NetExpr*elaborate_expr_base_div_(Design*, NetExpr*lp, NetExpr*rp,\n\t\t\t\t       unsigned expr_wid) const;\n      NetExpr*elaborate_expr_base_mult_(Design*, NetExpr*lp, NetExpr*rp,\n\t\t\t\t\tunsigned expr_wid) const;\n      NetExpr*elaborate_expr_base_add_(Design*, NetExpr*lp, NetExpr*rp,\n\t\t\t\t       unsigned expr_wid) const;\n\n};\n\n/*\n * Here are a few specialized classes for handling specific binary\n * operators.\n */\nclass PEBComp  : public PEBinary {\n\n    public:\n      explicit PEBComp(char op, PExpr*l, PExpr*r);\n      ~PEBComp();\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      NetExpr* elaborate_expr(Design*des, NetScope*scope,\n\t\t\t      unsigned expr_wid, unsigned flags) const;\n\n    private:\n      unsigned l_width_;\n      unsigned r_width_;\n};\n\n/*\n * This derived class is for handling logical expressions: && and ||.\n*/\nclass PEBLogic  : public PEBinary {\n\n    public:\n      explicit PEBLogic(char op, PExpr*l, PExpr*r);\n      ~PEBLogic();\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      NetExpr* elaborate_expr(Design*des, NetScope*scope,\n\t\t\t      unsigned expr_wid, unsigned flags) const;\n};\n\n/*\n * A couple of the binary operands have a special sub-expression rule\n * where the expression width is carried entirely by the left\n * expression, and the right operand is self-determined.\n */\nclass PEBLeftWidth  : public PEBinary {\n\n    public:\n      explicit PEBLeftWidth(char op, PExpr*l, PExpr*r);\n      ~PEBLeftWidth() =0;\n\n      virtual NetExpr*elaborate_expr_leaf(Design*des, NetExpr*lp, NetExpr*rp,\n\t\t\t\t\t  unsigned expr_wid) const =0;\n\n    protected:\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n};\n\nclass PEBPower  : public PEBLeftWidth {\n\n    public:\n      explicit PEBPower(char op, PExpr*l, PExpr*r);\n      ~PEBPower();\n\n      NetExpr*elaborate_expr_leaf(Design*des, NetExpr*lp, NetExpr*rp,\n\t\t\t\t  unsigned expr_wid) const;\n};\n\nclass PEBShift  : public PEBLeftWidth {\n\n    public:\n      explicit PEBShift(char op, PExpr*l, PExpr*r);\n      ~PEBShift();\n\n      NetExpr*elaborate_expr_leaf(Design*des, NetExpr*lp, NetExpr*rp,\n\t\t\t\t  unsigned expr_wid) const;\n};\n\n/*\n * This class supports the ternary (?:) operator. The operator takes\n * three expressions, the test, the true result and the false result.\n */\nclass PETernary : public PExpr {\n\n    public:\n      explicit PETernary(PExpr*e, PExpr*t, PExpr*f);\n      ~PETernary();\n\n      virtual void dump(std::ostream&out) const;\n\n      virtual void declare_implicit_nets(LexicalScope*scope, NetNet::Type type);\n\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*,\n\t\t                     unsigned expr_wid,\n                                     unsigned flags) const;\n\n    private:\n      NetExpr* elab_and_eval_alternative_(Design*des, NetScope*scope,\n\t\t\t\t\t  PExpr*expr, unsigned expr_wid,\n                                          unsigned flags, bool short_cct) const;\n\n    private:\n      PExpr*expr_;\n      PExpr*tru_;\n      PExpr*fal_;\n};\n\n/*\n * This class represents a parsed call to a function, including calls\n * to system functions. The parameters in the parms list are the\n * expressions that are passed as input to the ports of the function.\n */\nclass PECallFunction : public PExpr {\n    public:\n      explicit PECallFunction(const pform_name_t &n, const std::vector<named_pexpr_t> &parms);\n\t// Call function defined in package.\n      explicit PECallFunction(PPackage *pkg, const pform_name_t &n, const std::list<named_pexpr_t> &parms);\n\n\t// Used to convert a user function called as a task\n      explicit PECallFunction(PPackage *pkg, const pform_name_t &n, const std::vector<named_pexpr_t> &parms);\n\n\t// Call of system function (name is not hierarchical)\n      explicit PECallFunction(perm_string n, const std::vector<named_pexpr_t> &parms);\n      explicit PECallFunction(perm_string n);\n\n\t// std::list versions. Should be removed!\n      explicit PECallFunction(const pform_name_t &n, const std::list<named_pexpr_t> &parms);\n      explicit PECallFunction(perm_string n, const std::list<named_pexpr_t> &parms);\n\n      ~PECallFunction();\n\n      virtual void dump(std::ostream &) const;\n\n      virtual void declare_implicit_nets(LexicalScope*scope, NetNet::Type type);\n\n      virtual bool has_aa_term(Design*des, NetScope*scope) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid, unsigned flags) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n    private:\n      pform_scoped_name_t path_;\n      std::vector<named_pexpr_t> parms_;\n\n        // For system functions.\n      bool is_overridden_;\n\n      bool check_call_matches_definition_(Design*des, NetScope*dscope) const;\n\n\n      NetExpr* cast_to_width_(NetExpr*expr, unsigned wid) const;\n\n      NetExpr* elaborate_expr_(Design *des, NetScope *scope,\n\t\t\t       unsigned flags) const;\n\n      NetExpr* elaborate_expr_method_(Design*des, NetScope*scope,\n\t\t\t\t      symbol_search_results&search_results)\n\t\t\t\t      const;\n      NetExpr* elaborate_expr_method_par_(Design*des, NetScope*scope,\n\t\t\t\t\t  symbol_search_results&search_results)\n\t\t\t\t\t  const;\n\n\n      NetExpr* elaborate_sfunc_(Design*des, NetScope*scope,\n                                unsigned expr_wid,\n                                unsigned flags) const;\n      NetExpr* elaborate_access_func_(Design*des, NetScope*scope, ivl_nature_t)\n                                      const;\n      unsigned test_width_sfunc_(Design*des, NetScope*scope,\n\t\t\t         width_mode_t&mode);\n      unsigned test_width_method_(Design*des, NetScope*scope,\n\t\t\t\t  symbol_search_results&search_results,\n\t\t\t\t  width_mode_t&mode);\n\n      NetExpr*elaborate_base_(Design*des, NetScope*scope, NetScope*dscope,\n\t\t\t      unsigned flags) const;\n\n      unsigned elaborate_arguments_(Design*des, NetScope*scope,\n\t\t\t\t    NetFuncDef*def, bool need_const,\n\t\t\t\t    std::vector<NetExpr*>&parms,\n\t\t\t\t    unsigned parm_off) const;\n};\n\n/*\n * Support the SystemVerilog cast to size.\n */\nclass PECastSize  : public PExpr {\n\n    public:\n      explicit PECastSize(PExpr*size, PExpr*base);\n      ~PECastSize();\n\n      void dump(std::ostream &out) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n\n      virtual bool has_aa_term(Design *des, NetScope *scope) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n    private:\n      PExpr* size_;\n      PExpr* base_;\n};\n\n/*\n * Support the SystemVerilog cast to a different type.\n */\nclass PECastType  : public PExpr {\n\n    public:\n      explicit PECastType(data_type_t*target, PExpr*base);\n      ~PECastType();\n\n      void dump(std::ostream &out) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     ivl_type_t type, unsigned flags) const;\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid, unsigned flags) const;\n\n      virtual bool has_aa_term(Design *des, NetScope *scope) const;\n\n      virtual unsigned test_width(Design*des, NetScope*scope,\n\t\t\t\t  width_mode_t&mode);\n\n    private:\n      data_type_t* target_;\n      ivl_type_t target_type_;\n      PExpr* base_;\n};\n\n/*\n * Support the SystemVerilog sign cast.\n */\nclass PECastSign : public PExpr {\n\n    public:\n      explicit PECastSign(bool signed_flag, PExpr *base);\n      ~PECastSign() = default;\n\n      void dump(std::ostream &out) const;\n\n      NetExpr* elaborate_expr(Design *des, NetScope *scope,\n\t\t\t      unsigned expr_wid, unsigned flags) const;\n\n      virtual bool has_aa_term(Design *des, NetScope *scope) const;\n\n      unsigned test_width(Design *des, NetScope *scope, width_mode_t &mode);\n\n    private:\n      std::unique_ptr<PExpr> base_;\n};\n\n/*\n * This class is used for error recovery. All methods do nothing and return\n * null or default values.\n */\nclass PEVoid : public PExpr {\n\n    public:\n      explicit PEVoid();\n      ~PEVoid();\n\n      virtual NetExpr*elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid,\n                                     unsigned flags) const;\n};\n\n#endif /* IVL_PExpr_H */\n"
        },
        {
          "name": "PFunction.cc",
          "type": "blob",
          "size": 2.6201171875,
          "content": "/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"PTask.h\"\n# include \"Statement.h\"\n# include \"ivl_assert.h\"\n\nusing namespace std;\n\nPFunction::PFunction(perm_string name, LexicalScope*parent, bool is_auto__)\n: PTaskFunc(name, parent), statement_(0)\n{\n      is_auto_ = is_auto__;\n      return_type_ = 0;\n}\n\nPFunction::~PFunction()\n{\n}\n\nvoid PFunction::set_statement(Statement*s)\n{\n      ivl_assert(*this, s != 0);\n      ivl_assert(*this, statement_ == 0);\n      statement_ = s;\n}\n\nvoid PFunction::push_statement_front(Statement*stmt)\n{\n        // This should not be possible.\n      ivl_assert(*this, statement_);\n\n\t// Get the PBlock of the statement. If it is not a PBlock,\n\t// then create one to wrap the existing statement and the new\n\t// statement that we're pushing.\n      PBlock*blk = dynamic_cast<PBlock*> (statement_);\n      if (blk == 0) {\n\t    PBlock*tmp = new PBlock(PBlock::BL_SEQ);\n\t    tmp->set_line(*this);\n\t    vector<Statement*>tmp_list(1);\n\t    tmp_list[0] = statement_;\n\t    tmp->set_statement(tmp_list);\n\n\t    statement_ = tmp;\n\t    blk = tmp;\n      }\n\n\t// Now do the push.\n      blk->push_statement_front(stmt);\n}\n\nvoid PFunction::set_return(data_type_t*t)\n{\n      return_type_ = t;\n}\n\nPChainConstructor* PFunction::extract_chain_constructor()\n{\n      PChainConstructor*res = 0;\n\n      if ((res = dynamic_cast<PChainConstructor*> (statement_))) {\n\t    statement_ = new PBlock(PBlock::BL_SEQ);\n\t    statement_->set_line(*this);\n\n      } else if (PBlock*blk = dynamic_cast<PBlock*>(statement_)) {\n\t    res = blk->extract_chain_constructor();\n      }\n\n      return res;\n}\n\nPNamedItem::SymbolType PFunction::symbol_type() const\n{\n      return FUNCTION;\n}\n\n\nPLet::PLet(perm_string name, LexicalScope*parent, list<let_port_t*>*ports,\n           PExpr*expr)\n: PTaskFunc(name, parent), ports_(ports), expr_(expr)\n{\n}\n\nPLet::~PLet()\n{\n}\n"
        },
        {
          "name": "PGate.cc",
          "type": "blob",
          "size": 5.9365234375,
          "content": "/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"PGate.h\"\n# include  \"PExpr.h\"\n# include  \"verinum.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nvoid PGate::set_pins_(list<PExpr*>*pins)\n{\n      ivl_assert(*this, pins);\n      ivl_assert(*this, pins->size() == pins_.size());\n\n      for (size_t idx = 0 ; idx < pins_.size() ; idx += 1) {\n\t    pins_[idx] = pins->front();\n\t    pins->pop_front();\n      }\n\n      ivl_assert(*this, pins->empty());\n      delete pins;\n}\n\nPGate::PGate(perm_string name, list<PExpr*>*pins, const list<PExpr*>*del)\n: name_(name), pins_(pins? pins->size() : 0), ranges_(0)\n{\n      if (pins) set_pins_(pins);\n      if (del) delay_.set_delays(del);\n      str0_ = IVL_DR_STRONG;\n      str1_ = IVL_DR_STRONG;\n}\n\nPGate::PGate(perm_string name, list<PExpr*>*pins, PExpr*del)\n: name_(name), pins_(pins? pins->size() : 0), ranges_(0)\n{\n      if (pins) set_pins_(pins);\n      if (del) delay_.set_delay(del);\n      str0_ = IVL_DR_STRONG;\n      str1_ = IVL_DR_STRONG;\n}\n\nPGate::PGate(perm_string name, list<PExpr*>*pins)\n: name_(name), pins_(pins? pins->size() : 0), ranges_(0)\n{\n      if (pins) set_pins_(pins);\n      str0_ = IVL_DR_STRONG;\n      str1_ = IVL_DR_STRONG;\n}\n\nPGate::~PGate()\n{\n}\n\nvoid PGate::set_ranges(list<pform_range_t>*ranges)\n{\n      ivl_assert(*this, ranges_ == 0);\n      ranges_ = ranges;\n}\n\nivl_drive_t PGate::strength0() const\n{\n      return str0_;\n}\n\nvoid PGate::strength0(ivl_drive_t s)\n{\n      str0_ = s;\n}\n\nivl_drive_t PGate::strength1() const\n{\n      return str1_;\n}\n\nvoid PGate::strength1(ivl_drive_t s)\n{\n      str1_ = s;\n}\n\nvoid PGate::elaborate_scope(Design*, NetScope*) const\n{\n}\n\n/*\n * This method is used during elaboration to calculate the\n * rise/fall/decay times for the gate. These values were set in pform\n * by the constructor, so here I evaluate the expression in the given\n * design context and save the calculated delays into the output\n * parameters. This method understands how to handle the different\n * numbers of expressions.\n */\n\nvoid PGate::eval_delays(Design*des, NetScope*scope,\n\t\t\tNetExpr*&rise_expr,\n\t\t\tNetExpr*&fall_expr,\n\t\t\tNetExpr*&decay_expr,\n\t\t\tbool as_net_flag) const\n{\n      delay_.eval_delays(des, scope,\n\t\t\t rise_expr, fall_expr, decay_expr,\n\t\t\t as_net_flag);\n}\n\nunsigned PGate::delay_count() const\n{\n      return delay_.delay_count();\n}\n\nPNamedItem::SymbolType PGate::symbol_type() const\n{\n      return INSTANCE;\n}\n\nPGAssign::PGAssign(list<PExpr*>*pins)\n: PGate(perm_string(), pins)\n{\n      ivl_assert(*this, pin_count() == 2);\n}\n\nPGAssign::PGAssign(list<PExpr*>*pins, list<PExpr*>*dels)\n: PGate(perm_string(), pins, dels)\n{\n      ivl_assert(*this, pin_count() == 2);\n}\n\nPGAssign::~PGAssign()\n{\n}\n\nPGBuiltin::PGBuiltin(Type t, perm_string name,\n\t\t     list<PExpr*>*pins,\n\t\t     list<PExpr*>*del)\n: PGate(name, pins, del), type_(t)\n{\n}\n\nPGBuiltin::PGBuiltin(Type t, perm_string name,\n\t\t     list<PExpr*>*pins,\n\t\t     PExpr*del)\n: PGate(name, pins, del), type_(t)\n{\n}\n\n\nPGBuiltin::~PGBuiltin()\n{\n}\n\nconst char* PGBuiltin::gate_name() const\n{\n      switch(type_) {\n\tcase AND:\n\t    return \"AND\";\n\t    break;\n\tcase NAND:\n\t    return \"NAND\";\n\t    break;\n\n\tcase OR:\n\t    return \"OR\";\n\t    break;\n\tcase NOR:\n\t    return \"NOR\";\n\t    break;\n\n\tcase XOR:\n\t    return \"XOR\";\n\t    break;\n\tcase XNOR:\n\t    return \"XNOR\";\n\t    break;\n\n\tcase BUF:\n\t    return \"BUF\";\n\t    break;\n\tcase NOT:\n\t    return \"NOT\";\n\t    break;\n\n\tcase BUFIF0:\n\t    return \"BUFIF0\";\n\t    break;\n\tcase NOTIF0:\n\t    return \"NOTIF0\";\n\t    break;\n\n\tcase BUFIF1:\n\t    return \"BUFIF1\";\n\t    break;\n\tcase NOTIF1:\n\t    return \"NOTIF1\";\n\t    break;\n\n\tcase NMOS:\n\t    return \"NMOS\";\n\t    break;\n\tcase RNMOS:\n\t    return \"RNMOS\";\n\t    break;\n\n\tcase PMOS:\n\t    return \"PMOS\";\n\t    break;\n\tcase RPMOS:\n\t    return \"RPMOS\";\n\t    break;\n\n\tcase TRAN:\n\t    return \"TRAN\";\n\t    break;\n\tcase RTRAN:\n\t    return \"RTRAN\";\n\t    break;\n\n\tcase TRANIF0:\n\t    return \"TRANIF0\";\n\t    break;\n\tcase RTRANIF0:\n\t    return \"RTRANIF0\";\n\t    break;\n\n\tcase TRANIF1:\n\t    return \"TRANIF1\";\n\t    break;\n\tcase RTRANIF1:\n\t    return \"RTRANIF1\";\n\t    break;\n\n\tcase CMOS:\n\t    return \"CMOS\";\n\t    break;\n\tcase RCMOS:\n\t    return \"RCMOS\";\n\t    break;\n\n\tcase PULLUP:\n\t    return \"PULLUP\";\n\t    break;\n\tcase PULLDOWN:\n\t    return \"PULLDOWN\";\n\t    break;\n      }\n\n      return \"<unknown>\";\n}\n\nPGModule::PGModule(perm_string type, perm_string name, list<PExpr*>*pins)\n: PGate(name, pins), bound_type_(0), type_(type), overrides_(0), pins_(0),\n  npins_(0), parms_(0), nparms_(0)\n{\n}\n\nPGModule::PGModule(perm_string type, perm_string name,\n\t\t   named_pexpr_t *pins, unsigned npins)\n: PGate(name, 0), bound_type_(0), type_(type), overrides_(0), pins_(pins),\n  npins_(npins), parms_(0), nparms_(0)\n{\n}\n\nPGModule::PGModule(Module*type, perm_string name)\n: PGate(name, 0), bound_type_(type), overrides_(0), pins_(0),\n  npins_(0), parms_(0), nparms_(0)\n{\n}\n\nPGModule::~PGModule()\n{\n}\n\nvoid PGModule::set_parameters(list<PExpr*>*o)\n{\n      ivl_assert(*this, overrides_ == 0);\n      overrides_ = o;\n}\n\nvoid PGModule::set_parameters(named_pexpr_t *pa, unsigned npa)\n{\n      ivl_assert(*this, parms_ == 0);\n      ivl_assert(*this, overrides_ == 0);\n      parms_ = pa;\n      nparms_ = npa;\n}\n\nperm_string PGModule::get_type() const\n{\n      return type_;\n}\n"
        },
        {
          "name": "PGate.h",
          "type": "blob",
          "size": 8.482421875,
          "content": "#ifndef IVL_PGate_H\n#define IVL_PGate_H\n/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"StringHeap.h\"\n# include  \"named.h\"\n# include  \"PNamedItem.h\"\n# include  \"PDelays.h\"\n# include  \"netlist.h\"\n# include  <map>\n# include  <list>\n# include  <vector>\n# include  <string>\nclass PExpr;\nclass PUdp;\nclass Module;\n\n/*\n * A PGate represents a Verilog gate. The gate has a name and other\n * properties, and a set of pins that connect to wires. It is known at\n * the time a gate is constructed how many pins the gate has.\n *\n * This pins of a gate are connected to expressions. The elaboration\n * step will need to convert expressions to a network of gates in\n * order to elaborate expression inputs, but that can easily be done.\n *\n * The PGate base class also carries the strength0 and strength1\n * strengths for those gates where the driver[s] can be described by a\n * single strength pair. There is a strength of the 0 drive, and a\n * strength of the 1 drive.\n */\nclass PGate : public PNamedItem {\n\n    public:\n      explicit PGate(perm_string name, std::list<PExpr*>*pins,\n\t\t     const std::list<PExpr*>*del);\n\n      explicit PGate(perm_string name, std::list<PExpr*>*pins,\n\t\t     PExpr*del);\n\n      explicit PGate(perm_string name, std::list<PExpr*>*pins);\n\n      virtual ~PGate();\n\n      void set_ranges(std::list<pform_range_t>*ranges);\n      bool is_array() const { return ranges_ != 0; }\n\n      perm_string get_name() const { return name_; }\n\n\t// This evaluates the delays as far as possible, but returns\n\t// an expression, and do not signal errors.\n      void eval_delays(Design*des, NetScope*scope,\n\t\t       NetExpr*&rise_time,\n\t\t       NetExpr*&fall_time,\n\t\t       NetExpr*&decay_time,\n\t\t       bool as_net_flag =false) const;\n\n      unsigned delay_count() const;\n\n      unsigned pin_count() const { return pins_.size(); }\n      PExpr*pin(unsigned idx) const { return pins_[idx]; }\n\n      ivl_drive_t strength0() const;\n      ivl_drive_t strength1() const;\n\n      void strength0(ivl_drive_t);\n      void strength1(ivl_drive_t);\n\n      std::map<perm_string,PExpr*> attributes;\n\n      virtual void dump(std::ostream&out, unsigned ind =4) const;\n      virtual void elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*sc) const;\n      virtual bool elaborate_sig(Design*des, NetScope*scope) const;\n\n      SymbolType symbol_type() const;\n\n    protected:\n      const std::vector<PExpr*>& get_pins() const { return pins_; }\n\n      unsigned calculate_array_size_(Design*, NetScope*,\n\t\t\t\t     long&high, long&low) const;\n\n      void dump_pins(std::ostream&out) const;\n      void dump_delays(std::ostream&out) const;\n      void dump_ranges(std::ostream&out) const;\n\n    private:\n      perm_string name_;\n      PDelays delay_;\n      std::vector<PExpr*>pins_;\n\n      std::list<pform_range_t>*ranges_;\n\n      ivl_drive_t str0_, str1_;\n\n      void set_pins_(std::list<PExpr*>*pins);\n\n    private: // not implemented\n      PGate(const PGate&);\n      PGate& operator= (const PGate&);\n};\n\n/* A continuous assignment has a single output and a single input. The\n   input is passed directly to the output. This is different from a\n   BUF because elaboration may need to turn this into a vector of\n   gates. */\nclass PGAssign  : public PGate {\n\n    public:\n      explicit PGAssign(std::list<PExpr*>*pins);\n      explicit PGAssign(std::list<PExpr*>*pins, std::list<PExpr*>*dels);\n      ~PGAssign();\n\n      void dump(std::ostream&out, unsigned ind =4) const;\n      virtual void elaborate(Design*des, NetScope*scope) const;\n      virtual bool elaborate_sig(Design*des, NetScope*scope) const;\n\n    private:\n      void elaborate_unpacked_array_(Design*des, NetScope*scope, NetNet*lval) const;\n};\n\n\n/*\n * The Builtin class is specifically a gate with one of the builtin\n * types. The parser recognizes these types during parse. These types\n * have special properties that allow them to be treated specially.\n *\n * A PGBuiltin can be grouped into an array of devices. If this is\n * done, the msb_ and lsb_ are set to the indices of the array\n * range. Elaboration causes a gate to be created for each element of\n * the array, and a name will be generated for each gate.\n */\nclass PGBuiltin  : public PGate {\n\n    public:\n      enum Type { AND, NAND, OR, NOR, XOR, XNOR, BUF, BUFIF0, BUFIF1,\n\t\t  NOT, NOTIF0, NOTIF1, PULLDOWN, PULLUP, NMOS, RNMOS,\n\t\t  PMOS, RPMOS, CMOS, RCMOS, TRAN, RTRAN, TRANIF0,\n\t\t  TRANIF1, RTRANIF0, RTRANIF1 };\n\n    public:\n      explicit PGBuiltin(Type t, perm_string name,\n\t\t\t std::list<PExpr*>*pins,\n\t\t\t std::list<PExpr*>*del);\n      explicit PGBuiltin(Type t, perm_string name,\n\t\t\t std::list<PExpr*>*pins,\n\t\t\t PExpr*del);\n      ~PGBuiltin();\n\n      Type type() const { return type_; }\n      const char * gate_name() const;\n\n      virtual void dump(std::ostream&out, unsigned ind =4) const;\n      virtual void elaborate(Design*, NetScope*scope) const;\n      virtual bool elaborate_sig(Design*des, NetScope*scope) const;\n\n    private:\n      void calculate_gate_and_lval_count_(unsigned&gate_count,\n                                          unsigned&lval_count) const;\n\n      NetNode* create_gate_for_output_(Design*, NetScope*,\n\t\t\t\t       perm_string gate_name,\n\t\t\t\t       unsigned instance_width) const;\n\n      bool check_delay_count(Design*des) const;\n\n      Type type_;\n};\n\n/*\n * This kind of gate is an instantiation of a module. The stored type\n * is the name of a module definition somewhere in the pform. This\n * type also handles UDP devices, because it is generally not known at\n * parse time whether a name belongs to a module or a UDP.\n */\nclass PGModule  : public PGate {\n\n    public:\n\t// The name is the *instance* name of the gate.\n\n\t// If the binding of ports is by position, this constructor\n\t// builds everything all at once.\n      explicit PGModule(perm_string type, perm_string name,\n\t\t\tstd::list<PExpr*>*pins);\n\n\t// If the binding of ports is by name, this constructor takes\n\t// the bindings and stores them for later elaboration.\n      explicit PGModule(perm_string type, perm_string name,\n\t\t\tnamed_pexpr_t *pins, unsigned npins);\n\n\t// If the module type is known by design, then use this\n\t// constructor.\n      explicit PGModule(Module*type, perm_string name);\n\n      ~PGModule();\n\n\t// Parameter overrides can come as an ordered list, or a set\n\t// of named expressions.\n      void set_parameters(std::list<PExpr*>*o);\n      void set_parameters(named_pexpr_t *pa, unsigned npa);\n\n      std::map<perm_string,PExpr*> attributes;\n\n      virtual void dump(std::ostream&out, unsigned ind =4) const;\n      virtual void elaborate(Design*, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*sc) const;\n      virtual bool elaborate_sig(Design*des, NetScope*scope) const;\n\n\t// This returns the module name of this module. It is a\n\t// permallocated string.\n      perm_string get_type() const;\n\n    private:\n      Module*bound_type_;\n      perm_string type_;\n      std::list<PExpr*>*overrides_;\n      named_pexpr_t *pins_;\n      unsigned npins_;\n\n\t// These members support parameter override by name\n      named_pexpr_t *parms_;\n      unsigned nparms_;\n\n      friend class delayed_elaborate_scope_mod_instances;\n      void elaborate_mod_(Design*, Module*mod, NetScope*scope) const;\n      void elaborate_udp_(Design*, PUdp  *udp, NetScope*scope) const;\n      void elaborate_scope_mod_(Design*des, Module*mod, NetScope*sc) const;\n      void elaborate_scope_mod_instances_(Design*des, Module*mod, NetScope*sc) const;\n      bool elaborate_sig_mod_(Design*des, NetScope*scope, Module*mod) const;\n\t// Not currently used.\n#if 0\n      bool elaborate_sig_udp_(Design*des, NetScope*scope, PUdp*udp) const;\n#endif\n\n      NetNet*resize_net_to_port_(Design*des, NetScope*scope,\n\t\t\t\t NetNet*sig, unsigned port_wid,\n\t\t\t\t NetNet::PortType dir, bool as_signed) const;\n};\n\n#endif /* IVL_PGate_H */\n"
        },
        {
          "name": "PGenerate.cc",
          "type": "blob",
          "size": 1.90625,
          "content": "/*\n * Copyright (c) 2006-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PGenerate.h\"\n# include  \"PWire.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nPGenerate::PGenerate(LexicalScope*parent, unsigned id)\n: LexicalScope(parent), id_number(id)\n{\n      scheme_type = GS_NONE;\n      directly_nested = false;\n      local_index = false;\n      loop_init = 0;\n      loop_test = 0;\n      loop_step = 0;\n}\n\nPGenerate::~PGenerate()\n{\n}\n\nvoid PGenerate::add_gate(PGate*gate)\n{\n      gates.push_back(gate);\n}\n\nostream& operator << (ostream&out, PGenerate::scheme_t type)\n{\n      switch (type) {\n\t  case PGenerate::GS_NONE:\n\t    out << \"GS_NONE\";\n\t    break;\n\t  case PGenerate::GS_LOOP:\n\t    out << \"GS_LOOP\";\n\t    break;\n\t  case PGenerate::GS_CONDIT:\n\t    out << \"GS_CONDIT\";\n\t    break;\n\t  case PGenerate::GS_ELSE:\n\t    out << \"GS_ELSE\";\n\t    break;\n\t  case PGenerate::GS_CASE:\n\t    out << \"GS_CASE\";\n\t    break;\n\t  case PGenerate::GS_CASE_ITEM:\n\t    out << \"GS_CASE_ITEM\";\n\t    break;\n\t  case PGenerate::GS_NBLOCK:\n\t    out << \"GS_NBLOCK\";\n\t    break;\n      }\n      return out;\n}\n\nPNamedItem::SymbolType PGenerate::symbol_type() const\n{\n      return GENBLOCK;\n}\n"
        },
        {
          "name": "PGenerate.h",
          "type": "blob",
          "size": 4.7919921875,
          "content": "#ifndef IVL_PGenerate_H\n#define IVL_PGenerate_H\n/*\n * Copyright (c) 2006-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PNamedItem.h\"\n# include  \"StringHeap.h\"\n# include  \"HName.h\"\n# include  \"PScope.h\"\n# include  <list>\n# include  <map>\n# include  <valarray>\n# include  \"pform_types.h\"\n\nclass Design;\nclass NetScope;\nclass PExpr;\nclass PFunction;\nclass PProcess;\nclass PTask;\nclass PGate;\nclass PWire;\n\n/*\n * This represents a generate scheme. The interpretation of the\n * members depends on the scheme_type.\n *\n * GS_LOOP\n *\n * GS_CASE\n *    loop_test is the expression to be compared.\n *    generates contains only GS_CASE_ITEM schemes.\n * GS_CASE_ITEM\n *    The parent points to the GS_CASE that contains this item.\n *    the loop_test is compared with the parent->loop_test expression.\n */\nclass PGenerate : public PNamedItem, public LexicalScope {\n\n    public:\n      explicit PGenerate(LexicalScope*parent, unsigned id_number);\n      ~PGenerate();\n\n\t// Generate schemes have an ID number, for when the scope is\n\t// implicit.\n      const unsigned id_number;\n      perm_string scope_name;\n\n\t// This is used during parsing to stack lexical scopes within\n\t// this generate scheme.\n//      LexicalScope*lexical_scope;\n\n      enum scheme_t {GS_NONE, GS_LOOP, GS_CONDIT, GS_ELSE,\n\t\t     GS_CASE, GS_CASE_ITEM, GS_NBLOCK};\n      scheme_t scheme_type;\n\n      bool directly_nested;\n\n\t// generate loops have an index variable and three\n\t// expressions: for (index = <init>; <test>; index=<step>)\n\t// the index is local if it was declared in the init expression,\n\t// e.g. for (genvar index = <init>; <test>; index=<step>)\n      bool local_index;\n      perm_string loop_index;\n      PExpr*loop_init;\n      PExpr*loop_test;\n      PExpr*loop_step;\n\t// Case items may have multiple guard expression values. It is\n\t// enough for any on of the guards to match the case statement\n\t// test value.\n      std::valarray<PExpr*> item_test;\n\n\t// defparam assignments found in this scope.\n      typedef std::pair<pform_name_t,PExpr*> named_expr_t;\n      std::list<named_expr_t>defparms;\n\n      std::list<PGate*> gates;\n      void add_gate(PGate*);\n\n\t// Tasks instantiated within this scheme.\n      std::map<perm_string,PTask*> tasks;\n      std::map<perm_string,PFunction*>funcs;\n\n\t// Generate schemes can contain further generate schemes.\n      std::list<PGenerate*> generate_schemes;\n//      PGenerate*parent;\n\n\t// This method is called by the elaboration of a module to\n\t// generate scopes. the container is the scope that is to\n\t// contain the generated scope.\n      bool generate_scope(Design*des, NetScope*container);\n\n\t// Elaborate signals within any of the generated scopes that\n\t// were made by this generate block within the given container scope.\n      bool elaborate_sig(Design*des, NetScope*container) const;\n      bool elaborate(Design*des, NetScope*container) const;\n\n      void dump(std::ostream&out, unsigned indent) const;\n\n      SymbolType symbol_type() const;\n\n    private:\n      void check_for_valid_genvar_value_(long value);\n      bool generate_scope_loop_(Design*des, NetScope*container);\n      bool generate_scope_condit_(Design*des, NetScope*container, bool else_flag);\n      bool generate_scope_case_(Design*des, NetScope*container);\n      bool generate_scope_nblock_(Design*des, NetScope*container);\n\n\t// Elaborate_scope within a generated scope.\n      void elaborate_subscope_(Design*des, NetScope*scope);\n      void elaborate_subscope_direct_(Design*des, NetScope*scope);\n\n\t// These are the scopes created by generate_scope.\n      std::list<NetScope*>scope_list_;\n\t// internal function called on each scope generated by this scheme.\n      bool elaborate_sig_(Design*des, NetScope*scope) const;\n      bool elaborate_sig_direct_(Design*des, NetScope*scope) const;\n      bool elaborate_(Design*des, NetScope*scope) const;\n      bool elaborate_direct_(Design*des, NetScope*scope) const;\n\n    private: // not implemented\n      PGenerate(const PGenerate&);\n      PGenerate& operator= (const PGenerate&);\n};\n\nextern std::ostream& operator << (std::ostream&, PGenerate::scheme_t);\n\n#endif /* IVL_PGenerate_H */\n"
        },
        {
          "name": "PModport.cc",
          "type": "blob",
          "size": 1.033203125,
          "content": "/*\n * Copyright (c) 2015-2019 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"PModport.h\"\n\nPModport::PModport(perm_string n)\n: name_(n)\n{\n}\n\nPModport::~PModport()\n{\n}\n\nPNamedItem::SymbolType PModport::symbol_type() const\n{\n      return MODPORT;\n}\n"
        },
        {
          "name": "PModport.h",
          "type": "blob",
          "size": 1.6630859375,
          "content": "#ifndef IVL_PModport_H\n#define IVL_PModport_H\n/*\n * Copyright (c) 2015-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PNamedItem.h\"\n# include  \"PScope.h\"\n# include  \"StringHeap.h\"\n# include  \"netlist.h\"\n# include  <vector>\n\n/*\n * The PModport class represents a parsed SystemVerilog modport list.\n */\nclass PModport : public PNamedItem {\n\n    public:\n\t// The name is a perm-allocated string. It is the simple name\n\t// of the modport, without any scope.\n      explicit PModport(perm_string name);\n      ~PModport();\n\n      perm_string name() const { return name_; }\n\n      typedef std::pair <NetNet::PortType,PExpr*> simple_port_t;\n      std::map<perm_string,simple_port_t> simple_ports;\n\n      SymbolType symbol_type() const;\n\n    private:\n      perm_string name_;\n\n    private: // not implemented\n      PModport(const PModport&);\n      PModport& operator= (const PModport&);\n};\n\n#endif /* IVL_PModport_H */\n"
        },
        {
          "name": "PNamedItem.cc",
          "type": "blob",
          "size": 2.958984375,
          "content": "/*\n * Copyright (c) 2019 Martin Whitaker (icarus@martin-whitaker.me.uk)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PNamedItem.h\"\n# include  <ostream>\n\nPNamedItem::PNamedItem()\n{\n}\n\nPNamedItem::~PNamedItem()\n{\n}\n\nPNamedItem::SymbolType PNamedItem::symbol_type() const\n{\n      return ANY;\n}\n\nstd::ostream& operator << (std::ostream&o, PNamedItem::SymbolType st)\n{\n      switch (st) {\n          case PNamedItem::ANY:\n            o << \"a symbol\";\n            break;\n          case PNamedItem::PARAM:\n            o << \"a parameter\";\n            break;\n          case PNamedItem::NET:\n            o << \"a net\";\n            break;\n          case PNamedItem::VAR:\n            o << \"a variable\";\n            break;\n          case PNamedItem::GENVAR:\n            o << \"a genvar\";\n            break;\n          case PNamedItem::EVENT:\n            o << \"an event\";\n            break;\n          case PNamedItem::TYPE:\n            o << \"a type\";\n            break;\n          case PNamedItem::ENUM:\n            o << \"an enum type or value\";\n            break;\n          case PNamedItem::CLASS:\n            o << \"a class\";\n            break;\n          case PNamedItem::FUNCTION:\n            o << \"a function\";\n            break;\n          case PNamedItem::TASK:\n            o << \"a task\";\n            break;\n          case PNamedItem::BLOCK:\n            o << \"a named block\";\n            break;\n          case PNamedItem::GENBLOCK:\n            o << \"a generate block\";\n            break;\n          case PNamedItem::MODPORT:\n            o << \"a modport\";\n            break;\n          case PNamedItem::PACKAGE:\n            o << \"a package\";\n            break;\n          case PNamedItem::MODULE:\n            o << \"a module\";\n            break;\n          case PNamedItem::PROGRAM:\n            o << \"a program\";\n            break;\n          case PNamedItem::INTERFACE:\n            o << \"an interface\";\n            break;\n          case PNamedItem::PRIMITIVE:\n            o << \"a primitive\";\n            break;\n          case PNamedItem::INSTANCE:\n            o << \"an instance name\";\n            break;\n          default:\n            break;\n      }\n      return o;\n}\n\nPGenvar::PGenvar()\n{\n}\n\nPGenvar::~PGenvar()\n{\n}\n\nPNamedItem::SymbolType PGenvar::symbol_type() const\n{\n      return GENVAR;\n}\n"
        },
        {
          "name": "PNamedItem.h",
          "type": "blob",
          "size": 1.7998046875,
          "content": "#ifndef IVL_PNamedItem_H\n#define IVL_PNamedItem_H\n/*\n * Copyright (c) 2019 Martin Whitaker (icarus@martin-whitaker.me.uk)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"LineInfo.h\"\n\n/*\n * The PNamedItem class is the base class for all items that can be added\n * to a scope's local symbol map.\n */\nclass PNamedItem : virtual public LineInfo {\n\n    public:\n      enum SymbolType { ANY, PARAM, NET, VAR, GENVAR, EVENT, TYPE, ENUM,\n                        CLASS, FUNCTION, TASK, BLOCK, GENBLOCK, MODPORT,\n                        PACKAGE, MODULE, PROGRAM, INTERFACE, PRIMITIVE,\n                        INSTANCE };\n\n      explicit PNamedItem();\n      virtual ~PNamedItem();\n\n      virtual SymbolType symbol_type() const;\n};\n\nextern std::ostream& operator << (std::ostream&, PNamedItem::SymbolType);\n\n/*\n * The PGenvar class represents a genvar. This is only used to represent\n * genvar in a scope's local symbol map.\n */\nclass PGenvar : public PNamedItem {\n\n    public:\n      explicit PGenvar();\n      virtual ~PGenvar();\n\n      SymbolType symbol_type() const;\n};\n\n#endif /* IVL_PNamedItem_H */\n"
        },
        {
          "name": "PPackage.cc",
          "type": "blob",
          "size": 1.0283203125,
          "content": "/*\n * Copyright (c) 2012 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PPackage.h\"\n\nPPackage::PPackage(perm_string name, LexicalScope*parent)\n: PScopeExtra(name, parent)\n{\n}\n\nPPackage::~PPackage()\n{\n}\n"
        },
        {
          "name": "PPackage.h",
          "type": "blob",
          "size": 1.708984375,
          "content": "#ifndef IVL_PPackage_H\n#define IVL_PPackage_H\n/*\n * Copyright (c) 2012-2014 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PScope.h\"\n# include  \"LineInfo.h\"\n# include  \"StringHeap.h\"\n# include  <iostream>\n# include  <vector>\n\n/*\n * SystemVerilog supports class declarations with their own lexical\n * scope, etc. The parser arranges for these to be created and\n * collected.\n */\n\nclass PPackage : public PScopeExtra, public LineInfo {\n\n    public:\n      explicit PPackage (perm_string name, LexicalScope*parent);\n      ~PPackage();\n\n      bool elaborate_scope(Design*des, NetScope*scope);\n      bool elaborate_sig(Design*des, NetScope*scope) const;\n      bool elaborate(Design*des, NetScope*scope) const;\n\n      void pform_dump(std::ostream&out) const;\n\n      struct export_t {\n\t    PPackage *pkg;\n\t    perm_string name;\n      };\n\n      std::vector<export_t> exports;\n};\n\n#endif /* IVL_PPackage_H */\n"
        },
        {
          "name": "PScope.cc",
          "type": "blob",
          "size": 1.779296875,
          "content": "/*\n * Copyright (c) 2008-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PScope.h\"\n\nusing namespace std;\n\nbool LexicalScope::var_init_needs_explicit_lifetime() const\n{\n      return false;\n}\n\nPWire* LexicalScope::wires_find(perm_string name)\n{\n      map<perm_string,PWire*>::const_iterator cur = wires.find(name);\n      if (cur == wires.end())\n\t    return 0;\n      else\n\t    return (*cur).second;\n}\n\nPNamedItem::SymbolType LexicalScope::param_expr_t::symbol_type() const\n{\n      return PARAM;\n}\n\nPScope::PScope(perm_string n, LexicalScope*parent)\n: LexicalScope(parent), name_(n)\n{\n      time_unit = 0;\n      time_precision = 0;\n      time_unit_is_default = true;\n      time_prec_is_default = true;\n}\n\nPScope::~PScope()\n{\n    for(typedef_map_t::iterator it = typedefs.begin(); it != typedefs.end();\n        ++it)\n        delete it->second;\n}\n\nPScopeExtra::PScopeExtra(perm_string n, LexicalScope*parent)\n: PScope(n, parent)\n{\n      time_unit_is_local = false;\n      time_prec_is_local = false;\n}\n\nPScopeExtra::~PScopeExtra()\n{\n}\n"
        },
        {
          "name": "PScope.h",
          "type": "blob",
          "size": 8.4423828125,
          "content": "#ifndef IVL_PScope_H\n#define IVL_PScope_H\n/*\n * Copyright (c) 2008-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PNamedItem.h\"\n# include  \"StringHeap.h\"\n# include  \"pform_types.h\"\n# include  \"ivl_target.h\"\n# include  <map>\n# include  <set>\n# include  <unordered_set>\n# include  <vector>\n\nclass PEvent;\nclass PExpr;\nclass PFunction;\nclass PPackage;\nclass AProcess;\nclass PProcess;\nclass PClass;\nclass PTask;\nclass PWire;\nclass Statement;\nclass PCallTask;\n\nclass Design;\nclass NetScope;\n\n/*\n * The PScope class is a base representation of an object that\n * represents lexical scope. For example, a module, a function/task, a\n * named block is derived from a PScope.\n *\n * NOTE: This is not the same concept as the \"scope\" of an elaborated\n * hierarchy. That is represented by NetScope objects after elaboration.\n */\n\nclass LexicalScope {\n\n    public:\n      enum lifetime_t { INHERITED, STATIC, AUTOMATIC };\n\n      explicit LexicalScope(LexicalScope*parent)\n        : default_lifetime(INHERITED), has_parameter_port_list(false),\n\t  generate_counter(0), parent_(parent) { }\n\t// A virtual destructor is so that dynamic_cast can work.\n      virtual ~LexicalScope() { }\n\n      lifetime_t default_lifetime;\n\n\t// Symbols that are defined or declared in this scope.\n      std::map<perm_string,PNamedItem*>local_symbols;\n\n\t// Symbols that are explicitly imported. This contains the package where\n\t// the symbol has been decelared. When using exports, this might not be\n\t// the same as the package where it has been imported from.\n      std::map<perm_string,PPackage*>explicit_imports;\n        // Symbols that are explicitly imported. This contains the set of\n\t// packages from which the symbol has been imported. When using exports\n\t// the same identifier can be imported via multiple packages.\n      std::map<perm_string,std::unordered_set<PPackage*>> explicit_imports_from;\n\n\t// Packages that are wildcard imported. When identifiers from\n\t// these packages are referenced, they will be added to the\n\t// explicit imports (IEEE 1800-2012 26.3).\n      std::list<PPackage*>potential_imports;\n\n\t// A task or function call may reference a task or function defined\n\t// later in the scope. So here we stash the potential imports for\n\t// task and function calls. They will be added to the explicit\n\t// imports if we don't find a local definition.\n      std::map<perm_string,PPackage*>possible_imports;\n\n      struct range_t {\n\t      // True if this is an exclude\n\t    bool exclude_flag;\n\t      // lower bound\n\t      // If low_open_flag is false and low_expr=0, then use -inf\n\t    bool low_open_flag;\n\t    PExpr*low_expr;\n\t      // upper bound\n\t      // If high_open_flag is false and high_expr=0, then use +inf\n\t    bool high_open_flag;\n\t    PExpr*high_expr;\n\t      // Next range description in list\n\t    struct range_t*next;\n      };\n\n\t/* The scope has parameters that are evaluated when the scope\n\t   is elaborated. During parsing, I put the parameters into\n\t   this map. */\n      struct param_expr_t : public PNamedItem {\n            inline param_expr_t() : data_type(0), expr(0), range(0),\n\t\t\t\t    local_flag(false), overridable(true) { }\n\t      // Type information.\n\t    data_type_t*data_type;\n\t      // Value expression\n\t    PExpr*expr;\n\t      // If there are range constraints, list them here\n\t    range_t*range;\n\t      // Whether it is a local parameter\n\t    bool local_flag;\n\t      // Whether the parameter can be overridden\n\t    bool overridable;\n\t      // Whether the parameter is a type parameter\n\t    bool type_flag = false;\n\t      // The lexical position of the declaration\n\t    unsigned lexical_pos = 0;\n\n\t    SymbolType symbol_type() const;\n      };\n      std::map<perm_string,param_expr_t*>parameters;\n      bool has_parameter_port_list;\n\n\t// Defined types in the scope.\n      typedef std::map<perm_string,typedef_t*> typedef_map_t;\n      typedef_map_t typedefs;\n\n\t// Named events in the scope.\n      std::map<perm_string,PEvent*>events;\n\n\t// Nets and variables (wires) in the scope\n      std::map<perm_string,PWire*>wires;\n      PWire* wires_find(perm_string name);\n\n        // Genvars in the scope. These will only be present in module\n        // scopes, but are listed here to allow them to be found when\n        // creating implicit nets.\n      std::map<perm_string,LineInfo*> genvars;\n\n\t// Variable initializations in this scope\n      std::vector<Statement*> var_inits;\n\n\t// Behaviors (processes) in this scope\n      std::list<PProcess*> behaviors;\n      std::list<AProcess*> analog_behaviors;\n\n\t// The elaboration tasks in this scope\n      std::list<PCallTask*> elab_tasks;\n\n\t// Enumeration sets.\n      std::vector<enum_type_t*> enum_sets;\n\n        // A count of the generate constructs in this scope. This is\n        // used to automatically name unnamed generate blocks, as\n        // specified in the LRM.\n      unsigned generate_counter;\n\n      LexicalScope* parent_scope() const { return parent_; }\n\n      virtual bool var_init_needs_explicit_lifetime() const;\n\n    protected:\n      void dump_typedefs_(std::ostream&out, unsigned indent) const;\n\n      void dump_parameters_(std::ostream&out, unsigned indent) const;\n\n      void dump_enumerations_(std::ostream&out, unsigned indent) const;\n\n      void dump_events_(std::ostream&out, unsigned indent) const;\n\n      void dump_wires_(std::ostream&out, unsigned indent) const;\n\n      void dump_var_inits_(std::ostream&out, unsigned indent) const;\n\n      bool elaborate_var_inits_(Design*des, NetScope*scope) const;\n\n    private:\n      LexicalScope*parent_;\n};\n\nclass PScope : public LexicalScope {\n\n    public:\n\t// When created, a scope has a name and a parent. The name is\n\t// the name of the definition. For example, if this is a\n\t// module declaration, the name is the name after the \"module\"\n\t// keyword, and if this is a task scope, the name is the task\n\t// name. The parent is the lexical parent of this scope. Since\n\t// modules do not nest in Verilog, the parent must be nil for\n\t// modules. Scopes for tasks and functions point to their\n\t// containing module.\n      explicit PScope(perm_string name, LexicalScope*parent =0);\n      virtual ~PScope();\n\n      perm_string pscope_name() const { return name_; }\n\n\t/* These are the timescale for this scope. The value is\n\t   set by the `timescale directive or, in SystemVerilog,\n\t   by timeunit and timeprecision statements. */\n      int time_unit, time_precision;\n\n\t/* Flags used to support warnings about timescales. */\n      bool time_unit_is_default;\n      bool time_prec_is_default;\n\n      bool has_explicit_timescale() const {\n\t     return !(time_unit_is_default || time_prec_is_default);\n\t   }\n\n    protected:\n      bool elaborate_sig_wires_(Design*des, NetScope*scope) const;\n\n      bool elaborate_behaviors_(Design*des, NetScope*scope) const;\n\n    private:\n      perm_string name_;\n};\n\n/*\n * Some scopes can carry definitions. These include Modules and PClass\n * scopes. These derive from PScopeExtra so that they hold the maps of\n * extra definitions.\n */\nclass PScopeExtra : public PScope {\n\n    public:\n      explicit PScopeExtra(perm_string, LexicalScope*parent =0);\n      ~PScopeExtra();\n\n\t/* Task definitions within this module */\n      std::map<perm_string,PTask*> tasks;\n      std::map<perm_string,PFunction*> funcs;\n\t/* Class definitions within this module. */\n      std::map<perm_string,PClass*> classes;\n\t/* This is the lexical order of the classes, and is used by\n\t   elaboration to choose an elaboration order. */\n      std::vector<PClass*> classes_lexical;\n\n\t/* Flags used to support warnings about timescales. */\n      bool time_unit_is_local;\n      bool time_prec_is_local;\n\n    protected:\n      void dump_classes_(std::ostream&out, unsigned indent) const;\n      void dump_tasks_(std::ostream&out, unsigned indent) const;\n      void dump_funcs_(std::ostream&out, unsigned indent) const;\n};\n\n#endif /* IVL_PScope_H */\n"
        },
        {
          "name": "PSpec.cc",
          "type": "blob",
          "size": 1.2373046875,
          "content": "/*\n * Copyright (c) 2006-2011 Stephen Williams <steve@icarus.com>\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PSpec.h\"\n\nPSpecPath::PSpecPath(const std::list<perm_string> &src_list,\n\t\t     const std::list<perm_string> &dst_list,\n\t\t     char polarity, bool full_flag)\n: conditional(false), condition(0), edge(0),\n  src(src_list.begin(), src_list.end()), dst(dst_list.begin(), dst_list.end()),\n  data_source_expression(0)\n{\n      full_flag_ = full_flag;\n      polarity_ = polarity;\n}\n\nPSpecPath::~PSpecPath()\n{\n}\n"
        },
        {
          "name": "PSpec.h",
          "type": "blob",
          "size": 2.9267578125,
          "content": "#ifndef IVL_PSpec_H\n#define IVL_PSpec_H\n/*\n * Copyright (c) 2006-2014 Stephen Williams <steve@icarus.com>\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"LineInfo.h\"\n# include  \"StringHeap.h\"\n# include  <vector>\n# include  <list>\n\nclass PExpr;\n\n/*\n* The PSpecPath is the parse of a specify path, which is in its most\n* general form <path> = <delays>. The <delays> are collected into the\n* \"delays\" vector in all cases, and the variety is in the other\n* members.\n*\n* All paths also have a list of source names in the src vector, and a\n* list of destination names in the dst vector. These pairs are the\n* actual paths.\n*\n* If the path is a simple path, then:\n*      condition == nil\n*      edge == 0\n*      data_source_expression == nil\n*\n* If the path is conditional, then conditional == true and condition\n* is the condition expression. If the condition expression is nil,\n* then this is an ifnone conditional path.\n*\n* If data_source_expression != nil, then the path is edge sensitive\n* and the edge might not be 0.\n*\n* The full flag is used to verify that only vectors of the same size\n* are used in a parallel connection. Icarus always creates a full\n* connection between the source and destination. The polarity is for\n* informational (display) purposes only. The polarity is either '+',\n* '-' or 0.\n*/\nclass PSpecPath  : public LineInfo {\n\n    public:\n      PSpecPath(const std::list<perm_string> &src_list,\n\t        const std::list<perm_string> &dst_list,\n\t\tchar polarity, bool full_flag);\n      ~PSpecPath();\n\n      void elaborate(class Design*des, class NetScope*scope) const;\n\n      void dump(std::ostream&out, unsigned ind) const;\n\n    public:\n\t// Condition expression, if present.\n      bool conditional;\n      class PExpr* condition;\n\t// Edge specification (-1==negedge, 0 = no edge, 1==posedge)\n      int edge;\n\t// Is this a full connection.\n      bool full_flag_;\n\t// What is the polarity of the connection.\n      char polarity_;\n\t// Ordered set of source nodes of a path\n      std::vector<perm_string> src;\n\t// Ordered set of destination nodes of a path\n      std::vector<perm_string> dst;\n\t// Data source expression\n      class PExpr* data_source_expression;\n\n      std::vector<class PExpr*>delays;\n};\n\n#endif /* IVL_PSpec_H */\n"
        },
        {
          "name": "PTask.cc",
          "type": "blob",
          "size": 2.060546875,
          "content": "/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"PTask.h\"\n# include \"ivl_assert.h\"\n\nusing namespace std;\n\nPTaskFunc::PTaskFunc(perm_string n, LexicalScope*p)\n: PScope(n,p), this_type_(0), ports_(0)\n{\n}\n\nPTaskFunc::~PTaskFunc()\n{\n}\n\nbool PTaskFunc::var_init_needs_explicit_lifetime() const\n{\n      return default_lifetime == STATIC;\n}\n\nvoid PTaskFunc::set_ports(vector<pform_tf_port_t>*p)\n{\n      ivl_assert(*this, ports_ == 0);\n      ports_ = p;\n}\n\nvoid PTaskFunc::set_this(class_type_t*type, PWire*this_wire)\n{\n      ivl_assert(*this, this_type_ == 0);\n      this_type_ = type;\n\n\t// Push a synthesis argument that is the \"this\" value.\n      if (ports_==0)\n\t    ports_ = new vector<pform_tf_port_t>;\n\n      size_t use_size = ports_->size();\n      ports_->resize(use_size + 1);\n      for (size_t idx = use_size ; idx > 0 ; idx -= 1)\n\t    ports_->at(idx) = ports_->at(idx-1);\n\n      ports_->at(0) = pform_tf_port_t(this_wire);\n}\n\nPTask::PTask(perm_string name, LexicalScope*parent, bool is_auto__)\n: PTaskFunc(name, parent), statement_(0)\n{\n      is_auto_ = is_auto__;\n}\n\nPTask::~PTask()\n{\n}\n\nvoid PTask::set_statement(Statement*s)\n{\n      ivl_assert(*this, statement_ == 0);\n      statement_ = s;\n}\n\nPNamedItem::SymbolType PTask::symbol_type() const\n{\n      return TASK;\n}\n"
        },
        {
          "name": "PTask.h",
          "type": "blob",
          "size": 5.5361328125,
          "content": "#ifndef IVL_PTask_H\n#define IVL_PTask_H\n/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PScope.h\"\n# include  \"PNamedItem.h\"\n# include  \"StringHeap.h\"\n# include  <string>\n# include  <vector>\n# include  <list>\nclass Design;\nclass NetExpr;\nclass NetNet;\nclass NetScope;\nclass PChainConstructor;\nclass PWire;\nclass Statement;\nclass PExpr;\n\n\nclass PTaskFunc : public PScope, public PNamedItem {\n\n    public:\n      PTaskFunc(perm_string name, LexicalScope*parent);\n      ~PTaskFunc();\n\n      bool var_init_needs_explicit_lifetime() const;\n\n      void set_ports(std::vector<pform_tf_port_t>*p);\n\n      void set_this(class_type_t*use_type, PWire*this_wire);\n\n\t// If this task is a method of a class, this returns a pointer\n\t// to the class type.\n      inline class_type_t* method_of() const { return this_type_; }\n\n\n      virtual void elaborate_sig(Design*des, NetScope*scope) const =0;\n      virtual void elaborate(Design*des, NetScope*scope) const =0;\n\n      virtual void dump(std::ostream&, unsigned) const =0;\n\n    protected:\n\t// Elaborate the ports list. Write into the ports vector the\n\t// NetNet pointers for the ports, and write into the pdefs the\n\t// default value expressions, if any.\n      void elaborate_sig_ports_(Design*des, NetScope*scope,\n\t\t\t\tstd::vector<NetNet*>&ports,\n\t\t\t\tstd::vector<NetExpr*> &pdefs,\n\t\t\t\tstd::vector<perm_string> &port_names) const;\n\n      void dump_ports_(std::ostream&out, unsigned ind) const;\n\n    private:\n      class_type_t*this_type_;\n      std::vector<pform_tf_port_t>*ports_;\n};\n\n/*\n * The PTask holds the parsed definitions of a task.\n */\nclass PTask  : public PTaskFunc {\n\n    public:\n      explicit PTask(perm_string name, LexicalScope*parent, bool is_auto);\n      ~PTask();\n\n      void set_statement(Statement *s);\n\n\t// Tasks introduce scope, to need to be handled during the\n\t// scope elaboration pass. The scope passed is my scope,\n\t// created by the containing scope. I fill it in with stuff if\n\t// I need to.\n      void elaborate_scope(Design*des, NetScope*scope) const;\n\n\t// Bind the ports to the regs that are the ports.\n      void elaborate_sig(Design*des, NetScope*scope) const;\n\n\t// Elaborate the statement to finish off the task definition.\n      void elaborate(Design*des, NetScope*scope) const;\n\n      bool is_auto() const { return is_auto_; };\n\n      void dump(std::ostream&, unsigned) const;\n\n      SymbolType symbol_type() const;\n\n    private:\n      Statement*statement_;\n      bool is_auto_;\n\n    private: // Not implemented\n      PTask(const PTask&);\n      PTask& operator=(const PTask&);\n};\n\n/*\n * The function is similar to a task (in this context) but there is a\n * single output port and a set of input ports. The output port is the\n * function return value.\n *\n * The output value is not elaborated until elaborate_sig.\n */\nclass PFunction : public PTaskFunc {\n\n    public:\n      explicit PFunction(perm_string name, LexicalScope*parent, bool is_auto);\n      ~PFunction();\n\n      void set_statement(Statement *s);\n      void set_return(data_type_t*t);\n\n      inline Statement* get_statement() { return statement_; }\n\n\t// Push this statement to the front of the existing\n\t// definition. If the statement is a simple statement, make a\n\t// block to contain the statements.\n      void push_statement_front(Statement*stmt);\n\n\t// This is only used if this function is a constructor. In\n\t// that case, this method looks for a PChainConstructor in the\n\t// statement and extracts it if found.\n      PChainConstructor*extract_chain_constructor();\n\n      void elaborate_scope(Design*des, NetScope*scope) const;\n\n\t/* elaborate the ports and return value. */\n      void elaborate_sig(Design *des, NetScope*) const;\n\n\t/* Elaborate the behavioral statement. */\n      void elaborate(Design *des, NetScope*) const;\n\n      bool is_auto() const { return is_auto_; };\n\n      void dump(std::ostream&, unsigned) const;\n\n      SymbolType symbol_type() const;\n\n    private:\n      data_type_t* return_type_;\n      Statement *statement_;\n      bool is_auto_;\n};\n\n// A let is like a simple function that is expanded in the compiler\nclass PLet : public PTaskFunc {\n    public:\n      typedef struct let_port {\n\t    data_type_t*type_;\n\t    perm_string name_;\n\t    std::list<pform_range_t>*range_;\n\t    PExpr*def_;\n\n\t    void dump(std::ostream&, unsigned) const;\n      } let_port_t;\n\n// FIXME: Should the port list be a vector. Check once implemented completely\n      explicit PLet(perm_string name, LexicalScope*parent,\n                    std::list<let_port_t*>*ports, PExpr*expr);\n      ~PLet();\n\n      void elaborate_sig(Design*des, NetScope*scope) const { (void)des; (void)scope; }\n      void elaborate(Design*des, NetScope*scope) const { (void)des; (void)scope; }\n\n      void dump(std::ostream&, unsigned) const;\n\n    private:\n      std::list<let_port_t*>*ports_;\n      PExpr*expr_;\n};\n\n#endif /* IVL_PTask_H */\n"
        },
        {
          "name": "PTimingCheck.cc",
          "type": "blob",
          "size": 2.1416015625,
          "content": "/*\n * Copyright (c) 2006-2023 Stephen Williams <steve@icarus.com>\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PTimingCheck.h\"\n\nPRecRem::PRecRem(event_t* reference_event,\n      event_t* data_event,\n      PExpr* setup_limit,\n      PExpr* hold_limit,\n      pform_name_t* notifier,\n      PExpr* timestamp_cond,\n      PExpr* timecheck_cond,\n      pform_name_t* delayed_reference,\n      pform_name_t* delayed_data)\n      :\n      reference_event_ (reference_event),\n      data_event_ (data_event),\n      setup_limit_ (setup_limit),\n      hold_limit_ (hold_limit),\n      notifier_ (notifier),\n      timestamp_cond_ (timestamp_cond),\n      timecheck_cond_ (timecheck_cond),\n      delayed_reference_ (delayed_reference),\n      delayed_data_ (delayed_data)\n{\n}\n\nPRecRem::~PRecRem()\n{\n}\n\nPSetupHold::PSetupHold(event_t* reference_event,\n      event_t* data_event,\n      PExpr* setup_limit,\n      PExpr* hold_limit,\n      pform_name_t* notifier,\n      PExpr* timestamp_cond,\n      PExpr* timecheck_cond,\n      pform_name_t* delayed_reference,\n      pform_name_t* delayed_data)\n      :\n      reference_event_ (reference_event),\n      data_event_ (data_event),\n      setup_limit_ (setup_limit),\n      hold_limit_ (hold_limit),\n      notifier_ (notifier),\n      timestamp_cond_ (timestamp_cond),\n      timecheck_cond_ (timecheck_cond),\n      delayed_reference_ (delayed_reference),\n      delayed_data_ (delayed_data)\n{\n}\n\nPSetupHold::~PSetupHold()\n{\n}\n"
        },
        {
          "name": "PTimingCheck.h",
          "type": "blob",
          "size": 4.2041015625,
          "content": "#ifndef IVL_PTimingCheck_H\n#define IVL_PTimingCheck_H\n/*\n * Copyright (c) 2006-2023 Stephen Williams <steve@icarus.com>\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"LineInfo.h\"\n# include  \"PExpr.h\"\n# include  \"pform_types.h\"\n# include  <memory>\n\n/*\n* The PTimingCheck is the base class for all timing checks\n*/\nclass PTimingCheck  : public LineInfo {\n\n    public:\n      enum EdgeType {EDGE_01, EDGE_0X, EDGE_10, EDGE_1X, EDGE_X0, EDGE_X1};\n\n      struct event_t {\n        pform_name_t name;\n        bool posedge;\n        bool negedge;\n        std::vector<EdgeType> edges;\n        std::unique_ptr<PExpr> condition;\n      };\n\n      // This struct is used to parse the optional arguments\n      struct optional_args_t {\n        pform_name_t* notifier          = nullptr;\n        PExpr* timestamp_cond    = nullptr;\n        PExpr* timecheck_cond    = nullptr;\n        pform_name_t* delayed_reference = nullptr;\n        pform_name_t* delayed_data      = nullptr;\n        PExpr* event_based_flag         = nullptr;\n        PExpr* remain_active_flag       = nullptr;\n      };\n\n      PTimingCheck() { }\n      virtual ~PTimingCheck() { }\n\n      virtual void elaborate(class Design*des, class NetScope*scope) const = 0;\n\n      virtual void dump(std::ostream&out, unsigned ind) const = 0;\n};\n\n/*\n* The PRecRem is the parse of a $recrem timing check\n*/\nclass PRecRem : public PTimingCheck {\n\n    public:\n\n      PRecRem(event_t* reference_event,\n                    event_t* data_event,\n                    PExpr* setup_limit,\n                    PExpr* hold_limit,\n                    pform_name_t* notifier,\n                    PExpr* timestamp_cond,\n                    PExpr* timecheck_cond,\n                    pform_name_t* delayed_reference,\n                    pform_name_t* delayed_data);\n\n      ~PRecRem();\n\n      void elaborate(class Design*des, class NetScope*scope) const override;\n\n      void dump(std::ostream&out, unsigned ind) const override;\n\n    private:\n      std::unique_ptr<event_t> reference_event_;\n      std::unique_ptr<event_t> data_event_;\n\n      std::unique_ptr<PExpr> setup_limit_;\n      std::unique_ptr<PExpr> hold_limit_;\n\n      std::unique_ptr<pform_name_t> notifier_;\n\n      std::unique_ptr<PExpr> timestamp_cond_;\n      std::unique_ptr<PExpr> timecheck_cond_;\n\n      std::unique_ptr<pform_name_t> delayed_reference_;\n      std::unique_ptr<pform_name_t> delayed_data_;\n};\n\n/*\n* The PSetupHold is the parse of a $setuphold timing check\n*/\nclass PSetupHold : public PTimingCheck {\n\n    public:\n      PSetupHold(event_t* reference_event,\n                    event_t* data_event,\n                    PExpr* setup_limit,\n                    PExpr* hold_limit,\n                    pform_name_t* notifier,\n                    PExpr* timestamp_cond,\n                    PExpr* timecheck_cond,\n                    pform_name_t* delayed_reference,\n                    pform_name_t* delayed_data);\n\n      ~PSetupHold();\n\n      void elaborate(class Design*des, class NetScope*scope) const override;\n\n      void dump(std::ostream&out, unsigned ind) const override;\n\n    private:\n      std::unique_ptr<event_t> reference_event_;\n      std::unique_ptr<event_t> data_event_;\n\n      std::unique_ptr<PExpr> setup_limit_;\n      std::unique_ptr<PExpr> hold_limit_;\n\n      std::unique_ptr<pform_name_t> notifier_;\n\n      std::unique_ptr<PExpr> timestamp_cond_;\n      std::unique_ptr<PExpr> timecheck_cond_;\n\n      std::unique_ptr<pform_name_t> delayed_reference_;\n      std::unique_ptr<pform_name_t> delayed_data_;\n};\n\n#endif /* IVL_PTimingCheck_H */\n"
        },
        {
          "name": "PUdp.cc",
          "type": "blob",
          "size": 1.1572265625,
          "content": "/*\n * Copyright (c) 2003-2004 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PUdp.h\"\n\nPUdp::PUdp(perm_string n, unsigned nports)\n: ports(nports), sequential(false), initial(verinum::Vx), name_(n)\n{\n}\n\nunsigned PUdp::find_port(const char*name)\n{\n      for (unsigned idx = 0 ;  idx < ports.size() ;  idx += 1) {\n\n\t    if (ports[idx] == name)\n\t\t  return idx;\n      }\n\n      return ports.size();\n}\n\n"
        },
        {
          "name": "PUdp.h",
          "type": "blob",
          "size": 2.3779296875,
          "content": "#ifndef IVL_PUdp_H\n#define IVL_PUdp_H\n/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@picturel.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <map>\n# include  <vector>\n# include  \"LineInfo.h\"\n# include  \"StringHeap.h\"\n# include  \"verinum.h\"\n\nclass PExpr;\n\n/*\n * This class represents a parsed UDP. This is a much simpler object\n * than a module or macromodule.\n *\n *   - all ports are scalar,\n *   - pin 0 (the first port) is always output,\n *     and the remaining pins are input.\n *\n * Thus, the ports can be represented as an ordered list of pin names.\n * If the output port is declared as a register in the Verilog source,\n * then this is a sequential UDP and the sequential flag is set to true.\n *\n * STATE TABLE\n * Each entry in the state table is given as a string with the same\n * number of characters as inputs. If the UDP is sequential, a\n * character is also included at the end of the string to represent\n * the current output.\n *\n * If the UDP is sequential, the \"initial\" member is taken to be the\n * initial value assigned in the source, or 'x' if none is given.\n */\nclass PUdp : public LineInfo {\n\n    public:\n      explicit PUdp(perm_string n, unsigned nports);\n\n      std::vector<std::string> ports;\n      unsigned find_port(const char*name);\n\n      bool sequential;\n\n      std::vector<std::string> tinput;\n      std::vector<char> tcurrent;\n      std::vector<char> toutput;\n\n      verinum::V initial;\n\n      std::map<std::string,PExpr*> attributes;\n\n      void dump(std::ostream&out) const;\n\n      perm_string name_;\n    private:\n\n    private: // Not implemented\n      PUdp(const PUdp&);\n      PUdp& operator= (const PUdp&);\n};\n\n#endif /* IVL_PUdp_H */\n"
        },
        {
          "name": "PWire.cc",
          "type": "blob",
          "size": 4.5673828125,
          "content": "/*\n * Copyright (c) 1999-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"ivl_assert.h\"\n# include  \"PWire.h\"\n# include  \"PExpr.h\"\n\nusing namespace std;\n\nPWire::PWire(perm_string n,\n\t     unsigned lp,\n\t     NetNet::Type t,\n\t     NetNet::PortType pt,\n\t     PWSRType rt)\n: name_(n), lexical_pos_(lp), type_(t), port_type_(pt), signed_(false),\n  port_set_(false), net_set_(false), is_scalar_(false),\n  error_cnt_(0), discipline_(0)\n{\n      switch (rt) {\n\t  case SR_PORT:\n\t    port_set_ = true;\n\t    break;\n\t  case SR_NET:\n\t    net_set_ = true;\n\t    break;\n\t  case SR_BOTH:\n\t    port_set_ = true;\n\t    net_set_ = true;\n\t    break;\n      }\n}\n\nNetNet::Type PWire::get_wire_type() const\n{\n      return type_;\n}\n\nperm_string PWire::basename() const\n{\n      return name_;\n}\n\nbool PWire::set_wire_type(NetNet::Type t)\n{\n      ivl_assert(*this, t != NetNet::IMPLICIT);\n\n      switch (type_) {\n\t  case NetNet::IMPLICIT:\n\t    type_ = t;\n\t    return true;\n\t  case NetNet::IMPLICIT_REG:\n\t    if (t == NetNet::REG) {\n\t\t  type_ = t;\n\t\t  return true;\n\t    }\n\t    if (t == NetNet::IMPLICIT_REG) return true;\n\t    return false;\n\t  case NetNet::REG:\n\t    if (t == NetNet::REG) return true;\n\t    return false;\n\t  default:\n\t    if (type_ != t)\n\t\t  return false;\n\t    else\n\t\t  return true;\n      }\n}\n\nNetNet::PortType PWire::get_port_type() const\n{\n      return port_type_;\n}\n\nbool PWire::set_port_type(NetNet::PortType pt)\n{\n      ivl_assert(*this, pt != NetNet::NOT_A_PORT);\n      ivl_assert(*this, pt != NetNet::PIMPLICIT);\n\n      switch (port_type_) {\n\t  case NetNet::PIMPLICIT:\n\t  case NetNet::NOT_A_PORT:\n\t    port_type_ = pt;\n\t    return true;\n\n\t  default:\n\t    if (port_type_ != pt)\n\t\t  return false;\n\t    else\n\t\t  return true;\n      }\n}\n\nvoid PWire::set_signed(bool flag)\n{\n\t// For a non-ANSI style port declaration where the data type is\n\t// specified in a corresponding variable declaration, the signed\n\t// attribute may be attached to either the port declaration or to\n\t// the variable declaration (IEEE 1364-2005 section 12.3.3). The\n\t// signal is signed if either the port or the variable is signed.\n\t// Handle that here.\n      signed_ = signed_ || flag;\n}\n\nbool PWire::get_signed() const\n{\n      return signed_;\n}\n\nvoid PWire::set_port(NetNet::PortType pt)\n{\n      ivl_assert(*this, !port_set_);\n      port_set_ = true;\n\n      bool rc = set_port_type(pt);\n      ivl_assert(*this, rc);\n}\n\nvoid PWire::set_net(NetNet::Type t)\n{\n      ivl_assert(*this, !net_set_);\n      net_set_ = true;\n\n      if (t != NetNet::IMPLICIT) {\n\t    bool rc = set_wire_type(t);\n\t    ivl_assert(*this, rc);\n      }\n}\n\nvoid PWire::set_range(const list<pform_range_t>&rlist, PWSRType type)\n{\n      switch (type) {\n\t  case SR_PORT:\n\t    if (!port_.empty())\n\t\t  return;\n\t    port_ = rlist;\n\t    break;\n\t  case SR_NET:\n\t    if (!net_.empty())\n\t\t  return;\n\t    net_ = rlist;\n\t    break;\n\t  case SR_BOTH:\n\t    if (!port_.empty() || !net_.empty())\n\t\t  return;\n\t    port_ = rlist;\n\t    net_ = rlist;\n\t    break;\n      }\n}\n\nvoid PWire::set_unpacked_idx(const list<pform_range_t>&ranges)\n{\n      if (! unpacked_.empty()) {\n\t    cerr << get_fileline() << \": error: Array ``\" << name_\n\t         << \"'' has already been declared.\" << endl;\n\t    error_cnt_ += 1;\n      } else {\n\t    unpacked_ = ranges;\n      }\n}\n\nvoid PWire::set_data_type(data_type_t*type)\n{\n      if (set_data_type_.get() == type)\n\t    return;\n\n      ivl_assert(*this, !set_data_type_.get());\n      set_data_type_.reset(type);\n}\n\nvoid PWire::set_discipline(ivl_discipline_t d)\n{\n      ivl_assert(*this, discipline_ == 0);\n      discipline_ = d;\n}\n\nivl_discipline_t PWire::get_discipline(void) const\n{\n      return discipline_;\n}\n\nPNamedItem::SymbolType PWire::symbol_type() const\n{\n      switch (type_) {\n          case NetNet::IMPLICIT_REG:\n          case NetNet::REG:\n            return VAR;\n          default:\n            return NET;\n    }\n}\n"
        },
        {
          "name": "PWire.h",
          "type": "blob",
          "size": 4.5498046875,
          "content": "#ifndef IVL_PWire_H\n#define IVL_PWire_H\n/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netlist.h\"\n# include  \"PNamedItem.h\"\n# include  <list>\n# include  <map>\n# include  \"StringHeap.h\"\n\n#ifdef HAVE_IOSFWD\n# include  <iosfwd>\n#else\n# include  <iostream>\n#endif\n\nclass PExpr;\nclass Design;\nclass netdarray_t;\n\n/*\n * The different type of PWire::set_range() calls.\n */\nenum PWSRType {SR_PORT, SR_NET, SR_BOTH};\n\n/*\n * Wires include nets, registers and ports. A net or register becomes\n * a port by declaration, so ports are not separate. The module\n * identifies a port by keeping it in its port list.\n *\n * The hname parameter to the constructor is a hierarchical name. It\n * is the name of the wire within a module, so does not include the\n * current scope or any instances. Modules contain all the wires, so\n * from that perspective, sub-scopes within the module are a part of\n * the wire name.\n */\nclass PWire : public PNamedItem {\n\n    public:\n      PWire(perm_string name,\n\t    unsigned lexical_pos,\n\t    NetNet::Type t,\n\t    NetNet::PortType pt,\n\t    PWSRType rt = SR_NET);\n\n\t// Return a hierarchical name.\n      perm_string basename() const;\n\n      unsigned lexical_pos() const { return lexical_pos_; }\n\n      NetNet::Type get_wire_type() const;\n      bool set_wire_type(NetNet::Type);\n\n      NetNet::PortType get_port_type() const;\n      bool set_port_type(NetNet::PortType);\n\n      void set_const(bool is_const) { is_const_ = is_const; };\n      bool get_const() const { return is_const_; };\n\n      void set_signed(bool flag);\n      bool get_signed() const;\n\n      void set_range(const std::list<pform_range_t>&ranges, PWSRType type);\n\n      void set_unpacked_idx(const std::list<pform_range_t>&ranges);\n\n      void set_data_type(data_type_t*type);\n\n      void set_discipline(ivl_discipline_t);\n      ivl_discipline_t get_discipline(void) const;\n\n      std::map<perm_string,PExpr*> attributes;\n\n\t// Write myself to the specified stream.\n      void dump(std::ostream&out, unsigned ind=4) const;\n\n      NetNet* elaborate_sig(Design*, NetScope*scope);\n\n      SymbolType symbol_type() const;\n\n      bool is_net() const { return net_set_; };\n      bool is_port() const { return port_set_; };\n      void set_net(NetNet::Type t);\n      void set_port(NetNet::PortType pt);\n\n    private:\n      perm_string name_;\n      unsigned lexical_pos_;\n      NetNet::Type type_;\n      NetNet::PortType port_type_;\n      bool signed_;\n\n        // Whether the wire is variable declared with the const keyword.\n      bool is_const_ = false;\n\n      bool is_elaborating_ = false;\n\n\t// These members hold expressions for the bit width of the\n\t// wire. If they do not exist, the wire is 1 bit wide. If they\n\t// do exist, they represent the packed dimensions of the\n\t// bit. The first item in the list is the first range, and so\n\t// on. For example \"reg [3:0][7:0] ...\" will contains the\n\t// range_t object for [3:0] first and [7:0] last.\n      std::list<pform_range_t>port_;\n      bool port_set_;\n      std::list<pform_range_t>net_;\n      bool net_set_;\n      bool is_scalar_;\n      unsigned error_cnt_;\n\n\t// If this wire is actually a memory, these indices will give\n\t// me the size and address ranges of the memory.\n      std::list<pform_range_t>unpacked_;\n\n\t// This is the complex type of the wire. the data_type_ may\n\t// modify how this is interpreted.\n      std::unique_ptr<data_type_t> set_data_type_;\n\n      ivl_discipline_t discipline_;\n\n    private: // not implemented\n      PWire(const PWire&);\n      PWire& operator= (const PWire&);\n\n      ivl_type_t elaborate_type(Design*des, NetScope*scope,\n\t\t\t        const netranges_t &packed_dimensions) const;\n      ivl_type_t elaborate_darray_type(Design*des, NetScope*scope,\n\t\t\t\t       const char *darray_type,\n\t\t\t\t       const netranges_t &packed_dimensions)\n\t\t\t\t       const;\n};\n\n#endif /* IVL_PWire_H */\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.5546875,
          "content": "# The ICARUS Verilog Compilation System\n\nCopyright 2000-2019 Stephen Williams\n\n<details>\n<summary><h2>Table of Contents</h2></summary>\n\n1. [What is ICARUS Verilog?](#what-is-icarus-verilog)\n2. [Building/Installing Icarus Verilog From Source](#buildinginstalling-icarus-verilog-from-source)\n\t- [Compile Time Prerequisites](#compile-time-prerequisites)\n\t- [Compilation](#compilation)\n\t- [(Optional) Testing](#optional-testing)\n\t- [Installation](#installation)\n3. [How Icarus Verilog Works](#how-icarus-verilog-works)\n\t- [Preprocessing](#preprocessing)\n\t- [Parse](#parse)\n\t- [Elaboration](#elaboration)\n\t- [Optimization](#optimization)\n\t- [Code Generation](#code-generation)\n\t- [Attributes](#attributes)\n4.\t[Running iverilog](#running-iverilog)\n\t- [Examples](#examples)\n5. [Unsupported Constructs](#unsupported-constructs)\n6. [Nonstandard Constructs or Behaviors](#nonstandard-constructs-or-behaviors)\n\t- [Builtin system functions](#builtin-system-functions)\n\t- [Preprocessing Library Modules](#preprocessing-library-modules)\n\t- [Width in %t Time Formats](#width-in-t-time-formats)\n\t- [vpiScope iterator on vpiScope objects](#vpiscope-iterator-on-vpiscope-objects)\n\t- [Time 0 Race Resolution](#time-0-race-resolution)\n\t- [Nets with Types](#nets-with-types)\n7. [Credits](#credits)\n\n</details>\n\n## What is ICARUS Verilog?\n\nIcarus Verilog is intended to compile ALL of the Verilog HDL, as\ndescribed in the IEEE-1364 standard. Of course, it's not quite there\nyet. It does currently handle a mix of structural and behavioural\nconstructs. For a view of the current state of Icarus Verilog, see its\nhome page at https://steveicarus.github.io/iverilog/.\n\nIcarus Verilog is not aimed at being a simulator in the traditional\nsense, but a compiler that generates code employed by back-end\ntools.\n\n> For instructions on how to run Icarus Verilog, see the `iverilog` man page.\n\n\n## Building/Installing Icarus Verilog from Source\n\nIf you are starting from the source, the build process is designed to be\nas simple as practical. Someone basically familiar with the target\nsystem and C/C++ compilation should be able to build the source\ndistribution with little effort. Some actual programming skills are\nnot required, but helpful in case of problems.\n\n> If you are building on Windows, see the mingw.txt file.\n\n### Compile Time Prerequisites\n\nYou can use:\n```bash\napt install -y autoconf gperf make gcc g++ bison flex\n```\n\nYou need the following software to compile Icarus Verilog from source\non a UNIX-like system:\n\n- GNU Make\n  The Makefiles use some GNU extensions, so a basic POSIX\n  make will not work. Linux systems typically come with a\n  satisfactory make. BSD based systems (i.e., NetBSD, FreeBSD)\n  typically have GNU make as the gmake program.\n\n- ISO C++ Compiler\n  The ivl and ivlpp programs are written in C++ and make use\n  of templates and some of the standard C++ library. egcs and\n  recent gcc compilers with the associated libstdc++ are known\n  to work. MSVC++ 5 and 6 are known to definitely *not* work.\n\n- bison and flex\n  OSX note: bison 2.3 shipped with MacOS including Catalina generates\n  broken code, but bison 3+ works. We recommend using the Fink\n  project version of bison and flex (finkproject.org), brew version\n  works fine either.\n\n- gperf 3.0 or later\n  The lexical analyzer doesn't recognize keywords directly,\n  but instead matches symbols and looks them up in a hash\n  table in order to get the proper lexical code. The gperf\n  program generates the lookup table.\n\n  A version problem with this program is the most common cause\n  of difficulty. See the Icarus Verilog FAQ.\n\n- readline 4.2 or later\n  On Linux systems, this usually means the readline-devel\n  rpm. In any case, it is the development headers of readline\n  that are needed.\n\n- termcap\n  The readline library, in turn, uses termcap.\n\n\t> If you are building from git, you will also need software to generate the configure scripts.\n\n- autoconf 2.53 or later\n  This generates configure scripts from configure.ac. The 2.53\n  or later versions are known to work, autoconf 2.13 is\n  reported to *not* work.\n\n### Compilation\n\n<details>\n<summary><h4><a href=\"https://github.com/steveicarus/iverilog/releases\">Compiling From Release</a></h4></summary>\n\nUnpack the tar-ball, `cd` into the `verilog-#########` directory,\nand compile the source with the commands:\n\n```bash\n  ./configure\n  make\n```\n</details>\n\n<details>\n<summary><h4>Compiling From GitHub</h4></summary>\n\nIf you are building from git, you have to run the command below before\ncompiling the source. This will generate the \"configure\" file, which is\nautomatically done when building from tarball.\n\n```bash\n  sh autoconf.sh\n  ./configure\n  make\n```\n\nNormally, this command automatically figures out everything it needs\nto know. It generally works pretty well. There are a few flags to the\nconfigure script that modify its behaviour:\n\n```\n\t--prefix=<root>\n\t\tThe default is /usr/local, which causes the tool suite to\n\t\tbe compiled for install in /usr/local/bin,\n\t\t/usr/local/share/ivl, etc.\n\n\t\tI recommend that if you are configuring for precompiled\n\t\tbinaries, use --prefix=/usr.  On Solaris systems, it is\n\t\tcommon to use --prefix=/opt.  You can configure for a non-root\n\t\tinstall with --prefix=$HOME.\n\n\t--enable-suffix\n\t--enable-suffix=<your-suffix>\n\t--disable-suffix\n\t\tEnable/disable changing the names of install files to use\n\t\ta suffix string so that this version or install can co-\n\t\texist with other versions. This renames the installed\n\t\tcommands (iverilog, iverilog-vpi, vvp) and the installed\n\t\tlibrary files and include directory so that installations\n\t\twith the same prefix but different suffix are guaranteed\n\t\tto not interfere with each other.\n\n\t--host=<host-type>\n\t\tCompile iverilog for a different platform. You can use:\n\t\t\t\tx64_64-w64-mingw32 for building 64-bit Windows executables\n\t\t\t\ti686-w64-mingw32 for building 32-bit Windows executables\n\t\t\tBoth options require installing the required mingw-w64 packages.\n```\n</details>\n\n### (Optional) Testing\n\nTo run a simple test before installation, execute\n\n```bash\n  make check\n```\n\nThe commands printed by this run might help you in running Icarus\nVerilog on your own Verilog sources before the package is installed\nby root.\n\n### Installation\n\nNow install the files in an appropriate place. (The makefiles by\ndefault install in /usr/local unless you specify a different prefix\nwith the `--prefix=<path>` flag to the configure command.) You may need\nto do this as root to gain access to installation directories.\n\n```bash\n\tmake install\n```\n\n### Uninstallation\n\nThe generated Makefiles also include the uninstall target. This should\nremove all the files that `make install` creates.\n\n## How Icarus Verilog Works\n\nThis tool includes a parser which reads in Verilog (plus extensions)\nand generates an internal netlist. The netlist is passed to various\nprocessing steps that transform the design to more optimal/practical\nforms, then is passed to a code generator for final output. The\nprocessing steps and the code generator are selected by command line\nswitches.\n\n### Preprocessing\n\nThere is a separate program, `ivlpp`, that does the preprocessing. This\nprogram implements the `` `include `` and  `` `define `` directives producing\noutput that is equivalent but without the directives. The output is a\nsingle file with line number directives, so that the actual compiler\nonly sees a single input file. See `ivlpp/ivlpp.txt` for details.\n\n### Parse\n\nThe Verilog compiler starts by parsing the Verilog source file. The\noutput of the parse is a list of Module objects in \"pform\". The pform\n(see `pform.h`) is mostly a direct reflection of the compilation\nstep. There may be dangling references, and it is not yet clear which\nmodule is the root.\n\nOne can see a human-readable version of the final pform by using the\n`-P <path>` flag to the `ivl` subcommand. This will cause ivl\nto dump the pform into the file named `<path>`. (Note that this is not\nnormally done, unless debugging the `ivl` subcommand.)\n\n### Elaboration\n\nThis phase takes the pform and generates a netlist. The driver selects\n(by user request or lucky guess) the root module to elaborate,\nresolves references and expands the instantiations to form the design\nnetlist. (See netlist.txt.) Final semantic checks are performed during\nelaboration, and some simple optimizations are performed. The netlist\nincludes all the behavioural descriptions, as well as gates and wires.\n\nThe `elaborate()` function performs the elaboration.\n\nOne can see a human-readable version of the final, elaborated and\noptimized netlist by using the `-N <path>` flag to the compiler. If\nelaboration succeeds, the final netlist (i.e., after optimizations but\nbefore code generation) will be dumped into the file named `<path>`.\n\nElaboration is performed in two steps: scopes and parameters\nfirst, followed by the structural and behavioural elaboration.\n\n#### Scope Elaboration\n\nThis pass scans through the pform looking for scopes and parameters. A\ntree of NetScope objects is built up and placed in the Design object,\nwith the root module represented by the root NetScope object. The\n`elab_scope.cc` file contains most of the code for handling this phase.\n\nThe tail of the elaborate_scope behaviour (after the pform is\ntraversed) includes a scan of the NetScope tree to locate defparam\nassignments that were collected during scope elaboration. This is when\nthe defparam overrides are applied to the parameters.\n\n#### Netlist Elaboration\n\nAfter the scopes and parameters are generated and the NetScope tree\nfully formed, the elaboration runs through the pform again, this time\ngenerating the structural and behavioural netlist. Parameters are\nelaborated and evaluated by now so all the constants of code\ngeneration are now known locally, so the netlist can be generated by\nsimply passing through the pform.\n\n### Optimization\n\nThis is a collection of processing steps that perform\noptimizations that do not depend on the target technology. Examples of\nsome useful transformations are\n\n- eliminate null effect circuitry\n- combinational reduction\n- constant propagation\n\nThe actual functions performed are specified on the `ivl` command line by\nthe `-F` flags (see below).\n\n### Code Generation\n\nThis step takes the design netlist and uses it to drive the code\ngenerator (see target.h). This may require transforming the\ndesign to suit the technology.\n\nThe `emit()` method of the Design class performs this step. It runs\nthrough the design elements, calling target functions as the need arises\nto generate actual output.\n\nThe user selects the target code generator with the `-t` flag on the\ncommand line.\n\n### Attributes\n\n> NOTE: The $attribute syntax will soon be deprecated in favour of the Verilog-2001 attribute syntax, which is cleaner and standardized.\n\nThe parser accepts, as an extension to Verilog, the $attribute module\nitem. The syntax of the $attribute item is:\n\n```\n\t$attribute (<identifier>, <key>, <value>);\n```\n\nThe $attribute keyword looks like a system task invocation. The\ndifference here is that the parameters are more restricted than those\nof a system task. The `<identifier>` must be an identifier. This will be\nthe item to get an attribute. The `<key>` and `<value>` are strings, not\nexpressions, that give the key and the value of the attribute to be\nattached to the identified object.\n\nAttributes are `[<key> <value>]` pairs and are used to communicate with\nthe various processing steps. See the documentation for the processing\nstep for a list of the pertinent attributes.\n\nAttributes can also be applied to gate types. When this is done, the\nattribute is given to every instantiation of the primitive. The syntax\nfor the attribute statement is the same, except that the `<identifier>`\nnames a primitive earlier in the compilation unit and the statement is\nplaced in the global scope, instead of within a module. The semicolon is\nnot part of a type attribute.\n\nNote that attributes are also occasionally used for communication\nbetween processing steps. Processing steps that are aware of others\nmay place attributes on netlist objects to communicate information to\nlater steps.\n\nIcarus Verilog also accepts the Verilog 2001 syntax for\nattributes. They have the same general meaning as with the $attribute\nsyntax, but they are attached to objects by position instead of by\nname. Also, the key is a Verilog identifier instead of a string.\n\n## Running `iverilog`\n\nThe preferred way to invoke the compiler is with the `iverilog`(1)\ncommand. This program invokes the preprocessor (`ivlpp`) and the\ncompiler (`ivl`) with the proper command line options to get the job\ndone in a friendly way. See the `iverilog`(1) man page for usage details.\n\n\n### EXAMPLE: Hello World\n\nExample: Compiling `\"hello.vl\"`\n\n```verilog\n// ------------------------ hello.vl ----------------------------\n\nmodule main();\n\ninitial\n  begin\n    $display(\"Hello World\");\n    $finish ;\n  end\n\nendmodule\n\n// --------------------------------------------------------------\n```\n\nEnsure that `iverilog` is on your search path, and the vpi library\nis available.\n\nTo compile the program:\n\n```bash\n\tiverilog hello.vl\n```\n\n(The above presumes that `/usr/local/include` and `/usr/local/lib` are\npart of the compiler search path, which is usually the case for `gcc`.)\n\nTo run the generated program:\n\n```bash\n\t./a.out\n```\n\nYou can use the `-o` switch to name the output command to be generated\nby the compiler. See the `iverilog`(1) man page.\n\n## Unsupported Constructs\n\nIcarus Verilog is in development - as such it still only supports a\n(growing) subset of Verilog.  Below is a description of some of the\ncurrently unsupported Verilog features. This list is not exhaustive\nand does not account for errors in the compiler. See the Icarus\nVerilog web page for the current state of support for Verilog, and in\nparticular, browse the bug report database for reported unsupported\nconstructs.\n\n  - System functions are supported, but the return value is a little\n    tricky. See SYSTEM FUNCTION TABLE FILES in the iverilog man page.\n\n  - Specify blocks are parsed but ignored in general.\n\n  - `trireg` is not supported. `tri0` and `tri1` are supported.\n\n  - tran primitives, i.e. `tran`, `tranif1`, `tranif0`, `rtran`, `rtranif1`,\n    and `rtranif0` are not supported.\n\n  - Net delays, of the form `wire #N foo;` do not work. Delays in\n    every other context do work properly, including the V2001 form\n    `wire #5 foo = bar;`\n\n  - Event controls inside non-blocking assignments are not supported.\n    i.e.: `a <= @(posedge clk) b;`\n\n  - Macro arguments are not supported. `` `define `` macros are supported,\n    but they cannot take arguments.\n\n## Nonstandard Constructs or Behaviors\n\nIcarus Verilog includes some features that are not part of the\nIEEE1364 standard, but have well-defined meaning, and also sometimes\ngives nonstandard (but extended) meanings to some features of the\nlanguage that are defined. See the \"extensions.txt\" documentation for\nmore details.\n\n* `$is_signed(<expr>)`\n\n\tThis system function returns 1 if the expression contained is\n\tsigned, or 0 otherwise. This is mostly of use for compiler\n\tregression tests.\n\n* `$sizeof(<expr>)`, `$bits(<expr>)`\n\n\tThe `$bits` system function returns the size in bits of the\n\texpression that is its argument. The result of this\n\tfunction is undefined if the argument doesn't have a\n\tself-determined size.\n\n\tThe `$sizeof` function is deprecated in favour of `$bits`, which is\n\tthe same thing, but included in the SystemVerilog definition.\n\n* `$simtime`\n\n  The `$simtime` system function returns as a 64bit value the\n\tsimulation time, unscaled by the time units of local\n\tscope. This is different from the $time and $stime functions\n\twhich return the scaled times. This function is added for\n\tregression testing of the compiler and run time, but can be\n\tused by applications who really want the simulation time.\n\n\tNote that the simulation time can be confusing if there are\n\tlots of different `` `timescales`` within a design. It is not in\n\tgeneral possible to predict what the simulation precision will\n\tturn out to be.\n\n* `$mti_random()`, `$mti_dist_uniform`\n\n\tThese functions are similar to the IEEE1364 standard $random\n\tfunctions, but they use the Mersenne Twister (MT19937)\n\talgorithm. This is considered an excellent random number\n\tgenerator, but does not generate the same sequence as the\n\tstandardized $random.\n\n### Builtin system functions\n\nCertain of the system functions have well-defined meanings, so\ncan theoretically be evaluated at compile-time, instead of\nusing runtime VPI code. Doing so means that VPI cannot\noverride the definitions of functions handled in this\nmanner. On the other hand, this makes them synthesizable, and\nalso allows for more aggressive constant propagation. The\nfunctions handled in this manner are:\n\n* `$bits`\n* `$signed`\n* `$sizeof`\n* `$unsigned`\n\nImplementations of these system functions in VPI modules will be ignored.\n\n### Preprocessing Library Modules\n\nIcarus Verilog does preprocess modules that are loaded from\nlibraries via the -y mechanism. However, the only macros\ndefined during the compilation of that file are those that it\ndefines itself (or includes) or that are defined in the\ncommand line or command file.\n\nSpecifically, macros defined in the non-library source files\nare not remembered when the library module is loaded. This is\nintentional. If it were otherwise, then compilation results\nmight vary depending on the order that libraries are loaded,\nand that is too unpredictable.\n\nIt is said that some commercial compilers do allow macro\ndefinitions to span library modules. That's just plain weird.\n\n### Width in `%t` Time Formats\n\nStandard Verilog does not allow width fields in the %t formats\nof display strings. For example, this is illegal:\n\n```\n\t$display(\"Time is %0t\", $time);\n```\n\nStandard Verilog instead relies on the $timeformat to\ncompletely specify the format.\n\nIcarus Verilog allows the programmer to specify the field\nwidth. The `%t` format in Icarus Verilog works exactly as it\ndoes in standard Verilog. However, if the programmer chooses\nto specify a minimum width (i.e., `%5t`), then for that display\nIcarus Verilog will override the `$timeformat` minimum width and\nuse the explicit minimum width.\n\n### vpiScope Iterator on vpiScope Objects\n\nIn the VPI, the normal way to iterate over vpiScope objects\ncontained within a vpiScope object, is the vpiInternalScope\niterator. Icarus Verilog adds support for the vpiScope\niterator of a vpiScope object, that iterates over *everything*\nthe is contained in the current scope. This is useful in cases\nwhere one wants to iterate over all the objects in a scope\nwithout iterating over all the contained types explicitly.\n\n### Time 0 Race Resolution\n\nCombinational logic is routinely modelled using always\nblocks. However, this can lead to race conditions if the\ninputs to the combinational block are initialized in initial\nstatements. Icarus Verilog slightly modifies time 0 scheduling\nby arranging for always statements with ANYEDGE sensitivity\nlists to be scheduled before any other threads. This causes\ncombinational always blocks to be triggered when the values in\nthe sensitivity list are initialized by initial threads.\n\n### Nets with Types\n\nIcarus Verilog supports an extended syntax that allows nets\nand regs to be explicitly typed. The currently supported types\nare logic, bool and real. This implies that `logic` and `bool`\nare new keywords. Typical syntax is:\n\n```verilog\n\twire real foo = 1.0;\n\treg logic bar, bat;\n```\n... and so forth. The syntax can be turned off by using the\n`-g2` flag to iverilog, and turned on explicitly with the `-g2x`\nflag to iverilog.\n\n\n## Credits\n\nExcept where otherwise noted, Icarus Verilog, ivl, and ivlpp are\nCopyright Stephen Williams. The proper notices are in the head of each\nfile. However, I have early on received aid in the form of fixes,\nVerilog guidance, and especially testing from many people. Testers, in\nparticular, include a larger community of people interested in a GPL\nVerilog for Linux.\n"
        },
        {
          "name": "Statement.cc",
          "type": "blob",
          "size": 7.69921875,
          "content": "/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"Statement.h\"\n# include  \"PExpr.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nStatement::~Statement()\n{\n}\n\nPAssign_::PAssign_(PExpr*lval__, PExpr*ex, bool is_constant, bool is_init)\n: event_(0), count_(0), lval_(lval__), rval_(ex), is_constant_(is_constant),\n  is_init_(is_init)\n{\n      delay_ = 0;\n}\n\nPAssign_::PAssign_(PExpr*lval__, PExpr*de, PExpr*ex)\n: event_(0), count_(0), lval_(lval__), rval_(ex), is_constant_(false)\n{\n      delay_ = de;\n}\n\nPAssign_::PAssign_(PExpr*lval__, PExpr*cnt, PEventStatement*ev, PExpr*ex)\n: event_(ev), count_(cnt), lval_(lval__), rval_(ex), is_constant_(false)\n{\n      delay_ = 0;\n}\n\nPAssign_::~PAssign_()\n{\n      delete lval_;\n      delete rval_;\n}\n\nPAssign::PAssign(PExpr*lval__, PExpr*ex)\n: PAssign_(lval__, ex, false), op_(0)\n{\n}\n\nPAssign::PAssign(PExpr*lval__, char op, PExpr*ex)\n: PAssign_(lval__, ex, false), op_(op)\n{\n}\n\nPAssign::PAssign(PExpr*lval__, PExpr*d, PExpr*ex)\n: PAssign_(lval__, d, ex), op_(0)\n{\n}\n\nPAssign::PAssign(PExpr*lval__, PExpr*cnt, PEventStatement*d, PExpr*ex)\n: PAssign_(lval__, cnt, d, ex), op_(0)\n{\n}\n\nPAssign::PAssign(PExpr*lval__, PExpr*ex, bool is_constant, bool is_init)\n: PAssign_(lval__, ex, is_constant, is_init), op_(0)\n{\n}\n\nPAssign::~PAssign()\n{\n}\n\nPAssignNB::PAssignNB(PExpr*lval__, PExpr*ex)\n: PAssign_(lval__, ex, false)\n{\n}\n\nPAssignNB::PAssignNB(PExpr*lval__, PExpr*d, PExpr*ex)\n: PAssign_(lval__, d, ex)\n{\n}\n\nPAssignNB::PAssignNB(PExpr*lval__, PExpr*cnt, PEventStatement*d, PExpr*ex)\n: PAssign_(lval__, cnt, d, ex)\n{\n}\n\nPAssignNB::~PAssignNB()\n{\n}\n\nPBlock::PBlock(perm_string n, LexicalScope*parent, BL_TYPE t)\n: PScope(n, parent), bl_type_(t)\n{\n}\n\nPBlock::PBlock(BL_TYPE t)\n: PScope(perm_string()), bl_type_(t)\n{\n}\n\nPBlock::~PBlock()\n{\n      for (unsigned idx = 0 ;  idx < list_.size() ;  idx += 1)\n\t    delete list_[idx];\n}\n\nbool PBlock::var_init_needs_explicit_lifetime() const\n{\n      return default_lifetime == STATIC;\n}\n\nPChainConstructor* PBlock::extract_chain_constructor()\n{\n      if (list_.empty())\n\t    return 0;\n\n      if (PChainConstructor*res = dynamic_cast<PChainConstructor*> (list_[0])) {\n\t    for (size_t idx = 0 ; idx < list_.size()-1 ; idx += 1)\n\t\t  list_[idx] = list_[idx+1];\n\t    list_.resize(list_.size()-1);\n\t    return res;\n      }\n\n      return 0;\n}\n\nvoid PBlock::set_join_type(PBlock::BL_TYPE type)\n{\n      ivl_assert(*this, bl_type_ == BL_PAR);\n      ivl_assert(*this, type==BL_PAR || type==BL_JOIN_NONE || type==BL_JOIN_ANY);\n      bl_type_ = type;\n}\n\nvoid PBlock::set_statement(const vector<Statement*>&st)\n{\n      list_ = st;\n}\n\nvoid PBlock::push_statement_front(Statement*that)\n{\n      ivl_assert(*this, bl_type_==BL_SEQ);\n\n      list_.resize(list_.size()+1);\n      for (size_t idx = list_.size()-1 ; idx > 0 ; idx -= 1)\n\t    list_[idx] = list_[idx-1];\n\n      list_[0] = that;\n}\n\nPNamedItem::SymbolType PBlock::symbol_type() const\n{\n      return BLOCK;\n}\n\nPCallTask::PCallTask(const pform_name_t &n, const list<named_pexpr_t> &p)\n: package_(0), path_(n), parms_(p.begin(), p.end())\n{\n}\n\nPCallTask::PCallTask(PPackage *pkg, const pform_name_t &n, const list<named_pexpr_t> &p)\n: package_(pkg), path_(n), parms_(p.begin(), p.end())\n{\n}\n\nPCallTask::PCallTask(perm_string n, const list<named_pexpr_t> &p)\n: package_(0), parms_(p.begin(), p.end())\n{\n      path_.push_back(name_component_t(n));\n}\n\nPCallTask::~PCallTask()\n{\n}\n\nconst pform_name_t& PCallTask::path() const\n{\n      return path_;\n}\n\nPCase::PCase(ivl_case_quality_t q, NetCase::TYPE t, PExpr*ex, std::vector<PCase::Item*>*l)\n: quality_(q), type_(t), expr_(ex), items_(l)\n{\n}\n\nPCase::~PCase()\n{\n      delete expr_;\n      for (unsigned idx = 0 ;  idx < items_->size() ;  idx += 1)\n\t    if ((*items_)[idx]->stat) delete (*items_)[idx]->stat;\n\n      delete[]items_;\n}\n\nPCAssign::PCAssign(PExpr*l, PExpr*r)\n: lval_(l), expr_(r)\n{\n}\n\nPCAssign::~PCAssign()\n{\n      delete lval_;\n      delete expr_;\n}\n\nPChainConstructor::PChainConstructor(const list<named_pexpr_t> &parms)\n: parms_(parms.begin(), parms.end())\n{\n}\n\nPChainConstructor::PChainConstructor(const vector<named_pexpr_t> &parms)\n: parms_(parms)\n{\n}\n\nPChainConstructor::~PChainConstructor()\n{\n}\n\nPCondit::PCondit(PExpr*ex, Statement*i, Statement*e)\n: expr_(ex), if_(i), else_(e)\n{\n}\n\nPCondit::~PCondit()\n{\n      delete expr_;\n      delete if_;\n      delete else_;\n}\n\nPDeassign::PDeassign(PExpr*l)\n: lval_(l)\n{\n}\n\nPDeassign::~PDeassign()\n{\n      delete lval_;\n}\n\n\nPDelayStatement::PDelayStatement(PExpr*d, Statement*st)\n: delay_(d), statement_(st)\n{\n}\n\nPDelayStatement::~PDelayStatement()\n{\n}\n\nPDisable::PDisable(const pform_name_t&sc)\n: scope_(sc)\n{\n}\n\nPDisable::~PDisable()\n{\n}\n\nPDoWhile::PDoWhile(PExpr*ex, Statement*st)\n: cond_(ex), statement_(st)\n{\n}\n\nPDoWhile::~PDoWhile()\n{\n      delete cond_;\n      delete statement_;\n}\n\nPEventStatement::PEventStatement(const std::vector<PEEvent*>&ee)\n: expr_(ee), statement_(0), always_sens_(false)\n{\n      ivl_assert(*this, expr_.size() > 0);\n}\n\n\nPEventStatement::PEventStatement(PEEvent*ee)\n: expr_(1), statement_(0), always_sens_(false)\n{\n      expr_[0] = ee;\n}\n\nPEventStatement::PEventStatement(bool always_sens)\n: statement_(0), always_sens_(always_sens)\n{\n}\n\nPEventStatement::~PEventStatement()\n{\n\t// delete the events and the statement?\n}\n\nvoid PEventStatement::set_statement(Statement*st)\n{\n      statement_ = st;\n}\n\nbool PEventStatement::has_aa_term(Design*des, NetScope*scope)\n{\n      bool flag = false;\n      for (unsigned idx = 0 ; idx < expr_.size() ; idx += 1) {\n\t    flag = expr_[idx]->has_aa_term(des, scope) || flag;\n      }\n      return flag;\n}\n\nPForce::PForce(PExpr*l, PExpr*r)\n: lval_(l), expr_(r)\n{\n}\n\nPForce::~PForce()\n{\n      delete lval_;\n      delete expr_;\n}\n\nPForeach::PForeach(perm_string av, const list<perm_string>&ix, Statement*s)\n: array_var_(av), index_vars_(ix.begin(), ix.end()), statement_(s)\n{\n}\n\nPForeach::~PForeach()\n{\n      delete statement_;\n}\n\nPForever::PForever(Statement*s)\n: statement_(s)\n{\n}\n\nPForever::~PForever()\n{\n      delete statement_;\n}\n\nPForStatement::PForStatement(PExpr*n1, PExpr*e1, PExpr*cond,\n\t\t\t     Statement*step, Statement*st)\n: name1_(n1), expr1_(e1), cond_(cond), step_(step), statement_(st)\n{\n}\n\nPForStatement::~PForStatement()\n{\n}\n\nPProcess::~PProcess()\n{\n      delete statement_;\n}\n\nPRelease::PRelease(PExpr*l)\n: lval_(l)\n{\n}\n\nPRelease::~PRelease()\n{\n      delete lval_;\n}\n\nPRepeat::PRepeat(PExpr*e, Statement*s)\n: expr_(e), statement_(s)\n{\n}\n\nPRepeat::~PRepeat()\n{\n      delete expr_;\n      delete statement_;\n}\n\nPReturn::PReturn(PExpr*e)\n: expr_(e)\n{\n}\n\nPReturn::~PReturn()\n{\n      delete expr_;\n}\n\nPTrigger::PTrigger(PPackage*pkg, const pform_name_t&ev, unsigned lexical_pos)\n: event_(pkg, ev), lexical_pos_(lexical_pos)\n{\n}\n\nPTrigger::~PTrigger()\n{\n}\n\nPNBTrigger::PNBTrigger(const pform_name_t&ev, unsigned lexical_pos, PExpr*dly)\n: event_(ev), lexical_pos_(lexical_pos), dly_(dly)\n{\n}\n\nPNBTrigger::~PNBTrigger()\n{\n}\n\nPWhile::PWhile(PExpr*ex, Statement*st)\n: cond_(ex), statement_(st)\n{\n}\n\nPWhile::~PWhile()\n{\n      delete cond_;\n      delete statement_;\n}\n"
        },
        {
          "name": "Statement.h",
          "type": "blob",
          "size": 18.861328125,
          "content": "#ifndef IVL_Statement_H\n#define IVL_Statement_H\n/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <string>\n# include  <vector>\n# include  <list>\n# include  \"ivl_target.h\"\n# include  \"StringHeap.h\"\n# include  \"PDelays.h\"\n# include  \"PExpr.h\"\n# include  \"PScope.h\"\n# include  \"HName.h\"\n# include  \"LineInfo.h\"\nclass PExpr;\nclass PChainConstructor;\nclass PPackage;\nclass Statement;\nclass PEventStatement;\nclass Design;\nclass NetAssign_;\nclass NetCAssign;\nclass NetDeassign;\nclass NetForce;\nclass NetScope;\n\n/*\n * The PProcess is the root of a behavioral process. Each process gets\n * one of these, which contains its type (initial, always, or final)\n * and a pointer to the single statement that is the process. A module\n * may have several concurrent processes.\n */\nclass PProcess : public LineInfo {\n\n    public:\n      PProcess(ivl_process_type_t t, Statement*st)\n      : type_(t), statement_(st) { }\n\n      virtual ~PProcess();\n\n      bool elaborate(Design*des, NetScope*scope) const;\n\n      ivl_process_type_t type() const { return type_; }\n      Statement*statement() { return statement_; }\n\n      std::map<perm_string,PExpr*> attributes;\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      ivl_process_type_t type_;\n      Statement*statement_;\n};\n\n/*\n * The PProcess is a process, the Statement is the actual action. In\n * fact, the Statement class is abstract and represents all the\n * possible kinds of statements that exist in Verilog.\n */\nclass Statement : virtual public LineInfo {\n\n    public:\n      Statement() { }\n      virtual ~Statement() =0;\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n\n      std::map<perm_string,PExpr*> attributes;\n};\n\n/*\n * Assignment statements of the various forms are handled by this\n * type. The rvalue is an expression. The lvalue needs to be figured\n * out by the parser as much as possible.\n */\nclass PAssign_  : public Statement {\n    public:\n      explicit PAssign_(PExpr*lval, PExpr*ex, bool is_constant,\n\t\t\tbool is_init = false);\n      explicit PAssign_(PExpr*lval, PExpr*de, PExpr*ex);\n      explicit PAssign_(PExpr*lval, PExpr*cnt, PEventStatement*de, PExpr*ex);\n      virtual ~PAssign_() =0;\n\n      const PExpr* lval() const  { return lval_; }\n      PExpr* rval() const  { return rval_; }\n\n    protected:\n      NetAssign_* elaborate_lval(Design*, NetScope*scope) const;\n      NetExpr* elaborate_rval_(Design*, NetScope*, ivl_type_t lv_net_type,\n\t\t\t       ivl_variable_type_t lv_type,\n\t\t\t       unsigned lv_width,\n\t\t\t       bool force_unsigned =false) const;\n      NetExpr* elaborate_rval_(Design*, NetScope*, ivl_type_t ntype) const;\n\n      NetExpr* elaborate_rval_obj_(Design*, NetScope*,\n\t\t\t\t   ivl_variable_type_t type) const;\n\n      PExpr* delay_;\n      PEventStatement*event_;\n      PExpr* count_;\n\n    private:\n      PExpr* lval_;\n      PExpr* rval_;\n      bool is_constant_;\n        // Whether the assignment is a variable initializer expression\n      bool is_init_ = false;\n};\n\nclass PAssign  : public PAssign_ {\n\n    public:\n\t// lval  - assignment l-value\n\t// ex    - assignment r-value\n\t// op    - compressed assignment operator (i.e. '+', '-', ...)\n\t// de    - delayed assignment delay expression\n      explicit PAssign(PExpr*lval, PExpr*ex);\n      explicit PAssign(PExpr*lval, char op, PExpr*ex);\n      explicit PAssign(PExpr*lval, PExpr*de, PExpr*ex);\n      explicit PAssign(PExpr*lval, PExpr*cnt, PEventStatement*de, PExpr*ex);\n      explicit PAssign(PExpr*lval, PExpr*ex, bool is_constant, bool is_init);\n      ~PAssign();\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n\n    private:\n      NetProc* elaborate_compressed_(Design*des, NetScope*scope) const;\n      char op_;\n};\n\nclass PAssignNB  : public PAssign_ {\n\n    public:\n      explicit PAssignNB(PExpr*lval, PExpr*ex);\n      explicit PAssignNB(PExpr*lval, PExpr*de, PExpr*ex);\n      explicit PAssignNB(PExpr*lval, PExpr*cnt, PEventStatement*de, PExpr*ex);\n      ~PAssignNB();\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n\n    private:\n      NetProc*assign_to_memory_(class NetMemory*, PExpr*,\n\t\t\t\tDesign*des, NetScope*scope) const;\n};\n\n/*\n * A block statement is an ordered list of statements that make up the\n * block. The block can be sequential or parallel, which only affects\n * how the block is interpreted. The parser collects the list of\n * statements before constructing this object, so it knows a priori\n * what is contained.\n */\nclass PBlock  : public PScope, public Statement, public PNamedItem {\n\n    public:\n      enum BL_TYPE { BL_SEQ, BL_PAR, BL_JOIN_NONE, BL_JOIN_ANY };\n\n\t// If the block has a name, it is a scope and also has a parent.\n      explicit PBlock(perm_string n, LexicalScope*parent, BL_TYPE t);\n\t// If it doesn't have a name, it's not a scope\n      explicit PBlock(BL_TYPE t);\n      ~PBlock();\n\n      BL_TYPE bl_type() const { return bl_type_; }\n\n      bool var_init_needs_explicit_lifetime() const;\n\n\t// This is only used if this block is the statement list for a\n\t// constructor. We look for a PChainConstructor as the first\n\t// statement, and if it is there, extract it.\n      PChainConstructor*extract_chain_constructor();\n\n\t// If the bl_type() is BL_PAR, it is possible to replace it\n\t// with JOIN_NONE or JOIN_ANY. This is to help the parser.\n      void set_join_type(BL_TYPE);\n\n      void set_statement(const std::vector<Statement*>&st);\n\n\t// Copy the statement from that block to the front of this\n\t// block.\n      void push_statement_front(Statement*that);\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n\n      SymbolType symbol_type() const;\n\n    private:\n      BL_TYPE bl_type_;\n      std::vector<Statement*>list_;\n};\n\nclass PBreak : public Statement {\n    public:\n      void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n};\n\nclass PCallTask  : public Statement {\n\n    public:\n      explicit PCallTask(PPackage *pkg, const pform_name_t &n, const std::list<named_pexpr_t> &parms);\n      explicit PCallTask(const pform_name_t &n, const std::list<named_pexpr_t> &parms);\n      explicit PCallTask(perm_string n, const std::list<named_pexpr_t> &parms);\n      ~PCallTask();\n\n      const pform_name_t& path() const;\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n\n      bool elaborate_elab(Design*des, NetScope*scope) const;\n\n      void void_cast() { void_cast_ = true; }\n\n    private:\n      NetProc* elaborate_sys(Design*des, NetScope*scope) const;\n      NetProc* elaborate_usr(Design*des, NetScope*scope) const;\n\n      NetProc*elaborate_method_(Design*des, NetScope*scope,\n                                bool add_this_flag = false) const;\n      NetProc*elaborate_function_(Design*des, NetScope*scope) const;\n      NetProc*elaborate_void_function_(Design*des, NetScope*scope,\n\t\t\t\t       NetFuncDef*def) const;\n      NetProc *elaborate_non_void_function_(Design *des, NetScope *scope) const;\n\n      NetProc*elaborate_build_call_(Design*des, NetScope*scope,\n\t\t\t\t    NetScope*task, NetExpr*use_this) const;\n      NetProc*elaborate_sys_task_method_(Design*des, NetScope*scope,\n\t\t\t\t\t NetNet*net,\n\t\t\t\t\t perm_string method_name,\n\t\t\t\t\t const char *sys_task_name,\n\t\t\t\t         const std::vector<perm_string> &parm_names = {}) const;\n      NetProc*elaborate_queue_method_(Design*des, NetScope*scope,\n\t\t\t\t      NetNet*net,\n\t\t\t\t      perm_string method_name,\n\t\t\t\t      const char *sys_task_name,\n\t\t\t\t      const std::vector<perm_string> &parm_names) const;\n      NetProc*elaborate_method_func_(NetScope*scope,\n\t\t\t\t     NetNet*net,\n\t\t\t\t     ivl_type_t type,\n\t\t\t\t     perm_string method_name,\n\t\t\t\t     const char*sys_task_name) const;\n      bool test_task_calls_ok_(Design*des, NetScope*scope) const;\n\n      PPackage*package_;\n      pform_name_t path_;\n      std::vector<named_pexpr_t> parms_;\n      bool void_cast_ = false;\n};\n\nclass PCase  : public Statement {\n\n    public:\n      struct Item {\n\t    std::list<PExpr*>expr;\n\t    Statement*stat;\n      };\n\n      PCase(ivl_case_quality_t, NetCase::TYPE, PExpr*ex, std::vector<Item*>*);\n      ~PCase();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      ivl_case_quality_t quality_;\n      NetCase::TYPE type_;\n      PExpr*expr_;\n\n      std::vector<Item*>*items_;\n\n    private: // not implemented\n      PCase(const PCase&);\n      PCase& operator= (const PCase&);\n};\n\nclass PCAssign  : public Statement {\n\n    public:\n      explicit PCAssign(PExpr*l, PExpr*r);\n      ~PCAssign();\n\n      virtual NetCAssign* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*lval_;\n      PExpr*expr_;\n};\n\n/*\n * This represents the syntax \"super.new(...)\". This is not really an\n * executable statement, but the elaborator will handle these\n * specially and will remove them from the statement stream. If any\n */\nclass PChainConstructor : public Statement {\n    public:\n      explicit PChainConstructor(const std::list<named_pexpr_t> &parms);\n      explicit PChainConstructor(const std::vector<named_pexpr_t> &parms);\n      ~PChainConstructor();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n      inline const std::vector<named_pexpr_t>& chain_args(void) const\n      { return parms_; }\n\n    private:\n      std::vector<named_pexpr_t> parms_;\n};\n\nclass PCondit  : public Statement {\n\n    public:\n      PCondit(PExpr*ex, Statement*i, Statement*e);\n      ~PCondit();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*expr_;\n      Statement*if_;\n      Statement*else_;\n\n    private: // not implemented\n      PCondit(const PCondit&);\n      PCondit& operator= (const PCondit&);\n};\n\nclass PContinue : public Statement {\n\n    public:\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n};\n\nclass PDeassign  : public Statement {\n\n    public:\n      explicit PDeassign(PExpr*l);\n      ~PDeassign();\n\n      virtual NetDeassign* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*lval_;\n};\n\nclass PDelayStatement  : public Statement {\n\n    public:\n      PDelayStatement(PExpr*d, Statement*st);\n      ~PDelayStatement();\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n\n    private:\n      PExpr*delay_;\n      Statement*statement_;\n};\n\n\n/*\n * This represents the parsing of a disable <scope> statement.\n */\nclass PDisable  : public Statement {\n\n    public:\n      explicit PDisable(const pform_name_t&sc);\n      ~PDisable();\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n\n    private:\n      pform_name_t scope_;\n};\n\nclass PDoWhile  : public Statement {\n\n    public:\n      PDoWhile(PExpr*ex, Statement*st);\n      ~PDoWhile();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*cond_;\n      Statement*statement_;\n};\n\n/*\n * The event statement represents the event delay in behavioral\n * code. It comes from such things as:\n *\n *      @name <statement>;\n *      @(expr) <statement>;\n *      @* <statement>;\n */\nclass PEventStatement  : public Statement {\n\n    public:\n\n      explicit PEventStatement(const std::vector<PEEvent*>&ee);\n      explicit PEventStatement(PEEvent*ee);\n\t// Make an @* statement or make a special @* version with the items\n\t// from functions added and outputs removed for always_comb/latch.\n      explicit PEventStatement(bool always_sens = false);\n\n      ~PEventStatement();\n\n      void set_statement(Statement*st);\n\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\t// Call this with a NULL statement only. It is used to print\n\t// the event expression for inter-assignment event controls.\n      virtual void dump_inline(std::ostream&out) const;\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n\n      bool has_aa_term(Design*des, NetScope*scope);\n\n\t// This method is used to elaborate, but attach a previously\n\t// elaborated statement to the event.\n      NetProc* elaborate_st(Design*des, NetScope*scope, NetProc*st) const;\n\n      NetProc* elaborate_wait(Design*des, NetScope*scope, NetProc*st) const;\n      NetProc* elaborate_wait_fork(Design*des, NetScope*scope) const;\n\n    private:\n      std::vector<PEEvent*>expr_;\n      Statement*statement_;\n      bool always_sens_;\n};\n\nstd::ostream& operator << (std::ostream&o, const PEventStatement&obj);\n\nclass PForce  : public Statement {\n\n    public:\n      explicit PForce(PExpr*l, PExpr*r);\n      ~PForce();\n\n      virtual NetForce* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*lval_;\n      PExpr*expr_;\n};\n\nclass PForeach : public Statement {\n    public:\n      explicit PForeach(perm_string var, const std::list<perm_string>&ix, Statement*stmt);\n      ~PForeach();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      NetProc* elaborate_static_array_(Design*des, NetScope*scope,\n\t\t\t\t       const netranges_t&dims) const;\n\n    private:\n      perm_string array_var_;\n      std::vector<perm_string> index_vars_;\n      Statement*statement_;\n};\n\nclass PForever : public Statement {\n    public:\n      explicit PForever(Statement*s);\n      ~PForever();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      Statement*statement_;\n};\n\nclass PForStatement  : public Statement {\n\n    public:\n      PForStatement(PExpr*n1, PExpr*e1, PExpr*cond,\n\t\t    Statement*step, Statement*body);\n      ~PForStatement();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr* name1_;\n      PExpr* expr1_;\n\n      PExpr*cond_;\n\n      Statement*step_;\n\n      Statement*statement_;\n};\n\nclass PNoop  : public Statement {\n\n    public:\n      PNoop() { }\n      ~PNoop() { }\n};\n\nclass PRepeat : public Statement {\n    public:\n      explicit PRepeat(PExpr*expr, Statement*s);\n      ~PRepeat();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*expr_;\n      Statement*statement_;\n};\n\nclass PRelease  : public Statement {\n\n    public:\n      explicit PRelease(PExpr*l);\n      ~PRelease();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*lval_;\n};\n\nclass PReturn  : public Statement {\n\n    public:\n      explicit PReturn(PExpr*e);\n      ~PReturn();\n\n      NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*expr_;\n};\n\n/*\n * The PTrigger statement sends a trigger to a named event. Take the\n * name here.\n */\nclass PTrigger  : public Statement {\n\n    public:\n      explicit PTrigger(PPackage*pkg, const pform_name_t&ev, unsigned lexical_pos);\n      ~PTrigger();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      pform_scoped_name_t event_;\n      unsigned lexical_pos_;\n};\n\nclass PNBTrigger  : public Statement {\n    public:\n      explicit PNBTrigger(const pform_name_t&ev, unsigned lexical_pos, PExpr*dly);\n      ~PNBTrigger();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      pform_name_t event_;\n      unsigned lexical_pos_;\n      PExpr*dly_;\n};\n\nclass PWhile  : public Statement {\n\n    public:\n      PWhile(PExpr*ex, Statement*st);\n      ~PWhile();\n\n      virtual NetProc* elaborate(Design*des, NetScope*scope) const;\n      virtual void elaborate_scope(Design*des, NetScope*scope) const;\n      virtual void elaborate_sig(Design*des, NetScope*scope) const;\n      virtual void dump(std::ostream&out, unsigned ind) const;\n\n    private:\n      PExpr*cond_;\n      Statement*statement_;\n};\n\n#endif /* IVL_Statement_H */\n"
        },
        {
          "name": "_pli_types.h.in",
          "type": "blob",
          "size": 2.3828125,
          "content": "#ifndef PLI_TYPES_H\n#define PLI_TYPES_H\n/*\n * Copyright (c) 2003-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# undef HAVE_INTTYPES_H\n\n#ifdef HAVE_INTTYPES_H\n\n/*\n * If the host environment has the stdint.h header file,\n * then use that to size our PLI types.\n */\n#ifndef __STDC_FORMAT_MACROS\n# define __STDC_FORMAT_MACROS\n#endif\n\n# include  <inttypes.h>\ntypedef uint64_t PLI_UINT64;\ntypedef int64_t  PLI_INT64;\ntypedef uint32_t PLI_UINT32;\ntypedef int32_t  PLI_INT32;\n\ntypedef signed short   PLI_INT16;\ntypedef unsigned short PLI_UINT16;\ntypedef char           PLI_BYTE8;\ntypedef unsigned char  PLI_UBYTE8;\n\n# define PLI_UINT64_FMT PRIu64\n\n#else\n\n/*\n * If we do not have the c99 stdint.h header file, then use\n * configure detection to guess the pli types ourselves.\n */\n\n# define SIZEOF_UNSIGNED_LONG_LONG 8\n# define SIZEOF_UNSIGNED_LONG 8\n# define SIZEOF_UNSIGNED 4\n\n#if SIZEOF_UNSIGNED >= 8\ntypedef unsigned PLI_UINT64;\ntypedef int      PLI_INT64;\n# define PLI_UINT64_FMT \"u\"\n#else\n# if SIZEOF_UNSIGNED_LONG >= 8\ntypedef unsigned long PLI_UINT64;\ntypedef          long PLI_INT64;\n#  define PLI_UINT64_FMT \"lu\"\n# else\n#  if SIZEOF_UNSIGNED_LONG_LONG > SIZEOF_UNSIGNED_LONG\ntypedef unsigned long long PLI_UINT64;\ntypedef          long long PLI_INT64;\n#   define PLI_UINT64_FMT \"llu\"\n#  else\ntypedef unsigned long PLI_UINT64;\ntypedef          long PLI_INT64;\n#   define PLI_UINT64_FMT \"lu\"\n#  endif\n# endif\n#endif\n\ntypedef signed int     PLI_INT32;\ntypedef unsigned int   PLI_UINT32;\ntypedef signed short   PLI_INT16;\ntypedef unsigned short PLI_UINT16;\ntypedef char           PLI_BYTE8;\ntypedef unsigned char  PLI_UBYTE8;\n#endif\n\n#endif /* PLI_TYPES_H */\n"
        },
        {
          "name": "acc_user.h",
          "type": "blob",
          "size": 7.478515625,
          "content": "#ifndef ACC_USER_H\n#define ACC_USER_H\n/*\n * Copyright (c) 2002-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n/*\n * This header file contains the definitions and declarations needed\n * by an Icarus Verilog user using acc_ routines.\n *\n * NOTE: Icarus Verilog does not support acc_ routines. This is just a\n * stub. The functions that are implemented here are actually\n * implemented using VPI routines.\n */\n\n\n#ifdef __cplusplus\n# define EXTERN_C_START extern \"C\" {\n# define EXTERN_C_END }\n#else\n# define EXTERN_C_START\n# define EXTERN_C_END\n# define bool int\n#endif\n\nEXTERN_C_START\n\n# include  \"_pli_types.h\"\n\n/*\n * This is a declaration of the \"handle\" type that is compatible with\n * the vpiHandle from vpi_user.h. The libveriuser library implements\n * the acc handle type as a vpiHandle, to prevent useless indirection.\n */\ntypedef struct __vpiHandle *handle;\n\n/* OBJECT TYPES */\n#define accModule    20\n#define accScope     21\n#define accNet       25\n#define accReg       30\n#define accIntegerParam   200\n#define accRealParam 202\n#define accStringParam 204\n#define accParameter   220\n#define accTopModule      224\n#define accModuleInstance 226\n#define accWire        260\n#define accNamedEvent  280\n#define accIntegerVar  281\n#define accRealVar   282\n#define accTimeVar   283\n#define accIntVar    accIntegerVar\n#define accScalar    300\n#define accVector    302\n#define accUnknown   412\n#define accConstant  600\n\n/* type VALUES FOR t_setval_delay STRUCTURE */\n#define accNoDelay  0\n#define accInertialDelay 1\n#define accTransportDelay 2\n#define accPureTransportDelay 3\n#define accForceFlag 4\n#define accReleaseFlag 5\n\n/* type VALUES FOR t_setval_value STRUCTURE */\n#define accBinStrVal 1\n#define accOctStrVal 2\n#define accDecStrVal 3\n#define accHexStrVal 4\n#define accScalarVal 5\n#define accIntVal 6\n#define accRealVal 7\n#define accStringVal 8\n#define accVectorVal 9\n\n/* Scalar values */\n#define acc0 0\n#define acc1 1\n#define accX 2\n#define accZ 3\n\n/* type VALUES FOR t_acc_time STRUCTURE */\n#define accTime 1\n#define accSimTime 2\n#define accRealTime 3\n\n/* reason codes */\n#define logic_value_change     1\n#define strength_value_change  2\n#define real_value_change      3\n#define vector_value_change    4\n#define event_value_change     5\n#define integer_value_change   6\n#define time_value_change      7\n#define sregister_value_change 8\n#define vregister_value_change 9\n#define realtime_value_change 10\n\n/* VCL strength values */\n#define vclSupply  7\n#define vclStrong  6\n#define vclPull    5\n#define vclLarge   4\n#define vclWeak    3\n#define vclMedium  2\n#define vclSmall   1\n#define vclHighZ   0\n\n/* Constants used by acc_vcl_add */\n#define vcl_verilog_logic 2\n#define VCL_VERILOG_LOGIC vcl_verilog_logic\n#define vcl_verilog_strength 3\n#define VCL_VERILOG_STRENGTH vcl_verilog_strength\n\ntypedef struct t_acc_time {\n      int type;\n      int low, high;\n      double real;\n} s_acc_time, *p_acc_time;\n\ntypedef struct t_setval_delay {\n      s_acc_time time;\n      int model;\n} s_setval_delay, *p_setval_delay;\n\ntypedef struct t_acc_vecval {\n      int aval;\n      int bval;\n} s_acc_vecval, *p_acc_vecval;\n\ntypedef struct t_setval_value {\n      int format;\n      union {\n\t    char*str;\n\t    int scalar;\n\t    int integer;\n\t    double real;\n\t    p_acc_vecval vector;\n      } value;\n} s_setval_value, *p_setval_value, s_acc_value, *p_acc_value;\n\ntypedef struct t_strengths {\n      PLI_UBYTE8 logic_value;\n      PLI_UBYTE8 strength1;\n      PLI_UBYTE8 strength2;\n} s_strengths, *p_strengths;\n\ntypedef struct t_vc_record {\n      PLI_INT32 vc_reason;\n      PLI_INT32 vc_hightime;\n      PLI_INT32 vc_lowtime;\n      void*     user_data;\n      union {\n\t    PLI_UBYTE8 logic_value;\n\t    double real_value;\n\t    handle vector_handle;\n\t    s_strengths strengths_s;\n      } out_value;\n} s_vc_record, *p_vc_record;\n\n\ntypedef struct t_location {\n      PLI_INT32 line_no;\n      const char*filename;\n} s_location, *p_location;\n\nextern int acc_error_flag;\n\nextern int acc_initialize(void);\n\nextern void acc_close(void);\n\n/*\n * This is the acc_configure command, and the config_param\n * codes that are accepted.\n */\nextern int   acc_configure(PLI_INT32 config_param, const char*value);\n#define accEnableArgs          6\n#define accDevelopmentVersion 11\n\nextern int   acc_fetch_argc(void);\nextern char**acc_fetch_argv(void);\n\nextern PLI_INT32 acc_fetch_direction(handle obj);\n/* XXXX FIXME: Values returned by acc_fetch_direction */\n# define accInout 2\n\nextern char* acc_fetch_fullname(handle obj);\n\nextern int   acc_fetch_location(p_location loc, handle obj);\n\nextern char* acc_fetch_name(handle obj);\nextern char* acc_fetch_defname(handle obj);\n\nextern double acc_fetch_paramval(handle obj);\n\nextern double    acc_fetch_tfarg(PLI_INT32);\nextern double    acc_fetch_itfarg(PLI_INT32, handle);\nextern PLI_INT32 acc_fetch_tfarg_int(PLI_INT32);\nextern PLI_INT32 acc_fetch_itfarg_int(PLI_INT32, handle);\nextern char*     acc_fetch_tfarg_str(PLI_INT32);\nextern char*     acc_fetch_itfarg_str(PLI_INT32, handle);\n\ntypedef struct t_timescale_info {\n      PLI_INT16 unit;\n      PLI_INT16 precision;\n} s_timescale_info, *p_timescale_info;\nextern void acc_fetch_timescale_info(handle obj, p_timescale_info info);\n\nextern PLI_INT32 acc_fetch_size(handle obj);\n\nextern PLI_INT32 acc_fetch_type(handle obj);\nextern PLI_INT32 acc_fetch_fulltype(handle obj);\nextern PLI_INT32 acc_fetch_paramtype(handle obj);\nextern PLI_INT32 acc_fetch_range(handle object, int *msb, int *lsb);\nextern const char* acc_fetch_type_str(PLI_INT32 type);\n\nextern char* acc_fetch_value(handle obj, const char*fmt, s_acc_value*value);\n\nextern handle acc_handle_by_name(const char*name, handle scope);\nextern handle acc_handle_hiconn(handle port_ref_handle);\nextern handle acc_handle_object(const char*name);\nextern handle acc_handle_parent(handle obj);\nextern handle acc_handle_scope(handle obj);\nextern handle acc_handle_simulated_net(handle net);\n\nextern handle acc_handle_tfarg(int n);\nextern handle acc_handle_tfinst(void);\n\nextern PLI_INT32 acc_compare_handles(handle, handle);\n\nextern handle acc_next(PLI_INT32 *, handle, handle);\nextern handle acc_next_bit(handle ref, handle bit);\nextern handle acc_next_port(handle ref, handle bit);\nextern handle acc_next_scope(handle, handle);\nextern handle acc_next_topmod(handle prev_topmod);\n\nextern int acc_object_in_typelist(handle object, PLI_INT32*typelist);\nextern int acc_object_of_type(handle object, PLI_INT32 type);\n\nextern char*acc_product_version(void);\n\nextern char*acc_set_scope(handle ref, ...);\n\nextern int acc_set_value(handle obj, p_setval_value value,\n\t\t\t p_setval_delay delay);\n\nextern void acc_vcl_add(handle obj, PLI_INT32(*consumer)(p_vc_record),\n\t\t\tvoid*data, PLI_INT32 vcl_flag);\nextern  void acc_vcl_delete(handle obj, PLI_INT32(*consumer)(p_vc_record),\n\t\t\t    void*data, PLI_INT32 vcl_flag);\n\nextern char* acc_version(void);\n\nEXTERN_C_END\n\n#endif /* ACC_USER_H */\n"
        },
        {
          "name": "aclocal.m4",
          "type": "blob",
          "size": 11.3662109375,
          "content": "\n# AX_ENABLE_SUFFIX\n# ----------------\n#  Create the configure option --enable-suffix[=suffix] to generate suffix\n# strings for the installed commands. This allows for shared installs of\n# different builds. Remember to change the default suffix string to some\n# value appropriate for the current version.\nAC_DEFUN([AX_ENABLE_SUFFIX],\n[AC_ARG_ENABLE([suffix],[AS_HELP_STRING([--enable-suffix],\n                                        [Use/set the installation command suffix])],\n               [true],[enable_suffix=no])\nif test X$enable_suffix = Xyes; then\n  install_suffix='-0.10'\nelif test X$enable_suffix = Xno; then\n  install_suffix=''\nelse\n  install_suffix=\"$enable_suffix\"\nfi\nAC_SUBST(install_suffix)\n])# AX_ENABLE_SUFFIX\n\n# _AX_C_UNDERSCORES_MATCH_IFELSE(PATTERN, ACTION-IF-MATCH, ACTION-IF-NOMATCH)\n# ------------------------------\n# Sub-macro for AX_C_UNDERSCORES_LEADING and AX_C_UNDERSCORES_TRAILING.\n# Unwarranted assumptions:\n#   - the object file produced by AC_COMPILE_IFELSE is called\n#     \"conftest.$ac_objext\"\n#   - the nm(1) utility or an equivalent is available, and its name\n#     is defined by the $NM variable.\nAC_DEFUN([_AX_C_UNDERSCORES_MATCH_IF],\n[AC_COMPILE_IFELSE([AC_LANG_SOURCE([void underscore(void){}])],\n[AS_IF([$NM conftest.$ac_objext|grep $1 >/dev/null 2>/dev/null],[$2],[$3])],\n[AC_MSG_ERROR([underscore test crashed])]\n)])\n\n\n# AX_C_UNDERSCORES_LEADING\n# ---------------------------------\n# Check if symbol names in object files produced by C compiler have\n# leading underscores. Define NEED_LU if so.\nAC_DEFUN([AX_C_UNDERSCORES_LEADING],\n[AC_CACHE_CHECK([for leading underscores], ax_cv_c_underscores_leading,\n[_AX_C_UNDERSCORES_MATCH_IF([_underscore],\n[AS_VAR_SET(ax_cv_c_underscores_leading, yes)],\n[AS_VAR_SET(ax_cv_c_underscores_leading, no)])])\nif test $ax_cv_c_underscores_leading = yes -a \"$CYGWIN\" != \"yes\" -a \"$MINGW32\" != \"yes\"; then\n AC_DEFINE([NEED_LU], [1], [Symbol names in object files produced by C compiler have leading underscores.])\nfi\n])# AX_C_UNDERSCORES_LEADING\n\n\n# AX_C_UNDERSCORES_TRAILING\n# ---------------------------------\n# Check if symbol names in object files produced by C compiler have\n# trailing underscores.  Define NEED_TU if so.\nAC_DEFUN([AX_C_UNDERSCORES_TRAILING],\n[AC_CACHE_CHECK([for trailing underscores], ax_cv_c_underscores_trailing,\n[_AX_C_UNDERSCORES_MATCH_IF([underscore_],\n[AS_VAR_SET(ax_cv_c_underscores_trailing, yes)],\n[AS_VAR_SET(ax_cv_c_underscores_trailing, no)])])\nif test $ax_cv_c_underscores_trailing = yes; then\n AC_DEFINE([NEED_TU], [1], [Symbol names in object files produced by C compiler have trailing underscores.])\nfi\n])# AX_C_UNDERSCORES_TRAILING\n\n# AX_WIN32\n# --------\n# Combined check for several flavors of Microsoft Windows so\n # their \"issues\" can be dealt with\nAC_DEFUN([AX_WIN32],\n[AC_MSG_CHECKING([for Microsoft Windows])\nAC_REQUIRE([AC_CANONICAL_HOST]) []dnl\ncase $host_os in\n     *cygwin*) MINGW32=no;  WIN32=yes;;\n\n      *mingw*) MINGW32=yes; WIN32=yes;;\n\n            *) MINGW32=no;  WIN32=no;;\nesac\nAC_SUBST(MINGW32)\nAC_SUBST(WIN32)\nAC_MSG_RESULT($WIN32)\nif test $WIN32 = yes; then\nAC_MSG_CHECKING([for MinGW])\nAC_MSG_RESULT($MINGW32)\nfi\n])# AX_WIN32\n\n# AX_LD_EXTRALIBS\n# ---------------\n# mingw needs to link with libiberty.a, but cygwin alone can't tolerate it\nAC_DEFUN([AX_LD_EXTRALIBS],\n[AC_MSG_CHECKING([for extra libs needed])\nEXTRALIBS=\ncase \"${host}\" in\n     *-*-cygwin* )\n        if test \"$MINGW32\" = \"yes\"; then\n            EXTRALIBS=\"-liberty\"\n        fi\n        ;;\nesac\nAC_SUBST(EXTRALIBS)\nAC_MSG_RESULT($EXTRALIBS)\n])# AX_LD_EXTRALIBS\n\n# AX_LD_SHAREDLIB_OPTS\n# --------------------\n# linker options when building a shared library\nAC_DEFUN([AX_LD_SHAREDLIB_OPTS],\n[AC_MSG_CHECKING([for shared library link flag])\nshared=-shared\ncase \"${host}\" in\n     *-*-cygwin*)\n        shared=\"-shared -Wl,--enable-auto-image-base\"\n        ;;\n\n     *-*-mingw*)\n        shared=\"-shared -Wl,--enable-auto-image-base\"\n        ;;\n\n     *-*-hpux*)\n        shared=\"-b\"\n        ;;\n\n     *-*-darwin1.[0123])\n        shared=\"-bundle -undefined dynamic_lookup\"\n        ;;\n\n     *-*-darwin*)\n        shared=\"-bundle -undefined dynamic_lookup -flat_namespace\"\n        ;;\n\n     *-*-solaris*)\n        if test ${using_sunpro_c} = 1\n        then\n           shared=\"-G\"\n        fi\n        ;;\nesac\nAC_SUBST(shared)\nAC_MSG_RESULT($shared)\n])# AX_LD_SHAREDLIB_OPTS\n\n# AX_C_PICFLAG\n# ------------\n# The -fPIC flag is used to tell the compiler to make position\n# independent code. It is needed when making shared objects.\nAC_DEFUN([AX_C_PICFLAG],\n[AC_MSG_CHECKING([for flag to make position independent code])\nPICFLAG=-fPIC\ncase \"${host}\" in\n\n     *-*-cygwin*)\n        PICFLAG=\n        ;;\n\n     *-*-mingw*)\n        PICFLAG=\n        ;;\n\n     *-*-hpux*)\n        PICFLAG=+z\n        ;;\n\n     *-*-solaris*)\n        if test ${using_sunpro_c} = 1\n        then\n           PICFLAG=-G\n        fi\n        ;;\nesac\nAC_SUBST(PICFLAG)\nAC_MSG_RESULT($PICFLAG)\n])# AX_C_PICFLAG\n\n# AX_LD_RDYNAMIC\n# --------------\n# The -rdynamic flag is used by iverilog when compiling the target,\n# to know how to export symbols of the main program to loadable modules\n# that are brought in by -ldl\nAC_DEFUN([AX_LD_RDYNAMIC],\n[AC_MSG_CHECKING([for -rdynamic compiler flag])\nrdynamic=-rdynamic\ncase \"${host}\" in\n\n    *-*-netbsd*)\n        rdynamic=\"-Wl,--export-dynamic\"\n        ;;\n\n    *-*-openbsd*)\n        rdynamic=\"-Wl,--export-dynamic\"\n        ;;\n\n    *-*-solaris*)\n        rdynamic=\"\"\n        ;;\n\n    *-*-cygwin*)\n        rdynamic=\"\"\n        ;;\n\n    *-*-mingw*)\n        rdynamic=\"\"\n        ;;\n\n    *-*-hpux*)\n        rdynamic=\"-E\"\n        ;;\n\n    *-*-darwin*)\n        rdynamic=\"-Wl,-all_load\"\n        strip_dynamic=\"-SX\"\n        ;;\n\nesac\nAC_SUBST(rdynamic)\nAC_MSG_RESULT($rdynamic)\nAC_SUBST(strip_dynamic)\n# since we didn't tell them we're \"checking\", no good place to tell the answer\n# AC_MSG_RESULT($strip_dynamic)\n])# AX_LD_RDYNAMIC\n\n\n# AX_C99_STRTOD\n# -------------\nAC_DEFUN([AX_C99_STRTOD],\n[# On MinGW we need to jump through hoops to get a C99 compliant strtod().\n # mingw-w64 doesn't need this, and the 64-bit version doesn't support it.\ncase \"${host}\" in\n    x86_64-w64-mingw32)\n        ;;\n    *-*-mingw32)\n        LDFLAGS+=\" -Wl,--undefined=___strtod,--wrap,strtod,--defsym,___wrap_strtod=___strtod\"\n        ;;\nesac\n])# AX_C99_STRTOD\n\n# When config.status generates a header, we must update the stamp-h file.\n# This file resides in the same directory as the config header\n# that is generated.  The stamp file name are based on the header name.\n\n# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n# loop where config.status creates the headers, so we can generate\n# our stamp files there.\nAC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n[\n_config_header=$1\n_stamp_name=stamp-`expr //$_config_header : '.*/\\([[^./]]*\\)\\.[[^./]]*$'`-h\necho \"timestamp for $_config_header\" > `AS_DIRNAME([\"$_config_header\"])`/[]$_stamp_name\n]) #_AC_AM_CONFIG_HEADER_HOOK\n\n# ===========================================================================\n#   https://www.gnu.org/software/autoconf-archive/ax_prog_cc_for_build.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_PROG_CC_FOR_BUILD\n#\n# DESCRIPTION\n#\n#   This macro searches for a C compiler that generates native executables,\n#   that is a C compiler that surely is not a cross-compiler. This can be\n#   useful if you have to generate source code at compile-time like for\n#   example GCC does.\n#\n#   The macro sets the CC_FOR_BUILD and CPP_FOR_BUILD macros to anything\n#   needed to compile or link (CC_FOR_BUILD) and preprocess (CPP_FOR_BUILD).\n#   The value of these variables can be overridden by the user by specifying\n#   a compiler with an environment variable (like you do for standard CC).\n#\n#   It also sets BUILD_EXEEXT and BUILD_OBJEXT to the executable and object\n#   file extensions for the build platform, and GCC_FOR_BUILD to `yes' if\n#   the compiler we found is GCC. All these variables but GCC_FOR_BUILD are\n#   substituted in the Makefile.\n#\n# LICENSE\n#\n#   Copyright (c) 2008 Paolo Bonzini <bonzini@gnu.org>\n#\n#   Copying and distribution of this file, with or without modification, are\n#   permitted in any medium without royalty provided the copyright notice\n#   and this notice are preserved. This file is offered as-is, without any\n#   warranty.\n\n#serial 18\n\nAU_ALIAS([AC_PROG_CC_FOR_BUILD], [AX_PROG_CC_FOR_BUILD])\nAC_DEFUN([AX_PROG_CC_FOR_BUILD], [dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_CPP])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\n\ndnl Use the standard macros, but make them use other variable names\ndnl\npushdef([ac_cv_prog_CPP], ac_cv_build_prog_CPP)dnl\npushdef([ac_cv_prog_cc_c89], ac_cv_build_prog_cc_c89)dnl\npushdef([ac_cv_prog_gcc], ac_cv_build_prog_gcc)dnl\npushdef([ac_cv_prog_cc_works], ac_cv_build_prog_cc_works)dnl\npushdef([ac_cv_prog_cc_cross], ac_cv_build_prog_cc_cross)dnl\npushdef([ac_cv_prog_cc_g], ac_cv_build_prog_cc_g)dnl\npushdef([ac_cv_c_compiler_gnu], ac_cv_build_c_compiler_gnu)dnl\npushdef([ac_cv_exeext], ac_cv_build_exeext)dnl\npushdef([ac_cv_objext], ac_cv_build_objext)dnl\npushdef([ac_exeext], ac_build_exeext)dnl\npushdef([ac_objext], ac_build_objext)dnl\npushdef([CC], CC_FOR_BUILD)dnl\npushdef([CPP], CPP_FOR_BUILD)dnl\npushdef([GCC], GCC_FOR_BUILD)dnl\npushdef([CFLAGS], CFLAGS_FOR_BUILD)dnl\npushdef([CPPFLAGS], CPPFLAGS_FOR_BUILD)dnl\npushdef([EXEEXT], BUILD_EXEEXT)dnl\npushdef([LDFLAGS], LDFLAGS_FOR_BUILD)dnl\npushdef([OBJEXT], BUILD_OBJEXT)dnl\npushdef([host], build)dnl\npushdef([host_alias], build_alias)dnl\npushdef([host_cpu], build_cpu)dnl\npushdef([host_vendor], build_vendor)dnl\npushdef([host_os], build_os)dnl\npushdef([ac_cv_host], ac_cv_build)dnl\npushdef([ac_cv_host_alias], ac_cv_build_alias)dnl\npushdef([ac_cv_host_cpu], ac_cv_build_cpu)dnl\npushdef([ac_cv_host_vendor], ac_cv_build_vendor)dnl\npushdef([ac_cv_host_os], ac_cv_build_os)dnl\npushdef([ac_tool_prefix], ac_build_tool_prefix)dnl\npushdef([am_cv_CC_dependencies_compiler_type], am_cv_build_CC_dependencies_compiler_type)dnl\npushdef([am_cv_prog_cc_c_o], am_cv_build_prog_cc_c_o)dnl\npushdef([cross_compiling], cross_compiling_build)dnl\n\ncross_compiling_build=no\n\nac_build_tool_prefix=\nAS_IF([test -n \"$build\"],      [ac_build_tool_prefix=\"$build-\"],\n      [test -n \"$build_alias\"],[ac_build_tool_prefix=\"$build_alias-\"])\n\nAC_LANG_PUSH([C])\nAC_PROG_CC\n_AC_COMPILER_EXEEXT\n_AC_COMPILER_OBJEXT\nAC_PROG_CPP\n\ndnl Restore the old definitions\ndnl\npopdef([cross_compiling])dnl\npopdef([am_cv_prog_cc_c_o])dnl\npopdef([am_cv_CC_dependencies_compiler_type])dnl\npopdef([ac_tool_prefix])dnl\npopdef([ac_cv_host_os])dnl\npopdef([ac_cv_host_vendor])dnl\npopdef([ac_cv_host_cpu])dnl\npopdef([ac_cv_host_alias])dnl\npopdef([ac_cv_host])dnl\npopdef([host_os])dnl\npopdef([host_vendor])dnl\npopdef([host_cpu])dnl\npopdef([host_alias])dnl\npopdef([host])dnl\npopdef([OBJEXT])dnl\npopdef([LDFLAGS])dnl\npopdef([EXEEXT])dnl\npopdef([CPPFLAGS])dnl\npopdef([CFLAGS])dnl\npopdef([GCC])dnl\npopdef([CPP])dnl\npopdef([CC])dnl\npopdef([ac_objext])dnl\npopdef([ac_exeext])dnl\npopdef([ac_cv_objext])dnl\npopdef([ac_cv_exeext])dnl\npopdef([ac_cv_c_compiler_gnu])dnl\npopdef([ac_cv_prog_cc_g])dnl\npopdef([ac_cv_prog_cc_cross])dnl\npopdef([ac_cv_prog_cc_works])dnl\npopdef([ac_cv_prog_cc_c89])dnl\npopdef([ac_cv_prog_gcc])dnl\npopdef([ac_cv_prog_CPP])dnl\n\ndnl restore global variables ac_ext, ac_cpp, ac_compile,\ndnl ac_link, ac_compiler_gnu (dependant on the current\ndnl language after popping):\nAC_LANG_POP([C])\n\ndnl Finally, set Makefile variables\ndnl\nAC_SUBST(BUILD_EXEEXT)dnl\nAC_SUBST(BUILD_OBJEXT)dnl\nAC_SUBST([CFLAGS_FOR_BUILD])dnl\nAC_SUBST([CPPFLAGS_FOR_BUILD])dnl\nAC_SUBST([LDFLAGS_FOR_BUILD])dnl\n])\n"
        },
        {
          "name": "async.cc",
          "type": "blob",
          "size": 2.5,
          "content": "/*\n * Copyright (c) 2002-2010 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"functor.h\"\n# include  \"netlist.h\"\n# include  <cassert>\n\nbool NetAssign::is_asynchronous()\n{\n      return true;\n}\n\nbool NetCondit::is_asynchronous()\n{\n      return false;\n}\n\n/*\n * NetEvWait statements come from statements of the form @(...) in the\n * Verilog source. These event waits are considered asynchronous if\n * all of the events in the list are ANYEDGE, and all the inputs to\n * the statement are included in the sensitivity list. If any of the\n * events are posedge or negedge, the statement is synchronous\n * (i.e. an edge-triggered flip-flop) and if any of the inputs are\n * unaccounted for in the sensitivity list then the statement is a\n * latch.\n */\nbool NetEvWait::is_asynchronous()\n{\n\t/* The \"sense\" set contains the set of Nexa that are in the\n\t   sensitivity list. We also require that the events are all\n\t   level sensitive, but the nex_async_ method takes care of\n\t   that test. */\n      NexusSet*sense = new NexusSet;\n      for (unsigned idx = 0 ;  idx < events_.size() ;  idx += 1) {\n\t    NexusSet*tmp = events_[idx]->nex_async_();\n\t    if (tmp == 0) {\n\t\t  delete sense;\n\t\t  return false;\n\t    }\n\n\t    sense->add(*tmp);\n\t    delete tmp;\n      }\n\n      NexusSet*inputs = statement_->nex_input();\n\n      if (! sense->contains(*inputs)) {\n\t    delete sense;\n\t    delete inputs;\n\t    return false;\n      }\n\n      delete sense;\n      delete inputs;\n\n\t/* If it passes all the other tests, then this statement is\n\t   asynchronous. */\n      return true;\n}\n\nbool NetProc::is_asynchronous()\n{\n      return false;\n}\n\nbool NetProcTop::is_asynchronous() const\n{\n      if (type_ == IVL_PR_INITIAL)\n\t    return false;\n\n      return statement_->is_asynchronous();\n}\n"
        },
        {
          "name": "autoconf.sh",
          "type": "blob",
          "size": 0.783203125,
          "content": "#!/bin/sh\n\n#\n# This shell script exists to run autoconf on source distributions\n# that are pulled from git The configure script is not included\n# in git, so it is easiest to just run this script whenever needed\n# to generate the configure script.\n#\n# wget -O config.guess 'https://git.savannah.gnu.org/cgit/config.git/plain/config.guess'\n# wget -O config.sub 'https://git.savannah.gnu.org/cgit/config.git/plain/config.sub'\necho \"Autoconf in root...\"\nautoconf -f\n\necho \"Precompiling lexor_keyword.gperf\"\ngperf -o -i 7 -C -k 1-4,6,9,\\$ -H keyword_hash -N check_identifier -t ./lexor_keyword.gperf > lexor_keyword.cc\n\necho \"Precompiling vhdlpp/lexor_keyword.gperf\"\n(cd vhdlpp ; gperf -o -i 7 --ignore-case -C -k 1-4,6,9,\\$ -H keyword_hash -N check_identifier -t ./lexor_keyword.gperf > lexor_keyword.cc )\n"
        },
        {
          "name": "cadpli",
          "type": "tree",
          "content": null
        },
        {
          "name": "check.conf",
          "type": "blob",
          "size": 0.0615234375,
          "content": "functor:cprop\nfunctor:nodangle\n-t:dll\nflag:DLL=tgt-vvp/vvp.tgt\n"
        },
        {
          "name": "compiler.h",
          "type": "blob",
          "size": 9.8701171875,
          "content": "#ifndef IVL_compiler_H\n#define IVL_compiler_H\n/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <list>\n# include  <map>\n# include  \"netlist.h\"\n# include  \"StringHeap.h\"\n\n/*\n * This defines constants and defaults for the compiler in general.\n */\n\n\n/*\n * The integer_width is the width of integer variables. This is also\n * the minimum width of unsized integers when they are found in\n * self-determined contexts.\n */\nextern unsigned integer_width;\n\n/*\n * The width_cap is the width limit for unsized expressions.\n */\nextern unsigned width_cap;\n\n/*\n * This is the maximum number of recursive module loops allowed within\n * a generate block.\n */\nextern unsigned recursive_mod_limit;\n\n/* The TIME_WIDTH is the width of time variables. */\n#ifndef TIME_WIDTH\n# define TIME_WIDTH 64\n#endif\n\n/*\n * When doing dynamic linking, we need a uniform way to identify the\n * symbol. Some compilers put leading _, some trailing _. The\n * configure script figures out which is the local convention and\n * defines NEED_LU and NEED_TU as required.\n */\n#ifdef NEED_LU\n#define LU \"_\"\n#else\n#define LU \"\"\n#endif\n\n#ifdef NEED_TU\n#define TU \"_\"\n#else\n#define TU \"\"\n#endif\n\n\n/*\n * These are flags to enable various sorts of warnings. By default all\n * the warnings are off, the -W<list> parameter arranges for each to be\n * enabled.\n */\n\n/* Implicit definitions of wires. */\nextern bool warn_implicit;\n\n/* Warn if dimensions of port or var/net are implicitly taken from\n   the input/output/inout declaration. */\nextern bool warn_implicit_dimensions;\n\n/* inherit timescales across files. */\nextern bool warn_timescale;\n\n/* Warn about legal but questionable module port bindings. */\nextern bool warn_portbinding;\n\n/* Warn about constant out of bound selects. */\nextern bool warn_ob_select;\n\n/* Warn about structures that may have infinite loops. */\nextern bool warn_inf_loop;\n\n/* Warn about always @* statements where a part or word select causes\n   sensitivity to an entire vector or array. */\nextern bool warn_sens_entire_vec;\nextern bool warn_sens_entire_arr;\n\n/* Warn about level-appropriate anachronisms. */\nextern bool warn_anachronisms;\n\n/* Warn about nets that are references but not driven. */\nextern bool warn_floating_nets;\n\n/* This is true if verbose output is requested. */\nextern bool verbose_flag;\n\nextern bool debug_scopes;\nextern bool debug_eval_tree;\nextern bool debug_elaborate;\nextern bool debug_emit;\nextern bool debug_synth2;\nextern bool debug_optimizer;\n\n/* Ignore errors about missing modules */\nextern bool ignore_missing_modules;\n\n/* Treat each source file as a separate compilation unit (as defined\n   by SystemVerilog). */\nextern bool separate_compilation;\n\n/* Control evaluation of functions at compile time:\n *   0 = only for functions in constant expressions\n *   1 = only for automatic functions\n *   2 = for all functions\n * Level 2 should only be used if the user can guarantee that a\n * function's local variables are never accessed from outside the\n * function. */\nextern unsigned opt_const_func;\n\n/* Possibly temporary flag to control virtualization of pin arrays */\nextern bool disable_virtual_pins;\n\n/* The vlog95 code generator does not want the compiler to generate concat-Z\n * LPM objects so this flag is used to block them from being generated. */\nextern bool disable_concatz_generation;\n\n/* Limit to size of devirtualized arrays */\nextern unsigned long array_size_limit;\n\n/* Path to a directory useful for finding subcomponents. */\nextern const char*basedir;\n\n/* This is an ordered list of library suffixes to search. */\nextern std::list<const char*>library_suff;\nextern int build_library_index(const char*path, bool key_case_sensitive);\n\n/* This is the generation of Verilog that the compiler is asked to\n   support. Then there are also more detailed controls for more\n   specific language features. Note that the compiler often assumes\n   this is an ordered list. */\nenum generation_t {\n      GN_VER1995  = 1,\n      GN_VER2001_NOCONFIG  = 2,\n      GN_VER2001  = 3,\n      GN_VER2005  = 4,\n      GN_VER2005_SV  = 5,\n      GN_VER2009  = 6,\n      GN_VER2012  = 7,\n      GN_DEFAULT  = 4\n};\n\nextern generation_t generation_flag;\n\n/* If this flag is true, enable extended types support. */\nextern bool gn_cadence_types_flag;\n\n/* If this flag is true, enable miscellaneous extensions. */\nextern bool gn_icarus_misc_flag;\n\n/* If this flag is true, then elaborate specify blocks. If this flag\n   is false, then skip elaboration of specify behavior. */\nextern bool gn_specify_blocks_flag;\n\n/* If this flag is true, then add input/output buffers to modules so that\n   VVP can insert intermodpaths inbetween. If this flag\n   is false, then no input/output buffers are inserted if not needed. */\nextern bool gn_interconnect_flag;\n\n/* If this flag is true, then elaborate supported assertion statements. If\n   this flag is false, then stub out supported assertion statements. */\nextern bool gn_supported_assertions_flag;\n/* If this flag is true, then error on unsupported assertion statements. If\n   this flag is false, then stub out unsupported assertion statements. */\nextern bool gn_unsupported_assertions_flag;\n\n/* If this flag is true, then support/elaborate Verilog-AMS. */\nextern bool gn_verilog_ams_flag;\n\n/* If this flag is false a warning is printed when the port declaration\n   is scalar and the net/register definition is vectored. */\nextern bool gn_io_range_error_flag;\n\n/* If this flag is true, then force re-evaluation of user functions\n   in a continuous assignment when any part of the expression is\n   re-evaluated. */\nextern bool gn_strict_ca_eval_flag;\n\n/* If this flag is true, then force strict conformance to the IEEE\n   standard expression width rules. */\nextern bool gn_strict_expr_width_flag;\n\n/* If this flag is true, then don't add a for-loop control variable\n   to an implicit event_expression list if it is only used inside the\n   loop. */\nextern bool gn_shared_loop_index_flag;\n\nstatic inline bool gn_system_verilog(void)\n{\n      if (generation_flag >= GN_VER2005_SV)\n\t    return true;\n      return false;\n}\n\n/* If variables can be converted to uwires by a continuous assignment\n   (assuming no procedural assign), then return true. This will be true\n   for SystemVerilog */\nstatic inline bool gn_var_can_be_uwire(void)\n{\n      return gn_system_verilog();\n}\n\nstatic inline bool gn_modules_nest(void)\n{\n      return gn_system_verilog();\n}\n\n/* The bits of these GN_KEYWORDS_* constants define non-intersecting\n   sets of keywords. The compiler enables groups of keywords by setting\n   lexor_keyword_mask with the OR of the bits for the keywords to be\n   enabled. */\nenum { GN_KEYWORDS_1364_1995        = 0x0001,\n       GN_KEYWORDS_1364_2001        = 0x0002,\n       GN_KEYWORDS_1364_2001_CONFIG = 0x0004,\n       GN_KEYWORDS_1364_2005        = 0x0008,\n       GN_KEYWORDS_VAMS_2_3         = 0x0010,\n       GN_KEYWORDS_1800_2005        = 0x0020,\n       GN_KEYWORDS_1800_2009        = 0x0040,\n       GN_KEYWORDS_1800_2012        = 0x0080,\n       GN_KEYWORDS_ICARUS           = 0x8000\n};\nextern int lexor_keyword_mask;\n\n  /* This is the string to use to invoke the preprocessor. */\nextern char*ivlpp_string;\n\nextern std::map<perm_string,unsigned> missing_modules;\n\n  /* Files that are library files are in this map. The lexor compares\n     file names as it processes `line directives, and if the file name\n     matches an entry in this table, it will turn on the\n     library_active_flag so that modules know that they are in a\n     library. */\nextern std::map<perm_string,bool> library_file_map;\n\n/*\n * the lex_strings are perm_strings made up of tokens from the source\n * file. Identifiers are so likely to be used many times that it makes\n * much sense to use a StringHeapLex to hold them.\n */\nextern StringHeapLex lex_strings;\n\n/*\n * The ivl_target.h API in a variety of places keeps strings of\n * bits. Manage these as perm_string in a StringHeap.\n */\nextern StringHeapLex bits_strings;\n\n/*\n * The filename_strings are perm_strings for file names. They are put\n * into their own StringHeapLex because these paths are used a *lot*\n * and this makes them more sure to hash together.\n */\nextern StringHeapLex filename_strings;\n\n\n/*\n * system task/function listings.\n */\n/*\n * This table describes all the return values of various system\n * functions. This table is used to elaborate expressions that are\n * system function calls.\n */\nstruct sfunc_return_type {\n      const char*   name;\n      ivl_variable_type_t type;\n      unsigned      wid;\n      bool          signed_flag;\n      bool          override_flag;\n};\n\nextern void add_sys_func(const struct sfunc_return_type&ret_type);\nextern const struct sfunc_return_type* lookup_sys_func(const char*name);\nextern int load_sys_func_table(const char*path);\nextern void cleanup_sys_func_table();\n/*\n * This temporarily loads a VPI module, to determine the return values\n * of system functions provided by that module, and adds the return values\n * to the system function table.\n */\nextern bool load_vpi_module(const char*path);\n\n/*\n * In system Verilog it is allowed with a warning to call a function\n * as a task. You can even cast the return value away and have no\n * warning message.\n */\nextern ivl_sfunc_as_task_t def_sfunc_as_task;\n\nextern void pre_process_failed(const char*text);\n\n#endif /* IVL_compiler_H */\n"
        },
        {
          "name": "config.guess",
          "type": "blob",
          "size": 49.5537109375,
          "content": "#! /bin/sh\n# Attempt to guess a canonical system name.\n#   Copyright 1992-2024 Free Software Foundation, Inc.\n\n# shellcheck disable=SC2006,SC2268 # see below for rationale\n\ntimestamp='2024-07-27'\n\n# This file is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that\n# program.  This Exception is an additional permission under section 7\n# of the GNU General Public License, version 3 (\"GPLv3\").\n#\n# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.\n#\n# You can get the latest version of this script from:\n# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess\n#\n# Please send patches to <config-patches@gnu.org>.\n\n\n# The \"shellcheck disable\" line above the timestamp inhibits complaints\n# about features and limitations of the classic Bourne shell that were\n# superseded or lifted in POSIX.  However, this script identifies a wide\n# variety of pre-POSIX systems that do not have POSIX shells at all, and\n# even some reasonably current systems (Solaris 10 as case-in-point) still\n# have a pre-POSIX /bin/sh.\n\n\nme=`echo \"$0\" | sed -e 's,.*/,,'`\n\nusage=\"\\\nUsage: $0 [OPTION]\n\nOutput the configuration name of the system '$me' is run on.\n\nOptions:\n  -h, --help         print this help, then exit\n  -t, --time-stamp   print date of last modification, then exit\n  -v, --version      print version number, then exit\n\nReport bugs and patches to <config-patches@gnu.org>.\"\n\nversion=\"\\\nGNU config.guess ($timestamp)\n\nOriginally written by Per Bothner.\nCopyright 1992-2024 Free Software Foundation, Inc.\n\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n\nhelp=\"\nTry '$me --help' for more information.\"\n\n# Parse command line\nwhile test $# -gt 0 ; do\n  case $1 in\n    --time-stamp | --time* | -t )\n       echo \"$timestamp\" ; exit ;;\n    --version | -v )\n       echo \"$version\" ; exit ;;\n    --help | --h* | -h )\n       echo \"$usage\"; exit ;;\n    -- )     # Stop option processing\n       shift; break ;;\n    - )\t# Use stdin as input.\n       break ;;\n    -* )\n       echo \"$me: invalid option $1$help\" >&2\n       exit 1 ;;\n    * )\n       break ;;\n  esac\ndone\n\nif test $# != 0; then\n  echo \"$me: too many arguments$help\" >&2\n  exit 1\nfi\n\n# Just in case it came from the environment.\nGUESS=\n\n# CC_FOR_BUILD -- compiler used by this script. Note that the use of a\n# compiler to aid in system detection is discouraged as it requires\n# temporary files to be created and, as you can see below, it is a\n# headache to deal with in a portable fashion.\n\n# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still\n# use 'HOST_CC' if defined, but it is deprecated.\n\n# Portable tmp directory creation inspired by the Autoconf team.\n\ntmp=\n# shellcheck disable=SC2172\ntrap 'test -z \"$tmp\" || rm -fr \"$tmp\"' 0 1 2 13 15\n\nset_cc_for_build() {\n    # prevent multiple calls if $tmp is already set\n    test \"$tmp\" && return 0\n    : \"${TMPDIR=/tmp}\"\n    # shellcheck disable=SC2039,SC3028\n    { tmp=`(umask 077 && mktemp -d \"$TMPDIR/cgXXXXXX\") 2>/dev/null` && test -n \"$tmp\" && test -d \"$tmp\" ; } ||\n\t{ test -n \"$RANDOM\" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir \"$tmp\" 2>/dev/null) ; } ||\n\t{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir \"$tmp\" 2>/dev/null) && echo \"Warning: creating insecure temp directory\" >&2 ; } ||\n\t{ echo \"$me: cannot create a temporary directory in $TMPDIR\" >&2 ; exit 1 ; }\n    dummy=$tmp/dummy\n    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in\n\t,,)    echo \"int x;\" > \"$dummy.c\"\n\t       for driver in cc gcc c17 c99 c89 ; do\n\t\t   if ($driver -c -o \"$dummy.o\" \"$dummy.c\") >/dev/null 2>&1 ; then\n\t\t       CC_FOR_BUILD=$driver\n\t\t       break\n\t\t   fi\n\t       done\n\t       if test x\"$CC_FOR_BUILD\" = x ; then\n\t\t   CC_FOR_BUILD=no_compiler_found\n\t       fi\n\t       ;;\n\t,,*)   CC_FOR_BUILD=$CC ;;\n\t,*,*)  CC_FOR_BUILD=$HOST_CC ;;\n    esac\n}\n\n# This is needed to find uname on a Pyramid OSx when run in the BSD universe.\n# (ghazi@noc.rutgers.edu 1994-08-24)\nif test -f /.attbin/uname ; then\n\tPATH=$PATH:/.attbin ; export PATH\nfi\n\nUNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown\nUNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown\nUNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown\nUNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown\n\ncase $UNAME_SYSTEM in\nLinux|GNU|GNU/*)\n\tLIBC=unknown\n\n\tset_cc_for_build\n\tcat <<-EOF > \"$dummy.c\"\n\t#if defined(__ANDROID__)\n\tLIBC=android\n\t#else\n\t#include <features.h>\n\t#if defined(__UCLIBC__)\n\tLIBC=uclibc\n\t#elif defined(__dietlibc__)\n\tLIBC=dietlibc\n\t#elif defined(__GLIBC__)\n\tLIBC=gnu\n\t#elif defined(__LLVM_LIBC__)\n\tLIBC=llvm\n\t#else\n\t#include <stdarg.h>\n\t/* First heuristic to detect musl libc.  */\n\t#ifdef __DEFINED_va_list\n\tLIBC=musl\n\t#endif\n\t#endif\n\t#endif\n\tEOF\n\tcc_set_libc=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`\n\teval \"$cc_set_libc\"\n\n\t# Second heuristic to detect musl libc.\n\tif [ \"$LIBC\" = unknown ] &&\n\t   command -v ldd >/dev/null &&\n\t   ldd --version 2>&1 | grep -q ^musl; then\n\t\tLIBC=musl\n\tfi\n\n\t# If the system lacks a compiler, then just pick glibc.\n\t# We could probably try harder.\n\tif [ \"$LIBC\" = unknown ]; then\n\t\tLIBC=gnu\n\tfi\n\t;;\nesac\n\n# Note: order is significant - the case branches are not exclusive.\n\ncase $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in\n    *:NetBSD:*:*)\n\t# NetBSD (nbsd) targets should (where applicable) match one or\n\t# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,\n\t# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently\n\t# switched to ELF, *-*-netbsd* would select the old\n\t# object file format.  This provides both forward\n\t# compatibility and a consistent mechanism for selecting the\n\t# object file format.\n\t#\n\t# Note: NetBSD doesn't particularly care about the vendor\n\t# portion of the name.  We always set it to \"unknown\".\n\tUNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \\\n\t    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \\\n\t    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \\\n\t    echo unknown)`\n\tcase $UNAME_MACHINE_ARCH in\n\t    aarch64eb) machine=aarch64_be-unknown ;;\n\t    armeb) machine=armeb-unknown ;;\n\t    arm*) machine=arm-unknown ;;\n\t    sh3el) machine=shl-unknown ;;\n\t    sh3eb) machine=sh-unknown ;;\n\t    sh5el) machine=sh5le-unknown ;;\n\t    earmv*)\n\t\tarch=`echo \"$UNAME_MACHINE_ARCH\" | sed -e 's,^e\\(armv[0-9]\\).*$,\\1,'`\n\t\tendian=`echo \"$UNAME_MACHINE_ARCH\" | sed -ne 's,^.*\\(eb\\)$,\\1,p'`\n\t\tmachine=${arch}${endian}-unknown\n\t\t;;\n\t    *) machine=$UNAME_MACHINE_ARCH-unknown ;;\n\tesac\n\t# The Operating System including object format, if it has switched\n\t# to ELF recently (or will in the future) and ABI.\n\tcase $UNAME_MACHINE_ARCH in\n\t    earm*)\n\t\tos=netbsdelf\n\t\t;;\n\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n\t\tset_cc_for_build\n\t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t\t\t| grep -q __ELF__\n\t\tthen\n\t\t    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).\n\t\t    # Return netbsd for either.  FIX?\n\t\t    os=netbsd\n\t\telse\n\t\t    os=netbsdelf\n\t\tfi\n\t\t;;\n\t    *)\n\t\tos=netbsd\n\t\t;;\n\tesac\n\t# Determine ABI tags.\n\tcase $UNAME_MACHINE_ARCH in\n\t    earm*)\n\t\texpr='s/^earmv[0-9]/-eabi/;s/eb$//'\n\t\tabi=`echo \"$UNAME_MACHINE_ARCH\" | sed -e \"$expr\"`\n\t\t;;\n\tesac\n\t# The OS release\n\t# Debian GNU/NetBSD machines have a different userland, and\n\t# thus, need a distinct triplet. However, they do not need\n\t# kernel version information, so it can be replaced with a\n\t# suitable tag, in the style of linux-gnu.\n\tcase $UNAME_VERSION in\n\t    Debian*)\n\t\trelease='-gnu'\n\t\t;;\n\t    *)\n\t\trelease=`echo \"$UNAME_RELEASE\" | sed -e 's/[-_].*//' | cut -d. -f1,2`\n\t\t;;\n\tesac\n\t# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:\n\t# contains redundant information, the shorter form:\n\t# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.\n\tGUESS=$machine-${os}${release}${abi-}\n\t;;\n    *:Bitrig:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE\n\t;;\n    *:OpenBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE\n\t;;\n    *:SecBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE\n\t;;\n    *:LibertyBSD:*:*)\n\tUNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\\.//'`\n\tGUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE\n\t;;\n    *:MidnightBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE\n\t;;\n    *:ekkoBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE\n\t;;\n    *:SolidBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE\n\t;;\n    *:OS108:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE\n\t;;\n    macppc:MirBSD:*:*)\n\tGUESS=powerpc-unknown-mirbsd$UNAME_RELEASE\n\t;;\n    *:MirBSD:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE\n\t;;\n    *:Sortix:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-sortix\n\t;;\n    *:Twizzler:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-twizzler\n\t;;\n    *:Redox:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-redox\n\t;;\n    mips:OSF1:*.*)\n\tGUESS=mips-dec-osf1\n\t;;\n    alpha:OSF1:*:*)\n\t# Reset EXIT trap before exiting to avoid spurious non-zero exit code.\n\ttrap '' 0\n\tcase $UNAME_RELEASE in\n\t*4.0)\n\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`\n\t\t;;\n\t*5.*)\n\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`\n\t\t;;\n\tesac\n\t# According to Compaq, /usr/sbin/psrinfo has been available on\n\t# OSF/1 and Tru64 systems produced since 1995.  I hope that\n\t# covers most systems running today.  This code pipes the CPU\n\t# types through head -n 1, so we only detect the type of CPU 0.\n\tALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \\(.*\\) processor.*$/\\1/p' | head -n 1`\n\tcase $ALPHA_CPU_TYPE in\n\t    \"EV4 (21064)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"EV4.5 (21064)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"LCA4 (21066/21068)\")\n\t\tUNAME_MACHINE=alpha ;;\n\t    \"EV5 (21164)\")\n\t\tUNAME_MACHINE=alphaev5 ;;\n\t    \"EV5.6 (21164A)\")\n\t\tUNAME_MACHINE=alphaev56 ;;\n\t    \"EV5.6 (21164PC)\")\n\t\tUNAME_MACHINE=alphapca56 ;;\n\t    \"EV5.7 (21164PC)\")\n\t\tUNAME_MACHINE=alphapca57 ;;\n\t    \"EV6 (21264)\")\n\t\tUNAME_MACHINE=alphaev6 ;;\n\t    \"EV6.7 (21264A)\")\n\t\tUNAME_MACHINE=alphaev67 ;;\n\t    \"EV6.8CB (21264C)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.8AL (21264B)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.8CX (21264D)\")\n\t\tUNAME_MACHINE=alphaev68 ;;\n\t    \"EV6.9A (21264/EV69A)\")\n\t\tUNAME_MACHINE=alphaev69 ;;\n\t    \"EV7 (21364)\")\n\t\tUNAME_MACHINE=alphaev7 ;;\n\t    \"EV7.9 (21364A)\")\n\t\tUNAME_MACHINE=alphaev79 ;;\n\tesac\n\t# A Pn.n version is a patched version.\n\t# A Vn.n version is a released version.\n\t# A Tn.n version is a released field test version.\n\t# A Xn.n version is an unreleased experimental baselevel.\n\t# 1.2 uses \"1.2\" for uname -r.\n\tOSF_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`\n\tGUESS=$UNAME_MACHINE-dec-osf$OSF_REL\n\t;;\n    Amiga*:UNIX_System_V:4.0:*)\n\tGUESS=m68k-unknown-sysv4\n\t;;\n    *:[Aa]miga[Oo][Ss]:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-amigaos\n\t;;\n    *:[Mm]orph[Oo][Ss]:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-morphos\n\t;;\n    *:OS/390:*:*)\n\tGUESS=i370-ibm-openedition\n\t;;\n    *:z/VM:*:*)\n\tGUESS=s390-ibm-zvmoe\n\t;;\n    *:OS400:*:*)\n\tGUESS=powerpc-ibm-os400\n\t;;\n    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)\n\tGUESS=arm-acorn-riscix$UNAME_RELEASE\n\t;;\n    arm*:riscos:*:*|arm*:RISCOS:*:*)\n\tGUESS=arm-unknown-riscos\n\t;;\n    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)\n\tGUESS=hppa1.1-hitachi-hiuxmpp\n\t;;\n    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)\n\t# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.\n\tcase `(/bin/universe) 2>/dev/null` in\n\t    att) GUESS=pyramid-pyramid-sysv3 ;;\n\t    *)   GUESS=pyramid-pyramid-bsd   ;;\n\tesac\n\t;;\n    NILE*:*:*:dcosx)\n\tGUESS=pyramid-pyramid-svr4\n\t;;\n    DRS?6000:unix:4.0:6*)\n\tGUESS=sparc-icl-nx6\n\t;;\n    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)\n\tcase `/usr/bin/uname -p` in\n\t    sparc) GUESS=sparc-icl-nx7 ;;\n\tesac\n\t;;\n    s390x:SunOS:*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL\n\t;;\n    sun4H:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-hal-solaris2$SUN_REL\n\t;;\n    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-sun-solaris2$SUN_REL\n\t;;\n    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n\tGUESS=i386-pc-auroraux$UNAME_RELEASE\n\t;;\n    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n\tset_cc_for_build\n\tSUN_ARCH=i386\n\t# If there is a compiler, see if it is configured for 64-bit objects.\n\t# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.\n\t# This test works for both compilers.\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \\\n\t\t(CCOPTS=\"\" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \\\n\t\tgrep IS_64BIT_ARCH >/dev/null\n\t    then\n\t\tSUN_ARCH=x86_64\n\t    fi\n\tfi\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=$SUN_ARCH-pc-solaris2$SUN_REL\n\t;;\n    sun4*:SunOS:6*:*)\n\t# According to config.sub, this is the proper way to canonicalize\n\t# SunOS6.  Hard to guess exactly what SunOS6 will be like, but\n\t# it's likely to be more like Solaris than SunOS4.\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=sparc-sun-solaris3$SUN_REL\n\t;;\n    sun4*:SunOS:*:*)\n\tcase `/usr/bin/arch -k` in\n\t    Series*|S4*)\n\t\tUNAME_RELEASE=`uname -v`\n\t\t;;\n\tesac\n\t# Japanese Language versions have a version number like '4.1.3-JL'.\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/-/_/'`\n\tGUESS=sparc-sun-sunos$SUN_REL\n\t;;\n    sun3*:SunOS:*:*)\n\tGUESS=m68k-sun-sunos$UNAME_RELEASE\n\t;;\n    sun*:*:4.2BSD:*)\n\tUNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`\n\ttest \"x$UNAME_RELEASE\" = x && UNAME_RELEASE=3\n\tcase `/bin/arch` in\n\t    sun3)\n\t\tGUESS=m68k-sun-sunos$UNAME_RELEASE\n\t\t;;\n\t    sun4)\n\t\tGUESS=sparc-sun-sunos$UNAME_RELEASE\n\t\t;;\n\tesac\n\t;;\n    aushp:SunOS:*:*)\n\tGUESS=sparc-auspex-sunos$UNAME_RELEASE\n\t;;\n    # The situation for MiNT is a little confusing.  The machine name\n    # can be virtually everything (everything which is not\n    # \"atarist\" or \"atariste\" at least should have a processor\n    # > m68000).  The system name ranges from \"MiNT\" over \"FreeMiNT\"\n    # to the lowercase version \"mint\" (or \"freemint\").  Finally\n    # the system name \"TOS\" denotes a system which is actually not\n    # MiNT.  But MiNT is downward compatible to TOS, so this should\n    # be no problem.\n    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)\n\tGUESS=m68k-atari-mint$UNAME_RELEASE\n\t;;\n    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)\n\tGUESS=m68k-milan-mint$UNAME_RELEASE\n\t;;\n    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)\n\tGUESS=m68k-hades-mint$UNAME_RELEASE\n\t;;\n    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)\n\tGUESS=m68k-unknown-mint$UNAME_RELEASE\n\t;;\n    m68k:machten:*:*)\n\tGUESS=m68k-apple-machten$UNAME_RELEASE\n\t;;\n    powerpc:machten:*:*)\n\tGUESS=powerpc-apple-machten$UNAME_RELEASE\n\t;;\n    RISC*:Mach:*:*)\n\tGUESS=mips-dec-mach_bsd4.3\n\t;;\n    RISC*:ULTRIX:*:*)\n\tGUESS=mips-dec-ultrix$UNAME_RELEASE\n\t;;\n    VAX*:ULTRIX*:*:*)\n\tGUESS=vax-dec-ultrix$UNAME_RELEASE\n\t;;\n    2020:CLIX:*:* | 2430:CLIX:*:*)\n\tGUESS=clipper-intergraph-clix$UNAME_RELEASE\n\t;;\n    mips:*:*:UMIPS | mips:*:*:RISCos)\n\tset_cc_for_build\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n#ifdef __cplusplus\n#include <stdio.h>  /* for printf() prototype */\n\tint main (int argc, char *argv[]) {\n#else\n\tint main (argc, argv) int argc; char *argv[]; {\n#endif\n\t#if defined (host_mips) && defined (MIPSEB)\n\t#if defined (SYSTYPE_SYSV)\n\t  printf (\"mips-mips-riscos%ssysv\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#if defined (SYSTYPE_SVR4)\n\t  printf (\"mips-mips-riscos%ssvr4\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)\n\t  printf (\"mips-mips-riscos%sbsd\\\\n\", argv[1]); exit (0);\n\t#endif\n\t#endif\n\t  exit (-1);\n\t}\nEOF\n\t$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" &&\n\t  dummyarg=`echo \"$UNAME_RELEASE\" | sed -n 's/\\([0-9]*\\).*/\\1/p'` &&\n\t  SYSTEM_NAME=`\"$dummy\" \"$dummyarg\"` &&\n\t    { echo \"$SYSTEM_NAME\"; exit; }\n\tGUESS=mips-mips-riscos$UNAME_RELEASE\n\t;;\n    Motorola:PowerMAX_OS:*:*)\n\tGUESS=powerpc-motorola-powermax\n\t;;\n    Motorola:*:4.3:PL8-*)\n\tGUESS=powerpc-harris-powermax\n\t;;\n    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)\n\tGUESS=powerpc-harris-powermax\n\t;;\n    Night_Hawk:Power_UNIX:*:*)\n\tGUESS=powerpc-harris-powerunix\n\t;;\n    m88k:CX/UX:7*:*)\n\tGUESS=m88k-harris-cxux7\n\t;;\n    m88k:*:4*:R4*)\n\tGUESS=m88k-motorola-sysv4\n\t;;\n    m88k:*:3*:R3*)\n\tGUESS=m88k-motorola-sysv3\n\t;;\n    AViiON:dgux:*:*)\n\t# DG/UX returns AViiON for all architectures\n\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n\tif test \"$UNAME_PROCESSOR\" = mc88100 || test \"$UNAME_PROCESSOR\" = mc88110\n\tthen\n\t    if test \"$TARGET_BINARY_INTERFACE\"x = m88kdguxelfx || \\\n\t       test \"$TARGET_BINARY_INTERFACE\"x = x\n\t    then\n\t\tGUESS=m88k-dg-dgux$UNAME_RELEASE\n\t    else\n\t\tGUESS=m88k-dg-dguxbcs$UNAME_RELEASE\n\t    fi\n\telse\n\t    GUESS=i586-dg-dgux$UNAME_RELEASE\n\tfi\n\t;;\n    M88*:DolphinOS:*:*)\t# DolphinOS (SVR3)\n\tGUESS=m88k-dolphin-sysv3\n\t;;\n    M88*:*:R3*:*)\n\t# Delta 88k system running SVR3\n\tGUESS=m88k-motorola-sysv3\n\t;;\n    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)\n\tGUESS=m88k-tektronix-sysv3\n\t;;\n    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)\n\tGUESS=m68k-tektronix-bsd\n\t;;\n    *:IRIX*:*:*)\n\tIRIX_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/-/_/g'`\n\tGUESS=mips-sgi-irix$IRIX_REL\n\t;;\n    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.\n\tGUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id\n\t;;                    # Note that: echo \"'`uname -s`'\" gives 'AIX '\n    i*86:AIX:*:*)\n\tGUESS=i386-ibm-aix\n\t;;\n    ia64:AIX:*:*)\n\tif test -x /usr/bin/oslevel ; then\n\t\tIBM_REV=`/usr/bin/oslevel`\n\telse\n\t\tIBM_REV=$UNAME_VERSION.$UNAME_RELEASE\n\tfi\n\tGUESS=$UNAME_MACHINE-ibm-aix$IBM_REV\n\t;;\n    *:AIX:2:3)\n\tif grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then\n\t\tset_cc_for_build\n\t\tsed 's/^\t\t//' << EOF > \"$dummy.c\"\n\t\t#include <sys/systemcfg.h>\n\n\t\tint\n\t\tmain ()\n\t\t\t{\n\t\t\tif (!__power_pc())\n\t\t\t\texit(1);\n\t\t\tputs(\"powerpc-ibm-aix3.2.5\");\n\t\t\texit(0);\n\t\t\t}\nEOF\n\t\tif $CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" && SYSTEM_NAME=`\"$dummy\"`\n\t\tthen\n\t\t\tGUESS=$SYSTEM_NAME\n\t\telse\n\t\t\tGUESS=rs6000-ibm-aix3.2.5\n\t\tfi\n\telif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then\n\t\tGUESS=rs6000-ibm-aix3.2.4\n\telse\n\t\tGUESS=rs6000-ibm-aix3.2\n\tfi\n\t;;\n    *:AIX:*:[4567])\n\tIBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`\n\tif /usr/sbin/lsattr -El \"$IBM_CPU_ID\" | grep ' POWER' >/dev/null 2>&1; then\n\t\tIBM_ARCH=rs6000\n\telse\n\t\tIBM_ARCH=powerpc\n\tfi\n\tif test -x /usr/bin/lslpp ; then\n\t\tIBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \\\n\t\t\t   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`\n\telse\n\t\tIBM_REV=$UNAME_VERSION.$UNAME_RELEASE\n\tfi\n\tGUESS=$IBM_ARCH-ibm-aix$IBM_REV\n\t;;\n    *:AIX:*:*)\n\tGUESS=rs6000-ibm-aix\n\t;;\n    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)\n\tGUESS=romp-ibm-bsd4.4\n\t;;\n    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and\n\tGUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to\n\t;;                                  # report: romp-ibm BSD 4.3\n    *:BOSX:*:*)\n\tGUESS=rs6000-bull-bosx\n\t;;\n    DPX/2?00:B.O.S.:*:*)\n\tGUESS=m68k-bull-sysv3\n\t;;\n    9000/[34]??:4.3bsd:1.*:*)\n\tGUESS=m68k-hp-bsd\n\t;;\n    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)\n\tGUESS=m68k-hp-bsd4.4\n\t;;\n    9000/[34678]??:HP-UX:*:*)\n\tHPUX_REV=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*.[0B]*//'`\n\tcase $UNAME_MACHINE in\n\t    9000/31?)            HP_ARCH=m68000 ;;\n\t    9000/[34]??)         HP_ARCH=m68k ;;\n\t    9000/[678][0-9][0-9])\n\t\tif test -x /usr/bin/getconf; then\n\t\t    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`\n\t\t    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`\n\t\t    case $sc_cpu_version in\n\t\t      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0\n\t\t      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1\n\t\t      532)                      # CPU_PA_RISC2_0\n\t\t\tcase $sc_kernel_bits in\n\t\t\t  32) HP_ARCH=hppa2.0n ;;\n\t\t\t  64) HP_ARCH=hppa2.0w ;;\n\t\t\t  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20\n\t\t\tesac ;;\n\t\t    esac\n\t\tfi\n\t\tif test \"$HP_ARCH\" = \"\"; then\n\t\t    set_cc_for_build\n\t\t    sed 's/^\t\t//' << EOF > \"$dummy.c\"\n\n\t\t#define _HPUX_SOURCE\n\t\t#include <stdlib.h>\n\t\t#include <unistd.h>\n\n\t\tint\n\t\tmain ()\n\t\t{\n\t\t#if defined(_SC_KERNEL_BITS)\n\t\t    long bits = sysconf(_SC_KERNEL_BITS);\n\t\t#endif\n\t\t    long cpu  = sysconf (_SC_CPU_VERSION);\n\n\t\t    switch (cpu)\n\t\t\t{\n\t\t\tcase CPU_PA_RISC1_0: puts (\"hppa1.0\"); break;\n\t\t\tcase CPU_PA_RISC1_1: puts (\"hppa1.1\"); break;\n\t\t\tcase CPU_PA_RISC2_0:\n\t\t#if defined(_SC_KERNEL_BITS)\n\t\t\t    switch (bits)\n\t\t\t\t{\n\t\t\t\tcase 64: puts (\"hppa2.0w\"); break;\n\t\t\t\tcase 32: puts (\"hppa2.0n\"); break;\n\t\t\t\tdefault: puts (\"hppa2.0\"); break;\n\t\t\t\t} break;\n\t\t#else  /* !defined(_SC_KERNEL_BITS) */\n\t\t\t    puts (\"hppa2.0\"); break;\n\t\t#endif\n\t\t\tdefault: puts (\"hppa1.0\"); break;\n\t\t\t}\n\t\t    exit (0);\n\t\t}\nEOF\n\t\t    (CCOPTS=\"\" $CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" 2>/dev/null) && HP_ARCH=`\"$dummy\"`\n\t\t    test -z \"$HP_ARCH\" && HP_ARCH=hppa\n\t\tfi ;;\n\tesac\n\tif test \"$HP_ARCH\" = hppa2.0w\n\tthen\n\t    set_cc_for_build\n\n\t    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating\n\t    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler\n\t    # generating 64-bit code.  GNU and HP use different nomenclature:\n\t    #\n\t    # $ CC_FOR_BUILD=cc ./config.guess\n\t    # => hppa2.0w-hp-hpux11.23\n\t    # $ CC_FOR_BUILD=\"cc +DA2.0w\" ./config.guess\n\t    # => hppa64-hp-hpux11.23\n\n\t    if echo __LP64__ | (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) |\n\t\tgrep -q __LP64__\n\t    then\n\t\tHP_ARCH=hppa2.0w\n\t    else\n\t\tHP_ARCH=hppa64\n\t    fi\n\tfi\n\tGUESS=$HP_ARCH-hp-hpux$HPUX_REV\n\t;;\n    ia64:HP-UX:*:*)\n\tHPUX_REV=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*.[0B]*//'`\n\tGUESS=ia64-hp-hpux$HPUX_REV\n\t;;\n    3050*:HI-UX:*:*)\n\tset_cc_for_build\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n\t#include <unistd.h>\n\tint\n\tmain ()\n\t{\n\t  long cpu = sysconf (_SC_CPU_VERSION);\n\t  /* The order matters, because CPU_IS_HP_MC68K erroneously returns\n\t     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct\n\t     results, however.  */\n\t  if (CPU_IS_PA_RISC (cpu))\n\t    {\n\t      switch (cpu)\n\t\t{\n\t\t  case CPU_PA_RISC1_0: puts (\"hppa1.0-hitachi-hiuxwe2\"); break;\n\t\t  case CPU_PA_RISC1_1: puts (\"hppa1.1-hitachi-hiuxwe2\"); break;\n\t\t  case CPU_PA_RISC2_0: puts (\"hppa2.0-hitachi-hiuxwe2\"); break;\n\t\t  default: puts (\"hppa-hitachi-hiuxwe2\"); break;\n\t\t}\n\t    }\n\t  else if (CPU_IS_HP_MC68K (cpu))\n\t    puts (\"m68k-hitachi-hiuxwe2\");\n\t  else puts (\"unknown-hitachi-hiuxwe2\");\n\t  exit (0);\n\t}\nEOF\n\t$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" && SYSTEM_NAME=`\"$dummy\"` &&\n\t\t{ echo \"$SYSTEM_NAME\"; exit; }\n\tGUESS=unknown-hitachi-hiuxwe2\n\t;;\n    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)\n\tGUESS=hppa1.1-hp-bsd\n\t;;\n    9000/8??:4.3bsd:*:*)\n\tGUESS=hppa1.0-hp-bsd\n\t;;\n    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)\n\tGUESS=hppa1.0-hp-mpeix\n\t;;\n    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)\n\tGUESS=hppa1.1-hp-osf\n\t;;\n    hp8??:OSF1:*:*)\n\tGUESS=hppa1.0-hp-osf\n\t;;\n    i*86:OSF1:*:*)\n\tif test -x /usr/sbin/sysversion ; then\n\t    GUESS=$UNAME_MACHINE-unknown-osf1mk\n\telse\n\t    GUESS=$UNAME_MACHINE-unknown-osf1\n\tfi\n\t;;\n    parisc*:Lites*:*:*)\n\tGUESS=hppa1.1-hp-lites\n\t;;\n    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)\n\tGUESS=c1-convex-bsd\n\t;;\n    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)\n\tif getsysinfo -f scalar_acc\n\tthen echo c32-convex-bsd\n\telse echo c2-convex-bsd\n\tfi\n\texit ;;\n    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)\n\tGUESS=c34-convex-bsd\n\t;;\n    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)\n\tGUESS=c38-convex-bsd\n\t;;\n    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)\n\tGUESS=c4-convex-bsd\n\t;;\n    CRAY*Y-MP:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=ymp-cray-unicos$CRAY_REL\n\t;;\n    CRAY*[A-Z]90:*:*:*)\n\techo \"$UNAME_MACHINE\"-cray-unicos\"$UNAME_RELEASE\" \\\n\t| sed -e 's/CRAY.*\\([A-Z]90\\)/\\1/' \\\n\t      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \\\n\t      -e 's/\\.[^.]*$/.X/'\n\texit ;;\n    CRAY*TS:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=t90-cray-unicos$CRAY_REL\n\t;;\n    CRAY*T3E:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=alphaev5-cray-unicosmk$CRAY_REL\n\t;;\n    CRAY*SV1:*:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=sv1-cray-unicos$CRAY_REL\n\t;;\n    *:UNICOS/mp:*:*)\n\tCRAY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/\\.[^.]*$/.X/'`\n\tGUESS=craynv-cray-unicosmp$CRAY_REL\n\t;;\n    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)\n\tFUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`\n\tFUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\\///'`\n\tFUJITSU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/ /_/'`\n\tGUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\n\t;;\n    5000:UNIX_System_V:4.*:*)\n\tFUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\\///'`\n\tFUJITSU_REL=`echo \"$UNAME_RELEASE\" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`\n\tGUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\n\t;;\n    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\\ Embedded/OS:*:*)\n\tGUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE\n\t;;\n    sparc*:BSD/OS:*:*)\n\tGUESS=sparc-unknown-bsdi$UNAME_RELEASE\n\t;;\n    *:BSD/OS:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE\n\t;;\n    arm:FreeBSD:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tset_cc_for_build\n\tif echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t    | grep -q __ARM_PCS_VFP\n\tthen\n\t    FREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\t    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi\n\telse\n\t    FREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\t    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf\n\tfi\n\t;;\n    *:FreeBSD:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tcase $UNAME_PROCESSOR in\n\t    amd64)\n\t\tUNAME_PROCESSOR=x86_64 ;;\n\t    i386)\n\t\tUNAME_PROCESSOR=i586 ;;\n\tesac\n\tFREEBSD_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL\n\t;;\n    i*:CYGWIN*:*)\n\tGUESS=$UNAME_MACHINE-pc-cygwin\n\t;;\n    *:MINGW64*:*)\n\tGUESS=$UNAME_MACHINE-pc-mingw64\n\t;;\n    *:MINGW*:*)\n\tGUESS=$UNAME_MACHINE-pc-mingw32\n\t;;\n    *:MSYS*:*)\n\tGUESS=$UNAME_MACHINE-pc-msys\n\t;;\n    i*:PW*:*)\n\tGUESS=$UNAME_MACHINE-pc-pw32\n\t;;\n    *:SerenityOS:*:*)\n        GUESS=$UNAME_MACHINE-pc-serenity\n        ;;\n    *:Interix*:*)\n\tcase $UNAME_MACHINE in\n\t    x86)\n\t\tGUESS=i586-pc-interix$UNAME_RELEASE\n\t\t;;\n\t    authenticamd | genuineintel | EM64T)\n\t\tGUESS=x86_64-unknown-interix$UNAME_RELEASE\n\t\t;;\n\t    IA64)\n\t\tGUESS=ia64-unknown-interix$UNAME_RELEASE\n\t\t;;\n\tesac ;;\n    i*:UWIN*:*)\n\tGUESS=$UNAME_MACHINE-pc-uwin\n\t;;\n    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)\n\tGUESS=x86_64-pc-cygwin\n\t;;\n    prep*:SunOS:5.*:*)\n\tSUN_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[^.]*//'`\n\tGUESS=powerpcle-unknown-solaris2$SUN_REL\n\t;;\n    *:GNU:*:*)\n\t# the GNU system\n\tGNU_ARCH=`echo \"$UNAME_MACHINE\" | sed -e 's,[-/].*$,,'`\n\tGNU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's,/.*$,,'`\n\tGUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL\n\t;;\n    *:GNU/*:*:*)\n\t# other systems with GNU libc and userland\n\tGNU_SYS=`echo \"$UNAME_SYSTEM\" | sed 's,^[^/]*/,,' | tr \"[:upper:]\" \"[:lower:]\"`\n\tGNU_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC\n\t;;\n    x86_64:[Mm]anagarm:*:*|i?86:[Mm]anagarm:*:*)\n\tGUESS=\"$UNAME_MACHINE-pc-managarm-mlibc\"\n\t;;\n    *:[Mm]anagarm:*:*)\n\tGUESS=\"$UNAME_MACHINE-unknown-managarm-mlibc\"\n\t;;\n    *:Minix:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-minix\n\t;;\n    aarch64:Linux:*:*)\n\tset_cc_for_build\n\tCPU=$UNAME_MACHINE\n\tLIBCABI=$LIBC\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    ABI=64\n\t    sed 's/^\t    //' << EOF > \"$dummy.c\"\n\t    #ifdef __ARM_EABI__\n\t    #ifdef __ARM_PCS_VFP\n\t    ABI=eabihf\n\t    #else\n\t    ABI=eabi\n\t    #endif\n\t    #endif\nEOF\n\t    cc_set_abi=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`\n\t    eval \"$cc_set_abi\"\n\t    case $ABI in\n\t\teabi | eabihf) CPU=armv8l; LIBCABI=$LIBC$ABI ;;\n\t    esac\n\tfi\n\tGUESS=$CPU-unknown-linux-$LIBCABI\n\t;;\n    aarch64_be:Linux:*:*)\n\tUNAME_MACHINE=aarch64_be\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    alpha:Linux:*:*)\n\tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' /proc/cpuinfo 2>/dev/null` in\n\t  EV5)   UNAME_MACHINE=alphaev5 ;;\n\t  EV56)  UNAME_MACHINE=alphaev56 ;;\n\t  PCA56) UNAME_MACHINE=alphapca56 ;;\n\t  PCA57) UNAME_MACHINE=alphapca56 ;;\n\t  EV6)   UNAME_MACHINE=alphaev6 ;;\n\t  EV67)  UNAME_MACHINE=alphaev67 ;;\n\t  EV68*) UNAME_MACHINE=alphaev68 ;;\n\tesac\n\tobjdump --private-headers /bin/sh | grep -q ld.so.1\n\tif test \"$?\" = 0 ; then LIBC=gnulibc1 ; fi\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    arm*:Linux:*:*)\n\tset_cc_for_build\n\tif echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t    | grep -q __ARM_EABI__\n\tthen\n\t    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\telse\n\t    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n\t\t| grep -q __ARM_PCS_VFP\n\t    then\n\t\tGUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi\n\t    else\n\t\tGUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf\n\t    fi\n\tfi\n\t;;\n    avr32*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    cris:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-axis-linux-$LIBC\n\t;;\n    crisv32:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-axis-linux-$LIBC\n\t;;\n    e2k:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    frv:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    hexagon:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    i*86:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-pc-linux-$LIBC\n\t;;\n    ia64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    k1om:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    kvx:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    kvx:cos:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-cos\n\t;;\n    kvx:mbr:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-mbr\n\t;;\n    loongarch32:Linux:*:* | loongarch64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    m32r*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    m68*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    mips:Linux:*:* | mips64:Linux:*:*)\n\tset_cc_for_build\n\tIS_GLIBC=0\n\ttest x\"${LIBC}\" = xgnu && IS_GLIBC=1\n\tsed 's/^\t//' << EOF > \"$dummy.c\"\n\t#undef CPU\n\t#undef mips\n\t#undef mipsel\n\t#undef mips64\n\t#undef mips64el\n\t#if ${IS_GLIBC} && defined(_ABI64)\n\tLIBCABI=gnuabi64\n\t#else\n\t#if ${IS_GLIBC} && defined(_ABIN32)\n\tLIBCABI=gnuabin32\n\t#else\n\tLIBCABI=${LIBC}\n\t#endif\n\t#endif\n\n\t#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6\n\tCPU=mipsisa64r6\n\t#else\n\t#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6\n\tCPU=mipsisa32r6\n\t#else\n\t#if defined(__mips64)\n\tCPU=mips64\n\t#else\n\tCPU=mips\n\t#endif\n\t#endif\n\t#endif\n\n\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)\n\tMIPS_ENDIAN=el\n\t#else\n\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)\n\tMIPS_ENDIAN=\n\t#else\n\tMIPS_ENDIAN=\n\t#endif\n\t#endif\nEOF\n\tcc_set_vars=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^CPU\\|^MIPS_ENDIAN\\|^LIBCABI'`\n\teval \"$cc_set_vars\"\n\ttest \"x$CPU\" != x && { echo \"$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI\"; exit; }\n\t;;\n    mips64el:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    openrisc*:Linux:*:*)\n\tGUESS=or1k-unknown-linux-$LIBC\n\t;;\n    or32:Linux:*:* | or1k*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    padre:Linux:*:*)\n\tGUESS=sparc-unknown-linux-$LIBC\n\t;;\n    parisc64:Linux:*:* | hppa64:Linux:*:*)\n\tGUESS=hppa64-unknown-linux-$LIBC\n\t;;\n    parisc:Linux:*:* | hppa:Linux:*:*)\n\t# Look for CPU level\n\tcase `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in\n\t  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;\n\t  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;\n\t  *)    GUESS=hppa-unknown-linux-$LIBC ;;\n\tesac\n\t;;\n    ppc64:Linux:*:*)\n\tGUESS=powerpc64-unknown-linux-$LIBC\n\t;;\n    ppc:Linux:*:*)\n\tGUESS=powerpc-unknown-linux-$LIBC\n\t;;\n    ppc64le:Linux:*:*)\n\tGUESS=powerpc64le-unknown-linux-$LIBC\n\t;;\n    ppcle:Linux:*:*)\n\tGUESS=powerpcle-unknown-linux-$LIBC\n\t;;\n    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    s390:Linux:*:* | s390x:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-ibm-linux-$LIBC\n\t;;\n    sh64*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    sh*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    sparc:Linux:*:* | sparc64:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    tile*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    vax:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-dec-linux-$LIBC\n\t;;\n    x86_64:Linux:*:*)\n\tset_cc_for_build\n\tCPU=$UNAME_MACHINE\n\tLIBCABI=$LIBC\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    ABI=64\n\t    sed 's/^\t    //' << EOF > \"$dummy.c\"\n\t    #ifdef __i386__\n\t    ABI=x86\n\t    #else\n\t    #ifdef __ILP32__\n\t    ABI=x32\n\t    #endif\n\t    #endif\nEOF\n\t    cc_set_abi=`$CC_FOR_BUILD -E \"$dummy.c\" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`\n\t    eval \"$cc_set_abi\"\n\t    case $ABI in\n\t\tx86) CPU=i686 ;;\n\t\tx32) LIBCABI=${LIBC}x32 ;;\n\t    esac\n\tfi\n\tGUESS=$CPU-pc-linux-$LIBCABI\n\t;;\n    xtensa*:Linux:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-linux-$LIBC\n\t;;\n    i*86:DYNIX/ptx:4*:*)\n\t# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.\n\t# earlier versions are messed up and put the nodename in both\n\t# sysname and nodename.\n\tGUESS=i386-sequent-sysv4\n\t;;\n    i*86:UNIX_SV:4.2MP:2.*)\n\t# Unixware is an offshoot of SVR4, but it has its own version\n\t# number series starting with 2...\n\t# I am not positive that other SVR4 systems won't match this,\n\t# I just have to hope.  -- rms.\n\t# Use sysv4.2uw... so that sysv4* matches it.\n\tGUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION\n\t;;\n    i*86:OS/2:*:*)\n\t# If we were able to find 'uname', then EMX Unix compatibility\n\t# is probably installed.\n\tGUESS=$UNAME_MACHINE-pc-os2-emx\n\t;;\n    i*86:XTS-300:*:STOP)\n\tGUESS=$UNAME_MACHINE-unknown-stop\n\t;;\n    i*86:atheos:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-atheos\n\t;;\n    i*86:syllable:*:*)\n\tGUESS=$UNAME_MACHINE-pc-syllable\n\t;;\n    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)\n\tGUESS=i386-unknown-lynxos$UNAME_RELEASE\n\t;;\n    i*86:*DOS:*:*)\n\tGUESS=$UNAME_MACHINE-pc-msdosdjgpp\n\t;;\n    i*86:*:4.*:*)\n\tUNAME_REL=`echo \"$UNAME_RELEASE\" | sed 's/\\/MP$//'`\n\tif grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then\n\t\tGUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL\n\telse\n\t\tGUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL\n\tfi\n\t;;\n    i*86:*:5:[678]*)\n\t# UnixWare 7.x, OpenUNIX and OpenServer 6.\n\tcase `/bin/uname -X | grep \"^Machine\"` in\n\t    *486*)\t     UNAME_MACHINE=i486 ;;\n\t    *Pentium)\t     UNAME_MACHINE=i586 ;;\n\t    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;\n\tesac\n\tGUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}\n\t;;\n    i*86:*:3.2:*)\n\tif test -f /usr/options/cb.name; then\n\t\tUNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`\n\t\tGUESS=$UNAME_MACHINE-pc-isc$UNAME_REL\n\telif /bin/uname -X 2>/dev/null >/dev/null ; then\n\t\tUNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`\n\t\t(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486\n\t\t(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i586\n\t\t(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i686\n\t\t(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \\\n\t\t\t&& UNAME_MACHINE=i686\n\t\tGUESS=$UNAME_MACHINE-pc-sco$UNAME_REL\n\telse\n\t\tGUESS=$UNAME_MACHINE-pc-sysv32\n\tfi\n\t;;\n    pc:*:*:*)\n\t# Left here for compatibility:\n\t# uname -m prints for DJGPP always 'pc', but it prints nothing about\n\t# the processor, so we play safe by assuming i586.\n\t# Note: whatever this is, it MUST be the same as what config.sub\n\t# prints for the \"djgpp\" host, or else GDB configure will decide that\n\t# this is a cross-build.\n\tGUESS=i586-pc-msdosdjgpp\n\t;;\n    Intel:Mach:3*:*)\n\tGUESS=i386-pc-mach3\n\t;;\n    paragon:*:*:*)\n\tGUESS=i860-intel-osf1\n\t;;\n    i860:*:4.*:*) # i860-SVR4\n\tif grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then\n\t  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4\n\telse # Add other i860-SVR4 vendors below as they are discovered.\n\t  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4\n\tfi\n\t;;\n    mini*:CTIX:SYS*5:*)\n\t# \"miniframe\"\n\tGUESS=m68010-convergent-sysv\n\t;;\n    mc68k:UNIX:SYSTEM5:3.51m)\n\tGUESS=m68k-convergent-sysv\n\t;;\n    M680?0:D-NIX:5.3:*)\n\tGUESS=m68k-diab-dnix\n\t;;\n    M68*:*:R3V[5678]*:*)\n\ttest -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;\n    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)\n\tOS_REL=''\n\ttest -r /etc/.relid \\\n\t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t  && { echo i486-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n\t  && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; } ;;\n    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t  && { echo i486-ncr-sysv4; exit; } ;;\n    NCR*:*:4.2:* | MPRAS*:*:4.2:*)\n\tOS_REL='.3'\n\ttest -r /etc/.relid \\\n\t    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n\t    && { echo i486-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n\t    && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; }\n\t/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \\\n\t    && { echo i586-ncr-sysv4.3\"$OS_REL\"; exit; } ;;\n    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)\n\tGUESS=m68k-unknown-lynxos$UNAME_RELEASE\n\t;;\n    mc68030:UNIX_System_V:4.*:*)\n\tGUESS=m68k-atari-sysv4\n\t;;\n    TSUNAMI:LynxOS:2.*:*)\n\tGUESS=sparc-unknown-lynxos$UNAME_RELEASE\n\t;;\n    rs6000:LynxOS:2.*:*)\n\tGUESS=rs6000-unknown-lynxos$UNAME_RELEASE\n\t;;\n    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)\n\tGUESS=powerpc-unknown-lynxos$UNAME_RELEASE\n\t;;\n    SM[BE]S:UNIX_SV:*:*)\n\tGUESS=mips-dde-sysv$UNAME_RELEASE\n\t;;\n    RM*:ReliantUNIX-*:*:*)\n\tGUESS=mips-sni-sysv4\n\t;;\n    RM*:SINIX-*:*:*)\n\tGUESS=mips-sni-sysv4\n\t;;\n    *:SINIX-*:*:*)\n\tif uname -p 2>/dev/null >/dev/null ; then\n\t\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n\t\tGUESS=$UNAME_MACHINE-sni-sysv4\n\telse\n\t\tGUESS=ns32k-sni-sysv\n\tfi\n\t;;\n    PENTIUM:*:4.0*:*)\t# Unisys 'ClearPath HMP IX 4000' SVR4/MP effort\n\t\t\t# says <Richard.M.Bartel@ccMail.Census.GOV>\n\tGUESS=i586-unisys-sysv4\n\t;;\n    *:UNIX_System_V:4*:FTX*)\n\t# From Gerald Hewes <hewes@openmarket.com>.\n\t# How about differentiating between stratus architectures? -djm\n\tGUESS=hppa1.1-stratus-sysv4\n\t;;\n    *:*:*:FTX*)\n\t# From seanf@swdc.stratus.com.\n\tGUESS=i860-stratus-sysv4\n\t;;\n    i*86:VOS:*:*)\n\t# From Paul.Green@stratus.com.\n\tGUESS=$UNAME_MACHINE-stratus-vos\n\t;;\n    *:VOS:*:*)\n\t# From Paul.Green@stratus.com.\n\tGUESS=hppa1.1-stratus-vos\n\t;;\n    mc68*:A/UX:*:*)\n\tGUESS=m68k-apple-aux$UNAME_RELEASE\n\t;;\n    news*:NEWS-OS:6*:*)\n\tGUESS=mips-sony-newsos6\n\t;;\n    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)\n\tif test -d /usr/nec; then\n\t\tGUESS=mips-nec-sysv$UNAME_RELEASE\n\telse\n\t\tGUESS=mips-unknown-sysv$UNAME_RELEASE\n\tfi\n\t;;\n    BeBox:BeOS:*:*)\t# BeOS running on hardware made by Be, PPC only.\n\tGUESS=powerpc-be-beos\n\t;;\n    BeMac:BeOS:*:*)\t# BeOS running on Mac or Mac clone, PPC only.\n\tGUESS=powerpc-apple-beos\n\t;;\n    BePC:BeOS:*:*)\t# BeOS running on Intel PC compatible.\n\tGUESS=i586-pc-beos\n\t;;\n    BePC:Haiku:*:*)\t# Haiku running on Intel PC compatible.\n\tGUESS=i586-pc-haiku\n\t;;\n    ppc:Haiku:*:*)\t# Haiku running on Apple PowerPC\n\tGUESS=powerpc-apple-haiku\n\t;;\n    *:Haiku:*:*)\t# Haiku modern gcc (not bound by BeOS compat)\n\tGUESS=$UNAME_MACHINE-unknown-haiku\n\t;;\n    SX-4:SUPER-UX:*:*)\n\tGUESS=sx4-nec-superux$UNAME_RELEASE\n\t;;\n    SX-5:SUPER-UX:*:*)\n\tGUESS=sx5-nec-superux$UNAME_RELEASE\n\t;;\n    SX-6:SUPER-UX:*:*)\n\tGUESS=sx6-nec-superux$UNAME_RELEASE\n\t;;\n    SX-7:SUPER-UX:*:*)\n\tGUESS=sx7-nec-superux$UNAME_RELEASE\n\t;;\n    SX-8:SUPER-UX:*:*)\n\tGUESS=sx8-nec-superux$UNAME_RELEASE\n\t;;\n    SX-8R:SUPER-UX:*:*)\n\tGUESS=sx8r-nec-superux$UNAME_RELEASE\n\t;;\n    SX-ACE:SUPER-UX:*:*)\n\tGUESS=sxace-nec-superux$UNAME_RELEASE\n\t;;\n    Power*:Rhapsody:*:*)\n\tGUESS=powerpc-apple-rhapsody$UNAME_RELEASE\n\t;;\n    *:Rhapsody:*:*)\n\tGUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE\n\t;;\n    arm64:Darwin:*:*)\n\tGUESS=aarch64-apple-darwin$UNAME_RELEASE\n\t;;\n    *:Darwin:*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tcase $UNAME_PROCESSOR in\n\t    unknown) UNAME_PROCESSOR=powerpc ;;\n\tesac\n\tif command -v xcode-select > /dev/null 2> /dev/null && \\\n\t\t! xcode-select --print-path > /dev/null 2> /dev/null ; then\n\t    # Avoid executing cc if there is no toolchain installed as\n\t    # cc will be a stub that puts up a graphical alert\n\t    # prompting the user to install developer tools.\n\t    CC_FOR_BUILD=no_compiler_found\n\telse\n\t    set_cc_for_build\n\tfi\n\tif test \"$CC_FOR_BUILD\" != no_compiler_found; then\n\t    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \\\n\t\t   (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) | \\\n\t\t   grep IS_64BIT_ARCH >/dev/null\n\t    then\n\t\tcase $UNAME_PROCESSOR in\n\t\t    i386) UNAME_PROCESSOR=x86_64 ;;\n\t\t    powerpc) UNAME_PROCESSOR=powerpc64 ;;\n\t\tesac\n\t    fi\n\t    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc\n\t    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \\\n\t\t   (CCOPTS=\"\" $CC_FOR_BUILD -E - 2>/dev/null) | \\\n\t\t   grep IS_PPC >/dev/null\n\t    then\n\t\tUNAME_PROCESSOR=powerpc\n\t    fi\n\telif test \"$UNAME_PROCESSOR\" = i386 ; then\n\t    # uname -m returns i386 or x86_64\n\t    UNAME_PROCESSOR=$UNAME_MACHINE\n\tfi\n\tGUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE\n\t;;\n    *:procnto*:*:* | *:QNX:[0123456789]*:*)\n\tUNAME_PROCESSOR=`uname -p`\n\tif test \"$UNAME_PROCESSOR\" = x86; then\n\t\tUNAME_PROCESSOR=i386\n\t\tUNAME_MACHINE=pc\n\tfi\n\tGUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE\n\t;;\n    *:QNX:*:4*)\n\tGUESS=i386-pc-qnx\n\t;;\n    NEO-*:NONSTOP_KERNEL:*:*)\n\tGUESS=neo-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSE-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nse-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSR-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsr-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSV-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsv-tandem-nsk$UNAME_RELEASE\n\t;;\n    NSX-*:NONSTOP_KERNEL:*:*)\n\tGUESS=nsx-tandem-nsk$UNAME_RELEASE\n\t;;\n    *:NonStop-UX:*:*)\n\tGUESS=mips-compaq-nonstopux\n\t;;\n    BS2000:POSIX*:*:*)\n\tGUESS=bs2000-siemens-sysv\n\t;;\n    DS/*:UNIX_System_V:*:*)\n\tGUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE\n\t;;\n    *:Plan9:*:*)\n\t# \"uname -m\" is not consistent, so use $cputype instead. 386\n\t# is converted to i386 for consistency with other x86\n\t# operating systems.\n\tif test \"${cputype-}\" = 386; then\n\t    UNAME_MACHINE=i386\n\telif test \"x${cputype-}\" != x; then\n\t    UNAME_MACHINE=$cputype\n\tfi\n\tGUESS=$UNAME_MACHINE-unknown-plan9\n\t;;\n    *:TOPS-10:*:*)\n\tGUESS=pdp10-unknown-tops10\n\t;;\n    *:TENEX:*:*)\n\tGUESS=pdp10-unknown-tenex\n\t;;\n    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)\n\tGUESS=pdp10-dec-tops20\n\t;;\n    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)\n\tGUESS=pdp10-xkl-tops20\n\t;;\n    *:TOPS-20:*:*)\n\tGUESS=pdp10-unknown-tops20\n\t;;\n    *:ITS:*:*)\n\tGUESS=pdp10-unknown-its\n\t;;\n    SEI:*:*:SEIUX)\n\tGUESS=mips-sei-seiux$UNAME_RELEASE\n\t;;\n    *:DragonFly:*:*)\n\tDRAGONFLY_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/[-(].*//'`\n\tGUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL\n\t;;\n    *:*VMS:*:*)\n\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n\tcase $UNAME_MACHINE in\n\t    A*) GUESS=alpha-dec-vms ;;\n\t    I*) GUESS=ia64-dec-vms ;;\n\t    V*) GUESS=vax-dec-vms ;;\n\tesac ;;\n    *:XENIX:*:SysV)\n\tGUESS=i386-pc-xenix\n\t;;\n    i*86:skyos:*:*)\n\tSKYOS_REL=`echo \"$UNAME_RELEASE\" | sed -e 's/ .*$//'`\n\tGUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL\n\t;;\n    i*86:rdos:*:*)\n\tGUESS=$UNAME_MACHINE-pc-rdos\n\t;;\n    i*86:Fiwix:*:*)\n\tGUESS=$UNAME_MACHINE-pc-fiwix\n\t;;\n    *:AROS:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-aros\n\t;;\n    x86_64:VMkernel:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-esx\n\t;;\n    amd64:Isilon\\ OneFS:*:*)\n\tGUESS=x86_64-unknown-onefs\n\t;;\n    *:Unleashed:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE\n\t;;\n    *:Ironclad:*:*)\n\tGUESS=$UNAME_MACHINE-unknown-ironclad\n\t;;\nesac\n\n# Do we have a guess based on uname results?\nif test \"x$GUESS\" != x; then\n    echo \"$GUESS\"\n    exit\nfi\n\n# No uname command or uname output not recognized.\nset_cc_for_build\ncat > \"$dummy.c\" <<EOF\n#ifdef _SEQUENT_\n#include <sys/types.h>\n#include <sys/utsname.h>\n#endif\n#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)\n#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)\n#include <signal.h>\n#if defined(_SIZE_T_) || defined(SIGLOST)\n#include <sys/utsname.h>\n#endif\n#endif\n#endif\nint\nmain ()\n{\n#if defined (sony)\n#if defined (MIPSEB)\n  /* BFD wants \"bsd\" instead of \"newsos\".  Perhaps BFD should be changed,\n     I don't know....  */\n  printf (\"mips-sony-bsd\\n\"); exit (0);\n#else\n#include <sys/param.h>\n  printf (\"m68k-sony-newsos%s\\n\",\n#ifdef NEWSOS4\n  \"4\"\n#else\n  \"\"\n#endif\n  ); exit (0);\n#endif\n#endif\n\n#if defined (NeXT)\n#if !defined (__ARCHITECTURE__)\n#define __ARCHITECTURE__ \"m68k\"\n#endif\n  int version;\n  version=`(hostinfo | sed -n 's/.*NeXT Mach \\([0-9]*\\).*/\\1/p') 2>/dev/null`;\n  if (version < 4)\n    printf (\"%s-next-nextstep%d\\n\", __ARCHITECTURE__, version);\n  else\n    printf (\"%s-next-openstep%d\\n\", __ARCHITECTURE__, version);\n  exit (0);\n#endif\n\n#if defined (MULTIMAX) || defined (n16)\n#if defined (UMAXV)\n  printf (\"ns32k-encore-sysv\\n\"); exit (0);\n#else\n#if defined (CMU)\n  printf (\"ns32k-encore-mach\\n\"); exit (0);\n#else\n  printf (\"ns32k-encore-bsd\\n\"); exit (0);\n#endif\n#endif\n#endif\n\n#if defined (__386BSD__)\n  printf (\"i386-pc-bsd\\n\"); exit (0);\n#endif\n\n#if defined (sequent)\n#if defined (i386)\n  printf (\"i386-sequent-dynix\\n\"); exit (0);\n#endif\n#if defined (ns32000)\n  printf (\"ns32k-sequent-dynix\\n\"); exit (0);\n#endif\n#endif\n\n#if defined (_SEQUENT_)\n  struct utsname un;\n\n  uname(&un);\n  if (strncmp(un.version, \"V2\", 2) == 0) {\n    printf (\"i386-sequent-ptx2\\n\"); exit (0);\n  }\n  if (strncmp(un.version, \"V1\", 2) == 0) { /* XXX is V1 correct? */\n    printf (\"i386-sequent-ptx1\\n\"); exit (0);\n  }\n  printf (\"i386-sequent-ptx\\n\"); exit (0);\n#endif\n\n#if defined (vax)\n#if !defined (ultrix)\n#include <sys/param.h>\n#if defined (BSD)\n#if BSD == 43\n  printf (\"vax-dec-bsd4.3\\n\"); exit (0);\n#else\n#if BSD == 199006\n  printf (\"vax-dec-bsd4.3reno\\n\"); exit (0);\n#else\n  printf (\"vax-dec-bsd\\n\"); exit (0);\n#endif\n#endif\n#else\n  printf (\"vax-dec-bsd\\n\"); exit (0);\n#endif\n#else\n#if defined(_SIZE_T_) || defined(SIGLOST)\n  struct utsname un;\n  uname (&un);\n  printf (\"vax-dec-ultrix%s\\n\", un.release); exit (0);\n#else\n  printf (\"vax-dec-ultrix\\n\"); exit (0);\n#endif\n#endif\n#endif\n#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)\n#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)\n#if defined(_SIZE_T_) || defined(SIGLOST)\n  struct utsname *un;\n  uname (&un);\n  printf (\"mips-dec-ultrix%s\\n\", un.release); exit (0);\n#else\n  printf (\"mips-dec-ultrix\\n\"); exit (0);\n#endif\n#endif\n#endif\n\n#if defined (alliant) && defined (i860)\n  printf (\"i860-alliant-bsd\\n\"); exit (0);\n#endif\n\n  exit (1);\n}\nEOF\n\n$CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" 2>/dev/null && SYSTEM_NAME=`\"$dummy\"` &&\n\t{ echo \"$SYSTEM_NAME\"; exit; }\n\n# Apollos put the system type in the environment.\ntest -d /usr/apollo && { echo \"$ISP-apollo-$SYSTYPE\"; exit; }\n\necho \"$0: unable to guess system type\" >&2\n\ncase $UNAME_MACHINE:$UNAME_SYSTEM in\n    mips:Linux | mips64:Linux)\n\t# If we got here on MIPS GNU/Linux, output extra information.\n\tcat >&2 <<EOF\n\nNOTE: MIPS GNU/Linux systems require a C compiler to fully recognize\nthe system type. Please install a C compiler and try again.\nEOF\n\t;;\nesac\n\ncat >&2 <<EOF\n\nThis script (version $timestamp), has failed to recognize the\noperating system you are using. If your script is old, overwrite *all*\ncopies of config.guess and config.sub with the latest versions from:\n\n  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess\nand\n  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub\nEOF\n\nour_year=`echo $timestamp | sed 's,-.*,,'`\nthisyear=`date +%Y`\n# shellcheck disable=SC2003\nscript_age=`expr \"$thisyear\" - \"$our_year\"`\nif test \"$script_age\" -lt 3 ; then\n   cat >&2 <<EOF\n\nIf $0 has already been updated, send the following data and any\ninformation you think might be pertinent to config-patches@gnu.org to\nprovide the necessary information to handle your system.\n\nconfig.guess timestamp = $timestamp\n\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`\n\nhostinfo               = `(hostinfo) 2>/dev/null`\n/bin/universe          = `(/bin/universe) 2>/dev/null`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`\n/bin/arch              = `(/bin/arch) 2>/dev/null`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`\n\nUNAME_MACHINE = \"$UNAME_MACHINE\"\nUNAME_RELEASE = \"$UNAME_RELEASE\"\nUNAME_SYSTEM  = \"$UNAME_SYSTEM\"\nUNAME_VERSION = \"$UNAME_VERSION\"\nEOF\nfi\n\nexit 1\n\n# Local variables:\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-start: \"timestamp='\"\n# time-stamp-format: \"%:y-%02m-%02d\"\n# time-stamp-end: \"'\"\n# End:\n"
        },
        {
          "name": "config.h.in",
          "type": "blob",
          "size": 1.7333984375,
          "content": "#ifndef IVL_config_H                                           /* -*- c++ -*- */\n#define IVL_config_H\n/*\n * Copyright (c) 2001-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# undef NEED_LU\n# undef NEED_TU\n# undef WLU\n# undef WTU\n# undef HAVE_TIMES\n# undef HAVE_IOSFWD\n# undef HAVE_GETOPT_H\n# undef HAVE_INTTYPES_H\n# undef HAVE_LIBIBERTY_H\n# undef HAVE_DLFCN_H\n# undef HAVE_DL_H\n# undef HAVE_FCHMOD\n# undef HAVE_LIBREADLINE\n# undef HAVE_LIBZ\n# undef HAVE_LIBBZ2\n# undef HAVE_LROUND\n# undef HAVE_SYS_WAIT_H\n# undef WORDS_BIGENDIAN\n\n#ifdef HAVE_INTTYPES_H\n# include  <inttypes.h>\n#endif\n\n/* These two are needed by the lxt and lxt2 files (copied from GTKWave). */\n# undef HAVE_ALLOCA_H\n# undef HAVE_FSEEKO\n/* And this is needed by the fst files (copied from GTKWave). */\n# undef HAVE_LIBPTHREAD\n# undef HAVE_REALPATH\n\n/*\n * Define this if you want to compile vvp with memory freeing and\n * special valgrind hooks for the memory pools.\n */\n# undef CHECK_WITH_VALGRIND\n\n#endif /* IVL_config_H */\n"
        },
        {
          "name": "config.sub",
          "type": "blob",
          "size": 38.7822265625,
          "content": "#! /bin/sh\n# Configuration validation subroutine script.\n#   Copyright 1992-2024 Free Software Foundation, Inc.\n\n# shellcheck disable=SC2006,SC2268,SC2162 # see below for rationale\n\ntimestamp='2024-05-27'\n\n# This file is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that\n# program.  This Exception is an additional permission under section 7\n# of the GNU General Public License, version 3 (\"GPLv3\").\n\n\n# Please send patches to <config-patches@gnu.org>.\n#\n# Configuration subroutine to validate and canonicalize a configuration type.\n# Supply the specified configuration type as an argument.\n# If it is invalid, we print an error message on stderr and exit with code 1.\n# Otherwise, we print the canonical config type on stdout and succeed.\n\n# You can get the latest version of this script from:\n# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub\n\n# This file is supposed to be the same for all GNU packages\n# and recognize all the CPU types, system types and aliases\n# that are meaningful with *any* GNU software.\n# Each package is responsible for reporting which valid configurations\n# it does not support.  The user should be able to distinguish\n# a failure to support a valid configuration from a meaningless\n# configuration.\n\n# The goal of this file is to map all the various variations of a given\n# machine specification into a single specification in the form:\n#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n# or in some cases, the newer four-part form:\n#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n# It is wrong to echo any other type of specification.\n\n# The \"shellcheck disable\" line above the timestamp inhibits complaints\n# about features and limitations of the classic Bourne shell that were\n# superseded or lifted in POSIX.  However, this script identifies a wide\n# variety of pre-POSIX systems that do not have POSIX shells at all, and\n# even some reasonably current systems (Solaris 10 as case-in-point) still\n# have a pre-POSIX /bin/sh.\n\nme=`echo \"$0\" | sed -e 's,.*/,,'`\n\nusage=\"\\\nUsage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS\n\nCanonicalize a configuration name.\n\nOptions:\n  -h, --help         print this help, then exit\n  -t, --time-stamp   print date of last modification, then exit\n  -v, --version      print version number, then exit\n\nReport bugs and patches to <config-patches@gnu.org>.\"\n\nversion=\"\\\nGNU config.sub ($timestamp)\n\nCopyright 1992-2024 Free Software Foundation, Inc.\n\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n\nhelp=\"\nTry '$me --help' for more information.\"\n\n# Parse command line\nwhile test $# -gt 0 ; do\n  case $1 in\n    --time-stamp | --time* | -t )\n       echo \"$timestamp\" ; exit ;;\n    --version | -v )\n       echo \"$version\" ; exit ;;\n    --help | --h* | -h )\n       echo \"$usage\"; exit ;;\n    -- )     # Stop option processing\n       shift; break ;;\n    - )\t# Use stdin as input.\n       break ;;\n    -* )\n       echo \"$me: invalid option $1$help\" >&2\n       exit 1 ;;\n\n    *local*)\n       # First pass through any local machine types.\n       echo \"$1\"\n       exit ;;\n\n    * )\n       break ;;\n  esac\ndone\n\ncase $# in\n 0) echo \"$me: missing argument$help\" >&2\n    exit 1;;\n 1) ;;\n *) echo \"$me: too many arguments$help\" >&2\n    exit 1;;\nesac\n\n# Split fields of configuration type\nsaved_IFS=$IFS\nIFS=\"-\" read field1 field2 field3 field4 <<EOF\n$1\nEOF\nIFS=$saved_IFS\n\n# Separate into logical components for further validation\ncase $1 in\n\t*-*-*-*-*)\n\t\techo \"Invalid configuration '$1': more than four components\" >&2\n\t\texit 1\n\t\t;;\n\t*-*-*-*)\n\t\tbasic_machine=$field1-$field2\n\t\tbasic_os=$field3-$field4\n\t\t;;\n\t*-*-*)\n\t\t# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two\n\t\t# parts\n\t\tmaybe_os=$field2-$field3\n\t\tcase $maybe_os in\n\t\t\t  cloudabi*-eabi* \\\n\t\t\t| kfreebsd*-gnu* \\\n\t\t\t| knetbsd*-gnu* \\\n\t\t\t| kopensolaris*-gnu* \\\n\t\t\t| linux-* \\\n\t\t\t| managarm-* \\\n\t\t\t| netbsd*-eabi* \\\n\t\t\t| netbsd*-gnu* \\\n\t\t\t| nto-qnx* \\\n\t\t\t| os2-emx* \\\n\t\t\t| rtmk-nova* \\\n\t\t\t| storm-chaos* \\\n\t\t\t| uclinux-gnu* \\\n\t\t\t| uclinux-uclibc* \\\n\t\t\t| windows-* )\n\t\t\t\tbasic_machine=$field1\n\t\t\t\tbasic_os=$maybe_os\n\t\t\t\t;;\n\t\t\tandroid-linux)\n\t\t\t\tbasic_machine=$field1-unknown\n\t\t\t\tbasic_os=linux-android\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tbasic_machine=$field1-$field2\n\t\t\t\tbasic_os=$field3\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-*)\n\t\tcase $field1-$field2 in\n\t\t\t# Shorthands that happen to contain a single dash\n\t\t\tconvex-c[12] | convex-c3[248])\n\t\t\t\tbasic_machine=$field2-convex\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tdecstation-3100)\n\t\t\t\tbasic_machine=mips-dec\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\t*-*)\n\t\t\t\t# Second component is usually, but not always the OS\n\t\t\t\tcase $field2 in\n\t\t\t\t\t# Do not treat sunos as a manufacturer\n\t\t\t\t\tsun*os*)\n\t\t\t\t\t\tbasic_machine=$field1\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\t\t# Manufacturers\n\t\t\t\t\t  3100* \\\n\t\t\t\t\t| 32* \\\n\t\t\t\t\t| 3300* \\\n\t\t\t\t\t| 3600* \\\n\t\t\t\t\t| 7300* \\\n\t\t\t\t\t| acorn \\\n\t\t\t\t\t| altos* \\\n\t\t\t\t\t| apollo \\\n\t\t\t\t\t| apple \\\n\t\t\t\t\t| atari \\\n\t\t\t\t\t| att* \\\n\t\t\t\t\t| axis \\\n\t\t\t\t\t| be \\\n\t\t\t\t\t| bull \\\n\t\t\t\t\t| cbm \\\n\t\t\t\t\t| ccur \\\n\t\t\t\t\t| cisco \\\n\t\t\t\t\t| commodore \\\n\t\t\t\t\t| convergent* \\\n\t\t\t\t\t| convex* \\\n\t\t\t\t\t| cray \\\n\t\t\t\t\t| crds \\\n\t\t\t\t\t| dec* \\\n\t\t\t\t\t| delta* \\\n\t\t\t\t\t| dg \\\n\t\t\t\t\t| digital \\\n\t\t\t\t\t| dolphin \\\n\t\t\t\t\t| encore* \\\n\t\t\t\t\t| gould \\\n\t\t\t\t\t| harris \\\n\t\t\t\t\t| highlevel \\\n\t\t\t\t\t| hitachi* \\\n\t\t\t\t\t| hp \\\n\t\t\t\t\t| ibm* \\\n\t\t\t\t\t| intergraph \\\n\t\t\t\t\t| isi* \\\n\t\t\t\t\t| knuth \\\n\t\t\t\t\t| masscomp \\\n\t\t\t\t\t| microblaze* \\\n\t\t\t\t\t| mips* \\\n\t\t\t\t\t| motorola* \\\n\t\t\t\t\t| ncr* \\\n\t\t\t\t\t| news \\\n\t\t\t\t\t| next \\\n\t\t\t\t\t| ns \\\n\t\t\t\t\t| oki \\\n\t\t\t\t\t| omron* \\\n\t\t\t\t\t| pc533* \\\n\t\t\t\t\t| rebel \\\n\t\t\t\t\t| rom68k \\\n\t\t\t\t\t| rombug \\\n\t\t\t\t\t| semi \\\n\t\t\t\t\t| sequent* \\\n\t\t\t\t\t| siemens \\\n\t\t\t\t\t| sgi* \\\n\t\t\t\t\t| siemens \\\n\t\t\t\t\t| sim \\\n\t\t\t\t\t| sni \\\n\t\t\t\t\t| sony* \\\n\t\t\t\t\t| stratus \\\n\t\t\t\t\t| sun \\\n\t\t\t\t\t| sun[234]* \\\n\t\t\t\t\t| tektronix \\\n\t\t\t\t\t| tti* \\\n\t\t\t\t\t| ultra \\\n\t\t\t\t\t| unicom* \\\n\t\t\t\t\t| wec \\\n\t\t\t\t\t| winbond \\\n\t\t\t\t\t| wrs)\n\t\t\t\t\t\tbasic_machine=$field1-$field2\n\t\t\t\t\t\tbasic_os=\n\t\t\t\t\t\t;;\n\t\t\t\t\tzephyr*)\n\t\t\t\t\t\tbasic_machine=$field1-unknown\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\t\t*)\n\t\t\t\t\t\tbasic_machine=$field1\n\t\t\t\t\t\tbasic_os=$field2\n\t\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\t;;\n\t\tesac\n\t\t;;\n\t*)\n\t\t# Convert single-component short-hands not valid as part of\n\t\t# multi-component configurations.\n\t\tcase $field1 in\n\t\t\t386bsd)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\ta29khif)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tadobe68k)\n\t\t\t\tbasic_machine=m68010-adobe\n\t\t\t\tbasic_os=scout\n\t\t\t\t;;\n\t\t\talliant)\n\t\t\t\tbasic_machine=fx80-alliant\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\taltos | altos3068)\n\t\t\t\tbasic_machine=m68k-altos\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tam29k)\n\t\t\t\tbasic_machine=a29k-none\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\tamdahl)\n\t\t\t\tbasic_machine=580-amdahl\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tamiga)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tamigaos | amigados)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=amigaos\n\t\t\t\t;;\n\t\t\tamigaunix | amix)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tapollo68)\n\t\t\t\tbasic_machine=m68k-apollo\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tapollo68bsd)\n\t\t\t\tbasic_machine=m68k-apollo\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\taros)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=aros\n\t\t\t\t;;\n\t\t\taux)\n\t\t\t\tbasic_machine=m68k-apple\n\t\t\t\tbasic_os=aux\n\t\t\t\t;;\n\t\t\tbalance)\n\t\t\t\tbasic_machine=ns32k-sequent\n\t\t\t\tbasic_os=dynix\n\t\t\t\t;;\n\t\t\tblackfin)\n\t\t\t\tbasic_machine=bfin-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tcegcc)\n\t\t\t\tbasic_machine=arm-unknown\n\t\t\t\tbasic_os=cegcc\n\t\t\t\t;;\n\t\t\tcray)\n\t\t\t\tbasic_machine=j90-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tcrds | unos)\n\t\t\t\tbasic_machine=m68k-crds\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tda30)\n\t\t\t\tbasic_machine=m68k-da30\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tdecstation | pmax | pmin | dec3100 | decstatn)\n\t\t\t\tbasic_machine=mips-dec\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tdelta88)\n\t\t\t\tbasic_machine=m88k-motorola\n\t\t\t\tbasic_os=sysv3\n\t\t\t\t;;\n\t\t\tdicos)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=dicos\n\t\t\t\t;;\n\t\t\tdjgpp)\n\t\t\t\tbasic_machine=i586-pc\n\t\t\t\tbasic_os=msdosdjgpp\n\t\t\t\t;;\n\t\t\tebmon29k)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=ebmon\n\t\t\t\t;;\n\t\t\tes1800 | OSE68k | ose68k | ose | OSE)\n\t\t\t\tbasic_machine=m68k-ericsson\n\t\t\t\tbasic_os=ose\n\t\t\t\t;;\n\t\t\tgmicro)\n\t\t\t\tbasic_machine=tron-gmicro\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tgo32)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=go32\n\t\t\t\t;;\n\t\t\th8300hms)\n\t\t\t\tbasic_machine=h8300-hitachi\n\t\t\t\tbasic_os=hms\n\t\t\t\t;;\n\t\t\th8300xray)\n\t\t\t\tbasic_machine=h8300-hitachi\n\t\t\t\tbasic_os=xray\n\t\t\t\t;;\n\t\t\th8500hms)\n\t\t\t\tbasic_machine=h8500-hitachi\n\t\t\t\tbasic_os=hms\n\t\t\t\t;;\n\t\t\tharris)\n\t\t\t\tbasic_machine=m88k-harris\n\t\t\t\tbasic_os=sysv3\n\t\t\t\t;;\n\t\t\thp300 | hp300hpux)\n\t\t\t\tbasic_machine=m68k-hp\n\t\t\t\tbasic_os=hpux\n\t\t\t\t;;\n\t\t\thp300bsd)\n\t\t\t\tbasic_machine=m68k-hp\n\t\t\t\tbasic_os=bsd\n\t\t\t\t;;\n\t\t\thppaosf)\n\t\t\t\tbasic_machine=hppa1.1-hp\n\t\t\t\tbasic_os=osf\n\t\t\t\t;;\n\t\t\thppro)\n\t\t\t\tbasic_machine=hppa1.1-hp\n\t\t\t\tbasic_os=proelf\n\t\t\t\t;;\n\t\t\ti386mach)\n\t\t\t\tbasic_machine=i386-mach\n\t\t\t\tbasic_os=mach\n\t\t\t\t;;\n\t\t\tisi68 | isi)\n\t\t\t\tbasic_machine=m68k-isi\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tm68knommu)\n\t\t\t\tbasic_machine=m68k-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tmagnum | m3230)\n\t\t\t\tbasic_machine=mips-mips\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tmerlin)\n\t\t\t\tbasic_machine=ns32k-utek\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tmingw64)\n\t\t\t\tbasic_machine=x86_64-pc\n\t\t\t\tbasic_os=mingw64\n\t\t\t\t;;\n\t\t\tmingw32)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=mingw32\n\t\t\t\t;;\n\t\t\tmingw32ce)\n\t\t\t\tbasic_machine=arm-unknown\n\t\t\t\tbasic_os=mingw32ce\n\t\t\t\t;;\n\t\t\tmonitor)\n\t\t\t\tbasic_machine=m68k-rom68k\n\t\t\t\tbasic_os=coff\n\t\t\t\t;;\n\t\t\tmorphos)\n\t\t\t\tbasic_machine=powerpc-unknown\n\t\t\t\tbasic_os=morphos\n\t\t\t\t;;\n\t\t\tmoxiebox)\n\t\t\t\tbasic_machine=moxie-unknown\n\t\t\t\tbasic_os=moxiebox\n\t\t\t\t;;\n\t\t\tmsdos)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=msdos\n\t\t\t\t;;\n\t\t\tmsys)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=msys\n\t\t\t\t;;\n\t\t\tmvs)\n\t\t\t\tbasic_machine=i370-ibm\n\t\t\t\tbasic_os=mvs\n\t\t\t\t;;\n\t\t\tnacl)\n\t\t\t\tbasic_machine=le32-unknown\n\t\t\t\tbasic_os=nacl\n\t\t\t\t;;\n\t\t\tncr3000)\n\t\t\t\tbasic_machine=i486-ncr\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tnetbsd386)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=netbsd\n\t\t\t\t;;\n\t\t\tnetwinder)\n\t\t\t\tbasic_machine=armv4l-rebel\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tnews | news700 | news800 | news900)\n\t\t\t\tbasic_machine=m68k-sony\n\t\t\t\tbasic_os=newsos\n\t\t\t\t;;\n\t\t\tnews1000)\n\t\t\t\tbasic_machine=m68030-sony\n\t\t\t\tbasic_os=newsos\n\t\t\t\t;;\n\t\t\tnecv70)\n\t\t\t\tbasic_machine=v70-nec\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tnh3000)\n\t\t\t\tbasic_machine=m68k-harris\n\t\t\t\tbasic_os=cxux\n\t\t\t\t;;\n\t\t\tnh[45]000)\n\t\t\t\tbasic_machine=m88k-harris\n\t\t\t\tbasic_os=cxux\n\t\t\t\t;;\n\t\t\tnindy960)\n\t\t\t\tbasic_machine=i960-intel\n\t\t\t\tbasic_os=nindy\n\t\t\t\t;;\n\t\t\tmon960)\n\t\t\t\tbasic_machine=i960-intel\n\t\t\t\tbasic_os=mon960\n\t\t\t\t;;\n\t\t\tnonstopux)\n\t\t\t\tbasic_machine=mips-compaq\n\t\t\t\tbasic_os=nonstopux\n\t\t\t\t;;\n\t\t\tos400)\n\t\t\t\tbasic_machine=powerpc-ibm\n\t\t\t\tbasic_os=os400\n\t\t\t\t;;\n\t\t\tOSE68000 | ose68000)\n\t\t\t\tbasic_machine=m68000-ericsson\n\t\t\t\tbasic_os=ose\n\t\t\t\t;;\n\t\t\tos68k)\n\t\t\t\tbasic_machine=m68k-none\n\t\t\t\tbasic_os=os68k\n\t\t\t\t;;\n\t\t\tparagon)\n\t\t\t\tbasic_machine=i860-intel\n\t\t\t\tbasic_os=osf\n\t\t\t\t;;\n\t\t\tparisc)\n\t\t\t\tbasic_machine=hppa-unknown\n\t\t\t\tbasic_os=linux\n\t\t\t\t;;\n\t\t\tpsp)\n\t\t\t\tbasic_machine=mipsallegrexel-sony\n\t\t\t\tbasic_os=psp\n\t\t\t\t;;\n\t\t\tpw32)\n\t\t\t\tbasic_machine=i586-unknown\n\t\t\t\tbasic_os=pw32\n\t\t\t\t;;\n\t\t\trdos | rdos64)\n\t\t\t\tbasic_machine=x86_64-pc\n\t\t\t\tbasic_os=rdos\n\t\t\t\t;;\n\t\t\trdos32)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=rdos\n\t\t\t\t;;\n\t\t\trom68k)\n\t\t\t\tbasic_machine=m68k-rom68k\n\t\t\t\tbasic_os=coff\n\t\t\t\t;;\n\t\t\tsa29200)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tsei)\n\t\t\t\tbasic_machine=mips-sei\n\t\t\t\tbasic_os=seiux\n\t\t\t\t;;\n\t\t\tsequent)\n\t\t\t\tbasic_machine=i386-sequent\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsps7)\n\t\t\t\tbasic_machine=m68k-bull\n\t\t\t\tbasic_os=sysv2\n\t\t\t\t;;\n\t\t\tst2000)\n\t\t\t\tbasic_machine=m68k-tandem\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tstratus)\n\t\t\t\tbasic_machine=i860-stratus\n\t\t\t\tbasic_os=sysv4\n\t\t\t\t;;\n\t\t\tsun2)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun2os3)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun2os4)\n\t\t\t\tbasic_machine=m68000-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun3)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun3os3)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun3os4)\n\t\t\t\tbasic_machine=m68k-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun4)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsun4os3)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=sunos3\n\t\t\t\t;;\n\t\t\tsun4os4)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=sunos4\n\t\t\t\t;;\n\t\t\tsun4sol2)\n\t\t\t\tbasic_machine=sparc-sun\n\t\t\t\tbasic_os=solaris2\n\t\t\t\t;;\n\t\t\tsun386 | sun386i | roadrunner)\n\t\t\t\tbasic_machine=i386-sun\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\t\tsv1)\n\t\t\t\tbasic_machine=sv1-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tsymmetry)\n\t\t\t\tbasic_machine=i386-sequent\n\t\t\t\tbasic_os=dynix\n\t\t\t\t;;\n\t\t\tt3e)\n\t\t\t\tbasic_machine=alphaev5-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\tt90)\n\t\t\t\tbasic_machine=t90-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\ttoad1)\n\t\t\t\tbasic_machine=pdp10-xkl\n\t\t\t\tbasic_os=tops20\n\t\t\t\t;;\n\t\t\ttpf)\n\t\t\t\tbasic_machine=s390x-ibm\n\t\t\t\tbasic_os=tpf\n\t\t\t\t;;\n\t\t\tudi29k)\n\t\t\t\tbasic_machine=a29k-amd\n\t\t\t\tbasic_os=udi\n\t\t\t\t;;\n\t\t\tultra3)\n\t\t\t\tbasic_machine=a29k-nyu\n\t\t\t\tbasic_os=sym1\n\t\t\t\t;;\n\t\t\tv810 | necv810)\n\t\t\t\tbasic_machine=v810-nec\n\t\t\t\tbasic_os=none\n\t\t\t\t;;\n\t\t\tvaxv)\n\t\t\t\tbasic_machine=vax-dec\n\t\t\t\tbasic_os=sysv\n\t\t\t\t;;\n\t\t\tvms)\n\t\t\t\tbasic_machine=vax-dec\n\t\t\t\tbasic_os=vms\n\t\t\t\t;;\n\t\t\tvsta)\n\t\t\t\tbasic_machine=i386-pc\n\t\t\t\tbasic_os=vsta\n\t\t\t\t;;\n\t\t\tvxworks960)\n\t\t\t\tbasic_machine=i960-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\tvxworks68)\n\t\t\t\tbasic_machine=m68k-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\tvxworks29k)\n\t\t\t\tbasic_machine=a29k-wrs\n\t\t\t\tbasic_os=vxworks\n\t\t\t\t;;\n\t\t\txbox)\n\t\t\t\tbasic_machine=i686-pc\n\t\t\t\tbasic_os=mingw32\n\t\t\t\t;;\n\t\t\tymp)\n\t\t\t\tbasic_machine=ymp-cray\n\t\t\t\tbasic_os=unicos\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tbasic_machine=$1\n\t\t\t\tbasic_os=\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\n# Decode 1-component or ad-hoc basic machines\ncase $basic_machine in\n\t# Here we handle the default manufacturer of certain CPU types.  It is in\n\t# some cases the only manufacturer, in others, it is the most popular.\n\tw89k)\n\t\tcpu=hppa1.1\n\t\tvendor=winbond\n\t\t;;\n\top50n)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\t;;\n\top60c)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\t;;\n\tibm*)\n\t\tcpu=i370\n\t\tvendor=ibm\n\t\t;;\n\torion105)\n\t\tcpu=clipper\n\t\tvendor=highlevel\n\t\t;;\n\tmac | mpw | mac-mpw)\n\t\tcpu=m68k\n\t\tvendor=apple\n\t\t;;\n\tpmac | pmac-mpw)\n\t\tcpu=powerpc\n\t\tvendor=apple\n\t\t;;\n\n\t# Recognize the various machine names and aliases which stand\n\t# for a CPU type and a company and sometimes even an OS.\n\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n\t\tcpu=m68000\n\t\tvendor=att\n\t\t;;\n\t3b*)\n\t\tcpu=we32k\n\t\tvendor=att\n\t\t;;\n\tbluegene*)\n\t\tcpu=powerpc\n\t\tvendor=ibm\n\t\tbasic_os=cnk\n\t\t;;\n\tdecsystem10* | dec10*)\n\t\tcpu=pdp10\n\t\tvendor=dec\n\t\tbasic_os=tops10\n\t\t;;\n\tdecsystem20* | dec20*)\n\t\tcpu=pdp10\n\t\tvendor=dec\n\t\tbasic_os=tops20\n\t\t;;\n\tdelta | 3300 | delta-motorola | 3300-motorola | motorola-delta | motorola-3300)\n\t\tcpu=m68k\n\t\tvendor=motorola\n\t\t;;\n\t# This used to be dpx2*, but that gets the RS6000-based\n\t# DPX/20 and the x86-based DPX/2-100 wrong.  See\n\t# https://oldskool.silicium.org/stations/bull_dpx20.htm\n\t# https://www.feb-patrimoine.com/english/bull_dpx2.htm\n\t# https://www.feb-patrimoine.com/english/unix_and_bull.htm\n\tdpx2 | dpx2[23]00 | dpx2[23]xx)\n\t\tcpu=m68k\n\t\tvendor=bull\n\t\t;;\n\tdpx2100 | dpx21xx)\n\t\tcpu=i386\n\t\tvendor=bull\n\t\t;;\n\tdpx20)\n\t\tcpu=rs6000\n\t\tvendor=bull\n\t\t;;\n\tencore | umax | mmax)\n\t\tcpu=ns32k\n\t\tvendor=encore\n\t\t;;\n\telxsi)\n\t\tcpu=elxsi\n\t\tvendor=elxsi\n\t\tbasic_os=${basic_os:-bsd}\n\t\t;;\n\tfx2800)\n\t\tcpu=i860\n\t\tvendor=alliant\n\t\t;;\n\tgenix)\n\t\tcpu=ns32k\n\t\tvendor=ns\n\t\t;;\n\th3050r* | hiux*)\n\t\tcpu=hppa1.1\n\t\tvendor=hitachi\n\t\tbasic_os=hiuxwe2\n\t\t;;\n\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\thp9k2[0-9][0-9] | hp9k31[0-9])\n\t\tcpu=m68000\n\t\tvendor=hp\n\t\t;;\n\thp9k3[2-9][0-9])\n\t\tcpu=m68k\n\t\tvendor=hp\n\t\t;;\n\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k78[0-9] | hp78[0-9])\n\t\t# FIXME: really hppa2.0-hp\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n\t\t# FIXME: really hppa2.0-hp\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[0-9][13679] | hp8[0-9][13679])\n\t\tcpu=hppa1.1\n\t\tvendor=hp\n\t\t;;\n\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n\t\tcpu=hppa1.0\n\t\tvendor=hp\n\t\t;;\n\ti*86v32)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv32\n\t\t;;\n\ti*86v4*)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv4\n\t\t;;\n\ti*86v)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=sysv\n\t\t;;\n\ti*86sol2)\n\t\tcpu=`echo \"$1\" | sed -e 's/86.*/86/'`\n\t\tvendor=pc\n\t\tbasic_os=solaris2\n\t\t;;\n\tj90 | j90-cray)\n\t\tcpu=j90\n\t\tvendor=cray\n\t\tbasic_os=${basic_os:-unicos}\n\t\t;;\n\tiris | iris4d)\n\t\tcpu=mips\n\t\tvendor=sgi\n\t\tcase $basic_os in\n\t\t    irix*)\n\t\t\t;;\n\t\t    *)\n\t\t\tbasic_os=irix4\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tminiframe)\n\t\tcpu=m68000\n\t\tvendor=convergent\n\t\t;;\n\t*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)\n\t\tcpu=m68k\n\t\tvendor=atari\n\t\tbasic_os=mint\n\t\t;;\n\tnews-3600 | risc-news)\n\t\tcpu=mips\n\t\tvendor=sony\n\t\tbasic_os=newsos\n\t\t;;\n\tnext | m*-next)\n\t\tcpu=m68k\n\t\tvendor=next\n\t\t;;\n\tnp1)\n\t\tcpu=np1\n\t\tvendor=gould\n\t\t;;\n\top50n-* | op60c-*)\n\t\tcpu=hppa1.1\n\t\tvendor=oki\n\t\tbasic_os=proelf\n\t\t;;\n\tpa-hitachi)\n\t\tcpu=hppa1.1\n\t\tvendor=hitachi\n\t\tbasic_os=hiuxwe2\n\t\t;;\n\tpbd)\n\t\tcpu=sparc\n\t\tvendor=tti\n\t\t;;\n\tpbb)\n\t\tcpu=m68k\n\t\tvendor=tti\n\t\t;;\n\tpc532)\n\t\tcpu=ns32k\n\t\tvendor=pc532\n\t\t;;\n\tpn)\n\t\tcpu=pn\n\t\tvendor=gould\n\t\t;;\n\tpower)\n\t\tcpu=power\n\t\tvendor=ibm\n\t\t;;\n\tps2)\n\t\tcpu=i386\n\t\tvendor=ibm\n\t\t;;\n\trm[46]00)\n\t\tcpu=mips\n\t\tvendor=siemens\n\t\t;;\n\trtpc | rtpc-*)\n\t\tcpu=romp\n\t\tvendor=ibm\n\t\t;;\n\tsde)\n\t\tcpu=mipsisa32\n\t\tvendor=sde\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tsimso-wrs)\n\t\tcpu=sparclite\n\t\tvendor=wrs\n\t\tbasic_os=vxworks\n\t\t;;\n\ttower | tower-32)\n\t\tcpu=m68k\n\t\tvendor=ncr\n\t\t;;\n\tvpp*|vx|vx-*)\n\t\tcpu=f301\n\t\tvendor=fujitsu\n\t\t;;\n\tw65)\n\t\tcpu=w65\n\t\tvendor=wdc\n\t\t;;\n\tw89k-*)\n\t\tcpu=hppa1.1\n\t\tvendor=winbond\n\t\tbasic_os=proelf\n\t\t;;\n\tnone)\n\t\tcpu=none\n\t\tvendor=none\n\t\t;;\n\tleon|leon[3-9])\n\t\tcpu=sparc\n\t\tvendor=$basic_machine\n\t\t;;\n\tleon-*|leon[3-9]-*)\n\t\tcpu=sparc\n\t\tvendor=`echo \"$basic_machine\" | sed 's/-.*//'`\n\t\t;;\n\n\t*-*)\n\t\tsaved_IFS=$IFS\n\t\tIFS=\"-\" read cpu vendor <<EOF\n$basic_machine\nEOF\n\t\tIFS=$saved_IFS\n\t\t;;\n\t# We use 'pc' rather than 'unknown'\n\t# because (1) that's what they normally are, and\n\t# (2) the word \"unknown\" tends to confuse beginning users.\n\ti*86 | x86_64)\n\t\tcpu=$basic_machine\n\t\tvendor=pc\n\t\t;;\n\t# These rules are duplicated from below for sake of the special case above;\n\t# i.e. things that normalized to x86 arches should also default to \"pc\"\n\tpc98)\n\t\tcpu=i386\n\t\tvendor=pc\n\t\t;;\n\tx64 | amd64)\n\t\tcpu=x86_64\n\t\tvendor=pc\n\t\t;;\n\t# Recognize the basic CPU types without company name.\n\t*)\n\t\tcpu=$basic_machine\n\t\tvendor=unknown\n\t\t;;\nesac\n\nunset -v basic_machine\n\n# Decode basic machines in the full and proper CPU-Company form.\ncase $cpu-$vendor in\n\t# Here we handle the default manufacturer of certain CPU types in canonical form.\n\t# It is in some cases the only manufacturer, in others, it is the most popular.\n\tc[12]-convex | c[12]-unknown | c3[248]-convex | c3[248]-unknown)\n\t\tvendor=convex\n\t\tbasic_os=${basic_os:-bsd}\n\t\t;;\n\tcraynv-unknown)\n\t\tvendor=cray\n\t\tbasic_os=${basic_os:-unicosmp}\n\t\t;;\n\tc90-unknown | c90-cray)\n\t\tvendor=cray\n\t\tbasic_os=${basic_os:-unicos}\n\t\t;;\n\tfx80-unknown)\n\t\tvendor=alliant\n\t\t;;\n\tromp-unknown)\n\t\tvendor=ibm\n\t\t;;\n\tmmix-unknown)\n\t\tvendor=knuth\n\t\t;;\n\tmicroblaze-unknown | microblazeel-unknown)\n\t\tvendor=xilinx\n\t\t;;\n\trs6000-unknown)\n\t\tvendor=ibm\n\t\t;;\n\tvax-unknown)\n\t\tvendor=dec\n\t\t;;\n\tpdp11-unknown)\n\t\tvendor=dec\n\t\t;;\n\twe32k-unknown)\n\t\tvendor=att\n\t\t;;\n\tcydra-unknown)\n\t\tvendor=cydrome\n\t\t;;\n\ti370-ibm*)\n\t\tvendor=ibm\n\t\t;;\n\torion-unknown)\n\t\tvendor=highlevel\n\t\t;;\n\txps-unknown | xps100-unknown)\n\t\tcpu=xps100\n\t\tvendor=honeywell\n\t\t;;\n\n\t# Here we normalize CPU types with a missing or matching vendor\n\tarmh-unknown | armh-alt)\n\t\tcpu=armv7l\n\t\tvendor=alt\n\t\tbasic_os=${basic_os:-linux-gnueabihf}\n\t\t;;\n\n\t# Normalized CPU+vendor pairs that imply an OS, if not otherwise specified\n\tm68k-isi)\n\t\tbasic_os=${basic_os:-sysv}\n\t\t;;\n\tm68k-sony)\n\t\tbasic_os=${basic_os:-newsos}\n\t\t;;\n\tm68k-tektronix)\n\t\tbasic_os=${basic_os:-bsd}\n\t\t;;\n\tm88k-harris)\n\t\tbasic_os=${basic_os:-sysv3}\n\t\t;;\n\ti386-bull | m68k-bull)\n\t\tbasic_os=${basic_os:-sysv3}\n\t\t;;\n\trs6000-bull)\n\t\tbasic_os=${basic_os:-bosx}\n\t\t;;\n\tmips-sni)\n\t\tbasic_os=${basic_os:-sysv4}\n\t\t;;\n\n\t# Here we normalize CPU types irrespective of the vendor\n\tamd64-*)\n\t\tcpu=x86_64\n\t\t;;\n\tblackfin-*)\n\t\tcpu=bfin\n\t\tbasic_os=${basic_os:-linux}\n\t\t;;\n\tc54x-*)\n\t\tcpu=tic54x\n\t\t;;\n\tc55x-*)\n\t\tcpu=tic55x\n\t\t;;\n\tc6x-*)\n\t\tcpu=tic6x\n\t\t;;\n\te500v[12]-*)\n\t\tcpu=powerpc\n\t\tbasic_os=${basic_os}\"spe\"\n\t\t;;\n\tmips3*-*)\n\t\tcpu=mips64\n\t\t;;\n\tms1-*)\n\t\tcpu=mt\n\t\t;;\n\tm68knommu-*)\n\t\tcpu=m68k\n\t\tbasic_os=${basic_os:-linux}\n\t\t;;\n\tm9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)\n\t\tcpu=s12z\n\t\t;;\n\topenrisc-*)\n\t\tcpu=or32\n\t\t;;\n\tparisc-*)\n\t\tcpu=hppa\n\t\tbasic_os=${basic_os:-linux}\n\t\t;;\n\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n\t\tcpu=i586\n\t\t;;\n\tpentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)\n\t\tcpu=i686\n\t\t;;\n\tpentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)\n\t\tcpu=i686\n\t\t;;\n\tpentium4-*)\n\t\tcpu=i786\n\t\t;;\n\tppc-* | ppcbe-*)\n\t\tcpu=powerpc\n\t\t;;\n\tppcle-* | powerpclittle-*)\n\t\tcpu=powerpcle\n\t\t;;\n\tppc64-*)\n\t\tcpu=powerpc64\n\t\t;;\n\tppc64le-* | powerpc64little-*)\n\t\tcpu=powerpc64le\n\t\t;;\n\tsb1-*)\n\t\tcpu=mipsisa64sb1\n\t\t;;\n\tsb1el-*)\n\t\tcpu=mipsisa64sb1el\n\t\t;;\n\tsh5e[lb]-*)\n\t\tcpu=`echo \"$cpu\" | sed 's/^\\(sh.\\)e\\(.\\)$/\\1\\2e/'`\n\t\t;;\n\tspur-*)\n\t\tcpu=spur\n\t\t;;\n\tstrongarm-* | thumb-*)\n\t\tcpu=arm\n\t\t;;\n\ttx39-*)\n\t\tcpu=mipstx39\n\t\t;;\n\ttx39el-*)\n\t\tcpu=mipstx39el\n\t\t;;\n\txscale-* | xscalee[bl]-*)\n\t\tcpu=`echo \"$cpu\" | sed 's/^xscale/arm/'`\n\t\t;;\n\tarm64-* | aarch64le-*)\n\t\tcpu=aarch64\n\t\t;;\n\n\t# Recognize the canonical CPU Types that limit and/or modify the\n\t# company names they are paired with.\n\tcr16-*)\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tcrisv32-* | etraxfs*-*)\n\t\tcpu=crisv32\n\t\tvendor=axis\n\t\t;;\n\tcris-* | etrax*-*)\n\t\tcpu=cris\n\t\tvendor=axis\n\t\t;;\n\tcrx-*)\n\t\tbasic_os=${basic_os:-elf}\n\t\t;;\n\tneo-tandem)\n\t\tcpu=neo\n\t\tvendor=tandem\n\t\t;;\n\tnse-tandem)\n\t\tcpu=nse\n\t\tvendor=tandem\n\t\t;;\n\tnsr-tandem)\n\t\tcpu=nsr\n\t\tvendor=tandem\n\t\t;;\n\tnsv-tandem)\n\t\tcpu=nsv\n\t\tvendor=tandem\n\t\t;;\n\tnsx-tandem)\n\t\tcpu=nsx\n\t\tvendor=tandem\n\t\t;;\n\tmipsallegrexel-sony)\n\t\tcpu=mipsallegrexel\n\t\tvendor=sony\n\t\t;;\n\ttile*-*)\n\t\tbasic_os=${basic_os:-linux-gnu}\n\t\t;;\n\n\t*)\n\t\t# Recognize the canonical CPU types that are allowed with any\n\t\t# company name.\n\t\tcase $cpu in\n\t\t\t  1750a \\\n\t\t\t| 580 \\\n\t\t\t| [cjt]90 \\\n\t\t\t| a29k \\\n\t\t\t| aarch64 \\\n\t\t\t| aarch64_be \\\n\t\t\t| aarch64c \\\n\t\t\t| abacus \\\n\t\t\t| alpha \\\n\t\t\t| alpha64 \\\n\t\t\t| alpha64ev56 \\\n\t\t\t| alpha64ev6[78] \\\n\t\t\t| alpha64ev[4-8] \\\n\t\t\t| alpha64pca5[67] \\\n\t\t\t| alphaev56 \\\n\t\t\t| alphaev6[78] \\\n\t\t\t| alphaev[4-8] \\\n\t\t\t| alphapca5[67] \\\n\t\t\t| am33_2.0 \\\n\t\t\t| amdgcn \\\n\t\t\t| arc \\\n\t\t\t| arc32 \\\n\t\t\t| arc64 \\\n\t\t\t| arceb \\\n\t\t\t| arm \\\n\t\t\t| arm64e \\\n\t\t\t| arm64ec \\\n\t\t\t| arm[lb]e \\\n\t\t\t| arme[lb] \\\n\t\t\t| armv* \\\n\t\t\t| asmjs \\\n\t\t\t| avr \\\n\t\t\t| avr32 \\\n\t\t\t| ba \\\n\t\t\t| be32 \\\n\t\t\t| be64 \\\n\t\t\t| bfin \\\n\t\t\t| bpf \\\n\t\t\t| bs2000 \\\n\t\t\t| c30 \\\n\t\t\t| c4x \\\n\t\t\t| c8051 \\\n\t\t\t| c[123]* \\\n\t\t\t| clipper \\\n\t\t\t| craynv \\\n\t\t\t| csky \\\n\t\t\t| cydra \\\n\t\t\t| d10v \\\n\t\t\t| d30v \\\n\t\t\t| dlx \\\n\t\t\t| dsp16xx \\\n\t\t\t| e2k \\\n\t\t\t| elxsi \\\n\t\t\t| epiphany \\\n\t\t\t| f30[01] \\\n\t\t\t| f700 \\\n\t\t\t| fido \\\n\t\t\t| fr30 \\\n\t\t\t| frv \\\n\t\t\t| ft32 \\\n\t\t\t| fx80 \\\n\t\t\t| h8300 \\\n\t\t\t| h8500 \\\n\t\t\t| hexagon \\\n\t\t\t| hppa \\\n\t\t\t| hppa1.[01] \\\n\t\t\t| hppa2.0 \\\n\t\t\t| hppa2.0[nw] \\\n\t\t\t| hppa64 \\\n\t\t\t| i*86 \\\n\t\t\t| i370 \\\n\t\t\t| i860 \\\n\t\t\t| i960 \\\n\t\t\t| ia16 \\\n\t\t\t| ia64 \\\n\t\t\t| ip2k \\\n\t\t\t| iq2000 \\\n\t\t\t| javascript \\\n\t\t\t| k1om \\\n\t\t\t| kvx \\\n\t\t\t| le32 \\\n\t\t\t| le64 \\\n\t\t\t| lm32 \\\n\t\t\t| loongarch32 \\\n\t\t\t| loongarch64 \\\n\t\t\t| m32c \\\n\t\t\t| m32r \\\n\t\t\t| m32rle \\\n\t\t\t| m5200 \\\n\t\t\t| m68000 \\\n\t\t\t| m680[012346]0 \\\n\t\t\t| m6811 \\\n\t\t\t| m6812 \\\n\t\t\t| m68360 \\\n\t\t\t| m683?2 \\\n\t\t\t| m68hc11 \\\n\t\t\t| m68hc12 \\\n\t\t\t| m68hcs12x \\\n\t\t\t| m68k \\\n\t\t\t| m88110 \\\n\t\t\t| m88k \\\n\t\t\t| maxq \\\n\t\t\t| mb \\\n\t\t\t| mcore \\\n\t\t\t| mep \\\n\t\t\t| metag \\\n\t\t\t| microblaze \\\n\t\t\t| microblazeel \\\n\t\t\t| mips* \\\n\t\t\t| mmix \\\n\t\t\t| mn10200 \\\n\t\t\t| mn10300 \\\n\t\t\t| moxie \\\n\t\t\t| msp430 \\\n\t\t\t| mt \\\n\t\t\t| nanomips* \\\n\t\t\t| nds32 \\\n\t\t\t| nds32be \\\n\t\t\t| nds32le \\\n\t\t\t| nfp \\\n\t\t\t| nios \\\n\t\t\t| nios2 \\\n\t\t\t| nios2eb \\\n\t\t\t| nios2el \\\n\t\t\t| none \\\n\t\t\t| np1 \\\n\t\t\t| ns16k \\\n\t\t\t| ns32k \\\n\t\t\t| nvptx \\\n\t\t\t| open8 \\\n\t\t\t| or1k* \\\n\t\t\t| or32 \\\n\t\t\t| orion \\\n\t\t\t| pdp10 \\\n\t\t\t| pdp11 \\\n\t\t\t| picochip \\\n\t\t\t| pj \\\n\t\t\t| pjl \\\n\t\t\t| pn \\\n\t\t\t| power \\\n\t\t\t| powerpc \\\n\t\t\t| powerpc64 \\\n\t\t\t| powerpc64le \\\n\t\t\t| powerpcle \\\n\t\t\t| powerpcspe \\\n\t\t\t| pru \\\n\t\t\t| pyramid \\\n\t\t\t| riscv \\\n\t\t\t| riscv32 \\\n\t\t\t| riscv32be \\\n\t\t\t| riscv64 \\\n\t\t\t| riscv64be \\\n\t\t\t| rl78 \\\n\t\t\t| romp \\\n\t\t\t| rs6000 \\\n\t\t\t| rx \\\n\t\t\t| s390 \\\n\t\t\t| s390x \\\n\t\t\t| score \\\n\t\t\t| sh \\\n\t\t\t| sh64 \\\n\t\t\t| sh64le \\\n\t\t\t| sh[12345][lb]e \\\n\t\t\t| sh[1234] \\\n\t\t\t| sh[1234]e[lb] \\\n\t\t\t| sh[23]e \\\n\t\t\t| sh[23]ele \\\n\t\t\t| sh[24]a \\\n\t\t\t| sh[24]ae[lb] \\\n\t\t\t| sh[lb]e \\\n\t\t\t| she[lb] \\\n\t\t\t| shl \\\n\t\t\t| sparc \\\n\t\t\t| sparc64 \\\n\t\t\t| sparc64b \\\n\t\t\t| sparc64v \\\n\t\t\t| sparc86x \\\n\t\t\t| sparclet \\\n\t\t\t| sparclite \\\n\t\t\t| sparcv8 \\\n\t\t\t| sparcv9 \\\n\t\t\t| sparcv9b \\\n\t\t\t| sparcv9v \\\n\t\t\t| spu \\\n\t\t\t| sv1 \\\n\t\t\t| sx* \\\n\t\t\t| tahoe \\\n\t\t\t| thumbv7* \\\n\t\t\t| tic30 \\\n\t\t\t| tic4x \\\n\t\t\t| tic54x \\\n\t\t\t| tic55x \\\n\t\t\t| tic6x \\\n\t\t\t| tic80 \\\n\t\t\t| tron \\\n\t\t\t| ubicom32 \\\n\t\t\t| v70 \\\n\t\t\t| v810 \\\n\t\t\t| v850 \\\n\t\t\t| v850e \\\n\t\t\t| v850e1 \\\n\t\t\t| v850e2 \\\n\t\t\t| v850e2v3 \\\n\t\t\t| v850es \\\n\t\t\t| vax \\\n\t\t\t| vc4 \\\n\t\t\t| visium \\\n\t\t\t| w65 \\\n\t\t\t| wasm32 \\\n\t\t\t| wasm64 \\\n\t\t\t| we32k \\\n\t\t\t| x86 \\\n\t\t\t| x86_64 \\\n\t\t\t| xc16x \\\n\t\t\t| xgate \\\n\t\t\t| xps100 \\\n\t\t\t| xstormy16 \\\n\t\t\t| xtensa* \\\n\t\t\t| ymp \\\n\t\t\t| z80 \\\n\t\t\t| z8k)\n\t\t\t\t;;\n\n\t\t\t*)\n\t\t\t\techo \"Invalid configuration '$1': machine '$cpu-$vendor' not recognized\" 1>&2\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\n# Here we canonicalize certain aliases for manufacturers.\ncase $vendor in\n\tdigital*)\n\t\tvendor=dec\n\t\t;;\n\tcommodore*)\n\t\tvendor=cbm\n\t\t;;\n\t*)\n\t\t;;\nesac\n\n# Decode manufacturer-specific aliases for certain operating systems.\n\nif test x\"$basic_os\" != x\nthen\n\n# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just\n# set os.\nobj=\ncase $basic_os in\n\tgnu/linux*)\n\t\tkernel=linux\n\t\tos=`echo \"$basic_os\" | sed -e 's|gnu/linux|gnu|'`\n\t\t;;\n\tos2-emx)\n\t\tkernel=os2\n\t\tos=`echo \"$basic_os\" | sed -e 's|os2-emx|emx|'`\n\t\t;;\n\tnto-qnx*)\n\t\tkernel=nto\n\t\tos=`echo \"$basic_os\" | sed -e 's|nto-qnx|qnx|'`\n\t\t;;\n\t*-*)\n\t\tsaved_IFS=$IFS\n\t\tIFS=\"-\" read kernel os <<EOF\n$basic_os\nEOF\n\t\tIFS=$saved_IFS\n\t\t;;\n\t# Default OS when just kernel was specified\n\tnto*)\n\t\tkernel=nto\n\t\tos=`echo \"$basic_os\" | sed -e 's|nto|qnx|'`\n\t\t;;\n\tlinux*)\n\t\tkernel=linux\n\t\tos=`echo \"$basic_os\" | sed -e 's|linux|gnu|'`\n\t\t;;\n\tmanagarm*)\n\t\tkernel=managarm\n\t\tos=`echo \"$basic_os\" | sed -e 's|managarm|mlibc|'`\n\t\t;;\n\t*)\n\t\tkernel=\n\t\tos=$basic_os\n\t\t;;\nesac\n\n# Now, normalize the OS (knowing we just have one component, it's not a kernel,\n# etc.)\ncase $os in\n\t# First match some system type aliases that might get confused\n\t# with valid system types.\n\t# solaris* is a basic system type, with this one exception.\n\tauroraux)\n\t\tos=auroraux\n\t\t;;\n\tbluegene*)\n\t\tos=cnk\n\t\t;;\n\tsolaris1 | solaris1.*)\n\t\tos=`echo \"$os\" | sed -e 's|solaris1|sunos4|'`\n\t\t;;\n\tsolaris)\n\t\tos=solaris2\n\t\t;;\n\tunixware*)\n\t\tos=sysv4.2uw\n\t\t;;\n\t# The marketing names for NeXT's operating systems were\n\t# NeXTSTEP, NeXTSTEP 2, OpenSTEP 3, OpenSTEP 4.  'openstep' is\n\t# mapped to 'openstep3', but 'openstep1' and 'openstep2' are\n\t# mapped to 'nextstep' and 'nextstep2', consistent with the\n\t# treatment of SunOS/Solaris.\n\tns | ns1 | nextstep | nextstep1 | openstep1)\n\t\tos=nextstep\n\t\t;;\n\tns2 | nextstep2 | openstep2)\n\t\tos=nextstep2\n\t\t;;\n\tns3 | nextstep3 | openstep | openstep3)\n\t\tos=openstep3\n\t\t;;\n\tns4 | nextstep4 | openstep4)\n\t\tos=openstep4\n\t\t;;\n\t# es1800 is here to avoid being matched by es* (a different OS)\n\tes1800*)\n\t\tos=ose\n\t\t;;\n\t# Some version numbers need modification\n\tchorusos*)\n\t\tos=chorusos\n\t\t;;\n\tisc)\n\t\tos=isc2.2\n\t\t;;\n\tsco6)\n\t\tos=sco5v6\n\t\t;;\n\tsco5)\n\t\tos=sco3.2v5\n\t\t;;\n\tsco4)\n\t\tos=sco3.2v4\n\t\t;;\n\tsco3.2.[4-9]*)\n\t\tos=`echo \"$os\" | sed -e 's/sco3.2./sco3.2v/'`\n\t\t;;\n\tsco*v* | scout)\n\t\t# Don't match below\n\t\t;;\n\tsco*)\n\t\tos=sco3.2v2\n\t\t;;\n\tpsos*)\n\t\tos=psos\n\t\t;;\n\tqnx*)\n\t\tos=qnx\n\t\t;;\n\thiux*)\n\t\tos=hiuxwe2\n\t\t;;\n\tlynx*178)\n\t\tos=lynxos178\n\t\t;;\n\tlynx*5)\n\t\tos=lynxos5\n\t\t;;\n\tlynxos*)\n\t\t# don't get caught up in next wildcard\n\t\t;;\n\tlynx*)\n\t\tos=lynxos\n\t\t;;\n\tmac[0-9]*)\n\t\tos=`echo \"$os\" | sed -e 's|mac|macos|'`\n\t\t;;\n\topened*)\n\t\tos=openedition\n\t\t;;\n\tos400*)\n\t\tos=os400\n\t\t;;\n\tsunos5*)\n\t\tos=`echo \"$os\" | sed -e 's|sunos5|solaris2|'`\n\t\t;;\n\tsunos6*)\n\t\tos=`echo \"$os\" | sed -e 's|sunos6|solaris3|'`\n\t\t;;\n\twince*)\n\t\tos=wince\n\t\t;;\n\tutek*)\n\t\tos=bsd\n\t\tvendor=`echo \"$vendor\" | sed -e 's|^unknown$|tektronix|'`\n\t\t;;\n\tdynix*)\n\t\tos=bsd\n\t\t;;\n\tacis*)\n\t\tos=aos\n\t\t;;\n\tatheos*)\n\t\tos=atheos\n\t\t;;\n\tsyllable*)\n\t\tos=syllable\n\t\t;;\n\t386bsd)\n\t\tos=bsd\n\t\t;;\n\tctix*)\n\t\tos=sysv\n\t\tvendor=`echo \"$vendor\" | sed -e 's|^unknown$|convergent|'`\n\t\t;;\n\tuts*)\n\t\tos=sysv\n\t\t;;\n\tnova*)\n\t\tkernel=rtmk\n\t\tos=nova\n\t\t;;\n\t# Preserve the version number of sinix5.\n\tsinix5.*)\n\t\tos=`echo \"$os\" | sed -e 's|sinix|sysv|'`\n\t\tvendor=`echo \"$vendor\" | sed -e 's|^unknown$|sni|'`\n\t\t;;\n\tsinix*)\n\t\tos=sysv4\n\t\tvendor=`echo \"$vendor\" | sed -e 's|^unknown$|sni|'`\n\t\t;;\n\ttpf*)\n\t\tos=tpf\n\t\t;;\n\ttriton*)\n\t\tos=sysv3\n\t\t;;\n\toss*)\n\t\tos=sysv3\n\t\t;;\n\tsvr4*)\n\t\tos=sysv4\n\t\t;;\n\tsvr3)\n\t\tos=sysv3\n\t\t;;\n\tsysvr4)\n\t\tos=sysv4\n\t\t;;\n\tose*)\n\t\tos=ose\n\t\t;;\n\t*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)\n\t\tos=mint\n\t\t;;\n\tdicos*)\n\t\tos=dicos\n\t\t;;\n\tpikeos*)\n\t\t# Until real need of OS specific support for\n\t\t# particular features comes up, bare metal\n\t\t# configurations are quite functional.\n\t\tcase $cpu in\n\t\t    arm*)\n\t\t\tos=eabi\n\t\t\t;;\n\t\t    *)\n\t\t\tos=\n\t\t\tobj=elf\n\t\t\t;;\n\t\tesac\n\t\t;;\n\taout* | coff* | elf* | pe*)\n\t\t# These are machine code file formats, not OSes\n\t\tobj=$os\n\t\tos=\n\t\t;;\n\t*)\n\t\t# No normalization, but not necessarily accepted, that comes below.\n\t\t;;\nesac\n\nelse\n\n# Here we handle the default operating systems that come with various machines.\n# The value should be what the vendor currently ships out the door with their\n# machine or put another way, the most popular os provided with the machine.\n\n# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n# \"-sun\"), then you have to tell the case statement up towards the top\n# that MANUFACTURER isn't an operating system.  Otherwise, code above\n# will signal an error saying that MANUFACTURER isn't an operating\n# system, and we'll never get to this point.\n\nkernel=\nobj=\ncase $cpu-$vendor in\n\tscore-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tspu-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\t*-acorn)\n\t\tos=riscix1.2\n\t\t;;\n\tarm*-rebel)\n\t\tkernel=linux\n\t\tos=gnu\n\t\t;;\n\tarm*-semi)\n\t\tos=\n\t\tobj=aout\n\t\t;;\n\tc4x-* | tic4x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\tc8051-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tclipper-intergraph)\n\t\tos=clix\n\t\t;;\n\thexagon-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\ttic54x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\ttic55x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\ttic6x-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t# This must come before the *-dec entry.\n\tpdp10-*)\n\t\tos=tops20\n\t\t;;\n\tpdp11-*)\n\t\tos=none\n\t\t;;\n\t*-dec | vax-*)\n\t\tos=ultrix4.2\n\t\t;;\n\tm68*-apollo)\n\t\tos=domain\n\t\t;;\n\ti386-sun)\n\t\tos=sunos4.0.2\n\t\t;;\n\tm68000-sun)\n\t\tos=sunos3\n\t\t;;\n\tm68*-cisco)\n\t\tos=\n\t\tobj=aout\n\t\t;;\n\tmep-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\t# The -sgi and -siemens entries must be before the mips- entry\n\t# or we get the wrong os.\n\t*-sgi)\n\t\tos=irix\n\t\t;;\n\t*-siemens)\n\t\tos=sysv4\n\t\t;;\n\tmips*-cisco)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tmips*-*|nanomips*-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\tor32-*)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t# This must be before the sparc-* entry or we get the wrong os.\n\t*-tti)\n\t\tos=sysv3\n\t\t;;\n\tsparc-* | *-sun)\n\t\tos=sunos4.1.1\n\t\t;;\n\tpru-*)\n\t\tos=\n\t\tobj=elf\n\t\t;;\n\t*-be)\n\t\tos=beos\n\t\t;;\n\t*-ibm)\n\t\tos=aix\n\t\t;;\n\t*-knuth)\n\t\tos=mmixware\n\t\t;;\n\t*-wec)\n\t\tos=proelf\n\t\t;;\n\t*-winbond)\n\t\tos=proelf\n\t\t;;\n\t*-oki)\n\t\tos=proelf\n\t\t;;\n\t*-hp)\n\t\tos=hpux\n\t\t;;\n\t*-hitachi)\n\t\tos=hiuxwe2\n\t\t;;\n\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n\t\tos=sysv\n\t\t;;\n\t*-cbm)\n\t\tos=amigaos\n\t\t;;\n\t*-dg)\n\t\tos=dgux\n\t\t;;\n\t*-dolphin)\n\t\tos=sysv3\n\t\t;;\n\tm68k-ccur)\n\t\tos=rtu\n\t\t;;\n\tm88k-omron*)\n\t\tos=luna\n\t\t;;\n\t*-next)\n\t\tos=nextstep\n\t\t;;\n\t*-sequent)\n\t\tos=ptx\n\t\t;;\n\t*-crds)\n\t\tos=unos\n\t\t;;\n\t*-ns)\n\t\tos=genix\n\t\t;;\n\ti370-*)\n\t\tos=mvs\n\t\t;;\n\t*-gould)\n\t\tos=sysv\n\t\t;;\n\t*-highlevel)\n\t\tos=bsd\n\t\t;;\n\t*-encore)\n\t\tos=bsd\n\t\t;;\n\t*-masscomp)\n\t\tos=rtu\n\t\t;;\n\tf30[01]-fujitsu | f700-fujitsu)\n\t\tos=uxpv\n\t\t;;\n\t*-rom68k)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t*-*bug)\n\t\tos=\n\t\tobj=coff\n\t\t;;\n\t*-apple)\n\t\tos=macos\n\t\t;;\n\t*-atari*)\n\t\tos=mint\n\t\t;;\n\t*-wrs)\n\t\tos=vxworks\n\t\t;;\n\t*)\n\t\tos=none\n\t\t;;\nesac\n\nfi\n\n# Now, validate our (potentially fixed-up) individual pieces (OS, OBJ).\n\ncase $os in\n\t# Sometimes we do \"kernel-libc\", so those need to count as OSes.\n\tllvm* | musl* | newlib* | relibc* | uclibc*)\n\t\t;;\n\t# Likewise for \"kernel-abi\"\n\teabi* | gnueabi*)\n\t\t;;\n\t# VxWorks passes extra cpu info in the 4th filed.\n\tsimlinux | simwindows | spe)\n\t\t;;\n\t# See `case $cpu-$os` validation below\n\tghcjs)\n\t\t;;\n\t# Now accept the basic system types.\n\t# Each alternative MUST end in a * to match a version number.\n\t  abug \\\n\t| aix* \\\n\t| amdhsa* \\\n\t| amigados* \\\n\t| amigaos* \\\n\t| android* \\\n\t| aof* \\\n\t| aos* \\\n\t| aros* \\\n\t| atheos* \\\n\t| auroraux* \\\n\t| aux* \\\n\t| beos* \\\n\t| bitrig* \\\n\t| bme* \\\n\t| bosx* \\\n\t| bsd* \\\n\t| cegcc* \\\n\t| chorusos* \\\n\t| chorusrdb* \\\n\t| clix* \\\n\t| cloudabi* \\\n\t| cnk* \\\n\t| conix* \\\n\t| cos* \\\n\t| cxux* \\\n\t| cygwin* \\\n\t| darwin* \\\n\t| dgux* \\\n\t| dicos* \\\n\t| dnix* \\\n\t| domain* \\\n\t| dragonfly* \\\n\t| drops* \\\n\t| ebmon* \\\n\t| ecoff* \\\n\t| ekkobsd* \\\n\t| emscripten* \\\n\t| emx* \\\n\t| es* \\\n\t| fiwix* \\\n\t| freebsd* \\\n\t| fuchsia* \\\n\t| genix* \\\n\t| genode* \\\n\t| glidix* \\\n\t| gnu* \\\n\t| go32* \\\n\t| haiku* \\\n\t| hcos* \\\n\t| hiux* \\\n\t| hms* \\\n\t| hpux* \\\n\t| ieee* \\\n\t| interix* \\\n\t| ios* \\\n\t| iris* \\\n\t| irix* \\\n\t| ironclad* \\\n\t| isc* \\\n\t| its* \\\n\t| l4re* \\\n\t| libertybsd* \\\n\t| lites* \\\n\t| lnews* \\\n\t| luna* \\\n\t| lynxos* \\\n\t| mach* \\\n\t| macos* \\\n\t| magic* \\\n\t| mbr* \\\n\t| midipix* \\\n\t| midnightbsd* \\\n\t| mingw32* \\\n\t| mingw64* \\\n\t| minix* \\\n\t| mint* \\\n\t| mirbsd* \\\n\t| mks* \\\n\t| mlibc* \\\n\t| mmixware* \\\n\t| mon960* \\\n\t| morphos* \\\n\t| moss* \\\n\t| moxiebox* \\\n\t| mpeix* \\\n\t| mpw* \\\n\t| msdos* \\\n\t| msys* \\\n\t| mvs* \\\n\t| nacl* \\\n\t| netbsd* \\\n\t| netware* \\\n\t| newsos* \\\n\t| nextstep* \\\n\t| nindy* \\\n\t| nonstopux* \\\n\t| nova* \\\n\t| nsk* \\\n\t| nucleus* \\\n\t| nx6 \\\n\t| nx7 \\\n\t| oabi* \\\n\t| ohos* \\\n\t| onefs* \\\n\t| openbsd* \\\n\t| openedition* \\\n\t| openstep* \\\n\t| os108* \\\n\t| os2* \\\n\t| os400* \\\n\t| os68k* \\\n\t| os9* \\\n\t| ose* \\\n\t| osf* \\\n\t| oskit* \\\n\t| osx* \\\n\t| palmos* \\\n\t| phoenix* \\\n\t| plan9* \\\n\t| powermax* \\\n\t| powerunix* \\\n\t| proelf* \\\n\t| psos* \\\n\t| psp* \\\n\t| ptx* \\\n\t| pw32* \\\n\t| qnx* \\\n\t| rdos* \\\n\t| redox* \\\n\t| rhapsody* \\\n\t| riscix* \\\n\t| riscos* \\\n\t| rtems* \\\n\t| rtmk* \\\n\t| rtu* \\\n\t| scout* \\\n\t| secbsd* \\\n\t| sei* \\\n\t| serenity* \\\n\t| sim* \\\n\t| skyos* \\\n\t| solaris* \\\n\t| solidbsd* \\\n\t| sortix* \\\n\t| storm-chaos* \\\n\t| sunos \\\n\t| sunos[34]* \\\n\t| superux* \\\n\t| syllable* \\\n\t| sym* \\\n\t| sysv* \\\n\t| tenex* \\\n\t| tirtos* \\\n\t| toppers* \\\n\t| tops10* \\\n\t| tops20* \\\n\t| tpf* \\\n\t| tvos* \\\n\t| twizzler* \\\n\t| uclinux* \\\n\t| udi* \\\n\t| udk* \\\n\t| ultrix* \\\n\t| unicos* \\\n\t| uniplus* \\\n\t| unleashed* \\\n\t| unos* \\\n\t| uwin* \\\n\t| uxpv* \\\n\t| v88r* \\\n\t|*vms* \\\n\t| vos* \\\n\t| vsta* \\\n\t| vxsim* \\\n\t| vxworks* \\\n\t| wasi* \\\n\t| watchos* \\\n\t| wince* \\\n\t| windiss* \\\n\t| windows* \\\n\t| winnt* \\\n\t| xenix* \\\n\t| xray* \\\n\t| zephyr* \\\n\t| zvmoe* )\n\t\t;;\n\t# This one is extra strict with allowed versions\n\tsco3.2v2 | sco3.2v[4-9]* | sco5v6*)\n\t\t# Don't forget version if it is 3.2v4 or newer.\n\t\t;;\n\t# This refers to builds using the UEFI calling convention\n\t# (which depends on the architecture) and PE file format.\n\t# Note that this is both a different calling convention and\n\t# different file format than that of GNU-EFI\n\t# (x86_64-w64-mingw32).\n\tuefi)\n\t\t;;\n\tnone)\n\t\t;;\n\tkernel* | msvc* )\n\t\t# Restricted further below\n\t\t;;\n\t'')\n\t\tif test x\"$obj\" = x\n\t\tthen\n\t\t\techo \"Invalid configuration '$1': Blank OS only allowed with explicit machine code file format\" 1>&2\n\t\tfi\n\t\t;;\n\t*)\n\t\techo \"Invalid configuration '$1': OS '$os' not recognized\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\ncase $obj in\n\taout* | coff* | elf* | pe*)\n\t\t;;\n\t'')\n\t\t# empty is fine\n\t\t;;\n\t*)\n\t\techo \"Invalid configuration '$1': Machine code format '$obj' not recognized\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# Here we handle the constraint that a (synthetic) cpu and os are\n# valid only in combination with each other and nowhere else.\ncase $cpu-$os in\n\t# The \"javascript-unknown-ghcjs\" triple is used by GHC; we\n\t# accept it here in order to tolerate that, but reject any\n\t# variations.\n\tjavascript-ghcjs)\n\t\t;;\n\tjavascript-* | *-ghcjs)\n\t\techo \"Invalid configuration '$1': cpu '$cpu' is not valid with os '$os$obj'\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# As a final step for OS-related things, validate the OS-kernel combination\n# (given a valid OS), if there is a kernel.\ncase $kernel-$os-$obj in\n\tlinux-gnu*- | linux-android*- | linux-dietlibc*- | linux-llvm*- \\\n\t\t    | linux-mlibc*- | linux-musl*- | linux-newlib*- \\\n\t\t    | linux-relibc*- | linux-uclibc*- | linux-ohos*- )\n\t\t;;\n\tuclinux-uclibc*- | uclinux-gnu*- )\n\t\t;;\n\tmanagarm-mlibc*- | managarm-kernel*- )\n\t\t;;\n\twindows*-msvc*-)\n\t\t;;\n\t-dietlibc*- | -llvm*- | -mlibc*- | -musl*- | -newlib*- | -relibc*- \\\n\t\t    | -uclibc*- )\n\t\t# These are just libc implementations, not actual OSes, and thus\n\t\t# require a kernel.\n\t\techo \"Invalid configuration '$1': libc '$os' needs explicit kernel.\" 1>&2\n\t\texit 1\n\t\t;;\n\t-kernel*- )\n\t\techo \"Invalid configuration '$1': '$os' needs explicit kernel.\" 1>&2\n\t\texit 1\n\t\t;;\n\t*-kernel*- )\n\t\techo \"Invalid configuration '$1': '$kernel' does not support '$os'.\" 1>&2\n\t\texit 1\n\t\t;;\n\t*-msvc*- )\n\t\techo \"Invalid configuration '$1': '$os' needs 'windows'.\" 1>&2\n\t\texit 1\n\t\t;;\n\tkfreebsd*-gnu*- | knetbsd*-gnu*- | netbsd*-gnu*- | kopensolaris*-gnu*-)\n\t\t;;\n\tvxworks-simlinux- | vxworks-simwindows- | vxworks-spe-)\n\t\t;;\n\tnto-qnx*-)\n\t\t;;\n\tos2-emx-)\n\t\t;;\n\trtmk-nova-)\n\t\t;;\n\t*-eabi*- | *-gnueabi*-)\n\t\t;;\n\tnone--*)\n\t\t# None (no kernel, i.e. freestanding / bare metal),\n\t\t# can be paired with an machine code file format\n\t\t;;\n\t-*-)\n\t\t# Blank kernel with real OS is always fine.\n\t\t;;\n\t--*)\n\t\t# Blank kernel and OS with real machine code file format is always fine.\n\t\t;;\n\t*-*-*)\n\t\techo \"Invalid configuration '$1': Kernel '$kernel' not known to work with OS '$os'.\" 1>&2\n\t\texit 1\n\t\t;;\nesac\n\n# Here we handle the case where we know the os, and the CPU type, but not the\n# manufacturer.  We pick the logical manufacturer.\ncase $vendor in\n\tunknown)\n\t\tcase $cpu-$os in\n\t\t\t*-riscix*)\n\t\t\t\tvendor=acorn\n\t\t\t\t;;\n\t\t\t*-sunos* | *-solaris*)\n\t\t\t\tvendor=sun\n\t\t\t\t;;\n\t\t\t*-cnk* | *-aix*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-beos*)\n\t\t\t\tvendor=be\n\t\t\t\t;;\n\t\t\t*-hpux*)\n\t\t\t\tvendor=hp\n\t\t\t\t;;\n\t\t\t*-mpeix*)\n\t\t\t\tvendor=hp\n\t\t\t\t;;\n\t\t\t*-hiux*)\n\t\t\t\tvendor=hitachi\n\t\t\t\t;;\n\t\t\t*-unos*)\n\t\t\t\tvendor=crds\n\t\t\t\t;;\n\t\t\t*-dgux*)\n\t\t\t\tvendor=dg\n\t\t\t\t;;\n\t\t\t*-luna*)\n\t\t\t\tvendor=omron\n\t\t\t\t;;\n\t\t\t*-genix*)\n\t\t\t\tvendor=ns\n\t\t\t\t;;\n\t\t\t*-clix*)\n\t\t\t\tvendor=intergraph\n\t\t\t\t;;\n\t\t\t*-mvs* | *-opened*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-os400*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\ts390-* | s390x-*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-ptx*)\n\t\t\t\tvendor=sequent\n\t\t\t\t;;\n\t\t\t*-tpf*)\n\t\t\t\tvendor=ibm\n\t\t\t\t;;\n\t\t\t*-vxsim* | *-vxworks* | *-windiss*)\n\t\t\t\tvendor=wrs\n\t\t\t\t;;\n\t\t\t*-aux*)\n\t\t\t\tvendor=apple\n\t\t\t\t;;\n\t\t\t*-hms*)\n\t\t\t\tvendor=hitachi\n\t\t\t\t;;\n\t\t\t*-mpw* | *-macos*)\n\t\t\t\tvendor=apple\n\t\t\t\t;;\n\t\t\t*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)\n\t\t\t\tvendor=atari\n\t\t\t\t;;\n\t\t\t*-vos*)\n\t\t\t\tvendor=stratus\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\necho \"$cpu-$vendor${kernel:+-$kernel}${os:+-$os}${obj:+-$obj}\"\nexit\n\n# Local variables:\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-start: \"timestamp='\"\n# time-stamp-format: \"%:y-%02m-%02d\"\n# time-stamp-end: \"'\"\n# End:\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 10.662109375,
          "content": "dnl Process this file with autoconf to produce a configure script.\nAC_INIT\nAC_CONFIG_SRCDIR([netlist.h])\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_HEADERS([_pli_types.h])\nAC_CONFIG_HEADERS([vhdlpp/vhdlpp_config.h])\nAC_CONFIG_HEADERS([vvp/config.h])\nAC_CONFIG_HEADERS([vpi/vpi_config.h])\nAC_CONFIG_HEADERS([libveriuser/config.h])\nAC_CONFIG_HEADERS([tgt-vvp/vvp_config.h])\nAC_CONFIG_HEADERS([tgt-vhdl/vhdl_config.h])\nAC_CONFIG_HEADERS([tgt-pcb/pcb_config.h])\n\nAC_CANONICAL_HOST\ndnl Checks for programs.\nAC_PROG_CC\nAX_PROG_CC_FOR_BUILD\nAC_PREREQ([2.62])\nm4_version_prereq([2.70], [], [AC_PROG_CC_C99])\nAC_PROG_CXX\nAC_PROG_RANLIB\nAC_CHECK_TOOL(LD, ld, false)\nAC_CHECK_TOOL(AR, ar, false)\nAC_CHECK_TOOL(DLLTOOL, dlltool, false)\nAC_CHECK_TOOL(STRIP, strip, true)\nAC_CHECK_TOOL(WINDRES,windres,false)\nAC_CHECK_PROGS(XGPERF,gperf,none)\nAC_CHECK_PROGS(MAN,man,none)\nAC_CHECK_PROGS(PS2PDF,ps2pdf,none)\nAC_CHECK_PROGS(GIT,git,none)\nif test \"$XGPERF\" = \"none\"\nthen\n\techo \"\"\n        echo \"*** Warning: No suitable gperf found. ***\"\n\techo \"    The gperf package is essential for building ivl from\"\n\techo \"    git sources, or modifying the parse engine of ivl itself.\"\n\techo \"    You can get away without it when simply building from\"\n\techo \"    snapshots or major releases.\"\n\techo \"\"\nfi\n\nAC_CHECK_PROGS(LEX,flex,none)\nif test \"$LEX\" = \"none\"\nthen\n\techo \"*** Error: No suitable flex found. ***\"\n        echo \"    Please install the 'flex' package.\"\n        exit 1\nfi\n\nAC_CHECK_PROGS(YACC,bison,none)\nif test \"$YACC\" = \"none\"\nthen\n\techo \"*** Error: No suitable bison found. ***\"\n        echo \"    Please install the 'bison' package.\"\n        exit 1\nfi\n\nif test \"x$NM\" = \"x\"; then\n\tNM=nm\nfi\n\nAC_EXEEXT\nAC_SUBST(EXEEXT)\n\n# Combined check for Microsoft-related bogosities; sets WIN32 if found\nAX_WIN32\n\n# Check to see if we are using the Sun compiler. If so then configure\n# some of the flags to match the Sun compiler syntax. This is also used\n# in the aclocal.m4 file to configure the flags used to build and link\n# dynamic libraries\nAC_CHECK_DECL(__SUNPRO_C, using_sunpro_c=1, using_sunpro_c=0)\nif test ${using_sunpro_c} = 1\nthen\nAC_SUBST(DEPENDENCY_FLAG, [-xMMD])\nAC_SUBST(WARNING_FLAGS, [\"\"])\nAC_SUBST(WARNING_FLAGS_CXX, [\"\"])\nelse\n# Check to see if -Wextra is supported.\niverilog_temp_cflags=\"$CFLAGS\"\nCFLAGS=\"-Wextra $CFLAGS\"\nAC_MSG_CHECKING(if gcc supports -Wextra)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])],\n   [[iverilog_wextra_flag=\"-Wextra\";] AC_MSG_RESULT(yes)],\n   [[iverilog_wextra_flag=\"-W\";] AC_MSG_RESULT(no)])\nCFLAGS=\"$iverilog_temp_cflags\"\n\nAC_SUBST(DEPENDENCY_FLAG, [-MD])\nAC_SUBST(WARNING_FLAGS, [\"-Wall $iverilog_wextra_flag -Wshadow\"])\nAC_SUBST(WARNING_FLAGS_CC, [\"-Wstrict-prototypes\"])\nAC_SUBST(WARNING_FLAGS_CXX, [\"\"])\nfi\n\nAC_LANG(C++)\n\nAC_ARG_WITH([m32], [AS_HELP_STRING([--with-m32],[Compile 32-bit on x86_64])],\n            [ with_m32=yes ],[ with_m32=no ])\n\nAS_IF( [test \"x$with_m32\" = xyes],\n    [ AC_MSG_NOTICE([Compiling for 32-bit environment - needs gcc on x86_64])\n      LDTARGETFLAGS=\"-m elf_i386\"\n      CTARGETFLAGS=\"-m32\"\n    ],\n    [])\n\nCFLAGS=\"$CTARGETFLAGS $CFLAGS\"\nCXXFLAGS=\"$CTARGETFLAGS $CXXFLAGS -std=c++11\"\nLDFLAGS=\"$CTARGETFLAGS $LDFLAGS\"\n\n# Check that we are using either the GNU compilers or the Sun compilers\n# but not a mixture of the two (not currently supported).\nAC_CHECK_DECL(__SUNPRO_CC, using_sunpro_cc=1, using_sunpro_cc=0)\nif test ${using_sunpro_c} = 1\nthen\n  if test ${using_sunpro_cc} = 0\n  then\n    echo \"*** Error: No support for mixing GNU and Sun compilers. ***\"\n    echo \"           Using Sun C compiler and GNU C++ compiler..\"\n    exit 1\n  fi\nelse\n  if test ${using_sunpro_cc} = 1\n  then\n    echo \"*** Error: No support for mixing GNU and Sun compilers. ***\"\n    echo \"           Using GNU C compiler and Sun C++ compiler..\"\n    exit 1\n  fi\nfi\n\niverilog_temp_cxxflags=\"$CXXFLAGS\"\nCXXFLAGS=\"-DHAVE_DECL_BASENAME $CXXFLAGS\"\n\nAC_CHECK_HEADERS(getopt.h inttypes.h libiberty.h iosfwd sys/wait.h)\nCXXFLAGS=\"$iverilog_temp_cxxflags\"\n\nAC_CHECK_SIZEOF(unsigned long long)\nAC_CHECK_SIZEOF(unsigned long)\nAC_CHECK_SIZEOF(unsigned)\nAC_CHECK_SIZEOF(void *)\n\n# vvp uses these...\nAC_CHECK_LIB(termcap, tputs)\nAC_CHECK_LIB(readline, readline)\nAC_CHECK_LIB(readline, add_history, NEED_LIBHISTORY=no, NEED_LIBHISTORY=yes)\nif test \"$NEED_LIBHISTORY\" = \"yes\"; then\nAC_CHECK_LIB(history, add_history)\nelse\n# libreadline includes libhistory functions\nAC_DEFINE(HAVE_LIBHISTORY, 1)\nfi\nAC_CHECK_HEADERS(readline/readline.h readline/history.h sys/resource.h)\ncase \"${host}\" in *linux*) AC_DEFINE([LINUX], [1], [Host operating system is Linux.]) ;; esac\n\n# vpi uses these\nAC_CHECK_LIB(pthread, pthread_create)\nAC_CHECK_LIB(z, gzwrite)\nAC_CHECK_LIB(z, gzwrite, HAVE_LIBZ=yes, HAVE_LIBZ=no)\nAC_SUBST(HAVE_LIBZ)\nif test \"$WIN32\" = \"yes\"; then\nAC_CHECK_LIB(bz2, main)\nAC_CHECK_LIB(bz2, main, HAVE_LIBBZ2=yes, HAVE_LIBBZ2=no)\nelse\nAC_CHECK_LIB(bz2, BZ2_bzdopen)\nAC_CHECK_LIB(bz2, BZ2_bzdopen, HAVE_LIBBZ2=yes, HAVE_LIBBZ2=no)\nfi\nAC_SUBST(HAVE_LIBBZ2)\n\n# The lxt/lxt2 files from GTKWave use these...\n\nAC_FUNC_ALLOCA\nAC_FUNC_FSEEKO\n\n# Package Options\n# ---------------\n\n# Build VVP as a library and stub\nAC_ARG_ENABLE([libvvp],\n    [AS_HELP_STRING([--enable-libvvp], [build VVP as a shared library])],\n    [AC_SUBST(LIBVVP, yes)],[])\n\n# valgrind checks\nAC_ARG_WITH([valgrind], [AS_HELP_STRING([--with-valgrind],[Add valgrind hooks])],\n            [], [check_valgrind=yes])\n\nAS_IF([test \"x$check_valgrind\" = xyes],\n      [AC_MSG_NOTICE([Not using valgrind hooks])],\n      [AC_CHECK_HEADER([valgrind/memcheck.h],\n                       [AC_DEFINE([CHECK_WITH_VALGRIND], [1],\n                                  [Define to one to use the valgrind hooks])],\n                       [AC_MSG_ERROR([Could not find <valgrind/memcheck.h>])])])\n\nAC_MSG_CHECKING(for sys/times)\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <unistd.h>\n#include <sys/times.h>\n]], [[{clock_t a = times(0)/sysconf(_SC_CLK_TCK);}]])],[do_times=yes\nAC_DEFINE(HAVE_TIMES, 1, The times system call is available in the host operating system.)],[do_times=no\n])\nAC_MSG_RESULT($do_times)\n\n# --\n# Look for a dl library to use. First look for the standard dlopen\n# functions, and failing that look for the HP specific shl_load function.\n\nAC_CHECK_HEADERS(dlfcn.h dl.h, break)\n\nDLLIB=''\nAC_CHECK_LIB(dl,dlopen,[DLLIB=-ldl])\nif test -z \"$DLLIB\" ; then\nAC_CHECK_LIB(dld,shl_load,[DLLIB=-ldld])\nfi\nAC_SUBST(DLLIB)\nAC_SUBST(LDRELOCFLAGS)\n\nAC_SUBST(CTARGETFLAGS)\nAC_SUBST(LDTARGETFLAGS)\n\n\nAC_PROG_INSTALL\n\nAC_LANG(C)\nAC_C_BIGENDIAN\n\n# $host\n\nAX_ENABLE_SUFFIX\n\nAX_LD_EXTRALIBS\n\n# Compiler option for position independent code, needed when making shared objects.\n# CFLAGS inherited by cadpli/Makefile?\nAX_C_PICFLAG\n\n# may modify LDFLAGS\nAX_C99_STRTOD\n\n# Processor specific compile flags\ncase \"${host}\" in\n    alpha*-*-linux*)\n\tCPPFLAGS=\"-mieee $CPPFLAGS\"\n\tCFLAGS=\"-mieee $CFLAGS\"\n\t;;\n    *-*-mingw*)\n\t# The MINGW64/32 environments link to MSVCRT which has stdio issues\n\t# so use the slower, but functional mingw versions for this case.\n\tcase \"${MSYSTEM}\" in\n\t    MINGW*)\n\t\tCXXFLAGS=\"-D__USE_MINGW_ANSI_STDIO=1 $CXXFLAGS\"\n\t\tCFLAGS=\"-D__USE_MINGW_ANSI_STDIO=1 $CFLAGS\"\n\t\tAC_MSG_NOTICE([${MSYSTEM} needs -D__USE_MINGW_ANSI_STDIO=1])\n\t\t;;\n\n\tesac\n\t;;\nesac\n\n# Do some more operating system specific setup. We put the file64_support\n# define in a substitution instead of simply a define because there\n# are source files (namely lxt support files) that don't include any\n# config.h header file.\nfile64_support=''\ncase \"${host}\" in\n    *-*-linux*)\n\tAC_DEFINE([_LARGEFILE_SOURCE], [1], [Indicates LFS (i.e. the ability to create files larger than 2 GiB on 32-bit operating systems).])\n\tfile64_support='-D_LARGEFILE_SOURCE=1 -D_FILE_OFFSET_BITS=64'\n\t;;\nesac\nAC_SUBST(file64_support)\n\n# fstapi.c (from GTKWave) needs this define.\nAC_CHECK_FUNCS(realpath)\n\n# Check that these functions exist. They are mostly C99\n# functions that older compilers may not yet support.\nAC_CHECK_FUNCS(fopen64)\n# The following math functions may be defined in the math library so look\n# in the default libraries first and then look in -lm for them. On some\n# systems we may need to use the compiler in C99 mode to get a definition.\n# autoconf >= 2.70 will enable C99 if it is available. For older autoconf\n# versions, we requested C99 mode earlier with AC_PROG_CC_C99.\nAC_SEARCH_LIBS([lround], [m], [AC_DEFINE([HAVE_LROUND], [1])])\nAC_SEARCH_LIBS([llround], [m], [AC_DEFINE([HAVE_LLROUND], [1])])\nAC_SEARCH_LIBS([nan], [m], [AC_DEFINE([HAVE_NAN], [1])])\nAC_SEARCH_LIBS([fmin], [m], [AC_DEFINE([HAVE_FMIN], [1])])\nAC_SEARCH_LIBS([fmax], [m], [AC_DEFINE([HAVE_FMAX], [1])])\n\n# Check to see if an unsigned long and uint64_t are the same from\n# a compiler perspective. We can not just check that they are the\n# same size since unsigned long and unsigned long long are not the\n# same from an overloading perspective even though they could be\n# the same size on some 64 bit machines. The result from this test\n# is only used if inttypes.h is available, so if the test fails for\n# that reason we don't care.\nAC_LANG(C++)\nAC_MSG_CHECKING(if uint64_t and unsigned long are identical)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include \"inttypes.h\"\nstatic bool check(unsigned long val)\n{\n  return val != 0;\n}\nstatic bool check(uint64_t val)\n{\n  return val != 0;\n}]], [[unsigned long ulval = 1;\nbool result = check(ulval);\nuint64_t uival = 1;\nresult &= check(uival);\nreturn !result;]])],\n   [AC_MSG_RESULT(no)],\n   [AC_DEFINE([UINT64_T_AND_ULONG_SAME], [1]) AC_MSG_RESULT(yes)])\n\n# Linker option used when compiling the target\nAX_LD_RDYNAMIC\n\n# linker options when building a shared library\nAX_LD_SHAREDLIB_OPTS\n\n#######################\n## test for underscores. The vpi module loader needs to know this\n## in order to know the name of the start symbol for the .vpi module.\n#######################\n\nAX_C_UNDERSCORES_LEADING\nAX_C_UNDERSCORES_TRAILING\n\n#######################\n## end of test for underscores\n#######################\n\n#######################\n# Sanity check the configured results\n#######################\n\nAC_MSG_CHECKING(for sanity of prefix)\nif test `echo \"$prefix\" | wc -w` != 1\nthen\nAC_MSG_ERROR(cannot configure white space in prefix: $prefix)\nfi\nAC_MSG_RESULT(ok)\n\nAC_MSG_CHECKING(for sanity of exec_prefix)\nif test `echo \"$exec_prefix\" | wc -w` != 1\nthen\nAC_MSG_ERROR(cannot configure white space in exec_prefix: $exec_prefix)\nfi\nAC_MSG_RESULT(ok)\n\nAC_MSG_CHECKING(for sanity of libdir)\nif test `echo \"$libdir\" | wc -w` != 1\nthen\nAC_MSG_ERROR(cannot configure white space in libdir: $libdir)\nfi\nAC_MSG_RESULT(ok)\nAC_CONFIG_FILES([Makefile ivlpp/Makefile vhdlpp/Makefile vvp/Makefile vpi/Makefile driver/Makefile driver-vpi/Makefile cadpli/Makefile libveriuser/Makefile tgt-null/Makefile tgt-stub/Makefile tgt-vvp/Makefile tgt-vhdl/Makefile tgt-fpga/Makefile tgt-verilog/Makefile tgt-pal/Makefile tgt-vlog95/Makefile tgt-pcb/Makefile tgt-blif/Makefile tgt-sizer/Makefile])\nAC_OUTPUT\n"
        },
        {
          "name": "constants.vams",
          "type": "blob",
          "size": 1.3447265625,
          "content": "// Mathematical and physical constants\n\n`ifdef CONSTANTS_VAMS\n`else\n`define CONSTANTS_VAMS 1\n\n// M_ is a mathematical constant\n`define M_E        2.7182818284590452354\n`define M_LOG2E    1.4426950408889634074\n`define M_LOG10E   0.43429448190325182765\n`define M_LN2      0.69314718055994530942\n`define M_LN10     2.30258509299404568402\n`define M_PI       3.14159265358979323846\n`define M_TWO_PI   6.28318530717958647693\n`define M_PI_2     1.57079632679489661923\n`define M_PI_4     0.78539816339744830962\n`define M_1_PI     0.31830988618379067154\n`define M_2_PI     0.63661977236758134308\n`define M_2_SQRTPI 1.12837916709551257390\n`define M_SQRT2    1.41421356237309504880\n`define M_SQRT1_2  0.70710678118654752440\n\n/*\n * Do we need these? For now they are not available.\n *\n// The following constants have been taken from http://physics.nist.gov\n// P_ is a physical constant\n// charge of electron in coulombs\n`define P_Q        1.602176462e-19\n// speed of light in vacuum in meters/sec\n`define P_C        2.99792458e8\n// Boltzmann's constant in joules/kelvin\n`define P_K        1.3806503e-23\n// Planck's constant in joules*sec\n`define P_H        6.62606876e-34\n// permittivity of vacuum in farads/meter\n`define P_EPS0     8.854187817e-12\n// permeability of vacuum in henrys/meter\n`define P_U0       (4.0e-7 * `M_PI)\n// zero celsius in kelvin\n`define P_CELSIUS0 273.15\n*/\n`endif\n"
        },
        {
          "name": "cppcheck.sup",
          "type": "blob",
          "size": 16.2939453125,
          "content": "// These are correct and are used to find the base (zero) pin.\nthisSubtraction:netlist.h:5244\nthisSubtraction:netlist.h:5253\n\n// This is used when running a debugger\n// debugger_release\nknownConditionTrueFalse:main.cc:921\n\n// This are just stubs\n// vpi_control()\nunusedFunction:vpi_modules.cc:109\n// vpi_mcd_printf()\nunusedFunction:vpi_modules.cc:86\n// vpi_printf()\nunusedFunction:vpi_modules.cc:90\n// vpi_sim_control()\nunusedFunction:vpi_modules.cc:110\n\n// These are the functions that the compiler exports to the targets.\n//ivl_branch_island()\nunusedFunction:t-dll-api.cc:39\n//ivl_branch_terminal()\nunusedFunction:t-dll-api.cc:45\n\n//ivl_const_bits()\nunusedFunction:t-dll-api.cc:189\n//ivl_const_delay()\nunusedFunction:t-dll-api.cc:207\n//ivl_const_file()\nunusedFunction:t-dll-api.cc:214\n//ivl_const_lineno()\nunusedFunction:t-dll-api.cc:220\n//ivl_const_nex()\nunusedFunction:t-dll-api.cc:226\n//ivl_const_real()\nunusedFunction:t-dll-api.cc:232\n//ivl_const_scope()\nunusedFunction:t-dll-api.cc:239\n//ivl_const_signed()\nunusedFunction:t-dll-api.cc:245\n//ivl_const_type()\nunusedFunction:t-dll-api.cc:183\n//ivl_const_width()\nunusedFunction:t-dll-api.cc:251\n\n//ivl_design_const()\nunusedFunction:t-dll-api.cc:120\n//ivl_design_consts()\nunusedFunction:t-dll-api.cc:114\n//ivl_design_delay_sel()\nunusedFunction:t-dll-api.cc:52\n//ivl_design_discipline()\nunusedFunction:t-dll-api.cc:133\n//ivl_design_disciplines()\nunusedFunction:t-dll-api.cc:127\n//ivl_design_flag()\nunusedFunction:t-dll-api.cc:59\n//ivl_design_process()\nunusedFunction:t-dll-api.cc:66\n//ivl_design_root()\nunusedFunction:t-dll-api.cc:80\n//ivl_design_roots()\nunusedFunction:t-dll-api.cc:89\n//ivl_design_time_precision()\nunusedFunction:t-dll-api.cc:108\n\n//ivl_discipline_domain()\nunusedFunction:t-dll-api.cc:140\n//ivl_discipline_flow()\nunusedFunction:t-dll-api.cc:146\n//ivl_discipline_name()\nunusedFunction:t-dll-api.cc:152\n//ivl_discipline_potential()\nunusedFunction:t-dll-api.cc:158\n\n//ivl_enum_bits()\nunusedFunction:t-dll-api.cc:270\n//ivl_enum_file()\nunusedFunction:t-dll-api.cc:295\n//ivl_enum_lineno()\nunusedFunction:t-dll-api.cc:301\n//ivl_enum_name()\nunusedFunction:t-dll-api.cc:263\n//ivl_enum_names()\nunusedFunction:t-dll-api.cc:257\n//ivl_enum_signed()\nunusedFunction:t-dll-api.cc:289\n//ivl_enum_type()\nunusedFunction:t-dll-api.cc:277\n//ivl_enum_width()\nunusedFunction:t-dll-api.cc:283\n\n//ivl_event_any()\nunusedFunction:t-dll-api.cc:362\n//ivl_event_file()\nunusedFunction:t-dll-api.cc:338\n//ivl_event_lineno()\nunusedFunction:t-dll-api.cc:344\n//ivl_event_name()\nunusedFunction:t-dll-api.cc:307\n//ivl_event_nany()\nunusedFunction:t-dll-api.cc:356\n//ivl_event_neg()\nunusedFunction:t-dll-api.cc:375\n//ivl_event_nneg()\nunusedFunction:t-dll-api.cc:369\n//ivl_event_npos()\nunusedFunction:t-dll-api.cc:382\n//ivl_event_pos()\nunusedFunction:t-dll-api.cc:388\n//ivl_event_scope()\nunusedFunction:t-dll-api.cc:350\n\n//ivl_expr_bits()\nunusedFunction:t-dll-api.cc:395\n//ivl_expr_branch()\nunusedFunction:t-dll-api.cc:402\n//ivl_expr_def()\nunusedFunction:t-dll-api.cc:409\n//ivl_expr_delay_val()\nunusedFunction:t-dll-api.cc:425\n//ivl_expr_dvalue()\nunusedFunction:t-dll-api.cc:432\n//ivl_expr_enumtype()\nunusedFunction:t-dll-api.cc:439\n//ivl_expr_event()\nunusedFunction:t-dll-api.cc:649\n//ivl_expr_file()\nunusedFunction:t-dll-api.cc:171\n//ivl_expr_lineno()\nunusedFunction:t-dll-api.cc:177\n//ivl_expr_name()\nunusedFunction:t-dll-api.cc:452\n//ivl_expr_nature()\nunusedFunction:t-dll-api.cc:476\n//ivl_expr_net_type()\nunusedFunction:t-dll-api.cc:446\n//ivl_expr_opcode()\nunusedFunction:t-dll-api.cc:483\n//ivl_expr_oper1()\nunusedFunction:t-dll-api.cc:499\n//ivl_expr_oper2()\nunusedFunction:t-dll-api.cc:537\n//ivl_expr_oper3()\nunusedFunction:t-dll-api.cc:563\n//ivl_expr_parameter()\nunusedFunction:t-dll-api.cc:577\n//ivl_expr_parm()\nunusedFunction:t-dll-api.cc:592\n//ivl_expr_parms()\nunusedFunction:t-dll-api.cc:619\n//ivl_expr_repeat()\nunusedFunction:t-dll-api.cc:642\n//ivl_expr_scope()\nunusedFunction:t-dll-api.cc:663\n//ivl_expr_sel_type()\nunusedFunction:t-dll-api.cc:670\n//ivl_expr_signed()\nunusedFunction:t-dll-api.cc:795\n//ivl_expr_sized()\nunusedFunction:t-dll-api.cc:701\n//ivl_expr_string()\nunusedFunction:t-dll-api.cc:707\n//ivl_expr_type()\nunusedFunction:t-dll-api.cc:164\n//ivl_expr_uvalue()\nunusedFunction:t-dll-api.cc:714\n//ivl_expr_value()\nunusedFunction:t-dll-api.cc:740\n//ivl_expr_width()\nunusedFunction:t-dll-api.cc:746\n\n//ivl_file_table_index()\nunusedFunction:t-dll-api.cc:788\n//ivl_file_table_item()\nunusedFunction:t-dll-api.cc:778\n//ivl_file_table_size()\nunusedFunction:t-dll-api.cc:806\n\n//ivl_island_flag_set()\nunusedFunction:t-dll-api.cc:815\n//ivl_island_flag_test()\nunusedFunction:t-dll-api.cc:830\n\n//ivl_logic_attr()\nunusedFunction:t-dll-api.cc:857\n//ivl_logic_attr_cnt()\nunusedFunction:t-dll-api.cc:873\n//ivl_logic_attr_val()\nunusedFunction:t-dll-api.cc:879\n//ivl_logic_basename()\nunusedFunction:t-dll-api.cc:928\n//ivl_logic_delay()\nunusedFunction:t-dll-api.cc:967\n//ivl_logic_drive0()\nunusedFunction:t-dll-api.cc:887\n//ivl_logic_drive1()\nunusedFunction:t-dll-api.cc:904\n//ivl_logic_file()\nunusedFunction:t-dll-api.cc:839\n//ivl_logic_is_cassign()\nunusedFunction:t-dll-api.cc:851\n//ivl_logic_lineno()\nunusedFunction:t-dll-api.cc:845\n//ivl_logic_name()\nunusedFunction:t-dll-api.cc:921\n//ivl_logic_pins()\nunusedFunction:t-dll-api.cc:946\n//ivl_logic_scope()\nunusedFunction:t-dll-api.cc:934\n//ivl_logic_type()\nunusedFunction:t-dll-api.cc:940\n//ivl_logic_udp()\nunusedFunction:t-dll-api.cc:959\n//ivl_logic_width()\nunusedFunction:t-dll-api.cc:974\n\n//ivl_lpm_array()\nunusedFunction:t-dll-api.cc:1102\n//ivl_lpm_aset_value()\nunusedFunction:t-dll-api.cc:1153\n//ivl_lpm_async_clr()\nunusedFunction:t-dll-api.cc:1047\n//ivl_lpm_async_set()\nunusedFunction:t-dll-api.cc:1078\n//ivl_lpm_base()\nunusedFunction:t-dll-api.cc:1114\n//ivl_lpm_basename()\nunusedFunction:t-dll-api.cc:1041\n//ivl_lpm_clk()\nunusedFunction:t-dll-api.cc:1141\n//ivl_lpm_data()\nunusedFunction:t-dll-api.cc:1214\n//ivl_lpm_datab()\nunusedFunction:t-dll-api.cc:1316\n//ivl_lpm_define()\nunusedFunction:t-dll-api.cc:1176\n//ivl_lpm_delay()\nunusedFunction:t-dll-api.cc:1071\n//ivl_lpm_drive0()\nunusedFunction:t-dll-api.cc:1450\n//ivl_lpm_drive1()\nunusedFunction:t-dll-api.cc:1467\n//ivl_lpm_enable()\nunusedFunction:t-dll-api.cc:1188\n//ivl_lpm_file()\nunusedFunction:t-dll-api.cc:1202\n//ivl_lpm_lineno()\nunusedFunction:t-dll-api.cc:1208\n//ivl_lpm_name()\nunusedFunction:t-dll-api.cc:1350\n//ivl_lpm_negedge()\nunusedFunction:t-dll-api.cc:1129\n//ivl_lpm_select()\nunusedFunction:t-dll-api.cc:1490\n//ivl_lpm_selects()\nunusedFunction:t-dll-api.cc:1507\n//ivl_lpm_signed()\nunusedFunction:t-dll-api.cc:1526\n//ivl_lpm_size()\nunusedFunction:t-dll-api.cc:1587\n//ivl_lpm_sset_value()\nunusedFunction:t-dll-api.cc:1164\n//ivl_lpm_string()\nunusedFunction:t-dll-api.cc:1640\n//ivl_lpm_sync_clr()\nunusedFunction:t-dll-api.cc:1059\n//ivl_lpm_sync_set()\nunusedFunction:t-dll-api.cc:1090\n//ivl_lpm_trigger()\nunusedFunction:t-dll-api.cc:1659\n//ivl_lpm_type()\nunusedFunction:t-dll-api.cc:1647\n//ivl_lpm_width()\nunusedFunction:t-dll-api.cc:1653\n\n//ivl_lval_idx()\nunusedFunction:t-dll-api.cc:1681\n//ivl_lval_mux()\nunusedFunction:t-dll-api.cc:1676\n//ivl_lval_nest()\nunusedFunction:t-dll-api.cc:1726\n//ivl_lval_part_off()\nunusedFunction:t-dll-api.cc:1690\n//ivl_lval_property_idx()\nunusedFunction:t-dll-api.cc:1708\n//ivl_lval_sel_type()\nunusedFunction:t-dll-api.cc:1696\n//ivl_lval_sig()\nunusedFunction:t-dll-api.cc:1714\n\n//ivl_nature_name()\nunusedFunction:t-dll-api.cc:1735\n\n//ivl_nexus_get_private()\nunusedFunction:t-dll-api.cc:1756\n//ivl_nexus_name()\nunusedFunction:t-dll-api.cc:1745\n//ivl_nexus_ptr_branch()\nunusedFunction:t-dll-api.cc:1799\n//ivl_nexus_ptr_con()\nunusedFunction:t-dll-api.cc:1808\n//ivl_nexus_ptr_sig()\nunusedFunction:t-dll-api.cc:1835\n//ivl_nexus_ptr_switch()\nunusedFunction:t-dll-api.cc:1844\n//ivl_nexus_set_private()\nunusedFunction:t-dll-api.cc:1762\n\n//ivl_parameter_basename()\nunusedFunction:t-dll-api.cc:1853\n//ivl_parameter_expr()\nunusedFunction:t-dll-api.cc:1896\n//ivl_parameter_file()\nunusedFunction:t-dll-api.cc:1902\n//ivl_parameter_lineno()\nunusedFunction:t-dll-api.cc:1908\n//ivl_parameter_local()\nunusedFunction:t-dll-api.cc:1859\n//ivl_parameter_lsb()\nunusedFunction:t-dll-api.cc:1877\n//ivl_parameter_msb()\nunusedFunction:t-dll-api.cc:1871\n//ivl_parameter_scope()\nunusedFunction:t-dll-api.cc:1914\n//ivl_parameter_signed()\nunusedFunction:t-dll-api.cc:1865\n//ivl_parameter_width()\nunusedFunction:t-dll-api.cc:1887\n\n//ivl_path_condit()\nunusedFunction:t-dll-api.cc:1920\n//ivl_path_delay()\nunusedFunction:t-dll-api.cc:1938\n//ivl_path_is_condit()\nunusedFunction:t-dll-api.cc:1926\n//ivl_path_is_parallel()\nunusedFunction:t-dll-api.cc:1932\n//ivl_path_scope()\nunusedFunction:t-dll-api.cc:1944\n//ivl_path_source()\nunusedFunction:t-dll-api.cc:1951\n//ivl_path_source_negedge()\nunusedFunction:t-dll-api.cc:1963\n//ivl_path_source_posedge()\nunusedFunction:t-dll-api.cc:1957\n\n//ivl_process_analog()\nunusedFunction:t-dll-api.cc:1987\n//ivl_process_attr_cnt()\nunusedFunction:t-dll-api.cc:2005\n//ivl_process_attr_val()\nunusedFunction:t-dll-api.cc:2011\n//ivl_process_file()\nunusedFunction:t-dll-api.cc:1969\n//ivl_process_lineno()\nunusedFunction:t-dll-api.cc:1975\n//ivl_process_scope()\nunusedFunction:t-dll-api.cc:1993\n//ivl_process_stmt()\nunusedFunction:t-dll-api.cc:1999\n//ivl_process_type()\nunusedFunction:t-dll-api.cc:1981\n\n//ivl_scope_attr_cnt()\nunusedFunction:t-dll-api.cc:2019\n//ivl_scope_attr_val()\nunusedFunction:t-dll-api.cc:2025\n//ivl_scope_basename()\nunusedFunction:t-dll-api.cc:2033\n//ivl_scope_child()\nunusedFunction:t-dll-api.cc:2060\n//ivl_scope_children()\nunusedFunction:t-dll-api.cc:2039\n//ivl_scope_childs()\nunusedFunction:t-dll-api.cc:2053\n//ivl_scope_class()\nunusedFunction:t-dll-api.cc:2067\n//ivl_scope_classes()\nunusedFunction:t-dll-api.cc:2074\n//ivl_scope_def()\nunusedFunction:t-dll-api.cc:2081\n//ivl_scope_def_file()\nunusedFunction:t-dll-api.cc:2087\n//ivl_scope_def_lineno()\nunusedFunction:t-dll-api.cc:2093\n//ivl_scope_enumerate()\nunusedFunction:t-dll-api.cc:2105\n//ivl_scope_enumerates()\nunusedFunction:t-dll-api.cc:2099\n//ivl_scope_event()\nunusedFunction:t-dll-api.cc:2118\n//ivl_scope_events()\nunusedFunction:t-dll-api.cc:2112\n//ivl_scope_file()\nunusedFunction:t-dll-api.cc:2125\n//ivl_scope_func_signed\nunusedFunction:t-dll-api.cc:2138\n//ivl_scope_func_type\nunusedFunction:t-dll-api.cc:2131\n//ivl_scope_func_width\nunusedFunction:t-dll-api.cc:2146\n//ivl_scope_is_auto()\nunusedFunction:t-dll-api.cc:2154\n//ivl_scope_is_cell()\nunusedFunction:t-dll-api.cc:2160\n//ivl_scope_lineno()\nunusedFunction:t-dll-api.cc:2166\n//ivl_scope_log()\nunusedFunction:t-dll-api.cc:2178\n//ivl_scope_logs()\nunusedFunction:t-dll-api.cc:2172\n//ivl_scope_lpm()\nunusedFunction:t-dll-api.cc:2191\n//ivl_scope_lpms()\nunusedFunction:t-dll-api.cc:2185\n//ivl_scope_mod_module_port_name()\nunusedFunction:t-dll-api.cc:2270\n//ivl_scope_mod_module_port_type()\nunusedFunction:t-dll-api.cc:2279\n//ivl_scope_mod_module_port_width()\nunusedFunction:t-dll-api.cc:2291\n//ivl_scope_mod_module_ports()\nunusedFunction:t-dll-api.cc:2263\n//ivl_scope_mod_port()\nunusedFunction:t-dll-api.cc:2316\n//ivl_scope_param()\nunusedFunction:t-dll-api.cc:2249\n//ivl_scope_params()\nunusedFunction:t-dll-api.cc:2243\n//ivl_scope_parent()\nunusedFunction:t-dll-api.cc:2256\n//ivl_scope_port()\nunusedFunction:t-dll-api.cc:2307\n//ivl_scope_ports()\nunusedFunction:t-dll-api.cc:2298\n//ivl_scope_sig()\nunusedFunction:t-dll-api.cc:2330\n//ivl_scope_sigs()\nunusedFunction:t-dll-api.cc:2324\n//ivl_scope_switch()\nunusedFunction:t-dll-api.cc:2343\n//ivl_scope_switches()\nunusedFunction:t-dll-api.cc:2337\n//ivl_scope_time_precision()\nunusedFunction:t-dll-api.cc:2350\n//ivl_scope_time_units()\nunusedFunction:t-dll-api.cc:2356\n//ivl_scope_tname()\nunusedFunction:t-dll-api.cc:2368\n//ivl_scope_type()\nunusedFunction:t-dll-api.cc:2362\n\n//ivl_signal_array_addr_swapped()\nunusedFunction:t-dll-api.cc:2386\n//ivl_signal_array_base()\nunusedFunction:t-dll-api.cc:2374\n//ivl_signal_array_count()\nunusedFunction:t-dll-api.cc:2380\n//ivl_signal_attr()\nunusedFunction:t-dll-api.cc:2404\n//ivl_signal_attr_cnt()\nunusedFunction:t-dll-api.cc:2420\n//ivl_signal_attr_val()\nunusedFunction:t-dll-api.cc:2426\n//ivl_signal_basename()\nunusedFunction:t-dll-api.cc:2433\n//ivl_signal_data_type()\nunusedFunction:t-dll-api.cc:2584\n//ivl_signal_dimensions()\nunusedFunction:t-dll-api.cc:2392\n//ivl_signal_discipline()\nunusedFunction:t-dll-api.cc:2398\n//ivl_signal_file()\nunusedFunction:t-dll-api.cc:2561\n//ivl_signal_forced_net()\nunusedFunction:t-dll-api.cc:2555\n//ivl_signal_integer()\nunusedFunction:t-dll-api.cc:2573\n//ivl_signal_lineno()\nunusedFunction:t-dll-api.cc:2567\n//ivl_signal_local()\nunusedFunction:t-dll-api.cc:2542\n//ivl_signal_lsb()\nunusedFunction:t-dll-api.cc:2507\n//ivl_signal_module_port_index()\nunusedFunction:t-dll-api.cc:2536\n//ivl_signal_msb()\nunusedFunction:t-dll-api.cc:2497\n//ivl_signal_name()\nunusedFunction:t-dll-api.cc:2439\n//ivl_signal_nex()\nunusedFunction:t-dll-api.cc:2460\n//ivl_signal_npath()\nunusedFunction:t-dll-api.cc:2597\n//ivl_signal_packed_dimensions()\nunusedFunction:t-dll-api.cc:2477\n//ivl_signal_packed_lsb()\nunusedFunction:t-dll-api.cc:2490\n//ivl_signal_packed_msb()\nunusedFunction:t-dll-api.cc:2483\n//ivl_signal_path()\nunusedFunction:t-dll-api.cc:2603\n//ivl_signal_port()\nunusedFunction:t-dll-api.cc:2530\n//ivl_signal_scope()\nunusedFunction:t-dll-api.cc:2517\n//ivl_signal_signed()\nunusedFunction:t-dll-api.cc:2548\n//ivl_signal_width()\nunusedFunction:t-dll-api.cc:2523\n\n//ivl_statement_type()\nunusedFunction:t-dll-api.cc:2616\n\n//ivl_stmt_block_count()\nunusedFunction:t-dll-api.cc:2649\n//ivl_stmt_block_scope()\nunusedFunction:t-dll-api.cc:2634\n//ivl_stmt_block_stmt()\nunusedFunction:t-dll-api.cc:2664\n//ivl_stmt_call()\nunusedFunction:t-dll-api.cc:2680\n//ivl_stmt_case_count()\nunusedFunction:t-dll-api.cc:2701\n//ivl_stmt_case_expr()\nunusedFunction:t-dll-api.cc:2716\n//ivl_stmt_case_quality()\nunusedFunction:t-dll-api.cc:2733\n//ivl_stmt_case_stmt()\nunusedFunction:t-dll-api.cc:2749\n//ivl_stmt_cond_expr()\nunusedFunction:t-dll-api.cc:2766\n//ivl_stmt_cond_false()\nunusedFunction:t-dll-api.cc:2793\n//ivl_stmt_cond_true()\nunusedFunction:t-dll-api.cc:2803\n//ivl_stmt_delay_expr()\nunusedFunction:t-dll-api.cc:2813\n//ivl_stmt_delay_val()\nunusedFunction:t-dll-api.cc:2830\n//ivl_stmt_events()\nunusedFunction:t-dll-api.cc:2866\n//ivl_stmt_file()\nunusedFunction:t-dll-api.cc:2622\n//ivl_stmt_lexp()\nunusedFunction:t-dll-api.cc:2894\n//ivl_stmt_lineno()\nunusedFunction:t-dll-api.cc:2628\n//ivl_stmt_lval()\nunusedFunction:t-dll-api.cc:2906\n//ivl_stmt_lvals()\nunusedFunction:t-dll-api.cc:2925\n//ivl_stmt_lwidth()\nunusedFunction:t-dll-api.cc:2943\n//ivl_stmt_name()\nunusedFunction:t-dll-api.cc:2976\n//ivl_stmt_needs_t0_trigger()\nunusedFunction:t-dll-api.cc:2837\n//ivl_stmt_nevent()\nunusedFunction:t-dll-api.cc:2847\n//ivl_stmt_opcode()\nunusedFunction:t-dll-api.cc:2989\n//ivl_stmt_parm()\nunusedFunction:t-dll-api.cc:3001\n//ivl_stmt_parm_count()\nunusedFunction:t-dll-api.cc:3015\n//ivl_stmt_rval()\nunusedFunction:t-dll-api.cc:3027\n//ivl_stmt_sfunc_as_task()\nunusedFunction:t-dll-api.cc:3045\n//ivl_stmt_sub_stmt()\nunusedFunction:t-dll-api.cc:3058\n\n//ivl_switch_a()\nunusedFunction:t-dll-api.cc:3099\n//ivl_switch_b()\nunusedFunction:t-dll-api.cc:3105\n//ivl_switch_basename()\nunusedFunction:t-dll-api.cc:3081\n//ivl_switch_delay()\nunusedFunction:t-dll-api.cc:3135\n//ivl_switch_enable()\nunusedFunction:t-dll-api.cc:3111\n//ivl_switch_file()\nunusedFunction:t-dll-api.cc:3142\n//ivl_switch_island()\nunusedFunction:t-dll-api.cc:3148\n//ivl_switch_lineno()\nunusedFunction:t-dll-api.cc:3154\n//ivl_switch_offset()\nunusedFunction:t-dll-api.cc:3129\n//ivl_switch_part()\nunusedFunction:t-dll-api.cc:3123\n//ivl_switch_scope()\nunusedFunction:t-dll-api.cc:3087\n//ivl_switch_type()\nunusedFunction:t-dll-api.cc:3093\n//ivl_switch_width()\nunusedFunction:t-dll-api.cc:3117\n\n//ivl_type_base()\n//unusedFunction:t-dll-api.cc:3128 Used in netmisc.cc\n//ivl_type_element()\nunusedFunction:t-dll-api.cc:3166\n//ivl_type_name()\nunusedFunction:t-dll-api.cc:3198\n//ivl_type_packed_dimensions()\nunusedFunction:t-dll-api.cc:3175\n//ivl_type_packed_lsb()\nunusedFunction:t-dll-api.cc:3182\n//ivl_type_packed_msb()\nunusedFunction:t-dll-api.cc:3190\n//ivl_type_prop_type()\nunusedFunction:t-dll-api.cc:3223\n//ivl_type_properties()\nunusedFunction:t-dll-api.cc:3206\n//ivl_type_signed()\nunusedFunction:t-dll-api.cc:3231\n\n//ivl_udp_file()\nunusedFunction:t-dll-api.cc:1029\n//ivl_udp_init()\nunusedFunction:t-dll-api.cc:992\n//ivl_udp_lineno()\nunusedFunction:t-dll-api.cc:1035\n//ivl_udp_name()\nunusedFunction:t-dll-api.cc:1022\n//ivl_udp_nin()\nunusedFunction:t-dll-api.cc:986\n//ivl_udp_port()\nunusedFunction:t-dll-api.cc:998\n//ivl_udp_row()\nunusedFunction:t-dll-api.cc:1007\n//ivl_udp_rows()\nunusedFunction:t-dll-api.cc:1016\n// ivl_udp_sequ()\nunusedFunction:t-dll-api.cc:980\n"
        },
        {
          "name": "cprop.cc",
          "type": "blob",
          "size": 14.0166015625,
          "content": "/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <algorithm>\n# include  <vector>\n# include  <cstdlib>\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"functor.h\"\n# include  \"compiler.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * The cprop function below invokes constant propagation where\n * possible. The elaboration generates NetConst objects. I can remove\n * these and replace the gates connected to it with simpler ones. I\n * may even be able to replace nets with a new constant.\n */\n\nstruct cprop_functor  : public functor_t {\n\n      unsigned count;\n\n      virtual void signal(Design*des, NetNet*obj);\n      virtual void lpm_add_sub(Design*des, NetAddSub*obj);\n      virtual void lpm_compare(Design*des, const NetCompare*obj);\n      virtual void lpm_concat(Design*des, NetConcat*obj);\n      virtual void lpm_ff(Design*des, NetFF*obj);\n      virtual void lpm_logic(Design*des, NetLogic*obj);\n      virtual void lpm_mux(Design*des, NetMux*obj);\n      virtual void lpm_part_select(Design*des, NetPartSelect*obj);\n\n      void lpm_compare_eq_(Design*des, const NetCompare*obj);\n };\n\nvoid cprop_functor::signal(Design*, NetNet*)\n{\n}\n\nvoid cprop_functor::lpm_add_sub(Design*, NetAddSub*)\n{\n}\n\nvoid cprop_functor::lpm_compare(Design*des, const NetCompare*obj)\n{\n      if (obj->pin_AEB().is_linked()) {\n\t    assert( ! obj->pin_AGB().is_linked() );\n\t    assert( ! obj->pin_AGEB().is_linked() );\n\t    assert( ! obj->pin_ALB().is_linked() );\n\t    assert( ! obj->pin_ALEB().is_linked() );\n\t    assert( ! obj->pin_AGB().is_linked() );\n\t    assert( ! obj->pin_ANEB().is_linked() );\n\t    lpm_compare_eq_(des, obj);\n\t    return;\n      }\n}\n\nvoid cprop_functor::lpm_compare_eq_(Design*, const NetCompare*)\n{\n}\n\nvoid cprop_functor::lpm_concat(Design*des, NetConcat*obj)\n{\n\t// Sorry, I don't know how to constant-propagate through\n\t// transparent concatenations.\n      if (obj->transparent())\n\t    return;\n\n      verinum result (verinum::Vz, obj->width());\n      unsigned off = 0;\n\n      for (unsigned idx = 1 ; idx < obj->pin_count() ; idx += 1) {\n\t    Nexus*nex = obj->pin(idx).nexus();\n\t      // If there are non-constant drivers, then give up.\n\t    if (! nex->drivers_constant())\n\t\t  return;\n\n\t    verinum tmp = nex->driven_vector();\n\t    result.set(off, tmp);\n\t    off += tmp.len();\n      }\n\n      if (debug_optimizer)\n\t    cerr << obj->get_fileline() << \": cprop_functor::lpm_concat: \"\n\t\t << \"Replace NetConcat with \" << result << \".\" << endl;\n\n\n      NetScope*scope = obj->scope();\n\n\t// Create a NetConst object to carry the result. Give it the\n\t// same name as the Concat object that we are replacing, and\n\t// link the NetConst to the NetConcat object. Then delete the\n\t// concat that is now replaced.\n      NetConst*result_obj = new NetConst(scope, obj->name(), result);\n      result_obj->set_line(*obj);\n      des->add_node(result_obj);\n      connect(obj->pin(0), result_obj->pin(0));\n\n\t// Note that this will leave the const inputs to dangle. They\n\t// will be reaped by other passes of cprop_functor.\n      delete obj;\n\n      count += 1;\n}\n\nvoid cprop_functor::lpm_ff(Design*, NetFF*obj)\n{\n\t// Look for and count unlinked FF outputs. Note that if the\n\t// Data and Q pins are connected together, they can be removed\n\t// from the circuit, since it doesn't do anything.\n\n      if (connected(obj->pin_Data(), obj->pin_Q())\n\t  && (! obj->pin_Sclr().is_linked())\n\t  && (! obj->pin_Sset().is_linked())\n\t  && (! obj->pin_Aclr().is_linked())\n\t  && (! obj->pin_Aset().is_linked())) {\n\t    obj->pin_Data().unlink();\n\t    obj->pin_Q().unlink();\n\t    delete obj;\n      }\n}\n\nvoid cprop_functor::lpm_logic(Design*, NetLogic*)\n{\n}\n\n/*\n * This detects the case where the mux selects between a value and\n * Vz. In this case, replace the device with a mos with the sel\n * input used to enable the output.\n */\nvoid cprop_functor::lpm_mux(Design*des, NetMux*obj)\n{\n      if (obj->size() != 2)\n\t    return;\n      if (obj->sel_width() != 1)\n\t    return;\n\n      Nexus*sel_nex = obj->pin_Sel().nexus();\n\n\t/* If the select input is constant, then replace with a BUFZ */\n\n\t// If the select is not constant, there is nothing we can do.\n      if (! sel_nex->drivers_constant())\n\t    return;\n\n\t// If the constant select is 'bz or 'bx, then give up.\n      verinum::V sel_val = sel_nex->driven_value();\n      if (sel_val == verinum::Vz || sel_val == verinum::Vx)\n\t    return;\n\n\t// The Select input must be a defined constant value, so we\n\t// can replace the device with a BUFZ.\n\n      NetBUFZ*tmp = new NetBUFZ(obj->scope(), obj->name(), obj->width(), true);\n      tmp->set_line(*obj);\n\n      if (debug_optimizer)\n\t    cerr << obj->get_fileline() << \": debug: \"\n\t\t << \"Replace binary MUX with constant select=\" << sel_val\n\t\t << \" with a BUFZ to the selected input.\" << endl;\n\n      tmp->rise_time(obj->rise_time());\n      tmp->fall_time(obj->fall_time());\n      tmp->decay_time(obj->decay_time());\n\n      connect(tmp->pin(0), obj->pin_Result());\n      if (sel_val == verinum::V1)\n\t    connect(tmp->pin(1), obj->pin_Data(1));\n      else\n\t    connect(tmp->pin(1), obj->pin_Data(0));\n      delete obj;\n      des->add_node(tmp);\n      count += 1;\n}\n\nstatic bool compare_base(NetPartSelect*a, NetPartSelect*b)\n{\n      return a->base() < b->base();\n}\n\n/*\n * This optimization searches for Nexa that are driven only by\n * NetPartSelect(PV) outputs. These might turn from Verilog input that\n * looks like this:\n *    wire [7:0] foo\n *    assign foo[7:4] = a;\n *    assign foo[3:0] = b;\n * The idea is to convert the part selects of the above to a single\n * concatenation that looks like this:\n *    assign foo = {a, b};\n */\nvoid cprop_functor::lpm_part_select(Design*des, NetPartSelect*obj)\n{\n      if (obj->dir() != NetPartSelect::PV)\n\t    return;\n\n      NetScope*scope = obj->scope();\n      Nexus*nex = obj->pin(1).nexus();\n      vector<NetPartSelect*> obj_set;\n\n      bool output_2_state = false;\n\n      for (Link*cur = nex->first_nlink() ; cur ; cur = cur->next_nlink()) {\n\n\t    NetPins*tmp_obj = cur->get_obj();\n\n\t      // Record if we are driving a 2-state net.\n\t    NetNet*net_obj = dynamic_cast<NetNet*> (tmp_obj);\n\t    if (net_obj && (net_obj->data_type() == IVL_VT_BOOL))\n\t\t  output_2_state = true;\n\n\t      // If this is an input (or passive) then ignore it.\n\t    if (cur->get_dir() != Link::OUTPUT)\n\t\t  continue;\n\n\t      // Check to see if this is the output of a\n\t      // NetPartSelect::PV. If not, then give up on the blend.\n\t    unsigned tmp_pin = cur->get_pin();\n\n\t    NetPartSelect*cur_obj = dynamic_cast<NetPartSelect*> (tmp_obj);\n\t    if (cur_obj == 0)\n\t\t  return;\n\n\t    if (cur_obj->dir() != NetPartSelect::PV)\n\t\t  return;\n\n\t    if (tmp_pin != 1)\n\t\t  return;\n\n\t    obj_set.push_back(cur_obj);\n      }\n\n\t// When driving a 4-state signal, we only want to create a\n\t// concatenation if we have more than one part select. But\n\t// when driving a 2-state signal, create a concatenation\n\t// even if there's only one part select, which forces the\n\t// undriven bits to zero without needing an explicit cast.\n      if ((obj_set.size() == 0) || ((obj_set.size() == 1) && !output_2_state))\n\t    return;\n\n      if (debug_optimizer)\n\t    cerr << obj->get_fileline() << \": cprop::lpm_part_select: \"\n\t\t << \"Found \" << obj_set.size() << \" NetPartSelect(PV) objects.\"\n\t\t << endl;\n\n\t// Sort by increasing base offset.\n      sort(obj_set.begin(), obj_set.end(), compare_base);\n\n\t// Check and make sure there are no overlaps. If there are,\n\t// then give up on this optimization.\n      for (size_t idx = 1 ; idx < obj_set.size() ; idx += 1) {\n\t    unsigned top = obj_set[idx-1]->base() + obj_set[idx-1]->width();\n\t    if (top > obj_set[idx]->base()) {\n\t\t  if (debug_optimizer)\n\t\t\tcerr << obj->get_fileline() << \": cprop::lpm_part_select: \"\n\t\t\t     << \"Range [\" << obj_set[idx-1]->base()\n\t\t\t     << \" \" << top << \") overlaps PV starting at \"\n\t\t\t     << obj_set[idx]->base() << \". Give up.\" << endl;\n\t\t  return;\n\t    }\n      }\n\n\t// Check if the tail runs off the end of the target. If so it\n\t// should be possible to replace it with a bit select to\n\t// shorten the object for the target, but for now just give up.\n      unsigned sig_width = nex->vector_width();\n      if (obj_set.back()->base() + obj_set.back()->width() > sig_width) {\n\t    if (debug_optimizer)\n\t\t  cerr << obj->get_fileline() << \": cprop::lpm_part_select: \"\n\t\t       << \"Range [\" << obj_set.back()->base()\n\t\t       << \":\" << (obj_set.back()->base() + obj_set.back()->width() - 1)\n\t\t       << \"] runs off the end of target.\" << endl;\n\t    return;\n      }\n\n\t// Figure out how many components we are going to need.\n      unsigned part_count = 0;\n      unsigned off = 0;\n      for (size_t idx = 0 ; idx < obj_set.size() ; idx += 1) {\n\t    if (obj_set[idx]->base() > off) {\n\t\t  off = obj_set[idx]->base();\n\t\t  part_count += 1;\n\t    }\n\t    off += obj_set[idx]->width();\n\t    part_count += 1;\n      }\n\n      if (off < sig_width)\n\t    part_count += 1;\n\n      NetConcat*cncat = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t       sig_width, part_count);\n      cncat->set_line(*obj);\n      des->add_node(cncat);\n      connect(cncat->pin(0), obj->pin(1));\n\n      off = 0;\n      size_t concat_pin = 1;\n      for (size_t idx = 0 ; idx < obj_set.size() ; idx += 1) {\n\t    NetPartSelect*cobj = obj_set[idx];\n\t    if (cobj->base() > off) {\n\t\t  NetNet*val = output_2_state\n                             ? make_const_0(des, scope, cobj->base()-off)\n                             : make_const_z(des, scope, cobj->base()-off);\n\t\t  connect(cncat->pin(concat_pin), val->pin(0));\n\t\t  concat_pin += 1;\n\t\t  off = cobj->base();\n\t    }\n\t    connect(cncat->pin(concat_pin), cobj->pin(0));\n\t    concat_pin += 1;\n\t    off += cobj->width();\n      }\n      if (off < sig_width) {\n\t    NetNet*val = output_2_state\n                       ? make_const_0(des, scope, sig_width-off)\n                       : make_const_z(des, scope, sig_width-off);\n\t    connect(cncat->pin(concat_pin), val->pin(0));\n\t    concat_pin += 1;\n      }\n      ivl_assert(*obj, concat_pin == cncat->pin_count());\n\n      for (size_t idx = 0 ; idx < obj_set.size() ; idx += 1) {\n\t    delete obj_set[idx];\n      }\n\n      count += 1;\n}\n\n/*\n * This functor looks to see if the constant is connected to nothing\n * but signals. If that is the case, delete the dangling constant and\n * the now useless signals. This functor is applied after the regular\n * functor to clean up dangling constants that might be left behind.\n */\nstruct cprop_dc_functor  : public functor_t {\n\n      virtual void lpm_const(Design*des, NetConst*obj);\n};\n\nstruct nexus_info_s {\n      Nexus*nex;\n      unsigned inp;\n      unsigned out;\n};\n\nvoid cprop_dc_functor::lpm_const(Design*, NetConst*obj)\n{\n\t// 'bz constant values drive high impedance to whatever is\n\t// connected to it. In other words, it is a noop. But that is\n\t// only true if *all* the bits of the vectors.\n      { unsigned tmp = 0;\n\tivl_assert(*obj, obj->pin_count()==1);\n\tfor (unsigned idx = 0 ;  idx < obj->width() ;  idx += 1) {\n\t      if (obj->value(idx) == verinum::Vz) {\n\t\t    tmp += 1;\n\t      }\n\t}\n\n\tif (tmp == obj->width()) {\n\t      delete obj;\n\t      return;\n\t}\n      }\n\n      std::vector<nexus_info_s> nexus_info (obj->pin_count());\n      for (unsigned idx = 0 ; idx < obj->pin_count() ; idx += 1) {\n\t    nexus_info[idx].nex = obj->pin(idx).nexus();\n\t    unsigned inputs = 0, outputs = 0;\n\t    nexus_info[idx].nex -> count_io(inputs, outputs);\n\t    nexus_info[idx].inp = inputs;\n\t    nexus_info[idx].out = outputs;\n      }\n\n\t// If there are any links that take input, the constant is\n\t// used structurally somewhere.\n      for (unsigned idx = 0 ;  idx < obj->pin_count() ;  idx += 1)\n\t    if (nexus_info[idx].inp > 0)\n\t\t  return;\n\n\t// Look for signals that have NetESignal nodes attached to\n\t// them. If I find any, then this constant is used by a\n\t// behavioral expression somewhere.\n      for (unsigned idx = 0 ;  idx < obj->pin_count() ;  idx += 1) {\n\n\t    for (Link*clnk = nexus_info[idx].nex->first_nlink()\n\t\t       ; clnk ; clnk = clnk->next_nlink()) {\n\n\t\t  NetPins*cur;\n\t\t  unsigned pin;\n\t\t  clnk->cur_link(cur, pin);\n\n\t\t  const NetNet*tmp = dynamic_cast<NetNet*>(cur);\n\t\t  if (tmp == 0)\n\t\t\tcontinue;\n\n\t\t  assert(tmp->scope());\n\n\t\t    // If the net is a signal name from the source,\n\t\t    // then users will probably want to see it in the\n\t\t    // waveform dump, so unhooking the constant will\n\t\t    // make it look wrong.\n\t\t  if (! tmp->local_flag())\n\t\t\treturn;\n\n\t\t    // If the net has an eref, then there is an\n\t\t    // expression somewhere that reads this signal. So\n\t\t    // the constant does get read.\n\t\t  if (tmp->peek_eref() > 0)\n\t\t\treturn;\n\n\t\t    // If the net is a port of the root module, then\n\t\t    // the constant may be driving something outside\n\t\t    // the design, so do not eliminate it.\n\t\t  if ((tmp->port_type() != NetNet::NOT_A_PORT)\n\t\t      && (tmp->scope()->parent() == 0))\n\t\t\treturn;\n\n\t    }\n      }\n\n\t// Done. Found no reason to keep this object, so delete it.\n      delete obj;\n}\n\n\nvoid cprop(Design*des)\n{\n\t// Continually propagate constants until a scan finds nothing\n\t// to do.\n      cprop_functor prop;\n      do {\n\t    prop.count = 0;\n\t    des->functor(&prop);\n\t    if (verbose_flag) {\n\t\t  cout << \" ... Iteration detected \"\n\t\t       << prop.count << \" optimizations.\" << endl << flush;\n\t    }\n      } while (prop.count > 0);\n\n      if (verbose_flag) {\n\t    cout << \" ... Look for dangling constants\" << endl << flush;\n      }\n      cprop_dc_functor dc;\n      des->functor(&dc);\n\n      if (verbose_flag) {\n\t    cout << \" ... done\" << endl << flush;\n      }\n}\n"
        },
        {
          "name": "design_dump.cc",
          "type": "blob",
          "size": 45.5361328125,
          "content": "/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n/*\n * This file contains all the dump methods of the netlist classes.\n */\n# include  <typeinfo>\n# include  <iostream>\n# include  <iomanip>\n# include  \"netlist.h\"\n# include  \"compiler.h\"\n# include  \"discipline.h\"\n# include  \"netclass.h\"\n# include  \"netdarray.h\"\n# include  \"netqueue.h\"\n# include  \"netscalar.h\"\n# include  \"netvector.h\"\n# include  \"ivl_assert.h\"\n# include  \"PExpr.h\"\n\nusing namespace std;\n\nstatic ostream& operator<< (ostream&o, NetBlock::Type t)\n{\n      switch (t) {\n\t  case NetBlock::SEQU:\n\t    o << \"begin\";\n\t    break;\n\t  case NetBlock::PARA:\n\t    o << \"fork\";\n\t    break;\n\t  case NetBlock::PARA_JOIN_NONE:\n\t    o << \"fork-join_none\";\n\t    break;\n\t  case NetBlock::PARA_JOIN_ANY:\n\t    o << \"fork-join_any\";\n\t    break;\n      }\n      return o;\n}\n\nostream& operator << (ostream&o, ivl_drive_t str)\n{\n      switch (str) {\n\t  case IVL_DR_HiZ:\n\t    o << \"highz\";\n\t    break;\n\t  case IVL_DR_SMALL:\n\t    o << \"small\";\n\t    break;\n\t  case IVL_DR_MEDIUM:\n\t    o << \"medium\";\n\t    break;\n\t  case IVL_DR_WEAK:\n\t    o << \"weak\";\n\t    break;\n\t  case IVL_DR_LARGE:\n\t    o << \"large\";\n\t    break;\n\t  case IVL_DR_PULL:\n\t    o << \"pull\";\n\t    break;\n\t  case IVL_DR_STRONG:\n\t    o << \"strong\";\n\t    break;\n\t  case IVL_DR_SUPPLY:\n\t    o << \"supply\";\n\t    break;\n\t  default:\n\t    assert(0);\n      }\n      return o;\n}\n\nostream& operator << (ostream&o, ivl_variable_type_t val)\n{\n      switch (val) {\n\t  case IVL_VT_VOID:\n\t    o << \"void\";\n\t    break;\n\t  case IVL_VT_NO_TYPE:\n\t    o << \"<no_type>\";\n\t    break;\n\t  case IVL_VT_REAL:\n\t    o << \"real\";\n\t    break;\n\t  case IVL_VT_BOOL:\n\t    o << \"bool\";\n\t    break;\n\t  case IVL_VT_LOGIC:\n\t    o << \"logic\";\n\t    break;\n\t  case IVL_VT_STRING:\n\t    o << \"string\";\n\t    break;\n\t  case IVL_VT_DARRAY:\n\t    o << \"darray\";\n\t    break;\n\t  case IVL_VT_CLASS:\n\t    o << \"class\";\n\t    break;\n\t  case IVL_VT_QUEUE:\n\t    o << \"queue\";\n\t    break;\n      }\n      return o;\n}\n\nostream& operator << (ostream&o, ivl_switch_type_t val)\n{\n      switch (val) {\n\t  case IVL_SW_TRAN:\n\t    o << \"tran\";\n\t    break;\n\t  case IVL_SW_TRANIF0:\n\t    o << \"tranif0\";\n\t    break;\n\t  case IVL_SW_TRANIF1:\n\t    o << \"tranif1\";\n\t    break;\n\t  case IVL_SW_RTRAN:\n\t    o << \"rtran\";\n\t    break;\n\t  case IVL_SW_RTRANIF0:\n\t    o << \"rtranif0\";\n\t    break;\n\t  case IVL_SW_RTRANIF1:\n\t    o << \"rtranif1\";\n\t    break;\n\t  case IVL_SW_TRAN_VP:\n\t    o << \"tran(VP)\";\n\t    break;\n      }\n      return o;\n}\n\nostream& operator << (ostream&fd, PortType::Enum val)\n{\n      switch (val) {\n\t  case PortType::NOT_A_PORT:\n\t    fd << \"NOT_A_PORT\";\n\t    break;\n\t  case PortType::PIMPLICIT:\n\t    fd << \"PIMPLICIT\";\n\t    break;\n\t  case PortType::PINPUT:\n\t    fd << \"PINPUT\";\n\t    break;\n\t  case PortType::POUTPUT:\n\t    fd << \"POUTPUT\";\n\t    break;\n\t  case PortType::PINOUT:\n\t    fd << \"PINOUT\";\n\t    break;\n\t  case PortType::PREF:\n\t    fd << \"PREF\";\n\t    break;\n\t  default:\n\t    fd << \"PortType::Enum::?\";\n\t    break;\n      }\n\n      return fd;\n}\n\nostream& operator << (ostream&fd, NetCaseCmp::kind_t that)\n{\n      switch (that) {\n\t  case NetCaseCmp::EEQ:\n\t    fd << \"===\";\n\t    break;\n\t  case NetCaseCmp::NEQ:\n\t    fd << \"!==\";\n\t    break;\n\t  case NetCaseCmp::WEQ:\n\t    fd << \"==?\";\n\t    break;\n\t  case NetCaseCmp::WNE:\n\t    fd << \"!=?\";\n\t    break;\n\t  case NetCaseCmp::XEQ:\n\t    fd << \"==x?\";\n\t    break;\n\t  case NetCaseCmp::ZEQ:\n\t    fd << \"==z?\";\n\t    break;\n      }\n      return fd;\n}\n\nstatic std::ostream& operator << (std::ostream &out, const std::vector<NetExpr*> &exprs)\n{\n      for (size_t idx = 0; idx < exprs.size(); idx++) {\n\t    if (idx != 0)\n\t\t  out << \", \";\n\t    if (exprs[idx])\n\t\t  out << *exprs[idx];\n      }\n\n      return out;\n}\n\nostream& ivl_type_s::debug_dump(ostream&o) const\n{\n      o << typeid(*this).name();\n      return o;\n}\n\nostream& netclass_t::debug_dump(ostream&fd) const\n{\n      fd << \"class \" << name_ << \"{\";\n      for (size_t idx = 0 ; idx < property_table_.size() ; idx += 1) {\n\t    if (idx != 0) fd << \"; \";\n\t    if (property_table_[idx].type)\n\t\t  property_table_[idx].type->debug_dump(fd);\n\t    else\n\t\t  fd << \"NO_TYPE\";\n\t    fd << \" \" << property_table_[idx].name;\n      }\n      fd << \"}\";\n      return fd;\n}\n\nostream& netdarray_t::debug_dump(ostream&o) const\n{\n      o << \"dynamic array of \" << *element_type();\n      return o;\n}\n\nostream& netqueue_t::debug_dump(ostream&fd) const\n{\n      fd << \"queue of \";\n      if (max_idx_ >= 0) fd << \"(maximum of \" << max_idx_+1 << \" elements) \";\n      fd << *element_type();\n      return fd;\n}\n\nostream& netreal_t::debug_dump(ostream&fd) const\n{\n      fd << \"real\";\n      return fd;\n}\nostream& netstring_t::debug_dump(ostream&fd) const\n{\n      fd << \"string\";\n      return fd;\n}\n\nostream& netvector_t::debug_dump(ostream&o) const\n{\n      o << \"netvector_t:\" << type_ << (signed_? \" signed\" : \" unsigned\") << packed_dims_;\n      return o;\n}\n\nstatic inline void dump_scope_path(ostream&o, const NetScope*scope)\n{\n      const NetScope*parent = scope->parent();\n      if (parent) {\n\t    dump_scope_path(o, parent);\n\t    o << \".\";\n      }\n      o << scope->fullname();\n}\n\nostream& operator <<(ostream&o, struct __ScopePathManip marg)\n{\n      if (marg.scope != 0)\n\t    dump_scope_path(o, marg.scope);\n      return o;\n}\n\nostream& operator <<(ostream&o, struct __ObjectPathManip marg)\n{\n      if (marg.obj != 0) {\n\t    dump_scope_path(o, marg.obj->scope());\n\t    o << \".\" << marg.obj->name();\n      }\n      return o;\n}\n\nostream& operator <<(ostream&fd, Link::DIR dir)\n{\n      switch (dir) {\n\t  case Link::PASSIVE:\n\t    fd << \"PASSIVE\";\n\t    break;\n\t  case Link::INPUT:\n\t    fd << \"INPUT\";\n\t    break;\n\t  case Link::OUTPUT:\n\t    fd << \"OUTPUT\";\n\t    break;\n\t  default:\n\t    fd << \"<\" << (int)dir << \">\";\n\t    break;\n      }\n      return fd;\n}\n\nvoid NetPins::show_type(ostream&fd) const\n{\n      fd << typeid(*this).name();\n}\n\nvoid NetObj::show_type(ostream&fd) const\n{\n      fd << typeid(*this).name() << \"[\" << scope_path(scope_) << \".\" << name_ << \"]\";\n}\n\nstruct __ShowTypeManip { const NetPins*pins; };\ninline __ShowTypeManip show_type(const NetPins*pins)\n{ __ShowTypeManip tmp; tmp.pins = pins; return tmp; }\n\ninline ostream& operator << (ostream&fd, __ShowTypeManip man)\n{\n      if (man.pins == 0)\n\t    fd << \"NexusSet\";\n      else\n\t    man.pins->show_type(fd);\n      return fd;\n}\n\n\nvoid Link::dump_link(ostream&fd, unsigned ind) const\n{\n      const Link*cur;\n      const Nexus*nex = nexus();\n\n      if (nex == 0) {\n\t    fd << setw(ind) << \"\" << \"<unlinked>\" << endl;\n\t    return;\n      }\n\n      for (cur = nex->first_nlink() ; cur; cur = cur->next_nlink()) {\n\t    const NetPins*obj = cur->get_obj();\n\t    unsigned pin = cur->get_pin();\n\t    fd << setw(ind) << \"\" << \"Pin \" << pin\n\t       << \" of \" << show_type(obj)\n\t       << \", dir=\" << cur->dir_ << endl;\n      }\n}\n\nvoid NetBranch::dump(ostream&o, unsigned ind) const\n{\n      static const char*pin_names[2] = {\n\t    \"terminal0\",\n\t    \"terminal1\" };\n\n      o << setw(ind) << \"\" << \"branch island=\" << get_island();\n      o << \" // \" << get_fileline() << endl;\n      dump_node_pins(o, ind+4, pin_names);\n}\n\nvoid NetDelaySrc::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"specify delay\";\n      if (posedge_) o << \" posedge\";\n      if (negedge_) o << \" negedge\";\n      if (is_condit()) {\n\t    if (has_condit()) o << \" if\";\n\t    else o << \" ifnone\";\n      }\n      if (parallel_)\n\t    o << \" parallel\";\n      else\n\t    o << \" full\";\n      o << \" src \"\n\t<< \"(\" << transition_delays_[IVL_PE_01]\n\t<< \",\" << transition_delays_[IVL_PE_10]\n\t<< \",\" << transition_delays_[IVL_PE_0z]\n\t<< \"/\" << transition_delays_[IVL_PE_z1]\n\t<< \",\" << transition_delays_[IVL_PE_1z]\n\t<< \",\" << transition_delays_[IVL_PE_z0]\n\t<< \"/\" << transition_delays_[IVL_PE_0x]\n\t<< \",\" << transition_delays_[IVL_PE_x1]\n\t<< \",\" << transition_delays_[IVL_PE_1x]\n\t<< \"/\" << transition_delays_[IVL_PE_x0]\n\t<< \",\" << transition_delays_[IVL_PE_xz]\n\t<< \",\" << transition_delays_[IVL_PE_zx]\n\t<< \") scope=\" << scope_path(scope()) << endl;\n      dump_node_pins(o, ind+4);\n}\n\nstatic inline ostream&operator<<(ostream&out, const netrange_t&that)\n{\n      if (that.defined())\n\t    out << \"[\" << that.get_msb() << \":\" << that.get_lsb() << \"]\";\n      else\n\t    out << \"[]\";\n\n      return out;\n}\n\nostream&operator<<(ostream&out, const netranges_t&rlist)\n{\n      for (netranges_t::const_iterator cur = rlist.begin()\n\t\t ; cur != rlist.end() ; ++cur) {\n\t    out << *cur;\n      }\n      return out;\n}\n\n/* Dump a net. This can be a wire or register. */\nvoid NetNet::dump_net(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << type() << \": \" << name()\n\t<< unpacked_dims_ << \" unpacked dims=\" << unpacked_dimensions();\n      o << \" pin_count=\" << pin_count();\n      if (local_flag_)\n\t    o << \" (local)\";\n      switch (port_type_) {\n\t  case NetNet::NOT_A_PORT:\n\t    break;\n\t  case NetNet::PIMPLICIT:\n\t    o << \" implicit-port?\";\n\t    break;\n\t  case NetNet::PINPUT:\n\t    o << \" input\";\n\t    break;\n\t  case NetNet::POUTPUT:\n\t    o << \" output\";\n\t    break;\n\t  case NetNet::PINOUT:\n\t    o << \" inout\";\n\t    break;\n\t  case NetNet::PREF:\n\t    o <<\" ref\";\n\t    break;\n      }\n\n      if (ivl_discipline_t dis = get_discipline())\n\t    o << \" discipline=\" << dis->name();\n\n      if (net_type_)  o << \" \" << *net_type_;\n\n      o << \" (eref=\" << peek_eref() << \", lref=\" << peek_lref() << \")\";\n      if (scope())\n\t    o << \" scope=\" << scope_path(scope());\n      o << \" #(\" << rise_time() << \",\" << fall_time() << \",\"\n\t<<  decay_time() << \") vector_width=\" << vector_width()\n\t<< \" pin_count=\" << pin_count();\n      if (pins_are_virtual()) {\n\t    o << \" pins_are_virtual\" << endl;\n\t    return;\n      }\n      o << endl;\n\n      for (unsigned idx = 0 ;  idx < pin_count() ;  idx += 1) {\n\t    if (! pin(idx).is_linked())\n\t\t  continue;\n\n\t    const Nexus*nex = pin(idx).nexus();\n\t    o << setw(ind+4) << \"\" << \"[\" << idx << \"]: \" << nex\n\t      << \" \" << nex->name() << endl;\n      }\n\n      for (unsigned idx = 0 ;  idx < delay_paths_.size() ;  idx += 1) {\n\t    const NetDelaySrc*cur = delay_paths_[idx];\n\t    cur->dump(o, ind+4);\n      }\n\n      dump_obj_attr(o, ind+4);\n}\n\n/* Dump a NetNode and its pins. Dump what I know about the netnode on\n   the first line, then list all the pins, with the name of the\n   connected signal. */\nvoid NetNode::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"node: \";\n      o << typeid(*this).name() << \" #(\" << rise_time()\n\t<< \",\" << fall_time() << \",\" << decay_time() << \") \" << name()\n\t<< endl;\n\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\n/* This is the generic dumping of all the signals connected to each\n   pin of the object. The \"this\" object is not printed, only the\n   signals connected to this. */\nvoid NetPins::dump_node_pins(ostream&o, unsigned ind, const char**pin_names) const\n{\n      for (unsigned idx = 0 ;  idx < pin_count() ;  idx += 1) {\n\t    o << setw(ind) << \"\" << idx;\n\t    if (pin_names && pin_names[idx])\n\t\t  o << \" \" << pin_names[idx];\n\t    else\n\t\t  o << \" pin\" << idx;\n\n\t    switch (pin(idx).get_dir()) {\n\t\tcase Link::PASSIVE:\n\t\t  o << \" p\";\n\t\t  break;\n\t\tcase Link::INPUT:\n\t\t  o << \" I\";\n\t\t  break;\n\t\tcase Link::OUTPUT:\n\t\t  o << \" O\";\n\t\t  break;\n\t    }\n\n\t    o << \" (\" << pin(idx).drive0() << \"0 \"\n\t      << pin(idx).drive1() << \"1): \";\n\n\t    if (pin(idx).is_linked()) {\n\t\t  const Nexus*nex = pin(idx).nexus();\n\t\t  o << nex << \" \" << nex->name();\n\t    }\n\t    o << endl;\n\n      }\n}\n\nvoid NetObj::dump_obj_attr(ostream&o, unsigned ind) const\n{\n      unsigned idx;\n      for (idx = 0 ;  idx < attr_cnt() ;  idx += 1) {\n\t    o << setw(ind) << \"\" << attr_key(idx) << \" = \\\"\" <<\n\t\t  attr_value(idx) << \"\\\"\" << endl;\n      }\n}\n\nvoid NetAbs::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"Absolute value (NetAbs): \" << name()\n\t<< \" width=\" << width() << \" pin_count=\" << pin_count()\n\t<< endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetAddSub::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"Adder (NetAddSub): \" << name()\n\t<< \" width=\" << width() << \" pin_count=\" << pin_count()\n\t<< endl;\n      static const char* pin_names[] = {\n\t    \"Cout  \",\n\t    \"DataA \",\n\t    \"DataB \",\n\t    \"Result\"\n      };\n\n      dump_node_pins(o, ind+4, pin_names);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetArrayDq::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"NetArrayDq: \" << name()\n\t<< \" array=\" << mem_->name()\n\t<< endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetCastInt2::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"Cast to int2. (NetCastInt2): \" <<\n\t    name() << \" width=\" << width() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetCastInt4::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"Cast to int4. (NetCastInt4): \" <<\n\t    name() << \" width=\" << width() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetCastReal::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"Cast to real (NetCastReal): \" <<\n\t    name() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetCLShift::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"Combinatorial shift (NetCLShift): \" <<\n\t    name() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetCompare::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"LPM_COMPARE (NetCompare \"\n\t<< (get_signed()? \"signed\" : \"unsigned\") << \"): \"\n\t<< name() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetConcat::dump_node(ostream&o, unsigned ind) const\n{\n      if (transparent_)\n\t    o << setw(ind) << \"\" << \"NetConcat8: \";\n      else\n\t    o << setw(ind) << \"\" << \"NetConcat: \";\n      o << name();\n\n      if (rise_time())\n\t    o << \" #(\" << *rise_time()\n\t      << \",\" << *fall_time() << \",\" << *decay_time() << \")\";\n      else\n\t    o << \" #(0,0,0)\";\n      o << \" scope=\" << scope_path(scope())\n\t<< \" width=\" << width_ << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetDivide::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"NET_DIVIDE (NetDivide): \" << name() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetMult::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"LPM_MULT (NetMult): \" << name() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetPow::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"LPM_POW (NetPow): \" << name()\n\t<< \" scope=\" << scope_path(scope())\n\t<< \" delay=(\";\n      if (rise_time())\n\t    o << *rise_time() << \",\" << *fall_time() << \",\"\n\t      <<  *decay_time();\n      else\n\t    o << \"0,0,0\";\n\n      o << \")\"  << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetMux::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"Multiplexer (NetMux): \" << name()\n\t<< \" width=\" << width_ << \" swidth=\" << swidth_ << \" size=\" << size_\n\t<< \" scope=\" << scope_path(scope()) << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetBUFZ::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"NetBUFZ: \" << name()\n\t<< \" scope=\" << scope_path(scope())\n\t<< \" delay=(\" << rise_time() << \",\" << fall_time() << \",\" <<\n\t    decay_time() << \") width=\" << width()\n\t<< (transparent()? \" \" : \" non-\") << \"transparent\" << endl;\n      dump_node_pins(o, ind+4);\n}\n\nvoid NetCaseCmp::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"case compare \" << kind_ << \": \" << name() << endl;\n\n      dump_node_pins(o, ind+4);\n}\n\nvoid NetConst::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"constant \" << value_;\n      o << \": \" << name();\n      if (rise_time())\n\t    o << \" #(\" << *rise_time()\n\t      << \",\" << *fall_time()\n\t      << \",\" << *decay_time() << \")\";\n      else\n\t    o << \" #(.,.,.)\";\n      o << endl;\n      dump_node_pins(o, ind+4);\n}\n\nvoid NetFF::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"LPM_FF: \" << name()\n\t<< \" scope=\" << scope_path(scope());\n      if (negedge_)\n\t    o << \" negedge\";\n      else\n\t    o << \" posedge\";\n      o << \" aset_value=\" << aset_value_ << endl;\n\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetLatch::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"LPM_LATCH: \" << name()\n\t<< \" scope=\" << scope_path(scope()) << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetLiteral::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"constant real \" << real_\n\t<< \": \" << name();\n      if (rise_time())\n\t    o << \" #(\" << *rise_time()\n\t      << \",\" << *fall_time()\n\t      << \",\" << *decay_time() << \")\";\n      else\n\t    o << \" #(.,.,.)\";\n      o << endl;\n      dump_node_pins(o, ind+4);\n}\n\nvoid NetLogic::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"logic: \";\n      switch (type_) {\n\t  case AND:\n\t    o << \"and\";\n\t    break;\n\t  case BUF:\n\t    o << \"buf\";\n\t    break;\n\t  case BUFIF0:\n\t    o << \"bufif0\";\n\t    break;\n\t  case BUFIF1:\n\t    o << \"bufif1\";\n\t    break;\n\t  case CMOS:\n\t    o << \"cmos\";\n\t    break;\n\t  case EQUIV:\n\t    o << \"<->\";\n\t    break;\n\t  case IMPL:\n\t    o << \"->\";\n\t    break;\n\t  case NAND:\n\t    o << \"nand\";\n\t    break;\n\t  case NMOS:\n\t    o << \"nmos\";\n\t    break;\n\t  case NOR:\n\t    o << \"nor\";\n\t    break;\n\t  case NOT:\n\t    o << \"not\";\n\t    break;\n\t  case NOTIF0:\n\t    o << \"notif0\";\n\t    break;\n\t  case NOTIF1:\n\t    o << \"notif1\";\n\t    break;\n\t  case OR:\n\t    o << \"or\";\n\t    break;\n\t  case PULLDOWN:\n\t    o << \"pulldown\";\n\t    break;\n\t  case PULLUP:\n\t    o << \"pullup\";\n\t    break;\n\t  case RCMOS:\n\t    o << \"rcmos\";\n\t    break;\n\t  case RNMOS:\n\t    o << \"rnmos\";\n\t    break;\n\t  case RPMOS:\n\t    o << \"rpmos\";\n\t    break;\n\t  case PMOS:\n\t    o << \"pmos\";\n\t    break;\n\t  case XNOR:\n\t    o << \"xnor\";\n\t    break;\n\t  case XOR:\n\t    o << \"xor\";\n\t    break;\n      }\n      o << \" #(\" << rise_time()\n\t<< \",\" << fall_time() << \",\" << decay_time() << \") \" << name()\n\t<< \" scope=\" << scope_path(scope())\n\t<< endl;\n\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetModulo::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"NET_MODULO (NetModulo): \" << name() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetPartSelect::dump_node(ostream&o, unsigned ind) const\n{\n      const char*pt = \"\";\n      switch (dir_) {\n\t  case VP:\n\t    pt = \"VP\";\n\t    break;\n\t  case PV:\n\t    pt = \"PV\";\n\t    break;\n      }\n      o << setw(ind) << \"\" << \"NetPartSelect(\" << pt << \"): \"\n\t<< name();\n      if (rise_time())\n\t    o << \" #(\" << *rise_time()\n\t      << \",\" << *fall_time()\n\t      << \",\" << *decay_time() << \")\";\n      else\n\t    o << \" #(.,.,.)\";\n      o << \" off=\" << off_ << \" wid=\" << wid_ <<endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetSubstitute::dump_node(ostream&fd, unsigned ind) const\n{\n      fd << setw(ind) << \"\" << \"NetSubstitute: \"\n\t << name();\n      if (rise_time())\n\t    fd << \" #(\" << *rise_time()\n\t       << \",\" << *fall_time()\n\t       << \",\" << *decay_time() << \")\";\n      else\n\t    fd << \" #(.,.,.)\";\n      fd << \" width=\" << wid_ << \" base=\" << off_ <<endl;\n      dump_node_pins(fd, ind+4);\n      dump_obj_attr(fd, ind+4);\n}\n\nvoid NetReplicate::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"NetReplicate: \"\n\t<< name() << \" wid=\" << width_ << \", repeat_=\" << repeat_\n\t<< \", input wid=\" << width_/repeat_ << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetSignExtend::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"NetSignExtend: \" << name();\n      if (rise_time())\n\t    o << \" #(\" << *rise_time()\n\t      << \",\" << *fall_time()\n\t      << \",\" << *decay_time() << \")\";\n      else\n\t    o << \" #(.,.,.)\";\n      o << \" output width=\" << width_ << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetUReduce::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"reduction logic: \";\n      switch (type_) {\n\t  case NONE:\n\t    o << \"NONE\";\n\t    break;\n\t  case AND:\n\t    o << \"and\";\n\t    break;\n\t  case OR:\n\t    o << \"or\";\n\t    break;\n\t  case XOR:\n\t    o << \"xor\";\n\t    break;\n\t  case NAND:\n\t    o << \"nand\";\n\t    break;\n\t  case NOR:\n\t    o << \"nor\";\n\t    break;\n\t  case XNOR:\n\t    o << \"xnor\";\n\t    break;\n      }\n      o << \" #(\" << rise_time()\n\t<< \",\" << fall_time() << \",\" << decay_time() << \") \" << name()\n\t<< \" scope=\" << scope_path(scope())\n\t<< endl;\n\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetSysFunc::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << def_->name << \"(...) -->\"\n\t<< data_type() << \" width=\" << vector_width() << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetUserFunc::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"USER FUNC: \"\n\t<< scope_path(def_);\n      if (rise_time())\n\t    o << \" #(\" <<*rise_time()\n\t      <<\",\"<<*fall_time()\n\t      << \",\" <<*decay_time() << \")\";\n      o << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetTaskDef::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"task \" << scope_path(scope()) << \";\" << endl;\n\n      for (unsigned idx = 0 ;  idx < port_count() ;  idx += 1) {\n\t    const NetNet*pnet = port(idx);\n\t    o << setw(ind+4) << \"\";\n\t    assert(pnet);\n\t    switch (pnet->port_type()) {\n\t\tcase NetNet::PINPUT:\n\t\t  o << \"input \";\n\t\t  break;\n\t\tcase NetNet::POUTPUT:\n\t\t  o << \"output \";\n\t\t  break;\n\t\tcase NetNet::PINOUT:\n\t\t  o << \"input \";\n\t\t  break;\n\t\tdefault:\n\t\t  o << \"NOT_A_PORT \";\n\t\t  break;\n\t    }\n\t    o << pnet->name() << \";\" << endl;\n      }\n\n      if (proc_)\n\t    proc_->dump(o, ind+4);\n      else\n\t    o << setw(ind+4) << \"\" << \"MISSING PROCEDURAL CODE\" << endl;\n\n      o << setw(ind) << \"\" << \"endtask\" << endl;\n}\n\nvoid NetTran::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << type_ << \" \" << name()\n\t<< \" island \" << get_island();\n      if (type_ == IVL_SW_TRAN_VP) {\n\t    o << \" width=\" << vector_width()\n\t      << \" part=\" << part_width()\n\t      << \" offset=\" << part_offset();\n      }\n      o << \" delay=(\";\n      if (rise_time())\n\t    o << *rise_time() << \",\" << *fall_time() << \",\"\n\t      << *decay_time();\n      else\n\t    o << \"0,0,0\";\n\n      o << \")\" << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetUDP::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"UDP (\" << udp_name() << \"): \";\n      o << \" #(\" << rise_time() << \",\" << fall_time() << \",\" << decay_time() <<\n\t    \") \" << name() << endl;\n\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetProcTop::dump(ostream&o, unsigned ind) const\n{\n      switch (type_) {\n\t  case IVL_PR_INITIAL:\n\t    o << \"initial  /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n\t  case IVL_PR_ALWAYS:\n\t    o << \"always  /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n\t  case IVL_PR_ALWAYS_COMB:\n\t    o << \"always_comb  /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n\t  case IVL_PR_ALWAYS_FF:\n\t    o << \"always_ff  /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n\t  case IVL_PR_ALWAYS_LATCH:\n\t    o << \"always_latch  /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n\t  case IVL_PR_FINAL:\n\t    o << \"final  /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n      }\n\n      for (unsigned idx = 0 ;  idx < attr_cnt() ;  idx += 1) {\n\t    o << setw(ind+2) << \"\" << \"(* \" << attr_key(idx) << \" = \"\n\t      << attr_value(idx) << \" *)\" << endl;\n      }\n\n      statement_->dump(o, ind+2);\n}\n\nvoid NetAnalogTop::dump(ostream&o, unsigned ind) const\n{\n      switch (type_) {\n\t  case IVL_PR_INITIAL:\n\t    o << \"analog initial /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n\n\t  case IVL_PR_ALWAYS:\n\t    o << \"analog /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n\n\t    // These are not used in an analog context.\n\t  case IVL_PR_ALWAYS_COMB:\n\t  case IVL_PR_ALWAYS_FF:\n\t  case IVL_PR_ALWAYS_LATCH:\n\t    assert(0);\n\t    break;\n\n\t  case IVL_PR_FINAL:\n\t    o << \"analog final /* \" << get_fileline() << \" in \"\n\t      << scope_path(scope_) << \" */\" << endl;\n\t    break;\n      }\n\n      statement_->dump(o, ind+2);\n}\n\nvoid NetAlloc::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"// allocate storage : \" << scope_path(scope_) << endl;\n}\n\nvoid NetAssign_::dump_lval(ostream&o) const\n{\n      if (sig_) o << sig_->name();\n      else if (nest_) {\n\t    o << \"(\";\n\t    nest_->dump_lval(o);\n\t    o << \")\";\n      }\n      else o << \"<?>\";\n\n      if (! member_.nil()) {\n\t    o << \".\" << member_;\n      }\n      if (word_) {\n\t    o << \"[word=\" << *word_ << \"]\";\n      }\n      if (base_) {\n\t    o << \"[\" << *base_ << \" +: \" << lwid_ << \"]\";\n      }\n}\n\nvoid NetAssignBase::dump_lval(ostream&o) const\n{\n      o << \"{\";\n      lval_->dump_lval(o);\n\n      for (NetAssign_*cur = lval_->more ;  cur ;  cur = cur->more) {\n\t    o << \", \";\n\t    cur->dump_lval(o);\n      }\n\n      o << \"}\";\n}\n\n/* Dump an assignment statement */\nvoid NetAssign::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\";\n      dump_lval(o);\n\n      if (op_)\n\t    o << \" \" << op_ << \"= \";\n      else\n\t    o << \" = \";\n\n      if (const NetExpr*de = get_delay())\n\t    o << \"#(\" << *de << \") \";\n\n      if (rval())\n\t    o << *rval() << \";\" << endl;\n      else\n\t    o << \"<rval elaboration error>;\" << endl;\n}\n\nvoid NetAssignNB::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\";\n      dump_lval(o);\n\n      o << \" <= \";\n\n      if (const NetExpr*de = get_delay())\n\t    o << \"#(\" << *de << \") \";\n      if (count_)\n\t    o << \"repeat(\" << *count_ << \") \";\n      if (event_) {\n\t    o << *event_;\n      }\n\n      if (rval())\n\t    o << *rval() << \";\" << endl;\n      else\n\t    o << \"rval elaboration error>;\" << endl;\n\n}\n\nvoid NetAssignBase::dump(ostream&o, unsigned ind) const\n{\n      if (const NetAssignNB *n1 = dynamic_cast<const NetAssignNB*>(this)) {\n\t    n1->dump(o,ind);\n      } else if (const NetAssign *n2 = dynamic_cast<const NetAssign*>(this)) {\n\t    n2->dump(o,ind);\n      }\n}\n\n/* Dump a block statement */\nvoid NetBlock::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << type_;\n      if (subscope_)\n\t    o << \" : \" << scope_path(subscope_);\n      o << endl;\n\n      if (last_) {\n\t    const NetProc*cur = last_;\n\t    do {\n\t\t  cur = cur->next_;\n\t\t  cur->dump(o, ind+4);\n\t    } while (cur != last_);\n      }\n\n      o << setw(ind) << \"\" << \"end\" << endl;\n}\n\nvoid NetBreak::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"break;\" << endl;\n}\n\nvoid NetCase::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\";\n      switch (quality_) {\n\t  case IVL_CASE_QUALITY_BASIC:\n\t    break;\n\t  case IVL_CASE_QUALITY_UNIQUE:\n\t    o << \"unique \";\n\t    break;\n\t  case IVL_CASE_QUALITY_UNIQUE0:\n\t    o << \"unique0 \";\n\t    break;\n\t  case IVL_CASE_QUALITY_PRIORITY:\n\t    o << \"priority \";\n\t    break;\n      }\n      switch (type_) {\n\t  case EQ:\n\t    o << \"case (\" << *expr_ << \")\" << endl;\n\t    break;\n\t  case EQX:\n\t    o << \"casex (\" << *expr_ << \")\" << endl;\n\t    break;\n\t  case EQZ:\n\t    o << \"casez (\" << *expr_ << \")\" << endl;\n\t    break;\n      }\n\n      for (unsigned idx = 0 ;  idx < items_.size() ;  idx += 1) {\n\t    o << setw(ind+2) << \"\";\n\t    if (items_[idx].guard)\n\t\t  o << *items_[idx].guard << \":\";\n\t    else\n\t\t  o << \"default:\";\n\n\t    if (items_[idx].statement) {\n\t\t  o << endl;\n\t\t  items_[idx].statement->dump(o, ind+6);\n\t    } else {\n\t\t  o << \" ;\" << endl;\n\t    }\n      }\n\n      o << setw(ind) << \"\" << \"endcase\" << endl;\n}\n\nvoid NetCAssign::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"cassign \";\n      dump_lval(o);\n      o << \" = \" << *rval() << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid NetCondit::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"if (\";\n      expr_->dump(o);\n      o << \")\" << endl;\n\n      if (if_) if_->dump(o, ind+4);\n      else o << setw(ind+4) << \"\" << \"/* empty */ ;\" << endl;\n\n      if (else_) {\n\t    o << setw(ind) << \"\" << \"else\" << endl;\n\t    else_->dump(o, ind+4);\n      }\n}\n\nvoid NetContinue::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"continue;\" << endl;\n}\n\nvoid NetContribution::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\";\n      lval_->dump(o);\n      o << \" <+ \";\n      rval_->dump(o);\n      o << \";\" << endl;\n}\n\nvoid NetDeassign::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"deassign \";\n      dump_lval(o);\n      o << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid NetDisable::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"disable \";\n      if (target_) o << scope_path(target_);\n      else o << \"fork\";\n      o << \"; \" << \"/* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid NetDoWhile::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"do\" << endl;\n      proc_->dump(o, ind+3);\n      o << setw(ind) << \"\" << \"while (\" << *cond_ << \");\" << endl;\n}\n\nvoid NetEvProbe::dump_node(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\";\n\n      switch (edge_) {\n\t  case ANYEDGE:\n\t    o << \"anyedge \";\n\t    break;\n\t  case POSEDGE:\n\t    o << \"posedge \";\n\t    break;\n\t  case NEGEDGE:\n\t    o << \"negedge \";\n\t    break;\n\t  case EDGE:\n\t    o << \"edge \";\n\t    break;\n      }\n      o << setw(ind) << \"\" << \"-> \" << event_->name() << \"; \" << endl;\n      dump_node_pins(o, ind+4);\n      dump_obj_attr(o, ind+4);\n}\n\nvoid NetEvTrig::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"-> \" << event_->name() << \"; \"\n\t<< \"// \" << get_fileline() << endl;\n}\n\nvoid NetEvNBTrig::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"->> \" ;\n      if (dly_) o << \"#\" << *dly_ << \" \";\n      o << event_->name() << \"; \" << \"// \" << get_fileline() << endl;\n}\n\nvoid NetEvWait::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\";\n\n\t/* Check for a wait fork. */\n      if ((nevents() == 1) && (event(0) == 0)) {\n\t    o << \"wait fork;\";\n\t    return;\n      }\n\n      o << \"@(\";\n\n      if (nevents() > 0)\n\t    o << event(0)->name();\n\n      for (unsigned idx = 1 ;  idx < nevents() ;  idx += 1)\n\t    o << \" or \" << event(idx)->name();\n\n      o << \")  // \" << get_fileline() << endl;\n\n      if (statement_)\n\t    statement_->dump(o, ind+2);\n      else\n\t    o << setw(ind+2) << \"\" << \"/* noop */ ;\" << endl;\n}\n\nostream& operator << (ostream&out, const NetEvWait&obj)\n{\n      obj.dump_inline(out);\n      return out;\n}\n\nvoid NetEvWait::dump_inline(ostream&o) const\n{\n\t/* Check for a wait fork. */\n      if ((nevents() == 1) && (event(0) == 0)) {\n\t    o << \"wait fork;\";\n\t    return;\n      }\n\n      o << \"@(\";\n\n      if (nevents() > 0)\n\t    o << event(0)->name();\n\n      for (unsigned idx = 1 ;  idx < nevents() ;  idx += 1)\n\t    o << \" or \" << event(idx)->name();\n\n      o << \") \";\n}\n\nvoid NetForce::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"force \";\n      dump_lval(o);\n      o << \" = \" << *rval() << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid NetForever::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"forever\" << endl;\n      statement_->dump(o, ind+2);\n}\n\nvoid NetForLoop::dump(ostream&fd, unsigned ind) const\n{\n      fd << setw(ind) << \"\" << \"FOR LOOP index=\";\n      if (index_)\n\t    fd << index_->name();\n      else\n\t    fd << \"<nil>\";\n      fd << \", init_expr=\";\n      if (init_expr_)\n\t    fd << *init_expr_;\n      else\n\t    fd << \"<nil>\";\n      fd << \", condition=\";\n      if (condition_)\n\t    fd << *condition_;\n      else\n\t    fd << \"<nil>\";\n      fd << endl;\n      fd << setw(ind+4) << \"\" << \"Init Statement {\" << endl;\n      if (init_statement_)\n\t    init_statement_->dump(fd, ind+8);\n      fd << setw(ind+4) << \"\" << \"}\" << endl;\n      statement_->dump(fd, ind+4);\n      fd << setw(ind+4) << \"\" << \"Step Statement {\" << endl;\n      if (step_statement_)\n\t    step_statement_->dump(fd, ind+8);\n      fd << setw(ind+4) << \"\" << \"}\" << endl;\n}\n\nvoid NetFree::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"// free storage : \" << scope_path(scope_) << endl;\n}\n\nvoid NetFuncDef::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"function definition for \" << scope_path(scope()) << endl;\n      if (result_sig_) {\n\t    o << setw(ind+2) << \"\" << \"Return signal: \";\n\t    if (result_sig_->get_signed()) o << \"+\";\n\t    o << result_sig_->name() << endl;\n      }\n      o << setw(ind+2) << \"\" << \"Arguments: \";\n      if (port_count() == 0) o << \"<none>\";\n      o << endl;\n      for (unsigned idx = 0; idx < port_count(); idx += 1) {\n\t    o << setw(ind+4) << \"\" << \"Arg[\" << idx+1 << \"] = \";\n\t    switch (port(idx)->port_type()) {\n\t\tdefault:\n\t\t  o << \"implicit-port? \";\n\t\t  break;\n\t\tcase NetNet::PINPUT:\n\t\t  o << \"input \";\n\t\t  break;\n\t\tcase NetNet::POUTPUT:\n\t\t  o << \"output \";\n\t\t  break;\n\t\tcase NetNet::PINOUT:\n\t\t  o << \"inout \";\n\t\t  break;\n\t    }\n\t    if (port(idx)->get_signed()) o << \"+\";\n\t    o << port(idx)->name() << endl;\n      }\n      if (proc_)\n\t    proc_->dump(o, ind+2);\n      else\n\t    o << setw(ind+2) << \"\" << \"MISSING PROCEDURAL CODE\" << endl;\n}\n\nvoid NetPDelay::dump(ostream&o, unsigned ind) const\n{\n      if (expr_) {\n\t    o << setw(ind) << \"\" << \"#\" << *expr_;\n\n      } else {\n\t    o << setw(ind) << \"\" << \"#\" << delay_;\n      }\n\n      if (statement_) {\n\t    o << endl;\n\t    statement_->dump(o, ind+2);\n      } else {\n\t    o << \" /* noop */;\" << endl;\n      }\n}\n\nvoid NetRelease::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"release \";\n      dump_lval(o);\n      o << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid NetRepeat::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"repeat (\" << *expr_ << \")\" << endl;\n      statement_->dump(o, ind+2);\n}\n\nvoid netclass_t::dump_scope(ostream&fd) const\n{\n      class_scope_->dump(fd);\n}\n\nvoid NetScope::dump(ostream&o) const\n{\n\t/* This is a constructed hierarchical name. */\n      o << scope_path(this) << \" \";\n\n      print_type(o);\n      if (is_auto()) o << \" (automatic)\";\n      if (is_cell()) o << \" (cell)\";\n      if (nested_module()) o << \" (nested)\";\n      if (program_block()) o << \" (program)\";\n      if (is_interface()) o << \" (interface)\";\n      o << \" \" << children_.size() << \" children, \"\n\t<< classes_.size() << \" classes\" << endl;\n      if (unit() && !is_unit())\n\t    o << \"    in compilation unit \" << unit()->basename() << endl;\n\n      for (unsigned idx = 0 ;  idx < attr_cnt() ;  idx += 1)\n\t    o << \"    (* \" << attr_key(idx) << \" = \"\n\t      << attr_value(idx) << \" *)\" << endl;\n\n      o << \"    timescale = 10e\" << time_unit() << \" / 10e\"\n\t<< time_precision() << endl;\n\n\t/* Dump the parameters for this scope. */\n      {\n\t    map<perm_string,param_expr_t>::const_iterator pp;\n\t    for (pp = parameters.begin()\n\t\t       ; pp != parameters.end() ;  ++ pp ) {\n\t\t  if ((*pp).second.is_annotatable)\n\t\t\to << \"    specparam \";\n\t\t  else\n\t\t\to << \"    parameter \";\n\n\t\t  if (pp->second.ivl_type)\n\t\t\tpp->second.ivl_type->debug_dump(o);\n\n\t\t  o << (*pp).first << \" = \";\n\t\t  if (pp->second.val)\n\t\t\to << *(*pp).second.val;\n\t\t  else\n\t\t\to << \"<nil>\";\n\n\t\t  for (range_t*ran = (*pp).second.range ; ran ; ran = ran->next) {\n\t\t\tif (ran->exclude_flag)\n\t\t\t      o << \" exclude \";\n\t\t\telse\n\t\t\t      o << \" from \";\n\n\t\t\tif (ran->low_open_flag)\n\t\t\t      o << \"(\";\n\t\t\telse\n\t\t\t      o << \"[\";\n\t\t\tif (ran->low_expr)\n\t\t\t      o << *ran->low_expr;\n\t\t\telse if (ran->low_open_flag==false)\n\t\t\t      o << \"-inf\";\n\t\t\telse\n\t\t\t      o << \"<?>\";\n\t\t\tif (ran->high_expr)\n\t\t\t      o << \":\" << *ran->high_expr;\n\t\t\telse if (ran->high_open_flag==false)\n\t\t\t      o << \":inf\";\n\t\t\telse\n\t\t\t      o << \":<?>\";\n\t\t\tif (ran->high_open_flag)\n\t\t\t      o << \")\";\n\t\t\telse\n\t\t\t      o << \"]\";\n\t\t  }\n\n\t\t  o << \";\" << endl;\n\t    }\n      }\n\n\t/* Dump the saved defparam assignments here. */\n      {\n\t    list<pair<pform_name_t,PExpr*> >::const_iterator pp;\n\t    for (pp = defparams.begin()\n\t\t       ; pp != defparams.end() ;  ++ pp ) {\n\t\t  o << \"    defparam \" << (*pp).first << \" = \" <<\n\t\t\t*(*pp).second << \";\" << endl;\n\t    }\n      }\n\n      {\n\t    list<pair<list<hname_t>,PExpr*> >::const_iterator pp;\n\t    for (pp = defparams_later.begin()\n\t\t       ; pp != defparams_later.end() ;  ++ pp ) {\n\t\t  o << \"    defparam(later) \" << pp->first << \" = \" <<\n\t\t\t*(pp->second) << \";\" << endl;\n\t    }\n      }\n\n      o << \"    enum sets {\" << endl;\n\n\t/* Dump the enumerations and enum names in this scope. */\n      for (map<const enum_type_t*,netenum_t*>::const_iterator cur = enum_sets_.begin()\n\t\t ; cur != enum_sets_.end() ; ++ cur) {\n\t    o << \"      \" << cur->second << endl;\n      }\n      o << \"    }\" << endl;\n\n      o << \"    enum names {\" << endl;\n      for (map<perm_string,NetEConstEnum*>::const_iterator cur = enum_names_.begin()\n\t\t ; cur != enum_names_.end() ; ++ cur) {\n\t    o << \"      \" << cur->first << \" = \" << cur->second->value()\n\t      << \" from \" << cur->second->enumeration() << endl;\n      }\n      o << \"    }\" << endl;\n\n\t/* Dump the events in this scope. */\n      for (NetEvent*cur = events_ ;  cur ;  cur = cur->snext_) {\n\t    o << \"    event \" << cur->name() << \"; nprobe=\"\n\t      << cur->nprobe() << \" scope=\" << scope_path(cur->scope())\n\t      << \" // \" << cur->get_fileline() << endl;\n      }\n\n\t// Dump the signals,\n      for (signals_map_iter_t cur = signals_map_.begin()\n\t\t ; cur != signals_map_.end() ; ++ cur) {\n\t    cur->second->dump_net(o, 4);\n      }\n\n      switch (type_) {\n\t  case FUNC:\n\t    if (func_def())\n\t\t  func_def()->dump(o, 4);\n\t    else\n\t\t  o << \"    MISSING FUNCTION DEFINITION\" << endl;\n\t    break;\n\t  case TASK:\n\t    if (task_def())\n\t\t  task_def()->dump(o, 4);\n\t    else\n\t\t  o << \"    MISSING TASK DEFINITION\" << endl;\n\t    break;\n\t  default:\n\t    break;\n      }\n\n\t/* Dump any sub-scopes. */\n      for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t ; cur != children_.end() ; ++ cur )\n\t    cur->second->dump(o);\n\n      for (map<perm_string,netclass_t*>::const_iterator cur = classes_.begin()\n\t\t ; cur != classes_.end() ; ++ cur ) {\n\t    cur->second->dump_scope(o);\n      }\n}\n\nvoid NetSTask::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << name_;\n\n      if (! parms_.empty()) {\n\t    o << \"(\" << parms_ << \")\";\n      }\n      o << \";\" << endl;\n}\n\nvoid NetUTask::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << scope_path(task_) << \";\" << endl;\n}\n\nvoid NetWhile::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"while (\" << *cond_ << \")\" << endl;\n      proc_->dump(o, ind+3);\n}\n\n/* Dump a statement type that someone didn't write a dump for. */\nvoid NetProc::dump(ostream&o, unsigned ind) const\n{\n      o << setw(ind) << \"\" << \"// \" << typeid(*this).name() << endl;\n}\n\n/* Dump an expression that no one wrote a dump method for. */\nvoid NetExpr::dump(ostream&o) const\n{\n      o << \"(?\" << typeid(*this).name() << \"?)\";\n}\n\nvoid NetEAccess::dump(ostream&o) const\n{\n      o << nature_->name() << \".\" << nature_->access() << \"(\";\n      assert(branch_);\n      if (branch_->pin(0).is_linked())\n\t    o << branch_->pin(0).nexus()->name();\n      o << \", \";\n      if (branch_->pin(1).is_linked())\n\t    o << branch_->pin(1).nexus()->name();\n      o << \")\";\n}\n\nvoid NetEArrayPattern::dump(ostream&fd) const\n{\n      fd << \"'{\" << items_ << \"}\";\n}\n\nvoid NetEBinary::dump(ostream&o) const\n{\n      if (op_ == 'm' || op_ == 'M') {\n\t    if (op_ == 'm')\n\t\t  o << \"min\";\n\t    else\n\t\t  o << \"max\";\n\n\t    o << \"(\";\n\t    left_->dump(o);\n\t    o << \", \";\n\t    right_->dump(o);\n\t    o << \")\";\n\t    return;\n      }\n\n      o << \"(\";\n      left_->dump(o);\n      o << \")\";\n      switch (op_) {\n\t  default:\n\t    o << op_;\n\t    break;\n\t  case 'a':\n\t    o << \"&&\";\n\t    break;\n\t  case 'A':\n\t    o << \"~&\";\n\t    break;\n\t  case 'e':\n\t    o << \"==\";\n\t    break;\n\t  case 'E':\n\t    o << \"===\";\n\t    break;\n\t  case 'w':\n\t    o << \"==?\";\n\t    break;\n\t  case 'G':\n\t    o << \">=\";\n\t    break;\n\t  case 'l':\n\t    o << \"<<\";\n\t    break;\n\t  case 'L':\n\t    o << \"<=\";\n\t    break;\n\t  case 'n':\n\t    o << \"!=\";\n\t    break;\n\t  case 'N':\n\t    o << \"!==\";\n\t    break;\n\t  case 'W':\n\t    o << \"!=?\";\n\t    break;\n\t  case 'o':\n\t    o << \"||\";\n\t    break;\n\t  case 'O':\n\t    o << \"~|\";\n\t    break;\n\t  case 'p':\n\t    o << \"**\";\n\t    break;\n\t  case 'q':\n\t    o << \"->\";\n\t    break;\n\t  case 'Q':\n\t    o << \"<->\";\n\t    break;\n\t  case 'r':\n\t    o << \">>\";\n\t    break;\n\t  case 'R':\n\t    o << \">>>\";\n\t    break;\n\t  case 'X':\n\t    o << \"~^\";\n\t    break;\n      }\n      o << \"(\";\n      right_->dump(o);\n      o << \")\";\n}\n\nvoid NetECast::dump(ostream&fd) const\n{\n      if (op_=='2')\n\t    fd << \"bool<\" << expr_width() << \">(\" << *expr_ << \")\";\n      else if (op_=='v')\n\t    fd << \"logic<\" << expr_width() << \">(\" << *expr_ << \")\";\n      else\n\t    NetEUnary::dump(fd);\n}\n\nvoid NetEConcat::dump(ostream&o) const\n{\n      if (repeat_ != 1)\n            o << repeat_;\n\n      o << \"{\" << parms_ << \"}\";\n}\n\nvoid NetEConst::dump(ostream&o) const\n{\n      if (value_.is_string())\n\t    o << \"\\\"\" << value_.as_string() << \"\\\"\";\n      else\n\t    o << value_;\n}\n\nvoid NetEConstEnum::dump(ostream&o) const\n{\n      o << \"<\" << name_ << \"=\";\n      NetEConst::dump(o);\n      o << \", wid=\" << expr_width() << \">\";\n}\n\nvoid NetEConstParam::dump(ostream&o) const\n{\n      o << \"<\" << name_ << \"=\";\n      NetEConst::dump(o);\n      o << \", wid=\" << expr_width() << \">\";\n}\n\nvoid NetECReal::dump(ostream&o) const\n{\n      o << value_;\n}\n\nvoid NetECRealParam::dump(ostream&o) const\n{\n      o << \"<\" << name_ << \"=\";\n      NetECReal::dump(o);\n      o << \">\";\n}\n\nvoid NetEEvent::dump(ostream&o) const\n{\n      o << \"<event=\" << event_->name() << \">\";\n}\n\nvoid NetELast::dump(ostream&fd) const\n{\n      fd << \"<last of \" << sig_->name() << \">\";\n}\n\nvoid NetENetenum::dump(ostream&o) const\n{\n      o << \"<netenum=\" << netenum_ << \">\";\n}\n\nvoid NetENew::dump(ostream&o) const\n{\n      o << \"new <type> [\";\n      if (size_) size_->dump(o);\n      o << \"]\";\n      if (init_val_) {\n\t    o << \"(\";\n\t    init_val_->dump(o);\n\t    o << \")\";\n      }\n}\n\nvoid NetENull::dump(ostream&o) const\n{\n      o << \"<null>\";\n}\n\nvoid NetEProperty::dump(ostream&o) const\n{\n      o << net_->name() << \".<\" << pidx_ << \">\";\n      if (index_)\n\t    o << \"[\" << *index_ << \"]\";\n}\n\nvoid NetEScope::dump(ostream&o) const\n{\n      o << \"<scope=\" << scope_path(scope_) << \">\";\n}\n\nvoid NetESelect::dump(ostream&o) const\n{\n      o << \"<select\";\n      if (has_sign())\n\t    o << \"+=\";\n      else\n\t    o << \"=\";\n\n      expr_->dump(o);\n      o << \"[\";\n\n      if (base_)\n\t    base_->dump(o);\n      else\n\t    o << \"(0)\";\n\n      o << \"+:\" << expr_width() << \"]\";\n      if (ivl_type_t nt = net_type()) {\n\t    o << \" net_type=(\" << *nt << \")\";\n      } else {\n\t    o << \" expr_type=\" << expr_type();\n      }\n\n      o << \">\";\n}\n\nvoid NetESFunc::dump(ostream&o) const\n{\n      o << name_ << \"(\";\n      if (nparms() > 0)\n\t    o << *parm(0);\n      for (unsigned idx = 1 ;  idx < nparms() ;  idx += 1)\n\t    o << \", \" << *parm(idx);\n      o << \")\";\n}\n\nvoid NetEShallowCopy::dump(ostream&o) const\n{\n      o << \"<ShallowCopy, \" << *arg1_ << \" <-- \" << *arg2_ << \">\";\n}\n\nvoid NetESignal::dump(ostream&o) const\n{\n      if (has_sign())\n\t    o << \"+\";\n      o << name();\n      if (word_) o << \"[word=\" << *word_ << \"]\";\n      o << net_->net_type()->slice_dimensions();\n}\n\nvoid NetETernary::dump(ostream&o) const\n{\n      o << \"(\" << *cond_ << \") ? (\" << *true_val_ << \") : (\" <<\n\t    *false_val_ << \")\";\n}\n\nvoid NetEUFunc::dump(ostream&o) const\n{\n      o << scope_path(func_) << \"(\" << parms_ << \")\";\n}\n\nvoid NetEUnary::dump(ostream&o) const\n{\n      switch (op_) {\n\t  case 'A':\n\t    o << \"~&\";\n\t    break;\n\t  case 'm':\n\t    o << \"abs\";\n\t    break;\n\t  case 'N':\n\t    o << \"~|\";\n\t    break;\n\t  case 'X':\n\t    o << \"~^\";\n\t    break;\n          case 'I':\n\t    o << \"++\";\n\t    break;\n          case 'D':\n\t    o << \"--\";\n\t    break;\n          case 'i':\n          case 'd':\n\t    break;\n\t  default:\n\t    o << op_;\n\t    break;\n      }\n      o << \"(\";\n      expr_->dump(o);\n      o << \")\";\n      switch (op_) {\n          case 'i':\n\t    o << \"++\";\n\t    break;\n          case 'd':\n\t    o << \"--\";\n\t    break;\n      }\n}\n\nvoid Design::dump(ostream&o) const\n{\n      o << \"DESIGN TIME PRECISION: 10e\" << get_precision() << endl;\n\n      o << \"PACKAGES:\" << endl;\n      for (map<perm_string,NetScope*>::const_iterator cur = packages_.begin()\n\t\t ; cur != packages_.end() ; ++cur) {\n\t    cur->second->dump(o);\n      }\n\n      o << \"SCOPES:\" << endl;\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin();\n\t   scope != root_scopes_.end(); ++ scope ) {\n\t    (*scope)->dump(o);\n      }\n\n      o << \"ELABORATED NODES:\" << endl;\n\n\t// dump the nodes,\n      if (nodes_) {\n\t    NetNode*cur = nodes_->node_next_;\n\t    do {\n\t\t  assert(cur);\n\t\t  cur->dump_node(o, 0);\n\t\t  cur = cur->node_next_;\n\t    } while (cur != nodes_->node_next_);\n      }\n\n      o << \"ELABORATED BRANCHES:\" << endl;\n\n      if (branches_) {\n\t    for (NetBranch*cur = branches_ ; cur ; cur = cur->next_)\n\t\t  cur->dump(o, 0);\n      }\n\n      o << \"ELABORATED PROCESSES:\" << endl;\n\n\t// Dump the processes.\n      for (const NetProcTop*idx = procs_ ;  idx ;  idx = idx->next_)\n\t    idx->dump(o, 0);\n\n      for (const NetAnalogTop*idx = aprocs_ ; idx ; idx = idx->next_)\n\t    idx->dump(o, 0);\n}\n"
        },
        {
          "name": "discipline.cc",
          "type": "blob",
          "size": 1.2333984375,
          "content": "/*\n * Copyright (c) 2008 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"discipline.h\"\n\nivl_nature_s::ivl_nature_s(perm_string name__, perm_string access__)\n: name_(name__), access_(access__)\n{\n}\n\nivl_nature_s::~ivl_nature_s()\n{\n}\n\nivl_discipline_s::ivl_discipline_s(perm_string name__, ivl_dis_domain_t domain__,\n\t\t\t\t   ivl_nature_t pot, ivl_nature_t flow__)\n: name_(name__), domain_(domain__), potential_(pot), flow_(flow__)\n{\n}\n\nivl_discipline_s::~ivl_discipline_s()\n{\n}\n"
        },
        {
          "name": "discipline.h",
          "type": "blob",
          "size": 2.537109375,
          "content": "#ifndef IVL_discipline_H\n#define IVL_discipline_H\n/*\n * Copyright (c) 2008-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n/*\n * The discipline types include the discipline, nature and other\n * related types for managing declared and used disciplines in a\n * Verilog-AMS program.\n */\n\n# include  \"StringHeap.h\"\n# include  <iostream>\n# include  <map>\n# include  \"ivl_target.h\"\n# include  \"LineInfo.h\"\n\nextern std::ostream& operator << (std::ostream&, ivl_dis_domain_t);\n\nclass ivl_nature_s : public LineInfo {\n    public:\n      explicit ivl_nature_s(perm_string name, perm_string access);\n      ~ivl_nature_s();\n\n      perm_string name() const   { return name_; }\n\t// Identifier for the access function for this nature\n      perm_string access() const { return access_; }\n\n    private:\n      perm_string name_;\n      perm_string access_;\n};\n\nclass ivl_discipline_s : public LineInfo {\n    public:\n      explicit ivl_discipline_s (perm_string name, ivl_dis_domain_t dom,\n\t\t\t\t ivl_nature_t pot, ivl_nature_t flow);\n      ~ivl_discipline_s();\n\n      perm_string name() const         { return name_; }\n      ivl_dis_domain_t domain() const  { return domain_; }\n      ivl_nature_t potential() const { return potential_; }\n      ivl_nature_t flow() const      { return flow_; }\n\n    private:\n      perm_string name_;\n      ivl_dis_domain_t domain_;\n      ivl_nature_t potential_;\n      ivl_nature_t flow_;\n\n    private: // not implemented\n      ivl_discipline_s(const ivl_discipline_s&);\n      ivl_discipline_s& operator = (const ivl_discipline_s&);\n};\n\nextern std::map<perm_string,ivl_nature_t> natures;\nextern std::map<perm_string,ivl_discipline_t> disciplines;\n  // Map access function name to the nature that it accesses.\nextern std::map<perm_string,ivl_nature_t> access_function_nature;\n\n#endif /* IVL_discipline_H */\n"
        },
        {
          "name": "disciplines.vams",
          "type": "blob",
          "size": 1.0986328125,
          "content": "\n// Standard definitions for Verilog-AMS\n`ifdef DISCIPLINES_VAMS\n`else\n`define DISCIPLINES_VAMS 1\n\ndiscipline \\logic ;\n  domain discrete;\nenddiscipline\n\ndiscipline ddiscrete;\n  domain discrete;\nenddiscipline\n\nnature Current;\n  units      = \"A\";\n  access     = I;\n  idt_nature = Charge;\n`ifdef CURRENT_ABSTOL\n  abstol     = `CURRENT_ABSTOL\n`else\n  abstol     = 1e-12;\n`endif\nendnature\n\nnature Charge;\n  units      = \"coul\";\n  access     = Q;\n  ddt_nature = Current;\n`ifdef CHARGE_ABSTOL\n  abstol     = `CHARGE_ABSTOL;\n`else\n  abstol     = 1e-14;\n`endif\nendnature\n\nnature Voltage;\n  units      = \"V\";\n  access     = V;\n  idt_nature = Flux;\n`ifdef VOLTAGE_ABSTOL\n  abstol     = `VOLTAGE_ABSTOL;\n`else\n  abstol     = 1e-6;\n`endif\nendnature\n\nnature Flux;\n  units      = \"Wb\";\n  access     = Phi;\n  ddt_nature = Voltage;\n`ifdef FLUX_ABSTOL\n  abstol     = `flux_ABSTOL;\n`else\n  abstol     = 1e-9;\n`endif\nendnature\n\ndiscipline electrical;\n  potential Voltage;\n  flow Current;\nenddiscipline\n\ndiscipline voltage;\n  potential Voltage;\nenddiscipline\n\ndiscipline current;\n  flow Current;\nenddiscipline\n\n`endif // !`ifdef DISCIPLINES_VAMS\n"
        },
        {
          "name": "dosify.c",
          "type": "blob",
          "size": 1.8876953125,
          "content": "/*\n * Copyright (c) 2001-2009 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n/*\n * This is a simple program to make a dosified copy of the\n * original. That is, it converts Unix style line ends to DOS\n * style. This is useful for installing text files.\n *\n * The exact substitution is to replace \\n with \\r\\n. If the line\n * already ends with \\r\\n then it is not changed to \\r\\r\\n.\n */\n\n# include  <stdio.h>\n\nint main(int argc, char*argv[])\n{\n      FILE*ifile;\n      FILE*ofile;\n      int ch, pr;\n\n      if (argc != 3) {\n\t    fprintf(stderr, \"Usage: %s <input> <output>\\n\", argv[0]);\n\t    return 1;\n      }\n\n      ifile = fopen(argv[1], \"rb\");\n      if (ifile == 0) {\n\t    fprintf(stderr, \"Unable to open %s for input.\\n\", argv[1]);\n\t    return 2;\n      }\n\n      ofile = fopen(argv[2], \"wb\");\n      if (ofile == 0) {\n\t    fprintf(stderr, \"Unable to open %s for output.\\n\", argv[2]);\n\t    fclose(ifile);\n\t    return 2;\n      }\n\n      pr = 0;\n      while ((ch = fgetc(ifile)) != EOF) {\n\n\t    if ((ch == '\\n') && (pr != '\\r'))\n\t\t  fputc('\\r', ofile);\n\n\t    fputc(ch, ofile);\n\t    pr = ch;\n      }\n\n      fclose(ifile);\n      fclose(ofile);\n      return 0;\n}\n"
        },
        {
          "name": "driver-vpi",
          "type": "tree",
          "content": null
        },
        {
          "name": "driver",
          "type": "tree",
          "content": null
        },
        {
          "name": "dup_expr.cc",
          "type": "blob",
          "size": 8.0947265625,
          "content": "/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"netlist.h\"\n# include  <cassert>\n# include  <cstdlib>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nNetEAccess* NetEAccess::dup_expr() const\n{\n      NetEAccess*tmp = new NetEAccess(branch_, nature_);\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEArrayPattern*NetEArrayPattern::dup_expr() const\n{\n      vector<NetExpr*>tmp (items_.size());\n      for (size_t idx = 0 ; idx < tmp.size() ; idx += 1)\n\t    tmp[idx] = items_[idx]->dup_expr();\n\n      NetEArrayPattern*res = new NetEArrayPattern(net_type(), tmp);\n      res->set_line(*this);\n      return res;\n}\n\nNetEBinary* NetEBinary::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetEBAdd* NetEBAdd::dup_expr() const\n{\n      NetEBAdd*tmp = new NetEBAdd(op_, left_->dup_expr(), right_->dup_expr(),\n                                  expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEBBits* NetEBBits::dup_expr() const\n{\n      NetEBBits*tmp = new NetEBBits(op_, left_->dup_expr(), right_->dup_expr(),\n                                    expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEBComp* NetEBComp::dup_expr() const\n{\n      NetEBComp*tmp = new NetEBComp(op_, left_->dup_expr(), right_->dup_expr());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEBDiv* NetEBDiv::dup_expr() const\n{\n      NetEBDiv*tmp = new NetEBDiv(op_, left_->dup_expr(), right_->dup_expr(),\n                                  expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEBLogic* NetEBLogic::dup_expr() const\n{\n      NetEBLogic*tmp = new NetEBLogic(op_, left_->dup_expr(), right_->dup_expr());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEBMult* NetEBMult::dup_expr() const\n{\n      NetEBMult*tmp = new NetEBMult(op_, left_->dup_expr(), right_->dup_expr(),\n                                    expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEBPow* NetEBPow::dup_expr() const\n{\n      NetEBPow*tmp = new NetEBPow(op_, left_->dup_expr(), right_->dup_expr(),\n                                  expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEBShift* NetEBShift::dup_expr() const\n{\n      NetEBShift*tmp = new NetEBShift(op_, left_->dup_expr(), right_->dup_expr(),\n                                      expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEConcat* NetEConcat::dup_expr() const\n{\n      NetEConcat*dup = new NetEConcat(parms_.size(), repeat_, expr_type_);\n      ivl_assert(*this, dup);\n      dup->set_line(*this);\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1)\n\t    if (parms_[idx]) {\n\t\t  NetExpr*tmp = parms_[idx]->dup_expr();\n                  ivl_assert(*this, tmp);\n\t\t  dup->parms_[idx] = tmp;\n\t    }\n\n      dup->expr_width(expr_width());\n\n      return dup;\n}\n\nNetEConst* NetEConst::dup_expr() const\n{\n      NetEConst*tmp = new NetEConst(value_);\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEConstEnum* NetEConstEnum::dup_expr() const\n{\n      NetEConstEnum*tmp = new NetEConstEnum(name_, enumeration(), value());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEConstParam* NetEConstParam::dup_expr() const\n{\n      NetEConstParam*tmp = new NetEConstParam(scope_, name_, value());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetECReal* NetECReal::dup_expr() const\n{\n      NetECReal*tmp = new NetECReal(value_);\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetECRealParam* NetECRealParam::dup_expr() const\n{\n      NetECRealParam*tmp = new NetECRealParam(scope_, name_, value());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEEvent* NetEEvent::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetELast* NetELast::dup_expr() const\n{\n      NetELast*tmp = new NetELast(sig_);\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetENetenum* NetENetenum::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetENew* NetENew::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetENull* NetENull::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetEProperty* NetEProperty::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetEScope* NetEScope::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetESelect* NetESelect::dup_expr() const\n{\n      NetESelect*tmp = new NetESelect(expr_->dup_expr(),\n\t\t\t              base_? base_->dup_expr() : 0,\n\t\t\t              expr_width(), sel_type_);\n      ivl_assert(*this, tmp);\n      tmp->cast_signed(has_sign());\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetESFunc* NetESFunc::dup_expr() const\n{\n      NetESFunc*tmp = new NetESFunc(name_, type_, expr_width(), nparms(), is_overridden_);\n      ivl_assert(*this, tmp);\n\n      tmp->cast_signed(has_sign());\n      for (unsigned idx = 0 ;  idx < nparms() ;  idx += 1) {\n\t    ivl_assert(*this, parm(idx));\n\t    tmp->parm(idx, parm(idx)->dup_expr());\n      }\n\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEShallowCopy* NetEShallowCopy::dup_expr() const\n{\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetESignal* NetESignal::dup_expr() const\n{\n      NetESignal*tmp = new NetESignal(net_, word_);\n      ivl_assert(*this, tmp);\n      tmp->expr_width(expr_width());\n      tmp->cast_signed(has_sign());\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetETernary* NetETernary::dup_expr() const\n{\n      NetETernary*tmp = new NetETernary(cond_->dup_expr(),\n\t\t\t\t\ttrue_val_->dup_expr(),\n\t\t\t\t\tfalse_val_->dup_expr(),\n                                        expr_width(),\n                                        has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEUFunc* NetEUFunc::dup_expr() const\n{\n      NetEUFunc*tmp;\n      vector<NetExpr*> tmp_parms (parms_.size());\n\n      for (unsigned idx = 0 ;  idx < tmp_parms.size() ;  idx += 1) {\n\t    ivl_assert(*this, parms_[idx]);\n\t    tmp_parms[idx] = parms_[idx]->dup_expr();\n      }\n\n      tmp = new NetEUFunc(scope_, func_, result_sig_->dup_expr(), tmp_parms,\n                          need_const_);\n\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEUBits* NetEUBits::dup_expr() const\n{\n      NetEUBits*tmp = new NetEUBits(op_, expr_->dup_expr(), expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEUnary* NetEUnary::dup_expr() const\n{\n      NetEUnary*tmp = new NetEUnary(op_, expr_->dup_expr(), expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetEUReduce* NetEUReduce::dup_expr() const\n{\n      NetEUReduce*tmp = new NetEUReduce(op_, expr_->dup_expr());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetECast* NetECast::dup_expr() const\n{\n      NetECast*tmp = new NetECast(op_, expr_->dup_expr(), expr_width(), has_sign());\n      ivl_assert(*this, tmp);\n      tmp->set_line(*this);\n      return tmp;\n}\n"
        },
        {
          "name": "elab_expr.cc",
          "type": "blob",
          "size": 243.77734375,
          "content": "/*\n * Copyright (c) 1999-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include  <typeinfo>\n# include  <cstdlib>\n# include  <cstring>\n# include  <climits>\n# include \"compiler.h\"\n\n# include  \"PPackage.h\"\n# include  \"pform.h\"\n# include  \"netlist.h\"\n# include  \"netclass.h\"\n# include  \"netenum.h\"\n# include  \"netparray.h\"\n# include  \"netvector.h\"\n# include  \"discipline.h\"\n# include  \"netmisc.h\"\n# include  \"netdarray.h\"\n# include  \"netqueue.h\"\n# include  \"netstruct.h\"\n# include  \"netscalar.h\"\n# include  \"util.h\"\n# include  \"ivl_assert.h\"\n# include  \"map_named_args.h\"\n\nusing namespace std;\n\nbool type_is_vectorable(ivl_variable_type_t type)\n{\n      switch (type) {\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC:\n\t    return true;\n\t  default:\n\t    return false;\n      }\n}\n\nstatic ivl_nature_t find_access_function(const pform_scoped_name_t &path)\n{\n      if (path.package || path.name.size() != 1)\n\t    return nullptr;\n      return access_function_nature[peek_tail_name(path)];\n}\n\n/*\n * Look at the signal to see if there is already a branch that\n * connects the sig to the gnd. If there is, then return it. If not,\n * return 0.\n */\nstatic NetBranch* find_existing_implicit_branch(NetNet*sig, NetNet*gnd)\n{\n      Nexus*nex = sig->pin(0).nexus();\n      for (Link*cur = nex->first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t    if (cur->is_equal(sig->pin(0)))\n\t\t  continue;\n\n\t    if (cur->get_pin() != 0)\n\t\t  continue;\n\n\t    NetBranch*tmp = dynamic_cast<NetBranch*> (cur->get_obj());\n\t    if (tmp == 0)\n\t\t  continue;\n\n\t    if (tmp->name())\n\t\t  continue;\n\n\t    if (tmp->pin(1).is_linked(gnd->pin(0)))\n\t\t  return tmp;\n      }\n\n      return 0;\n}\n\nNetExpr* elaborate_rval_expr(Design *des, NetScope *scope, ivl_type_t lv_net_type,\n\t\t\t     PExpr *expr, bool need_const, bool force_unsigned)\n{\n      return elaborate_rval_expr(des, scope, lv_net_type,\n\t\t\t\t lv_net_type->base_type(),\n\t\t\t\t lv_net_type->packed_width(),\n\t\t\t\t expr, need_const, force_unsigned);\n}\n\nNetExpr* elaborate_rval_expr(Design*des, NetScope*scope, ivl_type_t lv_net_type,\n\t\t\t     ivl_variable_type_t lv_type, unsigned lv_width,\n\t\t\t     PExpr*expr, bool need_const, bool force_unsigned)\n{\n      if (debug_elaborate) {\n\t    cerr << expr->get_fileline() << \": elaborate_rval_expr: \"\n\t\t << \"expr=\" << *expr;\n\t    if (lv_net_type)\n\t\t  cerr << \", lv_net_type=\" << *lv_net_type;\n\t    else\n\t\t  cerr << \", lv_net_type=<nil>\";\n\n\t    cerr << \", lv_type=\" << lv_type\n\t\t << \", lv_width=\" << lv_width\n\t\t << endl;\n      }\n\n      NetExpr *rval;\n      int context_wid = -1;\n      bool typed_elab = false;\n\n      switch (lv_type) {\n\t  case IVL_VT_DARRAY:\n\t  case IVL_VT_QUEUE:\n\t  case IVL_VT_CLASS:\n\t      // For these types, use a different elab_and_eval that\n\t      // uses the lv_net_type. We should eventually transition\n\t      // all the types to this new form.\n\t    typed_elab = true;\n\t    break;\n\t  case IVL_VT_REAL:\n\t  case IVL_VT_STRING:\n\t    break;\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC:\n            context_wid = lv_width;\n\t    break;\n\t  case IVL_VT_VOID:\n\t  case IVL_VT_NO_TYPE:\n\t    ivl_assert(*expr, 0);\n\t    break;\n      }\n\n\t// If the target is an unpacked array we want full type checking,\n\t// regardless of the base type of the array.\n      if (dynamic_cast<const netuarray_t *>(lv_net_type))\n\t    typed_elab = true;\n\n\t// Special case, PEAssignPattern is context dependend on the type and\n\t// always uses the typed elaboration\n      if (dynamic_cast<PEAssignPattern*>(expr))\n\t    typed_elab = true;\n\n      if (lv_net_type && typed_elab) {\n\t    rval = elab_and_eval(des, scope, expr, lv_net_type, need_const);\n      } else {\n\t    rval = elab_and_eval(des, scope, expr, context_wid, need_const,\n\t\t\t\t false, lv_type, force_unsigned);\n      }\n\n      const netenum_t *lval_enum = dynamic_cast<const netenum_t*>(lv_net_type);\n      if (lval_enum) {\n\t    const netenum_t *rval_enum = rval->enumeration();\n\t    if (!rval_enum) {\n\t      cerr << expr->get_fileline() << \": error: \"\n\t\t\t      \"This assignment requires an explicit cast.\" << endl;\n\t      des->errors += 1;\n\t    } else if (!lval_enum->matches(rval_enum)) {\n\t      cerr << expr->get_fileline() << \": error: \"\n\t\t\t      \"Enumeration type mismatch in assignment.\" << endl;\n\t      des->errors += 1;\n\t    }\n      }\n\n      return rval;\n}\n\n/*\n * If the mode is UPSIZE, make sure the final expression width is at\n * least integer_width, but return the calculated lossless width to\n * the caller.\n */\nunsigned PExpr::fix_width_(width_mode_t mode)\n{\n      unsigned width = expr_width_;\n      if ((mode == UPSIZE) && type_is_vectorable(expr_type_)\n          && (width < integer_width))\n            expr_width_ = integer_width;\n\n      return width;\n}\n\nunsigned PExpr::test_width(Design*des, NetScope*, width_mode_t&)\n{\n      cerr << get_fileline() << \": internal error: I do not know how to\"\n\t   << \" test the width of this expression. \" << endl;\n      cerr << get_fileline() << \":               : Expression is: \" << *this\n\t   << endl;\n      des->errors += 1;\n      return 1;\n}\n\nNetExpr* PExpr::elaborate_expr(Design*des, NetScope*scope, ivl_type_t, unsigned flags) const\n{\n\t// Fall back to the old method. Currently the new method won't be used\n\t// if the target is a vector type, so we can use an arbitrary width.\n      return elaborate_expr(des, scope, 1, flags);\n}\n\n\nNetExpr* PExpr::elaborate_expr(Design*des, NetScope*, unsigned, unsigned) const\n{\n      cerr << get_fileline() << \": internal error: I do not know how to\"\n\t   << \" elaborate this expression. \" << endl;\n      cerr << get_fileline() << \":               : Expression is: \" << *this\n\t   << endl;\n      cerr << get_fileline() << \":               : Expression type: \" << typeid(*this).name() << endl;\n      des->errors += 1;\n      return 0;\n}\n\n/*\n * For now, assume that assignment patterns are for dynamic\n * objects. This is not really true as this expression type, fully\n * supported, can assign to packed arrays and structs, unpacked arrays\n * and dynamic arrays.\n */\nunsigned PEAssignPattern::test_width(Design*, NetScope*, width_mode_t&)\n{\n      expr_type_  = IVL_VT_DARRAY;\n      expr_width_ = 1;\n      min_width_  = 1;\n      signed_flag_= false;\n      return 1;\n}\n\nNetExpr*PEAssignPattern::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t\tivl_type_t ntype, unsigned flags) const\n{\n      bool need_const = NEED_CONST & flags;\n\n      if (auto darray_type = dynamic_cast<const netdarray_t*>(ntype))\n\t    return elaborate_expr_array_(des, scope, darray_type, need_const, true);\n\n      if (auto uarray_type = dynamic_cast<const netuarray_t*>(ntype)) {\n\t    return elaborate_expr_uarray_(des, scope, uarray_type,\n\t\t\t\t\t  uarray_type->static_dimensions(), 0,\n\t\t\t\t\t  need_const);\n      }\n\n      if (auto parray_type = dynamic_cast<const netparray_t*>(ntype)) {\n\t    return elaborate_expr_packed_(des, scope, parray_type->base_type(),\n\t\t\t\t\t  parray_type->packed_width(),\n\t\t\t\t\t  parray_type->slice_dimensions(), 0,\n\t\t\t\t\t  need_const);\n      }\n\n      if (auto vector_type = dynamic_cast<const netvector_t*>(ntype)) {\n\t    return elaborate_expr_packed_(des, scope, vector_type->base_type(),\n\t\t\t\t\t  vector_type->packed_width(),\n\t\t\t\t\t  vector_type->slice_dimensions(), 0,\n\t\t\t\t\t  need_const);\n      }\n\n      if (auto struct_type = dynamic_cast<const netstruct_t*>(ntype)) {\n\t    return elaborate_expr_struct_(des, scope, struct_type,\n\t\t\t\t\t  need_const);\n      }\n\n      cerr << get_fileline() << \": sorry: I don't know how to elaborate \"\n\t   << \"assignment_pattern expressions for \" << *ntype << \" type yet.\" << endl;\n      cerr << get_fileline() << \":      : Expression is: \" << *this\n\t   << endl;\n      des->errors += 1;\n      return 0;\n}\n\nNetExpr* PEAssignPattern::elaborate_expr_array_(Design *des, NetScope *scope,\n\t\t\t\t\t        const netarray_t *array_type,\n\t\t\t\t\t        bool need_const, bool up) const\n{\n\t// Special case: If this is an empty pattern (i.e. '{}) then convert\n\t// this to a null handle. Internally, Icarus Verilog uses this to\n\t// represent nil dynamic arrays.\n      if (parms_.empty()) {\n\t    NetENull *tmp = new NetENull;\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n\t// This is an array pattern, so run through the elements of\n\t// the expression and elaborate each as if they are\n\t// element_type expressions.\n      ivl_type_t elem_type = array_type->element_type();\n      vector<NetExpr*> elem_exprs (parms_.size());\n      size_t elem_idx = up ? 0 : parms_.size() - 1;\n      for (size_t idx = 0 ; idx < parms_.size() ; idx += 1) {\n\t    elem_exprs[elem_idx] = elaborate_rval_expr(des, scope, elem_type,\n\t\t\t\t\t\t       parms_[idx], need_const);\n\t    if (up)\n\t\t  elem_idx++;\n\t    else\n\t\t  elem_idx--;\n      }\n\n      NetEArrayPattern*res = new NetEArrayPattern(array_type, elem_exprs);\n      res->set_line(*this);\n      return res;\n}\n\nNetExpr* PEAssignPattern::elaborate_expr_uarray_(Design *des, NetScope *scope,\n\t\t\t\t\t\t const netuarray_t *uarray_type,\n\t\t\t\t\t\t const netranges_t &dims,\n\t\t\t\t\t\t unsigned int cur_dim,\n\t\t\t\t\t\t bool need_const) const\n{\n      if (dims.size() <= cur_dim)\n\t    return nullptr;\n\n      if (dims[cur_dim].width() != parms_.size()) {\n\t    cerr << get_fileline() << \": error: Unpacked array assignment pattern expects \"\n\t         << dims[cur_dim].width() << \" element(s) in this context.\\n\"\n\t         << get_fileline() << \":      : Found \"\n\t\t << parms_.size() << \" element(s).\" << endl;\n\t    des->errors++;\n      }\n\n      bool up = dims[cur_dim].get_msb() < dims[cur_dim].get_lsb();\n      if  (cur_dim == dims.size() - 1) {\n\t    return elaborate_expr_array_(des, scope, uarray_type, need_const, up);\n      }\n\n      cur_dim++;\n      vector<NetExpr*> elem_exprs(parms_.size());\n      size_t elem_idx = up ? 0 : parms_.size() - 1;\n      for (size_t idx = 0; idx < parms_.size(); idx++) {\n\t    NetExpr *expr = nullptr;\n\t    // Handle nested assignment patterns as a special case. We do not\n\t    // have a good way of passing the inner dimensions through the\n\t    // generic elaborate_expr() API and assigment patterns is the only\n\t    // place where we need it.\n\t    if (auto ap = dynamic_cast<PEAssignPattern*>(parms_[idx])) {\n\t\t  expr = ap->elaborate_expr_uarray_(des, scope, uarray_type,\n\t\t\t\t\t\t    dims, cur_dim, need_const);\n\t    } else if (dynamic_cast<PEConcat*>(parms_[idx])) {\n\t\t  cerr << get_fileline() << \": sorry: \"\n\t\t       << \"Array concatenation is not yet supported.\"\n\t\t       << endl;\n\t\t  des->errors++;\n\t    } else if (dynamic_cast<PEIdent*>(parms_[idx])) {\n\t\t  // The only other thing that's allow in this\n\t\t  // context is an array slice or identifier.\n\t\t  cerr << get_fileline() << \": sorry: \"\n\t\t       << \"Procedural assignment of array or array slice\"\n\t\t       << \" is not yet supported.\" << endl;\n\t\t  des->errors++;\n\t    } else if (parms_[idx]) {\n\t\t  cerr << get_fileline() << \": error: Expression \"\n\t\t       << *parms_[idx]\n\t\t       << \" is not compatible with this context.\"\n\t\t       << \" Expected array or array-like expression.\"\n\t\t       << endl;\n\t\t  des->errors++;\n\t    }\n\n\t    elem_exprs[elem_idx] = expr;\n\n\t    if (up)\n\t\t  elem_idx++;\n\t    else\n\t\t  elem_idx--;\n      }\n\n      NetEArrayPattern *res = new NetEArrayPattern(uarray_type, elem_exprs);\n      res->set_line(*this);\n      return res;\n}\n\nNetExpr* PEAssignPattern::elaborate_expr_packed_(Design *des, NetScope *scope,\n\t\t\t\t\t\t ivl_variable_type_t base_type,\n\t\t\t\t\t\t unsigned int width,\n\t\t\t\t\t\t const netranges_t &dims,\n\t\t\t\t\t\t unsigned int cur_dim,\n\t\t\t\t\t\t bool need_const) const\n{\n      if (dims.size() <= cur_dim) {\n\t    cerr << get_fileline() << \": error: scalar type is not a valid\"\n\t         << \" context for assignment pattern.\" << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n      if (dims[cur_dim].width() != parms_.size()) {\n\t    cerr << get_fileline() << \": error: Packed array assignment pattern expects \"\n\t         << dims[cur_dim].width() << \" element(s) in this context.\\n\"\n\t         << get_fileline() << \":      : Found \"\n\t\t << parms_.size() << \" element(s).\" << endl;\n\t    des->errors++;\n      }\n\n      width /= dims[cur_dim].width();\n      cur_dim++;\n\n      NetEConcat *concat = new NetEConcat(parms_.size(), 1, base_type);\n      for (size_t idx = 0; idx < parms_.size(); idx++) {\n\t    NetExpr *expr;\n\t    // Handle nested assignment patterns as a special case. We do not\n\t    // have a good way of passing the inner dimensions through the\n\t    // generic elaborate_expr() API and assigment patterns is the only\n\t    // place where we need it.\n\t    auto ap = dynamic_cast<PEAssignPattern*>(parms_[idx]);\n\t    if (ap)\n\t\t  expr = ap->elaborate_expr_packed_(des, scope, base_type,\n\t\t\t\t\t\t    width, dims, cur_dim, need_const);\n\t    else\n\t\t  expr = elaborate_rval_expr(des, scope, nullptr,\n\t\t\t\t\t     base_type, width,\n\t\t\t\t\t     parms_[idx], need_const);\n\t    if (expr)\n\t\t  concat->set(idx, expr);\n      }\n\n      return concat;\n}\n\nNetExpr* PEAssignPattern::elaborate_expr_struct_(Design *des, NetScope *scope,\n\t\t\t\t\t\t const netstruct_t *struct_type,\n\t\t\t\t\t\t bool need_const) const\n{\n      auto &members = struct_type->members();\n\n      if (members.size() != parms_.size()) {\n\t    cerr << get_fileline() << \": error: Struct assignment pattern expects \"\n\t         << members.size() << \" element(s) in this context.\\n\"\n\t         << get_fileline() << \":      : Found \"\n\t\t << parms_.size() << \" element(s).\" << endl;\n\t    des->errors++;\n      }\n\n      NetEConcat *concat = new NetEConcat(parms_.size(), 1,\n\t\t\t\t\t  struct_type->base_type());\n      for (size_t idx = 0; idx < std::min(parms_.size(), members.size()); idx++) {\n\t    auto expr = elaborate_rval_expr(des, scope,\n\t\t\t\t\t    members[idx].net_type,\n\t\t\t\t\t    parms_[idx], need_const);\n\t    if (expr)\n\t\t  concat->set(idx, expr);\n      }\n\n      return concat;\n}\n\nNetExpr* PEAssignPattern::elaborate_expr(Design*des, NetScope*, unsigned, unsigned) const\n{\n      cerr << get_fileline() << \": sorry: I do not know how to\"\n\t   << \" elaborate assignment patterns using old method.\" << endl;\n      cerr << get_fileline() << \":      : Expression is: \" << *this\n\t   << endl;\n      des->errors += 1;\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nunsigned PEBinary::test_width(Design*des, NetScope*scope, width_mode_t&mode)\n{\n      ivl_assert(*this, left_);\n      ivl_assert(*this, right_);\n\n      unsigned r_width = right_->test_width(des, scope, mode);\n\n      width_mode_t saved_mode = mode;\n\n      unsigned l_width = left_->test_width(des, scope, mode);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEBinary::test_width: \"\n\t\t << \"op_=\" << op_ << \", l_width=\" << l_width\n\t\t << \", r_width=\" << r_width\n\t\t << \", saved_mode=\" << saved_mode << endl;\n      }\n\n        // If the width mode changed, retest the right operand, as it\n        // may choose a different width if it is in a lossless context.\n      if ((mode >= LOSSLESS) && (saved_mode < LOSSLESS))\n\t    r_width = right_->test_width(des, scope, mode);\n\n      ivl_variable_type_t l_type =  left_->expr_type();\n      ivl_variable_type_t r_type = right_->expr_type();\n\n      if (l_type == IVL_VT_CLASS || r_type == IVL_VT_CLASS) {\n\t    cerr << get_fileline() << \": error: \"\n\t         << \"Class/null is not allowed with the '\"\n\t         << human_readable_op(op_) << \"' operator.\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (l_type == IVL_VT_REAL || r_type == IVL_VT_REAL)\n\t    expr_type_ = IVL_VT_REAL;\n      else if (l_type == IVL_VT_LOGIC || r_type == IVL_VT_LOGIC)\n\t    expr_type_ = IVL_VT_LOGIC;\n      else\n\t    expr_type_ = IVL_VT_BOOL;\n\n      if (expr_type_ == IVL_VT_REAL) {\n            expr_width_  = 1;\n            min_width_   = 1;\n            signed_flag_ = true;\n      } else {\n            expr_width_  = max(l_width, r_width);\n            min_width_   = max(left_->min_width(), right_->min_width());\n            signed_flag_ = left_->has_sign() && right_->has_sign();\n\n              // If the operands are different types, the expression is\n              // forced to unsigned. In this case the lossless width\n              // calculation is unreliable and we need to make sure the\n              // final expression width is at least integer_width.\n            if ((mode == LOSSLESS) && (left_->has_sign() != right_->has_sign()))\n                  mode = UPSIZE;\n\n            switch (op_) {\n                case '+':\n                case '-':\n                  if (mode >= EXPAND)\n                        expr_width_ += 1;\n                  break;\n\n                case '*':\n                  if (mode >= EXPAND)\n                        expr_width_ = l_width + r_width;\n                  break;\n\n                case '%':\n                case '/':\n                  min_width_ = UINT_MAX; // disable width pruning\n                  break;\n\n                case 'l': // <<  Should be handled by PEBLeftWidth\n                case 'r': // >>  Should be handled by PEBLeftWidth\n                case 'R': // >>> Should be handled by PEBLeftWidth\n                case '<': // <   Should be handled by PEBComp\n                case '>': // >   Should be handled by PEBComp\n                case 'e': // ==  Should be handled by PEBComp\n                case 'E': // === Should be handled by PEBComp\n                case 'w': // ==? Should be handled by PEBComp\n                case 'L': // <=  Should be handled by PEBComp\n                case 'G': // >=  Should be handled by PEBComp\n                case 'n': // !=  Should be handled by PEBComp\n                case 'N': // !== Should be handled by PEBComp\n                case 'W': // !=? Should be handled by PEBComp\n                case 'p': // **  should be handled by PEBLeftWidth\n                  ivl_assert(*this, 0);\n                default:\n                  break;\n            }\n      }\n\n      return fix_width_(mode);\n}\n\n/*\n * Elaborate binary expressions. This involves elaborating the left\n * and right sides, and creating one of a variety of different NetExpr\n * types.\n */\nNetExpr* PEBinary::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t  unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      ivl_assert(*this, left_);\n      ivl_assert(*this, right_);\n\n\t// Handle the special case that one of the operands is a real\n\t// value and the other is a vector type. In that case,\n\t// elaborate the vectorable argument as self-determined.\n        // Propagate the expression type (signed/unsigned) down to\n        // any context-determined operands.\n      unsigned l_width = expr_wid;\n      unsigned r_width = expr_wid;\n      if (left_->expr_type()==IVL_VT_REAL\n\t  && type_is_vectorable(right_->expr_type())) {\n\t    r_width = right_->expr_width();\n      } else {\n            right_->cast_signed(signed_flag_);\n      }\n      if (right_->expr_type()==IVL_VT_REAL\n\t  && type_is_vectorable(left_->expr_type())) {\n\t    l_width = left_->expr_width();\n      } else {\n            left_->cast_signed(signed_flag_);\n      }\n\n      NetExpr*lp =  left_->elaborate_expr(des, scope, l_width, flags);\n      NetExpr*rp = right_->elaborate_expr(des, scope, r_width, flags);\n      if ((lp == 0) || (rp == 0)) {\n\t    delete lp;\n\t    delete rp;\n\t    return 0;\n      }\n\n      return elaborate_expr_base_(des, lp, rp, expr_wid);\n}\n\n/*\n * This is the common elaboration of the operator. It presumes that the\n * operands are elaborated as necessary, and all I need to do is make\n * the correct NetEBinary object and connect the parameters.\n */\nNetExpr* PEBinary::elaborate_expr_base_(Design*des,\n\t\t\t\t\tNetExpr*lp, NetExpr*rp,\n\t\t\t\t\tunsigned expr_wid) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: elaborate expression \"\n\t\t << *this << \" expr_width=\" << expr_wid << endl;\n      }\n\n      NetExpr*tmp;\n\n      switch (op_) {\n\t  default:\n\t    tmp = new NetEBinary(op_, lp, rp, expr_wid, signed_flag_);\n\t    tmp->set_line(*this);\n\t    break;\n\n\t  case 'a':\n\t  case 'o':\n\t  case 'q':\n\t  case 'Q':\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Elaboration of \" << human_readable_op(op_)\n\t\t << \" Should have been handled in NetEBLogic::elaborate.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n\n\t  case 'p':\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Elaboration of \" << human_readable_op(op_)\n\t\t << \" Should have been handled in NetEBPower::elaborate.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n\n\t  case '*':\n\t    tmp = elaborate_expr_base_mult_(des, lp, rp, expr_wid);\n\t    break;\n\n\t  case '%':\n\t  case '/':\n\t    tmp = elaborate_expr_base_div_(des, lp, rp, expr_wid);\n\t    break;\n\n\t  case 'l':\n\t  case 'r':\n\t  case 'R':\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Elaboration of \" << human_readable_op(op_)\n\t\t << \" Should have been handled in NetEBShift::elaborate.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n\n\t  case '^':\n\t  case '&':\n\t  case '|':\n\t  case 'O': // NOR (~|)\n\t  case 'A': // NAND (~&)\n\t  case 'X':\n\t    tmp = elaborate_expr_base_bits_(des, lp, rp, expr_wid);\n\t    break;\n\n\t  case '+':\n\t  case '-':\n\t    tmp = new NetEBAdd(op_, lp, rp, expr_wid, signed_flag_);\n\t    tmp->set_line(*this);\n\t    break;\n\n\t  case 'E': /* === */\n\t  case 'N': /* !== */\n\t  case 'e': /* == */\n\t  case 'n': /* != */\n\t  case 'L': /* <= */\n\t  case 'G': /* >= */\n\t  case '<':\n\t  case '>':\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Elaboration of \" << human_readable_op(op_)\n\t\t << \" Should have been handled in NetEBComp::elaborate.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n\n\t  case 'm': // min(l,r)\n\t  case 'M': // max(l,r)\n\t    tmp = new NetEBMinMax(op_, lp, rp, expr_wid, signed_flag_);\n\t    tmp->set_line(*this);\n\t    break;\n      }\n\n      return tmp;\n}\n\nNetExpr* PEBinary::elaborate_expr_base_bits_(Design*des,\n\t\t\t\t\t     NetExpr*lp, NetExpr*rp,\n\t\t\t\t\t     unsigned expr_wid) const\n{\n      if (lp->expr_type() == IVL_VT_REAL || rp->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: \"\n\t         << human_readable_op(op_)\n\t         << \" operator may not have REAL operands.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetEBBits*tmp = new NetEBBits(op_, lp, rp, expr_wid, signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nNetExpr* PEBinary::elaborate_expr_base_div_(Design*des,\n\t\t\t\t\t    NetExpr*lp, NetExpr*rp,\n\t\t\t\t\t    unsigned expr_wid) const\n{\n\t/* The % operator does not support real arguments in\n\t   baseline Verilog. But we allow it in our extended\n\t   form of Verilog. */\n      if (op_ == '%' && ! gn_icarus_misc_flag) {\n\t    if (lp->expr_type() == IVL_VT_REAL ||\n\t\trp->expr_type() == IVL_VT_REAL) {\n\t\t  cerr << get_fileline() << \": error: Modulus operator \"\n\t\t\t\"may not have REAL operands.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n\n      NetEBDiv*tmp = new NetEBDiv(op_, lp, rp, expr_wid, signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nNetExpr* PEBinary::elaborate_expr_base_mult_(Design*,\n\t\t\t\t\t     NetExpr*lp, NetExpr*rp,\n\t\t\t\t\t     unsigned expr_wid) const\n{\n\t// Keep constants on the right side.\n      if (dynamic_cast<NetEConst*>(lp)) {\n\t    NetExpr*tmp = lp;\n\t    lp = rp;\n\t    rp = tmp;\n      }\n\n\t// Handle a few special case multiplies against constants.\n      if (NetEConst*rp_const = dynamic_cast<NetEConst*> (rp)) {\n\t    verinum rp_val = rp_const->value();\n\n\t    if (!rp_val.is_defined() && (lp->expr_type() == IVL_VT_LOGIC)) {\n\t\t  NetEConst*tmp = make_const_x(expr_wid);\n                  tmp->cast_signed(signed_flag_);\n                  tmp->set_line(*this);\n\n\t\t  return tmp;\n\t    }\n\n\t    if (rp_val.is_zero() && (lp->expr_type() == IVL_VT_BOOL)) {\n\t\t  NetEConst*tmp = make_const_0(expr_wid);\n                  tmp->cast_signed(signed_flag_);\n                  tmp->set_line(*this);\n\n\t\t  return tmp;\n\t    }\n      }\n\n      NetEBMult*tmp = new NetEBMult(op_, lp, rp, expr_wid, signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nunsigned PEBComp::test_width(Design*des, NetScope*scope, width_mode_t&)\n{\n      ivl_assert(*this, left_);\n      ivl_assert(*this, right_);\n\n\t// The width and type of a comparison are fixed and well known.\n      expr_type_   = IVL_VT_LOGIC;\n      expr_width_  = 1;\n      min_width_   = 1;\n      signed_flag_ = false;\n\n\t// The widths of the operands are semi-self-determined. They\n        // affect each other, but not the result.\n      width_mode_t mode = SIZED;\n\n      unsigned r_width = right_->test_width(des, scope, mode);\n\n      width_mode_t saved_mode = mode;\n\n      unsigned l_width = left_->test_width(des, scope, mode);\n\n        // If the width mode changed, retest the right operand, as it\n        // may choose a different width if it is in a lossless context.\n      if ((mode >= LOSSLESS) && (saved_mode < LOSSLESS))\n\t    r_width = right_->test_width(des, scope, mode);\n\n      ivl_variable_type_t l_type =  left_->expr_type();\n      ivl_variable_type_t r_type = right_->expr_type();\n\n      l_width_ = l_width;\n      if (type_is_vectorable(l_type) && (r_width > l_width))\n\t    l_width_ = r_width;\n\n      r_width_ = r_width;\n      if (type_is_vectorable(r_type) && (l_width > r_width))\n\t    r_width_ = l_width;\n\n\t// If the expression is lossless and smaller than the integer\n\t// minimum, then tweak the size up.\n\t// NOTE: I really would rather try to figure out what it would\n\t// take to get expand the sub-expressions so that they are\n\t// exactly the right width to behave just like infinite\n\t// width. I suspect that adding 1 more is sufficient in all\n\t// cases, but I'm not certain. Ideas?\n      if (mode >= EXPAND) {\n            if (type_is_vectorable(l_type) && (l_width_ < integer_width))\n\t          l_width_ += 1;\n            if (type_is_vectorable(r_type) && (r_width_ < integer_width))\n\t          r_width_ += 1;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEBComp::test_width: \"\n\t\t << \"Comparison expression operands are \"\n\t\t << l_type << \" \" << l_width << \" bits and \"\n\t\t << r_type << \" \" << r_width << \" bits. Resorting to \"\n\t\t << l_width_ << \" bits and \"\n\t\t << r_width_ << \" bits.\" << endl;\n      }\n\n      switch (op_) {\n\tcase 'e': /* == */\n\tcase 'n': /* != */\n\tcase 'E': /* === */\n\tcase 'N': /* !== */\n\t    if ((l_type == IVL_VT_CLASS || r_type == IVL_VT_CLASS) &&\n\t        l_type != r_type) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Both arguments (\"<< l_type << \", \" << r_type\n\t\t       << \") must be class/null for '\"\n\t\t       << human_readable_op(op_) << \"' operator.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    break;\n\tdefault:\n\t    if (l_type == IVL_VT_CLASS || r_type == IVL_VT_CLASS) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Class/null is not allowed with the '\"\n\t\t       << human_readable_op(op_) << \"' operator.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n\n\n      return expr_width_;\n}\n\nNetExpr* PEBComp::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      ivl_assert(*this, left_);\n      ivl_assert(*this, right_);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEBComp::elaborate_expr: \"\n\t\t << \"Left expression: \" << *left_ << endl;\n\t    cerr << get_fileline() << \": PEBComp::elaborate_expr: \"\n\t\t << \"Right expression: \" << *right_ << endl;\n\t    cerr << get_fileline() << \": PEBComp::elaborate_expr: \"\n\t\t << \"op_: \" << human_readable_op(op_)\n\t\t << \", expr_wid=\" << expr_wid\n\t\t << \", flags=0x\" << hex << flags << dec << endl;\n      }\n\n        // Propagate the comparison type (signed/unsigned) down to\n        // the operands.\n      if (type_is_vectorable(left_->expr_type()) && !left_->has_sign())\n\t    right_->cast_signed(false);\n      if (type_is_vectorable(right_->expr_type()) && !right_->has_sign())\n\t    left_->cast_signed(false);\n\n      NetExpr*lp =  left_->elaborate_expr(des, scope, l_width_, flags);\n      if (lp && debug_elaborate) {\n\t    cerr << get_fileline() << \": PEBComp::elaborate_expr: \"\n\t\t << \"Elaborated left_: \" << *lp << endl;\n      }\n      NetExpr*rp = right_->elaborate_expr(des, scope, r_width_, flags);\n      if (rp && debug_elaborate) {\n\t    cerr << get_fileline() << \": PEBComp::elaborate_expr: \"\n\t\t << \"Elaborated right_: \" << *rp << endl;\n      }\n\n      if ((lp == 0) || (rp == 0)) {\n\t    delete lp;\n\t    delete rp;\n\t    return 0;\n      }\n\n      eval_expr(lp, l_width_);\n      eval_expr(rp, r_width_);\n\n\t// Handle some operand-specific special cases...\n      switch (op_) {\n\t  case 'E': /* === */\n\t  case 'N': /* !== */\n\t    if (lp->expr_type() == IVL_VT_REAL ||\n\t\tlp->expr_type() == IVL_VT_STRING ||\n\t\trp->expr_type() == IVL_VT_REAL ||\n\t\trp->expr_type() == IVL_VT_STRING) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << human_readable_op(op_)\n\t\t       << \" operator may not have REAL or STRING operands.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    break;\n\t  case 'w': /* ==? */\n\t  case 'W': /* !=? */\n\t    if ((lp->expr_type() != IVL_VT_BOOL && lp->expr_type() != IVL_VT_LOGIC) ||\n\t\t(rp->expr_type() != IVL_VT_BOOL && rp->expr_type() != IVL_VT_LOGIC)) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << human_readable_op(op_)\n\t\t       << \" operator may only have INTEGRAL operands.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    break;\n\t  default:\n\t    break;\n      }\n\n      NetExpr*tmp = new NetEBComp(op_, lp, rp);\n      tmp->set_line(*this);\n\n      return pad_to_width(tmp, expr_wid, signed_flag_, *this);\n}\n\nunsigned PEBLogic::test_width(Design*, NetScope*, width_mode_t&)\n{\n\t// The width and type of a logical operation are fixed.\n      expr_type_   = IVL_VT_LOGIC;\n      expr_width_  = 1;\n      min_width_   = 1;\n      signed_flag_ = false;\n\n        // The widths of the operands are self determined. We don't need\n        // them now, so they can be tested when they are elaborated.\n\n      return expr_width_;\n}\n\nNetExpr*PEBLogic::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t unsigned expr_wid, unsigned flags) const\n{\n      ivl_assert(*this, left_);\n      ivl_assert(*this, right_);\n\n      bool need_const = NEED_CONST & flags;\n      NetExpr*lp = elab_and_eval(des, scope,  left_, -1, need_const);\n      NetExpr*rp = elab_and_eval(des, scope, right_, -1, need_const);\n      if ((lp == 0) || (rp == 0)) {\n\t    delete lp;\n\t    delete rp;\n\t    return 0;\n      }\n\n      lp = condition_reduce(lp);\n      rp = condition_reduce(rp);\n\n      NetExpr*tmp = new NetEBLogic(op_, lp, rp);\n      tmp->set_line(*this);\n\n      return pad_to_width(tmp, expr_wid, signed_flag_, *this);\n}\n\nunsigned PEBLeftWidth::test_width(Design*des, NetScope*scope, width_mode_t&mode)\n{\n      ivl_assert(*this, left_);\n      ivl_assert(*this, right_);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEBLeftWidth::test_width: \"\n\t\t << \"op_=\" << op_\n\t\t << \", left_=\" << *left_\n\t\t << \", right_=\" << *right_\n\t\t << \", mode=\" << width_mode_name(mode) << endl;\n      }\n\n        // The right operand is self determined. Test its type and\n        // width for use later. We only need to know its width now\n        // if the left operand is unsized and we need to calculate\n        // the lossless width.\n      width_mode_t r_mode = SIZED;\n      unsigned r_width = right_->test_width(des, scope, r_mode);\n\n\t// The left operand is what will determine the size of the\n\t// expression. The l_mode will be converted to UNSIZED if the\n\t// expression does not have a well-determined size.\n      width_mode_t l_mode = SIZED;\n      expr_width_  = left_->test_width(des, scope, l_mode);\n      expr_type_   = left_->expr_type();\n      signed_flag_ = left_->has_sign();\n\n      if (expr_type_ == IVL_VT_CLASS || right_->expr_type() == IVL_VT_CLASS) {\n\t    cerr << get_fileline() << \": error: \"\n\t         << \"Class/null is not allowed with the '\"\n\t         << human_readable_op(op_) << \"' operator.\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (mode==SIZED)\n\t    mode = l_mode;\n\n\t// The left operand width defines the size of the\n\t// expression. If the expression has a well-defined size, the\n\t// left_->test_width() above would have set mode==SIZED and we\n\t// can skip a lot of stuff. But if the mode is an undetermined\n\t// size, we need to figure out what we really want to keep a\n\t// lossless value. That's what the following if(...) {...} is\n\t// all about.\n      if ((mode >= EXPAND) && type_is_vectorable(expr_type_)) {\n\n              // We need to make our best guess at the right operand\n              // value, to minimize the calculated width. This is\n              // particularly important for the power operator...\n\n              // Start off by assuming the maximum value for the\n              // type and width of the right operand.\n            long r_val = LONG_MAX;\n            if (r_width < sizeof(long)*8) {\n                  r_val = (1UL << r_width) - 1UL;\n                  if ((op_ == 'p') && right_->has_sign())\n                        r_val >>= 1;\n            }\n\n              // If the right operand is constant, we can use the\n              // actual value.\n            NetExpr*rp = right_->elaborate_expr(des, scope, r_width, NO_FLAGS);\n            if (rp) {\n                  eval_expr(rp, r_width);\n            } else {\n                  // error recovery\n                  PEVoid*tmp = new PEVoid();\n                  tmp->set_line(*this);\n                  delete right_;\n                  right_ = tmp;\n            }\n            NetEConst*rc = dynamic_cast<NetEConst*> (rp);\n\t      // Adjust the expression width that can be converter depending\n\t      // on if the R-value is signed or not.\n\t    unsigned c_width = sizeof(long)*8;\n\t    if (! right_->has_sign()) c_width -= 1;\n\t    if (rc && (r_width <= c_width)) r_val = rc->value().as_long();\n\n\t    if (debug_elaborate && rc) {\n\t\t  cerr << get_fileline() << \": PEBLeftWidth::test_width: \"\n\t\t       << \"Evaluated rc=\" << *rc\n\t\t       << \", r_val=\" << r_val\n\t\t       << \", width_cap=\" << width_cap << endl;\n\t    }\n\n              // Clip to a sensible range to avoid underflow/overflow\n              // in the following calculations.\n            if (r_val < 0)\n                  r_val = 0;\n            if ((unsigned long)r_val > width_cap)\n                  r_val = width_cap;\n\n              // If the left operand is a simple unsized number, we\n              // can calculate the actual width required for the power\n              // operator.\n            PENumber*lc = dynamic_cast<PENumber*> (left_);\n\n              // Now calculate the lossless width.\n            unsigned use_width = expr_width_;\n            switch (op_) {\n                case 'l': // <<\n\t\t  if (l_mode != SIZED)\n\t\t\tuse_width += (unsigned)r_val;\n                  break;\n\n                case 'r': // >>\n                case 'R': // >>>\n                    // A logical shift will effectively coerce a signed\n                    // operand to unsigned. We have to assume an arithmetic\n                    // shift may do the same, as we don't yet know the final\n                    // expression type.\n                  if ((mode == LOSSLESS) && signed_flag_)\n                        mode = UPSIZE;\n                  break;\n\n                case 'p': // **\n                  if (lc && rc) {\n                        verinum result = pow(lc->value(), rc->value());\n                        use_width = max(use_width, result.len());\n                  } else {\n                        if (signed_flag_) use_width -= 1;\n                        use_width *= (unsigned)r_val;\n                        if (signed_flag_) use_width += 2;\n                  }\n                  break;\n\n                default:\n                  cerr << get_fileline() << \": internal error: \"\n                       << \"Unexpected opcode \" << human_readable_op(op_)\n                       << \" in PEBLeftWidth::test_width.\" << endl;\n                  des->errors += 1;\n            }\n\n              // If the right operand is not constant, we could end up\n              // grossly overestimating the required width. So in this\n              // case, don't expand beyond the width of an integer\n              // (which meets the requirements of the standard).\n            if ((rc == 0) && (use_width > expr_width_) && (use_width > integer_width))\n                  use_width = integer_width;\n\n\t    if (use_width >= width_cap) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t       << \"Unsized expression (\" << *this << \")\"\n\t\t       << \" expanded beyond and was clipped to \" << use_width\n\t\t       << \" bits. Try using sized operands.\" << endl;\n\t    }\n            expr_width_ = use_width;\n      }\n\n      if (op_ == 'l')\n            min_width_ = left_->min_width();\n      else\n            min_width_ = UINT_MAX; // disable width pruning\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEBLeftWidth::test_width: \"\n\t\t << \"Done calculating expr_width_=\" << expr_width_\n\t\t << \", min_width_=\" << min_width_\n\t\t << \", mode=\" << width_mode_name(mode) << endl;\n      }\n\n      return fix_width_(mode);\n}\n\nNetExpr*PEBLeftWidth::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t     unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      ivl_assert(*this, left_);\n\n        // The left operand is always context determined, so propagate\n        // down the expression type (signed/unsigned).\n      left_->cast_signed(signed_flag_);\n\n      unsigned r_width = right_->expr_width();\n\n      NetExpr*lp =  left_->elaborate_expr(des, scope, expr_wid, flags);\n      NetExpr*rp = right_->elaborate_expr(des, scope, r_width,  flags);\n      if (lp == 0 || rp == 0) {\n\t    delete lp;\n\t    delete rp;\n\t    return 0;\n      }\n\n        // For shift operations, the right operand is always treated as\n        // unsigned, so coerce it if necessary.\n      if ((op_ != 'p') && rp->has_sign()) {\n            rp = new NetESelect(rp, 0, rp->expr_width());\n            rp->cast_signed(false);\n            rp->set_line(*this);\n      }\n\n      eval_expr(lp, expr_wid);\n      eval_expr(rp, r_width);\n\n      return elaborate_expr_leaf(des, lp, rp, expr_wid);\n}\n\nNetExpr*PEBPower::elaborate_expr_leaf(Design*, NetExpr*lp, NetExpr*rp,\n\t\t\t\t      unsigned expr_wid) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: elaborate expression \"\n\t\t << *this << \" expr_wid=\" << expr_wid << endl;\n      }\n\n      NetExpr*tmp = new NetEBPow(op_, lp, rp, expr_wid, signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nstatic unsigned int sign_cast_width(Design*des, NetScope*scope, PExpr &expr,\n\t\t\t\t    PExpr::width_mode_t&mode)\n{\n      unsigned int width;\n\n      // The argument type/width is self-determined, but affects\n      // the result width.\n      PExpr::width_mode_t arg_mode = PExpr::SIZED;\n      width = expr.test_width(des, scope, arg_mode);\n\n      if ((arg_mode >= PExpr::EXPAND) && type_is_vectorable(expr.expr_type())) {\n\t    if (mode < PExpr::LOSSLESS)\n\t\t  mode = PExpr::LOSSLESS;\n\t    if (width < integer_width)\n\t\t  width = integer_width;\n     }\n\n     return width;\n}\n\nNetExpr*PEBShift::elaborate_expr_leaf(Design*des, NetExpr*lp, NetExpr*rp,\n\t\t\t\t      unsigned expr_wid) const\n{\n      switch (op_) {\n\t  case 'l': // <<\n\t  case 'r': // >>\n\t  case 'R': // >>>\n\t    break;\n\n\t  default:\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Unexpected opcode \" << human_readable_op(op_)\n\t\t << \" in PEBShift::elaborate_expr_leaf.\" << endl;\n\t    des->errors += 1;\n            return 0;\n      }\n\n      if (lp->expr_type() == IVL_VT_REAL || rp->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: \"\n\t         << human_readable_op(op_)\n\t         << \" operator may not have REAL operands.\" << endl;\n\t    des->errors += 1;\n            delete lp;\n            delete rp;\n\t    return 0;\n      }\n\n      NetExpr*tmp;\n\n\t// If the left expression is constant, then there are some\n\t// special cases we can work with. If the left expression is\n\t// not constant, but the right expression is constant, then\n\t// there are some other interesting cases. But if neither are\n\t// constant, then there is the general case.\n\n      if (NetEConst*lpc = dynamic_cast<NetEConst*> (lp)) {\n\n\t      // Special case: The left expression is zero. If the\n\t      // shift value contains no 'x' or 'z' bits, the result\n\t      // is going to be zero.\n\t    if (lpc->value().is_defined() && lpc->value().is_zero()\n\t\t&& (rp->expr_type() == IVL_VT_BOOL)) {\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Shift of zero always returns zero.\"\n\t\t\t     << \" Elaborate as constant zero.\" << endl;\n\n\t\t  tmp = make_const_0(expr_wid);\n                  tmp->cast_signed(signed_flag_);\n                  tmp->set_line(*this);\n\n                  return tmp;\n            }\n\n      } else if (NetEConst*rpc = dynamic_cast<NetEConst*> (rp)) {\n\n              // Special case: The shift value contains 'x' or 'z' bits.\n              // Elaborate as a constant-x.\n            if (!rpc->value().is_defined()) {\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Shift by undefined value. \"\n\t\t\t     << \"Elaborate as constant 'x'.\" << endl;\n\n\t\t  tmp = make_const_x(expr_wid);\n                  tmp->cast_signed(signed_flag_);\n                  tmp->set_line(*this);\n\n                  delete lp;\n                  delete rp;\n                  return tmp;\n\t    }\n\n\t    unsigned long shift = rpc->value().as_ulong();\n\n              // Special case: The shift is zero. The result is simply\n              // the left operand.\n\t    if (shift == 0) {\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Shift by zero. Elaborate as the \"\n\t\t\t     << \"left hand operand.\" << endl;\n\n                  delete rp;\n                  return lp;\n\t    }\n\n\t      // Special case: the shift is at least the size of the entire\n\t      // left operand, and the shift is a signed right shift.\n              // Elaborate as a replication of the top bit of the left\n              // expression.\n\t    if ((op_=='R' && signed_flag_) && (shift >= expr_wid)) {\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Value signed-right-shifted \" << shift\n\t\t\t     << \" beyond width of \" << expr_wid\n\t\t\t     << \". Elaborate as replicated top bit.\" << endl;\n\n\t\t  tmp = new NetEConst(verinum(expr_wid-1));\n\t\t  tmp->set_line(*this);\n\t\t  tmp = new NetESelect(lp, tmp, 1);\n\t\t  tmp->set_line(*this);\n\t\t  tmp = pad_to_width(tmp, expr_wid, true, *this);\n\n                  delete rp;\n\t\t  return tmp;\n\t    }\n\n\t      // Special case: The shift is at least the size of the entire\n\t      // left operand, and the shift is not a signed right shift\n              // (which is caught by the previous special case). Elaborate\n              // as a constant-0.\n\t    if (shift >= expr_wid) {\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Value shifted \" << shift\n\t\t\t     << \" beyond width of \" << expr_wid\n\t\t\t     << \". Elaborate as constant zero.\" << endl;\n\n\t\t  tmp = make_const_0(expr_wid);\n                  tmp->cast_signed(signed_flag_);\n\t\t  tmp->set_line(*this);\n\n                  delete lp;\n                  delete rp;\n\t\t  return tmp;\n\t    }\n      }\n\n\t// Fallback, handle the general case.\n      tmp = new NetEBShift(op_, lp, rp, expr_wid, signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nunsigned PECallFunction::test_width_sfunc_(Design*des, NetScope*scope,\n                                           width_mode_t&mode)\n{\n      perm_string name = peek_tail_name(path_);\n\n      if (name==\"$ivlh_to_unsigned\") {\n\t    ivl_assert(*this, parms_.size() == 2);\n\t      // The Icarus Verilog specific $ivlh_to_unsigned() system\n\t      // task takes a second argument which is the output\n\t      // size. This can be an arbitrary constant function.\n\t    PExpr *pexpr = parms_[1].parm;\n\t    if (pexpr == 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Missing $ivlh_to_unsigned width.\" << endl;\n\t\t  return 0;\n\t    }\n\n\t    NetExpr*nexpr = elab_and_eval(des, scope, pexpr, -1, true);\n\t    if (nexpr == 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Unable to evaluate \" << name\n\t\t       << \" width argument: \" << *pexpr << endl;\n\t\t  return 0;\n\t    }\n\n\t    long value = 0;\n\t    bool rc = eval_as_long(value, nexpr);\n\t    ivl_assert(*this, rc && value>=0);\n\n\t      // The argument width is self-determined and doesn't\n\t      // affect the result width.\n\t    width_mode_t arg_mode = SIZED;\n\t    parms_[0].parm->test_width(des, scope, arg_mode);\n\n\t    expr_type_  = pexpr->expr_type();\n\t    expr_width_ = value;\n\t    min_width_  = value;\n\t    signed_flag_= false;\n\t    return expr_width_;\n      }\n\n      if (name==\"$signed\" || name==\"$unsigned\") {\n\t    PExpr *expr = parms_[0].parm;\n\t    if (expr == 0)\n\t\t  return 0;\n\n\t    expr_width_  = sign_cast_width(des, scope, *expr, mode);\n\t    expr_type_   = expr->expr_type();\n            min_width_   = expr->min_width();\n            signed_flag_ = (name[1] == 's');\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: \" << name\n\t\t       << \" argument width = \" << expr_width_ << \".\" << endl;\n\n            return expr_width_;\n      }\n\n      if (name==\"$sizeof\" || name==\"$bits\") {\n\t    PExpr *expr = parms_[0].parm;\n\t    if (expr == 0)\n\t\t  return 0;\n\n\t    if (! dynamic_cast<PETypename*>(expr)) {\n\t\t    // The argument type/width is self-determined and doesn't\n\t\t    // affect the result type/width. Note that if the\n\t\t    // argument is a type name (a special case) then\n\t\t    // don't bother with this step.\n\t\t  width_mode_t arg_mode = SIZED;\n\t\t  expr->test_width(des, scope, arg_mode);\n\t    }\n\n\t    expr_type_   = IVL_VT_LOGIC;\n\t    expr_width_  = integer_width;\n\t    min_width_   = integer_width;\n            signed_flag_ = true;\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"test_width of \" << name << \" returns test_width\"\n\t\t       << \" of compiler integer.\" << endl;\n\n\t    return expr_width_;\n      }\n\n      if (name==\"$is_signed\") {\n\t    PExpr *expr = parms_[0].parm;\n\t    if (expr == 0)\n\t\t  return 0;\n\n              // The argument type/width is self-determined and doesn't\n              // affect the result type/width.\n            width_mode_t arg_mode = SIZED;\n\t    expr->test_width(des, scope, arg_mode);\n\n\t    expr_type_   = IVL_VT_BOOL;\n\t    expr_width_  = 1;\n\t    min_width_   = 1;\n            signed_flag_ = false;\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"test_width of $is_signed returns test_width\"\n\t\t       << \" of 1.\" << endl;\n\n\t    return expr_width_;\n      }\n\n\t/* Get the return type of the system function by looking it up\n\t   in the sfunc_table. */\n      const struct sfunc_return_type*sfunc_info = lookup_sys_func(name);\n\n      expr_type_   = sfunc_info->type;\n      expr_width_  = sfunc_info->wid;\n      min_width_   = expr_width_;\n      signed_flag_ = sfunc_info->signed_flag;\n\n      is_overridden_ = sfunc_info->override_flag;\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"test_width of system function \" << name\n\t\t << \" returns wid=\" << expr_width_\n\t\t << \", type=\" << expr_type_ << \".\" << endl;\n\n      return expr_width_;\n}\n\n/*\n * Get the function definition from the scope that we believe to be a\n * function. If it is not, return 0. If it is, handle the special case that we\n * may be still elaborating things. For example:\n *\n *    localparam foo = func(...)\n *\n * In this case, the function is not necessarily elaborated yet, and we need\n * to force enough elaboration that we can get a definition.\n */\nstatic NetFuncDef* find_function_definition(Design*des, NetScope*,\n\t\t\t\t\t    NetScope*func)\n{\n      if (func && (func->type() == NetScope::FUNC)) {\n\t    if (func->elab_stage() < 2) {\n\t\t  func->need_const_func(true);\n\t\t  const PFunction*pfunc = func->func_pform();\n\t\t  ivl_assert(*func, pfunc);\n\t\t  pfunc->elaborate_sig(des, func);\n\t    }\n\t    return func->func_def();\n      }\n      return 0;\n}\n\nunsigned PECallFunction::test_width_method_(Design*, NetScope*,\n\t\t\t\t\t    symbol_search_results&search_results,\n\t\t\t\t\t    width_mode_t&)\n{\n      if (!gn_system_verilog())\n\t    return 0;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t << \"search_results.path_head: \" << search_results.path_head << endl;\n\t    cerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t << \"search_results.path_tail: \" << search_results.path_tail << endl;\n\t    if (search_results.net)\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t       << \"search_results.net->data_type: \" << search_results.net->data_type() << endl;\n\t    if (search_results.net && search_results.net->net_type())\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t       << \"search_results.net->net_type: \" << *search_results.net->net_type() << endl;\n      }\n\n      // Don't support multiple chained methods yet.\n      if (search_results.path_tail.size() > 1) {\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t       << \"Chained path tail (\" << search_results.path_tail\n\t\t       << \") not supported.\" << endl;\n\t    }\n\t    return 0;\n      }\n\n      ivl_assert(*this, search_results.path_tail.size() == 1);\n      perm_string method_name = search_results.path_tail.back().name;\n\n      // Dynamic array variable without a select expression. The method\n      // applies to the array itself, and not to the object that might be\n      // indexed from it. So return\n      // the expr_width for the return value of the queue method. For example:\n      //    <scope>.x.size();\n      // In this example, x is a dynamic array.\n      if (search_results.net && search_results.net->data_type()==IVL_VT_DARRAY\n\t  && search_results.path_head.back().index.empty()) {\n\n\t    NetNet*net = search_results.net;\n\t    const netdarray_t*darray = net->darray_type();\n\t    ivl_assert(*this, darray);\n\n\t    if (method_name == \"size\") {\n\t\t  expr_type_  = IVL_VT_BOOL;\n\t\t  expr_width_ = 32;\n\t\t  min_width_  = expr_width_;\n\t\t  signed_flag_= true;\n\t\t  return expr_width_;\n\t    }\n\n\t    return 0;\n      }\n\n      // Queue variable without a select expression. The method applies to the\n      // queue, and not to the object that might be indexed from it. So return\n      // the expr_width for the return value of the queue method. For example:\n      //    <scope>.x.size();\n      // In this example, x is a queue.\n      if (search_results.net && search_results.net->data_type()==IVL_VT_QUEUE\n\t  && search_results.path_head.back().index.empty()) {\n\n\t    NetNet*net = search_results.net;\n\t    const netdarray_t*darray = net->darray_type();\n\t    ivl_assert(*this, darray);\n\n\t    if (method_name == \"size\") {\n\t\t  expr_type_  = IVL_VT_BOOL;\n\t\t  expr_width_ = 32;\n\t\t  min_width_  = expr_width_;\n\t\t  signed_flag_= true;\n\t\t  return expr_width_;\n\t    }\n\n\t    if (method_name==\"pop_back\" || method_name==\"pop_front\") {\n\t\t  expr_type_  = darray->element_base_type();\n\t\t  expr_width_ = darray->element_width();\n\t\t  min_width_  = expr_width_;\n\t\t  signed_flag_= darray->get_signed();\n\t\t  return expr_width_;\n\t    }\n\n\t    return 0;\n      }\n\n      // Queue variable with a select expression. The type of this expression\n      // is the type of the object that will interpret the method. For\n      // example:\n      //    <scope>.x[e].len()\n      // If for example x is a queue of strings, then x[e] is a string and\n      // x[e].len() is the length of the string.\n      if (search_results.net\n\t  && (search_results.net->data_type()==IVL_VT_QUEUE || search_results.net->data_type()==IVL_VT_DARRAY)\n\t  && search_results.path_head.back().index.size()) {\n\n\t    NetNet*net = search_results.net;\n\t    const netdarray_t*darray = net->darray_type();\n\t    ivl_assert(*this, darray);\n\n\t    if (darray->element_base_type()==IVL_VT_STRING && method_name==\"atohex\") {\n\t\t  expr_type_  = IVL_VT_BOOL;\n\t\t  expr_width_ = integer_width;\n\t\t  min_width_  = integer_width;\n\t\t  signed_flag_ = true;\n\t\t  return expr_width_;\n\t    }\n\n\t    if (darray->element_base_type()==IVL_VT_STRING && method_name==\"atoi\") {\n\t\t  expr_type_  = IVL_VT_BOOL;\n\t\t  expr_width_ = integer_width;\n\t\t  min_width_  = integer_width;\n\t\t  return expr_width_;\n\t    }\n\n\t    if (darray->element_base_type()==IVL_VT_STRING && method_name==\"len\") {\n\t\t  expr_type_  = IVL_VT_BOOL;\n\t\t  expr_width_ = 32;\n\t\t  min_width_  = 32;\n\t\t  signed_flag_= true;\n\t\t  return expr_width_;\n\t    }\n      }\n\n      // Enumeration variable. Check for the various enumeration methods.\n      if (search_results.net && search_results.net->enumeration()) {\n\t    NetNet*net = search_results.net;\n\t    const netenum_t*enum_type = net->enumeration();\n\n\t    if (method_name==\"first\" || method_name==\"last\"\n\t\t|| method_name==\"prev\" || method_name==\"next\") {\n\t\t  expr_type_  = IVL_VT_BOOL;\n\t\t  expr_width_ = enum_type->packed_width();\n\t\t  min_width_  = expr_width_;\n\t\t  signed_flag_= enum_type->get_signed();\n\t\t  return expr_width_;\n\t    }\n\t    if (method_name==\"num\") {\n\t\t  expr_type_  = IVL_VT_BOOL;\n\t\t  expr_width_ = 32;\n\t\t  min_width_  = expr_width_;\n\t\t  signed_flag_= true;\n\t\t  return expr_width_;\n\t    }\n\t    if (method_name==\"name\") {\n\t\t  expr_type_  = IVL_VT_STRING;\n\t\t  expr_width_ = 1;\n\t\t  min_width_  = 1;\n\t\t  signed_flag_= false;\n\t\t  return expr_width_;\n\t    }\n\t    return 0;\n      }\n\n      // Class variables. In this case, the search found the class instance,\n      // and the scope is the scope where the instance lives. The class method\n      // in turn defines it's own scope. Use that to find the return value.\n      if (search_results.net && search_results.net->data_type()==IVL_VT_CLASS) {\n\t    const netclass_t *class_type = dynamic_cast<const netclass_t*>(search_results.type);\n\t    ivl_assert(*this, class_type);\n\t    NetScope*method = class_type->method_from_name(method_name);\n\n\t    if (method == 0) {\n\t\t  return 0;\n\t    }\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t       << \"Found method \" << scope_path(method) << \"(...)\" << endl;\n\t    }\n\n\t    // Get the return value of the method function.\n\t    if (NetNet*res = method->find_signal(method->basename())) {\n\t\t  expr_type_   = res->data_type();\n\t\t  expr_width_  = res->vector_width();\n\t\t  min_width_   = expr_width_;\n\t\t  signed_flag_ = res->get_signed();\n\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t\t     << \"test_width of class method returns width \" << expr_width_\n\t\t\t     << \", type=\" << expr_type_\n\t\t\t     << \".\" << endl;\n\t\t  }\n\t\t  return expr_width_;\n\t    }\n\t    return 0;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::test_width_method_: \"\n\t\t << \"I give up.\" << endl;\n      }\n      return 0;\n}\n\nunsigned PECallFunction::test_width(Design*des, NetScope*scope,\n                                    width_mode_t&mode)\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t << \"path_: \" << path_ << endl;\n\t    cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t << \"mode: \" << width_mode_name(mode) << endl;\n      }\n\n      if (peek_tail_name(path_)[0] == '$')\n\t    return test_width_sfunc_(des, scope, mode);\n\n      // Search for the symbol. This should turn up a scope.\n      symbol_search_results search_results;\n      bool search_flag = symbol_search(this, des, scope, path_, UINT_MAX, &search_results);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t << \"search_flag: \" << (search_flag? \"true\" : \"false\") << endl;\n\t    if (search_results.scope)\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"search_results.scope: \" << scope_path(search_results.scope) << endl;\n\t    if (search_results.net)\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"search_results.net: \" << search_results.net->name() << endl;\n\t    cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t << \"search_results.path_head: \" << search_results.path_head << endl;\n\t    cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t << \"search_results.path_tail: \" << search_results.path_tail << endl;\n      }\n\n      // Nothing found? Return nothing.\n      if (!search_flag) {\n\t    expr_width_ = 0;\n\t    min_width_ = 0;\n\t    signed_flag_ = false;\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"Not found, returning nil width results.\" << endl;\n\t    }\n\t    return expr_width_;\n      }\n\n      // Catch the special case that this is not a scope, but that we\n      // are in fact in a function calling ourself recursively. For\n      // example:\n      //\n      //   function integer factoral;\n      //      input integer n;\n      //      begin\n      //        if (n > 1)\n      //          factorial = n * factorial(n-1); <== HERE\n      //        else\n      //          factorial = n;\n      //      end\n      //    endfunction\n      //\n      // In this case, the call to factorial within itself will find the\n      // net \"factorial\", but we can notice that the scope is a function\n      // with the same name as the function.\n      if (test_function_return_value(search_results)) {\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"Net \" << search_results.net->name()\n\t\t       << \" is actually a function call to \" << scope_path(search_results.scope)\n\t\t       << \".\" << endl;\n\t    }\n\n\t    NetNet*res = search_results.net;\n\t    expr_type_   = res->data_type();\n\t    expr_width_  = res->vector_width();\n            min_width_   = expr_width_;\n            signed_flag_ = res->get_signed();\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"test_width of function returns width \" << dec << expr_width_\n\t\t       << \", type=\" << expr_type_\n\t\t       << \".\" << endl;\n\n\t    return expr_width_;\n\n      }\n\n      // If the symbol is found, but is not a scope...\n      if (!search_results.is_scope()) {\n\n\t    if (!search_results.path_tail.empty()) {\n\t\t  return test_width_method_(des, scope, search_results, mode);\n\t    }\n\n\t    // I don't know what to do about this.\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"I don't know how to handle non-scopes here.\" << endl;\n\t    }\n\t    return 0;\n      }\n\n\n      NetFuncDef*def = find_function_definition(des, scope, search_results.scope);\n      if (def == 0) {\n\t    // If this is an access function, then the width and\n\t    // type are known by definition.\n\t    if (find_access_function(path_)) {\n\t\t  expr_type_   = IVL_VT_REAL;\n\t\t  expr_width_  = 1;\n\t\t  min_width_   = 1;\n                  signed_flag_ = true;\n\n\t\t  return expr_width_;\n\t    }\n\n\t    // I don't know what to do about this.\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"Scope is not a function.\" << endl;\n\t    }\n\t    return 0;\n      }\n\n      if (def->is_void())\n\t    return 0;\n\n      NetScope*dscope = def->scope();\n      ivl_assert(*this, dscope);\n\n      if (NetNet*res = dscope->find_signal(dscope->basename())) {\n\t    expr_type_   = res->data_type();\n\t    expr_width_  = res->vector_width();\n            min_width_   = expr_width_;\n            signed_flag_ = res->get_signed();\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": PECallFunction::test_width: \"\n\t\t       << \"test_width of function returns width \" << expr_width_\n\t\t       << \", type=\" << expr_type_\n\t\t       << \".\" << endl;\n\n\t    return expr_width_;\n      }\n\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetExpr*PECallFunction::cast_to_width_(NetExpr*expr, unsigned wid) const\n{\n      if (debug_elaborate) {\n            cerr << get_fileline() << \": PECallFunction::cast_to_width_: \"\n\t\t << \"cast to \" << wid\n                 << \" bits \" << (signed_flag_ ? \"signed\" : \"unsigned\")\n\t\t << \" from expr_width()=\" << expr->expr_width() << endl;\n      }\n\n      return cast_to_width(expr, wid, signed_flag_, *this);\n}\n\n/*\n * Given a call to a system function, generate the proper expression\n * nodes to represent the call in the netlist. Since we don't support\n * size_tf functions, make assumptions about widths based on some\n * known function names.\n */\nNetExpr* PECallFunction::elaborate_sfunc_(Design*des, NetScope*scope,\n                                          unsigned expr_wid,\n                                          unsigned flags) const\n{\n      perm_string name = peek_tail_name(path_);\n\n      // System functions don't have named parameters\n      for (const auto &parm : parms_) {\n\t    if (!parm.name.nil()) {\n\t\t  des->errors++;\n\t\t  cerr << parm.get_fileline() << \": error: \"\n\t\t       << \"The system function `\" << name\n\t\t       << \"` has no argument called `\" << parm.name << \"`.\"\n\t\t       << endl;\n\t    }\n      }\n\n\t/* Catch the special case that the system function is the\n\t   $ivl_unsigned function. In this case the second argument is\n\t   the size of the expression, but should already be accounted\n\t   for so treat this very much like the $unsigned() function. */\n      if (name==\"$ivlh_to_unsigned\") {\n\t    ivl_assert(*this, parms_.size()==2);\n\n\t    PExpr *expr = parms_[0].parm;\n\t    ivl_assert(*this, expr);\n\t    NetExpr*sub = expr->elaborate_expr(des, scope, expr->expr_width(), flags);\n\t    return cast_to_width_(sub, expr_wid);\n      }\n\n\t/* Catch the special case that the system function is the $signed\n\t   function. Its argument will be evaluated as a self-determined\n           expression. */\n      if (name==\"$signed\" || name==\"$unsigned\") {\n\t    if ((parms_.size() != 1) || !parms_[0].parm) {\n\t\t  cerr << get_fileline() << \": error: The \" << name\n\t\t       << \" function takes exactly one(1) argument.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n            if (!type_is_vectorable(expr_type_)) {\n\t          cerr << get_fileline() << \": error: The argument to \"\n\t\t       << name << \" must be a vector type.\" << endl;\n\t          des->errors += 1;\n\t          return 0;\n            }\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_sfunc_: \"\n\t\t       << name << \" expression is the argument cast to expr_wid=\" << expr_wid << endl;\n\t    }\n\t    PExpr *expr = parms_[0].parm;\n\t    NetExpr*sub = expr->elaborate_expr(des, scope, expr_width_, flags);\n\n\t    return cast_to_width_(sub, expr_wid);\n      }\n\n\t/* Interpret the internal $sizeof system function to return\n\t   the bit width of the sub-expression. The value of the\n\t   sub-expression is not used, so the expression itself can be\n\t   deleted. */\n      if (name==\"$sizeof\" || name==\"$bits\") {\n\t    if ((parms_.size() != 1) || !parms_[0].parm) {\n\t\t  cerr << get_fileline() << \": error: The \" << name\n\t\t       << \" function takes exactly one(1) argument.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    if (name==\"$sizeof\")\n\t\t  cerr << get_fileline() << \": warning: $sizeof is deprecated.\"\n\t\t       << \" Use $bits() instead.\" << endl;\n\n\t    PExpr *expr = parms_[0].parm;\n\n\t    uint64_t use_width = 0;\n\t    if (PETypename*type_expr = dynamic_cast<PETypename*>(expr)) {\n\t\t  ivl_type_t data_type = type_expr->get_type()->elaborate_type(des, scope);\n\t\t  ivl_assert(*this, data_type);\n\t\t  use_width = 1;\n\t\t  while (const netuarray_t *utype =\n\t\t\t dynamic_cast<const netuarray_t*>(data_type)) {\n\t\t\tuse_width = netrange_width(utype->static_dimensions(),\n\t\t\t                           use_width);\n\t\t\tdata_type = utype->element_type();\n\t\t  }\n\t\t  if (!data_type->packed()) {\n\t\t\tuse_width = 0;\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Invalid data type for $bits().\"\n\t\t\t     << endl;\n\t\t\tdes->errors++;\n\t\t  } else {\n\t\t\tuse_width *= data_type->packed_width();\n\t\t  }\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PECallFunction::elaborate_sfunc_: \"\n\t\t\t     << \" Packed width of type argument is \" << use_width << endl;\n\t\t  }\n\n\t    } else {\n\t\t  use_width = expr->expr_width();\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PECallFunction::elaborate_sfunc_: \"\n\t\t\t     << \" Width of expression argument is \" << use_width << endl;\n\t\t  }\n\t    }\n\n\t    verinum val (use_width, integer_width);\n\t    NetEConst*sub = new NetEConst(val);\n\t    sub->set_line(*this);\n\n\t    return cast_to_width_(sub, expr_wid);\n      }\n\n\t/* Interpret the internal $is_signed system function to return\n\t   a single bit flag -- 1 if the expression is signed, 0\n\t   otherwise. */\n      if (name==\"$is_signed\") {\n\t    if ((parms_.size() != 1) || !parms_[0].parm) {\n\t\t  cerr << get_fileline() << \": error: The \" << name\n\t\t       << \" function takes exactly one(1) argument.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    PExpr *expr = parms_[0].parm;\n\n\t    verinum val (expr->has_sign() ? verinum::V1 : verinum::V0, 1);\n\t    NetEConst*sub = new NetEConst(val);\n\t    sub->set_line(*this);\n\n\t    return cast_to_width_(sub, expr_wid);\n      }\n\n      unsigned nparms = parms_.size();\n\n      NetESFunc*fun = new NetESFunc(name, expr_type_, expr_width_, nparms, is_overridden_);\n      fun->set_line(*this);\n\n      bool need_const = NEED_CONST & flags;\n\n\t/* We don't support evaluating overridden functions. */\n      if (is_overridden_ && (need_const || scope->need_const_func())) {\n\t    cerr << get_fileline() << \": sorry: Cannot evaluate \"\n\t\t    \"overridden system function.\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (is_overridden_ || !fun->is_built_in()) {\n\t    if (scope->need_const_func()) {\n\t\t  cerr << get_fileline() << \": error: \" << name\n\t\t       << \" is not a built-in function, so cannot\"\n\t\t       << \" be used in a constant function.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    scope->is_const_func(false);\n      }\n\n\t/* Now run through the expected parameters. If we find that\n\t   there are missing parameters, print an error message.\n\n\t   While we're at it, try to evaluate the function parameter\n\t   expression as much as possible, and use the reduced\n\t   expression if one is created. */\n\n\t/* These functions can work in a constant context with a signal expression. */\n      if ((nparms == 1) && (dynamic_cast<PEIdent*>(parms_[0].parm))) {\n\t    if (strcmp(name, \"$dimensions\") == 0) need_const = false;\n\t    else if (strcmp(name, \"$high\") == 0) need_const = false;\n\t    else if (strcmp(name, \"$increment\") == 0) need_const = false;\n\t    else if (strcmp(name, \"$left\") == 0) need_const = false;\n\t    else if (strcmp(name, \"$low\") == 0) need_const = false;\n\t    else if (strcmp(name, \"$right\") == 0) need_const = false;\n\t    else if (strcmp(name, \"$size\") == 0) need_const = false;\n\t    else if (strcmp(name, \"$unpacked_dimensions\") == 0) need_const = false;\n      }\n\n      unsigned parm_errors = 0;\n      unsigned missing_parms = 0;\n      for (unsigned idx = 0 ;  idx < nparms ;  idx += 1) {\n\t    PExpr *expr = parms_[idx].parm;\n\t    if (expr) {\n\t\t  NetExpr*tmp = elab_sys_task_arg(des, scope, name, idx,\n                                                  expr, need_const);\n                  if (tmp) {\n                        fun->parm(idx, tmp);\n                  } else {\n                        parm_errors += 1;\n                        fun->parm(idx, 0);\n                  }\n\t    } else {\n\t\t  missing_parms += 1;\n\t\t  fun->parm(idx, 0);\n\t    }\n      }\n\n      if (missing_parms > 0) {\n\t    cerr << get_fileline() << \": error: The function \" << name\n\t\t << \" has been called with missing/empty parameters.\" << endl;\n\t    cerr << get_fileline() << \":      : Verilog doesn't allow \"\n\t\t << \"passing empty parameters to functions.\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (missing_parms || parm_errors)\n            return 0;\n\n      return pad_to_width(fun, expr_wid, signed_flag_, *this);\n}\n\nNetExpr* PECallFunction::elaborate_access_func_(Design*des, NetScope*scope,\n\t\t\t\t\t\tivl_nature_t nature) const\n{\n\t// An access function must have 1 or 2 arguments.\n      ivl_assert(*this, parms_.size()==2 || parms_.size()==1);\n\n      NetBranch*branch = 0;\n\n      if (parms_.size() == 1) {\n\t    PExpr *arg1 = parms_[0].parm;\n\t    PEIdent*arg_ident = dynamic_cast<PEIdent*> (arg1);\n\t    ivl_assert(*this, arg_ident);\n\n\t    const pform_name_t&path = arg_ident->path().name;\n\t    ivl_assert(*this, path.size()==1);\n\t    perm_string name = peek_tail_name(path);\n\n\t    NetNet*sig = scope->find_signal(name);\n\t    ivl_assert(*this, sig);\n\n\t    ivl_discipline_t dis = sig->get_discipline();\n\t    ivl_assert(*this, dis);\n\t    ivl_assert(*this, nature == dis->potential() || nature == dis->flow());\n\n\t    NetNet*gnd = des->find_discipline_reference(dis, scope);\n\n\t    if ( (branch = find_existing_implicit_branch(sig, gnd)) ) {\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Re-use implicit branch from \"\n\t\t\t     << branch->get_fileline() << endl;\n\t    } else {\n\t\t  branch = new NetBranch(dis);\n\t\t  branch->set_line(*this);\n\t\t  connect(branch->pin(0), sig->pin(0));\n\t\t  connect(branch->pin(1), gnd->pin(0));\n\n\t\t  des->add_branch(branch);\n\t\t  join_island(branch);\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Create implicit branch.\" << endl;\n\n\t    }\n\n      } else {\n\t    ivl_assert(*this, 0);\n      }\n\n      NetExpr*tmp = new NetEAccess(branch, nature);\n      tmp->set_line(*this);\n      return tmp;\n}\n\n/*\n * Routine to look for and build enumeration method calls.\n */\nstatic NetExpr* check_for_enum_methods(const LineInfo*li,\n                                       Design*des, NetScope*scope,\n                                       const netenum_t*netenum,\n                                       const pform_scoped_name_t&use_path,\n                                       perm_string method_name,\n                                       NetExpr*expr,\n                                       const std::vector<named_pexpr_t> &parms)\n{\n      if (debug_elaborate) {\n\t    cerr << li->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Check for method \" << method_name\n\t\t << \" of enumeration at \" << netenum->get_fileline()\n\t\t << endl;\n\t    cerr << li->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"use_path=\" << use_path << endl;\n\t    cerr << li->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"expr=\" << *expr << endl;\n      }\n\n      // First, look for some special methods that can be replace with\n      // constant literals. These get properties of the enumeration type, and\n      // so can be fully evaluated at compile time.\n\n      if (method_name == \"num\") {\n\t    // The \"num()\" method returns the number of elements. This is\n\t    // actually a static constant, and can be replaced at compile time\n\t    // with a constant value.\n\t    if (parms.size() != 0) {\n\t\t  cerr << li->get_fileline() << \": error: enumeration \"\n\t\t          \"method \" << use_path << \" does not \"\n\t\t          \"take an argument.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    NetEConst*tmp = make_const_val(netenum->size());\n\t    tmp->set_line(*li);\n\t    delete expr; // The elaborated enum variable is not needed.\n\t    return tmp;\n      }\n\n      if (method_name == \"first\") {\n\t    // The \"first()\" method returns the first enumeration value. This\n\t    // doesn't actually care about the constant value, and instead\n\t    // returns as a constant literal the first value of the enumeration.\n\t    if (parms.size() != 0) {\n\t\t  cerr << li->get_fileline() << \": error: enumeration \"\n\t\t          \"method \" << use_path << \" does not \"\n\t\t          \"take an argument.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    netenum_t::iterator item = netenum->first_name();\n\t    NetEConstEnum*tmp = new NetEConstEnum(item->first, netenum, item->second);\n\t    tmp->set_line(*li);\n\t    delete expr; // The elaborated enum variable is not needed.\n\t    return tmp;\n      }\n\n      if (method_name == \"last\") {\n\t    // The \"last()\" method returns the first enumeration value. This\n\t    // doesn't actually care about the constant value, and instead\n\t    // returns as a constant literal the last value of the enumeration.\n\t    if (parms.size() != 0) {\n\t\t  cerr << li->get_fileline() << \": error: enumeration \"\n\t\t          \"method \" << use_path << \" does not \"\n\t\t          \"take an argument.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    netenum_t::iterator item = netenum->last_name();\n\t    NetEConstEnum*tmp = new NetEConstEnum(item->first, netenum, item->second);\n\t    tmp->set_line(*li);\n\t    delete expr; // The elaborated enum variable is not needed.\n\t    return tmp;\n      }\n\n      NetESFunc*sys_expr;\n\n      if (method_name == \"name\") {\n\t    // The \"name()\" method returns the name of the current enumeration\n\t    // value. The generated system task takes the enumeration\n\t    // definition and the enumeration value. The return value is the\n\t    // string name of the enumeration.\n\t    if (parms.size() != 0) {\n\t\t  cerr << li->get_fileline() << \": error: enumeration \"\n\t\t          \"method \" << use_path << \" does not \"\n\t\t          \"take an argument.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    // Generate the internal system function. Make sure the return\n\t    // value is \"string\" type.\n\t    sys_expr = new NetESFunc(\"$ivl_enum_method$name\",\n\t\t\t\t     &netstring_t::type_string, 2);\n\t    NetENetenum* def = new NetENetenum(netenum);\n\t    def->set_line(*li);\n\t    sys_expr->parm(0, def);\n\t    sys_expr->parm(1, expr);\n\n      } else if (method_name == \"next\" || method_name == \"prev\") {\n\t    static const std::vector<perm_string> parm_names = {\n\t\t  perm_string::literal(\"N\"),\n\t    };\n\t    auto args = map_named_args(des, parm_names, parms);\n\n\t      // Process the method argument if it is available.\n\t    NetExpr *count = nullptr;\n\t    if (args.size() != 0 && args[0]) {\n\t\t  count = elaborate_rval_expr(des, scope, &netvector_t::atom2u32,\n\t\t\t\t\t      args[0]);\n\t\t  if (!count) {\n\t\t\tcerr << li->get_fileline() << \": error: unable to elaborate \"\n\t\t\t\t\"enumeration method argument \" << use_path << \".\"\n\t\t\t     << method_name << \"(\" << args[0] << \").\" << endl;\n\t\t\tdes->errors++;\n\t\t  } else if (NetEEvent *evt = dynamic_cast<NetEEvent*> (count)) {\n\t\t\tcerr << evt->get_fileline() << \": error: An event '\"\n\t\t\t     << evt->event()->name() << \"' cannot be an enumeration \"\n\t\t\t\t\"method argument.\" << endl;\n\t\t\tdes->errors++;\n\t\t  }\n\t    }\n\n\t    // The \"next()\" and \"prev()\" methods returns the next or previous enumeration value.\n\t    if (args.size() > 1) {\n\t\t  cerr << li->get_fileline() << \": error: enumeration \"\n\t\t          \"method \" << use_path << \" takes at \"\n\t\t          \"most one argument.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    const char *func_name;\n\t    if (method_name == \"next\")\n\t\t  func_name = \"$ivl_enum_method$next\";\n\t    else\n\t\t  func_name = \"$ivl_enum_method$prev\";\n\n\t    sys_expr = new NetESFunc(func_name, netenum,\n\t                             2 + (count != nullptr));\n\t    NetENetenum* def = new NetENetenum(netenum);\n\t    def->set_line(*li);\n\t    sys_expr->parm(0, def);\n\t    sys_expr->parm(1, expr);\n\t    if (count) sys_expr->parm(2, count);\n\n      } else {\n\t    // This is an unknown enumeration method.\n\t    cerr << li->get_fileline() << \": error: Unknown enumeration \"\n\t            \"method \" << use_path << \".\" << method_name << \"().\"\n\t         << endl;\n\t    des->errors += 1;\n\t    return expr;\n      }\n\n      sys_expr->set_line(*li);\n\n      if (debug_elaborate) {\n\t    cerr << li->get_fileline() << \": \" << __func__ << \": Generate \"\n\t         << sys_expr->name() << \"(\" << use_path << \")\" << endl;\n      }\n\n      return sys_expr;\n}\n\nbool calculate_part(const LineInfo*li, Design*des, NetScope*scope,\n\t\t    const index_component_t&index, long&off, unsigned long&wid)\n{\n      if (index.sel == index_component_t::SEL_BIT_LAST) {\n\t    cerr << li->get_fileline() << \": sorry: \"\n\t\t << \"Last element select expression \"\n\t\t << \"not supported.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n\t// Evaluate the last index expression into a constant long.\n      NetExpr*texpr = elab_and_eval(des, scope, index.msb, -1, true);\n      long msb;\n      if (texpr == 0 || !eval_as_long(msb, texpr)) {\n\t    cerr << li->get_fileline() << \": error: \"\n\t\t  \"Array/part index expressions must be constant here.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      delete texpr;\n\n      long lsb = msb;\n      if (index.lsb) {\n\t    texpr = elab_and_eval(des, scope, index.lsb, -1, true);\n\t    if (texpr==0 || !eval_as_long(lsb, texpr)) {\n\t\t  cerr << li->get_fileline() << \": error: \"\n\t\t\t\"Array/part index expressions must be constant here.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\n\t    delete texpr;\n      }\n\n      switch (index.sel) {\n\t  case index_component_t::SEL_BIT:\n\t    off = msb;\n\t    wid = 1;\n\t    return true;\n\n\t  case index_component_t::SEL_PART:\n\t    off = lsb;\n\t    if (msb >= lsb) {\n\t\t  wid = msb - lsb + 1;\n\t    } else {\n\t\t  wid = lsb - msb + 1;\n\t    }\n\t    return true;\n\n\t  case index_component_t::SEL_IDX_UP:\n\t    wid = lsb;\n\t    off = msb;\n\t    break;\n\n\t  default:\n\t    ivl_assert(*li, 0);\n\t    break;\n      }\n      return true;\n}\n\n/*\n * Test if the tail name (method_name argument) is a member name and\n * the net is a struct. If that turns out to be the case, and the\n * struct is packed, then return a NetExpr that selects the member out\n * of the variable.\n */\nstatic NetExpr* check_for_struct_members(const LineInfo*li,\n\t\t\t\t\t Design*des, NetScope*scope,\n\t\t\t\t\t NetNet*net,\n\t\t\t\t\t const list<index_component_t>&base_index,\n\t\t\t\t\t pform_name_t member_path)\n{\n      const netstruct_t*struct_type = net->struct_type();\n      ivl_assert(*li, struct_type);\n\n      if (! struct_type->packed()) {\n\t    cerr << li->get_fileline() << \": sorry: \"\n\t\t << \"Unpacked structures not supported here.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// These make up the \"part\" select that is the equivilent of\n\t// following the member path through the nested structs. To\n\t// start with, the off[set] is zero, and use_width is the\n\t// width of the entire variable. The first member_comp is at\n\t// some offset within the variable, and will have a reduced\n\t// width. As we step through the member_path the off\n\t// increases, and use_width shrinks.\n      unsigned long off = 0;\n      unsigned long use_width = struct_type->packed_width();\n\n      pform_name_t completed_path;\n      ivl_type_t member_type = 0;\n      do {\n\t    const name_component_t member_comp = member_path.front();\n\t    const perm_string&member_name = member_comp.name;\n\n\t    if (debug_elaborate) {\n\t\t  cerr << li->get_fileline() << \": check_for_struct_members: \"\n\t\t       << \"Processing member_comp=\" << member_comp\n\t\t       << \" (completed_path=\" << completed_path << \")\"\n\t\t       << endl;\n\t    }\n\n\t      // Calculate the offset within the packed structure of the\n\t      // member, and any indices. We will add in the offset of the\n\t      // struct into the packed array later. Note that this works\n\t      // for packed unions as well (although the offset will be 0\n\t      // for union members).\n\t    unsigned long tmp_off;\n\t    const netstruct_t::member_t* member = struct_type->packed_member(member_name, tmp_off);\n\n\t    if (member == 0) {\n\t\t  cerr << li->get_fileline() << \": error: Member \" << member_name\n\t\t       << \" is not a member of struct type of \"\n\t\t       << net->name()\n\t\t       << \".\" << completed_path << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    member_type = member->net_type;\n\t    if (debug_elaborate) {\n\t\t  cerr << li->get_fileline() << \": check_for_struct_members: \"\n\t\t       << \"Member type: \" << *member_type\n\t\t       << \" (\" << typeid(*member_type).name() << \")\"\n\t\t       << endl;\n\t    }\n\n\t    off += tmp_off;\n\t    ivl_assert(*li, use_width >= (unsigned long)member_type->packed_width());\n\t    use_width = member_type->packed_width();\n\n\t      // At this point, off and use_width are the part select\n\t      // expressed by the member_comp, which is a member of the\n\t      // struct. We can further refine the part select with any\n\t      // indices that might be present.\n\n\t    if (const netstruct_t*tmp_struct = dynamic_cast<const netstruct_t*>(member_type)) {\n\t\t    // If the member is itself a struct, then get\n\t\t    // ready to go on to the next iteration.\n\t\t  struct_type = tmp_struct;\n\n\t    } else if (const netenum_t*tmp_enum = dynamic_cast<const netenum_t*> (member_type)) {\n\n\t\t    // If the element is an enum, then we only need to check if\n\t\t    // there is a part select for it\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << li->get_fileline() << \": check_for_struct_members: \"\n\t\t\t     << \"Tail element is an enum\" << *tmp_enum\n\t\t\t     << endl;\n\t\t  }\n\t\t  struct_type = 0;\n\n\t\t  if (!member_comp.index.empty()) {\n\n\t\t\tif (member_comp.index.size() > 1) {\n\t\t\t      cerr << li->get_fileline() << \": error: \"\n\t\t\t\t   << \"Too many index expressions for enum member.\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\n\t\t\tlong tail_off = 0;\n\t\t\tunsigned long tail_wid = 0;\n\t\t\tbool rc = calculate_part(li, des, scope, member_comp.index.back(), tail_off, tail_wid);\n\t\t\tif (! rc) return 0;\n\n\t\t\toff += tail_off;\n\t\t\tuse_width = tail_wid;\n\t\t  }\n\n\t    } else if (const netvector_t*mem_vec = dynamic_cast<const netvector_t*>(member_type)) {\n\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << li->get_fileline() << \": check_for_struct_members: \"\n\t\t\t     << \"member_comp=\" << member_comp\n\t\t\t     << \" has \" << member_comp.index.size() << \" indices.\"\n\t\t\t     << endl;\n\t\t  }\n\n\t\t    // If the member type is a netvector_t, then it is a\n\t\t    // vector of atom or scaler objects. For example, if the\n\t\t    // l-value expression is \"foo.member[1][2]\",\n\t\t    // then the member should be something like:\n\t\t    //    ... logic [h:l][m:n] member;\n\t\t    // There should be index expressions index the vector\n\t\t    // down, but there doesn't need to be all of them. We\n\t\t    // can, for example, be selecting a part of the vector.\n\n\t\t    // We only need to process this if there are any\n\t\t    // index expressions. If not, then the packed\n\t\t    // vector can be handled atomically.\n\n\t\t    // In any case, this should be the tail of the\n\t\t    // member_path, because the array element of this\n\t\t    // kind of array cannot be a struct.\n\t\t  if (!member_comp.index.empty()) {\n\t\t\t  // These are the dimensions defined by the type\n\t\t\tconst netranges_t&mem_packed_dims = mem_vec->packed_dims();\n\n\t\t\tif (member_comp.index.size() > mem_packed_dims.size()) {\n\t\t\t      cerr << li->get_fileline() << \": error: \"\n\t\t\t\t   << \"Too many index expressions for member.\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\n\t\t\t  // Evaluate all but the last index expression, into prefix_indices.\n\t\t\tlist<long>prefix_indices;\n\t\t\tbool rc = evaluate_index_prefix(des, scope, prefix_indices, member_comp.index);\n\t\t\tivl_assert(*li, rc);\n\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << li->get_fileline() << \": check_for_struct_members: \"\n\t\t\t\t   << \"prefix_indices.size()==\" << prefix_indices.size()\n\t\t\t\t   << \", mem_packed_dims.size()==\" << mem_packed_dims.size()\n\t\t\t\t   << endl;\n\t\t\t}\n\n\t\t\tlong tail_off = 0;\n\t\t\tunsigned long tail_wid = 0;\n\t\t\trc = calculate_part(li, des, scope, member_comp.index.back(), tail_off, tail_wid);\n\t\t\tif (! rc) return 0;\n\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << li->get_fileline() << \": check_for_struct_member: \"\n\t\t\t\t   << \"calculate_part for tail returns tail_off=\" << tail_off\n\t\t\t\t   << \", tail_wid=\" << tail_wid\n\t\t\t\t   << endl;\n\t\t\t}\n\n\n\t\t\t  // Now use the prefix_to_slice function to calculate the\n\t\t\t  // offset and width of the addressed slice\n\t\t\t  // of the member. The lwid comming out of\n\t\t\t  // the prefix_to_slice is the number of\n\t\t\t  // elements, and should be 1. The tmp_wid it\n\t\t\t  // the bit with of the result.\n\t\t\tlong loff;\n\t\t\tunsigned long lwid;\n\t\t\tprefix_to_slice(mem_packed_dims, prefix_indices, tail_off, loff, lwid);\n\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << li->get_fileline() << \": check_for_struct_members: \"\n\t\t\t\t   << \"Calculate loff=\" << loff << \" lwid=\" << lwid\n\t\t\t\t   << \" tail_off=\" << tail_off << \" tail_wid=\" << tail_wid\n\t\t\t\t   << \" off=\" << off << \" use_width=\" << use_width\n\t\t\t\t   << endl;\n\t\t\t}\n\n\t\t\toff += loff;\n\t\t\tuse_width = lwid * tail_wid;\n\t\t  }\n\n\t\t    // The netvector_t only has atom elements, so\n\t\t    // there is no next struct type.\n\t\t  struct_type = 0;\n\n\t    } else if (const netparray_t*array = dynamic_cast<const netparray_t*>(member_type)) {\n\n\t\t    // If the member is a parray, then the elements\n\t\t    // are themselves packed object, including\n\t\t    // possibly a struct. Handle this by taking the\n\t\t    // part select of the current part of the\n\t\t    // variable, then stepping to the element type to\n\t\t    // possibly iterate through more of the member_path.\n\t\t  ivl_assert(*li, array->packed());\n\t\t  ivl_assert(*li, !member_comp.index.empty());\n\n\t\t    // These are the dimensions defined by the type\n\t\t  const netranges_t&mem_packed_dims = array->static_dimensions();\n\n\t\t  if (member_comp.index.size() != mem_packed_dims.size()) {\n\t\t\tcerr << li->get_fileline() << \": error: \"\n\t\t\t     << \"Incorrect number of index expressions for member \"\n\t\t\t     << member_name << \".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  }\n\n\t\t    // Evaluate all but the last index expression, into prefix_indices.\n\t\t  list<long>prefix_indices;\n\t\t  bool rc = evaluate_index_prefix(des, scope, prefix_indices, member_comp.index);\n\t\t  ivl_assert(*li, rc);\n\n\t\t    // Evaluate the last index expression into a constant long.\n\t\t  NetExpr*texpr = elab_and_eval(des, scope, member_comp.index.back().msb, -1, true);\n\t\t  long tmp;\n\t\t  if (texpr == 0 || !eval_as_long(tmp, texpr)) {\n\t\t\tcerr << li->get_fileline() << \": error: \"\n\t\t\t     << \"Array index expressions for member \" << member_name\n\t\t\t     << \" must be constant here.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  }\n\n\t\t  delete texpr;\n\n\t\t    // Now use the prefix_to_slice function to calculate the\n\t\t    // offset and width of the addressed slice of the member.\n\t\t  long loff;\n\t\t  unsigned long lwid;\n\t\t  prefix_to_slice(mem_packed_dims, prefix_indices, tmp, loff, lwid);\n\n\t\t  ivl_type_t element_type = array->element_type();\n\t\t  long element_width = element_type->packed_width();\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << li->get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t\t     << \"parray subselection loff=\" << loff\n\t\t\t     << \", lwid=\" << lwid\n\t\t\t     << \", element_width=\" << element_width\n\t\t\t     << endl;\n\t\t  }\n\n\t\t    // The width and offset calculated from the\n\t\t    // indices is actually in elements, and not\n\t\t    // bits. In fact, in this context, the lwid should\n\t\t    // come down to 1 (one element).\n\t\t  off += loff * element_width;\n\t\t  ivl_assert(*li, lwid==1);\n\t\t  use_width = element_width;\n\n\t\t    // To move on to the next component in the member\n\t\t    // path, get the element type. For example, for\n\t\t    // the path a.b[1].c, we are processing b[1] here,\n\t\t    // and the element type should be a netstruct_t\n\t\t    // that will wind up containing the member c.\n\t\t  struct_type = dynamic_cast<const netstruct_t*> (element_type);\n\n\t    } else {\n\t\t    // Unknown type?\n\t\t  cerr << li->get_fileline() << \": internal error: \"\n\t\t       << \"Unexpected member type? \" << *member_type\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  struct_type = 0;\n\t    }\n\n\t      // Complete this component of the path, mark it\n\t      // completed, and set up for the next component.\n\t    completed_path .push_back(member_comp);\n\t    member_path.pop_front();\n\n      } while (!member_path.empty() && struct_type != 0);\n\n\t// The dimensions in the expression must match the packed\n\t// dimensions that are declared for the variable. For example,\n\t// if foo is a packed array of struct, then this expression\n\t// must be \"b[n][m]\" with the right number of dimensions to\n\t// match the declaration of \"b\".\n\t// Note that one of the packed dimensions is the packed struct\n\t// itself.\n      ivl_assert(*li, base_index.size()+1 == net->packed_dimensions());\n\n      NetExpr*packed_base = 0;\n      if (net->packed_dimensions() > 1) {\n\t    list<index_component_t>tmp_index = base_index;\n\t    index_component_t member_select;\n\t    member_select.sel = index_component_t::SEL_BIT;\n\t    member_select.msb = new PENumber(new verinum(off));\n\t    tmp_index.push_back(member_select);\n\t    packed_base = collapse_array_exprs(des, scope, li, net, tmp_index);\n\t    ivl_assert(*li, packed_base);\n\t    if (debug_elaborate) {\n\t\t  cerr << li->get_fileline() << \": debug: check_for_struct_members: \"\n\t\t       << \"Got collapsed array expr: \" << *packed_base << endl;\n\t    }\n      }\n\n      long tmp;\n      if (packed_base && eval_as_long(tmp, packed_base)) {\n\t    off += tmp;\n\t    delete packed_base;\n\t    packed_base = 0;\n      }\n\n      NetESignal*sig = new NetESignal(net);\n      NetExpr   *base = packed_base? packed_base : make_const_val(off);\n      NetESelect*sel = new NetESelect(sig, base, use_width, member_type);\n\n      if (debug_elaborate) {\n\t    cerr << li->get_fileline() << \": check_for_struct_member: \"\n\t\t << \"Finally, completed_path=\" << completed_path\n\t\t << \", off=\" << off << \", use_width=\" << use_width\n\t\t << \", base=\" << *base\n\t\t << endl;\n      }\n\n      return sel;\n}\n\nstatic NetExpr* class_static_property_expression(const LineInfo*li,\n\t\t\t\t\t\t const netclass_t*class_type,\n\t\t\t\t\t\t perm_string name)\n{\n      NetNet*sig = class_type->find_static_property(name);\n      ivl_assert(*li, sig);\n      NetESignal*expr = new NetESignal(sig);\n      expr->set_line(*li);\n      return expr;\n}\n\nNetExpr* PEIdent::elaborate_expr_class_field_(Design*des, NetScope*scope,\n\t\t\t\t\t      const symbol_search_results &sr,\n\t\t\t\t\t      unsigned expr_wid,\n\t\t\t\t\t      unsigned flags) const\n{\n\n      const netclass_t *class_type = dynamic_cast<const netclass_t*>(sr.type);\n      const name_component_t comp = sr.path_tail.front();\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t << \"Ident \" << sr.path_head\n\t\t << \" look for property \" << comp << endl;\n      }\n\n      if (sr.path_tail.size() > 1) {\n\t    cerr << get_fileline() << \": sorry: \"\n\t\t << \"Nested member path not yet supported for class properties.\"\n\t\t << endl;\n\t    return nullptr;\n      }\n\n      ivl_type_t par_type;\n      const NetExpr *par_val = class_type->get_parameter(des, comp.name, par_type);\n      if (par_val)\n\t    return elaborate_expr_param_(des, scope, par_val,\n\t\t\t\t         class_type->class_scope(), par_type,\n\t\t\t\t         expr_wid, flags);\n\n      int pidx = class_type->property_idx_from_name(comp.name);\n      if (pidx < 0) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Class \" << class_type->get_name()\n\t\t << \" has no property \" << comp.name << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": check_for_class_property: \"\n\t\t << \"Property \" << comp.name\n\t\t << \" of net \" << sr.net->name()\n\t\t << \", context scope=\" << scope_path(scope)\n\t\t << endl;\n      }\n\n      property_qualifier_t qual = class_type->get_prop_qual(pidx);\n      if (qual.test_local() && ! class_type->test_scope_is_method(scope)) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Local property \" << class_type->get_prop_name(pidx)\n\t\t << \" is not accessible in this context.\"\n\t\t << \" (scope=\" << scope_path(scope) << \")\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (qual.test_static()) {\n\t    perm_string prop_name = lex_strings.make(class_type->get_prop_name(pidx));\n\t    return class_static_property_expression(this, class_type,\n\t\t\t\t\t\t    prop_name);\n      }\n\n      NetExpr *canon_index = nullptr;\n      ivl_type_t tmp_type = class_type->get_prop_type(pidx);\n      if (const netuarray_t *tmp_ua = dynamic_cast<const netuarray_t*>(tmp_type)) {\n\t    const auto &dims = tmp_ua->static_dimensions();\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_expr_class_member_: \"\n\t\t       << \"Property \" << class_type->get_prop_name(pidx)\n\t\t       << \" has \" << dims.size() << \" dimensions, \"\n\t\t       << \" got \" << comp.index.size() << \" indices.\" << endl;\n\t    }\n\n\t    if (dims.size() != comp.index.size()) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Got \" << comp.index.size() << \" indices, \"\n\t\t       << \"expecting \" << dims.size()\n\t\t       << \" to index the property \" << class_type->get_prop_name(pidx) << \".\" << endl;\n\t\t  des->errors++;\n\t    } else {\n\t\t  canon_index = make_canonical_index(des, scope, this,\n\t\t\t\t\t\t     comp.index, tmp_ua, false);\n\t    }\n      }\n\n      if (debug_elaborate && canon_index) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_expr_class_member_: \"\n\t\t << \"Property \" << class_type->get_prop_name(pidx)\n\t\t << \" canonical index: \" << *canon_index << endl;\n      }\n\n      NetEProperty *tmp = new NetEProperty(sr.net, pidx, canon_index);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetExpr* PECallFunction::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t\tunsigned expr_wid, unsigned flags) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t << \"path_: \" << path_ << endl;\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t << \"expr_wid: \" << expr_wid << endl;\n      }\n\n      if (peek_tail_name(path_)[0] == '$')\n\t    return elaborate_sfunc_(des, scope, expr_wid, flags);\n\n      NetExpr *result = elaborate_expr_(des, scope, flags);\n      if (!result || !type_is_vectorable(expr_type_))\n\t    return result;\n\n      return pad_to_width(result, expr_wid, signed_flag_, *this);\n}\n\nNetExpr* PECallFunction::elaborate_expr_(Design*des, NetScope*scope,\n\t\t\t\t\t unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      // Search for the symbol. This should turn up a scope.\n      symbol_search_results search_results;\n      bool search_flag = symbol_search(this, des, scope, path_, UINT_MAX, &search_results);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t << \"search_flag: \" << (search_flag? \"true\" : \"false\") << endl;\n\t    if (search_results.scope)\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t       << \"search_results.scope: \" << scope_path(search_results.scope) << endl;\n\t    if (search_results.net)\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t       << \"search_results.net: \" << search_results.net->name() << endl;\n\t    if (search_results.par_val)\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t       << \"search_results.par_val: \" << *search_results.par_val << endl;\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t << \"search_results.path_head: \" << search_results.path_head << endl;\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t << \"search_results.path_tail: \" << search_results.path_tail << endl;\n      }\n\n      // If the symbol is not found at all...\n      if (!search_flag) {\n\t    cerr << get_fileline() << \": error: No function named `\" << path_\n\t\t << \"' found in this context (\" << scope_path(scope) << \").\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      // If the symbol is found, but is not a scope...\n      if (! search_results.is_scope() && !test_function_return_value(search_results)) {\n\n\t    // Maybe this is a method of an object? Give it a try.\n\t    if (!search_results.path_tail.empty()) {\n\t\t  NetExpr*tmp = elaborate_expr_method_(des, scope, search_results);\n\t\t  if (tmp) {\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t\t\t   << \"Elaborated method: \" << *tmp << endl;\n\t\t\t}\n\t\t\treturn tmp;\n\t\t  } else {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Object \" << scope_path(search_results.scope)\n\t\t\t     << \".\" << search_results.path_head.back()\n\t\t\t     << \" has no method \\\"\" << search_results.path_tail\n\t\t\t     << \"(...)\\\".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  }\n\t    }\n\n\t    cerr << get_fileline() << \": error: Object \" << search_results.path_head.back()\n\t\t << \" in \" << scope_path(search_results.scope)\n\t\t << \" is not a function.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      // If the symbol is found, but is not a _function_ scope...\n      if (search_results.scope->type() != NetScope::FUNC) {\n\t      // Not a user defined function. Maybe it is an access\n\t      // function for a nature? If so then elaborate it that\n\t      // way.\n\t    ivl_nature_t access_nature = find_access_function(path_);\n\t    if (access_nature)\n\t\t  return elaborate_access_func_(des, scope, access_nature);\n\n\t      // Nothing was found so report this as an error.\n\t    cerr << get_fileline() << \": error: No function named `\" << path_\n\t         << \"' found in this context (\" << scope_path(scope) << \").\"\n                 << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n      NetFuncDef*def = search_results.scope->func_def();\n\n      ivl_assert(*this, def);\n      ivl_assert(*this, def->scope() == search_results.scope);\n      NetScope*dscope = search_results.scope;\n\n      // In SystemVerilog, a method calling another method in the current\n      // class needs to be elaborated as a method with an implicit \"this\"\n      // added. This is a special case. If we detect this case, then\n      // synthesize a new symbol_search_results thast properly reflects the\n      // implicit \"this\", and treat this item as a class method.\n      if (gn_system_verilog() && (path_.size() == 1)) {\n           const NetScope *c_scope = scope->get_class_scope();\n           if (c_scope && (c_scope == dscope->get_class_scope())) {\n\t\t if (debug_elaborate) {\n\t\t       cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t\t    << \"Found a class method calling another method.\" << endl;\n\t\t       cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t\t    << \"scope: \" << scope_path(scope) << endl;\n\t\t       cerr << get_fileline() << \": PECallFunction::elaborate_expr: \"\n\t\t\t    << \"c_scope: \" << scope_path(c_scope) << endl;\n\t\t }\n\t\t symbol_search_results use_search_results;\n\t\t use_search_results.scope = scope;\n\t\t use_search_results.path_tail.push_back(search_results.path_head.back());\n\t\t use_search_results.path_head.push_back(name_component_t(perm_string::literal(THIS_TOKEN)));\n\t\t use_search_results.net = scope->find_signal(perm_string::literal(THIS_TOKEN));\n\t\t use_search_results.type = use_search_results.net->net_type();\n\t\t ivl_assert(*this, use_search_results.net);\n\n\t\t return elaborate_expr_method_(des, scope, use_search_results);\n           }\n      }\n\n      bool need_const = NEED_CONST & flags;\n\n        // It is possible to get here before the called function has been\n        // fully elaborated. If this is the case, elaborate it now. This\n        // ensures we know whether or not it is a constant function.\n      if (dscope->elab_stage() < 3) {\n            dscope->need_const_func(need_const || scope->need_const_func());\n            const PFunction*pfunc = dscope->func_pform();\n            ivl_assert(*this, pfunc);\n            pfunc->elaborate(des, dscope);\n      }\n\n\t// From IEEE 1800-2023 section 13.4.3:\n\t// A constant function call is a function call of a constant function\n\t// wherein the constant function's declaration is local to the calling\n\t// design element or is in a package or $unit.\n      bool is_const_func_call = false;\n      if (dscope->is_const_func()) {\n\t    NetScope*caller_scope = scope;\n\t    while (caller_scope && caller_scope->type() != NetScope::MODULE\n\t\t\t\t&& caller_scope->type() != NetScope::PACKAGE) {\n\t\t  caller_scope = caller_scope->parent();\n\t    }\n\t    NetScope*callee_scope = dscope->parent();\n\t    while (callee_scope && callee_scope->type() != NetScope::MODULE\n\t\t\t\t&& callee_scope->type() != NetScope::PACKAGE) {\n\t\t  callee_scope = callee_scope->parent();\n\t    }\n\t    ivl_assert(*this, caller_scope);\n\t    ivl_assert(*this, callee_scope);\n\t    is_const_func_call = (callee_scope == caller_scope) ||\n\t\t\t\t (callee_scope->type() == NetScope::PACKAGE);\n      }\n      if (!is_const_func_call) {\n            if (scope->need_const_func()) {\n\t          cerr << get_fileline() << \": error: A function invoked by \"\n                          \"a constant function must be a constant function \"\n                          \"local to the current module or provided by a \"\n                          \"package.\" << endl;\n                  des->errors += 1;\n            }\n            scope->is_const_func(false);\n      }\n\n      return elaborate_base_(des, scope, dscope, flags);\n}\n\nNetExpr* PECallFunction::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t\tivl_type_t type, unsigned flags) const\n{\n      const netdarray_t*darray = dynamic_cast<const netdarray_t*>(type);\n      unsigned int width = 1;\n        // Icarus allows a dynamic array to be initialised with a single\n        // elementary value, in that case the expression needs to be evaluated\n        // with the rigth width.\n      if (darray)\n\t    width = darray->element_type()->packed_width();\n      return elaborate_expr(des, scope, width, flags);\n}\n\nNetExpr* PECallFunction::elaborate_base_(Design*des, NetScope*scope, NetScope*dscope,\n\t\t\t\t\t unsigned flags) const\n{\n\n      if (! check_call_matches_definition_(des, dscope))\n\t    return 0;\n\n      NetFuncDef*def = dscope->func_def();\n\n      bool need_const = NEED_CONST & flags;\n\n\t// If this is a constant expression, it is possible that we\n\t// are being elaborated before the function definition. If\n\t// that's the case, try to elaborate the function as a const\n\t// function.\n      if (need_const && ! def->proc()) {\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_base_: \"\n\t\t       << \"Try to elaborate \" << scope_path(dscope)\n\t\t       << \" as constant function.\" << endl;\n\t    }\n\t    dscope->set_elab_stage(2);\n\t    dscope->need_const_func(true);\n\t    const PFunction*pfunc = dscope->func_pform();\n\t    ivl_assert(*this, pfunc);\n\t    pfunc->elaborate(des, dscope);\n      }\n\n      unsigned parms_count = def->port_count();\n      vector<NetExpr*> parms (parms_count);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_base_: \"\n\t\t << \"Expecting \" << parms_count\n\t\t << \" argument for function \" << scope_path(dscope) << \".\" << endl;\n      }\n\n\t/* Elaborate the input expressions for the function. This is\n\t   done in the scope of the function call, and not the scope\n\t   of the function being called. The scope of the called\n\t   function is elaborated when the definition is elaborated. */\n      unsigned parm_errors = elaborate_arguments_(des, scope,\n\t\t\t\t\t\t  def, need_const,\n\t\t\t\t\t\t  parms, 0);\n\n      if (need_const && !dscope->is_const_func()) {\n\n              // If this is the first time the function has been called in\n              // a constant context, force the function to be re-elaborated.\n              // This will generate the necessary error messages to allow\n              // the user to diagnose the fault.\n            if (!dscope->need_const_func()) {\n                  dscope->set_elab_stage(2);\n                  dscope->need_const_func(true);\n                  const PFunction*pfunc = dscope->func_pform();\n                  ivl_assert(*this, pfunc);\n                  pfunc->elaborate(des, dscope);\n            }\n\n            cerr << get_fileline() << \": error: `\" << dscope->basename()\n                 << \"' is not a constant function.\" << endl;\n            des->errors += 1;\n            return 0;\n      }\n\n      if (parm_errors)\n            return 0;\n\n      if (def->is_void()) {\n\t    cerr << get_fileline() << \": error: void function `\"\n\t\t << dscope->basename() << \"` can not be called in an expression.\"\n\t\t << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n\t/* Look for the return value signal for the called\n\t   function. This return value is a magic signal in the scope\n\t   of the function, that has the name of the function. The\n\t   function code assigns to this signal to return a value.\n\n\t   dscope, in this case, is the scope of the function, so the\n\t   return value is the name within that scope. */\n\n      if (NetNet*res = dscope->find_signal(dscope->basename())) {\n\t    NetESignal*eres = new NetESignal(res);\n\t    NetEUFunc*func = new NetEUFunc(scope, dscope, eres, parms, need_const);\n\t    func->set_line(*this);\n\t    return func;\n      }\n\n      cerr << get_fileline() << \": internal error: Unable to locate \"\n              \"function return value for \" << path_\n           << \" in \" << dscope->basename() << \".\" << endl;\n      des->errors += 1;\n      return 0;\n}\n\n/*\n * Elaborate the arguments of a function or method. The parms vector\n * is where to place the elaborated expressions, so it an output. The\n * parm_off is where in the parms vector to start writing\n * arguments. This value is normally 0, but is 1 if this is a method\n * so that parms[0] can hold the \"this\" argument. In this latter case,\n * def->port(0) will be the \"this\" argument and should be skipped.\n */\nunsigned PECallFunction::elaborate_arguments_(Design*des, NetScope*scope,\n\t\t\t\t\t      NetFuncDef*def, bool need_const,\n\t\t\t\t\t      vector<NetExpr*>&parms,\n\t\t\t\t\t      unsigned parm_off) const\n{\n      unsigned parm_errors = 0;\n      unsigned missing_parms = 0;\n\n      const unsigned parm_count = parms.size() - parm_off;\n      const unsigned actual_count = parms_.size();\n\n      if (parm_count == 0 && actual_count == 0)\n\t    return 0;\n\n      if (actual_count > parm_count) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Too many arguments (\" << actual_count\n\t\t << \", expecting \" << parm_count << \")\"\n\t\t << \" in call to function.\" << endl;\n\t    des->errors += 1;\n      }\n\n      auto args = map_named_args(des, def, parms_, parm_off);\n\n      for (unsigned idx = 0 ; idx < parm_count ; idx += 1) {\n\t    unsigned pidx = idx + parm_off;\n\t    PExpr *tmp = args[idx];\n\n\t    if (tmp) {\n\t\t  parms[pidx] = elaborate_rval_expr(des, scope,\n\t\t\t\t\t\t    def->port(pidx)->net_type(),\n\t\t\t\t\t\t    tmp, need_const);\n\t\t  if (parms[pidx] == 0) {\n\t\t\tparm_errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  if (NetEEvent*evt = dynamic_cast<NetEEvent*> (parms[pidx])) {\n\t\t\tcerr << evt->get_fileline() << \": error: An event '\"\n\t\t\t     << evt->event()->name() << \"' can not be a user \"\n\t\t\t        \"function argument.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug:\"\n\t\t\t     << \" function \" << path_\n\t\t\t     << \" arg \" << (idx+1)\n\t\t\t     << \" argwid=\" << parms[pidx]->expr_width()\n\t\t\t     << \": \" << *parms[idx] << endl;\n\n\t    } else if (def->port_defe(pidx)) {\n\t\t  if (! gn_system_verilog()) {\n\t\t\tcerr << get_fileline() << \": internal error: \"\n\t\t\t     << \"Found (and using) default function argument \"\n\t\t\t     << \"requires SystemVerilog.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  parms[pidx] = def->port_defe(pidx)->dup_expr();\n\n\t    } else {\n\t\t  missing_parms += 1;\n\t\t  parms[pidx] = 0;\n\t    }\n      }\n\n      if (missing_parms > 0) {\n\t    cerr << get_fileline() << \": error: The function \" << path_\n\t\t << \" has been called with missing/empty parameters.\" << endl;\n\t    cerr << get_fileline() << \":      : Verilog doesn't allow \"\n\t\t << \"passing empty parameters to functions.\" << endl;\n\t    parm_errors += 1;\n\t    des->errors += 1;\n      }\n\n      return parm_errors;\n}\n\n/*\n * Look for a method of a given object. The search_results gives us the\n * information we need to look into this case: The net is the object that will\n * have its method applied, and the path_tail is the method we are looking\n * for. The method name is to be interpreted based on the type of the item. So\n * for example if the object is:\n *\n *     <scope>.x.len()\n *\n * Then net refers to object named x, and path_head is \"<scope>.x\". The method is\n * \"len\" in path_tail, and if x is a string object, we can handle the case.\n */\nNetExpr* PECallFunction::elaborate_expr_method_(Design*des, NetScope*scope,\n\t\t\t\t\t\tsymbol_search_results&search_results)\n\t\t\t\t\t\tconst\n{\n      if (!gn_system_verilog()) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Enable SystemVerilog to support object methods.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (search_results.path_tail.size() > 1) {\n\t    cerr << get_fileline() << \": sorry: \"\n\t\t << \"Method name nesting is not supported yet.\" << endl;\n\t    cerr << get_fileline() << \":      : \"\n\t\t << \"method path: \" << search_results.path_tail << endl;\n\t    return 0;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t << \"search_results.scope: \" << scope_path(search_results.scope) << endl;\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t << \"search_results.path_head: \" << search_results.path_head << endl;\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t << \"search_results.path_tail: \" << search_results.path_tail << endl;\n\t    if (search_results.net)\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t       << \"search_results.net->data_type: \" << search_results.net->data_type() << endl;\n\t    if (search_results.net && search_results.net->net_type())\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t       << \"search_results.net->net_type: \" << *search_results.net->net_type() << endl;\n\t    if (search_results.par_val)\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t       << \"search_results.par_val: \" << *search_results.par_val << endl;\n\t    if (search_results.type)\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t       << \"search_results.type: \" << *search_results.type << endl;\n      }\n\n      if (search_results.par_val && search_results.type) {\n\t    return elaborate_expr_method_par_(des, scope, search_results);\n      }\n\n      NetExpr* sub_expr = 0;\n      if (search_results.net) {\n\t    NetESignal*tmp = new NetESignal(search_results.net);\n\t    tmp->set_line(*this);\n\t    sub_expr = tmp;\n      }\n\n      // Queue variable with a select expression. The type of this expression\n      // is the type of the object that will interpret the method. For\n      // example:\n      //    <scope>.x[e].len()\n      // If x is a queue of strings, then x[e] is a string. Elaborate the x[e]\n      // expression and pass that to the len() method.\n      if (search_results.net && search_results.net->data_type()==IVL_VT_QUEUE\n\t  && search_results.path_head.back().index.size()==1) {\n\n\t    NetNet*net = search_results.net;\n\t    const netdarray_t*darray = net->darray_type();\n\t    const index_component_t&use_index = search_results.path_head.back().index.back();\n\t    ivl_assert(*this, use_index.msb != 0);\n\t    ivl_assert(*this, use_index.lsb == 0);\n\n\t    NetExpr*mux = elab_and_eval(des, scope, use_index.msb, -1, false);\n\t    if (!mux)\n\t\t  return 0;\n\n\t    NetESelect*tmp = new NetESelect(sub_expr, mux, darray->element_width(), darray->element_type());\n\t    tmp->set_line(*this);\n\t    sub_expr = tmp;\n      }\n\n      if (debug_elaborate && sub_expr) {\n\t    cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t << \"sub_expr->expr_type: \" << sub_expr->expr_type() << endl;\n\t    if (sub_expr->net_type())\n\t\t  cerr << get_fileline() << \": PECallFunction::elaborate_expr_method_: \"\n\t\t       << \"sub_expr->net_type: \" << *sub_expr->net_type() << endl;\n      }\n\n      ivl_assert(*this, sub_expr);\n\n      // Dynamic array methods. This handles the case that the located signal\n      // is a dynamic array, and there is no index.\n      if (search_results.net && search_results.net->data_type()==IVL_VT_DARRAY\n\t  && search_results.path_head.back().index.size()==0) {\n\n\t    // Get the method name that we are looking for.\n\t    perm_string method_name = search_results.path_tail.back().name;\n\n\t    if (method_name == \"size\") {\n\t\t  if (parms_.size() != 0) {\n\t\t\tcerr << get_fileline() << \": error: size() method \"\n\t\t\t     << \"takes no arguments\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$size\", &netvector_t::atom2u32, 1);\n\t\t  sys_expr->set_line(*this);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    cerr << get_fileline() << \": error: Method \" << method_name\n\t\t << \" is not a dynamic array method.\" << endl;\n\t    return 0;\n      }\n\n      // Queue methods. This handles the case that the located signal is a\n      // QUEUE object, and there is a method.\n      if (search_results.net && search_results.net->data_type()==IVL_VT_QUEUE\n\t  && search_results.path_head.back().index.size()==0) {\n\n\t    // Get the method name that we are looking for.\n\t    perm_string method_name = search_results.path_tail.back().name;\n\t    if (method_name == \"size\") {\n\t\t  if (parms_.size() != 0) {\n\t\t\tcerr << get_fileline() << \": error: size() method \"\n\t\t\t     << \"takes no arguments\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$size\", &netvector_t::atom2u32, 1);\n\t\t  sys_expr->set_line(*this);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    const netqueue_t*queue = search_results.net->queue_type();\n\t    ivl_type_t element_type = queue->element_type();\n\t    if (method_name == \"pop_back\") {\n\t\t  if (parms_.size() != 0) {\n\t\t\tcerr << get_fileline() << \": error: pop_back() method \"\n\t\t\t     << \"takes no arguments\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$ivl_queue_method$pop_back\",\n\t\t\t\t\t\t     element_type, 1);\n\t\t  sys_expr->set_line(*this);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    if (method_name == \"pop_front\") {\n\t\t  if (parms_.size() != 0) {\n\t\t\tcerr << get_fileline() << \": error: pop_front() method \"\n\t\t\t     << \"takes no arguments\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$ivl_queue_method$pop_front\",\n\t\t\t\t\t\t     element_type, 1);\n\t\t  sys_expr->set_line(*this);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    cerr << get_fileline() << \": error: Method \" << method_name\n\t\t << \" is not a queue method.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      // Enumeration methods.\n      if (search_results.net && search_results.net->enumeration()) {\n\n\t    NetNet*net = search_results.net;\n\t    const netenum_t*netenum = net->enumeration();\n\n\t    // Get the method name that we are looking for.\n\t    perm_string method_name = search_results.path_tail.back().name;\n\t    return check_for_enum_methods(this, des, scope,\n\t\t\t\t\t  netenum, path_,\n\t\t\t\t\t  method_name, sub_expr,\n\t\t\t\t\t  parms_);\n      }\n\n      // Class methods. Generate function call to the class method.\n      if (sub_expr->expr_type()==IVL_VT_CLASS) {\n\n\t    // Get the method name that we are looking for.\n\t    perm_string method_name = search_results.path_tail.back().name;\n\n\t    NetNet*net = search_results.net;\n\t    const netclass_t*class_type = dynamic_cast<const netclass_t*>(search_results.type);\n\t    ivl_assert(*this, class_type);\n\t    NetScope*method = class_type->method_from_name(method_name);\n\n\t    if (method == 0) {\n\t\t  cerr << get_fileline() << \": Error: \" << method_name\n\t\t       << \" is not a method of class \" << class_type->get_name()\n\t\t       << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    NetFuncDef*def = method->func_def();\n\t    ivl_assert(*this, def);\n\n\t    NetNet*res = method->find_signal(method->basename());\n\t    ivl_assert(*this, res);\n\n\t    vector<NetExpr*> parms(def->port_count());\n\t    ivl_assert(*this, def->port_count() >= 1);\n\n\t    NetESignal*ethis = new NetESignal(net);\n\t    ethis->set_line(*this);\n\t    parms[0] = ethis;\n\n\t    elaborate_arguments_(des, scope, def, false, parms, 1);\n\n\t    NetESignal*eres = new NetESignal(res);\n\t    NetEUFunc*call = new NetEUFunc(scope, method, eres, parms, false);\n\t    call->set_line(*this);\n\t    return call;\n      }\n\n      // String methods.\n      if (sub_expr->expr_type()==IVL_VT_STRING) {\n\n\t    // Get the method name that we are looking for.\n\t    perm_string method_name = search_results.path_tail.back().name;\n\n\t    if (method_name == \"len\") {\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$ivl_string_method$len\",\n\t\t\t\t\t\t     &netvector_t::atom2u32, 1);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    if (method_name == \"atoi\") {\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$ivl_string_method$atoi\",\n\t\t\t\t\t\t     netvector_t::integer_type(), 1);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    if (method_name == \"atoreal\") {\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$ivl_string_method$atoreal\",\n\t\t\t\t\t\t     &netreal_t::type_real, 1);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    if (method_name == \"atohex\") {\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$ivl_string_method$atohex\",\n\t\t\t\t\t\t     netvector_t::integer_type(), 1);\n\t\t  sys_expr->parm(0, sub_expr);\n\t\t  return sys_expr;\n\t    }\n\n\t    if (method_name == \"substr\") {\n\t\t  if (parms_.size() != 2)\n\t\t\tcerr << get_fileline() << \": error: Method `substr()`\"\n\t\t\t     << \" requires 2 arguments, got \" << parms_.size()\n\t\t\t     << \".\" << endl;\n\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"i\"),\n\t\t\tperm_string::literal(\"j\")\n\t\t  };\n\t\t  auto args = map_named_args(des, parm_names, parms_);\n\n\t\t  NetESFunc*sys_expr = new NetESFunc(\"$ivl_string_method$substr\",\n\t\t\t\t\t\t     &netstring_t::type_string, 3);\n\t\t  sys_expr->set_line(*this);\n\n\t\t    // First argument is the source string.\n\t\t  sys_expr->parm(0, sub_expr);\n\n\t\t  for (int i = 0; i < 2; i++) {\n\t\t\tif (!args[i])\n\t\t\t      continue;\n\n\t\t\tauto expr = elaborate_rval_expr(des, scope,\n\t\t\t\t\t\t        &netvector_t::atom2u32,\n\t\t\t\t\t\t        args[i], false);\n\t\t\tsys_expr->parm(i + 1, expr);\n\t\t  }\n\n\t\t  return sys_expr;\n\t    }\n\n\t    cerr << get_fileline() << \": error: Method \" << method_name\n\t\t << \" is not a string method.\" << endl;\n\t    return 0;\n      }\n\n      return 0;\n}\n\n/*\n * Handle parameters differently because some must constant elimination is\n * possible here. We know by definition that the par_val is a constant\n * expression of some sort (it's a parameter value) and most methods are\n * stable in the sense that they generate a constant value for a constant input.\n */\nNetExpr* PECallFunction::elaborate_expr_method_par_(Design*des, NetScope*scope,\n\t\t\t\t\t\t    symbol_search_results&search_results)\n\t\t\t\t\t\t    const\n{\n      ivl_assert(*this, search_results.par_val);\n      ivl_assert(*this, search_results.type);\n\n      const NetExpr*par_val = search_results.par_val;\n      ivl_type_t par_type = search_results.type;\n      perm_string method_name = search_results.path_tail.back().name;\n\n      // If the parameter is of type string, then look for the standard string\n      // methods. Return an error if not found. Since we are assured that the\n      // expression is a constant string, it should be able to calculate the\n      // result at compile time.\n      if (dynamic_cast<const netstring_t*>(par_type)) {\n\n\t    const NetECString*par_string = dynamic_cast<const NetECString*>(par_val);\n\t    ivl_assert(*par_val, par_string);\n\t    string par_value = par_string->value().as_string();\n\n\t    if (method_name==\"len\") {\n\t\t  NetEConst*use_val = make_const_val(par_value.size());\n\t\t  use_val->set_line(*this);\n\t\t  return use_val;\n\t    }\n\n\t    if (method_name == \"atoi\") {\n\t\t  NetEConst*use_val = make_const_val(atoi(par_value.c_str()));\n\t\t  use_val->set_line(*this);\n\t\t  return use_val;\n\t    }\n\n\t    if (method_name == \"atoreal\") {\n\t\t  NetECReal*use_val = new NetECReal(verireal(par_value.c_str()));\n\t\t  use_val->set_line(*this);\n\t\t  return use_val;\n\t    }\n\n\t    if (method_name == \"atohex\") {\n\t\t  NetEConst*use_val = make_const_val(strtoul(par_value.c_str(),0,16));\n\t\t  use_val->set_line(*this);\n\t\t  return use_val;\n\t    }\n\n\t    // Returning 0 here will cause the caller to print an error\n\t    // message and increment the error count, so there is no need to\n\t    // increment des->error_count here.\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Unknown or unsupport string method: \" << method_name\n\t\t << endl;\n\t    return 0;\n      }\n\n      // If we haven't figured out what to do with this method by now,\n      // something went wrong.\n      cerr << get_fileline() << \": sorry: Don't know how to handle methods of parameters of type:\" << endl;\n      cerr << get_fileline() << \":      : \" << *par_type << endl;\n      cerr << get_fileline() << \":      : in scope \" << scope_path(scope) << endl;\n\n      des->errors += 1;\n      return 0;\n}\n\nunsigned PECastSize::test_width(Design*des, NetScope*scope, width_mode_t&)\n{\n      ivl_assert(*this, size_);\n      ivl_assert(*this, base_);\n\n      expr_width_ = 0;\n\n      NetExpr*size_ex = elab_and_eval(des, scope, size_, -1, true);\n      NetEConst*size_ce = dynamic_cast<NetEConst*>(size_ex);\n      if (size_ce && !size_ce->value().is_negative())\n\t    expr_width_ = size_ce->value().as_ulong();\n      delete size_ex;\n      if (expr_width_ == 0) {\n\t    cerr << get_fileline() << \": error: Cast size expression \"\n\t\t    \"must be constant and greater than zero.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      width_mode_t tmp_mode = PExpr::SIZED;\n      base_->test_width(des, scope, tmp_mode);\n\n      if (!type_is_vectorable(base_->expr_type())) {\n\t    cerr << get_fileline() << \": error: Cast base expression \"\n\t\t    \"must be a vector type.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      expr_type_   = base_->expr_type();\n      min_width_   = expr_width_;\n      signed_flag_ = base_->has_sign();\n\n      return expr_width_;\n}\n\nNetExpr* PECastSize::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t    unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      ivl_assert(*this, size_);\n      ivl_assert(*this, base_);\n\n\t// A cast behaves exactly like an assignment to a temporary variable,\n\t// so the temporary result size may affect the sub-expression width.\n      unsigned cast_width = base_->expr_width();\n      if (cast_width < expr_width_)\n            cast_width = expr_width_;\n\n      NetExpr*sub = base_->elaborate_expr(des, scope, cast_width, flags);\n      if (sub == 0)\n\t    return 0;\n\n\t// Perform the cast. The extension method (zero/sign), if needed,\n\t// depends on the type of the base expression.\n      NetExpr*tmp = cast_to_width(sub, expr_width_, base_->has_sign(), *this);\n\n\t// Pad up to the expression width. The extension method (zero/sign)\n\t// depends on the type of enclosing expression.\n      return pad_to_width(tmp, expr_wid, signed_flag_, *this);\n}\n\nunsigned PECastType::test_width(Design*des, NetScope*scope, width_mode_t&)\n{\n      target_type_ = target_->elaborate_type(des, scope);\n\n      width_mode_t tmp_mode = PExpr::SIZED;\n      base_->test_width(des, scope, tmp_mode);\n\n      if (const netdarray_t*use_darray = dynamic_cast<const netdarray_t*>(target_type_)) {\n\t    expr_type_  = use_darray->element_base_type();\n\t    expr_width_ = use_darray->element_width();\n\n      } else if (const netstring_t*use_string = dynamic_cast<const netstring_t*>(target_type_)) {\n\t    expr_type_  = use_string->base_type();\n\t    expr_width_ = 8;\n\n      } else {\n\t    expr_type_  = target_type_->base_type();\n\t    expr_width_ = target_type_->packed_width();\n      }\n      min_width_   = expr_width_;\n      signed_flag_ = target_type_->get_signed();\n\n      return expr_width_;\n}\n\nNetExpr* PECastType::elaborate_expr(Design*des, NetScope*scope,\n                                    ivl_type_t type, unsigned flags) const\n{\n    const netdarray_t*darray = NULL;\n    const netvector_t*vector = NULL;\n\n    // Casting array of vectors to dynamic array type\n    if((darray = dynamic_cast<const netdarray_t*>(type)) &&\n            (vector = dynamic_cast<const netvector_t*>(darray->element_type()))) {\n        PExpr::width_mode_t mode = PExpr::SIZED;\n        unsigned use_wid = base_->test_width(des, scope, mode);\n        NetExpr*base = base_->elaborate_expr(des, scope, use_wid, NO_FLAGS);\n\n        ivl_assert(*this, vector->packed_width() > 0);\n        ivl_assert(*this, base->expr_width() > 0);\n\n        // Find rounded up length that can fit the whole casted array of vectors\n        int len = base->expr_width() + vector->packed_width() - 1;\n        if(base->expr_width() > (unsigned)vector->packed_width()) {\n            len /= vector->packed_width();\n        } else {\n            len /= base->expr_width();\n        }\n\n        // Number of words in the created dynamic array\n        NetEConst*len_expr = new NetEConst(verinum(len));\n        return new NetENew(type, len_expr, base);\n    }\n\n    // Fallback\n    return elaborate_expr(des, scope, (unsigned) 0, flags);\n}\n\nNetExpr* PECastType::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t    unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n\t// A cast behaves exactly like an assignment to a temporary variable,\n\t// so the temporary result size may affect the sub-expression width.\n      unsigned cast_width = base_->expr_width();\n      if (type_is_vectorable(base_->expr_type()) && (cast_width < expr_width_))\n\t    cast_width = expr_width_;\n\n      NetExpr*sub = base_->elaborate_expr(des, scope, cast_width, flags);\n      if (sub == 0)\n\t    return 0;\n\n      NetExpr*tmp = 0;\n      if (dynamic_cast<const netreal_t*>(target_type_)) {\n\t    return cast_to_real(sub);\n      } else if (dynamic_cast<const netstring_t*>(target_type_)) {\n\t    if (base_->expr_type() == IVL_VT_STRING)\n\t\t  return sub; // no conversion\n\t    if (base_->expr_type() == IVL_VT_LOGIC ||\n\t\tbase_->expr_type() == IVL_VT_BOOL)\n\t\t  return sub; // handled by the target as special cases\n      } else if (target_type_ && target_type_->packed()) {\n\t    switch (target_type_->base_type()) {\n\t\tcase IVL_VT_BOOL:\n\t\t  tmp = cast_to_int2(sub, expr_width_);\n\t\t  break;\n\n\t\tcase IVL_VT_LOGIC:\n\t\t  tmp = cast_to_int4(sub, expr_width_);\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t    }\n      }\n      if (tmp) {\n\t    if (tmp == sub) {\n\t\t    // We already had the correct base type, so we just need to\n\t\t    // fix the size. Note that even if the size is already correct,\n                    // we still need to isolate the sub-expression from changes in\n                    // the signedness pushed down from the main expression.\n\t\t  tmp = cast_to_width(sub, expr_width_, sub->has_sign(), *this);\n\t    }\n\t    return pad_to_width(tmp, expr_wid, signed_flag_, *this, target_type_);\n      }\n\n      cerr << get_fileline() << \": sorry: This cast operation is not yet supported.\" << endl;\n      des->errors += 1;\n      return 0;\n}\n\nunsigned PECastSign::test_width(Design *des, NetScope *scope, width_mode_t &mode)\n{\n      ivl_assert(*this, base_);\n\n      expr_width_ = sign_cast_width(des, scope, *base_, mode);\n      expr_type_  = base_->expr_type();\n      min_width_  = base_->min_width();\n\n      if (!type_is_vectorable(base_->expr_type())) {\n\t    cerr << get_fileline() << \": error: Cast base expression \"\n\t\t    \"must be a vector type.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      return expr_width_;\n}\n\nNetExpr* PECastSign::elaborate_expr(Design *des, NetScope *scope,\n\t\t\t\t    unsigned expr_wid, unsigned flags) const\n{\n      ivl_assert(*this, base_);\n\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      NetExpr *sub = base_->elaborate_expr(des, scope, expr_width_, flags);\n      if (!sub)\n\t    return nullptr;\n\n      return cast_to_width(sub, expr_wid, signed_flag_, *this);\n}\n\nunsigned PEConcat::test_width(Design*des, NetScope*scope, width_mode_t&)\n{\n      expr_width_ = 0;\n      enum {NO, MAYBE, YES} expr_is_string = MAYBE;\n      for (unsigned idx = 0 ; idx < parms_.size() ; idx += 1) {\n\t      // Add in the width of this sub-expression.\n\t    expr_width_ += parms_[idx]->test_width(des, scope, width_modes_[idx]);\n\n\t      // If we already know this is not a string, then move on.\n\t    if (expr_is_string == NO)\n\t\t  continue;\n\n\t      // If this expression is a string, then the\n\t      // concatenation is a string until we find a reason to\n\t      // deny it.\n\t    if (parms_[idx]->expr_type()==IVL_VT_STRING) {\n\t\t  expr_is_string = YES;\n\t\t  continue;\n\t    }\n\n\t      // If this is a string literal, then this may yet be a string.\n\t    if (dynamic_cast<PEString*> (parms_[idx]))\n\t\t  continue;\n\n\t      // Failed to allow a string result.\n\t    expr_is_string = NO;\n      }\n\n      expr_type_   = (expr_is_string==YES) ? IVL_VT_STRING : IVL_VT_LOGIC;\n      signed_flag_ = false;\n\n\t// If there is a repeat expression, then evaluate the constant\n\t// value and set the repeat count.\n      if (repeat_ && (scope != tested_scope_)) {\n\t    NetExpr*tmp = elab_and_eval(des, scope, repeat_, -1, true);\n\t    if (tmp == 0) return 0;\n\n\t    if (tmp->expr_type() == IVL_VT_REAL) {\n\t\t  cerr << tmp->get_fileline() << \": error: Concatenation \"\n\t\t       << \"repeat expression can not be REAL.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    NetEConst*rep = dynamic_cast<NetEConst*>(tmp);\n\n\t    if (rep == 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t\t\"Concatenation repeat expression is not constant.\"\n\t\t       << endl;\n\t\t  cerr << get_fileline() << \":      : The expression is: \"\n\t\t       << *tmp << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    if (!rep->value().is_defined()) {\n\t\t  cerr << get_fileline() << \": error: Concatenation repeat \"\n\t\t       << \"may not be undefined (\" << rep->value()\n\t\t       << \").\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    if (rep->value().is_negative()) {\n\t\t  cerr << get_fileline() << \": error: Concatenation repeat \"\n\t\t       << \"may not be negative (\" << rep->value().as_long()\n\t\t       << \").\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n            repeat_count_ = rep->value().as_ulong();\n\n            tested_scope_ = scope;\n      }\n      expr_width_ *= repeat_count_;\n      min_width_   = expr_width_;\n\n      return expr_width_;\n}\n\n// Keep track of the concatenation/repeat depth.\nstatic int concat_depth = 0;\n\nNetExpr* PEConcat::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t  ivl_type_t ntype, unsigned flags) const\n{\n      switch (ntype->base_type()) {\n\t  case IVL_VT_QUEUE:\n// FIXME: Does a DARRAY support a zero size?\n\t  case IVL_VT_DARRAY:\n\t    if (parms_.size() == 0) {\n\t\t  NetENull*tmp = new NetENull;\n\t\t  tmp->set_line(*this);\n\t\t  return tmp;\n\t    } else {\n\t\t  const netdarray_t*array_type = dynamic_cast<const netdarray_t*> (ntype);\n\t\t  ivl_assert(*this, array_type);\n\n\t\t    // This is going to be an array pattern, so run through the\n\t\t    // elements of the expression and elaborate each as if they\n\t\t    // are element_type expressions.\n\t\t  ivl_type_t elem_type = array_type->element_type();\n\t\t  vector<NetExpr*> elem_exprs (parms_.size());\n\t\t  for (size_t idx = 0 ; idx < parms_.size() ; idx += 1) {\n\t\t\tNetExpr*tmp = parms_[idx]->elaborate_expr(des, scope, elem_type, flags);\n\t\t\telem_exprs[idx] = tmp;\n\t\t  }\n\n\t\t  NetEArrayPattern*res = new NetEArrayPattern(array_type, elem_exprs);\n\t\t  res->set_line(*this);\n\t\t  return res;\n\t    }\n\t  default:\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"I don't know how to elaborate(ivl_type_t)\"\n\t\t << \" this expression: \" << *this << endl;\n\t    return 0;\n      }\n}\n\nNetExpr* PEConcat::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t  unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      concat_depth += 1;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Elaborate expr=\" << *this\n\t\t << \", expr_wid=\" << expr_wid << endl;\n      }\n\n      if (repeat_count_ == 0 && concat_depth < 2) {\n            cerr << get_fileline() << \": error: Concatenation repeat \"\n                 << \"may not be zero in this context.\" << endl;\n            des->errors += 1;\n            concat_depth -= 1;\n            return 0;\n      }\n\n      unsigned wid_sum = 0;\n      unsigned parm_cnt = 0;\n      unsigned parm_errors = 0;\n      std::vector<NetExpr*> parms(parms_.size());\n\n\t/* Elaborate all the parameters and attach them to the concat node. */\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\t    if (parms_[idx] == 0) {\n\t\t  cerr << get_fileline() << \": error: Missing expression \"\n\t\t       << (idx+1) << \" of concatenation list.\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    ivl_assert(*this, parms_[idx]);\n            unsigned wid = parms_[idx]->expr_width();\n\t    NetExpr*ex = parms_[idx]->elaborate_expr(des, scope, wid, flags);\n\t    if (ex == 0) continue;\n\n\t    ex->set_line(*parms_[idx]);\n\n            eval_expr(ex, -1);\n\n\t    if (ex->expr_type() == IVL_VT_REAL) {\n\t\t  cerr << ex->get_fileline() << \": error: \"\n\t\t       << \"Concatenation operand can not be real: \"\n\t\t       << *parms_[idx] << endl;\n\t\t  des->errors += 1;\n                  parm_errors += 1;\n\t\t  continue;\n\t    }\n\n\t    if (width_modes_[idx] != SIZED) {\n\t\t  cerr << ex->get_fileline() << \": error: \"\n\t\t       << \"Concatenation operand \\\"\" << *parms_[idx]\n\t\t       << \"\\\" has indefinite width.\" << endl;\n\t\t  des->errors += 1;\n                  parm_errors += 1;\n\t\t  continue;\n\t    }\n\n\t      /* We are going to ignore zero width constants. */\n\t    if ((ex->expr_width() == 0) && dynamic_cast<NetEConst*>(ex)) {\n\t\t  parms[idx] = 0;\n\t    } else {\n\t\t  parms[idx] = ex;\n\t\t  parm_cnt += 1;\n\t    }\n\t    wid_sum += ex->expr_width();\n      }\n      if (parm_errors) {\n\t    concat_depth -= 1;\n\t    return 0;\n      }\n\n\t/* Make the empty concat expression. */\n      NetEConcat*cncat = new NetEConcat(parm_cnt, repeat_count_, expr_type_);\n      cncat->set_line(*this);\n\n\t/* Remove any zero width constants. */\n      unsigned off = 0;\n      for (unsigned idx = 0 ;  idx < parm_cnt ;  idx += 1) {\n\t    while (parms[off+idx] == 0) off += 1;\n\t    cncat->set(idx, parms[off+idx]);\n      }\n\n      if (wid_sum == 0 && expr_type_ != IVL_VT_STRING) {\n\t    cerr << get_fileline() << \": error: Concatenation/replication \"\n\t         << \"may not have zero width in this context.\" << endl;\n\t    des->errors += 1;\n\t    concat_depth -= 1;\n\t    delete cncat;\n\t    return 0;\n      }\n\n      NetExpr*tmp = pad_to_width(cncat, expr_wid, signed_flag_, *this);\n\n      concat_depth -= 1;\n      return tmp;\n}\n\n/*\n * Floating point literals are not vectorable. It's not particularly\n * clear what to do about an actual width to return, but whatever the\n * width, it is unsigned.\n *\n * Absent any better idea, we call all real valued results a width of 1.\n */\nunsigned PEFNumber::test_width(Design*, NetScope*, width_mode_t&)\n{\n      expr_type_   = IVL_VT_REAL;\n      expr_width_  = 1;\n      min_width_   = 1;\n      signed_flag_ = true;\n\n      return expr_width_;\n}\n\nNetExpr* PEFNumber::elaborate_expr(Design*, NetScope*, ivl_type_t, unsigned) const\n{\n      NetECReal*tmp = new NetECReal(*value_);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetExpr* PEFNumber::elaborate_expr(Design*, NetScope*, unsigned, unsigned) const\n{\n      NetECReal*tmp = new NetECReal(*value_);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nbool PEIdent::calculate_packed_indices_(Design*des, NetScope*scope, NetNet*net,\n\t\t\t\t\tlist<long>&prefix_indices) const\n{\n      unsigned dimensions = net->unpacked_dimensions() + net->packed_dimensions();\n      switch (net->data_type()) {\n\t  case IVL_VT_STRING:\n\t  case IVL_VT_DARRAY:\n\t  case IVL_VT_QUEUE:\n\t    dimensions += 1;\n\t  default:\n\t    break;\n      }\n      if (path_.back().index.size() > dimensions) {\n\t    cerr << get_fileline() << \": error: the number of indices (\"\n\t\t << path_.back().index.size()\n\t\t << \") is greater than the number of dimensions (\"\n\t\t << dimensions\n\t\t << \").\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      list<index_component_t> index;\n      index = path_.back().index;\n      ivl_assert(*this, index.size() >= net->unpacked_dimensions());\n      for (size_t idx = 0 ; idx < net->unpacked_dimensions() ; idx += 1)\n\t    index.pop_front();\n\n      return evaluate_index_prefix(des, scope, prefix_indices, index);\n}\n\n\nbool PEIdent::calculate_bits_(Design*des, NetScope*scope,\n\t\t\t      long&msb, bool&defined) const\n{\n      defined = true;\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.sel == index_component_t::SEL_BIT);\n      ivl_assert(*this, index_tail.msb && !index_tail.lsb);\n\n\t/* This handles bit selects. In this case, there in one\n\t   bit select expressions which must be constant. */\n\n      NetExpr*msb_ex = elab_and_eval(des, scope, index_tail.msb, -1, true);\n      NetEConst*msb_c = dynamic_cast<NetEConst*>(msb_ex);\n      if (msb_c == 0) {\n\t    cerr << index_tail.msb->get_fileline() << \": error: \"\n\t            \"Bit select expressions must be a constant integral value.\"\n\t         << endl;\n\t    cerr << index_tail.msb->get_fileline() << \":      : \"\n\t            \"This expression violates that rule: \"\n\t         << *index_tail.msb << endl;\n\t    des->errors += 1;\n              /* Attempt to recover from error. */\n            msb = 0;\n      } else {\n\t    if (! msb_c->value().is_defined())\n\t\t  defined = false;\n            msb = msb_c->value().as_long();\n      }\n\n      delete msb_ex;\n      return true;\n}\n\n/*\n * Given that the msb_ and lsb_ are part select expressions, this\n * function calculates their values. Note that this method does *not*\n * convert the values to canonical form.\n */\nbool PEIdent::calculate_parts_(Design*des, NetScope*scope,\n\t\t\t       long&msb, long&lsb, bool&defined) const\n{\n      defined = true;\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.sel == index_component_t::SEL_PART);\n      ivl_assert(*this, index_tail.msb && index_tail.lsb);\n\n\t/* This handles part selects. In this case, there are\n\t   two bit select expressions, and both must be\n\t   constant. Evaluate them and pass the results back to\n\t   the caller. */\n      NetExpr*lsb_ex = elab_and_eval(des, scope, index_tail.lsb, -1, true);\n      NetEConst*lsb_c = dynamic_cast<NetEConst*>(lsb_ex);\n      if (lsb_c == 0) {\n\t    cerr << index_tail.lsb->get_fileline() << \": error: \"\n\t            \"Part select expressions must be constant integral values.\"\n\t         << endl;\n\t    cerr << index_tail.lsb->get_fileline() << \":      : \"\n\t            \"The lsb expression violates that rule: \"\n\t         << *index_tail.lsb << endl;\n\t    des->errors += 1;\n              /* Attempt to recover from error. */\n            lsb = 0;\n      } else {\n\t    if (! lsb_c->value().is_defined())\n\t\t  defined = false;\n            lsb = lsb_c->value().as_long();\n      }\n\n      NetExpr*msb_ex = elab_and_eval(des, scope, index_tail.msb, -1, true);\n      NetEConst*msb_c = dynamic_cast<NetEConst*>(msb_ex);\n      if (msb_c == 0) {\n\t    cerr << index_tail.msb->get_fileline() << \": error: \"\n\t            \"Part select expressions must be constant integral values.\"\n\t         << endl;\n\t    cerr << index_tail.msb->get_fileline() << \":      : \"\n\t            \"The msb expression violates that rule: \"\n\t         << *index_tail.msb << endl;\n\t    des->errors += 1;\n              /* Attempt to recover from error. */\n            msb = lsb;\n      } else {\n\t    if (! msb_c->value().is_defined())\n\t\t  defined = false;\n            msb = msb_c->value().as_long();\n      }\n\n      delete msb_ex;\n      delete lsb_ex;\n      return true;\n}\n\nbool PEIdent::calculate_up_do_width_(Design*des, NetScope*scope,\n\t\t\t\t     unsigned long&wid) const\n{\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.lsb && index_tail.msb);\n\n      bool flag = true;\n\n\t/* Calculate the width expression (in the lsb_ position)\n\t   first. If the expression is not constant, error but guess 1\n\t   so we can keep going and find more errors. */\n      NetExpr*wid_ex = elab_and_eval(des, scope, index_tail.lsb, -1, true);\n      NetEConst*wid_c = dynamic_cast<NetEConst*>(wid_ex);\n\n      wid = wid_c ? wid_c->value().as_ulong() : 0;\n      if (wid == 0) {\n\t    cerr << index_tail.lsb->get_fileline() << \": error: \"\n\t\t  \"Indexed part select width must be an integral constants greater than zero.\"\n\t\t << endl;\n\t    cerr << index_tail.lsb->get_fileline() << \":      : \"\n\t\t  \"This width expression violates that rule: \"\n\t\t << *index_tail.lsb << endl;\n\t    des->errors += 1;\n\t    flag = false;\n\t    wid = 1;\n      }\n      delete wid_ex;\n\n      return flag;\n}\n\n/*\n * When we know that this is an indexed part select (up or down) this\n * method calculates the up/down base, as far at it can be calculated.\n */\nNetExpr* PEIdent::calculate_up_do_base_(Design*des, NetScope*scope,\n                                        bool need_const) const\n{\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.lsb != 0);\n      ivl_assert(*this, index_tail.msb != 0);\n\n      NetExpr*tmp = elab_and_eval(des, scope, index_tail.msb, -1, need_const);\n      return tmp;\n}\n\nunsigned PEIdent::test_width_parameter_(const NetExpr *par, width_mode_t&mode)\n{\n\t// The width of an enumeration literal is the width of the\n\t// enumeration base.\n      if (const NetEConstEnum*par_enum = dynamic_cast<const NetEConstEnum*> (par)) {\n\t    const netenum_t*use_enum = par_enum->enumeration();\n\t    ivl_assert(*this, use_enum != 0);\n\n\t    expr_type_   = use_enum->base_type();\n\t    expr_width_  = use_enum->packed_width();\n\t    min_width_   = expr_width_;\n\t    signed_flag_ = par_enum->has_sign();\n\n\t    return expr_width_;\n      }\n\n      expr_type_   = par->expr_type();\n      expr_width_  = par->expr_width();\n      min_width_   = expr_width_;\n      signed_flag_ = par->has_sign();\n\n      if (!par->has_width() && (mode < LOSSLESS))\n\t    mode = LOSSLESS;\n\n      return expr_width_;\n}\n\nivl_type_t PEIdent::resolve_type_(Design *des, const symbol_search_results &sr,\n\t\t\t\t  unsigned int &index_depth) const\n{\n      ivl_type_t type;\n      if (sr.net && sr.net->unpacked_dimensions())\n\t    type = sr.net->array_type();\n      else\n\t    type = sr.type;\n\n      auto path = sr.path_tail.cbegin();\n\n      ivl_assert(*this, !sr.path_head.empty());\n\n      // Start with processing the indices of the path head\n      auto indices = &sr.path_head.back().index;\n\n      while (type) {\n\t    auto index = indices->cbegin();\n\t    index_depth = indices->size();\n\n\t    // First process all indices\n\t    while (index_depth) {\n\t\t  if (type == &netstring_t::type_string) {\n\t\t\tindex++;\n\t\t\tindex_depth--;\n\t\t\ttype = &netvector_t::atom2u8;\n\t\t  } else if (auto array = dynamic_cast<const netsarray_t*>(type)) {\n\t\t\tauto array_size = array->static_dimensions().size();\n\n\t\t\t// Not enough indices to consume the array\n\t\t\tif (index_depth < array_size)\n\t\t\t      return type;\n\n\t\t\tindex_depth -= array_size;\n\t\t\twhile (array_size--)\n\t\t\t      index++;\n\n\t\t\ttype = array->element_type();\n\t\t  } else if (auto darray = dynamic_cast<const netdarray_t*>(type)) {\n\t\t\tindex++;\n\t\t\tindex_depth--;\n\t\t\ttype = darray->element_type();\n\t\t  } else {\n\t\t\treturn type;\n\t\t  }\n\t    }\n\n\t    if (path == sr.path_tail.cend())\n\t\t  return type;\n\n\t    // Next look up the next path element based on name\n\n\t    const auto &name = path->name;\n\n\t    if (auto class_type = dynamic_cast<const netclass_t*>(type)) {\n\t\t  // If the type is an object, the next path member may be a\n\t\t  // class property.\n\t\t  ivl_type_t par_type;\n\t\t  if (class_type->get_parameter(des, name, par_type)) {\n\t\t\ttype = par_type;\n\t\t  } else {\n\t\t\tint pidx = class_type->property_idx_from_name(name);\n\t\t\tif (pidx < 0)\n\t\t\t      return nullptr;\n\n\t\t\ttype = class_type->get_prop_type(pidx);\n\t\t  }\n\t    } else if (auto struct_type = dynamic_cast<const netstruct_t*>(type)) {\n\t\t  // If this net is a struct, the next path element may be a\n\t\t  // struct member. If it is, then we know the type of this\n\t\t  // identifier by knowing the type of the member.\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": debug: PEIdent::test_width: \"\n\t\t\t     << \"Element is a struct, \"\n\t\t\t     << \"checking width of member \" << name << endl;\n\t\t  }\n\n\t\t  unsigned long unused;\n\t\t  auto mem = struct_type->packed_member(name, unused);\n\t\t  if (!mem)\n\t\t\treturn nullptr;\n\n\t\t  type = mem->net_type;\n\t    } else if (auto queue = dynamic_cast<const netqueue_t*>(type)) {\n\t\t  if (name == \"size\")\n\t\t\ttype = &netvector_t::atom2s32;\n\t\t  else if (name == \"pop_back\" || name == \"pop_front\")\n\t\t\ttype = queue->element_type();\n\t\t  else\n\t\t\treturn nullptr;\n\t    } else if (dynamic_cast<const netdarray_t*>(type)) {\n\t\t  if (name == \"size\")\n\t\t\ttype = &netvector_t::atom2s32;\n\t\t  else\n\t\t\treturn nullptr;\n\t    } else if (auto netenum = dynamic_cast<const netenum_t*>(type)) {\n\t\t  if (name == \"num\")\n\t\t\ttype = &netvector_t::atom2s32;\n\t\t  else if ((name == \"first\") || (name == \"last\") ||\n\t\t\t   (name == \"next\") || (name == \"prev\"))\n\t\t\ttype = netenum;\n\t\t  else\n\t\t\treturn nullptr;\n\t    } else {\n\t\t  // Type has no members, properties or functions. Path is\n\t\t  // invalid.\n\t\t  return nullptr;\n\t    }\n\n\t    indices = &path->index;\n\t    path++;\n      }\n\n      return type;\n}\n\nunsigned PEIdent::test_width(Design*des, NetScope*scope, width_mode_t&mode)\n{\n      symbol_search_results sr;\n      bool found_symbol = symbol_search(this, des, scope, path_, lexical_pos_, &sr);\n\n\t// If there is a part/bit select expression, then process it\n\t// here. This constrains the results no matter what kind the\n\t// name is.\n\n      const name_component_t&name_tail = path_.back();\n      index_component_t::ctype_t use_sel = index_component_t::SEL_NONE;\n      if (!name_tail.index.empty()) {\n\t    const index_component_t&index_tail = name_tail.index.back();\n\t    use_sel = index_tail.sel;\n      }\n\n      unsigned use_width = UINT_MAX;\n      switch (use_sel) {\n\t  case index_component_t::SEL_NONE:\n\t    break;\n\t  case index_component_t::SEL_PART:\n\t      { long msb, lsb;\n\t\tbool parts_defined;\n\t\tcalculate_parts_(des, scope, msb, lsb, parts_defined);\n\t\tif (parts_defined)\n\t\t      use_width = 1 + ((msb>lsb) ? (msb-lsb) : (lsb-msb));\n\t\telse\n\t\t      use_width = UINT_MAX;\n\t\tbreak;\n\t      }\n\t  case index_component_t::SEL_IDX_UP:\n\t  case index_component_t::SEL_IDX_DO:\n\t      { unsigned long tmp = 0;\n\t\tcalculate_up_do_width_(des, scope, tmp);\n\t\tuse_width = tmp;\n\t\tbreak;\n\t      }\n\t  case index_component_t::SEL_BIT:\n\t      { ivl_assert(*this, !name_tail.index.empty());\n\t\tconst index_component_t&index_tail = name_tail.index.back();\n\t\tivl_assert(*this, index_tail.msb);\n\t      }\n\t      use_width = 1;\n\t      break;\n\t  case index_component_t::SEL_BIT_LAST:\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::test_width: \"\n\t\t       << \"Queue/Darray last index ($)\" << endl;\n\t    }\n\t    break;\n\t  default:\n\t    ivl_assert(*this, 0);\n      }\n\n      unsigned int use_depth = path_.back().index.size();\n      ivl_type_t type = nullptr;\n\n      if (found_symbol)\n\t    type = resolve_type_(des, sr, use_depth);\n\n      if (use_width != UINT_MAX && (!type || (use_depth != 0 && type->packed()))) {\n\t      // We have a bit/part select. Account for any remaining dimensions\n\t      // beyond the indexed dimension.\n\t    if (type) {\n\t\t  const auto &slice_dims = type->slice_dimensions();\n\t\t  for ( ; use_depth < slice_dims.size(); use_depth++)\n\t\t\tuse_width *= slice_dims[use_depth].width();\n\t    }\n\n\t    expr_type_   = IVL_VT_LOGIC; // Assume bit/parts selects are logic\n\t    expr_width_  = use_width;\n\t    min_width_   = use_width;\n            signed_flag_ = false;\n\n\t    return expr_width_;\n      }\n\n      // The width of a parameter is the width of the parameter value\n      // (as evaluated earlier).\n      if (sr.par_val != 0)\n\t    return test_width_parameter_(sr.par_val, mode);\n\n      // If the identifier has a type take the information from the type\n      if (type) {\n\t      // Unindexed indentifier\n\t    if (use_width == UINT_MAX)\n\t\t  use_width = 1;\n\n\t    // In this case, we have an unpacked array or a slice of an\n\t    // unpacked array. These expressions strictly speaking do\n\t    // not have a width. But we use the value calculated here\n\t    // for things $bits(), so return the full number of bits of\n\t    // the expression.\n\t    while (auto uarray = dynamic_cast<const netuarray_t *>(type)) {\n\t\t  const auto &dims = uarray->static_dimensions();\n\t\t  for ( ; use_depth < dims.size(); use_depth++)\n\t\t\tuse_width *= dims[use_depth].width();\n\n\t\t  type = uarray->element_type();\n\t\t  use_depth = 0;\n\t    }\n\n\t    const auto &slice_dims = type->slice_dimensions();\n\t    for ( ; use_depth < slice_dims.size(); use_depth++)\n\t\t  use_width *= slice_dims[use_depth].width();\n\n\t    expr_type_   = type->base_type();\n\t    expr_width_  = use_width;\n\t    min_width_   = expr_width_;\n\t    signed_flag_ = type->get_signed();\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::test_width: \"\n\t\t       << path_\n\t\t       << \", type=\" << expr_type_\n\t\t       << \", width=\" << expr_width_\n\t\t       << \", signed_=\" << (signed_flag_ ? \"true\" : \"false\")\n\t\t       << \", use_depth=\" << use_depth\n\t\t       << endl;\n\t    }\n\t    return expr_width_;\n      }\n\n      if (path_.size() == 1\n\t  && scope->genvar_tmp.str()\n\t  && strcmp(peek_tail_name(path_), scope->genvar_tmp) == 0) {\n\t    verinum val (scope->genvar_tmp_val);\n            expr_type_   = IVL_VT_BOOL;\n            expr_width_  = val.len();\n            min_width_   = expr_width_;\n            signed_flag_ = true;\n\n            if (gn_strict_expr_width_flag) {\n                  expr_width_ = integer_width;\n                  mode = UNSIZED;\n            } else if (mode < LOSSLESS) {\n                  mode = LOSSLESS;\n            }\n\n            return expr_width_;\n      }\n\n\t// Not a net, and not a parameter? Give up on the type, but\n\t// set the width to 0.\n      expr_type_   = IVL_VT_NO_TYPE;\n      expr_width_  = 0;\n      min_width_   = 0;\n      signed_flag_ = false;\n\n      return expr_width_;\n}\n\n\nNetExpr* PEIdent::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t ivl_type_t ntype, unsigned flags) const\n{\n      bool need_const = NEED_CONST & flags;\n\n      symbol_search_results sr;\n      symbol_search(this, des, scope, path_, lexical_pos_, &sr);\n\n      if (!sr.net) {\n            cerr << get_fileline() << \": error: Unable to bind variable `\"\n\t         << path_ << \"' in `\" << scope_path(scope) << \"'\" << endl;\n\t    if (sr.decl_after_use) {\n\t\t  cerr << sr.decl_after_use->get_fileline() << \":      : \"\n\t\t\t  \"A symbol with that name was declared here. \"\n\t\t\t  \"Check for declaration after use.\" << endl;\n\t    }\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n      NetNet *net = sr.net;\n\n      if (!sr.path_tail.empty()) {\n\t    if (net->struct_type()) {\n\t\t  return check_for_struct_members(this, des, scope, net,\n\t\t\t\t\t\t  sr.path_head.back().index,\n\t\t\t\t\t\t  sr.path_tail);\n\t    } else if (dynamic_cast<const netclass_t*>(sr.type)) {\n\t\t  return elaborate_expr_class_field_(des, scope, sr, 0, flags);\n\t    }\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t << \"Found net \" << net->name() << \" for expr \" << *this << endl;\n      }\n\n      ivl_type_t check_type = ntype;\n      if (const netdarray_t*array_type = dynamic_cast<const netdarray_t*> (ntype)) {\n            if (array_type->type_compatible(net->net_type())) {\n                  NetESignal*tmp = new NetESignal(net);\n                  tmp->set_line(*this);\n                  return tmp;\n            }\n\n              // Icarus allows a dynamic array to be initialised with a\n              // single elementary value, so try that next.\n\t    check_type = array_type->element_type();\n      }\n\n      if (! check_type->type_compatible(net->net_type())) {\n\t    cerr << get_fileline() << \": error: the type of the variable '\"\n\t\t << path_ << \"' doesn't match the context type.\" << endl;\n\n\t    cerr << get_fileline() << \":      : \" << \"variable type=\";\n\t    if (net->net_type())\n\t\t  net->net_type()->debug_dump(cerr);\n\t    else\n\t\t  cerr << \"<nil>\";\n\t    cerr << endl;\n\n\t    cerr << get_fileline() << \":      : \" << \"context type=\";\n\t    ivl_assert(*this, ntype);\n\t    ntype->debug_dump(cerr);\n\t    cerr << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n      ivl_assert(*this, ntype->type_compatible(net->net_type()));\n\n      const name_component_t&use_comp = path_.back();\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t << \"Typed ident \" << net->name()\n\t\t << \" with \" << use_comp.index.size() << \" indices\"\n\t\t << \" and \" << net->unpacked_dimensions() << \" expected.\"\n\t\t << endl;\n      }\n\n// FIXME: The real array to queue is failing here.\n      if (net->unpacked_dimensions() != use_comp.index.size()) {\n\t    cerr << get_fileline() << \": sorry: \"\n\t\t << \"Net \" << net->name()\n\t\t << \" expects \" << net->unpacked_dimensions()\n\t\t << \", but got \" << use_comp.index.size() << \".\"\n\t\t << endl;\n\t    des->errors += 1;\n\n\t    NetESignal*tmp = new NetESignal(net);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n      if (net->unpacked_dimensions() == 0) {\n\t    NetESignal*tmp = new NetESignal(net);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n\t// Convert a set of index expressions to a single expression\n\t// that addresses the canonical element.\n      list<NetExpr*>unpacked_indices;\n      list<long> unpacked_indices_const;\n      indices_flags idx_flags;\n      indices_to_expressions(des, scope, this,\n\t\t\t     use_comp.index, net->unpacked_dimensions(),\n\t\t\t     need_const,\n\t\t\t     idx_flags,\n\t\t\t     unpacked_indices,\n\t\t\t     unpacked_indices_const);\n\n      NetExpr*canon_index = 0;\n\n      if (idx_flags.invalid) {\n\t      // Nothing to do\n\n      } else if (idx_flags.undefined) {\n\t    cerr << get_fileline() << \": warning: \"\n\t\t << \"returning 'bx for undefined array access \"\n\t\t << net->name() << as_indices(unpacked_indices)\n\t\t << \".\" << endl;\n\n      } else if (idx_flags.variable) {\n\t    ivl_assert(*this, unpacked_indices.size() == net->unpacked_dimensions());\n\t    canon_index = normalize_variable_unpacked(net, unpacked_indices);\n\n      } else {\n\t    ivl_assert(*this, unpacked_indices_const.size() == net->unpacked_dimensions());\n\t    canon_index = normalize_variable_unpacked(net, unpacked_indices_const);\n      }\n\n      ivl_assert(*this, canon_index);\n      NetESignal*tmp = new NetESignal(net, canon_index);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\n/*\n * Elaborate an identifier in an expression. The identifier can be a\n * parameter name, a signal name or a memory name. It can also be a\n * scope name (Return a NetEScope) but only certain callers can use\n * scope names. However, we still support it here.\n *\n * Function names are not handled here, they are detected by the\n * parser and are elaborated by PECallFunction.\n *\n * The signal name may be escaped, but that affects nothing here.\n */\nNetExpr* PEIdent::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t unsigned expr_wid, unsigned flags) const\n{\n      NetExpr *result;\n\n      result = elaborate_expr_(des, scope, expr_wid, flags);\n      if (!result || !type_is_vectorable(expr_type_))\n\t    return result;\n\n      auto net_type = result->net_type();\n      if (net_type && !net_type->packed())\n\t    return result;\n\n      return pad_to_width(result, expr_wid, signed_flag_, *this);\n}\n\nNetExpr* PEIdent::elaborate_expr_(Design*des, NetScope*scope,\n\t\t\t\t unsigned expr_wid, unsigned flags) const\n{\n      ivl_assert(*this, scope);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t << \"path_=\" << path_\n\t\t << endl;\n      }\n\n      if (path_.size() > 1) {\n            if (NEED_CONST & flags) {\n                  cerr << get_fileline() << \": error: A hierarchical reference\"\n                          \" (`\" << path_ << \"') is not allowed in a constant\"\n                          \" expression.\" << endl;\n                  des->errors += 1;\n                  return 0;\n            }\n            if (scope->need_const_func()) {\n                  cerr << get_fileline() << \": error: A hierarchical reference\"\n                          \" (`\" << path_ << \"') is not allowed in a constant\"\n                          \" function.\" << endl;\n                  des->errors += 1;\n                  return 0;\n            }\n            scope->is_const_func(false);\n      }\n\n\t// Find the net/parameter/event object that this name refers\n\t// to. The path_ may be a scoped path, and may include method\n\t// or member name parts. For example, main.a.b.c may refer to\n\t// a net called \"b\" in the scope \"main.a\" and with a member\n\t// named \"c\". symbol_search() handles this for us.\n      symbol_search_results sr;\n      symbol_search(this, des, scope, path_, lexical_pos_, &sr);\n\n\t// If the identifier name is a parameter name, then return\n\t// the parameter value.\n      if (sr.par_val != 0) {\n\n\t    if (!sr.path_tail.empty()) {\n\t\t  cerr << get_fileline() << \": error: Parameter name \"\n\t\t       << sr.path_head << \" can't have member names (\"\n\t\t       << sr.path_tail << \").\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    return elaborate_expr_param_or_specparam_(des, scope, sr.par_val,\n\t\t\t\t\t\t      sr.scope, sr.type,\n\t\t\t\t\t\t      expr_wid, flags);\n      }\n\n\t// If the identifier names a signal (a variable or a net)\n\t// then create a NetESignal node to handle it.\n      if (sr.net != 0) {\n            if (NEED_CONST & flags) {\n                  cerr << get_fileline() << \": error: A reference to a net \"\n                          \"or variable (`\" << path_ << \"') is not allowed in \"\n                          \"a constant expression.\" << endl;\n\t          des->errors += 1;\n                  return 0;\n            }\n            if (sr.net->scope()->type() == NetScope::MODULE) {\n                  if (scope->need_const_func()) {\n                        cerr << get_fileline() << \": error: A reference to a \"\n                                \"non-local net or variable (`\" << path_ << \"') is \"\n                                \"not allowed in a constant function.\" << endl;\n                        des->errors += 1;\n                        return 0;\n                  }\n                  scope->is_const_func(false);\n            }\n\n\t      // If this is a struct, and there are members in the\n\t      // member_path, then generate an expression that\n\t      // reflects the member selection.\n\t    if (sr.net->struct_type() && !sr.path_tail.empty()) {\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t\t        \"Ident \" << sr.path_head\n\t\t\t     << \" look for struct member \" << sr.path_tail\n\t\t\t     << endl;\n\t\t  }\n\n\t\t  return check_for_struct_members(this, des, scope, sr.net,\n\t\t\t\t\t\t  sr.path_head.back().index,\n\t\t\t\t\t\t  sr.path_tail);\n\t    }\n\n\t      // If this is an array object, and there are members in\n\t      // the sr.path_tail, check for array properties.\n\t    if (sr.net->darray_type() && !sr.path_tail.empty()) {\n                  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t\t        \"Ident \" << sr.path_head\n\t\t\t     << \" looking for array property \" << sr.path_tail\n\t\t\t     << endl;\n                  }\n\n\t\t  ivl_assert(*this, sr.path_tail.size() == 1);\n\t\t  const name_component_t member_comp = sr.path_tail.front();\n\t\t  if (member_comp.name == \"size\") {\n\t\t\tNetESFunc*fun = new NetESFunc(\"$size\",\n\t\t\t\t\t\t      &netvector_t::atom2s32,\n\t\t\t\t\t\t      1);\n\t\t\tfun->set_line(*this);\n\n\t\t\tNetESignal*arg = new NetESignal(sr.net);\n\t\t\targ->set_line(*sr.net);\n\n\t\t\tfun->parm(0, arg);\n\t\t\treturn fun;\n\t\t  } else if (member_comp.name == \"find\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'find()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"find_index\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'find_index()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"find_first\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'find_first()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"find_first_index\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'find_first_index()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"find_last\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'find_last()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"find_last_index\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'find_last_index()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"min\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'min()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"max\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'max()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"unique\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'unique()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"unique_index\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'unique_index()' \"\n\t\t\t        \"array location method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n// FIXME: Check this is a real or integral type.\n\t\t  } else if (member_comp.name == \"sum\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'sum()' \"\n\t\t\t        \"array reduction method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"product\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'product()' \"\n\t\t\t        \"array reduction method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n// FIXME: Check this is only an integral type.\n\t\t  } else if (member_comp.name == \"and\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'and()' \"\n\t\t\t        \"array reduction method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"or\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'or()' \"\n\t\t\t        \"array reduction method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  } else if (member_comp.name == \"xor\") {\n\t\t\tcerr << get_fileline() << \": sorry: 'xor()' \"\n\t\t\t        \"array reduction method is not currently \"\n\t\t\t        \"implemented.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  }\n\t    }\n\n\t      // If this is a queue object, and there are members in\n\t      // the sr.path_tail, check for array properties.\n\t    if (sr.net->queue_type() && !sr.path_tail.empty()) {\n                  if (debug_elaborate) {\n                        cerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n                             << \"Ident \" << sr.path_head\n                             << \" looking for queue property \" << sr.path_tail\n                             << endl;\n                  }\n\n\t\t  ivl_assert(*this, sr.path_tail.size() == 1);\n\t\t  const name_component_t member_comp = sr.path_tail.front();\n\t\t  const netqueue_t*queue = sr.net->queue_type();\n\t\t  ivl_type_t element_type = queue->element_type();\n\t\t  if (member_comp.name == \"pop_back\") {\n\t\t\tNetESFunc*fun = new NetESFunc(\"$ivl_queue_method$pop_back\",\n\t\t\t                              element_type, 1);\n\t\t\tfun->set_line(*this);\n\n\t\t\tNetESignal*arg = new NetESignal(sr.net);\n\t\t\targ->set_line(*sr.net);\n\n\t\t\tfun->parm(0, arg);\n\t\t\treturn fun;\n\t\t  }\n\n\t\t  if (member_comp.name == \"pop_front\") {\n\t\t\tNetESFunc*fun = new NetESFunc(\"$ivl_queue_method$pop_front\",\n\t\t\t                              element_type, 1);\n\t\t\tfun->set_line(*this);\n\n\t\t\tNetESignal*arg = new NetESignal(sr.net);\n\t\t\targ->set_line(*sr.net);\n\n\t\t\tfun->parm(0, arg);\n\t\t\treturn fun;\n\t\t  }\n\t    }\n\n\t    if ((sr.net->data_type() == IVL_VT_STRING) && !sr.path_tail.empty()) {\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t\t        \"Ident \" << sr.path_head\n\t\t\t     << \" looking for string property \" << sr.path_tail\n\t\t\t     << endl;\n\t\t  }\n\n\t\t  ivl_assert(*this, sr.path_tail.size() == 1);\n\t\t  const name_component_t member_comp = sr.path_tail.front();\n\t\t  cerr << get_fileline() << \": sorry: String method '\"\n\t\t       << member_comp.name << \"' currently requires ().\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    if (dynamic_cast<const netclass_t*>(sr.type) && !sr.path_tail.empty()) {\n\t\t  return elaborate_expr_class_field_(des, scope, sr,\n\t\t\t\t\t\t     expr_wid, flags);\n\t    }\n\n\t    if (sr.net->enumeration() && !sr.path_tail.empty()) {\n\t\t  const netenum_t*netenum = sr.net->enumeration();\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t\t        \"Ident \" << sr.path_head\n\t\t\t     << \" look for enumeration method \" << sr.path_tail\n\t\t\t     << endl;\n\t\t  }\n\n\t\t  NetESignal*expr = new NetESignal(sr.net);\n\t\t  expr->set_line(*this);\n\t\t  ivl_assert(*this, sr.path_tail.size() == 1);\n\t\t  const name_component_t member_comp = sr.path_tail.front();\n\t\t  ivl_assert(*this, member_comp.index.empty());\n\t\t  return check_for_enum_methods(this, des, scope,\n\t\t\t\t\t\tnetenum, sr.path_head,\n\t\t\t\t\t\tmember_comp.name,\n\t\t\t\t\t\texpr, {});\n\t    }\n\n\t    ivl_assert(*this, sr.path_tail.empty());\n\t    NetExpr*tmp = elaborate_expr_net(des, scope, sr.net, sr.scope,\n                                             expr_wid, flags);\n\n            if (!tmp) return 0;\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_expr: \"\n\t\t          \"Expression as net. expr_wid=\" << expr_wid\n\t\t       << \", tmp->expr_width()=\" << tmp->expr_width()\n\t\t       << \", tmp=\" << *tmp << endl;\n\t    }\n\n            return tmp;\n      }\n\n\t// If the identifier is a named event\n        // then create a NetEEvent node to handle it.\n      if (sr.eve != 0) {\n            if (NEED_CONST & flags) {\n                  cerr << get_fileline() << \": error: A reference to a named \"\n                          \"event (`\" << path_ << \"') is not allowed in a \"\n                          \"constant expression.\" << endl;\n\t          des->errors += 1;\n                  return 0;\n            }\n            if (sr.eve->scope() != scope) {\n                  if (scope->need_const_func()) {\n                        cerr << get_fileline() << \": error: A reference to a \"\n                                \"non-local named event (`\" << path_ << \"') is \"\n                                \"not allowed in a constant function.\" << endl;\n                        des->errors += 1;\n                        return 0;\n                  }\n                  scope->is_const_func(false);\n            }\n\n\t    if (!sr.path_tail.empty()) {\n\t\t  cerr << get_fileline() << \": error: Event name \"\n\t\t       << sr.path_head << \" can't have member names (\"\n\t\t       << sr.path_tail << \")\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    NetEEvent*tmp = new NetEEvent(sr.eve);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n\t// Hmm... maybe this is a genvar? This is only possible while\n\t// processing generate blocks, but then the genvar_tmp will be\n\t// set in the scope.\n      if (path_.size() == 1\n\t  && scope->genvar_tmp.str()\n\t  && strcmp(peek_tail_name(path_), scope->genvar_tmp) == 0) {\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: \" << path_\n\t\t       << \" is genvar with value \" << scope->genvar_tmp_val\n\t\t       << \".\" << endl;\n\t    verinum val (scope->genvar_tmp_val, expr_wid);\n\t    val.has_sign(true);\n\t    NetEConst*tmp = new NetEConst(val);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n\n\t// At this point we've exhausted all the possibilities that\n\t// are not scopes. If this is not a system task argument, then\n\t// it cannot be a scope name, so give up.\n\n      if ( !(SYS_TASK_ARG & flags) ) {\n\t      // I cannot interpret this identifier. Error message.\n            cerr << get_fileline() << \": error: Unable to bind \"\n                 << ((NEED_CONST & flags) ? \"parameter\" : \"wire/reg/memory\")\n                 << \" `\" << path_ << \"' in `\" << scope_path(scope) << \"'\"\n                 << endl;\n            if (scope->need_const_func()) {\n                  cerr << get_fileline() << \":      : `\" << scope->basename()\n                       << \"' is being used as a constant function, so may \"\n                          \"only reference local variables.\" << endl;\n            }\n\t    if (sr.decl_after_use) {\n\t\t  cerr << sr.decl_after_use->get_fileline() << \":      : \"\n\t\t\t  \"A symbol with that name was declared here. \"\n\t\t\t  \"Check for declaration after use.\" << endl;\n\t    }\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Finally, if this is a scope name, then return that. Look\n\t// first to see if this is a name of a local scope. Failing\n\t// that, search globally for a hierarchical name.\n      if ((path_.size() == 1)) {\n\t    hname_t use_name ( peek_tail_name(path_) );\n\t    if (NetScope*nsc = scope->child(use_name)) {\n\t\t  NetEScope*tmp = new NetEScope(nsc);\n\t\t  tmp->set_line(*this);\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: Found scope \"\n\t\t\t     << use_name << \" in scope \" << scope->basename()\n\t\t\t     << endl;\n\n\t\t  return tmp;\n\t    }\n      }\n\n      list<hname_t> spath = eval_scope_path(des, scope, path_.name);\n\n      ivl_assert(*this, spath.size() == path_.size());\n\n\t// Try full hierarchical scope name.\n      if (NetScope*nsc = des->find_scope(spath)) {\n\t    NetEScope*tmp = new NetEScope(nsc);\n\t    tmp->set_line(*this);\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: Found scope \"\n\t\t       << nsc->basename()\n\t\t       << \" path=\" << path_ << endl;\n\n\t    if ( !(SYS_TASK_ARG & flags) ) {\n\t\t  cerr << get_fileline() << \": error: Scope name \"\n\t\t       << nsc->basename() << \" not allowed here.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    return tmp;\n      }\n\n\t// Try relative scope name.\n      if (NetScope*nsc = des->find_scope(scope, spath)) {\n\t    NetEScope*tmp = new NetEScope(nsc);\n\t    tmp->set_line(*this);\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: Found scope \"\n\t\t       << nsc->basename() << \" in \" << scope_path(scope) << endl;\n\n\t    return tmp;\n      }\n\n\t// I cannot interpret this identifier. Error message.\n      cerr << get_fileline() << \": error: Unable to bind wire/reg/memory \"\n              \"`\" << path_ << \"' in `\" << scope_path(scope) << \"'\" << endl;\n      des->errors += 1;\n      return 0;\n}\n\nstatic verinum param_part_select_bits(const verinum&par_val, long wid,\n\t\t\t\t     long lsv)\n{\n      verinum result (verinum::Vx, wid, true);\n\n      for (long idx = 0 ; idx < wid ; idx += 1) {\n\t    long off = idx + lsv;\n\t    if (off < 0)\n\t\t  continue;\n\t    else if (off < (long)par_val.len())\n\t\t  result.set(idx, par_val.get(off));\n\t    else if (par_val.is_string()) // Pad strings with nulls.\n\t\t  result.set(idx, verinum::V0);\n\t    else if (par_val.has_len()) // Pad sized parameters with X\n\t\t  continue;\n\t    else // Unsized parameters are \"infinite\" width.\n\t\t  result.set(idx, sign_bit(par_val));\n      }\n\n\t// If the input is a string, and the part select is working on\n\t// byte boundaries, then make the result into a string.\n      if (par_val.is_string() && (labs(lsv)%8 == 0) && (wid%8 == 0))\n\t    return verinum(result.as_string());\n\n      return result;\n}\n\nNetExpr* PEIdent::elaborate_expr_param_bit_(Design*des, NetScope*scope,\n\t\t\t\t\t    const NetExpr*par,\n\t\t\t\t\t    const NetScope*found_in,\n\t\t\t\t\t    ivl_type_t par_type,\n                                            bool need_const) const\n{\n      const NetEConst*par_ex = dynamic_cast<const NetEConst*> (par);\n      ivl_assert(*this, par_ex);\n\n      long par_msv, par_lsv;\n      if(! calculate_param_range(*this, par_type, par_msv, par_lsv,\n\t\t\t\t par_ex->value().len())) return 0;\n\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.msb);\n      ivl_assert(*this, !index_tail.lsb);\n\n      NetExpr*sel = elab_and_eval(des, scope, index_tail.msb, -1, need_const);\n      if (sel == 0) return 0;\n\n      perm_string name = peek_tail_name(path_);\n\n      if (sel->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: Index expression for \"\n\t         << name << \"[\" << *sel\n\t         << \"] cannot be a real value.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": debug: Calculate bit select \"\n\t\t << name << \"[\" << *sel << \"] from range \"\n\t\t << \"[\" << par_msv << \":\" << par_lsv << \"].\" << endl;\n\n\t// Handle the special case that the selection is constant. In this\n\t// case, just precalculate the entire constant result.\n      if (NetEConst*sel_c = dynamic_cast<NetEConst*> (sel)) {\n\t      // Special case: If the bit select is constant and not fully\n\t      // defined, then we know that the result must be 1'bx.\n\t    if (! sel_c->value().is_defined()) {\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline() << \": warning: \"\n\t\t\t        \"Constant undefined bit select [\"\n\t\t\t     << sel_c->value() << \"] for parameter '\"\n\t\t\t     << name << \"'.\" << endl;\n\t\t\tcerr << get_fileline() << \":        : \"\n\t\t\t        \"Replacing select with a constant 1'bx.\"\n\t\t\t     << endl;\n\t\t  }\n\t\t  NetEConst*res = make_const_x(1);\n\t\t  res->set_line(*this);\n\t\t  return res;\n\t    }\n\t      // Calculate the canonical index value.\n\t    long sel_v = sel_c->value().as_long();\n\t    if (par_msv >= par_lsv) sel_v -= par_lsv;\n\t    else sel_v = par_lsv - sel_v;\n\n\t      // Select a bit from the parameter.\n\t    verinum par_v = par_ex->value();\n\t    verinum::V rtn = verinum::Vx;\n\n\t      // A constant in range select.\n\t    if ((sel_v >= 0) && ((unsigned long) sel_v < par_v.len())) {\n\t\t  rtn = par_v[sel_v];\n\t      // An unsized after select.\n\t    } else if ((sel_v >= 0) && (! par_v.has_len())) {\n\t\t  if (par_v.has_sign()) rtn = par_v[par_v.len()-1];\n\t\t  else rtn = verinum::V0;\n\t    } else if (warn_ob_select) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t          \"Constant bit select [\" << sel_c->value().as_long()\n\t\t       << \"] is \";\n\t\t  if (sel_v < 0) cerr << \"before \";\n\t\t  else cerr << \"after \";\n\t\t  cerr << name << \"[\";\n\t\t  if (par_v.has_len()) cerr << par_msv;\n\t\t  else cerr << \"<inf>\";\n\t\t  cerr << \":\" << par_lsv << \"].\" << endl;\n\t\t  cerr << get_fileline() << \":        : \"\n\t\t          \"Replacing select with a constant 1'bx.\" << endl;\n\t    }\n\t    NetEConst*res = new NetEConst(verinum(rtn, 1));\n\t    res->set_line(*this);\n\t    return res;\n      }\n\n      sel = normalize_variable_base(sel, par_msv, par_lsv, 1, true);\n\n\t/* Create a parameter reference for the variable select. */\n      NetEConstParam*ptmp = new NetEConstParam(found_in, name, par_ex->value());\n      ptmp->set_line(found_in->get_parameter_line_info(name));\n\n      NetExpr*tmp = new NetESelect(ptmp, sel, 1);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetExpr* PEIdent::elaborate_expr_param_part_(Design*des, NetScope*scope,\n\t\t\t\t\t     const NetExpr*par,\n\t\t\t\t\t     const NetScope*,\n\t\t\t\t\t     ivl_type_t par_type,\n                                             unsigned expr_wid) const\n{\n      long msv, lsv;\n      bool parts_defined_flag;\n      bool flag = calculate_parts_(des, scope, msv, lsv, parts_defined_flag);\n      if (!flag)\n\t    return 0;\n\n      const NetEConst*par_ex = dynamic_cast<const NetEConst*> (par);\n      ivl_assert(*this, par_ex);\n\n\n      long par_msv, par_lsv;\n      if (! calculate_param_range(*this, par_type, par_msv, par_lsv,\n\t\t\t\t  par_ex->value().len())) return 0;\n\n      if (! parts_defined_flag) {\n\t    if (warn_ob_select) {\n\t\t  const index_component_t&psel = path_.back().index.back();\n\t\t  perm_string name = peek_tail_name(path_);\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t          \"Undefined part select [\" << *(psel.msb) << \":\"\n\t\t       << *(psel.lsb) << \"] for parameter '\" << name\n\t\t       << \"'.\" << endl;\n\t\t  cerr << get_fileline() << \":        : \"\n\t\t          \"Replacing select with a constant 'bx.\" << endl;\n\t    }\n\n\t    verinum val(verinum::Vx, expr_wid, true);\n\t    NetEConst*tmp = new NetEConst(val);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n\t// Notice that the par_msv is not used in this function other\n\t// than for this test. It is used to tell the direction that\n\t// the bits are numbers, so that we can make sure the\n\t// direction matches the part select direction. After that,\n\t// we only need the par_lsv.\n      if ((msv>lsv && par_msv<par_lsv) || (msv<lsv && par_msv>=par_lsv)) {\n\t    perm_string name = peek_tail_name(path_);\n\t    cerr << get_fileline() << \": error: Part select \" << name\n\t\t << \"[\" << msv << \":\" << lsv << \"] is out of order.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      long wid = 1 + labs(msv-lsv);\n\n\t// Watch out for reversed bit numbering. We're making\n\t// the part select from LSB to MSB.\n      long base;\n      if (par_msv < par_lsv) {\n\t    base = par_lsv - lsv;\n      } else {\n\t    base = lsv - par_lsv;\n      }\n\n      if (warn_ob_select) {\n\t    if (base < 0) {\n\t\t  perm_string name = peek_tail_name(path_);\n\t\t  cerr << get_fileline() << \": warning: Part select \"\n\t\t       << \"[\" << msv << \":\" << lsv << \"] is selecting \"\n\t\t          \"before the parameter \" << name << \"[\";\n\t\t  if (par_ex->value().has_len()) cerr << par_msv;\n\t\t  else cerr << \"<inf>\";\n\t\t  cerr << \":\" << par_lsv << \"].\" << endl;\n\t\t  cerr << get_fileline() << \":        : Replacing \"\n\t\t          \"the out of bound bits with 'bx.\" << endl;\n\t    }\n\t    if (par_ex->value().has_len() &&\n                (base+wid > (long)par->expr_width())) {\n\t\t  perm_string name = peek_tail_name(path_);\n\t\t  cerr << get_fileline() << \": warning: Part select \"\n\t\t       << name << \"[\" << msv << \":\" << lsv << \"] is selecting \"\n\t\t          \"after the parameter \" << name << \"[\" << par_msv\n\t\t       << \":\" << par_lsv << \"].\" << endl;\n\t\t  cerr << get_fileline() << \":        : Replacing \"\n\t\t          \"the out of bound bits with 'bx.\" << endl;\n\t    }\n      }\n\n      verinum result = param_part_select_bits(par_ex->value(), wid, base);\n      NetEConst*result_ex = new NetEConst(result);\n      result_ex->set_line(*this);\n\n      return result_ex;\n}\n\nstatic void warn_param_ob(long par_msv, long par_lsv, bool defined,\n                          long par_base, unsigned long wid, long pwid,\n                          const LineInfo *info, perm_string name, bool up)\n{\n      long par_max;\n\n      if (defined) {\n\t    if (par_msv < par_lsv) par_max = par_lsv-par_msv;\n\t     else par_max = par_msv-par_lsv;\n      } else {\n\t    if (pwid < 0) par_max = integer_width;\n\t    else par_max = pwid;\n      }\n\n\t/* Is this a select before the start of the parameter? */\n      if (par_base < 0) {\n\t    cerr << info->get_fileline() << \": warning: \" << name << \"[\"\n\t         << par_base;\n\t    if (up) cerr << \"+:\";\n\t    else cerr << \"-:\";\n\t    cerr << wid << \"] is selecting before vector.\" << endl;\n      }\n\n\t/* Is this a select after the end of the parameter? */\n      if (par_base + (long)wid - 1 > par_max) {\n\t    cerr << info->get_fileline() << \": warning: \" << name << \"[\"\n\t         << par_base;\n\t    if (up) cerr << \"+:\";\n\t    else cerr << \"-:\";\n\t    cerr << wid << \"] is selecting after vector.\" << endl;\n      }\n}\n\nNetExpr* PEIdent::elaborate_expr_param_idx_up_(Design*des, NetScope*scope,\n\t\t\t\t\t       const NetExpr*par,\n\t\t\t\t\t       const NetScope*found_in,\n\t\t\t\t\t       ivl_type_t par_type,\n                                               bool need_const) const\n{\n      const NetEConst*par_ex = dynamic_cast<const NetEConst*> (par);\n      ivl_assert(*this, par_ex);\n\n      long par_msv, par_lsv;\n      if(! calculate_param_range(*this, par_type, par_msv, par_lsv,\n\t\t\t\t par_ex->value().len())) return 0;\n\n      NetExpr*base = calculate_up_do_base_(des, scope, need_const);\n      if (base == 0) return 0;\n\n\t// Use the part select width already calculated by test_width().\n      unsigned long wid = min_width_;\n\n      perm_string name = peek_tail_name(path_);\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": debug: Calculate part select \"\n\t\t << name << \"[\" << *base << \"+:\" << wid << \"] from range \"\n\t\t << \"[\" << par_msv << \":\" << par_lsv << \"].\" << endl;\n\n      if (base->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: Indexed part select base \"\n\t            \"expression for \" << name << \"[\" << *base << \"+:\" << wid\n\t         << \"] cannot be a real value.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Handle the special case that the base is constant. In this\n\t// case, just precalculate the entire constant result.\n      if (NetEConst*base_c = dynamic_cast<NetEConst*> (base)) {\n\t    if (! base_c->value().is_defined()) {\n\t\t  NetEConst *ex;\n\t\t  ex = new NetEConst(verinum(verinum::Vx, wid, true));\n\t\t  ex->set_line(*this);\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline() << \": warning: \" << name\n\t\t\t     << \"['bx+:\" << wid\n\t\t\t     << \"] is always outside vector.\" << endl;\n\t\t  }\n\t\t  return ex;\n\t    }\n\t    long lsv = base_c->value().as_long();\n\t    long par_base = par_lsv;\n\n\t      // Watch out for reversed bit numbering. We're making\n\t      // the part select from LSB to MSB.\n\t    if (par_msv < par_lsv) {\n\t\t  par_base = lsv;\n\t\t  lsv = par_lsv - wid + 1;\n\t    }\n\n\t    if (warn_ob_select) {\n                  bool defined = true;\n\t\t    // Check to see if the parameter has a defined range.\n                  if (par_type == 0) {\n\t\t\tdefined = false;\n                  }\n\t\t    // Get the parameter values width.\n                  long pwid = -1;\n                  if (par_ex->has_width()) pwid = par_ex->expr_width()-1;\n                  warn_param_ob(par_msv, par_lsv, defined, lsv-par_base, wid,\n                                pwid, this, name, true);\n\t    }\n\t    verinum result = param_part_select_bits(par_ex->value(), wid,\n\t\t\t\t\t\t    lsv-par_base);\n\t    NetEConst*result_ex = new NetEConst(result);\n\t    result_ex->set_line(*this);\n\t    return result_ex;\n      }\n\n      base = normalize_variable_base(base, par_msv, par_lsv, wid, true);\n\n\t/* Create a parameter reference for the variable select. */\n      NetEConstParam*ptmp = new NetEConstParam(found_in, name, par_ex->value());\n      ptmp->set_line(found_in->get_parameter_line_info(name));\n\n      NetExpr*tmp = new NetESelect(ptmp, base, wid, IVL_SEL_IDX_UP);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetExpr* PEIdent::elaborate_expr_param_idx_do_(Design*des, NetScope*scope,\n\t\t\t\t\t       const NetExpr*par,\n\t\t\t\t\t       const NetScope*found_in,\n\t\t\t\t\t       ivl_type_t par_type,\n                                               bool need_const) const\n{\n      const NetEConst*par_ex = dynamic_cast<const NetEConst*> (par);\n      ivl_assert(*this, par_ex);\n\n      long par_msv, par_lsv;\n      if(! calculate_param_range(*this, par_type, par_msv, par_lsv,\n\t\t\t\t par_ex->value().len())) return 0;\n\n      NetExpr*base = calculate_up_do_base_(des, scope, need_const);\n      if (base == 0) return 0;\n\n\t// Use the part select width already calculated by test_width().\n      unsigned long wid = min_width_;\n\n      perm_string name = peek_tail_name(path_);\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": debug: Calculate part select \"\n\t\t << name << \"[\" << *base << \"-:\" << wid << \"] from range \"\n\t\t << \"[\" << par_msv << \":\" << par_lsv << \"].\" << endl;\n\n      if (base->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: Indexed part select base \"\n\t            \"expression for \" << name << \"[\" << *base << \"-:\" << wid\n\t         << \"] cannot be a real value.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Handle the special case that the base is constant. In this\n\t// case, just precalculate the entire constant result.\n      if (NetEConst*base_c = dynamic_cast<NetEConst*> (base)) {\n\t    if (! base_c->value().is_defined()) {\n\t\t  NetEConst *ex;\n\t\t  ex = new NetEConst(verinum(verinum::Vx, wid, true));\n\t\t  ex->set_line(*this);\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline() << \": warning: \" << name\n\t\t\t     << \"['bx-:\" << wid\n\t\t\t     << \"] is always outside vector.\" << endl;\n\t\t  }\n\t\t  return ex;\n\t    }\n\t    long lsv = base_c->value().as_long();\n\t    long par_base = par_lsv + wid - 1;\n\n\t      // Watch out for reversed bit numbering. We're making\n\t      // the part select from LSB to MSB.\n\t    if (par_msv < par_lsv) {\n\t\t  par_base = lsv;\n\t\t  lsv = par_lsv;\n\t    }\n\n\t    if (warn_ob_select) {\n                  bool defined = true;\n\t\t    // Check to see if the parameter has a defined range.\n                  if (par_type == 0) {\n\t\t\tdefined = false;\n                  }\n\t\t    // Get the parameter values width.\n                  long pwid = -1;\n                  if (par_ex->has_width()) pwid = par_ex->expr_width()-1;\n                  warn_param_ob(par_msv, par_lsv, defined, lsv-par_base, wid,\n                                pwid, this, name, false);\n\t    }\n\n\t    verinum result = param_part_select_bits(par_ex->value(), wid,\n\t\t\t\t\t\t    lsv-par_base);\n\t    NetEConst*result_ex = new NetEConst(result);\n\t    result_ex->set_line(*this);\n\t    return result_ex;\n      }\n\n      base = normalize_variable_base(base, par_msv, par_lsv, wid, false);\n\n\t/* Create a parameter reference for the variable select. */\n      NetEConstParam*ptmp = new NetEConstParam(found_in, name, par_ex->value());\n      ptmp->set_line(found_in->get_parameter_line_info(name));\n\n      NetExpr*tmp = new NetESelect(ptmp, base, wid, IVL_SEL_IDX_DOWN);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetExpr* PEIdent::elaborate_expr_param_or_specparam_(Design*des,\n\t\t\t\t\t\t     NetScope*scope,\n\t\t\t\t\t\t     const NetExpr*par,\n\t\t\t\t\t\t     NetScope*found_in,\n\t\t\t\t\t\t     ivl_type_t par_type,\n\t\t\t\t\t\t     unsigned expr_wid,\n\t\t\t\t\t\t     unsigned flags) const\n{\n      bool need_const = NEED_CONST & flags;\n\n      if (need_const && !(ANNOTATABLE & flags)) {\n            perm_string name = peek_tail_name(path_);\n            if (found_in->make_parameter_unannotatable(name)) {\n                  cerr << get_fileline() << \": warning: specparam '\" << name\n                       << \"' is being used in a constant expression.\" << endl;\n                  cerr << get_fileline() << \":        : This will prevent it \"\n                          \"being annotated at run time.\" << endl;\n            }\n      }\n\n      return elaborate_expr_param_(des, scope, par, found_in, par_type,\n\t\t\t           expr_wid, flags);\n}\n\n\n/*\n * Handle the case that the identifier is a parameter reference. The\n * parameter expression has already been located for us (as the par\n * argument) so we just need to process the sub-expression.\n */\nNetExpr* PEIdent::elaborate_expr_param_(Design*des,\n\t\t\t\t\tNetScope*scope,\n\t\t\t\t\tconst NetExpr*par,\n\t\t\t\t\tconst NetScope*found_in,\n\t\t\t\t\tivl_type_t par_type,\n\t\t\t\t\tunsigned expr_wid, unsigned flags) const\n{\n      bool need_const = NEED_CONST & flags;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Parameter: \" << path_ << endl;\n\t    if (par_type)\n\t\t  cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"par_type: \" << *par_type << endl;\n\t    else\n\t\t  cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"par_type: <nil>\" << endl;\n      }\n\n      const name_component_t&name_tail = path_.back();\n      index_component_t::ctype_t use_sel = index_component_t::SEL_NONE;\n      if (!name_tail.index.empty())\n\t    use_sel = name_tail.index.back().sel;\n\n      if (par->expr_type() == IVL_VT_REAL &&\n          use_sel != index_component_t::SEL_NONE) {\n\t    perm_string name = peek_tail_name(path_);\n\t    cerr << get_fileline() << \": error: \"\n\t         << \"can not select part of real parameter: \" << name << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      ivl_assert(*this, use_sel != index_component_t::SEL_BIT_LAST);\n\n      if (use_sel == index_component_t::SEL_BIT)\n\t    return elaborate_expr_param_bit_(des, scope, par, found_in,\n\t\t\t\t\t     par_type, need_const);\n\n      if (use_sel == index_component_t::SEL_PART)\n\t    return elaborate_expr_param_part_(des, scope, par, found_in,\n\t\t\t\t\t      par_type, expr_wid);\n\n      if (use_sel == index_component_t::SEL_IDX_UP)\n\t    return elaborate_expr_param_idx_up_(des, scope, par, found_in,\n\t\t\t\t\t\tpar_type, need_const);\n\n      if (use_sel == index_component_t::SEL_IDX_DO)\n\t    return elaborate_expr_param_idx_do_(des, scope, par, found_in,\n\t\t\t\t\t\tpar_type, need_const);\n\n      NetExpr*tmp = 0;\n\n      const NetEConstEnum*etmp = dynamic_cast<const NetEConstEnum*>(par);\n      if (etmp) {\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Elaborate parameter <\" << path_\n\t\t       << \"> as enumeration constant.\" << *etmp << endl;\n\t    tmp = etmp->dup_expr();\n      } else {\n\t    perm_string name = peek_tail_name(path_);\n\n\t      /* No bit or part select. Make the constant into a\n\t\t NetEConstParam or NetECRealParam as appropriate. */\n\t    const NetEConst*ctmp = dynamic_cast<const NetEConst*>(par);\n\t    if (ctmp) {\n                  verinum cvalue = ctmp->value();\n                  if (cvalue.has_len())\n\t\t\tcvalue.has_sign(signed_flag_);\n                  cvalue = cast_to_width(cvalue, expr_wid);\n\t\t  tmp = new NetEConstParam(found_in, name, cvalue);\n\t\t  tmp->cast_signed(signed_flag_);\n\t\t  tmp->set_line(*par);\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Elaborate parameter <\" << name\n\t\t\t     << \"> as constant \" << *tmp << endl;\n\t    }\n\n\t    const NetECReal*rtmp = dynamic_cast<const NetECReal*>(par);\n\t    if (rtmp) {\n\t\t  tmp = new NetECRealParam(found_in, name, rtmp->value());\n\t\t  tmp->set_line(*par);\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Elaborate parameter <\" << name\n\t\t\t     << \"> as constant \" << *tmp << endl;\n\t    }\n\t      /* The numeric parameter value needs to have the file and line\n\t       * information for the actual parameter not the expression. */\n\t    ivl_assert(*this, tmp);\n\t    tmp->set_line(found_in->get_parameter_line_info(name));\n      }\n\n      return tmp;\n}\n\n/*\n * Handle word selects of vector arrays.\n */\nNetExpr* PEIdent::elaborate_expr_net_word_(Design*des, NetScope*scope,\n\t\t\t\t\t   NetNet*net, NetScope*found_in,\n                                           unsigned expr_wid,\n\t\t\t\t\t   unsigned flags) const\n{\n      bool need_const = NEED_CONST & flags;\n\n      const name_component_t&name_tail = path_.back();\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_net_word_: \"\n\t\t << \"expr_wid=\" << expr_wid\n\t\t << \", net->get_scalar()==\" << (net->get_scalar()?\"true\":\"false\")\n\t\t << endl;\n      }\n\n\t// Special case: This is the entire array, and we are a direct\n\t// argument of a system task.\n      if (name_tail.index.empty() && (SYS_TASK_ARG & flags)) {\n\t    NetESignal*res = new NetESignal(net, 0);\n\t    res->set_line(*this);\n\t    return res;\n      }\n\n      if (name_tail.index.empty()) {\n\t    cerr << get_fileline() << \": error: Array \" << path()\n\t\t << \" needs an array index here.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Make sure there are enough indices to address an array element.\n      if (name_tail.index.size() < net->unpacked_dimensions()) {\n\t    cerr << get_fileline() << \": error: Array \" << path()\n\t\t << \" needs \" << net->unpacked_dimensions() << \" indices,\"\n\t\t << \" but got only \" << name_tail.index.size() << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Evaluate all the index expressions into an\n\t// \"unpacked_indices\" array.\n      list<NetExpr*>unpacked_indices;\n      list<long> unpacked_indices_const;\n      indices_flags idx_flags;\n      indices_to_expressions(des, scope, this,\n\t\t\t     name_tail.index, net->unpacked_dimensions(),\n\t\t\t     need_const,\n\t\t\t     idx_flags,\n\t\t\t     unpacked_indices,\n\t\t\t     unpacked_indices_const);\n\n      NetExpr*canon_index = 0;\n      if (idx_flags.invalid) {\n\t    // Nothing to do.\n\n      } else if (idx_flags.undefined) {\n\t    cerr << get_fileline() << \": warning: \"\n\t\t << \"returning 'bx for undefined array access \"\n\t\t << net->name() << as_indices(unpacked_indices)\n\t\t << \".\" << endl;\n\n      } else if (idx_flags.variable) {\n\t    ivl_assert(*this, unpacked_indices.size() == net->unpacked_dimensions());\n\t    canon_index = normalize_variable_unpacked(net, unpacked_indices);\n\n      } else {\n\t    ivl_assert(*this, unpacked_indices_const.size() == net->unpacked_dimensions());\n\t    canon_index = normalize_variable_unpacked(net, unpacked_indices_const);\n\n\t    if (canon_index == 0) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t       << \"returning 'bx for out of bounds array access \"\n\t\t       << net->name() << as_indices(unpacked_indices_const)\n\t\t       << \".\" << endl;\n\t    }\n      }\n\n      if (canon_index == 0) {\n\t    NetEConst*xxx = make_const_x(net->vector_width());\n\t    xxx->set_line(*this);\n\t    return xxx;\n      }\n      canon_index->set_line(*this);\n\n      NetESignal*res = new NetESignal(net, canon_index);\n      res->set_line(*this);\n\n\t// Detect that the word has a bit/part select as well.\n\n      index_component_t::ctype_t word_sel = index_component_t::SEL_NONE;\n      if (name_tail.index.size() > net->unpacked_dimensions())\n\t    word_sel = name_tail.index.back().sel;\n\n      if (net->get_scalar() &&\n          word_sel != index_component_t::SEL_NONE) {\n\t    cerr << get_fileline() << \": error: can not select part of \";\n\t    if (res->expr_type() == IVL_VT_REAL) cerr << \"real\";\n\t    else cerr << \"scalar\";\n\t    cerr << \" array word: \" << net->name()\n\t\t << as_indices(unpacked_indices) << endl;\n\t    des->errors += 1;\n\t    delete res;\n\t    return 0;\n      }\n\n      if (word_sel == index_component_t::SEL_PART)\n\t    return elaborate_expr_net_part_(des, scope, res, found_in,\n                                            expr_wid);\n\n      if (word_sel == index_component_t::SEL_IDX_UP)\n\t    return elaborate_expr_net_idx_up_(des, scope, res, found_in,\n                                              need_const);\n\n      if (word_sel == index_component_t::SEL_IDX_DO)\n\t    return elaborate_expr_net_idx_do_(des, scope, res, found_in,\n                                              need_const);\n\n      if (word_sel == index_component_t::SEL_BIT)\n\t    return elaborate_expr_net_bit_(des, scope, res, found_in,\n                                           need_const);\n\n      ivl_assert(*this, word_sel == index_component_t::SEL_NONE);\n\n      return res;\n}\n\n/*\n * Handle part selects of NetNet identifiers.\n */\nNetExpr* PEIdent::elaborate_expr_net_part_(Design*des, NetScope*scope,\n\t\t\t\t           NetESignal*net, NetScope*,\n                                           unsigned expr_wid) const\n{\n      if (net->sig()->data_type() == IVL_VT_STRING) {\n\t    cerr << get_fileline() << \": error: Cannot take the part select of a string ('\"\n\t         << net->name() << \"').\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      list<long> prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, net->sig(), prefix_indices);\n      if (!rc)\n\t    return 0;\n\n      long msv, lsv;\n      bool parts_defined_flag;\n      bool flag = calculate_parts_(des, scope, msv, lsv, parts_defined_flag);\n      if (!flag)\n\t    return 0;\n\n\t/* But wait... if the part select expressions are not fully\n\t   defined, then fall back on the tested width. */\n      if (!parts_defined_flag) {\n\t    if (warn_ob_select) {\n\t\t  const index_component_t&psel = path_.back().index.back();\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t          \"Undefined part select [\" << *(psel.msb) << \":\"\n\t\t       << *(psel.lsb) << \"] for \";\n\t\t  if (net->word_index()) cerr << \"array word\";\n\t\t  else cerr << \"vector\";\n\t\t  cerr << \" '\" << net->name();\n\t\t  if (net->word_index()) cerr << \"[]\";\n\t\t  cerr << \"'.\" << endl;\n\t\t  cerr << get_fileline() << \":        : \"\n\t\t          \"Replacing select with a constant 'bx.\" << endl;\n\t    }\n\n\t    NetEConst*tmp = new NetEConst(verinum(verinum::Vx, expr_wid, true));\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n      long sb_lsb, sb_msb;\n      if (prefix_indices.size()+1 < net->sig()->packed_dims().size()) {\n\t      // Here we have a slice that doesn't have enough indices\n\t      // to get to a single slice. For example:\n\t      //    wire [9:0][5:1] foo\n\t      //      ... foo[4:3] ...\n\t      // Make this work by finding the indexed slices and\n\t      // creating a generated slice that spans the whole\n\t      // range.\n\t    unsigned long lwid, mwid;\n\t    bool lrc, mrc;\n\t    lrc = net->sig()->sb_to_slice(prefix_indices, lsv, sb_lsb, lwid);\n\t    mrc = net->sig()->sb_to_slice(prefix_indices, msv, sb_msb, mwid);\n\t    if (!mrc || !lrc) {\n\t\t  cerr << get_fileline() << \": error: \";\n\t\t  cerr << \"Part-select [\" << msv << \":\" << lsv;\n\t\t  cerr << \"] exceeds the declared bounds for \";\n\t\t  cerr << net->sig()->name();\n\t\t  if (net->sig()->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t  cerr << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    ivl_assert(*this, lwid == mwid);\n\t    sb_msb += mwid - 1;\n      } else {\n\t      // This case, the prefix indices are enough to index\n\t      // down to a single bit/slice.\n\t    ivl_assert(*this, prefix_indices.size()+1 == net->sig()->packed_dims().size());\n\t    sb_lsb = net->sig()->sb_to_idx(prefix_indices, lsv);\n\t    sb_msb = net->sig()->sb_to_idx(prefix_indices, msv);\n      }\n\n      if (sb_msb < sb_lsb) {\n\t    cerr << get_fileline() << \": error: part select \" << net->name();\n\t    if (net->word_index()) cerr << \"[]\";\n\t    cerr << \"[\" << msv << \":\" << lsv << \"] is out of order.\" << endl;\n\t    des->errors += 1;\n\t      //delete lsn;\n\t      //delete msn;\n\t    return net;\n      }\n\n      if (warn_ob_select) {\n\t    if ((sb_lsb >= (signed) net->vector_width()) ||\n\t        (sb_msb >= (signed) net->vector_width())) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t          \"Part select \" << \"[\" << msv << \":\" << lsv\n\t\t       << \"] is selecting after the \";\n\t\t  if (net->word_index()) cerr << \"array word \";\n\t\t  else cerr << \"vector \";\n\t\t  cerr << net->name();\n\t\t  if (net->word_index()) cerr << \"[]\";\n\t\t  cerr << \"[\" << net->msi() << \":\" << net->lsi() << \"].\"\n\t\t       << endl;\n\t\t  cerr << get_fileline() << \":        : \"\n\t\t       << \"Replacing the out of bound bits with 'bx.\" << endl;\n\t    }\n\t    if ((sb_msb < 0) || (sb_lsb < 0)) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t          \"Part select \" << \"[\" << msv << \":\" << lsv\n\t\t       << \"] is selecting before the \";\n\t\t  if (net->word_index()) cerr << \"array word \";\n\t\t  else cerr << \"vector \";\n\t\t  cerr << net->name();\n\t\t  if (net->word_index()) cerr << \"[]\";\n\t\t  cerr << \"[\" << net->msi() << \":\" << net->lsi() << \"].\"\n\t\t       << endl;\n\t\t  cerr << get_fileline() << \":        : \"\n\t\t          \"Replacing the out of bound bits with 'bx.\" << endl;\n\t    }\n      }\n\n      unsigned long wid = sb_msb - sb_lsb + 1;\n\n\t// If the part select covers exactly the entire\n\t// vector, then do not bother with it. Return the\n\t// signal itself, casting to unsigned if necessary.\n      if (sb_lsb == 0 && wid == net->vector_width()) {\n\t    net->cast_signed(false);\n\t    return net;\n      }\n\n\t// If the part select covers NONE of the vector, then return a\n\t// constant X.\n\n      if ((sb_lsb >= (signed) net->vector_width()) || (sb_msb < 0)) {\n\t    NetEConst*tmp = make_const_x(wid);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n      NetExpr*ex = new NetEConst(verinum(sb_lsb));\n      NetESelect*ss = new NetESelect(net, ex, wid);\n      ss->set_line(*this);\n      return ss;\n}\n\n/*\n * Part select indexed up, i.e. net[<m> +: <l>]\n */\nNetExpr* PEIdent::elaborate_expr_net_idx_up_(Design*des, NetScope*scope,\n\t\t\t\t             NetESignal*net, NetScope*,\n                                             bool need_const) const\n{\n      if (net->sig()->data_type() == IVL_VT_STRING) {\n\t    cerr << get_fileline() << \": error: Cannot take the index part \"\n\t            \"select of a string ('\" << net->name() << \"').\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      list<long>prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, net->sig(), prefix_indices);\n      if (!rc)\n\t    return 0;\n\n      NetExpr*base = calculate_up_do_base_(des, scope, need_const);\n      if (!base)\n\t    return nullptr;\n\n\t// Use the part select width already calculated by test_width().\n      unsigned long wid = min_width_;\n\n      if (base->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: Indexed part select base \"\n\t            \"expression for \" << net->sig()->name() << \"[\" << *base\n\t         << \"+:\" << wid << \"] cannot be a real value.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Handle the special case that the base is constant as\n\t// well. In this case it can be converted to a conventional\n\t// part select.\n      if (NetEConst*base_c = dynamic_cast<NetEConst*> (base)) {\n\t    NetExpr*ex;\n\t    if (base_c->value().is_defined()) {\n\t\t  long lsv = base_c->value().as_long();\n\t\t  long rel_base = 0;\n\n\t\t    // Check whether an unsigned base fits in a 32 bit int.\n\t\t    // This ensures correct results for the vlog95 target, and\n\t\t    // for the vvp target on LLP64 platforms (Microsoft Windows).\n\t\t  if (!base_c->has_sign() && (int32_t)lsv < 0) {\n\t\t\t  // Return 'bx for a wrapped around base.\n\t\t\tex = new NetEConst(verinum(verinum::Vx, wid, true));\n\t\t\tex->set_line(*this);\n\t\t\tdelete base;\n\t\t\tif (warn_ob_select) {\n\t\t\t      cerr << get_fileline() << \": warning: \" << net->name();\n\t\t\t      if (net->word_index()) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << (unsigned long)lsv << \"+:\" << wid\n\t\t\t\t   << \"] is always outside vector.\" << endl;\n\t\t\t}\n\t\t\treturn ex;\n\t\t  }\n\n\t\t    // Get the signal range.\n\t\t  const netranges_t&packed = net->sig()->packed_dims();\n\t\t  if (prefix_indices.size()+1 < net->sig()->packed_dims().size()) {\n\t\t\t  // Here we are selecting one or more sub-arrays.\n\t\t\t  // Make this work by finding the indexed sub-arrays and\n\t\t\t  // creating a generated slice that spans the whole range.\n\t\t\tunsigned long swid = net->sig()->slice_width(prefix_indices.size()+1);\n\t\t\tivl_assert(*this, swid > 0);\n\t\t\tlong loff, moff;\n\t\t\tunsigned long lwid, mwid;\n\t\t\tbool lrc, mrc;\n\t\t\tmrc = net->sig()->sb_to_slice(prefix_indices, lsv, moff, mwid);\n\t\t\tlrc = net->sig()->sb_to_slice(prefix_indices, lsv+(wid/swid)-1, loff, lwid);\n\t\t\tif (!mrc || !lrc) {\n\t\t\t      cerr << get_fileline() << \": error: \";\n\t\t\t      cerr << \"Part-select [\" << lsv << \"+:\" << (wid/swid);\n\t\t\t      cerr << \"] exceeds the declared bounds for \";\n\t\t\t      cerr << net->sig()->name();\n\t\t\t      if (net->sig()->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t      cerr << \".\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\t\t\tivl_assert(*this, mwid == swid);\n\t\t\tivl_assert(*this, lwid == swid);\n\n\t\t\tif (moff > loff) {\n\t\t\t      rel_base = loff;\n\t\t\t} else {\n\t\t\t      rel_base = moff;\n\t\t\t}\n\t\t  } else {\n\t\t        long offset = 0;\n\t\t          // We want the last range, which is where we work.\n\t\t        const netrange_t&rng = packed.back();\n\t\t        if (rng.get_msb() < rng.get_lsb()) {\n\t\t\t      offset = -wid + 1;\n\t\t        }\n\t\t        rel_base = net->sig()->sb_to_idx(prefix_indices, lsv) + offset;\n\t\t  }\n\n\t\t    // If the part select covers exactly the entire\n\t\t    // vector, then do not bother with it. Return the\n\t\t    // signal itself.\n\t\t  if (rel_base == 0 && wid == net->vector_width()) {\n\t\t\tdelete base;\n\t\t\tnet->cast_signed(false);\n\t\t\treturn net;\n\t\t  }\n\n\t\t    // Otherwise, make a part select that covers the right\n\t\t    // range.\n\t\t  ex = new NetEConst(verinum(rel_base));\n\t\t  if (warn_ob_select) {\n\t\t\tif (rel_base < 0) {\n\t\t\t      cerr << get_fileline() << \": warning: \"\n\t\t\t           << net->name();\n\t\t\t      if (net->word_index()) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << lsv << \"+:\" << wid\n\t\t\t           << \"] is selecting before vector.\" << endl;\n\t\t\t}\n\t\t\tif (rel_base + wid > net->vector_width()) {\n\t\t\t      cerr << get_fileline() << \": warning: \"\n\t\t\t           << net->name();\n\t\t\t      if (net->word_index()) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << lsv << \"+:\" << wid\n\t\t\t           << \"] is selecting after vector.\" << endl;\n\t\t\t}\n\t\t  }\n\t    } else {\n\t\t    // Return 'bx for an undefined base.\n\t\t  ex = new NetEConst(verinum(verinum::Vx, wid, true));\n\t\t  ex->set_line(*this);\n\t\t  delete base;\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline() << \": warning: \" << net->name();\n\t\t\tif (net->word_index()) cerr << \"[]\";\n\t\t\tcerr << \"['bx+:\" << wid\n\t\t\t     << \"] is always outside vector.\" << endl;\n\t\t  }\n\t\t  return ex;\n\t    }\n\t    NetESelect*ss = new NetESelect(net, ex, wid);\n\t    ss->set_line(*this);\n\n\t    delete base;\n\t    return ss;\n      }\n\n\n      ivl_assert(*this, prefix_indices.size()+1 == net->sig()->packed_dims().size());\n\n\t// Convert the non-constant part select index expression into\n\t// an expression that returns a canonical base.\n      base = normalize_variable_part_base(prefix_indices, base, net->sig(), wid, true);\n\n      NetESelect*ss = new NetESelect(net, base, wid, IVL_SEL_IDX_UP);\n      ss->set_line(*this);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Elaborate part \"\n\t\t << \"select base=\"<< *base << \", wid=\"<< wid << endl;\n      }\n\n      return ss;\n}\n\n/*\n * Part select indexed down, i.e. net[<m> -: <l>]\n */\nNetExpr* PEIdent::elaborate_expr_net_idx_do_(Design*des, NetScope*scope,\n\t\t\t\t\t     NetESignal*net, NetScope*,\n                                             bool need_const) const\n{\n      if (net->sig()->data_type() == IVL_VT_STRING) {\n\t    cerr << get_fileline() << \": error: Cannot take the index part \"\n\t            \"select of a string ('\" << net->name() << \"').\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      list<long>prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, net->sig(), prefix_indices);\n      if (!rc)\n\t    return 0;\n\n      NetExpr*base = calculate_up_do_base_(des, scope, need_const);\n      if (!base)\n\t    return nullptr;\n\n\t// Use the part select width already calculated by test_width().\n      unsigned long wid = min_width_;\n\n      if (base->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: Indexed part select base \"\n\t            \"expression for \" << net->sig()->name() << \"[\" << *base\n\t         << \"-:\" << wid << \"] cannot be a real value.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Handle the special case that the base is constant as\n\t// well. In this case it can be converted to a conventional\n\t// part select.\n      if (NetEConst*base_c = dynamic_cast<NetEConst*> (base)) {\n\t    NetExpr*ex;\n\t    if (base_c->value().is_defined()) {\n\t\t  long lsv = base_c->value().as_long();\n\t\t  long rel_base = 0;\n\n\t\t    // Check whether an unsigned base fits in a 32 bit int.\n\t\t    // This ensures correct results for the vlog95 target, and\n\t\t    // for the vvp target on LLP64 platforms (Microsoft Windows).\n\t\t  if (!base_c->has_sign() && (int32_t)lsv < 0) {\n\t\t\t  // Return 'bx for a wrapped around base.\n\t\t\tex = new NetEConst(verinum(verinum::Vx, wid, true));\n\t\t\tex->set_line(*this);\n\t\t\tdelete base;\n\t\t\tif (warn_ob_select) {\n\t\t\t      cerr << get_fileline() << \": warning: \" << net->name();\n\t\t\t      if (net->word_index()) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << (unsigned long)lsv << \"-:\" << wid\n\t\t\t\t   << \"] is always outside vector.\" << endl;\n\t\t\t}\n\t\t\treturn ex;\n\t\t  }\n\n\t\t    // Get the signal range.\n\t\t  const netranges_t&packed = net->sig()->packed_dims();\n\t\t  if (prefix_indices.size()+1 < net->sig()->packed_dims().size()) {\n\t\t\t  // Here we are selecting one or more sub-arrays.\n\t\t\t  // Make this work by finding the indexed sub-arrays and\n\t\t\t  // creating a generated slice that spans the whole range.\n\t\t\tunsigned long swid = net->sig()->slice_width(prefix_indices.size()+1);\n\t\t\tivl_assert(*this, swid > 0);\n\t\t\tlong loff, moff;\n\t\t\tunsigned long lwid, mwid;\n\t\t\tbool lrc, mrc;\n\t\t\tmrc = net->sig()->sb_to_slice(prefix_indices, lsv, moff, mwid);\n\t\t\tlrc = net->sig()->sb_to_slice(prefix_indices, lsv-(wid/swid)+1, loff, lwid);\n\t\t\tif (!mrc || !lrc) {\n\t\t\t      cerr << get_fileline() << \": error: \";\n\t\t\t      cerr << \"Part-select [\" << lsv << \"-:\" << (wid/swid);\n\t\t\t      cerr << \"] exceeds the declared bounds for \";\n\t\t\t      cerr << net->sig()->name();\n\t\t\t      if (net->sig()->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t      cerr << \".\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\t\t\tivl_assert(*this, mwid == swid);\n\t\t\tivl_assert(*this, lwid == swid);\n\n\t\t\tif (moff > loff) {\n\t\t\t      rel_base = loff;\n\t\t\t} else {\n\t\t\t      rel_base = moff;\n\t\t\t}\n\t\t  } else {\n\t\t        long offset = 0;\n\t\t          // We want the last range, which is where we work.\n\t\t        const netrange_t&rng = packed.back();\n\t\t        if (rng.get_msb() > rng.get_lsb()) {\n\t\t\t      offset = -wid + 1;\n\t\t        }\n\t\t        rel_base = net->sig()->sb_to_idx(prefix_indices, lsv) + offset;\n                  }\n\n\t\t    // If the part select covers exactly the entire\n\t\t    // vector, then do not bother with it. Return the\n\t\t    // signal itself.\n\t\t  if (rel_base == (long)(wid-1) && wid == net->vector_width()) {\n\t\t\tdelete base;\n\t\t\tnet->cast_signed(false);\n\t\t\treturn net;\n\t\t  }\n\n\t\t    // Otherwise, make a part select that covers the right\n\t\t    // range.\n\t\t  ex = new NetEConst(verinum(rel_base));\n\t\t  if (warn_ob_select) {\n\t\t\tif (rel_base < 0) {\n\t\t\t      cerr << get_fileline() << \": warning: \"\n\t\t\t           << net->name();\n\t\t\t      if (net->word_index()) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << lsv << \"-:\" << wid\n\t\t\t           << \"] is selecting before vector.\" << endl;\n\t\t\t}\n\t\t\tif (rel_base + wid > net->vector_width()) {\n\t\t\t      cerr << get_fileline() << \": warning: \"\n\t\t\t           << net->name();\n\t\t\t      if (net->word_index()) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << lsv << \"-:\" << wid\n\t\t\t           << \"] is selecting after vector.\" << endl;\n\t\t\t}\n\t\t  }\n\t    } else {\n\t\t    // Return 'bx for an undefined base.\n\t\t  ex = new NetEConst(verinum(verinum::Vx, wid, true));\n\t\t  ex->set_line(*this);\n\t\t  delete base;\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline() << \": warning: \" << net->name();\n\t\t\tif (net->word_index()) cerr << \"[]\";\n\t\t\tcerr << \"['bx-:\" << wid\n\t\t\t     << \"] is always outside vector.\" << endl;\n\t\t  }\n\t\t  return ex;\n\t    }\n\t    NetESelect*ss = new NetESelect(net, ex, wid);\n\t    ss->set_line(*this);\n\n\t    delete base;\n\t    return ss;\n      }\n\n      ivl_assert(*this, prefix_indices.size()+1 == net->sig()->packed_dims().size());\n\n\t// Convert the non-constant part select index expression into\n\t// an expression that returns a canonical base.\n      base = normalize_variable_part_base(prefix_indices, base, net->sig(), wid, false);\n\n      NetESelect*ss = new NetESelect(net, base, wid, IVL_SEL_IDX_DOWN);\n      ss->set_line(*this);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Elaborate part \"\n\t\t << \"select base=\"<< *base << \", wid=\"<< wid << endl;\n      }\n\n      return ss;\n}\n\nNetExpr* PEIdent::elaborate_expr_net_bit_(Design*des, NetScope*scope,\n\t\t\t\t          NetESignal*net, NetScope*,\n                                          bool need_const) const\n{\n      list<long>prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, net->sig(), prefix_indices);\n      if (!rc)\n\t    return 0;\n\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.msb != 0);\n      ivl_assert(*this, index_tail.lsb == 0);\n\n      NetExpr*mux = elab_and_eval(des, scope, index_tail.msb, -1, need_const);\n      if (!mux)\n\t    return 0;\n\n      if (mux->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: Index expression for \"\n\t         << net->sig()->name() << \"[\" << *mux\n\t         << \"] cannot be a real value.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (const netdarray_t*darray = net->sig()->darray_type()) {\n\t      // Special case: This is a select of a dynamic\n\t      // array. Generate a NetESelect and attach it to\n\t      // the NetESignal. This should be interpreted as\n\t      // an array word select downstream.\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Bit select of a dynamic array becomes NetESelect.\" << endl;\n\t    }\n\t    NetESelect*res = new NetESelect(net, mux, darray->element_width(), darray->element_type());\n\t    res->set_line(*net);\n\t    return res;\n      }\n\n\t// If the bit select is constant, then treat it similar\n\t// to the part select, so that I save the effort of\n\t// making a mux part in the netlist.\n      if (NetEConst*msc = dynamic_cast<NetEConst*> (mux)) {\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_expr_net_bit_: \"\n\t\t       << \"mux is constant=\" << *msc\n\t\t       << \", packed_dims()=\" << net->sig()->packed_dims()\n\t\t       << \", packed_dims().size()=\" << net->sig()->packed_dims().size()\n\t\t       << \", prefix_indices.size()=\" << prefix_indices.size()\n\t\t       << endl;\n\t    }\n\n\t      // Special case: The bit select expression is constant\n\t      // x/z. The result of the expression is 1'bx.\n\t    if (! msc->value().is_defined()) {\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline() << \": warning: \"\n\t\t\t        \"Constant bit select [\" << msc->value()\n\t\t\t      << \"] is undefined for \";\n\t\t\tif (net->word_index()) cerr << \"array word\";\n\t\t\telse cerr << \"vector\";\n\t\t\tcerr << \" '\" << net->name();\n\t\t\tif (net->word_index()) cerr << \"[]\";\n\t\t\tcerr  << \"'.\" << endl;\n\t\t\tcerr << get_fileline() << \":        : \"\n\t\t\t     << \"Replacing select with a constant 1'bx.\"\n\t\t\t     << endl;\n\t\t  }\n\n\t\t    // FIXME: Should I be using slice_width() here?\n\t\t  NetEConst*tmp = make_const_x(1);\n\t\t  tmp->set_line(*this);\n\t\t  delete mux;\n\t\t  return tmp;\n\t    }\n\n\t    long msv = msc->value().as_long();\n\n\t    const netranges_t& sig_packed = net->sig()->packed_dims();\n\t    if (prefix_indices.size()+2 <= sig_packed.size()) {\n\t\t    // Special case: this is a slice of a multi-dimensional\n\t\t    // packed array. For example:\n\t\t    //   reg [3:0][7:0] x;\n\t\t    //   ... x[2] ...\n\t\t    // This shows up as the prefix_indices being too short\n\t\t    // for the packed dimensions of the vector. What we do\n\t\t    // here is convert to a \"slice\" of the vector.\n\t\t  unsigned long lwid;\n\t\t  long idx;\n\t\t  rc = net->sig()->sb_to_slice(prefix_indices, msv, idx, lwid);\n\n                  if(!rc) {\n                    cerr << get_fileline() << \": error: Index \" << net->sig()->name()\n                         << \"[\" << msv << \"] is out of range.\"\n                         << endl;\n                    des->errors += 1;\n                    return 0;\n                  }\n\n\t\t    // Make an expression out of the index\n\t\t  NetEConst*idx_c = new NetEConst(verinum(idx));\n\t\t  idx_c->set_line(*net);\n\n\t\t  NetESelect*res = new NetESelect(net, idx_c, lwid);\n\t\t  res->set_line(*net);\n\t\t  return res;\n\t    }\n\n\t    if (net->sig()->data_type()==IVL_VT_STRING && (msv < 0)) {\n\t\t    // Special case: This is a constant bit select of\n\t\t    // a string, and the index is < 0. For example:\n\t\t    //   string foo;\n\t\t    //   ... foo[-1] ...\n\t\t    // This is known to be 8'h00.\n\t\t  NetEConst*tmp = make_const_0(8);\n\t\t  tmp->set_line(*this);\n\t\t  delete mux;\n\t\t  return tmp;\n\t    }\n\n\t    if (net->sig()->data_type()==IVL_VT_STRING) {\n\t\t    // Special case: This is a select of a string\n\t\t    // variable. Generate a NetESelect and attach it\n\t\t    // to the NetESignal. This should be interpreted\n\t\t    // as a character select downstream.\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Bit select of string becomes NetESelect.\" << endl;\n\t\t  }\n\t\t  NetESelect*res = new NetESelect(net, mux, 8);\n\t\t  res->set_line(*net);\n\t\t  return res;\n\t    }\n\n\t    long idx = net->sig()->sb_to_idx(prefix_indices,msv);\n\n\t    if (idx >= (long)net->vector_width() || idx < 0) {\n\t\t    /* The bit select is out of range of the\n\t\t       vector. This is legal, but returns a\n\t\t       constant 1'bx value. */\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline() << \": warning: \"\n\t\t\t        \"Constant bit select [\" << msv\n\t\t\t      << \"] is \";\n\t\t\tif (idx < 0) cerr << \"before \";\n\t\t\telse cerr << \"after \";\n\t\t\tif (net->word_index()) cerr << \"array word \";\n\t\t\telse cerr << \"vector \";\n\t\t\tcerr << net->name();\n\t\t\tif (net->word_index()) cerr << \"[]\";\n\t\t\tcerr  << net->sig()->packed_dims() << \".\" << endl;\n\t\t\tcerr << get_fileline() << \":        : \"\n\t\t\t     << \"Replacing select with a constant 1'bx.\"\n\t\t\t     << endl;\n\t\t  }\n\n\t\t  NetEConst*tmp = make_const_x(1);\n\t\t  tmp->set_line(*this);\n\n\t\t  delete mux;\n\t\t  return tmp;\n\t    }\n\n\t      // If the vector is only one bit, we are done. The\n\t      // bit select will return the scalar itself.\n\t    if (net->vector_width() == 1)\n\t\t  return net;\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_expr_net_bit_: \"\n\t\t       << \"Make bit select idx=\" << idx\n\t\t       << endl;\n\t    }\n\n\t      // Make an expression out of the index\n\t    NetEConst*idx_c = new NetEConst(verinum(idx));\n\t    idx_c->set_line(*net);\n\n\t      // Make a bit select with the canonical index\n\t    NetESelect*res = new NetESelect(net, idx_c, 1);\n\t    res->set_line(*net);\n\n\t    return res;\n      }\n\n      const netranges_t& sig_packed = net->sig()->packed_dims();\n      if (prefix_indices.size()+2 <= sig_packed.size()) {\n\t      // Special case: this is a slice of a multi-dimensional\n\t      // packed array. For example:\n\t      //   reg [3:0][7:0] x;\n\t      //   x[2] = ...\n\t      // This shows up as the prefix_indices being too short\n\t      // for the packed dimensions of the vector. What we do\n\t      // here is convert to a \"slice\" of the vector.\n\t    unsigned long lwid;\n\t    mux = normalize_variable_slice_base(prefix_indices, mux,\n\t\t\t\t\t\tnet->sig(), lwid);\n\t    mux->set_line(*net);\n\n\t      // Make a PART select with the canonical index\n\t    NetESelect*res = new NetESelect(net, mux, lwid);\n\t    res->set_line(*net);\n\n\t    return res;\n      }\n\n      if (net->sig()->data_type() == IVL_VT_STRING) {\n\t      // Special case: This is a select of a string.\n\t      // This should be interpreted as a byte select.\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Bit select of a string becomes NetESelect.\" << endl;\n\t    }\n\t    NetESelect*res = new NetESelect(net, mux, 8);\n\t    res->set_line(*net);\n\t    return res;\n      }\n\n\t// Non-constant bit select? punt and make a subsignal\n\t// device to mux the bit in the net. This is a fairly\n\t// complicated task because we need to generate\n\t// expressions to convert calculated bit select\n\t// values to canonical values that are used internally.\n      mux = normalize_variable_bit_base(prefix_indices, mux, net->sig());\n\n      NetESelect*ss = new NetESelect(net, mux, 1);\n      ss->set_line(*this);\n      return ss;\n}\n\nNetExpr* PEIdent::elaborate_expr_net_bit_last_(Design*, NetScope*,\n\t\t\t\t\t       NetESignal*net,\n\t\t\t\t\t       NetScope* /* found_in */,\n\t\t\t\t\t       bool need_const) const\n{\n      if (need_const) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Expression with \\\"[$]\\\" is not constant.\" << endl;\n\t    return 0;\n      }\n\n      unsigned use_width = 1;\n      ivl_type_t use_type = 0;\n      if (const netdarray_t*darray = net->sig()->darray_type()) {\n\t    use_width = darray->element_width();\n\t    use_type = darray->element_type();\n      }\n\n      NetELast*mux = new NetELast(net->sig());\n      mux->set_line(*this);\n      NetESelect*ss = new NetESelect(net, mux, use_width, use_type);\n      ss->set_line(*this);\n      return ss;\n}\n\nNetExpr* PEIdent::elaborate_expr_net(Design*des, NetScope*scope,\n\t\t\t\t     NetNet*net, NetScope*found_in,\n                                     unsigned expr_wid,\n\t\t\t\t     unsigned flags) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_expr_net: \"\n\t\t << \"net=\" << net->name()\n\t\t << \", net->unpacked_dimensions()=\" << net->unpacked_dimensions()\n\t\t << \", net->get_scalar()=\" << (net->get_scalar()?\"true\":\"false\")\n\t\t << \", net->net_type()=\" << *net->net_type()\n\t\t << endl;\n      }\n\n      if (net->unpacked_dimensions() > 0)\n\t    return elaborate_expr_net_word_(des, scope, net, found_in,\n                                            expr_wid, flags);\n\n      bool need_const = NEED_CONST & flags;\n\n      NetESignal*node = new NetESignal(net);\n      node->set_line(*this);\n\n      index_component_t::ctype_t use_sel = index_component_t::SEL_NONE;\n      if (! path_.name.back().index.empty())\n\t    use_sel = path_.name.back().index.back().sel;\n\n      if (net->get_scalar() && use_sel != index_component_t::SEL_NONE) {\n\t    cerr << get_fileline() << \": error: can not select part of \";\n\t    if (node->expr_type() == IVL_VT_REAL) cerr << \"real: \";\n\t    else cerr << \"scalar: \";\n\t    cerr << net->name() << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      list<long> prefix_indices;\n      bool rc = evaluate_index_prefix(des, scope, prefix_indices, path_.back().index);\n      if (!rc) return 0;\n\n\t// If this is a part select of a signal, then make a new\n\t// temporary signal that is connected to just the\n\t// selected bits. The lsb_ and msb_ expressions are from\n\t// the foo[msb:lsb] expression in the original.\n      if (use_sel == index_component_t::SEL_PART)\n\t    return elaborate_expr_net_part_(des, scope, node, found_in,\n                                            expr_wid);\n\n      if (use_sel == index_component_t::SEL_IDX_UP)\n\t    return elaborate_expr_net_idx_up_(des, scope, node, found_in,\n                                              need_const);\n\n      if (use_sel == index_component_t::SEL_IDX_DO)\n\t    return elaborate_expr_net_idx_do_(des, scope, node, found_in,\n                                              need_const);\n\n      if (use_sel == index_component_t::SEL_BIT)\n\t    return elaborate_expr_net_bit_(des, scope, node, found_in,\n                                           need_const);\n\n      if (use_sel == index_component_t::SEL_BIT_LAST)\n\t    return elaborate_expr_net_bit_last_(des, scope, node, found_in,\n\t\t\t\t\t\tneed_const);\n\n\t// It's not anything else, so this must be a simple identifier\n\t// expression with no part or bit select. Return the signal\n\t// itself as the expression.\n      ivl_assert(*this, use_sel == index_component_t::SEL_NONE);\n\n      return node;\n}\n\nunsigned PENewArray::test_width(Design*, NetScope*, width_mode_t&)\n{\n      expr_type_  = IVL_VT_DARRAY;\n      expr_width_ = 1;\n      min_width_  = 1;\n      signed_flag_= false;\n      return 1;\n}\n\nNetExpr* PENewArray::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t    ivl_type_t ntype, unsigned flags) const\n{\n\t// Elaborate the size expression.\n      width_mode_t mode = LOSSLESS;\n      unsigned use_wid = size_->test_width(des, scope, mode);\n      NetExpr*size = size_->elaborate_expr(des, scope, use_wid, flags);\n      NetExpr*init_val = 0;\n\n      if (dynamic_cast<PEAssignPattern*> (init_)) {\n\t      // Special case: the initial value expression is an\n\t      // array_pattern. Elaborate the expression like the\n\t      // r-value to an assignment to array.\n\t    init_val = init_->elaborate_expr(des, scope, ntype, flags);\n\n      } else if (init_) {\n\t      // Regular case: The initial value is an\n\t      // expression. Elaborate the expression as an element\n\t      // type. The run-time will assign this value to each element.\n\t    const netarray_t*array_type = dynamic_cast<const netarray_t*> (ntype);\n\n\t    init_val = init_->elaborate_expr(des, scope, array_type, flags);\n      }\n\n      NetENew*tmp = new NetENew(ntype, size, init_val);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nNetExpr* PENewArray::elaborate_expr(Design*des, NetScope*, unsigned, unsigned) const\n{\n      cerr << get_fileline() << \": error: The new array constructor may \"\n              \"only be used in an assignment to a dynamic array.\" << endl;\n      des->errors += 1;\n      return 0;\n}\n\nunsigned PENewClass::test_width(Design*, NetScope*, width_mode_t&)\n{\n      expr_type_  = IVL_VT_CLASS;\n      expr_width_ = 1;\n      min_width_  = 1;\n      signed_flag_= false;\n      return 1;\n}\n\n/*\n * This elaborates the constructor for a class. This arranges for the\n * call of class constructor, if present, and also\n * initializers in front of an explicit constructor.\n *\n * The derived argument is the type of the class derived from the\n * current one. This is used to get chained constructor arguments, if necessary.\n */\nNetExpr* PENewClass::elaborate_expr_constructor_(Design*des, NetScope*scope,\n\t\t\t\t\t\t const netclass_t*ctype,\n\t\t\t\t\t\t NetExpr*obj, unsigned /*flags*/) const\n{\n      ivl_assert(*this, ctype);\n\n      NetScope *new_scope = ctype->get_constructor();\n      if (new_scope == 0) {\n\t      // No constructor.\n\t    if (parms_.size() > 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Class \" << ctype->get_name()\n\t\t       << \" has no constructor, but you passed \" << parms_.size()\n\t\t       << \" arguments to the new operator.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    return obj;\n      }\n\n\n      NetFuncDef*def = new_scope->func_def();\n      if (def == 0) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Scope \" << scope_path(new_scope)\n\t\t << \" is missing constructor definition.\" << endl;\n\t    des->errors += 1;\n      }\n      ivl_assert(*this, def);\n\n\t// Are there too many arguments passed to the function. If so,\n\t// generate an error message. The case of too few arguments\n\t// will be handled below, when we run out of arguments.\n      if ((parms_.size()+1) > def->port_count()) {\n\t    cerr << get_fileline() << \": error: Argument count mismatch.\"\n\t\t << \" Passing \" << parms_.size() << \" arguments\"\n\t\t << \" to constructor expecting \" << (def->port_count()-1)\n\t\t << \" arguments.\" << endl;\n\t    des->errors += 1;\n      }\n\n      vector<NetExpr*> parms (def->port_count());\n      parms[0] = obj;\n\n      auto args = map_named_args(des, def, parms_, 1);\n\n      int missing_parms = 0;\n      for (size_t idx = 1 ; idx < parms.size() ; idx += 1) {\n\t      // While there are default arguments, check them.\n\t    if (args[idx - 1]) {\n\t\t  parms[idx] = elaborate_rval_expr(des, scope,\n\t\t\t\t\t\t   def->port(idx)->net_type(),\n\t\t\t\t\t\t   args[idx - 1], false);\n\t\t  // NOTE: if elaborate_rval_expr fails, it will return a\n\t\t  // nullptr, but it will also increment des->errors so there\n\t\t  // is nothing we need to do here.\n\n\t\t  continue;\n\t    }\n\n\t      // Ran out of explicit arguments. Is there a default\n\t      // argument we can use?\n\t    if (NetExpr*tmp = def->port_defe(idx)) {\n\t\t  parms[idx] = tmp->dup_expr();\n\t\t  continue;\n\t    }\n\n\t      // If we run out of passed expressions, and there is no\n\t      // default value for this port, then we will need to\n\t      // report an error that we are missing parameters.\n\t    missing_parms += 1;\n\t    parms[idx] = 0;\n      }\n\n      if (missing_parms > 0) {\n\t    cerr << get_fileline() << \": error: The \" << scope_path(new_scope)\n\t\t << \" constructor call is missing arguments.\" << endl;\n\t    des->errors += 1;\n      }\n\n\t// The return value for the constructor is actually the \"this\"\n\t// variable, instead of the \"new\" scope name.\n      NetNet*res = new_scope->find_signal(perm_string::literal(THIS_TOKEN));\n      ivl_assert(*this, res);\n\n      NetESignal*eres = new NetESignal(res);\n      NetEUFunc*con = new NetEUFunc(scope, new_scope, eres, parms, true);\n      con->set_line(*this);\n\n      return con;\n}\n\nNetExpr* PENewClass::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t    ivl_type_t ntype, unsigned flags) const\n{\n\t// Find the constructor for the class. If there is no\n\t// constructor then the result of this expression is the\n\t// allocation alone.\n      const netclass_t*ctype = dynamic_cast<const netclass_t*> (ntype);\n\n      if (!ctype) {\n\t    cerr << get_fileline() << \": error: class new not allowed here. \"\n\t\t << \"Left-hand side is not of class type.\" << endl;\n\t    des->errors++;\n\t    return 0;\n      }\n\n      if (class_type_) {\n\t    ivl_type_t elab_class_type = class_type_->elaborate_type(des,\n\t\t\t\t\t\t\t\t     scope);\n\t    ctype = dynamic_cast<const netclass_t*> (elab_class_type);\n\t    if (!ctype) {\n\t\t  cerr << get_fileline() << \": error: Incompatible type in\"\n\t\t       << \" typed constructor call.\\n\"\n\t\t       << get_fileline() << \":      : Constructor type `\"\n\t\t       << *elab_class_type << \"` is not a class type.\"\n\t\t       << endl;\n\t\t  des->errors++;\n\t\t  return nullptr;\n\t    }\n\n\t    if (!ntype->type_compatible(ctype)) {\n\t\t  cerr << get_fileline() << \": error: Incompatible type in\"\n\t\t       << \" typed constructor call.\\n\"\n\t\t       << get_fileline() << \":      : Constructor type `\"\n\t\t       << *ctype\n\t\t       << \"` is not compatible with the target type `\"\n\t\t       << *ntype << \"`.\" << endl;\n\t\t  des->errors++;\n\t\t  return nullptr;\n\t    }\n      }\n\n      if (ctype->is_virtual()) {\n\t    cerr << get_fileline() << \": error: \"\n\t         << \"Can not create object of virtual class `\"\n\t\t << ctype->get_name() << \"`.\" << endl;\n\t    des->errors++;\n\t    return 0;\n      }\n\n      NetExpr*obj = new NetENew(ctype);\n      obj->set_line(*this);\n\n      obj = elaborate_expr_constructor_(des, scope, ctype, obj, flags);\n      return obj;\n}\n\nunsigned PENewCopy::test_width(Design*, NetScope*, width_mode_t&)\n{\n      expr_type_  = IVL_VT_CLASS;\n      expr_width_ = 1;\n      min_width_  = 1;\n      signed_flag_= false;\n      return 1;\n}\n\nNetExpr* PENewCopy::elaborate_expr(Design*des, NetScope*scope, ivl_type_t obj_type, unsigned) const\n{\n      NetExpr*copy_arg = src_->elaborate_expr(des, scope, obj_type, 0);\n      if (copy_arg == 0)\n\t    return 0;\n\n      NetENew*obj_new = new NetENew(obj_type);\n      obj_new->set_line(*this);\n\n      NetEShallowCopy*copy = new NetEShallowCopy(obj_new, copy_arg);\n      copy->set_line(*this);\n\n      return copy;\n}\n\n/*\n * A \"null\" expression represents class objects/handles. This brings\n * up a ton of special cases, but we handle it here by setting the\n * expr_type_ and expr_width_ to fixed values.\n */\nunsigned PENull::test_width(Design*, NetScope*, width_mode_t&)\n{\n      expr_type_   = IVL_VT_CLASS;\n      expr_width_  = 1;\n      min_width_   = 1;\n      signed_flag_ = false;\n      return expr_width_;\n}\n\nNetExpr* PENull::elaborate_expr(Design*, NetScope*, ivl_type_t, unsigned) const\n{\n      NetENull*tmp = new NetENull;\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetExpr* PENull::elaborate_expr(Design*, NetScope*, unsigned, unsigned) const\n{\n      NetENull*tmp = new NetENull;\n      tmp->set_line(*this);\n      return tmp;\n}\n\nunsigned PENumber::test_width(Design*, NetScope*, width_mode_t&mode)\n{\n      expr_type_   = IVL_VT_LOGIC;\n      expr_width_  = value_->len();\n      min_width_   = expr_width_;\n      signed_flag_ = value_->has_sign();\n\n      if (!value_->has_len() && !value_->is_single()) {\n            if (gn_strict_expr_width_flag) {\n                  expr_width_ = integer_width;\n                  mode = UNSIZED;\n            } else if (mode < LOSSLESS) {\n\t\t  if (expr_width_ < integer_width) {\n\t\t\texpr_width_ = integer_width;\n\t\t\tif (mode < UNSIZED)\n\t\t\t      mode = UNSIZED;\n\t\t  } else {\n\t\t\tmode = LOSSLESS;\n\t\t  }\n            }\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PENumber::test_width: \"\n\t\t << \"Value=\" << *value_\n\t\t << \", width=\" << expr_width_\n\t\t << \", output mode=\" << width_mode_name(mode) << endl;\n      }\n\n      return expr_width_;\n}\n\nNetExpr* PENumber::elaborate_expr(Design*, NetScope*, ivl_type_t ntype, unsigned) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PENumber::elaborate_expr: \"\n\t\t << \"expression: \" << *this << endl;\n\t    if (ntype)\n\t\t  cerr << get_fileline() << \": PENumber::elaborate_expr: \"\n\t\t       << \"ntype=\" << *ntype << endl;\n      }\n\n      // Icarus allows dynamic arrays to be initialised with a single value.\n      if (const netdarray_t*array_type = dynamic_cast<const netdarray_t*> (ntype))\n            ntype = array_type->element_type();\n\n      // Special case: If the context type is REAL, then cast the\n      // vector value to a real and return a NetECReal.\n      if (ntype->base_type() == IVL_VT_REAL) {\n\t    verireal val (value_->as_long());\n\t    NetECReal*tmp = new NetECReal(val);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n      verinum use_val = value();\n      use_val.has_sign( ntype->get_signed() );\n      use_val = cast_to_width(use_val, ntype->packed_width());\n\n      NetEConst*tmp = new NetEConst(use_val);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nNetEConst* PENumber::elaborate_expr(Design*, NetScope*,\n\t\t\t\t    unsigned expr_wid, unsigned) const\n{\n      ivl_assert(*this, value_);\n      verinum val = *value_;\n      if (val.has_len())\n            val.has_sign(signed_flag_);\n      val = cast_to_width(val, expr_wid);\n      NetEConst*tmp = new NetEConst(val);\n      tmp->cast_signed(signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nunsigned PEString::test_width(Design*, NetScope*, width_mode_t&)\n{\n      expr_type_   = IVL_VT_BOOL;\n      expr_width_  = text_ ? verinum(text_).len() : 0;\n      min_width_   = expr_width_;\n      signed_flag_ = false;\n\n      return expr_width_;\n}\n\nNetEConst* PEString::elaborate_expr(Design*, NetScope*, ivl_type_t, unsigned) const\n{\n      NetECString*tmp = new NetECString(value());\n      tmp->cast_signed(signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\n/*\n * When the expression is being elaborated with a width, then we are trying to\n * make a vector, so create a NetEConst with the basic types.\n */\nNetEConst* PEString::elaborate_expr(Design*, NetScope*,\n\t\t\t\t    unsigned expr_wid, unsigned) const\n{\n      verinum val(value());\n      val = pad_to_width(val, expr_wid);\n      NetEConst*tmp = new NetEConst(val);\n      tmp->cast_signed(signed_flag_);\n      tmp->set_line(*this);\n\n      return tmp;\n}\n\nunsigned PETernary::test_width(Design*des, NetScope*scope, width_mode_t&mode)\n{\n\t// The condition of the ternary is self-determined, so\n\t// we will test its width when we elaborate it.\n\n        // Test the width of the true and false clauses.\n      unsigned tru_width = tru_->test_width(des, scope, mode);\n\n      width_mode_t saved_mode = mode;\n\n      unsigned fal_width = fal_->test_width(des, scope, mode);\n\n        // If the width mode changed, retest the true clause, as it\n        // may choose a different width if it is in a lossless context.\n      if ((mode >= LOSSLESS) && (saved_mode < LOSSLESS)) {\n\t    tru_width = tru_->test_width(des, scope, mode);\n      }\n\n\t// If either of the alternatives is IVL_VT_REAL, then the\n\t// expression as a whole is IVL_VT_REAL. Otherwise, if either\n\t// of the alternatives is IVL_VT_LOGIC, then the expression as\n\t// a whole is IVL_VT_LOGIC. The fallback assumes that the\n\t// types are the same and we take that.\n      ivl_variable_type_t tru_type = tru_->expr_type();\n      ivl_variable_type_t fal_type = fal_->expr_type();\n\n      if (tru_type == IVL_VT_REAL || fal_type == IVL_VT_REAL) {\n\t    expr_type_ = IVL_VT_REAL;\n      } else if (tru_type == IVL_VT_LOGIC || fal_type == IVL_VT_LOGIC) {\n\t    expr_type_ = IVL_VT_LOGIC;\n      } else {\n\t    expr_type_ = tru_type;\n      }\n      if (expr_type_ == IVL_VT_REAL) {\n\t    expr_width_  = 1;\n            min_width_   = 1;\n            signed_flag_ = true;\n      } else {\n\t    expr_width_  = max(tru_width, fal_width);\n            min_width_   = max(tru_->min_width(), fal_->min_width());\n            signed_flag_ = tru_->has_sign() && fal_->has_sign();\n\n              // If the alternatives are different types, the expression\n              // is forced to unsigned. In this case the lossless width\n              // calculation is unreliable and we need to make sure the\n              // final expression width is at least integer_width.\n            if ((mode == LOSSLESS) && (tru_->has_sign() != fal_->has_sign()))\n                  mode = UPSIZE;\n      }\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": debug: \"\n\t\t << \"Ternary expression type=\" << expr_type_\n\t\t << \", width=\" << expr_width_\n\t\t << \" (tru_type=\" << tru_type\n\t\t << \", fal_type=\" << fal_type << \")\" << endl;\n\n      return fix_width_(mode);\n}\n\nbool NetETernary::test_operand_compat(ivl_variable_type_t l,\n\t\t\t\t      ivl_variable_type_t r)\n{\n      if (l == IVL_VT_LOGIC && r == IVL_VT_BOOL)\n\t    return true;\n      if (l == IVL_VT_BOOL && r == IVL_VT_LOGIC)\n\t    return true;\n\n      if (l == IVL_VT_REAL && (r == IVL_VT_LOGIC || r == IVL_VT_BOOL))\n\t    return true;\n      if (r == IVL_VT_REAL && (l == IVL_VT_LOGIC || l == IVL_VT_BOOL))\n\t    return true;\n\n      if (l == r)\n\t    return true;\n\n      return false;\n}\n\n/*\n * Elaborate the Ternary operator. I know that the expressions were\n * parsed so I can presume that they exist, and call elaboration\n * methods. If any elaboration fails, then give up and return 0.\n */\nNetExpr*PETernary::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t  unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n\n      ivl_assert(*this, expr_);\n      ivl_assert(*this, tru_);\n      ivl_assert(*this, fal_);\n\n\t// Elaborate and evaluate the condition expression. Note that\n\t// it is always self-determined.\n      NetExpr*con = elab_and_eval(des, scope, expr_, -1, NEED_CONST & flags);\n      if (con == 0)\n\t    return 0;\n\n\t/* Make sure the condition expression reduces to a single bit. */\n      con = condition_reduce(con);\n\n\t// Verilog doesn't say that we must do short circuit evaluation\n\t// of ternary expressions, but it doesn't disallow it.\n      if (NetEConst*tmp = dynamic_cast<NetEConst*> (con)) {\n\t    verinum cval = tmp->value();\n\t    ivl_assert(*this, cval.len()==1);\n\n\t      // Condition is constant TRUE, so we only need the true clause.\n\t    if (cval.get(0) == verinum::V1) {\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: Short-circuit \"\n\t\t\t        \"elaborate TRUE clause of ternary.\"\n\t\t\t     << endl;\n\n\t\t    // Evaluate the alternate expression to find any errors.\n\t\t  NetExpr*dmy = elab_and_eval_alternative_(des, scope, fal_,\n\t\t                                           expr_wid, flags,\n\t\t                                           true);\n\t\t  delete dmy;\n\n\t\t  delete con;\n\t\t  return elab_and_eval_alternative_(des, scope, tru_,\n                                                    expr_wid, flags, true);\n\t    }\n\n\t      // Condition is constant FALSE, so we only need the\n\t      // false clause.\n\t    if (cval.get(0) == verinum::V0) {\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: Short-circuit \"\n\t\t\t        \"elaborate FALSE clause of ternary.\"\n\t\t\t<< endl;\n\n\t\t    // Evaluate the alternate expression to find any errors.\n\t\t  NetExpr*dmy = elab_and_eval_alternative_(des, scope, tru_,\n\t\t                                           expr_wid, flags,\n\t\t                                           true);\n\t\t  delete dmy;\n\n\t\t  delete con;\n\t\t  return elab_and_eval_alternative_(des, scope, fal_,\n                                                    expr_wid, flags, true);\n\t    }\n\n\t      // X and Z conditions need to blend both results, so we\n\t      // can't short-circuit.\n      }\n\n      NetExpr*tru = elab_and_eval_alternative_(des, scope, tru_,\n\t\t\t\t\t       expr_wid, flags, false);\n      if (tru == 0) {\n\t    delete con;\n\t    return 0;\n      }\n\n      NetExpr*fal = elab_and_eval_alternative_(des, scope, fal_,\n\t\t\t\t\t       expr_wid, flags, false);\n      if (fal == 0) {\n\t    delete con;\n\t    delete tru;\n\t    return 0;\n      }\n\n      if (! NetETernary::test_operand_compat(tru->expr_type(), fal->expr_type())) {\n\t    cerr << get_fileline() << \": error: Data types \"\n\t\t << tru->expr_type() << \" and \"\n\t\t << fal->expr_type() << \" of ternary\"\n\t\t << \" do not match.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetETernary*res = new NetETernary(con, tru, fal, expr_wid, signed_flag_);\n      res->set_line(*this);\n      return res;\n}\n\n/*\n * When elaborating the true or false alternative expression of a\n * ternary, take into account the overall expression type. If the type\n * is not vectorable, then the alternative expression is evaluated as\n * self-determined.\n */\nNetExpr* PETernary::elab_and_eval_alternative_(Design*des, NetScope*scope,\n\t\t\t\t\t       PExpr*expr, unsigned expr_wid,\n                                               unsigned flags, bool short_cct) const\n{\n      int context_wid = expr_wid;\n      if (type_is_vectorable(expr->expr_type()) && !type_is_vectorable(expr_type_)) {\n\t    expr_wid = expr->expr_width();\n            context_wid = -1;\n      } else {\n            expr->cast_signed(signed_flag_);\n      }\n      NetExpr*tmp = expr->elaborate_expr(des, scope, expr_wid, flags);\n      if (tmp == 0) return 0;\n\n      if (short_cct && (expr_type_ == IVL_VT_REAL)\n          && (expr->expr_type() != IVL_VT_REAL))\n\t    tmp = cast_to_real(tmp);\n\n      eval_expr(tmp, context_wid);\n\n      return tmp;\n}\n\n/*\n * A typename expression is only legal in very narrow cases. This is\n * just a placeholder.\n */\nunsigned PETypename::test_width(Design*des, NetScope*, width_mode_t&)\n{\n      cerr << get_fileline() << \": error: \"\n\t   << \"Type names are not valid expressions here.\" << endl;\n      des->errors += 1;\n\n      expr_type_   = IVL_VT_NO_TYPE;\n      expr_width_  = 1;\n      min_width_   = 1;\n      signed_flag_ = false;\n      return expr_width_;\n}\n\nNetExpr*PETypename::elaborate_expr(Design*des, NetScope*,\n\t\t\t\t   ivl_type_t, unsigned) const\n{\n      cerr << get_fileline() << \": error: Type name not a valid expression here.\" << endl;\n      des->errors += 1;\n      return 0;\n}\n\nunsigned PEUnary::test_width(Design*des, NetScope*scope, width_mode_t&mode)\n{\n\t// Evaluate the expression width to get the correct type information\n      expr_width_  = expr_->test_width(des, scope, mode);\n\n      if (expr_->expr_type() == IVL_VT_CLASS) {\n\t    cerr << get_fileline() << \": error: \"\n\t    << \"Class/null is not allowed with the '\"\n\t    << human_readable_op(op_) << \"' operator.\" << endl;\n\t    des->errors += 1;\n      }\n\n      switch (op_) {\n\t  case '&': // Reduction AND\n\t  case '|': // Reduction OR\n\t  case '^': // Reduction XOR\n\t  case 'A': // Reduction NAND (~&)\n\t  case 'N': // Reduction NOR (~|)\n\t  case 'X': // Reduction NXOR (~^)\n\t  case '!':\n\t    {\n\t\t  width_mode_t sub_mode = SIZED;\n\t\t  unsigned sub_width = expr_->test_width(des, scope, sub_mode);\n\n\t\t  expr_type_   = expr_->expr_type();\n\t          expr_width_  = 1;\n\t          min_width_   = 1;\n                  signed_flag_ = false;\n\n                  if ((op_ == '!') && (expr_type_ != IVL_VT_BOOL))\n                        expr_type_ = IVL_VT_LOGIC;\n\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Test width of sub-expression of \" << op_\n\t\t\t     << \" returns \" << sub_width << \".\" << endl;\n\n\t    }\n            return expr_width_;\n      }\n\n      expr_type_   = expr_->expr_type();\n      min_width_   = expr_->min_width();\n      signed_flag_ = expr_->has_sign();\n\n      return fix_width_(mode);\n}\n\n\nNetExpr* PEUnary::elaborate_expr(Design*des, NetScope*scope,\n\t\t\t\t unsigned expr_wid, unsigned flags) const\n{\n      flags &= ~SYS_TASK_ARG; // don't propagate the SYS_TASK_ARG flag\n      ivl_variable_type_t t;\n\n      unsigned sub_width = expr_wid;\n      switch (op_) {\n            // Reduction operators and ! always have a self determined width.\n\t  case '!':\n\t  case '&': // Reduction AND\n\t  case '|': // Reduction OR\n\t  case '^': // Reduction XOR\n\t  case 'A': // Reduction NAND (~&)\n\t  case 'N': // Reduction NOR (~|)\n\t  case 'X': // Reduction NXOR (~^)\n\t    sub_width = expr_->expr_width();\n\t    break;\n\n            // Other operators have context determined operands, so propagate\n            // the expression type (signed/unsigned) down to the operands.\n\t  default:\n            expr_->cast_signed(signed_flag_);\n\t    break;\n      }\n      NetExpr*ip = expr_->elaborate_expr(des, scope, sub_width, flags);\n      if (ip == 0) return 0;\n\n      ivl_assert(*expr_, expr_type_ != IVL_VT_NO_TYPE);\n\n      NetExpr*tmp;\n      switch (op_) {\n\t  case 'i':\n\t  case 'I':\n\t  case 'D':\n\t  case 'd':\n\t\tt = ip->expr_type();\n\t\tif (expr_wid != expr_->expr_width()) {\n\t\t\t/*\n\t\t\t * TODO: Need to modify draw_unary_expr() to support\n\t\t\t * increment/decrement operations on slice of vector.\n\t\t\t */\n\t\t\tcerr << get_fileline() << \": sorry: \"\n\t\t\t\t<< human_readable_op(op_, true)\n\t\t\t\t<< \" operation is not yet supported on \"\n\t\t\t\t<< \"vector slice.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t} else if (t == IVL_VT_LOGIC || t == IVL_VT_BOOL ||\n\t\t\t\tt == IVL_VT_REAL) {\n\n\t\t\tif (dynamic_cast<NetEConst *> (ip) ||\n\t\t\t\tdynamic_cast<NetECReal*> (ip)) {\n\t\t\t\t/*\n\t\t\t\t * invalid operand: operand is a constant\n\t\t\t\t * or real number\n\t\t\t\t */\n\t\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t\t\t<< \"inappropriate use of \"\n\t\t\t\t\t<< human_readable_op(op_, true)\n\t\t\t\t\t<< \" operator.\" << endl;\n\t\t\t\tdes->errors += 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * **** Valid use of operator ***\n\t\t\t * For REAL variables draw_unary_real() is invoked during\n\t\t\t * evaluation and for LOGIC/BOOLEAN draw_unary_expr()\n\t\t\t * is called for evaluation.\n\t\t\t */\n\t\t\ttmp = new NetEUnary(op_, ip, expr_wid, signed_flag_);\n\t\t\ttmp->set_line(*this);\n\t\t} else {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t\t<< \"inappropriate use of \"\n\t\t\t\t<< human_readable_op(op_, true)\n\t\t\t\t<< \" operator.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\t  default:\n\t    tmp = new NetEUnary(op_, ip, expr_wid, signed_flag_);\n\t    tmp->set_line(*this);\n\t    break;\n\n\t  case '-':\n\t    if (NetEConst*ipc = dynamic_cast<NetEConst*>(ip)) {\n\n\t\t  verinum val = - ipc->value();\n\t\t  tmp = new NetEConst(val);\n\t\t  tmp->cast_signed(signed_flag_);\n\t\t  tmp->set_line(*this);\n\t\t  delete ip;\n\n\t    } else if (NetECReal*ipr = dynamic_cast<NetECReal*>(ip)) {\n\n\t\t    /* When taking the - of a real, fold this into the\n\t\t       constant value. */\n\t\t  verireal val = - ipr->value();\n\t\t  tmp = new NetECReal(val);\n\t\t  tmp->set_line(*this);\n\t\t  delete ip;\n\n\t    } else {\n\t\t  tmp = new NetEUnary(op_, ip, expr_wid, signed_flag_);\n\t\t  tmp->set_line(*this);\n\t    }\n\t    break;\n\n\t  case '+':\n\t    tmp = ip;\n\t    break;\n\n\t  case '!': // Logical NOT\n\t      /* If the operand to unary ! is a constant, then I can\n\t\t evaluate this expression here and return a logical\n\t\t constant in its place. */\n\t    if (NetEConst*ipc = dynamic_cast<NetEConst*>(ip)) {\n\t\t  verinum val = ipc->value();\n\t\t  unsigned v1 = 0;\n\t\t  unsigned vx = 0;\n\t\t  for (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t\t\tswitch (val[idx]) {\n\t\t\t    case verinum::V0:\n\t\t\t      break;\n\t\t\t    case verinum::V1:\n\t\t\t      v1 += 1;\n\t\t\t      break;\n\t\t\t    default:\n\t\t\t      vx += 1;\n\t\t\t      break;\n\t\t\t}\n\n\t\t  verinum::V res;\n\t\t  if (v1 > 0)\n\t\t\tres = verinum::V0;\n\t\t  else if (vx > 0)\n\t\t\tres = verinum::Vx;\n\t\t  else\n\t\t\tres = verinum::V1;\n\n\t\t  verinum vres (res, 1, true);\n\t\t  tmp = new NetEConst(vres);\n\t\t  tmp->set_line(*this);\n\t\t  delete ip;\n\t    } else if (NetECReal*ipr = dynamic_cast<NetECReal*>(ip)) {\n\t\t  verinum::V res;\n\t\t  if (ipr->value().as_double() == 0.0) res = verinum::V1;\n\t\t  else res = verinum::V0;\n\t\t  verinum vres (res, 1, true);\n\t\t  tmp = new NetEConst(vres);\n\t\t  tmp->set_line(*this);\n\t\t  delete ip;\n\t    } else {\n\t\t  if (ip->expr_type() == IVL_VT_REAL) {\n\t\t\ttmp = new NetEBComp('e', ip,\n\t\t\t                    new NetECReal(verireal(0.0)));\n\t\t  } else {\n\t\t\ttmp = new NetEUReduce(op_, ip);\n\t\t  }\n\t\t  tmp->set_line(*this);\n\t    }\n            tmp = pad_to_width(tmp, expr_wid, signed_flag_, *this);\n\t    break;\n\n\t  case '&': // Reduction AND\n\t  case '|': // Reduction OR\n\t  case '^': // Reduction XOR\n\t  case 'A': // Reduction NAND (~&)\n\t  case 'N': // Reduction NOR (~|)\n\t  case 'X': // Reduction NXOR (~^)\n\t    if (ip->expr_type() == IVL_VT_REAL) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << human_readable_op(op_, true)\n\t\t       << \" operator may not have a REAL operand.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    tmp = new NetEUReduce(op_, ip);\n\t    tmp->set_line(*this);\n            tmp = pad_to_width(tmp, expr_wid, signed_flag_, *this);\n\t    break;\n\n\t  case '~':\n\t    tmp = elaborate_expr_bits_(ip, expr_wid);\n\t    break;\n      }\n\n      return tmp;\n}\n\nNetExpr* PEUnary::elaborate_expr_bits_(NetExpr*operand, unsigned expr_wid) const\n{\n\t// Handle the special case that the operand is a\n\t// constant. Simply calculate the constant results of the\n\t// expression and return that.\n      if (NetEConst*ctmp = dynamic_cast<NetEConst*> (operand)) {\n\t    verinum value = ctmp->value();\n\n\t      // The only operand that I know can get here is the\n\t      // unary not (~).\n\t    ivl_assert(*this, op_ == '~');\n\t    value = ~value;\n\n\t    ctmp = new NetEConst(value);\n\t    ctmp->set_line(*this);\n\t    delete operand;\n\t    return ctmp;\n      }\n\n      NetEUBits*tmp = new NetEUBits(op_, operand, expr_wid, signed_flag_);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetExpr* PEVoid::elaborate_expr(Design*, NetScope*, unsigned, unsigned) const\n{\n      return 0;\n}\n\nNetNet* Design::find_discipline_reference(ivl_discipline_t dis, NetScope*scope)\n{\n      NetNet*gnd = discipline_references_[dis->name()];\n\n      if (gnd) return gnd;\n\n      string name = string(dis->name()) + \"$gnd\";\n      netvector_t*gnd_vec = new netvector_t(IVL_VT_REAL,0,0);\n      gnd = new NetNet(scope, lex_strings.make(name), NetNet::WIRE, gnd_vec);\n      gnd->set_discipline(dis);\n      discipline_references_[dis->name()] = gnd;\n\n      if (debug_elaborate)\n\t    cerr << gnd->get_fileline() << \": debug: \"\n\t\t << \"Create an implicit reference terminal\"\n\t\t << \" for discipline=\" << dis->name()\n\t\t << \" in scope=\" << scope_path(scope) << endl;\n\n      return gnd;\n}\n"
        },
        {
          "name": "elab_lval.cc",
          "type": "blob",
          "size": 55.3330078125,
          "content": "/*\n * Copyright (c) 2000-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2012-2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"PExpr.h\"\n# include  \"PPackage.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"netstruct.h\"\n# include  \"netclass.h\"\n# include  \"netdarray.h\"\n# include  \"netparray.h\"\n# include  \"netvector.h\"\n# include  \"netenum.h\"\n# include  \"compiler.h\"\n# include  <cstdlib>\n# include  <iostream>\n# include  <climits>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * These methods generate a NetAssign_ object for the l-value of the\n * assignment. This is common code for the = and <= statements.\n *\n * What gets generated depends on the structure of the l-value. If the\n * l-value is a simple name (i.e., foo <= <value>) then the NetAssign_\n * is created the width of the foo reg and connected to all the\n * bits.\n *\n * If there is a part select (i.e., foo[3:1] <= <value>) the NetAssign_\n * is made only as wide as it needs to be (3 bits in this example) and\n * connected to the correct bits of foo. A constant bit select is a\n * special case of the part select.\n *\n * If the bit-select is non-constant (i.e., foo[<expr>] = <value>) the\n * NetAssign_ is made wide enough to connect to all the bits of foo,\n * then the mux expression is elaborated and attached to the\n * NetAssign_ node as a b_mux value. The target must interpret the\n * presence of a bmux value as taking a single bit and assigning it to\n * the bit selected by the bmux expression.\n *\n * If the l-value expression is non-trivial, but can be fully\n * evaluated at compile time (meaning any bit selects are constant)\n * then elaboration will make a single NetAssign_ that connects to a\n * synthetic reg that in turn connects to all the proper pins of the\n * l-value.\n *\n * This last case can turn up in statements like: {a, b[1]} = c;\n * rather than create a NetAssign_ for each item in the concatenation,\n * elaboration makes a single NetAssign_ and connects it up properly.\n */\n\nvoid PEIdent::report_mixed_assignment_conflict_(const char*category) const\n{\n      cerr << get_fileline() << \": error: Cannot perform procedural \"\n              \"assignment to \" << category << \" '\" << path_\n           << \"' because it is also continuously assigned.\" << endl;\n}\n\n/*\n * The default interpretation of an l-value to a procedural assignment\n * is to try to make a net elaboration, and see if the result is\n * suitable for assignment.\n */\nNetAssign_* PExpr::elaborate_lval(Design*, NetScope*, bool, bool, bool) const\n{\n      cerr << get_fileline() << \": Assignment l-value too complex.\" << endl;\n      return 0;\n}\n\n/*\n * Concatenation expressions can appear as l-values. Handle them here.\n *\n * If adjacent l-values in the concatenation are not bit selects, then\n * merge them into a single NetAssign_ object. This can happen is code\n * like ``{ ...a, b, ...}''. As long as \"a\" and \"b\" do not have bit\n * selects (or the bit selects are constant) we can merge the\n * NetAssign_ objects.\n *\n * Be careful to get the bit order right. In the expression ``{a, b}''\n * a is the MSB and b the LSB. Connect the LSB to the low pins of the\n * NetAssign_ object.\n */\nNetAssign_* PEConcat::elaborate_lval(Design*des,\n\t\t\t\t     NetScope*scope,\n\t\t\t\t     bool is_cassign,\n\t\t\t\t     bool is_force,\n\t\t\t\t     bool is_init) const\n{\n      if (repeat_) {\n\t    cerr << get_fileline() << \": error: Repeat concatenations make \"\n\t\t  \"no sense in l-value expressions. I refuse.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetAssign_*res = 0;\n\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\n\t    if (parms_[idx] == 0) {\n\t\t  cerr << get_fileline() << \": error: Empty expressions \"\n\t\t       << \"not allowed in concatenations.\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    NetAssign_*tmp = parms_[idx]->elaborate_lval(des, scope,\n\t\t\t\t\t\t\t is_cassign, is_force, is_init);\n\n\t      /* If the l-value doesn't elaborate, the error was\n\t\t already detected and printed. We just skip it and let\n\t\t the compiler catch more errors. */\n\t    if (tmp == 0) continue;\n\n\t    if (tmp->expr_type() == IVL_VT_REAL) {\n\t\t  cerr << parms_[idx]->get_fileline() << \": error: \"\n\t\t       << \"concatenation operand can not be real: \"\n\t\t       << *parms_[idx] << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t      /* A concatenation is always unsigned. */\n\t    tmp->set_signed(false);\n\n\t      /* Link the new l-value to the previous one. */\n\t    NetAssign_*last = tmp;\n\t    while (last->more)\n\t\t  last = last->more;\n\n\t    last->more = res;\n\t    res = tmp;\n      }\n\n      return res;\n}\n\n\n/*\n * Handle the ident as an l-value. This includes bit and part selects\n * of that ident.\n */\nNetAssign_* PEIdent::elaborate_lval(Design*des,\n\t\t\t\t    NetScope*scope,\n\t\t\t\t    bool is_cassign,\n\t\t\t\t    bool is_force,\n\t\t\t\t    bool is_init) const\n{\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval: \"\n\t\t << \"Elaborate l-value ident expression: \" << *this << endl;\n      }\n\n      symbol_search_results sr;\n      symbol_search(this, des, scope, path_, lexical_pos_, &sr);\n\n      NetNet *reg = sr.net;\n      pform_name_t &member_path = sr.path_tail;\n\n\t/* The l-value must be a variable. If not, then give up and\n\t   print a useful error message. */\n      if (reg == 0) {\n\t    if (scope->type()==NetScope::FUNC\n\t\t&& scope->func_def()->is_void()\n\t\t&& scope->basename()==peek_tail_name(path_)) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Cannot assign to \" << path_\n\t\t       << \" because function \" << scope_path(scope)\n\t\t       << \" is void.\" << endl;\n\t    } else {\n\t\t  cerr << get_fileline() << \": error: Could not find variable ``\"\n\t\t       << path_ << \"'' in ``\" << scope_path(scope) <<\n\t\t\t\"''\" << endl;\n\t\t  if (sr.decl_after_use) {\n\t\t\tcerr << sr.decl_after_use->get_fileline() << \":      : \"\n\t\t\t\t\"A symbol with that name was declared here. \"\n\t\t\t\t\"Check for declaration after use.\" << endl;\n\t\t  }\n\t    }\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      ivl_assert(*this, reg);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Found l-value path_=\" << path_\n\t\t << \" as reg=\" << reg->name() << endl;\n\t    cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"reg->type()=\" << reg->type()\n\t\t << \", reg->unpacked_dimensions()=\" << reg->unpacked_dimensions()\n\t\t << endl;\n\t    if (reg->net_type())\n\t\t  cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"reg->net_type()=\" << *reg->net_type() << endl;\n\t    else\n\t\t  cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"reg->net_type()=<nil>\" << endl;\n\t    const pform_name_t &base_path = sr.path_head;\n\t    cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t << \" base_path=\" << base_path\n\t\t << \", member_path=\" << member_path\n\t\t << endl;\n      }\n\n      if (reg->get_const() && !is_init) {\n\t    cerr << get_fileline() << \": error: Assignment to const signal `\"\n\t         << reg->name() << \"` is not allowed.\" << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n\t/* We are elaborating procedural assignments. Wires are not allowed\n\t   unless this is the l-value of a force. */\n      if ((reg->type() != NetNet::REG)\n\t  && ((reg->type() != NetNet::UNRESOLVED_WIRE) || !reg->coerced_to_uwire())\n\t  && !is_force) {\n\t    cerr << get_fileline() << \": error: '\" << path_\n\t\t << \"' is not a valid l-value for a procedural assignment.\"\n\t\t << endl;\n\t    cerr << reg->get_fileline() << \":      : '\" << path_ <<\n\t\t  \"' is declared here as a \" << reg->type() << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      return elaborate_lval_var_(des, scope, is_force, is_cassign, reg,\n\t\t\t         sr.type, member_path);\n}\n\nNetAssign_*PEIdent::elaborate_lval_var_(Design *des, NetScope *scope,\n\t\t\t\t        bool is_force, bool is_cassign,\n\t\t\t\t\tNetNet *reg, ivl_type_t data_type,\n\t\t\t\t\tpform_name_t tail_path) const\n{\n\t// We are processing the tail of a string of names. For\n\t// example, the Verilog may be \"a.b.c\", so we are processing\n\t// \"c\" at this point.\n      const name_component_t&name_tail = path_.back();\n\n\t// Use the last index to determine what kind of select\n\t// (bit/part/etc) we are processing. For example, the Verilog\n\t// may be \"a.b.c[1][2][<index>]\". All but the last index must\n\t// be simple expressions, only the <index> may be a part\n\t// select etc., so look at it to determine how we will be\n\t// proceeding.\n      index_component_t::ctype_t use_sel = index_component_t::SEL_NONE;\n      if (!name_tail.index.empty())\n\t    use_sel = name_tail.index.back().sel;\n\n\t// Special case: The l-value is an entire memory, or array\n\t// slice. Detect the situation by noting if the index count\n\t// is less than the array dimensions (unpacked).\n      if (reg->unpacked_dimensions() > name_tail.index.size()) {\n\t    return elaborate_lval_array_(des, scope, is_force, reg);\n      }\n\n\t// If we find that the matched variable is a packed struct,\n\t// then we can handled it with the net_packed_member_ method.\n      if (reg->struct_type() && !tail_path.empty()) {\n\t    NetAssign_*lv = new NetAssign_(reg);\n\t    elaborate_lval_net_packed_member_(des, scope, lv, tail_path, is_force);\n\t    return lv;\n      }\n\n\t// If the variable is a class object, then handle it with the\n\t// net_class_member_ method.\n      const netclass_t *class_type = dynamic_cast<const netclass_t *>(data_type);\n      if (class_type && !tail_path.empty() && gn_system_verilog())\n\t    return elaborate_lval_net_class_member_(des, scope, class_type, reg, tail_path);\n\n\n\t// Past this point, we should have taken care of the cases\n\t// where the name is a member/method of a struct/class.\n\t// XXXX ivl_assert(*this, method_name.nil());\n      ivl_assert(*this, tail_path.empty());\n\n      bool need_const_idx = is_cassign || is_force;\n\n      if (reg->unpacked_dimensions() > 0)\n\t    return elaborate_lval_net_word_(des, scope, reg, need_const_idx, is_force);\n\n\t// This must be after the array word elaboration above!\n      if (reg->get_scalar() &&\n          use_sel != index_component_t::SEL_NONE) {\n\t    cerr << get_fileline() << \": error: can not select part of \";\n\t    if (reg->data_type() == IVL_VT_REAL) cerr << \"real: \";\n\t    else cerr << \"scalar: \";\n\t    cerr << reg->name() << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (use_sel == index_component_t::SEL_PART) {\n\t    NetAssign_*lv = new NetAssign_(reg);\n\t    elaborate_lval_net_part_(des, scope, lv, is_force);\n\t    return lv;\n      }\n\n      if (use_sel == index_component_t::SEL_IDX_UP ||\n          use_sel == index_component_t::SEL_IDX_DO) {\n\t    NetAssign_*lv = new NetAssign_(reg);\n\t    elaborate_lval_net_idx_(des, scope, lv, use_sel, need_const_idx, is_force);\n\t    return lv;\n      }\n\n\n      if (use_sel == index_component_t::SEL_BIT) {\n\t    if (reg->darray_type()) {\n\t\t  NetAssign_*lv = new NetAssign_(reg);\n\t\t  elaborate_lval_darray_bit_(des, scope, lv, is_force);\n\t\t  return lv;\n\t    } else {\n\t\t  NetAssign_*lv = new NetAssign_(reg);\n\t\t  elaborate_lval_net_bit_(des, scope, lv, need_const_idx, is_force);\n\t\t  return lv;\n\t    }\n      }\n\n      ivl_assert(*this, use_sel == index_component_t::SEL_NONE);\n\n      if (reg->type()==NetNet::UNRESOLVED_WIRE && !is_force) {\n\t    ivl_assert(*this, reg->coerced_to_uwire());\n\t    report_mixed_assignment_conflict_(\"variable\");\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t/* No select expressions. */\n\n      NetAssign_*lv = new NetAssign_(reg);\n      lv->set_signed(reg->get_signed());\n\n      return lv;\n}\n\nNetAssign_*PEIdent::elaborate_lval_array_(Design *des, NetScope *,\n\t\t\t\t          bool is_force, NetNet *reg) const\n{\n      if (!gn_system_verilog()) {\n\t    cerr << get_fileline() << \": error: Assignment to an entire\"\n\t\t  \" array or to an array slice requires SystemVerilog.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      const name_component_t&name_tail = path_.back();\n      if (name_tail.index.empty()) {\n\t    if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t  ivl_assert(*this, reg->coerced_to_uwire());\n\t\t  report_mixed_assignment_conflict_(\"array\");\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    NetAssign_*lv = new NetAssign_(reg);\n\t    return lv;\n      }\n\n      cerr << get_fileline() << \": sorry: Assignment to an \"\n\t    \" array slice is not yet supported.\"\n\t   << endl;\n      des->errors += 1;\n      return 0;\n}\n\nNetAssign_* PEIdent::elaborate_lval_net_word_(Design*des,\n\t\t\t\t\t      NetScope*scope,\n\t\t\t\t\t      NetNet*reg,\n\t\t\t\t\t      bool need_const_idx,\n\t\t\t\t\t      bool is_force) const\n{\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval_net_word_: \"\n\t\t << \"Handle as n-dimensional array.\" << endl;\n      }\n\n      if (name_tail.index.size() < reg->unpacked_dimensions()) {\n\t    cerr << get_fileline() << \": error: Array \" << reg->name()\n\t\t << \" needs \" << reg->unpacked_dimensions() << \" indices,\"\n\t\t << \" but got only \" << name_tail.index.size() << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// Make sure there are enough indices to address an array element.\n      const index_component_t&index_head = name_tail.index.front();\n      if (index_head.sel == index_component_t::SEL_PART) {\n\t    cerr << get_fileline() << \": error: cannot perform a part \"\n\t         << \"select on array \" << reg->name() << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\n\t// Evaluate all the index expressions into an\n\t// \"unpacked_indices\" array.\n      list<NetExpr*>unpacked_indices;\n      list<long> unpacked_indices_const;\n      indices_flags flags;\n      indices_to_expressions(des, scope, this,\n\t\t\t     name_tail.index, reg->unpacked_dimensions(),\n\t\t\t     false,\n\t\t\t     flags,\n\t\t\t     unpacked_indices,\n\t\t\t     unpacked_indices_const);\n\n      NetExpr*canon_index = 0;\n      if (flags.invalid) {\n\t    // Nothing to do.\n\n      } else if (flags.undefined) {\n\t    cerr << get_fileline() << \": warning: \"\n\t\t << \"ignoring undefined l-value array access \"\n\t\t << reg->name() << as_indices(unpacked_indices)\n\t\t << \".\" << endl;\n\n      } else if (flags.variable) {\n\t    if (need_const_idx) {\n\t\t  cerr << get_fileline() << \": error: array '\" << reg->name()\n\t\t       << \"' index must be a constant in this context.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    ivl_assert(*this, unpacked_indices.size() == reg->unpacked_dimensions());\n\t    canon_index = normalize_variable_unpacked(reg, unpacked_indices);\n\n      } else {\n\t    ivl_assert(*this, unpacked_indices_const.size() == reg->unpacked_dimensions());\n\t    canon_index = normalize_variable_unpacked(reg, unpacked_indices_const);\n\n\t    if (canon_index == 0) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t       << \"ignoring out of bounds l-value array access \"\n\t\t       << reg->name() << as_indices(unpacked_indices_const)\n\t\t       << \".\" << endl;\n\t    }\n      }\n\n\t// Ensure invalid array accesses are ignored.\n      if (canon_index == 0)\n\t    canon_index = new NetEConst(verinum(verinum::Vx));\n      canon_index->set_line(*this);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval_net_word_: \"\n\t\t << \"canon_index=\" << *canon_index << endl;\n      }\n\n      if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t    ivl_assert(*this, reg->coerced_to_uwire());\n\t    NetEConst*canon_const = dynamic_cast<NetEConst*>(canon_index);\n\t    if (!canon_const || reg->test_part_driven(reg->vector_width() - 1, 0,\n\t\t\t\t\t\t      canon_const->value().as_long())) {\n\t\t  report_mixed_assignment_conflict_(\"array word\");\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t     }\n      }\n\n      NetAssign_*lv = new NetAssign_(reg);\n      lv->set_word(canon_index);\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": debug: Set array word=\" << *canon_index << endl;\n\n\n\t/* An array word may also have part selects applied to them. */\n\n      index_component_t::ctype_t use_sel = index_component_t::SEL_NONE;\n      if (name_tail.index.size() > reg->unpacked_dimensions())\n\t    use_sel = name_tail.index.back().sel;\n\n      if (reg->get_scalar() &&\n          use_sel != index_component_t::SEL_NONE) {\n\t    cerr << get_fileline() << \": error: can not select part of \";\n\t    if (reg->data_type() == IVL_VT_REAL) cerr << \"real\";\n\t    else cerr << \"scalar\";\n\t    cerr << \" array word: \" << reg->name()\n\t         << as_indices(unpacked_indices) << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (use_sel == index_component_t::SEL_BIT)\n\t    elaborate_lval_net_bit_(des, scope, lv, need_const_idx, is_force);\n\n      if (use_sel == index_component_t::SEL_PART)\n\t    elaborate_lval_net_part_(des, scope, lv, is_force);\n\n      if (use_sel == index_component_t::SEL_IDX_UP ||\n          use_sel == index_component_t::SEL_IDX_DO)\n\t    elaborate_lval_net_idx_(des, scope, lv, use_sel,\n\t\t\t\t    need_const_idx, is_force);\n\n      return lv;\n}\n\nbool PEIdent::elaborate_lval_net_bit_(Design*des,\n\t\t\t\t      NetScope*scope,\n\t\t\t\t      NetAssign_*lv,\n\t\t\t\t      bool need_const_idx,\n\t\t\t\t      bool is_force) const\n{\n      list<long>prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, lv->sig(), prefix_indices);\n      if (!rc) return false;\n\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.msb != 0);\n      ivl_assert(*this, index_tail.lsb == 0);\n\n      NetNet*reg = lv->sig();\n      ivl_assert(*this, reg);\n\n\t// Bit selects have a single select expression. Evaluate the\n\t// constant value and treat it as a part select with a bit\n\t// width of 1.\n      NetExpr*mux = elab_and_eval(des, scope, index_tail.msb, -1);\n      long lsb = 0;\n\n      if (mux && mux->expr_type() == IVL_VT_REAL) {\n           cerr << get_fileline() << \": error: Index expression for \"\n                << reg->name() << \"[\" << *mux\n                << \"] cannot be a real value.\" << endl;\n           des->errors += 1;\n           return false;\n      }\n\n      if (NetEConst*index_con = dynamic_cast<NetEConst*> (mux)) {\n\t      // The index has a constant defined value.\n\t    if (index_con->value().is_defined()) {\n\t\t  lsb = index_con->value().as_long();\n\t\t  mux = 0;\n\t      // The index is undefined and this is a packed array.\n\t    } else if (prefix_indices.size()+2 <= reg->packed_dims().size()) {\n\t\t  long loff;\n\t\t  unsigned long lwid;\n\t\t  bool rcl = reg->sb_to_slice(prefix_indices, lsb, loff, lwid);\n\t\t  ivl_assert(*this, rcl);\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline()\n\t\t\t     << \": warning: L-value packed array select of \"\n\t\t\t     << reg->name();\n\t\t\tif (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\tcerr << \" has an undefined index.\" << endl;\n\t\t  }\n\t\t  lv->set_part(new NetEConst(verinum(verinum::Vx)), lwid);\n\t\t  return true;\n\t      // The index is undefined and this is a bit select.\n\t    } else {\n\t\t  if (warn_ob_select) {\n\t\t\tcerr << get_fileline()\n\t\t\t     << \": warning: L-value bit select of \"\n\t\t\t     << reg->name();\n\t\t\tif (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\tcerr << \" has an undefined index.\" << endl;\n\t\t  }\n\t\t  lv->set_part(new NetEConst(verinum(verinum::Vx)), 1);\n\t\t  return true;\n\t    }\n      }\n\n      if (debug_elaborate && (reg->type()==NetNet::UNRESOLVED_WIRE)) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval_net_bit_: \"\n\t\t << \"Try to assign bits of variable which is also continuously assigned.\"\n\t\t << endl;\n      }\n\n      if (prefix_indices.size()+2 <= reg->packed_dims().size()) {\n\t      // Special case: this is a slice of a multi-dimensional\n\t      // packed array. For example:\n\t      //   reg [3:0][7:0] x;\n\t      //   x[2] = ...\n\t      // This shows up as the prefix_indices being too short\n\t      // for the packed dimensions of the vector. What we do\n\t      // here is convert to a \"slice\" of the vector.\n\t    if (mux == 0) {\n\t\t  long loff;\n\t\t  unsigned long lwid;\n\t\t  bool rcl = reg->sb_to_slice(prefix_indices, lsb, loff, lwid);\n\t\t  ivl_assert(*this, rcl);\n\n\t\t  if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t\tivl_assert(*this, reg->coerced_to_uwire());\n\t\t\tif (reg->test_part_driven(loff+lwid-1, loff)) {\n\t\t\t      report_mixed_assignment_conflict_(\"slice\");\n\t\t\t      des->errors += 1;\n\t\t\t      return false;\n\t\t\t}\n\t\t  }\n\n\t\t  lv->set_part(new NetEConst(verinum(loff)), lwid);\n\n\t    } else {\n\t\t  unsigned long lwid;\n\t\t  mux = normalize_variable_slice_base(prefix_indices, mux,\n\t\t\t\t\t\t      reg, lwid);\n\n\t\t  if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t\tivl_assert(*this, reg->coerced_to_uwire());\n\t\t\treport_mixed_assignment_conflict_(\"slice\");\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\n\t\t  lv->set_part(mux, lwid);\n\t    }\n\n      } else if (reg->data_type() == IVL_VT_STRING) {\n\t    ivl_assert(*this, reg->type()!=NetNet::UNRESOLVED_WIRE);\n\t      // Special case: This is a select of a string\n\t      // variable. The target of the assignment is a character\n\t      // select of a string. Force the r-value to be an 8bit\n\t      // vector and set the \"part\" to be the character select\n\t      // expression. The code generator knows what to do with\n\t      // this.\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Bit select of string becomes character select.\" << endl;\n\t    }\n\t    if (!mux)\n\t\t  mux = new NetEConst(verinum(lsb));\n\t    lv->set_part(mux, &netvector_t::atom2s8);\n\n      } else if (mux) {\n\t      // Non-constant bit mux. Correct the mux for the range\n\t      // of the vector, then set the l-value part select\n\t      // expression.\n\t    if (need_const_idx) {\n\t\t  cerr << get_fileline() << \": error: '\" << reg->name()\n\t\t       << \"' bit select must be a constant in this context.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    mux = normalize_variable_bit_base(prefix_indices, mux, reg);\n\n\t    if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t  ivl_assert(*this, reg->coerced_to_uwire());\n\t\t  report_mixed_assignment_conflict_(\"bit select\");\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\n\t    lv->set_part(mux, 1);\n\n      } else if (reg->vector_width() == 1 && reg->sb_is_valid(prefix_indices,lsb)) {\n\t      // Constant bit mux that happens to select the only bit\n\t      // of the l-value. Don't bother with any select at all.\n\t      // If there's a continuous assignment, it must be a conflict.\n\t    if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t  ivl_assert(*this, reg->coerced_to_uwire());\n\t\t  report_mixed_assignment_conflict_(\"bit select\");\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\n      } else {\n\t      // Constant bit select that does something useful.\n\t    long loff = reg->sb_to_idx(prefix_indices,lsb);\n\n\t    if (warn_ob_select && (loff < 0 || loff >= (long)reg->vector_width())) {\n\t\t  cerr << get_fileline() << \": warning: bit select \"\n\t\t       << reg->name() << \"[\" <<lsb<<\"]\"\n\t\t       << \" is out of range.\" << endl;\n\t    }\n\n\t    if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t  ivl_assert(*this, reg->coerced_to_uwire());\n\t\t  if (reg->test_part_driven(loff, loff)) {\n\t\t\treport_mixed_assignment_conflict_(\"bit select\");\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\t    }\n\n\t    lv->set_part(new NetEConst(verinum(loff)), 1);\n      }\n\n      return true;\n}\n\nbool PEIdent::elaborate_lval_darray_bit_(Design*des,\n\t\t\t\t\t NetScope*scope,\n\t\t\t\t\t NetAssign_*lv,\n\t\t\t\t\t bool is_force) const\n{\n      const name_component_t&name_tail = path_.back();\n      ivl_assert(*this, !name_tail.index.empty());\n\n\t// For now, only support single-dimension dynamic arrays.\n      ivl_assert(*this, name_tail.index.size() == 1);\n\n      if ((lv->sig()->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t    ivl_assert(*this, lv->sig()->coerced_to_uwire());\n\t    report_mixed_assignment_conflict_(\"darray word\");\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.msb != 0);\n      ivl_assert(*this, index_tail.lsb == 0);\n\n\t// Evaluate the select expression...\n      NetExpr*mux = elab_and_eval(des, scope, index_tail.msb, -1);\n\n      lv->set_word(mux);\n\n      return true;\n}\n\nbool PEIdent::elaborate_lval_net_part_(Design*des,\n\t\t\t\t       NetScope*scope,\n\t\t\t\t       NetAssign_*lv,\n\t\t\t\t       bool is_force) const\n{\n      if (lv->sig()->data_type() == IVL_VT_STRING) {\n           cerr << get_fileline() << \": error: Cannot part select assign to a string ('\"\n                << lv->sig()->name() << \"').\" << endl;\n           des->errors += 1;\n           return false;\n      }\n\n      list<long> prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, lv->sig(), prefix_indices);\n      ivl_assert(*this, rc);\n\n\t// The range expressions of a part select must be\n\t// constant. The calculate_parts_ function calculates the\n\t// values into msb and lsb.\n      long msb, lsb;\n      bool parts_defined_flag;\n      bool flag = calculate_parts_(des, scope, msb, lsb, parts_defined_flag);\n      if (!flag) return false;\n\n      NetNet*reg = lv->sig();\n      ivl_assert(*this, reg);\n\n      if (! parts_defined_flag) {\n\t    if (warn_ob_select) {\n\t\t  cerr << get_fileline()\n\t\t       << \": warning: L-value part select of \"\n\t\t       << reg->name();\n\t\t  if (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t  cerr << \" has an undefined index.\" << endl;\n\t    }\n\t      // Use a width of two here so we can distinguish between an\n\t      // undefined bit or part select.\n\t    lv->set_part(new NetEConst(verinum(verinum::Vx)), 2);\n\t    return true;\n      }\n\n      if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t    ivl_assert(*this, reg->coerced_to_uwire());\n\t    if (reg->test_part_driven(msb, lsb)) {\n\t\t  report_mixed_assignment_conflict_(\"part select\");\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n      }\n\n      const netranges_t&packed = reg->packed_dims();\n\n      long loff, moff;\n      if (prefix_indices.size()+1 < packed.size()) {\n\t      // If there are fewer indices then there are packed\n\t      // dimensions, then this is a range of slices. Calculate\n\t      // it into a big slice.\n\t    bool lrc, mrc;\n\t    unsigned long lwid, mwid;\n\t    lrc = reg->sb_to_slice(prefix_indices, lsb, loff, lwid);\n\t    mrc = reg->sb_to_slice(prefix_indices, msb, moff, mwid);\n\t    if (!mrc || !lrc) {\n\t\t  cerr << get_fileline() << \": error: \";\n\t\t  cerr << \"Part-select [\" << msb << \":\" << lsb;\n\t\t  cerr << \"] exceeds the declared bounds for \";\n\t\t  cerr << reg->name();\n\t\t  if (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t  cerr << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    assert(lwid == mwid);\n\t    moff += mwid - 1;\n      } else {\n\t    loff = reg->sb_to_idx(prefix_indices,lsb);\n\t    moff = reg->sb_to_idx(prefix_indices,msb);\n      }\n\n      if (moff < loff) {\n\t    cerr << get_fileline() << \": error: part select \"\n\t\t << reg->name() << \"[\" << msb<<\":\"<<lsb<<\"]\"\n\t\t << \" is reversed.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      unsigned long wid = moff - loff + 1;\n\n\t// Special case: The range winds up selecting the entire\n\t// vector. Treat this as no part select at all.\n      if (loff == 0 && wid == reg->vector_width()) {\n\t    return true;\n      }\n\n\t/* If the part select extends beyond the extremes of the\n\t   variable, then output a warning. Note that loff is\n\t   converted to normalized form so is relative the\n\t   variable pins. */\n\n      if (warn_ob_select && (loff < 0 || moff >= (long)reg->vector_width())) {\n\t    cerr << get_fileline() << \": warning: Part select \"\n\t\t << reg->name() << \"[\" << msb<<\":\"<<lsb<<\"]\"\n\t\t << \" is out of range.\" << endl;\n      }\n\n      lv->set_part(new NetEConst(verinum(loff)), wid);\n\n      return true;\n}\n\nbool PEIdent::elaborate_lval_net_idx_(Design*des,\n\t\t\t\t      NetScope*scope,\n\t\t\t\t      NetAssign_*lv,\n\t\t\t\t      index_component_t::ctype_t use_sel,\n\t\t\t\t      bool need_const_idx,\n\t\t\t\t      bool is_force) const\n{\n      if (lv->sig()->data_type() == IVL_VT_STRING) {\n           cerr << get_fileline() << \": error: Cannot index part select assign to a string ('\"\n                << lv->sig()->name() << \"').\" << endl;\n           des->errors += 1;\n           return false;\n      }\n\n      list<long>prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, lv->sig(), prefix_indices);\n      ivl_assert(*this, rc);\n\n      const name_component_t&name_tail = path_.back();;\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n      ivl_assert(*this, index_tail.msb != 0);\n      ivl_assert(*this, index_tail.lsb != 0);\n\n      NetNet*reg = lv->sig();\n      ivl_assert(*this, reg);\n\n      unsigned long wid;\n      calculate_up_do_width_(des, scope, wid);\n\n      NetExpr*base = elab_and_eval(des, scope, index_tail.msb, -1);\n\n      if (base && base->expr_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: Indexed part select base \"\n\t            \"expression for \";\n\t    cerr << lv->sig()->name() << \"[\" << *base;\n\t    if (index_tail.sel == index_component_t::SEL_IDX_UP) {\n\t\t  cerr << \"+:\";\n\t    } else {\n\t\t  cerr << \"-:\";\n\t    }\n\t    cerr << wid << \"] cannot be a real value.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      ivl_select_type_t sel_type = IVL_SEL_OTHER;\n\n\t// Handle the special case that the base is constant. For this\n\t// case we can reduce the expression.\n      if (NetEConst*base_c = dynamic_cast<NetEConst*> (base)) {\n\t      // For the undefined case just let the constant pass and\n\t      // we will handle it in the code generator.\n\t    if (base_c->value().is_defined()) {\n\t\t  long lsv = base_c->value().as_long();\n\t\t  long rel_base = 0;\n\n\t\t    // Check whether an unsigned base fits in a 32 bit int.\n\t\t    // This ensures correct results for the vlog95 target, and\n\t\t    // for the vvp target on LLP64 platforms (Microsoft Windows).\n\t\t  if (!base_c->has_sign() && (int32_t)lsv < 0) {\n\t\t          // The base is wrapped around.\n\t\t\tdelete base;\n\t\t\tif (warn_ob_select) {\n\t\t\t      cerr << get_fileline() << \": warning: \" << lv->name();\n\t\t\t      if (lv->word()) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << (unsigned long)lsv\n\t\t\t\t   << (index_tail.sel == index_component_t::SEL_IDX_UP ? \"+:\" : \"-:\")\n\t\t\t\t   << wid << \"] is always outside vector.\" << endl;\n\t\t\t}\n\t\t\treturn false;\n\t\t  }\n\n\t\t    // Get the signal range.\n\t\t  const netranges_t&packed = reg->packed_dims();\n\t\t  if (prefix_indices.size()+1 < reg->packed_dims().size()) {\n\t\t\t  // Here we are selecting one or more sub-arrays.\n\t\t\t  // Make this work by finding the indexed sub-arrays and\n\t\t\t  // creating a generated slice that spans the whole range.\n\t\t\tlong loff, moff;\n\t\t\tunsigned long lwid, mwid;\n\t\t\tbool lrc, mrc;\n\t\t\tmrc = reg->sb_to_slice(prefix_indices, lsv, moff, mwid);\n\t\t\tif (use_sel == index_component_t::SEL_IDX_UP)\n\t\t\t      lrc = reg->sb_to_slice(prefix_indices, lsv+wid-1, loff, lwid);\n\t\t\telse\n\t\t\t      lrc = reg->sb_to_slice(prefix_indices, lsv-wid+1, loff, lwid);\n\t\t\tif (!mrc || !lrc) {\n\t\t\t      cerr << get_fileline() << \": error: \";\n\t\t\t      cerr << \"Part-select [\" << lsv;\n\t\t\t      if (index_tail.sel == index_component_t::SEL_IDX_UP) {\n\t\t\t\t    cerr << \"+:\";\n\t\t\t      } else {\n\t\t\t\t    cerr << \"-:\";\n\t\t\t      }\n\t\t\t      cerr << wid << \"] exceeds the declared bounds for \";\n\t\t\t      cerr << reg->name();\n\t\t\t      if (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t      cerr << \".\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\t\t\tivl_assert(*this, lwid == mwid);\n\n\t\t\tif (moff > loff) {\n\t\t\t      rel_base = loff;\n\t\t\t      wid = moff + mwid - loff;\n\t\t\t} else {\n\t\t\t      rel_base = moff;\n\t\t\t      wid = loff + lwid - moff;\n\t\t\t}\n\t\t  } else {\n\t\t\tlong offset = 0;\n\t\t\t  // We want the last range, which is where we work.\n\t\t\tconst netrange_t&rng = packed.back();\n\t\t\tif (((rng.get_msb() < rng.get_lsb()) &&\n\t\t\t     use_sel == index_component_t::SEL_IDX_UP) ||\n\t\t\t    ((rng.get_msb() > rng.get_lsb()) &&\n\t\t\t     use_sel == index_component_t::SEL_IDX_DO)) {\n\t\t\t      offset = -wid + 1;\n\t\t\t}\n\t\t\trel_base = reg->sb_to_idx(prefix_indices,lsv) + offset;\n\t\t  }\n\t\t  delete base;\n\t\t  if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t\tivl_assert(*this, reg->coerced_to_uwire());\n\t\t\tif (reg->test_part_driven(rel_base+wid-1, rel_base)) {\n\t\t\t      report_mixed_assignment_conflict_(\"part select\");\n\t\t\t      des->errors += 1;\n\t\t\t      return false;\n\t\t\t}\n\t\t  }\n\t\t    /* If we cover the entire lvalue just skip the select. */\n\t\t  if (rel_base == 0 && wid == reg->vector_width()) return true;\n\t\t  base = new NetEConst(verinum(rel_base));\n\t\t  if (warn_ob_select) {\n\t\t\tif (rel_base < 0) {\n\t\t\t      cerr << get_fileline() << \": warning: \" << reg->name();\n\t\t\t      if (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << lsv;\n\t\t\t      if (use_sel == index_component_t::SEL_IDX_UP) {\n\t\t\t\t    cerr << \"+:\";\n\t\t\t      } else {\n\t\t\t\t    cerr << \"-:\";\n\t\t\t      }\n\t\t\t      cerr << wid << \"] is selecting before vector.\" << endl;\n\t\t\t}\n\t\t\tif (rel_base + wid > reg->vector_width()) {\n\t\t\t      cerr << get_fileline() << \": warning: \" << reg->name();\n\t\t\t      if (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t      cerr << \"[\" << lsv;\n\t\t\t      if (use_sel == index_component_t::SEL_IDX_UP) {\n\t\t\t\t    cerr << \"+:\";\n\t\t\t      } else {\n\t\t\t\t    cerr << \"-:\";\n\t\t\t      }\n\t\t\t      cerr << wid << \"] is selecting after vector.\" << endl;\n\t\t\t}\n\t\t  }\n\t    } else if (warn_ob_select) {\n\t\t  cerr << get_fileline() << \": warning: L-value indexed part \"\n\t\t       << \"select of \" << reg->name();\n\t\t  if (reg->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t  cerr << \" has an undefined base.\" << endl;\n\t    }\n      } else {\n\t    if (need_const_idx) {\n\t\t  cerr << get_fileline() << \": error: '\" << reg->name()\n\t\t       << \"' base index must be a constant in this context.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t\t  ivl_assert(*this, reg->coerced_to_uwire());\n\t\t  report_mixed_assignment_conflict_(\"part select\");\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    ivl_assert(*this, prefix_indices.size()+1 == reg->packed_dims().size());\n\t      /* Correct the mux for the range of the vector. */\n\t    if (use_sel == index_component_t::SEL_IDX_UP) {\n\t\t  base = normalize_variable_part_base(prefix_indices, base,\n\t\t\t\t\t\t      reg, wid, true);\n\t\t  sel_type = IVL_SEL_IDX_UP;\n\t    } else {\n\t\t    // This is assumed to be a SEL_IDX_DO.\n\t\t  base = normalize_variable_part_base(prefix_indices, base,\n\t\t\t\t\t\t      reg, wid, false);\n\t\t  sel_type = IVL_SEL_IDX_DOWN;\n\t    }\n      }\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": debug: Set part select width=\"\n\t\t << wid << \", base=\" << *base << endl;\n\n      lv->set_part(base, wid, sel_type);\n\n      return true;\n}\n\n/*\n * When the l-value turns out to be a class object, this method is\n * called with the bound variable, and the method path. For example,\n * if path_=a.b.c and a.b binds to the variable, then sig is b, and\n * member_path=c. if path_=obj.base.x, and base_path=obj, then sig is\n * obj, and member_path=base.x.\n */\nNetAssign_* PEIdent::elaborate_lval_net_class_member_(Design*des, NetScope*scope,\n\t\t\t\t    const netclass_t *class_type, NetNet*sig,\n\t\t\t\t    pform_name_t member_path) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval_net_class_member_: \"\n\t\t << \"l-value is property \" << member_path\n\t\t << \" of \" << sig->name() << \".\" << endl;\n      }\n\n      ivl_assert(*this, class_type);\n\n\t// Iterate over the member_path. This handles nested class\n\t// object, by generating nested NetAssign_ object. We start\n\t// with lv==0, so the front of the member_path is the member\n\t// of the outermost class. This generates an lv from sig. Then\n\t// iterate over the remaining of the member_path, replacing\n\t// the outer lv with an lv that nests the lv from the previous\n\t// iteration.\n      NetAssign_*lv = 0;\n      do {\n\t      // Start with the first component of the member path...\n\t    perm_string method_name = peek_head_name(member_path);\n\t      // Pull that component from the member_path. We need to\n\t      // know the current member being worked on, and will\n\t      // need to know if there are more members to be worked on.\n\t    name_component_t member_cur = member_path.front();\n\t    member_path.pop_front();\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_lval_net_class_member_: \"\n\t\t       << \"Processing member_cur=\" << member_cur\n\t\t       << endl;\n\t    }\n\n\t      // Make sure the property is really present in the class. If\n\t      // not, then generate an error message and return an error.\n\t    int pidx = class_type->property_idx_from_name(method_name);\n\t    if (pidx < 0) {\n\t\t  cerr << get_fileline() << \": error: Class \" << class_type->get_name()\n\t\t       << \" does not have a property \" << method_name << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    property_qualifier_t qual = class_type->get_prop_qual(pidx);\n\t    if (qual.test_local() && ! class_type->test_scope_is_method(scope)) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Local property \" << class_type->get_prop_name(pidx)\n\t\t       << \" is not accessible (l-value) in this context.\"\n\t\t       << \" (scope=\" << scope_path(scope) << \")\" << endl;\n\t\t  des->errors += 1;\n\n\t    } else if (qual.test_static()) {\n\n\t\t    // Special case: this is a static property. Ignore the\n\t\t    // \"this\" sig and use the property itself, which is not\n\t\t    // part of the sig, as the l-value.\n\t\t  NetNet*psig = class_type->find_static_property(method_name);\n\t\t  ivl_assert(*this, psig);\n\n\t\t  lv = new NetAssign_(psig);\n\t\t  return lv;\n\n\t    } else if (qual.test_const()) {\n\t\t if (class_type->get_prop_initialized(pidx)) {\n\t\t       cerr << get_fileline() << \": error: \"\n\t\t\t    << \"Property \" << class_type->get_prop_name(pidx)\n\t\t\t    << \" is constant in this method.\"\n\t\t\t    << \" (scope=\" << scope_path(scope) << \")\" << endl;\n\t\t       des->errors++;\n\t\t } else if (scope->basename() != \"new\" && scope->basename() != \"new@\") {\n\t\t       cerr << get_fileline() << \": error: \"\n\t\t\t    << \"Property \" << class_type->get_prop_name(pidx)\n\t\t\t    << \" is constant in this method.\"\n\t\t\t    << \" (scope=\" << scope_path(scope) << \")\" << endl;\n\t\t       des->errors++;\n\t\t } else {\n\t\t\t // Mark this property as initialized. This is used\n\t\t\t // to know that we have initialized the constant\n\t\t\t // object so the next assignment will be marked as\n\t\t\t // illegal.\n\t\t       class_type->set_prop_initialized(pidx);\n\n\t\t       if (debug_elaborate) {\n\t\t\t     cerr << get_fileline() << \": PEIdent::elaborate_lval_method_class_member_: \"\n\t\t\t\t  << \"Found initializers for property \" << class_type->get_prop_name(pidx) << endl;\n\t\t       }\n\t\t }\n\t    }\n\n\t    lv = lv? new NetAssign_(lv) : new NetAssign_(sig);\n\t    lv->set_property(method_name, pidx);\n\n\t      // Now get the type of the property.\n\t    ivl_type_t ptype = class_type->get_prop_type(pidx);\n\t    const netdarray_t*mtype = dynamic_cast<const netdarray_t*> (ptype);\n\t    if (mtype) {\n\t\t  if (! member_cur.index.empty()) {\n\t\t\tcerr << get_fileline() << \": sorry: \"\n\t\t\t     << \"Array index of array properties not supported.\"\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t    }\n\t    NetExpr *canon_index = nullptr;\n\t    if (!member_cur.index.empty()) {\n\t\t  if (const netsarray_t *stype = dynamic_cast<const netsarray_t*>(ptype)) {\n\t\t\tcanon_index = make_canonical_index(des, scope, this,\n\t\t\t\t\t\t\t   member_cur.index, stype, false);\n\n\t\t  } else {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Index expressions don't apply to this type of property.\" << endl;\n\t\t\tdes->errors++;\n\t\t  }\n\t    }\n\n\t    if (const netuarray_t *tmp_ua = dynamic_cast<const netuarray_t*>(ptype)) {\n\t\t  const auto &dims = tmp_ua->static_dimensions();\n\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_lval_method_class_member_: \"\n\t\t\t     << \"Property \" << class_type->get_prop_name(pidx)\n\t\t\t     << \" has \" << dims.size() << \" dimensions, \"\n\t\t\t     << \" got \" << member_cur.index.size() << \" indices.\" << endl;\n\t\t\tif (canon_index) {\n\t\t\t      cerr << get_fileline() << \": PEIdent::elaborate_lval_method_class_member_: \"\n\t\t\t\t   << \"Canonical index is:\" << *canon_index << endl;\n\t\t\t}\n\t\t  }\n\n\t\t  if (dims.size() != member_cur.index.size()) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Got \" << member_cur.index.size() << \" indices, \"\n\t\t\t     << \"expecting \" << dims.size()\n\t\t\t     << \" to index the property \" << class_type->get_prop_name(pidx) << \".\" << endl;\n\t\t\tdes->errors++;\n\t\t  }\n\t    }\n\n\t    if (canon_index)\n\t\t  lv->set_word(canon_index);\n\n\t      // If the current member is a class object, then get the\n\t      // type. We may wind up iterating, and need the proper\n\t      // class type.\n\t    class_type = dynamic_cast<const netclass_t*>(ptype);\n\n      } while (!member_path.empty());\n\n\n      return lv;\n}\n\n/*\n * This method is caled to handle l-value identifiers that are packed\n * structs. The lv is already attached to the variable, so this method\n * calculates the part select that is defined by the member_path. For\n * example, if the path_ is main.sub.sub_local, and the variable is\n * main, then we know at this point that main is a packed struct, and\n * lv contains the reference to the bound variable (main). In this\n * case member_path==sub.sub_local, and it is up to this method to\n * work out the part select that the member_path represents.\n */\nbool PEIdent::elaborate_lval_net_packed_member_(Design*des, NetScope*scope,\n\t\t\t\t\t\tNetAssign_*lv,\n\t\t\t\t\t\tpform_name_t member_path,\n\t\t\t\t\t\tbool is_force) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t << \"path_=\" << path_\n\t\t << \" member_path=\" << member_path\n\t\t << endl;\n      }\n\n      NetNet*reg = lv->sig();\n      ivl_assert(*this, reg);\n\n      const netstruct_t*struct_type = reg->struct_type();\n      ivl_assert(*this, struct_type);\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t << \"Type=\" << *struct_type\n\t\t << endl;\n      }\n\n      if (! struct_type->packed()) {\n\t    cerr << get_fileline() << \": sorry: Only packed structures \"\n\t\t << \"are supported in l-value.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n\t// Looking for the base name. We need that to know about\n\t// indices we may need to apply. This is to handle the case\n\t// that the base is an array of structs, and not just a\n\t// struct.\n      pform_name_t::const_reverse_iterator name_idx = path_.name.rbegin();\n      for (size_t idx = 1 ; idx < member_path.size() ; idx += 1)\n\t    ++ name_idx;\n      if (name_idx->name != peek_head_name(member_path)) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"name_idx=\" << name_idx->name\n\t\t << \", expecting member_name=\" << peek_head_name(member_path)\n\t\t << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n      ivl_assert(*this, name_idx->name == peek_head_name(member_path));\n      ++ name_idx;\n      const name_component_t&name_base = *name_idx;\n\n\t// Shouldn't be seeing unpacked arrays of packed structs...\n      ivl_assert(*this, reg->unpacked_dimensions() == 0);\n\n\t// These make up the \"part\" select that is the equivilent of\n\t// following the member path through the nested structs. To\n\t// start with, the off[set] is zero, and use_width is the\n\t// width of the entire variable. The first member_comp is at\n\t// some offset within the variable, and will have a reduced\n\t// width. As we step through the member_path the off\n\t// increases, and use_width shrinks.\n      unsigned long off = 0;\n      unsigned long use_width = struct_type->packed_width();\n      ivl_type_t member_type;\n\n      pform_name_t completed_path;\n      do {\n\t    const name_component_t member_comp = member_path.front();\n\t    const perm_string&member_name = member_comp.name;\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t       << \"Processing member_comp=\" << member_comp\n\t\t       << \" (completed_path=\" << completed_path << \")\"\n\t\t       << endl;\n\t    }\n\n\t      // This is a packed member, so the name is of the form\n\t      // \"a.b[...].c[...]\" which means that the path_ must have at\n\t      // least 2 components. We are processing \"c[...]\" at that\n\t      // point (otherwise known as member_name) and we have a\n\t      // reference to it in member_comp.\n\n\t      // The member_path is the members we want to follow for the\n\t      // variable. For example, main[N].a.b may have main[N] as the\n\t      // base_name, and member_path=a.b. The member_name is the\n\t      // start of the member_path, and is \"a\". The member_name\n\t      // should be a member of the struct_type type.\n\n\t      // Calculate the offset within the packed structure of the\n\t      // member, and any indices. We will add in the offset of the\n\t      // struct into the packed array later. Note that this works\n\t      // for packed unions as well (although the offset will be 0\n\t      // for union members).\n\t    unsigned long tmp_off;\n\t    const netstruct_t::member_t* member = struct_type->packed_member(member_name, tmp_off);\n\n\t    if (member == 0) {\n\t\t  cerr << get_fileline() << \": error: Member \" << member_name\n\t\t       << \" is not a member of struct type of \"\n\t\t       << reg->name()\n\t\t       << \".\" << completed_path << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t       << \"Member type: \" << *(member->net_type)\n\t\t       << endl;\n\t    }\n\n\t    off += tmp_off;\n\t    ivl_assert(*this, use_width >= (unsigned long)member->net_type->packed_width());\n\t    use_width = member->net_type->packed_width();\n\n\t      // At this point, off and use_width are the part select\n\t      // expressed by the member_comp, which is a member of the\n\t      // struct. We can further refine the part select with any\n\t      // indices that might be present.\n\n\t      // Get the index component type. At this point, we only\n\t      // support bit select or none.\n\t    index_component_t::ctype_t use_sel = index_component_t::SEL_NONE;\n\t    if (!member_comp.index.empty())\n\t\t  use_sel = member_comp.index.back().sel;\n\n\t    if (use_sel != index_component_t::SEL_NONE\n\t\t&& use_sel != index_component_t::SEL_BIT\n\t\t&& use_sel != index_component_t::SEL_PART) {\n\t\t  cerr << get_fileline() << \": sorry: Assignments to part selects of \"\n\t\t\t\"a struct member are not yet supported.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\n\t    member_type = member->net_type;\n\n\t    if (const netvector_t*mem_vec = dynamic_cast<const netvector_t*>(member->net_type)) {\n\t\t    // If the member type is a netvector_t, then it is a\n\t\t    // vector of atom or scaler objects. For example, if the\n\t\t    // l-value expression is \"foo.member[1][2]\",\n\t\t    // then the member should be something like:\n\t\t    //    ... logic [h:l][m:n] member;\n\t\t    // There should be index expressions index the vector\n\t\t    // down, but there doesn't need to be all of them. We\n\t\t    // can, for example, be selecting a part of the vector.\n\n\t\t    // We only need to process this if there are any\n\t\t    // index expressions. If not, then the packed\n\t\t    // vector can be handled atomically.\n\n\t\t    // In any case, this should be the tail of the\n\t\t    // member_path, because the array element of this\n\t\t    // kind of array cannot be a struct.\n\t\t  if (!member_comp.index.empty()) {\n\t\t\t  // These are the dimensions defined by the type\n\t\t\tconst netranges_t&mem_packed_dims = mem_vec->packed_dims();\n\n\t\t\tif (member_comp.index.size() > mem_packed_dims.size()) {\n\t\t\t      cerr << get_fileline() << \": error: \"\n\t\t\t\t   << \"Too many index expressions for member.\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return false;\n\t\t\t}\n\n\t\t\t  // Evaluate all but the last index expression, into prefix_indices.\n\t\t\tlist<long>prefix_indices;\n\t\t\tbool rc = evaluate_index_prefix(des, scope, prefix_indices, member_comp.index);\n\t\t\tivl_assert(*this, rc);\n\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t\t\t   << \"prefix_indices.size()==\" << prefix_indices.size()\n\t\t\t\t   << \", mem_packed_dims.size()==\" << mem_packed_dims.size()\n\t\t\t\t   << \" (netvector_t context)\"\n\t\t\t\t   << endl;\n\t\t\t}\n\n\t\t\tlong tail_off = 0;\n\t\t\tunsigned long tail_wid = 0;\n\t\t\trc = calculate_part(this, des, scope, member_comp.index.back(), tail_off, tail_wid);\n\t\t\tivl_assert(*this, rc);\n\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t\t\t   << \"calculate_part for tail returns tail_off=\" << tail_off\n\t\t\t\t   << \", tail_wid=\" << tail_wid\n\t\t\t\t   << endl;\n\t\t\t}\n\n\t\t\t  // Now use the prefix_to_slice function to calculate the\n\t\t\t  // offset and width of the addressed slice of the member.\n\t\t\tlong loff;\n\t\t\tunsigned long lwid;\n\t\t\tprefix_to_slice(mem_packed_dims, prefix_indices, tail_off, loff, lwid);\n\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t\t\t   << \"Calculate loff=\" << loff << \" lwid=\" << lwid\n\t\t\t\t   << \" tail_off=\" << tail_off << \" tail_wid=\" << tail_wid\n\t\t\t\t   << \" off=\" << off << \" use_width=\" << use_width\n\t\t\t\t   << endl;\n\t\t\t}\n\n\t\t\toff += loff;\n\t\t\tuse_width = lwid * tail_wid;\n\t\t\tmember_type = nullptr;\n\t\t  }\n\n\t\t    // The netvector_t only has atom elements, to\n\t\t    // there is no next struct type.\n\t\t  struct_type = 0;\n\n\t    } else if (const netparray_t*array = dynamic_cast<const netparray_t*> (member->net_type)) {\n\t\t    // If the member is a parray, then the elements\n\t\t    // are themselves packed object, including\n\t\t    // possibly a struct. Handle this by taking the\n\t\t    // part select of the current part of the\n\t\t    // variable, then stepping to the element type to\n\t\t    // possibly iterate through more of the member_path.\n\n\t\t  ivl_assert(*this, array->packed());\n\t\t  ivl_assert(*this, !member_comp.index.empty());\n\n\t\t    // These are the dimensions defined by the type\n\t\t  const netranges_t&mem_packed_dims = array->static_dimensions();\n\n\t\t  if (member_comp.index.size() != mem_packed_dims.size()) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Incorrect number of index expressions for member \"\n\t\t\t     << member_name << \".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\n\t\t    // Evaluate all but the last index expression, into prefix_indices.\n\t\t  list<long>prefix_indices;\n\t\t  bool rc = evaluate_index_prefix(des, scope, prefix_indices, member_comp.index);\n\t\t  ivl_assert(*this, rc);\n\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t\t     << \"prefix_indices.size()==\" << prefix_indices.size()\n\t\t\t     << \", mem_packed_dims.size()==\" << mem_packed_dims.size()\n\t\t\t     << \" (netparray_t context)\"\n\t\t\t     << endl;\n\t\t  }\n\n\t\t    // Evaluate the last index expression into a constant long.\n\t\t  NetExpr*texpr = elab_and_eval(des, scope, member_comp.index.back().msb, -1, true);\n\t\t  long tmp;\n\t\t  if (texpr == 0 || !eval_as_long(tmp, texpr)) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Array index expressions for member \" << member_name\n\t\t\t     << \" must be constant here.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\n\t\t  delete texpr;\n\n\t\t    // Now use the prefix_to_slice function to calculate the\n\t\t    // offset and width of the addressed slice of the member.\n\t\t  long loff;\n\t\t  unsigned long lwid;\n\t\t  prefix_to_slice(mem_packed_dims, prefix_indices, tmp, loff, lwid);\n\n\t\t  ivl_type_t element_type = array->element_type();\n\t\t  long element_width = element_type->packed_width();\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t\t     << \"parray subselection loff=\" << loff\n\t\t\t     << \", lwid=\" << lwid\n\t\t\t     << \", element_width=\" << element_width\n\t\t\t     << endl;\n\t\t  }\n\n\t\t    // The width and offset calculated from the\n\t\t    // indices is actually in elements, and not\n\t\t    // bits. In fact, in this context, the lwid should\n\t\t    // come down to 1 (one element).\n\t\t  off += loff * element_width;\n\t\t  ivl_assert(*this, lwid==1);\n\t\t  use_width = element_width;\n\n\t\t    // To move on to the next component in the member\n\t\t    // path, get the element type. For example, for\n\t\t    // the path a.b[1].c, we are processing b[1] here,\n\t\t    // and the element type should be a netstruct_t\n\t\t    // that will wind up containing the member c.\n\t\t  struct_type = dynamic_cast<const netstruct_t*> (element_type);\n\n\t    } else if (const netstruct_t*tmp_struct = dynamic_cast<const netstruct_t*> (member->net_type)) {\n\t\t    // If the member is itself a struct, then get\n\t\t    // ready to go on to the next iteration.\n\t\t  struct_type = tmp_struct;\n\n\t    } else if (const netenum_t*tmp_enum = dynamic_cast<const netenum_t*> (member->net_type)) {\n\t\t    // If the element is an enum, then we don't have\n\t\t    // anything special to do.\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t\t     << \"Tail element is an enum: \" << *tmp_enum\n\t\t\t     << endl;\n\t\t  }\n\t\t  struct_type = 0;\n\n\t    } else {\n\t\t    // Unknown type?\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"Unexpected member type? \" << *(member->net_type)\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\n\t      // Complete this component of the path, mark it\n\t      // completed, and set up for the next component.\n\t    completed_path .push_back(member_comp);\n\t    member_path.pop_front();\n\n      } while (!member_path.empty() && struct_type != 0);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_lval_net_packed_member_: \"\n\t\t << \"After processing member_path, \"\n\t\t << \"off=\" << off\n\t\t << \", use_width=\" << use_width\n\t\t << \", completed_path=\" << completed_path\n\t\t << \", member_path=\" << member_path\n\t\t << endl;\n      }\n\n\t// The dimensions in the expression must match the packed\n\t// dimensions that are declared for the variable. For example,\n\t// if foo is a packed array of struct, then this expression\n\t// must be \"b[n][m]\" with the right number of dimensions to\n\t// match the declaration of \"b\".\n\t// Note that one of the packed dimensions is the packed struct\n\t// itself.\n      ivl_assert(*this, name_base.index.size()+1 == reg->packed_dimensions());\n\n\t// Generate an expression that takes the input array of\n\t// expressions and generates a canonical offset into the\n\t// packed array.\n      NetExpr*packed_base = 0;\n      if (reg->packed_dimensions() > 1) {\n\t    list<index_component_t>tmp_index = name_base.index;\n\t    index_component_t member_select;\n\t    member_select.sel = index_component_t::SEL_BIT;\n\t    member_select.msb = new PENumber(new verinum(off));\n\t    tmp_index.push_back(member_select);\n\t    packed_base = collapse_array_indices(des, scope, reg, tmp_index);\n      }\n\n      long tmp;\n      if (packed_base && eval_as_long(tmp, packed_base)) {\n\t    off = tmp;\n\t    delete packed_base;\n\t    packed_base = 0;\n      }\n\n      if ((reg->type()==NetNet::UNRESOLVED_WIRE) && !is_force) {\n\t    ivl_assert(*this, reg->coerced_to_uwire());\n\t    report_mixed_assignment_conflict_(\"variable\");\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      if (packed_base == 0) {\n\t    NetExpr *base = new NetEConst(verinum(off));\n\t    if (member_type)\n\t\t  lv->set_part(base, member_type);\n\t    else\n\t\t  lv->set_part(base, use_width);\n\t    return true;\n      }\n\n\t// Oops, packed_base is not fully evaluated, so I don't know\n\t// yet what to do with it.\n      cerr << get_fileline() << \": internal error: \"\n\t   << \"I don't know how to handle this index expression? \" << *packed_base << endl;\n      ivl_assert(*this, 0);\n      return false;\n}\n\nNetAssign_* PENumber::elaborate_lval(Design*des, NetScope*, bool, bool, bool) const\n{\n      cerr << get_fileline() << \": error: Constant values not allowed \"\n\t   << \"in l-value expressions.\" << endl;\n      des->errors += 1;\n      return 0;\n}\n"
        },
        {
          "name": "elab_net.cc",
          "type": "blob",
          "size": 37.8603515625,
          "content": "/*\n * Copyright (c) 1999-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2012 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"PExpr.h\"\n# include  \"PPackage.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"netstruct.h\"\n# include  \"netvector.h\"\n# include  \"compiler.h\"\n\n# include  <cstdlib>\n# include  <cstring>\n# include  <iostream>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * The concatenation is also OK an an l-value. This method elaborates\n * it as a structural l-value. The return values is the *input* net of\n * the l-value, which may feed via part selects to the final\n * destination. The caller can connect gate outputs to this signal to\n * make the l-value connections.\n */\nNetNet* PEConcat::elaborate_lnet_common_(Design*des, NetScope*scope,\n\t\t\t\t\t bool bidirectional_flag) const\n{\n      ivl_assert(*this, scope);\n\n      std::vector<NetNet*> nets(parms_.size());\n      unsigned width = 0;\n      unsigned errors = 0;\n\n      if (repeat_) {\n\t    cerr << repeat_->get_fileline() << \": error: \"\n\t         << \"repeat concatenations are not allowed in net l-values.\"\n\t         << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t/* Elaborate the operands of the concatenation. */\n      for (unsigned idx = 0 ;  idx < nets.size() ;  idx += 1) {\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: Elaborate subexpression \"\n\t\t       << idx << \" of \" << nets.size() << \" l-values: \"\n\t\t       << *parms_[idx] << endl;\n\t    }\n\n\t    if (parms_[idx] == 0) {\n\t\t  cerr << get_fileline() << \": error: Empty expressions \"\n\t\t       << \"not allowed in concatenations.\" << endl;\n\t\t  errors += 1;\n\t\t  continue;\n\t    }\n\n\t    if (bidirectional_flag) {\n\t\t  nets[idx] = parms_[idx]->elaborate_bi_net(des, scope);\n\t    } else {\n\t\t  nets[idx] = parms_[idx]->elaborate_lnet(des, scope);\n\t    }\n\n\t    if (nets[idx] == 0) {\n                  errors += 1;\n            } else if (nets[idx]->data_type() == IVL_VT_REAL) {\n\t\t  cerr << parms_[idx]->get_fileline() << \": error: \"\n\t\t       << \"concatenation operand can no be real: \"\n\t\t       << *parms_[idx] << endl;\n\t\t  errors += 1;\n\t\t  continue;\n\t    } else {\n                  width += nets[idx]->vector_width();\n            }\n      }\n\n      if (errors) {\n\t    des->errors += errors;\n\t    return 0;\n      }\n\n\t/* Make the temporary signal that connects to all the\n\t   operands, and connect it up. Scan the operands of the\n\t   concat operator from most significant to least significant,\n\t   which is the order they are given in the concat list. */\n\n      netvector_t*tmp2_vec = new netvector_t(nets[0]->data_type(),width-1,0);\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, tmp2_vec);\n\n\t/* Assume that the data types of the nets are all the same, so\n\t   we can take the data type of any, the first will do. */\n      osig->local_flag(true);\n      osig->set_line(*this);\n\n      if (bidirectional_flag) {\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: Generating tran(VP) \"\n\t\t       << \"to connect input l-value to subexpressions.\"\n\t\t       << endl;\n\t    }\n\n\t    for (unsigned idx = 0 ; idx < nets.size() ; idx += 1) {\n\t\t  unsigned wid = nets[idx]->vector_width();\n\t\t  unsigned off = width - wid;\n\t\t  NetTran*ps = new NetTran(scope, scope->local_symbol(),\n\t\t\t\t\t   osig->vector_width(), wid, off);\n\t\t  des->add_node(ps);\n\t\t  ps->set_line(*this);\n\n\t\t  connect(ps->pin(0), osig->pin(0));\n\t\t  connect(ps->pin(1), nets[idx]->pin(0));\n\n\t\t  ivl_assert(*this, wid <= width);\n\t\t  width -= wid;\n\t    }\n\n      } else {\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: Generating part selects \"\n\t\t       << \"to connect input l-value to subexpressions.\"\n\t\t       << endl;\n\t    }\n\n\t    NetPartSelect::dir_t part_dir = NetPartSelect::VP;\n\n\t    for (unsigned idx = 0 ;  idx < nets.size() ;  idx += 1) {\n\t\t  unsigned wid = nets[idx]->vector_width();\n\t\t  unsigned off = width - wid;\n\t\t  NetPartSelect*ps = new NetPartSelect(osig, off, wid, part_dir);\n\t\t  des->add_node(ps);\n\t\t  ps->set_line(*this);\n\n\t\t  connect(ps->pin(1), osig->pin(0));\n\t\t  connect(ps->pin(0), nets[idx]->pin(0));\n\n\t\t  ivl_assert(*this, wid <= width);\n\t\t  width -= wid;\n\t    }\n\t    ivl_assert(*this, width == 0);\n      }\n\n      return osig;\n}\n\nNetNet* PEConcat::elaborate_lnet(Design*des, NetScope*scope) const\n{\n      return elaborate_lnet_common_(des, scope, false);\n}\n\nNetNet* PEConcat::elaborate_bi_net(Design*des, NetScope*scope) const\n{\n      return elaborate_lnet_common_(des, scope, true);\n}\n\nbool PEConcat::is_collapsible_net(Design*des, NetScope*scope,\n                                  NetNet::PortType port_type) const\n{\n      ivl_assert(*this, scope);\n\n        // Repeat concatenations are not currently supported.\n      if (repeat_)\n            return false;\n\n\t// Test the operands of the concatenation.\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\n              // Empty expressions are not allowed in concatenations\n\t    if (parms_[idx] == 0)\n                  return false;\n\n\t    if (!parms_[idx]->is_collapsible_net(des, scope, port_type))\n                  return false;\n      }\n\n      return true;\n}\n\n/*\n * This private method evaluates the part selects (if any) for the\n * signal. The sig argument is the NetNet already located for the\n * PEIdent name. The midx and lidx arguments are loaded with the\n * results, which may be the whole vector, or a single bit, or\n * anything in between. The values are in canonical indices.\n */\nbool PEIdent::eval_part_select_(Design*des, NetScope*scope, NetNet*sig,\n\t\t\t\tlong&midx, long&lidx) const\n{\n      list<long> prefix_indices;\n      bool rc = calculate_packed_indices_(des, scope, sig, prefix_indices);\n      ivl_assert(*this, rc);\n\n      const name_component_t&name_tail = path_.back();\n\t// Only treat as part/bit selects any index that is beyond the\n\t// word selects for an array. This is not an array, then\n\t// dimensions==0 and any index is treated as a select.\n      if (name_tail.index.size() <= sig->unpacked_dimensions()) {\n\t    midx = sig->vector_width()-1;\n\t    lidx = 0;\n\t    return true;\n      }\n\n      ivl_assert(*this, !name_tail.index.empty());\n\n      const index_component_t&index_tail = name_tail.index.back();\n\n      switch (index_tail.sel) {\n\t  default:\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Unexpected sel_ value = \" << index_tail.sel << endl;\n\t    ivl_assert(*this, 0);\n\t    break;\n\n\t  case index_component_t::SEL_IDX_DO:\n\t  case index_component_t::SEL_IDX_UP: {\n\t\tNetExpr*tmp_ex = elab_and_eval(des, scope, index_tail.msb, -1, true);\n\t\tNetEConst*tmp = dynamic_cast<NetEConst*>(tmp_ex);\n\t\tif (!tmp) {\n\t\t      cerr << get_fileline() << \": error: Indexed part select \"\n\t\t              \"base expression must be a constant integral value \"\n\t\t\t      \"in this context.\" << endl;\n\t\t      cerr << get_fileline() << \":      : This expression \"\n\t\t\t      \"violates that rule: \" << *index_tail.msb << endl;\n\t\t      des->errors += 1;\n\t\t      return 0;\n\t\t}\n\n\t\t  /* The width (a constant) is calculated here. */\n\t\tunsigned long wid = 0;\n\t\tbool flag = calculate_up_do_width_(des, scope, wid);\n\t\tif (! flag) return false;\n\n\t\t  /* We have an undefined index and that is out of range. */\n\t\tif (! tmp->value().is_defined()) {\n\t\t      delete tmp_ex;\n\t\t      if (warn_ob_select) {\n\t\t\t    cerr << get_fileline() << \": warning: \"\n\t\t\t         << sig->name();\n\t\t\t    if (sig->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t    cerr << \"['bx\";\n\t\t\t    if (index_tail.sel ==\n\t\t\t        index_component_t::SEL_IDX_UP) {\n\t\t\t\t  cerr << \"+:\";\n\t\t\t    } else {\n\t\t\t\t  cerr << \"-:\";\n\t\t\t    }\n\t\t\t    cerr << wid << \"] is always outside the vector.\"\n\t\t\t         << endl;\n\t\t      }\n\t\t      return false;\n\t\t}\n\n\t\tlong midx_val = tmp->value().as_long();\n\n\t\t  // Check whether an unsigned base fits in a 32 bit int.\n\t\t  // This ensures correct results for the vlog95 target, and\n\t\t  // for the vvp target on LLP64 platforms (Microsoft Windows).\n\t\tif (!tmp->has_sign() && (int32_t)midx_val < 0) {\n\t\t        // The base is wrapped around.\n\t\t      delete tmp_ex;\n\t\t      if (warn_ob_select) {\n\t\t\t    cerr << get_fileline() << \": warning: \" << sig->name();\n\t\t\t    cerr << \"[\" << (unsigned long)midx_val\n\t\t\t\t << (index_tail.sel == index_component_t::SEL_IDX_UP ? \"+:\" : \"-:\")\n\t\t\t\t << wid << \"] is always outside vector.\" << endl;\n\t\t      }\n\t\t      return false;\n\t\t}\n\n\t\tdelete tmp_ex;\n\n\t\tif (prefix_indices.size()+1 < sig->packed_dims().size()) {\n\t\t\t// Here we are selecting one or more sub-arrays.\n\t\t\t// Make this work by finding the indexed sub-arrays and\n\t\t\t// creating a generated slice that spans the whole range.\n\t\t      long loff, moff;\n\t\t      unsigned long lwid, mwid;\n\t\t      bool mrc, lrc;\n\t\t      mrc = sig->sb_to_slice(prefix_indices, midx_val, moff, mwid);\n\t\t      if (index_tail.sel == index_component_t::SEL_IDX_UP)\n\t\t\t    lrc = sig->sb_to_slice(prefix_indices, midx_val+wid-1, loff, lwid);\n\t\t      else\n\t\t\t    lrc = sig->sb_to_slice(prefix_indices, midx_val-wid+1, loff, lwid);\n\t\t      if (!mrc || !lrc) {\n\t\t\t    cerr << get_fileline() << \": error: \";\n\t\t\t    cerr << \"Part-select [\" << midx_val;\n\t\t\t    if (index_tail.sel == index_component_t::SEL_IDX_UP) {\n\t\t\t\t  cerr << \"+:\";\n\t\t\t    } else {\n\t\t\t\t  cerr << \"-:\";\n\t\t\t    }\n\t\t\t    cerr << wid << \"] exceeds the declared bounds for \";\n\t\t\t    cerr << sig->name();\n\t\t\t    if (sig->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t    cerr << \".\" << endl;\n\t\t\t    des->errors += 1;\n\t\t\t    return 0;\n\t\t      }\n\t\t      ivl_assert(*this, lwid == mwid);\n\n\t\t      if (moff > loff) {\n\t\t\t    lidx = loff;\n\t\t\t    midx = moff + mwid - 1;\n\t\t      } else {\n\t\t\t    lidx = moff;\n\t\t\t    midx = loff + lwid - 1;\n\t\t      }\n\t\t} else {\n\t\t      midx = sig->sb_to_idx(prefix_indices, midx_val);\n\n\t\t      if (index_tail.sel == index_component_t::SEL_IDX_UP)\n\t\t\t    lidx = sig->sb_to_idx(prefix_indices, midx_val+wid-1);\n\t\t      else\n\t\t\t    lidx = sig->sb_to_idx(prefix_indices, midx_val-wid+1);\n\n\t\t      if (midx < lidx) {\n\t\t\t    long tmpx = midx;\n\t\t\t    midx = lidx;\n\t\t\t    lidx = tmpx;\n\t\t      }\n\n\t\t\t/* Warn about an indexed part select that is out of range. */\n\t\t      if (warn_ob_select && (lidx < 0)) {\n\t\t\t    cerr << get_fileline() << \": warning: \" << sig->name();\n\t\t\t    if (sig->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t    cerr << \"[\" << midx_val;\n\t\t\t    if (index_tail.sel == index_component_t::SEL_IDX_UP) {\n\t\t\t\t  cerr << \"+:\";\n\t\t\t    } else {\n\t\t\t\t  cerr << \"-:\";\n\t\t\t    }\n\t\t\t    cerr << wid << \"] is selecting before vector.\" << endl;\n\t\t      }\n\t\t      if (warn_ob_select && (midx >= (long)sig->vector_width())) {\n\t\t\t    cerr << get_fileline() << \": warning: \" << sig->name();\n\t\t\t    if (sig->unpacked_dimensions() > 0) {\n\t\t\t\t  cerr << \"[]\";\n\t\t\t    }\n\t\t\t    cerr << \"[\" << midx_val;\n\t\t\t    if (index_tail.sel == index_component_t::SEL_IDX_UP) {\n\t\t\t\t  cerr << \"+:\";\n\t\t\t    } else {\n\t\t\t\t  cerr << \"-:\";\n\t\t\t    }\n\t\t\t    cerr << wid << \"] is selecting after vector.\" << endl;\n\t\t      }\n\n\t\t\t/* This is completely out side the signal so just skip it. */\n\t\t      if (lidx >= (long)sig->vector_width() || midx < 0) {\n\t\t\t    return false;\n\t\t      }\n\t\t}\n\n\t\tbreak;\n\t  }\n\n\t  case index_component_t::SEL_PART: {\n\n\t\tlong msb, lsb;\n\t\tbool part_defined_flag;\n\t\t/* bool flag = */ calculate_parts_(des, scope, msb, lsb, part_defined_flag);\n\n\t\t  /* We have an undefined index and that is out of range. */\n\t\tif (!part_defined_flag) {\n\t\t      if (warn_ob_select) {\n\t\t\t    cerr << get_fileline() << \": warning: \"\n\t\t\t         << sig->name();\n\t\t\t    if (sig->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t    cerr << \"['bx] is always outside the vector.\"\n\t\t\t         << endl;\n\t\t      }\n\t\t      return false;\n\t\t}\n\n\t\tif (prefix_indices.size()+1 < sig->packed_dims().size()) {\n\t\t      // Here we have a slice that doesn't have enough indices\n\t\t      // to get to a single slice. For example:\n\t\t      //    wire [9:0][5:1] foo\n\t\t      //      ... foo[4:3] ...\n\t\t      // Make this work by finding the indexed slices and\n\t\t      // creating a generated slice that spans the whole\n\t\t      // range.\n\t\t      unsigned long lwid, mwid;\n\t\t      bool lrc, mrc;\n\t\t      lrc = sig->sb_to_slice(prefix_indices, lsb, lidx, lwid);\n\t\t      mrc = sig->sb_to_slice(prefix_indices, msb, midx, mwid);\n\t\t      if (!mrc || !lrc) {\n\t\t\t    cerr << get_fileline() << \": error: \";\n\t\t\t    cerr << \"Part-select [\" << msb << \":\" << lsb;\n\t\t\t    cerr << \"] exceeds the declared bounds for \";\n\t\t\t    cerr << sig->name();\n\t\t\t    if (sig->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t    cerr << \".\" << endl;\n\t\t\t    des->errors += 1;\n\t\t\t    return 0;\n\t\t      }\n\t\t      ivl_assert(*this, lwid == mwid);\n\t\t      midx += mwid - 1;\n\t\t} else {\n\t\t      lidx = sig->sb_to_idx(prefix_indices, lsb);\n\t\t      midx = sig->sb_to_idx(prefix_indices, msb);\n\t        }\n\n\t\t  /* Detect reversed indices of a part select. */\n\t\tif (lidx > midx) {\n\t\t      cerr << get_fileline() << \": error: Part select \"\n\t\t\t  << sig->name() << \"[\" << msb << \":\"\n\t\t\t  << lsb << \"] indices reversed.\" << endl;\n\t\t      cerr << get_fileline() << \":      : Did you mean \"\n\t\t\t  << sig->name() << \"[\" << lsb << \":\"\n\t\t\t  << msb << \"]?\" << endl;\n\t\t      des->errors += 1;\n\n\t\t      std::swap(lidx, midx);\n\t\t}\n\n\t\t  /* Warn about a part select that is out of range. */\n\t\tif (midx >= (long)sig->vector_width() || lidx < 0) {\n\t\t      cerr << get_fileline() << \": warning: Part select \"\n\t\t\t   << sig->name();\n\t\t      if (sig->unpacked_dimensions() > 0) {\n\t\t\t  cerr << \"[]\";\n\t\t      }\n\t\t      cerr << \"[\" << msb << \":\" << lsb\n\t\t\t   << \"] is out of range.\" << endl;\n\t\t}\n\n\t\t  /* This is completely out side the signal so just skip it. */\n\t\tif (lidx >= (long)sig->vector_width() || midx < 0) {\n\t\t      return false;\n\t\t}\n\t\tbreak;\n\t  }\n\n\t  case index_component_t::SEL_BIT:\n\t    if (name_tail.index.size() > sig->unpacked_dimensions()) {\n\t\t  long msb;\n\t\t  bool bit_defined_flag;\n\t\t  /* bool flag = */ calculate_bits_(des, scope, msb, bit_defined_flag);\n\n\t\t  /* We have an undefined index and that is out of range. */\n\t\t  if (!bit_defined_flag) {\n\t\t\tif (warn_ob_select) {\n\t\t\t      cerr << get_fileline() << \": warning: \"\n\t\t\t           << sig->name();\n\t\t\t      if (sig->unpacked_dimensions() > 0) cerr << \"[]\";\n\t\t\t      cerr << \"['bx] is always outside the vector.\"\n\t\t\t           << endl;\n\t\t\t}\n\t\t\treturn false;\n\t\t  }\n\n\n\t\t  if (prefix_indices.size()+2 <= sig->packed_dims().size()) {\n\t\t\tlong tmp_loff;\n\t\t\tunsigned long tmp_lwid;\n\t\t\tbool rcl = sig->sb_to_slice(prefix_indices, msb,\n\t\t\t\t\t\t    tmp_loff, tmp_lwid);\n                        if(rcl) {\n                          midx = tmp_loff + tmp_lwid - 1;\n                          lidx = tmp_loff;\n                        } else {\n                          cerr << get_fileline() << \": error: Index \" << sig->name()\n                               << \"[\" << msb << \"] is out of range.\"\n                               << endl;\n                          des->errors += 1;\n                          midx = 0;\n                          lidx = 0;\n                        }\n\t\t  } else {\n\t\t\tmidx = sig->sb_to_idx(prefix_indices, msb);\n\t\t\tif (midx >= (long)sig->vector_width()) {\n\t\t\t      cerr << get_fileline() << \": error: Index \" << sig->name()\n\t\t\t\t   << \"[\" << msb << \"] is out of range.\"\n\t\t\t\t   << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      midx = 0;\n\t\t\t}\n\t\t\tlidx = midx;\n\t\t  }\n\n\t    } else {\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"Bit select \" << path_ << endl;\n\t\t  ivl_assert(*this, 0);\n\t\t  midx = sig->vector_width() - 1;\n\t\t  lidx = 0;\n\t    }\n\t    break;\n      }\n\n      return true;\n}\n\n/*\n * This is the common code for l-value nets and bi-directional\n * nets. There is very little that is different between the two cases,\n * so most of the work for both is done here.\n */\nNetNet* PEIdent::elaborate_lnet_common_(Design*des, NetScope*scope,\n\t\t\t\t\tbool bidirectional_flag) const\n{\n      ivl_assert(*this, scope);\n\n      symbol_search_results sr;\n      symbol_search(this, des, scope, path_.name, lexical_pos_, &sr);\n\n      if (sr.eve != 0) {\n\t    cerr << get_fileline() << \": error: named events (\" << path_\n\t\t << \") cannot be l-values in continuous \"\n\t\t << \"assignments.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetNet*sig = sr.net;\n      pform_name_t base_path = sr.path_head;\n      pform_name_t member_path = sr.path_tail;\n\n      if (sig == 0) {\n\t    cerr << get_fileline() << \": error: Net \" << path_\n\t\t << \" is not defined in this context.\" << endl;\n\t    if (sr.decl_after_use) {\n\t\t  cerr << sr.decl_after_use->get_fileline() << \":      : \"\n\t\t\t  \"A symbol with that name was declared here. \"\n\t\t\t  \"Check for declaration after use.\" << endl;\n\t    }\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Found l-value path_=\" << path_\n\t\t << \" as sig=\" << sig->name()\n\t\t << \" base_path=\" << base_path\n\t\t << \" member_path=\" << member_path\n\t\t << \" unpacked_dimensions()=\" << sig->unpacked_dimensions()\n\t\t << endl;\n      }\n\n      if (sig->get_const()) {\n\t    cerr << get_fileline() << \": error: Continuous assignment to const\"\n\t         << \" signal `\" << sig->name() << \"` is not allowed.\" << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n      // If this is SystemVerilog and the variable is not yet\n      // assigned by anything, then convert it to an unresolved\n      // wire.\n      if (gn_var_can_be_uwire()\n\t  && (sig->type() == NetNet::REG)\n\t  && (sig->peek_lref() == 0) ) {\n\t    sig->type(NetNet::UNRESOLVED_WIRE);\n      }\n\n      // Don't allow registers as assign l-values.\n      if (sig->type() == NetNet::REG) {\n\t    cerr << get_fileline() << \": error: reg \" << sig->name()\n\t\t << \"; cannot be driven by primitives\"\n\t\t << \" or continuous assignment.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      // Some parts below need the tail component. This is a convenient\n      // reference to it.\n      const name_component_t&path_tail = path_.back();\n\n      // Default part select is the entire word.\n      unsigned midx = sig->vector_width()-1, lidx = 0;\n      // The default word select is the first.\n      long widx = 0;\n      // Set this to true if we calculate the word index. This is\n      // used to distinguish between unpacked array assignment and\n      // array word assignment.\n      bool widx_flag = false;\n\n      list<long> unpacked_indices_const;\n\n      // Detect the net is a structure and there was a method path\n      // detected. We have already broken the path_ into the path to\n      // the net, and the path of member names. For example, if the\n      // path_ is a.b.x.y, we have determined that a.b is a reference\n      // to the net, and that x.y are the member_path. So in this case\n      // we handle the member_path.\n      const netstruct_t*struct_type = 0;\n      if ((struct_type = sig->struct_type()) && !member_path.empty()) {\n\n\t    if (debug_elaborate) {\n\t          cerr << get_fileline() << \": PEIdent::elaborate_lnet_common_: \"\n\t\t       << \"Signal \" << sig->name() << \" is a structure, \"\n\t\t       << \"try to match member path \" << member_path << endl;\n\t    }\n\n\t    unsigned long member_off = 0;\n\t    unsigned long member_width = sig->vector_width();\n\n\t    // Might be an array of structs, like a.b[N].x.y. (A packed\n\t    // array.) Handle that here by taking a part select that\n\t    // reflects the array index.\n\t    if (sig->packed_dimensions() > 1) {\n\t\t  list<index_component_t>tmp_index = base_path.back().index;\n\t\t  index_component_t member_select;\n\t\t  member_select.sel = index_component_t::SEL_BIT;\n\t\t  member_select.msb = new PENumber(new verinum(member_off));\n\t\t  tmp_index.push_back(member_select);\n\t\t  NetExpr*packed_base = collapse_array_indices(des, scope, sig, tmp_index);\n\t\t  if (debug_elaborate) {\n\t\t        cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t\t     << \"packed_base=\" << *packed_base\n\t\t\t     << endl;\n\t\t  }\n\n\t\t  long tmp;\n\t\t  if (packed_base && eval_as_long(tmp, packed_base)) {\n\t\t        member_off = tmp;\n\t\t\tmember_width = struct_type->packed_width();\n\t\t\tdelete packed_base;\n\t\t\tpacked_base = 0;\n\t\t  }\n\n\t\t  // Only support constant dimensions here.\n\t\t  ivl_assert(*this, packed_base == 0);\n\t    }\n\n\t    // Now run through the member names, possibly nested, to take\n\t    // further part selects reflected by the member name. So for\n\t    // example, (.x.y) member x has an offset and width within the\n\t    // containing vector, and member y an offset and width within\n\t    // that.\n\t    pform_name_t use_path = member_path;\n\n\t    while (! use_path.empty()) {\n\t          const name_component_t member_comp = use_path.front();\n\t          const perm_string&member_name = member_comp.name;\n\n\t\t  unsigned long tmp_off;\n\n\t\t  const struct netstruct_t::member_t*member = struct_type->packed_member(member_name, tmp_off);\n\n                  if(!member) {\n                    cerr << get_fileline() << \": error: missing element \" << path() << endl;\n\t\t    des->errors += 1;\n\t\t    return 0;\n                  }\n\n\t\t  member_off += tmp_off;\n\t\t  member_width = member->net_type->packed_width();\n\n\t\t  if (const netstruct_t*tmp_struct = dynamic_cast<const netstruct_t*> (member->net_type)) {\n\t\t        struct_type = tmp_struct;\n\t\t  } else {\n\t\t        struct_type = 0;\n\t\t  }\n\n\t\t  use_path.pop_front();\n\t    }\n\n\t    // Look for part selects on the final member. For example if\n\t    // the path is a.b.x.y[3:0], the end of the member_path will\n\t    // have an index that needs to be handled.\n\t    // For now, assume there is unly a single part/bit select, and\n\t    // assume it's constant.\n\t    if (member_path.back().index.size() > 0) {\n\t\t  list<index_component_t>tmp_index = member_path.back().index;\n\t\t  if (debug_elaborate) {\n\t\t        cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t\t     << \"Process trailing bit/part select. \"\n\t\t\t     << \"index.size()=\" << tmp_index.size()\n\t\t\t     << endl;\n\t\t  }\n\t\t  ivl_assert(*this, tmp_index.size() == 1);\n\t\t  const index_component_t&tail_sel = tmp_index.back();\n\t\t  ivl_assert(*this, tail_sel.sel == index_component_t::SEL_PART || tail_sel.sel == index_component_t::SEL_BIT);\n\t\t  long tmp_off;\n\t\t  unsigned long tmp_wid;\n\t\t  bool rc = calculate_part(this, des, scope, tail_sel, tmp_off, tmp_wid);\n\t\t  ivl_assert(*this, rc);\n\t\t  member_off += tmp_off;\n\t\t  member_width = tmp_wid;\n\t    }\n\n\t    if (debug_elaborate) {\n\t          cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"Final, calculated member \" << member_path\n\t\t       << \" offset=\" << member_off\n\t\t       << \" width=\" << member_width\n\t\t       << endl;\n\t    }\n\n\t    // Rewrite a member select of a packed structure as a\n\t    // part select of the base variable.\n\t    lidx = member_off;\n\t    midx = lidx + member_width - 1;\n\n\t    // Elaborate an expression from the packed indices and\n\t    // the member offset (into the structure) to get a\n\t    // canonical expression into the packed signal vector.\n\t    if (sig->packed_dimensions() > 1) {\n\t\t  list<index_component_t>tmp_index = base_path.back().index;\n\t\t  index_component_t member_select;\n\t\t  member_select.sel = index_component_t::SEL_BIT;\n\t\t  member_select.msb = new PENumber(new verinum(member_off));\n\t\t  tmp_index.push_back(member_select);\n\t\t  NetExpr*packed_base = collapse_array_indices(des, scope, sig, tmp_index);\n\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PEIdent::elaborate_lnet_common_: \"\n\t\t\t     << \"packed_base=\" << *packed_base\n\t\t\t     << \", member_off=\" << member_off << endl;\n\t\t  }\n\t    }\n\n      } else if (gn_system_verilog() && sig->unpacked_dimensions() > 0 && path_tail.index.empty()) {\n\n\t      // In this case, we are doing a continuous assignment to\n\t      // an unpacked array. The NetNet representation is a\n\t      // NetNet with a pin for each array element, so there is\n\t      // nothing more needed here.\n\t      //\n\t      // This can come up from code like this:\n\t      //   logic [...] data [0:3];\n\t      //   assign data = ...;\n\t      // In this case, \"sig\" is \"data\", and sig->pin_count()\n\t      // is 4 to account for the unpacked size.\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_lnet_common_: \"\n\t\t       << \"Net assign to unpacked array \\\"\" << sig->name()\n\t\t       << \"\\\" with \" << sig->pin_count() << \" elements.\" << endl;\n\t    }\n\n      } else if (sig->unpacked_dimensions() > 0) {\n\n\t      // Make sure there are enough indices to address an array element.\n\t    if (path_tail.index.size() < sig->unpacked_dimensions()) {\n\t\t  cerr << get_fileline() << \": error: Array \" << path()\n\t\t       << \" needs \" << sig->unpacked_dimensions() << \" indices,\"\n\t\t       << \" but got only \" << path_tail.index.size() << \". (net)\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t      // Evaluate all the index expressions into an\n\t      // \"unpacked_indices\" array.\n\t    list<NetExpr*>unpacked_indices;\n\t    indices_flags flags;\n\t    indices_to_expressions(des, scope, this,\n\t\t\t\t   path_tail.index, sig->unpacked_dimensions(),\n\t\t\t\t   true,\n\t\t\t\t   flags,\n\t\t\t\t   unpacked_indices,\n\t\t\t\t   unpacked_indices_const);\n\n\t    if (flags.invalid) {\n\t\t  return 0;\n\n\t    } else if (flags.variable) {\n\t\t  cerr << get_fileline() << \": error: array '\" << sig->name()\n\t\t       << \"' index must be a constant in this context.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\n\t    } else if (flags.undefined) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t       << \"ignoring undefined l-value array access \"\n\t\t       << sig->name() << as_indices(unpacked_indices)\n\t\t       << \".\" << endl;\n\t\t  widx = -1;\n\t\t  widx_flag = true;\n\n\t    } else {\n\t\t  NetExpr*canon_index = 0;\n\t\t  ivl_assert(*this, unpacked_indices_const.size() == sig->unpacked_dimensions());\n\t\t  canon_index = normalize_variable_unpacked(sig, unpacked_indices_const);\n\n\t\t  if (canon_index == 0) {\n\t\t\tcerr << get_fileline() << \": warning: \"\n\t\t\t     << \"ignoring out of bounds l-value array access \"\n\t\t\t     << sig->name() << as_indices(unpacked_indices_const)\n\t\t\t     << \".\" << endl;\n\t\t\twidx = -1;\n\t\t\twidx_flag = true;\n\n\t\t  } else {\n\t\t\tNetEConst*canon_const = dynamic_cast<NetEConst*>(canon_index);\n\t\t\tivl_assert(*this, canon_const);\n\n\t\t\twidx = canon_const->value().as_long();\n\t\t\twidx_flag = true;\n\t\t\tdelete canon_index;\n\t\t  }\n\t    }\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: Use [\" << widx << \"]\"\n\t\t       << \" to index l-value array.\" << endl;\n\n\t      /* The array has a part/bit select at the end. */\n\t    if (path_tail.index.size() > sig->unpacked_dimensions()) {\n\t\t  if (sig->get_scalar()) {\n\t\t        cerr << get_fileline() << \": error: \"\n\t\t             << \"can not select part of \";\n\t\t\tif (sig->data_type() == IVL_VT_REAL) cerr << \"real\";\n\t\t\telse cerr << \"scalar\";\n\t\t\tcerr << \" array word: \" << sig->name()\n\t\t\t     << as_indices(unpacked_indices_const) << endl;\n\t\t        des->errors += 1;\n\t\t        return 0;\n\t\t  }\n\n\t\t  long midx_tmp, lidx_tmp;\n\t\t  if (! eval_part_select_(des, scope, sig, midx_tmp, lidx_tmp))\n\t\t        return 0;\n\n\t\t  if (lidx_tmp < 0) {\n\t\t        cerr << get_fileline() << \": sorry: part selects \"\n\t\t                \"straddling the start of signal (\" << path_\n\t\t             << \") are not currently supported.\" << endl;\n\t\t        des->errors += 1;\n\t\t        return 0;\n\t\t  }\n\t\t  midx = midx_tmp;\n\t\t  lidx = lidx_tmp;\n\t    }\n\n      } else if (!path_tail.index.empty()) {\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_lnet_common_: \"\n\t\t       << \"path_tail.index.size()=\" << path_tail.index.size()\n\t\t       << endl;\n\t    }\n\n\t      // There are index expressions on the name, so this is a\n\t      // bit/slice select of the name. Calculate a canonical\n\t      // part select.\n\n\t    if (sig->get_scalar()) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"can not select part of \";\n\t\t  if (sig->data_type() == IVL_VT_REAL) cerr << \"real: \";\n\t\t  else cerr << \"scalar: \";\n\t\t  cerr << sig->name() << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    long midx_tmp, lidx_tmp;\n\t    if (! eval_part_select_(des, scope, sig, midx_tmp, lidx_tmp))\n\t\t  return 0;\n\n\t    if (lidx_tmp < 0) {\n\t\t  cerr << get_fileline() << \": sorry: part selects \"\n\t\t          \"straddling the start of signal (\" << path_\n                       << \") are not currently supported.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    midx = midx_tmp;\n\t    lidx = lidx_tmp;\n      }\n\n      unsigned subnet_wid = midx-lidx+1;\n\n\t/* Check if the l-value bits are double-driven. */\n\n      if (sig->type() == NetNet::UNRESOLVED_WIRE) {\n\t    ivl_assert(*this, widx_flag || (widx == 0));\n\t    long wcount = widx_flag ? 1 : sig->pin_count();\n\t    for (long idx = 0; idx < wcount; idx += 1) {\n\t\t  if (sig->test_and_set_part_driver(midx, lidx, widx + idx)) {\n\t\t\tcerr << get_fileline() << \": error: \";\n\t\t\tif (sig->coerced_to_uwire())\n\t\t\t      cerr << \"Variable '\";\n\t\t\telse\n\t\t\t      cerr << \"Unresolved wire '\";\n\t\t\tcerr << sig->name() << \"' cannot have multiple drivers.\" << endl;\n\t\t\tif (debug_elaborate) {\n\t\t\t      cerr << get_fileline() << \":\t: Overlap in \"\n\t\t\t\t   << \"[\" << midx << \":\" << lidx << \"] (canonical)\"\n\t\t\t\t   << \", widx=\" << (widx_flag? widx : 0)\n\t\t\t\t   << \", vector width=\" << sig->vector_width()\n\t\t\t\t   << endl;\n\t\t\t}\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  }\n\t    }\n      }\n\n      if (sig->pin_count() > 1 && widx_flag) {\n\t    if (widx < 0 || widx >= (long) sig->pin_count())\n\t\t  return 0;\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    sig->type(), sig->net_type());\n\t    tmp->set_line(*this);\n\t    tmp->local_flag(true);\n\t    connect(sig->pin(widx), tmp->pin(0));\n\t    sig = tmp;\n\n      } else if (sig->pin_count() > 1) {\n\n\t      // If this turns out to be an l-value unpacked array,\n\t      // then let the caller handle it. It will probably be\n\t      // converted into an array of assignments.\n\t    return sig;\n      }\n\n\t/* If the desired l-value vector is narrower than the\n\t   signal itself, then use a NetPartSelect node to\n\t   arrange for connection to the desired bits. All this\n\t   can be skipped if the desired width matches the\n\t   original vector. */\n\n      if (subnet_wid != sig->vector_width()) {\n\t      /* If we are processing a tran or inout, then the\n\t\t partselect is bi-directional. Otherwise, it is a\n\t\t Part-to-Vector select. */\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Elaborate lnet part select \"\n\t\t       << sig->name()\n\t\t       << \"[base=\" << lidx\n\t\t       << \" wid=\" << subnet_wid <<\"]\"\n\t\t       << endl;\n\n\t    netvector_t*tmp2_vec = new netvector_t(sig->data_type(),\n\t\t\t\t\t\t   subnet_wid-1,0);\n\t    NetNet*subsig = new NetNet(sig->scope(),\n\t\t\t\t       sig->scope()->local_symbol(),\n\t\t\t\t       NetNet::WIRE, tmp2_vec);\n\t    subsig->local_flag(true);\n\t    subsig->set_line(*this);\n\n\t    if (bidirectional_flag) {\n\t\t    // Make a tran(VP)\n\t\t  NetTran*sub = new NetTran(scope, scope->local_symbol(),\n\t\t\t\t\t    sig->vector_width(),\n\t\t\t\t\t    subnet_wid, lidx);\n\t\t  sub->set_line(*this);\n\t\t  des->add_node(sub);\n\t\t  connect(sub->pin(0), sig->pin(0));\n\t\t  connect(sub->pin(1), subsig->pin(0));\n\n\t    } else {\n\t\t  NetPartSelect*sub = new NetPartSelect(sig, lidx, subnet_wid,\n\t\t\t\t\t\t\tNetPartSelect::PV);\n\t\t  des->add_node(sub);\n\t\t  sub->set_line(*this);\n\t\t  connect(sub->pin(0), subsig->pin(0));\n\t\t  collapse_partselect_pv_to_concat(des, sig);\n\t    }\n\t    sig = subsig;\n      }\n\n      return sig;\n}\n\n/*\n * Identifiers in continuous assignment l-values are limited to wires\n * and that ilk. Detect registers and memories here and report errors.\n */\nNetNet* PEIdent::elaborate_lnet(Design*des, NetScope*scope) const\n{\n      return elaborate_lnet_common_(des, scope, false);\n}\n\nNetNet* PEIdent::elaborate_bi_net(Design*des, NetScope*scope) const\n{\n      return elaborate_lnet_common_(des, scope, true);\n}\n\n/*\n * This method is used to elaborate identifiers that are ports to a\n * scope. The scope is presumed to be that of the module that has the\n * port. This elaboration is done inside the module, and is only done\n * to PEIdent objects. This method is used by elaboration of a module\n * instantiation (PGModule::elaborate_mod_) to get NetNet objects for\n * the port.\n */\nNetNet* PEIdent::elaborate_subport(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope->type() == NetScope::MODULE);\n      NetNet*sig = des->find_signal(scope, path_.name);\n      if (sig == 0) {\n\t    cerr << get_fileline() << \": error: no wire/reg \" << path_\n\t\t << \" in module \" << scope_path(scope) << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t/* Check the port_type of the signal to make sure it is really\n\t   a port, and its direction is resolved. */\n      switch (sig->port_type()) {\n\t  case NetNet::PINPUT:\n\t  case NetNet::POUTPUT:\n\t  case NetNet::PINOUT:\n\t  case NetNet::PREF:\n\t    break;\n\n\t      /* If the name matches, but the signal is not a port,\n\t\t then the user declared the object but there is no\n\t\t matching input/output/inout declaration. */\n\n\t  case NetNet::NOT_A_PORT:\n\t    cerr << get_fileline() << \": error: signal \" << path_ << \" in\"\n\t\t << \" module \" << scope_path(scope) << \" is not a port.\" << endl;\n\t    cerr << get_fileline() << \":      : Are you missing an input/\"\n\t\t << \"output/inout declaration?\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n\n\t      /* This should not happen. A PWire can only become\n\t\t PIMPLICIT if this is a UDP reg port, and the make_udp\n\t\t function should turn it into an output.... I think. */\n\n\t  case NetNet::PIMPLICIT:\n\t    cerr << get_fileline() << \": internal error: signal \" << path_\n\t\t << \" in module \" << scope_path(scope) << \" is left as \"\n\t\t << \"port type PIMPLICIT.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      long midx;\n      long lidx;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PEIdent::elaborate_subport: \"\n\t\t << \"path_ = \\\"\" << path_\n\t\t << \"\\\", unpacked_dimensions=\" << sig->unpacked_dimensions()\n\t\t << \", port_type()=\" << sig->port_type() << endl;\n      }\n\n      if (sig->unpacked_dimensions() && !gn_system_verilog()) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Ports cannot be unpacked arrays. Try enabling SystemVerilog support.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// There cannot be parts to an unpacked array, so process this\n\t// simply as an unpacked array.\n      if (sig->unpacked_dimensions()) {\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PEIdent::elaborate_subport: \"\n\t\t       << \"path_=\\\"\" << path_\n\t\t       << \"\\\" is an unpacked array with \" << sig->pin_count()\n\t\t       << \" elements.\" << endl;\n\t    }\n\t    scope->add_module_port_net(sig);\n\t    return sig;\n      }\n\n\t/* Evaluate the part/bit select expressions, to get the part\n\t   select of the signal that attaches to the port. Also handle\n\t   range and direction checking here. */\n\n      if (! eval_part_select_(des, scope, sig, midx, lidx))\n\t    return 0;\n\n\t/* If this is a part select of the entire signal (or no part\n\t   select at all) then we're done. */\n      if ((lidx == 0) && (midx == (long)sig->vector_width()-1)) {\n\t    scope->add_module_port_net(sig);\n\t    return sig;\n      }\n\n      unsigned swid = abs(midx - lidx) + 1;\n      ivl_assert(*this, swid > 0 && swid < sig->vector_width());\n\n      netvector_t*tmp2_vec = new netvector_t(sig->data_type(),swid-1,0);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t      NetNet::WIRE, tmp2_vec);\n      tmp->port_type(sig->port_type());\n      tmp->set_line(*this);\n      tmp->local_flag(true);\n      NetNode*ps = 0;\n      switch (sig->port_type()) {\n\n\t  case NetNet::PINPUT:\n\t    ps = new NetPartSelect(sig, lidx, swid, NetPartSelect::PV);\n\t    connect(tmp->pin(0), ps->pin(0));\n\t    sig = tmp;\n\t    break;\n\n\t  case NetNet::POUTPUT:\n\t    ps = new NetPartSelect(sig, lidx, swid, NetPartSelect::VP);\n\t    connect(tmp->pin(0), ps->pin(0));\n\t    sig = tmp;\n\t    break;\n\n\t  case NetNet::PREF:\n\t      // For the purposes of module ports, treat ref ports\n\t      // just like inout ports.\n\t  case NetNet::PINOUT:\n\t    ps = new NetTran(scope, scope->local_symbol(), sig->vector_width(),\n\t\t\t     swid, lidx);\n\t    connect(sig->pin(0), ps->pin(0));\n\t    connect(tmp->pin(0), ps->pin(1));\n\t    sig = tmp;\n\t    break;\n\n\t  default:\n\t    ivl_assert(*this, 0);\n\t    break;\n      }\n\n      ps->set_line(*this);\n      des->add_node(ps);\n\n      scope->add_module_port_net(sig);\n      return sig;\n}\n\nNetNet*PEIdent::elaborate_unpacked_net(Design*des, NetScope*scope) const\n{\n      symbol_search_results sr;\n      symbol_search(this, des, scope, path_, lexical_pos_, &sr);\n      if (!sr.net) {\n\t    cerr << get_fileline() << \": error: Net \" << path_\n\t\t << \" is not defined in this context.\" << endl;\n\t    if (sr.decl_after_use) {\n\t\t  cerr << sr.decl_after_use->get_fileline() << \":      : \"\n\t\t\t  \"A symbol with that name was declared here. \"\n\t\t\t  \"Check for declaration after use.\" << endl;\n\t    }\n\t    des->errors += 1;\n\t    return nullptr;\n      }\n\n      const name_component_t&name_tail = path_.back();\n      if (!name_tail.index.empty()) {\n\t    cerr << get_fileline() << \": sorry: Array slices are not yet \"\n\t         << \"supported for continuous assignment.\" << endl;\n\t    des->errors += 1;\n\t    return nullptr;\n      }\n\n      return sr.net;\n}\n\nbool PEIdent::is_collapsible_net(Design*des, NetScope*scope,\n                                 NetNet::PortType port_type) const\n{\n      ivl_assert(*this, scope);\n\n      symbol_search_results sr;\n      symbol_search(this, des, scope, path_.name, lexical_pos_, &sr);\n\n      if (sr.eve != 0)\n            return false;\n\n      NetNet*sig = sr.net;\n\n      if (sig == 0)\n            return false;\n\n      ivl_assert(*this, sig);\n\n\t/* If this is SystemVerilog and the variable is not yet\n\t   assigned by anything, then convert it to an unresolved\n\t   wire. */\n      if (gn_var_can_be_uwire() &&\n          (sig->type() == NetNet::REG) &&\n          (sig->peek_eref() == 0) &&\n          (port_type == NetNet::POUTPUT)) {\n\t    sig->type(NetNet::UNRESOLVED_WIRE);\n      }\n\n      if (sig->type() == NetNet::UNRESOLVED_WIRE && sig->pin(0).is_linked())\n            return false;\n\n      if (sig->type() == NetNet::REG)\n            return false;\n\n      return true;\n}\n"
        },
        {
          "name": "elab_scope.cc",
          "type": "blob",
          "size": 57.8935546875,
          "content": "/*\n * Copyright (c) 2000-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"compiler.h\"\n# include  \"netmisc.h\"\n# include  \"netvector.h\"\n# include  \"netparray.h\"\n# include  <cstring>\n# include  <iostream>\n# include  <cstdlib>\n# include  <cstdio>\n\n/*\n * Elaboration happens in two passes, generally. The first scans the\n * pform to generate the NetScope tree and attach it to the Design\n * object. The methods in this source file implement the elaboration\n * of the scopes.\n */\n\n# include  \"Module.h\"\n# include  \"PClass.h\"\n# include  \"PExpr.h\"\n# include  \"PEvent.h\"\n# include  \"PClass.h\"\n# include  \"PGate.h\"\n# include  \"PGenerate.h\"\n# include  \"PPackage.h\"\n# include  \"PTask.h\"\n# include  \"PWire.h\"\n# include  \"Statement.h\"\n# include  \"AStatement.h\"\n# include  \"netlist.h\"\n# include  \"netclass.h\"\n# include  \"netenum.h\"\n# include  \"netqueue.h\"\n# include  \"parse_api.h\"\n# include  \"util.h\"\n# include  <typeinfo>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nvoid set_scope_timescale(Design*des, NetScope*scope, PScope*pscope)\n{\n      scope->time_unit(pscope->time_unit);\n      scope->time_precision(pscope->time_precision);\n      scope->time_from_timescale(pscope->has_explicit_timescale());\n      des->set_precision(pscope->time_precision);\n}\n\ntypedef map<perm_string,LexicalScope::param_expr_t*>::const_iterator mparm_it_t;\n\nstatic void collect_parm_item(Design*des, NetScope*scope, perm_string name,\n\t\t\t      const LexicalScope::param_expr_t&cur,\n\t\t\t      bool is_annotatable)\n{\n      if (debug_scopes) {\n\t    cerr << cur.get_fileline() << \": \" << __func__  << \": \"\n\t\t << \"parameter \" << name << \" \";\n\t    if (cur.data_type)\n\t\t  cerr << *cur.data_type;\n\t    else\n\t\t  cerr << \"(nil type)\";\n\t    ivl_assert(cur, cur.expr);\n\t    cerr << \" = \" << *cur.expr << \"; \";\n\t    if (cur.range)\n\t\t  cerr << \"with ranges \";\n\t    else\n\t\t  cerr << \"without ranges \";\n\t    cerr << \"; in scope \" << scope_path(scope) << endl;\n      }\n\n      NetScope::range_t*range_list = 0;\n      for (LexicalScope::range_t*range = cur.range ; range ; range = range->next) {\n\t    NetScope::range_t*tmp = new NetScope::range_t;\n\t    tmp->exclude_flag = range->exclude_flag;\n\t    tmp->low_open_flag = range->low_open_flag;\n\t    tmp->high_open_flag = range->high_open_flag;\n\n\t    if (range->low_expr) {\n\t\t  tmp->low_expr = elab_and_eval(des, scope, range->low_expr, -1);\n\t\t  ivl_assert(*range->low_expr, tmp->low_expr);\n\t    } else {\n\t\t  tmp->low_expr = 0;\n\t    }\n\n\t    if (range->high_expr && range->high_expr==range->low_expr) {\n\t\t    // Detect the special case of a \"point\"\n\t\t    // range. These are called out by setting the high\n\t\t    // and low expression ranges to the same\n\t\t    // expression. The exclude_flags should be false\n\t\t    // in this case\n\t\t  ivl_assert(*range->high_expr, tmp->low_open_flag==false && tmp->high_open_flag==false);\n\t\t  tmp->high_expr = tmp->low_expr;\n\n\t    } else if (range->high_expr) {\n\t\t  tmp->high_expr = elab_and_eval(des, scope, range->high_expr, -1);\n\t\t  ivl_assert(*range->high_expr, tmp->high_expr);\n\t    } else {\n\t\t  tmp->high_expr = 0;\n\t    }\n\n\t    tmp->next = range_list;\n\t    range_list = tmp;\n      }\n\n      // The type of the parameter, if unspecified in the source, will come\n      // from the type of the value assigned to it. Therefore, if the type is\n      // not yet known, don't try to guess here, put the type guess off. Also\n      // don't try to elaborate it here, because there may be references to\n      // other parameters still being located during scope elaboration.\n      scope->set_parameter(name, is_annotatable, cur, range_list);\n}\n\nstatic void collect_scope_parameters(Design*des, NetScope*scope,\n      const map<perm_string,LexicalScope::param_expr_t*>&parameters)\n{\n      if (debug_scopes) {\n\t    cerr << scope->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"collect parameters for \" << scope_path(scope) << \".\" << endl;\n      }\n\n      for (mparm_it_t cur = parameters.begin()\n\t\t ; cur != parameters.end() ;  ++ cur ) {\n\n\t    collect_parm_item(des, scope, cur->first, *(cur->second), false);\n      }\n}\n\nstatic void collect_scope_specparams(Design*des, NetScope*scope,\n      const map<perm_string,LexicalScope::param_expr_t*>&specparams)\n{\n      if (debug_scopes) {\n\t    cerr << scope->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"collect specparams for \" << scope_path(scope) << \".\" << endl;\n      }\n\n      for (mparm_it_t cur = specparams.begin()\n\t\t ; cur != specparams.end() ;  ++ cur ) {\n\n\t    collect_parm_item(des, scope, cur->first, *(cur->second), true);\n      }\n}\n\nstatic void collect_scope_signals(NetScope*scope,\n      const map<perm_string,PWire*>&wires)\n{\n      for (map<perm_string,PWire*>::const_iterator cur = wires.begin()\n\t\t ; cur != wires.end() ; ++ cur ) {\n\n\t    PWire*wire = (*cur).second;\n\t    if (debug_scopes) {\n\t\t  cerr << wire->get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"adding placeholder for signal '\" << wire->basename()\n\t\t       << \"' in scope '\" << scope_path(scope) << \"'.\" << endl;\n\t    }\n\t    scope->add_signal_placeholder(wire);\n      }\n}\n\n/*\n * Elaborate the enumeration into the given scope.\n */\nstatic void elaborate_scope_enumeration(Design*des, NetScope*scope,\n\t\t\t\t\tenum_type_t*enum_type)\n{\n      bool rc_flag;\n\n      enum_type->elaborate_type(des, scope);\n\n      netenum_t *use_enum = scope->enumeration_for_key(enum_type);\n\n      size_t name_idx = 0;\n\t// Find the enumeration width.\n      long raw_width = use_enum->packed_width();\n      ivl_assert(*use_enum, raw_width > 0);\n      unsigned enum_width = (unsigned)raw_width;\n      bool is_signed = use_enum->get_signed();\n\t// Define the default start value and the increment value to be the\n\t// correct type for this enumeration.\n      verinum cur_value ((uint64_t)0, enum_width);\n      cur_value.has_sign(is_signed);\n      verinum one_value ((uint64_t)1, enum_width);\n      one_value.has_sign(is_signed);\n\t// Find the maximum allowed enumeration value.\n      verinum max_value (0);\n      if (is_signed) {\n\t    max_value = pow(verinum(2), verinum(enum_width-1)) - one_value;\n      } else {\n\t    max_value = pow(verinum(2), verinum(enum_width)) - one_value;\n      }\n      max_value.has_sign(is_signed);\n\t// Variable to indicate when a defined value wraps.\n      bool implicit_wrapped = false;\n\t// Process the enumeration definition.\n      for (list<named_pexpr_t>::const_iterator cur = enum_type->names->begin()\n\t\t ; cur != enum_type->names->end() ;  ++ cur, name_idx += 1) {\n\t      // Check to see if the enumeration name has a value given.\n\t    if (cur->parm) {\n\t\t    // There is an explicit value. elaborate/evaluate\n\t\t    // the value and assign it to the enumeration name.\n\t\t  NetExpr*val = elab_and_eval(des, scope, cur->parm, -1);\n\t\t  NetEConst*val_const = dynamic_cast<NetEConst*> (val);\n\t\t  if (val_const == 0) {\n\t\t\tcerr << use_enum->get_fileline()\n\t\t\t     << \": error: Enumeration expression for \"\n\t\t\t     << cur->name <<\" is not an integer constant.\"\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\t\t  cur_value = val_const->value();\n\t\t    // Clear the implicit wrapped flag if a parameter is given.\n\t\t  implicit_wrapped = false;\n\n\t\t    // A 2-state value can not have a constant with X/Z bits.\n\t\t  if (use_enum->base_type() == IVL_VT_BOOL &&\n\t\t      ! cur_value.is_defined()) {\n\t\t\tcerr << use_enum->get_fileline()\n\t\t\t     << \": error: Enumeration name \" << cur->name\n\t\t\t     << \" can not have an undefined value.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t    // If this is a literal constant and it has a defined\n\t\t    // width then the width must match the enumeration width.\n\t\t  if (PENumber *tmp = dynamic_cast<PENumber*>(cur->parm)) {\n\t\t\tif (tmp->value().has_len() &&\n\t\t\t    (tmp->value().len() != enum_width)) {\n\t\t\t      cerr << use_enum->get_fileline()\n\t\t\t           << \": error: Enumeration name \" << cur->name\n\t\t\t           << \" has an incorrectly sized constant.\"\n\t\t\t           << endl;\n\t\t\t      des->errors += 1;\n\t\t\t}\n\t\t  }\n\n\t\t    // If we are padding/truncating a negative value for an\n\t\t    // unsigned enumeration that is an error or if the new\n\t\t    // value does not have a defined width.\n\t\t  if (((cur_value.len() != enum_width) ||\n\t\t       ! cur_value.has_len()) &&\n\t\t      ! is_signed && cur_value.is_negative()) {\n\t\t\tcerr << use_enum->get_fileline()\n\t\t\t     << \": error: Enumeration name \" << cur->name\n\t\t\t     << \" has a negative value.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\n\t\t    // Narrower values need to be padded to the width of the\n\t\t    // enumeration and defined to have the specified width.\n\t\t  if (cur_value.len() < enum_width) {\n\t\t\tcur_value = pad_to_width(cur_value, enum_width);\n\t\t  }\n\n\t\t    // Some wider values can be truncated.\n\t\t  if (cur_value.len() > enum_width) {\n\t\t\tunsigned check_width = enum_width - 1;\n\t\t\t  // Check that the upper bits match the MSB\n\t\t\tfor (unsigned idx = enum_width;\n\t\t\t     idx < cur_value.len();\n\t\t\t     idx += 1) {\n\t\t\t      if (cur_value[idx] != cur_value[check_width]) {\n\t\t\t\t      // If this is an unsigned enumeration\n\t\t\t\t      // then zero padding is okay.\n\t\t\t\t    if (!is_signed &&\n\t\t\t\t        (idx == enum_width) &&\n\t\t\t\t        (cur_value[idx] == verinum::V0)) {\n\t\t\t\t\t  check_width += 1;\n\t\t\t\t\t  continue;\n\t\t\t\t    }\n\t\t\t\t    if (cur_value.is_defined()) {\n\t\t\t\t\t  cerr << use_enum->get_fileline()\n\t\t\t\t\t       << \": error: Enumeration name \"\n\t\t\t\t\t       << cur->name\n\t\t\t\t\t       << \" has a value that is too \"\n\t\t\t\t\t       << ((cur_value > max_value) ?\n\t\t\t\t\t           \"large\" : \"small\")\n\t\t\t\t\t       << \" \" << cur_value << \".\"\n\t\t\t\t\t       << endl;\n\t\t\t\t    } else {\n\t\t\t\t\t  cerr << use_enum->get_fileline()\n\t\t\t\t\t       << \": error: Enumeration name \"\n\t\t\t\t\t       << cur->name\n\t\t\t\t\t       << \" has trimmed bits that do \"\n\t\t\t\t\t       << \"not match the enumeration \"\n\t\t\t\t\t       << \"MSB: \" << cur_value << \".\"\n\t\t\t\t\t       << endl;\n\t\t\t\t    }\n\t\t\t\t    des->errors += 1;\n\t\t\t\t    break;\n\t\t\t      }\n\t\t\t}\n\t\t\t  // If this is an unsigned value then make sure\n\t\t\t  // The upper bits are not 1.\n\t\t\tif (! cur_value.has_sign() &&\n\t\t\t    (cur_value[enum_width] == verinum::V1)) {\n\t\t\t      cerr << use_enum->get_fileline()\n\t\t\t           << \": error: Enumeration name \"\n\t\t\t           << cur->name\n\t\t\t           << \" has a value that is too large: \"\n\t\t\t           << cur_value << \".\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      break;\n\t\t\t}\n\t\t\tcur_value = verinum(cur_value, enum_width);\n\t\t  }\n\n\t\t    // At this point the value has the correct size and needs\n\t\t    // to have the correct sign attribute set.\n\t\t  cur_value.has_len(true);\n\t\t  cur_value.has_sign(is_signed);\n\n\t    } else if (! cur_value.is_defined()) {\n\t\t  cerr << use_enum->get_fileline()\n\t\t       << \": error: Enumeration name \" << cur->name\n\t\t       << \" has an undefined inferred value.\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t      // Check to see if an implicitly wrapped value is used.\n\t    if (implicit_wrapped) {\n\t\t  cerr << use_enum->get_fileline()\n\t\t       << \": error: Enumeration name \" << cur->name\n\t\t       << \" has an inferred value that overflowed.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    // The enumeration value must be unique.\n\t    perm_string dup_name = use_enum->find_value(cur_value);\n\t    if (dup_name) {\n\t\t  cerr << use_enum->get_fileline()\n\t\t       << \": error: Enumeration name \"\n\t\t       << cur->name << \" and \" << dup_name\n\t\t       << \" have the same value: \" << cur_value << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    rc_flag = use_enum->insert_name(name_idx, cur->name, cur_value);\n\t    rc_flag &= scope->add_enumeration_name(use_enum, cur->name);\n\n\t    if (! rc_flag) {\n\t\t  cerr << use_enum->get_fileline()\n\t\t       << \": error: Duplicate enumeration name \"\n\t\t       << cur->name << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t      // In case the next name has an implicit value,\n\t      // increment the current value by one.\n\t    if (cur_value.is_defined()) {\n\t\t  if (cur_value == max_value) implicit_wrapped = true;\n\t\t  cur_value = cur_value + one_value;\n\t    }\n      }\n\n      use_enum->insert_name_close();\n}\n\nstatic void elaborate_scope_enumerations(Design*des, NetScope*scope,\n\t\t\t\t\t const vector<enum_type_t*>&enum_types)\n{\n      if (debug_scopes) {\n\t    cerr << scope->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Elaborate \" << enum_types.size() << \" enumerations\"\n\t\t << \" in scope \" << scope_path(scope) << \".\"\n\t\t << endl;\n      }\n\n      for (vector<enum_type_t*>::const_iterator cur = enum_types.begin()\n\t\t ; cur != enum_types.end() ; ++ cur) {\n\t    enum_type_t*curp = *cur;\n\t    elaborate_scope_enumeration(des, scope, curp);\n      }\n}\n\n/*\n * If the pclass includes an implicit and explicit constructor, then\n * merge the implicit constructor into the explicit constructor as\n * statements in the beginning.\n *\n * This is not necessary for proper functionality, it is an\n * optimization, so we can easily give up if it doesn't seem like it\n * will obviously work.\n */\nstatic void blend_class_constructors(PClass*pclass)\n{\n      perm_string new1 = perm_string::literal(\"new\");\n      perm_string new2 = perm_string::literal(\"new@\");\n\n      PFunction*use_new;\n      PFunction*use_new2;\n\n\t// Locate the explicit constructor.\n      map<perm_string,PFunction*>::iterator iter_new = pclass->funcs.find(new1);\n      if (iter_new == pclass->funcs.end())\n\t    use_new = 0;\n      else\n\t    use_new = iter_new->second;\n\n\t// Locate the implicit constructor.\n      map<perm_string,PFunction*>::iterator iter_new2 = pclass->funcs.find(new2);\n      if (iter_new2 == pclass->funcs.end())\n\t    use_new2 = 0;\n      else\n\t    use_new2 = iter_new2->second;\n\n\t// If there are no constructors, then we are done.\n      if (use_new==0 && use_new2==0)\n\t    return;\n\n\t// While we're here, look for a super.new() call. If we find\n\t// it, strip it out of the constructor and set it aside for\n\t// when we actually call the chained constructor.\n      PChainConstructor*chain_new = use_new? use_new->extract_chain_constructor() : NULL;\n\n\t// If we do not have an explicit constructor chain, but there\n\t// is a parent class, then create an implicit chain.\n      if (chain_new==0 && pclass->type->base_type) {\n\t    chain_new = new PChainConstructor(pclass->type->base_args);\n\t    chain_new->set_line(*pclass);\n      }\n\n\t// If there are both an implicit and explicit constructor,\n\t// then blend the implicit constructor into the explicit\n\t// constructor. This eases the task for the elaborator later.\n      if (use_new && use_new2) {\n\t      // These constructors must be methods of the same class.\n\t    ivl_assert(*use_new, use_new->method_of() == use_new2->method_of());\n\n\t    Statement*def_new = use_new->get_statement();\n\t    Statement*def_new2 = use_new2->get_statement();\n\n\t      // It is possible, i.e. recovering from a parse error,\n\t      // for the statement from the constructor to be\n\t      // missing. In that case, create an empty one.\n\t    if (def_new==0) {\n\t\t  def_new = new PBlock(PBlock::BL_SEQ);\n\t\t  use_new->set_statement(def_new);\n\t    }\n\n\t    if (def_new2) use_new->push_statement_front(def_new2);\n\n\t      // Now the implicit initializations are all built into\n\t      // the constructor. Delete the \"new@\" constructor.\n\t    pclass->funcs.erase(iter_new2);\n\t    delete use_new2;\n\t    use_new2 = 0;\n      }\n\n      if (chain_new) {\n\t    if (use_new2) {\n\t\t  use_new2->push_statement_front(chain_new);\n\t    } else {\n\t\t  use_new->push_statement_front(chain_new);\n\t    }\n      }\n}\n\nstatic void elaborate_scope_class(Design*des, NetScope*scope, PClass*pclass)\n{\n      class_type_t*use_type = pclass->type;\n\n      if (debug_scopes) {\n\t    cerr << pclass->get_fileline() <<\": elaborate_scope_class: \"\n\t\t << \"Elaborate scope class \" << pclass->pscope_name()\n\t\t << \" within scope \" << scope_path(scope)\n\t\t << endl;\n      }\n\n\n      const netclass_t*use_base_class = 0;\n      if (use_type->base_type) {\n\t    ivl_type_t base_type = use_type->base_type->elaborate_type(des, scope);\n\t    use_base_class = dynamic_cast<const netclass_t *>(base_type);\n\t    if (!use_base_class) {\n\t\t  cerr << pclass->get_fileline() << \": error: \"\n\t\t       << \"Base type of \" << use_type->name\n\t\t       << \" is not a class.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n\n      netclass_t*use_class = new netclass_t(use_type->name, use_base_class);\n\n      NetScope*class_scope = new NetScope(scope, hname_t(pclass->pscope_name()),\n\t\t\t\t\t  NetScope::CLASS, scope->unit());\n      class_scope->set_line(pclass);\n      class_scope->set_class_def(use_class);\n      use_class->set_class_scope(class_scope);\n      use_class->set_definition_scope(scope);\n      use_class->set_virtual(use_type->virtual_class);\n      set_scope_timescale(des, class_scope, pclass);\n\n      class_scope->add_typedefs(&pclass->typedefs);\n\n      collect_scope_parameters(des, class_scope, pclass->parameters);\n\n      collect_scope_signals(class_scope, pclass->wires);\n\n\t// Elaborate enum types declared in the class. We need these\n\t// now because enumeration constants can be used during scope\n\t// elaboration.\n      if (debug_scopes) {\n\t    cerr << pclass->get_fileline() << \": elaborate_scope_class: \"\n\t\t << \"Elaborate \" << pclass->enum_sets.size() << \" enumerations\"\n\t\t << \" in class \" << scope_path(class_scope)\n\t\t << \", scope=\" << scope_path(scope) << \".\"\n\t\t << endl;\n      }\n      elaborate_scope_enumerations(des, class_scope, pclass->enum_sets);\n\n      for (map<perm_string,PTask*>::iterator cur = pclass->tasks.begin()\n\t\t ; cur != pclass->tasks.end() ; ++cur) {\n\n\t    hname_t use_name (cur->first);\n\t    NetScope*method_scope = new NetScope(class_scope, use_name, NetScope::TASK);\n\n\t      // Task methods are always automatic...\n\t    if (!cur->second->is_auto()) {\n\t\t  cerr << \"error: Lifetime of method `\"\n\t\t       << scope_path(method_scope)\n\t\t       << \"` must not be static\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    method_scope->is_auto(true);\n\t    method_scope->set_line(cur->second);\n\t    method_scope->add_imports(&cur->second->explicit_imports);\n\n\t    if (debug_scopes) {\n\t\t  cerr << cur->second->get_fileline() << \": elaborate_scope_class: \"\n\t\t       << \"Elaborate method (task) scope \"\n\t\t       << scope_path(method_scope) << endl;\n\t    }\n\n\t    cur->second->elaborate_scope(des, method_scope);\n      }\n\n      for (map<perm_string,PFunction*>::iterator cur = pclass->funcs.begin()\n\t\t ; cur != pclass->funcs.end() ; ++cur) {\n\n\t    hname_t use_name (cur->first);\n\t    NetScope*method_scope = new NetScope(class_scope, use_name, NetScope::FUNC);\n\n\t      // Function methods are always automatic...\n\t    if (!cur->second->is_auto()) {\n\t\t  cerr << \"error: Lifetime of method `\"\n\t\t       << scope_path(method_scope)\n\t\t       << \"` must not be static\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    method_scope->is_auto(true);\n\t    method_scope->set_line(cur->second);\n\t    method_scope->add_imports(&cur->second->explicit_imports);\n\n\t    if (debug_scopes) {\n\t\t  cerr << cur->second->get_fileline() << \": elaborate_scope_class: \"\n\t\t       << \"Elaborate method (function) scope \"\n\t\t       << scope_path(method_scope) << endl;\n\t    }\n\n\t    cur->second->elaborate_scope(des, method_scope);\n      }\n\n      scope->add_class(use_class);\n}\n\nstatic void elaborate_scope_classes(Design*des, NetScope*scope,\n\t\t\t\t    const vector<PClass*>&classes)\n{\n      if (debug_scopes) {\n\t    cerr << scope->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Elaborate \" << classes.size() << \" classes\"\n\t\t << \" in scope \" << scope_path(scope) << \".\"\n\t\t << endl;\n      }\n\n      for (size_t idx = 0 ; idx < classes.size() ; idx += 1) {\n\t    blend_class_constructors(classes[idx]);\n\t    elaborate_scope_class(des, scope, classes[idx]);\n      }\n}\n\nstatic void replace_scope_parameters(Design *des, NetScope*scope, const LineInfo&loc,\n\t\t\t\t     const Module::replace_t&replacements)\n{\n      if (debug_scopes) {\n\t    cerr << scope->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Replace scope parameters for \" << scope_path(scope) << \".\" << endl;\n      }\n\n      for (Module::replace_t::const_iterator cur = replacements.begin()\n\t\t ; cur != replacements.end() ;  ++ cur ) {\n\n\t    PExpr*val = (*cur).second;\n\t    if (val == 0) {\n\t\t  cerr << loc.get_fileline() << \": internal error: \"\n\t\t       << \"Missing expression in parameter replacement for \"\n\t\t       << (*cur).first << endl;;\n\t    }\n\t    ivl_assert(loc, val);\n\t    if (debug_scopes) {\n\t\t  cerr << loc.get_fileline() << \": debug: \"\n\t\t       << \"Replace \" << (*cur).first\n\t\t       << \" with expression \" << *val\n\t\t       << \" from \" << val->get_fileline() << \".\" << endl;\n\t\t  cerr << loc.get_fileline() << \":      : \"\n\t\t       << \"Type=\" << val->expr_type() << endl;\n\t    }\n\t    scope->replace_parameter(des, (*cur).first, val, scope->parent());\n      }\n}\n\nstatic void elaborate_scope_events_(Design*des, NetScope*scope,\n                                    const map<perm_string,PEvent*>&events)\n{\n      for (map<perm_string,PEvent*>::const_iterator et = events.begin()\n\t\t ; et != events.end() ;  ++ et ) {\n\n\t    (*et).second->elaborate_scope(des, scope);\n      }\n}\n\nstatic void elaborate_scope_task(Design*des, NetScope*scope, PTask*task)\n{\n      hname_t use_name( task->pscope_name() );\n\n      NetScope*task_scope = new NetScope(scope, use_name, NetScope::TASK);\n      task_scope->is_auto(task->is_auto());\n      task_scope->set_line(task);\n      task_scope->add_imports(&task->explicit_imports);\n\n      if (debug_scopes) {\n\t    cerr << task->get_fileline() << \": elaborate_scope_task: \"\n\t\t << \"Elaborate task scope \" << scope_path(task_scope) << endl;\n      }\n\n      task->elaborate_scope(des, task_scope);\n}\n\nstatic void elaborate_scope_tasks(Design*des, NetScope*scope,\n\t\t\t\t  const map<perm_string,PTask*>&tasks)\n{\n      typedef map<perm_string,PTask*>::const_iterator tasks_it_t;\n\n      for (tasks_it_t cur = tasks.begin()\n\t\t ; cur != tasks.end() ;  ++ cur ) {\n\n\t    elaborate_scope_task(des, scope, cur->second);\n      }\n\n}\n\nstatic void elaborate_scope_func(Design*des, NetScope*scope, PFunction*task)\n{\n      hname_t use_name( task->pscope_name() );\n\n      NetScope*task_scope = new NetScope(scope, use_name, NetScope::FUNC);\n      task_scope->is_auto(task->is_auto());\n      task_scope->set_line(task);\n      task_scope->add_imports(&task->explicit_imports);\n\n      if (debug_scopes) {\n\t    cerr << task->get_fileline() << \": elaborate_scope_func: \"\n\t\t << \"Elaborate function scope \" << scope_path(task_scope)\n\t\t << endl;\n      }\n\n      task->elaborate_scope(des, task_scope);\n}\n\nstatic void elaborate_scope_funcs(Design*des, NetScope*scope,\n\t\t\t\t  const map<perm_string,PFunction*>&funcs)\n{\n      typedef map<perm_string,PFunction*>::const_iterator funcs_it_t;\n\n      for (funcs_it_t cur = funcs.begin()\n\t\t ; cur != funcs.end() ;  ++ cur ) {\n\n\t    elaborate_scope_func(des, scope, cur->second);\n      }\n\n}\n\nclass generate_schemes_work_item_t : public elaborator_work_item_t {\n    public:\n      generate_schemes_work_item_t(Design*des__, NetScope*scope, Module*mod)\n      : elaborator_work_item_t(des__), scope_(scope), mod_(mod)\n      { }\n\n      void elaborate_runrun()\n      {\n\t    if (debug_scopes)\n\t\t  cerr << mod_->get_fileline() << \": debug: \"\n\t\t       << \"Processing generate schemes for \"\n\t\t       << scope_path(scope_) << endl;\n\n\t      // Generate schemes can create new scopes in the form of\n\t      // generated code. Scan the generate schemes, and *generate*\n\t      // new scopes, which is slightly different from simple\n\t      // elaboration.\n\t    typedef list<PGenerate*>::const_iterator generate_it_t;\n\t    for (generate_it_t cur = mod_->generate_schemes.begin()\n\t\t       ; cur != mod_->generate_schemes.end() ; ++ cur ) {\n\t\t  (*cur) -> generate_scope(des, scope_);\n\t    }\n      }\n\n    private:\n\t// The scope_ is the scope that contains the generate scheme\n\t// we are to work on. the mod_ is the Module definition for\n\t// that scope, and contains the parsed generate schemes.\n      NetScope*scope_;\n      Module*mod_;\n};\n\nbool PPackage::elaborate_scope(Design*des, NetScope*scope)\n{\n      if (debug_scopes) {\n\t    cerr << get_fileline() << \": PPackage::elaborate_scope: \"\n\t\t << \"Elaborate package \" << scope_path(scope) << \".\" << endl;\n      }\n\n      scope->add_typedefs(&typedefs);\n\n      collect_scope_parameters(des, scope, parameters);\n\n      collect_scope_signals(scope, wires);\n\n      if (debug_scopes) {\n\t    cerr << get_fileline() << \": PPackage::elaborate_scope: \"\n\t\t << \"Elaborate \" << enum_sets.size() << \" enumerations\"\n\t\t << \" in package scope \" << scope_path(scope) << \".\"\n\t\t << endl;\n      }\n      elaborate_scope_enumerations(des, scope, enum_sets);\n\n      elaborate_scope_classes(des, scope, classes_lexical);\n      elaborate_scope_funcs(des, scope, funcs);\n      elaborate_scope_tasks(des, scope, tasks);\n      elaborate_scope_events_(des, scope, events);\n      return true;\n}\n\nbool Module::elaborate_scope(Design*des, NetScope*scope,\n\t\t\t     const replace_t&replacements)\n{\n      if (debug_scopes) {\n\t    cerr << get_fileline() << \": Module::elaborate_scope: \"\n\t\t << \"Elaborate \" << scope_path(scope) << \".\" << endl;\n      }\n\n      scope->add_typedefs(&typedefs);\n\n\t// Add the genvars to the scope.\n      typedef map<perm_string,LineInfo*>::const_iterator genvar_it_t;\n      for (genvar_it_t cur = genvars.begin(); cur != genvars.end(); ++ cur ) {\n\t    scope->add_genvar((*cur).first, (*cur).second);\n      }\n\n\t// Scan the parameters in the module, and store the information\n\t// needed to evaluate the parameter expressions. The expressions\n\t// will be evaluated later, once all parameter overrides for this\n\t// module have been done.\n\n      collect_scope_parameters(des, scope, parameters);\n\n      collect_scope_specparams(des, scope, specparams);\n\n      collect_scope_signals(scope, wires);\n\n\t// Run parameter replacements that were collected from the\n\t// containing scope and meant for me.\n\n      replace_scope_parameters(des, scope, *this, replacements);\n\n      elaborate_scope_enumerations(des, scope, enum_sets);\n\n      ivl_assert(*this, classes.size() == classes_lexical.size());\n      elaborate_scope_classes(des, scope, classes_lexical);\n\n\t// Run through the defparams for this module and save the result\n\t// in a table for later final override.\n\n      typedef list<Module::named_expr_t>::const_iterator defparms_iter_t;\n      for (defparms_iter_t cur = defparms.begin()\n\t\t ; cur != defparms.end() ; ++ cur ) {\n\t    scope->defparams.push_back(make_pair(cur->first, cur->second));\n      }\n\n\t// Evaluate the attributes. Evaluate them in the scope of the\n\t// module that the attribute is attached to. Is this correct?\n      unsigned nattr;\n      attrib_list_t*attr = evaluate_attributes(attributes, nattr, des, scope);\n\n      for (unsigned idx = 0 ;  idx < nattr ;  idx += 1)\n\t    scope->attribute(attr[idx].key, attr[idx].val);\n\n      delete[]attr;\n\n\t// Generate schemes need to have their scopes elaborated, but\n\t// we can not do that until defparams are run, so push it off\n\t// into an elaborate work item.\n      if (debug_scopes)\n\t    cerr << get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Schedule generates within \" << scope_path(scope)\n\t\t << \" for elaboration after defparams.\" << endl;\n\n      des->elaboration_work_list.push_back(new generate_schemes_work_item_t(des, scope, this));\n\n\t// Tasks introduce new scopes, so scan the tasks in this\n\t// module. Create a scope for the task and pass that to the\n\t// elaborate_scope method of the PTask for detailed\n\t// processing.\n\n      elaborate_scope_tasks(des, scope, tasks);\n\n\n\t// Functions are very similar to tasks, at least from the\n\t// perspective of scopes. So handle them exactly the same\n\t// way.\n\n      elaborate_scope_funcs(des, scope, funcs);\n\n\t// Look for implicit modules and implicit gates for them.\n\n      for (map<perm_string,Module*>::iterator cur = nested_modules.begin()\n\t\t ; cur != nested_modules.end() ; ++cur) {\n\t      // Skip modules that must be explicitly instantiated.\n\t    if (cur->second->port_count() > 0)\n\t\t  continue;\n\n\t    PGModule*nested_gate = new PGModule(cur->second, cur->second->mod_name());\n\t    nested_gate->set_line(*cur->second);\n\t    gates_.push_back(nested_gate);\n      }\n\n\t// Gates include modules, which might introduce new scopes, so\n\t// scan all of them to create those scopes.\n\n      typedef list<PGate*>::const_iterator gates_it_t;\n      for (gates_it_t cur = gates_.begin()\n\t\t ; cur != gates_.end() ; ++ cur ) {\n\n\t    (*cur) -> elaborate_scope(des, scope);\n      }\n\n\n\t// initial and always blocks may contain begin-end and\n\t// fork-join blocks that can introduce scopes. Therefore, I\n\t// get to scan processes here.\n\n      typedef list<PProcess*>::const_iterator proc_it_t;\n\n      for (proc_it_t cur = behaviors.begin()\n\t\t ; cur != behaviors.end() ; ++ cur ) {\n\n\t    (*cur) -> statement() -> elaborate_scope(des, scope);\n      }\n\n\t// Scan through all the named events in this scope. We do not\n\t// need anything more than the current scope to do this\n\t// elaboration, so do it now. This allows for normal\n\t// elaboration to reference these events.\n\n      elaborate_scope_events_(des, scope, events);\n\n      scope->is_cell(is_cell);\n\n      return des->errors == 0;\n}\n\nbool PGenerate::generate_scope(Design*des, NetScope*container)\n{\n      switch (scheme_type) {\n\t  case GS_LOOP:\n\t    return generate_scope_loop_(des, container);\n\n\t  case GS_CONDIT:\n\t    return generate_scope_condit_(des, container, false);\n\n\t  case GS_ELSE:\n\t    return generate_scope_condit_(des, container, true);\n\n\t  case GS_CASE:\n\t    return generate_scope_case_(des, container);\n\n\t  case GS_NBLOCK:\n\t    return generate_scope_nblock_(des, container);\n\n\t  case GS_CASE_ITEM:\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Case item outside of a case generate scheme?\" << endl;\n\t    return false;\n\n\t  default:\n\t    cerr << get_fileline() << \": sorry: Generate of this sort\"\n\t\t << \" is not supported yet!\" << endl;\n\t    return false;\n      }\n}\n\nvoid PGenerate::check_for_valid_genvar_value_(long value)\n{\n      if (generation_flag < GN_VER2005 && value < 0) {\n\t    cerr << get_fileline() << \": warning: A negative value (\" << value\n\t\t << \") has been assigned to genvar '\" << loop_index << \"'.\"\n\t\t << endl;\n\t    cerr << get_fileline() << \":        : This is illegal in \"\n\t\t    \"Verilog-2001. Use at least -g2005 to remove this warning.\"\n\t\t << endl;\n      }\n}\n\n/*\n * This is the elaborate scope method for a generate loop.\n */\nbool PGenerate::generate_scope_loop_(Design*des, NetScope*container)\n{\n      if (!local_index) {\n\t      // Check that the loop_index variable was declared in a\n\t      // genvar statement.\n\t    NetScope*cscope = container;\n\t    while (cscope && !cscope->find_genvar(loop_index)) {\n\t\t  if (cscope->symbol_exists(loop_index)) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"generate loop variable '\" << loop_index\n\t\t\t     << \"' is not a genvar in this scope.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\t\t  cscope = cscope->parent();\n            }\n\t    if (!cscope) {\n\t\t  cerr << get_fileline() << \": error: genvar is missing for \"\n\t\t\t  \"generate \\\"loop\\\" variable '\" << loop_index << \"'.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n      }\n\n\t// We're going to need a genvar...\n      long genvar;\n\n\t// The initial value for the genvar does not need (nor can it\n\t// use) the genvar itself, so we can evaluate this expression\n\t// the same way any other parameter value is evaluated.\n      NetExpr*init_ex = elab_and_eval(des, container, loop_init, -1, true);\n      NetEConst*init = dynamic_cast<NetEConst*> (init_ex);\n      if (init == 0) {\n\t    cerr << get_fileline() << \": error: Cannot evaluate genvar\"\n\t\t << \" init expression: \" << *loop_init << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      genvar = init->value().as_long();\n      check_for_valid_genvar_value_(genvar);\n      delete init_ex;\n\n      if (debug_scopes)\n\t    cerr << get_fileline() << \": debug: genvar init = \" << genvar << endl;\n      container->genvar_tmp = loop_index;\n      container->genvar_tmp_val = genvar;\n      NetExpr*test_ex = elab_and_eval(des, container, loop_test, -1, true);\n      NetEConst*test = dynamic_cast<NetEConst*>(test_ex);\n      if (test == 0) {\n\t    cerr << get_fileline() << \": error: Cannot evaluate genvar\"\n\t\t << \" conditional expression: \" << *loop_test << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n      while (test->value().as_long()) {\n\n\t      // The actual name of the scope includes the genvar so\n\t      // that each instance has a unique name in the\n\t      // container. The format of using [] is part of the\n\t      // Verilog standard.\n\t    hname_t use_name (scope_name, genvar);\n\n\t    if (debug_scopes)\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Create generated scope \" << use_name << endl;\n\n\t    NetScope*scope = new NetScope(container, use_name,\n\t\t\t\t\t  NetScope::GENBLOCK);\n\t    scope->set_line(get_file(), get_lineno());\n\t    scope->add_imports(&explicit_imports);\n\n\t      // Set in the scope a localparam for the value of the\n\t      // genvar within this instance of the generate\n\t      // block. Code within this scope thus has access to the\n\t      // genvar as a constant.\n\t    {\n\t\t  verinum genvar_verinum;\n\t\t  if (gn_strict_expr_width_flag)\n\t\t\tgenvar_verinum = verinum(genvar, integer_width);\n\t\t  else\n\t\t\tgenvar_verinum = verinum(genvar);\n\t\t  genvar_verinum.has_sign(true);\n\t\t  NetEConstParam*gp = new NetEConstParam(scope,\n\t\t\t\t\t\t\t loop_index,\n\t\t\t\t\t\t\t genvar_verinum);\n\t\t    // The file and line information should really come\n\t\t    // from the genvar statement, not the for loop.\n\t\t  scope->set_parameter(loop_index, gp, *this);\n\t\t  if (debug_scopes)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Create implicit localparam \"\n\t\t\t     << loop_index << \" = \" << genvar_verinum << endl;\n\t    }\n\n\t    elaborate_subscope_(des, scope);\n\n\t      // Calculate the step for the loop variable.\n\t    NetExpr*step_ex = elab_and_eval(des, container, loop_step, -1, true);\n\t    NetEConst*step = dynamic_cast<NetEConst*>(step_ex);\n\t    if (step == 0) {\n\t\t  cerr << get_fileline() << \": error: Cannot evaluate genvar\"\n\t\t       << \" step expression: \" << *loop_step << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    if (debug_scopes)\n\t\t  cerr << get_fileline() << \": debug: genvar step from \"\n\t\t       << genvar << \" to \" << step->value().as_long() << endl;\n\n\t    genvar = step->value().as_long();\n\t    check_for_valid_genvar_value_(genvar);\n\t    container->genvar_tmp_val = genvar;\n\t    delete step;\n\t    delete test_ex;\n\t    test_ex = elab_and_eval(des, container, loop_test, -1, true);\n\t    test = dynamic_cast<NetEConst*>(test_ex);\n\t    ivl_assert(*this, test);\n      }\n\n\t// Clear the genvar_tmp field in the scope to reflect that the\n\t// genvar is no longer valid for evaluating expressions.\n      container->genvar_tmp = perm_string();\n\n      return true;\n}\n\nbool PGenerate::generate_scope_condit_(Design*des, NetScope*container, bool else_flag)\n{\n      NetExpr*test_ex = elab_and_eval(des, container, loop_test, -1, true);\n      NetEConst*test = dynamic_cast<NetEConst*> (test_ex);\n      if (test == 0) {\n\t    cerr << get_fileline() << \": error: Cannot evaluate genvar\"\n\t\t << \" conditional expression: \" << *loop_test << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n\t// If the condition evaluates as false, then do not create the\n\t// scope.\n      if ( (test->value().as_long() == 0 && !else_flag)\n\t|| (test->value().as_long() != 0 &&  else_flag) ) {\n\t    if (debug_scopes)\n\t\t  cerr << get_fileline() << \": debug: Generate condition \"\n\t\t       << (else_flag? \"(else)\" : \"(if)\")\n\t\t       << \" value=\" << test->value() << \": skip generation\"\n\t\t       << endl;\n\t    delete test_ex;\n\t    return true;\n      }\n\n      hname_t use_name (scope_name);\n      if (debug_scopes)\n\t    cerr << get_fileline() << \": debug: Generate condition \"\n\t\t << (else_flag? \"(else)\" : \"(if)\")\n\t\t << \" value=\" << test->value() << \": Generate scope=\"\n\t\t << use_name << endl;\n\n      if (directly_nested) {\n\t    if (debug_scopes)\n\t\t  cerr << get_fileline() << \": debug: Generate condition \"\n\t\t       << (else_flag? \"(else)\" : \"(if)\")\n\t\t       << \" detected direct nesting.\" << endl;\n\t    elaborate_subscope_direct_(des, container);\n\t    return true;\n      }\n\n\t// If this is not directly nested, then generate a scope\n\t// for myself. That is what I will pass to the subscope.\n      NetScope*scope = new NetScope(container, use_name, NetScope::GENBLOCK);\n      scope->set_line(get_file(), get_lineno());\n      scope->add_imports(&explicit_imports);\n\n      elaborate_subscope_(des, scope);\n\n      return true;\n}\n\nbool PGenerate::generate_scope_case_(Design*des, NetScope*container)\n{\n      NetExpr*case_value_ex = elab_and_eval(des, container, loop_test, -1, true);\n      NetEConst*case_value_co = dynamic_cast<NetEConst*>(case_value_ex);\n      if (case_value_co == 0) {\n\t    cerr << get_fileline() << \": error: Cannot evaluate genvar case\"\n\t\t << \" expression: \" << *loop_test << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      if (debug_scopes)\n\t    cerr << get_fileline() << \": debug: Generate case \"\n\t\t << \"switch value=\" << case_value_co->value() << endl;\n\n      PGenerate*default_item = 0;\n\n      typedef list<PGenerate*>::const_iterator generator_it_t;\n      generator_it_t cur = generate_schemes.begin();\n      while (cur != generate_schemes.end()) {\n\t    PGenerate*item = *cur;\n\t    ivl_assert(*item, item->scheme_type == PGenerate::GS_CASE_ITEM);\n\n\t      // Detect that the item is a default.\n\t    if (item->item_test.size() == 0) {\n\t\t  default_item = item;\n\t\t  ++ cur;\n\t\t  continue;\n\t    }\n\n\t    bool match_flag = false;\n\t    for (unsigned idx = 0 ; idx < item->item_test.size() && !match_flag ; idx +=1 ) {\n\t\t  NetExpr*item_value_ex = elab_and_eval(des, container,\n                                                        item->item_test[idx],\n                                                        -1, true);\n\t\t  NetEConst*item_value_co = dynamic_cast<NetEConst*>(item_value_ex);\n\t\t  if (item_value_co == 0) {\n\t\t\tcerr << get_fileline() << \": error: Cannot evaluate \"\n\t\t\t     << \" genvar case item expression: \"\n\t\t\t     << *item->item_test[idx] << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\n\t\t  if (debug_scopes)\n\t\t\tcerr << get_fileline() << \": debug: Generate case \"\n\t\t\t     << \"item value=\" << item_value_co->value() << endl;\n\n\t\t  if (case_value_co->value() == item_value_co->value())\n\t\t\tmatch_flag = true;\n\t\t  delete item_value_co;\n\t    }\n\n\t      // If we stumble on the item that matches, then break out now.\n\t    if (match_flag)\n\t\t  break;\n\n\t    ++ cur;\n      }\n\n      delete case_value_co;\n\n      PGenerate*item = (cur == generate_schemes.end())? default_item : *cur;\n      if (item == 0) {\n\t    cerr << get_fileline() << \": debug: \"\n\t\t << \"No generate items found\" << endl;\n\t    return true;\n      }\n\n      if (debug_scopes)\n\t    cerr << get_fileline() << \": debug: \"\n\t\t << \"Generate case matches item at \"\n\t\t << item->get_fileline() << endl;\n\n\t// The name of the scope to generate, whatever that item is.\n      hname_t use_name (item->scope_name);\n\n      if (item->directly_nested) {\n\t    if (debug_scopes)\n\t\t  cerr << get_fileline() << \": debug: Generate case item \" << scope_name\n\t\t       << \" detected direct nesting.\" << endl;\n\t    item->elaborate_subscope_direct_(des, container);\n\t    return true;\n      }\n\n      if (debug_scopes) {\n\t    cerr << get_fileline() << \": PGenerate::generate_scope_case_: \"\n\t\t << \"Generate subscope \" << use_name\n\t\t << \" and elaborate.\" << endl;\n      }\n\n      NetScope*scope = new NetScope(container, use_name,\n\t\t\t\t    NetScope::GENBLOCK);\n      scope->set_line(get_file(), get_lineno());\n      scope->add_imports(&explicit_imports);\n\n      item->elaborate_subscope_(des, scope);\n\n      return true;\n}\n\nbool PGenerate::generate_scope_nblock_(Design*des, NetScope*container)\n{\n      hname_t use_name (scope_name);\n      if (debug_scopes)\n\t    cerr << get_fileline() << \": debug: Generate named block \"\n\t\t << \": Generate scope=\" << use_name << endl;\n\n      NetScope*scope = new NetScope(container, use_name,\n\t\t\t\t    NetScope::GENBLOCK);\n      scope->set_line(get_file(), get_lineno());\n      scope->add_imports(&explicit_imports);\n\n      elaborate_subscope_(des, scope);\n\n      return true;\n}\n\nvoid PGenerate::elaborate_subscope_direct_(Design*des, NetScope*scope)\n{\n      typedef list<PGenerate*>::const_iterator generate_it_t;\n      for (generate_it_t cur = generate_schemes.begin()\n\t\t ; cur != generate_schemes.end() ; ++ cur ) {\n\t    PGenerate*curp = *cur;\n\t    if (debug_scopes) {\n\t\t  cerr << get_fileline() << \": elaborate_subscope_direct_: \"\n\t\t       << \"Elaborate direct subscope \" << curp->scope_name\n\t\t       << \" within scope \" << scope_name << endl;\n\t    }\n\t    curp -> generate_scope(des, scope);\n      }\n}\n\nvoid PGenerate::elaborate_subscope_(Design*des, NetScope*scope)\n{\n      scope->add_typedefs(&typedefs);\n\n\t// Add the genvars to this scope.\n      typedef map<perm_string,LineInfo*>::const_iterator genvar_it_t;\n      for (genvar_it_t cur = genvars.begin(); cur != genvars.end(); ++ cur ) {\n\t    scope->add_genvar((*cur).first, (*cur).second);\n      }\n\n\t// Scan the parameters in this scope, and store the information\n        // needed to evaluate the parameter expressions. The expressions\n\t// will be evaluated later, once all parameter overrides for this\n\t// module have been done.\n      collect_scope_parameters(des, scope, parameters);\n\n      collect_scope_signals(scope, wires);\n\n\t// Run through the defparams for this scope and save the result\n\t// in a table for later final override.\n\n      typedef list<PGenerate::named_expr_t>::const_iterator defparms_iter_t;\n      for (defparms_iter_t cur = defparms.begin()\n\t\t ; cur != defparms.end() ; ++ cur ) {\n\t    scope->defparams.push_back(make_pair(cur->first, cur->second));\n      }\n\n\t// Scan the generated scope for nested generate schemes,\n\t// and *generate* new scopes, which is slightly different\n\t// from simple elaboration.\n\n      typedef list<PGenerate*>::const_iterator generate_it_t;\n      for (generate_it_t cur = generate_schemes.begin()\n\t\t ; cur != generate_schemes.end() ; ++ cur ) {\n\t    (*cur) -> generate_scope(des, scope);\n      }\n\n        // Scan through all the task and function declarations in this\n        // scope.\n      elaborate_scope_tasks(des, scope, tasks);\n      elaborate_scope_funcs(des, scope, funcs);\n\n\t// Scan the generated scope for gates that may create\n\t// their own scopes.\n      typedef list<PGate*>::const_iterator pgate_list_it_t;\n      for (pgate_list_it_t cur = gates.begin()\n\t\t ; cur != gates.end() ; ++ cur ) {\n\t    (*cur) ->elaborate_scope(des, scope);\n      }\n\n      typedef list<PProcess*>::const_iterator proc_it_t;\n      for (proc_it_t cur = behaviors.begin()\n\t\t ; cur != behaviors.end() ; ++ cur ) {\n\t    (*cur) -> statement() -> elaborate_scope(des, scope);\n      }\n\n\t// Scan through all the named events in this scope.\n      elaborate_scope_events_(des, scope, events);\n\n      if (debug_scopes)\n\t    cerr << get_fileline() << \": debug: Generated scope \" << scope_path(scope)\n\t\t << \" for generate block \" << scope_name << endl;\n\n\t// Save the scope that we created, for future use.\n      scope_list_.push_back(scope);\n}\n\nclass delayed_elaborate_scope_mod_instances : public elaborator_work_item_t {\n\n    public:\n      delayed_elaborate_scope_mod_instances(Design*des__,\n\t\t\t\t\t    const PGModule*obj,\n\t\t\t\t\t    Module*mod,\n\t\t\t\t\t    NetScope*sc)\n      : elaborator_work_item_t(des__), obj_(obj), mod_(mod), sc_(sc)\n      { }\n      ~delayed_elaborate_scope_mod_instances() { }\n\n      virtual void elaborate_runrun();\n\n    private:\n      const PGModule*obj_;\n      Module*mod_;\n      NetScope*sc_;\n};\n\nvoid delayed_elaborate_scope_mod_instances::elaborate_runrun()\n{\n      if (debug_scopes)\n\t    cerr << obj_->get_fileline() << \": debug: \"\n\t\t << \"Resume scope elaboration of instances of \"\n\t\t << mod_->mod_name() << \".\" << endl;\n\n      obj_->elaborate_scope_mod_instances_(des, mod_, sc_);\n}\n\n/*\n * Here we handle the elaborate scope of a module instance. The caller\n * has already figured out that this \"gate\" is a module, and has found\n * the module definition. The \"sc\" argument is the scope that will\n * contain this instance.\n */\nvoid PGModule::elaborate_scope_mod_(Design*des, Module*mod, NetScope*sc) const\n{\n      if (get_name() == \"\") {\n\t    cerr << get_fileline() << \": error: Instantiation of module \"\n\t\t << mod->mod_name() << \" requires an instance name.\" << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n\n\t// Missing module instance names have already been rejected.\n      ivl_assert(*this, get_name() != \"\");\n\n\t// check for recursive instantiation by scanning the current\n\t// scope and its parents. Look for a module instantiation of\n\t// the same module, but farther up in the scope.\n      unsigned rl_count = 0;\n      bool in_genblk = false;\n      for (NetScope*scn = sc ;  scn ;  scn = scn->parent()) {\n\t      // We need to know if we are inside a generate block to allow\n\t      // recursive instances.\n\t    if (scn->type() == NetScope::GENBLOCK) {\n\t\t  in_genblk = true;\n\t\t  continue;\n\t    }\n\n\t    if (scn->type() != NetScope::MODULE) continue;\n\n\t    if (strcmp(mod->mod_name(), scn->module_name()) != 0) continue;\n\n\t      // We allow nested scopes if they are inside a generate block,\n\t      // but only to a certain nesting depth.\n\t    if (in_genblk) {\n\t\t  rl_count += 1;\n\t\t  if (rl_count > recursive_mod_limit) {\n\t\t\tcerr << get_fileline() << \": error: instance \"\n\t\t\t     << scope_path(sc) << \".\" << get_name()\n\t\t\t     << \" of module \" << mod->mod_name()\n\t\t\t     << \" is nested too deep.\" << endl;\n\t\t\tcerr << get_fileline() << \":      : check for \"\n\t\t\t        \"proper recursion termination or increase the \"\n\t\t\t        \"limit (\" << recursive_mod_limit\n\t\t\t     << \") with the -pRECURSIVE_MOD_LIMIT flag.\"\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn;\n\t\t  }\n\t\t  continue;\n\t    }\n\n\t    cerr << get_fileline() << \": error: You can not instantiate \"\n\t\t << \"module \" << mod->mod_name() << \" within itself.\" << endl;\n\t    cerr << get_fileline() << \":      : The offending instance is \"\n\t\t << get_name() << \" within \" << scope_path(scn) << \".\" << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n\n      if (is_array()) {\n\t      // If there are expressions to evaluate in order to know\n\t      // the actual number of instances that will be\n\t      // instantiated, then we have to delay further scope\n\t      // elaboration until after defparams (above me) are\n\t      // run. Do that by appending a work item to the\n\t      // elaboration work list.\n\t    if (debug_scopes)\n\t\t  cerr << get_fileline() << \": debug: delay elaborate_scope\"\n\t\t       << \" of array of \" << get_name()\n\t\t       << \" in scope \" << scope_path(sc) << \".\" << endl;\n\n\t    elaborator_work_item_t*tmp\n\t\t  = new delayed_elaborate_scope_mod_instances(des, this, mod, sc);\n\t    des->elaboration_work_list.push_back(tmp);\n\n      } else {\n\t      // If there are no expressions that need to be evaluated\n\t      // to elaborate the scope of this next instances, then\n\t      // get right to it.\n\t    elaborate_scope_mod_instances_(des, mod, sc);\n      }\n}\n\n/*\n * This method is called to process a module instantiation after basic\n * sanity testing is already complete.\n */\nvoid PGModule::elaborate_scope_mod_instances_(Design*des, Module*mod, NetScope*sc) const\n{\n      long instance_low  = 0;\n      long instance_high = 0;\n      long instance_count = calculate_array_size_(des, sc, instance_high, instance_low);\n      if (instance_count == 0)\n\t    return;\n\n      NetScope::scope_vec_t instances (instance_count);\n\n      struct attrib_list_t*attrib_list;\n      unsigned attrib_list_n = 0;\n      attrib_list = evaluate_attributes(attributes, attrib_list_n, des, sc);\n\n\t// Run through the module instances, and make scopes out of\n\t// them. Also do parameter overrides that are done on the\n\t// instantiation line.\n      for (int idx = 0 ;  idx < instance_count ;  idx += 1) {\n\n\t    hname_t use_name (get_name());\n\n\t    if (is_array()) {\n\t\t  int instance_idx;\n\t\t  if (instance_low < instance_high)\n\t\t\tinstance_idx = instance_low + idx;\n\t\t  else\n\t\t\tinstance_idx = instance_low - idx;\n\n\t\t  use_name = hname_t(get_name(), instance_idx);\n\t    }\n\n\t    if (debug_scopes) {\n\t\t  cerr << get_fileline() << \": debug: Module instance \" << use_name\n\t\t       << \" becomes child of \" << scope_path(sc)\n\t\t       << \".\" << endl;\n\t    }\n\n\t      // Create the new scope as a MODULE with my name. Note\n\t      // that if this is a nested module, mark it thus so that\n\t      // scope searches will continue into the parent scope.\n\t    NetScope*my_scope = new NetScope(sc, use_name, NetScope::MODULE, 0,\n\t\t\t\t\t     bound_type_? true : false,\n\t\t\t\t\t     mod->program_block,\n\t\t\t\t\t     mod->is_interface);\n\t    my_scope->set_line(get_file(), mod->get_file(),\n\t                       get_lineno(), mod->get_lineno());\n\t    my_scope->set_module_name(mod->mod_name());\n\t    my_scope->add_imports(&mod->explicit_imports);\n\n\t    for (unsigned adx = 0 ;  adx < attrib_list_n ;  adx += 1)\n\t      my_scope->attribute(attrib_list[adx].key, attrib_list[adx].val);\n\n\t    instances[idx] = my_scope;\n\n\t    set_scope_timescale(des, my_scope, mod);\n\n\t      // Look for module parameter replacements. The \"replace\" map\n\t      // maps parameter name to replacement expression that is\n\t      // passed. It is built up by the ordered overrides or named\n\t      // overrides.\n\n\t    Module::replace_t replace;\n\n\t      // Positional parameter overrides are matched to parameter\n\t      // names by using the param_names list of parameter\n\t      // names. This is an ordered list of names so the first name\n\t      // is parameter 0, the second parameter 1, and so on.\n\n\t    if (overrides_) {\n\t\t  ivl_assert(*this, parms_ == 0);\n\t\t  list<perm_string>::const_iterator cur\n\t\t\t= mod->param_names.begin();\n\t\t  list<PExpr*>::const_iterator jdx = overrides_->begin();\n\t\t  for (;;) {\n\t\t\tif (jdx == overrides_->end())\n\t\t\t      break;\n\t\t\t  // If we reached here we have more overrides than\n\t\t\t  // module parameters, so print a warning.\n\t\t\tif (cur == mod->param_names.end()) {\n\t\t\t      cerr << get_fileline() << \": warning: \"\n\t\t\t              \"ignoring \"\n\t\t\t           << overrides_->size() -\n\t\t\t              mod->param_names.size()\n\t\t\t           << \" extra parameter override(s) for \"\n\t\t\t              \"instance '\" << use_name\n\t\t\t           << \"' of module '\" << mod->mod_name()\n\t\t\t           << \"' which expects \"\n\t\t\t           << mod->param_names.size()\n\t\t\t           << \" parameter(s).\" << endl;\n\t\t\t      break;\n\t\t\t}\n\n\t\t          // No expression means that the parameter is not\n\t\t          // replaced at all.\n\t\t\tif (*jdx)\n\t\t\t      replace[*cur] = *jdx;\n\n\t\t\t++ jdx;\n\t\t\t++ cur;\n\t\t  }\n\t    }\n\n\t      // Named parameter overrides carry a name with each override\n\t      // so the mapping into the replace list is much easier.\n\t    if (parms_) {\n\t\t  ivl_assert(*this, overrides_ == 0);\n\t\t  for (unsigned jdx = 0 ;  jdx < nparms_ ;  jdx += 1) {\n\t\t          // No expression means that the parameter is not\n\t\t          // replaced.\n\t\t\tif (parms_[jdx].parm)\n\t\t\t      replace[parms_[jdx].name] = parms_[jdx].parm;\n\t\t  }\n\n\t    }\n\n\t      // This call actually arranges for the description of the\n\t      // module type to process this instance and handle parameters\n\t      // and sub-scopes that might occur. Parameters are also\n\t      // created in that scope, as they exist. (I'll override them\n\t      // later.)\n\t    mod->elaborate_scope(des, my_scope, replace);\n\n      }\n\t    delete[]attrib_list;\n\n\t/* Stash the instance array of scopes into the parent\n\t   scope. Later elaboration passes will use this vector to\n\t   further elaborate the array.\n\n\t   Note that the array is ordered from LSB to MSB. We will use\n\t   that fact in the main elaborate to connect things in the\n\t   correct order. */\n      sc->instance_arrays[get_name()] = instances;\n}\n\n/*\n * The isn't really able to create new scopes, but it does create the\n * event name in the current scope, so can be done during the\n * elaborate_scope scan. Note that the name_ of the PEvent object has\n * no hierarchy, but neither does the NetEvent, until it is stored in\n * the NetScope object.\n */\nvoid PEvent::elaborate_scope(Design*, NetScope*scope) const\n{\n      NetEvent*ev = new NetEvent(name_);\n      ev->lexical_pos(lexical_pos_);\n      ev->set_line(*this);\n      scope->add_event(ev);\n}\n\nvoid PFunction::elaborate_scope(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope->type() == NetScope::FUNC);\n\n        // Save a reference to the pform representation of the function\n        // in case we need to perform early elaboration.\n      scope->set_func_pform(this);\n\n        // Assume the function is a constant function until we\n        // find otherwise.\n      scope->is_const_func(true);\n\n      scope->add_typedefs(&typedefs);\n\n\t// Scan the parameters in the function, and store the information\n        // needed to evaluate the parameter expressions.\n\n      collect_scope_parameters(des, scope, parameters);\n\n      collect_scope_signals(scope, wires);\n\n\t// Scan through all the named events in this scope.\n      elaborate_scope_events_(des, scope, events);\n\n      if (statement_)\n\t    statement_->elaborate_scope(des, scope);\n}\n\nvoid PTask::elaborate_scope(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope->type() == NetScope::TASK);\n\n      scope->add_typedefs(&typedefs);\n\n\t// Scan the parameters in the task, and store the information\n        // needed to evaluate the parameter expressions.\n\n      collect_scope_parameters(des, scope, parameters);\n\n      collect_scope_signals(scope, wires);\n\n\t// Scan through all the named events in this scope.\n      elaborate_scope_events_(des, scope, events);\n\n      if (statement_)\n\t    statement_->elaborate_scope(des, scope);\n}\n\n\n/*\n * The base statement does not have sub-statements and does not\n * introduce any scope, so this is a no-op.\n */\nvoid Statement::elaborate_scope(Design*, NetScope*) const\n{\n}\n\n/*\n * When I get a behavioral block, check to see if it has a name. If it\n * does, then create a new scope for the statements within it,\n * otherwise use the current scope. Use the selected scope to scan the\n * statements that I contain.\n */\nvoid PBlock::elaborate_scope(Design*des, NetScope*scope) const\n{\n      NetScope*my_scope = scope;\n\n      if (pscope_name() != 0) {\n\t    hname_t use_name(pscope_name());\n\t    if (debug_scopes)\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Elaborate block scope \" << use_name\n\t\t       << \" within \" << scope_path(scope) << endl;\n\n\t      // The scope type is begin-end or fork-join. The\n\t      // sub-types of fork-join are not interesting to the scope.\n\t    my_scope = new NetScope(scope, use_name, bl_type_!=BL_SEQ\n\t\t\t\t    ? NetScope::FORK_JOIN\n\t\t\t\t    : NetScope::BEGIN_END);\n\t    my_scope->set_line(get_file(), get_lineno());\n            my_scope->is_auto(scope->is_auto());\n\t    my_scope->add_imports(&explicit_imports);\n\t    my_scope->add_typedefs(&typedefs);\n\n\t      // Scan the parameters in the scope, and store the information\n\t      // needed to evaluate the parameter expressions.\n\n            collect_scope_parameters(des, my_scope, parameters);\n\n\t    collect_scope_signals(my_scope, wires);\n\n              // Scan through all the named events in this scope.\n            elaborate_scope_events_(des, my_scope, events);\n      }\n\n      for (unsigned idx = 0 ;  idx < list_.size() ;  idx += 1)\n\t    list_[idx] -> elaborate_scope(des, my_scope);\n}\n\n/*\n * The case statement itself does not introduce scope, but contains\n * other statements that may be named blocks. So scan the case items\n * with the elaborate_scope method.\n */\nvoid PCase::elaborate_scope(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, items_);\n      for (unsigned idx = 0 ;  idx < (*items_).size() ;  idx += 1) {\n\t    ivl_assert(*this, (*items_)[idx]);\n\n\t    if (Statement*sp = (*items_)[idx]->stat)\n\t\t  sp -> elaborate_scope(des, scope);\n      }\n}\n\n/*\n * The conditional statement (if-else) does not introduce scope, but\n * the statements of the clauses may, so elaborate_scope the contained\n * statements.\n */\nvoid PCondit::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (if_)\n\t    if_ -> elaborate_scope(des, scope);\n\n      if (else_)\n\t    else_ -> elaborate_scope(des, scope);\n}\n\n/*\n * Statements that contain a further statement but do not\n * intrinsically add a scope need to elaborate_scope the contained\n * statement.\n */\nvoid PDelayStatement::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n\n/*\n * Statements that contain a further statement but do not\n * intrinsically add a scope need to elaborate_scope the contained\n * statement.\n */\nvoid PDoWhile::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n\n/*\n * Statements that contain a further statement but do not\n * intrinsically add a scope need to elaborate_scope the contained\n * statement.\n */\nvoid PEventStatement::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n\n/*\n * The standard says that we create an implicit scope for foreach\n * loops, but that is just to hold the index variables, and we'll\n * handle them by creating unique names. So just jump into the\n * contained statement for scope elaboration.\n */\nvoid PForeach::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n\n/*\n * Statements that contain a further statement but do not\n * intrinsically add a scope need to elaborate_scope the contained\n * statement.\n */\nvoid PForever::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n\n/*\n * Statements that contain a further statement but do not\n * intrinsically add a scope need to elaborate_scope the contained\n * statement.\n */\nvoid PForStatement::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n\n/*\n * Statements that contain a further statement but do not\n * intrinsically add a scope need to elaborate_scope the contained\n * statement.\n */\nvoid PRepeat::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n\n/*\n * Statements that contain a further statement but do not\n * intrinsically add a scope need to elaborate_scope the contained\n * statement.\n */\nvoid PWhile::elaborate_scope(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_ -> elaborate_scope(des, scope);\n}\n"
        },
        {
          "name": "elab_sig.cc",
          "type": "blob",
          "size": 37.23828125,
          "content": "/*\n * Copyright (c) 2000-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2012 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <typeinfo>\n# include  <cstdlib>\n# include  <iostream>\n\n# include  \"Module.h\"\n# include  \"PClass.h\"\n# include  \"PExpr.h\"\n# include  \"PGate.h\"\n# include  \"PGenerate.h\"\n# include  \"PPackage.h\"\n# include  \"PTask.h\"\n# include  \"PWire.h\"\n# include  \"Statement.h\"\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"netclass.h\"\n# include  \"netenum.h\"\n# include  \"netvector.h\"\n# include  \"netdarray.h\"\n# include  \"netparray.h\"\n# include  \"netqueue.h\"\n# include  \"netscalar.h\"\n# include  \"util.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n#if 0\n/* These functions are not currently used. */\nstatic bool get_const_argument(NetExpr*exp, verinum&res)\n{\n      switch (exp->expr_type()) {\n\t  case IVL_VT_REAL: {\n\t    NetECReal*cv = dynamic_cast<NetECReal*>(exp);\n\t    if (cv == 0) return false;\n\t    verireal tmp = cv->value();\n\t    res = verinum(tmp.as_long());\n\t    break;\n\t  }\n\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC: {\n\t    NetEConst*cv = dynamic_cast<NetEConst*>(exp);\n\t    if (cv == 0) return false;\n\t    res = cv->value();\n\t    break;\n\t  }\n\n\t  default:\n\t    ivl_assert(*exp, 0);;\n      }\n\n      return true;\n}\n\nstatic bool get_const_argument(NetExpr*exp, long&res)\n{\n      verinum tmp;\n      bool rc = get_const_argument(exp, tmp);\n      if (rc == false) return false;\n      res = tmp.as_long();\n      return true;\n}\n#endif\n\nvoid Statement::elaborate_sig(Design*, NetScope*) const\n{\n}\n\nstatic void sig_check_data_type(Design*des, NetScope*scope,\n\t\t\t        PWire *wire, NetNet *sig)\n{\n      ivl_type_t type = sig->net_type();\n\n      if (!type)\n\t    return;\n\n      if ((sig->type() == NetNet::WIRE) && (sig->data_type() != IVL_VT_LOGIC)) {\n\t    if (gn_cadence_types_flag) {\n\t\t  sig->type(NetNet::UNRESOLVED_WIRE);\n\t    } else {\n\t\t  cerr << wire->get_fileline() << \": error: Net `\"\n\t\t       << wire->basename() << \"` can not be of type `\"\n\t\t       << sig->data_type() << \"`.\" << endl;\n\t\t  des->errors++;\n\t    }\n      }\n\n      if (type->packed()) {\n\t    switch (type->base_type()) {\n\t    case IVL_VT_LOGIC: // 4-state packed is allowed by the standard\n\t    case IVL_VT_BOOL: // Icarus allows 2-state packed as an extension\n\t\t  return;\n\t    default:\n\t\t  break;\n\t    }\n      }\n\n      // Icarus allows real nets as an extension\n      if (type->base_type() == IVL_VT_REAL)\n\t    return;\n\n      if (wire->symbol_type() == PNamedItem::NET) {\n\t    cerr << wire->get_fileline() << \": error: Net `\"\n\t         << wire->basename() << \"` can not be of type `\"\n\t\t << sig->data_type() << \"`.\" << endl;\n\t    des->errors++;\n      } else if (scope->type() == NetScope::MODULE &&\n\t         sig->port_type() != NetNet::NOT_A_PORT) {\n\t    // Module ports only support wire types a the moment\n\t    cerr << wire->get_fileline() << \": sorry: Port `\"\n\t         << wire->basename() << \"` of module `\"\n\t         << scope->module_name()\n\t         << \"` with type `\" << sig->data_type()\n\t\t << \"` is not supported.\"\n\t         << endl;\n\t    des->errors++;\n      }\n}\n\nstatic void sig_check_port_type(Design*des, NetScope*scope,\n\t\t\t        PWire *wire, NetNet *sig)\n{\n      if (sig->port_type() == NetNet::PREF) {\n\t    cerr << wire->get_fileline() << \": sorry: \"\n\t\t << \"Reference ports not supported yet.\" << endl;\n\t    des->errors += 1;\n      }\n\n      // Some extra checks for module ports\n      if (scope->type() != NetScope::MODULE)\n\t    return;\n\n\t/* If the signal is an input and is also declared as a\n\t   reg, then report an error. In SystemVerilog a input\n\t   is allowed to be a register. It will get converted\n\t   to a unresolved wire when the port is connected. */\n\n      if (sig->port_type() == NetNet::PINPUT &&\n\t  sig->type() == NetNet::REG && !gn_var_can_be_uwire()) {\n\t    cerr << wire->get_fileline() << \": error: Port `\"\n\t\t << wire->basename() << \"` of module `\"\n\t\t << scope->module_name()\n\t\t << \"` is declared as input and as a reg type.\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (sig->port_type() == NetNet::PINOUT &&\n\t  sig->type() == NetNet::REG) {\n\t    cerr << wire->get_fileline() << \": error: Port `\"\n\t\t << wire->basename() << \"` of module `\"\n\t\t << scope->module_name()\n\t\t << \"` is declared as inout and as a reg type.\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (sig->port_type() == NetNet::PINOUT &&\n\t  sig->data_type() == IVL_VT_REAL) {\n\t    cerr << wire->get_fileline() << \": error: Port `\"\n\t\t << wire->basename() << \"` of module `\"\n\t\t << scope->module_name()\n\t\t << \"` is declared as a real inout port.\" << endl;\n\t    des->errors += 1;\n      }\n}\n\nbool PScope::elaborate_sig_wires_(Design*des, NetScope*scope) const\n{\n      bool flag = true;\n\n      for (map<perm_string,PWire*>::const_iterator wt = wires.begin()\n\t\t ; wt != wires.end() ; ++ wt ) {\n\n\t    PWire*cur = (*wt).second;\n\t    NetNet*sig = cur->elaborate_sig(des, scope);\n\n\t    if (!sig || sig->scope() != scope)\n\t\t  continue;\n\n\t    sig_check_data_type(des, scope, cur, sig);\n\t    sig_check_port_type(des, scope, cur, sig);\n\n      }\n\n      return flag;\n}\n\nstatic void elaborate_sig_funcs(Design*des, NetScope*scope,\n\t\t\t\tconst map<perm_string,PFunction*>&funcs)\n{\n      typedef map<perm_string,PFunction*>::const_iterator mfunc_it_t;\n\n      for (mfunc_it_t cur = funcs.begin()\n\t\t ; cur != funcs.end() ; ++ cur ) {\n\n\t    hname_t use_name ( (*cur).first );\n\t    NetScope*fscope = scope->child(use_name);\n\t    if (fscope == 0) {\n\t\t  cerr << (*cur).second->get_fileline() << \": internal error: \"\n\t\t       << \"Child scope for function \" << (*cur).first\n\t\t       << \" missing in \" << scope_path(scope) << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    if (debug_elaborate) {\n\t\t  cerr << cur->second->get_fileline() << \": elaborate_sig_funcs: \"\n\t\t       << \"Elaborate function \" << use_name\n\t\t       << \" in \" << scope_path(fscope) << endl;\n\t    }\n\n\t    cur->second->elaborate_sig(des, fscope);\n      }\n}\n\nstatic void elaborate_sig_tasks(Design*des, NetScope*scope,\n\t\t\t\tconst map<perm_string,PTask*>&tasks)\n{\n      typedef map<perm_string,PTask*>::const_iterator mtask_it_t;\n\n      for (mtask_it_t cur = tasks.begin()\n\t\t ; cur != tasks.end() ; ++ cur ) {\n\t    NetScope*tscope = scope->child( hname_t((*cur).first) );\n\t    ivl_assert(*(*cur).second, tscope);\n\t    (*cur).second->elaborate_sig(des, tscope);\n      }\n}\n\nstatic void elaborate_sig_classes(Design*des, NetScope*scope,\n\t\t\t\t  const map<perm_string,PClass*>&classes)\n{\n      for (map<perm_string,PClass*>::const_iterator cur = classes.begin()\n\t\t ; cur != classes.end() ; ++ cur) {\n\t    netclass_t*use_class = scope->find_class(des, cur->second->pscope_name());\n\t    use_class->elaborate_sig(des, cur->second);\n      }\n}\n\nbool PPackage::elaborate_sig(Design*des, NetScope*scope) const\n{\n      bool flag = true;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PPackage::elaborate_sig: \"\n\t\t << \"Start package scope=\" << scope_path(scope) << endl;\n      }\n\n      flag = elaborate_sig_wires_(des, scope) && flag;\n\n\t// After all the wires are elaborated, we are free to\n\t// elaborate the ports of the tasks defined within this\n\t// module. Run through them now.\n\n      elaborate_sig_funcs(des, scope, funcs);\n      elaborate_sig_tasks(des, scope, tasks);\n      elaborate_sig_classes(des, scope, classes);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PPackage::elaborate_sig: \"\n\t\t << \"Done package scope=\" << scope_path(scope)\n\t\t << \", flag=\" << flag << endl;\n      }\n\n      return flag;\n}\n\nbool Module::elaborate_sig(Design*des, NetScope*scope) const\n{\n      bool flag = true;\n\n\t// Scan all the ports of the module, and make sure that each\n\t// is connected to wires that have port declarations.\n      for (unsigned idx = 0 ;  idx < ports.size() ;  idx += 1) {\n\t    Module::port_t*pp = ports[idx];\n\t    if (pp == 0)\n\t\t  continue;\n\n\t      // The port has a name and an array of expressions. The\n\t      // expression are all identifiers that should reference\n\t      // wires within the scope.\n\t    map<perm_string,PWire*>::const_iterator wt;\n\t    for (unsigned cc = 0 ;  cc < pp->expr.size() ;  cc += 1) {\n\t\t  pform_name_t port_path (pp->expr[cc]->path().name);\n\t\t    // A concatenated wire of a port really should not\n\t\t    // have any hierarchy.\n\t\t  if (port_path.size() != 1) {\n\t\t\tcerr << get_fileline() << \": internal error: \"\n\t\t\t     << \"Port \" << port_path << \" has a funny name?\"\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\n\t\t  wt = wires.find(peek_tail_name(port_path));\n\n\t\t  if (wt == wires.end()) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Port \" << port_path << \" (\"\n\t\t\t     << (idx+1) << \") of module \" << mod_name()\n\t\t\t     << \" is not declared within module.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  if ((*wt).second->get_port_type() == NetNet::NOT_A_PORT) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Port \" << pp->expr[cc]->path() << \" (\"\n\t\t\t     << (idx+1) << \") of module \" << mod_name()\n\t\t\t     << \" has no direction declaration.\"\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t    }\n      }\n\n      flag = elaborate_sig_wires_(des, scope) && flag;\n\n\t// Run through all the generate schemes to elaborate the\n\t// signals that they hold. Note that the generate schemes hold\n\t// the scopes that they instantiated, so we don't pass any\n\t// scope in.\n      typedef list<PGenerate*>::const_iterator generate_it_t;\n      for (generate_it_t cur = generate_schemes.begin()\n\t\t ; cur != generate_schemes.end() ; ++ cur ) {\n\t    (*cur) -> elaborate_sig(des, scope);\n      }\n\n\t// Get all the gates of the module and elaborate them by\n\t// connecting them to the signals. The gate may be simple or\n\t// complex. What we are looking for is gates that are modules\n\t// that can create scopes and signals.\n\n      const list<PGate*>&gl = get_gates();\n\n      for (list<PGate*>::const_iterator gt = gl.begin()\n\t\t ; gt != gl.end() ; ++ gt ) {\n\n\t    flag &= (*gt)->elaborate_sig(des, scope);\n      }\n\n\t// After all the wires are elaborated, we are free to\n\t// elaborate the ports of the tasks defined within this\n\t// module. Run through them now.\n\n      elaborate_sig_funcs(des, scope, funcs);\n      elaborate_sig_tasks(des, scope, tasks);\n      elaborate_sig_classes(des, scope, classes);\n\n\t// initial and always blocks may contain begin-end and\n\t// fork-join blocks that can introduce scopes. Therefore, I\n\t// get to scan processes here.\n\n      typedef list<PProcess*>::const_iterator proc_it_t;\n\n      for (proc_it_t cur = behaviors.begin()\n\t\t ; cur != behaviors.end() ; ++ cur ) {\n\n\t    (*cur) -> statement() -> elaborate_sig(des, scope);\n      }\n\n      return flag;\n}\n\nvoid netclass_t::elaborate_sig(Design*des, PClass*pclass)\n{\n\t// Collect the properties, elaborate them, and add them to the\n\t// elaborated class definition.\n      for (map<perm_string,struct class_type_t::prop_info_t>::iterator cur = pclass->type->properties.begin()\n\t\t ; cur != pclass->type->properties.end() ; ++ cur) {\n\n\t    ivl_type_t use_type = cur->second.type->elaborate_type(des, class_scope_);\n\t    if (debug_scopes) {\n\t\t  cerr << pclass->get_fileline() << \": elaborate_scope_class: \"\n\t\t       << \"  Property \" << cur->first\n\t\t       << \" type=\" << *use_type << endl;\n\t    }\n\n\t    if (dynamic_cast<const netqueue_t *> (use_type)) {\n\t\t  cerr << cur->second.get_fileline() << \": sorry: \"\n\t\t       << \"Queues inside classes are not yet supported.\" << endl;\n\t\t  des->errors++;\n\t    }\n\t    set_property(cur->first, cur->second.qual, use_type);\n\n\t    if (! cur->second.qual.test_static())\n\t\t  continue;\n\n\t    if (debug_elaborate) {\n\t\t  cerr << pclass->get_fileline() << \": netclass_t::elaborate_sig: \"\n\t\t       << \"Elaborate static property \" << cur->first\n\t\t       << \" as signal in scope \" << scope_path(class_scope_)\n\t\t       << \".\" << endl;\n\t    }\n\n\t    /* NetNet*sig = */ new NetNet(class_scope_, cur->first, NetNet::REG,\n\t\t\t\t\t  use_type);\n      }\n\n      for (map<perm_string,PFunction*>::iterator cur = pclass->funcs.begin()\n\t\t ; cur != pclass->funcs.end() ; ++ cur) {\n\t    if (debug_elaborate) {\n\t\t  cerr << cur->second->get_fileline() << \": netclass_t::elaborate_sig: \"\n\t\t       << \"Elaborate signals in function method \" << cur->first << endl;\n\t    }\n\n\t    NetScope*scope = class_scope_->child( hname_t(cur->first) );\n\t    ivl_assert(*cur->second, scope);\n\t    cur->second->elaborate_sig(des, scope);\n      }\n\n      for (map<perm_string,PTask*>::iterator cur = pclass->tasks.begin()\n\t\t ; cur != pclass->tasks.end() ; ++ cur) {\n\t    if (debug_elaborate) {\n\t\t  cerr << cur->second->get_fileline() << \": netclass_t::elaborate_sig: \"\n\t\t       << \"Elaborate signals in task method \" << cur->first << endl;\n\t    }\n\n\t    NetScope*scope = class_scope_->child( hname_t(cur->first) );\n\t    ivl_assert(*cur->second, scope);\n\t    cur->second->elaborate_sig(des, scope);\n      }\n\n}\n\nbool PGate::elaborate_sig(Design*, NetScope*) const\n{\n      return true;\n}\n\nbool PGBuiltin::elaborate_sig(Design*, NetScope*) const\n{\n      return true;\n}\n\nbool PGAssign::elaborate_sig(Design*, NetScope*) const\n{\n      return true;\n}\n\nbool PGModule::elaborate_sig_mod_(Design*des, NetScope*scope,\n\t\t\t\t  Module*rmod) const\n{\n      bool flag = true;\n\n      NetScope::scope_vec_t instance = scope->instance_arrays[get_name()];\n\n      for (unsigned idx = 0 ;  idx < instance.size() ;  idx += 1) {\n\t      // I know a priori that the elaborate_scope created the scope\n\t      // already, so just look it up as a child of the current scope.\n\t    NetScope*my_scope = instance[idx];\n\t    ivl_assert(*this, my_scope);\n\n\t    if (my_scope->parent() != scope) {\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"Instance \" << scope_path(my_scope)\n\t\t       << \" is in parent \" << scope_path(my_scope->parent())\n\t\t       << \" instead of \" << scope_path(scope)\n\t\t       << endl;\n\t    }\n\t    ivl_assert(*this, my_scope->parent() == scope);\n\n\t    if (! rmod->elaborate_sig(des, my_scope))\n\t\t  flag = false;\n\n      }\n\n      return flag;\n}\n\n\t// Not currently used.\n#if 0\nbool PGModule::elaborate_sig_udp_(Design*des, NetScope*scope, PUdp*udp) const\n{\n      return true;\n}\n#endif\n\nbool PGenerate::elaborate_sig(Design*des,  NetScope*container) const\n{\n      if (directly_nested)\n\t    return elaborate_sig_direct_(des, container);\n\n      bool flag = true;\n\n\t// Handle the special case that this is a CASE scheme. In this\n\t// case the PGenerate itself does not have the generated\n\t// item. Look instead for the case ITEM that has a scope\n\t// generated for it.\n      if (scheme_type == PGenerate::GS_CASE) {\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: generate case\"\n\t\t       << \" elaborate_sig in scope \"\n\t\t       << scope_path(container) << \".\" << endl;\n\n\t    typedef list<PGenerate*>::const_iterator generate_it_t;\n\t    for (generate_it_t cur = generate_schemes.begin()\n\t\t       ; cur != generate_schemes.end() ; ++ cur ) {\n\t\t  PGenerate*item = *cur;\n\t\t  if (item->directly_nested || !item->scope_list_.empty()) {\n\t\t\tflag &= item->elaborate_sig(des, container);\n\t\t  }\n\t    }\n\t    return flag;\n      }\n\n      typedef list<NetScope*>::const_iterator scope_list_it_t;\n      for (scope_list_it_t cur = scope_list_.begin()\n\t\t ; cur != scope_list_.end() ; ++ cur ) {\n\n\t    NetScope*scope = *cur;\n\n\t    if (scope->parent() != container)\n\t\t  continue;\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: Elaborate nets in \"\n\t\t       << \"scope \" << scope_path(*cur)\n\t\t       << \" in generate \" << id_number << endl;\n\t    flag = elaborate_sig_(des, *cur) & flag;\n      }\n\n      return flag;\n}\n\nbool PGenerate::elaborate_sig_direct_(Design*des, NetScope*container) const\n{\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": debug: \"\n\t\t << \"Direct nesting \" << scope_name\n\t\t << \" (scheme_type=\" << scheme_type << \")\"\n\t\t << \" elaborate_sig in scope \"\n\t\t << scope_path(container) << \".\" << endl;\n\n\t// Elaborate_sig for a direct nested generated scheme knows\n\t// that there are only sub_schemes to be elaborated.  There\n\t// should be exactly 1 active generate scheme, search for it\n\t// using this loop.\n      bool flag = true;\n      typedef list<PGenerate*>::const_iterator generate_it_t;\n      for (generate_it_t cur = generate_schemes.begin()\n\t\t ; cur != generate_schemes.end() ; ++ cur ) {\n\t    PGenerate*item = *cur;\n\t    if (item->scheme_type == PGenerate::GS_CASE) {\n\t\t  for (generate_it_t icur = item->generate_schemes.begin()\n\t\t\t     ; icur != item->generate_schemes.end() ; ++ icur ) {\n\t\t\tPGenerate*case_item = *icur;\n\t\t\tif (case_item->directly_nested || !case_item->scope_list_.empty()) {\n\t\t\t      flag &= case_item->elaborate_sig(des, container);\n\t\t\t}\n\t\t  }\n\t    } else {\n\t\t  if (item->directly_nested || !item->scope_list_.empty()) {\n\t\t\t  // Found the item, and it is direct nested.\n\t\t\tflag &= item->elaborate_sig(des, container);\n\t\t  }\n\t    }\n      }\n      return flag;\n}\n\nbool PGenerate::elaborate_sig_(Design*des, NetScope*scope) const\n{\n\t// Scan the declared PWires to elaborate the obvious signals\n\t// in the current scope.\n      typedef map<perm_string,PWire*>::const_iterator wires_it_t;\n      for (wires_it_t wt = wires.begin()\n\t\t ; wt != wires.end() ; ++ wt ) {\n\n\t    PWire*cur = (*wt).second;\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: Elaborate PWire \"\n\t\t       << cur->basename() << \" in scope \" << scope_path(scope) << endl;\n\n\t    cur->elaborate_sig(des, scope);\n      }\n\n      elaborate_sig_funcs(des, scope, funcs);\n      elaborate_sig_tasks(des, scope, tasks);\n\n      typedef list<PGenerate*>::const_iterator generate_it_t;\n      for (generate_it_t cur = generate_schemes.begin()\n\t\t ; cur != generate_schemes.end() ; ++ cur ) {\n\t    (*cur) -> elaborate_sig(des, scope);\n      }\n\n      typedef list<PGate*>::const_iterator pgate_list_it_t;\n      for (pgate_list_it_t cur = gates.begin()\n\t\t ; cur != gates.end() ; ++ cur ) {\n\t    (*cur) ->elaborate_sig(des, scope);\n      }\n\n      typedef list<PProcess*>::const_iterator proc_it_t;\n      for (proc_it_t cur = behaviors.begin()\n\t\t ; cur != behaviors.end() ; ++ cur ) {\n\t    (*cur) -> statement() -> elaborate_sig(des, scope);\n      }\n\n\n      return true;\n}\n\n\n/*\n * A function definition exists within an elaborated module. This\n * matters when elaborating signals, as the ports of the function are\n * created as signals/variables for each instance of the\n * function. That is why PFunction has an elaborate_sig method.\n */\nvoid PFunction::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (scope->elab_stage() > 1)\n            return;\n\n      scope->set_elab_stage(2);\n\n      perm_string fname = scope->basename();\n      ivl_assert(*this, scope->type() == NetScope::FUNC);\n\n      elaborate_sig_wires_(des, scope);\n\n      NetNet*ret_sig;\n      if (gn_system_verilog() && (fname==\"new\" || fname==\"new@\")) {\n\t      // Special case: this is a constructor, so the return\n\t      // signal is also the first argument. For example, the\n\t      // source code for the definition may be:\n\t      //   function new(...);\n\t      //   endfunction\n\t      // In this case, the \"@\" port (THIS_TOKEN) is the synthetic\n\t      // \"this\" argument and we also use it as a return value at\n\t      // the same time.\n\t    ret_sig = scope->find_signal(perm_string::literal(THIS_TOKEN));\n\t    ivl_assert(*this, ret_sig);\n\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": PFunction::elaborate_sig: \"\n\t\t       << \"Scope \" << scope_path(scope)\n\t\t       << \" is a CONSTRUCTOR, so use \\\"this\\\" argument\"\n\t\t       << \" as return value.\" << endl;\n\n      } else {\n\t    ivl_type_t ret_type;\n\n\t    if (return_type_) {\n\t\t  if (dynamic_cast<const struct void_type_t*> (return_type_)) {\n\t\t\tret_type = 0;\n\t\t  } else {\n\t\t\tret_type = return_type_->elaborate_type(des, scope->parent());\n\t\t\tivl_assert(*this, ret_type);\n\t\t  }\n\t    } else {\n\t\t  netvector_t*tmp = new netvector_t(IVL_VT_LOGIC);\n\t\t  ret_type = tmp;\n\t    }\n\n\t    if (ret_type) {\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PFunction::elaborate_sig: \"\n\t\t\t     << \"return type: \" << *ret_type << endl;\n\t\t\tif (return_type_)\n\t\t\t      return_type_->pform_dump(cerr, 8);\n\t\t  }\n\t\t  ret_sig = new NetNet(scope, fname, NetNet::REG, ret_type);\n\n\t\t  ret_sig->set_line(*this);\n\t\t  ret_sig->port_type(NetNet::POUTPUT);\n\t    } else {\n\t\t  ret_sig = 0;\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PFunction::elaborate_sig: \"\n\t\t\t     << \"Detected that function is void.\" << endl;\n\t\t  }\n\t    }\n      }\n\n      vector<NetNet*>ports;\n      vector<NetExpr*>pdef;\n      vector<perm_string> port_names;\n      elaborate_sig_ports_(des, scope, ports, pdef, port_names);\n\n      NetFuncDef*def = new NetFuncDef(scope, ret_sig, ports, pdef);\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \": PFunction::elaborate_sig: \"\n\t\t << \"Attach function definition \" << scope_path(scope)\n\t\t << \" with ret_sig width=\" << (ret_sig? ret_sig->vector_width() : 0)\n\t\t << \".\" << endl;\n\n      scope->set_func_def(def);\n\n\t// Look for further signals in the sub-statement\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\n/*\n * A task definition is a scope within an elaborated module. When we\n * are elaborating signals, the scopes have already been created, as\n * have the reg objects that are the parameters of this task. The\n * elaborate_sig method of PTask is therefore left to connect the\n * signals to the ports of the NetTaskDef definition. We know for\n * certain that signals exist (They are in my scope!) so the port\n * binding is sure to work.\n */\nvoid PTask::elaborate_sig(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope->type() == NetScope::TASK);\n\n      elaborate_sig_wires_(des, scope);\n\n      vector<NetNet*>ports;\n      vector<NetExpr*>pdefs;\n      vector<perm_string> port_names;\n      elaborate_sig_ports_(des, scope, ports, pdefs, port_names);\n      NetTaskDef*def = new NetTaskDef(scope, ports, pdefs);\n      scope->set_task_def(def);\n\n\t// Look for further signals in the sub-statement\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PTaskFunc::elaborate_sig_ports_(Design*des, NetScope*scope,\n\t\t\t\t     vector<NetNet*> &ports,\n\t\t\t\t     vector<NetExpr*> &pdefs,\n\t\t\t\t     vector<perm_string> &port_names) const\n{\n      if (ports_ == 0) {\n\t    ports.clear();\n\t    pdefs.clear();\n\t    port_names.clear();\n\n\t      /* Make sure the function has at least one input\n\t\t port. If it fails this test, print an error\n\t\t message. Keep going so we can find more errors. */\n\t    if (scope->type()==NetScope::FUNC && !gn_system_verilog()) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Function \" << scope->basename()\n\t\t       << \" has no ports.\" << endl;\n\t\t  cerr << get_fileline() << \":      : \"\n\t\t       << \"Functions must have at least one input port.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    return;\n      }\n\n      ports.resize(ports_->size());\n      pdefs.resize(ports_->size());\n      port_names.resize(ports_->size());\n\n      for (size_t idx = 0 ; idx < ports_->size() ; idx += 1) {\n\n\t    perm_string port_name = ports_->at(idx).port->basename();\n\n\t    ports[idx] = 0;\n\t    pdefs[idx] = 0;\n\t    NetNet*tmp = scope->find_signal(port_name);\n\t    NetExpr*tmp_def = 0;\n\t    if (tmp == 0) {\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"task/function \" << scope_path(scope)\n\t\t       << \" is missing port \" << port_name << \".\" << endl;\n\t\t  scope->dump(cerr);\n\t\t  cerr << get_fileline() << \": Continuing...\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t      // If the port has a default expression, elaborate\n\t      // that expression here.\n\t    if (ports_->at(idx).defe != 0) {\n\t\t  if (tmp->port_type() == NetNet::PINPUT) {\n\t\t\t  // Elaborate a class port default in the context of\n\t\t\t  // the class type.\n\t\t\tif (tmp->data_type() == IVL_VT_CLASS) {\n\t\t\t      tmp_def = elab_and_eval(des, scope,\n\t\t\t                              ports_->at(idx).defe,\n\t\t\t                              tmp->net_type(),\n\t\t\t                              scope->need_const_func());\n\t\t\t} else {\n\t\t\t      tmp_def = elab_and_eval(des, scope,\n\t\t\t                              ports_->at(idx).defe,\n\t\t\t                              -1,\n\t\t\t                              scope->need_const_func());\n\t\t\t}\n\t\t\tif (tmp_def == 0) {\n\t\t\t      cerr << get_fileline()\n\t\t\t\t   << \": error: Unable to evaluate \"\n\t\t\t\t   << *ports_->at(idx).defe\n\t\t\t\t   << \" as a port default expression.\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t}\n\t\t  } else {\n\t\t\tcerr << get_fileline() << \": sorry: Default arguments \"\n\t\t\t        \"for subroutine output or inout ports are not \"\n\t\t\t        \"yet supported.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t    }\n\n\t    if (tmp->port_type() == NetNet::NOT_A_PORT) {\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"task/function \" << scope_path(scope)\n\t\t       << \" port \" << port_name\n\t\t       << \" is a port but is not a port?\" << endl;\n\t\t  des->errors += 1;\n\t\t  scope->dump(cerr);\n\t\t  continue;\n\t    }\n\n\t    ports[idx] = tmp;\n\t    port_names[idx] = port_name;\n\t    pdefs[idx] = tmp_def;\n\t    if (scope->type()==NetScope::FUNC && tmp->port_type()!=NetNet::PINPUT) {\n\t\t  cerr << tmp->get_fileline() << \": error: \"\n\t\t       << \"Function \" << scope_path(scope)\n\t\t       << \" port \" << port_name\n\t\t       << \" is not an input port.\" << endl;\n\t\t  cerr << tmp->get_fileline() << \":      : \"\n\t\t       << \"Function arguments must be input ports.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    if (tmp->unpacked_dimensions() != 0) {\n\t\t  cerr << get_fileline() << \": sorry: Subroutine ports with \"\n\t\t\t  \"unpacked dimensions are not yet supported.\" << endl;\n\t\t des->errors += 1;\n\t    }\n      }\n}\n\nvoid PBlock::elaborate_sig(Design*des, NetScope*scope) const\n{\n      NetScope*my_scope = scope;\n\n      if (pscope_name() != 0) {\n\t    hname_t use_name (pscope_name());\n\t    my_scope = scope->child(use_name);\n\t    if (my_scope == 0) {\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"Unable to find child scope \" << pscope_name()\n\t\t       << \" in this context?\" << endl;\n\t\t  des->errors += 1;\n\t\t  my_scope = scope;\n\t    } else {\n\t\t  if (debug_elaborate)\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"elaborate_sig descending into \"\n\t\t\t     << scope_path(my_scope) << \".\" << endl;\n\n\t\t  elaborate_sig_wires_(des, my_scope);\n\t    }\n      }\n\n\t// elaborate_sig in the statements included in the\n\t// block. There may be named blocks in there.\n      for (unsigned idx = 0 ;  idx < list_.size() ;  idx += 1)\n\t    list_[idx] -> elaborate_sig(des, my_scope);\n}\n\nvoid PCase::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (items_ == 0)\n\t    return;\n\n      for (unsigned idx = 0 ; idx < items_->size() ; idx += 1) {\n\t    if ( (*items_)[idx]->stat )\n\t\t  (*items_)[idx]->stat ->elaborate_sig(des,scope);\n      }\n}\n\nvoid PCondit::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (if_)\n\t    if_->elaborate_sig(des, scope);\n      if (else_)\n\t    else_->elaborate_sig(des, scope);\n}\n\nvoid PDelayStatement::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PDoWhile::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PEventStatement::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PForeach::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PForever::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PForStatement::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PRepeat::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nvoid PWhile::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (statement_)\n\t    statement_->elaborate_sig(des, scope);\n}\n\nbool test_ranges_eeq(const netranges_t&lef, const netranges_t&rig)\n{\n      if (lef.size() != rig.size())\n\t    return false;\n\n      netranges_t::const_iterator lcur = lef.begin();\n      netranges_t::const_iterator rcur = rig.begin();\n      while (lcur != lef.end()) {\n\t    if (lcur->get_msb() != rcur->get_msb())\n\t\t  return false;\n\t    if (lcur->get_lsb() != rcur->get_lsb())\n\t\t  return false;\n\n\t    ++ lcur;\n\t    ++ rcur;\n      }\n\n      return true;\n}\n\nivl_type_t PWire::elaborate_type(Design*des, NetScope*scope,\n\t\t\t         const netranges_t &packed_dimensions) const\n{\n      vector_type_t *vec_type = dynamic_cast<vector_type_t*>(set_data_type_.get());\n      if (set_data_type_ && !vec_type) {\n\t    ivl_assert(*this, packed_dimensions.empty());\n\t    return set_data_type_->elaborate_type(des, scope);\n      }\n\n      // Fallback method. Create vector type.\n\n      ivl_variable_type_t use_data_type;\n      if (vec_type) {\n\t    use_data_type = vec_type->base_type;\n      } else {\n\t    use_data_type = IVL_VT_LOGIC;\n      }\n\n      if (use_data_type == IVL_VT_NO_TYPE) {\n\t    use_data_type = IVL_VT_LOGIC;\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PWire::elaborate_sig: \"\n\t\t       << \"Signal \" << name_\n\t\t       << \" in scope \" << scope_path(scope)\n\t\t       << \" defaults to data type \" << use_data_type << endl;\n\t    }\n      }\n\n      ivl_assert(*this, use_data_type == IVL_VT_LOGIC ||\n\t\t\tuse_data_type == IVL_VT_BOOL);\n\n      netvector_t*vec = new netvector_t(packed_dimensions, use_data_type);\n      vec->set_signed(get_signed());\n\n      return vec;\n}\n\n/*\n * Elaborate a source wire. The \"wire\" is the declaration of wires,\n * registers, ports and memories. The parser has already merged the\n * multiple properties of a wire (i.e., \"input wire\"), so come the\n * elaboration this creates an object in the design that represents the\n * defined item.\n */\nNetNet* PWire::elaborate_sig(Design*des, NetScope*scope)\n{\n\t// This sets the vector or array dimension size that will\n\t// cause a warning. For now, these warnings are permanently\n\t// enabled.\n      const long warn_dimension_size = 1 << 30;\n\n\t// Check if we elaborated this signal earlier because it was\n\t// used in another declaration.\n      if (NetNet*sig = scope->find_signal(name_))\n            return sig;\n\n      if (is_elaborating_) {\n\t    cerr << get_fileline() << \": error: Circular dependency \"\n\t\t    \"detected in declaration of '\" << name_ << \"'.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n      is_elaborating_ = true;\n\n      NetNet::Type wtype = type_;\n      if (wtype == NetNet::IMPLICIT)\n\t    wtype = NetNet::WIRE;\n\n\t// Certain contexts, such as arguments to functions, presume\n\t// \"reg\" instead of \"wire\". The parser reports these as\n\t// IMPLICIT_REG.\n      if (wtype == NetNet::IMPLICIT_REG)\n\t    wtype = NetNet::REG;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PWire::elaborate_sig: \"\n\t\t << \"Signal \" << basename()\n\t\t << \", wtype=\" << wtype;\n\t    if (set_data_type_)\n\t\t  cerr << \", set_data_type_=\" << *set_data_type_;\n\t    cerr << \", unpacked_.size()=\" << unpacked_.size()\n\t\t << endl;\n      }\n\n      unsigned wid = 1;\n      netranges_t packed_dimensions;\n\n      des->errors += error_cnt_;\n\n      if (port_set_ || net_set_) {\n\n\t    if (warn_implicit_dimensions\n\t\t&& port_set_ && net_set_\n\t\t&& net_.empty() && !port_.empty()) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t       << \"var/net declaration of \" << basename()\n\t\t       << \" inherits dimensions from port declaration.\" << endl;\n\t    }\n\n\t    if (warn_implicit_dimensions\n\t\t&& port_set_ && net_set_\n\t\t&& port_.empty() && !net_.empty()) {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t       << \"Port declaration of \" << basename()\n\t\t       << \" inherits dimensions from var/net.\" << endl;\n\t    }\n\n\t    bool dimensions_ok = true;\n\t    netranges_t plist, nlist;\n\t    /* If they exist get the port definition MSB and LSB */\n\t    if (port_set_ && !port_.empty()) {\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PWire::elaborate_sig: \"\n\t\t\t     << \"Evaluate ranges for port \" << basename() << endl;\n\t\t  }\n\t\t  dimensions_ok &= evaluate_ranges(des, scope, this, plist, port_);\n\t    }\n            ivl_assert(*this, port_set_ || port_.empty());\n\n\t    /* If they exist get the net/etc. definition MSB and LSB */\n\t    if (net_set_ && !net_.empty() && dimensions_ok) {\n\t\t  nlist.clear();\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PWire::elaborate_sig: \"\n\t\t\t     << \"Evaluate ranges for net \" << basename() << endl;\n\t\t  }\n\t\t  dimensions_ok &= evaluate_ranges(des, scope, this, nlist, net_);\n\t    }\n            ivl_assert(*this, net_set_ || net_.empty());\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PWire::elaborate_sig: \"\n\t\t       << \"Calculated ranges for \" << basename()\n\t\t       << \". Now check for consistency.\" << endl;\n\t    }\n\n\t    /* We have a port size error. Skip this if the dimensions could not\n\t     * be evaluated since it will likely print nonsensical errors. */\n            if (port_set_ && net_set_ && !test_ranges_eeq(plist, nlist) &&\n\t        dimensions_ok) {\n\t\t  /* Scalar port with a vector net/etc. definition */\n\t\t  if (port_.empty()) {\n\t\t\tif (gn_io_range_error_flag) {\n\t\t\t      cerr << get_fileline()\n\t\t\t           << \": error: Scalar port ``\" << name_\n\t\t\t           << \"'' has a vectored net declaration \"\n\t\t\t\t   << nlist << \".\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t} else if (warn_anachronisms) {\n\t\t\t      cerr << get_fileline()\n\t\t\t           << \": warning: Scalar port ``\" << name_\n\t\t\t           << \"'' has a vectored net declaration \"\n\t\t\t\t   << nlist << \".\" << endl;\n\t\t\t}\n\t\t  }\n\n\t\t  /* Vectored port with a scalar net/etc. definition */\n\t\t  if (net_.empty()) {\n\t\t\tcerr << port_.front().first->get_fileline()\n\t\t\t     << \": error: Vectored port ``\"\n\t\t\t     << name_ << \"'' \" << plist\n\t\t\t     << \" has a scalar net declaration at \"\n\t\t\t     << get_fileline() << \".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\n\t\t  /* Both vectored, but they have different ranges. */\n\t\t  if (!port_.empty() && !net_.empty()) {\n\t\t\tcerr << port_.front().first->get_fileline()\n\t\t\t     << \": error: Vectored port ``\"\n\t\t\t     << name_ << \"'' \" << plist\n\t\t\t     << \" has a net declaration \" << nlist\n\t\t\t     << \" at \" << net_.front().first->get_fileline()\n\t\t\t     << \" that does not match.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n            }\n\n\t    packed_dimensions = net_set_ ? nlist : plist;\n\t    wid = netrange_width(packed_dimensions);\n\t    if (wid > warn_dimension_size) {\n\t\t  cerr << get_fileline() << \": warning: Vector size \"\n\t\t          \"is greater than \" << warn_dimension_size\n\t\t       << \".\" << endl;\n\t    }\n      }\n\n      unsigned nattrib = 0;\n      attrib_list_t*attrib_list = evaluate_attributes(attributes, nattrib,\n\t\t\t\t\t\t      des, scope);\n\n\t/* If the net type is supply0 or supply1, replace it\n\t   with a simple wire with a pulldown/pullup with supply\n\t   strength. In other words, transform:\n\n\t   supply0 foo;\n\n\t   to:\n\n\t   wire foo;\n\t   pulldown #(supply0) (foo);\n\n\t   This reduces the backend burden, and behaves exactly\n\t   the same. */\n\n      NetLogic*pull = 0;\n      if (wtype == NetNet::SUPPLY0 || wtype == NetNet::SUPPLY1) {\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Generate a SUPPLY pull for the \";\n\t\t  if (wtype == NetNet::SUPPLY0) cerr << \"supply0\";\n\t\t  else cerr << \"supply1\";\n\t\t  cerr << \" net.\" << endl;\n\t    }\n\n\t    NetLogic::TYPE pull_type = (wtype==NetNet::SUPPLY1)\n\t\t  ? NetLogic::PULLUP\n\t\t  : NetLogic::PULLDOWN;\n\t    pull = new NetLogic(scope, scope->local_symbol(),\n\t\t\t\t1, pull_type, wid);\n\t    pull->set_line(*this);\n\t    pull->pin(0).drive0(IVL_DR_SUPPLY);\n\t    pull->pin(0).drive1(IVL_DR_SUPPLY);\n\t    des->add_node(pull);\n\t    wtype = NetNet::WIRE;\n      }\n\n      ivl_type_t type = elaborate_type(des, scope, packed_dimensions);\n\t// Create the type for the unpacked dimensions. If the\n\t// unpacked_dimensions are empty this will just return the base type.\n      type = elaborate_array_type(des, scope, *this, type, unpacked_);\n\n      netranges_t unpacked_dimensions;\n\t// If this is an unpacked array extract the base type and unpacked\n\t// dimensions as these are separate properties of the NetNet.\n      while (const netuarray_t *atype = dynamic_cast<const netuarray_t*>(type)) {\n\t    unpacked_dimensions.insert(unpacked_dimensions.begin(),\n\t\t\t\t       atype->static_dimensions().begin(),\n\t\t\t\t       atype->static_dimensions().end());\n\t    type = atype->element_type();\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Create signal \" << wtype;\n\t    if (set_data_type_)\n\t\t  cout << \" \" << *set_data_type_;\n\t    cout << \" \" << name_ << unpacked_dimensions << \" in scope \"\n\t\t << scope_path(scope) << endl;\n      }\n\n      NetNet*sig = new NetNet(scope, name_, wtype, unpacked_dimensions, type);\n\n      if (wtype == NetNet::WIRE) sig->devirtualize_pins();\n      sig->set_line(*this);\n      sig->port_type(port_type_);\n      sig->lexical_pos(lexical_pos_);\n\n      if (ivl_discipline_t dis = get_discipline()) {\n\t    sig->set_discipline(dis);\n      }\n\n      if (pull)\n\t    connect(sig->pin(0), pull->pin(0));\n\n      for (unsigned idx = 0 ;  idx < nattrib ;  idx += 1)\n\t    sig->attribute(attrib_list[idx].key, attrib_list[idx].val);\n\n      sig->set_const(is_const_);\n\n      scope->rem_signal_placeholder(this);\n      is_elaborating_ = false;\n\n      return sig;\n}\n"
        },
        {
          "name": "elab_sig_analog.cc",
          "type": "blob",
          "size": 0.9208984375,
          "content": "/*\n * Copyright (c) 2008 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"AStatement.h\"\n\n# include  <cstdlib>\n# include  <iostream>\n\n"
        },
        {
          "name": "elab_type.cc",
          "type": "blob",
          "size": 13.8681640625,
          "content": "/*\n * Copyright (c) 2012-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"PExpr.h\"\n# include  \"PScope.h\"\n# include  \"pform_types.h\"\n# include  \"netlist.h\"\n# include  \"netclass.h\"\n# include  \"netdarray.h\"\n# include  \"netenum.h\"\n# include  \"netqueue.h\"\n# include  \"netparray.h\"\n# include  \"netscalar.h\"\n# include  \"netstruct.h\"\n# include  \"netvector.h\"\n# include  \"netmisc.h\"\n# include  <typeinfo>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * Elaborations of types may vary depending on the scope that it is\n * done in, so keep a per-scope cache of the results.\n */\nivl_type_t data_type_t::elaborate_type(Design*des, NetScope*scope)\n{\n      scope = find_scope(des, scope);\n\n      Definitions*use_definitions = scope;\n\n      map<Definitions*,ivl_type_t>::iterator pos = cache_type_elaborate_.lower_bound(use_definitions);\n\t  if (pos != cache_type_elaborate_.end() && pos->first == use_definitions)\n\t     return pos->second;\n\n      ivl_type_t tmp;\n      if (elaborating) {\n\t    des->errors++;\n\t    cerr << get_fileline() << \": error: \"\n\t         << \"Circular type definition found involving `\" << *this << \"`.\"\n\t\t << endl;\n\t    // Try to recover\n\t    tmp = netvector_t::integer_type();\n      } else {\n\t    elaborating = true;\n\t    tmp = elaborate_type_raw(des, scope);\n\t    elaborating = false;\n      }\n\n      cache_type_elaborate_.insert(pos, pair<NetScope*,ivl_type_t>(scope, tmp));\n      return tmp;\n}\n\nNetScope *data_type_t::find_scope(Design *, NetScope *scope) const\n{\n\treturn scope;\n}\n\nivl_type_t data_type_t::elaborate_type_raw(Design*des, NetScope*) const\n{\n      cerr << get_fileline() << \": internal error: \"\n\t   << \"Elaborate method not implemented for \" << typeid(*this).name()\n\t   << \".\" << endl;\n      des->errors += 1;\n      return 0;\n}\n\nivl_type_t atom_type_t::elaborate_type_raw(Design*des, NetScope*) const\n{\n      switch (type_code) {\n\t  case INTEGER:\n\t    return netvector_t::integer_type(signed_flag);\n\n\t  case TIME:\n\t    if (signed_flag)\n\t\t  return &netvector_t::time_signed;\n\t    else\n\t\t  return &netvector_t::time_unsigned;\n\n\t  case LONGINT:\n\t    if (signed_flag)\n\t\t  return &netvector_t::atom2s64;\n\t    else\n\t\t  return &netvector_t::atom2u64;\n\n\t  case INT:\n\t    if (signed_flag)\n\t\t  return &netvector_t::atom2s32;\n\t    else\n\t\t  return &netvector_t::atom2u32;\n\n\t  case SHORTINT:\n\t    if (signed_flag)\n\t\t  return &netvector_t::atom2s16;\n\t    else\n\t\t  return &netvector_t::atom2u16;\n\n\t  case BYTE:\n\t    if (signed_flag)\n\t\t  return &netvector_t::atom2s8;\n\t    else\n\t\t  return &netvector_t::atom2u8;\n\n\t  default:\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"atom_type_t type_code=\" << type_code << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n}\n\nivl_type_t class_type_t::elaborate_type_raw(Design*des, NetScope*scope) const\n{\n      return scope->find_class(des, name);\n}\n\n/*\n * elaborate_type_raw for enumerations is actually mostly performed\n * during scope elaboration so that the enumeration literals are\n * available at the right time. At that time, the netenum_t* object is\n * stashed in the scope so that I can retrieve it here.\n */\nivl_type_t enum_type_t::elaborate_type_raw(Design *des, NetScope *scope) const\n{\n      ivl_type_t base = base_type->elaborate_type(des, scope);\n\n      const class netvector_t *vec_type = dynamic_cast<const netvector_t*>(base);\n\n      if (!vec_type && !dynamic_cast<const netparray_t*>(base)) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Invalid enum base type `\" << *base << \"`.\"\n\t\t << endl;\n\t    des->errors++;\n      } else if (base->slice_dimensions().size() > 1) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Enum type must not have more than 1 packed dimension.\"\n\t\t << endl;\n\t    des->errors++;\n      }\n\n      bool integer_flag = false;\n      if (vec_type)\n\t    integer_flag = vec_type->get_isint();\n\n      netenum_t *type = new netenum_t(base, names->size(), integer_flag);\n      type->set_line(*this);\n\n      scope->add_enumeration_set(this, type);\n\n      return type;\n}\n\nivl_type_t vector_type_t::elaborate_type_raw(Design*des, NetScope*scope) const\n{\n      netranges_t packed;\n      if (pdims.get())\n\t    evaluate_ranges(des, scope, this, packed, *pdims);\n\n      netvector_t*tmp = new netvector_t(packed, base_type);\n      tmp->set_signed(signed_flag);\n      tmp->set_isint(integer_flag);\n      tmp->set_implicit(implicit_flag);\n\n      return tmp;\n}\n\nivl_type_t real_type_t::elaborate_type_raw(Design*, NetScope*) const\n{\n      switch (type_code_) {\n\t  case REAL:\n\t    return &netreal_t::type_real;\n\t  case SHORTREAL:\n\t    return &netreal_t::type_shortreal;\n      }\n      return 0;\n}\n\nivl_type_t string_type_t::elaborate_type_raw(Design*, NetScope*) const\n{\n      return &netstring_t::type_string;\n}\n\nivl_type_t parray_type_t::elaborate_type_raw(Design*des, NetScope*scope) const\n{\n      netranges_t packed;\n      if (dims.get())\n\t    evaluate_ranges(des, scope, this, packed, *dims);\n\n      ivl_type_t etype = base_type->elaborate_type(des, scope);\n      if (!etype->packed()) {\n\t\tcerr << this->get_fileline() << \" error: Packed array \";\n\t\tcerr << \"base-type `\";\n\t\tcerr << *base_type;\n\t\tcerr << \"` is not packed.\" << endl;\n\t\tdes->errors++;\n      }\n\n      return new netparray_t(packed, etype);\n}\n\nivl_type_t struct_type_t::elaborate_type_raw(Design*des, NetScope*scope) const\n{\n      netstruct_t*res = new netstruct_t;\n\n      res->set_line(*this);\n\n      res->packed(packed_flag);\n      res->set_signed(signed_flag);\n\n      if (union_flag)\n\t    res->union_flag(true);\n\n      for (list<struct_member_t*>::iterator cur = members->begin()\n\t\t ; cur != members->end() ; ++ cur) {\n\n\t      // Elaborate the type of the member.\n\t    struct_member_t*curp = *cur;\n\t    ivl_type_t mem_vec = curp->type->elaborate_type(des, scope);\n\t    if (mem_vec == 0)\n\t\t  continue;\n\n\t      // There may be several names that are the same type:\n\t      //   <data_type> name1, name2, ...;\n\t      // Process all the member, and give them a type.\n\t    for (list<decl_assignment_t*>::iterator cur_name = curp->names->begin()\n\t\t       ; cur_name != curp->names->end() ;  ++ cur_name) {\n\t\t  decl_assignment_t*namep = *cur_name;\n\n\t\t  if (packed_flag && namep->expr) {\n\t\t\tcerr << namep->expr->get_fileline() << \" error: \"\n\t\t\t     << \"Packed structs must not have default member values.\"\n\t\t\t     << endl;\n\t\t\tdes->errors++;\n\t\t  }\n\n\t\t  netstruct_t::member_t memb;\n\t\t  memb.name = namep->name.first;\n\t\t  memb.net_type = elaborate_array_type(des, scope, *this,\n\t\t\t\t\t\t       mem_vec, namep->index);\n\t\t  res->append_member(des, memb);\n\t    }\n      }\n\n      return res;\n}\n\nstatic ivl_type_t elaborate_darray_check_type(Design *des, const LineInfo &li,\n\t\t\t\t\t      ivl_type_t type,\n\t\t\t\t\t      const char *darray_type)\n{\n      if (dynamic_cast<const netvector_t*>(type) ||\n\t  dynamic_cast<const netparray_t*>(type) ||\n\t  dynamic_cast<const netreal_t*>(type) ||\n\t  dynamic_cast<const netstring_t*>(type))\n\t    return type;\n\n      cerr << li.get_fileline() << \": Sorry: \"\n           << darray_type << \" of type `\" << *type\n\t   << \"` is not yet supported.\" << endl;\n      des->errors++;\n\n      // Return something to recover\n      return new netvector_t(IVL_VT_LOGIC);\n}\n\nstatic ivl_type_t elaborate_queue_type(Design *des, NetScope *scope,\n\t\t\t\t       const LineInfo &li, ivl_type_t base_type,\n\t\t\t\t       PExpr *ridx)\n{\n      base_type = elaborate_darray_check_type(des, li, base_type, \"Queue\");\n\n      long max_idx = -1;\n      if (ridx) {\n\t    NetExpr*tmp = elab_and_eval(des, scope, ridx, -1, true);\n\t    NetEConst*cv = dynamic_cast<NetEConst*>(tmp);\n\t    if (cv == 0) {\n\t\t  cerr << li.get_fileline() << \": error: \"\n\t\t       << \"queue bound must be constant.\"\n\t\t       << endl;\n\t\t  des->errors++;\n\t    } else {\n\t\t  verinum res = cv->value();\n\t\t  if (res.is_defined()) {\n\t\t\tmax_idx = res.as_long();\n\t\t\tif (max_idx < 0) {\n\t\t\t      cerr << li.get_fileline() << \": error: \"\n\t\t\t\t   << \"queue bound must be positive (\"\n\t\t\t\t   << max_idx << \").\" << endl;\n\t\t\t      des->errors++;\n\t\t\t      max_idx = -1;\n\t\t\t}\n\t\t  } else {\n\t\t\tcerr << li.get_fileline() << \": error: \"\n\t\t\t     << \"queue bound must be defined.\"\n\t\t\t     << endl;\n\t\t\tdes->errors++;\n\t\t  }\n\t    }\n\t    delete cv;\n      }\n\n      return new netqueue_t(base_type, max_idx);\n}\n\n// If dims is not empty create a unpacked array type and clear dims, otherwise\n// return the base type. Also check that we actually support the base type.\nstatic ivl_type_t elaborate_static_array_type(Design *des, const LineInfo &li,\n\t\t\t\t\t      ivl_type_t base_type,\n\t\t\t\t\t      netranges_t &dims)\n{\n      if (dims.empty())\n\t    return base_type;\n\n      if (dynamic_cast<const netqueue_t*>(base_type)) {\n\t    cerr << li.get_fileline() << \": sorry: \"\n\t\t << \"array of queue type is not yet supported.\"\n\t\t << endl;\n\t    des->errors++;\n\t    // Recover\n\t    base_type = new netvector_t(IVL_VT_LOGIC);\n      } else if (dynamic_cast<const netdarray_t*>(base_type)) {\n\t    cerr << li.get_fileline() << \": sorry: \"\n\t\t << \"array of dynamic array type is not yet supported.\"\n\t\t << endl;\n\t    des->errors++;\n\t    // Recover\n\t    base_type = new netvector_t(IVL_VT_LOGIC);\n      }\n\n      ivl_type_t type = new netuarray_t(dims, base_type);\n      dims.clear();\n\n      return type;\n}\n\nivl_type_t elaborate_array_type(Design *des, NetScope *scope,\n\t\t\t        const LineInfo &li, ivl_type_t base_type,\n\t\t\t        const list<pform_range_t> &dims)\n{\n      const long warn_dimension_size = 1 << 30;\n      netranges_t dimensions;\n      dimensions.reserve(dims.size());\n\n      ivl_type_t type = base_type;\n\n      for (list<pform_range_t>::const_iterator cur = dims.begin();\n\t   cur != dims.end() ; ++cur) {\n\t    PExpr *lidx = cur->first;\n\t    PExpr *ridx = cur->second;\n\n\t    if (lidx == 0 && ridx == 0) {\n\t\t    // Special case: If we encounter an undefined dimensions,\n\t\t    // then turn this into a dynamic array and put all the\n\t\t    // packed dimensions there.\n\t\t  type = elaborate_static_array_type(des, li, type, dimensions);\n\t\t  type = elaborate_darray_check_type(des, li, type, \"Dynamic array\");\n\t\t  type = new netdarray_t(type);\n\t\t  continue;\n\t    } else if (dynamic_cast<PENull*>(lidx)) {\n\t\t    // Special case: Detect the mark for a QUEUE declaration,\n\t\t    // which is the dimensions [null:max_idx].\n\t\t  type = elaborate_static_array_type(des, li, type, dimensions);\n\t\t  type = elaborate_queue_type(des, scope, li, type, ridx);\n\t\t  continue;\n\t    }\n\n\t    long index_l, index_r;\n\t    evaluate_range(des, scope, &li, *cur, index_l, index_r);\n\n\t    if (abs(index_r - index_l) > warn_dimension_size) {\n\t\t  cerr << li.get_fileline() << \": warning: \"\n\t\t       << \"Array dimension is greater than \"\n\t\t       << warn_dimension_size << \".\"\n\t\t       << endl;\n\t    }\n\n\t    dimensions.push_back(netrange_t(index_l, index_r));\n      }\n\n      return elaborate_static_array_type(des, li, type, dimensions);\n}\n\nivl_type_t uarray_type_t::elaborate_type_raw(Design*des, NetScope*scope) const\n{\n      ivl_type_t btype = base_type->elaborate_type(des, scope);\n\n      return elaborate_array_type(des, scope, *this, btype, *dims.get());\n}\n\nivl_type_t typeref_t::elaborate_type_raw(Design*des, NetScope*s) const\n{\n      if (!s) {\n\t    // Try to recover\n\t    return new netvector_t(IVL_VT_LOGIC);\n      }\n\n      return type->elaborate_type(des, s);\n}\n\nNetScope *typeref_t::find_scope(Design *des, NetScope *s) const\n{\n        // If a scope has been specified use that as a starting point for the\n\t// search\n      if (scope)\n\t    s = des->find_package(scope->pscope_name());\n\n      return s;\n}\n\nivl_type_t typedef_t::elaborate_type(Design *des, NetScope *scope)\n{\n      if (!data_type.get()) {\n\t    cerr << get_fileline() << \": error: Undefined type `\" << name << \"`.\"\n\t\t << endl;\n\t    des->errors++;\n\n\t    // Try to recover\n\t    return netvector_t::integer_type();\n      }\n\n        // Search upwards from where the type was referenced\n      scope = scope->find_typedef_scope(des, this);\n      if (!scope) {\n\t    cerr << get_fileline() << \": sorry: \"\n\t         << \"Can not find the scope type definition `\" << name << \"`.\"\n\t\t << endl;\n\t    des->errors++;\n\n\t    // Try to recover\n\t    return netvector_t::integer_type();\n      }\n\n      ivl_type_t elab_type = data_type->elaborate_type(des, scope);\n      if (!elab_type)\n\t    return netvector_t::integer_type();\n\n      bool type_ok = true;\n      switch (basic_type) {\n      case ENUM:\n\t    type_ok = dynamic_cast<const netenum_t *>(elab_type);\n\t    break;\n      case STRUCT: {\n\t    const netstruct_t *struct_type = dynamic_cast<const netstruct_t *>(elab_type);\n\t    type_ok = struct_type && !struct_type->union_flag();\n\t    break;\n      }\n      case UNION: {\n\t    const netstruct_t *struct_type = dynamic_cast<const netstruct_t *>(elab_type);\n\t    type_ok = struct_type && struct_type->union_flag();\n\t    break;\n      }\n      case CLASS:\n\t    type_ok = dynamic_cast<const netclass_t *>(elab_type);\n\t    break;\n      default:\n\t    break;\n      }\n\n      if (!type_ok) {\n\t    cerr << data_type->get_fileline() << \" error: \"\n\t         << \"Unexpected type `\" << *elab_type << \"` for `\" << name\n\t\t << \"`. It was forward declared as `\" << basic_type\n\t\t << \"` at \" << get_fileline() << \".\"\n\t\t << endl;\n\t    des->errors++;\n      }\n\n      return elab_type;\n}\n\nivl_type_t type_parameter_t::elaborate_type_raw(Design *des, NetScope*scope) const\n{\n      ivl_type_t type;\n\n      scope->get_parameter(des, name, type);\n\n      // Recover\n      if (!type)\n\t    return netvector_t::integer_type();\n\n      return type;\n}\n"
        },
        {
          "name": "elaborate.cc",
          "type": "blob",
          "size": 236.466796875,
          "content": "/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n/*\n * Elaboration takes as input a complete parse tree and the name of a\n * root module, and generates as output the elaborated design. This\n * elaborated design is presented as a Module, which does not\n * reference any other modules. It is entirely self contained.\n */\n\n# include  <algorithm>\n# include  <typeinfo>\n# include  <climits>\n# include  <cstdlib>\n# include  <cstring>\n# include  <iostream>\n# include  <sstream>\n# include  <list>\n# include  \"pform.h\"\n# include  \"PClass.h\"\n# include  \"PEvent.h\"\n# include  \"PGenerate.h\"\n# include  \"PPackage.h\"\n# include  \"PScope.h\"\n# include  \"PSpec.h\"\n# include  \"PTimingCheck.h\"\n# include  \"netlist.h\"\n# include  \"netenum.h\"\n# include  \"netvector.h\"\n# include  \"netdarray.h\"\n# include  \"netparray.h\"\n# include  \"netscalar.h\"\n# include  \"netclass.h\"\n# include  \"netmisc.h\"\n# include  \"util.h\"\n# include  \"parse_api.h\"\n# include  \"compiler.h\"\n# include  \"ivl_assert.h\"\n# include \"map_named_args.h\"\n\nusing namespace std;\n\n// Implemented in elab_scope.cc\nextern void set_scope_timescale(Design*des, NetScope*scope, PScope*pscope);\n\nvoid PGate::elaborate(Design*, NetScope*) const\n{\n      cerr << \"internal error: what kind of gate? \" <<\n\t    typeid(*this).name() << endl;\n}\n\nunsigned PGate::calculate_array_size_(Design*des, NetScope*scope,\n\t\t\t\t      long&high, long&low) const\n{\n      if (ranges_ && ranges_->size() > 1) {\n\t    if (gn_system_verilog()) {\n\t\t  cerr << get_fileline() << \": sorry: Multi-dimensional\"\n\t\t       << \" arrays of instances are not yet supported.\" << endl;\n\t    } else {\n\t\t  cerr << get_fileline() << \": error: Multi-dimensional\"\n\t\t       << \" arrays of instances require SystemVerilog.\" << endl;\n\t    }\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      unsigned size = 1;\n      high = 0;\n      low = 0;\n\n      if (ranges_) {\n\t    if (!evaluate_range(des, scope, this, ranges_->front(), high, low))\n\t\treturn 0;\n\n\t    if (high > low)\n\t\t  size = high - low + 1;\n\t    else\n\t\t  size = low - high + 1;\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: PGate: Make array \"\n\t\t       << \"[\" << high << \":\" << low << \"]\" << \" of \"\n\t\t       << size << \" instances for \" << get_name() << endl;\n\t    }\n      }\n\n      return size;\n}\n\n/*\n * Elaborate the continuous assign. (This is *not* the procedural\n * assign.) Elaborate the lvalue and rvalue, and do the assignment.\n */\nvoid PGAssign::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      NetExpr* rise_time, *fall_time, *decay_time;\n      eval_delays(des, scope, rise_time, fall_time, decay_time, true);\n\n      ivl_drive_t drive0 = strength0();\n      ivl_drive_t drive1 = strength1();\n\n      ivl_assert(*this, pin(0));\n      ivl_assert(*this, pin(1));\n\n\t/* Elaborate the l-value. */\n      NetNet*lval = pin(0)->elaborate_lnet(des, scope);\n      if (lval == 0) {\n\t    return;\n      }\n\n\t// If this turns out to be an assignment to an unpacked array,\n\t// then handle that special case elsewhere.\n      if (lval->pin_count() > 1) {\n\t    elaborate_unpacked_array_(des, scope, lval);\n\t    return;\n      }\n\n      ivl_assert(*this, lval->pin_count() == 1);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PGAssign::elaborate: elaborated l-value\"\n\t\t << \" width=\" << lval->vector_width()\n\t\t << \", pin_count=\" << lval->pin_count() << endl;\n      }\n\n      NetExpr*rval_expr = elaborate_rval_expr(des, scope, lval->net_type(), pin(1));\n\n      if (rval_expr == 0) {\n\t    cerr << get_fileline() << \": error: Unable to elaborate r-value: \"\n\t\t << *pin(1) << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n\n      NetNet*rval = rval_expr->synthesize(des, scope, rval_expr);\n\n      if (rval == 0) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Failed to synthesize expression: \" << *rval_expr << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: PGAssign: elaborated r-value\"\n\t\t << \" width=\"<< rval->vector_width()\n\t\t << \", type=\"<< rval->data_type()\n\t\t << \", expr=\" << *rval_expr << endl;\n      }\n\n      ivl_assert(*this, lval && rval);\n      ivl_assert(*this, rval->pin_count() == 1);\n\n\t// Detect the case that the rvalue-expression is a simple\n\t// expression. In this case, we will need to create a driver\n\t// (later) to carry strengths.\n      bool need_driver_flag = false;\n      if (dynamic_cast<NetESignal*>(rval_expr) ||!rval->is_linked())\n\t    need_driver_flag = true;\n\n\t// expression elaboration should have caused the rval width to\n\t// match the l-value by now.\n      if (rval->vector_width() < lval->vector_width()) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"lval-rval width mismatch: \"\n\t\t << \"rval->vector_width()==\" << rval->vector_width()\n\t\t << \", lval->vector_width()==\" << lval->vector_width() << endl;\n      }\n      ivl_assert(*this, rval->vector_width() >= lval->vector_width());\n\n\t/* If the r-value insists on being larger than the l-value,\n\t   use a part select to chop it down down to size. */\n      if (lval->vector_width() < rval->vector_width()) {\n\t    NetPartSelect*tmp = new NetPartSelect(rval, 0,lval->vector_width(),\n\t\t\t\t\t\t  NetPartSelect::VP);\n\t    des->add_node(tmp);\n\t    tmp->set_line(*this);\n\t    netvector_t*osig_vec = new netvector_t(rval->data_type(),\n\t\t\t\t\t\t   lval->vector_width()-1,0);\n\t    NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t     NetNet::TRI, osig_vec);\n\t    osig->set_line(*this);\n\t    osig->local_flag(true);\n\t    connect(osig->pin(0), tmp->pin(0));\n\t    rval = osig;\n\t    need_driver_flag = false;\n      }\n\n\t/* When we are given a non-default strength value and if the drive\n\t * source is a bit, part, indexed select or a concatenation we need\n\t * to add a driver (BUFZ) to convey the strength information. */\n      if ((drive0 != IVL_DR_STRONG || drive1 != IVL_DR_STRONG) &&\n          ((dynamic_cast<NetESelect*>(rval_expr)) ||\n\t   (dynamic_cast<NetEConcat*>(rval_expr)))) {\n\t    need_driver_flag = true;\n      }\n\n      if (need_driver_flag) {\n\t    NetBUFZ*driver = new NetBUFZ(scope, scope->local_symbol(),\n\t\t\t\t\t rval->vector_width(), false);\n\t    driver->set_line(*this);\n\t    des->add_node(driver);\n\n\t    connect(rval->pin(0), driver->pin(1));\n\n\t    netvector_t*tmp_vec = new netvector_t(rval->data_type(),\n\t\t\t\t\t\t  rval->vector_width()-1,0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::WIRE, tmp_vec);\n\t    tmp->set_line(*this);\n\t    tmp->local_flag(true);\n\n\t    connect(driver->pin(0), tmp->pin(0));\n\n\t    rval = tmp;\n      }\n\n\t/* Set the drive and delays for the r-val. */\n\n      if (drive0 != IVL_DR_STRONG || drive1 != IVL_DR_STRONG)\n\t    rval->pin(0).drivers_drive(drive0, drive1);\n\n      if (rise_time || fall_time || decay_time)\n\t    rval->pin(0).drivers_delays(rise_time, fall_time, decay_time);\n\n      connect(lval->pin(0), rval->pin(0));\n\n      if (lval->local_flag())\n\t    delete lval;\n\n}\n\nNetNet *elaborate_unpacked_array(Design *des, NetScope *scope, const LineInfo &loc,\n\t\t\t         const NetNet *lval, PExpr *expr)\n{\n      NetNet *expr_net;\n      PEIdent* ident = dynamic_cast<PEIdent*> (expr);\n      if (!ident) {\n\t    if (dynamic_cast<PEConcat*> (expr)) {\n\t\t  cout << loc.get_fileline() << \": sorry: Continuous assignment\"\n\t\t       << \" of array concatenation is not yet supported.\"\n\t\t       << endl;\n\t\t  des->errors++;\n\t\t  return nullptr;\n\t    } else if (dynamic_cast<PEAssignPattern*> (expr)) {\n\t\t  auto net_expr = elaborate_rval_expr(des, scope, lval->array_type(), expr);\n\t\t  expr_net = net_expr->synthesize(des, scope, net_expr);\n\t    } else {\n\t\t  cout << loc.get_fileline() << \": error: Can not assign\"\n\t\t       << \" non-array expression `\" << *expr << \"` to array.\"\n\t\t       << endl;\n\t\t  des->errors++;\n\t\t  return nullptr;\n\t    }\n      } else {\n\t    expr_net = ident->elaborate_unpacked_net(des, scope);\n      }\n\n      if (!expr_net)\n\t    return nullptr;\n\n      auto const &lval_dims = lval->unpacked_dims();\n      auto const &expr_dims = expr_net->unpacked_dims();\n\n      if (expr_dims.empty()) {\n\t    cerr << loc.get_fileline() << \": error: Can not assign\"\n\t         << \" non-array identifier `\" << *expr << \"` to array.\"\n\t\t << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n      if (!netrange_equivalent(lval_dims, expr_dims)) {\n\t    cerr << loc.get_fileline() << \": error: Unpacked dimensions\"\n\t\t << \" are not compatible in array assignment.\" << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n      if (!lval->net_type()->type_equivalent(expr_net->net_type())) {\n\t    cerr << loc.get_fileline() << \": error: Element types are not\"\n\t         << \" compatible in array assignment.\" << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n      return expr_net;\n}\n\nvoid PGAssign::elaborate_unpacked_array_(Design*des, NetScope*scope, NetNet*lval) const\n{\n      NetNet *rval_net = elaborate_unpacked_array(des, scope, *this, lval, pin(1));\n      if (rval_net)\n\t    assign_unpacked_with_bufz(des, scope, lval, lval, rval_net);\n}\n\nvoid PGBuiltin::calculate_gate_and_lval_count_(unsigned&gate_count,\n                                               unsigned&lval_count) const\n{\n      switch (type()) {\n\t  case BUF:\n\t  case NOT:\n\t    if (pin_count() > 2) gate_count = pin_count() - 1;\n\t    else gate_count = 1;\n            lval_count = gate_count;\n\t    break;\n\t  case PULLDOWN:\n\t  case PULLUP:\n\t    gate_count = pin_count();\n            lval_count = gate_count;\n\t    break;\n\t  case TRAN:\n\t  case RTRAN:\n\t  case TRANIF0:\n\t  case TRANIF1:\n\t  case RTRANIF0:\n\t  case RTRANIF1:\n\t    gate_count = 1;\n            lval_count = 2;\n\t    break;\n\t  default:\n\t    gate_count = 1;\n            lval_count = 1;\n\t    break;\n      }\n}\n\nNetNode* PGBuiltin::create_gate_for_output_(Design*des, NetScope*scope,\n\t\t\t\t\t    perm_string inst_name,\n\t\t\t\t\t    unsigned instance_width) const\n{\n      NetNode*gate = 0;\n\n      switch (type()) {\n\n\t  case AND:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the AND \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::AND, instance_width);\n\t    }\n\t    break;\n\n\t  case BUF:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the BUF \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, 2,\n\t\t                      NetLogic::BUF, instance_width);\n\t    }\n\t    break;\n\n\t  case BUFIF0:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the BUFIF0 \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t\t  NetLogic::BUFIF0, instance_width);\n\t    }\n\t    break;\n\n\t  case BUFIF1:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the BUFIF1 \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t\t  NetLogic::BUFIF1, instance_width);\n\t    }\n\t    break;\n\n\t  case CMOS:\n\t    if (pin_count() != 4) {\n\t\t  cerr << get_fileline() << \": error: the CMOS \"\n\t\t\t\"primitive must have four arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::CMOS, instance_width);\n\t    }\n\t    break;\n\n\t  case NAND:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the NAND \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::NAND, instance_width);\n\t    }\n\t    break;\n\n\t  case NMOS:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the NMOS \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::NMOS, instance_width);\n\t    }\n\t    break;\n\n\t  case NOR:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the NOR \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::NOR, instance_width);\n\t    }\n\t    break;\n\n\t  case NOT:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the NOT \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, 2,\n\t\t                      NetLogic::NOT, instance_width);\n\t    }\n\t    break;\n\n\t  case NOTIF0:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the NOTIF0 \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::NOTIF0, instance_width);\n\t    }\n\t    break;\n\n\t  case NOTIF1:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the NOTIF1 \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::NOTIF1, instance_width);\n\t    }\n\t    break;\n\n\t  case OR:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the OR \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::OR, instance_width);\n\t    }\n\t    break;\n\n\t  case RCMOS:\n\t    if (pin_count() != 4) {\n\t\t  cerr << get_fileline() << \": error: the RCMOS \"\n\t\t\t\"primitive must have four arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::RCMOS, instance_width);\n\t    }\n\t    break;\n\n\t  case RNMOS:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the RNMOS \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::RNMOS, instance_width);\n\t    }\n\t    break;\n\n\t  case RPMOS:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the RPMOS \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::RPMOS, instance_width);\n\t    }\n\t    break;\n\n\t  case PMOS:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: the PMOS \"\n\t\t\t\"primitive must have three arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::PMOS, instance_width);\n\t    }\n\t    break;\n\n\t  case PULLDOWN:\n\t    gate = new NetLogic(scope, inst_name, 1,\n\t\t\t\tNetLogic::PULLDOWN, instance_width);\n\t    break;\n\n\t  case PULLUP:\n\t    gate = new NetLogic(scope, inst_name, 1,\n\t\t\t\tNetLogic::PULLUP, instance_width);\n\t    break;\n\n\t  case XNOR:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the XNOR \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::XNOR, instance_width);\n\t    }\n\t    break;\n\n\t  case XOR:\n\t    if (pin_count() < 2) {\n\t\t  cerr << get_fileline() << \": error: the XOR \"\n\t\t\t\"primitive must have an input.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetLogic(scope, inst_name, pin_count(),\n\t\t\t\t      NetLogic::XOR, instance_width);\n\t    }\n\t    break;\n\n\t  case TRAN:\n\t    if (pin_count() != 2) {\n\t\t  cerr << get_fileline() << \": error: Pin count for \"\n\t\t       << \"tran device.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetTran(scope, inst_name, IVL_SW_TRAN,\n\t\t                     instance_width);\n\t    }\n\t    break;\n\n\t  case RTRAN:\n\t    if (pin_count() != 2) {\n\t\t  cerr << get_fileline() << \": error: Pin count for \"\n\t\t       << \"rtran device.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetTran(scope, inst_name, IVL_SW_RTRAN,\n\t\t                     instance_width);\n\t    }\n\t    break;\n\n\t  case TRANIF0:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: Pin count for \"\n\t\t       << \"tranif0 device.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetTran(scope, inst_name, IVL_SW_TRANIF0,\n\t\t                     instance_width);\n\t    }\n\t    break;\n\n\t  case RTRANIF0:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: Pin count for \"\n\t\t       << \"rtranif0 device.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetTran(scope, inst_name, IVL_SW_RTRANIF0,\n\t\t                     instance_width);\n\t    }\n\t    break;\n\n\t  case TRANIF1:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: Pin count for \"\n\t\t       << \"tranif1 device.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetTran(scope, inst_name, IVL_SW_TRANIF1,\n\t\t                     instance_width);\n\t    }\n\t    break;\n\n\t  case RTRANIF1:\n\t    if (pin_count() != 3) {\n\t\t  cerr << get_fileline() << \": error: Pin count for \"\n\t\t       << \"rtranif1 device.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  gate = new NetTran(scope, inst_name, IVL_SW_RTRANIF1,\n\t\t                     instance_width);\n\t    }\n\t    break;\n\n\t  default:\n\t    cerr << get_fileline() << \": internal error: unhandled \"\n\t\t  \"gate type.\" << endl;\n\t    des->errors += 1;\n\t    break;\n      }\n\n      return gate;\n}\n\nbool PGBuiltin::check_delay_count(Design*des) const\n{\n      switch (type()) {\n\t  case AND:\n\t  case NAND:\n\t  case OR:\n\t  case NOR:\n\t  case XOR:\n\t  case XNOR:\n\t  case BUF:\n\t  case NOT:\n\t    if (delay_count() > 2) {\n\t\t  cerr << get_fileline() << \": error: More than two delays \"\n\t\t       << \"given to a \" << gate_name() << \" gate.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return true;\n\t    }\n\t    break;\n\n\t  case BUFIF0:\n\t  case NOTIF0:\n\t  case BUFIF1:\n\t  case NOTIF1:\n\t    if (delay_count() > 3) {\n\t\t  cerr << get_fileline() << \": error: More than three delays \"\n\t\t       << \"given to a \" << gate_name() << \" gate.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return true;\n\t    }\n\t    break;\n\n\t  case NMOS:\n\t  case RNMOS:\n\t  case PMOS:\n\t  case RPMOS:\n\t  case CMOS:\n\t  case RCMOS:\n\t    if (delay_count() > 3) {\n\t\t  cerr << get_fileline() << \": error: More than three delays \"\n\t\t       << \"given to a \" << gate_name() << \" switch.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return true;\n\t    }\n\t    break;\n\n\t  case TRAN:\n\t  case RTRAN:\n\t    if (delay_count() != 0) {\n\t\t  cerr << get_fileline() << \": error: A \" << gate_name()\n\t\t       << \" switch does not take any delays.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return true;\n\t    }\n\t    break;\n\n\t  case TRANIF0:\n\t  case TRANIF1:\n\t    if (delay_count() > 2) {\n\t\t  cerr << get_fileline() << \": error: More than two delays \"\n\t\t       << \"given to a \" << gate_name() << \" switch.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return true;\n\t    }\n\t    break;\n\n\t  case RTRANIF0:\n\t  case RTRANIF1:\n\t    if (delay_count() > 2) {\n\t\t  cerr << get_fileline() << \": error: More than two delays \"\n\t\t       << \"given to an \" << gate_name() << \" switch.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return true;\n\t    }\n\t    break;\n\n\t  case PULLUP:\n\t  case PULLDOWN:\n\t    if (delay_count() != 0) {\n\t\t  cerr << get_fileline() << \": error: A \" << gate_name()\n\t\t       << \" source does not take any delays.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return true;\n\t    }\n\t    break;\n\n\t  default:\n\t    cerr << get_fileline() << \": internal error: unhandled \"\n\t\t  \"gate type.\" << endl;\n\t    des->errors += 1;\n\t    return true;\n\t    break;\n      }\n\n      return false;\n}\n\n/*\n * Elaborate a Builtin gate. These normally get translated into\n * NetLogic nodes that reflect the particular logic function.\n */\nvoid PGBuiltin::elaborate(Design*des, NetScope*scope) const\n{\n      unsigned instance_width = 1;\n      perm_string name = get_name();\n\n      if (name == \"\") name = scope->local_symbol();\n\n\t/* Calculate the array bounds and instance count for the gate,\n\t   as described in the Verilog source. If there is none, then\n\t   the count is 1, and high==low==0. */\n\n      long low=0, high=0;\n      unsigned array_count = calculate_array_size_(des, scope, high, low);\n      if (array_count == 0) return;\n\n      unsigned gate_count = 0, lval_count = 0;\n      calculate_gate_and_lval_count_(gate_count, lval_count);\n\n\t/* Now we have a gate count. Elaborate the lval (output or\n           bi-directional) expressions only. We do it early so that\n           we can see if we can make wide gates instead of an array\n           of gates. */\n\n      vector<NetNet*>lval_sigs (lval_count);\n\n      for (unsigned idx = 0 ; idx < lval_count ; idx += 1) {\n\t    if (pin(idx) == 0) {\n\t\t  cerr << get_fileline() << \": error: Logic gate port \"\n\t\t\t\"expressions are not optional.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n            if (lval_count > gate_count)\n\t          lval_sigs[idx] = pin(idx)->elaborate_bi_net(des, scope);\n            else\n\t          lval_sigs[idx] = pin(idx)->elaborate_lnet(des, scope);\n\n\t      // The only way this should return zero is if an error\n\t      // happened, so for that case just return.\n\t    if (lval_sigs[idx] == 0) return;\n\n\t      // For now, assume all the outputs are the same width.\n\t    ivl_assert(*this, idx == 0 || lval_sigs[idx]->vector_width() == lval_sigs[0]->vector_width());\n      }\n\n\t/* Detect the special case that the l-value width exactly\n\t   matches the gate count. In this case, we will make a single\n\t   gate that has the desired vector width.\n\n\t   NOTE: This assumes that all the outputs have the same\n\t   width. For gates with 1 output, this is trivially true. */\n      if (lval_sigs[0]->vector_width() == array_count) {\n\t    instance_width = array_count;\n\t    array_count = 1;\n\n\t    if (debug_elaborate && instance_width != 1)\n\t\t  cerr << get_fileline() << \": debug: PGBuiltin: \"\n\t\t\t\"Collapsed gate array into single wide \"\n\t\t\t\"(\" << instance_width << \") instance.\" << endl;\n      }\n\n\t/* Calculate the gate delays from the delay expressions\n\t   given in the source. For logic gates, the decay time\n\t   is meaningless because it can never go to high\n\t   impedance. However, the bufif devices can generate\n\t   'bz output, so we will pretend that anything can.\n\n\t   If only one delay value expression is given (i.e., #5\n\t   nand(foo,...)) then rise, fall and decay times are\n\t   all the same value. If two values are given, rise and\n\t   fall times are use, and the decay time is the minimum\n\t   of the rise and fall times. Finally, if all three\n\t   values are given, they are taken as specified. */\n\n      if (check_delay_count(des)) return;\n      NetExpr* rise_time, *fall_time, *decay_time;\n      eval_delays(des, scope, rise_time, fall_time, decay_time, true);\n\n      struct attrib_list_t*attrib_list;\n      unsigned attrib_list_n = 0;\n      attrib_list = evaluate_attributes(attributes, attrib_list_n,\n\t\t\t\t\tdes, scope);\n\n\t/* Allocate all the netlist nodes for the gates. */\n      vector<NetNode*>cur (array_count*gate_count);\n\n\t/* Now make as many gates as the bit count dictates. Give each\n\t   a unique name, and set the delay times. */\n\n      for (unsigned idx = 0 ;  idx < array_count*gate_count ;  idx += 1) {\n\t    unsigned array_idx = idx/gate_count;\n\t    unsigned gate_idx = idx%gate_count;\n\n\t    ostringstream tmp;\n\t    unsigned index = (low < high)? (low+array_idx) : (low-array_idx);\n\n\t    tmp << name << \"<\" << index << \".\" << gate_idx << \">\";\n\t    perm_string inm = lex_strings.make(tmp.str());\n\n\t    cur[idx] = create_gate_for_output_(des, scope, inm, instance_width);\n\t    if (cur[idx] == 0)\n\t\t  return;\n\n\t    for (unsigned adx = 0 ;  adx < attrib_list_n ;  adx += 1)\n\t\t  cur[idx]->attribute(attrib_list[adx].key,\n\t\t\t\t      attrib_list[adx].val);\n\n\t      /* Set the delays and drive strength for all built in gates. */\n\t    cur[idx]->rise_time(rise_time);\n\t    cur[idx]->fall_time(fall_time);\n\t    cur[idx]->decay_time(decay_time);\n\n\t    cur[idx]->pin(0).drive0(strength0());\n\t    cur[idx]->pin(0).drive1(strength1());\n\n\t    cur[idx]->set_line(*this);\n\t    des->add_node(cur[idx]);\n      }\n\n\n      delete[]attrib_list;\n\n\t/* The gates have all been allocated, this loop runs through\n\t   the parameters and attaches the ports of the objects. */\n\n      for (unsigned idx = 0 ;  idx < pin_count() ;  idx += 1) {\n\n\t    PExpr*ex = pin(idx);\n\t    if (ex == 0) {\n\t\t  cerr << get_fileline() << \": error: Logic gate port \"\n\t\t          \"expressions are not optional.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n\t    NetNet*sig = 0;\n\t    if (idx < lval_count) {\n\t\t  sig = lval_sigs[idx];\n\n\t    } else {\n                    // If this is an array, the port expression is required\n                    // to be the exact width required (this will be checked\n                    // later). But if this is a single instance, consensus\n                    // is that we just take the LSB of the port expression.\n\t\t  NetExpr*tmp = elab_and_eval(des, scope, ex, is_array() ? -1 : 1);\n                  if (tmp == 0)\n                        continue;\n                  if (!is_array() && tmp->expr_width() != 1)\n                        tmp = new NetESelect(tmp, make_const_0(1), 1,\n                                             IVL_SEL_IDX_UP);\n\t\t  sig = tmp->synthesize(des, scope, tmp);\n\t\t  delete tmp;\n\t    }\n\n\t    if (sig == 0)\n\t\t  continue;\n\n\t    ivl_assert(*this, sig);\n\n\t    if (array_count == 1) {\n\t\t    /* Handle the case where there is one gate that\n\t\t       carries the whole vector width. */\n\n\t\t  if (1 == sig->vector_width() && instance_width != 1) {\n\n\t\t\tivl_assert(*this, sig->vector_width() == 1);\n\t\t\tNetReplicate*rep\n\t\t\t      = new NetReplicate(scope,\n\t\t\t\t\t\t scope->local_symbol(),\n\t\t\t\t\t\t instance_width,\n\t\t\t\t\t\t instance_width);\n\t\t\trep->set_line(*this);\n\t\t\tdes->add_node(rep);\n\t\t\tconnect(rep->pin(1), sig->pin(0));\n\n\t\t\tnetvector_t*osig_vec = new netvector_t(IVL_VT_LOGIC,\n\t\t\t\t\t\t\t       instance_width-1,0);\n\t\t\tsig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t\t NetNet::WIRE, osig_vec);\n\t\t\tsig->set_line(*this);\n\t\t\tsig->local_flag(true);\n\t\t\tconnect(rep->pin(0), sig->pin(0));\n\n\t\t  }\n\n\t\t  if (instance_width != sig->vector_width()) {\n\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Expression width \" << sig->vector_width()\n\t\t\t     << \" does not match width \" << instance_width\n\t\t\t     << \" of logic gate array port \" << idx+1\n\t\t\t     << \".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\n\t\t    // There is only 1 instance, but there may be\n\t\t    // multiple outputs to that gate. That would\n\t\t    // potentially mean multiple actual gates.\n\t\t    // Although in Verilog proper a multiple\n\t\t    // output gate has only 1 input, this conditional\n\t\t    // handles gates with N outputs and M inputs.\n\t\t  if (idx < gate_count) {\n\t\t\tconnect(cur[idx]->pin(0), sig->pin(0));\n\t\t  } else {\n\t\t\tfor (unsigned dev = 0 ; dev < gate_count; dev += 1)\n\t\t\t      connect(cur[dev]->pin(idx-gate_count+1), sig->pin(0));\n\t\t  }\n\n\t    } else if (sig->vector_width() == 1) {\n\n\t\t    /* Handle the case where a single bit is connected\n\t\t       repetitively to all the instances. If idx is an\n\t\t       output port, connect it to all array_count\n\t\t       devices that have outputs at this\n\t\t       position. Otherwise, idx is an input to all\n\t\t       array_count*gate_count devices. */\n\n\t\t  if (idx < gate_count) {\n\t\t\tfor (unsigned gdx = 0 ; gdx < array_count ; gdx += 1) {\n\t\t\t      unsigned dev = gdx*gate_count;\n\t\t\t      connect(cur[dev+idx]->pin(0), sig->pin(0));\n\t\t\t}\n\t\t  } else {\n\t\t\tunsigned use_idx = idx - gate_count + 1;\n\t\t\tfor (unsigned gdx = 0 ;  gdx < cur.size() ;  gdx += 1)\n\t\t\t      connect(cur[gdx]->pin(use_idx), sig->pin(0));\n\t\t  }\n\n\t    } else if (sig->vector_width() == array_count) {\n\n                    /* Bi-directional switches should get collapsed into\n                       a single wide instance, so should never reach this\n                       point. Check this is so, as the following code\n                       doesn't handle bi-directional connections. */\n                  ivl_assert(*this, lval_count == gate_count);\n\n\t\t    /* Handle the general case that each bit of the\n\t\t       value is connected to a different instance. In\n\t\t       this case, the output is handled slightly\n\t\t       different from the inputs. */\n\t\t  if (idx < gate_count) {\n\t\t\tNetConcat*cc = new NetConcat(scope,\n\t\t\t\t\t\t     scope->local_symbol(),\n\t\t\t\t\t\t     sig->vector_width(),\n\t\t\t\t\t\t     array_count);\n\t\t\tcc->set_line(*this);\n\t\t\tdes->add_node(cc);\n\n\t\t\t  /* Connect the concat to the signal. */\n\t\t\tconnect(cc->pin(0), sig->pin(0));\n\n\t\t\t  /* Connect the outputs of the gates to the concat. */\n\t\t\tfor (unsigned gdx = 0 ;  gdx < array_count;  gdx += 1) {\n\t\t\t      unsigned dev = gdx*gate_count;\n\t\t\t      connect(cur[dev+idx]->pin(0), cc->pin(gdx+1));\n\n\t\t\t      netvector_t*tmp2_vec = new netvector_t(IVL_VT_LOGIC);\n\t\t\t      NetNet*tmp2 = new NetNet(scope,\n\t\t\t\t\t\t       scope->local_symbol(),\n\t\t\t\t\t\t       NetNet::WIRE, tmp2_vec);\n\t\t\t      tmp2->set_line(*this);\n\t\t\t      tmp2->local_flag(true);\n\t\t\t      connect(cc->pin(gdx+1), tmp2->pin(0));\n\t\t\t}\n\n\t\t  } else for (unsigned gdx = 0 ;  gdx < array_count ;  gdx += 1) {\n\t\t\t  /* Use part selects to get the bits\n\t\t\t     connected to the inputs of out gate. */\n\t\t\tNetPartSelect*tmp1 = new NetPartSelect(sig, gdx, 1,\n\t\t\t\t\t\t\t   NetPartSelect::VP);\n\t\t\ttmp1->set_line(*this);\n\t\t\tdes->add_node(tmp1);\n\t\t\tconnect(tmp1->pin(1), sig->pin(0));\n\t\t\tnetvector_t*tmp2_vec = new netvector_t(sig->data_type());\n\t\t\tNetNet*tmp2 = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t\t\t NetNet::WIRE, tmp2_vec);\n\t\t\ttmp2->set_line(*this);\n\t\t\ttmp2->local_flag(true);\n\t\t\tconnect(tmp1->pin(0), tmp2->pin(0));\n\t\t\tunsigned use_idx = idx - gate_count + 1;\n\t\t\tunsigned dev = gdx*gate_count;\n\t\t\tfor (unsigned gdx2 = 0 ; gdx2 < gate_count ; gdx2 += 1)\n\t\t\t      connect(cur[dev+gdx2]->pin(use_idx), tmp1->pin(0));\n\t\t  }\n\n\t    } else {\n\t\t  cerr << get_fileline() << \": error: Gate count of \" <<\n\t\t\tarray_count << \" does not match net width of \" <<\n\t\t\tsig->vector_width() << \" at pin \" << idx << \".\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t    }\n\n      }\n\n}\n\nNetNet*PGModule::resize_net_to_port_(Design*des, NetScope*scope,\n\t\t\t\t     NetNet*sig, unsigned port_wid,\n\t\t\t\t     NetNet::PortType dir, bool as_signed) const\n{\n      ivl_assert(*this, dir != NetNet::NOT_A_PORT);\n      ivl_assert(*this, dir != NetNet::PIMPLICIT);\n\n      netvector_t*tmp_type = new netvector_t(IVL_VT_LOGIC, port_wid-1, 0);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t      NetNet::WIRE, tmp_type);\n      tmp->local_flag(true);\n      tmp->set_line(*this);\n\n\t// Handle the special case of a bi-directional part\n\t// select. Create a NetTran(VP) instead of a uni-directional\n\t// NetPartSelect node.\n      if (dir == NetNet::PINOUT) {\n\t    unsigned wida = sig->vector_width();\n\t    unsigned widb = tmp->vector_width();\n\t    bool part_b = widb < wida;\n\t      // This needs to pad the value!\n\t      // Also delete the inout specific warning when this is fixed.\n\t      // It is located just before this routine is called.\n\t    NetTran*node = new NetTran(scope, scope->local_symbol(),\n\t\t\t\t       part_b? wida : widb,\n\t\t\t\t       part_b? widb : wida,\n\t\t\t\t       0);\n\t    if (part_b) {\n\t\t  connect(node->pin(0), sig->pin(0));\n\t\t  connect(node->pin(1), tmp->pin(0));\n\t    } else {\n\t\t  connect(node->pin(0), tmp->pin(0));\n\t\t  connect(node->pin(1), sig->pin(0));\n\t    }\n\n\t    node->set_line(*this);\n\t    des->add_node(node);\n\n\t    return tmp;\n      }\n\n      unsigned pwidth = tmp->vector_width();\n      unsigned swidth = sig->vector_width();\n      switch (dir) {\n\t  case NetNet::POUTPUT:\n\t    if (pwidth > swidth) {\n\t\t  NetPartSelect*node = new NetPartSelect(tmp, 0, swidth,\n\t\t\t\t\t   NetPartSelect::VP);\n\t\t  connect(node->pin(0), sig->pin(0));\n\t\t  des->add_node(node);\n\t    } else {\n\t\t  NetNet*osig;\n\t\t  if (as_signed) {\n\t\t\tosig = pad_to_width_signed(des, tmp, swidth, *this);\n\t\t  } else {\n\t\t\tosig = pad_to_width(des, tmp, swidth, *this);\n\t\t  }\n\t\t  connect(osig->pin(0), sig->pin(0));\n\t    }\n\t    break;\n\n\t  case NetNet::PINPUT:\n\t    if (pwidth > swidth) {\n\t\t  delete tmp;\n\t\t  if (as_signed) {\n\t\t\ttmp = pad_to_width_signed(des, sig, pwidth, *this);\n\t\t  } else {\n\t\t\ttmp = pad_to_width(des, sig, pwidth, *this);\n\t\t  }\n\t    } else {\n\t\t  NetPartSelect*node = new NetPartSelect(sig, 0, pwidth,\n\t\t\t\t\t   NetPartSelect::VP);\n\t\t  connect(node->pin(0), tmp->pin(0));\n\t\t  des->add_node(node);\n\t    }\n\t    break;\n\n\t  case NetNet::PINOUT:\n\t    ivl_assert(*this, 0);\n\t    break;\n\n\t  case NetNet::PREF:\n\t    ivl_assert(*this, 0);\n\t    break;\n\n\t  default:\n\t    ivl_assert(*this, 0);\n      }\n\n      return tmp;\n}\n\nstatic bool need_bufz_for_input_port(const vector<NetNet*>&prts)\n{\n      if (prts[0]->port_type() != NetNet::PINPUT)\n\t    return false;\n\n      if (prts[0]->pin(0).nexus()->drivers_present())\n\t    return true;\n\n      return false;\n}\n\n/*\n * Convert a wire or tri to a tri0 or tri1 as needed to make\n * an unconnected drive pull for floating inputs.\n */\nstatic void convert_net(Design*des, const LineInfo *line,\n                        NetNet *net, NetNet::Type type)\n{\n\t// If the types already match just return.\n      if (net->type() == type) return;\n\n\t// We can only covert a wire or tri to have a default pull.\n      if (net->type() == NetNet::WIRE || net->type() == NetNet::TRI) {\n\t    net->type(type);\n\t    return;\n      }\n\n\t// We may have to support this at some point in time!\n      cerr << line->get_fileline() << \": sorry: Can not pull floating \"\n              \"input type '\" << net->type() << \"'.\" << endl;\n      des->errors += 1;\n}\n\nstatic void isolate_and_connect(Design*des, NetScope*scope, const PGModule*mod,\n\t\t\t\tNetNet*port, NetNet*sig, NetNet::PortType ptype, int idx = -1)\n{\n      switch (ptype) {\n\t  case NetNet::POUTPUT:\n\t    {\n\t\t  NetBUFZ*tmp = new NetBUFZ(scope, scope->local_symbol(),\n\t\t\t\t\t    sig->vector_width(), true, idx);\n\t\t  tmp->set_line(*mod);\n\t\t  des->add_node(tmp);\n\t\t  connect(tmp->pin(1), port->pin(0));\n\t\t  connect(tmp->pin(0), sig->pin(0));\n\t    }\n\t    break;\n\t  case NetNet::PINOUT:\n\t    {\n\t\t  NetTran*tmp = new NetTran(scope, scope->local_symbol(),\n\t\t\t\t\t    sig->vector_width(),\n\t\t\t\t\t    sig->vector_width(), 0);\n\t\t  tmp->set_line(*mod);\n\t\t  des->add_node(tmp);\n\t\t  connect(tmp->pin(1), port->pin(0));\n\t\t  connect(tmp->pin(0), sig->pin(0));\n\t    }\n\t    break;\n\t  default:\n\t    ivl_assert(*mod, 0);\n\t    break;\n      }\n}\n\nvoid elaborate_unpacked_port(Design *des, NetScope *scope, NetNet *port_net,\n\t\t\t     PExpr *expr, NetNet::PortType port_type,\n\t\t\t     Module *mod, unsigned int port_idx)\n{\n      NetNet *expr_net = elaborate_unpacked_array(des, scope, *expr, port_net,\n\t\t\t\t\t\t  expr);\n      if (!expr_net) {\n\t    perm_string port_name = mod->get_port_name(port_idx);\n\t    cerr << expr->get_fileline() << \":      : Port \"\n\t\t<< port_idx+1 << \" (\" << port_name << \") of \"\n\t        << mod->mod_name() << \" is connected to \"\n\t        << *expr << endl;\n\n\t    return;\n      }\n\n      ivl_assert(*port_net, expr_net->pin_count() == port_net->pin_count());\n      if (port_type == NetNet::POUTPUT) {\n\t    // elaborate_unpacked_array normally elaborates a RHS expression\n\t    // so does not perform this check.\n\t    if (gn_var_can_be_uwire() && (expr_net->type() == NetNet::REG)) {\n\t\t  if (expr_net->peek_lref() > 0) {\n\t\t\tperm_string port_name = mod->get_port_name(port_idx);\n\t\t\tcerr << expr->get_fileline() << \": error: \"\n\t\t\t\t\"Cannot connect port '\" << port_name\n\t\t\t     << \"' to variable '\" << expr_net->name()\n\t\t\t     << \"'. This conflicts with a procedural \"\n\t\t\t\t\"assignment.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn;\n\t\t  }\n\t\t  expr_net->type(NetNet::UNRESOLVED_WIRE);\n\t    }\n\t    assign_unpacked_with_bufz(des, scope, port_net, expr_net, port_net);\n      } else\n\t    assign_unpacked_with_bufz(des, scope, port_net, port_net, expr_net);\n}\n\n/*\n * Instantiate a module by recursively elaborating it. Set the path of\n * the recursive elaboration so that signal names get properly\n * set. Connect the ports of the instantiated module to the signals of\n * the parameters. This is done with BUFZ gates so that they look just\n * like continuous assignment connections.\n */\nvoid PGModule::elaborate_mod_(Design*des, Module*rmod, NetScope*scope) const\n{\n\n      ivl_assert(*this, scope);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Instantiate module \"\n\t\t << rmod->mod_name() << \" with instance name \"\n\t\t << get_name() << \" in scope \" << scope_path(scope) << endl;\n      }\n\n\t// This is the array of pin expressions, shuffled to match the\n\t// order of the declaration. If the source instantiation uses\n\t// bind by order, this is the same as the source list. Otherwise,\n\t// the source list is rearranged by name binding into this list.\n      vector<PExpr*>pins (rmod->port_count());\n      vector<bool>pins_fromwc (rmod->port_count(), false);\n      vector<bool>pins_is_explicitly_not_connected (rmod->port_count(), false);\n\n\t// If the instance has a pins_ member, then we know we are\n\t// binding by name. Therefore, make up a pins array that\n\t// reflects the positions of the named ports.\n      if (pins_) {\n\t    unsigned nexp = rmod->port_count();\n\n\t      // Scan the bindings, matching them with port names.\n\t    for (unsigned idx = 0 ;  idx < npins_ ;  idx += 1) {\n\n\t\t    // Handle wildcard named port\n\t\t  if (pins_[idx].name[0] == '*') {\n\t\t\tfor (unsigned j = 0 ; j < nexp ; j += 1) {\n\t\t\t      if (rmod->ports[j] && !pins[j] && !pins_is_explicitly_not_connected[j]) {\n\t\t\t\t    pins_fromwc[j] = true;\n\t\t\t\t    pform_name_t path_;\n\t\t\t\t    path_.push_back(name_component_t(rmod->ports[j]->name));\n\t\t\t\t    symbol_search_results sr;\n\t\t\t\t    symbol_search(this, des, scope, path_, UINT_MAX, &sr);\n\t\t\t\t    if (sr.net != 0) {\n\t\t\t\t\t  pins[j] = new PEIdent(rmod->ports[j]->name, UINT_MAX, true);\n\t\t\t\t\t  pins[j]->set_lineno(get_lineno());\n\t\t\t\t\t  pins[j]->set_file(get_file());\n\t\t\t\t    }\n\t\t\t      }\n\t\t\t}\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // Given a binding, look at the module port names\n\t\t    // for the position that matches the binding name.\n\t\t  unsigned pidx = rmod->find_port(pins_[idx].name);\n\n\t\t    // If the port name doesn't exist, the find_port\n\t\t    // method will return the port count. Detect that\n\t\t    // as an error.\n\t\t  if (pidx == nexp) {\n\t\t\tcerr << get_fileline() << \": error: port ``\" <<\n\t\t\t      pins_[idx].name << \"'' is not a port of \"\n\t\t\t     << get_name() << \".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // If I am overriding a wildcard port, delete and\n\t\t    // override it\n\t\t  if (pins_fromwc[pidx]) {\n\t\t\tdelete pins[pidx];\n\t\t\tpins_fromwc[pidx] = false;\n\n\t\t    // If I already explicitly bound something to\n\t\t    // this port, then the pins array will already\n\t\t    // have a pointer value where I want to place this\n\t\t    // expression.\n\t\t  } else if (pins[pidx]) {\n\t\t\tcerr << get_fileline() << \": error: port ``\" <<\n\t\t\t      pins_[idx].name << \"'' already bound.\" <<\n\t\t\t      endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // OK, do the binding by placing the expression in\n\t\t    // the right place.\n\t\t  pins[pidx] = pins_[idx].parm;\n\t\t  if (!pins[pidx])\n\t\t\tpins_is_explicitly_not_connected[pidx] = true;\n\t    }\n\n\n      } else if (pin_count() == 0) {\n\n\t      /* Handle the special case that no ports are\n\t\t connected. It is possible that this is an empty\n\t\t connect-by-name list, so we'll allow it and assume\n\t\t that is the case. */\n\n\t    for (unsigned idx = 0 ;  idx < rmod->port_count() ;  idx += 1)\n\t\t  pins[idx] = 0;\n\n      } else {\n\n\t      /* Otherwise, this is a positional list of port\n\t\t connections. Use as many ports as provided. Trailing\n\t\t missing ports will be left unconnect or use the default\n\t\t value if one is available */\n\n\t    if (pin_count() > rmod->port_count()) {\n\t\t  cerr << get_fileline() << \": error: Wrong number \"\n\t\t\t\"of ports. Expecting at most \" << rmod->port_count() <<\n\t\t\t\", got \" << pin_count() << \".\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n\n\t    std::copy(get_pins().begin(), get_pins().end(), pins.begin());\n      }\n\n\t// Elaborate these instances of the module. The recursive\n\t// elaboration causes the module to generate a netlist with\n\t// the ports represented by NetNet objects. I will find them\n\t// later.\n\n      NetScope::scope_vec_t&instance = scope->instance_arrays[get_name()];\n      if (debug_elaborate) cerr << get_fileline() << \": debug: start \"\n\t    \"recursive elaboration of \" << instance.size() << \" instance(s) of \" <<\n\t    get_name() << \"...\" << endl;\n      for (unsigned inst = 0 ;  inst < instance.size() ;  inst += 1) {\n\t    rmod->elaborate(des, instance[inst]);\n\t    instance[inst]->set_num_ports( rmod->port_count() );\n      }\n      if (debug_elaborate) cerr << get_fileline() << \": debug: ...done.\" << endl;\n\n\n\t// Now connect the ports of the newly elaborated designs to\n\t// the expressions that are the instantiation parameters. Scan\n\t// the pins, elaborate the expressions attached to them, and\n\t// bind them to the port of the elaborated module.\n\n\t// This can get rather complicated because the port can be\n\t// unconnected (meaning an empty parameter is passed) connected\n\t// to a concatenation, or connected to an internally\n\t// unconnected port.\n\n      for (unsigned idx = 0 ;  idx < pins.size() ;  idx += 1) {\n\t    bool unconnected_port = false;\n\t    bool using_default = false;\n\n\t    perm_string port_name = rmod->get_port_name(idx);\n\n\t      // If the port is unconnected, substitute the default\n\t      // value. The parser ensures that a default value only\n\t      // exists for input ports.\n\t    if (pins[idx] == 0) {\n\t\t  PExpr*default_value = rmod->get_port_default_value(idx);\n\t\t  if (default_value) {\n\t\t\tpins[idx] = default_value;\n\t\t\tusing_default = true;\n\t\t  }\n\t    }\n\n\t      // Skip unconnected module ports. This happens when a\n\t      // null parameter is passed in and there is no default\n\t      // value.\n\t    if (pins[idx] == 0) {\n\n\t\t  if (pins_fromwc[idx]) {\n\t\t\tcerr << get_fileline() << \": error: Wildcard named \"\n\t\t\t        \"port connection (.*) did not find a matching \"\n\t\t\t        \"identifier for port \" << (idx+1) << \" (\"\n\t\t\t     << port_name << \").\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn;\n\t\t  }\n\n\t\t    // We need this information to support the\n\t\t    // unconnected_drive directive and for a\n\t\t    // unconnected input warning when asked for.\n\t\t  vector<PEIdent*> mport = rmod->get_port(idx);\n\t\t  if (mport.empty()) continue;\n\n\t\t  perm_string pname = peek_tail_name(mport[0]->path().name);\n\n\t\t  NetNet*tmp = instance[0]->find_signal(pname);\n\n\t\t    // Handle the error case where there is no internal\n\t\t    // signal connected to the port.\n\t\t  if (!tmp) continue;\n\t\t  ivl_assert(*this, tmp);\n\n\t\t  if (tmp->port_type() == NetNet::PINPUT) {\n\t\t\t  // If we have an unconnected input convert it\n\t\t\t  // as needed if an unconnected_drive directive\n\t\t\t  // was given. This only works for tri or wire!\n\t\t\tswitch (rmod->uc_drive) {\n\t\t\t    case Module::UCD_PULL0:\n\t\t\t      convert_net(des, this, tmp, NetNet::TRI0);\n\t\t\t      break;\n\t\t\t    case Module::UCD_PULL1:\n\t\t\t      convert_net(des, this, tmp, NetNet::TRI1);\n\t\t\t      break;\n\t\t\t    case Module::UCD_NONE:\n\t\t\t      break;\n\t\t\t}\n\n\t\t\t  // Print a warning for an unconnected input.\n\t\t\tif (warn_portbinding) {\n\t\t\t      cerr << get_fileline() << \": warning: \"\n\t\t\t\t   << \"Instantiating module \"\n\t\t\t\t   << rmod->mod_name()\n\t\t\t\t   << \" with dangling input port \"\n\t\t\t\t   << (idx+1) << \" (\" << port_name;\n\t\t\t      switch (rmod->uc_drive) {\n\t\t\t\t  case Module::UCD_PULL0:\n\t\t\t\t    cerr << \") pulled low.\" << endl;\n\t\t\t\t    break;\n\t\t\t\t  case Module::UCD_PULL1:\n\t\t\t\t    cerr << \") pulled high.\" << endl;\n\t\t\t\t    break;\n\t\t\t\t  case Module::UCD_NONE:\n\t\t\t\t    cerr << \") floating.\" << endl;\n\t\t\t\t    break;\n\t\t\t      }\n\t\t\t}\n\t\t  }\n\t\t  unconnected_port = true;\n\t    }\n\n\t      // Inside the module, the port connects zero or more signals\n\t      // that were already elaborated. List all those signals\n\t      // and the NetNet equivalents, for all the instances.\n\t    vector<PEIdent*> mport = rmod->get_port(idx);\n\t    vector<NetNet*>  prts (mport.size() * instance.size());\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: \" << get_name()\n\t\t       << \": Port \" << (idx+1) << \" (\" << port_name\n\t\t       << \") has \" << prts.size() << \" sub-ports.\" << endl;\n\t    }\n\n\t      // Count the internal vector bits of the port.\n\t    unsigned prts_vector_width = 0;\n\n\t    for (unsigned inst = 0 ;  inst < instance.size() ;  inst += 1) {\n\t\t    // Scan the instances from MSB to LSB. The port\n\t\t    // will be assembled in that order as well.\n\t\t  NetScope*inst_scope = instance[instance.size()-inst-1];\n\n\t\t  unsigned int prt_vector_width = 0;\n\t\t  PortType::Enum ptype = PortType::PIMPLICIT;\n\t\t    // Scan the module sub-ports for this instance...\n\t\t    // (Sub-ports are concatenated ports that form the\n\t\t    // single port for the instance. This is not a\n\t\t    // commonly used feature.)\n\t\t  for (unsigned ldx = 0 ;  ldx < mport.size() ;  ldx += 1) {\n\t\t\tunsigned lbase = inst * mport.size();\n\t\t\tPEIdent*pport = mport[ldx];\n\t\t\tivl_assert(*this, pport);\n\t\t\tNetNet *netnet = pport->elaborate_subport(des, inst_scope);\n\t\t\tprts[lbase + ldx] = netnet;\n\t\t\tif (netnet == 0)\n\t\t\t      continue;\n\n\t\t\tivl_assert(*this, netnet);\n\t\t\tunsigned port_width = netnet->vector_width() * netnet->pin_count();\n\t\t\tprts_vector_width += port_width;\n\t\t\tprt_vector_width += port_width;\n\t\t\tptype = PortType::merged(netnet->port_type(), ptype);\n\t\t  }\n\t\t  inst_scope->add_module_port_info(idx, port_name, ptype, prt_vector_width );\n\t    }\n\n\t      // If I find that the port is unconnected inside the\n\t      // module, then there is nothing to connect. Skip the\n\t      // argument.\n\t    if ((prts_vector_width == 0) || unconnected_port) {\n\t\t  continue;\n\t    }\n\n\t      // We know by design that each instance has the same\n\t      // width port. Therefore, the prts_pin_count must be an\n\t      // even multiple of the instance count.\n\t    ivl_assert(*this, prts_vector_width % instance.size() == 0);\n\n\t    if (!prts.empty() && (prts[0]->port_type() == NetNet::PINPUT)\n\t        && prts[0]->pin(0).nexus()->drivers_present()\n\t        && pins[idx]->is_collapsible_net(des, scope,\n\t                                         prts[0]->port_type())) {\n                  prts[0]->port_type(NetNet::PINOUT);\n\n\t\t  cerr << pins[idx]->get_fileline() << \": warning: input port \"\n\t\t       << prts[0]->name() << \" is coerced to inout.\" << endl;\n\t    }\n\n\t    if (!prts.empty() && (prts[0]->port_type() == NetNet::POUTPUT)\n\t        && (prts[0]->type() != NetNet::REG)\n\t        && prts[0]->pin(0).nexus()->has_floating_input()\n\t        && pins[idx]->is_collapsible_net(des, scope,\n\t                                         prts[0]->port_type())) {\n                  prts[0]->port_type(NetNet::PINOUT);\n\n\t\t  cerr << pins[idx]->get_fileline() << \": warning: output port \"\n\t\t       << prts[0]->name() << \" is coerced to inout.\" << endl;\n\t    }\n\n\t      // Elaborate the expression that connects to the\n\t      // module[s] port. sig is the thing outside the module\n\t      // that connects to the port.\n\n\t    NetNet*sig = 0;\n\t    NetNet::PortType ptype;\n\t    if (prts.empty())\n\t\t   ptype = NetNet::NOT_A_PORT;\n\t    else\n\t\t   ptype = prts[0]->port_type();\n\t    if (prts.empty() || (ptype == NetNet::PINPUT)) {\n\n\t\t    // Special case: If the input port is an unpacked\n\t\t    // array, then there should be no sub-ports and\n\t\t    // the r-value expression is processed\n\t\t    // differently.\n\t\t  if (prts.size() >= 1 && prts[0]->unpacked_dimensions() > 0) {\n\t\t\tivl_assert(*this, prts.size()==1);\n\t\t\telaborate_unpacked_port(des, scope, prts[0], pins[idx],\n\t\t\t\t\t\tptype, rmod, idx);\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    /* Input to module. Here we elaborate the source expression\n\t\t       using its self-determined width. This allows us to check\n\t\t       for and warn about port width mismatches. But in the\n\t\t       special case that the source expression is a SV unbased\n\t\t       unsized literal, we need to force the expression width\n\t\t       to match the destination.\n\n\t\t       NOTE that this also handles the case that the\n\t\t       port is actually empty on the inside. We assume\n\t\t       in that case that the port is input. */\n\n\t\t  int context_width = -1;\n\t\t  if (PENumber*literal = dynamic_cast<PENumber*>(pins[idx])) {\n\t\t\tif (literal->value().is_single())\n\t\t\t      context_width = prts_vector_width;\n\t\t  }\n\t\t  NetExpr*tmp_expr = elab_and_eval(des, scope, pins[idx], context_width, using_default);\n\t\t  if (tmp_expr == 0) {\n\t\t\tcerr << pins[idx]->get_fileline()\n\t\t\t     << \": error: Failed to elaborate port \"\n\t\t\t     << (using_default ? \"default value.\" : \"expression.\")\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Elaborating INPUT port expression: \" << *tmp_expr << endl;\n\t\t  }\n\n\t\t  sig = tmp_expr->synthesize(des, scope, tmp_expr);\n\t\t  if (sig == 0) {\n\t\t\tcerr << pins[idx]->get_fileline()\n\t\t\t     << \": internal error: Port expression \"\n\t\t\t     << \"too complicated for elaboration.\" << endl;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  delete tmp_expr;\n\t\t  if (!sig->get_lineno()) sig->set_line(*this);\n\n\t\t  if (ptype == NetNet::PINPUT && gn_var_can_be_uwire()) {\n\t\t\tfor (unsigned int i = 0; i < prts.size(); i++) {\n\t\t\t      if (prts[i]->type() == NetNet::REG)\n\t\t\t\t    prts[i]->type(NetNet::UNRESOLVED_WIRE);\n\t\t\t}\n\t\t  }\n\n\t\t    // Add module input buffers if needed\n\t\t  if (need_bufz_for_input_port(prts) || gn_interconnect_flag == true) {\n\t\t\t  // FIXME improve this for multiple module instances\n\t\t\tNetScope* inner_scope = scope->instance_arrays[get_name()][0];\n\n\t\t\tNetBUFZ*tmp = new NetBUFZ(inner_scope, inner_scope->local_symbol(),\n\t\t\t                          sig->vector_width(), true, gn_interconnect_flag ? idx : -1);\n\t\t\ttmp->set_line(*this);\n\t\t\tdes->add_node(tmp);\n\t\t\tconnect(tmp->pin(1), sig->pin(0));\n\n\t\t\tnetvector_t*tmp2_vec = new netvector_t(sig->data_type(),\n\t\t\t                                       sig->vector_width()-1,0);\n\t\t\tNetNet*tmp2 = new NetNet(inner_scope, inner_scope->local_symbol(),\n\t\t\t                         NetNet::WIRE, tmp2_vec);\n\t\t\ttmp2->local_flag(true);\n\t\t\ttmp2->set_line(*this);\n\t\t\tconnect(tmp->pin(0), tmp2->pin(0));\n\t\t\tsig = tmp2;\n\t\t  }\n\n\t\t    // If we have a real signal driving a bit/vector port\n\t\t    // then we convert the real value using the appropriate\n\t\t    // width cast. Since a real is only one bit the whole\n\t\t    // thing needs to go to each instance when arrayed.\n\t\t  if ((sig->data_type() == IVL_VT_REAL ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() != IVL_VT_REAL )) {\n\t\t\tsig = cast_to_int4(des, scope, sig,\n\t\t\t                  prts_vector_width/instance.size());\n\t\t  }\n\t\t    // If we have a bit/vector signal driving a real port\n\t\t    // then we convert the value to a real.\n\t\t  if ((sig->data_type() != IVL_VT_REAL ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() == IVL_VT_REAL )) {\n\t\t\tsig = cast_to_real(des, scope, sig);\n\t\t  }\n\t\t    // If we have a 4-state bit/vector signal driving a\n\t\t    // 2-state port then we convert the value to 2-state.\n\t\t  if ((sig->data_type() == IVL_VT_LOGIC ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() == IVL_VT_BOOL )) {\n\t\t\tsig = cast_to_int2(des, scope, sig,\n\t\t\t\t\t   sig->vector_width());\n\t\t  }\n\n\t    } else if (ptype == NetNet::PINOUT) {\n\n\t\t    // For now, do not support unpacked array outputs.\n\t\t  ivl_assert(*this, prts[0]->unpacked_dimensions()==0);\n\n\t\t    /* Inout to/from module. This is a more\n\t\t       complicated case, where the expression must be\n\t\t       an lnet, but also an r-value net.\n\n\t\t       Normally, this winds up being the same as if we\n\t\t       just elaborated as an lnet, as passing a simple\n\t\t       identifier elaborates to the same NetNet in\n\t\t       both cases so the extra elaboration has no\n\t\t       effect. But if the expression passed to the\n\t\t       inout port is a part select, a special part\n\t\t       select must be created that can pass data in\n\t\t       both directions.\n\n\t\t       Use the elaborate_bi_net method to handle all\n\t\t       the possible cases. */\n\n\t\t  sig = pins[idx]->elaborate_bi_net(des, scope);\n\t\t  if (sig == 0) {\n\t\t\tcerr << pins[idx]->get_fileline() << \": error: \"\n\t\t\t     << \"Inout port expression must support \"\n\t\t\t     << \"continuous assignment.\" << endl;\n\t\t\tcerr << pins[idx]->get_fileline() << \":      : Port \"\n\t\t\t     << (idx+1) << \" (\" << port_name << \") of \"\n\t\t\t     << rmod->mod_name() << \" is connected to \"\n\t\t\t     << *pins[idx] << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // We do not support automatic bits to real conversion\n\t\t    // for inout ports.\n\t\t  if ((sig->data_type() == IVL_VT_REAL ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() != IVL_VT_REAL )) {\n\t\t\tcerr << pins[idx]->get_fileline() << \": error: \"\n\t\t\t     << \"Cannot automatically connect bit based \"\n\t\t\t        \"inout port \" << (idx+1) << \" (\" << port_name\n\t\t\t     << \") of module \" << rmod->mod_name()\n\t\t\t     << \" to real signal \" << sig->name() << \".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // We do not support real inout ports at all.\n\t\t  if (!prts.empty() && (prts[0]->data_type() == IVL_VT_REAL )) {\n\t\t\tcerr << pins[idx]->get_fileline() << \": error: \"\n\t\t\t     << \"No support for connecting real inout ports (\"\n\t\t\t        \"port \" << (idx+1) << \" (\" << port_name\n\t\t\t     << \") of module \" << rmod->mod_name() << \").\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\n\t    } else {\n\n\t\t    /* Port type must be OUTPUT here. */\n\t\t  ivl_assert(*this, ptype == NetNet::POUTPUT);\n\n\t\t    // Special case: If the output port is an unpacked\n\t\t    // array, then there should be no sub-ports and\n\t\t    // the passed port expression is processed\n\t\t    // differently. Note that we are calling it the\n\t\t    // \"r-value\" expression, but since this is an\n\t\t    // output port, we assign to it from the internal object.\n\t\t  if (prts[0]->unpacked_dimensions() > 0) {\n\t\t\telaborate_unpacked_port(des, scope, prts[0], pins[idx],\n\t\t\t\t\t\tptype, rmod, idx);\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // At this point, arrays are handled.\n\t\t  ivl_assert(*this, prts[0]->unpacked_dimensions()==0);\n\n\t\t    /* Output from module. Elaborate the port\n\t\t       expression as the l-value of a continuous\n\t\t       assignment, as the port will continuous assign\n\t\t       into the port. */\n\n\t\t  sig = pins[idx]->elaborate_lnet(des, scope);\n\t\t  if (sig == 0) {\n\t\t\tcerr << pins[idx]->get_fileline() << \": error: \"\n\t\t\t     << \"Output port expression must support \"\n\t\t\t     << \"continuous assignment.\" << endl;\n\t\t\tcerr << pins[idx]->get_fileline() << \":      : Port \"\n\t\t\t     << (idx+1) << \" (\" << port_name << \") of \"\n\t\t\t     << rmod->mod_name() << \" is connected to \"\n\t\t\t     << *pins[idx] << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // If we have a real port driving a bit/vector signal\n\t\t    // then we convert the real value using the appropriate\n\t\t    // width cast. Since a real is only one bit the whole\n\t\t    // thing needs to go to each instance when arrayed.\n\t\t  if ((sig->data_type() != IVL_VT_REAL ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() == IVL_VT_REAL )) {\n\t\t\tif (sig->vector_width() % instance.size() != 0) {\n\t\t\t      cerr << pins[idx]->get_fileline() << \": error: \"\n\t\t\t              \"When automatically converting a real \"\n\t\t\t              \"port of an arrayed instance to a bit \"\n\t\t\t              \"signal\" << endl;\n\t\t\t      cerr << pins[idx]->get_fileline() << \":      : \"\n\t\t\t              \"the signal width (\"\n\t\t\t           << sig->vector_width() << \") must be an \"\n\t\t\t              \"integer multiple of the instance count (\"\n\t\t\t           << instance.size() << \").\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      continue;\n\t\t\t}\n\t\t\tprts_vector_width = sig->vector_width();\n\t\t\tfor (unsigned pidx = 0; pidx < prts.size(); pidx += 1) {\n\t\t\t      prts[pidx] = cast_to_int4(des, scope, prts[pidx],\n\t\t\t                               prts_vector_width /\n\t\t\t                               instance.size());\n\t\t\t}\n\t\t  }\n\n\t\t    // If we have a bit/vector port driving a single real\n\t\t    // signal then we convert the value to a real.\n\t\t  if ((sig->data_type() == IVL_VT_REAL ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() != IVL_VT_REAL )) {\n\t\t\tprts_vector_width -= prts[0]->vector_width() - 1;\n\t\t\tprts[0] = cast_to_real(des, scope, prts[0]);\n\t\t\t  // No support for multiple real drivers.\n\t\t\tif (instance.size() != 1) {\n\t\t\t      cerr << pins[idx]->get_fileline() << \": error: \"\n\t\t\t           << \"Cannot connect an arrayed instance of \"\n\t\t\t              \"module \" << rmod->mod_name() << \" to \"\n\t\t\t              \"real signal \" << sig->name() << \".\"\n\t\t\t           << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      continue;\n\t\t\t}\n\t\t  }\n\n\t\t    // If we have a 4-state bit/vector port driving a\n\t\t    // 2-state signal then we convert the value to 2-state.\n\t\t  if ((sig->data_type() == IVL_VT_BOOL ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() == IVL_VT_LOGIC )) {\n\t\t\tfor (unsigned pidx = 0; pidx < prts.size(); pidx += 1) {\n\t\t\t      prts[pidx] = cast_to_int2(des, scope, prts[pidx],\n\t\t\t                                prts[pidx]->vector_width());\n\t\t\t}\n\t\t  }\n\n\t\t    // A real to real connection is not allowed for arrayed\n\t\t    // instances. You cannot have multiple real drivers.\n\t\t  if ((sig->data_type() == IVL_VT_REAL ) &&\n\t\t      !prts.empty() && (prts[0]->data_type() == IVL_VT_REAL ) &&\n\t\t      instance.size() != 1) {\n\t\t\tcerr << pins[idx]->get_fileline() << \": error: \"\n\t\t\t     << \"An arrayed instance of \" << rmod->mod_name()\n\t\t\t     << \" cannot have a real port (port \" << (idx+1)\n\t\t\t     << \" : \" << port_name << \") connected to a \"\n\t\t\t        \"real signal (\" << sig->name() << \").\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t    }\n\n\t    ivl_assert(*this, sig);\n\n#ifndef NDEBUG\n\t    if ((! prts.empty())\n\t\t&& (ptype != NetNet::PINPUT)) {\n\t\t  ivl_assert(*this, sig->type() != NetNet::REG);\n\t    }\n#endif\n\n\t      /* If we are working with an instance array, then the\n\t\t signal width must match the port width exactly. */\n\t    if ((instance.size() != 1)\n\t\t&& (sig->vector_width() != prts_vector_width)\n\t\t&& (sig->vector_width() != prts_vector_width/instance.size())) {\n\t\t  cerr << pins[idx]->get_fileline() << \": error: \"\n\t\t       << \"Port expression width \" << sig->vector_width()\n\t\t       << \" does not match expected width \"<< prts_vector_width\n\t\t       << \" or \" << (prts_vector_width/instance.size())\n\t\t       << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: \" << get_name()\n\t\t       << \": Port \" << (idx+1) << \" (\" << port_name\n\t\t       << \") has vector width of \" << prts_vector_width\n\t\t       << \".\" << endl;\n\t    }\n\n\t      // Check that the parts have matching pin counts. If\n\t      // not, they are different widths. Note that idx is 0\n\t      // based, but users count parameter positions from 1.\n\t    if ((instance.size() == 1)\n\t\t&& (prts_vector_width != sig->vector_width())) {\n\t\t  bool as_signed = false;\n\n\t\t  switch (ptype) {\n\t\t    case NetNet::POUTPUT:\n\t\t\tas_signed = prts[0]->get_signed();\n\t\t\tbreak;\n\t\t    case NetNet::PINPUT:\n\t\t\tas_signed = sig->get_signed();\n\t\t\tbreak;\n\t\t    case NetNet::PINOUT:\n\t\t\t  /* This may not be correct! */\n\t\t\tas_signed = prts[0]->get_signed() && sig->get_signed();\n\t\t\tbreak;\n\t\t    case NetNet::PREF:\n\t\t\tivl_assert(*this, 0);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tivl_assert(*this, 0);\n\t\t  }\n\n\t\t  cerr << get_fileline() << \": warning: Port \" << (idx+1)\n\t\t       << \" (\" << port_name << \") of \"\n\t\t       << type_ << \" expects \" << prts_vector_width <<\n\t\t\t\" bits, got \" << sig->vector_width() << \".\" << endl;\n\n\t\t    // Delete this when inout ports pad correctly.\n\t\t  if (ptype == NetNet::PINOUT) {\n\t\t     if (prts_vector_width > sig->vector_width()) {\n\t\t\tcerr << get_fileline() << \":        : Leaving \"\n\t\t\t     << (prts_vector_width-sig->vector_width())\n\t\t\t     << \" high bits of the port unconnected.\"\n\t\t\t     << endl;\n\t\t     } else {\n\t\t\tcerr << get_fileline() << \":        : Leaving \"\n\t\t\t     << (sig->vector_width()-prts_vector_width)\n\t\t\t     << \" high bits of the expression dangling.\"\n\t\t\t     << endl;\n\t\t     }\n\t\t    // Keep the if, but delete the \"} else\" when fixed.\n\t\t  } else if (prts_vector_width > sig->vector_width()) {\n\t\t\tcerr << get_fileline() << \":        : Padding \";\n\t\t\tif (as_signed) cerr << \"(signed) \";\n\t\t\tcerr << (prts_vector_width-sig->vector_width())\n\t\t\t     << \" high bits of the port.\"\n\t\t\t     << endl;\n\t\t  } else {\n\t\t\tif (ptype == NetNet::PINPUT) {\n\t\t\t      cerr << get_fileline() << \":        : Pruning \";\n\t\t\t} else {\n\t\t\t      cerr << get_fileline() << \":        : Padding \";\n\t\t\t}\n\t\t\tif (as_signed) cerr << \"(signed) \";\n\t\t\tcerr << (sig->vector_width()-prts_vector_width)\n\t\t\t     << \" high bits of the expression.\"\n\t\t\t     << endl;\n\t\t  }\n\n\t\t  sig = resize_net_to_port_(des, scope, sig, prts_vector_width,\n\t\t\t\t\t    ptype, as_signed);\n\t    }\n\n\t      // Connect the sig expression that is the context of the\n\t      // module instance to the ports of the elaborated module.\n\n\t      // The prts_pin_count variable is the total width of the\n\t      // port and is the maximum number of connections to\n\t      // make. sig is the elaborated expression that connects\n\t      // to that port. If sig has too few pins, then reduce\n\t      // the number of connections to make.\n\n\t      // Connect this many of the port pins. If the expression\n\t      // is too small, then reduce the number of connects.\n\t    unsigned ccount = prts_vector_width;\n\t    if (instance.size() == 1 && sig->vector_width() < ccount)\n\t\t  ccount = sig->vector_width();\n\n\t      // Now scan the concatenation that makes up the port,\n\t      // connecting pins until we run out of port pins or sig\n\t      // pins. The sig object is the NetNet that is connected\n\t      // to the port from the outside, and the prts object is\n\t      // an array of signals to be connected to the sig.\n\n\t    NetConcat*ctmp;\n\n\t    if (prts.size() == 1) {\n\n\t\t    // The simplest case, there are no\n\t\t    // parts/concatenations on the inside of the\n\t\t    // module, so the port and sig need simply be\n\t\t    // connected directly. But don't collapse ports\n\t\t    // that are a delay path destination, to avoid\n\t\t    // the delay being applied to other drivers of\n\t\t    // the external signal.\n\t\t  if (prts[0]->delay_paths() > 0 || (gn_interconnect_flag == true && ptype == NetNet::POUTPUT)) {\n\t\t\t  // FIXME improve this for multiple module instances\n\t\t\tNetScope* inner_scope = scope->instance_arrays[get_name()][0];\n\n\t\t\tisolate_and_connect(des, inner_scope, this, prts[0], sig, ptype, gn_interconnect_flag ? idx : -1);\n\t\t  } else {\n\t\t\tconnect(prts[0]->pin(0), sig->pin(0));\n\t\t  }\n\n\t    } else if (sig->vector_width()==prts_vector_width/instance.size()\n\t\t       && prts.size()/instance.size() == 1) {\n\n\t\t  if (debug_elaborate){\n\t\t\tcerr << get_fileline() << \": debug: \" << get_name()\n\t\t\t     << \": Replicating \" << prts_vector_width\n\t\t\t     << \" bits across all \"\n\t\t\t     << prts_vector_width/instance.size()\n\t\t\t     << \" sub-ports.\" << endl;\n\t\t  }\n\n\t\t    // The signal width is exactly the width of a\n\t\t    // single instance of the port. In this case,\n\t\t    // connect the sig to all the ports identically.\n\t\t  for (unsigned ldx = 0 ;  ldx < prts.size() ;\tldx += 1) {\n\t\t\tif (prts[ldx]->delay_paths() > 0) {\n\t\t\t      isolate_and_connect(des, scope, this, prts[ldx], sig, ptype);\n\t\t\t} else {\n\t\t\t      connect(prts[ldx]->pin(0), sig->pin(0));\n\t\t\t}\n\t\t  }\n\n\t    } else switch (ptype) {\n\t\tcase NetNet::POUTPUT:\n\t\t  ctmp = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t       prts_vector_width, prts.size());\n\t\t  ctmp->set_line(*this);\n\t\t  des->add_node(ctmp);\n\t\t  connect(ctmp->pin(0), sig->pin(0));\n\t\t  for (unsigned ldx = 0 ;  ldx < prts.size() ;  ldx += 1) {\n\t\t\tconnect(ctmp->pin(ldx+1),\n\t\t\t\tprts[prts.size()-ldx-1]->pin(0));\n\t\t  }\n\t\t  break;\n\n\t\tcase NetNet::PINPUT:\n\t\t  if (debug_elaborate){\n\t\t\tcerr << get_fileline() << \": debug: \" << get_name()\n\t\t\t     << \": Dividing \" << prts_vector_width\n\t\t\t     << \" bits across all \"\n\t\t\t     << prts_vector_width/instance.size()\n\t\t\t     << \" input sub-ports of port \"\n\t\t\t     << (idx+1) << \".\" << endl;\n\t\t  }\n\n\t\t  for (unsigned ldx = 0, spin = 0 ;\n\t\t       ldx < prts.size() ;  ldx += 1) {\n\t\t\tNetNet*sp = prts[prts.size()-ldx-1];\n\t\t\tNetPartSelect*ptmp = new NetPartSelect(sig, spin,\n\t\t\t\t\t\t\t   sp->vector_width(),\n\t\t\t\t\t\t\t   NetPartSelect::VP);\n\t\t\tptmp->set_line(*this);\n\t\t\tdes->add_node(ptmp);\n\t\t\tconnect(ptmp->pin(0), sp->pin(0));\n\t\t\tspin += sp->vector_width();\n\t\t  }\n\t\t  break;\n\n\t\tcase NetNet::PINOUT:\n\t\t  for (unsigned ldx = 0, spin = 0 ;\n\t\t       ldx < prts.size() ;  ldx += 1) {\n\t\t\tNetNet*sp = prts[prts.size()-ldx-1];\n\t\t\tNetTran*ttmp = new NetTran(scope,\n\t\t\t                           scope->local_symbol(),\n\t\t\t                           sig->vector_width(),\n\t\t\t                           sp->vector_width(),\n\t\t\t                           spin);\n\t\t\tttmp->set_line(*this);\n\t\t\tdes->add_node(ttmp);\n\t\t\tconnect(ttmp->pin(0), sig->pin(0));\n\t\t\tconnect(ttmp->pin(1), sp->pin(0));\n\t\t\tspin += sp->vector_width();\n\t\t  }\n\t\t  break;\n\n\t\tcase NetNet::PREF:\n\t\t  cerr << get_fileline() << \": sorry: \"\n\t\t       << \"Reference ports not supported yet.\" << endl;\n\t\t  des->errors += 1;\n\t\t  break;\n\n\t\tcase NetNet::PIMPLICIT:\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"Unexpected IMPLICIT port\" << endl;\n\t\t  des->errors += 1;\n\t\t  break;\n\t\tcase NetNet::NOT_A_PORT:\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"Unexpected NOT_A_PORT port.\" << endl;\n\t\t  des->errors += 1;\n\t\t  break;\n\t    }\n\n      }\n\n}\n\n/*\n * From a UDP definition in the source, make a NetUDP\n * object. Elaborate the pin expressions as netlists, then connect\n * those networks to the pins.\n */\n\nvoid PGModule::elaborate_udp_(Design*des, PUdp*udp, NetScope*scope) const\n{\n      NetExpr*rise_expr =0, *fall_expr =0, *decay_expr =0;\n\n      perm_string my_name = get_name();\n      if (my_name == 0)\n\t    my_name = scope->local_symbol();\n\n\t/* When the parser notices delay expressions in front of a\n\t   module or primitive, it interprets them as parameter\n\t   overrides. Correct that misconception here. */\n      if (overrides_) {\n\t    if (overrides_->size() > 2) {\n\t\t  cerr << get_fileline() << \": error: UDPs take at most two \"\n\t\t          \"delay arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  PDelays tmp_del;\n\t\t  tmp_del.set_delays(overrides_, false);\n\t\t  tmp_del.eval_delays(des, scope, rise_expr, fall_expr,\n\t\t                      decay_expr, true);\n\t    }\n      }\n\n      long low = 0, high = 0;\n      unsigned inst_count = calculate_array_size_(des, scope, high, low);\n      if (inst_count == 0) return;\n\n      if (inst_count != 1) {\n\t    cerr << get_fileline() << \": sorry: UDPs with a range (\"\n\t         << my_name << \" [\" << high << \":\" << low << \"]) are \"\n\t         << \"not supported.\" << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n\n      ivl_assert(*this, udp);\n      NetUDP*net = new NetUDP(scope, my_name, udp->ports.size(), udp);\n      net->set_line(*this);\n      net->rise_time(rise_expr);\n      net->fall_time(fall_expr);\n      net->decay_time(decay_expr);\n\n      struct attrib_list_t*attrib_list;\n      unsigned attrib_list_n = 0;\n      attrib_list = evaluate_attributes(attributes, attrib_list_n,\n\t\t\t\t\tdes, scope);\n\n      for (unsigned adx = 0 ;  adx < attrib_list_n ;  adx += 1)\n\t    net->attribute(attrib_list[adx].key, attrib_list[adx].val);\n\n      delete[]attrib_list;\n\n\n\t// This is the array of pin expressions, shuffled to match the\n\t// order of the declaration. If the source instantiation uses\n\t// bind by order, this is the same as the source\n\t// list. Otherwise, the source list is rearranged by name\n\t// binding into this list.\n      vector<PExpr*>pins;\n\n\t// Detect binding by name. If I am binding by name, then make\n\t// up a pins array that reflects the positions of the named\n\t// ports. If this is simply positional binding in the first\n\t// place, then get the binding from the base class.\n      if (pins_) {\n\t    unsigned nexp = udp->ports.size();\n\t    pins = vector<PExpr*>(nexp);\n\n\t      // Scan the bindings, matching them with port names.\n\t    for (unsigned idx = 0 ;  idx < npins_ ;  idx += 1) {\n\n\t\t    // Given a binding, look at the module port names\n\t\t    // for the position that matches the binding name.\n\t\t  unsigned pidx = udp->find_port(pins_[idx].name);\n\n\t\t    // If the port name doesn't exist, the find_port\n\t\t    // method will return the port count. Detect that\n\t\t    // as an error.\n\t\t  if (pidx == nexp) {\n\t\t\tcerr << get_fileline() << \": error: port ``\" <<\n\t\t\t      pins_[idx].name << \"'' is not a port of \"\n\t\t\t     << get_name() << \".\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // If I already bound something to this port, then\n\t\t    // the (*exp) array will already have a pointer\n\t\t    // value where I want to place this expression.\n\t\t  if (pins[pidx]) {\n\t\t\tcerr << get_fileline() << \": error: port ``\" <<\n\t\t\t      pins_[idx].name << \"'' already bound.\" <<\n\t\t\t      endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t    // OK, do the binding by placing the expression in\n\t\t    // the right place.\n\t\t  pins[pidx] = pins_[idx].parm;\n\t    }\n\n      } else {\n\n\t      /* Otherwise, this is a positional list of port\n\t\t connections. In this case, the port count must be\n\t\t right. Check that is is, the get the pin list. */\n\n\t    if (pin_count() != udp->ports.size()) {\n\t\t  cerr << get_fileline() << \": error: Wrong number \"\n\t\t\t\"of ports. Expecting \" << udp->ports.size() <<\n\t\t\t\", got \" << pin_count() << \".\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n\n\t      // No named bindings, just use the positional list I\n\t      // already have.\n\t    ivl_assert(*this, pin_count() == udp->ports.size());\n\t    pins = get_pins();\n      }\n\n\n\t/* Handle the output port of the primitive special. It is an\n\t   output port (the only output port) so must be passed an\n\t   l-value net. */\n      if (pins[0] == 0) {\n\t    cerr << get_fileline() << \": warning: output port unconnected.\"\n\t\t << endl;\n\n      } else {\n\t    NetNet*sig = pins[0]->elaborate_lnet(des, scope);\n\t    if (sig == 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Output port expression is not valid.\" << endl;\n\t\t  cerr << get_fileline() << \":      : Output \"\n\t\t       << \"port of \" << udp->name_\n\t\t       << \" is \" << udp->ports[0] << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    } else {\n\t\t  connect(sig->pin(0), net->pin(0));\n\t    }\n\t    if (sig->vector_width() != 1) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Output port expression \" << *pins[0]\n\t\t       << \" is too wide (\" << sig->vector_width()\n\t\t       << \") expected 1.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n\n\t/* Run through the pins, making netlists for the pin\n\t   expressions and connecting them to the pin in question. All\n\t   of this is independent of the nature of the UDP. */\n      for (unsigned idx = 1 ;  idx < net->pin_count() ;  idx += 1) {\n\t    if (pins[idx] == 0)\n\t\t  continue;\n\n\t    NetExpr*expr_tmp = elab_and_eval(des, scope, pins[idx], 1);\n\t    if (expr_tmp == 0) {\n\t\t  cerr << \"internal error: Expression too complicated \"\n\t\t\t\"for elaboration:\" << *pins[idx] << endl;\n\t\t  continue;\n\t    }\n\t    NetNet*sig = expr_tmp->synthesize(des, scope, expr_tmp);\n\t    ivl_assert(*this, sig);\n\t    sig->set_line(*this);\n\n\t    delete expr_tmp;\n\n\t    connect(sig->pin(0), net->pin(idx));\n\t    if (sig->vector_width() != 1) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Input port expression \" << *pins[idx]\n\t\t       << \" is too wide (\" << sig->vector_width()\n\t\t       << \") expected 1.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n\n\t// All done. Add the object to the design.\n      des->add_node(net);\n}\n\n\nbool PGModule::elaborate_sig(Design*des, NetScope*scope) const\n{\n      if (bound_type_) {\n\t    return elaborate_sig_mod_(des, scope, bound_type_);\n      }\n\n\t// Look for the module type\n      map<perm_string,Module*>::const_iterator mod = pform_modules.find(type_);\n      if (mod != pform_modules.end())\n\t    return elaborate_sig_mod_(des, scope, (*mod).second);\n\n\t// elaborate_sig_udp_ currently always returns true so skip all this\n\t// for now.\n#if 0\n      map<perm_string,PUdp*>::const_iterator udp = pform_primitives.find(type_);\n      if (udp != pform_primitives.end())\n\t    return elaborate_sig_udp_(des, scope, (*udp).second);\n#endif\n\n      return true;\n}\n\n\nvoid PGModule::elaborate(Design*des, NetScope*scope) const\n{\n      if (bound_type_) {\n\t    elaborate_mod_(des, bound_type_, scope);\n\t    return;\n      }\n\n\t// Look for the module type\n      map<perm_string,Module*>::const_iterator mod = pform_modules.find(type_);\n      if (mod != pform_modules.end()) {\n\t    elaborate_mod_(des, (*mod).second, scope);\n\t    return;\n      }\n\n\t// Try a primitive type\n      map<perm_string,PUdp*>::const_iterator udp = pform_primitives.find(type_);\n      if (udp != pform_primitives.end()) {\n\t    ivl_assert(*this, (*udp).second);\n\t    elaborate_udp_(des, (*udp).second, scope);\n\t    return;\n      }\n\n      if (!ignore_missing_modules) {\n        cerr << get_fileline() << \": internal error: Unknown module type: \" <<\n\t      type_ << endl;\n      }\n}\n\nvoid PGModule::elaborate_scope(Design*des, NetScope*sc) const\n{\n\t// If the module type is known by design, then go right to it.\n      if (bound_type_) {\n\t    elaborate_scope_mod_(des, bound_type_, sc);\n\t    return;\n      }\n\n\t// Look for the module type\n      map<perm_string,Module*>::const_iterator mod = pform_modules.find(type_);\n      if (mod != pform_modules.end()) {\n\t    elaborate_scope_mod_(des, mod->second, sc);\n\t    return;\n      }\n\n\t// Try a primitive type\n      map<perm_string,PUdp*>::const_iterator udp = pform_primitives.find(type_);\n      if (udp != pform_primitives.end())\n\t    return;\n\n\t// Not a module or primitive that I know about yet, so try to\n\t// load a library module file (which parses some new Verilog\n\t// code) and try again.\n      int parser_errors = 0;\n      if (load_module(type_, parser_errors)) {\n\n\t      // Try again to find the module type\n\t    mod = pform_modules.find(type_);\n\t    if (mod != pform_modules.end()) {\n\t\t  elaborate_scope_mod_(des, mod->second, sc);\n\t\t  return;\n\t    }\n\n\t      // Try again to find a primitive type\n\t    udp = pform_primitives.find(type_);\n\t    if (udp != pform_primitives.end())\n\t\t  return;\n      }\n\n      if (parser_errors) {\n            cerr << get_fileline() << \": error: Failed to parse library file.\" << endl;\n            des->errors += parser_errors + 1;\n      }\n\n\t// Not a module or primitive that I know about or can find by\n\t// any means, so give up.\n      if (!ignore_missing_modules) {\n        cerr << get_fileline() << \": error: Unknown module type: \" << type_ << endl;\n        missing_modules[type_] += 1;\n        des->errors += 1;\n      }\n}\n\n\nNetProc* Statement::elaborate(Design*des, NetScope*) const\n{\n      cerr << get_fileline() << \": internal error: elaborate: \"\n\t    \"What kind of statement? \" << typeid(*this).name() << endl;\n      NetProc*cur = new NetProc;\n      des->errors += 1;\n      return cur;\n}\n\n\nNetAssign_* PAssign_::elaborate_lval(Design*des, NetScope*scope) const\n{\n\t// A function called as a task does not have an L-value.\n      if (! lval_) {\n\t      // The R-value must be a simple function call.\n\t    assert (dynamic_cast<PECallFunction*>(rval_));\n\t    PExpr::width_mode_t mode = PExpr::SIZED;\n\t    rval_->test_width(des, scope, mode);\n\t      // Create a L-value that matches the function return type.\n\t    NetNet*tmp;\n\t    netvector_t*tmp_vec = new netvector_t(rval_->expr_type(),\n\t                                          rval_->expr_width()-1, 0,\n\t                                          rval_->has_sign());\n\n\t    if(rval_->expr_type() == IVL_VT_DARRAY) {\n\t\tnetdarray_t*darray = new netdarray_t(tmp_vec);\n\t\ttmp = new NetNet(scope, scope->local_symbol(), NetNet::REG, darray);\n\t    } else {\n\t\ttmp = new NetNet(scope, scope->local_symbol(), NetNet::REG, tmp_vec);\n\t    }\n\n\t    tmp->set_file(rval_->get_file());\n\t    tmp->set_lineno(rval_->get_lineno());\n\t    NetAssign_*lv = new NetAssign_(tmp);\n\t    return lv;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PAssign_::elaborate_lval: \"\n\t\t << \"lval_ = \" << *lval_ << endl;\n\t    cerr << get_fileline() << \": PAssign_::elaborate_lval: \"\n\t\t << \"lval_ expr type = \" << typeid(*lval_).name() << endl;\n      }\n\n      return lval_->elaborate_lval(des, scope, false, false, is_init_);\n}\n\nNetExpr* PAssign_::elaborate_rval_(Design*des, NetScope*scope,\n\t\t\t\t   ivl_type_t net_type) const\n{\n      ivl_assert(*this, rval_);\n\n      NetExpr*rv = elaborate_rval_expr(des, scope, net_type, rval_,\n\t\t\t\t       is_constant_);\n\n      if (!is_constant_ || !rv) return rv;\n\n      cerr << get_fileline() << \": error: \"\n            \"The RHS expression must be constant.\" << endl;\n      cerr << get_fileline() << \"       : \"\n            \"This expression violates the rule: \" << *rv << endl;\n      des->errors += 1;\n      delete rv;\n      return 0;\n}\n\nNetExpr* PAssign_::elaborate_rval_(Design*des, NetScope*scope,\n\t\t\t\t   ivl_type_t lv_net_type,\n\t\t\t\t   ivl_variable_type_t lv_type,\n\t\t\t\t   unsigned lv_width,\n\t\t\t\t   bool force_unsigned) const\n{\n      ivl_assert(*this, rval_);\n\n      NetExpr*rv = elaborate_rval_expr(des, scope, lv_net_type, lv_type, lv_width,\n\t\t\t\t       rval(), is_constant_, force_unsigned);\n\n      if (!is_constant_ || !rv) return rv;\n\n      if (dynamic_cast<NetEConst*>(rv)) return rv;\n      if (dynamic_cast<NetECReal*>(rv)) return rv;\n\n      cerr << get_fileline() << \": error: \"\n            \"The RHS expression must be constant.\" << endl;\n      cerr << get_fileline() << \"       : \"\n            \"This expression violates the rule: \" << *rv << endl;\n      des->errors += 1;\n      delete rv;\n      return 0;\n}\n\n/*\n * This function elaborates delay expressions. This is a little\n * different from normal elaboration because the result may need to be\n * scaled.\n */\nstatic NetExpr*elaborate_delay_expr(PExpr*expr, Design*des, NetScope*scope)\n{\n      NetExpr*dex = elab_and_eval(des, scope, expr, -1);\n\n\t// If the elab_and_eval returns nil, then the function\n\t// failed. It should already have printed an error message,\n\t// but we can add some detail. Lets add the error count, just\n\t// in case.\n      if (dex == 0) {\n\t    cerr << expr->get_fileline() << \": error: \"\n\t\t << \"Unable to elaborate (or evaluate) delay expression.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      check_for_inconsistent_delays(scope);\n\n\t/* If the delay expression is a real constant or vector\n\t   constant, then evaluate it, scale it to the local time\n\t   units, and return an adjusted NetEConst. */\n\n      if (NetECReal*tmp = dynamic_cast<NetECReal*>(dex)) {\n\t    uint64_t delay = get_scaled_time_from_real(des, scope, tmp);\n\n\t    delete tmp;\n\t    NetEConst*tmp2 = new NetEConst(verinum(delay, 64));\n\t    tmp2->set_line(*expr);\n\t    return tmp2;\n      }\n\n\n      if (NetEConst*tmp = dynamic_cast<NetEConst*>(dex)) {\n\t    verinum fn = tmp->value();\n\t    uint64_t delay = des->scale_to_precision(fn.as_ulong64(), scope);\n\n\t    delete tmp;\n\t    NetEConst*tmp2 = new NetEConst(verinum(delay, 64));\n\t    tmp2->set_line(*expr);\n\t    return tmp2;\n      }\n\n\n\t/* The expression is not constant, so generate an expanded\n\t   expression that includes the necessary scale shifts, and\n\t   return that expression. */\n      ivl_assert(*expr, dex);\n      if (dex->expr_type() == IVL_VT_REAL) {\n\t      // Scale the real value.\n\t    int shift = scope->time_unit() - scope->time_precision();\n\t    ivl_assert(*expr, shift >= 0);\n\t    double round = 1;\n\t    for (int lp = 0; lp < shift; lp += 1) round *= 10.0;\n\n\t    NetExpr*scal_val = new NetECReal(verireal(round));\n\t    scal_val->set_line(*expr);\n\t    dex = new NetEBMult('*', dex, scal_val, 1, true);\n\t    dex->set_line(*expr);\n\n\t      // Cast this part of the expression to an integer.\n\t    dex = new NetECast('v', dex, 64, false);\n\t    dex->set_line(*expr);\n\n\t      // Now scale the integer value.\n\t    shift = scope->time_precision() - des->get_precision();\n\t    ivl_assert(*expr, shift >= 0);\n\t    uint64_t scale = 1;\n\t    for (int lp = 0; lp < shift; lp += 1) scale *= 10;\n\n\t    scal_val = new NetEConst(verinum(scale, 64));\n\t    scal_val->set_line(*expr);\n\t    dex = new NetEBMult('*', dex, scal_val, 64, false);\n\t    dex->set_line(*expr);\n      } else {\n\t    int shift = scope->time_unit() - des->get_precision();\n\t    ivl_assert(*expr, shift >= 0);\n\t    uint64_t scale = 1;\n\t    for (int lp = 0; lp < shift; lp += 1) scale *= 10;\n\n\t    NetExpr*scal_val = new NetEConst(verinum(scale, 64));\n\t    scal_val->set_line(*expr);\n\t    dex = new NetEBMult('*', dex, scal_val, 64, false);\n\t    dex->set_line(*expr);\n      }\n\n      return dex;\n}\n\nNetProc* PAssign::elaborate_compressed_(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, ! delay_);\n      ivl_assert(*this, ! count_);\n      ivl_assert(*this, ! event_);\n\n      NetAssign_*lv = elaborate_lval(des, scope);\n      if (lv == 0) return 0;\n\n\t// Compressed assignments should behave identically to the\n\t// equivalent uncompressed assignments. This means we need\n\t// to take the type of the LHS into account when determining\n\t// the type of the RHS expression.\n      bool force_unsigned;\n      switch (op_) {\n\t  case 'l':\n\t  case 'r':\n\t  case 'R':\n\t      // The right-hand operand of shift operations is\n\t      // self-determined.\n\t    force_unsigned = false;\n\t    break;\n\t  default:\n\t    force_unsigned = !lv->get_signed();\n\t    break;\n      }\n      NetExpr*rv = elaborate_rval_(des, scope, 0, lv->expr_type(),\n\t\t\t\t   count_lval_width(lv), force_unsigned);\n      if (rv == 0) return 0;\n\n\t// The ivl_target API doesn't support signalling the type\n\t// of a lval, so convert arithmetic shifts into logical\n\t// shifts now if the lval is unsigned.\n      char op = op_;\n      if ((op == 'R') && !lv->get_signed())\n\t    op = 'r';\n\n      NetAssign*cur = new NetAssign(lv, op, rv);\n      cur->set_line(*this);\n\n      return cur;\n}\n\n/*\n * Assignments within program blocks are supposed to be run\n * in the Reactive region, but that is currently not supported\n * so find out if we are assigning to something outside a\n * program block and print a warning for that.\n */\nstatic bool lval_not_program_variable(const NetAssign_*lv)\n{\n      while (lv) {\n\t    NetScope*sig_scope = lv->scope();\n\t    if (! sig_scope->program_block()) return true;\n\t    lv = lv->more;\n      }\n      return false;\n}\n\nNetProc* PAssign::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n\t/* If this is a compressed assignment, then handle the\n\t   elaboration in a specialized function. */\n      if (op_ != 0)\n\t    return elaborate_compressed_(des, scope);\n\n\t/* elaborate the lval. This detects any part selects and mux\n\t   expressions that might exist. */\n      NetAssign_*lv = elaborate_lval(des, scope);\n      if (lv == 0) return 0;\n\n      if (scope->program_block() && lval_not_program_variable(lv)) {\n\t    cerr << get_fileline() << \": warning: Program blocking \"\n\t            \"assignments are not currently scheduled in the \"\n\t            \"Reactive region.\"\n\t         << endl;\n      }\n\n\t/* If there is an internal delay expression, elaborate it. */\n      NetExpr*delay = 0;\n      if (delay_ != 0)\n\t    delay = elaborate_delay_expr(delay_, des, scope);\n\n      NetExpr*rv;\n      const ivl_type_s*lv_net_type = lv->net_type();\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PAssign::elaborate: \";\n\t    if (lv_net_type)\n\t\t  cerr << \"lv_net_type=\" << *lv_net_type << endl;\n\t    else\n\t\t  cerr << \"lv_net_type=<nil>\" << endl;\n      }\n\n\t/* If the l-value is a compound type of some sort, then use\n\t   the newer net_type form of the elaborate_rval_ method to\n\t   handle the new types. */\n      if (dynamic_cast<const netclass_t*> (lv_net_type)) {\n\t    ivl_assert(*this, lv->more==0);\n\t    rv = elaborate_rval_(des, scope, lv_net_type);\n\n      } else if (const netdarray_t*dtype = dynamic_cast<const netdarray_t*> (lv_net_type)) {\n\t    ivl_assert(*this, lv->more==0);\n\t    if (debug_elaborate) {\n\t\t  if (lv->word())\n\t\t\tcerr << get_fileline() << \": PAssign::elaborate: \"\n\t\t\t     << \"lv->word() = \" << *lv->word() << endl;\n\t\t  else\n\t\t\tcerr << get_fileline() << \": PAssign::elaborate: \"\n\t\t\t     << \"lv->word() = <nil>\" << endl;\n\t    }\n\t    ivl_type_t use_lv_type = lv_net_type;\n\t    if (lv->word())\n\t\t  use_lv_type = dtype->element_type();\n\n\t    rv = elaborate_rval_(des, scope, use_lv_type);\n\n      } else if (const netuarray_t*utype = dynamic_cast<const netuarray_t*>(lv_net_type)) {\n\t    ivl_assert(*this, lv->more==0);\n\t    if (debug_elaborate) {\n\t\t  if (lv->word())\n\t\t\tcerr << get_fileline() << \": PAssign::elaborate: \"\n\t\t\t     << \"lv->word() = \" << *lv->word() << endl;\n\t\t  else\n\t\t\tcerr << get_fileline() << \": PAssign::elaborate: \"\n\t\t\t     << \"lv->word() = <nil>\" << endl;\n\t    }\n\t    ivl_type_t use_lv_type = lv_net_type;\n\t    if (lv->word())\n\t\t  use_lv_type = utype->element_type();\n\n\t    ivl_assert(*this, use_lv_type);\n\t    rv = elaborate_rval_(des, scope, use_lv_type);\n\n      } else {\n\t      /* Elaborate the r-value expression, then try to evaluate it. */\n\t    rv = elaborate_rval_(des, scope, lv_net_type, lv->expr_type(), count_lval_width(lv));\n      }\n\n      if (rv == 0) {\n\t    delete lv;\n\t    return 0;\n      }\n      ivl_assert(*this, rv);\n\n      if (count_) ivl_assert(*this, event_);\n\n\t/* Rewrite delayed assignments as assignments that are\n\t   delayed. For example, a = #<d> b; becomes:\n\n\t     begin\n\t        tmp = b;\n\t\t#<d> a = tmp;\n\t     end\n\n\t   If the delay is an event delay, then the transform is\n\t   similar, with the event delay replacing the time delay. It\n\t   is an event delay if the event_ member has a value.\n\n\t   This rewriting of the expression allows me to not bother to\n\t   actually and literally represent the delayed assign in the\n\t   netlist. The compound statement is exactly equivalent. */\n\n      if (delay || event_) {\n\t    unsigned wid = count_lval_width(lv);\n\n\t    netvector_t*tmp2_vec = new netvector_t(rv->expr_type(),wid-1,0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::REG, tmp2_vec);\n\t    tmp->local_flag(true);\n\t    tmp->set_line(*this);\n\n\t    NetESignal*sig = new NetESignal(tmp);\n\n\t      /* Generate an assignment of the l-value to the temporary... */\n\t    NetAssign_*lvt = new NetAssign_(tmp);\n\n\t    NetAssign*a1 = new NetAssign(lvt, rv);\n\t    a1->set_line(*this);\n\n\t      /* Generate an assignment of the temporary to the r-value... */\n\t    NetAssign*a2 = new NetAssign(lv, sig);\n\t    a2->set_line(*this);\n\n\t      /* Generate the delay statement with the final\n\t\t assignment attached to it. If this is an event delay,\n\t\t elaborate the PEventStatement. Otherwise, create the\n\t\t right NetPDelay object. For a repeat event control\n\t\t repeat the event and then do the final assignment.  */\n\t    NetProc*st;\n\t    if (event_) {\n\t\t  if (count_) {\n\t\t\tNetExpr*count = elab_and_eval(des, scope, count_, -1);\n\t\t\tif (count == 0) {\n\t\t\t      cerr << get_fileline() << \": Unable to \"\n\t\t\t              \"elaborate repeat expression.\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\t\t\tst = event_->elaborate(des, scope);\n\t\t\tif (st == 0) {\n\t\t\t      cerr << event_->get_fileline() << \": error: \"\n\t\t\t              \"unable to elaborate event expression.\"\n\t\t\t      << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\t\t\tst->set_line(*this);\n\n\t\t\t  // If the expression is a constant, handle\n\t\t\t  // certain special iteration counts.\n\t\t\tif (NetEConst*ce = dynamic_cast<NetEConst*>(count)) {\n\t\t\t      long val = ce->value().as_long();\n\t\t\t\t// We only need the real statement.\n\t\t\t      if (val <= 0) {\n\t\t\t\t    delete count;\n\t\t\t\t    delete st;\n\t\t\t\t    st = 0;\n\n\t\t\t\t// We don't need the repeat statement.\n\t\t\t      } else if (val == 1) {\n\t\t\t\t    delete count;\n\n\t\t\t\t// We need a repeat statement.\n\t\t\t      } else {\n\t\t\t\t    st = new NetRepeat(count, st);\n\t\t\t\t    st->set_line(*this);\n\t\t\t      }\n\t\t\t} else {\n\t\t\t      st = new NetRepeat(count, st);\n\t\t\t      st->set_line(*this);\n\t\t\t}\n\t\t  } else {\n\t\t\tst = event_->elaborate_st(des, scope, a2);\n\t\t\tif (st == 0) {\n\t\t\t      cerr << event_->get_fileline() << \": error: \"\n\t\t\t              \"unable to elaborate event expression.\"\n\t\t\t      << endl;\n\t\t\t      des->errors += 1;\n\t\t\t      return 0;\n\t\t\t}\n\t\t\tst->set_line(*this);\n\t\t  }\n\t    } else {\n\t\t  NetPDelay*de = new NetPDelay(delay, a2);\n\t\t  de->set_line(*this);\n\t\t  st = de;\n\t    }\n\n\t      /* And build up the complex statement. */\n\t    NetBlock*bl = new NetBlock(NetBlock::SEQU, 0);\n\t    bl->append(a1);\n\t    if (st) bl->append(st);\n\t    if (count_) bl->append(a2);\n\t    bl->set_line(*this);\n\n\t    return bl;\n      }\n\n      NetAssign*cur = new NetAssign(lv, rv);\n      cur->set_line(*this);\n\n      return cur;\n}\n\n/*\n * Elaborate non-blocking assignments. The statement is of the general\n * form:\n *\n *    <lval> <= #<delay> <rval> ;\n */\nNetProc* PAssignNB::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      if (scope->in_func()) {\n\t    cerr << get_fileline() << \": error: functions cannot have non \"\n\t            \"blocking assignment statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->in_final()) {\n\t    cerr << get_fileline() << \": error: final procedures cannot have \"\n\t\t    \"non blocking assignment statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->is_auto() && lval()->has_aa_term(des, scope)) {\n\t    cerr << get_fileline() << \": error: automatically allocated \"\n                    \"variables may not be assigned values using non-blocking \"\n\t            \"assignments.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t/* Elaborate the l-value. */\n      NetAssign_*lv = elaborate_lval(des, scope);\n      if (lv == 0) return 0;\n\n      if (scope->program_block() && lval_not_program_variable(lv)) {\n\t    cerr << get_fileline() << \": warning: Program non-blocking \"\n\t            \"assignments are not currently scheduled in the \"\n\t            \"Reactive-NBA region.\"\n\t         << endl;\n      }\n\n      NetExpr*rv = elaborate_rval_(des, scope, lv->net_type(), lv->expr_type(), count_lval_width(lv));\n      if (rv == 0) return 0;\n\n      NetExpr*delay = 0;\n      if (delay_ != 0) {\n\t    ivl_assert(*this, count_ == 0 && event_ == 0);\n\t    delay = elaborate_delay_expr(delay_, des, scope);\n      }\n\n      NetExpr*count = 0;\n      NetEvWait*event = 0;\n      if (count_ != 0 || event_ != 0) {\n\t    if (count_ != 0) {\n                  if (scope->is_auto() && count_->has_aa_term(des, scope)) {\n                        cerr << get_fileline() << \": error: automatically \"\n                                \"allocated variables may not be referenced \"\n                                \"in intra-assignment event controls of \"\n                                \"non-blocking assignments.\" << endl;\n                        des->errors += 1;\n                        return 0;\n                  }\n\n\t\t  ivl_assert(*this, event_ != 0);\n\t\t  count = elab_and_eval(des, scope, count_, -1);\n\t\t  if (count == 0) {\n\t\t\tcerr << get_fileline() << \": Unable to elaborate \"\n\t\t\t        \"repeat expression.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn 0;\n\t\t  }\n\t    }\n\n            if (scope->is_auto() && event_->has_aa_term(des, scope)) {\n                  cerr << get_fileline() << \": error: automatically \"\n                          \"allocated variables may not be referenced \"\n                          \"in intra-assignment event controls of \"\n                          \"non-blocking assignments.\" << endl;\n                  des->errors += 1;\n                  return 0;\n            }\n\n\t    NetProc*st = event_->elaborate(des, scope);\n\t    if (st == 0) {\n\t\t  cerr << get_fileline() << \": unable to elaborate \"\n\t\t          \"event expression.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    event = dynamic_cast<NetEvWait*>(st) ;\n\t    ivl_assert(*this, event);\n\n\t      // Some constant values are special.\n\t    if (NetEConst*ce = dynamic_cast<NetEConst*>(count)) {\n\t\t  long val = ce->value().as_long();\n\t\t    // We only need the assignment statement.\n\t\t  if (val <= 0) {\n\t\t\tdelete count;\n\t\t\tdelete event;\n\t\t\tcount = 0;\n\t\t\tevent = 0;\n\t\t    // We only need the event.\n\t\t  } else if (val == 1) {\n\t\t\tdelete count;\n\t\t\tcount = 0;\n\t\t  }\n\t    }\n      }\n\n\t/* All done with this node. Mark its line number and check it in. */\n      NetAssignNB*cur = new NetAssignNB(lv, rv, event, count);\n      cur->set_delay(delay);\n      cur->set_line(*this);\n      return cur;\n}\n\n\n/*\n * This is the elaboration method for a begin-end block. Try to\n * elaborate the entire block, even if it fails somewhere. This way I\n * get all the error messages out of it. Then, if I detected a failure\n * then pass the failure up.\n */\nNetProc* PBlock::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      NetBlock::Type type;\n      switch (bl_type_) {\n\t  case PBlock::BL_SEQ:\n\t    type = NetBlock::SEQU;\n\t    break;\n\t  case PBlock::BL_PAR:\n\t    type = NetBlock::PARA;\n\t    break;\n\t  case PBlock::BL_JOIN_NONE:\n\t    type = NetBlock::PARA_JOIN_NONE;\n\t    break;\n\t  case PBlock::BL_JOIN_ANY:\n\t    type = NetBlock::PARA_JOIN_ANY;\n\t    break;\n\t    // Added to remove a \"type\" uninitialized compiler warning.\n\t    // This should never be reached since all the PBlock enumeration\n\t    // cases are handled above.\n\t  default:\n\t    type = NetBlock::SEQU;\n\t    ivl_assert(*this, 0);\n      }\n\n      NetScope*nscope = 0;\n      if (pscope_name() != 0) {\n\t    nscope = scope->child(hname_t(pscope_name()));\n\t    if (nscope == 0) {\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t\t\"unable to find block scope \" << scope_path(scope)\n\t\t       << \".\" << pscope_name() << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    ivl_assert(*this, nscope);\n      }\n\n      NetBlock*cur = new NetBlock(type, nscope);\n\n      if (nscope) {\n\t      // Handle any variable initialization statements in this scope.\n\t      // For automatic scopes these statements need to be executed\n\t      // each time the block is entered, so add them to the main\n\t      // block. For static scopes, put them in a separate process\n\t      // that will be executed at the start of simulation.\n\t    if (nscope->is_auto()) {\n\t\t  for (unsigned idx = 0; idx < var_inits.size(); idx += 1) {\n\t\t\tNetProc*tmp = var_inits[idx]->elaborate(des, nscope);\n\t\t\tif (tmp) cur->append(tmp);\n\t\t  }\n\t    } else {\n\t\t  elaborate_var_inits_(des, nscope);\n\t    }\n      }\n\n      if (nscope == 0)\n\t    nscope = scope;\n\n\t// Handle the special case that the sequential block contains\n\t// only one statement. There is no need to keep the block node.\n\t// Also, don't elide named blocks, because they might be\n\t// referenced elsewhere.\n      if ((type == NetBlock::SEQU) && (list_.size() == 1) &&\n          (pscope_name() == 0)) {\n\t    ivl_assert(*this, list_[0]);\n\t    NetProc*tmp = list_[0]->elaborate(des, nscope);\n\t    return tmp;\n      }\n\n      if (type != NetBlock::SEQU)\n\t    des->fork_enter();\n\n      for (unsigned idx = 0 ;  idx < list_.size() ;  idx += 1) {\n\t    ivl_assert(*this, list_[idx]);\n\n\t      // Detect the error that a super.new() statement is in the\n\t      // midst of a block. Report the error. Continue on with the\n\t      // elaboration so that other errors might be found.\n\t    if (PChainConstructor*supernew = dynamic_cast<PChainConstructor*> (list_[idx])) {\n\t          if (debug_elaborate) {\n\t\t        cerr << get_fileline() << \": PBlock::elaborate: \"\n\t\t\t     << \"Found super.new statement, idx=\" << idx << \", \"\n\t\t\t     << \" at \" << supernew->get_fileline() << \".\"\n\t\t\t     << endl;\n\t\t  }\n\t\t  if (idx > 0) {\n\t\t        des->errors += 1;\n\t\t\tcerr << supernew->get_fileline() << \": error: \"\n\t\t\t     << \"super.new(...) must be the first statement in a block.\"\n\t\t\t     << endl;\n\t\t  }\n\t    }\n\n\t    NetProc*tmp = list_[idx]->elaborate(des, nscope);\n\t      // If the statement fails to elaborate, then simply\n\t      // ignore it. Presumably, the elaborate for the\n\t      // statement already generated an error message and\n\t      // marked the error count in the design so no need to\n\t      // do any of that here.\n\t    if (tmp == 0) {\n\t\t  continue;\n\t    }\n\n\t      // If the result turns out to be a noop, then skip it.\n\t    if (NetBlock*tbl = dynamic_cast<NetBlock*>(tmp))\n\t\t  if (tbl->proc_first() == 0) {\n\t\t\tdelete tbl;\n\t\t\tcontinue;\n\t\t  }\n\n\t    cur->append(tmp);\n      }\n\n      if (type != NetBlock::SEQU)\n\t    des->fork_exit();\n\n\t// Update flags in parent scope.\n      if (!nscope->is_const_func())\n\t    scope->is_const_func(false);\n      if (nscope->calls_sys_task())\n\t    scope->calls_sys_task(true);\n\n      cur->set_line(*this);\n      return cur;\n}\n\nNetProc* PBreak::elaborate(Design*des, NetScope*) const\n{\n      if (!gn_system_verilog()) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t<< \"'break' jump statement requires SystemVerilog.\" << endl;\n\t    des->errors += 1;\n\t    return nullptr;\n      }\n\n\n      NetBreak*res = new NetBreak;\n      res->set_line(*this);\n      return res;\n}\n\nstatic int test_case_width(Design*des, NetScope*scope, PExpr*pe,\n\t\t\t   PExpr::width_mode_t&mode)\n{\n      unsigned expr_width = pe->test_width(des, scope, mode);\n      if (debug_elaborate) {\n\t    cerr << pe->get_fileline() << \": debug: test_width \"\n\t\t << \"of case expression \" << *pe\n\t\t << endl;\n\t    cerr << pe->get_fileline() << \":        \"\n\t\t << \"returns type=\" << pe->expr_type()\n\t\t << \", width=\"      << expr_width\n\t\t << \", signed=\"     << pe->has_sign()\n\t\t << \", mode=\"       << PExpr::width_mode_name(mode)\n\t\t << endl;\n      }\n      return expr_width;\n}\n\nstatic NetExpr*elab_and_eval_case(Design*des, NetScope*scope, PExpr*pe,\n\t\t\t\t  bool context_is_real, bool context_unsigned,\n\t\t\t\t  unsigned context_width)\n{\n      if (context_unsigned)\n\t    pe->cast_signed(false);\n\n      unsigned width = context_is_real ? pe->expr_width() : context_width;\n      NetExpr*expr = pe->elaborate_expr(des, scope, width, PExpr::NO_FLAGS);\n      if (expr == 0) return 0;\n\n      if (context_is_real)\n\t    expr = cast_to_real(expr);\n\n      eval_expr(expr, context_width);\n\n      return expr;\n}\n\n/*\n * Elaborate a case statement.\n */\nNetProc* PCase::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n\t/* The type of the case expression and case item expressions is\n\t   determined according to the following rules:\n\n\t    - if any of the expressions is real, all the expressions are\n\t      evaluated as real (non-real expressions will be treated as\n\t      self-determined, then converted to real)\n\n\t    - otherwise if any of the expressions is unsigned, all the\n\t      expressions are evaluated as unsigned\n\n\t    - otherwise all the expressions are evaluated as signed\n\n\t   If the type is not real, the bit width is determined by the\n\t   largest self-determined width of any of the expressions. */\n\n      PExpr::width_mode_t context_mode = PExpr::SIZED;\n      unsigned context_width = test_case_width(des, scope, expr_, context_mode);\n      bool context_is_real = (expr_->expr_type() == IVL_VT_REAL);\n      bool context_unsigned = !expr_->has_sign();\n\n      for (unsigned idx = 0; idx < items_->size(); idx += 1) {\n\n\t    PCase::Item*cur = (*items_)[idx];\n\n\t    for (list<PExpr*>::iterator idx_expr = cur->expr.begin()\n\t\t ; idx_expr != cur->expr.end() ; ++idx_expr) {\n\n\t\t  PExpr*cur_expr = *idx_expr;\n\t\t  ivl_assert(*this, cur_expr);\n\n\t\t  PExpr::width_mode_t cur_mode = PExpr::SIZED;\n\t\t  unsigned cur_width = test_case_width(des, scope, cur_expr,\n\t\t\t\t\t\t       cur_mode);\n\t\t  if (cur_mode > context_mode)\n\t\t\tcontext_mode = cur_mode;\n\t\t  if (cur_width > context_width)\n\t\t\tcontext_width = cur_width;\n\t\t  if (cur_expr->expr_type() == IVL_VT_REAL)\n\t\t\tcontext_is_real = true;\n\t\t  if (!cur_expr->has_sign())\n\t\t\tcontext_unsigned = true;\n\t    }\n      }\n\n      if (context_is_real) {\n\t    context_width = 1;\n\t    context_unsigned = false;\n\n      } else if (context_mode >= PExpr::LOSSLESS) {\n\n\t      /* Expressions may choose a different size if they are\n\t\t in a lossless context, so we need to run through the\n\t\t process again to get the final expression width. */\n\n\t    context_width = test_case_width(des, scope, expr_, context_mode);\n\n\t    for (unsigned idx = 0; idx < items_->size(); idx += 1) {\n\n\t\t  PCase::Item*cur = (*items_)[idx];\n\n\t\t  for (list<PExpr*>::iterator idx_expr = cur->expr.begin()\n\t\t       ; idx_expr != cur->expr.end() ; ++idx_expr) {\n\n\t\t\tPExpr*cur_expr = *idx_expr;\n\t\t\tivl_assert(*this, cur_expr);\n\n\t\t\tunsigned cur_width = test_case_width(des, scope, cur_expr,\n\t\t\t\t\t\t\t     context_mode);\n\t\t\tif (cur_width > context_width)\n\t\t\t      context_width = cur_width;\n\t\t  }\n\t    }\n\n\t    if (context_width < integer_width)\n\t\t  context_width += 1;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: case context is \";\n\t    if (context_is_real) {\n\t\t  cerr << \"real\" << endl;\n\t    } else {\n\t\t  cerr << (context_unsigned ? \"unsigned\" : \"signed\")\n\t\t       << \" vector, width=\" << context_width << endl;\n\t    }\n      }\n      NetExpr*expr = elab_and_eval_case(des, scope, expr_,\n\t\t\t\t\tcontext_is_real,\n\t\t\t\t\tcontext_unsigned,\n\t\t\t\t\tcontext_width);\n      if (expr == 0) {\n\t    cerr << get_fileline() << \": error: Unable to elaborate this case\"\n\t\t  \" expression.\" << endl;\n\t    return 0;\n      }\n\n\t/* Count the items in the case statement. Note that there may\n\t   be some cases that have multiple guards. Count each as a\n\t   separate item. */\n      unsigned icount = 0;\n      for (unsigned idx = 0 ;  idx < items_->size() ;  idx += 1) {\n\t    PCase::Item*cur = (*items_)[idx];\n\n\t    if (cur->expr.empty())\n\t\t  icount += 1;\n\t    else\n\t\t  icount += cur->expr.size();\n      }\n\n      NetCase*res = new NetCase(quality_, type_, expr, icount);\n      res->set_line(*this);\n\n\t/* Iterate over all the case items (guard/statement pairs)\n\t   elaborating them. If the guard has no expression, then this\n\t   is a \"default\" case. Otherwise, the guard has one or more\n\t   expressions, and each guard is a case. */\n      unsigned inum = 0;\n      for (unsigned idx = 0 ;  idx < items_->size() ;  idx += 1) {\n\n\t    ivl_assert(*this, inum < icount);\n\t    PCase::Item*cur = (*items_)[idx];\n\n\t    if (cur->expr.empty()) {\n\t\t    /* If there are no expressions, then this is the\n\t\t       default case. */\n\t\t  NetProc*st = 0;\n\t\t  if (cur->stat)\n\t\t\tst = cur->stat->elaborate(des, scope);\n\n\t\t  res->set_case(inum, 0, st);\n\t\t  inum += 1;\n\n\t    } else for (list<PExpr*>::iterator idx_expr = cur->expr.begin()\n\t\t\t      ; idx_expr != cur->expr.end() ; ++idx_expr) {\n\n\t\t    /* If there are one or more expressions, then\n\t\t       iterate over the guard expressions, elaborating\n\t\t       a separate case for each. (Yes, the statement\n\t\t       will be elaborated again for each.) */\n\t\t  PExpr*cur_expr = *idx_expr;\n\t\t  ivl_assert(*this, cur_expr);\n\t\t  NetExpr*gu = elab_and_eval_case(des, scope, cur_expr,\n\t\t\t\t\t\t  context_is_real,\n\t\t\t\t\t\t  context_unsigned,\n\t\t\t\t\t\t  context_width);\n\n\t\t  NetProc*st = 0;\n\t\t  if (cur->stat)\n\t\t\tst = cur->stat->elaborate(des, scope);\n\n\t\t  res->set_case(inum, gu, st);\n\t\t  inum += 1;\n\t    }\n      }\n\n      res->prune();\n\n      return res;\n}\n\nNetProc* PChainConstructor::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PChainConstructor::elaborate: \"\n\t\t << \"Elaborate constructor chain in scope=\" << scope_path(scope) << endl;\n      }\n\n\t// The scope is the <class>.new function, so scope->parent()\n\t// is the class. Use that to get the class type that we are\n\t// constructing.\n      NetScope*scope_class = scope->parent();\n      const netclass_t*class_this = scope_class->class_def();\n      ivl_assert(*this, class_this);\n\n\t// We also need the super-class.\n      const netclass_t*class_super = class_this->get_super();\n      if (class_super == 0) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Class \" << class_this->get_name()\n\t\t << \" has no parent class for super.new constructor chaining.\" << endl;\n\t    des->errors += 1;\n\t    NetBlock*tmp = new NetBlock(NetBlock::SEQU, 0);\n\t    tmp->set_line(*this);\n\t    return tmp;\n      }\n\n\t// Need the \"this\" variable for the current constructor. We're\n\t// going to pass this to the chained constructor.\n      NetNet*var_this = scope->find_signal(perm_string::literal(THIS_TOKEN));\n\n\t// If super.new(...) is a user defined constructor, then call\n\t// it. This is a bit more complicated because there may be arguments.\n      if (NetScope*new_scope = class_super->get_constructor()) {\n\n\t    int missing_parms = 0;\n\t    NetFuncDef*def = new_scope->func_def();\n\t    ivl_assert(*this, def);\n\n\t    NetESignal*eres = new NetESignal(var_this);\n\t    vector<NetExpr*> parms (def->port_count());\n\t    parms[0] = eres;\n\n\t    auto args = map_named_args(des, def, parms_, 1);\n\t    for (size_t idx = 1 ; idx < parms.size() ; idx += 1) {\n\t\t  if (args[idx - 1]) {\n\t\t\tparms[idx] = elaborate_rval_expr(des, scope,\n\t\t\t\t\t\t\t def->port(idx)->net_type(),\n\t\t\t\t\t\t\t args[idx - 1], false);\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  if (NetExpr*tmp = def->port_defe(idx)) {\n\t\t\tparms[idx] = tmp->dup_expr();\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  missing_parms += 1;\n\t\t  parms[idx] = 0;\n\t    }\n\n\t    if (missing_parms) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Missing \" << missing_parms\n\t\t       << \" arguments to constructor \" << scope_path(new_scope) << \".\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    NetEUFunc*tmp = new NetEUFunc(scope, new_scope, eres, parms, true);\n\t    tmp->set_line(*this);\n\n\t    NetAssign_*lval_this = new NetAssign_(var_this);\n\t    NetAssign*stmt = new NetAssign(lval_this, tmp);\n\t    stmt->set_line(*this);\n\t    return stmt;\n      }\n\n\t// There is no constructor at all in the parent, so skip it.\n      NetBlock*tmp = new NetBlock(NetBlock::SEQU, 0);\n      tmp->set_line(*this);\n      return tmp;\n}\n\nNetProc* PCondit::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      if (debug_elaborate)\n\t    cerr << get_fileline() << \":  PCondit::elaborate: \"\n\t\t << \"Elaborate condition statement\"\n\t\t << \" with conditional: \" << *expr_ << endl;\n\n\t// Elaborate and try to evaluate the conditional expression.\n      NetExpr*expr = elab_and_eval(des, scope, expr_, -1);\n      if (expr == 0) {\n\t    cerr << get_fileline() << \": error: Unable to elaborate\"\n\t\t  \" condition expression.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// If the condition of the conditional statement is constant,\n\t// then look at the value and elaborate either the if statement\n\t// or the else statement. I don't need both. If there is no\n\t// else_ statement, then use an empty block as a noop.\n      if (NetEConst*ce = dynamic_cast<NetEConst*>(expr)) {\n\t    verinum val = ce->value();\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: Condition expression \"\n\t\t       << \"is a constant \" << val << \".\" << endl;\n\t    }\n\n\t    verinum::V reduced = verinum::V0;\n\t    for (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t\t  reduced = reduced | val[idx];\n\n\t    delete expr;\n\t    if (reduced == verinum::V1)\n\t\t  if (if_) {\n\t\t\treturn if_->elaborate(des, scope);\n\t\t  } else {\n\t\t\tNetBlock*tmp = new NetBlock(NetBlock::SEQU, 0);\n\t\t\ttmp->set_line(*this);\n\t\t\treturn tmp;\n\t\t  }\n\t    else if (else_)\n\t\t  return else_->elaborate(des, scope);\n\t    else\n\t\t  return new NetBlock(NetBlock::SEQU, 0);\n      }\n\n\t// If the condition expression is more than 1 bits, then\n\t// generate a comparison operator to get the result down to\n\t// one bit. Turn <e> into <e> != 0;\n\n      if (expr->expr_width() < 1) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t  \"incomprehensible expression width (0).\" << endl;\n\t    return 0;\n      }\n\n\t// Make sure the condition expression evaluates to a condition.\n      expr = condition_reduce(expr);\n\n\t// Well, I actually need to generate code to handle the\n\t// conditional, so elaborate.\n      NetProc*i = if_? if_->elaborate(des, scope) : NULL;\n      NetProc*e = else_? else_->elaborate(des, scope) : NULL;\n\n\t// Detect the special cases that the if or else statements are\n\t// empty blocks. If this is the case, remove the blocks as\n\t// null statements.\n      if (NetBlock*tmp = dynamic_cast<NetBlock*>(i)) {\n\t    if (tmp->proc_first() == 0) {\n\t\t  delete i;\n\t\t  i = 0;\n\t    }\n      }\n\n      if (NetBlock*tmp = dynamic_cast<NetBlock*>(e)) {\n\t    if (tmp->proc_first() == 0) {\n\t\t  delete e;\n\t\t  e = 0;\n\t    }\n      }\n\n      NetCondit*res = new NetCondit(expr, i, e);\n      res->set_line(*this);\n      return res;\n}\n\nNetProc* PContinue::elaborate(Design*des, NetScope*) const\n{\n      if (!gn_system_verilog()) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t<< \"'continue' jump statement requires SystemVerilog.\" << endl;\n\t    des->errors += 1;\n\t    return nullptr;\n      }\n\n      NetContinue*res = new NetContinue;\n      res->set_line(*this);\n      return res;\n}\n\nNetProc* PCallTask::elaborate(Design*des, NetScope*scope) const\n{\n      if (peek_tail_name(path_)[0] == '$') {\n\t    if (void_cast_)\n\t\t  return elaborate_non_void_function_(des, scope);\n\t    else\n\t\t  return elaborate_sys(des, scope);\n      } else {\n\t    return elaborate_usr(des, scope);\n      }\n}\n\n/*\n * A call to a system task involves elaborating all the parameters,\n * then passing the list to the NetSTask object.\n *XXXX\n * There is a single special case in the call to a system\n * task. Normally, an expression cannot take an unindexed\n * memory. However, it is possible to take a system task parameter a\n * memory if the expression is trivial.\n */\nNetProc* PCallTask::elaborate_sys(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      if (path_.size() > 1) {\n\t    cerr << get_fileline() << \": error: Hierarchical system task names\"\n\t\t << \" make no sense: \" << path_ << endl;\n\t    des->errors += 1;\n      }\n\n      unsigned parm_count = parms_.size();\n      vector<NetExpr*>eparms (parm_count);\n\n      perm_string name = peek_tail_name(path_);\n\n      for (unsigned idx = 0 ;  idx < parm_count ;  idx += 1) {\n\t    auto &parm = parms_[idx];\n\n\t    // System functions don't have named parameters\n\t    if (!parm.name.nil()) {\n\t\t  cerr << parm.get_fileline() << \": error: \"\n\t\t       << \"The system task `\" << name\n\t\t       << \"` has no argument called `\" << parm.name\n\t\t       << \"`.\" << endl;\n\t\t  des->errors++;\n\t    }\n\n\t    eparms[idx] = elab_sys_task_arg(des, scope, name, idx,\n\t\t\t\t\t    parm.parm);\n      }\n\n\t// Special case: Specify blocks and interconnects are turned off,\n\t// and this is an $sdf_annotate system task. There will be nothing for\n\t// $sdf to annotate, and the user is intending to turn the behavior\n\t// off anyhow, so replace the system task invocation with a no-op.\n      if (gn_specify_blocks_flag == false && gn_interconnect_flag == false && name == \"$sdf_annotate\") {\n\n\t    cerr << get_fileline() << \": warning: Omitting $sdf_annotate() \"\n\t         << \"since specify blocks and interconnects are being omitted.\" << endl;\n\t    NetBlock*noop = new NetBlock(NetBlock::SEQU, scope);\n\t    noop->set_line(*this);\n\t    return noop;\n      }\n\n      scope->calls_sys_task(true);\n\n      NetSTask*cur = new NetSTask(name, def_sfunc_as_task, eparms);\n      cur->set_line(*this);\n      return cur;\n}\n\n/*\n * A call to a user defined task is different from a call to a system\n * task because a user task in a netlist has no parameters: the\n * assignments are done by the calling thread. For example:\n *\n *  task foo;\n *    input a;\n *    output b;\n *    [...]\n *  endtask;\n *\n *  [...] foo(x, y);\n *\n * is really:\n *\n *  task foo;\n *    reg a;\n *    reg b;\n *    [...]\n *  endtask;\n *\n *  [...]\n *  begin\n *    a = x;\n *    foo;\n *    y = b;\n *  end\n */\nNetProc* PCallTask::elaborate_usr(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      NetScope*pscope = scope;\n      if (package_) {\n\t    pscope = des->find_package(package_->pscope_name());\n\t    ivl_assert(*this, pscope);\n      }\n\n      NetScope*task = des->find_task(pscope, path_);\n      if (task == 0) {\n\t      // For SystemVerilog this may be a few other things.\n\t    if (gn_system_verilog()) {\n\t\t  NetProc *tmp;\n\t\t    // This could be a method attached to a signal\n\t\t    // or defined in this object?\n\t\t  bool try_implicit_this = scope->get_class_scope() && path_.size() == 1;\n\t\t  tmp = elaborate_method_(des, scope, try_implicit_this);\n\t\t  if (tmp) return tmp;\n\t\t    // Or it could be a function call ignoring the return?\n\t\t  tmp = elaborate_function_(des, scope);\n\t\t  if (tmp) return tmp;\n\t    }\n\n\t    cerr << get_fileline() << \": error: Enable of unknown task \"\n\t\t << \"``\" << path_ << \"''.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      ivl_assert(*this, task);\n      ivl_assert(*this, task->type() == NetScope::TASK);\n      NetTaskDef*def = task->task_def();\n      if (def == 0) {\n\t    cerr << get_fileline() << \": internal error: task \" << path_\n\t\t << \" doesn't have a definition in \" << scope_path(scope)\n\t\t << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n      ivl_assert(*this, def);\n\n\t/* In SystemVerilog a method calling another method in the\n\t * current class needs to be elaborated as a method with an\n\t * implicit this added.  */\n      if (gn_system_verilog() && (path_.size() == 1)) {\n\t    const NetScope *c_scope = scope->get_class_scope();\n\t    if (c_scope && (c_scope == task->get_class_scope())) {\n\t\t  NetProc *tmp = elaborate_method_(des, scope, true);\n\t\t  ivl_assert(*this, tmp);\n\t\t  return tmp;\n\t    }\n      }\n\n      unsigned parm_count = def->port_count();\n\n\t/* Handle non-automatic tasks with no parameters specially. There is\n           no need to make a sequential block to hold the generated code. */\n      if ((parm_count == 0) && !task->is_auto()) {\n\t      // Check if a task call is allowed in this context.\n\t    test_task_calls_ok_(des, scope);\n\n\t    NetUTask*cur = new NetUTask(task);\n\t    cur->set_line(*this);\n\t    return cur;\n      }\n\n      return elaborate_build_call_(des, scope, task, 0);\n}\n\n/*\n * This private method is called to elaborate built-in methods. The\n * method_name is the detected name of the built-in method, and the\n * sys_task_name is the internal system-task name to use.\n */\nNetProc* PCallTask::elaborate_sys_task_method_(Design*des, NetScope*scope,\n\t\t\t\t\t       NetNet*net,\n\t\t\t\t\t       perm_string method_name,\n\t\t\t\t\t       const char *sys_task_name,\n\t\t\t\t\t       const std::vector<perm_string> &parm_names) const\n{\n      NetESignal*sig = new NetESignal(net);\n      sig->set_line(*this);\n\n      unsigned nparms = parms_.size();\n\n      vector<NetExpr*>argv (1 + nparms);\n      argv[0] = sig;\n\n      if (method_name == \"delete\") {\n\t      // The queue delete method takes an optional element.\n\t    if (net->queue_type()) {\n\t\t  if (nparms > 1)  {\n\t\t\tcerr << get_fileline() << \": error: queue delete() \"\n\t\t\t     << \"method takes zero or one argument.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t    } else if (nparms > 0) {\n\t\t  cerr << get_fileline() << \": error: darray delete() \"\n\t\t       << \"method takes no arguments.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      } else if (parm_names.size() != parms_.size()) {\n\t    cerr << get_fileline() << \": error: \" << method_name\n\t         << \"() method takes \" << parm_names.size() << \" arguments, got \"\n\t\t << parms_.size() << \".\" << endl;\n\t    des->errors++;\n      }\n\n      auto args = map_named_args(des, parm_names, parms_);\n      for (unsigned idx = 0 ; idx < nparms ; idx += 1) {\n\t    argv[idx + 1] = elab_sys_task_arg(des, scope, method_name,\n\t\t\t\t\t      idx, args[idx]);\n      }\n\n      NetSTask*sys = new NetSTask(sys_task_name, IVL_SFUNC_AS_TASK_IGNORE, argv);\n      sys->set_line(*this);\n      return sys;\n}\n\n/*\n * This private method is called to elaborate queue push methods. The\n * sys_task_name is the internal system-task name to use.\n */\nNetProc* PCallTask::elaborate_queue_method_(Design*des, NetScope*scope,\n\t\t\t\t\t    NetNet*net,\n\t\t\t\t\t    perm_string method_name,\n\t\t\t\t\t    const char *sys_task_name,\n\t\t\t\t\t    const std::vector<perm_string> &parm_names) const\n{\n      NetESignal*sig = new NetESignal(net);\n      sig->set_line(*this);\n\n      unsigned nparms = parms_.size();\n\t// insert() requires two arguments.\n      if ((method_name == \"insert\") && (nparms != 2)) {\n\t    cerr << get_fileline() << \": error: \" << method_name\n\t\t << \"() method requires two arguments.\" << endl;\n\t    des->errors += 1;\n      }\n\t// push_front() and push_back() require one argument.\n      if ((method_name != \"insert\") && (nparms != 1)) {\n\t    cerr << get_fileline() << \": error: \" << method_name\n\t\t << \"() method requires a single argument.\" << endl;\n\t    des->errors += 1;\n      }\n\n\t// Get the context width if this is a logic type.\n      ivl_variable_type_t base_type = net->darray_type()->element_base_type();\n      int context_width = -1;\n      switch (base_type) {\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC:\n\t    context_width = net->darray_type()->element_width();\n\t    break;\n\t  default:\n\t    break;\n      }\n\n      vector<NetExpr*>argv (nparms+1);\n      argv[0] = sig;\n\n      auto args = map_named_args(des, parm_names, parms_);\n      if (method_name != \"insert\") {\n\t    if (nparms == 0 || !args[0]) {\n\t\t  argv[1] = nullptr;\n\t\t  cerr << get_fileline() << \": error: \" << method_name\n\t\t       << \"() methods first argument is missing.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  argv[1] = elab_and_eval(des, scope, args[0], context_width,\n\t\t                          false, false, base_type);\n\t    }\n      } else {\n\t    if (nparms == 0 || !args[0]) {\n\t\t  argv[1] = nullptr;\n\t\t  cerr << get_fileline() << \": error: \" << method_name\n\t\t       << \"() methods first argument is missing.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  argv[1] = elab_and_eval(des, scope, args[0], context_width,\n\t\t                          false, false, IVL_VT_LOGIC);\n\t    }\n\n\t    if (nparms < 2 || !args[1]) {\n\t\t  argv[2] = nullptr;\n\t\t  cerr << get_fileline() << \": error: \" << method_name\n\t\t       << \"() methods second argument is missing.\" << endl;\n\t\t  des->errors += 1;\n\t    } else {\n\t\t  argv[2] = elab_and_eval(des, scope, args[1], context_width,\n\t\t                          false, false, base_type);\n\t    }\n      }\n\n      NetSTask*sys = new NetSTask(sys_task_name, IVL_SFUNC_AS_TASK_IGNORE, argv);\n      sys->set_line(*this);\n      return sys;\n}\n\n/*\n * This is used for array/queue function methods called as tasks.\n */\nNetProc* PCallTask::elaborate_method_func_(NetScope*scope,\n                                           NetNet*net,\n\t\t\t\t\t   ivl_type_t type,\n\t\t\t\t\t   perm_string method_name,\n                                           const char*sys_task_name) const\n{\n      if (!void_cast_) {\n\t    cerr << get_fileline() << \": warning: method function '\"\n\t\t << method_name << \"' is being called as a task.\" << endl;\n      }\n\n\t// Generate the function.\n      NetESFunc*sys_expr = new NetESFunc(sys_task_name, type, 1);\n      sys_expr->set_line(*this);\n      NetESignal*arg = new NetESignal(net);\n      arg->set_line(*net);\n      sys_expr->parm(0, arg);\n\t// Create a L-value that matches the function return type.\n      NetNet*tmp;\n      tmp = new NetNet(scope, scope->local_symbol(), NetNet::REG, type);\n      tmp->set_line(*this);\n      NetAssign_*lv = new NetAssign_(tmp);\n\t// Generate an assign to the fake L-value.\n      NetAssign*cur = new NetAssign(lv, sys_expr);\n      cur->set_line(*this);\n      return cur;\n}\n\nNetProc* PCallTask::elaborate_method_(Design*des, NetScope*scope,\n                                      bool add_this_flag) const\n{\n      pform_name_t use_path = path_;\n      perm_string method_name = peek_tail_name(use_path);\n      use_path.pop_back();\n\n\t/* Add the implicit this reference when requested. */\n      if (add_this_flag) {\n\t    ivl_assert(*this, use_path.empty());\n\t    use_path.push_front(name_component_t(perm_string::literal(THIS_TOKEN)));\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PCallTask::elaborate_method_: \"\n\t\t << \"use_path=\" << use_path\n\t\t << \", method_name=\" << method_name\n\t\t << \", add_this_flag=\" << add_this_flag\n\t\t << endl;\n      }\n\n\t// There is no signal to search for so this cannot be a method.\n      if (use_path.empty()) return 0;\n\n\t// Search for an object using the use_path. This should\n\t// resolve to a class object. Note that the \"this\" symbol\n\t// (internally represented as \"@\") is handled by there being a\n\t// \"this\" object in the instance scope.\n      symbol_search_results sr;\n      symbol_search(this, des, scope, use_path, UINT_MAX, &sr);\n\n      NetNet*net = sr.net;\n      if (net == 0)\n\t    return 0;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PCallTask::elaborate_method_: \"\n\t\t << \"Try to match method \" << method_name\n\t\t << \" of object \" << net->name()\n\t\t << \".\" << endl;\n\t    if (net->net_type())\n\t\t  cerr << get_fileline() << \": PCallTask::elaborate_method_: \"\n\t\t       << net->name() << \".net_type() --> \"\n\t\t       << *net->net_type() << endl;\n\t    cerr << get_fileline() << \": PCallTask::elaborate_method_: \"\n\t\t << net->name() << \".data_type() --> \" << net->data_type() << endl;\n      }\n\n      // Is this a method of a \"string\" type?\n      if (dynamic_cast<const netstring_t*>(net->net_type())) {\n\t    if (method_name == \"itoa\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"i\")\n\t\t  };\n\n\t\t  return elaborate_sys_task_method_(des, scope, net, method_name,\n\t\t\t\t\t\t    \"$ivl_string_method$itoa\",\n\t\t\t\t\t\t    parm_names);\n\t    } else if (method_name == \"hextoa\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"i\")\n\t\t  };\n\n\t\t  return elaborate_sys_task_method_(des, scope, net, method_name,\n\t\t\t\t\t\t    \"$ivl_string_method$hextoa\",\n\t\t\t\t\t\t    parm_names);\n\t    } else if (method_name == \"octtoa\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"i\")\n\t\t  };\n\n\t\t  return elaborate_sys_task_method_(des, scope, net, method_name,\n\t\t\t\t\t\t    \"$ivl_string_method$octtoa\",\n\t\t\t\t\t\t    parm_names);\n\t    } else if (method_name == \"bintoa\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"i\")\n\t\t  };\n\n\t\t  return elaborate_sys_task_method_(des, scope, net, method_name,\n\t\t\t\t\t\t    \"$ivl_string_method$bintoa\",\n\t\t\t\t\t\t    parm_names);\n\t    } else if (method_name == \"realtoa\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"r\")\n\t\t  };\n\n\t\t  return elaborate_sys_task_method_(des, scope, net, method_name,\n\t\t\t\t\t\t    \"$ivl_string_method$realtoa\",\n\t\t\t\t\t\t    parm_names);\n\t    }\n      }\n\n\t// Is this a delete method for dynamic arrays or queues?\n      if (net->darray_type()) {\n\t    if (method_name == \"delete\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"index\")\n\t\t  };\n\n\t\t  return elaborate_sys_task_method_(des, scope, net, method_name,\n\t\t                                    \"$ivl_darray_method$delete\",\n\t\t\t\t\t\t    parm_names);\n\t    } else if (method_name == \"size\") {\n\t\t    // This returns an int. It could be removed, but keep for now.\n\t\t  return elaborate_method_func_(scope, net,\n\t\t                                &netvector_t::atom2s32,\n\t\t                                method_name, \"$size\");\n\t    } else if (method_name == \"reverse\") {\n\t\t  cerr << get_fileline() << \": sorry: 'reverse()' \"\n\t\t          \"array sorting method is not currently supported.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    } else if (method_name==\"sort\") {\n\t\t  cerr << get_fileline() << \": sorry: 'sort()' \"\n\t\t          \"array sorting method is not currently supported.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    } else if (method_name==\"rsort\") {\n\t\t  cerr << get_fileline() << \": sorry: 'rsort()' \"\n\t\t          \"array sorting method is not currently supported.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    } else if (method_name==\"shuffle\") {\n\t\t  cerr << get_fileline() << \": sorry: 'shuffle()' \"\n\t\t          \"array sorting method is not currently supported.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n      }\n\n      if (net->queue_type()) {\n\t    const netdarray_t*use_darray = net->darray_type();\n\t    if (method_name == \"push_back\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"item\")\n\t\t  };\n\n\t\t  return elaborate_queue_method_(des, scope, net, method_name,\n\t\t\t\t\t\t \"$ivl_queue_method$push_back\",\n\t\t\t\t\t\t parm_names);\n\t    } else if (method_name == \"push_front\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"item\")\n\t\t  };\n\n\t\t  return elaborate_queue_method_(des, scope, net, method_name,\n\t\t\t\t\t\t \"$ivl_queue_method$push_front\",\n\t\t\t\t\t\t parm_names);\n\t    } else if (method_name == \"insert\") {\n\t\t  static const std::vector<perm_string> parm_names = {\n\t\t\tperm_string::literal(\"index\"),\n\t\t\tperm_string::literal(\"item\")\n\t\t  };\n\n\t\t  return elaborate_queue_method_(des, scope, net, method_name,\n\t\t\t\t\t\t \"$ivl_queue_method$insert\",\n\t\t\t\t\t\t parm_names);\n\t    } else if (method_name == \"pop_front\") {\n\t\t  return elaborate_method_func_(scope, net,\n\t\t                                use_darray->element_type(),\n\t\t                                method_name,\n\t\t                                \"$ivl_queue_method$pop_front\");\n\t    } else if (method_name == \"pop_back\") {\n\t\t  return elaborate_method_func_(scope, net,\n\t\t                                use_darray->element_type(),\n\t\t                                method_name,\n\t\t                                \"$ivl_queue_method$pop_back\");\n\t    }\n      }\n\n      if (const netclass_t*class_type = dynamic_cast<const netclass_t*>(sr.type)) {\n\t    NetScope*task = class_type->method_from_name(method_name);\n\t    if (task == 0) {\n\t\t    // If an implicit this was added it is not an error if we\n\t\t    // don't find a method. It might actually be a call to a\n\t\t    // function outside of the class.\n\t\t  if (!add_this_flag) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Can't find task \" << method_name\n\t\t\t     << \" in class \" << class_type->get_name() << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  return 0;\n\t    }\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PCallTask::elaborate_method_: \"\n\t\t       << \"Elaborate \" << class_type->get_name()\n\t\t       << \" method \" << task->basename() << endl;\n\t    }\n\n\t    NetESignal*use_this = new NetESignal(net);\n\t    use_this->set_line(*this);\n\n\t    return elaborate_build_call_(des, scope, task, use_this);\n      }\n\n      return 0;\n}\n\n/*\n * If during elaboration we determine (for sure) that we are calling a\n * task (and not just a void function) then this method tests if that\n * task call is allowed in the current context. If so, return true. If\n * not, print an error message and return false;\n */\nbool PCallTask::test_task_calls_ok_(Design*des, NetScope*scope) const\n{\n      if (scope->in_func()) {\n\t    cerr << get_fileline() << \": error: Functions cannot enable/call \"\n\t            \"tasks.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      if (scope->in_final()) {\n\t    cerr << get_fileline() << \": error: final procedures cannot \"\n\t            \"enable/call tasks.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      return true;\n}\n\nNetProc *PCallTask::elaborate_non_void_function_(Design *des, NetScope *scope) const\n{\n\t// Generate a function call version of this task call.\n      PExpr*rval = new PECallFunction(package_, path_, parms_);\n      rval->set_file(get_file());\n      rval->set_lineno(get_lineno());\n\t// Generate an assign to nothing.\n      PAssign*tmp = new PAssign(0, rval);\n      tmp->set_file(get_file());\n      tmp->set_lineno(get_lineno());\n      if (!void_cast_) {\n\t    cerr << get_fileline() << \": warning: User function '\"\n\t\t << peek_tail_name(path_) << \"' is being called as a task.\" << endl;\n      }\n\n\t// Elaborate the assignment to a dummy variable.\n      return tmp->elaborate(des, scope);\n}\n\nNetProc* PCallTask::elaborate_function_(Design*des, NetScope*scope) const\n{\n      NetFuncDef*func = des->find_function(scope, path_);\n\n\t// This is not a function, so this task call cannot be a function\n\t// call with a missing return assignment.\n      if (!func)\n\t    return nullptr;\n\n      if (gn_system_verilog() && func->is_void())\n\t    return elaborate_void_function_(des, scope, func);\n\n      return elaborate_non_void_function_(des, scope);\n}\n\nNetProc* PCallTask::elaborate_void_function_(Design*des, NetScope*scope,\n\t\t\t\t\t     NetFuncDef*def) const\n{\n      NetScope*dscope = def->scope();\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PCallTask::elaborate_void_function_: \"\n\t\t << \"function void \" << scope_path(dscope)\n\t\t << endl;\n      }\n\n\t// If we haven't already elaborated the function, do so now.\n\t// This allows elaborate_build_call_ to elide the function call\n\t// if the function body is empty.\n      if (dscope->elab_stage() < 3) {\n\t    const PFunction*pfunc = dscope->func_pform();\n\t    ivl_assert(*this, pfunc);\n\t    pfunc->elaborate(des, dscope);\n      }\n      return elaborate_build_call_(des, scope, dscope, 0);\n}\n\nNetProc* PCallTask::elaborate_build_call_(Design*des, NetScope*scope,\n\t\t\t\t\t  NetScope*task, NetExpr*use_this) const\n{\n      NetBaseDef*def = 0;\n      if (task->type() == NetScope::TASK) {\n\t    def = task->task_def();\n\n\t      // OK, this is certainly a TASK that I'm calling. Make\n\t      // sure that is OK where I am. Even if this test fails,\n\t      // continue with the elaboration as if it were OK so\n\t      // that we can catch more errors.\n\t    test_task_calls_ok_(des, scope);\n\n\t    if (void_cast_) {\n\t\t  cerr << get_fileline() << \": error: void casting user task '\"\n\t\t       << peek_tail_name(path_) << \"' is not allowed.\" << endl;\n\t\t  des->errors++;\n\t    }\n\n      } else if (task->type() == NetScope::FUNC) {\n\t    NetFuncDef*tmp = task->func_def();\n\t    if (!tmp->is_void())\n\t\t  return elaborate_non_void_function_(des, scope);\n\t    def = tmp;\n\n\t    if (void_cast_) {\n\t\t  cerr << get_fileline() << \": error: void casting user void function '\"\n\t\t       << peek_tail_name(path_) << \"' is not allowed.\" << endl;\n\t\t  des->errors++;\n\t    }\n      }\n\n\t/* The caller has checked the parms_ size to make sure it\n\t   matches the task definition, so we can just use the task\n\t   definition to get the parm_count. */\n\n      unsigned parm_count = def->port_count();\n\n      if (parms_.size() > parm_count) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Too many arguments (\" << parms_.size()\n\t\t << \", expecting \" << parm_count << \")\"\n\t\t << \" in call to task.\" << endl;\n\t    des->errors += 1;\n      }\n\n      NetBlock*block = new NetBlock(NetBlock::SEQU, 0);\n      block->set_line(*this);\n\n\t/* Detect the case where the definition of the task is known\n\t   empty. In this case, we need not bother with calls to the\n\t   task, all the assignments, etc. Just return a no-op. */\n\n      if (const NetBlock*tp = dynamic_cast<const NetBlock*>(def->proc())) {\n\t    if (tp->proc_first() == 0) {\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << get_fileline() << \": PCallTask::elaborate_build_call_: \"\n\t\t\t     << \"Eliding call to empty task \" << task->basename() << endl;\n\t\t  }\n\t\t  return block;\n\t    }\n      }\n\n        /* If this is an automatic task, generate a statement to\n           allocate the local storage. */\n\n      if (task->is_auto()) {\n\t    NetAlloc*ap = new NetAlloc(task);\n\t    ap->set_line(*this);\n\t    block->append(ap);\n      }\n\n\t/* If this is a method call, then the use_this pointer will\n\t   have an expression for the \"this\" argument. The \"this\"\n\t   argument is the first argument of any method, so emit it\n\t   here. */\n\n      if (use_this) {\n\t    ivl_assert(*this, def->port_count() >= 1);\n\t    NetNet*port = def->port(0);\n\t    ivl_assert(*this, port->port_type()==NetNet::PINPUT);\n\n\t    NetAssign_*lv = new NetAssign_(port);\n\t    NetAssign*pr = new NetAssign(lv, use_this);\n\t    pr->set_line(*this);\n\t    block->append(pr);\n      }\n\n\t/* Generate assignment statement statements for the input and\n\t   INOUT ports of the task. These are managed by writing\n\t   assignments with the task port the l-value and the passed\n\t   expression the r-value. We know by definition that the port\n\t   is a reg type, so this elaboration is pretty obvious. */\n\n      unsigned int off = use_this ? 1 : 0;\n\n      auto args = map_named_args(des, def, parms_, off);\n      for (unsigned int idx = off; idx < parm_count; idx++) {\n\t    size_t parms_idx = idx - off;\n\n\t    NetNet*port = def->port(idx);\n\t    ivl_assert(*this, port->port_type() != NetNet::NOT_A_PORT);\n\t    if (port->port_type() == NetNet::POUTPUT)\n\t\t  continue;\n\n\t    NetAssign_*lv = new NetAssign_(port);\n\t    unsigned wid = count_lval_width(lv);\n\t    ivl_variable_type_t lv_type = lv->expr_type();\n\n\t    NetExpr*rv = 0;\n\n\t    if (args[parms_idx]) {\n\t\t  rv = elaborate_rval_expr(des, scope, port->net_type(),\n\t\t\t\t\t   args[parms_idx]);\n\t\t  if (NetEEvent*evt = dynamic_cast<NetEEvent*> (rv)) {\n\t\t\tcerr << evt->get_fileline() << \": error: An event '\"\n\t\t\t     << evt->event()->name() << \"' can not be a user \"\n\t\t\t      \"task argument.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t    } else if (def->port_defe(idx)) {\n\t\t  if (! gn_system_verilog()) {\n\t\t\tcerr << get_fileline() << \": internal error: \"\n\t\t\t     << \"Found (and using) default task expression \"\n\t\t\t        \"requires SystemVerilog.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  rv = def->port_defe(idx)->dup_expr();\n\t\t  if (lv_type==IVL_VT_BOOL||lv_type==IVL_VT_LOGIC)\n\t\t\trv = pad_to_width(rv, wid, *this);\n\n\t    } else {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Missing argument \" << (idx+1)\n\t\t       << \" of call to task.\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    NetAssign*pr = new NetAssign(lv, rv);\n\t    pr->set_line(*this);\n\t    block->append(pr);\n      }\n\n\t/* Generate the task call proper... */\n      NetUTask*cur = new NetUTask(task);\n      cur->set_line(*this);\n      block->append(cur);\n\n\t/* Generate assignment statements for the output and INOUT\n\t   ports of the task. The l-value in this case is the\n\t   expression passed as a parameter, and the r-value is the\n\t   port to be copied out.\n\n\t   We know by definition that the r-value of this copy-out is\n\t   the port, which is a reg. The l-value, however, may be any\n\t   expression that can be a target to a procedural\n\t   assignment, including a memory word. */\n\n      for (unsigned int idx = off; idx < parm_count; idx++) {\n\n\t    size_t parms_idx = idx - off;\n\n\t    NetNet*port = def->port(idx);\n\n\t      /* Skip input ports. */\n\t    ivl_assert(*this, port->port_type() != NetNet::NOT_A_PORT);\n\t    if (port->port_type() == NetNet::PINPUT)\n\t\t  continue;\n\n\n\t      /* Elaborate an l-value version of the port expression\n\t\t for output and inout ports. If the expression does\n\t\t not exist or is not a valid l-value print an error\n\t\t message. Note that the elaborate_lval method already\n\t\t printed a detailed message for the latter case. */\n\t    NetAssign_*lv = 0;\n\t    if (args[parms_idx]) {\n\t\t  lv = args[parms_idx]->elaborate_lval(des, scope, false, false);\n\t\t  if (lv == 0) {\n\t\t\tcerr << args[parms_idx]->get_fileline() << \": error: \"\n\t\t\t     << \"I give up on task port \" << (idx+1)\n\t\t\t     << \" expression: \" << *args[parms_idx] << endl;\n\t\t  }\n\t    } else if (port->port_type() == NetNet::POUTPUT) {\n\t\t    // Output ports were skipped earlier, so\n\t\t    // report the error now.\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Missing argument \" << (idx+1)\n\t\t       << \" of call to task.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    if (lv == 0)\n\t\t  continue;\n\n\t    NetExpr*rv = new NetESignal(port);\n\n\t      /* Handle any implicit cast. */\n\t    unsigned lv_width = count_lval_width(lv);\n\t    if (lv->expr_type() != rv->expr_type()) {\n\t\t  switch (lv->expr_type()) {\n\t\t      case IVL_VT_REAL:\n\t\t\trv = cast_to_real(rv);\n\t\t\tbreak;\n\t\t      case IVL_VT_BOOL:\n\t\t\trv = cast_to_int2(rv, lv_width);\n\t\t\tbreak;\n\t\t      case IVL_VT_LOGIC:\n\t\t\trv = cast_to_int4(rv, lv_width);\n\t\t\tbreak;\n\t\t      default:\n\t\t\t  /* Don't yet know how to handle this. */\n\t\t\tivl_assert(*this, 0);\n\t\t\tbreak;\n\t\t  }\n\t    }\n\t    rv = pad_to_width(rv, lv_width, *this);\n\n\t      /* Generate the assignment statement. */\n\t    NetAssign*ass = new NetAssign(lv, rv);\n\t    ass->set_line(*this);\n\n\t    block->append(ass);\n      }\n\n        /* If this is an automatic task, generate a statement to free\n           the local storage. */\n      if (task->is_auto()) {\n\t    NetFree*fp = new NetFree(task);\n\t    fp->set_line(*this);\n\t    block->append(fp);\n      }\n\n      return block;\n}\n\nstatic bool check_parm_is_const(NetExpr*param)\n{\n// FIXME: Are these actually needed and are others needed?\n//      if (dynamic_cast<NetEConstEnum*>(param)) { cerr << \"Enum\" << endl; return; }\n//      if (dynamic_cast<NetECString*>(param)) { cerr << \"String\" << endl; return; }\n      if (dynamic_cast<NetEConstParam*>(param)) return true;\n      if (dynamic_cast<NetECReal*>(param)) return true;\n      if (dynamic_cast<NetECRealParam*>(param)) return true;\n      if (dynamic_cast<NetEConst*>(param)) return true;\n\n      return false;\n}\n\nstatic bool get_value_as_long(const NetExpr*expr, long&val)\n{\n      switch(expr->expr_type()) {\n\t  case IVL_VT_REAL: {\n\t    const NetECReal*c = dynamic_cast<const NetECReal*> (expr);\n\t    ivl_assert(*expr, c);\n\t    verireal tmp = c->value();\n\t    val = tmp.as_long();\n\t    break;\n\t  }\n\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC: {\n\t    const NetEConst*c = dynamic_cast<const NetEConst*>(expr);\n\t    ivl_assert(*expr, c);\n\t    verinum tmp = c->value();\n\t    if (tmp.is_string()) return false;\n\t    val = tmp.as_long();\n\t    break;\n\t  }\n\n\t  default:\n\t    return false;\n      }\n\n      return true;\n}\n\nstatic bool get_value_as_string(const NetExpr*expr, string&str)\n{\n      switch(expr->expr_type()) {\n\t  case IVL_VT_REAL:\n\t    return false;\n\t    break;\n\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC: {\n\t    const NetEConst*c = dynamic_cast<const NetEConst*>(expr);\n\t    ivl_assert(*expr, c);\n\t    verinum tmp = c->value();\n\t    if (!tmp.is_string()) return false;\n\t    str = tmp.as_string();\n\t    break;\n\t  }\n\n\t  default:\n\t    return false;\n      }\n\n      return true;\n}\n\n/* Elaborate an elaboration task. */\nbool PCallTask::elaborate_elab(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n      ivl_assert(*this, path_.size() == 1);\n\n      unsigned parm_count = parms_.size();\n\n      perm_string name = peek_tail_name(path_);\n\n      if (!gn_system_verilog()) {\n\t    cerr << get_fileline() << \": error: Elaboration task '\"\n\t         << name << \"' requires SystemVerilog.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      if (name != \"$fatal\" &&\n          name != \"$error\" &&\n          name != \"$warning\" &&\n          name != \"$info\") {\n\t    cerr << get_fileline() << \": error: '\" << name\n\t         << \"' is not a valid elaboration task.\" << endl;\n\t    des->errors += 1;\n\t    return true;\n      }\n\n      vector<NetExpr*>eparms (parm_count);\n\n      bool const_parms = true;\n      for (unsigned idx = 0 ;  idx < parm_count ;  idx += 1) {\n\t    auto &parm = parms_[idx];\n\n\t    // Elaboration tasks don't have named parameters\n\t    if (!parm.name.nil()) {\n\t\t  cerr << parm.get_fileline() << \": error: \"\n\t\t       << \"The elaboration system task `\" << name\n\t\t       << \"` has no argument called `\" << parm.name\n\t\t       << \"`.\" << endl;\n\t\t  des->errors++;\n\t    }\n\n\t    eparms[idx] = elab_sys_task_arg(des, scope, name, idx, parm.parm);\n\t    if (!check_parm_is_const(eparms[idx])) {\n\t\t  cerr << get_fileline() << \": error: Elaboration task \"\n\t\t       << name << \"() parameter [\" << idx+1 << \"] '\"\n\t\t       << *eparms[idx] << \"' is not constant.\" << endl;\n\t\t  des->errors += 1;\n\t\t  const_parms = false;\n\t    }\n      }\n      if (!const_parms) return true;\n\n\t// Drop the $ and convert to upper case for the severity string\n      string sstr = name.str()+1;\n      transform(sstr.begin(), sstr.end(), sstr.begin(), ::toupper);\n\n      cerr << sstr << \": \" << get_fileline() << \":\";\n      if (parm_count != 0) {\n\t    unsigned param_start = 0;\n\t      // Drop the finish number, but check it is actually valid!\n\t    if (name == \"$fatal\") {\n\t\t  long finish_num = 1;\n\t\t  if (!get_value_as_long(eparms[0],finish_num)) {\n\t\t\tcerr << endl;\n\t\t\tcerr << get_fileline() << \": error: Elaboration task \"\n\t\t\t        \"$fatal() finish number argument must be \"\n\t\t\t        \"numeric.\" << endl;;\n\t\t\tdes->errors += 1;\n\t\t\tcerr << string(sstr.size()+1, ' ');\n\t\t  } else if ((finish_num < 0) || (finish_num > 2)) {\n\t\t\tcerr << endl;\n\t\t\tcerr << get_fileline() << \": error: Elaboration task \"\n\t\t\t        \"$fatal() finish number argument must be in \"\n\t\t\t        \"the range [0-2], given '\" << finish_num\n\t\t\t     << \"'.\" << endl;;\n\t\t\tdes->errors += 1;\n\t\t\tcerr << string(sstr.size()+1, ' ');\n\t\t  }\n\t\t  param_start += 1;\n\t    }\n\n\t      // FIXME: For now just handle a single string value.\n\t    string str;\n\t    if ((parm_count == param_start + 1) && (get_value_as_string(eparms[param_start], str))) {\n\t\t  cerr << \" \" << str;\n\t    } else if (param_start < parm_count) {\n\t\t  cerr << endl;\n\t\t  cerr << get_fileline() << \": sorry: Elaboration tasks \"\n\t\t          \"currently only support a single string argument.\";\n\t\t  des->errors += 1;\n\t    }\n/*\n\t    cerr << *eparms[0];\n\t    for (unsigned idx = 1; idx < parm_count; idx += 1) {\n\t    cerr << \", \" << *eparms[idx];\n\t    }\n*/\n      }\n      cerr << endl;\n\n      cerr << string(sstr.size(), ' ') << \"  During elaboration  Scope: \"\n           << scope->fullname() << endl;\n\n\t// For a fatal mark as an error and fail elaboration.\n      if (name == \"$fatal\") {\n\t    des->errors += 1;\n\t    return false;\n      }\n\n\t// For an error just set it as an error.\n      if (name == \"$error\") des->errors += 1;\n\n      return true;\n}\n\n/*\n * Elaborate a procedural continuous assign. This really looks very\n * much like other procedural assignments, at this point, but there\n * is no delay to worry about. The code generator will take care of\n * the differences between continuous assign and normal assignments.\n */\nNetCAssign* PCAssign::elaborate(Design*des, NetScope*scope) const\n{\n      NetCAssign*dev = 0;\n      ivl_assert(*this, scope);\n\n      if (scope->is_auto() && lval_->has_aa_term(des, scope)) {\n\t    cerr << get_fileline() << \": error: automatically allocated \"\n                    \"variables may not be assigned values using procedural \"\n\t            \"continuous assignments.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->is_auto() && expr_->has_aa_term(des, scope)) {\n\t    cerr << get_fileline() << \": error: automatically allocated \"\n                    \"variables may not be referenced in procedural \"\n\t            \"continuous assignments.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetAssign_*lval = lval_->elaborate_lval(des, scope, true, false);\n      if (lval == 0)\n\t    return 0;\n\n      unsigned lwid = count_lval_width(lval);\n      ivl_variable_type_t ltype = lval->expr_type();\n\n      NetExpr*rexp = elaborate_rval_expr(des, scope, lval->net_type(), ltype, lwid, expr_);\n      if (rexp == 0)\n\t    return 0;\n\n      dev = new NetCAssign(lval, rexp);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Elaborate cassign,\"\n\t\t << \" lval width=\" << lwid\n\t\t << \" rval width=\" << rexp->expr_width()\n\t\t << \" rval=\" << *rexp\n\t\t << endl;\n      }\n\n      dev->set_line(*this);\n      return dev;\n}\n\nNetDeassign* PDeassign::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      if (scope->is_auto() && lval_->has_aa_term(des, scope)) {\n\t    cerr << get_fileline() << \": error: automatically allocated \"\n                    \"variables may not be assigned values using procedural \"\n\t            \"continuous assignments.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetAssign_*lval = lval_->elaborate_lval(des, scope, true, false);\n      if (lval == 0)\n\t    return 0;\n\n      NetDeassign*dev = new NetDeassign(lval);\n      dev->set_line( *this );\n      return dev;\n}\n\n/*\n * Elaborate the delay statement (of the form #<expr> <statement>) as a\n * NetPDelay object. If the expression is constant, evaluate it now\n * and make a constant delay. If not, then pass an elaborated\n * expression to the constructor of NetPDelay so that the code\n * generator knows to evaluate the expression at run time.\n */\nNetProc* PDelayStatement::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      if (scope->in_func()) {\n\t    cerr << get_fileline() << \": error: functions cannot have \"\n\t            \"delay statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->in_final()) {\n\t    cerr << get_fileline() << \": error: final procedures cannot \"\n\t            \"have delay statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t/* This call evaluates the delay expression to a NetEConst, if\n\t   possible. This includes transforming NetECReal values to\n\t   integers, and applying the proper scaling. */\n      NetExpr*dex = elaborate_delay_expr(delay_, des, scope);\n\n      NetPDelay *obj;\n      if (NetEConst*tmp = dynamic_cast<NetEConst*>(dex)) {\n\t    if (statement_)\n\t\t  obj = new NetPDelay(tmp->value().as_ulong64(),\n\t\t                      statement_->elaborate(des, scope));\n\t    else\n\t\t  obj = new NetPDelay(tmp->value().as_ulong64(), 0);\n\n\t    delete dex;\n\n      } else {\n\t    if (statement_)\n\t\t  obj = new NetPDelay(dex, statement_->elaborate(des, scope));\n\t    else\n\t\t  obj = new NetPDelay(dex, 0);\n      }\n      obj->set_line(*this);\n      return obj;\n}\n\n/*\n * The disable statement is not yet supported.\n */\nNetProc* PDisable::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n\t/* If the disable scope_ is empty then this is a SystemVerilog\n\t * disable fork statement. */\n      if (scope_.empty()) {\n\t    if (gn_system_verilog()) {\n\t\t  NetDisable*obj = new NetDisable(0);\n\t\t  obj->set_line(*this);\n\t\t  return obj;\n\t    } else {\n\t\t  cerr << get_fileline()\n\t\t       << \": error: 'disable fork' requires SystemVerilog.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n      }\n\n      list<hname_t> spath = eval_scope_path(des, scope, scope_);\n\n      NetScope*target = des->find_scope(scope, spath);\n      if (target == 0) {\n\t    cerr << get_fileline() << \": error: Cannot find scope \"\n\t\t << scope_ << \" in \" << scope_path(scope) << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      switch (target->type()) {\n\t  case NetScope::FUNC:\n\t    cerr << get_fileline() << \": error: Cannot disable functions.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n\n\t  case NetScope::MODULE:\n\t    cerr << get_fileline() << \": error: Cannot disable modules.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n\n\t  default:\n\t    break;\n      }\n\n      NetDisable*obj = new NetDisable(target);\n      obj->set_line(*this);\n      return obj;\n}\n\n/*\n * The do/while loop is fairly directly represented in the netlist.\n */\nNetProc* PDoWhile::elaborate(Design*des, NetScope*scope) const\n{\n      NetExpr*ce = elab_and_eval(des, scope, cond_, -1);\n      NetProc*sub;\n      if (statement_)\n\t    sub = statement_->elaborate(des, scope);\n      else\n\t    sub = new NetBlock(NetBlock::SEQU, 0);\n      if (ce == 0 || sub == 0) {\n\t    delete ce;\n\t    delete sub;\n\t    return 0;\n      }\n      NetDoWhile*loop = new NetDoWhile(ce, sub);\n      loop->set_line(*this);\n      return loop;\n}\n\n/*\n * An event statement is an event delay of some sort, attached to a\n * statement. Some Verilog examples are:\n *\n *      @(posedge CLK) $display(\"clock rise\");\n *      @event_1 $display(\"event triggered.\");\n *      @(data or negedge clk) $display(\"data or clock fall.\");\n *\n * The elaborated netlist uses the NetEvent, NetEvWait and NetEvProbe\n * classes. The NetEvWait class represents the part of the netlist\n * that is executed by behavioral code. The process starts waiting on\n * the NetEvent when it executes the NetEvWait step. Net NetEvProbe\n * and NetEvTrig are structural and behavioral equivalents that\n * trigger the event, and awakens any processes blocking in the\n * associated wait.\n *\n * The basic data structure is:\n *\n *       NetEvWait ---/--->  NetEvent  <----\\---- NetEvProbe\n *        ...         |                     |         ...\n *       NetEvWait ---+                     +---- NetEvProbe\n *                                          |         ...\n *                                          +---- NetEvTrig\n *\n * That is, many NetEvWait statements may wait on a single NetEvent\n * object, and Many NetEvProbe objects may trigger the NetEvent\n * object. The many NetEvWait objects pointing to the NetEvent object\n * reflects the possibility of different places in the code blocking\n * on the same named event, like so:\n *\n *         event foo;\n *           [...]\n *         always begin @foo <statement1>; @foo <statement2> end\n *\n * This tends to not happen with signal edges. The multiple probes\n * pointing to the same event reflect the possibility of many\n * expressions in the same blocking statement, like so:\n *\n *         wire reset, clk;\n *           [...]\n *         always @(reset or posedge clk) <stmt>;\n *\n * Conjunctions like this cause a NetEvent object be created to\n * represent the overall conjunction, and NetEvProbe objects for each\n * event expression.\n *\n * If the NetEvent object represents a named event from the source,\n * then there are NetEvTrig objects that represent the trigger\n * statements instead of the NetEvProbe objects representing signals.\n * For example:\n *\n *         event foo;\n *         always @foo <stmt>;\n *         initial begin\n *                [...]\n *            -> foo;\n *                [...]\n *            -> foo;\n *                [...]\n *         end\n *\n * Each trigger statement in the source generates a separate NetEvTrig\n * object in the netlist. Those trigger objects are elaborated\n * elsewhere.\n *\n * Additional complications arise when named events show up in\n * conjunctions. An example of such a case is:\n *\n *         event foo;\n *         wire bar;\n *         always @(foo or posedge bar) <stmt>;\n *\n * Since there is by definition a NetEvent object for the foo object,\n * this is handled by allowing the NetEvWait object to point to\n * multiple NetEvent objects. All the NetEvProbe based objects are\n * collected and pointed as the synthetic NetEvent object, and all the\n * named events are added into the list of NetEvent object that the\n * NetEvWait object can refer to.\n */\n\nNetProc* PEventStatement::elaborate_st(Design*des, NetScope*scope,\n\t\t\t\t       NetProc*enet) const\n{\n      ivl_assert(*this, scope);\n\n      if (scope->in_func()) {\n\t    cerr << get_fileline() << \": error: functions cannot have \"\n\t            \"event statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->in_final()) {\n\t    cerr << get_fileline() << \": error: final procedures cannot \"\n\t            \"have event statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t/* Create a single NetEvent and NetEvWait. Then, create a\n\t   NetEvProbe for each conjunctive event in the event\n\t   list. The NetEvProbe objects all refer back to the NetEvent\n\t   object. */\n\n      NetEvent*ev = new NetEvent(scope->local_symbol());\n      ev->set_line(*this);\n      ev->local_flag(true);\n      unsigned expr_count = 0;\n\n      NetEvWait*wa = new NetEvWait(enet);\n      wa->set_line(*this);\n\n\t/* If there are no expressions, this is a signal that it is an\n\t   @* statement. Generate an expression to use. */\n\n      if (expr_.size() == 0) {\n\t    ivl_assert(*this, enet);\n\t     /* For synthesis or always_comb/latch we want just the inputs,\n\t      * but for the rest we want inputs and outputs that may cause\n\t      * a value to change. */\n\t    extern bool synthesis; /* Synthesis flag from main.cc */\n\t    bool rem_out = false;\n\t    if (synthesis || always_sens_) {\n\t\t  rem_out = true;\n\t    }\n\t      // If this is an always_comb/latch then we need an implicit T0\n\t      // trigger of the event expression.\n\t    if (always_sens_) wa->set_t0_trigger();\n\t    NexusSet*nset = enet->nex_input(rem_out, always_sens_);\n\t    if (nset == 0) {\n\t\t  cerr << get_fileline() << \": error: Unable to elaborate:\"\n\t\t       << endl;\n\t\t  enet->dump(cerr, 6);\n\t\t  des->errors += 1;\n\t\t  return enet;\n\t    }\n\n\t    if (nset->size() == 0) {\n                  if (always_sens_) return wa;\n\n\t\t  cerr << get_fileline() << \": warning: @* found no \"\n\t\t          \"sensitivities so it will never trigger.\"\n\t\t       << endl;\n\t\t    /* Add the currently unreferenced event to the scope. */\n\t\t  scope->add_event(ev);\n\t\t    /* Delete the current wait, create a new one with no\n\t\t     * statement and add the event to it. This creates a\n\t\t     * perpetual wait since nothing will ever trigger the\n\t\t     * unreferenced event. */\n\t\t  delete wa;\n\t\t  wa = new NetEvWait(0);\n\t\t  wa->set_line(*this);\n\t\t  wa->add_event(ev);\n\t\t  return wa;\n\t    }\n\n\t    NetEvProbe*pr = new NetEvProbe(scope, scope->local_symbol(),\n\t\t\t\t\t   ev, NetEvProbe::ANYEDGE,\n\t\t\t\t\t   nset->size());\n\t    for (unsigned idx = 0 ;  idx < nset->size() ;  idx += 1) {\n\t\t  unsigned wid = nset->at(idx).wid;\n\t\t  unsigned vwid = nset->at(idx).lnk.nexus()->vector_width();\n\t\t    // Is this a part select?\n\t\t  if (always_sens_ && (wid != vwid)) {\n\t\t\tcerr << get_fileline() << \": sorry: constant \"\n\t\t\t        \"selects in always_* processes are not \"\n\t\t\t        \"currently supported (all bits will be \"\n\t\t\t        \"included).\" << endl;\n# if 0\n\t\t\tunsigned base = nset->at(idx).base;\ncerr << get_fileline() << \": base = \" << base << endl;\n// FIXME: make this work with selects that go before the base.\n\t\t\tivl_assert(*this, base < vwid);\n\t\t\tif (base + wid > vwid) wid = vwid - base;\ncerr << get_fileline() << \": base = \" << base << \", width = \" << wid\n     << \", expr width = \" << vwid << endl;\nnset->at(idx).lnk.dump_link(cerr, 4);\ncerr << endl;\n// FIXME: Convert the link to the appropriate NetNet\n\t\t\tnetvector_t*tmp_vec = new netvector_t(IVL_VT_BOOL, vwid, 0);\n\t\t\tNetNet*sig = new NetNet(scope, scope->local_symbol(), NetNet::IMPLICIT, tmp_vec);\n\t\t\tNetPartSelect*tmp = new NetPartSelect(sig, base, wid, NetPartSelect::VP);\n\t\t\tdes->add_node(tmp);\n\t\t\ttmp->set_line(*this);\n// FIXME: create a part select to get the correct bits to connect.\n\t\t\tconnect(tmp->pin(1), nset->at(idx).lnk);\n\t\t\tconnect(tmp->pin(0), pr->pin(idx));\n# endif\n\t\t\tconnect(nset->at(idx).lnk, pr->pin(idx));\n\t\t  } else {\n\t\t\tconnect(nset->at(idx).lnk, pr->pin(idx));\n\t\t  }\n\t    }\n\n\t    delete nset;\n\t    des->add_node(pr);\n\n\t    expr_count = 1;\n\n      } else for (unsigned idx = 0 ;  idx < expr_.size() ;  idx += 1) {\n\n\t    ivl_assert(*this, expr_[idx]->expr());\n\n\t      /* If the expression is an identifier that matches a\n\t\t named event, then handle this case all at once and\n\t\t skip the rest of the expression handling. */\n\n\t    if (PEIdent*id = dynamic_cast<PEIdent*>(expr_[idx]->expr())) {\n\t\t  symbol_search_results sr;\n\t\t  symbol_search(this, des, scope, id->path(), id->lexical_pos(), &sr);\n\n\t\t  if (sr.scope && sr.eve) {\n\t\t\twa->add_event(sr.eve);\n\t\t\t  /* You can not look for the posedge or negedge of\n\t\t\t   * an event. */\n\t\t\tif (expr_[idx]->type() != PEEvent::ANYEDGE) {\n                              cerr << get_fileline() << \": error: \";\n                              switch (expr_[idx]->type()) {\n\t\t\t\t  case PEEvent::POSEDGE:\n\t\t\t\t    cerr << \"posedge\";\n\t\t\t\t    break;\n\t\t\t\t  case PEEvent::NEGEDGE:\n\t\t\t\t    cerr << \"negedge\";\n\t\t\t\t    break;\n\t\t\t\t  default:\n\t\t\t\t    cerr << \"unknown edge type!\";\n\t\t\t\t    ivl_assert(*this, 0);\n\t\t\t      }\n\t\t\t      cerr << \" can not be used with a named event (\"\n\t\t\t           << sr.eve->name() << \").\" << endl;\n                              des->errors += 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t  }\n\t    }\n\n\n\t      /* So now we have a normal event expression. Elaborate\n\t\t the sub-expression as a net and decide how to handle\n\t\t the edge. */\n\n            if (scope->is_auto()) {\n                  if (! dynamic_cast<PEIdent*>(expr_[idx]->expr())) {\n                        cerr << get_fileline() << \": sorry, complex event \"\n                                \"expressions are not yet supported in \"\n                                \"automatic tasks.\" << endl;\n                        des->errors += 1;\n                        return 0;\n                  }\n            }\n\n\t    NetExpr*tmp = elab_and_eval(des, scope, expr_[idx]->expr(), -1);\n\t    if (tmp == 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t\t  \"Failed to evaluate event expression '\"\n\t\t       << *expr_[idx] << \"'.\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t      // posedge, negedge and edge are not allowed on real expressions.\n\t    if ((tmp->expr_type() == IVL_VT_REAL) &&\n\t        (expr_[idx]->type() != PEEvent::ANYEDGE)) {\n\t\t  cerr << get_fileline() << \": error: '\";\n\t\t  switch (expr_[idx]->type()) {\n\t\t    case PEEvent::POSEDGE:\n\t\t\tcerr << \"posedge\";\n\t\t\tbreak;\n\t\t    case PEEvent::NEGEDGE:\n\t\t\tcerr << \"negedge\";\n\t\t\tbreak;\n\t\t    case PEEvent::EDGE:\n\t\t\tcerr << \"edge\";\n\t\t\tbreak;\n\t\t    default:\n\t\t\tivl_assert(*this, 0);\n\t\t  }\n\t\t  cerr << \"' cannot be used with real expressions '\"\n\t\t       << *expr_[idx]->expr() << \"'.\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    NetNet*expr = tmp->synthesize(des, scope, tmp);\n\t    if (expr == 0) {\n\t\t  expr_[idx]->dump(cerr);\n\t\t  cerr << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\t    ivl_assert(*this, expr);\n\n\t    delete tmp;\n\n\t    unsigned pins = (expr_[idx]->type() == PEEvent::ANYEDGE)\n\t\t  ? expr->pin_count() : 1;\n\n\t    NetEvProbe*pr;\n\t    switch (expr_[idx]->type()) {\n\t\tcase PEEvent::POSEDGE:\n\t\t  pr = new NetEvProbe(scope, scope->local_symbol(), ev,\n\t\t\t\t      NetEvProbe::POSEDGE, pins);\n\t\t  break;\n\n\t\tcase PEEvent::NEGEDGE:\n\t\t  pr = new NetEvProbe(scope, scope->local_symbol(), ev,\n\t\t\t\t      NetEvProbe::NEGEDGE, pins);\n\t\t  break;\n\n\t\tcase PEEvent::EDGE:\n\t\t  pr = new NetEvProbe(scope, scope->local_symbol(), ev,\n\t\t\t\t      NetEvProbe::EDGE, pins);\n\t\t  break;\n\n\t\tcase PEEvent::ANYEDGE:\n\t\t  pr = new NetEvProbe(scope, scope->local_symbol(), ev,\n\t\t\t\t      NetEvProbe::ANYEDGE, pins);\n\t\t  break;\n\n\t\tdefault:\n\t\t  pr = NULL;\n\t\t  ivl_assert(*this, 0);\n\t    }\n\n\t    for (unsigned p = 0 ;  p < pr->pin_count() ; p += 1)\n\t\t  connect(pr->pin(p), expr->pin(p));\n\n\t    des->add_node(pr);\n\t    expr_count += 1;\n      }\n\n\t/* If there was at least one conjunction that was an\n\t   expression (and not a named event) then add this\n\t   event. Otherwise, we didn't use it so delete it. */\n      if (expr_count > 0) {\n\t    scope->add_event(ev);\n\t    wa->add_event(ev);\n\t      /* NOTE: This event that I am adding to the wait may be\n\t\t a duplicate of another event somewhere else. However,\n\t\t I don't know that until all the modules are hooked\n\t\t up, so it is best to leave find_similar_event to\n\t\t after elaboration. */\n      } else {\n\t    delete ev;\n      }\n\n      return wa;\n}\n\n/*\n * This is the special case of the event statement, the wait\n * statement. This is elaborated into a slightly more complicated\n * statement that uses non-wait statements:\n *\n *     wait (<expr>)  <statement>\n *\n * becomes\n *\n *     begin\n *         while (1 !== <expr>)\n *           @(<expr inputs>) <noop>;\n *         <statement>;\n *     end\n */\nNetProc* PEventStatement::elaborate_wait(Design*des, NetScope*scope,\n\t\t\t\t\t NetProc*enet) const\n{\n      ivl_assert(*this, scope);\n      ivl_assert(*this, expr_.size() == 1);\n\n      if (scope->in_func()) {\n\t    cerr << get_fileline() << \": error: functions cannot have \"\n\t            \"wait statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->in_final()) {\n\t    cerr << get_fileline() << \": error: final procedures cannot \"\n\t            \"have wait statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      PExpr *pe = expr_[0]->expr();\n\n\t/* Elaborate wait expression. Don't eval yet, we will do that\n\t   shortly, after we apply a reduction or. */\n\n      PExpr::width_mode_t mode = PExpr::SIZED;\n      pe->test_width(des, scope, mode);\n      NetExpr*expr = pe->elaborate_expr(des, scope, pe->expr_width(),\n                                        PExpr::NO_FLAGS);\n      if (expr == 0) {\n\t    cerr << get_fileline() << \": error: Unable to elaborate\"\n\t\t  \" wait condition expression.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n\t// If the condition expression is more than 1 bits, then\n\t// generate a reduction operator to get the result down to\n\t// one bit. In other words, Turn <e> into |<e>;\n\n      if (expr->expr_width() < 1) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t  \"incomprehensible wait expression width (0).\" << endl;\n\t    return 0;\n      }\n\n      if (expr->expr_width() > 1) {\n\t    ivl_assert(*this, expr->expr_width() > 1);\n\t    NetEUReduce*cmp = new NetEUReduce('|', expr);\n\t    cmp->set_line(*pe);\n\t    expr = cmp;\n      }\n\n\t/* precalculate as much as possible of the wait expression. */\n      eval_expr(expr);\n\n\t/* Detect the unusual case that the wait expression is\n\t   constant. Constant true is OK (it becomes transparent) but\n\t   constant false is almost certainly not what is intended. */\n      ivl_assert(*this, expr->expr_width() == 1);\n      if (NetEConst*ce = dynamic_cast<NetEConst*>(expr)) {\n\t    verinum val = ce->value();\n\t    ivl_assert(*this, val.len() == 1);\n\n\t      /* Constant true -- wait(1) <s1> reduces to <s1>. */\n\t    if (val[0] == verinum::V1) {\n\t\t  delete expr;\n\t\t  ivl_assert(*this, enet);\n\t\t  return enet;\n\t    }\n\n\t      /* Otherwise, false. wait(0) blocks permanently. */\n\n\t    cerr << get_fileline() << \": warning: wait expression is \"\n\t\t << \"constant false.\" << endl;\n\t    cerr << get_fileline() << \":        : The statement will \"\n\t\t << \"block permanently.\" << endl;\n\n\t      /* Create an event wait and an otherwise unreferenced\n\t\t event variable to force a perpetual wait. */\n\t    NetEvent*wait_event = new NetEvent(scope->local_symbol());\n\t    wait_event->set_line(*this);\n\t    wait_event->local_flag(true);\n\t    scope->add_event(wait_event);\n\n\t    NetEvWait*wait = new NetEvWait(0);\n\t    wait->add_event(wait_event);\n\t    wait->set_line(*this);\n\n\t    delete expr;\n\t    delete enet;\n\t    return wait;\n      }\n\n\t/* Invert the sense of the test with an exclusive NOR. In\n\t   other words, if this adjusted expression returns TRUE, then\n\t   wait. */\n      ivl_assert(*this, expr->expr_width() == 1);\n      expr = new NetEBComp('N', expr, new NetEConst(verinum(verinum::V1)));\n      expr->set_line(*pe);\n      eval_expr(expr);\n\n      NetEvent*wait_event = new NetEvent(scope->local_symbol());\n      wait_event->set_line(*this);\n      wait_event->local_flag(true);\n      scope->add_event(wait_event);\n\n      NetEvWait*wait = new NetEvWait(0 /* noop */);\n      wait->add_event(wait_event);\n      wait->set_line(*this);\n\n      NexusSet*wait_set = expr->nex_input();\n      if (wait_set == 0) {\n\t    cerr << get_fileline() << \": internal error: No NexusSet\"\n\t\t << \" from wait expression.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (wait_set->size() == 0) {\n\t    cerr << get_fileline() << \": internal error: Empty NexusSet\"\n\t\t << \" from wait expression.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetEvProbe*wait_pr = new NetEvProbe(scope, scope->local_symbol(),\n\t\t\t\t\t  wait_event, NetEvProbe::ANYEDGE,\n\t\t\t\t\t  wait_set->size());\n      for (unsigned idx = 0; idx < wait_set->size() ;  idx += 1)\n\t    connect(wait_set->at(idx).lnk, wait_pr->pin(idx));\n\n      delete wait_set;\n      des->add_node(wait_pr);\n\n      NetWhile*loop = new NetWhile(expr, wait);\n      loop->set_line(*this);\n\n\t/* If there is no real substatement (i.e., \"wait (foo) ;\") then\n\t   we are done. */\n      if (enet == 0)\n\t    return loop;\n\n\t/* Create a sequential block to combine the wait loop and the\n\t   delayed statement. */\n      NetBlock*block = new NetBlock(NetBlock::SEQU, 0);\n      block->append(loop);\n      block->append(enet);\n      block->set_line(*this);\n\n      return block;\n}\n\n/*\n * This is a special case of the event statement, the wait fork\n * statement. This is elaborated into a simplified statement.\n *\n *     wait fork;\n *\n * becomes\n *\n *     @(0) <noop>;\n */\nNetProc* PEventStatement::elaborate_wait_fork(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n      ivl_assert(*this, expr_.size() == 1);\n      ivl_assert(*this, expr_[0] == 0);\n      ivl_assert(*this, ! statement_);\n\n      if (scope->in_func()) {\n\t    cerr << get_fileline() << \": error: functions cannot have \"\n\t            \"wait fork statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->in_final()) {\n\t    cerr << get_fileline() << \": error: final procedures cannot \"\n\t            \"have wait fork statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (gn_system_verilog()) {\n\t    NetEvWait*wait = new NetEvWait(0 /* noop */);\n\t    wait->add_event(0);\n\t    wait->set_line(*this);\n\t    return wait;\n      } else {\n\t    cerr << get_fileline()\n\t         << \": error: 'wait fork' requires SystemVerilog.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n}\n\nNetProc* PEventStatement::elaborate(Design*des, NetScope*scope) const\n{\n\t/* Check to see if this is a wait fork statement. */\n      if ((expr_.size() == 1) && (expr_[0] == 0))\n\t\t  return elaborate_wait_fork(des, scope);\n\n      NetProc*enet = 0;\n      if (statement_) {\n\t    enet = statement_->elaborate(des, scope);\n\t    if (enet == 0)\n\t\t  return 0;\n\n      } else {\n\t    enet = new NetBlock(NetBlock::SEQU, 0);\n\t    enet->set_line(*this);\n      }\n\n      if ((expr_.size() == 1) && (expr_[0]->type() == PEEvent::POSITIVE))\n\t    return elaborate_wait(des, scope, enet);\n\n      return elaborate_st(des, scope, enet);\n}\n\n/*\n * Forever statements are represented directly in the netlist. It is\n * theoretically possible to use a while structure with a constant\n * expression to represent the loop, but why complicate the code\n * generators so?\n */\nNetProc* PForever::elaborate(Design*des, NetScope*scope) const\n{\n      NetProc*stat;\n      if (statement_)\n\t    stat = statement_->elaborate(des, scope);\n      else\n\t    stat = new NetBlock(NetBlock::SEQU, 0);\n      if (stat == 0) return 0;\n\n      NetForever*proc = new NetForever(stat);\n      proc->set_line(*this);\n      return proc;\n}\n\n/*\n * Force is like a procedural assignment, most notably procedural\n * continuous assignment:\n *\n *    force <lval> = <rval>\n *\n * The <lval> can be anything that a normal behavioral assignment can\n * take, plus net signals. This is a little bit more lax than the\n * other procedural assignments.\n */\nNetForce* PForce::elaborate(Design*des, NetScope*scope) const\n{\n      NetForce*dev = 0;\n      ivl_assert(*this, scope);\n\n      if (scope->is_auto() && lval_->has_aa_term(des, scope)) {\n\t    cerr << get_fileline() << \": error: automatically allocated \"\n                    \"variables may not be assigned values using procedural \"\n\t            \"force statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (scope->is_auto() && expr_->has_aa_term(des, scope)) {\n\t    cerr << get_fileline() << \": error: automatically allocated \"\n                    \"variables may not be referenced in procedural force \"\n\t            \"statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetAssign_*lval = lval_->elaborate_lval(des, scope, false, true);\n      if (lval == 0)\n\t    return 0;\n\n      unsigned lwid = count_lval_width(lval);\n      ivl_variable_type_t ltype = lval->expr_type();\n\n\t// Like a variety of other assigns, we need to figure out a\n\t// better way to get a reasonable lv_net_type value, and that\n\t// probably will involve NetAssign_ having a method for\n\t// synthesizing one as needed.\n      NetExpr*rexp = elaborate_rval_expr(des, scope, lval->net_type(), ltype, lwid, expr_);\n      if (rexp == 0)\n\t    return 0;\n\n      dev = new NetForce(lval, rexp);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Elaborate force,\"\n\t\t << \" lval width=\" << lval->lwidth()\n\t\t << \" rval width=\" << rexp->expr_width()\n\t\t << \" rval=\" << *rexp\n\t\t << endl;\n      }\n\n      dev->set_line(*this);\n      return dev;\n}\n\nstatic void find_property_in_class(const LineInfo&loc, const NetScope*scope, perm_string name, const netclass_t*&found_in, int&property)\n{\n      found_in = find_class_containing_scope(loc, scope);\n      property = -1;\n\n      if (found_in==0) return;\n\n      property = found_in->property_idx_from_name(name);\n      if (property < 0) {\n\t    found_in = 0;\n\t    return;\n      }\n}\n\n/*\n * The foreach statement can be written as a for statement like so:\n *\n *     for (<idx> = $left(<array>) ; <idx> {<,>}= $right(<array>) ; <idx> {+,-}= 1)\n *          <statement_>\n *\n * The <idx> variable is already known to be in the containing named\n * block scope, which was created by the parser.\n */\nNetProc* PForeach::elaborate(Design*des, NetScope*scope) const\n{\n\t// Locate the signal for the array variable\n      pform_name_t array_name;\n      array_name.push_back(name_component_t(array_var_));\n      NetNet*array_sig = des->find_signal(scope, array_name);\n\n\t// And if necessary, look for the class property that is\n\t// referenced.\n      const netclass_t*class_scope = 0;\n      int class_property = -1;\n      if (array_sig == 0)\n\t    find_property_in_class(*this, scope, array_var_, class_scope, class_property);\n\n      if (debug_elaborate && array_sig) {\n\t    cerr << get_fileline() << \": PForeach::elaborate: \"\n\t\t << \"Found array_sig in \" << scope_path(array_sig->scope()) << \".\" << endl;\n      }\n\n      if (debug_elaborate && class_scope) {\n\t    cerr << get_fileline() << \": PForeach::elaborate: \"\n\t\t << \"Found array_sig property (\" << class_property\n\t\t << \") in class \" << class_scope->get_name()\n\t\t << \" as \" << *class_scope->get_prop_type(class_property) << \".\" << endl;\n      }\n\n      if (class_scope!=0 && class_property >= 0) {\n\t    ivl_type_t ptype = class_scope->get_prop_type(class_property);\n\t    const netsarray_t*atype = dynamic_cast<const netsarray_t*> (ptype);\n\t    if (atype == 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"I can't handle the type of \" << array_var_\n\t\t       << \" as a foreach loop.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    const netranges_t&dims = atype->static_dimensions();\n\t    if (dims.size() < index_vars_.size()) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"class \" << class_scope->get_name()\n\t\t       << \" property \" << array_var_\n\t\t       << \" has too few dimensions for foreach dimension list.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    return elaborate_static_array_(des, scope, dims);\n      }\n\n      if (array_sig == 0) {\n\t    cerr << get_fileline() << \": error:\"\n\t\t << \" Unable to find foreach array \" << array_name\n\t\t << \" in scope \" << scope_path(scope)\n\t\t << \".\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      ivl_assert(*this, array_sig);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PForeach::elaborate: \"\n\t\t << \"Scan array \" << array_sig->name()\n\t\t << \" of \" << array_sig->data_type()\n\t\t << \" with \" << array_sig->unpacked_dimensions() << \" unpacked\"\n\t\t << \" and \" << array_sig->packed_dimensions()\n\t\t << \" packed dimensions.\" << endl;\n      }\n\n      netranges_t dims = array_sig->unpacked_dims();\n      if (array_sig->packed_dimensions() > 0) {\n            dims.insert(dims.end(), array_sig->packed_dims().begin(), array_sig->packed_dims().end());\n      }\n\n\t// Classic arrays are processed this way.\n      if (array_sig->data_type()==IVL_VT_BOOL)\n\t    return elaborate_static_array_(des, scope, dims);\n      if (array_sig->data_type()==IVL_VT_LOGIC)\n\t    return elaborate_static_array_(des, scope, dims);\n      if (array_sig->unpacked_dimensions() >= index_vars_.size())\n\t    return elaborate_static_array_(des, scope, dims);\n\n\t// At this point, we know that the array is dynamic so we\n\t// handle that slightly differently, using run-time tests.\n\n      if (index_vars_.size() != 1) {\n\t    cerr << get_fileline() << \": sorry: \"\n\t\t << \"Multi-index foreach loops not supported.\" << endl;\n\t    des->errors += 1;\n      }\n\n\t// Get the signal for the index variable.\n      pform_name_t index_name;\n      index_name.push_back(name_component_t(index_vars_[0]));\n      NetNet*idx_sig = des->find_signal(scope, index_name);\n      ivl_assert(*this, idx_sig);\n\n      NetESignal*array_exp = new NetESignal(array_sig);\n      array_exp->set_line(*this);\n\n      NetESignal*idx_exp = new NetESignal(idx_sig);\n      idx_exp->set_line(*this);\n\n\t// This is a dynamic array or queue where $low is $left and $high is\n\t// $right. It will always count up.\n\n\t// Make an initialization expression for the index.\n      NetESFunc*init_expr = new NetESFunc(\"$low\", &netvector_t::atom2s32, 1);\n      init_expr->set_line(*this);\n      init_expr->parm(0, array_exp);\n\n\t// Make a condition expression: idx <= $high(array)\n      NetESFunc*high_exp = new NetESFunc(\"$high\", &netvector_t::atom2s32, 1);\n      high_exp->set_line(*this);\n      high_exp->parm(0, array_exp);\n\n      NetEBComp*cond_expr = new NetEBComp('L', idx_exp, high_exp);\n      cond_expr->set_line(*this);\n\n\t/* Elaborate the statement that is contained in the foreach\n\t   loop. */\n      NetProc*sub;\n      if (statement_)\n\t    sub = statement_->elaborate(des, scope);\n      else\n\t    sub = new NetBlock(NetBlock::SEQU, 0);\n\n\t/* Make a step statement: idx += 1 */\n      NetAssign_*idx_lv = new NetAssign_(idx_sig);\n      NetEConst*step_val = make_const_val(1);\n      NetAssign*step = new NetAssign(idx_lv, '+', step_val);\n      step->set_line(*this);\n\n      NetForLoop*stmt = new NetForLoop(idx_sig, init_expr, cond_expr, sub, step);\n      stmt->set_line(*this);\n\n      return stmt;\n}\n\n/*\n * This is a variant of the PForeach::elaborate() method that handles\n * the case that the array has static dimensions. We can use constants\n * and possibly do some optimizations.\n */\nNetProc* PForeach::elaborate_static_array_(Design*des, NetScope*scope,\n\t\t\t\t\t   const netranges_t&dims) const\n{\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PForeach::elaborate_static_array_: \"\n\t\t << \"Handle as array with static dimensions.\" << endl;\n      }\n\n      NetProc*sub;\n      if (statement_)\n\t    sub = statement_->elaborate(des, scope);\n      else\n\t    sub = new NetBlock(NetBlock::SEQU, 0);\n      NetForLoop*stmt = 0;\n\n      if (index_vars_.size() > dims.size()) {\n\t    delete sub;\n\t    cerr << get_fileline() << \": error: Number of foreach loop variables\"\n\t         << \"(\" << index_vars_.size() << \") must not exceed number of \"\n\t\t << \"array dimensions (\" << dims.size() << \").\" << endl;\n\t    des->errors++;\n\t    return nullptr;\n      }\n\n      for (int idx_idx = index_vars_.size()-1 ; idx_idx >= 0 ; idx_idx -= 1) {\n\t    const netrange_t&idx_range = dims[idx_idx];\n\n\t      // It is possible to skip dimensions by not providing a identifier\n\t      // name for it. E.g. `int x[1][2][3]; foreach(x[a,,b]) ...`\n\t    if (index_vars_[idx_idx].nil())\n\t\t  continue;\n\n\t      // Get the $high and $low constant values for this slice\n\t      // of the array.\n\t    NetEConst*left_expr = make_const_val_s(idx_range.get_msb());\n\t    NetEConst*right_expr = make_const_val_s(idx_range.get_lsb());\n\n\t    bool up = idx_range.get_msb() < idx_range.get_lsb();\n\n\t    left_expr->set_line(*this);\n\t    right_expr->set_line(*this);\n\n\t    pform_name_t idx_name;\n\t    idx_name.push_back(name_component_t(index_vars_[idx_idx]));\n\t    NetNet*idx_sig = des->find_signal(scope, idx_name);\n\t    ivl_assert(*this, idx_sig);\n\n\t      // Make the condition expression <idx> {<,>}= $right(slice)\n\t    NetESignal*idx_expr = new NetESignal(idx_sig);\n\t    idx_expr->set_line(*this);\n\n\t    NetEBComp*cond_expr = new NetEBComp(up ? 'L' : 'G', idx_expr, right_expr);\n\t    cond_expr->set_line(*this);\n\n\t      // Make the step statement: <idx> {+,-}= 1\n\t    NetAssign_*idx_lv = new NetAssign_(idx_sig);\n\t    NetEConst*step_val = make_const_val_s(1);\n\t    NetAssign*step = new NetAssign(idx_lv, up ? '+' : '-', step_val);\n\t    step->set_line(*this);\n\n\t    stmt = new NetForLoop(idx_sig, left_expr, cond_expr, sub, step);\n\t    stmt->set_line(*this);\n\n\t    sub = stmt;\n      }\n\n        // If there are no loop variables elide the whole block\n      if (!stmt) {\n\t    delete sub;\n\t    return new NetBlock(NetBlock::SEQU, 0);\n      }\n\n      return stmt;\n}\n\n/*\n * Elaborate the PForStatement as discovered by the parser into a\n * NetForLoop object. The parser detects the:\n *\n *  - index variable (name1_)  (optional)\n *  - initial value (expr1_)   (only if name1_ is present)\n *  - condition expression (cond_) (optional)\n *  - step statement (step_)   (optional)\n *  - sub-statement (statement_)\n *\n * The rules that lead to the PForStatment look like:\n *\n *    for ( <name1_> = <expr1_> ; <cond_> ; <step_> ) <statement_>\n *    for ( ; <cond_ ; <step_> ) <statement_>\n */\nNetProc* PForStatement::elaborate(Design*des, NetScope*scope) const\n{\n      NetExpr*initial_expr;\n      NetNet*sig;\n      bool error_flag = false;\n      ivl_assert(*this, scope);\n\n      if (!name1_) {\n\t    // If there is no initial assignment expression, then mark that\n\t    // fact with null pointers.\n\t    ivl_assert(*this, !expr1_);\n\t    sig = nullptr;\n\t    initial_expr = nullptr;\n\n      } else if (const PEIdent*id1 = dynamic_cast<const PEIdent*>(name1_)) {\n\t    // If there is an initialization assignment, make the expression,\n\t    // and later the initial assignment to the condition variable. The\n\t    // statement in the for loop is very specifically an assignment.\n\t    sig = des->find_signal(scope, id1->path().name);\n\t    if (sig == 0) {\n\t\t  cerr << id1->get_fileline() << \": register ``\" << id1->path()\n\t\t       << \"'' unknown in \" << scope_path(scope) << \".\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    // Make the r-value of the initial assignment, and size it\n\t    // properly. Then use it to build the assignment statement.\n\t    initial_expr = elaborate_rval_expr(des, scope, sig->net_type(),\n\t\t\t\t\t       expr1_);\n\t    if (!initial_expr)\n\t\t  error_flag = true;\n\n\t    if (debug_elaborate && initial_expr) {\n\t\t  cerr << get_fileline() << \": debug: FOR initial assign: \"\n\t\t       << sig->name() << \" = \" << *initial_expr << endl;\n\t    }\n\n      } else {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Index name \" << *name1_ << \" is not a PEIdent.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      // Elaborate the statement that is contained in the for\n      // loop. If there is an error, this will return 0 and I should\n      // skip the append. No need to worry, the error has been\n      // reported so it's OK that the netlist is bogus.\n      NetProc*sub;\n      if (statement_) {\n\t    sub = statement_->elaborate(des, scope);\n\t    if (sub == 0)\n\t\t  error_flag = true;\n      } else {\n\t    sub = new NetBlock(NetBlock::SEQU, 0);\n      }\n\n      // Now elaborate the for_step statement. I really should do\n      // some error checking here to make sure the step statement\n      // really does step the variable.\n      NetProc*step = nullptr;\n      if (step_) {\n\t    step = step_->elaborate(des, scope);\n\t    if (!step)\n\t\t  error_flag = true;\n      }\n\n      // Elaborate the condition expression. Try to evaluate it too,\n      // in case it is a constant. This is an interesting case\n      // worthy of a warning.\n      NetExpr*ce = nullptr;\n      if (cond_) {\n\t    ce = elab_and_eval(des, scope, cond_, -1);\n\t    if (!ce)\n\t\t  error_flag = true;\n\t    if (dynamic_cast<NetEConst*>(ce)) {\n\t\t  cerr << get_fileline() << \": warning: condition expression \"\n\t\t\t\"of for-loop is constant.\" << endl;\n\t    }\n      }\n\n      // Error recovery - if we failed to elaborate any of the loop\n      // expressions, give up now. Error counts where handled elsewhere.\n      if (error_flag) {\n\t    if (initial_expr) delete initial_expr;\n\t    if (ce) delete ce;\n\t    if (step) delete step;\n\t    if (sub) delete sub;\n\t    return 0;\n      }\n\n      // All done, build up the loop. Note that sig and initial_expr may be\n      // nil. But if one is nil, then so is the other. The follow-on code\n      // can handle that case, but let's make sure with an assert that we\n      // have a consistent input.\n      ivl_assert(*this, sig || !initial_expr);\n\n      NetForLoop*loop = new NetForLoop(sig, initial_expr, ce, sub, step);\n      loop->set_line(*this);\n      return loop;\n}\n\n/*\n * (See the PTask::elaborate methods for basic common stuff.)\n *\n * The return value of a function is represented as a reg variable\n * within the scope of the function that has the name of the\n * function. So for example with the function:\n *\n *    function [7:0] incr;\n *      input [7:0] in1;\n *      incr = in1 + 1;\n *    endfunction\n *\n * The scope of the function is <parent>.incr and there is a reg\n * variable <parent>.incr.incr. The elaborate_1 method is called with\n * the scope of the function, so the return reg is easily located.\n *\n * The function parameters are all inputs, except for the synthetic\n * output parameter that is the return value. The return value goes\n * into port 0, and the parameters are all the remaining ports.\n */\n\nvoid PFunction::elaborate(Design*des, NetScope*scope) const\n{\n      if (scope->elab_stage() > 2)\n            return;\n\n      scope->set_elab_stage(3);\n\n      NetFuncDef*def = scope->func_def();\n      if (def == 0) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"No function definition for function \"\n\t\t << scope_path(scope) << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n      ivl_assert(*this, def);\n\n      NetProc*st;\n      if (statement_ == 0) {\n\t    st = new NetBlock(NetBlock::SEQU, 0);\n      } else {\n\t    st = statement_->elaborate(des, scope);\n\t    if (st == 0) {\n\t\t  cerr << statement_->get_fileline() << \": error: Unable to elaborate \"\n\t\t\t  \"statement in function \" << scope->basename() << \".\" << endl;\n\t\t  scope->is_const_func(true); // error recovery\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n      }\n\n\t// Handle any variable initialization statements in this scope.\n\t// For automatic functions, these statements need to be executed\n\t// each time the function is called, so insert them at the start\n\t// of the elaborated definition. For static functions, put them\n\t// in a separate process that will be executed before the start\n\t// of simulation.\n      if (is_auto_) {\n\t      // Get the NetBlock of the statement. If it is not a\n\t      // NetBlock then create one to wrap the initialization\n\t      // statements and the original statement.\n\t    NetBlock*blk = dynamic_cast<NetBlock*> (st);\n\t    if ((blk == 0) && (var_inits.size() > 0)) {\n\t\t  blk = new NetBlock(NetBlock::SEQU, scope);\n\t\t  blk->set_line(*this);\n\t\t  blk->append(st);\n\t\t  st = blk;\n\t    }\n\t    for (unsigned idx = var_inits.size(); idx > 0; idx -= 1) {\n\t\t  NetProc*tmp = var_inits[idx-1]->elaborate(des, scope);\n\t\t  if (tmp) blk->prepend(tmp);\n\t    }\n      } else {\n\t    elaborate_var_inits_(des, scope);\n      }\n\n      def->set_proc(st);\n}\n\nNetProc* PRelease::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      if (scope->is_auto() && lval_->has_aa_term(des, scope)) {\n\t    cerr << get_fileline() << \": error: automatically allocated \"\n                    \"variables may not be assigned values using procedural \"\n\t            \"force statements.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetAssign_*lval = lval_->elaborate_lval(des, scope, false, true);\n      if (lval == 0)\n\t    return 0;\n\n      NetRelease*dev = new NetRelease(lval);\n      dev->set_line( *this );\n      return dev;\n}\n\nNetProc* PRepeat::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      NetExpr*expr = elab_and_eval(des, scope, expr_, -1);\n      if (expr == 0) {\n\t    cerr << get_fileline() << \": Unable to elaborate\"\n\t\t  \" repeat expression.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\t// If the expression is real, convert to an integer. 64 bits\n\t// should be more enough for any real use case.\n      if (expr->expr_type() == IVL_VT_REAL)\n\t    expr = cast_to_int4(expr, 64);\n\n      NetProc*stat;\n      if (statement_)\n\t    stat = statement_->elaborate(des, scope);\n      else\n\t    stat = new NetBlock(NetBlock::SEQU, 0);\n      if (stat == 0) return 0;\n\n\t// If the expression is a constant, handle certain special\n\t// iteration counts.\n      if (NetEConst*ce = dynamic_cast<NetEConst*>(expr)) {\n\t    long val = ce->value().as_long();\n\t    if (val <= 0) {\n\t\t  delete expr;\n\t\t  delete stat;\n\t\t  return new NetBlock(NetBlock::SEQU, 0);\n\t    } else if (val == 1) {\n\t\t  delete expr;\n\t\t  return stat;\n\t    }\n      }\n\n      NetRepeat*proc = new NetRepeat(expr, stat);\n      proc->set_line( *this );\n      return proc;\n}\n\nNetProc* PReturn::elaborate(Design*des, NetScope*scope) const\n{\n      NetScope*target = scope;\n\n      if (des->is_in_fork()) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Return statement is not allowed within fork-join block.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      for (;;) {\n\t    if (target == 0) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Return statement is not in a function or task.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\n\t    if (target->type() == NetScope::FUNC)\n\t\t  break;\n\t    if (target->type() == NetScope::TASK)\n\t\t  break;\n\n\t    if (target->type()==NetScope::BEGIN_END) {\n\t\t  target = target->parent();\n\t\t  continue;\n\t    }\n\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Cannot \\\"return\\\" from this scope: \" << scope_path(target) << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (target->type() == NetScope::TASK) {\n\t    if (expr_) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"A value cannot be returned from a task.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    NetDisable *disa = new NetDisable(target, true);\n\t    disa->set_line(*this);\n\t    return disa;\n      }\n\n      ivl_assert(*this, target->type() == NetScope::FUNC);\n\n      if (target->func_def()->is_void()) {\n\t    if (expr_) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"A value can't be returned from a void function.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    NetDisable*disa = new NetDisable(target, true);\n\t    disa->set_line( *this );\n\t    return disa;\n      }\n\n      if (expr_ == 0) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t << \"Return from \" << scope_path(target)\n\t\t << \" requires a return value expression.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetNet*res = target->find_signal(target->basename());\n      ivl_assert(*this, res);\n      NetAssign_*lv = new NetAssign_(res);\n\n      NetExpr*val = elaborate_rval_expr(des, scope, res->net_type(), expr_);\n\n      NetBlock*proc = new NetBlock(NetBlock::SEQU, 0);\n      proc->set_line( *this );\n\n      NetAssign*assn = new NetAssign(lv, val);\n      assn->set_line( *this );\n      proc->append(assn);\n\n      NetDisable*disa = new NetDisable(target, true);\n      disa->set_line( *this );\n      proc->append( disa );\n\n      return proc;\n}\n\n/*\n * A task definition is elaborated by elaborating the statement that\n * it contains, and connecting its ports to NetNet objects. The\n * netlist doesn't really need the array of parameters once elaboration\n * is complete, but this is the best place to store them.\n *\n * The first elaboration pass finds the reg objects that match the\n * port names, and creates the NetTaskDef object. The port names are\n * in the form task.port.\n *\n *      task foo;\n *        output blah;\n *        begin <body> end\n *      endtask\n *\n * So in the foo example, the PWire objects that represent the ports\n * of the task will include a foo.blah for the blah port. This port is\n * bound to a NetNet object by looking up the name. All of this is\n * handled by the PTask::elaborate_sig method and the results stashed\n * in the created NetTaskDef attached to the scope.\n *\n * Elaboration pass 2 for the task definition causes the statement of\n * the task to be elaborated and attached to the NetTaskDef object\n * created in pass 1.\n *\n * NOTE: I am not sure why I bothered to prepend the task name to the\n * port name when making the port list. It is not really useful, but\n * that is what I did in pform_make_task_ports, so there it is.\n */\n\nvoid PTask::elaborate(Design*des, NetScope*task) const\n{\n      NetTaskDef*def = task->task_def();\n      ivl_assert(*this, def);\n\n      NetProc*st;\n      if (statement_ == 0) {\n\t    st = new NetBlock(NetBlock::SEQU, 0);\n\n      } else {\n\n\t    st = statement_->elaborate(des, task);\n\t    if (st == 0) {\n\t\t  cerr << statement_->get_fileline() << \": Unable to elaborate \"\n\t\t\t\"statement in task \" << scope_path(task)\n\t\t       << \" at \" << get_fileline() << \".\" << endl;\n\t\t  return;\n\t    }\n      }\n\n\t// Handle any variable initialization statements in this scope.\n\t// For automatic tasks , these statements need to be executed\n\t// each time the task is called, so insert them at the start\n\t// of the elaborated definition. For static tasks, put them\n\t// in a separate process that will be executed before the start\n\t// of simulation.\n      if (is_auto_) {\n\t      // Get the NetBlock of the statement. If it is not a\n\t      // NetBlock then create one to wrap the initialization\n\t      // statements and the original statement.\n\t    NetBlock*blk = dynamic_cast<NetBlock*> (st);\n\t    if ((blk == 0) && (var_inits.size() > 0)) {\n\t\t  blk = new NetBlock(NetBlock::SEQU, task);\n\t\t  blk->set_line(*this);\n\t\t  blk->append(st);\n\t\t  st = blk;\n\t    }\n\t    for (unsigned idx = var_inits.size(); idx > 0; idx -= 1) {\n\t\t  NetProc*tmp = var_inits[idx-1]->elaborate(des, task);\n\t\t  if (tmp) blk->prepend(tmp);\n\t    }\n      } else {\n\t    elaborate_var_inits_(des, task);\n      }\n\n      def->set_proc(st);\n}\n\nNetProc* PTrigger::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      symbol_search_results sr;\n      if (!symbol_search(this, des, scope, event_, lexical_pos_, &sr)) {\n\t    cerr << get_fileline() << \": error: event <\" << event_ << \">\"\n\t\t << \" not found.\" << endl;\n\t    if (sr.decl_after_use) {\n\t\t  cerr << sr.decl_after_use->get_fileline() << \":      : \"\n\t\t\t  \"A symbol with that name was declared here. \"\n\t\t\t  \"Check for declaration after use.\" << endl;\n\t    }\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (!sr.eve) {\n\t    cerr << get_fileline() << \": error:  <\" << event_ << \">\"\n\t\t << \" is not a named event.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetEvTrig*trig = new NetEvTrig(sr.eve);\n      trig->set_line(*this);\n      return trig;\n}\n\nNetProc* PNBTrigger::elaborate(Design*des, NetScope*scope) const\n{\n      ivl_assert(*this, scope);\n\n      symbol_search_results sr;\n      if (!symbol_search(this, des, scope, event_, lexical_pos_, &sr)) {\n\t    cerr << get_fileline() << \": error: event <\" << event_ << \">\"\n\t\t << \" not found.\" << endl;\n\t    if (sr.decl_after_use) {\n\t\t  cerr << sr.decl_after_use->get_fileline() << \":      : \"\n\t\t\t  \"A symbol with that name was declared here. \"\n\t\t\t  \"Check for declaration after use.\" << endl;\n\t    }\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (sr.eve == 0) {\n\t    cerr << get_fileline() << \": error:  <\" << event_ << \">\"\n\t\t << \" is not a named event.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetExpr*dly = 0;\n      if (dly_) dly = elab_and_eval(des, scope, dly_, -1);\n      NetEvNBTrig*trig = new NetEvNBTrig(sr.eve, dly);\n      trig->set_line(*this);\n      return trig;\n}\n\n/*\n * The while loop is fairly directly represented in the netlist.\n */\nNetProc* PWhile::elaborate(Design*des, NetScope*scope) const\n{\n      NetExpr*ce = elab_and_eval(des, scope, cond_, -1);\n      NetProc*sub;\n      if (statement_)\n\t    sub = statement_->elaborate(des, scope);\n      else\n\t    sub = new NetBlock(NetBlock::SEQU, 0);\n      if (ce == 0 || sub == 0) {\n\t    delete ce;\n\t    delete sub;\n\t    return 0;\n      }\n      NetWhile*loop = new NetWhile(ce, sub);\n      loop->set_line(*this);\n      return loop;\n}\n\nbool PProcess::elaborate(Design*des, NetScope*scope) const\n{\n      scope->in_final(type() == IVL_PR_FINAL);\n      NetProc*cur = statement_->elaborate(des, scope);\n      scope->in_final(false);\n      if (cur == 0) {\n\t    return false;\n      }\n\n      NetProcTop*top=new NetProcTop(scope, type(), cur);\n      ivl_assert(*this, top);\n\n\t// Evaluate the attributes for this process, if there\n\t// are any. These attributes are to be attached to the\n\t// NetProcTop object.\n      struct attrib_list_t*attrib_list;\n      unsigned attrib_list_n = 0;\n      attrib_list = evaluate_attributes(attributes, attrib_list_n, des, scope);\n\n      for (unsigned adx = 0 ;  adx < attrib_list_n ;  adx += 1)\n\t    top->attribute(attrib_list[adx].key,\n\t\t\t   attrib_list[adx].val);\n\n      delete[]attrib_list;\n\n      top->set_line(*this);\n      des->add_process(top);\n\n\t/* Detect the special case that this is a combinational\n\talways block. We want to attach an _ivl_schedule_push\n\tattribute to this process so that it starts up and\n\tgets into its wait statement before non-combinational\n\tcode is executed. */\n      do {\n\t    if ((top->type() != IVL_PR_ALWAYS) &&\n\t        (top->type() != IVL_PR_ALWAYS_COMB) &&\n\t        (top->type() != IVL_PR_ALWAYS_FF) &&\n\t        (top->type() != IVL_PR_ALWAYS_LATCH))\n\t\t  break;\n\n\t    NetEvWait*st = dynamic_cast<NetEvWait*>(top->statement());\n\t    if (st == 0)\n\t\t  break;\n\n\t    if (st->nevents() != 1)\n\t\t  break;\n\n\t    NetEvent*ev = st->event(0);\n\n\t    if (ev->nprobe() == 0)\n\t\t  break;\n\n\t    bool anyedge_test = true;\n\t    for (unsigned idx = 0 ;  anyedge_test && (idx<ev->nprobe())\n\t\t       ; idx += 1) {\n\t\t  const NetEvProbe*pr = ev->probe(idx);\n\t\t  if (pr->edge() != NetEvProbe::ANYEDGE)\n\t\t\tanyedge_test = false;\n\t    }\n\n\t    if (! anyedge_test)\n\t\t  break;\n\n\t    top->attribute(perm_string::literal(\"_ivl_schedule_push\"),\n\t\t\t   verinum(1));\n      } while (0);\n\n      return true;\n}\n\nvoid PSpecPath::elaborate(Design*des, NetScope*scope) const\n{\n      uint64_t delay_value[12];\n      unsigned ndelays = 0;\n\n\t/* Do not elaborate specify delay paths if this feature is\n\t   turned off. */\n      if (!gn_specify_blocks_flag) return;\n\n      ivl_assert(*this, conditional || (condition==0));\n\n      ndelays = delays.size();\n      if (ndelays > 12) ndelays = 12;\n\n      check_for_inconsistent_delays(scope);\n\n\t/* Elaborate the delay values themselves. Remember to scale\n\t   them for the timescale/precision of the scope. */\n      for (unsigned idx = 0 ;  idx < ndelays ;  idx += 1) {\n\t    PExpr*exp = delays[idx];\n\t    NetExpr*cur = elab_and_eval(des, scope, exp, -1);\n\n\t    if (NetEConst*con = dynamic_cast<NetEConst*> (cur)) {\n\t\t  verinum fn = con->value();\n\t\t  delay_value[idx] = des->scale_to_precision(fn.as_ulong64(),\n\t\t                                             scope);\n\n\t    } else if (NetECReal*rcon = dynamic_cast<NetECReal*>(cur)) {\n\t\t  delay_value[idx] = get_scaled_time_from_real(des, scope,\n\t\t                                               rcon);\n\n\t    } else {\n\t\t  cerr << get_fileline() << \": error: Path delay value \"\n\t\t       << \"must be constant (\" << *cur << \").\" << endl;\n\t\t  delay_value[idx] = 0;\n\t\t  des->errors += 1;\n\t    }\n\t    delete cur;\n      }\n\n      switch (delays.size()) {\n\t  case 1:\n\t  case 2:\n\t  case 3:\n\t  case 6:\n\t  case 12:\n\t    break;\n\t  default:\n\t    cerr << get_fileline() << \": error: Incorrect delay configuration.\"\n\t\t << \" Given \" << delays.size() << \" delay expressions.\" << endl;\n\t    ndelays = 1;\n\t    des->errors += 1;\n\t    break;\n      }\n\n      NetNet*condit_sig = 0;\n      if (conditional && condition) {\n\n\t    NetExpr*tmp = elab_and_eval(des, scope, condition, -1);\n\t    ivl_assert(*condition, tmp);\n\n\t      // FIXME: Look for constant expressions here?\n\n\t      // Get a net form.\n\t    condit_sig = tmp->synthesize(des, scope, tmp);\n\t    ivl_assert(*condition, condit_sig);\n      }\n\n\t/* A parallel connection does not support more than a one to one\n\t   connection (source/destination). */\n      if (! full_flag_ && ((src.size() != 1) || (dst.size() != 1))) {\n\t    /* To be compatible with NC-Verilog we allow a parallel connection\n\t     * with multiple sources/destinations if all the paths are only a\n\t     * single bit wide (a scalar or a one bit vector). */\n\t    bool all_single = true;\n\t    typedef std::vector<perm_string>::const_iterator str_vec_iter;\n\t    for (str_vec_iter cur = src.begin();\n\t\t ( cur != src.end() && all_single); ++ cur) {\n\t\t  NetNet *psig = scope->find_signal(*cur);\n\t\t    /* We will report a missing signal as invalid later. For\n\t\t     * now assume it's a single bit. */\n\t\t  if (psig == 0) continue;\n\t\t  if (psig->vector_width() != 1) all_single = false;\n\t    }\n\t    for (str_vec_iter cur = dst.begin();\n\t\t ( cur != dst.end() && all_single); ++ cur) {\n\t\t  NetNet *psig = scope->find_signal(*cur);\n\t\t    /* The same as above for source paths. */\n\t\t  if (psig == 0) continue;\n\t\t  if (psig->vector_width() != 1) all_single = false;\n\t    }\n\n\t    if (! all_single) {\n\t\t  cerr << get_fileline() << \": error: Parallel connections \"\n\t\t          \"only support one source/destination path found (\"\n\t\t       << src.size() << \"/\" << dst.size() << \").\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n\n\t/* Create all the various paths from the path specifier. */\n      typedef std::vector<perm_string>::const_iterator str_vector_iter;\n      for (str_vector_iter cur = dst.begin()\n\t\t ; cur != dst.end() ; ++ cur ) {\n\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": debug: Path to \" << (*cur);\n\t\t  if (condit_sig)\n\t\t\tcerr << \" if \" << condit_sig->name();\n\t\t  else if (conditional)\n\t\t\tcerr << \" ifnone\";\n\t\t  cerr << \" from \";\n\t    }\n\n\t    NetNet*dst_sig = scope->find_signal(*cur);\n\t    if (dst_sig == 0) {\n\t\t  cerr << get_fileline() << \": error: No wire '\"\n\t\t       << *cur << \"' in this module.\" << endl;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    unsigned long dst_wid = dst_sig->vector_width();\n\n\t    if (dst_sig->port_type() != NetNet::POUTPUT\n\t\t&& dst_sig->port_type() != NetNet::PINOUT) {\n\n\t\t  cerr << get_fileline() << \": error: Path destination \"\n\t\t       << *cur << \" must be an output or inout port.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\n\t    NetDelaySrc*path = new NetDelaySrc(scope, scope->local_symbol(),\n\t\t\t\t\t       src.size(), condit_sig,\n\t\t\t\t\t       conditional, !full_flag_);\n\t    path->set_line(*this);\n\n\t      // The presence of the data_source_expression indicates\n\t      // that this is an edge sensitive path. If so, then set\n\t      // the edges. Note that edge==0 is BOTH edges.\n\t    if (data_source_expression) {\n\t\t  if (edge >= 0) path->set_posedge();\n\t\t  if (edge <= 0) path->set_negedge();\n\t    }\n\n\t    switch (ndelays) {\n\t\tcase 12:\n\t\t  path->set_delays(delay_value[0],  delay_value[1],\n\t\t\t\t   delay_value[2],  delay_value[3],\n\t\t\t\t   delay_value[4],  delay_value[5],\n\t\t\t\t   delay_value[6],  delay_value[7],\n\t\t\t\t   delay_value[8],  delay_value[9],\n\t\t\t\t   delay_value[10], delay_value[11]);\n\t\t  break;\n\t\tcase 6:\n\t\t  path->set_delays(delay_value[0], delay_value[1],\n\t\t\t\t   delay_value[2], delay_value[3],\n\t\t\t\t   delay_value[4], delay_value[5]);\n\t\t  break;\n\t\tcase 3:\n\t\t  path->set_delays(delay_value[0], delay_value[1],\n\t\t\t\t   delay_value[2]);\n\t\t  break;\n\t\tcase 2:\n\t\t  path->set_delays(delay_value[0], delay_value[1]);\n\t\t  break;\n\t\tcase 1:\n\t\t  path->set_delays(delay_value[0]);\n\t\t  break;\n\t    }\n\n\t    unsigned idx = 0;\n\t    for (str_vector_iter cur_src = src.begin()\n\t\t       ; cur_src != src.end() ; ++ cur_src ) {\n\t\t  NetNet*src_sig = scope->find_signal(*cur_src);\n\t\t  if (src_sig == 0) {\n\t\t\tcerr << get_fileline() << \": error: No wire '\"\n\t\t\t     << *cur_src << \"' in this module.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  if (debug_elaborate) {\n\t\t\tif (cur_src != src.begin()) cerr << \" and \";\n\t\t\tcerr << src_sig->name();\n\t\t  }\n\n\t\t  if ( (src_sig->port_type() != NetNet::PINPUT)\n\t\t    && (src_sig->port_type() != NetNet::PINOUT) ) {\n\n\t\t\tcerr << get_fileline() << \": error: Path source \"\n\t\t\t     << *cur_src << \" must be an input or inout port.\"\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\n\t\t    // For a parallel connection the source and destination\n\t\t    // must be the same width.\n\t\t  if (! full_flag_) {\n\t\t\tunsigned long src_wid = src_sig->vector_width();\n\t\t\tif (src_wid != dst_wid) {\n\t\t\t      cerr << get_fileline() << \": error: For a \"\n\t\t\t              \"parallel connection the \"\n\t\t\t              \"source/destination width must match \"\n\t\t\t              \"found (\" << src_wid << \"/\" << dst_wid\n\t\t\t           << \").\" << endl;\n\t\t\t      des->errors += 1;\n\t\t\t}\n\t\t  }\n\n\t\t  connect(src_sig->pin(0), path->pin(idx));\n\t\t  idx += 1;\n\t    }\n\t    if (debug_elaborate) {\n\t\t  cerr << endl;\n\t    }\n\n\t    if (condit_sig)\n\t\t  connect(condit_sig->pin(0), path->pin(idx));\n\n\t    dst_sig->add_delay_path(path);\n      }\n}\n\nvoid PRecRem::elaborate(Design*des, NetScope*scope) const\n{\n      // At present, no timing checks are supported.\n      // Still, in order to get some models working\n      // assign the original reference and data signals to\n      // the delayed reference and data signals as per\n      // 15.5.4 Option behavior\n\n      if (delayed_reference_ != nullptr)\n      {\n\t      if (debug_elaborate) {\n\t\t    cerr << get_fileline() << \": PRecRem::elaborate: Assigning \"\n\t\t       << reference_event_->name\n\t\t       << \" to \" << *delayed_reference_ << endl;\n\t      }\n\n\t      NetNet*sig = des->find_signal(scope, reference_event_->name);\n\n\t      if (sig == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << reference_event_->name << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      NetNet*sig_delayed = des->find_signal(scope, *delayed_reference_);\n\n\t      if (sig_delayed == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << *delayed_reference_ << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      connect(sig->pin(0), sig_delayed->pin(0));\n      }\n\n      if (delayed_data_ != nullptr)\n      {\n\t      if (debug_elaborate) {\n\t\t    cerr << get_fileline() << \": PRecRem::elaborate: Assigning \"\n\t\t       << data_event_->name\n\t\t       << \" to \" << *delayed_data_ << endl;\n\t      }\n\n\t      NetNet*sig = des->find_signal(scope, data_event_->name);\n\n\t      if (sig == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << data_event_->name << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      NetNet*sig_delayed = des->find_signal(scope, *delayed_data_);\n\n\t      if (sig_delayed == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << *delayed_data_ << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      connect(sig->pin(0), sig_delayed->pin(0));\n      }\n}\n\nvoid PSetupHold::elaborate(Design*des, NetScope*scope) const\n{\n      // At present, no timing checks are supported.\n      // Still, in order to get some models working\n      // assign the original reference and data signals to\n      // the delayed reference and data signals as per\n      // 15.5.4 Option behavior\n\n      if (delayed_reference_ != nullptr)\n      {\n\t      if (debug_elaborate) {\n\t\t    cerr << get_fileline() << \": PSetupHold::elaborate: Assigning\"\n\t\t       << reference_event_->name\n\t\t       << \" to \" << *delayed_reference_ << endl;\n\t      }\n\n\t      NetNet*sig = des->find_signal(scope, reference_event_->name);\n\n\t      if (sig == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << reference_event_->name << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      NetNet*sig_delayed = des->find_signal(scope, *delayed_reference_);\n\n\t      if (sig_delayed == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << *delayed_reference_ << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      connect(sig->pin(0), sig_delayed->pin(0));\n      }\n\n      if (delayed_data_ != nullptr)\n      {\n\t      if (debug_elaborate) {\n\t\t    cerr << get_fileline() << \": PSetupHold::elaborate: Assigning\"\n\t\t       << data_event_->name\n\t\t       << \" to \" << *delayed_data_ << endl;\n\t      }\n\n\t      NetNet*sig = des->find_signal(scope, data_event_->name);\n\n\t      if (sig == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << data_event_->name << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      NetNet*sig_delayed = des->find_signal(scope, *delayed_data_);\n\n\t      if (sig_delayed == nullptr) {\n\t\t    cerr << get_fileline() << \": error: Cannot find: \"\n\t\t       << *delayed_data_ << endl;\n\t\t    des->errors += 1;\n\t\t    return;\n\t      }\n\n\t      connect(sig->pin(0), sig_delayed->pin(0));\n      }\n}\n\nstatic void elaborate_functions(Design*des, NetScope*scope,\n\t\t\t\tconst map<perm_string,PFunction*>&funcs)\n{\n      typedef map<perm_string,PFunction*>::const_iterator mfunc_it_t;\n      for (mfunc_it_t cur = funcs.begin()\n\t\t ; cur != funcs.end() ; ++ cur ) {\n\n\t    hname_t use_name ( (*cur).first );\n\t    NetScope*fscope = scope->child(use_name);\n\t    ivl_assert(*(*cur).second, fscope);\n\t    (*cur).second->elaborate(des, fscope);\n      }\n}\n\nstatic void elaborate_tasks(Design*des, NetScope*scope,\n\t\t\t    const map<perm_string,PTask*>&tasks)\n{\n      typedef map<perm_string,PTask*>::const_iterator mtask_it_t;\n      for (mtask_it_t cur = tasks.begin()\n\t\t ; cur != tasks.end() ; ++ cur ) {\n\n\t    hname_t use_name ( (*cur).first );\n\t    NetScope*tscope = scope->child(use_name);\n\t    ivl_assert(*(*cur).second, tscope);\n\t    (*cur).second->elaborate(des, tscope);\n      }\n}\n\nstatic void elaborate_classes(Design*des, NetScope*scope,\n\t\t\t      const map<perm_string,PClass*>&classes)\n{\n      for (map<perm_string,PClass*>::const_iterator cur = classes.begin()\n\t\t ; cur != classes.end() ; ++ cur) {\n\t    netclass_t*use_class = scope->find_class(des, cur->second->pscope_name());\n\t    use_class->elaborate(des, cur->second);\n\n\t    if (use_class->test_for_missing_initializers()) {\n\t\t  cerr << cur->second->get_fileline() << \": error: \"\n\t\t       << \"Const properties of class \" << use_class->get_name()\n\t\t       << \" are missing initialization.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n}\n\nbool PPackage::elaborate(Design*des, NetScope*scope) const\n{\n      bool result_flag = true;\n\n\t// Elaborate function methods, and...\n      elaborate_functions(des, scope, funcs);\n\n\t// Elaborate task methods.\n      elaborate_tasks(des, scope, tasks);\n\n\t// Elaborate class definitions.\n      elaborate_classes(des, scope, classes);\n\n\t// Elaborate the variable initialization statements, making a\n\t// single initial process out of them.\n      result_flag &= elaborate_var_inits_(des, scope);\n\n      return result_flag;\n}\n\n/*\n * When a module is instantiated, it creates the scope then uses this\n * method to elaborate the contents of the module.\n */\n\nbool Module::elaborate(Design*des, NetScope*scope) const\n{\n      bool result_flag = true;\n\n\t// Elaborate the elaboration tasks.\n      for (const auto et : elab_tasks) {\n\t    result_flag &= et->elaborate_elab(des, scope);\n\t      // Only elaborate until a fatal elab task.\n\t    if (!result_flag) break;\n      }\n\n\t// If there are no fatal elab tasks then elaborate the rest.\n      if (result_flag) {\n\t      // Elaborate within the generate blocks.\n\t    for (const auto cur : generate_schemes) cur->elaborate(des, scope);\n\n\t      // Elaborate functions.\n\t    elaborate_functions(des, scope, funcs);\n\n\t      // Elaborate the task definitions. This is done before the\n\t      // behaviors so that task calls may reference these, and after\n\t      // the signals so that the tasks can reference them.\n\t    elaborate_tasks(des, scope, tasks);\n\n\t      // Elaborate class definitions.\n\t    elaborate_classes(des, scope, classes);\n\n\t      // Get all the gates of the module and elaborate them by\n\t      // connecting them to the signals. The gate may be simple or\n\t      // complex.\n\t    const list<PGate*>&gl = get_gates();\n\n\t    for (const auto gt : gl) gt->elaborate(des, scope);\n\n\t      // Elaborate the variable initialization statements, making a\n\t      // single initial process out of them.\n\t    result_flag &= elaborate_var_inits_(des, scope);\n\n\t      // Elaborate the behaviors, making processes out of them. This\n\t      // involves scanning the PProcess* list, creating a NetProcTop\n\t      // for each process.\n\t    result_flag &= elaborate_behaviors_(des, scope);\n\n\t      // Elaborate the specify paths of the module.\n\t    for (const auto sp : specify_paths) sp->elaborate(des, scope);\n\n\t      // Elaborate the timing checks of the module.\n\t    for (const auto tc : timing_checks) tc->elaborate(des, scope);\n      }\n\n      return result_flag;\n}\n\n/*\n * Elaborating a netclass_t means elaborating the PFunction and PTask\n * objects that it contains. The scopes and signals have already been\n * elaborated in the class of the netclass_t scope, so we can get the\n * child scope for each definition and use that for the context of the\n * function.\n */\nvoid netclass_t::elaborate(Design*des, PClass*pclass)\n{\n      if (! pclass->type->initialize_static.empty()) {\n\t    std::vector<Statement*>&stmt_list = pclass->type->initialize_static;\n\t    NetBlock*stmt = new NetBlock(NetBlock::SEQU, 0);\n\t    for (size_t idx = 0 ; idx < stmt_list.size() ; idx += 1) {\n\t\t  NetProc*tmp = stmt_list[idx]->elaborate(des, class_scope_);\n\t\t  if (tmp == 0) continue;\n\t\t  stmt->append(tmp);\n\t    }\n\t    NetProcTop*top = new NetProcTop(class_scope_, IVL_PR_INITIAL, stmt);\n\t    top->set_line(*pclass);\n\t    des->add_process(top);\n      }\n\n      for (map<perm_string,PFunction*>::iterator cur = pclass->funcs.begin()\n\t\t ; cur != pclass->funcs.end() ; ++ cur) {\n\t    if (debug_elaborate) {\n\t\t  cerr << cur->second->get_fileline() << \": netclass_t::elaborate: \"\n\t\t       << \"Elaborate class \" << scope_path(class_scope_)\n\t\t       << \" function method \" << cur->first << endl;\n\t    }\n\n\t    NetScope*scope = class_scope_->child( hname_t(cur->first) );\n\t    ivl_assert(*cur->second, scope);\n\t    cur->second->elaborate(des, scope);\n      }\n\n      for (map<perm_string,PTask*>::iterator cur = pclass->tasks.begin()\n\t\t ; cur != pclass->tasks.end() ; ++ cur) {\n\t    if (debug_elaborate) {\n\t\t  cerr << cur->second->get_fileline() << \": netclass_t::elaborate: \"\n\t\t       << \"Elaborate class \" << scope_path(class_scope_)\n\t\t       << \" task method \" << cur->first << endl;\n\t    }\n\n\t    NetScope*scope = class_scope_->child( hname_t(cur->first) );\n\t    ivl_assert(*cur->second, scope);\n\t    cur->second->elaborate(des, scope);\n      }\n}\n\nbool PGenerate::elaborate(Design*des, NetScope*container) const\n{\n      if (directly_nested)\n\t    return elaborate_direct_(des, container);\n\n      bool flag = true;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": PGenerate::elaborate: \"\n\t\t  \"generate \" << scheme_type\n\t\t << \" elaborating in scope \" << scope_path(container)\n\t\t << \".\" << endl;\n\t    cerr << get_fileline() << \": PGenerate::elaborate: \"\n\t\t  \"generate scope_name=\" << scope_name\n\t\t << \", id_number=\" << id_number << endl;\n      }\n\n\t// Handle the special case that this is a CASE scheme. In this\n\t// case the PGenerate itself does not have the generated\n\t// item. Look instead for the case ITEM that has a scope\n\t// generated for it.\n      if (scheme_type == PGenerate::GS_CASE) {\n\n\t    typedef list<PGenerate*>::const_iterator generate_it_t;\n\t    for (generate_it_t cur = generate_schemes.begin()\n\t\t       ; cur != generate_schemes.end() ; ++ cur ) {\n\t\t  PGenerate*item = *cur;\n\t\t  if (item->directly_nested || !item->scope_list_.empty()) {\n\t\t\tflag &= item->elaborate(des, container);\n\t\t  }\n\t    }\n\t    return flag;\n      }\n\n      typedef list<NetScope*>::const_iterator scope_list_it_t;\n      for (scope_list_it_t cur = scope_list_.begin()\n\t\t ; cur != scope_list_.end() ; ++ cur ) {\n\n\t    NetScope*scope = *cur;\n\t      // Check that this scope is one that is contained in the\n\t      // container that the caller passed in.\n\t    if (scope->parent() != container)\n\t\t  continue;\n\n\t      // If this was an unnamed generate block, replace its\n\t      // temporary name with a name generated using the naming\n\t      // scheme defined in the Verilog-2005 standard.\n\t    const char*name = scope_name.str();\n\t    if (name[0] == '$') {\n\n\t\t  if (!scope->auto_name(\"genblk\", '0', name + 4)) {\n\t\t\tcerr << get_fileline() << \": warning: Couldn't build\"\n\t\t\t     << \" unique name for unnamed generate block\"\n\t\t\t     << \" - using internal name \" << name << endl;\n\t\t  }\n\t    }\n\t    if (debug_elaborate)\n\t\t  cerr << get_fileline() << \": debug: Elaborate in \"\n\t\t       << \"scope \" << scope_path(scope) << endl;\n\n\t    flag = elaborate_(des, scope) & flag;\n      }\n\n      return flag;\n}\n\nbool PGenerate::elaborate_direct_(Design*des, NetScope*container) const\n{\n      bool flag = true;\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: \"\n\t\t << \"Direct nesting elaborate in scope \"\n\t\t << scope_path(container)\n\t\t << \", scheme_type=\" << scheme_type << endl;\n      }\n\n\t// Elaborate for a direct nested generated scheme knows\n\t// that there are only sub_schemes to be elaborated.  There\n\t// should be exactly 1 active generate scheme, search for it\n\t// using this loop.\n      typedef list<PGenerate*>::const_iterator generate_it_t;\n      for (generate_it_t cur = generate_schemes.begin()\n\t\t ; cur != generate_schemes.end() ; ++ cur ) {\n\t    PGenerate*item = *cur;\n\t    if (debug_elaborate) {\n\t\t  cerr << get_fileline() << \": PGenerate::elaborate_direct_: \"\n\t\t       << \"item->scope_name=\" << item->scope_name\n\t\t       << \", item->scheme_type=\" << item->scheme_type\n\t\t       << \", item->directly_nested=\" << item->directly_nested\n\t\t       << \", item->scope_list_.size()=\" << item->scope_list_.size()\n\t\t       << \".\" << endl;\n\t    }\n\n\t      // Special case: If this is a case generate scheme, then\n\t      // the PGenerate object (item) does not actually\n\t      // contain anything. Instead scan the case items, which\n\t      // are listed as sub-schemes of the item.\n\t    if (item->scheme_type == PGenerate::GS_CASE) {\n\t\t  for (generate_it_t icur = item->generate_schemes.begin()\n\t\t\t     ; icur != item->generate_schemes.end() ; ++ icur ) {\n\t\t\tPGenerate*case_item = *icur;\n\t\t\tif (case_item->directly_nested || !case_item->scope_list_.empty()) {\n\t\t\t      flag &= case_item->elaborate(des, container);\n\t\t\t}\n\t\t  }\n\t    } else {\n\t\t  if (item->directly_nested || !item->scope_list_.empty()) {\n\t\t\t  // Found the item, and it is direct nested.\n\t\t\tflag &= item->elaborate(des, container);\n\t\t  }\n\t    }\n      }\n      return flag;\n}\n\nbool PGenerate::elaborate_(Design*des, NetScope*scope) const\n{\n      bool result_flag = true;\n\n\t// Elaborate the elaboration tasks.\n      for (const auto et : elab_tasks) {\n\t    result_flag &= et->elaborate_elab(des, scope);\n\t      // Only elaborate until a fatal elab task.\n\t    if (!result_flag) break;\n      }\n\n\t// If there are no fatal elab tasks then elaborate the rest.\n      if (result_flag) {\n\t    elaborate_functions(des, scope, funcs);\n\t    elaborate_tasks(des, scope, tasks);\n\n\t    for (const auto gt : gates) gt->elaborate(des, scope);\n\n\t    result_flag &= elaborate_var_inits_(des, scope);\n\n\t    for (const auto bh : behaviors) bh->elaborate(des, scope);\n\n\t    for (const auto gs : generate_schemes) gs->elaborate(des, scope);\n      }\n\n      return result_flag;\n}\n\nbool PScope::elaborate_behaviors_(Design*des, NetScope*scope) const\n{\n      bool result_flag = true;\n\n\t// Elaborate the behaviors, making processes out of them. This\n\t// involves scanning the PProcess* list, creating a NetProcTop\n\t// for each process.\n      for (list<PProcess*>::const_iterator st = behaviors.begin()\n\t\t ; st != behaviors.end() ; ++ st ) {\n\n\t    result_flag &= (*st)->elaborate(des, scope);\n      }\n\n      for (list<AProcess*>::const_iterator st = analog_behaviors.begin()\n\t\t ; st != analog_behaviors.end() ; ++ st ) {\n\n\t    result_flag &= (*st)->elaborate(des, scope);\n      }\n\n      return result_flag;\n}\n\nbool LexicalScope::elaborate_var_inits_(Design*des, NetScope*scope) const\n{\n      if (var_inits.size() == 0)\n\t    return true;\n\n      NetProc*proc = 0;\n      if (var_inits.size() == 1) {\n\t    proc = var_inits[0]->elaborate(des, scope);\n      } else {\n\t    NetBlock*blk = new NetBlock(NetBlock::SEQU, 0);\n\t    bool flag = true;\n\t    for (unsigned idx = 0; idx < var_inits.size(); idx += 1) {\n\t\t  NetProc*tmp = var_inits[idx]->elaborate(des, scope);\n\t\t  if (tmp)\n\t\t\tblk->append(tmp);\n\t\t  else\n\t\t\tflag = false;\n\t    }\n\t    if (flag) proc = blk;\n      }\n      if (proc == 0)\n\t    return false;\n\n      NetProcTop*top = new NetProcTop(scope, IVL_PR_INITIAL, proc);\n      if (const LineInfo*li = dynamic_cast<const LineInfo*>(this)) {\n\t    top->set_line(*li);\n      }\n      if (gn_system_verilog()) {\n\t    top->attribute(perm_string::literal(\"_ivl_schedule_init\"),\n\t\t\t   verinum(1));\n      }\n      des->add_process(top);\n\n      scope->set_var_init(proc);\n\n      return true;\n}\n\nclass elaborate_package_t : public elaborator_work_item_t {\n    public:\n      elaborate_package_t(Design*d, NetScope*scope, PPackage*p)\n      : elaborator_work_item_t(d), scope_(scope), package_(p)\n      { }\n\n      ~elaborate_package_t() { }\n\n      virtual void elaborate_runrun()\n      {\n\t    if (! package_->elaborate_scope(des, scope_))\n\t\t  des->errors += 1;\n      }\n\n    private:\n      NetScope*scope_;\n      PPackage*package_;\n};\n\nclass elaborate_root_scope_t : public elaborator_work_item_t {\n    public:\n      elaborate_root_scope_t(Design*des__, NetScope*scope, Module*rmod)\n      : elaborator_work_item_t(des__), scope_(scope), rmod_(rmod)\n      { }\n\n      ~elaborate_root_scope_t() { }\n\n      virtual void elaborate_runrun()\n      {\n\t    Module::replace_t root_repl;\n\t    for (list<Module::named_expr_t>::iterator cur = Module::user_defparms.begin()\n\t\t       ; cur != Module::user_defparms.end() ; ++ cur ) {\n\n\t\t  pform_name_t tmp_name = cur->first;\n\t\t  if (peek_head_name(tmp_name) != scope_->basename())\n\t\t\tcontinue;\n\n\t\t  tmp_name.pop_front();\n\t\t  if (tmp_name.size() != 1)\n\t\t\tcontinue;\n\n\t\t  root_repl[peek_head_name(tmp_name)] = cur->second;\n\t    }\n\n\t    if (! rmod_->elaborate_scope(des, scope_, root_repl))\n\t\t  des->errors += 1;\n      }\n\n    private:\n      NetScope*scope_;\n      Module*rmod_;\n};\n\nclass top_defparams : public elaborator_work_item_t {\n    public:\n      explicit top_defparams(Design*des__)\n      : elaborator_work_item_t(des__)\n      { }\n\n      ~top_defparams() { }\n\n      virtual void elaborate_runrun()\n      {\n\t    if (debug_scopes) {\n\t\t  cerr << \"debug: top_defparams::elaborate_runrun()\" << endl;\n\t    }\n\t      // This method recurses through the scopes, looking for\n\t      // defparam assignments to apply to the parameters in the\n\t      // various scopes. This needs to be done after all the scopes\n\t      // and basic parameters are taken care of because the defparam\n\t      // can assign to a parameter declared *after* it.\n\t    des->run_defparams();\n\n\t      // At this point, all parameter overrides are done. Scan the\n\t      // scopes and evaluate the parameters all the way down to\n\t      // constants.\n\t    des->evaluate_parameters();\n\n\t    if (debug_scopes) {\n\t\t  cerr << \"debug: top_defparams::elaborate_runrun() done\" << endl;\n\t    }\n      }\n};\n\nclass later_defparams : public elaborator_work_item_t {\n    public:\n      explicit later_defparams(Design*des__)\n      : elaborator_work_item_t(des__)\n      { }\n\n      ~later_defparams() { }\n\n      virtual void elaborate_runrun()\n      {\n\t    if (debug_scopes) {\n\t\t  cerr << \"debug: later_defparams::elaborate_runrun()\" << endl;\n\t    }\n\n\t    list<NetScope*>tmp_list;\n\t    for (set<NetScope*>::iterator cur = des->defparams_later.begin()\n\t\t       ; cur != des->defparams_later.end() ; ++ cur )\n\t\t  tmp_list.push_back(*cur);\n\n\t    des->defparams_later.clear();\n\n\t    while (! tmp_list.empty()) {\n\t\t  NetScope*cur = tmp_list.front();\n\t\t  tmp_list.pop_front();\n\t\t  cur->run_defparams_later(des);\n\t    }\n\n\t      // The overridden parameters will be evaluated later in\n\t      // a top_defparams work item.\n\n\t    if (debug_scopes) {\n\t\t  cerr << \"debuf: later_defparams::elaborate_runrun() done\" << endl;\n\t    }\n      }\n};\n\nstatic ostream& operator<< (ostream&o, ivl_process_type_t t)\n{\n      switch (t) {\n\tcase IVL_PR_ALWAYS:\n\t    o << \"always\";\n\t    break;\n\tcase IVL_PR_ALWAYS_COMB:\n\t    o << \"always_comb\";\n\t    break;\n\tcase IVL_PR_ALWAYS_FF:\n\t    o << \"always_ff\";\n\t    break;\n\tcase IVL_PR_ALWAYS_LATCH:\n\t    o << \"always_latch\";\n\t    break;\n\tcase IVL_PR_INITIAL:\n\t    o << \"initial\";\n\t    break;\n\tcase IVL_PR_FINAL:\n\t    o << \"final\";\n\t    break;\n      }\n      return o;\n}\n\nbool Design::check_proc_delay() const\n{\n      bool result = false;\n\n      for (const NetProcTop*pr = procs_ ;  pr ;  pr = pr->next_) {\n\t      /* If this is an always process and we have no or zero delay then\n\t       * a runtime infinite loop will happen. If we possibly have some\n\t       * delay then print a warning that an infinite loop is possible.\n\t       */\n\t    if (pr->type() == IVL_PR_ALWAYS) {\n\t\t  DelayType dly_type = pr->statement()->delay_type();\n\n\t\t  if (dly_type == NO_DELAY || dly_type == ZERO_DELAY) {\n\t\t\tcerr << pr->get_fileline() << \": error: always \"\n\t\t\t        \"process does not have any delay.\" << endl;\n\t\t\tcerr << pr->get_fileline() << \":      : A runtime \"\n\t\t\t        \"infinite loop will occur.\" << endl;\n\t\t\tresult = true;\n\n\t\t  } else if (dly_type == POSSIBLE_DELAY && warn_inf_loop) {\n\t\t\tcerr << pr->get_fileline() << \": warning: always \"\n\t\t\t        \"process may not have any delay.\" << endl;\n\t\t\tcerr << pr->get_fileline() << \":        : A runtime \"\n\t\t\t     << \"infinite loop may be possible.\" << endl;\n\t\t  }\n\t    }\n\n\t      // The always_comb/ff/latch processes have special delay rules\n\t      // that need to be checked.\n\t    if ((pr->type() == IVL_PR_ALWAYS_COMB) ||\n\t        (pr->type() == IVL_PR_ALWAYS_FF) ||\n\t        (pr->type() == IVL_PR_ALWAYS_LATCH)) {\n\t\t  const NetEvWait *wait = dynamic_cast<const NetEvWait*> (pr->statement());\n\t\t  if (! wait) {\n\t\t\t  // The always_comb/latch processes have an event\n\t\t\t  // control added automatically by the compiler.\n\t\t\tivl_assert(*pr, pr->type() == IVL_PR_ALWAYS_FF);\n\t\t\tcerr << pr->get_fileline() << \": error: the first \"\n\t\t\t        \"statement of an always_ff process must be \"\n\t\t\t        \"an event control statement.\" << endl;\n\t\t\tresult = true;\n\t\t  } else if (wait->statement()->delay_type(true) != NO_DELAY) {\n\t\t\tcerr << pr->get_fileline() << \": error: there must \";\n\n\t\t\tif (pr->type() == IVL_PR_ALWAYS_FF) {\n\t\t\t      cerr << \"only be a single event control and \"\n\t\t\t              \"no blocking delays in an always_ff \"\n\t\t\t              \"process.\";\n\t\t\t} else {\n\t\t\t      cerr << \"be no event controls or blocking \"\n\t\t\t              \"delays in an \" << pr->type()\n\t\t\t           << \" process.\";\n\t\t\t}\n\t\t\tcerr << endl;\n\t\t\tresult = true;\n\t\t  }\n\n\t\t  if ((pr->type() != IVL_PR_ALWAYS_FF) &&\n\t\t      (wait->nevents() == 0)) {\n\t\t\tif (pr->type() == IVL_PR_ALWAYS_LATCH) {\n\t\t\t      cerr << pr->get_fileline() << \": error: \"\n\t\t\t              \"always_latch process has no event \"\n\t\t\t              \"control.\" << endl;\n\t\t\t      result = true;\n\t\t\t} else {\n\t\t\t      ivl_assert(*pr, pr->type() == IVL_PR_ALWAYS_COMB);\n\t\t\t      cerr << pr->get_fileline() << \": warning: \"\n\t\t\t              \"always_comb process has no \"\n\t\t\t              \"sensitivities.\" << endl;\n\t\t\t}\n\t\t  }\n\t    }\n\n\t        /* If this is a final block it must not have a delay,\n\t\t   but this should have been caught by the statement\n\t\t   elaboration, so maybe this should be an internal\n\t\t   error? */\n\t    if (pr->type() == IVL_PR_FINAL) {\n\t\t  DelayType dly_type = pr->statement()->delay_type();\n\n\t\t  if (dly_type != NO_DELAY) {\n\t\t\tcerr << pr->get_fileline() << \": error: final\"\n\t\t\t     << \" statement contains a delay.\" << endl;\n\t\t\tresult = true;\n\t\t  }\n\t    }\n      }\n\n      return result;\n}\n\nstatic void print_nexus_name(const Nexus*nex)\n{\n      for (const Link*cur = nex->first_nlink(); cur; cur = cur->next_nlink()) {\n\t    if (cur->get_dir() != Link::OUTPUT) continue;\n\t    const NetPins*obj = cur->get_obj();\n\t      // For a NetNet (signal) just use the name.\n\t    if (const NetNet*net = dynamic_cast<const NetNet*>(obj)) {\n\t\t  cerr << net->name();\n\t\t  return;\n\t      // For a NetPartSelect calculate the name.\n\t    } else if (const NetPartSelect*ps = dynamic_cast<const NetPartSelect*>(obj)) {\n\t\t  ivl_assert(*ps, ps->pin_count() >= 2);\n\t\t  ivl_assert(*ps, ps->pin(1).get_dir() == Link::INPUT);\n\t\t  ivl_assert(*ps, ps->pin(1).is_linked());\n\t\t  print_nexus_name(ps->pin(1).nexus());\n\t\t  cerr << \"[]\";\n\t\t  return;\n\t      // For a NetUReduce calculate the name.\n\t    } else if (const NetUReduce*reduce = dynamic_cast<const NetUReduce*>(obj)) {\n\t\t  ivl_assert(*reduce, reduce->pin_count() == 2);\n\t\t  ivl_assert(*reduce, reduce->pin(1).get_dir() == Link::INPUT);\n\t\t  ivl_assert(*reduce, reduce->pin(1).is_linked());\n\t\t  switch (reduce->type()) {\n\t\t    case NetUReduce::AND:\n\t\t\tcerr << \"&\";\n\t\t\tbreak;\n\t\t    case NetUReduce::OR:\n\t\t\tcerr << \"|\";\n\t\t\tbreak;\n\t\t    case NetUReduce::XOR:\n\t\t\tcerr << \"^\";\n\t\t\tbreak;\n\t\t    case NetUReduce::NAND:\n\t\t\tcerr << \"~&\";\n\t\t\tbreak;\n\t\t    case NetUReduce::NOR:\n\t\t\tcerr << \"~|\";\n\t\t\tbreak;\n\t\t    case NetUReduce::XNOR:\n\t\t\tcerr << \"~^\";\n\t\t\tbreak;\n\t\t    case NetUReduce::NONE:\n\t\t\tivl_assert(*reduce, 0);\n\t\t  }\n\t\t  print_nexus_name(reduce->pin(1).nexus());\n\t\t  return;\n\t    } else if (const NetLogic*logic = dynamic_cast<const NetLogic*>(obj)) {\n\t\t  ivl_assert(*logic, logic->pin_count() >= 2);\n\t\t  ivl_assert(*logic, logic->pin(1).get_dir() == Link::INPUT);\n\t\t  ivl_assert(*logic, logic->pin(1).is_linked());\n\t\t  switch (logic->type()) {\n\t\t    case NetLogic::NOT:\n\t\t\tcerr << \"~\";\n\t\t\tbreak;\n\t\t    default:\n\t\t\t  // The other operators should never be used here,\n\t\t\t  // so just return the nexus name.\n\t\t\tcerr << nex->name();\n\t\t\treturn;\n\t\t  }\n\t\t  print_nexus_name(logic->pin(1).nexus());\n\t\t  return;\n\t    }\n\t// Use the following to find the type of anything that may be missing:\n\t//    cerr << \"(\" << typeid(*obj).name() << \") \";\n      }\n\t// Otherwise just use the nexus name so somthing is printed.\n      cerr << nex->name();\n}\n\nstatic void print_event_probe_name(const NetEvProbe *prb)\n{\n      ivl_assert(*prb, prb->pin_count() == 1);\n      ivl_assert(*prb, prb->pin(0).get_dir() == Link::INPUT);\n      ivl_assert(*prb, prb->pin(0).is_linked());\n      print_nexus_name(prb->pin(0).nexus());\n}\n\nstatic void check_event_probe_width(const LineInfo *info, const NetEvProbe *prb)\n{\n      ivl_assert(*prb, prb->pin_count() == 1);\n      ivl_assert(*prb, prb->pin(0).get_dir() == Link::INPUT);\n      ivl_assert(*prb, prb->pin(0).is_linked());\n      if (prb->edge() == NetEvProbe::ANYEDGE) return;\n      if (prb->pin(0).nexus()->vector_width() > 1) {\n\t    cerr << info->get_fileline() << \" warning: Synthesis wants \"\n                    \"the sensitivity list expressions for '\";\n\t    switch (prb->edge()) {\n\t      case NetEvProbe::POSEDGE:\n\t\t  cerr << \"posedge \";\n\t\t  break;\n\t      case NetEvProbe::NEGEDGE:\n\t\t  cerr << \"negedge \";\n\t\t  break;\n\t      default:\n\t\t  break;\n\t    }\n\t    print_nexus_name(prb->pin(0).nexus());\n\t    cerr << \"' to be a single bit.\" << endl;\n      }\n}\n\nstatic void check_ff_sensitivity(const NetProc* statement)\n{\n      const NetEvWait *evwt = dynamic_cast<const NetEvWait*> (statement);\n\t// We have already checked for and reported if the first statmemnt is\n\t// not a wait.\n      if (! evwt) return;\n\n      for (unsigned cevt = 0; cevt < evwt->nevents(); cevt += 1) {\n\t    const NetEvent *evt = evwt->event(cevt);\n\t    for (unsigned cprb = 0; cprb < evt->nprobe(); cprb += 1) {\n\t\t  const NetEvProbe *prb = evt->probe(cprb);\n\t\t  check_event_probe_width(evwt, prb);\n\t\t  if (prb->edge() == NetEvProbe::ANYEDGE) {\n\t\t\tcerr << evwt->get_fileline() << \" warning: Synthesis \"\n\t\t\t        \"requires the sensitivity list of an \"\n\t\t\t        \"always_ff process to only be edge \"\n\t\t\t        \"sensitive. \";\n\t\t\tprint_event_probe_name(prb);\n\t\t\tcerr  << \" is missing a pos/negedge.\" << endl;\n\t\t  }\n\t    }\n      }\n}\n\n/*\n * Check to see if the always_* processes only contain synthesizable\n * constructs.\n */\nbool Design::check_proc_synth() const\n{\n      bool result = false;\n      for (const NetProcTop*pr = procs_ ;  pr ;  pr = pr->next_) {\n\t    if ((pr->type() == IVL_PR_ALWAYS_COMB) ||\n\t        (pr->type() == IVL_PR_ALWAYS_FF) ||\n\t        (pr->type() == IVL_PR_ALWAYS_LATCH)) {\n\t\t  result |= pr->statement()->check_synth(pr->type(),\n\t\t                                         pr->scope());\n\t\t  if (pr->type() == IVL_PR_ALWAYS_FF) {\n\t\t\tcheck_ff_sensitivity(pr->statement());\n\t\t  }\n\t    }\n      }\n      return result;\n}\n\n/*\n * Check whether all design elements have an explicit timescale or all\n * design elements use the default timescale. If a mixture of explicit\n * and default timescales is found, a warning message is output. Note\n * that we only need to check the top level design elements - nested\n * design elements will always inherit the timescale from their parent\n * if they don't have any local timescale declarations.\n *\n * NOTE: Strictly speaking, this should be an error for SystemVerilog\n * (1800-2012 section 3.14.2).\n */\nstatic void check_timescales(bool&some_explicit, bool&some_implicit,\n\t\t\t     const PScope*scope)\n{\n      if (scope->time_unit_is_default)\n\t    some_implicit = true;\n      else\n\t    some_explicit = true;\n      if (scope->time_prec_is_default)\n\t    some_implicit = true;\n      else\n\t    some_explicit = true;\n}\n\nstatic void check_timescales()\n{\n      bool some_explicit = false;\n      bool some_implicit = false;\n      map<perm_string,Module*>::iterator mod;\n      for (mod = pform_modules.begin(); mod != pform_modules.end(); ++mod) {\n\t    const Module*mp = (*mod).second;\n\t    check_timescales(some_explicit, some_implicit, mp);\n\t    if (some_explicit && some_implicit)\n\t\t  break;\n      }\n      vector<PPackage*>::iterator pkg;\n      if (gn_system_verilog() && !(some_explicit && some_implicit)) {\n\t    for (pkg = pform_packages.begin(); pkg != pform_packages.end(); ++pkg) {\n\t\t  const PPackage*pp = *pkg;\n\t\t  check_timescales(some_explicit, some_implicit, pp);\n\t\t  if (some_explicit && some_implicit)\n\t\t\tbreak;\n\t    }\n      }\n      if (gn_system_verilog() && !(some_explicit && some_implicit)) {\n\t    for (pkg = pform_units.begin(); pkg != pform_units.end(); ++pkg) {\n\t\t  const PPackage*pp = *pkg;\n\t\t    // We don't need a timescale if the compilation unit\n\t\t    // contains no items outside a design element.\n\t\t  if (pp->parameters.empty() &&\n\t\t      pp->wires.empty() &&\n\t\t      pp->tasks.empty() &&\n\t\t      pp->funcs.empty() &&\n\t\t      pp->classes.empty())\n\t\t\tcontinue;\n\n\t\t  check_timescales(some_explicit, some_implicit, pp);\n\t\t  if (some_explicit && some_implicit)\n\t\t\tbreak;\n\t    }\n      }\n\n      if (!(some_explicit && some_implicit))\n\t    return;\n\n      if (gn_system_verilog()) {\n\t    cerr << \"warning: \"\n\t\t << \"Some design elements have no explicit time unit and/or\"\n\t\t << endl;\n\t    cerr << \"       : \"\n\t\t << \"time precision. This may cause confusing timing results.\"\n\t\t << endl;\n\t    cerr << \"       : \"\n\t\t << \"Affected design elements are:\"\n\t\t << endl;\n      } else {\n\t    cerr << \"warning: \"\n\t\t << \"Some modules have no timescale. This may cause\"\n\t\t << endl;\n\t    cerr << \"       : \"\n\t\t << \"confusing timing results.\tAffected modules are:\"\n\t\t << endl;\n      }\n\n      for (mod = pform_modules.begin(); mod != pform_modules.end(); ++mod) {\n\t    Module*mp = (*mod).second;\n\t    if (mp->has_explicit_timescale())\n\t\t  continue;\n\t    cerr << \"       :   -- module \" << (*mod).first\n\t\t << \" declared here: \" << mp->get_fileline() << endl;\n      }\n\n      if (!gn_system_verilog())\n\t    return;\n\n      for (pkg = pform_packages.begin(); pkg != pform_packages.end(); ++pkg) {\n\t    PPackage*pp = *pkg;\n\t    if (pp->has_explicit_timescale())\n\t\t  continue;\n\t    cerr << \"       :   -- package \" << pp->pscope_name()\n\t\t << \" declared here: \" << pp->get_fileline() << endl;\n      }\n\n      for (pkg = pform_units.begin(); pkg != pform_units.end(); ++pkg) {\n\t    PPackage*pp = *pkg;\n\t    if (pp->has_explicit_timescale())\n\t\t  continue;\n\n\t    if (pp->parameters.empty() &&\n\t\tpp->wires.empty() &&\n\t\tpp->tasks.empty() &&\n\t\tpp->funcs.empty() &&\n\t\tpp->classes.empty())\n\t\t  continue;\n\n\t    cerr << \"       :   -- compilation unit\";\n\t    if (pform_units.size() > 1) {\n\t\t  cerr << \" from: \" << pp->get_file();\n\t    }\n\t    cerr << endl;\n      }\n}\n\n/*\n * This function is the root of all elaboration. The input is the list\n * of root module names. The function locates the Module definitions\n * for each root, does the whole elaboration sequence, and fills in\n * the resulting Design.\n */\n\nstruct pack_elem {\n      PPackage*pack;\n      NetScope*scope;\n};\n\nstruct root_elem {\n      Module *mod;\n      NetScope *scope;\n};\n\nDesign* elaborate(list<perm_string>roots)\n{\n      unsigned npackages = pform_packages.size();\n      if (gn_system_verilog())\n\t    npackages += pform_units.size();\n\n      vector<struct root_elem> root_elems(roots.size());\n      vector<struct pack_elem> pack_elems(npackages);\n      map<LexicalScope*,NetScope*> unit_scopes;\n      bool rc = true;\n      unsigned i = 0;\n\n\t// This is the output design. I fill it in as I scan the root\n\t// module and elaborate what I find.\n      Design*des = new Design;\n\n\t// Elaborate the compilation unit scopes. From here on, these are\n\t// treated as an additional set of packages.\n      if (gn_system_verilog()) {\n\t    for (vector<PPackage*>::iterator pkg = pform_units.begin()\n\t\t       ; pkg != pform_units.end() ; ++pkg) {\n\t\t  PPackage*unit = *pkg;\n\t\t  NetScope*scope = des->make_package_scope(unit->pscope_name(), 0, true);\n\t\t  scope->set_line(unit);\n\t\t  scope->add_imports(&unit->explicit_imports);\n\t\t  set_scope_timescale(des, scope, unit);\n\n\t\t  elaborator_work_item_t*es = new elaborate_package_t(des, scope, unit);\n\t\t  des->elaboration_work_list.push_back(es);\n\n\t\t  pack_elems[i].pack = unit;\n\t\t  pack_elems[i].scope = scope;\n\t\t  i += 1;\n\n\t\t  unit_scopes[unit] = scope;\n\t    }\n      }\n\n\t// Elaborate the packages. Package elaboration is simpler\n\t// because there are fewer sub-scopes involved. Note that\n\t// in SystemVerilog, packages are not allowed to refer to\n\t// the compilation unit scope, but the VHDL preprocessor\n\t// assumes they can.\n      for (vector<PPackage*>::iterator pkg = pform_packages.begin()\n\t\t ; pkg != pform_packages.end() ; ++pkg) {\n\t    PPackage*pack = *pkg;\n\t    NetScope*unit_scope = unit_scopes[pack->parent_scope()];\n\t    NetScope*scope = des->make_package_scope(pack->pscope_name(), unit_scope, false);\n\t    scope->set_line(pack);\n\t    scope->add_imports(&pack->explicit_imports);\n\t    set_scope_timescale(des, scope, pack);\n\n\t    elaborator_work_item_t*es = new elaborate_package_t(des, scope, pack);\n\t    des->elaboration_work_list.push_back(es);\n\n\t    pack_elems[i].pack = pack;\n\t    pack_elems[i].scope = scope;\n\t    i += 1;\n      }\n\n\t// Scan the root modules by name, and elaborate their scopes.\n      i = 0;\n      for (list<perm_string>::const_iterator root = roots.begin()\n\t\t ; root != roots.end() ; ++ root ) {\n\n\t      // Look for the root module in the list.\n\t    map<perm_string,Module*>::const_iterator mod = pform_modules.find(*root);\n\t    if (mod == pform_modules.end()) {\n\t\t  cerr << \"error: Unable to find the root module \\\"\"\n\t\t       << (*root) << \"\\\" in the Verilog source.\" << endl;\n\t\t  cerr << \"     : Perhaps ``-s \" << (*root)\n\t\t       << \"'' is incorrect?\" << endl;\n\t\t  des->errors++;\n\t\t  continue;\n\t    }\n\n\t      // Get the module definition for this root instance.\n\t    Module *rmod = (*mod).second;\n\n\t      // Get the compilation unit scope for this module.\n\t    NetScope*unit_scope = unit_scopes[rmod->parent_scope()];\n\n\t      // Make the root scope. This makes a NetScope object and\n\t      // pushes it into the list of root scopes in the Design.\n\t    NetScope*scope = des->make_root_scope(*root, unit_scope,\n\t\t\t\t\t\t  rmod->program_block,\n\t\t\t\t\t\t  rmod->is_interface);\n\n\t      // Collect some basic properties of this scope from the\n\t      // Module definition.\n\t    scope->set_line(rmod);\n\t    scope->add_imports(&rmod->explicit_imports);\n\t    set_scope_timescale(des, scope, rmod);\n\n\t      // Save this scope, along with its definition, in the\n\t      // \"root_elems\" list for later passes.\n\t    root_elems[i].mod = rmod;\n\t    root_elems[i].scope = scope;\n\t    i += 1;\n\n\t      // Arrange for these scopes to be elaborated as root\n\t      // scopes. Create an \"elaborate_root_scope\" object to\n\t      // contain the work item, and append it to the scope\n\t      // elaborations work list.\n\t    elaborator_work_item_t*es = new elaborate_root_scope_t(des, scope, rmod);\n\t    des->elaboration_work_list.push_back(es);\n      }\n\n\t// Run the work list of scope elaborations until the list is\n\t// empty. This list is initially populated above where the\n\t// initial root scopes are primed.\n      while (! des->elaboration_work_list.empty()) {\n\t      // Push a work item to process the defparams of any scopes\n\t      // that are elaborated during this pass. For the first pass\n\t      // this will be all the root scopes. For subsequent passes\n\t      // it will be any scopes created during the previous pass\n\t      // by a generate construct or instance array.\n\t    des->elaboration_work_list.push_back(new top_defparams(des));\n\n\t      // Transfer the queue to a temporary queue.\n\t    list<elaborator_work_item_t*> cur_queue;\n\t    std::swap(cur_queue, des->elaboration_work_list);\n\n\t      // Run from the temporary queue. If the temporary queue\n\t      // items create new work queue items, they will show up\n\t      // in the elaboration_work_list and then we get to run\n\t      // through them in the next pass.\n\t    while (! cur_queue.empty()) {\n\t\t  elaborator_work_item_t*tmp = cur_queue.front();\n\t\t  cur_queue.pop_front();\n\t\t  tmp->elaborate_runrun();\n\t\t  delete tmp;\n\t    }\n\n\t    if (! des->elaboration_work_list.empty()) {\n\t\t  des->elaboration_work_list.push_back(new later_defparams(des));\n\t    }\n      }\n\n      if (debug_elaborate) {\n\t    cerr << \"<toplevel>: elaborate: \"\n\t\t << \"elaboration work list done. Start processing residual defparams.\" << endl;\n      }\n\n\t// Look for residual defparams (that point to a non-existent\n\t// scope) and clean them out.\n      des->residual_defparams();\n\n\t// Errors already? Probably missing root modules. Just give up\n\t// now and return nothing.\n      if (des->errors > 0)\n\t    return des;\n\n\t// Now we have the full design, check for timescale inconsistencies.\n      if (warn_timescale)\n\t    check_timescales();\n\n      if (debug_elaborate) {\n\t    cerr << \"<toplevel>: elaborate: \"\n\t\t << \"Start calling Package elaborate_sig methods.\" << endl;\n      }\n\n\t// With the parameters evaluated down to constants, we have\n\t// what we need to elaborate signals and memories. This pass\n\t// creates all the NetNet and NetMemory objects for declared\n\t// objects.\n      for (i = 0; i < pack_elems.size(); i += 1) {\n\t    PPackage*pack = pack_elems[i].pack;\n\t    NetScope*scope= pack_elems[i].scope;\n\n\t    if (! pack->elaborate_sig(des, scope)) {\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << \"<toplevel>\" << \": debug: \" << pack->pscope_name()\n\t\t\t     << \": elaborate_sig failed!!!\" << endl;\n\t\t  }\n\t\t  delete des;\n\t\t  return 0;\n\t    }\n      }\n\n      if (debug_elaborate) {\n\t    cerr << \"<toplevel>: elaborate: \"\n\t\t << \"Start calling $root elaborate_sig methods.\" << endl;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << \"<toplevel>: elaborate: \"\n\t\t << \"Start calling root module elaborate_sig methods.\" << endl;\n      }\n\n      for (i = 0; i < root_elems.size(); i++) {\n\t    Module *rmod = root_elems[i].mod;\n\t    NetScope *scope = root_elems[i].scope;\n\t    scope->set_num_ports( rmod->port_count() );\n\n\t    if (debug_elaborate) {\n\t\t  cerr << \"<toplevel>\" << \": debug: \" << rmod->mod_name()\n\t\t       << \": port elaboration root \"\n\t\t       << rmod->port_count() << \" ports\" << endl;\n\t    }\n\n\t    if (! rmod->elaborate_sig(des, scope)) {\n\t\t  if (debug_elaborate) {\n\t\t\tcerr << \"<toplevel>\" << \": debug: \" << rmod->mod_name()\n\t\t\t     << \": elaborate_sig failed!!!\" << endl;\n\t\t  }\n\t\t  delete des;\n\t\t  return 0;\n\t    }\n\n\t      // Some of the generators need to have the ports correctly\n\t      // defined for the root modules. This code does that.\n\t    for (unsigned idx = 0; idx < rmod->port_count(); idx += 1) {\n\t\t  vector<PEIdent*> mport = rmod->get_port(idx);\n                  unsigned int prt_vector_width = 0;\n                  PortType::Enum ptype = PortType::PIMPLICIT;\n\t\t  for (unsigned pin = 0; pin < mport.size(); pin += 1) {\n\t\t\t  // This really does more than we need and adds extra\n\t\t\t  // stuff to the design that should be cleaned later.\n\t\t\tNetNet *netnet = mport[pin]->elaborate_subport(des, scope);\n\t\t\tif (netnet != 0) {\n\t\t\t  // Elaboration may actually fail with\n\t\t\t  // erroneous input source\n                          prt_vector_width += netnet->vector_width() * netnet->pin_count();\n                          ptype = PortType::merged(netnet->port_type(), ptype);\n\t\t\t}\n\t\t  }\n                  if (debug_elaborate) {\n                           cerr << \"<toplevel>\" << \": debug: \" << rmod->mod_name()\n                                << \": adding module port \"\n                                << rmod->get_port_name(idx) << endl;\n                     }\n\t\t  scope->add_module_port_info(idx, rmod->get_port_name(idx), ptype, prt_vector_width );\n\t    }\n      }\n\n\t// Now that the structure and parameters are taken care of,\n\t// run through the pform again and generate the full netlist.\n\n      for (i = 0; i < pack_elems.size(); i += 1) {\n\t    PPackage*pkg = pack_elems[i].pack;\n\t    NetScope*scope = pack_elems[i].scope;\n\t    rc &= pkg->elaborate(des, scope);\n      }\n\n      for (i = 0; i < root_elems.size(); i++) {\n\t    Module *rmod = root_elems[i].mod;\n\t    NetScope *scope = root_elems[i].scope;\n\t    rc &= rmod->elaborate(des, scope);\n      }\n\n      if (rc == false) {\n\t    delete des;\n\t    return 0;\n      }\n\n\t// Now that everything is fully elaborated verify that we do\n\t// not have an always block with no delay (an infinite loop),\n        // or a final block with a delay.\n      bool has_failure = des->check_proc_delay();\n\n\t// Check to see if the always_comb/ff/latch processes only have\n\t// synthesizable constructs\n      has_failure |= des->check_proc_synth();\n\n      if (debug_elaborate) {\n               cerr << \"<toplevel>\" << \": debug: \"\n                    << \" finishing with \"\n                    <<  des->find_root_scopes().size() << \" root scopes \" << endl;\n         }\n\n      if (has_failure) {\n\t    delete des;\n\t    des = 0;\n      }\n\n      return des;\n}\n"
        },
        {
          "name": "elaborate_analog.cc",
          "type": "blob",
          "size": 2.291015625,
          "content": "/*\n * Copyright (c) 2008-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"AStatement.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"util.h\"\n\n# include  <typeinfo>\n\nusing namespace std;\n\nNetProc* AContrib::elaborate(Design*des, NetScope*scope) const\n{\n      NetExpr*lval = elab_and_eval(des, scope, lval_, -1);\n      NetExpr*rval = elab_and_eval(des, scope, rval_, -1);\n\n      NetEAccess*lacc = dynamic_cast<NetEAccess*> (lval);\n      if (lacc == 0) {\n\t    cerr << get_fileline() << \": error: The l-value of a contribution\"\n\t\t << \" statement must be a branch probe access function.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetContribution*st = new NetContribution(lacc, rval);\n      st->set_line(*this);\n      return st;\n}\n\nbool AProcess::elaborate(Design*des, NetScope*scope) const\n{\n      NetProc*estatement = statement_->elaborate(des, scope);\n      if (estatement == 0)\n\t    return false;\n\n      NetAnalogTop*top = new NetAnalogTop(scope, type_, estatement);\n\n\t// Evaluate the attributes for this process, if there\n\t// are any. These attributes are to be attached to the\n\t// NetProcTop object.\n      struct attrib_list_t*attrib_list;\n      unsigned attrib_list_n = 0;\n      attrib_list = evaluate_attributes(attributes, attrib_list_n, des, scope);\n\n      for (unsigned adx = 0 ;  adx < attrib_list_n ;  adx += 1)\n\t    top->attribute(attrib_list[adx].key,\n\t\t\t   attrib_list[adx].val);\n\n      delete[]attrib_list;\n\n      top->set_line(*this);\n      des->add_process(top);\n\n      return true;\n}\n"
        },
        {
          "name": "emit.cc",
          "type": "blob",
          "size": 15.662109375,
          "content": "/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n/*\n * The emit function is called to generate the output required of the\n * target.\n */\n# include  \"target.h\"\n# include  \"netclass.h\"\n# include  \"netlist.h\"\n# include  \"compiler.h\"\n# include  <typeinfo>\n# include  <cassert>\n# include  <cstring>\n\nusing namespace std;\n\nbool NetNode::emit_node(struct target_t*) const\n{\n      cerr << \"EMIT: Gate type? \" << typeid(*this).name() << endl;\n      return false;\n}\n\nbool NetLogic::emit_node(struct target_t*tgt) const\n{\n      tgt->logic(this);\n      return true;\n}\n\nbool NetUDP::emit_node(struct target_t*tgt) const\n{\n      tgt->udp(this);\n      return true;\n}\n\nbool NetAbs::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_abs(this);\n      return true;\n}\n\nbool NetAddSub::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_add_sub(this);\n      return true;\n}\n\nbool NetArrayDq::emit_node(struct target_t*tgt) const\n{\n      return tgt->lpm_array_dq(this);\n}\n\nbool NetCaseCmp::emit_node(struct target_t*tgt) const\n{\n      tgt->net_case_cmp(this);\n      return true;\n}\n\nbool NetCastInt2::emit_node(struct target_t*tgt) const\n{\n      return tgt->lpm_cast_int2(this);\n}\n\nbool NetCastInt4::emit_node(struct target_t*tgt) const\n{\n      return tgt->lpm_cast_int4(this);\n}\n\nbool NetCastReal::emit_node(struct target_t*tgt) const\n{\n      return tgt->lpm_cast_real(this);\n}\n\nbool NetCLShift::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_clshift(this);\n      return true;\n}\n\nbool NetCompare::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_compare(this);\n      return true;\n}\n\nbool NetConcat::emit_node(struct target_t*tgt) const\n{\n      return tgt->concat(this);\n}\n\nbool NetConst::emit_node(struct target_t*tgt) const\n{\n      return tgt->net_const(this);\n}\n\nbool NetDivide::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_divide(this);\n      return true;\n}\n\nbool NetFF::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_ff(this);\n      return true;\n}\n\nbool NetLatch::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_latch(this);\n      return true;\n}\n\nbool NetLiteral::emit_node(struct target_t*tgt) const\n{\n      return tgt->net_literal(this);\n}\n\nbool NetModulo::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_modulo(this);\n      return true;\n}\n\nbool NetMult::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_mult(this);\n      return true;\n}\n\nbool NetMux::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_mux(this);\n      return true;\n}\n\nbool NetPartSelect::emit_node(struct target_t*tgt) const\n{\n      return tgt->part_select(this);\n}\n\nbool NetPow::emit_node(struct target_t*tgt) const\n{\n      tgt->lpm_pow(this);\n      return true;\n}\n\nbool NetReplicate::emit_node(struct target_t*tgt) const\n{\n      return tgt->replicate(this);\n}\n\nbool NetSignExtend::emit_node(struct target_t*tgt) const\n{\n      return tgt->sign_extend(this);\n}\n\nbool NetSubstitute::emit_node(struct target_t*tgt) const\n{\n      return tgt->substitute(this);\n}\n\nbool NetUReduce::emit_node(struct target_t*tgt) const\n{\n      return tgt->ureduce(this);\n}\n\nbool NetSysFunc::emit_node(struct target_t*tgt) const\n{\n      return tgt->net_sysfunction(this);\n}\n\nbool NetUserFunc::emit_node(struct target_t*tgt) const\n{\n      return tgt->net_function(this);\n}\n\nbool NetTran::emit_node(struct target_t*tgt) const\n{\n      return tgt->tran(this);\n}\n\nbool NetBUFZ::emit_node(struct target_t*tgt) const\n{\n      return tgt->bufz(this);\n}\n\nbool NetProcTop::emit(struct target_t*tgt) const\n{\n      return tgt->process(this);\n}\n\nbool NetAnalogTop::emit(struct target_t*tgt) const\n{\n      return tgt->process(this);\n}\n\nbool NetProc::emit_proc(struct target_t*) const\n{\n      cerr << \"EMIT: Proc type? \" << typeid(*this).name() << endl;\n      return false;\n}\n\nbool NetAlloc::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_alloc(this);\n      return true;\n}\n\nbool NetAssign::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_assign(this);\n}\n\nbool NetAssignNB::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_assign_nb(this);\n      return true;\n}\n\nbool NetBlock::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_block(this);\n}\n\nbool NetBreak::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_break(this);\n}\n\nbool NetCase::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_case(this);\n      return true;\n}\n\nbool NetCAssign::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_cassign(this);\n}\n\nbool NetCondit::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_condit(this);\n}\n\nbool NetContinue::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_continue(this);\n}\n\nbool NetContribution::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_contribution(this);\n}\n\nbool NetDeassign::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_deassign(this);\n}\n\nbool NetDisable::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_disable(this);\n}\n\nbool NetDoWhile::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_do_while(this);\n      return true;\n}\n\nvoid NetDoWhile::emit_proc_recurse(struct target_t*tgt) const\n{\n      proc_->emit_proc(tgt);\n}\n\nbool NetForce::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_force(this);\n}\n\nbool NetForever::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_forever(this);\n      return true;\n}\n\nbool NetForLoop::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_forloop(this);\n}\n\nbool NetForLoop::emit_recurse_init(struct target_t*tgt) const\n{\n      if (init_statement_) return init_statement_->emit_proc(tgt);\n      return true;\n}\n\nbool NetForLoop::emit_recurse_stmt(struct target_t*tgt) const\n{\n      if (statement_) return statement_->emit_proc(tgt);\n      return true;\n}\n\nbool NetForLoop::emit_recurse_step(struct target_t*tgt) const\n{\n      if (step_statement_) return step_statement_->emit_proc(tgt);\n      return true;\n}\n\nbool NetForLoop::emit_recurse_condition(struct expr_scan_t*tgt) const\n{\n      if (condition_) condition_->expr_scan(tgt);\n      return true;\n}\n\nbool NetFree::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_free(this);\n      return true;\n}\n\nbool NetPDelay::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_delay(this);\n}\n\nbool NetPDelay::emit_proc_recurse(struct target_t*tgt) const\n{\n      if (statement_) return statement_->emit_proc(tgt);\n      return true;\n}\n\nbool NetRelease::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_release(this);\n}\n\nbool NetRepeat::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_repeat(this);\n      return true;\n}\n\nbool NetSTask::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_stask(this);\n      return true;\n}\n\nbool NetUTask::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_utask(this);\n      return true;\n}\n\nbool NetWhile::emit_proc(struct target_t*tgt) const\n{\n      tgt->proc_while(this);\n      return true;\n}\n\nvoid NetWhile::emit_proc_recurse(struct target_t*tgt) const\n{\n      proc_->emit_proc(tgt);\n}\n\nvoid NetBlock::emit_recurse(struct target_t*tgt) const\n{\n      if (last_ == 0)\n\t    return;\n\n      NetProc*cur = last_;\n      do {\n\t    cur = cur->next_;\n\t    cur->emit_proc(tgt);\n      } while (cur != last_);\n}\n\nbool NetCondit::emit_recurse_if(struct target_t*tgt) const\n{\n      if (if_)\n\t    return if_->emit_proc(tgt);\n      else\n\t    return true;\n}\n\nbool NetCondit::emit_recurse_else(struct target_t*tgt) const\n{\n      if (else_)\n\t    return else_->emit_proc(tgt);\n      else\n\t    return true;\n}\n\nbool NetEvProbe::emit_node(struct target_t*tgt) const\n{\n      tgt->net_probe(this);\n      return true;\n}\n\nbool NetEvTrig::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_trigger(this);\n}\n\nbool NetEvNBTrig::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_nb_trigger(this);\n}\n\nbool NetEvWait::emit_proc(struct target_t*tgt) const\n{\n      return tgt->proc_wait(this);\n}\n\nbool NetEvWait::emit_recurse(struct target_t*tgt) const\n{\n      if (!statement_) return true;\n      return statement_->emit_proc(tgt);\n}\n\nvoid NetForever::emit_recurse(struct target_t*tgt) const\n{\n      if (statement_)\n\t    statement_->emit_proc(tgt);\n}\n\nvoid NetRepeat::emit_recurse(struct target_t*tgt) const\n{\n      if (statement_)\n\t    statement_->emit_proc(tgt);\n}\n\nvoid netclass_t::emit_scope(struct target_t*tgt) const\n{\n      class_scope_->emit_scope(tgt);\n}\n\nvoid NetScope::emit_scope(struct target_t*tgt) const\n{\n      if (debug_emit) {\n\t    cerr << \"NetScope::emit_scope: \"\n\t\t << \"Emit scope \" << scope_path(this) << endl;\n      }\n\n      tgt->scope(this);\n\n      for (NetEvent*cur = events_ ;  cur ;  cur = cur->snext_)\n\t    tgt->event(cur);\n\n      for (map<perm_string,netclass_t*>::const_iterator cur = classes_.begin()\n\t\t ; cur != classes_.end() ; ++cur) {\n\t    cur->second->emit_scope(tgt);\n\t    tgt->class_type(this, cur->second);\n      }\n\n      for (map<const enum_type_t*,netenum_t*>::const_iterator cur = enum_sets_.begin()\n\t\t ; cur != enum_sets_.end() ;  ++cur)\n\t    tgt->enumeration(this, cur->second);\n\n      for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t ; cur != children_.end() ; ++ cur )\n\t    cur->second->emit_scope(tgt);\n\n      for (signals_map_iter_t cur = signals_map_.begin()\n\t\t ; cur != signals_map_.end() ; ++ cur ) {\n\t    tgt->signal(cur->second);\n      }\n\n\t// Run the signals again, but this time to connect the\n\t// delay paths. This is done as a second pass because\n\t// the paths reference other signals that may be later\n\t// in the list. We can do it here because delay paths are\n\t// always connected within the scope.\n      for (signals_map_iter_t cur = signals_map_.begin()\n\t\t ; cur != signals_map_.end() ; ++ cur) {\n\n\t    tgt->signal_paths(cur->second);\n      }\n\n      if (type_ == MODULE) tgt->convert_module_ports(this);\n}\n\nbool NetScope::emit_defs(struct target_t*tgt) const\n{\n      bool flag = true;\n\n      if (debug_emit) {\n\t    cerr << \"NetScope::emit_defs: \"\n\t\t << \"Emit definitions for \" << scope_path(this) << endl;\n      }\n\n      switch (type_) {\n\t  case PACKAGE:\n\t  case MODULE:\n\t    for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t       ; cur != children_.end() ; ++ cur )\n\t\t  flag &= cur->second->emit_defs(tgt);\n\t    for (map<perm_string,netclass_t*>::const_iterator cur = classes_.begin()\n\t\t       ; cur != classes_.end() ; ++ cur)\n\t\t  flag &= cur->second->emit_defs(tgt);\n\t    break;\n\n\t  case FUNC:\n\t    flag &= tgt->func_def(this);\n\t    break;\n\t  case TASK:\n\t    tgt->task_def(this);\n\t    break;\n\t  default:  /* BEGIN_END and FORK_JOIN, GENERATE... */\n\t    for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t       ; cur != children_.end() ; ++ cur )\n\t\t  flag &= cur->second->emit_defs(tgt);\n\t    break;\n      }\n\n      return flag;\n}\n\nbool netclass_t::emit_defs(struct target_t*tgt) const\n{\n      return class_scope_->emit_defs(tgt);\n}\n\nint Design::emit(struct target_t*tgt) const\n{\n      int rc = 0;\n\n      if (tgt->start_design(this) == false)\n\t    return -2;\n\n\t// enumerate package scopes\n      for (map<perm_string,NetScope*>::const_iterator scope = packages_.begin()\n\t\t ; scope != packages_.end() ; ++ scope) {\n\t    scope->second->emit_scope(tgt);\n      }\n\n\t// enumerate root scopes\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin()\n\t\t ; scope != root_scopes_.end(); ++ scope ) {\n\t    (*scope)->emit_scope(tgt);\n      }\n\n\t// emit nodes\n      bool nodes_rc = true;\n      if (nodes_) {\n\t    NetNode*cur = nodes_->node_next_;\n\t    do {\n\t\t  nodes_rc = nodes_rc && cur->emit_node(tgt);\n\t\t  cur = cur->node_next_;\n\t    } while (cur != nodes_->node_next_);\n      }\n\n\n      bool branches_rc = true;\n      for (NetBranch*cur = branches_ ; cur ; cur = cur->next_) {\n\t    branches_rc = tgt->branch(cur) && branches_rc;\n      }\n\n\t// emit task and function definitions\n      bool tasks_rc = true;\n      for (map<perm_string,NetScope*>::const_iterator scope = packages_.begin()\n\t\t ; scope != packages_.end() ; ++ scope )\n\t    tasks_rc &= scope->second->emit_defs(tgt);\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin()\n\t\t ; scope != root_scopes_.end(); ++ scope )\n\t    tasks_rc &= (*scope)->emit_defs(tgt);\n\n\n\t// emit the processes\n      bool proc_rc = true;\n      for (const NetProcTop*idx = procs_ ;  idx ;  idx = idx->next_)\n\t    proc_rc &= idx->emit(tgt);\n      for (const NetAnalogTop*idx = aprocs_ ;  idx ;  idx = idx->next_)\n\t    proc_rc &= idx->emit(tgt);\n\n      if (nodes_rc == false)\n\t    tgt->errors += 1;\n      if (tasks_rc == false)\n\t    tgt->errors += 1;\n      if (proc_rc == false)\n\t    tgt->errors += 1;\n      if (branches_rc == false)\n\t    tgt->errors += 1;\n\n      rc = tgt->end_design(this);\n\n      if (nodes_rc == false)\n\t    return -1;\n      if (tasks_rc == false)\n\t    return -2;\n      if (proc_rc == false)\n\t    return -3;\n      if (branches_rc == false)\n\t    return -4;\n\n      return rc;\n}\n\nvoid NetEAccess::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_access_func(this);\n}\n\nvoid NetEArrayPattern::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_array_pattern(this);\n}\n\nvoid NetEBinary::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_binary(this);\n}\n\nvoid NetEConcat::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_concat(this);\n}\n\nvoid NetEConst::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_const(this);\n}\n\nvoid NetEConstEnum::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_const(this);\n}\n\nvoid NetEConstParam::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_param(this);\n}\n\nvoid NetECReal::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_creal(this);\n}\n\nvoid NetECRealParam::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_rparam(this);\n}\n\nvoid NetEEvent::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_event(this);\n}\n\nvoid NetELast::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_last(this);\n}\n\nvoid NetENetenum::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_netenum(this);\n}\n\nvoid NetENew::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_new(this);\n}\n\nvoid NetENull::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_null(this);\n}\n\nvoid NetEProperty::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_property(this);\n}\n\nvoid NetEScope::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_scope(this);\n}\n\nvoid NetESelect::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_select(this);\n}\n\nvoid NetESFunc::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_sfunc(this);\n}\n\nvoid NetEShallowCopy::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_scopy(this);\n}\n\nvoid NetEShallowCopy::expr_scan_oper1(struct expr_scan_t*tgt) const\n{\n      arg1_->expr_scan(tgt);\n}\n\nvoid NetEShallowCopy::expr_scan_oper2(struct expr_scan_t*tgt) const\n{\n      arg2_->expr_scan(tgt);\n}\n\nvoid NetEUFunc::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_ufunc(this);\n}\n\nvoid NetESignal::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_signal(this);\n}\n\nvoid NetETernary::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_ternary(this);\n}\n\nvoid NetEUnary::expr_scan(struct expr_scan_t*tgt) const\n{\n      tgt->expr_unary(this);\n}\n"
        },
        {
          "name": "eval_attrib.cc",
          "type": "blob",
          "size": 2.37890625,
          "content": "/*\n * Copyright (c) 2002-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"util.h\"\n# include  \"PExpr.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  <iostream>\n# include  <cassert>\n\nusing namespace std;\n\n/*\n * The evaluate_attributes function evaluates the attribute\n * expressions from the map, and returns a table in a form suitable\n * for passing to netlist devices.\n */\n\nattrib_list_t* evaluate_attributes(const map<perm_string,PExpr*>&att,\n\t\t\t\t   unsigned&natt,\n\t\t\t\t   Design*des, NetScope*scope)\n{\n      natt = att.size();\n      if (natt == 0)\n\t    return 0;\n\n      attrib_list_t*table = new attrib_list_t [natt];\n\n      unsigned idx = 0;\n\n      typedef map<perm_string,PExpr*>::const_iterator iter_t;\n      for (iter_t cur = att.begin() ;  cur != att.end() ;  ++ cur , idx += 1) {\n\t    table[idx].key = (*cur).first;\n\t    PExpr*exp = (*cur).second;\n\n\t      /* If the attribute value is given in the source, then\n\t\t evaluate it as a constant. If the value is not\n\t\t given, then assume the value is 1. */\n\t    if (exp) {\n\t\t  NetExpr *tmp = elab_and_eval(des, scope, exp, -1, true);\n\t\t  if (!tmp)\n\t\t\tcontinue;\n\n\t\t  if (NetEConst *ce = dynamic_cast<NetEConst*>(tmp)) {\n\t\t\ttable[idx].val = ce->value();\n\t\t  } else if (NetECReal *cer = dynamic_cast<NetECReal*>(tmp)) {\n\t\t\ttable[idx].val = verinum(cer->value().as_long());\n\t\t  } else {\n\t\t\tcerr << exp->get_fileline() << \": error: ``\"\n\t\t\t     << *exp << \"'' is not a constant expression.\"\n\t\t\t     << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  delete tmp;\n\t    } else {\n\t\t  table[idx].val = verinum(1);\n\t    }\n      }\n\n      assert(idx == natt);\n      return table;\n}\n"
        },
        {
          "name": "eval_tree.cc",
          "type": "blob",
          "size": 65.7138671875,
          "content": "/*\n * Copyright (c) 1999-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"compiler.h\"\n\n# include  <iostream>\n# include  <cstdlib>\n# include  <cstring>\n# include  <cmath>\n\n# include  \"netlist.h\"\n# include  \"ivl_assert.h\"\n# include  \"netmisc.h\"\n\nusing namespace std;\n\nNetExpr* NetExpr::eval_tree()\n{\n      return 0;\n}\n\nstatic void eval_debug(const NetExpr*expr, NetExpr*res, bool is_real)\n{\n      if (res != 0) {\n\t    res->set_line(*expr);\n\t    if (debug_eval_tree) {\n\t\t  cerr << expr->get_fileline() << \": debug: Evaluated\";\n\t\t  if (is_real) cerr << \" (real)\";\n\t\t  cerr << \": \" << *expr << \" --> \" << *res << endl;\n\t    }\n      }\n}\n\nstatic bool get_real_arg_(const NetExpr*expr, verireal&val)\n{\n      switch (expr->expr_type()) {\n\t  case IVL_VT_REAL: {\n\t\tconst NetECReal*c = dynamic_cast<const NetECReal*> (expr);\n\t\tif (c == 0) return false;\n\t\tval = c->value();\n\t\tbreak;\n\t  }\n\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC: {\n\t\tconst NetEConst*c = dynamic_cast<const NetEConst*>(expr);\n\t\tif (c == 0) return false;\n\t\tverinum tmp = c->value();\n\t\tval = verireal(tmp.as_double());\n\t\tbreak;\n\t  }\n\n\t  case IVL_VT_DARRAY:\n\t    return false;\n\n\t  default:\n\t    ivl_assert(*expr, 0);\n      }\n\n      return true;\n}\n\nstatic bool get_real_arguments(const NetExpr*le, const NetExpr*re,\n                               double&lval, double&rval)\n{\n      verireal val;\n\n      if (!get_real_arg_(le, val)) return false;\n      lval = val.as_double();\n\n      if (!get_real_arg_(re, val)) return false;\n      rval = val.as_double();\n\n      return true;\n}\n\nNetExpr* NetEBinary::eval_tree()\n{\n      eval_expr(left_);\n      eval_expr(right_);\n\n      return eval_arguments_(left_, right_);\n}\n\nNetExpr* NetEBinary::eval_arguments_(const NetExpr*, const NetExpr*) const\n{\n\t// this method should be overridden in all sub-classes\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nNetECReal* NetEBAdd::eval_tree_real_(const NetExpr*l, const NetExpr*r) const\n{\n      double lval;\n      double rval;\n\n      bool flag = get_real_arguments(l, r, lval, rval);\n      if (!flag) return 0;\n\n      double res_val;\n\n      switch (op()) {\n\t  case '+':\n\t    res_val = lval + rval;\n\t    break;\n\t  case '-':\n\t    res_val = lval - rval;\n\t    break;\n\t  default:\n\t    ivl_assert(*this, 0);\n      }\n\n      NetECReal*res = new NetECReal( verireal(res_val) );\n      ivl_assert(*this, res);\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetEBAdd::eval_tree()\n{\n      eval_expr(left_);\n      eval_expr(right_);\n\n\t// First try to elaborate the expression completely.\n      NetExpr*res = eval_arguments_(left_,right_);\n      if (res != 0) return res;\n\n\t// If the expression type is real, then do not attempt the\n\t// following alternative processing.\n      if (expr_type() == IVL_VT_REAL)\n\t    return 0;\n\n\t// The expression has not evaluated to a constant. Let's still\n\t// try to optimize by trying to combine a right constant value\n\t// with the right constant value of a sub-expression add. For\n\t// example, the expression (a + 2) - 1 can be rewritten as a + 1.\n\n      NetEBAdd*se = dynamic_cast<NetEBAdd*>(left_);\n      NetEConst*lc = se? dynamic_cast<NetEConst*>(se->right_) : NULL;\n      NetEConst*rc = dynamic_cast<NetEConst*>(right_);\n\n      if (lc != 0 && rc != 0) {\n\t    ivl_assert(*this, se != 0);\n\n\t    if (debug_eval_tree) {\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Partially evaluate \" << *this\n\t\t       << \" using (a+2)-1 --> (a+1) transform.\" << endl;\n\t    }\n\n\t    verinum lval = lc->value();\n\t    verinum rval = rc->value();\n\n            unsigned wid = expr_width();\n            ivl_assert(*this, wid > 0);\n            ivl_assert(*this, lval.len() == wid);\n            ivl_assert(*this, rval.len() == wid);\n\n\t    verinum val;\n\t    if (op_ == se->op_) {\n\t\t    /* (a + lval) + rval  --> a + (rval+lval) */\n\t\t    /* (a - lval) - rval  --> a - (rval+lval) */\n\t\t  val = cast_to_width(rval + lval, wid);\n\t    } else {\n\t\t    /* (a - lval) + rval  -->  a + (rval-lval) */\n\t\t    /* (a + lval) - rval  -->  a - (rval-lval) */\n\t\t  val = cast_to_width(rval - lval, wid);\n\t    }\n\n\t    NetEConst*tmp = new NetEConst(val);\n\t    left_ = se->left_->dup_expr();\n\t    delete se;\n\t    tmp->set_line(*right_);\n\t    delete right_;\n\t    right_ = tmp;\n      }\n\n\t// We may have changed the subexpression, but the result is\n\t// still not constant, so return nil here anyhow.\n      return 0;\n}\n\nNetExpr* NetEBAdd::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      if (expr_type() == IVL_VT_REAL)\n\t    return eval_tree_real_(l,r);\n\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(r);\n\n\t/* If both operands are constant, then replace the entire\n\t   expression with a constant value. */\n      if (lc != 0 && rc != 0) {\n\t    verinum lval = lc->value();\n\t    verinum rval = rc->value();\n\n            unsigned wid = expr_width();\n            ivl_assert(*this, wid > 0);\n            ivl_assert(*this, lval.len() == wid);\n            ivl_assert(*this, rval.len() == wid);\n\n\t    verinum val;\n\t    switch (op_) {\n\t\tcase '+':\n\t\t  val = cast_to_width(lval + rval, wid);\n\t\t  break;\n\t\tcase '-':\n\t\t  val = cast_to_width(lval - rval, wid);\n\t\t  break;\n\t\tdefault:\n\t\t  return 0;\n\t    }\n\n\t    NetEConst *res = new NetEConst(val);\n\t    ivl_assert(*this, res);\n\t    eval_debug(this, res, false);\n\t    return res;\n      }\n\n\n\t/* Nothing more to be done, the value is not constant. */\n      return 0;\n}\n\nNetEConst* NetEBBits::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(r);\n      if (lc == 0 || rc == 0) return 0;\n\n\t/* Notice the special case where one of the operands is 0 and\n\t   this is a bitwise &. If this happens, then the result is\n\t   known to be 0. */\n      if ((op() == '&') && (lc->value() == verinum(0))) {\n\t    verinum res (verinum::V0, expr_width());\n\t    res.has_sign(has_sign());\n\t    NetEConst*tmp = new NetEConst(res);\n\t    ivl_assert(*this, tmp);\n\t    eval_debug(this, tmp, false);\n\t    return tmp;\n      }\n\n      if ((op() == '&') && (rc->value() == verinum(0))) {\n\t    verinum res (verinum::V0, expr_width());\n\t    res.has_sign(has_sign());\n\t    NetEConst*tmp = new NetEConst(res);\n\t    ivl_assert(*this, tmp);\n\t    eval_debug(this, tmp, false);\n\t    return tmp;\n      }\n\n      verinum lval = lc->value();\n      verinum rval = rc->value();\n\n      unsigned wid = expr_width();\n      ivl_assert(*this, wid > 0);\n      ivl_assert(*this, lval.len() == wid);\n      ivl_assert(*this, rval.len() == wid);\n\n      verinum res (verinum::V0, wid);\n\n      switch (op()) {\n\n\t  case '|': {\n\t\tfor (unsigned idx = 0 ;  idx < wid ;  idx += 1)\n\t\t      res.set(idx, lval.get(idx) | rval.get(idx));\n\n\t\tbreak;\n\t  }\n\n\t  case '&': {\n\t\tfor (unsigned idx = 0 ;  idx < wid ;  idx += 1)\n\t\t      res.set(idx, lval.get(idx) & rval.get(idx));\n\n\t\tbreak;\n\t  }\n\n\t  case 'X': {\n\t\tfor (unsigned idx = 0 ;  idx < wid ;  idx += 1)\n\t\t      res.set(idx, ~(lval.get(idx) ^ rval.get(idx)));\n\n\t\tbreak;\n\t}\n\n\t  case '^': {\n\t\tfor (unsigned idx = 0 ;  idx < wid ;  idx += 1)\n\t\t      res.set(idx, lval.get(idx) ^ rval.get(idx));\n\n\t\tbreak;\n\t  }\n\n\t  default:\n\t    return 0;\n      }\n\n      res.has_sign(has_sign());\n      NetEConst*tmp = new NetEConst(res);\n      ivl_assert(*this, tmp);\n      eval_debug(this, tmp, false);\n      return tmp;\n}\n\nNetEConst* NetEBComp::eval_less_(const NetExpr*le, const NetExpr*re) const\n{\n      if (le->expr_type() == IVL_VT_REAL || re->expr_type() == IVL_VT_REAL)\n\t    return eval_leeq_real_(le, re, false);\n\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(re);\n      if (rc == 0) return 0;\n\n      verinum rv = rc->value();\n      if (! rv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (NetEConst*tmp = must_be_leeq_(le, rv, false)) {\n\t    return tmp;\n      }\n\n\t/* Now go on to the normal test of the values. */\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(le);\n      if (lc == 0) return 0;\n\n      verinum lv = lc->value();\n      if (! lv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (lv < rv) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V1, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      } else {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V0, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n}\n\nNetEConst* NetEBComp::must_be_leeq_(const NetExpr*le, const verinum&rv, bool eq_flag) const\n{\n\t// The following optimization is not valid if le can contain 'x'\n\t// or 'z' values.\n      if (le->expr_type() == IVL_VT_LOGIC) return 0;\n\n      ivl_assert(*le, le->expr_width() > 0);\n      verinum lv (verinum::V1, le->expr_width());\n      if (le->has_sign() && rv.has_sign()) {\n\t      // If the expression is signed, then the largest\n\t      // possible value for the left_ needs to have a 0 in the\n\t      // sign position.\n\t    lv.set(lv.len()-1, verinum::V0);\n\t    lv.has_sign(true);\n      }\n\n      if (lv < rv || (eq_flag && (lv == rv))) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V1, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      return 0;\n}\n\nNetEConst* NetEBComp::eval_leeq_real_(const NetExpr*le, const NetExpr*re, bool eq_flag) const\n{\n      double lval;\n      double rval;\n\n      bool flag = get_real_arguments(le, re, lval, rval);\n      if (! flag) return 0;\n\n      bool tmp = false;\n      if (lval < rval) tmp = true;\n      if (tmp == false && eq_flag && lval == rval) tmp = true;\n\n      verinum result(tmp ? verinum::V1 : verinum::V0, 1);\n      NetEConst*res = new NetEConst(result);\n      ivl_assert(*this, res);\n\n      return res;\n}\n\nNetEConst* NetEBComp::eval_leeq_(const NetExpr*le, const NetExpr*re) const\n{\n      if (le->expr_type() == IVL_VT_REAL || re->expr_type() == IVL_VT_REAL)\n\t    return eval_leeq_real_(le, re, true);\n\n      const NetEConst*r = dynamic_cast<const NetEConst*>(re);\n      if (r == 0) return 0;\n\n      verinum rv = r->value();\n      if (! rv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (NetEConst*tmp = must_be_leeq_(le, rv, true)) {\n\t    return tmp;\n      }\n\n\t/* Now go on to the normal test of the values. */\n      const NetEConst*l = dynamic_cast<const NetEConst*>(le);\n      if (l == 0) return 0;\n\n      verinum lv = l->value();\n      if (! lv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (lv <= rv) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V1, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      } else {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V0, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n}\n\nNetEConst* NetEBComp::eval_gt_(const NetExpr*le, const NetExpr*re) const\n{\n      if (le->expr_type() == IVL_VT_REAL || re->expr_type() == IVL_VT_REAL)\n\t    return eval_leeq_real_(re, le, false);\n\n      const NetEConst*l = dynamic_cast<const NetEConst*>(le);\n      if (l == 0) return 0;\n\n      verinum lv = l->value();\n      if (! lv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (NetEConst*tmp = must_be_leeq_(re, lv, false)) {\n\t    return tmp;\n      }\n\n\t/* Now go on to the normal test of the values. */\n      const NetEConst*r = dynamic_cast<const NetEConst*>(re);\n      if (r == 0) return 0;\n\n      verinum rv = r->value();\n      if (! rv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (lv > rv) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V1, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      } else {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V0, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n}\n\nNetEConst* NetEBComp::eval_gteq_(const NetExpr*le, const NetExpr*re) const\n{\n      if (le->expr_type() == IVL_VT_REAL || re->expr_type() == IVL_VT_REAL)\n\t    return eval_leeq_real_(re, le, true);\n\n      const NetEConst*l = dynamic_cast<const NetEConst*>(le);\n      if (l == 0) return 0;\n\n      verinum lv = l->value();\n      if (! lv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (NetEConst*tmp = must_be_leeq_(re, lv, true)) {\n\t    return tmp;\n      }\n\n\t/* Now go on to the normal test of the values. */\n      const NetEConst*r = dynamic_cast<const NetEConst*>(re);\n      if (r == 0) return 0;\n\n      verinum rv = r->value();\n      if (! rv.is_defined()) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::Vx, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n\n      if (lv >= rv) {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V1, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      } else {\n\t    NetEConst*res = new NetEConst(verinum(verinum::V0, 1));\n\t    ivl_assert(*this, res);\n\t    return res;\n      }\n}\n\n/*\n * Evaluate <A>==<B> or <A>!=<B>. The equality operator checks all the\n * bits and returns true(false) if there are any bits in the vector\n * that are defined (0 or 1) and different. If all the defined bits\n * are equal, but there are are x/z bits, then the situation is\n * ambiguous so the result is x.\n */\nNetEConst* NetEBComp::eval_eqeq_real_(bool ne_flag, const NetExpr*le, const NetExpr*re) const\n{\n      double lval;\n      double rval;\n\n      bool flag = get_real_arguments(le, re, lval, rval);\n      if (! flag) return 0;\n\n      verinum result(((lval == rval) != ne_flag) ?\n                     verinum::V1 : verinum::V0, 1);\n      NetEConst*res = new NetEConst(result);\n      ivl_assert(*this, res);\n\n      return res;\n}\n\nNetEConst* NetEBComp::eval_eqeq_(bool ne_flag, const NetExpr*le, const NetExpr*re) const\n{\n      if (le->expr_type() == IVL_VT_REAL ||\n          re->expr_type() == IVL_VT_REAL)\n\t    return eval_eqeq_real_(ne_flag, le, re);\n\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(le);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(re);\n      if (lc == 0 || rc == 0) return 0;\n\n      const verinum&lv = lc->value();\n      const verinum&rv = rc->value();\n\n      const verinum::V eq_res = ne_flag? verinum::V0 : verinum::V1;\n      const verinum::V ne_res = ne_flag? verinum::V1 : verinum::V0;\n\n      verinum::V res = eq_res;\n\n\t// The two expressions should already be padded to the same size.\n      ivl_assert(*this, lv.len() == rv.len());\n\n      for (unsigned idx = 0 ;  idx < lv.len() ;  idx += 1) {\n\n\t    bool x_bit_present = false;\n\n\t    switch (lv.get(idx)) {\n\n\t\tcase verinum::Vx:\n\t\tcase verinum::Vz:\n\t\t  res = verinum::Vx;\n\t\t  x_bit_present = true;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t    }\n\n\t    switch (rv.get(idx)) {\n\n\t\tcase verinum::Vx:\n\t\tcase verinum::Vz:\n\t\t  res = verinum::Vx;\n\t\t  x_bit_present = true;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t    }\n\n\t    if (x_bit_present)\n\t\t  continue;\n\n\t    if (rv.get(idx) != lv.get(idx)) {\n\t\t  res = ne_res;\n\t\t  break;\n\t    }\n      }\n\n      NetEConst*result = new NetEConst(verinum(res, 1));\n      ivl_assert(*this, result);\n      return result;\n}\n\nNetEConst* NetEBComp::eval_eqeqeq_(bool ne_flag, const NetExpr*le, const NetExpr*re) const\n{\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(le);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(re);\n      if (lc == 0 || rc == 0) return 0;\n\n      const verinum&lv = lc->value();\n      const verinum&rv = rc->value();\n\n      verinum::V res = verinum::V1;\n\n\t// The two expressions should already be padded to the same size.\n      ivl_assert(*this, lv.len() == rv.len());\n\n      for (unsigned idx = 0 ;  idx < lv.len() ;  idx += 1)\n\t    if (lv.get(idx) != rv.get(idx)) {\n\t\t  res = verinum::V0;\n\t\t  break;\n\t    }\n\n      if (ne_flag) {\n\t    if (res == verinum::V0) res = verinum::V1;\n\t    else res = verinum::V0;\n      }\n\n      NetEConst*result = new NetEConst(verinum(res, 1));\n      ivl_assert(*this, result);\n      return result;\n}\n\nNetEConst* NetEBComp::eval_weqeq_(bool ne_flag, const NetExpr*le, const NetExpr*re) const\n{\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(le);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(re);\n      if (lc == 0 || rc == 0) return 0;\n\n      const verinum&lv = lc->value();\n      const verinum&rv = rc->value();\n\n      const verinum::V eq_res = ne_flag ? verinum::V0 : verinum::V1;\n      const verinum::V ne_res = ne_flag ? verinum::V1 : verinum::V0;\n\n      verinum::V res = eq_res;\n\n\t// The two expressions should already be padded to the same size.\n      ivl_assert(*this, lv.len() == rv.len());\n\n      for (unsigned idx = 0 ;  idx < lv.len() ;  idx += 1) {\n\t      // An X or Z in the R-value matches any L-value.\n\t    switch (rv.get(idx)) {\n\t\tcase verinum::Vx:\n\t\tcase verinum::Vz:\n\t\t  continue;\n\t\tdefault:\n\t\t  break;\n\t    }\n\n\t      // An X or Z in the L-value that is not matches by an R-value X/Z returns undefined.\n\t    switch (lv.get(idx)) {\n\t\tcase verinum::Vx:\n\t\tcase verinum::Vz:\n\t\t  res = verinum::Vx;\n\t\t  continue;\n\t\tdefault:\n\t\t  break;\n\t    }\n\n\t      // A hard (0/1) mismatch gives a not-equal result.\n\t    if (rv.get(idx) != lv.get(idx)) {\n\t\t  res = ne_res;\n\t\t  break;\n\t    }\n      }\n\n      NetEConst*result = new NetEConst(verinum(res, 1));\n      ivl_assert(*this, result);\n      return result;\n}\n\nNetEConst* NetEBComp::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      NetEConst*res = 0;\n\n      switch (op_) {\n\t  case 'E': // Case equality (===)\n\t    res = eval_eqeqeq_(false, l, r);\n\t    break;\n\n\t  case 'e': // Equality (==)\n\t    res = eval_eqeq_(false, l, r);\n\t    break;\n\n\t  case 'w': // Wild equality (==?)\n\t    res = eval_weqeq_(false, l, r);\n\t    break;\n\n\t  case 'G': // >=\n\t    res = eval_gteq_(l, r);\n\t    break;\n\n\t  case 'L': // <=\n\t    res = eval_leeq_(l, r);\n\t    break;\n\n\t  case 'N': // Case inequality (!==)\n\t    res = eval_eqeqeq_(true, l, r);\n\t    break;\n\n\t  case 'n': // not-equal (!=)\n\t    res = eval_eqeq_(true, l, r);\n\t    break;\n\n\t  case 'W': // Wild not-equal (!=?)\n\t    res = eval_weqeq_(true, l, r);\n\t    break;\n\n\t  case '<': // Less than\n\t    res = eval_less_(l, r);\n\t    break;\n\n\t  case '>': // Greater than\n\t    res = eval_gt_(l, r);\n\t    break;\n\n      }\n      eval_debug(this, res, l->expr_type() == IVL_VT_REAL ||\n                            r->expr_type() == IVL_VT_REAL);\n      return res;\n}\n\nNetExpr* NetEBDiv::eval_tree_real_(const NetExpr*l, const NetExpr*r) const\n{\n      double lval;\n      double rval;\n\n      bool flag = get_real_arguments(l, r, lval, rval);\n      if (! flag) return 0;\n\n      double res_val = 0.0;\n      switch (op_) {\n\t  case '/':\n\t    res_val = lval / rval;\n\t    break;\n\n\t  case '%':\n\t      // Since this could/may be called early we don't want to\n\t      // leak functionality.\n\t    if (!gn_icarus_misc_flag) return 0;\n\t    res_val = fmod(lval, rval);\n\t    break;\n      }\n      NetECReal*res = new NetECReal( verireal(res_val) );\n      ivl_assert(*this, res);\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetEBDiv::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      if (expr_type() == IVL_VT_REAL) return eval_tree_real_(l,r);\n      ivl_assert(*this, expr_type() == IVL_VT_LOGIC);\n\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(r);\n      if (lc == 0 || rc == 0) return 0;\n\n      verinum lval = lc->value();\n      verinum rval = rc->value();\n\n      unsigned wid = expr_width();\n      ivl_assert(*this, wid > 0);\n      ivl_assert(*this, lval.len() == wid);\n      ivl_assert(*this, rval.len() == wid);\n\n      verinum val;\n      switch (op_) {\n\t  case '/':\n\t    val = cast_to_width(lval / rval, wid);\n\t    break;\n\t  case '%':\n\t    val = cast_to_width(lval % rval, wid);\n\t    break;\n\t  default:\n\t    return 0;\n      }\n\n      NetExpr*tmp = new NetEConst(val);\n      ivl_assert(*this, tmp);\n      eval_debug(this, tmp, false);\n      return tmp;\n}\n\nNetEConst* NetEBLogic::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n\t// NetEBLogic arguments should have already been reduced so real is not possible.\n      ivl_assert(*this, (l->expr_type() != IVL_VT_REAL) && (r->expr_type() != IVL_VT_REAL));\n      ivl_assert(*this, expr_type() == IVL_VT_LOGIC || expr_type() == IVL_VT_BOOL);\n\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(r);\n\n      // If the left side is constant and the right side is short circuited\n      // replace the expression with a constant\n      if (rc == 0 && lc != 0) {\n\t    verinum v = lc->value();\n\t    verinum::V res = verinum::Vx;\n\t    switch (op_) {\n\t\tcase 'a': // Logical AND (&&)\n\t\t  if (v.is_zero())\n\t\t\tres = verinum::V0;\n\t\t  break;\n\t\tcase 'o': // Logical OR (||)\n\t\t  if (! v.is_zero() && v.is_defined())\n\t\t\tres = verinum::V1;\n\t\t  break;\n\t\tcase 'q': // Logical implication (->)\n\t\t  if (v.is_zero())\n\t\t\tres = verinum::V1;\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t    }\n\t    if (res != verinum::Vx) {\n\t\t  NetEConst*tmp = new NetEConst(verinum(res, 1));\n\t\t  ivl_assert(*this, tmp);\n\t\t  eval_debug(this, tmp, false);\n\t\t  return tmp;\n\t    }\n      }\n\n      if (lc == 0 || rc == 0) return 0;\n\n      verinum::V lv = verinum::V0;\n      verinum::V rv = verinum::V0;\n\n      verinum v = lc->value();\n      for (unsigned idx = 0 ;  idx < v.len() ;  idx += 1)\n\t    if (v.get(idx) == verinum::V1) {\n\t\t  lv = verinum::V1;\n\t\t  break;\n\t    }\n\n      if (lv == verinum::V0 && ! v.is_defined()) lv = verinum::Vx;\n\n      v = rc->value();\n      for (unsigned idx = 0 ;  idx < v.len() ;  idx += 1)\n\t    if (v.get(idx) == verinum::V1) {\n\t\t  rv = verinum::V1;\n\t\t  break;\n\t    }\n\n      if (rv == verinum::V0 && ! v.is_defined()) rv = verinum::Vx;\n\n      verinum::V res;\n      switch (op_) {\n\t  case 'a': // Logical AND (&&)\n\t    if ((lv == verinum::V0) || (rv == verinum::V0))\n\t\t  res = verinum::V0;\n\t    else if ((lv == verinum::V1) && (rv == verinum::V1))\n\t\t  res = verinum::V1;\n\t    else\n\t\t  res = verinum::Vx;\n\t    break;\n\n\t  case 'o': // Logical OR (||)\n\t    if ((lv == verinum::V1) || (rv == verinum::V1))\n\t\t  res = verinum::V1;\n\t    else if ((lv == verinum::V0) && (rv == verinum::V0))\n\t\t  res = verinum::V0;\n\t    else\n\t\t  res = verinum::Vx;\n\t    break;\n\n\t  case 'q': // Logical implication (->)\n\t    if ((lv == verinum::V0) || (rv == verinum::V1))\n\t\t  res = verinum::V1;\n\t    else if ((lv == verinum::V1) && (rv == verinum::V0))\n\t\t  res = verinum::V0;\n\t    else\n\t\t  res = verinum::Vx;\n\t    break;\n\n\t  case 'Q': // Logical equivalence (<->)\n\t    if (((lv == verinum::V0) && (rv == verinum::V0)) ||\n\t        ((lv == verinum::V1) && (rv == verinum::V1)))\n\t\t  res = verinum::V1;\n\t    else if (((lv == verinum::V0) && (rv == verinum::V1)) ||\n\t             ((lv == verinum::V1) && (rv == verinum::V0)))\n\t\t  res = verinum::V0;\n\t    else\n\t\t  res = verinum::Vx;\n\t    break;\n\n\t  default:\n\t    return 0;\n      }\n\n      NetEConst*tmp = new NetEConst(verinum(res, 1));\n      ivl_assert(*this, tmp);\n      eval_debug(this, tmp, false);\n      return tmp;\n}\n\nNetExpr* NetEBMinMax::eval_tree_real_(const NetExpr*l, const NetExpr*r) const\n{\n      double lval;\n      double rval;\n\n      bool flag = get_real_arguments(l, r, lval, rval);\n      if (! flag) return 0;\n\n      double res_val;\n      switch (op()) {\n\t  case 'm':\n\t    res_val = lval < rval ? lval : rval;\n\t    break;\n\t  case 'M':\n\t    res_val = lval > rval ? lval : rval;\n\t    break;\n\t  default:\n\t    ivl_assert(*this, 0);\n      }\n\n      NetECReal*res = new NetECReal( verireal(res_val) );\n      ivl_assert(*this, res);\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetEBMinMax::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      if (expr_type() == IVL_VT_REAL) return eval_tree_real_(l,r);\n      ivl_assert(*this, expr_type() == IVL_VT_LOGIC || expr_type() == IVL_VT_BOOL);\n\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(r);\n      if (lc == 0 || rc == 0) return 0;\n\n      verinum lval = lc->value();\n      verinum rval = rc->value();\n\n      unsigned wid = expr_width();\n      ivl_assert(*this, wid > 0);\n      ivl_assert(*this, lval.len() == wid);\n      ivl_assert(*this, rval.len() == wid);\n\n      verinum res_val;\n      if (lval.is_defined() && rval.is_defined()) {\n            switch (op()) {\n                case 'm':\n                  res_val = lval < rval ? lval : rval;\n                  break;\n                case 'M':\n                  res_val = lval > rval ? lval : rval;\n                  break;\n                default:\n                  ivl_assert(*this, 0);\n            }\n      } else {\n            res_val = verinum(verinum::Vx, wid);\n      }\n      res_val.has_sign(has_sign());\n      NetEConst*res = new NetEConst(res_val);\n      ivl_assert(*this, res);\n      eval_debug(this, res, false);\n      return res;\n}\n\nNetExpr* NetEBMult::eval_tree_real_(const NetExpr*l, const NetExpr*r) const\n{\n      double lval;\n      double rval;\n\n      bool flag = get_real_arguments(l, r, lval, rval);\n      if (! flag) return 0;\n\n      NetECReal*res = new NetECReal( verireal(lval * rval) );\n      ivl_assert(*this, res);\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetEBMult::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      if (expr_type() == IVL_VT_REAL) return eval_tree_real_(l,r);\n      ivl_assert(*this, expr_type() == IVL_VT_LOGIC || expr_type() == IVL_VT_BOOL);\n\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(r);\n      if (lc == 0 || rc == 0) return 0;\n\n      verinum lval = lc->value();\n      verinum rval = rc->value();\n\n      unsigned wid = expr_width();\n      ivl_assert(*this, wid > 0);\n      ivl_assert(*this, lval.len() == wid);\n      ivl_assert(*this, rval.len() == wid);\n\n      verinum val = cast_to_width(lval * rval, wid);\n      NetEConst*tmp = new NetEConst(val);\n      ivl_assert(*this, tmp);\n      eval_debug(this, tmp, false);\n      return tmp;\n}\n\nNetExpr* NetEBPow::eval_tree_real_(const NetExpr*l, const NetExpr*r) const\n{\n      double lval;\n      double rval;\n\n      bool flag = get_real_arguments(l, r, lval, rval);\n      if (! flag) return 0;\n\n      NetECReal*res = new NetECReal( verireal( pow(lval,rval) ) );\n      ivl_assert(*this, res);\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetEBPow::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      if (expr_type() == IVL_VT_REAL) return eval_tree_real_(l,r);\n      ivl_assert(*this, expr_type() == IVL_VT_LOGIC || expr_type() == IVL_VT_BOOL);\n\n      const NetEConst*lc = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*rc = dynamic_cast<const NetEConst*>(r);\n      if (lc == 0 || rc == 0) return 0;\n\n      verinum lval = lc->value();\n      verinum rval = rc->value();\n\n      unsigned wid = expr_width();\n      ivl_assert(*this, wid > 0);\n      ivl_assert(*this, lval.len() == wid);\n\n      verinum val = cast_to_width(pow(lval, rval), wid);\n      NetEConst*res = new NetEConst(val);\n      ivl_assert(*this, res);\n      eval_debug(this, res, false);\n      return res;\n}\n\nNetEConst* NetEBShift::eval_arguments_(const NetExpr*l, const NetExpr*r) const\n{\n      const NetEConst*le = dynamic_cast<const NetEConst*>(l);\n      const NetEConst*re = dynamic_cast<const NetEConst*>(r);\n      if (le == 0 || re == 0) return 0;\n\n      NetEConst*res;\n\n      verinum lv = le->value();\n      verinum rv = re->value();\n\n      unsigned wid = expr_width();\n      ivl_assert(*this, wid > 0);\n      ivl_assert(*this, lv.len() == wid);\n\n      verinum val;\n      if (rv.is_defined()) {\n\t    unsigned shift = rv.as_unsigned();\n\n\t    switch (op_) {\n\t\tcase 'l':\n\t\t  val = cast_to_width(lv << shift, wid);\n\t\t  break;\n\t\tcase 'r':\n                  lv.has_sign(false);\n\t\t  // fallthrough\n\t\tcase 'R':\n\t\t  val = cast_to_width(lv >> shift, wid);\n\t\t  break;\n\t\tdefault:\n\t\t  return 0;\n\t    }\n      } else {\n\t    val = verinum(verinum::Vx, wid);\n      }\n      val.has_sign(has_sign());\n      res = new NetEConst(val);\n      ivl_assert(*this, res);\n      eval_debug(this, res, false);\n      return res;\n}\n\nNetEConst* NetEConcat::eval_tree()\n{\n      unsigned local_errors = 0;\n\n      unsigned gap = 0;\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\n\t      // Parameter not here? This is an error, but presumably\n\t      // already caught and we are here just to catch more.\n\t    if (parms_[idx] == 0) continue;\n\n\t      // If this parameter is already a constant, all is well\n\t      // so go on.\n\t    if (dynamic_cast<NetEConst*>(parms_[idx])) {\n\t\t  gap += parms_[idx]->expr_width();\n\t\t  continue;\n\t    }\n\n\t      // Finally, try to evaluate the parameter expression\n\t      // that is here. If I succeed, reset the parameter to\n\t      // the evaluated value.\n\t    ivl_assert(*this, parms_[idx]);\n\t    NetExpr*expr = parms_[idx]->eval_tree();\n\t    if (expr) {\n\t\t  expr->set_line(*parms_[idx]);\n\t\t  delete parms_[idx];\n\t\t  parms_[idx] = expr;\n\n\t\t  if (! expr->has_width()) {\n\t\t\tcerr << get_fileline() << \": error: concatenation \"\n\t\t\t     << \"operand has indefinite width: \"\n\t\t\t     << *parms_[idx] << endl;\n\t\t\tlocal_errors += 1;\n\t\t  } else if (expr->expr_width() == 0) {\n\t\t\tcerr << expr->get_fileline() << \": internal error: \"\n\t\t\t     << \"Operand of concatenation has no width: \"\n\t\t\t     << *expr << endl;\n\t\t\tlocal_errors += 1;\n\t\t  }\n\n\t\t  gap += expr->expr_width();\n\t    }\n\n      }\n\n      if (local_errors > 0) return 0;\n\n      return eval_arguments_(parms_, gap);\n}\n\nNetEConst* NetEConcat::eval_arguments_(const vector<NetExpr*>&vals,\n                                       unsigned gap) const\n{\n      unsigned repeat_val = repeat();\n\n\t// At this point, the \"gap\" is the width of a single repeat of\n\t// the concatenation. The total width of the result is the gap\n\t// times the repeat count.\n      verinum val (verinum::Vx, repeat_val * gap);\n\n\t// build up the result from least significant to most.\n\n      unsigned cur = 0;\n      bool is_string_flag = true;\n      for (unsigned idx = vals.size() ;  idx > 0 ;  idx -= 1) {\n\t    const NetEConst*expr = dynamic_cast<NetEConst*>(vals[idx-1]);\n\t    if (expr == 0)\n\t\t  return 0;\n\n\t    verinum tmp = expr->value();\n\t    for (unsigned bit = 0;  bit < tmp.len(); bit += 1, cur += 1)\n\t\t  for (unsigned rep = 0 ;  rep < repeat_val ;  rep += 1)\n\t\t\tval.set(rep*gap+cur, tmp[bit]);\n\n\t    is_string_flag = is_string_flag && tmp.is_string();\n      }\n\n\t/* If all the values were strings, then re-stringify this\n\t   constant. This might be useful information in the code\n\t   generator or other optimizer steps. */\n      if (is_string_flag) {\n\t    val = verinum(val.as_string());\n      }\n\n\t// Normally, concatenations are unsigned. However, the\n\t// $signed() function works by marking the expression as\n\t// signed, so we really have to check.\n      val.has_sign( this->has_sign() );\n\n      NetEConst*res = new NetEConst(val);\n      ivl_assert(*this, res);\n      eval_debug(this, res, false);\n      return res;\n}\n\nNetEConst* NetESelect::eval_tree()\n{\n      eval_expr(expr_);\n      NetEConst*expr = dynamic_cast<NetEConst*>(expr_);\n\n      long bval = 0;\n      if (base_) {\n\t    eval_expr(base_);\n\t    NetEConst*base = dynamic_cast<NetEConst*>(base_);\n\n\t    if (base == 0) return 0;\n\n\t    bval = base->value().as_long();\n      }\n\n      if (expr == 0) return 0;\n\n      verinum eval = expr->value();\n      verinum oval (verinum::V0, expr_width(), true);\n\n      verinum::V pad_bit = verinum::Vx;\n      if (base_ == 0) {\n\n\t      /* If the base is NULL (different from 0) then this\n\t\t select is here for zero or sign extension. So\n                 calculate a proper pad bit. */\n            if (has_sign())\n\t          pad_bit = eval.get(expr->expr_width()-1);\n            else\n\t\t  pad_bit = verinum::V0;\n      }\n\n      for (unsigned long idx = 0 ;  idx < expr_width() ;  idx += 1) {\n\t    if ((bval >= 0) && ((unsigned long) bval < eval.len()))\n\t\t  oval.set(idx, eval.get(bval));\n\t    else\n\t\t  oval.set(idx, pad_bit);\n\n\t    bval += 1;\n      }\n\n      oval.has_sign(has_sign());\n\n      NetEConst*res = new NetEConst(oval);\n      eval_debug(this, res, false);\n      return res;\n}\n\n\nstatic void print_ternary_cond(NetExpr*expr)\n{\n      if (NetEConst*c = dynamic_cast<NetEConst*>(expr)) {\n\t    cerr << c->value() << endl;\n\t    return;\n      }\n      if (NetECReal*c = dynamic_cast<NetECReal*>(expr)) {\n\t    cerr << c->value() << endl;\n\t    return;\n      }\n      ivl_assert(*expr, 0);\n}\n\n/*\n * A ternary expression evaluation is controlled by the condition\n * expression. If the condition evaluates to true or false, then\n * return the evaluated true or false expression. If the condition\n * evaluates to x or z, then merge the constant bits of the true and\n * false expressions.\n */\nNetExpr* NetETernary::eval_tree()\n{\n      eval_expr(cond_);\n      switch (const_logical(cond_)) {\n\t  case C_0:\n\t    eval_expr(false_val_);\n\t    if (debug_eval_tree) {\n\n\t\t  cerr << get_fileline() << \": debug: Evaluate ternary with \"\n\t\t       << \"constant condition value: \";\n\t\t  print_ternary_cond(cond_);\n\t\t  cerr << get_fileline() << \":      : Selecting false case: \"\n\t\t       << *false_val_ << endl;\n\t    }\n\n\t      // Elaborate the alternate expression to check for errors.\n\t    eval_expr(true_val_);\n\n\t    if (expr_type() == IVL_VT_REAL &&\n\t        false_val_->expr_type() != IVL_VT_REAL) {\n\t\t  verireal f;\n\t\t  if (get_real_arg_(false_val_, f)) {\n\t\t\tNetECReal*rc = new NetECReal(f);\n\t\t\trc->set_line(*this);\n\t\t\treturn rc;\n\t\t  }\n\t    }\n\n\t    return false_val_->dup_expr();\n\n\t  case C_1:\n\t    eval_expr(true_val_);\n\t    if (debug_eval_tree) {\n\t\t  cerr << get_fileline() << \": debug: Evaluate ternary with \"\n\t\t       << \"constant condition value: \";\n\t\t  print_ternary_cond(cond_);\n\t\t  cerr << get_fileline() << \":      : Selecting true case: \"\n\t\t       << *true_val_ << endl;\n\t    }\n\n\t      // Elaborate the alternate expression to check for errors.\n\t    eval_expr(false_val_);\n\n\t    if (expr_type() == IVL_VT_REAL &&\n\t        true_val_->expr_type() != IVL_VT_REAL) {\n\t\t  verireal t;\n\t\t  if (get_real_arg_(true_val_, t)) {\n\t\t\tNetECReal*rc = new NetECReal(t);\n\t\t\trc->set_line(*this);\n\t\t\treturn rc;\n\t\t  }\n\t    }\n\n\t    return true_val_->dup_expr();\n\n\t  case C_X:\n\t    break;\n\n\t  default:\n\t    return 0;\n      }\n\n\t/* Here we have a more complex case. We need to evaluate both\n\t   expressions down to constants then compare the values to\n\t   build up a constant result. */\n\n      eval_expr(true_val_);\n      eval_expr(false_val_);\n\n      return blended_arguments_(true_val_, false_val_);\n}\n\nNetExpr*NetETernary::blended_arguments_(const NetExpr*te, const NetExpr*fe) const\n{\n\n      const NetEConst*t = dynamic_cast<const NetEConst*>(te);\n      const NetEConst*f = dynamic_cast<const NetEConst*>(fe);\n      if (t == 0 || f == 0) {\n\t    verireal tv, fv;\n\t    if (!get_real_arg_(te, tv)) return 0;\n\t    if (!get_real_arg_(fe, fv)) return 0;\n\n\t    verireal val = verireal(0.0);\n\t    if (tv.as_double() == fv.as_double()) val = tv;\n\n\t    if (debug_eval_tree) {\n\t\t  cerr << get_fileline() << \": debug: Evaluate ternary with \"\n\t\t       << \"constant condition value: \";\n\t\t  print_ternary_cond(cond_);\n\t\t  cerr << get_fileline() << \":      : Blending real cases \"\n\t\t       << \"true=\" << tv.as_double()\n\t\t       << \", false=\" << fv.as_double()\n\t\t       << \", to get \" << val << endl;\n\t    }\n\n\t    NetECReal*rc = new NetECReal(val);\n\t    rc->set_line(*this);\n\t    return rc;\n      }\n\n      unsigned tsize = t->expr_width();\n      unsigned fsize = f->expr_width();\n\t/* Size of the result is the size of the widest operand. */\n      unsigned rsize = tsize > fsize? tsize : fsize;\n\n      verinum val (verinum::V0, rsize);\n      for (unsigned idx = 0 ;  idx < rsize ;  idx += 1) {\n\t    verinum::V tv = idx < tsize? t->value().get(idx) : verinum::V0;\n\t    verinum::V fv = idx < fsize? f->value().get(idx) : verinum::V0;\n\n\t    if (tv == fv) val.set(idx, tv);\n\t    else val.set(idx, verinum::Vx);\n      }\n      val.has_sign(has_sign());\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": debug: Evaluate ternary with \"\n\t\t << \"constant condition value: \";\n\t    print_ternary_cond(cond_);\n\t    cerr << get_fileline() << \":      : Blending cases to get \"\n\t\t << val << endl;\n      }\n\n      NetEConst*rc = new NetEConst(val);\n      rc->set_line(*this);\n      return rc;\n}\n\nNetExpr* NetEUnary::eval_tree()\n{\n      eval_expr(expr_);\n      return eval_arguments_(expr_);\n}\n\nNetExpr* NetEUnary::eval_tree_real_(const NetExpr*ex) const\n{\n      const NetECReal*val= dynamic_cast<const NetECReal*> (ex);\n      if (val == 0) return 0;\n\n      double res_val = val->value().as_double();\n      switch (op_) {\n\t  case '+':\n\t    break;\n\n\t  case '-':\n\t    res_val = -res_val;\n\t    break;\n\n\t  case 'm':\n\t    if (res_val < 0.0) res_val = -res_val;\n\t    break;\n\n\t  default:\n\t    return 0;\n      }\n      NetECReal *res = new NetECReal( verireal(res_val) );\n      ivl_assert(*this, res);\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetEUnary::eval_arguments_(const NetExpr*ex) const\n{\n      if (expr_type() == IVL_VT_REAL) return eval_tree_real_(ex);\n\n      const NetEConst*rval = dynamic_cast<const NetEConst*>(ex);\n      if (rval == 0) return 0;\n\n      verinum val = rval->value();\n\n      switch (op_) {\n\n\t  case '+':\n\t      /* Unary + is a no-op. */\n\t    break;\n\n\t  case '-':\n\t    val = -val;\n\t    break;\n\n\t  case 'm':\n\t    if (!val.is_defined()) {\n\t\t  for (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t\t\tval.set(idx, verinum::Vx);\n\t    } else if (val.is_negative()) {\n\t\t  val = -val;\n\t    }\n\t    break;\n\n\t  case '~':\n\t      /* Bitwise not is even simpler than logical\n\t         not. Just invert all the bits of the operand and\n\t         make the new value with the same dimensions. */\n\t    for (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t\t  switch (val.get(idx)) {\n\t\t      case verinum::V0:\n\t\t\tval.set(idx, verinum::V1);\n\t\t\tbreak;\n\t\t      case verinum::V1:\n\t\t\tval.set(idx, verinum::V0);\n\t\t\tbreak;\n\t\t      default:\n\t\t\tval.set(idx, verinum::Vx);\n\t\t  }\n\n\t    break;\n\n\t  case '!':\n\t    ivl_assert(*this, 0);\n\t  default:\n\t    return 0;\n      }\n\n      NetEConst *res = new NetEConst(val);\n      ivl_assert(*this, res);\n      eval_debug(this, res, false);\n      return res;\n}\n\n\nNetEConst* NetEUReduce::eval_tree_real_(const NetExpr*ex) const\n{\n      ivl_assert(*this, op_ == '!');\n\n      const NetECReal*val= dynamic_cast<const NetECReal*> (ex);\n      if (val == 0) return 0;\n\n      verinum::V res = val->value().as_double() == 0.0 ? verinum::V1 :\n                                                         verinum::V0;\n\n      NetEConst*tmp = new NetEConst(verinum(res, 1));\n      ivl_assert(*this, tmp);\n      eval_debug(this, tmp, true);\n      return tmp;\n}\n\nNetEConst* NetEUReduce::eval_arguments_(const NetExpr*ex) const\n{\n      if (expr_type() == IVL_VT_REAL) return eval_tree_real_(ex);\n\n      const NetEConst*rval = dynamic_cast<const NetEConst*>(ex);\n      if (rval == 0) return 0;\n\n      verinum val = rval->value();\n\n      verinum::V res;\n      bool invert = false;\n\n      switch (op_) {\n\n\t  case '!': {\n\t\t  /* Evaluate the unary logical not by first scanning\n\t\t     the operand value for V1 and Vx bits. If we find\n\t\t     any V1 bits we know that the value is TRUE, so\n\t\t     the result of ! is V0. If there are no V1 bits\n\t\t     but there are some Vx/Vz bits, the result is\n\t\t     unknown. Otherwise, the result is V1. */\n\t\tbool v1 = false, vx = false;\n\t\tfor (unsigned idx = 0 ;  idx < val.len() && !v1 ;  idx += 1) {\n\t\t      switch (val.get(idx)) {\n\t\t\t  case verinum::V0:\n\t\t\t    break;\n\t\t\t  case verinum::V1:\n\t\t\t    v1 = true;\n\t\t\t    break;\n\t\t\t  default:\n\t\t\t    vx = true;\n\t\t\t    break;\n\t\t      }\n\t\t}\n\n\t\tres = v1? verinum::V0 : (vx? verinum::Vx : verinum::V1);\n\t\tbreak;\n\t  }\n\n\t  case 'A':\n\t\tinvert = true;\n\t\t// fallthrough\n\t  case '&': {\n\t\tres = verinum::V1;\n\t\tfor (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t\t      res = res & val.get(idx);\n\t\tbreak;\n\t  }\n\n\t  case 'N':\n\t\tinvert = true;\n\t\t// fallthrough\n\t  case '|': {\n\t\tres = verinum::V0;\n\t\tfor (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t\t      res = res | val.get(idx);\n\t\tbreak;\n\t  }\n\n\t  case 'X':\n\t\tinvert = true;\n\t\t// fallthrough\n\t  case '^': {\n\t\t  /* Reduction XOR. */\n\t\tunsigned ones = 0, unknown = 0;\n\t\tfor (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t\t      switch (val.get(idx)) {\n\t\t\t  case verinum::V0:\n\t\t\t    break;\n\t\t\t  case verinum::V1:\n\t\t\t    ones += 1;\n\t\t\t    break;\n\t\t\t  default:\n\t\t\t    unknown += 1;\n\t\t\t    break;\n\t\t      }\n\n\t\tif (unknown) res = verinum::Vx;\n\t\telse if (ones%2) res = verinum::V1;\n\t\telse res = verinum::V0;\n\t\tbreak;\n\t  }\n\n\t  default:\n\t    return 0;\n      }\n\n      if (invert) res = ~res;\n\n      NetEConst*tmp = new NetEConst(verinum(res, 1));\n      ivl_assert(*this, tmp);\n      eval_debug(this, tmp, false);\n      return tmp;\n}\n\nNetExpr* NetECast::eval_arguments_(const NetExpr*ex) const\n{\n      NetExpr*res = 0;\n      switch (op_) {\n\t  case 'r':\n\t    if (const NetEConst*val = dynamic_cast<const NetEConst*>(ex)) {\n\t\t  verireal res_val(val->value().as_double());\n\t\t  res = new NetECReal(res_val);\n\t    }\n\t    break;\n\t  case '2':\n\t    if (const NetEConst*val = dynamic_cast<const NetEConst*>(ex)) {\n\t\t  verinum res_val(val->value());\n\t\t  res_val.cast_to_int2();\n\t\t  if (expr_width() > 0)\n\t\t\tres_val = cast_to_width(res_val, expr_width());\n\t\t  res = new NetEConst(res_val);\n\t    }\n\t    // fallthrough\n\t  case 'v':\n\t    if (const NetECReal*val = dynamic_cast<const NetECReal*>(ex)) {\n\t\t  verinum res_val(val->value().as_double(), false);\n\t\t  if (expr_width() > 0)\n\t\t\tres_val = cast_to_width(res_val, expr_width());\n\t\t  res = new NetEConst(res_val);\n\t    }\n\t    break;\n\t  default:\n\t    ivl_assert(*this, 0);\n\t    return 0;\n      }\n      if (res == 0) return 0;\n\n      ivl_assert(*this, res);\n      eval_debug(this, res, op_ == 'r');\n      return res;\n}\n\nNetEConst* NetESFunc::evaluate_clog2_(const NetExpr*arg_) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg_);\n      const NetECReal*tmpr = dynamic_cast<const NetECReal*>(arg_);\n\n      if (tmpi == 0 && tmpr == 0) return 0;\n\n      verinum arg;\n      if (tmpi) {\n\t    arg = tmpi->value();\n      } else {\n\t    arg = verinum(tmpr->value().as_double(), true);\n      }\n\n      NetEConst*rtn;\n\n\t/* If we have an x in the verinum we return 'bx. */\n      if (!arg.is_defined()) {\n\t    verinum tmp (verinum::Vx, integer_width);\n\t    tmp.has_sign(true);\n\n\t    rtn = new NetEConst(tmp);\n\t    ivl_assert(*this, rtn);\n      } else {\n\t    bool is_neg = false;\n\t    uint64_t res = 0;\n\n\t    if (arg.is_negative()) {\n\t\t  is_neg = true;\n\t\t    // If the length is not defined, then work with\n\t\t    // the trimmed version of the number.\n\t\t  if (! arg.has_len())\n\t\t\targ = trim_vnum(arg);\n\t    }\n\t    arg.has_sign(false);  // $unsigned()\n\n\t    if (!arg.is_zero()) {\n\t\t  arg = arg - verinum((uint64_t)1, 1);\n\t\t  while (!arg.is_zero()) {\n\t\t\tres += 1;\n\t\t\targ = arg >> 1;\n\t\t  }\n\t    }\n\n\t    if (is_neg && res < integer_width)\n\t\t  res = integer_width;\n\n\t    verinum tmp (res, integer_width);\n\t    tmp.has_sign(true);\n\n\t    rtn = new NetEConst(tmp);\n\t    ivl_assert(*this, rtn);\n      }\n\n      eval_debug(this, rtn, false);\n      return rtn;\n}\n\nNetEConst* NetESFunc::evaluate_rtoi_(const NetExpr*arg_) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg_);\n      const NetECReal*tmpr = dynamic_cast<const NetECReal*>(arg_);\n\n      if (tmpi == 0 && tmpr == 0) return 0;\n\n\t/* If the argument is already a bit based value just extend/trim it\n\t * to the integer width and translate all undefined bits to zero. */\n      if (tmpi) {\n\t    verinum arg = verinum(tmpi->value(), integer_width);\n\t    arg.cast_to_int2();\n\t    return new NetEConst(arg);\n      }\n\n\t/* Get the value of the real argument as a bit based value and then\n\t * extend/trim it to the integer width. */\n      double arg = tmpr->value().as_double();\n      if (arg >= 0.0) arg = floor(arg);\n      else arg = ceil(arg);\n      return new NetEConst(verinum(verinum(arg, false), integer_width));\n}\n\nNetECReal* NetESFunc::evaluate_itor_(const NetExpr*arg_) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg_);\n      const NetECReal*tmpr = dynamic_cast<const NetECReal*>(arg_);\n\n      if (tmpi == 0 && tmpr == 0) return 0;\n\n\t/* If the argument is already a real value round it, but NaN and\n\t * +/- infinity need to be translated to 0.0. */\n      if (tmpr) {\n\t    double arg = tmpr->value().as_double();\n\t      /* Convert a NaN or +/- infinity to 0.0 since these convert\n\t       * to 'bz which is then translated to 0.0. */\n\t    if (arg != arg || (arg && (arg == 0.5*arg))) {\n\t\t  return new NetECReal(verireal(0.0));\n\t    }\n\n\t    if (arg >= 0.0) arg = floor(arg + 0.5);\n\t    else arg = ceil(arg - 0.5);\n\n\t    return new NetECReal(verireal(arg));\n      }\n\n\t/* Convert the bit based value to a real value. */\n      double arg = tmpi->value().as_double();\n      return new NetECReal(verireal(arg));\n}\n\nNetECReal* NetESFunc::evaluate_math_one_arg_(ID id, const NetExpr*arg_) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg_);\n      const NetECReal*tmpr = dynamic_cast<const NetECReal*>(arg_);\n\n      NetECReal*res = 0;\n\n      if (tmpi || tmpr) {\n\t    double arg;\n\t    if (tmpi) {\n\t\t  arg = tmpi->value().as_double();\n\t    } else {\n\t\t  arg = tmpr->value().as_double();\n\t    }\n\n\t    switch (id) {\n\t\tcase LN:\n\t\t  res = new NetECReal(verireal(log(arg)));\n\t\t  break;\n\t\tcase LOG10:\n\t\t  res = new NetECReal(verireal(log10(arg)));\n\t\t  break;\n\t\tcase EXP:\n\t\t  res = new NetECReal(verireal(exp(arg)));\n\t\t  break;\n\t\tcase SQRT:\n\t\t  res = new NetECReal(verireal(sqrt(arg)));\n\t\t  break;\n\t\tcase FLOOR:\n\t\t  res = new NetECReal(verireal(floor(arg)));\n\t\t  break;\n\t\tcase CEIL:\n\t\t  res = new NetECReal(verireal(ceil(arg)));\n\t\t  break;\n\t\tcase SIN:\n\t\t  res = new NetECReal(verireal(sin(arg)));\n\t\t  break;\n\t\tcase COS:\n\t\t  res = new NetECReal(verireal(cos(arg)));\n\t\t  break;\n\t\tcase TAN:\n\t\t  res = new NetECReal(verireal(tan(arg)));\n\t\t  break;\n\t\tcase ASIN:\n\t\t  res = new NetECReal(verireal(asin(arg)));\n\t\t  break;\n\t\tcase ACOS:\n\t\t  res = new NetECReal(verireal(acos(arg)));\n\t\t  break;\n\t\tcase ATAN:\n\t\t  res = new NetECReal(verireal(atan(arg)));\n\t\t  break;\n\t\tcase SINH:\n\t\t  res = new NetECReal(verireal(sinh(arg)));\n\t\t  break;\n\t\tcase COSH:\n\t\t  res = new NetECReal(verireal(cosh(arg)));\n\t\t  break;\n\t\tcase TANH:\n\t\t  res = new NetECReal(verireal(tanh(arg)));\n\t\t  break;\n\t\tcase ASINH:\n\t\t  res = new NetECReal(verireal(asinh(arg)));\n\t\t  break;\n\t\tcase ACOSH:\n\t\t  res = new NetECReal(verireal(acosh(arg)));\n\t\t  break;\n\t\tcase ATANH:\n\t\t  res = new NetECReal(verireal(atanh(arg)));\n\t\t  break;\n\t\tdefault:\n\t\t  ivl_assert(*this, 0);\n\t\t  break;\n\t    }\n\t    ivl_assert(*this, res);\n      }\n\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetECReal* NetESFunc::evaluate_math_two_arg_(ID id, const NetExpr*arg0_,\n\t\t\t\t\t\t    const NetExpr*arg1_) const\n{\n      const NetEConst*tmpi0 = dynamic_cast<const NetEConst*>(arg0_);\n      const NetECReal*tmpr0 = dynamic_cast<const NetECReal*>(arg0_);\n      const NetEConst*tmpi1 = dynamic_cast<const NetEConst*>(arg1_);\n      const NetECReal*tmpr1 = dynamic_cast<const NetECReal*>(arg1_);\n\n      NetECReal*res = 0;\n\n      if ((tmpi0 || tmpr0) && (tmpi1 || tmpr1)) {\n\t    double arg0, arg1;\n\t    if (tmpi0) {\n\t\t  arg0 = tmpi0->value().as_double();\n\t    } else {\n\t\t  arg0 = tmpr0->value().as_double();\n\t    }\n\t    if (tmpi1) {\n\t\t  arg1 = tmpi1->value().as_double();\n\t    } else {\n\t\t  arg1 = tmpr1->value().as_double();\n\t    }\n\n\t    switch (id) {\n\t\tcase POW:\n\t\t  res = new NetECReal(verireal(pow(arg0, arg1)));\n\t\t  break;\n\t\tcase ATAN2:\n\t\t  res = new NetECReal(verireal(atan2(arg0, arg1)));\n\t\t  break;\n\t\tcase HYPOT:\n\t\t  res = new NetECReal(verireal(hypot(arg0, arg1)));\n\t\t  break;\n\t\tdefault:\n\t\t  ivl_assert(*this, 0);\n\t\t  break;\n\t    }\n\t    ivl_assert(*this, res);\n      }\n\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetESFunc::evaluate_abs_(const NetExpr*arg_) const\n{\n      NetExpr*res = 0;\n\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg_);\n      const NetECReal*tmpr = dynamic_cast<const NetECReal*>(arg_);\n      if (tmpi || tmpr) {\n\t    double arg;\n\t    if (tmpi) {\n\t\t  arg = tmpi->value().as_double();\n\t    } else {\n\t\t  arg = tmpr->value().as_double();\n\t    }\n\t    res = new NetECReal(verireal(fabs(arg)));\n\t    ivl_assert(*this, res);\n      }\n\n      eval_debug(this, res, true);\n      return res;\n}\n\nNetExpr* NetESFunc::evaluate_min_max_(ID id, const NetExpr*arg0_,\n\t\t\t\t\t     const NetExpr*arg1_) const\n{\n      const NetEConst*tmpi0 = dynamic_cast<const NetEConst*>(arg0_);\n      const NetECReal*tmpr0 = dynamic_cast<const NetECReal*>(arg0_);\n      const NetEConst*tmpi1 = dynamic_cast<const NetEConst*>(arg1_);\n      const NetECReal*tmpr1 = dynamic_cast<const NetECReal*>(arg1_);\n\n      NetExpr*res = 0;\n\n      if ((tmpi0 || tmpr0) && (tmpi1 || tmpr1)) {\n\t    double arg0, arg1;\n\t    if (tmpi0) {\n\t\t  arg0 = tmpi0->value().as_double();\n\t    } else {\n\t\t  arg0 = tmpr0->value().as_double();\n\t    }\n\t    if (tmpi1) {\n\t\t  arg1 = tmpi1->value().as_double();\n\t    } else {\n\t\t  arg1 = tmpr1->value().as_double();\n\t    }\n\t    switch (id) {\n\t\tcase MIN:\n\t\t  res = new NetECReal(verireal(arg0 < arg1 ? arg0 : arg1));\n\t\t  break;\n\t\tcase MAX:\n\t\t  res = new NetECReal(verireal(arg0 < arg1 ? arg1 : arg0));\n\t\t  break;\n\t\tdefault:\n\t\t  ivl_assert(*this, 0);\n\t\t  break;\n\t    }\n\t    ivl_assert(*this, res);\n      }\n\n      eval_debug(this, res, true);\n      return res;\n}\n\nstatic void no_string_arg(const NetESFunc*info, unsigned arg_num)\n{\n      cerr << info->get_fileline() << \": error: constant function \"\n           << info->name() << \"() does not support a string argument (\"\n           << arg_num+1 << \").\" << endl;\n}\n\nNetEConst* NetESFunc::evaluate_countbits_() const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(parms_[0]);\n\n      NetEConst*res = 0;\n\n      if (tmpi) {\n\t    verinum value = tmpi->value();\n\n\t    if (value.is_string()) {\n\t\t  no_string_arg(this, 0);\n\t\t  return 0;\n\t    }\n\n\t      /* Find which values need to be counted. */\n\t    bool count_0 = false;\n\t    bool count_1 = false;\n\t    bool count_z = false;\n\t    bool count_x = false;\n\t    for (unsigned arg=1; arg < parms_.size(); ++arg) {\n\t\t  const NetEConst*argi = dynamic_cast<const NetEConst*>(parms_[arg]);\n\t\t  if (! argi) return 0;\n\t\t  verinum check_for = argi->value();\n\t\t  if (check_for.is_string()) {\n\t\t\tno_string_arg(this, arg);\n\t\t\treturn 0;\n\t\t  }\n\t\t  switch (check_for[0]) {\n\t\t    case verinum::V0:\n\t\t\tcount_0 = true;\n\t\t\tbreak;\n\t\t    case verinum::V1:\n\t\t\tcount_1 = true;\n\t\t\tbreak;\n\t\t    case verinum::Vz:\n\t\t\tcount_z = true;\n\t\t\tbreak;\n\t\t    case verinum::Vx:\n\t\t\tcount_x = true;\n\t\t\tbreak;\n\t\t  }\n\t    }\n\n\t      /* Search each bit of the vector looking for the values to\n\t       * be counted. */\n\t    int count = 0;\n\t    for (unsigned bit=0; bit < value.len(); ++bit) {\n\t\t  switch (value[bit]) {\n\t\t    case verinum::V0:\n\t\t\tif (count_0) ++count;\n\t\t\tbreak;\n\t\t    case verinum::V1:\n\t\t\tif (count_1) ++count;\n\t\t\tbreak;\n\t\t    case verinum::Vz:\n\t\t\tif (count_z) ++count;\n\t\t\tbreak;\n\t\t    case verinum::Vx:\n\t\t\tif (count_x) ++count;\n\t\t\tbreak;\n\t\t  }\n\t    }\n\n\t    verinum tmp (count, integer_width);\n\t    tmp.has_sign(true);\n\t    res = new NetEConst(tmp);\n\t    ivl_assert(*this, res);\n      }\n\n      return res;\n}\n\nNetEConst* NetESFunc::evaluate_countones_(const NetExpr* arg) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg);\n\n      NetEConst*res = 0;\n\n      if (tmpi) {\n\t    verinum value = tmpi->value();\n\t    int count = 0;\n\n\t    if (value.is_string()) {\n\t\t  no_string_arg(this, 0);\n\t\t  return 0;\n\t    }\n\n\t    for (unsigned bit=0; bit < value.len(); ++bit) {\n\t\t  if (value[bit] == verinum::V1) ++count;\n\t    }\n\n\t    verinum tmp (count, integer_width);\n\t    tmp.has_sign(true);\n\t    res = new NetEConst(tmp);\n\t    ivl_assert(*this, res);\n      }\n\n      return res;\n}\n\n/* Get the total number of dimensions for the given expression. */\nNetEConst* NetESFunc::evaluate_dimensions_(const NetExpr*arg) const\n{\n      const NetESignal*esig = dynamic_cast<const NetESignal*>(arg);\n      long res = 0;\n      if (esig != 0) {\n\t    const NetNet *sig = esig->sig();\n\t    res = sig->packed_dimensions() + sig->unpacked_dimensions();\n\t      /* Icarus does not think a string has a packed size so to\n\t       * make these routines work correct add one if this is a\n\t       * string data type. */\n\t    if (sig->data_type() == IVL_VT_STRING) {\n\t\t  ivl_assert(*this, sig->packed_dimensions() == 0);\n\t\t  res += 1;\n\t    }\n      }\n\t/* Return the result as an integer sized constant. */\n      return new NetEConst(verinum(verinum(res), integer_width));\n}\n\nNetEConst* NetESFunc::evaluate_isunknown_(const NetExpr* arg) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg);\n\n      NetEConst*res = 0;\n\n      if (tmpi) {\n\t    verinum value = tmpi->value();\n\t    unsigned is_unknown = 1;\n\n\t    if (value.is_string()) {\n\t\t  no_string_arg(this, 0);\n\t\t  return 0;\n\t    }\n\n\t    if (value.is_defined()) is_unknown = 0;\n\n\t    verinum tmp (is_unknown, 1U);\n\t    tmp.has_sign(false);\n\t    res = new NetEConst(tmp);\n\t    ivl_assert(*this, res);\n      }\n\n      return res;\n}\n\nstatic bool is_onehot(const verinum&value, bool zero_is_okay)\n{\n      bool found_a_one = false;\n\n      for (unsigned bit=0; bit < value.len(); ++bit) {\n\t    if (value[bit] == verinum::V1) {\n\t\t  if (found_a_one) return false;\n\t\t  found_a_one = true;\n\t    }\n      }\n\n\t/* If no one bit was found return true if zero is okay. */\n      if (zero_is_okay) found_a_one = true;\n      return found_a_one;\n}\n\nNetEConst* NetESFunc::evaluate_onehot_(const NetExpr* arg) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg);\n\n      NetEConst*res = 0;\n\n      if (tmpi) {\n\t    verinum value = tmpi->value();\n\n\t    if (value.is_string()) {\n\t\t  no_string_arg(this, 0);\n\t\t  return 0;\n\t    }\n\n\t    verinum tmp (is_onehot(value, false), 1U);\n\t    tmp.has_sign(false);\n\t    res = new NetEConst(tmp);\n\t    ivl_assert(*this, res);\n      }\n\n      return res;\n}\n\nNetEConst* NetESFunc::evaluate_onehot0_(const NetExpr* arg) const\n{\n      const NetEConst*tmpi = dynamic_cast<const NetEConst*>(arg);\n\n      NetEConst*res = 0;\n\n      if (tmpi) {\n\t    verinum value = tmpi->value();\n\n\t    if (value.is_string()) {\n\t\t  no_string_arg(this, 0);\n\t\t  return 0;\n\t    }\n\n\t    verinum tmp (is_onehot(value, true), 1U);\n\t    tmp.has_sign(false);\n\t    res = new NetEConst(tmp);\n\t    ivl_assert(*this, res);\n      }\n\n      return res;\n}\n\n/* Get the number of unpacked dimensions for the given expression. */\nNetEConst* NetESFunc::evaluate_unpacked_dimensions_(const NetExpr*arg) const\n{\n      const NetESignal*esig = dynamic_cast<const NetESignal*>(arg);\n      long res = 0;\n      if (esig != 0) {\n\t    const NetNet *sig = esig->sig();\n\t    res = sig->unpacked_dimensions();\n      }\n\t/* Return the result as an integer sized constant. */\n      return new NetEConst(verinum(verinum(res), integer_width));\n}\n\n/* This code assumes that the dimension value will fit in a long.\n * Return true if no constant dimension value is available. */\nstatic bool check_dimension(const NetExpr*dim_expr, long &dim)\n{\n      const NetEConst*dimi = dynamic_cast<const NetEConst*>(dim_expr);\n      const NetECReal*dimr = dynamic_cast<const NetECReal*>(dim_expr);\n      if (dimi == 0 && dimr == 0) return true;\n\n      if (dimi) dim = dimi->value().as_long();\n      if (dimr) dim = dimr->value().as_long();\n      return false;\n}\n\n/* Get the left and right values for the argument at the given dimension\n * if it exists. Return true if no values are available. Set defer to true\n * if this should be handled in the run time. */\nstatic bool get_array_info(const NetExpr*arg, long dim,\n                           long &left, long &right, bool&defer)\n{\n      if (const NetEConstParam*param = dynamic_cast<const NetEConstParam*>(arg)) {\n\t    ivl_assert(*arg, dim == 1);\n\t    left = param->expr_width() - 1;\n\t    right = 0;\n\t    return false;\n      }\n      if (const NetESelect*select = dynamic_cast<const NetESelect*>(arg)) {\n\t    const netranges_t&dim_vals = select->net_type()->slice_dimensions();\n\t    const netrange_t&range = dim_vals[dim-1];\n\t    left = range.get_msb();\n\t    right = range.get_lsb();\n\t    return false;\n      }\n\t/* The argument must be a signal that has enough dimensions. */\n      const NetESignal*esig = dynamic_cast<const NetESignal*>(arg);\n      if (esig == 0) return true;\n      const NetNet *sig = esig->sig();\n\t/* A string or dynamic array must be handled by the run time. */\n      switch (sig->data_type()) {\n\tcase IVL_VT_DARRAY:\n\tcase IVL_VT_QUEUE:\n\tcase IVL_VT_STRING:\n\t    defer = true;\n\t    return true;\n\t    break;\n\tdefault:\n\t    break;\n      }\n      long pdims = sig->packed_dimensions();\n      long updims = sig->unpacked_dimensions();\n      if (dim > (pdims + updims)) return true;\n\t/* Get the appropriate unpacked or packed dimension information. */\n      if (dim > updims) {\n\t    const netranges_t&dim_vals = sig->packed_dims();\n\t    const netrange_t&range = dim_vals[dim-updims-1];\n\t    left = range.get_msb();\n\t    right = range.get_lsb();\n      } else {\n\t    const netranges_t&dim_vals = sig->unpacked_dims();\n\t    const netrange_t&range = dim_vals[dim-1];\n\t    left = range.get_msb();\n\t    right = range.get_lsb();\n      }\n      return false;\n}\n\n/* Calculate the array property functions. */\nNetEConst* NetESFunc::evaluate_array_funcs_(ID id,\n                                            const NetExpr*arg0,\n                                            const NetExpr*arg1) const\n{\n      long dim = 0;\n\t/* Check to see if the dimension argument is constant. */\n      if (check_dimension(arg1, dim)) return 0;\n\t/* If dimension is less than 1 return undefined. */\n      if (dim < 1) {\n\t    return new NetEConst(verinum(verinum::Vx, integer_width));\n      }\n\t/* Get the left/right information for this dimension if it exists. */\n      long left = 0;\n      long right = 0;\n      bool defer = false;\n      if (get_array_info(arg0, dim, left, right, defer)) {\n\t      /* If this is a string or dynamic array defer this function\n\t       * call since the left/right information is dynamic and is\n\t       * not available yet. */\n\t    if (defer) return 0;\n\t    return new NetEConst(verinum(verinum::Vx, integer_width));\n      }\n\t/* Calculate the appropriate array function result. */\n      long res;\n      switch (id) {\n\tcase HIGH:\n\t    res = (right > left) ? right : left;\n\t    break;\n\tcase INCR:\n\t    res = (right > left) ? -1 : 1;\n\t    break;\n\tcase LEFT:\n\t    res = left;\n\t    break;\n\tcase LOW:\n\t    res = (right > left) ? left : right;\n\t    break;\n\tcase RIGHT:\n\t    res = right;\n\t    break;\n\tcase SIZE:\n\t    res = (right > left) ? right - left : left - right;\n\t    res += 1;\n\t    break;\n\tdefault:\n\t    res = 0;\n\t    ivl_assert(*this, 0);\n      }\n\t/* Return the result as an integer sized constant. */\n      return new NetEConst(verinum(verinum(res), integer_width));\n}\n\n/* Make a constant one value that can be used by the one argument\n * array properties calls. */\nconst NetEConst* NetESFunc::const_one_ = new NetEConst(verinum(1U, 32U));\n\nNetExpr* NetESFunc::evaluate_one_arg_(ID id, const NetExpr*arg) const\n{\n      switch (id) {\n\t  case ABS:\n\t    return evaluate_abs_(arg);\n\t  case CLOG2:\n\t    return evaluate_clog2_(arg);\n\t  case CTONES:\n\t    return evaluate_countones_(arg);\n\t  case DIMS:\n\t    return evaluate_dimensions_(arg);\n\t      /* The array functions are handled together. */\n\t  case HIGH:\n\t  case INCR:\n\t  case LEFT:\n\t  case LOW:\n\t  case RIGHT:\n\t  case SIZE:\n\t    return evaluate_array_funcs_(id, arg, const_one_);\n\t  case ISUNKN:\n\t    return evaluate_isunknown_(arg);\n\t  case ITOR:\n\t    return evaluate_itor_(arg);\n\t  case ONEHT:\n\t    return evaluate_onehot_(arg);\n\t  case ONEHT0:\n\t    return evaluate_onehot0_(arg);\n\t  case RTOI:\n\t    return evaluate_rtoi_(arg);\n\t  case UPDIMS:\n\t    return evaluate_unpacked_dimensions_(arg);\n\t  default:\n\t    return evaluate_math_one_arg_(id, arg);\n      }\n}\n\nNetExpr* NetESFunc::evaluate_two_arg_(ID id, const NetExpr*arg0,\n                                      const NetExpr*arg1) const\n{\n      switch (id) {\n\t  case CTBITS:\n\t    return evaluate_countbits_();\n\t      /* The array functions are handled together. */\n\t  case HIGH:\n\t  case INCR:\n\t  case LEFT:\n\t  case LOW:\n\t  case RIGHT:\n\t  case SIZE:\n\t    return evaluate_array_funcs_(id, arg0, arg1);\n\t  case MAX:\n\t  case MIN:\n\t    return evaluate_min_max_(id, arg0, arg1);\n\t  default:\n\t    return evaluate_math_two_arg_(id, arg0, arg1);\n      }\n}\n\nNetESFunc::ID NetESFunc::built_in_id_() const\n{\n      static map<string,ID> built_in_func;\n      static bool funcs_need_init = true;\n\n\t/* These functions are always available. */\n      if (funcs_need_init) {\n\t    built_in_func[\"$itor\"] = ITOR;\n\t    built_in_func[\"$rtoi\"] = RTOI;\n      }\n\n\t/* These are available in 1364-2005 and later or if the Icarus misc\n\t * flag was given. */\n      if (funcs_need_init && ((generation_flag >= GN_VER2005) ||\n                              gn_icarus_misc_flag)) {\n\t    built_in_func[\"$acos\" ] = ACOS;\n\t    built_in_func[\"$acosh\"] = ACOSH;\n\t    built_in_func[\"$asin\" ] = ASIN;\n\t    built_in_func[\"$asinh\"] = ASINH;\n\t    built_in_func[\"$atan\" ] = ATAN;\n\t    built_in_func[\"$atanh\"] = ATANH;\n\t    built_in_func[\"$atan2\"] = ATAN2;\n\t    built_in_func[\"$ceil\" ] = CEIL;\n\t    built_in_func[\"$clog2\"] = CLOG2;\n\t    built_in_func[\"$cos\"  ] = COS;\n\t    built_in_func[\"$cosh\" ] = COSH;\n\t    built_in_func[\"$exp\"  ] = EXP;\n\t    built_in_func[\"$floor\"] = FLOOR;\n\t    built_in_func[\"$hypot\"] = HYPOT;\n\t    built_in_func[\"$ln\"   ] = LN;\n\t    built_in_func[\"$log10\"] = LOG10;\n\t    built_in_func[\"$pow\"  ] = POW;\n\t    built_in_func[\"$sin\"  ] = SIN;\n\t    built_in_func[\"$sinh\" ] = SINH;\n\t    built_in_func[\"$sqrt\" ] = SQRT;\n\t    built_in_func[\"$tan\"  ] = TAN;\n\t    built_in_func[\"$tanh\" ] = TANH;\n      }\n\n\t/* These are available in 1800-2005 and later. */\n      if (funcs_need_init && (generation_flag >= GN_VER2005_SV)) {\n\t    built_in_func[\"$dimensions\" ] = DIMS;\n\t    built_in_func[\"$high\" ]       = HIGH;\n\t    built_in_func[\"$increment\" ]  = INCR;\n\t    built_in_func[\"$isunknown\" ]  = ISUNKN;\n\t    built_in_func[\"$left\" ]       = LEFT;\n\t    built_in_func[\"$low\" ]        = LOW;\n\t    built_in_func[\"$onehot\" ]     = ONEHT;\n\t    built_in_func[\"$onehot0\" ]    = ONEHT0;\n\t    built_in_func[\"$right\" ]      = RIGHT;\n\t    built_in_func[\"$size\" ]       = SIZE;\n\t    built_in_func[\"$unpacked_dimensions\" ] = UPDIMS;\n      }\n\n\t/* This is available in 1800-2009 and later. */\n      if (funcs_need_init && (generation_flag >= GN_VER2009)) {\n\t    built_in_func[\"$countones\" ] = CTONES;\n      }\n\n\t/* This is available in 1800-2012 and later. */\n      if (funcs_need_init && (generation_flag >= GN_VER2012)) {\n\t    built_in_func[\"$countbits\" ] = CTBITS;\n      }\n\n\t/* These are available in Verilog-A as Icarus extensions or if the\n\t * Icarus misc flag was given. */\n      if (funcs_need_init && (gn_verilog_ams_flag || gn_icarus_misc_flag)) {\n\t    built_in_func[\"$abs\"] = ABS;\n\t    built_in_func[\"$max\"] = MAX;\n\t    built_in_func[\"$min\"] = MIN;\n      }\n\n\t/* The function table has been initialized at this point. */\n      funcs_need_init = false;\n\n\t/* Look for the given function and if it is not available return\n\t * NOT_BUILT_IN otherwise return the ID for the function. */\n      map<string,ID>::iterator idx = built_in_func.find(name_);\n\n      if (idx == built_in_func.end()) return NOT_BUILT_IN;\n\n      return idx->second;\n}\n\nNetExpr* NetESFunc::eval_tree()\n{\n\t/* We don't support evaluating overridden functions. */\n      if (is_overridden_)\n\t    return 0;\n\n\t/* Get the ID for this system function if it can be used as a\n\t * constant function. */\n      ID id = built_in_id_();\n      if (id == NOT_BUILT_IN) return 0;\n\n      switch (parms_.size()) {\n\t  case 1:\n\t    if (! takes_nargs_(id, 1)) {\n\t\t  cerr << get_fileline() << \": error: constant function \"\n\t\t       << name_ << \"() does not support a single argument.\"\n\t\t       << endl;\n\t\t  return 0;\n\t    }\n\t    eval_expr(parms_[0]);\n\t    return evaluate_one_arg_(id, parms_[0]);\n\n\t  case 2:\n\t    if (! takes_nargs_(id, 2)) {\n\t\t  cerr << get_fileline() << \": error: constant function \"\n\t\t       << name_ << \"() does not support two arguments.\"\n\t\t       << endl;\n\t\t  return 0;\n\t    }\n\t    eval_expr(parms_[0]);\n\t    eval_expr(parms_[1]);\n\t    return evaluate_two_arg_(id, parms_[0], parms_[1]);\n\n\t  default:\n\t      /* Check to see if the function was called correctly. */\n\t    if (! takes_nargs_(id, parms_.size())) {\n\t\t  cerr << get_fileline() << \": error: constant function \"\n\t\t       << name_ << \"() does not support \" << parms_.size()\n\t\t       << \" arguments.\" << endl;\n\t\t  return 0;\n\t    }\n\t    if (id == CTBITS) {\n\t\t  for (unsigned bit = 0; bit < parms_.size(); ++bit) {\n\t\t\teval_expr(parms_[bit]);\n\t\t  }\n\t\t  return evaluate_countbits_();\n\t    } else {\n\t\t  cerr << get_fileline() << \": sorry: constant functions with \"\n\t\t       << parms_.size() << \" arguments are not supported: \"\n\t\t       << name_ << \"().\" << endl;\n\t    }\n\t    return 0;\n      }\n}\n\nNetExpr* NetEUFunc::eval_tree()\n{\n        // If we know the function cannot be evaluated as a constant,\n        // give up now.\n      if (!func()->is_const_func() || (func()->calls_sys_task() && !need_const_))\n            return 0;\n\n\t// If we neither want nor need to evaluate the function at\n\t// compile time, give up now.\n      if (!opt_const_func && !need_const_)\n            return 0;\n\n        // Variables inside static functions can be accessed from outside\n        // the function, so we can't be sure they are constant unless the\n        // function was called in a constant context or the user has told\n\t// us this is safe.\n      if (!func()->is_auto() && !need_const_ && (opt_const_func < 2))\n            return 0;\n\n        // Run through the input parameters to check they are constants.\n      for (unsigned idx = 0; idx < parm_count(); idx += 1) {\n            if (dynamic_cast<const NetEConst*> (parm(idx)))\n                  continue;\n            if (dynamic_cast<const NetECReal*> (parm(idx)))\n                  continue;\n            return 0;\n      }\n\n      NetFuncDef*def = func_->func_def();\n      ivl_assert(*this, def);\n\n      vector<NetExpr*>args(parms_.size());\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1)\n\t    args[idx] = parms_[idx]->dup_expr();\n\n      NetExpr*res = def->evaluate_function(*this, args);\n      return res;\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "exposenodes.cc",
          "type": "blob",
          "size": 3.908203125,
          "content": "/*\n * Copyright (c) 2016-2021 Martin Whitaker (icarus@martin-whitaker.me.uk)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <cstdlib>\n# include  <sstream>\n# include  \"netlist.h\"\n# include  \"functor.h\"\n# include  \"compiler.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * The exposenodes functor is primarily provided for use by the vlog95\n * target. To implement some LPM objects, it needs to take a bit or part\n * of one of the LPM inputs. If that input is not connected to a real\n * net in the design, we need to create a net at that point so that\n * there is something to which we can apply a bit or part select. This\n * has the effect of splitting the synthesised structure at that point.\n * Rather than creating a new net, we just look for a temporary net\n * created by the synthesis process (there should be at least one) and\n * reset its \"local\" flag. We also prepend another '_' to the synthetic\n * name to avoid name collisions when we recompile the vlog95 output\n * (because NetScope::local_symbol() doesn't actually check that the\n * name it generates is unique).\n */\n\nstruct exposenodes_functor  : public functor_t {\n\n      unsigned count;\n\n      virtual void lpm_mux(Design*des, NetMux*obj);\n      virtual void lpm_part_select(Design*des, NetPartSelect*obj);\n      virtual void lpm_substitute(Design*des, NetSubstitute*obj);\n};\n\nstatic bool expose_nexus(Nexus*nex)\n{\n      NetNet*sig = 0;\n      for (Link*cur = nex->first_nlink() ; cur ; cur = cur->next_nlink()) {\n\n\t      // Don't expose nodes that are attached to constants\n\t    if (dynamic_cast<NetConst*> (cur->get_obj()))\n\t\t  return false;\n\t    if (dynamic_cast<NetLiteral*> (cur->get_obj()))\n\t\t  return false;\n\n\t    NetNet*cur_sig = dynamic_cast<NetNet*> (cur->get_obj());\n\t    if (cur_sig == 0)\n\t\t  continue;\n\n\t    if (!cur_sig->local_flag())\n\t\t  return false;\n\n\t    sig = cur_sig;\n      }\n      assert(sig);\n      ostringstream res;\n      res << \"_\" << sig->name();\n      sig->rename(lex_strings.make(res.str()));\n      sig->local_flag(false);\n      return true;\n}\n\n/*\n * The vlog95 target implements a wide mux as a hierarchy of 2:1 muxes,\n * picking off one bit of the select input at each level of the hierarchy.\n */\nvoid exposenodes_functor::lpm_mux(Design*, NetMux*obj)\n{\n      if (obj->sel_width() == 1)\n\t    return;\n\n      if (expose_nexus(obj->pin_Sel().nexus()))\n\t    count += 1;\n}\n\n/*\n * A VP part select is going to select a part from its input.\n */\nvoid exposenodes_functor::lpm_part_select(Design*, NetPartSelect*obj)\n{\n      if (obj->dir() != NetPartSelect::VP)\n\t    return;\n\n      if (expose_nexus(obj->pin(1).nexus()))\n\t    count += 1;\n}\n\n/*\n * A substitute is going to select one or two parts from the wider input signal.\n */\nvoid exposenodes_functor::lpm_substitute(Design*, NetSubstitute*obj)\n{\n      if (expose_nexus(obj->pin(1).nexus()))\n\t    count += 1;\n}\n\nvoid exposenodes(Design*des)\n{\n      exposenodes_functor exposenodes;\n      exposenodes.count = 0;\n      if (verbose_flag) {\n\t    cout << \" ... Look for intermediate nodes\" << endl << flush;\n      }\n      des->functor(&exposenodes);\n      if (verbose_flag) {\n\t    cout << \" ... Exposed \" << exposenodes.count\n\t\t << \" intermediate signals.\" << endl << flush;\n      }\n}\n"
        },
        {
          "name": "expr_synth.cc",
          "type": "blob",
          "size": 49.7841796875,
          "content": "/*\n * Copyright (c) 1999-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"compiler.h\"\n\n# include  <cstdlib>\n# include  <iostream>\n\n# include  \"netlist.h\"\n# include  \"netvector.h\"\n# include  \"netparray.h\"\n# include  \"netmisc.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nstatic NetNet* convert_to_real_const(Design*des, NetScope*scope, NetEConst*expr)\n{\n      verireal vrl(expr->value().as_double());\n      NetECReal rlval(vrl);\n      NetNet* sig = rlval.synthesize(des, scope, 0);\n\n      return sig;\n}\n\n  /* Note that lsig, rsig and real_args are references. */\nstatic bool process_binary_args(Design*des, NetScope*scope, NetExpr*root,\n\t\t\t\tNetExpr*left, NetExpr*right,\n\t\t\t\tNetNet*&lsig, NetNet*&rsig, bool&real_args)\n{\n      if (left->expr_type() == IVL_VT_REAL ||\n          right->expr_type() == IVL_VT_REAL) {\n\t    real_args = true;\n\n\t      /* Convert the arguments to real. Handle the special\n\t         cases of constants, which can be converted more directly. */\n\t    if (left->expr_type() == IVL_VT_REAL) {\n\t\t  lsig = left->synthesize(des, scope, root);\n\t    } else if (NetEConst*tmpc = dynamic_cast<NetEConst*> (left)) {\n\t\t  lsig = convert_to_real_const(des, scope, tmpc);\n\t    } else {\n\t\t  NetNet*tmp = left->synthesize(des, scope, root);\n\t\t  lsig = cast_to_real(des, scope, tmp);\n\t    }\n\n\t    if (right->expr_type() == IVL_VT_REAL) {\n\t\t  rsig = right->synthesize(des, scope, root);\n\t    } else if (NetEConst*tmpc = dynamic_cast<NetEConst*> (right)) {\n\t\t  rsig = convert_to_real_const(des, scope, tmpc);\n\t    } else {\n\t\t  NetNet*tmp = right->synthesize(des, scope, root);\n\t\t  rsig = cast_to_real(des, scope, tmp);\n\t    }\n\n      } else {\n            real_args = false;\n\t    lsig = left->synthesize(des, scope, root);\n\t    rsig = right->synthesize(des, scope, root);\n\n      }\n\n      if (lsig == 0 || rsig == 0) return true;\n      else return false;\n}\n\nNetNet* NetExpr::synthesize(Design*des, NetScope*, NetExpr*)\n{\n      cerr << get_fileline() << \": internal error: cannot synthesize expression: \"\n\t   << *this << endl;\n      des->errors += 1;\n      return 0;\n}\n\n/*\n * Make an LPM_ADD_SUB device from addition operators.\n */\nNetNet* NetEBAdd::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      ivl_assert(*this, (op()=='+') || (op()=='-'));\n\n      NetNet *lsig=0, *rsig=0;\n      bool real_args=false;\n      if (process_binary_args(des, scope, root, left_, right_, lsig, rsig,\n                              real_args)) {\n\t    return 0;\n      }\n\n      ivl_assert(*this, expr_width() >= lsig->vector_width());\n      ivl_assert(*this, expr_width() >= rsig->vector_width());\n\n      unsigned width;\n      if (expr_type() == IVL_VT_REAL) {\n\t    width = 1;\n\t    if (lsig->data_type() != IVL_VT_REAL)\n\t\t  lsig = cast_to_real(des, scope, lsig);\n\t    if (rsig->data_type() != IVL_VT_REAL)\n\t\t  rsig = cast_to_real(des, scope, rsig);\n\n      } else {\n\t    lsig = pad_to_width(des, lsig, expr_width(), *this);\n\t    rsig = pad_to_width(des, rsig, expr_width(), *this);\n\n\t    ivl_assert(*this, lsig->vector_width() == rsig->vector_width());\n\t    width=lsig->vector_width();\n      }\n\n      perm_string path = lsig->scope()->local_symbol();\n      netvector_t*osig_vec = new netvector_t(expr_type(), width-1, 0);\n      osig_vec->set_signed(has_sign());\n      NetNet*osig = new NetNet(lsig->scope(), path, NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      perm_string oname = osig->scope()->local_symbol();\n      NetAddSub *adder = new NetAddSub(lsig->scope(), oname, width);\n      adder->set_line(*this);\n      connect(lsig->pin(0), adder->pin_DataA());\n      connect(rsig->pin(0), adder->pin_DataB());\n      connect(osig->pin(0), adder->pin_Result());\n      des->add_node(adder);\n\n      switch (op()) {\n\t  case '+':\n\t    adder->attribute(perm_string::literal(\"LPM_Direction\"), verinum(\"ADD\"));\n\t    break;\n\t  case '-':\n\t    adder->attribute(perm_string::literal(\"LPM_Direction\"), verinum(\"SUB\"));\n\t    break;\n      }\n\n      return osig;\n}\n\n/*\n * The bitwise logic operators are turned into discrete gates pretty\n * easily. Synthesize the left and right sub-expressions to get\n * signals, then just connect a single gate to each bit of the vector\n * of the expression.\n */\nNetNet* NetEBBits::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet*lsig = left_->synthesize(des, scope, root);\n      NetNet*rsig = right_->synthesize(des, scope, root);\n\n      if (lsig == 0 || rsig == 0) return 0;\n\n        /* You cannot do bitwise operations on real values. */\n      if (lsig->data_type() == IVL_VT_REAL ||\n          rsig->data_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: \" << human_readable_op(op_)\n\t         << \" operator may not have REAL operands.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      unsigned width = expr_width();\n      if (rsig->vector_width() > width) width = rsig->vector_width();\n\n      lsig = pad_to_width(des, lsig, width, *this);\n      rsig = pad_to_width(des, rsig, width, *this);\n\n      ivl_assert(*this, lsig->vector_width() == rsig->vector_width());\n      netvector_t*osig_vec = new netvector_t(expr_type(), width-1, 0);\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      perm_string oname = scope->local_symbol();\n      NetLogic*gate;\n\n      switch (op()) {\n\t  case '&':\n\t    gate = new NetLogic(scope, oname, 3, NetLogic::AND, width, true);\n\t    break;\n\t  case 'A':\n\t    gate = new NetLogic(scope, oname, 3, NetLogic::NAND, width, true);\n\t    break;\n\t  case '|':\n\t    gate = new NetLogic(scope, oname, 3, NetLogic::OR, width, true);\n\t    break;\n\t  case '^':\n\t    gate = new NetLogic(scope, oname, 3, NetLogic::XOR, width, true);\n\t    break;\n\t  case 'O':\n\t    gate = new NetLogic(scope, oname, 3, NetLogic::NOR, width, true);\n\t    break;\n\t  case 'X':\n\t    gate = new NetLogic(scope, oname, 3, NetLogic::XNOR, width, true);\n\t    break;\n\t  default:\n\t    gate = NULL;\n\t    ivl_assert(*this, 0);\n      }\n\n      connect(osig->pin(0), gate->pin(0));\n      connect(lsig->pin(0), gate->pin(1));\n      connect(rsig->pin(0), gate->pin(2));\n\n      gate->set_line(*this);\n      des->add_node(gate);\n\n      return osig;\n}\n\nNetNet* NetEBComp::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n\n      NetNet *lsig=0, *rsig=0;\n      unsigned width;\n      bool real_args=false;\n      if (process_binary_args(des, scope, root, left_, right_, lsig, rsig,\n                              real_args)) {\n\t    return 0;\n      }\n\n      if (real_args) {\n\t    width = 1;\n      } else {\n\t    width = lsig->vector_width();\n\t    if (rsig->vector_width() > width) width = rsig->vector_width();\n\n\t    if (lsig->get_signed())\n\t\t  lsig = pad_to_width_signed(des, lsig, width, *this);\n\t    else\n\t\t  lsig = pad_to_width(des, lsig, width, *this);\n\t    if (rsig->get_signed())\n\t\t  rsig = pad_to_width_signed(des, rsig, width, *this);\n\t    else\n\t\t  rsig = pad_to_width(des, rsig, width, *this);\n      }\n\n      netvector_t*osig_vec = new netvector_t(IVL_VT_LOGIC);\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n\t// Test if the comparison is signed.\n\t//\n\t// Note 1: This is not the same as asking if the result is\n\t// signed. In fact, the result will typically be UNsigned. The\n\t// decision to make the comparison signed depends on the\n\t// operand expressions.\n\t//\n\t// Note 2: The operand expressions may be signed even if the\n\t// sig that comes out of synthesis is unsigned. The $signed()\n\t// function marks the expression but doesn't change the\n\t// underlying signals.\n      bool signed_compare = left_->has_sign() && right_->has_sign();\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Comparison (\" << op_ << \")\"\n\t\t << \" is \" << (signed_compare? \"signed\"  : \"unsigned\")\n\t\t << endl;\n\t    cerr << get_fileline() << \":      : lsig is \"\n\t\t << (lsig->get_signed()? \"signed\" : \"unsigned\")\n\t\t << \" rsig is \" << (rsig->get_signed()? \"signed\" : \"unsigned\")\n\t\t << endl;\n      }\n\n      if (op_ == 'E' || op_ == 'N') {\n\t    NetCaseCmp*gate = new NetCaseCmp(scope, scope->local_symbol(),\n\t\t\t\t\t     width, op_=='E' ? NetCaseCmp::EEQ : NetCaseCmp::NEQ);\n\t    gate->set_line(*this);\n\t    connect(gate->pin(0), osig->pin(0));\n\t    connect(gate->pin(1), lsig->pin(0));\n\t    connect(gate->pin(2), rsig->pin(0));\n\t    des->add_node(gate);\n\t    return osig;\n      }\n\n      if (op_ == 'w' || op_ == 'W') {\n\t    NetCaseCmp*gate = new NetCaseCmp(scope, scope->local_symbol(),\n\t\t\t\t\t     width, op_=='w' ? NetCaseCmp::WEQ : NetCaseCmp::WNE);\n\t    gate->set_line(*this);\n\t    connect(gate->pin(0), osig->pin(0));\n\t    connect(gate->pin(1), lsig->pin(0));\n\t    connect(gate->pin(2), rsig->pin(0));\n\t    des->add_node(gate);\n\t    return osig;\n      }\n\n\t/* Handle the special case of a single bit equality\n\t   operation. Make an XNOR gate instead of a comparator. */\n      if ((width == 1) && (op_ == 'e') && !real_args) {\n\t    NetLogic*gate = new NetLogic(scope, scope->local_symbol(),\n\t\t\t\t\t 3, NetLogic::XNOR, 1, true);\n\t    gate->set_line(*this);\n\t    connect(gate->pin(0), osig->pin(0));\n\t    connect(gate->pin(1), lsig->pin(0));\n\t    connect(gate->pin(2), rsig->pin(0));\n\t    des->add_node(gate);\n\t    return osig;\n      }\n\n\t/* Handle the special case of a single bit inequality\n\t   operation. This is similar to single bit equality, but uses\n\t   an XOR instead of an XNOR gate. */\n      if ((width == 1) && (op_ == 'n')  && !real_args) {\n\t    NetLogic*gate = new NetLogic(scope, scope->local_symbol(),\n\t\t\t\t\t 3, NetLogic::XOR, 1, true);\n\t    gate->set_line(*this);\n\t    connect(gate->pin(0), osig->pin(0));\n\t    connect(gate->pin(1), lsig->pin(0));\n\t    connect(gate->pin(2), rsig->pin(0));\n\t    des->add_node(gate);\n\t    return osig;\n      }\n\n\n      NetCompare*dev = new NetCompare(scope, scope->local_symbol(), width);\n      dev->set_line(*this);\n      des->add_node(dev);\n\n      connect(dev->pin_DataA(), lsig->pin(0));\n      connect(dev->pin_DataB(), rsig->pin(0));\n\n\n      switch (op_) {\n\t  case '<':\n\t    connect(dev->pin_ALB(), osig->pin(0));\n\t    dev->set_signed(signed_compare);\n\t    break;\n\t  case '>':\n\t    connect(dev->pin_AGB(), osig->pin(0));\n\t    dev->set_signed(signed_compare);\n\t    break;\n\t  case 'E': // === ?\n\t    if (real_args) {\n\t\t  cerr << get_fileline() << \": error: Case equality may \"\n\t\t          \"not have real operands.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    // fallthrough\n\t  case 'e': // ==\n\t    connect(dev->pin_AEB(), osig->pin(0));\n\t    break;\n\t  case 'G': // >=\n\t    connect(dev->pin_AGEB(), osig->pin(0));\n\t    dev->set_signed(signed_compare);\n\t    break;\n\t  case 'L': // <=\n\t    connect(dev->pin_ALEB(), osig->pin(0));\n\t    dev->set_signed(signed_compare);\n\t    break;\n\t  case 'N': // !==\n\t    if (real_args) {\n\t\t  cerr << get_fileline() << \": error: Case inequality may \"\n\t\t          \"not have real operands.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    // fallthrough\n\t  case 'n': // !=\n\t    connect(dev->pin_ANEB(), osig->pin(0));\n\t    break;\n\n\t  default:\n\t    cerr << get_fileline() << \": internal error: cannot synthesize \"\n\t\t  \"comparison: \" << *this << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      return osig;\n}\n\nNetNet* NetEBPow::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet *lsig=0, *rsig=0;\n      unsigned width;\n      bool real_args=false;\n      if (process_binary_args(des, scope, root, left_, right_, lsig, rsig,\n                              real_args)) {\n\t    return 0;\n      }\n\n      if (real_args) width = 1;\n      else width = expr_width();\n\n      NetPow*powr = new NetPow(scope, scope->local_symbol(), width,\n\t\t\t       lsig->vector_width(),\n\t\t\t       rsig->vector_width());\n      powr->set_line(*this);\n      des->add_node(powr);\n\n        // The lpm_pwr object only cares about the signedness of the exponent.\n      powr->set_signed( right_->has_sign() );\n\n      connect(powr->pin_DataA(), lsig->pin(0));\n      connect(powr->pin_DataB(), rsig->pin(0));\n\n      netvector_t*osig_vec = new netvector_t(expr_type(), width-1, 0);\n      osig_vec->set_signed(has_sign());\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      connect(powr->pin_Result(), osig->pin(0));\n\n      return osig;\n}\n\nNetNet* NetEBMult::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet *lsig=0, *rsig=0;\n      unsigned width;\n      bool real_args=false;\n      if (process_binary_args(des, scope, root, left_, right_, lsig, rsig,\n                              real_args)) {\n\t    return 0;\n      }\n\n      if (real_args) width = 1;\n      else width = expr_width();\n\n      NetMult*mult = new NetMult(scope, scope->local_symbol(),\n\t\t\t\t width,\n\t\t\t\t lsig->vector_width(),\n\t\t\t\t rsig->vector_width());\n      mult->set_line(*this);\n      des->add_node(mult);\n\n      mult->set_signed( has_sign() );\n\n      connect(mult->pin_DataA(), lsig->pin(0));\n      connect(mult->pin_DataB(), rsig->pin(0));\n\n      netvector_t*osig_vec = new netvector_t(expr_type(), width-1, 0);\n      osig_vec->set_signed(has_sign());\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      connect(mult->pin_Result(), osig->pin(0));\n\n      return osig;\n}\n\nNetNet* NetEBDiv::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet *lsig=0, *rsig=0;\n      unsigned width;\n      bool real_args=false;\n      if (process_binary_args(des, scope, root, left_, right_, lsig, rsig,\n                              real_args)) {\n\t    return 0;\n      }\n\n      if (real_args) width = 1;\n      else width = expr_width();\n\n      netvector_t*osig_vec = new netvector_t(lsig->data_type(), width-1, 0);\n      osig_vec->set_signed(has_sign());\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      switch (op()) {\n\n\t  case '/': {\n\t\tNetDivide*div = new NetDivide(scope, scope->local_symbol(),\n\t\t\t\t\t      width,\n\t\t\t\t\t      lsig->vector_width(),\n\t\t\t\t\t      rsig->vector_width());\n\t\tdiv->set_line(*this);\n\t\tdiv->set_signed(has_sign());\n\t\tdes->add_node(div);\n\n\t\tconnect(div->pin_DataA(), lsig->pin(0));\n\t\tconnect(div->pin_DataB(), rsig->pin(0));\n\t\tconnect(div->pin_Result(),osig->pin(0));\n\t\tbreak;\n\t  }\n\n\t  case '%': {\n\t\t  /* Baseline Verilog does not support the % operator with\n\t\t     real arguments, but we allow it in our extended form. */\n\t\tif (real_args && !gn_icarus_misc_flag) {\n\t\t      cerr << get_fileline() << \": error: Modulus operator \"\n\t\t              \"may not have REAL operands.\" << endl;\n\t\t      des->errors += 1;\n\t\t      return 0;\n\t\t}\n\t\tNetModulo*div = new NetModulo(scope, scope->local_symbol(),\n\t\t\t\t\t      width,\n\t\t\t\t\t      lsig->vector_width(),\n\t\t\t\t\t      rsig->vector_width());\n\t\tdiv->set_line(*this);\n\t\tdiv->set_signed(has_sign());\n\t\tdes->add_node(div);\n\n\t\tconnect(div->pin_DataA(), lsig->pin(0));\n\t\tconnect(div->pin_DataB(), rsig->pin(0));\n\t\tconnect(div->pin_Result(),osig->pin(0));\n\t\tbreak;\n\t  }\n\n\t  default: {\n\t\tcerr << get_fileline() << \": internal error: \"\n\t\t     << \"NetEBDiv has unexpected op() code: \"\n\t\t     << op() << endl;\n\t\tdes->errors += 1;\n\n\t\tdelete osig;\n\t\treturn 0;\n\t  }\n      }\n\n      return osig;\n}\n\nNetNet* NetEBLogic::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet*lsig = left_->synthesize(des, scope, root);\n      NetNet*rsig = right_->synthesize(des, scope, root);\n\n      if (lsig == 0 || rsig == 0) return 0;\n\n        /* Any real value should have already been converted to a bit value. */\n      if (lsig->data_type() == IVL_VT_REAL ||\n          rsig->data_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t         << human_readable_op(op_)\n\t         << \" is missing real to bit conversion.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetLogic*olog;\n      perm_string oname = scope->local_symbol();\n\n\t/* Create the logic OR/AND gate. This has a single bit output,\n\t * with single bit inputs for the two operands. */\n      switch (op()) {\n\tcase 'a':\n\t    olog = new NetLogic(scope, oname, 3, NetLogic::AND, 1, true);\n\t    break;\n\tcase 'o':\n\t    olog = new NetLogic(scope, oname, 3, NetLogic::OR, 1, true);\n\t    break;\n\tcase 'q':\n\t    olog = new NetLogic(scope, oname, 3, NetLogic::IMPL, 1, true);\n\t    break;\n\tcase 'Q':\n\t    olog = new NetLogic(scope, oname, 3, NetLogic::EQUIV, 1, true);\n\t    break;\n\tdefault:\n\t    cerr << get_fileline() << \": sorry: \"\n\t         << human_readable_op(op_)\n\t         << \" is not currently supported.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n      olog->set_line(*this);\n      des->add_node(olog);\n\n      netvector_t*osig_tmp = new netvector_t(expr_type());\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_tmp);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      connect(osig->pin(0), olog->pin(0));\n\n\t/* The left and right operands have already been reduced to a\n\t * single bit value, so just connect then to the logic gate. */\n      ivl_assert(*this, lsig->pin_count() == 1);\n      connect(lsig->pin(0), olog->pin(1));\n\n      ivl_assert(*this, rsig->pin_count() == 1);\n      connect(rsig->pin(0), olog->pin(2));\n\n      return osig;\n}\n\nNetNet* NetEBShift::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      eval_expr(right_);\n\n      NetNet*lsig = left_->synthesize(des, scope, root);\n\n      if (lsig == 0) return 0;\n\n        /* Cannot shift a real values. */\n      if (lsig->data_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: shift operator (\"\n\t         << human_readable_op(op_)\n\t         << \") cannot shift a real values.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      const bool right_flag  = op_ == 'r' || op_ == 'R';\n      const bool signed_flag = has_sign() && op_ == 'R';\n\n\t/* Detect the special case where the shift amount is\n\t   constant. Evaluate the shift amount, and simply reconnect\n\t   the left operand to the output, but shifted. */\n      if (NetEConst*rcon = dynamic_cast<NetEConst*>(right_)) {\n\t    verinum shift_v = rcon->value();\n\t    long shift = shift_v.as_long();\n\n\t    if (right_flag)\n\t\t  shift = 0-shift;\n\n\t    if (shift == 0)\n\t\t  return lsig;\n\n\t    netvector_t*osig_vec = new netvector_t(expr_type(), expr_width()-1,0);\n\t    NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t     NetNet::IMPLICIT, osig_vec);\n\t    osig->set_line(*this);\n\t    osig->local_flag(true);\n\n\t      // ushift is the amount of pad created by the shift.\n\t    unsigned long ushift = shift>=0? shift : -shift;\n\t    ivl_assert(*this, ushift < osig->vector_width());\n\n\t      // part_width is the bits of the vector that survive the shift.\n\t    unsigned long part_width = osig->vector_width() - ushift;\n\n\t      // Create a part select to reduce the width of the lsig\n\t      // to the amount left by the shift.\n\t    NetPartSelect*psel = new NetPartSelect(lsig, shift<0? ushift : 0,\n\t\t\t\t\t\t   part_width,\n\t\t\t\t\t\t   NetPartSelect::VP,\n\t                                           signed_flag && right_flag);\n\t    psel->set_line(*this);\n\t    des->add_node(psel);\n\n\t    netvector_t*psig_vec = new netvector_t(expr_type(), part_width-1, 0);\n\t    NetNet*psig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t     NetNet::IMPLICIT, psig_vec);\n\t    psig->set_line(*this);\n\t    psig->local_flag(true);\n\t    connect(psig->pin(0), psel->pin(0));\n\n\t      // Handle the special case of a signed right shift. In\n\t      // this case, use the NetSignExtend device to pad the\n\t      // result to the desired width.\n\t    if (signed_flag && right_flag) {\n\t\t  NetSignExtend*pad = new NetSignExtend(scope, scope->local_symbol(),\n\t\t\t\t\t\t\tosig->vector_width());\n\t\t  pad->set_line(*this);\n\t\t  des->add_node(pad);\n\n\t\t  connect(pad->pin(1), psig->pin(0));\n\t\t  connect(pad->pin(0), osig->pin(0));\n\t\t  return osig;\n\t    }\n\n\t      // Other cases are handled by zero-extending on the\n\t      // proper end.\n\t    verinum znum (verinum::V0, ushift, true);\n\t    NetConst*zcon = new NetConst(scope, scope->local_symbol(),\n\t\t\t\t\t znum);\n\t    des->add_node(zcon);\n\n\t    netvector_t*zsig_vec = new netvector_t(osig->data_type(),\n\t\t\t\t\t\t   znum.len()-1, 0);\n\t    NetNet*zsig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t     NetNet::WIRE, zsig_vec);\n\t    zsig->set_line(*this);\n\t    zsig->local_flag(true);\n\t    connect(zcon->pin(0), zsig->pin(0));\n\n\t    NetConcat*ccat = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t\t   osig->vector_width(), 2);\n\t    ccat->set_line(*this);\n\t    des->add_node(ccat);\n\n\t    connect(ccat->pin(0), osig->pin(0));\n\t    if (shift > 0) {\n\t\t    // Left shift.\n\t\t  connect(ccat->pin(1), zsig->pin(0));\n\t\t  connect(ccat->pin(2), psig->pin(0));\n\t    } else {\n\t\t    // Right shift\n\t\t  connect(ccat->pin(1), psig->pin(0));\n\t\t  connect(ccat->pin(2), zsig->pin(0));\n\t    }\n\n\t    return osig;\n      }\n\n      NetNet*rsig = right_->synthesize(des, scope, root);\n\n      if (rsig == 0) return 0;\n\n      netvector_t*osig_vec = new netvector_t(expr_type(), expr_width()-1, 0);\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      NetCLShift*dev = new NetCLShift(scope, scope->local_symbol(),\n\t\t\t\t      osig->vector_width(),\n\t\t\t\t      rsig->vector_width(),\n\t\t\t\t      right_flag, signed_flag);\n      dev->set_line(*this);\n      des->add_node(dev);\n\n      connect(dev->pin_Result(), osig->pin(0));\n\n      ivl_assert(*this, lsig->vector_width() == dev->width());\n      connect(dev->pin_Data(), lsig->pin(0));\n\n      connect(dev->pin_Distance(), rsig->pin(0));\n\n      return osig;\n}\n\nNetNet* NetEConcat::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n\t/* First, synthesize the operands. */\n      unsigned num_parms = parms_.size();\n      NetNet**tmp = new NetNet*[parms_.size()];\n      bool flag = true;\n      ivl_variable_type_t data_type = IVL_VT_NO_TYPE;\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\t    if (parms_[idx]->expr_width() == 0) {\n\t\t    /* We need to synthesize a replication of zero. */\n\t\t  tmp[idx] = parms_[idx]->synthesize(des, scope, root);\n\t\t  ivl_assert(*this, tmp[idx] == 0);\n\t\t  num_parms -= 1;\n\t    } else {\n\t\t  tmp[idx] = parms_[idx]->synthesize(des, scope, root);\n\t\t  if (tmp[idx] == 0) flag = false;\n\t\t    /* Set the data type to the first one found. */\n\t\t  switch (data_type) {\n\t\t      case IVL_VT_NO_TYPE:\n\t\t\tdata_type = tmp[idx]->data_type();\n\t\t\tbreak;\n\t\t      case IVL_VT_BOOL:\n\t\t\tif (tmp[idx]->data_type()==IVL_VT_LOGIC)\n\t\t\t      data_type = IVL_VT_LOGIC;\n\t\t\tbreak;\n\t\t      default:\n\t\t\tbreak;\n\t\t  }\n\t    }\n      }\n\n      if (flag == false) {\n\t    delete[]tmp;\n\t    return 0;\n      }\n\n      ivl_assert(*this, data_type != IVL_VT_NO_TYPE);\n\n\t/* If this is a replication of zero just return 0. */\n      if (expr_width() == 0) {\n\t    delete[]tmp;\n\t    return 0;\n      }\n\n      NetNet *osig = nullptr;\n\n      if (num_parms != 1) {\n\t      /* Make a NetNet object to carry the output vector. */\n\t    auto osig_vec = new netvector_t(data_type, expr_width() / repeat() - 1, 0);\n\t    osig = new NetNet(scope, scope->local_symbol(), NetNet::IMPLICIT,\n\t\t\t      osig_vec);\n\t    osig->set_line(*this);\n\t    osig->local_flag(true);\n\n\t    auto cncat = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t       osig->vector_width(), num_parms);\n\t    cncat->set_line(*this);\n\t    des->add_node(cncat);\n\t    connect(cncat->pin(0), osig->pin(0));\n\n\t    unsigned count_input_width = 0;\n\t    unsigned cur_pin = 1;\n\t    for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\t\t  unsigned concat_item = parms_.size()-idx-1;\n\t\t  if (tmp[concat_item] == 0) continue;\n\t\t  connect(cncat->pin(cur_pin), tmp[concat_item]->pin(0));\n\t\t  cur_pin += 1;\n\t\t  count_input_width += tmp[concat_item]->vector_width();\n\t    }\n\n\t    if (count_input_width != osig->vector_width()) {\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"NetEConcat input width = \" << count_input_width\n\t\t       << \", expecting \" << osig->vector_width()\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t    }\n      } else {\n\t    /* There is exactly one input signal */\n\t    for (unsigned idx = 0; idx < parms_.size(); idx++) {\n\t\t  if (tmp[idx]) {\n\t\t\tosig = tmp[idx];\n\t\t\tbreak;\n\t\t  }\n\t    }\n\t    ivl_assert(*this, osig);\n\t    if (osig->get_signed()) {\n\t\t    // A concatenation is always unsigned, so make a new signal to\n\t\t    // reflect this.\n\t\t  NetNet*isig = osig;\n\t\t  auto osig_vec = new netvector_t(data_type, isig->vector_width() - 1, 0);\n\t\t  osig = new NetNet(scope, scope->local_symbol(), NetNet::IMPLICIT,\n\t\t\t\t    osig_vec);\n\t\t  osig->set_line(*this);\n\t\t  osig->local_flag(true);\n\t\t  connect(isig->pin(0), osig->pin(0));\n\t    }\n      }\n\n      if (repeat() != 1) {\n\t    auto rep = new NetReplicate(scope, scope->local_symbol(),\n\t\t\t\t\texpr_width(), repeat());\n\t    rep->set_line(*this);\n\t    des->add_node(rep);\n\t    connect(rep->pin(1), osig->pin(0));\n\n\t    auto osig_vec = new netvector_t(data_type, expr_width() - 1, 0);\n\t    osig = new NetNet(scope, scope->local_symbol(), NetNet::IMPLICIT,\n\t\t\t      osig_vec);\n\t    osig->set_line(*this);\n\t    osig->local_flag(true);\n\t    connect(rep->pin(0), osig->pin(0));\n      }\n\n      delete[]tmp;\n      return osig;\n}\n\nNetNet *NetEArrayPattern::synthesize(Design *des, NetScope *scope, NetExpr *root)\n{\n      const netsarray_t *array_type = dynamic_cast<const netsarray_t *>(net_type());\n      ivl_assert(*this, array_type);\n\n      if (items_.empty())\n\t    return nullptr;\n\n      bool failed = false;\n\n      std::unique_ptr<NetNet*[]> nets(new NetNet*[items_.size()]);\n      for (unsigned int idx = 0; idx < items_.size(); idx++) {\n\t    if (!items_[idx]) {\n\t\t  failed = true;\n\t\t  continue;\n\t    }\n\t    nets[idx] = items_[idx]->synthesize(des, scope, root);\n\t    if (!nets[idx])\n\t\t  failed = true;\n      }\n\n      if (failed)\n\t    return nullptr;\n\n      // Infer which dimension we are in for nested assignment patterns based on\n      // the dimensions of the element.\n      size_t dim = nets[0]->unpacked_dims().size() + 1;\n      const auto &type_dims = array_type->static_dimensions();\n\n      if (dim > type_dims.size())\n\t    return nullptr;\n\n      netranges_t dims(type_dims.end() - dim, type_dims.end());\n\n      if (dims.front().width() != items_.size())\n\t    return nullptr;\n\n      perm_string path = scope->local_symbol();\n      NetNet *osig = new NetNet(scope, path, NetNet::IMPLICIT, dims,\n\t\t\t        array_type->element_type());\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      unsigned int opin = 0;\n      for (unsigned int idx = 0; idx < items_.size(); idx++) {\n\t    for (unsigned int net_pin = 0; net_pin < nets[idx]->pin_count(); net_pin++)\n\t\t  connect(osig->pin(opin++), nets[idx]->pin(net_pin));\n      }\n\n      return osig;\n}\n\nNetNet* NetEConst::synthesize(Design*des, NetScope*scope, NetExpr*)\n{\n      perm_string path = scope->local_symbol();\n      unsigned width=expr_width();\n      if (width == 0) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t         << \"Found a zero width constant!\" << endl;\n\t    return 0;\n      }\n\n      netvector_t*osig_vec = new netvector_t(expr_type(), width-1, 0);\n      osig_vec->set_signed(has_sign());\n      NetNet*osig = new NetNet(scope, path, NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      NetConst*con = new NetConst(scope, scope->local_symbol(), value());\n      con->set_line(*this);\n      des->add_node(con);\n\n      connect(osig->pin(0), con->pin(0));\n      return osig;\n}\n\n/*\n* Create a NetLiteral object to represent real valued constants.\n*/\nNetNet* NetECReal::synthesize(Design*des, NetScope*scope, NetExpr*)\n{\n      perm_string path = scope->local_symbol();\n\n      netvector_t*osig_vec = new netvector_t(IVL_VT_REAL);\n      osig_vec->set_signed(has_sign());\n      NetNet*osig = new NetNet(scope, path, NetNet::WIRE, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      NetLiteral*con = new NetLiteral(scope, scope->local_symbol(), value_);\n      con->set_line(*this);\n      des->add_node(con);\n\n      connect(osig->pin(0), con->pin(0));\n      return osig;\n}\n\n/*\n * The bitwise unary logic operator (there is only one) is turned\n * into discrete gates just as easily as the binary ones above.\n */\nNetNet* NetEUBits::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet*isig = expr_->synthesize(des, scope, root);\n\n      if (isig == 0) return 0;\n\n      if (isig->data_type() == IVL_VT_REAL) {\n\t    cerr << get_fileline() << \": error: bit-wise negation (\"\n\t         << human_readable_op(op_)\n\t         << \") may not have a REAL operand.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      unsigned width = isig->vector_width();\n      netvector_t*osig_vec = new netvector_t(expr_type(), width-1, 0);\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      perm_string oname = scope->local_symbol();\n      NetLogic*gate;\n\n      switch (op()) {\n\t  case '~':\n\t    gate = new NetLogic(scope, oname, 2, NetLogic::NOT, width, true);\n\t    gate->set_line(*this);\n\t    break;\n\t  default:\n\t    gate = NULL;\n\t    ivl_assert(*this, 0);\n      }\n\n      connect(osig->pin(0), gate->pin(0));\n      connect(isig->pin(0), gate->pin(1));\n\n      des->add_node(gate);\n\n      return osig;\n}\n\nNetNet* NetEUnary::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      if (op_ == '+')\n\t    return expr_->synthesize(des, scope, root);\n\n      if (op_ == '-') {\n\t    NetNet*sig = expr_->synthesize(des, scope, root);\n\t    sig = sub_net_from(des, scope, 0, sig);\n\t    return sig;\n      }\n\n      if (op_ == 'm') {\n\t    NetNet*sub = expr_->synthesize(des, scope, root);\n\t    if (expr_->has_sign() == false)\n\t\t  return sub;\n\n\t    netvector_t*sig_vec = new netvector_t(sub->data_type(),\n\t\t\t\t\t\t  sub->vector_width()-1, 0);\n\t    NetNet*sig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::WIRE, sig_vec);\n\t    sig->set_line(*this);\n\t    sig->local_flag(true);\n\n\t    NetAbs*tmp = new NetAbs(scope, scope->local_symbol(), sub->vector_width());\n\t    tmp->set_line(*this);\n\t    des->add_node(tmp);\n\n\t    connect(tmp->pin(1), sub->pin(0));\n\t    connect(tmp->pin(0), sig->pin(0));\n\t    return sig;\n      }\n\n      cerr << get_fileline() << \": internal error: \"\n\t   << \"NetEUnary::synthesize cannot handle op_=\" << op_ << endl;\n      des->errors += 1;\n      return expr_->synthesize(des, scope, root);\n}\n\nNetNet* NetEUReduce::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet*isig = expr_->synthesize(des, scope, root);\n\n      if (isig == 0) return 0;\n\n      if (isig->data_type() == IVL_VT_REAL) {\n\t    if (op() == '!') {\n\t\t  cerr << get_fileline() << \": sorry: ! is currently \"\n\t\t          \"unsupported for real values.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return 0;\n\t    }\n\t    cerr << get_fileline() << \": error: reduction operator (\"\n\t         << human_readable_op(op_)\n\t         << \") may not have a REAL operand.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      NetUReduce::TYPE rtype = NetUReduce::NONE;\n\n      switch (op()) {\n\t  case 'N':\n\t  case '!':\n\t    rtype = NetUReduce::NOR;\n\t    break;\n\t  case '&':\n\t    rtype = NetUReduce::AND;\n\t    break;\n\t  case '|':\n\t    rtype = NetUReduce::OR;\n\t    break;\n\t  case '^':\n\t    rtype = NetUReduce::XOR;\n\t    break;\n\t  case 'A':\n\t    rtype = NetUReduce::NAND;\n\t    break;\n\t  case 'X':\n\t    rtype = NetUReduce::XNOR;\n\t    break;\n\t  default:\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Unable to synthesize \" << *this << \".\" << endl;\n\t    return 0;\n      }\n\n      NetUReduce*gate = new NetUReduce(scope, scope->local_symbol(),\n\t\t\t\t       rtype, isig->vector_width());\n      gate->set_line(*this);\n      des->add_node(gate);\n\n      netvector_t*osig_vec = new netvector_t(expr_type());\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      connect(gate->pin(0), osig->pin(0));\n      for (unsigned idx = 0 ;  idx < isig->pin_count() ;  idx += 1)\n\t    connect(gate->pin(1+idx), isig->pin(idx));\n\n      return osig;\n}\n\nNetNet* NetECast::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetNet*isig = expr_->synthesize(des, scope, root);\n\n      if (isig == 0) return 0;\n\n      switch (op()) {\n\t  case 'v':\n\t    isig = cast_to_int4(des, scope, isig, expr_width());\n\t    break;\n\t  case '2':\n\t    isig = cast_to_int2(des, scope, isig, expr_width());\n\t    break;\n\t  case 'r':\n\t    isig = cast_to_real(des, scope, isig);\n\t    break;\n\t  default:\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \"Unable to synthesize \" << *this << \".\" << endl;\n\t    return 0;\n      }\n\n      return isig;\n}\n\n/*\n * Turn a part/bit select expression into gates.\n * We know some things about the expression that elaboration enforces\n * for us:\n *\n * - Expression elaboration already converted the offset expression into\n * canonical form, so we don't have to worry about that here.\n */\nNetNet* NetESelect::synthesize(Design *des, NetScope*scope, NetExpr*root)\n{\n\n      NetNet*sub = expr_->synthesize(des, scope, root);\n\n      if (sub == 0) return 0;\n\n\t// Detect the special case that there is a base expression and\n\t// it is constant. In this case we can generate fixed part selects.\n      if (NetEConst*base_const = dynamic_cast<NetEConst*>(base_)) {\n\t    verinum base_tmp = base_const->value();\n\t    unsigned select_width = expr_width();\n\n\t      // Return 'bx for a constant undefined selections.\n\t    if (!base_tmp.is_defined()) {\n\t\t  NetNet*result = make_const_x(des, scope, select_width);\n\t\t  result->set_line(*this);\n\t\t  return result;\n\t    }\n\n\t    long base_val = base_tmp.as_long();\n\t    unsigned below_width = 0;\n\n\t      // Any below X bits?\n\t    NetNet*below = 0;\n\t    if (base_val < 0) {\n\t\t  below_width = abs(base_val);\n\t\t  base_val = 0;\n\t\t  if (below_width > select_width) {\n\t\t\tbelow_width = select_width;\n\t\t\tselect_width = 0;\n\t\t  } else {\n\t\t\tselect_width -= below_width;\n\t\t  }\n\n\t\t  below = make_const_x(des, scope, below_width);\n\t\t  below->set_line(*this);\n\t\t    // All the selected bits are below the signal.\n\t\t  if (select_width == 0) return below;\n\t    }\n\n\t      // Any above bits?\n\t    NetNet*above = 0;\n\t    if ((unsigned)base_val+select_width > sub->vector_width()) {\n\t\t  if (base_val > (long)sub->vector_width()) {\n\t\t\tselect_width = 0;\n\t\t  } else {\n\t\t\tselect_width = sub->vector_width() - base_val;\n\t\t  }\n\t\t  ivl_assert(*this, expr_width() > (select_width+below_width));\n\t\t  unsigned above_width = expr_width() - select_width - below_width;\n\n\t\t  above = make_const_x(des, scope, above_width);\n\t\t  above->set_line(*this);\n\t\t    // All the selected bits are above the signal.\n\t\t  if (select_width == 0) return above;\n\t    }\n\n\t      // Make the make part select.\n\t    NetPartSelect*sel = new NetPartSelect(sub, base_val, select_width,\n\t\t\t\t\t\t  NetPartSelect::VP);\n\t    des->add_node(sel);\n\n\t    ivl_assert(*this, select_width > 0);\n\t    netvector_t*tmp_vec = new netvector_t(sub->data_type(),\n\t\t\t\t\t\t  select_width-1, 0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::WIRE, tmp_vec);\n\t    tmp->set_line(*this);\n\t    tmp->local_flag(true);\n\t    connect(sel->pin(0), tmp->pin(0));\n\n\t    unsigned concat_count = 1;\n\t    if (above)\n\t\t  concat_count += 1;\n\t    if (below)\n\t\t  concat_count += 1;\n\t    if (concat_count > 1) {\n\t\t  NetConcat*cat = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t\t\texpr_width(), concat_count);\n\t\t  cat->set_line(*this);\n\t\t  des->add_node(cat);\n\t\t  if (below) {\n\t\t\tconnect(cat->pin(1), below->pin(0));\n\t\t\tconnect(cat->pin(2), tmp->pin(0));\n\t\t  } else {\n\t\t\tconnect(cat->pin(1), tmp->pin(0));\n\t\t  }\n\t\t  if (above) {\n\t\t\tconnect(cat->pin(concat_count), above->pin(0));\n\t\t  }\n\n\t\t  tmp_vec = new netvector_t(sub->data_type(), expr_width()-1, 0);\n\t\t  tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t   NetNet::WIRE, tmp_vec);\n\t\t  tmp->set_line(*this);\n\t\t  tmp->local_flag(true);\n\t\t  connect(cat->pin(0), tmp->pin(0));\n\t    }\n\t    return tmp;\n      }\n\n\t// This handles the case that the NetESelect exists to do an\n\t// actual part/bit select. Generate a NetPartSelect object to\n\t// do the work, and replace \"sub\" with the selected output.\n      if (base_ != 0) {\n\t    NetNet*off = base_->synthesize(des, scope, root);\n\n\t    NetPartSelect*sel = new NetPartSelect(sub, off, expr_width(),\n\t                                          base_->has_sign());\n\t    sel->set_line(*this);\n\t    des->add_node(sel);\n\n\t    netvector_t*tmp_vec = new netvector_t(sub->data_type(),\n\t\t\t\t\t\t  expr_width()-1, 0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::IMPLICIT, tmp_vec);\n\t    tmp->local_flag(true);\n\t    tmp->set_line(*this);\n\t    sub = tmp;\n\t    connect(sub->pin(0), sel->pin(0));\n      }\n\n\n\t// Now look for the case that the NetESelect actually exists\n\t// to change the width of the expression. (i.e. to do\n\t// padding.) If this was for an actual part select that at\n\t// this point the output vector_width is exactly right, and we\n\t// are done.\n      if (sub->vector_width() == expr_width()) {\n\t    if (sub->get_signed() == has_sign())\n\t\t  return sub;\n\n\t      // If the signal and expression type don't match, we\n\t      // need to add an intermediate signal to reflect that.\n\n\t    auto tmp_vec = new netvector_t(sub->data_type(), sub->vector_width() - 1, 0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(), NetNet::IMPLICIT,\n\t\t\t\t    tmp_vec);\n\t    tmp->set_line(*this);\n\t    tmp->local_flag(true);\n\t    connect(sub->pin(0), tmp->pin(0));\n\t    return tmp;\n      }\n\n      netvector_t*net_vec = new netvector_t(expr_type(), expr_width()-1, 0);\n      net_vec->set_signed(has_sign());\n      NetNet*net = new NetNet(scope, scope->local_symbol(),\n\t\t\t      NetNet::IMPLICIT, net_vec);\n      net->set_line(*this);\n      net->local_flag(true);\n\n\t// It may still happen that the expression is wider than the selection,\n\t// and there was no part select created earlier (size casting).\n      if(expr_width() < sub->vector_width()) {\n\t    NetPartSelect*sel = new NetPartSelect(sub, 0, expr_width(),\n                                                  NetPartSelect::VP, has_sign());\n\t    sel->set_line(*this);\n\t    des->add_node(sel);\n\n\t    connect(net->pin(0), sel->pin(0));\n\n\t// The vector_width is not exactly right, so the source is\n\t// probably asking for padding. Create nodes to do sign\n\t// extension or 0 extension, depending on the has_sign() mode\n\t// of the expression.\n\n      } else if (has_sign()) {\n\t    NetSignExtend*pad = new NetSignExtend(scope,\n\t\t\t\t\t\t  scope->local_symbol(),\n\t\t\t\t\t\t  expr_width());\n\t    pad->set_line(*this);\n\t    des->add_node(pad);\n\n\t    connect(pad->pin(1), sub->pin(0));\n\t    connect(pad->pin(0), net->pin(0));\n\n      } else {\n\n\t    NetConcat*cat = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t\t  expr_width(), 2);\n\t    cat->set_line(*this);\n\t    des->add_node(cat);\n\n\t    unsigned pad_width = expr_width() - sub->vector_width();\n\t    verinum pad((uint64_t)0, pad_width);\n\t    NetConst*con = new NetConst(scope, scope->local_symbol(),\n\t\t\t\t\tpad);\n\t    con->set_line(*this);\n\t    des->add_node(con);\n\n\t    netvector_t*tmp_vec = new netvector_t(expr_type(), pad_width-1, 0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::IMPLICIT, tmp_vec);\n\t    tmp->set_line(*this);\n\t    tmp->local_flag(true);\n\t    connect(tmp->pin(0), con->pin(0));\n\n\t    connect(cat->pin(0), net->pin(0));\n\t    connect(cat->pin(1), sub->pin(0));\n\t    connect(cat->pin(2), con->pin(0));\n      }\n\n      return net;\n}\n\n/*\n * Synthesize a ?: operator as a NetMux device. Connect the condition\n * expression to the select input, then connect the true and false\n * expressions to the B and A inputs. This way, when the select input\n * is one, the B input, which is the true expression, is selected.\n */\nNetNet* NetETernary::synthesize(Design *des, NetScope*scope, NetExpr*root)\n{\n      NetNet*csig = cond_->synthesize(des, scope, root),\n            *tsig = true_val_->synthesize(des, scope, root),\n            *fsig = false_val_->synthesize(des, scope, root);\n\n      if (csig == 0 || tsig == 0 || fsig == 0) return 0;\n\n      if (! NetETernary::test_operand_compat(tsig->data_type(),fsig->data_type())) {\n\t    cerr << get_fileline() << \": internal error: \"\n\t\t << \" True and False clauses of ternary expression \"\n\t\t << \" have incompatible types.\" << endl;\n\t    cerr << get_fileline() << \":      : True  clause is: \"\n\t         << tsig->data_type()\n\t\t << \" (\" << true_val_->expr_type() << \"): \"\n\t\t << *true_val_ << endl;\n\t    cerr << get_fileline() << \":      : False clause is: \"\n\t         << fsig->data_type()\n\t\t << \" (\" << false_val_->expr_type() << \"): \"\n\t\t << *false_val_ << endl;\n\t    des->errors += 1;\n\t    return 0;\n      } else if (tsig->data_type() == IVL_VT_NO_TYPE) {\n\t    cerr << get_fileline() << \": internal error: True and False \"\n\t            \"clauses of ternary both have NO TYPE.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      perm_string path = csig->scope()->local_symbol();\n\n      ivl_assert(*this, csig->vector_width() == 1);\n\n      unsigned width=expr_width();\n      netvector_t*osig_vec = new netvector_t(expr_type(), width-1, 0);\n      NetNet*osig = new NetNet(csig->scope(), path, NetNet::IMPLICIT, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n\t/* Make sure the types match. */\n      if (expr_type() == IVL_VT_REAL) {\n\t    tsig = cast_to_real(des, scope, tsig);\n\t    fsig = cast_to_real(des, scope, fsig);\n\n      }\n\n\t/* Make sure both value operands are the right width. */\n      if (type_is_vectorable(expr_type())) {\n\t    tsig = crop_to_width(des, pad_to_width(des, tsig, width, *this), width);\n\t    fsig = crop_to_width(des, pad_to_width(des, fsig, width, *this), width);\n\t    ivl_assert(*this, width == tsig->vector_width());\n\t    ivl_assert(*this, width == fsig->vector_width());\n      }\n\n\n      perm_string oname = csig->scope()->local_symbol();\n      NetMux *mux = new NetMux(csig->scope(), oname, width,\n\t\t\t       2, csig->vector_width());\n      mux->set_line(*this);\n      connect(tsig->pin(0), mux->pin_Data(1));\n      connect(fsig->pin(0), mux->pin_Data(0));\n      connect(osig->pin(0), mux->pin_Result());\n      connect(csig->pin(0), mux->pin_Sel());\n      des->add_node(mux);\n\n      return osig;\n}\n\n/*\n * When synthesizing a signal expression, it is usually fine to simply\n * return the NetNet that it refers to. If this is an array word though,\n * a bit more work needs to be done. Return a temporary that represents\n * the selected word.\n */\nNetNet* NetESignal::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n\t// If this is a synthesis with a specific value for the\n\t// signal, then replace it (here) with a constant value.\n      if (net_->scope()==scope && net_->name()==scope->genvar_tmp) {\n\t    netvector_t*tmp_vec = new netvector_t(net_->data_type(),\n\t\t\t\t\t\t  net_->vector_width()-1, 0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::IMPLICIT, tmp_vec);\n\t    tmp->set_line(*this);\n\t    tmp->local_flag(true);\n\t    verinum tmp_val ((uint64_t)scope->genvar_tmp_val, net_->vector_width());\n\t    NetConst*tmp_const = new NetConst(scope, scope->local_symbol(), tmp_val);\n\t    tmp_const->set_line(*this);\n\t    des->add_node(tmp_const);\n\n\t    connect(tmp->pin(0), tmp_const->pin(0));\n\t    return tmp;\n      }\n\n      if (word_ == 0) {\n\t    if (net_->get_signed() == has_sign())\n\t\t  return net_;\n\n\t      // If the signal has been cast to a different type, we\n\t      // need to add an intermediate signal to reflect that.\n\n\t    auto tmp_vec = new netvector_t(net_->data_type(), net_->vector_width() - 1, 0);\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(), NetNet::IMPLICIT,\n\t\t\t\t    tmp_vec);\n\t    tmp->set_line(*this);\n\t    tmp->local_flag(true);\n\t    connect(net_->pin(0), tmp->pin(0));\n\t    return tmp;\n      }\n\n      netvector_t*tmp_vec = new netvector_t(net_->data_type(),\n\t\t\t\t\t    net_->vector_width()-1, 0);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t      NetNet::IMPLICIT, tmp_vec);\n      tmp->set_line(*this);\n      tmp->local_flag(true);\n\n\t// For NetExpr objects, the word index is already converted to\n\t// a canonical (lsb==0) address. Just use the index directly.\n\n      if (NetEConst*index_co = dynamic_cast<NetEConst*> (word_)) {\n\n\t    long index = index_co->value().as_long();\n\t    connect(tmp->pin(0), net_->pin(index));\n\n      } else {\n\t    unsigned selwid = word_->expr_width();\n\n\t    NetArrayDq*mux = new NetArrayDq(scope, scope->local_symbol(),\n\t\t\t\t\t    net_, selwid);\n\t    mux->set_line(*this);\n\t    des->add_node(mux);\n\n\t    NetNet*index_net = word_->synthesize(des, scope, root);\n\t    connect(mux->pin_Address(), index_net->pin(0));\n\n\t    connect(tmp->pin(0), mux->pin_Result());\n      }\n      return tmp;\n}\n\nstatic NetEvWait* make_func_trigger(Design*des, NetScope*scope, NetExpr*root)\n{\n      NetEvWait*trigger = 0;\n\n      NexusSet*nset = root->nex_input(false);\n      if (nset && (nset->size() > 0)) {\n            NetEvent*ev = new NetEvent(scope->local_symbol());\n            ev->set_line(*root);\n            ev->local_flag(true);\n\n            NetEvProbe*pr = new NetEvProbe(scope, scope->local_symbol(),\n                                           ev, NetEvProbe::ANYEDGE,\n                                           nset->size());\n            pr->set_line(*root);\n            for (unsigned idx = 0 ;  idx < nset->size() ;  idx += 1)\n                  connect(nset->at(idx).lnk, pr->pin(idx));\n\n            des->add_node(pr);\n\n            scope->add_event(ev);\n\n            trigger = new NetEvWait(0);\n            trigger->set_line(*root);\n            trigger->add_event(ev);\n      }\n      delete nset;\n\n      return trigger;\n}\n\nNetNet* NetESFunc::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n\n      const struct sfunc_return_type*def = lookup_sys_func(name_);\n\n        /* We cannot use the default value for system functions in a\n         * continuous assignment since the function name is NULL. */\n      if (def == 0 || def->name == 0) {\n\t    cerr << get_fileline() << \": error: System function \"\n\t\t << name_ << \" not defined in system \"\n\t\t \"table or SFT file(s).\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: Net system function \"\n\t\t << name_ << \" returns \" << def->type << endl;\n      }\n\n      NetEvWait*trigger = 0;\n      if (parms_.empty()) {\n            trigger = make_func_trigger(des, scope, root);\n      }\n\n      NetSysFunc*net = new NetSysFunc(scope, scope->local_symbol(),\n\t\t\t\t      def, 1+parms_.size(), trigger);\n      net->set_line(*this);\n      des->add_node(net);\n\n      netvector_t*osig_vec = new netvector_t(def->type, def->wid-1, 0);\n      osig_vec->set_signed(def->type==IVL_VT_REAL? true : false);\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::WIRE, osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n\n      connect(net->pin(0), osig->pin(0));\n\n      unsigned errors = 0;\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\t    NetNet*tmp = parms_[idx]->synthesize(des, scope, root);\n\t    if (tmp == 0) {\n\t\t  cerr << get_fileline() << \": error: Unable to elaborate \"\n\t\t       << \"argument \" << idx << \" of call to \" << name_ <<\n\t\t\t\".\" << endl;\n\t\t  errors += 1;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\n\t    connect(net->pin(1+idx), tmp->pin(0));\n      }\n\n      if (errors > 0) return 0;\n\n      return osig;\n}\n\nNetNet* NetEUFunc::synthesize(Design*des, NetScope*scope, NetExpr*root)\n{\n      vector<NetNet*> eparms (parms_.size());\n\n        /* Synthesize the arguments. */\n      bool errors = false;\n      for (unsigned idx = 0; idx < eparms.size(); idx += 1) {\n\t    if (dynamic_cast<NetEEvent*> (parms_[idx])) {\n\t\t  errors = true;\n\t\t  continue;\n\t    }\n\t    NetNet*tmp = parms_[idx]->synthesize(des, scope, root);\n\t    if (tmp == 0) {\n\t\t  cerr << get_fileline() << \": error: Unable to synthesize \"\n\t\t          \"port \" << idx << \" of call to \"\n\t\t       << func_->basename() << \".\" << endl;\n\t\t  errors = true;\n\t\t  des->errors += 1;\n\t\t  continue;\n\t    }\n\t    eparms[idx] = tmp;\n      }\n      if (errors) return 0;\n\n      NetEvWait*trigger = 0;\n      if (gn_strict_ca_eval_flag) {\n              /* Ideally we would only do this for functions that have hidden\n                 dependencies or side effects. Once constant functions are\n                 implemented, we may be able to reuse some code to achieve\n                 this. */\n            trigger = make_func_trigger(des, scope, root);\n      }\n\n      NetUserFunc*net = new NetUserFunc(scope_, scope_->local_symbol(), func_,\n                                        trigger);\n      net->set_line(*this);\n      des->add_node(net);\n\n        /* Create an output signal and connect it to the function. */\n      netvector_t*osig_vec = new netvector_t(result_sig_->expr_type(),\n\t\t\t\t\t     result_sig_->vector_width()-1, 0);\n      NetNet*osig = new NetNet(scope_, scope_->local_symbol(), NetNet::WIRE,\n                               osig_vec);\n      osig->set_line(*this);\n      osig->local_flag(true);\n      connect(net->pin(0), osig->pin(0));\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetEUFunc::synthesize: \"\n\t\t << \"result_sig_->vector_width()=\" << result_sig_->vector_width()\n\t\t << \", osig->vector_width()=\" << osig->vector_width() << endl;\n      }\n\n        /* Connect the pins to the arguments. */\n      NetFuncDef*def = func_->func_def();\n      for (unsigned idx = 0; idx < eparms.size(); idx += 1) {\n\t    unsigned width = def->port(idx)->vector_width();\n\t    NetNet*tmp;\n\t    if (eparms[idx]->get_signed()) {\n\t\t  tmp = pad_to_width_signed(des, eparms[idx], width, *this);\n\t    } else {\n\t\t  tmp = pad_to_width(des, eparms[idx], width, *this);\n\t    }\n\t    NetNet*tmpc = crop_to_width(des, tmp, width);\n\t    connect(net->pin(idx+1), tmpc->pin(0));\n      }\n\n      return osig;\n}\n"
        },
        {
          "name": "functor.cc",
          "type": "blob",
          "size": 6.39453125,
          "content": "/*\n * Copyright (c) 1999-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  \"functor.h\"\n# include  \"netlist.h\"\n\nusing namespace std;\n\nfunctor_t::~functor_t()\n{\n}\n\nvoid functor_t::event(Design*, NetEvent*)\n{\n}\n\nvoid functor_t::signal(Design*, NetNet*)\n{\n}\n\nvoid functor_t::process(Design*, NetProcTop*)\n{\n}\n\nvoid functor_t::lpm_abs(Design*, NetAbs*)\n{\n}\n\nvoid functor_t::lpm_add_sub(Design*, NetAddSub*)\n{\n}\n\nvoid functor_t::lpm_compare(Design*, const NetCompare*)\n{\n}\n\nvoid functor_t::lpm_concat(Design*, NetConcat*)\n{\n}\n\nvoid functor_t::lpm_const(Design*, NetConst*)\n{\n}\n\nvoid functor_t::lpm_divide(Design*, NetDivide*)\n{\n}\n\nvoid functor_t::lpm_literal(Design*, NetLiteral*)\n{\n}\n\nvoid functor_t::lpm_modulo(Design*, NetModulo*)\n{\n}\n\nvoid functor_t::lpm_ff(Design*, NetFF*)\n{\n}\n\nvoid functor_t::lpm_latch(Design*, NetLatch*)\n{\n}\n\nvoid functor_t::lpm_logic(Design*, NetLogic*)\n{\n}\n\nvoid functor_t::lpm_mult(Design*, NetMult*)\n{\n}\n\nvoid functor_t::lpm_mux(Design*, NetMux*)\n{\n}\n\nvoid functor_t::lpm_part_select(Design*, NetPartSelect*)\n{\n}\n\nvoid functor_t::lpm_pow(Design*, NetPow*)\n{\n}\n\nvoid functor_t::sign_extend(Design*, NetSignExtend*)\n{\n}\n\nvoid functor_t::lpm_substitute(Design*, NetSubstitute*)\n{\n}\n\nvoid functor_t::lpm_ureduce(Design*, NetUReduce*)\n{\n}\n\n\nvoid NetScope::run_functor(Design*des, functor_t*fun)\n{\n      for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t ; cur != children_.end() ; ++ cur )\n\t    cur->second->run_functor(des, fun);\n\n      for (NetEvent*cur = events_ ;  cur ;  /* */) {\n\t    NetEvent*tmp = cur;\n\t    cur = cur->snext_;\n\t    fun->event(des, tmp);\n      }\n\n\t// apply to signals. Each iteration, allow for the possibility\n\t// that the current signal deletes itself.\n\n      signals_map_iter_t cur = signals_map_.begin();\n      while (cur != signals_map_.end()) {\n\t    signals_map_iter_t tmp = cur;\n\t    ++ cur;\n\t    fun->signal(des, tmp->second);\n      }\n}\n\nvoid Design::functor(functor_t*fun)\n{\n\t// Scan the scopes\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin();\n\t   scope != root_scopes_.end(); ++ scope )\n\t    (*scope)->run_functor(this, fun);\n\n\t// apply to processes\n      procs_idx_ = procs_;\n      while (procs_idx_) {\n\t    NetProcTop*idx = procs_idx_;\n\t    procs_idx_ = idx->next_;\n\t    fun->process(this, idx);\n      }\n\n\t// apply to nodes\n      if (nodes_) {\n\t    assert(nodes_functor_cur_ == 0);\n\t    assert(nodes_functor_nxt_ == 0);\n\n\t      /* Scan the circular list of nodes, starting with the\n\t\t front of the list.\n\n\t\t This loop interacts with the Design::del_node method\n\t\t so that the functor is free to delete any nodes it\n\t\t choose. The destructors of the NetNode objects call\n\t\t the del_node method, which checks with the\n\t\t nodes_functor_* members, to keep the iterator\n\t\t operating safely. */\n\t    nodes_functor_cur_ = nodes_;\n\t    do {\n\t\t  nodes_functor_nxt_ = nodes_functor_cur_->node_next_;\n\t\t  nodes_functor_cur_->functor_node(this, fun);\n\n\t\t  if (nodes_functor_nxt_ == 0)\n\t\t\tbreak;\n\n\t\t  nodes_functor_cur_ = nodes_functor_nxt_;\n\t    } while (nodes_functor_cur_ != nodes_);\n\t    nodes_functor_cur_ = 0;\n\t    nodes_functor_nxt_ = 0;\n\n      }\n}\n\n\nvoid NetNode::functor_node(Design*, functor_t*)\n{\n}\n\nvoid NetAbs::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_abs(des, this);\n}\n\nvoid NetAddSub::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_add_sub(des, this);\n}\n\nvoid NetCompare::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_compare(des, this);\n}\n\nvoid NetConcat::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_concat(des, this);\n}\n\nvoid NetConst::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_const(des, this);\n}\n\nvoid NetDivide::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_divide(des, this);\n}\n\nvoid NetFF::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_ff(des, this);\n}\n\nvoid NetLatch::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_latch(des, this);\n}\n\nvoid NetLiteral::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_literal(des, this);\n}\n\nvoid NetLogic::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_logic(des, this);\n}\n\nvoid NetModulo::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_modulo(des, this);\n}\n\nvoid NetMult::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_mult(des, this);\n}\n\nvoid NetMux::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_mux(des, this);\n}\n\nvoid NetPartSelect::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_part_select(des, this);\n}\n\nvoid NetPow::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_pow(des, this);\n}\n\nvoid NetSignExtend::functor_node(Design*des, functor_t*fun)\n{\n      fun->sign_extend(des, this);\n}\n\nvoid NetSubstitute::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_substitute(des, this);\n}\n\nvoid NetUReduce::functor_node(Design*des, functor_t*fun)\n{\n      fun->lpm_ureduce(des, this);\n}\n\nproc_match_t::~proc_match_t()\n{\n}\n\nint NetProc::match_proc(proc_match_t*)\n{\n      return 0;\n}\n\nint proc_match_t::assign(NetAssign*)\n{\n      return 0;\n}\n\nint NetAssign::match_proc(proc_match_t*that)\n{\n      return that->assign(this);\n}\n\nint proc_match_t::assign_nb(NetAssignNB*)\n{\n      return 0;\n}\n\nint NetAssignNB::match_proc(proc_match_t*that)\n{\n      return that->assign_nb(this);\n}\n\nint proc_match_t::block(NetBlock*)\n{\n      return 0;\n}\n\nint NetBlock::match_proc(proc_match_t*that)\n{\n      return that->block(this);\n}\n\nint proc_match_t::condit(NetCondit*)\n{\n      return 0;\n}\n\nint NetCondit::match_proc(proc_match_t*that)\n{\n      return that->condit(this);\n}\n\nint NetEvWait::match_proc(proc_match_t*that)\n{\n      return that->event_wait(this);\n}\n\nint proc_match_t::event_wait(NetEvWait*)\n{\n      return 0;\n}\n"
        },
        {
          "name": "functor.h",
          "type": "blob",
          "size": 4.0400390625,
          "content": "#ifndef IVL_functor_H\n#define IVL_functor_H\n/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n/*\n * The functor is an object that can be applied to a design to\n * transform it. This is different from the target_t, which can only\n * scan the design but not transform it in any way.\n *\n * When a functor it scanning a process, signal or node, the functor\n * is free to manipulate the list by deleting items, including the\n * node being scanned. The Design class scanner knows how to handle\n * the situation. However, if objects are added to the netlist, there\n * is no guarantee that object will be scanned unless the functor is\n * rerun.\n */\n\nclass Design;\nclass NetNet;\nclass NetProcTop;\n\nstruct functor_t {\n      virtual ~functor_t();\n\n\t/* Events are scanned here. */\n      virtual void event(Design*des, class NetEvent*);\n\n\t/* This is called once for each signal in the design. */\n      virtual void signal(Design*des, NetNet*);\n\n\t/* This method is called for each process in the design. */\n      virtual void process(Design*des, NetProcTop*);\n\n\t/* This method is called for each structural abs(). */\n      virtual void lpm_abs(Design*des, class NetAbs*);\n\n\t/* This method is called for each structural adder. */\n      virtual void lpm_add_sub(Design*des, class NetAddSub*);\n\n\t/* This method is called for each structural comparator. */\n      virtual void lpm_compare(Design*des, const class NetCompare*);\n\n\t/* This method is called for each structural concatenation. */\n      virtual void lpm_concat(Design*des, class NetConcat*);\n\n\t/* This method is called for each structural constant. */\n      virtual void lpm_const(Design*des, class NetConst*);\n\n\t/* This method is called for each structural constant. */\n      virtual void lpm_divide(Design*des, class NetDivide*);\n\n\t/* Constant literals. */\n      virtual void lpm_literal(Design*des, class NetLiteral*);\n\n\t/* This method is called for each structural constant. */\n      virtual void lpm_modulo(Design*des, class NetModulo*);\n\n\t/* This method is called for each FF in the design. */\n      virtual void lpm_ff(Design*des, class NetFF*);\n\n\t/* This method is called for each LATCH in the design. */\n      virtual void lpm_latch(Design*des, class NetLatch*);\n\n\t/* Handle LPM combinational logic devices. */\n      virtual void lpm_logic(Design*des, class NetLogic*);\n\n\t/* This method is called for each multiplier. */\n      virtual void lpm_mult(Design*des, class NetMult*);\n\n\t/* This method is called for each MUX. */\n      virtual void lpm_mux(Design*des, class NetMux*);\n\n      virtual void lpm_part_select(Design*des, class NetPartSelect*);\n\n\t/* This method is called for each power. */\n      virtual void lpm_pow(Design*des, class NetPow*);\n\n\t/* This method is called for each part substitute. */\n      virtual void lpm_substitute(Design*des, class NetSubstitute*);\n\n\t/* This method is called for each unary reduction gate. */\n      virtual void lpm_ureduce(Design*des, class NetUReduce*);\n\n      virtual void sign_extend(Design*des, class NetSignExtend*);\n};\n\nstruct proc_match_t {\n      virtual ~proc_match_t();\n\n      virtual int assign(class NetAssign*);\n      virtual int assign_nb(class NetAssignNB*);\n      virtual int condit(class NetCondit*);\n      virtual int event_wait(class NetEvWait*);\n      virtual int block(class NetBlock*);\n};\n\n#endif /* IVL_functor_H */\n"
        },
        {
          "name": "install-sh",
          "type": "blob",
          "size": 4.6533203125,
          "content": "#! /bin/sh\n#\n# install - install a program, script, or datafile\n# This comes from X11R5.\n#\n# Calling this script install-sh is preferred over install.sh, to prevent\n# `make' implicit rules from creating a file called install from it\n# when there is no Makefile.\n#\n# This script is compatible with the BSD install script, but was written\n# from scratch.\n#\n\n\n# set DOITPROG to echo to test this script\n\n# Don't use :- since 4.3BSD and earlier shells don't like it.\ndoit=\"${DOITPROG-}\"\n\n\n# put in absolute paths if you don't have them in your path; or use env. vars.\n\nmvprog=\"${MVPROG-mv}\"\ncpprog=\"${CPPROG-cp}\"\nchmodprog=\"${CHMODPROG-chmod}\"\nchownprog=\"${CHOWNPROG-chown}\"\nchgrpprog=\"${CHGRPPROG-chgrp}\"\nstripprog=\"${STRIPPROG-strip}\"\nrmprog=\"${RMPROG-rm}\"\nmkdirprog=\"${MKDIRPROG-mkdir}\"\n\ntransformbasename=\"\"\ntransform_arg=\"\"\ninstcmd=\"$mvprog\"\nchmodcmd=\"$chmodprog 0755\"\nchowncmd=\"\"\nchgrpcmd=\"\"\nstripcmd=\"\"\nrmcmd=\"$rmprog -f\"\nmvcmd=\"$mvprog\"\nsrc=\"\"\ndst=\"\"\ndir_arg=\"\"\n\nwhile [ x\"$1\" != x ]; do\n    case $1 in\n\t-c) instcmd=\"$cpprog\"\n\t    shift\n\t    continue;;\n\n\t-d) dir_arg=true\n\t    shift\n\t    continue;;\n\n\t-m) chmodcmd=\"$chmodprog $2\"\n\t    shift\n\t    shift\n\t    continue;;\n\n\t-o) chowncmd=\"$chownprog $2\"\n\t    shift\n\t    shift\n\t    continue;;\n\n\t-g) chgrpcmd=\"$chgrpprog $2\"\n\t    shift\n\t    shift\n\t    continue;;\n\n\t-s) stripcmd=\"$stripprog\"\n\t    shift\n\t    continue;;\n\n\t-t=*) transformarg=`echo $1 | sed 's/-t=//'`\n\t    shift\n\t    continue;;\n\n\t-b=*) transformbasename=`echo $1 | sed 's/-b=//'`\n\t    shift\n\t    continue;;\n\n\t*)  if [ x\"$src\" = x ]\n\t    then\n\t\tsrc=$1\n\t    else\n\t\t# this colon is to work around a 386BSD /bin/sh bug\n\t\t:\n\t\tdst=$1\n\t    fi\n\t    shift\n\t    continue;;\n    esac\ndone\n\nif [ x\"$src\" = x ]\nthen\n\techo \"install:\tno input file specified\"\n\texit 1\nelse\n\ttrue\nfi\n\nif [ x\"$dir_arg\" != x ]; then\n\tdst=$src\n\tsrc=\"\"\n\n\tif [ -d $dst ]; then\n\t\tinstcmd=:\n\telse\n\t\tinstcmd=mkdir\n\tfi\nelse\n\n# Waiting for this to be detected by the \"$instcmd $src $dsttmp\" command\n# might cause directories to be created, which would be especially bad\n# if $src (and thus $dsttmp) contains '*'.\n\n\tif [ -f $src -o -d $src ]\n\tthen\n\t\ttrue\n\telse\n\t\techo \"install:  $src does not exist\"\n\t\texit 1\n\tfi\n\n\tif [ x\"$dst\" = x ]\n\tthen\n\t\techo \"install:\tno destination specified\"\n\t\texit 1\n\telse\n\t\ttrue\n\tfi\n\n# If destination is a directory, append the input filename; if your system\n# does not like double slashes in filenames, you may need to add some logic\n\n\tif [ -d $dst ]\n\tthen\n\t\tdst=\"$dst\"/`basename $src`\n\telse\n\t\ttrue\n\tfi\nfi\n\n## this sed command emulates the dirname command\ndstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`\n\n# Make sure that the destination directory exists.\n#  this part is taken from Noah Friedman's mkinstalldirs script\n\n# Skip lots of stat calls in the usual case.\nif [ ! -d \"$dstdir\" ]; then\ndefaultIFS='\n'\nIFS=\"${IFS-${defaultIFS}}\"\n\noIFS=\"${IFS}\"\n# Some sh's can't handle IFS=/ for some reason.\nIFS='%'\nset - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`\nIFS=\"${oIFS}\"\n\npathcomp=''\n\nwhile [ $# -ne 0 ] ; do\n\tpathcomp=\"${pathcomp}${1}\"\n\tshift\n\n\tif [ ! -d \"${pathcomp}\" ] ;\n        then\n\t\t$mkdirprog \"${pathcomp}\"\n\telse\n\t\ttrue\n\tfi\n\n\tpathcomp=\"${pathcomp}/\"\ndone\nfi\n\nif [ x\"$dir_arg\" != x ]\nthen\n\t$doit $instcmd $dst &&\n\n\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dst; else true ; fi &&\n\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&\n\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dst; else true ; fi &&\n\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dst; else true ; fi\nelse\n\n# If we're going to rename the final executable, determine the name now.\n\n\tif [ x\"$transformarg\" = x ]\n\tthen\n\t\tdstfile=`basename $dst`\n\telse\n\t\tdstfile=`basename $dst $transformbasename |\n\t\t\tsed $transformarg`$transformbasename\n\tfi\n\n# don't allow the sed command to completely eliminate the filename\n\n\tif [ x\"$dstfile\" = x ]\n\tthen\n\t\tdstfile=`basename $dst`\n\telse\n\t\ttrue\n\tfi\n\n# Make a temp file name in the proper directory.\n\n\tdsttmp=$dstdir/#inst.$$#\n\n# Move or copy the file name to the temp name\n\n\t$doit $instcmd $src $dsttmp &&\n\n\ttrap \"rm -f ${dsttmp}\" 0 &&\n\n# and set any options; do chmod last to preserve setuid bits\n\n# If any of these fail, we abort the whole thing.  If we want to\n# ignore errors from any of these, just make sure not to ignore\n# errors from the above \"$doit $instcmd $src $dsttmp\" command.\n\n\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&\n\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&\n\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&\n\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&\n\n# Now rename the file to the real destination.\n\n\t$doit $rmcmd -f $dstdir/$dstfile &&\n\t$doit $mvcmd $dsttmp $dstdir/$dstfile\n\nfi &&\n\n\nexit 0\n"
        },
        {
          "name": "iverilog-vpi.man.in",
          "type": "blob",
          "size": 3.623046875,
          "content": ".TH iverilog-vpi 1 \"Jan 20th, 2024\" \"\" \"Version %M.%n%E\"\n.SH NAME\niverilog-vpi - Compile front end for VPI modules\n\n.SH SYNOPSIS\n.B iverilog-vpi\n[options]\n\\fIsourcefile\\fP...\n\n.SH DESCRIPTION\n.PP\n\\fIiverilog\\-vpi\\fP is a tool to simplify the compilation of VPI\nmodules for use with Icarus Verilog. It takes on the command line a\nlist of C or C++ source files, and generates as output a linked VPI\nmodule. See the \\fBvvp\\fP(1) man page for a description of how the\nlinked module is loaded by a simulation.\n\nBy default the output is named after the first source file. For\nexample, if the first source file is named \\fIfoo.c\\fP, the output\nbecomes \\fIfoo.vpi\\fP.\n\n.SH OPTIONS\n\\fIiverilog\\-vpi\\fP accepts the following options:\n.TP 8\n.B -l\\fIlibrary\\fP\nInclude the named library in the link of the VPI module. This allows\nVPI modules to further reference external libraries.\n\n.TP 8\n.B -L\\fIdirectory\\fP\nAdd \\fIdirectory\\fP to the list of directories that will be searched\nfor library files.\n\n.TP 8\n.B -I\\fIdirectory\\fP\nAdd \\fIdirectory\\fP to the list of directories that will be searched\nfor header files.\n\n.TP 8\n.B -D\\fIdefine\\fP\nDefine a macro named \\fIdefine\\fP.\n\n.TP 8\n.B --name=\\fIname\\fP\nNormally, the output VPI module will be named after the first source\nfile passed to the command. This flag sets the name (without the .vpi\nsuffix) of the output vpi module.\n\n.SH \"PC-ONLY OPTIONS\"\n\nWhen built as a native Windows program (using the MinGW toolchain),\nby default \\fIiverilog\\-vpi\\fP will attempt to locate the MinGW tools\nneeded to compile a VPI module on the system path (as set by the PATH\nenvironment variable). As an alternative, the user may specify the\nlocation of the MinGW tools via the following option.\n\n.TP 8\n.B -mingw=\\fIpath\\fP\nTell the program the root of the MinGW compiler tool suite. The\n\\fBvvp\\fP runtime is compiled with this compiler, and this is the\ncompiler that \\fIiverilog\\-vpi\\fP expects to use to compile your\nsource code. If this option accompanies a list of files, it will\napply to the current build only. If this option is provided on its\nown, \\fIiverilog\\-vpi\\fP will save the \\fIpath\\fP in the registry\nand use that path in preference to the system path for subsequent\noperations, avoiding the need to specify it on the command line\nevery time.\n\n.SH \"INFORMATIONAL OPTIONS\"\n\n\\fIiverilog\\-vpi\\fP includes additional flags to let Makefile gurus\npeek at the configuration of the \\fIiverilog\\fP installation.  This way,\nMakefiles can be written that handle complex VPI builds natively, and\nwithout hard-coding values that depend on the system and installation.\nIf used at all, these options must be used one at a time, and without\nany other options or directives.\n\n.TP 8\n.B --install-dir\nPrint the install directory for VPI modules.\n\n.TP 8\n.B --cflags\nPrint the compiler flags (CFLAGS or CXXFLAGS) needed to compile source\ncode destined for a VPI module.\n\n.TP 8\n.B --ldflags\nPrint the linker flags (LDFLAGS) needed to link a VPI module.\n\n.TP 8\n.B --ldlibs\nPrint the libraries (LDLIBS) needed to link a VPI module.\n\n.P\nExample GNU makefile that takes advantage of these flags:\n.IP \"\" 4\nCFLAGS = \\-Wall \\-O $(CFLAGS_$@)\n.br\nVPI_CFLAGS := $(shell iverilog-vpi \\-\\-cflags)\n.br\nCFLAGS_messagev.o = $(VPI_CFLAGS)\n.br\nCFLAGS_fifo.o = $(VPI_CFLAGS)\n.br\nmessagev.o fifo.o: transport.h\n.br\nmessagev.vpi: messagev.o fifo.o\n.br\n\tiverilog-vpi $^\n\n.SH \"AUTHOR\"\n.nf\nSteve Williams (steve@icarus.com)\n\n.SH SEE ALSO\niverilog(1), vvp(1),\n.BR \"<https://steveicarus.github.io/iverilog/>\",\n.BR \"<http://mingw-w64.yaxm.org/>\",\n\n.SH COPYRIGHT\n.nf\nCopyright \\(co  2002\\-2024 Stephen Williams\n\nThis document can be freely redistributed according to the terms of the\nGNU General Public License version 2.0\n"
        },
        {
          "name": "iverilog-vpi.sh",
          "type": "blob",
          "size": 3.0654296875,
          "content": "#!/bin/sh\n#\n#    This source code is free software; you can redistribute it\n#    and/or modify it in source code form under the terms of the GNU\n#    Library General Public License as published by the Free Software\n#    Foundation; either version 2 of the License, or (at your option)\n#    any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU Library General Public License for more details.\n#\n#    You should have received a copy of the GNU Library General Public\n#    License along with this program; if not, write to the Free\n#    Software Foundation, Inc.,\n#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#    Boston, MA 02111-1307, USA\n#\n\n# These are the variables used for compiling files\nCC=\"@IVCC@\"\nCXX=\"@IVCXX@\"\nCFLAGS=\"@PIC@ @IVCFLAGS@ -I@INCLUDEDIR@\"\nCXXFLAGS=\"@PIC@ @IVCXXFLAGS@ -I@INCLUDEDIR@\"\n\nSUFFIX=@SUFFIX@\n\n# These are used for linking...\nLD=$CC\nLDFLAGS=\"@IVCTARGETFLAGS@ @SHARED@ -L@LIBDIR@\"\nLDLIBS=\"-lveriuser$SUFFIX -lvpi$SUFFIX\"\n\nCCSRC=\nCXSRC=\nOBJ=\nLIB=\nLIBDIR=\nOUT=\nINCOPT=\nDEFS=\n\n# --\n# parse the command line switches. This collects the source files\n# and precompiled object files, and maybe user libraries. As we are\n# going, guess an output file name.\nfor parm\ndo\n    case $parm\n    in\n\n    *.c) CCSRC=\"$CCSRC $parm\"\n         if [ x$OUT = x ]; then\n\t    OUT=`basename $parm .c`\n\t fi\n\t ;;\n\n    *.cc) CXSRC=\"$CXSRC $parm\"\n\t LD=$CXX\n         if [ x$OUT = x ]; then\n\t    OUT=`basename $parm .cc`\n\t fi\n\t ;;\n\n    *.cpp) CXSRC=\"$CXSRC $parm\"\n\t LD=$CXX\n         if [ x$OUT = x ]; then\n\t    OUT=`basename $parm .cpp`\n\t fi\n\t ;;\n\n    *.o) OBJ=\"$OBJ $parm\"\n         if [ x$OUT = x ]; then\n\t    OUT=`basename $parm .o`\n\t fi\n\t ;;\n\n    --name=*)\n\t OUT=`echo $parm | cut -b8-`\n\t ;;\n\n    -l*) LIB=\"$LIB $parm\"\n\t ;;\n\n    -L*) LIBDIR=\"$LIBDIR $parm\"\n\t ;;\n\n    -I*) INCOPT=\"$INCOPT $parm\"\n\t ;;\n\n    -D*) DEFS=\"$DEFS $parm\"\n\t ;;\n\n    --cflags)\n\t echo \"$CFLAGS\"\n\t exit;\n\t ;;\n\n    --ccflags)\n\t echo \"$CXXFLAGS\"\n\t exit;\n\t ;;\n\n    --ldflags)\n\t echo \"$LDFLAGS\"\n\t exit;\n\t ;;\n\n    --ldlibs)\n\t echo \"$LDLIBS\"\n\t exit;\n\t ;;\n\n    --install-dir)\n\t echo \"@LIBDIR@/ivl$SUFFIX\"\n\t exit\n\t ;;\n    esac\n\ndone\n\nif [ x$OUT = x ]; then\n    echo \"Usage: $0 [src and obj files]...\" 1>&2\n    exit 0\nfi\n\n# Put the .vpi on the result file.\nOUT=$OUT\".vpi\"\n\ncompile_errors=0\n\n# Compile all the source files into object files\nfor src in $CCSRC\ndo\n    base=`basename $src .c`\n    obj=$base\".o\"\n\n    echo \"Compiling $src...\"\n    $CC -c -o $obj $DEFS $CFLAGS $INCOPT $src || compile_errors=`expr $compile_errors + 1`\n    OBJ=\"$OBJ $obj\"\ndone\n\nfor src in $CXSRC\ndo\n    base=`basename $src .cc`\n    obj=$base\".o\"\n\n    echo \"Compiling $src...\"\n    $CXX -c -o $obj $DEFS $CXXFLAGS $INCOPT $src || compile_errors=`expr $compile_errors + 1`\n    OBJ=\"$OBJ $obj\"\ndone\n\nif test $compile_errors -gt 0\nthen\n    echo \"$0: $compile_errors file(s) failed to compile.\"\n    exit $compile_errors\nfi\n\necho \"Making $OUT from $OBJ...\"\nexec $LD -o $OUT $LDFLAGS $LIBDIR $OBJ $LIB $LDLIBS\n"
        },
        {
          "name": "ivl.def",
          "type": "blob",
          "size": 5.564453125,
          "content": "EXPORTS\n\nivl_branch_island\nivl_branch_terminal\n\nivl_design_const\nivl_design_consts\nivl_design_discipline\nivl_design_disciplines\nivl_design_delay_sel\nivl_design_flag\nivl_design_process\nivl_design_root\nivl_design_roots\nivl_design_time_precision\n\nivl_const_bits\nivl_const_delay\nivl_const_file\nivl_const_lineno\nivl_const_nex\nivl_const_real\nivl_const_scope\nivl_const_signed\nivl_const_type\nivl_const_width\n\nivl_discipline_domain\nivl_discipline_flow\nivl_discipline_name\nivl_discipline_potential\n\nivl_enum_bits\nivl_enum_file\nivl_enum_lineno\nivl_enum_name\nivl_enum_names\nivl_enum_signed\nivl_enum_type\nivl_enum_width\n\nivl_event_any\nivl_event_basename\nivl_event_edg\nivl_event_file\nivl_event_lineno\nivl_event_name\nivl_event_nany\nivl_event_nedg\nivl_event_neg\nivl_event_nneg\nivl_event_npos\nivl_event_pos\nivl_event_scope\n\nivl_expr_type\nivl_expr_bits\nivl_expr_branch\nivl_expr_def\nivl_expr_delay_val\nivl_expr_dvalue\nivl_expr_enumtype\nivl_expr_event\nivl_expr_file\nivl_expr_lineno\nivl_expr_name\nivl_expr_nature\nivl_expr_net_type\nivl_expr_opcode\nivl_expr_oper1\nivl_expr_oper2\nivl_expr_oper3\nivl_expr_parameter\nivl_expr_parm\nivl_expr_parms\nivl_expr_property_idx\nivl_expr_repeat\nivl_expr_scope\nivl_expr_sel_type\nivl_expr_signal\nivl_expr_signed\nivl_expr_sized\nivl_expr_string\nivl_expr_uvalue\nivl_expr_value\nivl_expr_width\n\nivl_file_table_index\nivl_file_table_item\nivl_file_table_size\n\nivl_island_flag_set\nivl_island_flag_test\n\nivl_logic_attr\nivl_logic_attr_cnt\nivl_logic_attr_val\nivl_logic_basename\nivl_logic_delay\nivl_logic_drive0\nivl_logic_drive1\nivl_logic_file\nivl_logic_is_cassign\nivl_logic_lineno\nivl_logic_name\nivl_logic_pin\nivl_logic_pins\nivl_logic_scope\nivl_logic_type\nivl_logic_udp\nivl_logic_width\nivl_logic_port_buffer\n\nivl_lpm_array\nivl_lpm_aset_value\nivl_lpm_async_clr\nivl_lpm_async_set\nivl_lpm_base\nivl_lpm_basename\nivl_lpm_clk\nivl_lpm_data\nivl_lpm_datab\nivl_lpm_define\nivl_lpm_delay\nivl_lpm_drive0\nivl_lpm_drive1\nivl_lpm_enable\nivl_lpm_file\nivl_lpm_lineno\nivl_lpm_name\nivl_lpm_negedge\nivl_lpm_q\nivl_lpm_scope\nivl_lpm_select\nivl_lpm_selects\nivl_lpm_signed\nivl_lpm_size\nivl_lpm_sset_value\nivl_lpm_string\nivl_lpm_sync_clr\nivl_lpm_sync_set\nivl_lpm_trigger\nivl_lpm_type\nivl_lpm_width\n\nivl_lval_idx\nivl_lval_mux\nivl_lval_nest\nivl_lval_part_off\nivl_lval_property_idx\nivl_lval_sel_type\nivl_lval_sig\nivl_lval_width\n\nivl_nature_name\n\nivl_nexus_get_private\nivl_nexus_name\nivl_nexus_ptrs\nivl_nexus_ptr\nivl_nexus_set_private\n\nivl_nexus_ptr_branch\nivl_nexus_ptr_con\nivl_nexus_ptr_drive0\nivl_nexus_ptr_drive1\nivl_nexus_ptr_pin\nivl_nexus_ptr_lpm\nivl_nexus_ptr_log\nivl_nexus_ptr_sig\nivl_nexus_ptr_switch\n\nivl_parameter_basename\nivl_parameter_expr\nivl_parameter_file\nivl_parameter_is_type\nivl_parameter_lineno\nivl_parameter_local\nivl_parameter_lsb\nivl_parameter_msb\nivl_parameter_scope\nivl_parameter_signed\nivl_parameter_width\n\nivl_path_condit\nivl_path_delay\nivl_path_is_condit\nivl_path_is_parallel\nivl_path_scope\nivl_path_source\nivl_path_source_negedge\nivl_path_source_posedge\n\nivl_process_analog\nivl_process_attr_cnt\nivl_process_attr_val\nivl_process_file\nivl_process_lineno\nivl_process_scope\nivl_process_stmt\nivl_process_type\n\nivl_scope_attr_cnt\nivl_scope_attr_val\nivl_scope_basename\nivl_scope_children\nivl_scope_child\nivl_scope_childs\nivl_scope_class\nivl_scope_classes\nivl_scope_def\nivl_scope_def_file\nivl_scope_def_lineno\nivl_scope_enumerate\nivl_scope_enumerates\nivl_scope_event\nivl_scope_events\nivl_scope_file\nivl_scope_func_type\nivl_scope_func_signed\nivl_scope_func_width\nivl_scope_is_auto\nivl_scope_is_cell\nivl_scope_lineno\nivl_scope_logs\nivl_scope_log\nivl_scope_lpms\nivl_scope_lpm\nivl_scope_mod_module_ports\nivl_scope_mod_module_port_name\nivl_scope_mod_module_port_type\nivl_scope_mod_module_port_width\nivl_scope_mod_module_port_buffer\nivl_scope_mod_port\nivl_scope_name\nivl_scope_param\nivl_scope_params\nivl_scope_parent\nivl_scope_port\nivl_scope_ports\nivl_scope_sigs\nivl_scope_sig\nivl_scope_switch\nivl_scope_switches\nivl_scope_time_precision\nivl_scope_time_units\nivl_scope_type\nivl_scope_tname\n\nivl_signal_array_addr_swapped\nivl_signal_array_base\nivl_signal_array_count\nivl_signal_attr\nivl_signal_attr_cnt\nivl_signal_attr_val\nivl_signal_basename\nivl_signal_data_type\nivl_signal_dimensions\nivl_signal_discipline\nivl_signal_file\nivl_signal_forced_net\nivl_signal_integer\nivl_signal_lineno\nivl_signal_local\nivl_signal_lsb\nivl_signal_msb\nivl_signal_name\nivl_signal_net_type\nivl_signal_nex\nivl_signal_npath\nivl_signal_packed_dimensions\nivl_signal_packed_lsb\nivl_signal_packed_msb\nivl_signal_path\nivl_signal_port\nivl_signal_scope\nivl_signal_signed\nivl_signal_type\nivl_signal_width\n\nivl_statement_type\n\nivl_stmt_block_count\nivl_stmt_block_scope\nivl_stmt_block_stmt\nivl_stmt_call\nivl_stmt_case_count\nivl_stmt_case_expr\nivl_stmt_case_quality\nivl_stmt_case_stmt\nivl_stmt_cond_expr\nivl_stmt_cond_false\nivl_stmt_cond_true\nivl_stmt_delay_expr\nivl_stmt_delay_val\nivl_stmt_events\nivl_stmt_file\nivl_stmt_flow_control\nivl_stmt_init_stmt\nivl_stmt_lexp\nivl_stmt_lineno\nivl_stmt_lval\nivl_stmt_lvals\nivl_stmt_lwidth\nivl_stmt_name\nivl_stmt_needs_t0_trigger\nivl_stmt_nevent\nivl_stmt_opcode\nivl_stmt_parm\nivl_stmt_parm_count\nivl_stmt_rval\nivl_stmt_sfunc_as_task\nivl_stmt_step_stmt\nivl_stmt_sub_stmt\n\nivl_switch_a\nivl_switch_b\nivl_switch_basename\nivl_switch_delay\nivl_switch_enable\nivl_switch_file\nivl_switch_island\nivl_switch_lineno\nivl_switch_offset\nivl_switch_part\nivl_switch_scope\nivl_switch_type\nivl_switch_width\n\nivl_type_base\nivl_type_element\nivl_type_name\nivl_type_packed_dimensions\nivl_type_packed_lsb\nivl_type_packed_msb\nivl_type_packed_width\nivl_type_prop_name\nivl_type_prop_type\nivl_type_properties\nivl_type_signed\n\nivl_udp_init\nivl_udp_file\nivl_udp_lineno\nivl_udp_name\nivl_udp_nin\nivl_udp_port\nivl_udp_row\nivl_udp_rows\nivl_udp_sequ\n"
        },
        {
          "name": "ivl_alloc.h",
          "type": "blob",
          "size": 2.65234375,
          "content": "#ifndef IVL_ivl_alloc_H\n#define IVL_ivl_alloc_H\n/*\n *  Copyright (C) 2010-2014  Cary R. (cygcary@yahoo.com)\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifdef __cplusplus\n#  include <cstdlib>\n#  include <cstdio>\n#else\n#  include <stdlib.h>\n#  include <stdio.h>\n#endif\n\n#if defined(__GNUC__)\n/*\n * Define a safer version of malloc().\n */\n\n#define malloc(__ivl_size) \\\n({ \\\n\t/* To be safe we only evaluate the argument once. */ \\\n      size_t __ivl_lsize = __ivl_size; \\\n      void *__ivl_rtn = malloc(__ivl_lsize); \\\n\t/* If we run out of memory then exit with a message. */ \\\n      if ((__ivl_rtn == NULL) && (__ivl_lsize != 0)) { \\\n\t    fprintf(stderr, \"%s:%d: Error: malloc() ran out of memory.\\n\", \\\n\t                    __FILE__, __LINE__); \\\n\t    exit(1); \\\n      } \\\n      __ivl_rtn; \\\n})\n\n/*\n * Define a safer version of realloc().\n */\n\n#define realloc(__ivl_ptr, __ivl_size) \\\n({ \\\n\t/* To be safe we only evaluate the arguments once. */ \\\n      void *__ivl_lptr = __ivl_ptr; \\\n      size_t __ivl_lsize = __ivl_size; \\\n      void *__ivl_rtn = realloc(__ivl_lptr, __ivl_lsize); \\\n\t/* If we run out of memory then exit with a message. */ \\\n      if ((__ivl_rtn == NULL) && (__ivl_lsize != 0)) { \\\n\t    fprintf(stderr, \"%s:%d: Error: realloc() ran out of memory.\\n\", \\\n\t                    __FILE__, __LINE__); \\\n\t    free(__ivl_lptr); \\\n\t    exit(1); \\\n      } \\\n      __ivl_rtn; \\\n})\n\n/*\n * Define a safer version of calloc().\n */\n\n#define calloc(__ivl_count, __ivl_size) \\\n({ \\\n\t/* To be safe we only evaluate the arguments once. */ \\\n      size_t __ivl_lcount = __ivl_count; \\\n      size_t __ivl_lsize = __ivl_size; \\\n      void *__ivl_rtn = calloc(__ivl_lcount, __ivl_lsize); \\\n\t/* If we run out of memory then exit with a message. */ \\\n      if ((__ivl_rtn == NULL) && (__ivl_lcount != 0) && (__ivl_lsize != 0)) { \\\n\t    fprintf(stderr, \"%s:%d: Error: calloc() ran out of memory.\\n\", \\\n\t                    __FILE__, __LINE__); \\\n\t    exit(1); \\\n      } \\\n      __ivl_rtn; \\\n})\n#endif\n\n#endif /* IVL_ivl_alloc_H */\n"
        },
        {
          "name": "ivl_assert.h",
          "type": "blob",
          "size": 1.2109375,
          "content": "#ifndef IVL_ivl_assert_H\n#define IVL_ivl_assert_H\n/*\n * Copyright (c) 2007-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <cstdlib>\n\n#define ivl_assert(tok, expression)  \\\n      do { \\\n\t    if (! (expression)) { \\\n\t\t  std::cerr << (tok).get_fileline() << \": assert: \" \\\n\t\t\t    << __FILE__ << \":\" << __LINE__ \\\n\t\t\t    << \": failed assertion \" << #expression << std::endl; \\\n\t\t  abort(); \\\n\t    } \\\n      } while (0)\n\n#endif /* IVL_ivl_assert_H */\n"
        },
        {
          "name": "ivl_target.h",
          "type": "blob",
          "size": 95.2607421875,
          "content": "#ifndef IVL_ivl_target_H\n#define IVL_ivl_target_H\n/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <inttypes.h>\n# include  <stddef.h>\n# include  <stdbool.h>\n\n/* Re the _CLASS define: clang++ wants this to be class to match the\n * definition, but clang (the C) compiler needs it to be a struct\n * since class is not defined in C. They are effectively both pointers\n * to an object so everything works out. */\n\n#ifdef __cplusplus\n#define _BEGIN_DECL extern \"C\" {\n#define _END_DECL }\n#define _CLASS class\n#else\n#define _BEGIN_DECL\n#define _END_DECL\n#define _CLASS struct\n#endif\n\n#ifndef __GNUC__\n# define __attribute__(x)\n#endif\n\n#if defined(__cplusplus) && defined(_MSC_VER)\n# define ENUM_UNSIGNED_INT : unsigned int\n#else\n# define ENUM_UNSIGNED_INT\n#endif\n\n_BEGIN_DECL\n\n/*\n * This header file describes the API for the loadable target\n * module. The main program can load these modules and access the\n * functions within the loaded module to implement the backend\n * behavior.\n *\n * The interface is divided into two parts: the entry points within\n * the core that are called by the module, and the entry points in\n * the module that are called by the core. It is the latter that\n * causes the module to be invoked in the first place, but most of the\n * interesting information about the design is accessed through the\n * various access functions that the modules calls into the core.\n */\n\n\n/*\n * In order to grab onto data in the design, the core passes cookies\n * to the various functions of the module. These cookies can in turn\n * be passed to access functions in the core to get more detailed\n * information.\n *\n * The following typedefs list the various cookies that may be passed\n * around.\n *\n * ivl_array_t\n *    This object represents an array that can be a memory or a net\n *    array. (They are the same from the perspective of ivl_target.h.)\n *\n * ivl_branch_t\n *    this object represents an analog branch.\n *\n * ivl_design_t\n *    This object represents the entire elaborated design. Various\n *    global properties and methods are available from this.\n *\n * ivl_event_t\n *    This object represents an event node. An event node stands for\n *    named events written explicitly in the Verilog, and net events\n *    that are implicit when @ statements are used.\n *\n * ivl_expr_t\n *    This object represents a node of an expression. If the\n *    expression has sub-expressions, they can be accessed from\n *    various method described below. The ivl_expr_type method in\n *    particular gets the type of the node in the form of an\n *    ivl_expr_type_t enumeration value.\n *\n *    Objects of this type represent expressions in processes.\n *    Structural expressions are instead treated as logic gates.\n *\n * ivl_island_t\n *    Certain types of objects may belong to islands. The island that\n *    they belong to is represented by the ivl_island_t cookie. To\n *    know if objects belong to the same island, it is sufficient to\n *    compare island cookies. If a==b, then island a is the same as\n *    island b.\n *\n * ivl_lpm_t\n *    This object is the base class for all the various LPM type\n *    device nodes. This object carries a few base properties\n *    (including a type) including a handle to the specific type.\n *\n * ivl_net_logic_t\n *    This object represents various built in logic devices. In fact,\n *    this includes just about every directional device that has a\n *    single output, including logic gates and nmos, pmos and cmos\n *    devices. There is also the occasional Icarus Verilog creation.\n *    What is common about these devices is that they are\n *    bitwise. That is, when fed a vector, they produce a vector\n *    result where each bit of the output is made only from the same\n *    bits in the vector inputs.\n *\n * ivl_nexus_t\n *    Structural links within an elaborated design are connected\n *    together at each bit. The connection point is a nexus, so pins\n *    of devices refer to an ivl_nexus_t. Furthermore, from a nexus\n *    there are backward references to all the device pins that point\n *    to it.\n *\n * ivl_parameter_t\n *    Scopes have zero or more parameter objects that represent\n *    parameters that the source defined. The parameter has a value\n *    that is fully elaborated, with defparams and other parameter\n *    overrides taken care of.\n *\n * ivl_process_t\n *    A Verilog process is represented by one of these. A process may\n *    be an \"initial\" or an \"always\" process. These come from initial\n *    or always statements from the Verilog source.\n *\n * ivl_scope_t\n *    Elaborated scopes within a design are represented by this\n *    type. Objects of this type also act as containers for scoped\n *    objects such as signals.\n *\n * ivl_statement_t\n *    Statements within processes are represented by one of these. The\n *    ivl_process_t object holds one of these, but a statement may in\n *    turn contain other statements.\n *\n * ivl_switch_t\n *    Switches are the tran/tranif devices in the design.\n *\n * -- A Note About Bit Sets --\n * Some objects hold a value as an array of bits. In these cases there\n * is some method that retrieves the width of the value and another\n * that returns a \"char*\". The latter is a pointer to the least\n * significant bit value. Bit values are represented by the characters\n * '0', '1', 'x' and 'z'. Strengths are stored elsewhere.\n *\n * -- A Note About Names --\n * The names of objects are complete, hierarchical names. That is,\n * they include the instance name of the module that contains them.\n *\n * basenames are the name of the object without the containing\n * scope. These names are unique within a scope, but not necessarily\n * throughout the design.\n */\ntypedef struct ivl_array_s    *ivl_array_t;\ntypedef struct ivl_branch_s   *ivl_branch_t;\ntypedef struct ivl_delaypath_s*ivl_delaypath_t;\ntypedef struct ivl_design_s   *ivl_design_t;\ntypedef _CLASS ivl_discipline_s*ivl_discipline_t;\ntypedef const _CLASS netenum_t*ivl_enumtype_t;\ntypedef struct ivl_event_s    *ivl_event_t;\ntypedef struct ivl_expr_s     *ivl_expr_t;\ntypedef struct ivl_island_s   *ivl_island_t;\ntypedef struct ivl_lpm_s      *ivl_lpm_t;\ntypedef struct ivl_lval_s     *ivl_lval_t;\ntypedef struct ivl_net_const_s*ivl_net_const_t;\ntypedef struct ivl_net_logic_s*ivl_net_logic_t;\ntypedef struct ivl_udp_s      *ivl_udp_t;\ntypedef _CLASS ivl_nature_s   *ivl_nature_t;\ntypedef struct ivl_net_probe_s*ivl_net_probe_t;\ntypedef struct ivl_nexus_s    *ivl_nexus_t;\ntypedef struct ivl_nexus_ptr_s*ivl_nexus_ptr_t;\ntypedef struct ivl_parameter_s*ivl_parameter_t;\ntypedef struct ivl_process_s  *ivl_process_t;\ntypedef struct ivl_scope_s    *ivl_scope_t;\ntypedef struct ivl_signal_s   *ivl_signal_t;\ntypedef struct ivl_port_info_s*ivl_port_info_t;\ntypedef struct ivl_switch_s   *ivl_switch_t;\ntypedef struct ivl_memory_s   *ivl_memory_t; //XXXX __attribute__((deprecated));\ntypedef struct ivl_statement_s*ivl_statement_t;\ntypedef const _CLASS ivl_type_s*ivl_type_t;\n\n/*\n * These are types that are defined as enumerations. These have\n * explicit values so that the binary API is a bit more resilient to\n * changes and additions to the enumerations.\n */\n\ntypedef enum ivl_dis_domain_e {\n      IVL_DIS_NONE       = 0,\n      IVL_DIS_DISCRETE   = 1,\n      IVL_DIS_CONTINUOUS = 2\n} ivl_dis_domain_t;\n\ntypedef enum ivl_drive_e ENUM_UNSIGNED_INT {\n      IVL_DR_HiZ    = 0,\n      IVL_DR_SMALL  = 1,\n      IVL_DR_MEDIUM = 2,\n      IVL_DR_WEAK   = 3,\n      IVL_DR_LARGE  = 4,\n      IVL_DR_PULL   = 5,\n      IVL_DR_STRONG = 6,\n      IVL_DR_SUPPLY = 7\n} ivl_drive_t;\n\n/* This is the type of an ivl_expr_t object. The explicit numbers\n   allow additions to the enumeration without causing values to shift\n   and incompatibilities to be introduced. */\ntypedef enum ivl_expr_type_e {\n      IVL_EX_NONE = 0,\n      IVL_EX_ARRAY = 18,\n      IVL_EX_BACCESS= 19,\n      IVL_EX_BINARY = 2,\n      IVL_EX_CONCAT = 3,\n      IVL_EX_DELAY = 20,\n      IVL_EX_ENUMTYPE = 21,\n      IVL_EX_EVENT  = 17,\n      IVL_EX_MEMORY = 4,\n      IVL_EX_NEW    = 23,\n      IVL_EX_NULL   = 22,\n      IVL_EX_NUMBER = 5,\n      IVL_EX_ARRAY_PATTERN  = 26,\n      IVL_EX_PROPERTY = 24,\n      IVL_EX_REALNUM  = 16,\n      IVL_EX_SCOPE  = 6,\n      IVL_EX_SELECT = 7,\n      IVL_EX_SFUNC  = 8,\n      IVL_EX_SHALLOWCOPY = 25,\n      IVL_EX_SIGNAL = 9,\n      IVL_EX_STRING = 10,\n      IVL_EX_TERNARY = 11,\n      IVL_EX_UFUNC = 12,\n      IVL_EX_ULONG = 13,\n      IVL_EX_UNARY = 14\n} ivl_expr_type_t;\n\ntypedef enum ivl_select_type_e ENUM_UNSIGNED_INT {\n      IVL_SEL_OTHER = 0,\n      IVL_SEL_IDX_UP = 1,\n      IVL_SEL_IDX_DOWN = 2\n} ivl_select_type_t;\n\n/* This is the type code for an ivl_net_logic_t object. */\ntypedef enum ivl_logic_e {\n      IVL_LO_NONE   =  0,\n      IVL_LO_AND    =  1,\n      IVL_LO_BUF    =  2,\n      IVL_LO_BUFIF0 =  3,\n      IVL_LO_BUFIF1 =  4,\n      IVL_LO_BUFT   = 24, /* transparent bufz. (NOT \"tri-state\") */\n      IVL_LO_BUFZ   =  5,\n      IVL_LO_CMOS   = 22,\n      IVL_LO_EQUIV  = 25,\n      IVL_LO_IMPL   = 26,\n      IVL_LO_NAND   =  6,\n      IVL_LO_NMOS   =  7,\n      IVL_LO_NOR    =  8,\n      IVL_LO_NOT    =  9,\n      IVL_LO_NOTIF0 = 10,\n      IVL_LO_NOTIF1 = 11,\n      IVL_LO_OR     = 12,\n      IVL_LO_PMOS   = 17,\n      IVL_LO_PULLDOWN  = 13,\n      IVL_LO_PULLUP = 14,\n      IVL_LO_RCMOS  = 23,\n      IVL_LO_RNMOS  = 15,\n      IVL_LO_RPMOS  = 16,\n      IVL_LO_XNOR   = 18,\n      IVL_LO_XOR    = 19,\n      IVL_LO_UDP    = 21\n} ivl_logic_t;\n\n/* This is the type of a ivl_switch_t object */\ntypedef enum ivl_switch_type_e {\n      IVL_SW_TRAN     = 0,\n      IVL_SW_TRANIF0  = 1,\n      IVL_SW_TRANIF1  = 2,\n      IVL_SW_RTRAN    = 3,\n      IVL_SW_RTRANIF0 = 4,\n      IVL_SW_RTRANIF1 = 5,\n      IVL_SW_TRAN_VP  = 6\n} ivl_switch_type_t;\n\n/* This is the type of an LPM object. */\ntypedef enum ivl_lpm_type_e {\n      IVL_LPM_ABS    = 32,\n      IVL_LPM_ADD    =  0,\n      IVL_LPM_ARRAY  = 30,\n      IVL_LPM_CAST_INT  = 34,\n      IVL_LPM_CAST_INT2 = 35,\n      IVL_LPM_CAST_REAL = 33,\n      IVL_LPM_CONCAT = 16,\n      IVL_LPM_CONCATZ = 36, /* Transparent concat */\n      IVL_LPM_CMP_EEQ= 18, /* Case EQ (===) */\n      IVL_LPM_CMP_EQX= 37, /* Wildcard EQ (casex) */\n      IVL_LPM_CMP_EQZ= 38, /* casez EQ */\n      IVL_LPM_CMP_WEQ= 41,\n      IVL_LPM_CMP_WNE= 42,\n      IVL_LPM_CMP_EQ = 10,\n      IVL_LPM_CMP_GE =  1,\n      IVL_LPM_CMP_GT =  2,\n      IVL_LPM_CMP_NE = 11,\n      IVL_LPM_CMP_NEE= 19, /* Case NE (!==) */\n      IVL_LPM_DIVIDE = 12,\n      IVL_LPM_FF     =  3,\n      IVL_LPM_LATCH  = 40,\n      IVL_LPM_MOD    = 13,\n      IVL_LPM_MULT   =  4,\n      IVL_LPM_MUX    =  5,\n      /* IVL_LPM_PART_BI= 28, / obsolete */\n      IVL_LPM_PART_VP= 15, /* part select: vector to part */\n      IVL_LPM_PART_PV= 17, /* part select: part written to vector */\n      IVL_LPM_POW    = 31,\n      IVL_LPM_RE_AND = 20,\n      IVL_LPM_RE_NAND= 21,\n      IVL_LPM_RE_NOR = 22,\n      IVL_LPM_RE_OR  = 23,\n      IVL_LPM_RE_XNOR= 24,\n      IVL_LPM_RE_XOR = 25,\n      IVL_LPM_REPEAT = 26,\n      IVL_LPM_SFUNC  = 29,\n      IVL_LPM_SHIFTL =  6,\n      IVL_LPM_SHIFTR =  7,\n      IVL_LPM_SIGN_EXT=27,\n      IVL_LPM_SUB    =  8,\n      IVL_LPM_SUBSTITUTE=39,\n      /* IVL_LPM_RAM =  9, / obsolete */\n      IVL_LPM_UFUNC  = 14\n} ivl_lpm_type_t;\n\n/* The path edge type is the edge type used to select a specific\n   delay. */\ntypedef enum ivl_path_edge_e {\n      IVL_PE_01 = 0, IVL_PE_10, IVL_PE_0z,\n      IVL_PE_z1,     IVL_PE_1z, IVL_PE_z0,\n      IVL_PE_0x,     IVL_PE_x1, IVL_PE_1x,\n      IVL_PE_x0,     IVL_PE_xz, IVL_PE_zx,\n      IVL_PE_COUNT\n} ivl_path_edge_t;\n\n/* Processes are initial, always, or final blocks with a statement. This is\n   the type of the ivl_process_t object. */\ntypedef enum ivl_process_type_e ENUM_UNSIGNED_INT {\n      IVL_PR_INITIAL      = 0,\n      IVL_PR_ALWAYS       = 1,\n      IVL_PR_ALWAYS_COMB  = 3,\n      IVL_PR_ALWAYS_FF    = 4,\n      IVL_PR_ALWAYS_LATCH = 5,\n      IVL_PR_FINAL        = 2\n} ivl_process_type_t;\n\n/* These are the sorts of reasons a scope may come to be. These types\n   are properties of ivl_scope_t objects. */\ntypedef enum ivl_scope_type_e {\n      IVL_SCT_MODULE  = 0,\n      IVL_SCT_FUNCTION= 1,\n      IVL_SCT_TASK    = 2,\n      IVL_SCT_BEGIN   = 3,\n      IVL_SCT_FORK    = 4,\n      IVL_SCT_GENERATE= 5,\n      IVL_SCT_PACKAGE = 6,\n      IVL_SCT_CLASS   = 7\n} ivl_scope_type_t;\n\n/* Signals (ivl_signal_t) that are ports into the scope that contains\n   them have a port type. Otherwise, they are port IVL_SIP_NONE. */\ntypedef enum OUT {\n      IVL_SIP_NONE  = 0,\n      IVL_SIP_INPUT = 1,\n      IVL_SIP_OUTPUT= 2,\n      IVL_SIP_INOUT = 3\n} ivl_signal_port_t;\n\n/* This is the type code for an ivl_signal_t object. Implicit types\n   are resolved by the core compiler, and integers are converted into\n   signed registers. */\ntypedef enum ivl_signal_type_e {\n      IVL_SIT_NONE = 0,\n      IVL_SIT_REG  = 1,\n      IVL_SIT_TRI  = 4,\n      IVL_SIT_TRI0 = 5,\n      IVL_SIT_TRI1 = 6,\n      IVL_SIT_TRIAND = 7,\n      IVL_SIT_TRIOR  = 8,\n      IVL_SIT_UWIRE  = 9\n} ivl_signal_type_t;\n\n/* This is the type code for ivl_statement_t objects. */\ntypedef enum ivl_statement_type_e {\n      IVL_ST_NONE    = 0,\n      IVL_ST_NOOP    = 1,\n      IVL_ST_ALLOC   = 25,\n      IVL_ST_ASSIGN    = 2,\n      IVL_ST_ASSIGN_NB = 3,\n      IVL_ST_BLOCK   = 4,\n      IVL_ST_BREAK   = 32,\n      IVL_ST_CASE    = 5,\n      IVL_ST_CASER   = 24, /* Case statement with real expressions. */\n      IVL_ST_CASEX   = 6,\n      IVL_ST_CASEZ   = 7,\n      IVL_ST_CASSIGN = 8,\n      IVL_ST_CONDIT  = 9,\n      IVL_ST_CONTINUE= 33,\n      IVL_ST_CONTRIB = 27,\n      IVL_ST_DEASSIGN = 10,\n      IVL_ST_DELAY   = 11,\n      IVL_ST_DELAYX  = 12,\n      IVL_ST_DISABLE = 13,\n      IVL_ST_DO_WHILE = 30,\n      IVL_ST_FORLOOP = 34,\n      IVL_ST_FORCE   = 14,\n      IVL_ST_FOREVER = 15,\n      IVL_ST_FORK    = 16,\n      IVL_ST_FORK_JOIN_ANY  = 28,\n      IVL_ST_FORK_JOIN_NONE = 29,\n      IVL_ST_FREE    = 26,\n      IVL_ST_NB_TRIGGER = 31,\n      IVL_ST_RELEASE = 17,\n      IVL_ST_REPEAT  = 18,\n      IVL_ST_STASK   = 19,\n      IVL_ST_TRIGGER = 20,\n      IVL_ST_UTASK   = 21,\n      IVL_ST_WAIT    = 22,\n      IVL_ST_WHILE   = 23\n} ivl_statement_type_t;\n\n/* Case statements can be tagged as unique/unique0/priority. */\ntypedef enum ivl_case_quality_t {\n      IVL_CASE_QUALITY_BASIC    = 0,  /* no quality flags */\n      IVL_CASE_QUALITY_UNIQUE   = 1,\n      IVL_CASE_QUALITY_UNIQUE0  = 2,\n      IVL_CASE_QUALITY_PRIORITY = 3\n} ivl_case_quality_t;\n\n/* SystemVerilog allows a system function to be called as a task. */\ntypedef enum ivl_sfunc_as_task_e {\n      IVL_SFUNC_AS_TASK_ERROR   = 0,\n      IVL_SFUNC_AS_TASK_WARNING = 1,\n      IVL_SFUNC_AS_TASK_IGNORE  = 2\n} ivl_sfunc_as_task_t;\n\n/* This is the type of a variable, and also used as the type for an\n   expression. */\ntypedef enum ivl_variable_type_e ENUM_UNSIGNED_INT {\n      IVL_VT_VOID    = 0,  /* Not used */\n      IVL_VT_NO_TYPE = 1,  /* Place holder for missing/unknown type. */\n      IVL_VT_REAL    = 2,\n      IVL_VT_BOOL    = 3,\n      IVL_VT_LOGIC   = 4,\n      IVL_VT_STRING  = 5,\n      IVL_VT_DARRAY  = 6,  /* Array (esp. dynamic array) */\n      IVL_VT_CLASS   = 7,  /* SystemVerilog class instances */\n      IVL_VT_QUEUE   = 8,  /* SystemVerilog queue instances */\n      IVL_VT_VECTOR = IVL_VT_LOGIC /* For compatibility */\n} ivl_variable_type_t;\n\n/* This is the type of the function to apply to a process. */\ntypedef int (*ivl_process_f)(ivl_process_t net, void*cd);\n\n/* This is the type of a function to apply to a scope. The ivl_scope_t\n   parameter is the scope, and the cd parameter is client data that\n   the user passes to the scanner. */\ntypedef int (ivl_scope_f)(ivl_scope_t net, void*cd);\n\n/* Attributes, which can be attached to various object types, have\n   this form. */\ntypedef enum ivl_attribute_type_e {\n      IVL_ATT_VOID = 0,\n      IVL_ATT_STR,\n      IVL_ATT_NUM\n} ivl_attribute_type_t;\n\nstruct ivl_attribute_s {\n      const char*key;\n      ivl_attribute_type_t type;\n      union val_ {\n\t    const char*str;\n\t    long num;\n      } val;\n};\ntypedef const struct ivl_attribute_s*ivl_attribute_t;\n\n/* BRANCH\n * Branches are analog constructs, a pair of terminals that is used in\n * branch access functions. Terminal-1 is the reference node (The\n * \"ground\") for the purposes of the access function that accesses it.\n *\n * SEMANTIC NOTES\n * All the branches in an island are connected by terminals or by\n * expressions. The island is the connection of branches that must be\n * solved together.\n */\n  /* extern ivl_scope_t ivl_branch_scope(ivl_branch_t obj); */\nextern ivl_nexus_t ivl_branch_terminal(ivl_branch_t obj, int idx);\nextern ivl_island_t ivl_branch_island(ivl_branch_t obj);\n\n/* DELAYPATH\n * Delaypath objects represent delay paths called out by a specify\n * block in the Verilog source file. The destination signal references\n * the path object, which in turn points to the source for the path.\n *\n * ivl_path_scope\n *    This returns the scope of the delay path. This scope corresponds\n *    to the scope of the specify-block that led to this path.\n *\n * ivl_path_source\n *    This returns the nexus that is the source end of the delay\n *    path. Transitions on the source are the start of the delay time\n *    for this path.\n *\n * ivl_path_condit\n *    This returns the nexus that tracks the condition for the\n *    delay. If the delay path is unconditional, this returns nil.\n * ivl_path_is_condit\n *    Is this a conditional structure? Needed for ifnone.\n *\n * ivl_path_is_parallel\n *    This returns true if the path is a parallel connection and\n *    false if the path is a full connection.\n *\n * ivl_path_source_posedge\n * ivl_path_source_negedge\n *    These functions return true if the source is edge sensitive.\n */\nextern ivl_scope_t ivl_path_scope(ivl_delaypath_t obj);\nextern ivl_nexus_t ivl_path_source(ivl_delaypath_t obj);\nextern uint64_t ivl_path_delay(ivl_delaypath_t obj, ivl_path_edge_t pt);\nextern ivl_nexus_t ivl_path_condit(ivl_delaypath_t obj);\nextern int ivl_path_is_condit(ivl_delaypath_t obj);\n\nextern int ivl_path_is_parallel(ivl_delaypath_t obj);\n\nextern int ivl_path_source_posedge(ivl_delaypath_t obj);\nextern int ivl_path_source_negedge(ivl_delaypath_t obj);\n\n/* DESIGN\n * When handed a design (ivl_design_t) there are a few things that you\n * can do with it. The Verilog program has one design that carries the\n * entire program. Use the design methods to iterate over the elements\n * of the design.\n *\n * ivl_design_delay_sel\n *    Returns the tool delay selection: \"MINIMUM\", \"TYPICAL\" or \"MAXIMUM\"?\n *\n * ivl_design_flag\n *    This function returns the string value of a named flag. Flags\n *    come from the \"-pkey=value\" options to the iverilog command and\n *    are stored in a map for this function. Given the key, this\n *    function returns the value.\n *\n *    The special key \"-o\" is the argument to the -o flag of the\n *    command line (or the default if the -o flag is not used) and is\n *    generally how the target learns the name of the output file.\n *\n * ivl_design_process\n *    This function scans the processes (threads) in the design. It\n *    calls the user supplied function on each of the processes until\n *    one of the functors returns non-0 or all the processes are\n *    scanned. This function will return 0, or the non-zero value that\n *    was returned from the last scanned process.\n *\n * ivl_design_root (ANACHRONISM)\n *    A design has a root named scope that is an instance of the top\n *    level module in the design. This is a hook for naming the\n *    design, or for starting the scope scan.\n *\n * ivl_design_roots\n *    A design has some number of root scopes. These are the starting\n *    points for structural elaboration. This function returns to the\n *    caller a pointer to an ivl_scope_t array, and the size of the\n *    array.\n *\n * ivl_design_time_precision\n *    A design as a time precision. This is the size in seconds (a\n *    signed power of 10) of a simulation tick.\n */\n\nextern const char* ivl_design_delay_sel(ivl_design_t des);\nextern const char* ivl_design_flag(ivl_design_t des, const char*key);\nextern int         ivl_design_process(ivl_design_t des,\n\t\t\t\t      ivl_process_f fun, void*cd);\nextern ivl_scope_t ivl_design_root(ivl_design_t des);\nextern void        ivl_design_roots(ivl_design_t des,\n\t\t\t\t    ivl_scope_t **scopes,\n\t\t\t\t    unsigned int *nscopes);\nextern int         ivl_design_time_precision(ivl_design_t des);\n\nextern unsigned        ivl_design_consts(ivl_design_t des);\nextern ivl_net_const_t ivl_design_const(ivl_design_t, unsigned idx);\n\nextern unsigned         ivl_design_disciplines(ivl_design_t des);\nextern ivl_discipline_t ivl_design_discipline(ivl_design_t des, unsigned idx);\n\n/* LITERAL CONSTANTS\n * Literal constants are nodes with no input and a single constant\n * output. The form of the output depends on the type of the node.\n * The output is an array of 4-value bits, using a single char\n * value for each bit. The bits of the vector are in canonical (lsb\n * first) order for the width of the constant.\n *\n * ivl_const_type\n *    The is the type of the node.\n *\n * ivl_const_bits\n *    This returns a pointer to an array of constant characters,\n *    each byte a '0', '1', 'x' or 'z'. The array is *not* nul\n *    terminated. This value is only value if ivl_const_type is\n *    IVL_VT_LOGIC or IVL_VT_BOOL. It returns nil otherwise.\n *\n * ivl_const_nex\n *    Return the ivl_nexus_t of the output for the constant.\n *\n * ivl_const_scope\n *    Return the scope this constant was defined in.\n\n * ivl_const_signed\n *    Return true (!0) if the constant is a signed value, 0 otherwise.\n *\n * ivl_const_width\n *    Return the width, in logical bits, of the constant.\n *\n * ivl_const_delay\n *    T0 delay for a transition (0, 1 and Z).\n *\n * SEMANTIC NOTES\n *\n * The const_type of the literal constant must match the\n * ivl_signal_data_type if the signals that share the nexus of this\n * node. The compiler makes sure it is so, converting constant values\n * as needed.\n *\n * - IVL_VT_LOGIC\n *\n * - IVL_VT_REAL\n * Real valued constants have a width of 1. The value emitted to the\n * output is ivl_const_real.\n */\nextern ivl_variable_type_t ivl_const_type(ivl_net_const_t net);\nextern const char* ivl_const_bits(ivl_net_const_t net);\nextern ivl_expr_t  ivl_const_delay(ivl_net_const_t net, unsigned transition);\nextern ivl_nexus_t ivl_const_nex(ivl_net_const_t net);\nextern ivl_scope_t ivl_const_scope(ivl_net_const_t net);\nextern int         ivl_const_signed(ivl_net_const_t net);\nextern unsigned    ivl_const_width(ivl_net_const_t net);\nextern double      ivl_const_real(ivl_net_const_t net);\n\nextern const char* ivl_const_file(ivl_net_const_t net);\nextern unsigned ivl_const_lineno(ivl_net_const_t net);\n\n/* extern ivl_nexus_t ivl_const_pin(ivl_net_const_t net, unsigned idx); */\n/* extern unsigned    ivl_const_pins(ivl_net_const_t net); */\n\n/* DISCIPLINES\n *\n * Disciplines are Verilog-AMS construct. A discipline is a collection\n * of attributes that can be attached to a signal.\n *\n * FUNCTION SUMMARY\n *\n * ivl_discipline_name\n *    This is the name of the discipline in the Verilog-AMS source.\n *\n * ivl_discipline_domain\n *    This is the domain: continuous or discrete.\n *\n * SEMANTIC NOTES\n *\n * The discipline domain will not be IVL_DIS_NONE. The \"none\" domain\n * is a place-holder internally for incomplete parsing, and is also\n * available for code generators to use.\n */\nextern const char*ivl_discipline_name(ivl_discipline_t net);\nextern ivl_dis_domain_t ivl_discipline_domain(ivl_discipline_t net);\nextern ivl_nature_t ivl_discipline_potential(ivl_discipline_t net);\nextern ivl_nature_t ivl_discipline_flow(ivl_discipline_t net);\n\nextern const char* ivl_nature_name(ivl_nature_t net);\n\n/* ENUMERATIONS\n *\n * Enumerations are a collections of symbolic names and vector\n * values. The enumeration has a base type, and a list of names and\n * values.\n *\n * FUNCTION SUMMARY\n *\n * ivl_enum_names\n *    This is the number of enumeration names in the enum type.\n *\n * ivl_enum_name\n *    Get the string name for an item in the enumeration\n *\n * ivl_enum_bits\n *    Get the bits (lsb first) of the enumeration value. The width\n *    of the enumeration should match the length of this string. Every\n *    name also has bits that make up the value.\n *\n * ivl_enum_signed\n *    Is the base type for the enum signed?\n *\n * ivl_enum_type\n *    Get the data-type for the base type that the enum uses. This\n *    will be either IVL_VT_BOOL or IVL_VT_LOGIC\n *\n * ivl_enum_width\n *    Return the bit width of the base type for this enum type.\n *\n * SEMANTIC NOTES\n */\nextern unsigned ivl_enum_names(ivl_enumtype_t net);\nextern const char*ivl_enum_name(ivl_enumtype_t net, unsigned idx);\nextern const char*ivl_enum_bits(ivl_enumtype_t net, unsigned idx);\nextern int ivl_enum_signed(ivl_enumtype_t net);\nextern ivl_variable_type_t ivl_enum_type(ivl_enumtype_t net);\nextern unsigned ivl_enum_width(ivl_enumtype_t net);\n\nextern const char*ivl_enum_file(ivl_enumtype_t net);\nextern unsigned ivl_enum_lineno(ivl_enumtype_t net);\n\n/* EVENTS\n *\n * Events are a unification of named events and implicit events\n * generated by the @ statements.\n *\n * FUNCTION SUMMARY\n *\n * ivl_event_name (Obsolete)\n * ivl_event_basename\n *    Return the name of the event. The basename is the name within\n *    the scope, as declared by the user or generated by elaboration.\n *\n * ivl_event_scope\n *    All events exist within a scope.\n *\n * SEMANTICS NOTES\n *\n * Named events (i.e. event objects declared by the Verilog\n * declaration \"event foo\") are recognized by the fact that they have\n * no edge sources. The name of the event as given in the Verilog\n * source is available from the ivl_event_basename function.\n *\n * Named events are referenced in trigger statements.\n *\n * Named events have file and line number information.\n *\n * Edge events are created implicitly by the @(...) Verilog syntax to\n * watch for the correct type of edge for the functor being\n * watched. The nodes to watch are collected into groups based on the\n * type of edge to be watched for on that node. For example, nodes to\n * be watched for positive edges are accessed via the ivl_event_npos\n * and ivl_event_pos functions.\n */\nextern const char* ivl_event_name(ivl_event_t net);\nextern const char* ivl_event_basename(ivl_event_t net);\nextern ivl_scope_t ivl_event_scope(ivl_event_t net);\n\nextern unsigned    ivl_event_nany(ivl_event_t net);\nextern ivl_nexus_t ivl_event_any(ivl_event_t net, unsigned idx);\n\nextern unsigned    ivl_event_nedg(ivl_event_t net);\nextern ivl_nexus_t ivl_event_edg(ivl_event_t net, unsigned idx);\n\nextern unsigned    ivl_event_nneg(ivl_event_t net);\nextern ivl_nexus_t ivl_event_neg(ivl_event_t net, unsigned idx);\n\nextern unsigned    ivl_event_npos(ivl_event_t net);\nextern ivl_nexus_t ivl_event_pos(ivl_event_t net, unsigned idx);\n\nextern const char*ivl_event_file(ivl_event_t net);\nextern unsigned ivl_event_lineno(ivl_event_t net);\n\n\n/* EXPRESSIONS\n *\n * These methods operate on expression objects from the\n * design. Expressions mainly exist in behavioral code. The\n * ivl_expr_type() function returns the type of the expression node,\n * and the remaining functions access value bits of the expression.\n *\n * ivl_expr_signed\n *    This method returns true (!= 0) if the expression node\n *    represents a signed expression. It is possible for sub-\n *    expressions to be unsigned even if a node is signed, but the\n *    IVL core figures all this out for you. At any rate, this method\n *    can be applied to any expression node.\n *\n * ivl_expr_sized\n *    This method returns false (0) if the expression node does not\n *    have a defined size. This is unusual, but may happen for\n *    constant expressions.\n *\n * ivl_expr_type\n *    Get the type of the expression node. Every expression node has a\n *    type, which can affect how some of the other expression methods\n *    operate on the node\n *\n * ivl_expr_value\n *    Get the data type of the expression node. This uses the variable\n *    type enum to express the type of the expression node.\n *\n * ivl_expr_net_type\n *    This is used in some cases to carry more advanced type\n *    descriptions. Over the long run, all type information will be\n *    moved into the ivl_type_t type description method.\n *\n * ivl_expr_width\n *    This method returns the bit width of the expression at this\n *    node. It can be applied to any expression node, and returns the\n *    *output* width of the expression node.\n *\n * ivl_expr_parameter\n *    This function returns the ivl_parameter_t object that represents\n *    this object, or 0 (nil) if it is not a parameter value. This\n *    function allows the code generator to detect the case where the\n *    expression is a parameter. This will normally only return a\n *    non-nil value for constants.\n *\n * ivl_expr_opcode\n *    IVL_EX_BINARY and IVL_EX_UNARY expression nodes include an\n *    opcode from this table:\n *              &   -- AND\n *              A   -- NAND (~&)\n *              X   -- XNOR (~^)\n *              *   -- Multiply\n *\n * SEMANTIC NOTES\n *\n * - IVL_EX_ARRAY\n * This expression type is a special case of the IVL_EX_SIGNAL where\n * the target is an array (ivl_signal_t with an array_count) but there\n * is no index expression. This is used only in the special situation\n * where the array is passed to a system task/function. The function\n * ivl_expr_signal returns the ivl_signal_t of the array object, and\n * from that all the properties of the array can be determined.\n *\n * - IVL_EX_BINARY\n *\n * - IVL_EX_PROPERTY\n * This expression represents the property select from a class\n * type, for example \"foo.property\" where \"foo\" is a class handle and\n * \"property\" is the name of one of the properties of the class. The\n * ivl_expr_signal function returns the ivl_signal_t for \"foo\" and the\n * data_type for the signal will be IVL_VT_CLASS.\n *\n * The ivl_signal_net_type(sig) for the \"foo\" signal will be a class\n * type and from there you can get access to the type information.\n *\n * Elaboration reduces the properties of a class to a vector numbered\n * from 0 to the number of properties. The ivl_expr_property_idx()\n * function gets the index of the selected property into the property\n * table. That number can be passed to ivl_type_prop_*() functions to\n * get details about the property.\n *\n * If the property is an array, then the ivl_expr_oper1() function\n * returns the canonical expression for accessing the element of the\n * property.\n *\n * - IVL_EX_NEW\n * This expression takes one or two operands. The first operand,\n * returned by ivl_expr_oper1() is the number of elements to create\n * for the dynamic array. The second operand, if present, is returned\n * by the ivl_expr_oper2() function. If this returns a non-nil\n * expression, it is the initial value to be written to the elements\n * of the array. If the expression is an IVL_EX_ARRAY_PATTERN, then\n * this is the very special case of a list of values to be written to\n * array elements.\n *\n * - IVL_EX_SELECT\n * This expression takes two operands, oper1 is the expression to\n * select from, and oper2 is the selection base. The ivl_expr_width\n * value is the width of the bit/part select. The ivl_expr_oper1 value\n * is the base of a vector. The compiler has already figured out any\n * conversion from signal units to vector units, so the result of\n * ivl_expr_oper1 should range from 0 to ivl_expr_width().\n *\n * This expression is also used to implement string substrings. If the\n * sub-expression (oper1) is IVL_VT_STRING, then the base expression\n * (oper2) is a character address, with 0 the first address of the\n * string, 1 the second, and so on. This is OPPOSITE how a part select\n * of a string cast to a vector works, to be aware. The size of the\n * expression is an even multiple of 8, and is 8 times the number of\n * characters to pick.\n *\n * - IVL_EX_SIGNAL\n * This expression references a signal vector. The ivl_expr_signal\n * function gets a handle for the signal that is referenced. The\n * signal may be an array (see the ivl_signal_array_count function)\n * that is addressed by the expression returned by the ivl_expr_oper1\n * function. This expression returns a *canonical* address. The core\n * compiler already corrected the expression to account for index\n * bases.\n *\n * The ivl_expr_width function returns the vector width of the signal\n * word. The ivl_expr_value returns the data type of the word.\n *\n * Bit and part selects are not done here. The IVL_EX_SELECT\n * expression does bit/part selects on the word read from the signal.\n *\n * - IVL_EX_STRING\n * This expression refers to a string constant. The ivl_expr_string\n * function returns a pointer to the first byte of the string. The\n * compiler has translated it to a \"vvp escaped string\" which has\n * quoting and escapes eliminated. The string may contain octal\n * escapes (\\<oct>) so that the string text returned by\n * ivl_expr_string will only contain graphical characters. It is up to\n * the target to change the escaped \\NNN to the proper byte value when\n * using this string. No other escape sequences will appear in the\n * string. Quote (\") and slash (\\) characters will be delivered in\n * \\NNN form.\n */\n\nextern ivl_expr_type_t ivl_expr_type(ivl_expr_t net);\nextern ivl_type_t ivl_expr_net_type(ivl_expr_t net);\nextern ivl_variable_type_t ivl_expr_value(ivl_expr_t net);\nextern const char*ivl_expr_file(ivl_expr_t net);\nextern unsigned ivl_expr_lineno(ivl_expr_t net);\n\n  /* IVL_EX_NUMBER */\nextern const char* ivl_expr_bits(ivl_expr_t net);\n  /* IVL_EX_BACCESS */\nextern ivl_branch_t ivl_expr_branch(ivl_expr_t net);\n  /* IVL_EX_UFUNC */\nextern ivl_scope_t ivl_expr_def(ivl_expr_t net);\n  /* IVL_EX_DELAY */\nextern uint64_t ivl_expr_delay_val(ivl_expr_t net);\n  /* IVL_EX_REALNUM */\nextern double ivl_expr_dvalue(ivl_expr_t net);\n  /* IVL_EX_ENUMTYPE */\nextern ivl_enumtype_t ivl_expr_enumtype(ivl_expr_t net);\n  /* IVL_EX_PROPERTY IVL_EX_SIGNAL IVL_EX_SFUNC IVL_EX_VARIABLE */\nextern const char* ivl_expr_name(ivl_expr_t net);\n  /* IVL_EX_BACCESS */\nextern ivl_nature_t ivl_expr_nature(ivl_expr_t net);\n  /* IVL_EX_BINARY IVL_EX_UNARY */\nextern char        ivl_expr_opcode(ivl_expr_t net);\n  /* IVL_EX_BINARY  IVL_EX_UNARY, IVL_EX_MEMORY IVL_EX_NEW IVL_EX_TERNARY */\nextern ivl_expr_t  ivl_expr_oper1(ivl_expr_t net);\n  /* IVL_EX_BINARY IVL_EX_NEW IVL_EX_TERNARY */\nextern ivl_expr_t  ivl_expr_oper2(ivl_expr_t net);\n  /* IVL_EX_TERNARY */\nextern ivl_expr_t  ivl_expr_oper3(ivl_expr_t net);\n  /* and expression */\nextern ivl_parameter_t ivl_expr_parameter(ivl_expr_t net);\n  /* IVL_EX_ARRAY_PATTERN IVL_EX_CONCAT IVL_EX_UFUNC */\nextern ivl_expr_t  ivl_expr_parm(ivl_expr_t net, unsigned idx);\n  /* IVL_EX_ARRAY_PATTERN IVL_EX_CONCAT IVL_EX_SFUNC IVL_EX_UFUNC */\nextern unsigned    ivl_expr_parms(ivl_expr_t net);\n  /* IVL_EX_CONCAT */\nextern unsigned    ivl_expr_repeat(ivl_expr_t net);\n  /* IVL_EX_SELECT */\nextern ivl_select_type_t ivl_expr_sel_type(ivl_expr_t net);\n  /* IVL_EX_EVENT */\nextern ivl_event_t ivl_expr_event(ivl_expr_t net);\n  /* IVL_EX_PROPERTY */\nextern int ivl_expr_property_idx(ivl_expr_t net);\n  /* IVL_EX_SCOPE */\nextern ivl_scope_t ivl_expr_scope(ivl_expr_t net);\n  /* IVL_EX_PROPERTY IVL_EX_SIGNAL */\nextern ivl_signal_t ivl_expr_signal(ivl_expr_t net);\n  /* any expression */\nextern int         ivl_expr_signed(ivl_expr_t net);\n  /* any expression */\nextern int         ivl_expr_sized(ivl_expr_t net);\n  /* IVL_EX_STRING */\nextern const char* ivl_expr_string(ivl_expr_t net);\n  /* IVL_EX_ULONG */\nextern unsigned long ivl_expr_uvalue(ivl_expr_t net);\n  /* any expression */\nextern unsigned    ivl_expr_width(ivl_expr_t net);\n\nextern const char* ivl_file_table_item(unsigned  idx);\nextern unsigned ivl_file_table_index(const char *);\nextern unsigned ivl_file_table_size(void);\n\n\n/* ISLAND\n *\n * ivl_island_flag_set\n * ivl_island_flag_test\n *    Allow the user to test or set a boolean flag associated with the\n *    island.\n */\nextern int ivl_island_flag_set(ivl_island_t net, unsigned flag, int value);\nextern int ivl_island_flag_test(ivl_island_t net, unsigned flag);\n\nextern const char* ivl_logic_file(ivl_net_logic_t net);\nextern unsigned ivl_logic_lineno(ivl_net_logic_t net);\n\n/* LOGIC\n * These types and functions support manipulation of logic gates. The\n * ivl_logic_t enumeration identifies the various kinds of gates that\n * the ivl_net_logic_t can represent. The various functions then\n * provide access to the bits of information for a given logic device.\n *\n * The ivl_net_logic_t nodes are bit-slice devices. That means that\n * the device may have width (and therefore processes vectors) but\n * each bit slice of the width is independent.\n *\n * ivl_logic_type\n *    This method returns the type of logic gate that the node\n *    represents. The logic type implies the meaning of the various pins.\n *\n * ivl_logic_name (obsolete)\n *    This method returns the complete name of the logic gate. Every\n *    gate has a complete name (that includes the scope) even if the\n *    Verilog source doesn't include one. The compiler will choose one\n *    if necessary.\n *\n * ivl_logic_basename\n *    This is the name of the gate without the scope part.\n *\n * ivl_logic_scope\n *    This is the scope that directly contains the logic device.\n *\n * ivl_logic_pins\n * ivl_logic_pin\n *    Return the nexus for the pin. If two pins are connected\n *    together, then these values are the same. Use the nexus\n *    functions to find other pins that are connected to this nexus.\n *\n * ivl_logic_width\n *    This returns the width of the logic array. This does not affect\n *    the number of pins, but implies the width of the vector at each\n *    pin.\n *\n * ivl_logic_delay\n *    Logic devices have a delay for each transition (0, 1 and Z).\n *\n * ivl_logic_attr (obsolete)\n *    Return the value of a specific attribute, given the key name as\n *    a string. If the key is not defined, then return 0 (null).\n *\n * ivl_logic_attr_cnt\n * ivl_logic_attr_val\n *    These support iterating over logic attributes. The _cnt method\n *    returns the number of attributes attached to the gate, and the\n *    ivl_logic_attr_val returns the value of the attribute.\n *\n * SEMANTIC NOTES\n * The ivl_logic_width applies to all the pins of a logic device. If a\n * logic device has width, that means that it is actually an array of\n * logic devices that each process a bit slice of the\n * inputs/output. That implies that the widths of all the inputs and\n * the output must be identical.\n *\n * The ivl_logic_width  and ivl_logic_pins are *not* related. A logic\n * device has a number of pins that is the number of inputs to a logic\n * array of identical gates, and the ivl_logic_width, is the width of\n * the vector into each input pin and out of the output pin.\n *\n * The output pin is pin-0. The ivl_logic_driveX functions return the\n * drive strengths for the output pin-0, and match the drive values\n * stored in the ivl_nexus_ptr_t object for the pin.\n *\n * Logic devices have a logic propagation delay. The delay can be any\n * expression, although the most common expression is an IVL_EX_NUMBER\n * for a number value. The expression already includes scaling for the\n * containing module, so the delay value is always taken to be in\n * simulation clock ticks.\n *\n * If the delay is present, then ivl_logic_delay returns a non-nil\n * object. If any of the three delays is present, then all three are\n * present, even if they are all the same. The compiler will translate\n * shorthands into a complete set of delay expressions.\n *\n * The ivl_logic_delay expression will always be an IVL_EX_NUMBER, an\n * IVL_EX_ULONG, or an IVL_EX_SIGNAL. These expressions can easily be\n * used in structural contexts. The compiler will take care of\n * elaborating more complex expressions to nets.\n *\n * - IVL_LO_PULLUP/IVL_LO_PULLDOWN\n * These devices are grouped as logic devices with zero inputs because\n * the outputs have the same characteristics as other logic\n * devices. They are special only in that they have zero inputs, and\n * their drivers typically have strength other than strong.\n *\n * - IVL_LO_UDP\n * User defined primitives (UDPs) are like any other logic devices, in\n * that they are bit-slice devices. If they have a width, then they\n * are repeated to accommodate that width, and that implies that the\n * output and all the inputs must have the same width.\n *\n * The IVL_LO_UDP represents instantiations of UDP devices. The\n * ivl_udp_t describes the implementation.\n */\n\nextern const char* ivl_logic_name(ivl_net_logic_t net);\nextern const char* ivl_logic_basename(ivl_net_logic_t net);\nextern ivl_scope_t ivl_logic_scope(ivl_net_logic_t net);\nextern ivl_logic_t ivl_logic_type(ivl_net_logic_t net);\nextern ivl_nexus_t ivl_logic_pin(ivl_net_logic_t net, unsigned pin);\nextern unsigned    ivl_logic_pins(ivl_net_logic_t net);\nextern ivl_udp_t   ivl_logic_udp(ivl_net_logic_t net);\nextern ivl_expr_t  ivl_logic_delay(ivl_net_logic_t net, unsigned transition);\nextern ivl_drive_t ivl_logic_drive0(ivl_net_logic_t net);\nextern ivl_drive_t ivl_logic_drive1(ivl_net_logic_t net);\nextern unsigned    ivl_logic_width(ivl_net_logic_t net);\nextern unsigned    ivl_logic_is_cassign(ivl_net_logic_t net);\nextern unsigned    ivl_logic_port_buffer(ivl_net_logic_t net);\n\n  /* DEPRECATED */\nextern const char* ivl_logic_attr(ivl_net_logic_t net, const char*key);\n\nextern unsigned        ivl_logic_attr_cnt(ivl_net_logic_t net);\nextern ivl_attribute_t ivl_logic_attr_val(ivl_net_logic_t net, unsigned idx);\n\n/* UDP\n * These methods allow access to the ivl_udp_t definition of a UDP.\n * The UDP definition is accessed through the ivl_logic_udp method of\n * an ivl_net_logic_t object.\n *\n * ivl_udp_name\n *    This returns the name of the definition of the primitive.\n *\n * ivl_udp_nin\n *    This is the number of inputs for the UDP definition.\n *\n * ivl_udp_rows\n * ivl_udp_row\n *    These methods give access to the rows that define the table of\n *    the primitive.\n *\n * SEMANTIC NOTES\n *\n * - Combinational primitives\n * These devices have no edge dependencies, and have no table entry\n * for the current input value. These have ivl_udp_sequ return 0\n * (false) and the length of each row is the number of inputs plus 1.\n * The first N characters correspond to the N inputs of the\n * device. The next character, the last character, is the output for\n * that row.\n *\n * - Sequential primitives\n * These devices allow edge transitions, and the rows are 1+N+1\n * characters long. The first character is the current output, the\n * next N characters the current input and the last character is the\n * new output.\n *\n * The ivl_udp_init value is only valid if the device is\n * sequential. It is the initial value for the output of the storage\n * element.\n */\n\nextern int         ivl_udp_sequ(ivl_udp_t net);\nextern unsigned    ivl_udp_nin(ivl_udp_t net);\nextern char        ivl_udp_init(ivl_udp_t net);\nextern const char* ivl_udp_row(ivl_udp_t net, unsigned idx);\nextern unsigned    ivl_udp_rows(ivl_udp_t net);\nextern const char* ivl_udp_name(ivl_udp_t net);\nextern const char* ivl_udp_file(ivl_udp_t net);\nextern unsigned    ivl_udp_lineno(ivl_udp_t net);\nextern const char* ivl_udp_port(ivl_udp_t net, unsigned idx);\n\nextern const char* ivl_lpm_file(ivl_lpm_t net);\nextern unsigned    ivl_lpm_lineno(ivl_lpm_t net);\n\n/* LPM\n * These functions support access to the properties of LPM\n * devices. LPM devices are a variety of devices that handle more\n * complex structural semantics. They are based on EIA LPM standard\n * devices, but vary to suite the technical situation.\n *\n * These are the functions that apply to all LPM devices:\n *\n * ivl_lpm_name (Obsolete)\n * ivl_lpm_basename\n *    Return the name of the device. The name is the name of the\n *    device with the scope part, and the basename is without the scope.\n *\n * ivl_lpm_delay\n *    LPM devices have a delay for each transition (0, 1 and Z).\n *\n * ivl_lpm_scope\n *    LPM devices exist within a scope. Return the scope that contains\n *    this device.\n *\n * ivl_lpm_type\n *    Return the ivl_lpm_type_t of the specific LPM device.\n *\n * ivl_lpm_width\n *    Return the width of the LPM device. What this means depends on\n *    the LPM type, but it generally has to do with the width of the\n *    output data path.\n *\n *\n * These functions apply to a subset of the LPM devices, or may have\n * varying meaning depending on the device:\n *\n * ivl_lpm_base\n *    The IVL_LPM_PART objects use this value as the base (first bit)\n *    of the part select. The ivl_lpm_width is the size of the part.\n *\n * ivl_lpm_data\n *    Return the input data nexus for device types that have input\n *    vectors. The \"idx\" parameter selects which data input is selected.\n *\n * ivl_lpm_datab (ANACHRONISM)\n *    This is the same as ivl_lpm_data(net,1), in other words the\n *    second data input. Use the ivl_lpm_data method instead.\n *\n * ivl_lpm_q\n *    Return the output data nexus for device types that have a single\n *    output vector. This is most devices, it turns out.\n *\n * ivl_lpm_selects\n *    This is the size of the select input for a LPM_MUX device, or the\n *    address bus width of an LPM_RAM.\n *\n * ivl_lpm_signed\n *    Arithmetic LPM devices may be signed or unsigned if there is a\n *    distinction. For some devices this gives the signedness of the\n *    output, but not all devices.\n *\n * ivl_lpm_size\n *    In addition to a width, some devices have a size. The size is\n *    often the number of inputs per out, i.e., the number of inputs\n *    per bit for a MUX.\n *\n * ivl_lpm_trigger\n *    SFUNC and UFUNC devices may have a trigger that forces the\n *    function output to be re-evaluated.\n *\n * SEMANTIC NOTES\n *\n * - Concatenation (IVL_LPM_CONCAT)\n * These devices take vectors in and combine them to form a single\n * output the width specified by ivl_lpm_width.\n *\n * The ivl_lpm_q nexus is the output from the concatenation.\n *\n * The ivl_lpm_data function returns the connections for the inputs to\n * the concatenation. The ivl_lpm_size function returns the number of\n * inputs help by the device.\n *\n * - Divide (IVL_LPM_DIVIDE)\n * The divide operators take two inputs and generate an output. The\n * ivl_lpm_width returns the width of the result. The width of the\n * inputs are their own.\n *\n * - Multiply (IVL_LPM_MULT)\n * The multiply takes two inputs and generates an output. Unlike other\n * arithmetic nodes, the width only refers to the output. The inputs\n * have independent widths, to reflect the arithmetic truth that the\n * width of a general multiply is the sum of the widths of the\n * inputs. In fact, the compiler doesn't assure that the widths of the\n * inputs add up to the width of the output, but the possibility\n * exists. It is *not* an error for the sum of the input widths to be\n * more than the width of the output, although the possibility of\n * overflow exists at run time.\n *\n * The inputs are always treated as unsigned. If the expression is\n * supposed to be signed, elaboration will generate the necessary sign\n * extension, so the target need not (must not) consider signedness.\n *\n * - Power (IVL_LPM_POW)\n * The power takes two inputs and generates an output. Unlike other\n * arithmetic nodes, the width only refers to the output. The inputs\n * have independent widths, to reflect the arithmetic truth that the\n * width of a general power is the XXXX of the widths of the\n * inputs.\n *\n * Power may be signed. This indicates the type of the exponent. The\n * base will always be treated as unsigned. The compiler must ensure\n * the width of the base is equal to the width of the output to\n * obtain the correct result when the base is really a signed value.\n *\n * - Part Select (IVL_LPM_PART_VP and IVL_LPM_PART_PV)\n * There are two part select devices, one that extracts a part from a\n * vector, and another that writes a part of a vector. The _VP is\n * Vector-to-Part, and _PV is Part-to-Vector. The _VP form is meant to\n * model part/bin selects in r-value expressions, where the _PV from\n * is meant to model part selects in l-value nets.\n *\n * In both cases, ivl_lpm_data(0) is the input pin, and ivl_lpm_q is the\n * output. In the case of the _VP device, the vector is input and the\n * part is the output. In the case of the _PV device, the part is the\n * input and the vector is the output.\n *\n * If the base of the part select is non-constant, then\n * ivl_lpm_data(1) is non-nil and is the select, or base, address of\n * the part. If this pin is nil, then the constant base is used\n * instead.\n *\n * Also in both cases, the width of the device is the width of the\n * part. In the _VP case, this is obvious as the output nexus has the\n * part width. In the _PV case, this is a little less obvious, but\n * still correct. The output being written to the wider vector is\n * indeed the width of the part, even though it is written to a wider\n * gate. The target will need to handle this case specially.\n *\n * - Bi-directional Part Select (IVL_LPM_PART_BI)\n * This is not exactly a part select but a bi-directional partial link\n * of two nexa with different widths. This is used to implement tran\n * devices and inout ports in certain cases. The device width is the\n * width of the part. The ivl_lpm_q is the part end, and the\n * ivl_lpm_data(0) is the non-part end.\n *\n * - Comparisons (IVL_LPM_CMP_GT/GE/EQ/NE/EEQ/NEE/EQX/EQZ)\n * These devices have two inputs, available by the ivl_lpm_data()\n * function, and one output available by the ivl_lpm_q function. The\n * output width is always 1, but the ivl_lpm_width() returns the width\n * of the inputs. Both inputs must have the same width.\n *\n * The CMP_GE and CMP_GT nodes may also be signed or unsigned, with\n * the obvious implications. The widths are matched by the compiler\n * (so the target need not worry about sign extension) but when doing\n * magnitude compare, the signedness does matter. In any case, the\n * result of the compare is always unsigned.\n *\n * The EQX and EQZ nodes are wildcard compares, where xz bits (EQX) or\n * z bits (EQZ) in the data(1) operand are treated as wildcards. no\n * bits in the data(0) operand are wild. This matches the\n * SystemVerilog convention for the ==? operator.\n *\n * - Mux Device (IVL_LPM_MUX)\n * The MUX device has a q output, a select input, and a number of data\n * inputs. The ivl_lpm_q output and the ivl_lpm_data inputs all have\n * the width from the ivl_lpm_width() method. The Select input, from\n * ivl_lpm_select, has the width ivl_lpm_selects().\n *\n * The ivl_lpm_data() method returns the inputs of the MUX device. The\n * ivl_lpm_size() method returns the number of data inputs there\n * are. All the data inputs have the same width, the width of the\n * ivl_lpm_q output. The type of the device is divined from the\n * inputs and the Q. All the types must be exactly the same.\n *\n * - D-FlipFlop (IVL_LPM_FF)\n * This device is an edge sensitive register. The ivl_lpm_q output and\n * single ivl_lpm_data input are the same width, ivl_lpm_width. This\n * device carries a vector like other LPM devices.\n *\n * - Latch (IVL_LPM_LATCH)\n * This device is an asynchronous latch. The ivl_lpm_q output and\n * single ivl_lpm_data input are the same width, ivl_lpm_width. This\n * device carries a vector like other LPM devices.\n *\n * - Memory port (IVL_LPM_RAM) (deprecated in favor of IVL_LPM_ARRAY)\n * These are structural ports into a memory device. They represent\n * address/data ports of a memory device that the context can hook to\n * for read or write. Read devices have an ivl_lpm_q output port that\n * is the data being read.\n *\n * The ivl_lpm_memory function returns the ivl_memory_t for the memory\n * that the port access. The ivl_lpm_width for the port then must\n * match the ivl_memory_width of the memory device.\n *\n * Read or write, the ivl_lpm_select nexus is the address. The\n * ivl_lpm_selects function returns the vector width of the\n * address. The range of the address is always from 0 to the memory\n * size-1 -- the canonical form. It is up to the compiler to generate\n * offsets to correct for a range declaration.\n *\n * Read ports use the ivl_lpm_q as the data output, and write ports\n * use the ivl_lpm_data(0) as the input. In either case the width of\n * the vector matches the width of the memory itself.\n *\n * - Reduction operators (IVL_LPM_RE_*)\n * These devices have one input, a vector, and generate a single bit\n * result. The width from the ivl_lpm_width is the width of the input\n * vector.\n *\n * - Repeat Node (IVL_LPM_REPEAT)\n * This node takes as input a single vector, and outputs a single\n * vector. The ivl_lpm_width if this node is the width of the *output*\n * vector. The ivl_lpm_size() returns the number of times the input is\n * repeated to get the desired width. The ivl core assures that the\n * input vector is exactly ivl_lpm_width() / ivl_lpm_size() bits.\n *\n * - Sign Extend (IVL_LPM_SIGN_EXT)\n * This node takes a single input and generates a single output. The\n * input must be signed, and the output will be a vector sign extended\n * to the desired width. The ivl_lpm_width() value is the output\n * width, the input will be whatever it wants to be.\n *\n * - Shifts (IVL_LPM_SHIFTL/SHIFTR)\n * This node takes two inputs, a vector and a shift distance. The\n * ivl_lpm_data(0) nexus is the vector input, and the ivl_lpm_data(1)\n * the shift distance. The vector input is the same width as the\n * output, but the distance has its own width.\n *\n * The ivl_lpm_signed() flag means for IVL_LPM_SHIFTR that the right\n * shift is *signed*. For SHIFTL, then signed-ness is meaningless.\n *\n * - System function call (IVL_LPM_SFUNC)\n * This device represents a netlist call to a system function. The\n * inputs to the device are passed to a system function, and the\n * result is sent via the output. The ivl_lpm_q function returns the\n * output nexus.\n *\n * The ivl_lpm_size function returns the number of arguments, and the\n * ivl_lpm_data(net,N) returns the nexa for the argument.\n *\n * The ivl_lpm_string(net) function returns the name of the system\n * function (i.e. \"$display\") that was found in the source code. The\n * compiler does little checking of that name.\n *\n * The ivl_lpm_trigger function retrieves the trigger event that\n * indicates when the system function needs to be re-evaluated. If\n * there is no trigger event, the system function only needs to be\n * re-evaluated when a change is detected on its input ports.\n *\n * - User Function Call (IVL_LPM_UFUNC)\n * This device is special as it represents a call to a user defined\n * function (behavioral code) within a netlist. The inputs to the\n * function are connected to the net, as is the output.\n *\n * The function definition is associated with a scope, and the\n * ivl_lpm_define function returns the scope that is that definition.\n * See the ivl_scope_* functions for how to get at the actual\n * definition.\n *\n * As with many LPM nodes, the ivl_lpm_q function returns the nexus\n * for the signal function return value. The width of this nexus must\n * exactly match the width of the device from ivl_lpm_width.\n *\n * The ivl_lpm_data function retrieves the nexa for all the input\n * ports. The ivl_lpm_size function returns the number of inputs for\n * the device, and the ivl_lpm_data() function index argument selects\n * the port to retrieve. Each port is sized independently.\n *\n * The ivl_lpm_trigger function retrieves the trigger event that\n * indicates when the user function needs to be re-evaluated. If\n * there is no trigger event, the user function only needs to be\n * re-evaluated when a change is detected on its input ports.\n */\n\nextern const char*    ivl_lpm_name(ivl_lpm_t net); /* (Obsolete) */\nextern const char*    ivl_lpm_basename(ivl_lpm_t net);\nextern ivl_expr_t     ivl_lpm_delay(ivl_lpm_t net, unsigned transition);\nextern ivl_scope_t    ivl_lpm_scope(ivl_lpm_t net);\nextern int            ivl_lpm_signed(ivl_lpm_t net);\nextern ivl_lpm_type_t ivl_lpm_type(ivl_lpm_t net);\nextern unsigned       ivl_lpm_width(ivl_lpm_t net);\nextern ivl_event_t    ivl_lpm_trigger(ivl_lpm_t net);\n\n  /* IVL_LPM_FF */\nextern ivl_nexus_t ivl_lpm_async_clr(ivl_lpm_t net);\nextern ivl_nexus_t ivl_lpm_async_set(ivl_lpm_t net);\nextern ivl_expr_t  ivl_lpm_aset_value(ivl_lpm_t net);\nextern ivl_nexus_t ivl_lpm_sync_clr(ivl_lpm_t net);\nextern ivl_nexus_t ivl_lpm_sync_set(ivl_lpm_t net);\nextern ivl_expr_t  ivl_lpm_sset_value(ivl_lpm_t net);\n  /* IVL_LPM_ARRAY */\nextern ivl_signal_t ivl_lpm_array(ivl_lpm_t net);\n  /* IVL_LPM_PART IVL_LPM_SUBSTITUTE */\nextern unsigned ivl_lpm_base(ivl_lpm_t net);\n  /* IVL_LPM_FF */\nextern unsigned    ivl_lpm_negedge(ivl_lpm_t net);\nextern ivl_nexus_t ivl_lpm_clk(ivl_lpm_t net);\n  /* IVL_LPM_UFUNC */\nextern ivl_scope_t  ivl_lpm_define(ivl_lpm_t net);\n  /* IVL_LPM_FF IVL_LPM_LATCH*/\nextern ivl_nexus_t ivl_lpm_enable(ivl_lpm_t net);\n  /* IVL_LPM_ADD IVL_LPM_CONCAT IVL_LPM_FF IVL_LPM_PART IVL_LPM_MULT\n     IVL_LPM_MUX IVL_LPM_POW IVL_LPM_SHIFTL IVL_LPM_SHIFTR IVL_LPM_SUB\n     IVL_LPM_UFUNC IVL_LPM_SUBSTITUTE IVL_LPM_LATCH */\nextern ivl_nexus_t ivl_lpm_data(ivl_lpm_t net, unsigned idx);\n  /* IVL_LPM_ADD IVL_LPM_MULT IVL_LPM_POW IVL_LPM_SUB IVL_LPM_CMP_EQ\n     IVL_LPM_CMP_EEQ IVL_LPM_CMP_EQX IVL_LPM_CMP_EQZ IVL_LPM_CMP_NEE */\nextern ivl_nexus_t ivl_lpm_datab(ivl_lpm_t net, unsigned idx);\n  /* IVL_LPM_ADD IVL_LPM_FF IVL_LPM_MULT IVL_LPM_PART IVL_LPM_POW\n     IVL_LPM_SUB IVL_LPM_UFUNC IVL_LPM_CMP_EEQ IVL_LPM_CMP_EQX\n     IVL_LPM_CMP_EQZ IVL_LPM_CMP_NEE IVL_LPM_SUBSTITUTE IVL_LPM_LATCH */\nextern ivl_nexus_t ivl_lpm_q(ivl_lpm_t net);\nextern ivl_drive_t ivl_lpm_drive0(ivl_lpm_t net);\nextern ivl_drive_t ivl_lpm_drive1(ivl_lpm_t net);\n  /* IVL_LPM_MUX */\nextern unsigned ivl_lpm_selects(ivl_lpm_t net);\n  /* IVL_LPM_MUX */\nextern ivl_nexus_t ivl_lpm_select(ivl_lpm_t net);\n  /* IVL_LPM_CONCAT IVL_LPM_MUX IVL_LPM_REPEAT IVL_LPM_UFUNC */\nextern unsigned ivl_lpm_size(ivl_lpm_t net);\n  /* IVL_LPM_SFUNC */\nextern const char*ivl_lpm_string(ivl_lpm_t net);\n\n/* LVAL\n * The l-values of assignments are concatenation of ivl_lval_t\n * objects. Each lvi_lval_t object is an assignment to a var or a\n * memory, through a bit select, part select or word select.\n *\n * Var lvals are things like assignments to a part select or a bit\n * select. Assignment to the whole variable is a special case of a\n * part select, as is a bit select with a constant expression.\n *\n * ivl_lval_width\n *    The width of a vector that this lval can receive. This accounts\n *    for the local part selecting I might to in the lval object, as\n *    well as the target object width.\n *\n * ivl_lval_mux (* obsolete *)\n *\n * ivl_lval_nest\n *    If the l-value is an object more complex than a variable, then\n *    this returns the nested l-value (and ivl_lval_sig==0).\n *\n * ivl_lval_sig\n *    If the l-value is a variable, this method returns the signal\n *    object that is the target of the assign.\n *\n * ivl_lval_part_off\n *    The part select of the signal is based here. This is the\n *    canonical index of bit-0 of the part select. The return value is\n *    an ivl_expr_t. If the return value is nil, then take the offset\n *    as zero. Otherwise, evaluate the expression to get the offset.\n *\n * ivl_lval_idx\n *    If the l-value is a memory, this method returns an\n *    ivl_expr_t that represents the index expression.  Otherwise, it\n *    returns 0.\n *\n * ivl_lval_property_idx\n *    If the l-value is a class object, this is the name of a property\n *    to select from the object. If this property is not present (<0)\n *    then the l-value represents the class object itself.\n *\n * SEMANTIC NOTES\n * The ivl_lval_width is not necessarily the same as the width of the\n * signal or memory word it represents. It is the width of the vector\n * it receives and assigns. This may be less than the width of the\n * signal (or even 1) if only a part of the l-value signal is to be\n * assigned.\n *\n * The ivl_lval_part_off is the canonical base of a part or\n * bit select.\n *\n * - Array words\n * If the l-value is an array, then ivl_lval_idx function will return\n * an expression that calculates the address of the array word. If\n * the referenced signal has more than one word, this expression must\n * be present. If the signal has exactly one word (it is not an array)\n * then the ivl_lval_idx expression must *not* be present.\n *\n * For array words, the ivl_lval_width is the width of the word.\n *\n * - Arrayed properties\n * If the l-value is a class property, then the ivl_lval_idx function\n * will return an expression if the property is in fact arrayed. The\n * expression is the canonical index for elements in the property.\n */\n\nextern unsigned    ivl_lval_width(ivl_lval_t net);\nextern ivl_expr_t  ivl_lval_mux(ivl_lval_t net) __attribute__((deprecated)); /* XXXX Obsolete? */\nextern ivl_expr_t  ivl_lval_idx(ivl_lval_t net);\nextern ivl_expr_t  ivl_lval_part_off(ivl_lval_t net);\nextern ivl_select_type_t ivl_lval_sel_type(ivl_lval_t net);\nextern int ivl_lval_property_idx(ivl_lval_t net);\nextern ivl_signal_t ivl_lval_sig(ivl_lval_t net);\nextern ivl_lval_t  ivl_lval_nest(ivl_lval_t net);\n\n\n/* NEXUS\n * connections of signals and nodes is handled by single-bit\n * nexus. These functions manage the ivl_nexus_t object. They also\n * manage the ivl_nexus_ptr_t objects that are closely related to the\n * nexus.\n *\n * ivl_nexus_name\n *    Each nexus is given a name, typically derived from the signals\n *    connected to it, but completely made up if need be. The name of\n *    every nexus is unique.\n *\n * ivl_nexus_ptrs\n *    This function returns the number of pointers that are held by\n *    the nexus. It should always return at least 1. The pointer\n *    proper is accessed by index.\n *\n * ivl_nexus_ptr\n *    Return a nexus pointer given the nexus and an index.\n *\n * ivl_nexus_set_private\n * ivl_nexus_get_private\n *    The target module often needs to associate data with a nexus for\n *    later use when the nexus is encountered associated with a\n *    device. These methods allow the code generator to store to or\n *    retrieve from a nexus a void* of private data. This pointer is\n *    guaranteed to be 0 before the target module is invoked.\n *\n * Once an ivl_nexus_ptr_t is selected by the ivl_nexus_ptr method,\n * the properties of the pointer can be accessed by the following\n * methods:\n *\n * ivl_nexus_ptr_pin\n *    This returns the pin number of the device where this nexus\n *    points. It is the bit within the signal or logic device that is\n *    connected to the nexus.\n *\n *    If the target is an LPM device, then this value is zero, and it\n *    is up to the application to find the pin that refers to this\n *    nexus. The problem is that LPM devices do not have a pinout per\n *    se, the pins all have specific names.\n *\n * ivl_nexus_ptr_con\n *    If this is a pointer to a magic constant device, then this\n *    returns the net_const object.\n *\n * ivl_nexus_ptr_drive0\n * ivl_nexus_ptr_drive1\n *    These are the 0 and 1 strength values for the devices. For most\n *    devices, these values are fixed by the description in the\n *    original source, with the default as IVL_DR_STRONG. For pins\n *    that are input only, drive0 and drive1 are both IVL_DR_HiZ.\n *\n *    The strength of strength-aware devices (such as nmos devices)\n *    does not really matter, as long as the output is not\n *    IVL_DR_HiZ. Testing for HiZ drivers is how code generators\n *    detect inputs.\n *\n * ivl_nexus_ptr_log\n *    If the target object is an ivl_net_logic_t, this method returns\n *    the object. Otherwise, this method returns 0.\n *\n * ivl_nexus_ptr_lpm\n *    If the target object is an ivl_lpm_t, this method returns the\n *    object. Otherwise, this method returns 0.\n *\n * ivl_nexus_ptr_sig\n *    If the target object is an ivl_signal_t, this method returns the\n *    object. If the target is not a signal, this method returns 0.\n *\n * SEMANTIC NOTES\n * All the device pins that connect to a nexus have the same\n * type. That means, for example, that vector pins have the same\n * width. The compiler will insure this is so.\n */\n\nextern const char*     ivl_nexus_name(ivl_nexus_t net) __attribute__((deprecated));\nextern unsigned        ivl_nexus_ptrs(ivl_nexus_t net);\nextern ivl_nexus_ptr_t ivl_nexus_ptr(ivl_nexus_t net, unsigned idx);\n\nextern void  ivl_nexus_set_private(ivl_nexus_t net, void*data);\nextern void* ivl_nexus_get_private(ivl_nexus_t net);\n\n\nextern ivl_drive_t  ivl_nexus_ptr_drive0(ivl_nexus_ptr_t net);\nextern ivl_drive_t  ivl_nexus_ptr_drive1(ivl_nexus_ptr_t net);\nextern unsigned     ivl_nexus_ptr_pin(ivl_nexus_ptr_t net);\nextern ivl_branch_t ivl_nexus_ptr_branch(ivl_nexus_ptr_t net);\nextern ivl_net_const_t ivl_nexus_ptr_con(ivl_nexus_ptr_t net);\nextern ivl_net_logic_t ivl_nexus_ptr_log(ivl_nexus_ptr_t net);\nextern ivl_lpm_t    ivl_nexus_ptr_lpm(ivl_nexus_ptr_t net);\nextern ivl_switch_t ivl_nexus_ptr_switch(ivl_nexus_ptr_t net);\nextern ivl_signal_t ivl_nexus_ptr_sig(ivl_nexus_ptr_t net);\n\n/* PARAMETER\n * Parameters are named constants associated with a scope. The user\n * may set in the Verilog source the value of parameters, and that\n * leads to ivl_parameter_t objects contained in the ivl_scope_t\n * objects.\n *\n * Parameters are essentially named constants. These constant values\n * can be accessed by looking at the scope (using ivl_scope_param) or\n * they can be discovered when they are used, via the\n * ivl_expr_parameter function. The fact that a constant has a name\n * (i.e. is a parameter) does not otherwise impose on the value or\n * interpretation of the constant expression so far as ivl_target is\n * concerned. The target may need this information, or may choose to\n * completely ignore it.\n *\n * ivl_parameter_basename\n *    return the name of the parameter.\n *\n * ivl_parameter_scope\n *    Return the scope of the parameter. The parameter name is only\n *    unique within its scope.\n *\n * ivl_parameter_expr\n *    Return the value of the parameter. This should be a simple\n *    constant expression, an IVL_EX_STRING or IVL_EX_NUMBER.\n *\n * ivl_parameter_msb\n * ivl_parameter_lsb\n *    Returns the MSB and LSB for the parameter. For a parameter without\n *    a range the value is zero based and the width of the expression is\n *    used to determine the MSB.\n *\n * ivl_parameter_width\n *    return |MSB - LSB| + 1\n *\n * ivl_parameter_signed\n *    Returns if the parameter was declared to be signed.\n *\n * ivl_parameter_local\n *    Return whether parameter was local (localparam, implicit genvar etc)\n *    or not.\n *\n * ivl_parameter_is_type\n *    Return whether the parameter is a type parameter or not.\n *\n * ivl_parameter_file\n * ivl_parameter_lineno\n *    Returns the file and line where this parameter is defined\n */\nextern const char* ivl_parameter_basename(ivl_parameter_t net);\nextern ivl_scope_t ivl_parameter_scope(ivl_parameter_t net);\nextern ivl_expr_t  ivl_parameter_expr(ivl_parameter_t net);\nextern int         ivl_parameter_msb(ivl_parameter_t net);\nextern int         ivl_parameter_lsb(ivl_parameter_t net);\nextern unsigned    ivl_parameter_width(ivl_parameter_t net);\nextern int         ivl_parameter_signed(ivl_parameter_t net);\nextern int         ivl_parameter_local(ivl_parameter_t net);\nextern int         ivl_parameter_is_type(ivl_parameter_t net);\nextern const char* ivl_parameter_file(ivl_parameter_t net);\nextern unsigned    ivl_parameter_lineno(ivl_parameter_t net);\n\n\n/* SCOPE\n * Scopes of various sort have these properties. Use these methods to\n * access them. Scopes come to exist in the elaborated design\n * generally when a module is instantiated, though they also come from\n * named blocks, tasks and functions.\n *\n * - module instances (IVL_SCT_MODULE)\n *    A module instance scope may contain events, logic gates, lpm\n *    nodes, signals, and possibly children. The children are further\n *    instances, or function/task scopes. Module instances do *not*\n *    contain a definition.\n *\n * - function scopes (IVL_SCT_FUNCTION)\n *    These scopes represent functions. A function may not be a root,\n *    so it is contained within a module instance scope. A function is\n *    required to have a definition (in the form of a statement) and a\n *    signal (IVL_SIG_REG) that is its return value.\n *\n *    A single function scope is created each time the module with the\n *    definition is instantiated.\n *\n *\n * - task scopes (IVL_SCT_TASK)\n *    [...]\n *\n * ivl_scope_attr_cnt\n * ivl_scope_attr_val\n *    A scope may have attributes attached to it. These functions\n *    allow the target to access the attributes values.\n *\n * ivl_scope_children\n *    A scope may in turn contain other scopes. This method iterates\n *    through all the child scopes of a given scope. If the function\n *    returns any value other than 0, the iteration stops and the\n *    method returns that value. Otherwise, iteration continues until\n *    the children run out.\n *\n *    If the scope has no children, this method will return 0 and\n *    otherwise do nothing.\n *\n * ivl_scope_childs\n * ivl_scope_child\n *    This is an alternative way of getting at the childs scopes of a\n *    given scope.\n *\n * ivl_scope_def\n *    Task definition scopes carry a task definition, in the form of\n *    a statement. This method accesses that definition. The\n *    ivl_scope_def function must return a statement for scopes that\n *    are type FUNCTION or TASK, and must return nil otherwise.\n *\n * ivl_scope_def_file\n * ivl_scope_def_lineno\n *    Returns the file and line where this scope is defined.\n *\n * ivl_scope_enumerate\n * ivl_scope_enumerates\n *    Scopes have 0 or more enumeration types in them.\n *\n * ivl_scope_event\n * ivl_scope_events\n *    Scopes have 0 or more event objects in them.\n *\n * ivl_scope_file\n * ivl_scope_lineno\n *    Returns the instantiation file and line for this scope.\n *\n * ivl_scope_func_type\n * ivl_scope_func_signed\n * ivl_scope_func_width\n *\n *    If the scope is a function, these function can be used to get\n *    the type of the return value.\n *\n * ivl_scope_is_auto\n *    Is the task or function declared to be automatic?\n *\n * ivl_scope_is_cell\n *    Is the module defined to be a cell?\n *\n * ivl_scope_var\n * ivl_scope_vars\n *    REMOVED\n *\n * ivl_scope_log\n * ivl_scope_logs\n *    Scopes have 0 or more logic devices in them. A logic device is\n *    represented by ivl_logic_t.\n *\n * ivl_scope_lpm\n * ivl_scope_lpms\n *    Scopes have 0 or more LPM devices in them. These functions access\n *    those devices.\n *\n * ivl_scope_name\n * ivl_scope_basename\n *    Every scope has a hierarchical name. This name is also a prefix\n *    of all the names of objects contained within the scope. The\n *    ivl_scope_basename is the name of the scope without the included\n *    hierarchy.\n *\n * ivl_scope_param\n * ivl_scope_params\n *    A scope has zero or more named parameters. These parameters have\n *    a name and an expression value.\n *\n * ivl_scope_parent\n *    If this is a non-root scope, then the parent is the scope that\n *    contains this scope. Otherwise, the parent is nil.\n *\n * ivl_scope_port\n * ivl_scope_ports\n *    Scopes that are functions or tasks have ports defined by\n *    signals. These methods access the ports by name.\n *\n *    If this scope represents a function, then the ports list\n *    includes the return value, as port 0. The remaining ports are\n *    the input ports in order.\n *\n * ivl_scope_sig\n * ivl_scope_sigs\n *    Scopes have 0 or more signals in them. These signals are\n *    anything that can become and ivl_signal_t, include synthetic\n *    signals generated by the compiler.\n *\n * ivl_scope_time_precision\n *    Scopes have their own intrinsic time precision, typically from\n *    the timescale compiler directive. This method returns the\n *    precision as a signed power of 10 value.\n *\n * ivl_scope_time_units\n *    Scopes have their own intrinsic time units, typically from the\n *    timescale compiler directive. This method returns the units as a\n *    signed power of 10 value.\n *\n * ivl_scope_type\n * ivl_scope_tname\n *    Scopes have a type and a type name. For example, if a scope is\n *    an instance of module foo, its type is IVL_SCT_MODULE and its\n *    type name is \"foo\". This is different from the instance name\n *    returned by ivl_scope_name above.\n */\n\nextern unsigned        ivl_scope_attr_cnt(ivl_scope_t net);\nextern ivl_attribute_t ivl_scope_attr_val(ivl_scope_t net, unsigned idx);\n\nextern int          ivl_scope_children(ivl_scope_t net,\n\t\t\t\t       ivl_scope_f func, void*cd);\n\nextern ivl_statement_t ivl_scope_def(ivl_scope_t net);\nextern const char* ivl_scope_def_file(ivl_scope_t net);\nextern unsigned ivl_scope_def_lineno(ivl_scope_t net);\n\nextern size_t      ivl_scope_childs(ivl_scope_t net);\nextern ivl_scope_t ivl_scope_child(ivl_scope_t net, size_t idx);\nextern unsigned   ivl_scope_classes(ivl_scope_t net);\nextern ivl_type_t ivl_scope_class(ivl_scope_t net, unsigned idx);\nextern unsigned       ivl_scope_enumerates(ivl_scope_t net);\nextern ivl_enumtype_t ivl_scope_enumerate(ivl_scope_t net, unsigned idx);\nextern unsigned     ivl_scope_events(ivl_scope_t net);\nextern ivl_event_t  ivl_scope_event(ivl_scope_t net, unsigned idx);\nextern const char* ivl_scope_file(ivl_scope_t net);\nextern unsigned ivl_scope_is_auto(ivl_scope_t net);\nextern unsigned ivl_scope_is_cell(ivl_scope_t net);\nextern unsigned ivl_scope_lineno(ivl_scope_t net);\nextern unsigned     ivl_scope_logs(ivl_scope_t net);\nextern ivl_net_logic_t ivl_scope_log(ivl_scope_t net, unsigned idx);\nextern unsigned     ivl_scope_lpms(ivl_scope_t net);\nextern ivl_lpm_t    ivl_scope_lpm(ivl_scope_t, unsigned idx);\nextern const char*  ivl_scope_name(ivl_scope_t net);\nextern const char*  ivl_scope_basename(ivl_scope_t net);\nextern unsigned     ivl_scope_params(ivl_scope_t net);\nextern ivl_parameter_t ivl_scope_param(ivl_scope_t net, unsigned idx);\nextern ivl_scope_t  ivl_scope_parent(ivl_scope_t net);\n\nextern unsigned ivl_scope_mod_module_ports(ivl_scope_t net);\nextern const char *ivl_scope_mod_module_port_name(ivl_scope_t net, unsigned idx );\nextern ivl_signal_port_t ivl_scope_mod_module_port_type(ivl_scope_t net, unsigned idx );\nextern unsigned ivl_scope_mod_module_port_width(ivl_scope_t net, unsigned idx );\nextern ivl_net_logic_t ivl_scope_mod_module_port_buffer(ivl_scope_t net, unsigned idx );\n\nextern unsigned     ivl_scope_ports(ivl_scope_t net);\nextern ivl_signal_t ivl_scope_port(ivl_scope_t net, unsigned idx);\nextern ivl_nexus_t  ivl_scope_mod_port(ivl_scope_t net, unsigned idx);\nextern unsigned     ivl_scope_sigs(ivl_scope_t net);\nextern ivl_signal_t ivl_scope_sig(ivl_scope_t net, unsigned idx);\nextern unsigned     ivl_scope_switches(ivl_scope_t net);\nextern ivl_switch_t ivl_scope_switch(ivl_scope_t net, unsigned idx);\nextern ivl_scope_type_t ivl_scope_type(ivl_scope_t net);\nextern const char*  ivl_scope_tname(ivl_scope_t net);\nextern int          ivl_scope_time_precision(ivl_scope_t net);\nextern int          ivl_scope_time_units(ivl_scope_t net);\n\nextern ivl_variable_type_t ivl_scope_func_type(ivl_scope_t net);\nextern int ivl_scope_func_signed(ivl_scope_t net);\nextern unsigned ivl_scope_func_width(ivl_scope_t net);\n\n/* SIGNALS\n * Signals are named things in the Verilog source, like wires and\n * regs, and also named things that are created as temporaries during\n * certain elaboration or optimization steps. A signal may also be a\n * port of a module or task.\n *\n * Signals have a name (obviously) and types. A signal may also be\n * signed or unsigned.\n *\n * ivl_signal_nex\n *    This is the nexus of the signal. This is used for managing\n *    connections to the rest of the net. There is exactly one pin for\n *    each word of a signal. Each word may in turn be a vector. The\n *    word address is the zero-based index for the word. It is up to\n *    the context to translate different bases to the canonical address.\n *\n * ivl_signal_array_base\n * ivl_signal_array_count\n * ivl_signal_array_addr_swapped\n *    The signal may be arrayed. If so, the array_count is >1. Each\n *    word of the array has its own nexus. The array_base is the\n *    address in the Verilog source for the canonical zero word. This\n *    may be negative, positive or zero. The array addresses may be\n *    reversed/swapped.\n *\n *    Note that arraying of the signal into words is distinct from the\n *    vectors. The width of a signal is the width of a WORD.\n *\n * ivl_signal_dimensions\n *    The signal may be an array (of vectors) in which case this\n *    function returns >0, the number of dimensions of the array.\n *\n * ivl_signal_discipline\n *    If the signal has been declared with a domain (Verilog-AMS) then\n *    this function will return a non-nil ivl_discipline_t.\n *\n * ivl_signal_msb (deprecated)\n * ivl_signal_lsb (deprecated)\n * ivl_signal_packed_dimensions\n * ivl_signal_packed_msb\n * ivl_signal_packed_lsb\n * ivl_signal_width\n *    These functions return the msb and lsb packed indices. The\n *    packed dimensions are declared differently from array\n *    dimensions, like so:\n *       reg [4:1][7:0] sig...\n *    which has two packed dimensions. The [4:1] dimension is the\n *    first, and so forth. If the signal is a scalar, it has 0\n *    dimension.\n *\n *    The ivl_signal_msb/ivl_signal_lsb functions are deprecated\n *    versions that only work with variables that have less than two\n *    dimensions. They will return msb==lsb==0 for scalars.\n *\n * ivl_signal_port\n *    If the signal is a port to a module, this function returns the\n *    port direction. If the signal is not a port, it returns\n *    IVL_SIP_NONE.\n *\n * ivl_signal_signed\n *    A signal, which is a vector, may be signed. In Verilog 2000, any\n *    net or variable may be signed. This function returns true if the\n *    signal is signed.\n *\n * ivl_signal_local\n *    A signal that was generated by the compiler as a place holder is\n *    marked as local.\n *\n * ivl_signal_forced_net\n *    Return whether the signal is a net that is the subject of a force\n *    statement.\n *\n * ivl_signal_type\n *    Return the type of the signal, i.e., reg, wire, tri0, etc.\n *\n * ivl_signal_data_type\n *    Return the data type of the signal, i.e. logic, real, bool,\n *    etc. All the signals connected to a nexus should have the same\n *    data type\n *\n * ivl_signal_npath\n * ivl_signal_path\n *    This function returns the delay path object for the signal. The\n *    delay path has this signal as the output, the source is attached\n *    to the delay path itself.\n *\n * ivl_signal_name (DEPRECATED)\n *    This function returns the fully scoped hierarchical name for the\n *    signal. The name refers to the entire vector that is the signal.\n *\n *    NOTE: This function is deprecated. The hierarchical name is too\n *    vague a construct when escaped names can have . characters in\n *    them. Do no use this function in new code, it will disappear.\n *\n * ivl_signal_basename\n *    This function returns the name of the signal, without the scope\n *    information. This is the tail of the signal name. Since Verilog\n *    has an escape syntax, this name can contain any ASCII\n *    characters, except NULL or white space. The leading \\ and\n *    trailing ' ' of escaped names in Verilog source are not part of\n *    the name, so not included here.\n *\n * ivl_signal_attr\n *    Icarus Verilog supports attaching attributes to signals, with\n *    the attribute value (a string) associated with a key. This\n *    function returns the attribute value for the given key. If the\n *    key does not exist, the function returns 0.\n *\n * ivl_signal_file\n * ivl_signal_lineno\n *    Returns the file and line where this signal is defined.\n */\n\nextern ivl_scope_t ivl_signal_scope(ivl_signal_t net);\nextern ivl_nexus_t ivl_signal_nex(ivl_signal_t net, unsigned word);\nextern int         ivl_signal_array_base(ivl_signal_t net);\nextern unsigned    ivl_signal_array_count(ivl_signal_t net);\nextern unsigned    ivl_signal_array_addr_swapped(ivl_signal_t net);\nextern unsigned    ivl_signal_dimensions(ivl_signal_t net);\nextern ivl_discipline_t ivl_signal_discipline(ivl_signal_t net);\nextern unsigned    ivl_signal_packed_dimensions(ivl_signal_t net);\nextern int         ivl_signal_packed_msb(ivl_signal_t net, unsigned dim);\nextern int         ivl_signal_packed_lsb(ivl_signal_t net, unsigned dim);\nextern int         ivl_signal_msb(ivl_signal_t net) __attribute__((deprecated));\nextern int         ivl_signal_lsb(ivl_signal_t net) __attribute__((deprecated));\nextern unsigned    ivl_signal_width(ivl_signal_t net);\nextern ivl_signal_port_t ivl_signal_port(ivl_signal_t net);\nextern int         ivl_signal_module_port_index(ivl_signal_t net);\nextern int         ivl_signal_signed(ivl_signal_t net);\nextern int         ivl_signal_integer(ivl_signal_t net);\nextern int         ivl_signal_local(ivl_signal_t net);\nextern unsigned    ivl_signal_forced_net(ivl_signal_t net);\nextern unsigned    ivl_signal_npath(ivl_signal_t net);\nextern ivl_delaypath_t ivl_signal_path(ivl_signal_t net, unsigned idx);\nextern ivl_signal_type_t ivl_signal_type(ivl_signal_t net);\nextern ivl_variable_type_t ivl_signal_data_type(ivl_signal_t net);\nextern ivl_type_t  ivl_signal_net_type(ivl_signal_t net);\nextern const char* ivl_signal_name(ivl_signal_t net);\nextern const char* ivl_signal_basename(ivl_signal_t net);\nextern const char* ivl_signal_attr(ivl_signal_t net, const char*key);\n\nextern const char* ivl_signal_file(ivl_signal_t net);\nextern unsigned ivl_signal_lineno(ivl_signal_t net);\n\nextern unsigned        ivl_signal_attr_cnt(ivl_signal_t net);\nextern ivl_attribute_t ivl_signal_attr_val(ivl_signal_t net, unsigned idx);\n\n/* ivl_nexus_t ivl_signal_pin(ivl_signal_t net, unsigned idx); */\n/* unsigned    ivl_signal_pins(ivl_signal_t net); */\n\n/*\n * These functions get information about a process. A process is\n * an initial or always block within the original Verilog source, that\n * is translated into a type and a single statement. (The statement\n * may be a compound statement.)\n *\n * ivl_process_type\n * ivl_process_analog\n *    The ivl_process_type function returns the type of the process,\n *    an \"initial\" or \"always\" statement. The ivl_process_analog\n *    returns true if the process is analog.\n *\n * ivl_process_scope\n *    A process is placed in a scope. The statement within the process\n *    operates within the scope of the process unless there are calls\n *    outside the scope.\n *\n * The ivl_process_stmt function gets the statement that forms the\n * process. See the statement related functions for how to manipulate\n * statements.\n *\n * Processes can have attributes attached to them. the attr_cnt and\n * attr_val methods return those attributes.\n */\nextern ivl_process_type_t ivl_process_type(ivl_process_t net);\nextern int ivl_process_analog(ivl_process_t net);\n\nextern ivl_scope_t ivl_process_scope(ivl_process_t net);\n\nextern ivl_statement_t ivl_process_stmt(ivl_process_t net);\n\nextern unsigned        ivl_process_attr_cnt(ivl_process_t net);\nextern ivl_attribute_t ivl_process_attr_val(ivl_process_t net, unsigned idx);\n\nextern const char* ivl_process_file(ivl_process_t net);\nextern unsigned ivl_process_lineno(ivl_process_t net);\n\n/*\n * These functions manage statements of various type. This includes\n * all the different kinds of statements (as enumerated in\n * ivl_statement_type_t) that might occur in behavioral code.\n *\n * The ivl_statement_type() function returns the type code for the\n * statement. This is the major type, and implies which of the later\n * functions are applicable to the statement.\n *\n * the ivl_statement_file() and _lineno() functions return the source\n * file and line number of the statement in the Verilog source. This\n * information is useful for diagnostic information.\n */\nextern ivl_statement_type_t ivl_statement_type(ivl_statement_t net);\n\nextern const char* ivl_stmt_file(ivl_statement_t net);\nextern unsigned ivl_stmt_lineno(ivl_statement_t net);\n\n/*\n * The following functions retrieve specific single values from the\n * statement. These values are the bits of data and parameters that\n * make up the statement. Many of these functions apply to more than\n * one type of statement, so the comment in front of them tells which\n * statement types can be passed to the function.\n *\n * FUNCTION SUMMARY:\n *\n * ivl_stmt_block_scope\n *    If the block is named, then there is a scope associated with\n *    this. The code generator may need to know this in order to\n *    handle disable statements.\n *\n * ivl_stmt_events\n * ivl_stmt_needs_t0_trigger\n * ivl_stmt_nevent\n *    Statements that have event arguments (TRIGGER and WAIT) make\n *    those event objects available through these methods.\n *\n* ivl_stmt_lval\n * ivl_stmt_lvals\n *    Return the number of l-values for an assignment statement, or\n *    the specific l-value. If there is more than 1 l-value, then the\n *    l-values are presumed to be vector values concatenated together\n *    from msb (idx==0) to lsb.\n *\n * ivl_stmt_rval\n *    Return the rval expression of the assignment. This is the value\n *    that is to be calculated and assigned to the l-value in all the\n *    assignment statements.\n *\n * ivl_stmt_sub_stmt\n *    Some statements contain a single, subordinate statement. An\n *    example is the IVL_ST_WAIT, which contains the statement to be\n *    executed after the wait completes. This method retrieves that\n *    sub-statement.\n *\n * SEMANTIC NOTES:\n *\n * - Assignments: IVL_ST_ASSIGN, IVL_ST_ASSIGN_NB, IVL_CASSIGN, IVL_ST_FORCE\n *\n * The assignments support ivl_stmt_rval to get the r-value expression\n * that is to be assign to the l-value, and ivl_stmt_lval[s] to get\n * the l-value that receives the value. The compiler has already made\n * sure that the types (l-value and r-value) are compatible.\n *\n * If the l-value is a vector, then the compiler also makes sure the\n * expression width of the r-values matches. It handles padding or\n * operator sizing as needed to get the width exactly right.\n *\n * The blocking and non-blocking assignments may also have an internal\n * delay. These are of the form \"lval = #<delay> rval;\" and <delay> is\n * the internal delay expression. (It is internal because it is inside\n * the statement.) The ivl_stmt_delay_expr function returns the\n * expression for the delay, or nil if there is no delay expression.\n *\n * The blocking assignment (IVL_ST_ASSIGN) may have an associated\n * opcode, that can be extracted from ivl_stmt_opcode(). This opcode\n * is the compressed operator used it statements like this:\n *      foo += <expr>\n * The ivl_stmt_opcode() returns null (0) if this is not a compressed\n * assignment statement.\n *\n * - IVL_ST_CASSIGN\n * This reflects a procedural continuous assignment to an l-value. The\n * l-value is the same as any other assignment (use ivl_stmt_lval).\n *\n * The value to be assigned is an ivl_expr_t retrieved by the\n * ivl_stmt_rval function. The run time is expected to calculate the\n * value of the expression at the assignment, then continuous assign\n * that constant value. If the expression is non-constant, the code\n * generator is supposed to know what to do about that, too.\n *\n * - IVL_ST_CONTRIB\n * This is an analog contribution statement. The ivl_stmt_lexp\n * function returns the l-value expression which is guaranteed to be a\n * branch access expression. The ivl_stmt_rval returns the r-value\n * expression for the assignment.\n *\n * - IVL_ST_DELAY, IVL_ST_DELAYX\n * These statement types are delay statements. They are a way to\n * attach a delay to a statement. The ivl_stmt_sub_stmt() function\n * gets the statement to be executed after the delay. If this is\n * IVL_ST_DELAY, then the ivl_stmt_delay_val function gets the\n * constant delay. If this is IVL_ST_DELAYX, then the\n * ivl_stmt_delay_expr gets the expression of the delay. In this case,\n * the expression is not necessarily constant.\n *\n * Whether constant or calculated, the resulting delay is in units of\n * simulation ticks. The compiler has already taken care of converting\n * the delay to the time scale/precision of the scope.\n *\n * - IVL_ST_FORCE\n * This is very much like IVL_ST_CASSIGN, but adds that l-values can\n * include nets (tri, wire, etc). Memory words are restricted from\n * force l-values, and also non-constant bit or part selects. The\n * compiler will assure these constraints are met.\n *\n * - IVL_ST_FORLOOP\n * This contains the key portions of a for loop, broken into the init\n * statement, the sub statement, and the step statement. There is also\n * a condition expression that the code generator must check. It is up\n * to the target code generator to put these to use. In general, the\n * result needs to reflect this:\n *\n *      ivl_stmt_init_stmt(net);\n *      while( <ivl_stmt_cond_expr> is true ) {\n *          ivl_stmt_sub_stmt(net);\n *        continue_label:\n *          ivl_stmt_step_stmt(net);\n *      }\n *      out_label:\n *\n * - IVL_ST_TRIGGER\n * This represents the \"-> name\" statement that sends a trigger to a\n * named event. The ivl_stmt_nevent function should always return 1,\n * and the ivl_stmt_events(net,0) function returns the target event,\n * as an ivl_event_t. The only behavior of this statement is to send a\n * \"trigger\" to the target event.\n *\n * - IVL_ST_WAIT\n * This is the edge sensitive wait (for event) statement. The\n * statement contains an array of events that are to be tested, and a\n * single statement that is to be executed when any of the array of\n * events triggers.\n *\n * the ivl_stmt_events function accesses the array of events to wait\n * for, and the ivl_stmt_sub_stmt function gets the sub-statement,\n * which may be null, that is to be executed when an event\n * triggers. The statement waits even if the sub-statement is nul.\n */\n\n  /* IVL_ST_BLOCK, IVL_ST_FORK, IVL_ST_FORK_JOIN_ANY, IVL_ST_FORK_JOIN_NONE */\nextern unsigned ivl_stmt_block_count(ivl_statement_t net);\n  /* IVL_ST_BLOCK, IVL_ST_FORK, IVL_ST_FORK_JOIN_ANY, IVL_ST_FORK_JOIN_NONE */\nextern ivl_scope_t ivl_stmt_block_scope(ivl_statement_t net);\n  /* IVL_ST_BLOCK, IVL_ST_FORK, IVL_ST_FORK_JOIN_ANY, IVL_ST_FORK_JOIN_NONE */\nextern ivl_statement_t ivl_stmt_block_stmt(ivl_statement_t net, unsigned i);\n  /* IVL_ST_UTASK IVL_ST_DISABLE */\nextern ivl_scope_t ivl_stmt_call(ivl_statement_t net);\n  /* IVL_ST_CASE,IVL_ST_CASER,IVL_ST_CASEX,IVL_ST_CASEZ */\nextern unsigned ivl_stmt_case_count(ivl_statement_t net);\n  /* IVL_ST_CASE,IVL_ST_CASER,IVL_ST_CASEX,IVL_ST_CASEZ */\nextern ivl_expr_t ivl_stmt_case_expr(ivl_statement_t net, unsigned i);\n  /* IVL+ST_CASE,IVL_ST_CASER,IVL_ST_CASEX,IVL_ST_CASEZ */\nextern ivl_case_quality_t ivl_stmt_case_quality(ivl_statement_t net);\n  /* IVL_ST_CASE,IVL_ST_CASER,IVL_ST_CASEX,IVL_ST_CASEZ */\nextern ivl_statement_t ivl_stmt_case_stmt(ivl_statement_t net, unsigned i);\n  /* IVL_ST_CONDIT IVL_ST_FORLOOP IVL_ST_CASE IVL_ST_REPEAT IVL_ST_WHILE */\nextern ivl_expr_t      ivl_stmt_cond_expr(ivl_statement_t net);\n  /* IVL_ST_CONDIT */\nextern ivl_statement_t ivl_stmt_cond_false(ivl_statement_t net);\n  /* IVL_ST_CONDIT */\nextern ivl_statement_t ivl_stmt_cond_true(ivl_statement_t net);\n  /* IVL_ST_ASSIGN IVL_ST_ASSIGN_NB IVL_ST_DELAYX */\nextern ivl_expr_t ivl_stmt_delay_expr(ivl_statement_t net);\n  /* IVL_ST_DELAY */\nextern uint64_t ivl_stmt_delay_val(ivl_statement_t net);\n  /* IVL_ST_WAIT IVL_ST_TRIGGER */\nextern unsigned    ivl_stmt_needs_t0_trigger(ivl_statement_t net);\nextern unsigned    ivl_stmt_nevent(ivl_statement_t net);\nextern ivl_event_t ivl_stmt_events(ivl_statement_t net, unsigned idx);\n  /* IVL_ST_DISABLE */\nextern bool ivl_stmt_flow_control(ivl_statement_t net);\n  /* IVL_ST_CONTRIB */\nextern ivl_expr_t ivl_stmt_lexp(ivl_statement_t net);\n  /* IVL_ST_ASSIGN IVL_ST_ASSIGN_NB IVL_ST_CASSIGN IVL_ST_DEASSIGN\n     IVL_ST_FORCE IVL_ST_RELEASE */\nextern ivl_lval_t ivl_stmt_lval(ivl_statement_t net, unsigned idx);\n  /* IVL_ST_ASSIGN IVL_ST_ASSIGN_NB IVL_ST_CASSIGN IVL_ST_DEASSIGN\n     IVL_ST_FORCE IVL_ST_RELEASE */\nextern unsigned ivl_stmt_lvals(ivl_statement_t net);\n  /* IVL_ST_ASSIGN IVL_ST_ASSIGN_NB IVL_ST_CASSIGN */\nextern unsigned ivl_stmt_lwidth(ivl_statement_t net);\n  /* IVL_ST_STASK */\nextern const char* ivl_stmt_name(ivl_statement_t net);\n  /* IVL_ST_ASSIGN */\nextern char ivl_stmt_opcode(ivl_statement_t net);\n  /* IVL_ST_STASK */\nextern ivl_expr_t ivl_stmt_parm(ivl_statement_t net, unsigned idx);\n  /* IVL_ST_STASK */\nextern unsigned ivl_stmt_parm_count(ivl_statement_t net);\n  /* IVL_ST_ASSIGN IVL_ST_ASSIGN_NB IVL_ST_CASSIGN IVL_ST_CONTRIB\n     IVL_ST_FORCE */\nextern ivl_expr_t ivl_stmt_rval(ivl_statement_t net);\n  /* IVL_ST_STASK */\nextern ivl_sfunc_as_task_t ivl_stmt_sfunc_as_task(ivl_statement_t net);\n  /* IVL_ST_DELAY, IVL_ST_DELAYX, IVL_ST_FOREVER, IVL_ST_FORLOOP,\n     IVL_ST_REPEAT, IVL_ST_WAIT, IVL_ST_WHILE */\nextern ivl_statement_t ivl_stmt_sub_stmt(ivl_statement_t net);\n  /* IVL_ST_FORLOOP */\nextern ivl_statement_t ivl_stmt_init_stmt(ivl_statement_t net);\n  /* IVL_ST_FORLOOP */\nextern ivl_statement_t ivl_stmt_step_stmt(ivl_statement_t net);\n\n\n/* SWITCHES\n *\n * The switches represent the tran devices in the design.\n *\n * FUNCTION SUMMARY\n *\n * ivl_switch_type\n *    Return the enumerated value that is the type of the switch.\n *\n * ivl_switch_basename\n *    This is the name given to the device in the source code.\n *\n * ivl_switch_a\n * ivl_switch_b\n *    The a and b ports are the two ports of the switch.\n *\n * ivl_switch_enable\n *    If the device has an enable (tranifX) then this is the enable\n *    port.\n *\n * SEMANTIC NOTES\n * The a/b ports can be any type, but the types must exactly\n * match, including vector widths. The enable must be a scalar.\n *\n * The IVL_SW_TRAN_VP is an exception to the above. In this case,\n * the B side may be a different size, and the a side will have a\n * a fixed width. The unused bits are padded to Z on the A side.\n */\nextern ivl_switch_type_t ivl_switch_type(ivl_switch_t net);\nextern ivl_scope_t ivl_switch_scope(ivl_switch_t net);\nextern const char*ivl_switch_basename(ivl_switch_t net);\nextern ivl_nexus_t ivl_switch_a(ivl_switch_t net);\nextern ivl_nexus_t ivl_switch_b(ivl_switch_t net);\nextern ivl_nexus_t ivl_switch_enable(ivl_switch_t net);\nextern ivl_island_t ivl_switch_island(ivl_switch_t net);\n\n  /* These are only support for IVL_SW_TRAN_VP switches. */\nextern unsigned ivl_switch_width(ivl_switch_t net);\nextern unsigned ivl_switch_part(ivl_switch_t net);\nextern unsigned ivl_switch_offset(ivl_switch_t net);\nextern ivl_expr_t ivl_switch_delay(ivl_switch_t net, unsigned transition);\n\n/* Not implemented yet\nextern unsigned        ivl_switch_attr_cnt(ivl_switch_t net);\nextern ivl_attribute_t ivl_switch_attr_val(ivl_switch_t net, unsigned idx);\n*** */\nextern const char* ivl_switch_file(ivl_switch_t net);\nextern unsigned ivl_switch_lineno(ivl_switch_t net);\n\n/* TYPES\n *\n * ivl_type_base\n *    This returns the base type for the type. See the\n *    ivl_variable_type_t definition for the various base types.\n *\n * ivl_type_element\n *    Return the type of the element of an array. This is only valid\n *    for array types.\n *\n * ivl_type_packed_width\n *    Returns the total width of all packed dimensions.\n *\n * ivl_type_signed\n *    Return TRUE if the type represents a signed packed vector or\n *    signed atomic type, and FALSE otherwise.\n *\n * SEMANTIC NOTES\n *\n * Class types have names and properties.\n */\nextern ivl_variable_type_t ivl_type_base(ivl_type_t net);\nextern ivl_type_t ivl_type_element(ivl_type_t net);\nextern unsigned ivl_type_packed_dimensions(ivl_type_t net);\nextern int ivl_type_packed_lsb(ivl_type_t net, unsigned dim);\nextern int ivl_type_packed_msb(ivl_type_t net, unsigned dim);\nextern unsigned ivl_type_packed_width(ivl_type_t net);\nextern int ivl_type_signed(ivl_type_t net);\nextern const char* ivl_type_name(ivl_type_t net);\nextern int         ivl_type_properties(ivl_type_t net);\nextern const char* ivl_type_prop_name(ivl_type_t net, int idx);\nextern ivl_type_t  ivl_type_prop_type(ivl_type_t net, int idx);\n\n\n#if defined(__MINGW32__) || defined (__CYGWIN__)\n#  define DLLEXPORT __declspec(dllexport)\n#else\n#  define DLLEXPORT\n#endif\n\nextern DLLEXPORT int target_design(ivl_design_t des);\nextern DLLEXPORT const char* target_query(const char*key);\n\n/* target_design\n\n   The \"target_design\" function is called once after the whole design\n   is processed and available to the target. The target doesn't return\n   from this function until it is finished with the design.\n\n   The return value of this function should normally be zero. If the\n   code generator detects errors, however, then the code generator\n   returns a positive number to indicate the approximate number of\n   errors detected (before it gave up.) Return values <0 are reserved\n   for system and infrastructure errors.\n\n   This function is implemented in the loaded target, and not in the\n   ivl core. This function is how the target module is invoked. */\n\ntypedef int  (*target_design_f)(ivl_design_t des);\ntypedef const char* (*target_query_f) (const char*key);\n\n\n_END_DECL\n\n#undef ENUM_UNSIGNED_INT\n\n#endif /* IVL_ivl_target_H */\n\n"
        },
        {
          "name": "ivl_target_priv.h",
          "type": "blob",
          "size": 2.74609375,
          "content": "#ifndef IVL_ivl_target_priv_H\n#define IVL_ivl_target_priv_H\n/*\n * Copyright (c) 2008-2019 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"ivl_target.h\"\n# include  <inttypes.h>\n# include  <map>\n# include  <vector>\n# include  <ostream>\n# include  <valarray>\n\nclass NetScope;\n\n/*\n* This header has declarations related to the ivl_target.h API that\n* are not to be exported outside of the core via the ivl_target.h\n* interface.\n*\n* (NOTE: A lot of similar definitions exist in the t-dll.h header\n* file. That is a legacy from an earlier time before the\n* ivl_target_priv.h header file was started, and those definitions\n* should gradually be moved over to this header file.)\n*/\n\n/*\n * This is the root of a design, from the ivl_target point of few. The\n * ivl_target API uses this as the root for getting at everything else\n * in the design.\n */\nstruct ivl_design_s {\n\n      int time_precision;\n\n      ivl_process_t threads_;\n\n\t// Keep arrays of root scopes.\n      std::vector<ivl_scope_t> packages;\n      std::vector<ivl_scope_t> roots;\n\n\t// This is used to implement the ivl_design_roots function.\n      std::vector<ivl_scope_t> root_scope_list;\n\n\t// Keep an array of constants objects.\n      std::vector<ivl_net_const_t> consts;\n\n\t// Keep a handy array of all of the disciplines in the design.\n      std::valarray<ivl_discipline_t> disciplines;\n\n      const class Design*self;\n};\n\n/*\n * A branch is a pair of terminals. The elaborator assures that the\n * terminals have compatible disciplines.\n */\nstruct ivl_branch_s {\n      ivl_nexus_t pins[2];\n      ivl_island_t island;\n};\n\n/*\n* Information about islands. Connected branches within a net are\n* collected into islands. Branches that are purely ddiscrete do not\n* have disciplines and do not belong to islands.\n*/\n\nstruct ivl_island_s {\n      ivl_discipline_t discipline;\n\t// user accessible flags. They are initially false, always.\n      std::vector<bool> flags;\n};\n\nextern std::ostream& operator << (std::ostream&o, ivl_drive_t str);\n\n#endif /* IVL_ivl_target_priv_H */\n"
        },
        {
          "name": "ivlpp",
          "type": "tree",
          "content": null
        },
        {
          "name": "ivtest",
          "type": "tree",
          "content": null
        },
        {
          "name": "lexor.lex",
          "type": "blob",
          "size": 46.82421875,
          "content": "%option prefix=\"VL\"\n%option never-interactive\n%option nounput\n\n%{\n/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n      //# define YYSTYPE lexval\n\n# include  <climits>\n# include  <cstdarg>\n# include  <iostream>\n# include  \"compiler.h\"\n# include  \"parse_misc.h\"\n# include  \"parse_api.h\"\n# include  \"parse.h\"\n# include  <cctype>\n# include  <cstring>\n# include  \"lexor_keyword.h\"\n# include  \"discipline.h\"\n# include  <list>\n\nusing namespace std;\n\n# define YY_USER_INIT do { reset_lexor(); yylloc.lexical_pos = 0; } while (0);\n# define yylval VLlval\n\n# define YY_NO_INPUT\n\n/*\n * Lexical location information is passed in the yylloc variable to th\n * parser. The file names, strings, are kept in a list so that I can\n * re-use them. The set_file_name function will return a pointer to\n * the name as it exists in the list (and delete the passed string.)\n * If the name is new, it will be added to the list.\n */\nextern YYLTYPE yylloc;\n\nchar* yytext_string_filter(const char*str, size_t str_len)\n{\n      if (str == 0) return 0;\n      char*buf = new char[str_len+1];\n      size_t didx = 0;\n      for (size_t sidx = 0 ; sidx < str_len ; sidx += 1, didx += 1) {\n\t    if (str[sidx] == 0) {\n\t\t  VLerror(yylloc, \"error: Found nil (\\\\000) in string literal, replacing with space (\\\\015) character.\");\n\t\t  buf[didx] = ' ';\n\t    } else if (str[sidx] == '\\\\') { /* Skip \\\\\\n */\n\t\t  if ((sidx+1 < str_len) && (str[sidx+1] == '\\n')) {\n\t\t\tsidx += 1;\n\t\t\tdidx -= 1;\n\t\t  } else {\n\t\t\tbuf[didx] = str[sidx];\n\t\t  }\n\t    } else {\n\t\t  buf[didx] = str[sidx];\n\t    }\n      }\n      buf[didx] = 0;\n      return buf;\n}\n\nchar* strdupnew(char const *str)\n{\n       return str ? strcpy(new char [strlen(str)+1], str) : NULL;\n}\n\nstatic const char* set_file_name(char*text)\n{\n      perm_string path = filename_strings.make(text);\n      delete[]text;\n\n\t/* Check this file name with the list of library file\n\t   names. If there is a match, then turn on the\n\t   pform_library_flag. This is how the parser knows that\n\t   modules declared in this file are library modules. */\n      pform_library_flag = library_file_map[path];\n      return path;\n}\n\nvoid reset_lexor();\nstatic void line_directive();\nstatic void line_directive2();\nstatic void reset_all();\n\nverinum*make_unsized_binary(const char*txt);\nverinum*make_undef_highz_dec(const char*txt);\nverinum*make_unsized_dec(const char*txt);\nverinum*make_unsized_octal(const char*txt);\nverinum*make_unsized_hex(const char*txt);\n\nstatic int dec_buf_div2(char *buf);\n\nstatic int get_timescale_scale(const char*cp);\nstatic int get_timescale_const(int scale, const char*units);\n\nstatic void process_ucdrive(const char*txt);\n\nstatic list<int> keyword_mask_stack;\n\nstatic int comment_enter;\nstatic bool in_module = false;\nstatic bool in_UDP = false;\nbool in_celldefine = false;\nUCDriveType uc_drive = UCD_NONE;\nstatic int ts_state = 0;\nstatic int ts_scale = 0;\nstatic int ts_unit = 0;\nstatic int ts_prec = 0;\n\n/*\n * The parser sometimes needs to indicate to the lexor that the next\n * identifier needs to be understood in the context of a package. The\n * parser feeds back that left context with calls to the\n * lex_in_package_scope.\n */\nstatic PPackage* in_package_scope = 0;\nvoid lex_in_package_scope(PPackage*pkg)\n{\n      in_package_scope = pkg;\n}\n\n%}\n\n%x CCOMMENT\n%x PCOMMENT\n%x LCOMMENT\n%x CSTRING\n%s UDPTABLE\n%x PPTIMESCALE_SCALE\n%x PPTIMESCALE_UNITS\n%x PPTIMESCALE_SLASH\n%x PPTIMESCALE_ERROR\n%x PPUCDRIVE\n%x PPUCDRIVE_ERROR\n%x PPDEFAULT_NETTYPE\n%x PPDEFAULT_NETTYPE_ERROR\n%x PPBEGIN_KEYWORDS\n%x PPBEGIN_KEYWORDS_ERROR\n%s EDGES\n%x REAL_SCALE\n\nW [ \\t\\b\\f\\r]+\n\nS [afpnumkKMGT]\n\nTU [munpf]\n\n%%\n\n  /* Recognize the various line directives. */\n^\"#line\"[ \\t]+.+ { line_directive(); }\n^[ \\t]*\"`line\"[ \\t]+.+ { line_directive2(); }\n\n[ \\t\\b\\f\\r] { ; }\n\\n { yylloc.first_line += 1; }\n\n  /* C++ style comments start with / / and run to the end of the\n     current line. These are very easy to handle. The meta-comments\n     format is a little more tricky to handle, but do what we can. */\n\n  /* The lexor detects \"// synthesis translate_on/off\" meta-comments,\n     we handle them here by turning on/off a flag. The pform uses\n     that flag to attach implicit attributes to \"initial\" and\n     \"always\" statements. */\n\n\"// Icarus preprocessor had (\"[0-9]+\") errors.\"\\n { pre_process_failed(yytext); }\n\"//\"{W}*\"synthesis\"{W}+\"translate_on\"{W}*\\n { pform_mc_translate_on(true); }\n\"//\"{W}*\"synthesis\"{W}+\"translate_off\"{W}*\\n { pform_mc_translate_on(false); }\n\"//\" { comment_enter = YY_START; BEGIN(LCOMMENT); }\n<LCOMMENT>.    { yymore(); }\n<LCOMMENT>\\n   { yylloc.first_line += 1; BEGIN(comment_enter); }\n\n\n  /* The contents of C-style comments are ignored, like white space. */\n\n\"/*\" { comment_enter = YY_START; BEGIN(CCOMMENT); }\n<CCOMMENT>.    { ; }\n  /* Check for a possible nested comment. */\n<CCOMMENT>\"/*\" { VLerror(yylloc, \"error: Possible nested comment.\"); }\n<CCOMMENT>\\n   { yylloc.first_line += 1; }\n<CCOMMENT>\"*/\" { BEGIN(comment_enter); }\n\n\n\"(*\" { return K_PSTAR; }\n\"*)\" { return K_STARP; }\n\".*\" { return K_DOTSTAR; }\n\"<<\" { return K_LS; }\n\"<<<\" { return K_LS; /* Note: Functionally, <<< is the same as <<. */}\n\">>\"  { return K_RS; }\n\">>>\" { return K_RSS; }\n\"**\" { return K_POW; }\n\"<=\" { return K_LE; }\n\">=\" { return K_GE; }\n\"=>\" { return K_EG; }\n\"+=>\"|\"-=>\"\t{\n\t\t\t/*\n\t\t\t * Resolve the ambiguity between the += assignment\n\t\t\t * operator and +=> polarity edge path operator\n\t\t\t *\n\t\t\t * +=> should be treated as two separate tokens '+' and\n\t\t\t * '=>' (K_EG), therefore we only consume the first\n\t\t\t * character of the matched pattern i.e. either + or -\n\t\t\t * and push back the rest of the matches text (=>) in\n\t\t\t * the input stream.\n\t\t\t */\n\t\t\tyyless(1);\n\t\t\treturn yytext[0];\n\t\t}\n\"*>\" { return K_SG; }\n\"==\" { return K_EQ; }\n\"!=\" { return K_NE; }\n\"===\" { return K_CEQ; }\n\"!==\" { return K_CNE; }\n\"==?\" { return K_WEQ; }\n\"!=?\" { return K_WNE; }\n\"||\" { return K_LOR; }\n\"&&\" { return K_LAND; }\n\"<->\" { return K_LEQUIV; }\n\"&&&\" { return K_TAND; }\n\"~|\" { return K_NOR; }\n\"~^\" { return K_NXOR; }\n\"^~\" { return K_NXOR; }\n\"~&\" { return K_NAND; }\n\"->\" { return K_TRIGGER; }\n\"->>\" { return K_NB_TRIGGER; }\n\"+:\" { return K_PO_POS; }\n\"-:\" { return K_PO_NEG; }\n\"<+\" { return K_CONTRIBUTE; }\n\"+=\" { return K_PLUS_EQ; }\n\"-=\" { return K_MINUS_EQ; }\n\"*=\" { return K_MUL_EQ; }\n\"/=\" { return K_DIV_EQ; }\n\"%=\" { return K_MOD_EQ; }\n\"&=\" { return K_AND_EQ; }\n\"|=\" { return K_OR_EQ; }\n\"^=\" { return K_XOR_EQ; }\n\"<<=\" { return K_LS_EQ; }\n\">>=\" { return K_RS_EQ; }\n\"<<<=\" { return K_LS_EQ; }\n\">>>=\" { return K_RSS_EQ; }\n\"++\" { return K_INCR; }\n\"--\" {return K_DECR; }\n\"'{\" { return K_LP; }\n\"::\" { return K_SCOPE_RES; }\n\n  /* This is horrible. The Verilog systax uses \"->\" in a lot of places.\n     The trickiest is in constraints, where it is not an operator at all\n     but a constraint implication. This only turns up as a problem when\n     the \"->\" is followed by a constraint_expression_list. If that shows\n     up, then there will be a \"{\" to the right of the \"->\". In that case,\n     turn the \"->\" into a K_CONSTRAINT_IMPL so that the parser can be\n     written without the shift/reduce conflict. Ugh! */\n\"->\"/{W}*\"{\" { return gn_system_verilog()? K_CONSTRAINT_IMPL :  K_TRIGGER; }\n\n  /* Watch out for the tricky case of (*). Cannot parse this as \"(*\"\n     and \")\", but since I know that this is really ( * ), replace it\n     with \"*\" and return that. */\n\"(\"{W}*\"*\"{W}*\")\" { return '*'; }\n\n<EDGES>\"]\" { BEGIN(0); return yytext[0]; }\n[}{;:\\[\\],()#=.@&!?<>%|^~+*/-] { return yytext[0]; }\n\n\\\"            { BEGIN(CSTRING); }\n<CSTRING>\\\\\\\\ { yymore(); /* Catch \\\\, which is a \\ escaping itself */ }\n<CSTRING>\\\\\\\" { yymore(); /* Catch \\\", which is an escaped quote */ }\n<CSTRING>\\\\\\n { yymore(); /* Catch \\\\n, which will be filtered out */\n\t\tyylloc.first_line += 1; }\n<CSTRING>\\n   { BEGIN(0);\n\t\tyylval.text = yytext_string_filter(yytext, yyleng);\n\t\tVLerror(yylloc, \"error: Missing closing quote for string.\");\n\t\tyylloc.first_line += 1;\n\t\treturn STRING; }\n<CSTRING>\\\"   { BEGIN(0);\n\t\tyylval.text = yytext_string_filter(yytext, yyleng);\n\t\tyylval.text[strlen(yylval.text)-1] = 0;\n\t\treturn STRING; }\n<CSTRING>.    { yymore(); }\n\n  /* The UDP Table is a unique lexical environment. These are most\n     tokens that we can expect in a table. */\n<UDPTABLE>\\(\\?0\\)    { return '_'; }\n<UDPTABLE>\\(\\?1\\)    { return '+'; }\n<UDPTABLE>\\(\\?[xX]\\) { return '%'; }\n<UDPTABLE>\\(\\?\\?\\)  { return '*'; }\n<UDPTABLE>\\(01\\)    { return 'r'; }\n<UDPTABLE>\\(0[xX]\\) { return 'Q'; }\n<UDPTABLE>\\(b[xX]\\) { return 'q'; }\n<UDPTABLE>\\(b0\\)    { return 'f'; /* b0 is 10|00, but only 10 is meaningful */}\n<UDPTABLE>\\(b1\\)    { return 'r'; /* b1 is 11|01, but only 01 is meaningful */}\n<UDPTABLE>\\(0\\?\\)   { return 'P'; }\n<UDPTABLE>\\(10\\)    { return 'f'; }\n<UDPTABLE>\\(1[xX]\\) { return 'M'; }\n<UDPTABLE>\\(1\\?\\)   { return 'N'; }\n<UDPTABLE>\\([xX]0\\) { return 'F'; }\n<UDPTABLE>\\([xX]1\\) { return 'R'; }\n<UDPTABLE>\\([xX]\\?\\) { return 'B'; }\n<UDPTABLE>[bB]     { return 'b'; }\n<UDPTABLE>[lL]     { return 'l'; /* IVL extension */ }\n<UDPTABLE>[hH]     { return 'h'; /* IVL extension */ }\n<UDPTABLE>[fF]     { return 'f'; }\n<UDPTABLE>[rR]     { return 'r'; }\n<UDPTABLE>[xX]     { return 'x'; }\n<UDPTABLE>[nN]     { return 'n'; }\n<UDPTABLE>[pP]     { return 'p'; }\n<UDPTABLE>[01\\?\\*\\-:;] { return yytext[0]; }\n\n<EDGES>\"01\" { return K_edge_descriptor; }\n<EDGES>\"0x\" { return K_edge_descriptor; }\n<EDGES>\"0z\" { return K_edge_descriptor; }\n<EDGES>\"10\" { return K_edge_descriptor; }\n<EDGES>\"1x\" { return K_edge_descriptor; }\n<EDGES>\"1z\" { return K_edge_descriptor; }\n<EDGES>\"x0\" { return K_edge_descriptor; }\n<EDGES>\"x1\" { return K_edge_descriptor; }\n<EDGES>\"z0\" { return K_edge_descriptor; }\n<EDGES>\"z1\" { return K_edge_descriptor; }\n\n[a-zA-Z_][a-zA-Z0-9$_]* {\n      int rc = lexor_keyword_code(yytext, yyleng);\n      switch (rc) {\n\t  case IDENTIFIER:\n\t    assert(yylloc.lexical_pos != UINT_MAX);\n\t    yylloc.lexical_pos += 1;\n\t    yylval.text = strdupnew(yytext);\n\t    if (strncmp(yylval.text,\"PATHPULSE$\", 10) == 0)\n\t\t  rc = PATHPULSE_IDENTIFIER;\n\t    break;\n\n\t  case K_edge:\n\t    BEGIN(EDGES);\n\t    break;\n\n\t  case K_module:\n\t  case K_macromodule:\n\t    in_module = true;\n\t    break;\n\n\t  case K_endmodule:\n\t    in_module = false;\n\t    break;\n\n\t  case K_primitive:\n\t    in_UDP = true;\n\t    break;\n\n\t  case K_endprimitive:\n\t    in_UDP = false;\n\t    break;\n\n\t  case K_table:\n\t    BEGIN(UDPTABLE);\n\t    break;\n\n\t  default:\n\t    yylval.text = 0;\n\t    break;\n      }\n\n\t/* Special case: If this is part of a scoped name, then check\n\t   the package for identifier details. For example, if the\n\t   source file is  foo::bar, the parse.y will note the\n\t   PACKAGE_IDENTIFIER and \"::\" token and mark the\n\t   \"in_package_scope\" variable. Then this lexor will see the\n\t   identifier here and interpret it in the package scope. */\n      if (in_package_scope) {\n\t    if (rc == IDENTIFIER) {\n\t\t  if (typedef_t*type = pform_test_type_identifier(in_package_scope, yylval.text)) {\n\t\t\tyylval.type_identifier.text = yylval.text;\n\t\t\tyylval.type_identifier.type = type;\n\t\t\trc = TYPE_IDENTIFIER;\n\t\t  }\n\t    }\n\t    in_package_scope = 0;\n\t    return rc;\n      }\n\n\t/* If this identifier names a discipline, then return this as\n\t   a DISCIPLINE_IDENTIFIER and return the discipline as the\n\t   value instead. */\n      if (rc == IDENTIFIER && gn_verilog_ams_flag) {\n\t    perm_string tmp = lex_strings.make(yylval.text);\n\t    map<perm_string,ivl_discipline_t>::iterator cur = disciplines.find(tmp);\n\t    if (cur != disciplines.end()) {\n\t\t  delete[]yylval.text;\n\t\t  yylval.discipline = (*cur).second;\n\t\t  rc = DISCIPLINE_IDENTIFIER;\n\t    }\n      }\n\n\t/* If this identifier names a previously declared package, then\n\t   return this as a PACKAGE_IDENTIFIER instead. */\n      if (rc == IDENTIFIER && gn_system_verilog()) {\n\t    if (PPackage*pkg = pform_test_package_identifier(yylval.text)) {\n\t\t  delete[]yylval.text;\n\t\t  yylval.package = pkg;\n\t\t  rc = PACKAGE_IDENTIFIER;\n\t    }\n      }\n\n\t/* If this identifier names a previously declared type, then\n\t   return this as a TYPE_IDENTIFIER instead. */\n      if (rc == IDENTIFIER && gn_system_verilog()) {\n\t    if (typedef_t*type = pform_test_type_identifier(yylloc, yylval.text)) {\n\t\t  yylval.type_identifier.text = yylval.text;\n\t\t  yylval.type_identifier.type = type;\n\t\t  rc = TYPE_IDENTIFIER;\n\t    }\n      }\n\n      return rc;\n  }\n\n\n\\\\[^ \\t\\b\\f\\r\\n]+         {\n      assert(yylloc.lexical_pos != UINT_MAX);\n      yylloc.lexical_pos += 1;\n      yylval.text = strdupnew(yytext+1);\n      if (gn_system_verilog()) {\n\t    if (PPackage*pkg = pform_test_package_identifier(yylval.text)) {\n\t\t  delete[]yylval.text;\n\t\t  yylval.package = pkg;\n\t\t  return PACKAGE_IDENTIFIER;\n\t    }\n      }\n      if (gn_system_verilog()) {\n\t    if (typedef_t*type = pform_test_type_identifier(yylloc, yylval.text)) {\n\t\t  yylval.type_identifier.text = yylval.text;\n\t\t  yylval.type_identifier.type = type;\n\t\t  return TYPE_IDENTIFIER;\n\t    }\n      }\n      return IDENTIFIER;\n  }\n\n\\$([a-zA-Z0-9$_]+)        {\n\t/* The 1364-1995 timing checks. */\n      if (strcmp(yytext,\"$hold\") == 0)\n\t    return K_Shold;\n      if (strcmp(yytext,\"$nochange\") == 0)\n\t    return K_Snochange;\n      if (strcmp(yytext,\"$period\") == 0)\n\t    return K_Speriod;\n      if (strcmp(yytext,\"$recovery\") == 0)\n\t    return K_Srecovery;\n      if (strcmp(yytext,\"$setup\") == 0)\n\t    return K_Ssetup;\n      if (strcmp(yytext,\"$setuphold\") == 0)\n\t    return K_Ssetuphold;\n      if (strcmp(yytext,\"$skew\") == 0)\n\t    return K_Sskew;\n      if (strcmp(yytext,\"$width\") == 0)\n\t    return K_Swidth;\n\t/* The new 1364-2001 timing checks. */\n      if (strcmp(yytext,\"$fullskew\") == 0)\n\t    return K_Sfullskew;\n      if (strcmp(yytext,\"$recrem\") == 0)\n\t    return K_Srecrem;\n      if (strcmp(yytext,\"$removal\") == 0)\n\t    return K_Sremoval;\n      if (strcmp(yytext,\"$timeskew\") == 0)\n\t    return K_Stimeskew;\n\n      if (strcmp(yytext,\"$attribute\") == 0)\n\t    return KK_attribute;\n\n      if (gn_system_verilog() && strcmp(yytext,\"$unit\") == 0) {\n\t    yylval.package = pform_units.back();\n\t    return PACKAGE_IDENTIFIER;\n      }\n\n      yylval.text = strdupnew(yytext);\n      return SYSTEM_IDENTIFIER; }\n\n\n\\'[sS]?[dD][ \\t]*[0-9][0-9_]* {\n      yylval.number = make_unsized_dec(yytext);\n      return BASED_NUMBER;\n}\n\\'[sS]?[dD][ \\t]*[xzXZ?]_* {\n      yylval.number = make_undef_highz_dec(yytext);\n      return BASED_NUMBER;\n}\n\\'[sS]?[bB][ \\t]*[0-1xzXZ?][0-1xzXZ?_]* {\n      yylval.number = make_unsized_binary(yytext);\n      return BASED_NUMBER;\n}\n\\'[sS]?[oO][ \\t]*[0-7xzXZ?][0-7xzXZ?_]* {\n      yylval.number = make_unsized_octal(yytext);\n      return BASED_NUMBER;\n}\n\\'[sS]?[hH][ \\t]*[0-9a-fA-FxzXZ?][0-9a-fA-FxzXZ?_]* {\n      yylval.number = make_unsized_hex(yytext);\n      return BASED_NUMBER;\n}\n\\'[01xzXZ] {\n      if (!gn_system_verilog()) {\n\t    VLwarn(yylloc, \"warning: Using SystemVerilog 'N bit vector. \"\n                           \"Use at least -g2005-sv to remove this warning.\");\n      }\n      generation_t generation_save = generation_flag;\n      generation_flag = GN_VER2005_SV;\n      yylval.number = make_unsized_binary(yytext);\n      generation_flag = generation_save;\n      return UNBASED_NUMBER; }\n\n  /* Decimal numbers are the usual. But watch out for the UDPTABLE\n     mode, where there are no decimal numbers. Reject the match if we\n     are in the UDPTABLE state. */\n[0-9][0-9_]* {\n      if (YY_START==UDPTABLE) {\n\t    REJECT;\n      } else {\n\t    yylval.number = make_unsized_dec(yytext);\n\t    based_size = yylval.number->as_ulong();\n\t    return DEC_NUMBER;\n      }\n}\n\n  /* This rule handles scaled time values for SystemVerilog. */\n[0-9][0-9_]*(\\.[0-9][0-9_]*)?{TU}?s {\n      if (gn_system_verilog()) {\n\t    yylval.text = strdupnew(yytext);\n\t    return TIME_LITERAL;\n      } else REJECT; }\n\n  /* These rules handle the scaled real literals from Verilog-AMS. The\n     value is a number with a single letter scale factor. If\n     verilog-ams is not enabled, then reject this rule. If it is\n     enabled, then collect the scale and use it to scale the value. */\n[0-9][0-9_]*\\.[0-9][0-9_]*/{S} {\n      if (!gn_verilog_ams_flag) REJECT;\n      BEGIN(REAL_SCALE);\n      yymore();  }\n\n[0-9][0-9_]*/{S} {\n      if (!gn_verilog_ams_flag) REJECT;\n      BEGIN(REAL_SCALE);\n      yymore();  }\n\n<REAL_SCALE>{S} {\n      size_t token_len = strlen(yytext);\n      char*tmp = new char[token_len + 5];\n      int scale = 0;\n      strcpy(tmp, yytext);\n      switch (tmp[token_len-1]) {\n\t  case 'a': scale = -18; break; /* atto- */\n\t  case 'f': scale = -15; break; /* femto- */\n\t  case 'p': scale = -12; break; /* pico- */\n\t  case 'n': scale = -9;  break; /* nano- */\n\t  case 'u': scale = -6;  break; /* micro- */\n\t  case 'm': scale = -3;  break; /* milli- */\n\t  case 'k': scale = 3;  break; /* kilo- */\n\t  case 'K': scale = 3;  break; /* kilo- */\n\t  case 'M': scale = 6;  break; /* mega- */\n\t  case 'G': scale = 9;  break; /* giga- */\n\t  case 'T': scale = 12; break; /* tera- */\n\t  default: assert(0); break;\n      }\n      snprintf(tmp+token_len-1, 5, \"e%d\", scale);\n      yylval.realtime = new verireal(tmp);\n      delete[]tmp;\n\n      BEGIN(0);\n      return REALTIME;  }\n\n[0-9][0-9_]*\\.[0-9][0-9_]*([Ee][+-]?[0-9][0-9_]*)? {\n      yylval.realtime = new verireal(yytext);\n      return REALTIME; }\n\n[0-9][0-9_]*[Ee][+-]?[0-9][0-9_]* {\n      yylval.realtime = new verireal(yytext);\n      return REALTIME; }\n\n\n  /* Notice and handle the `timescale directive. */\n\n`timescale { ts_state = 0; BEGIN(PPTIMESCALE_SCALE); }\n\n<PPTIMESCALE_SCALE>10?0? {\n      ts_scale = get_timescale_scale(yytext);\n      BEGIN(PPTIMESCALE_UNITS); }\n\n<PPTIMESCALE_SCALE>\"//\" { comment_enter = PPTIMESCALE_SCALE; BEGIN(LCOMMENT); }\n<PPTIMESCALE_SCALE>\"/*\" { comment_enter = PPTIMESCALE_SCALE; BEGIN(CCOMMENT); }\n<PPTIMESCALE_SCALE>\"\\n\" { yylloc.first_line += 1; }\n<PPTIMESCALE_SCALE>{W}  { ; }\n<PPTIMESCALE_SCALE>.    { BEGIN(PPTIMESCALE_ERROR); }\n\n<PPTIMESCALE_UNITS>[munpf]?s {\n      if (++ts_state == 1) {\n            ts_unit = get_timescale_const(ts_scale, yytext);\n            BEGIN(PPTIMESCALE_SLASH);\n      } else {\n            ts_prec = get_timescale_const(ts_scale, yytext);\n            if (in_module) {\n                  VLerror(yylloc, \"error: timescale directive cannot be inside \"\n                          \"a module definition.\");\n            }\n            if (ts_unit < ts_prec) {\n                  VLerror(yylloc, \"error: timescale unit must not be less than \"\n                          \"the precision.\");\n            } else {\n                  pform_set_timescale(ts_unit, ts_prec, yylloc.text, yylloc.first_line);\n            }\n            BEGIN(0);\n      } }\n\n<PPTIMESCALE_UNITS>\"//\" { comment_enter = PPTIMESCALE_UNITS; BEGIN(LCOMMENT); }\n<PPTIMESCALE_UNITS>\"/*\" { comment_enter = PPTIMESCALE_UNITS; BEGIN(CCOMMENT); }\n<PPTIMESCALE_UNITS>\"\\n\" { yylloc.first_line += 1; }\n<PPTIMESCALE_UNITS>{W}  { ; }\n<PPTIMESCALE_UNITS>.    { BEGIN(PPTIMESCALE_ERROR); }\n\n<PPTIMESCALE_SLASH>\"/\"  { BEGIN(PPTIMESCALE_SCALE); }\n\n<PPTIMESCALE_SLASH>\"//\" { comment_enter = PPTIMESCALE_SLASH; BEGIN(LCOMMENT); }\n<PPTIMESCALE_SLASH>\"/*\" { comment_enter = PPTIMESCALE_SLASH; BEGIN(CCOMMENT); }\n<PPTIMESCALE_SLASH>\"\\n\" { yylloc.first_line += 1; }\n<PPTIMESCALE_SLASH>{W}  { ; }\n<PPTIMESCALE_SLASH>.    { BEGIN(PPTIMESCALE_ERROR); }\n\n  /* On error, try to recover by skipping to the end of the line. */\n<PPTIMESCALE_ERROR>[^\\n]+ {\n      VLerror(yylloc, \"error: Invalid `timescale directive.\");\n      BEGIN(0); }\n\n  /* Notice and handle the `celldefine and `endcelldefine directives. */\n\n`celldefine    { in_celldefine = true; }\n`endcelldefine { in_celldefine = false; }\n\n  /* Notice and handle the `resetall directive. */\n\n`resetall {\n      if (in_module) {\n\t    VLerror(yylloc, \"error: `resetall directive cannot be inside a \"\n\t\t    \"module definition.\");\n      } else if (in_UDP) {\n\t    VLerror(yylloc, \"error: `resetall directive cannot be inside a \"\n\t\t    \"UDP definition.\");\n      } else {\n\t    reset_all();\n      } }\n\n  /* Notice and handle the `unconnected_drive directive. */\n\n`unconnected_drive { BEGIN(PPUCDRIVE); }\n\n<PPUCDRIVE>[a-zA-Z0-9_]+ {\n      process_ucdrive(yytext);\n      if (in_module) {\n\t    VLerror(yylloc, \"error: `unconnected_drive directive cannot be \"\n\t\t    \"inside a module definition.\");\n      }\n      BEGIN(0); }\n\n<PPUCDRIVE>\"//\" { comment_enter = PPUCDRIVE; BEGIN(LCOMMENT); }\n<PPUCDRIVE>\"/*\" { comment_enter = PPUCDRIVE; BEGIN(CCOMMENT); }\n<PPUCDRIVE>\"\\n\" { yylloc.first_line += 1; }\n<PPUCDRIVE>{W}  { ; }\n<PPUCDRIVE>.    { BEGIN(PPUCDRIVE_ERROR); }\n\n  /* On error, try to recover by skipping to the end of the line. */\n<PPUCDRIVE_ERROR>[^\\n]+ {\n      VLerror(yylloc, \"error: Invalid `unconnected_drive directive.\");\n      BEGIN(0); }\n\n  /* Notice and handle the `nounconnected_drive directive. */\n\n`nounconnected_drive {\n      if (in_module) {\n\t    VLerror(yylloc, \"error: `nounconnected_drive directive cannot be \"\n                    \"inside a module definition.\");\n      }\n      uc_drive = UCD_NONE; }\n\n  /* These are directives that I do not yet support. I think that IVL\n     should handle these, not an external preprocessor. */\n  /* From 1364-2005 Chapter 19. */\n^{W}?`pragma{W}?.*                  {  }\n\n  /* From 1364-2005 Annex D. */\n^{W}?`default_decay_time{W}?.*      {  }\n^{W}?`default_trireg_strength{W}?.* {  }\n^{W}?`delay_mode_distributed{W}?.*  {  }\n^{W}?`delay_mode_path{W}?.*         {  }\n^{W}?`delay_mode_unit{W}?.*         {  }\n^{W}?`delay_mode_zero{W}?.*         {  }\n\n  /* From other places. */\n^{W}?`disable_portfaults{W}?.*      {  }\n^{W}?`enable_portfaults{W}?.*       {  }\n`endprotect                         {  }\n^{W}?`nosuppress_faults{W}?.*       {  }\n`protect                            {  }\n^{W}?`suppress_faults{W}?.*         {  }\n^{W}?`uselib{W}?.*                  {  }\n\n  /* Notice and handle the `begin_keywords directive. */\n\n`begin_keywords { BEGIN(PPBEGIN_KEYWORDS); }\n\n<PPBEGIN_KEYWORDS>\\\"[a-zA-Z0-9 -\\.]*\\\" {\n      keyword_mask_stack.push_front(lexor_keyword_mask);\n\n      char*word = yytext+1;\n      char*tail = strchr(word, '\"');\n      tail[0] = 0;\n      if (strcmp(word,\"1364-1995\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995;\n      } else if (strcmp(word,\"1364-2001\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995\n\t\t                |GN_KEYWORDS_1364_2001\n\t\t                |GN_KEYWORDS_1364_2001_CONFIG;\n      } else if (strcmp(word,\"1364-2001-noconfig\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995\n\t\t                |GN_KEYWORDS_1364_2001;\n      } else if (strcmp(word,\"1364-2005\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995\n\t\t                |GN_KEYWORDS_1364_2001\n\t\t                |GN_KEYWORDS_1364_2001_CONFIG\n\t\t                |GN_KEYWORDS_1364_2005;\n      } else if (strcmp(word,\"1800-2005\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995\n\t\t                |GN_KEYWORDS_1364_2001\n\t\t                |GN_KEYWORDS_1364_2001_CONFIG\n\t\t                |GN_KEYWORDS_1364_2005\n\t\t                |GN_KEYWORDS_1800_2005;\n      } else if (strcmp(word,\"1800-2009\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995\n\t\t                |GN_KEYWORDS_1364_2001\n\t\t                |GN_KEYWORDS_1364_2001_CONFIG\n\t\t                |GN_KEYWORDS_1364_2005\n\t\t                |GN_KEYWORDS_1800_2005\n\t\t                |GN_KEYWORDS_1800_2009;\n      } else if (strcmp(word,\"1800-2012\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995\n\t\t                |GN_KEYWORDS_1364_2001\n\t\t                |GN_KEYWORDS_1364_2001_CONFIG\n\t\t                |GN_KEYWORDS_1364_2005\n\t\t                |GN_KEYWORDS_1800_2005\n\t\t                |GN_KEYWORDS_1800_2009\n\t\t                |GN_KEYWORDS_1800_2012;\n      } else if (strcmp(word,\"VAMS-2.3\") == 0) {\n\t    lexor_keyword_mask = GN_KEYWORDS_1364_1995\n\t\t                |GN_KEYWORDS_1364_2001\n\t\t                |GN_KEYWORDS_1364_2001_CONFIG\n\t\t                |GN_KEYWORDS_1364_2005\n\t\t                |GN_KEYWORDS_VAMS_2_3;\n      } else {\n\t    fprintf(stderr, \"%s:%d: Ignoring unknown keywords string: %s\\n\",\n\t\t    yylloc.text, yylloc.first_line, word);\n      }\n      BEGIN(0);\n }\n\n<PPBEGIN_KEYWORDS>\"//\" { comment_enter = PPBEGIN_KEYWORDS; BEGIN(LCOMMENT); }\n<PPBEGIN_KEYWORDS>\"/*\" { comment_enter = PPBEGIN_KEYWORDS; BEGIN(CCOMMENT); }\n<PPBEGIN_KEYWORDS>\"\\n\" { yylloc.first_line += 1; }\n<PPBEGIN_KEYWORDS>{W}  { ; }\n<PPBEGIN_KEYWORDS>.    { BEGIN(PPBEGIN_KEYWORDS_ERROR); }\n\n  /* On error, try to recover by skipping to the end of the line. */\n<PPBEGIN_KEYWORDS_ERROR>[^\\n]+ {\n      VLerror(yylloc, \"error: Invalid `begin_keywords directive.\");\n      BEGIN(0); }\n\n  /* Notice and handle the `end_keywords directive. */\n\n`end_keywords {\n      if (!keyword_mask_stack.empty()) {\n\t    lexor_keyword_mask = keyword_mask_stack.front();\n\t    keyword_mask_stack.pop_front();\n      } else {\n\t    VLwarn(yylloc, \"warning: Mismatched `end_keywords directive\");\n      }\n }\n\n  /* Notice and handle the `default_nettype directive. */\n\n`default_nettype { BEGIN(PPDEFAULT_NETTYPE); }\n\n<PPDEFAULT_NETTYPE>[a-zA-Z0-9_]+ {\n      NetNet::Type net_type;\n  /* Add support for other wire types and better error detection. */\n      if (strcmp(yytext,\"wire\") == 0) {\n\t    net_type = NetNet::WIRE;\n\n      } else if (strcmp(yytext,\"tri\") == 0) {\n\t    net_type = NetNet::TRI;\n\n      } else if (strcmp(yytext,\"tri0\") == 0) {\n\t    net_type = NetNet::TRI0;\n\n      } else if (strcmp(yytext,\"tri1\") == 0) {\n\t    net_type = NetNet::TRI1;\n\n      } else if (strcmp(yytext,\"wand\") == 0) {\n\t    net_type = NetNet::WAND;\n\n      } else if (strcmp(yytext,\"triand\") == 0) {\n\t    net_type = NetNet::TRIAND;\n\n      } else if (strcmp(yytext,\"wor\") == 0) {\n\t    net_type = NetNet::WOR;\n\n      } else if (strcmp(yytext,\"trior\") == 0) {\n\t    net_type = NetNet::TRIOR;\n\n      } else if (strcmp(yytext,\"none\") == 0) {\n\t    net_type = NetNet::NONE;\n\n      } else {\n\t    VLerror(yylloc, \"error: Net type '%s' is not a valid (or supported) \"\n\t\t            \"default net type.\", yytext);\n\t    net_type = NetNet::WIRE;\n\t    error_count += 1;\n      }\n      pform_set_default_nettype(net_type, yylloc.text, yylloc.first_line);\n      BEGIN(0);\n  }\n\n<PPDEFAULT_NETTYPE>\"//\" { comment_enter = PPDEFAULT_NETTYPE; BEGIN(LCOMMENT); }\n<PPDEFAULT_NETTYPE>\"/*\" { comment_enter = PPDEFAULT_NETTYPE; BEGIN(CCOMMENT); }\n<PPDEFAULT_NETTYPE>\"\\n\" { yylloc.first_line += 1; }\n<PPDEFAULT_NETTYPE>{W}  { ; }\n<PPDEFAULT_NETTYPE>.    { BEGIN(PPDEFAULT_NETTYPE_ERROR); }\n\n  /* On error, try to recover by skipping to the end of the line. */\n<PPDEFAULT_NETTYPE_ERROR>[^\\n]+ {\n      VLerror(yylloc, \"error: Invalid `default_nettype directive.\");\n      BEGIN(0); }\n\n  /* These are directives that are not supported by me and should have\n     been handled by an external preprocessor such as ivlpp. */\n\n^{W}?`define{W}?.* {\n      VLwarn(yylloc, \"warning: `define not supported. Use an external preprocessor.\");\n  }\n\n^{W}?`else{W}?.* {\n      VLwarn(yylloc, \"warning: `else not supported. Use an external preprocessor.\");\n  }\n\n^{W}?`elsif{W}?.* {\n      VLwarn(yylloc, \"warning: `elsif not supported. Use an external preprocessor.\");\n  }\n\n^{W}?`endif{W}?.* {\n      VLwarn(yylloc, \"warning: `endif not supported. Use an external preprocessor.\");\n  }\n\n^{W}?`ifdef{W}?.* {\n      VLwarn(yylloc, \"warning: `ifdef not supported. Use an external preprocessor.\");\n  }\n\n^{W}?`ifndef{W}?.* {\n      VLwarn(yylloc, \"warning: `ifndef not supported. Use an external preprocessor.\");\n  }\n\n^`include{W}?.* {\n      VLwarn(yylloc, \"warning: `include not supported. Use an external preprocessor.\");\n  }\n\n^`undef{W}?.* {\n      VLwarn(yylloc, \"warning: `undef not supported. Use an external preprocessor.\");\n  }\n\n`[a-zA-Z_]+ {\n      VLwarn(yylloc, \"warning: Macro replacement not supported. \"\n             \"Use an external preprocessor.\");\n  }\n\n\n`{W} { VLerror(yylloc, \"error: Stray tic (`) here. Perhaps you put white \"\n                       \"space between the tic and preprocessor directive?\"); }\n\n. { return yytext[0]; }\n\n  /* Final catchall. something got lost or mishandled. */\n  /* XXX Should we tell the user something about the lexical state? */\n\n<*>.|\\n {\n      if (isprint(yytext[0]))\n            VLerror(yylloc, \"error: Unmatched character (%c).\", yytext[0]);\n      else\n            VLerror(yylloc, \"error: Unmatched character (0x%x).\",\n\t\t\t    (unsigned char) yytext[0]);\n}\n\n%%\n\n/*\n * The UDP state table needs some slightly different treatment by the\n * lexor. The level characters are normally accepted as other things,\n * so the parser needs to switch my mode when it believes in needs to.\n */\nvoid lex_end_table()\n{\n      BEGIN(INITIAL);\n}\n\nstatic unsigned truncate_to_integer_width(verinum::V*bits, unsigned size)\n{\n      if (size <= integer_width) return size;\n\n      verinum::V pad = bits[size-1];\n      if (pad == verinum::V1) pad = verinum::V0;\n\n      for (unsigned idx = integer_width; idx < size; idx += 1) {\n\t    if (bits[idx] != pad) {\n\t\t  VLwarn(yylloc, \"warning: Unsized numeric constant truncated \"\n                                 \"to integer width.\");\n\t\t  break;\n\t    }\n      }\n      return integer_width;\n}\n\nverinum*make_unsized_binary(const char*txt)\n{\n      bool sign_flag = false;\n      bool single_flag = false;\n      const char*ptr = txt;\n      assert(*ptr == '\\'');\n      ptr += 1;\n\n      if (tolower(*ptr) == 's') {\n\t    sign_flag = true;\n\t    ptr += 1;\n      }\n\n      assert((tolower(*ptr) == 'b') || gn_system_verilog());\n      if (tolower(*ptr) == 'b') {\n\t    ptr += 1;\n      } else {\n\t    assert(sign_flag == false);\n\t    single_flag = true;\n      }\n\n      while (*ptr && ((*ptr == ' ') || (*ptr == '\\t')))\n\t    ptr += 1;\n\n      unsigned size = 0;\n      for (const char*idx = ptr ;  *idx ;  idx += 1)\n\t    if (*idx != '_') size += 1;\n\n      if (size == 0) {\n\t    VLerror(yylloc, \"error: Numeric literal has no digits in it.\");\n\t    verinum*out = new verinum();\n\t    out->has_sign(sign_flag);\n\t    out->is_single(single_flag);\n\t    return out;\n      }\n\n      if ((based_size > 0) && (size > based_size)) VLwarn(yylloc,\n          \"warning: Extra digits given for sized binary constant.\");\n\n\t// Allocate one extra bit in case we need to zero-extend.\n      verinum::V*bits = new verinum::V[size+1];\n\n      unsigned idx = size;\n      while (*ptr) {\n\t    switch (ptr[0]) {\n\t\tcase '0':\n\t\t  bits[--idx] = verinum::V0;\n\t\t  break;\n\t\tcase '1':\n\t\t  bits[--idx] = verinum::V1;\n\t\t  break;\n\t\tcase 'z': case 'Z': case '?':\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  break;\n\t\tcase 'x': case 'X':\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  break;\n\t\t  case '_':\n\t\t  break;\n\t\tdefault:\n\t\t  fprintf(stderr, \"%c\\n\", ptr[0]);\n\t\t  assert(0);\n\t    }\n\t    ptr += 1;\n      }\n\n      if (gn_strict_expr_width_flag && (based_size == 0))\n\t    size = truncate_to_integer_width(bits, size);\n\n      if (sign_flag && (size < integer_width) && (bits[size-1] == verinum::V1))\n\t    bits[size++] = verinum::V0;\n\n      verinum*out = new verinum(bits, size, false);\n      out->has_sign(sign_flag);\n      out->is_single(single_flag);\n      delete[]bits;\n      return out;\n}\n\n\nverinum*make_unsized_octal(const char*txt)\n{\n      bool sign_flag = false;\n      const char*ptr = txt;\n      assert(*ptr == '\\'');\n      ptr += 1;\n\n      if (tolower(*ptr) == 's') {\n\t    sign_flag = true;\n\t    ptr += 1;\n      }\n\n      assert(tolower(*ptr) == 'o');\n      ptr += 1;\n\n      while (*ptr && ((*ptr == ' ') || (*ptr == '\\t')))\n\t    ptr += 1;\n\n      unsigned size = 0;\n      for (const char*idx = ptr ;  *idx ;  idx += 1)\n\t    if (*idx != '_') size += 3;\n\n      if (based_size > 0) {\n            int rem = based_size % 3;\n\t    if (rem != 0) based_size += 3 - rem;\n\t    if (size > based_size) VLwarn(yylloc,\n\t        \"warning: Extra digits given for sized octal constant.\");\n      }\n\n\t// Allocate one extra bit in case we need to zero-extend.\n      verinum::V*bits = new verinum::V[size+1];\n\n      unsigned idx = size;\n      while (*ptr) {\n\t    unsigned val;\n\t    switch (ptr[0]) {\n\t\tcase '0': case '1': case '2': case '3':\n\t\tcase '4': case '5': case '6': case '7':\n\t\t  val = *ptr - '0';\n\t\t  bits[--idx] = (val&4) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&2) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&1) ? verinum::V1 : verinum::V0;\n\t\t  break;\n\t\tcase 'x': case 'X':\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  break;\n\t\tcase 'z': case 'Z': case '?':\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  break;\n\t\tcase '_':\n\t\t  break;\n\t\tdefault:\n\t\t  assert(0);\n\t    }\n\t    ptr += 1;\n      }\n\n      if (gn_strict_expr_width_flag && (based_size == 0))\n\t    size = truncate_to_integer_width(bits, size);\n\n      if (sign_flag && (size < integer_width) && (bits[size-1] == verinum::V1))\n\t    bits[size++] = verinum::V0;\n\n      verinum*out = new verinum(bits, size, false);\n      out->has_sign(sign_flag);\n      delete[]bits;\n      return out;\n}\n\n\nverinum*make_unsized_hex(const char*txt)\n{\n      bool sign_flag = false;\n      const char*ptr = txt;\n      assert(*ptr == '\\'');\n      ptr += 1;\n\n      if (tolower(*ptr) == 's') {\n\t    sign_flag = true;\n\t    ptr += 1;\n      }\n      assert(tolower(*ptr) == 'h');\n\n      ptr += 1;\n      while (*ptr && ((*ptr == ' ') || (*ptr == '\\t')))\n\t    ptr += 1;\n\n      unsigned size = 0;\n      for (const char*idx = ptr ;  *idx ;  idx += 1)\n\t    if (*idx != '_') size += 4;\n\n      if (based_size > 0) {\n            int rem = based_size % 4;\n\t    if (rem != 0) based_size += 4 - rem;\n\t    if (size > based_size) VLwarn(yylloc,\n\t        \"warning: Extra digits given for sized hex constant.\");\n      }\n\n\t// Allocate one extra bit in case we need to zero-extend.\n      verinum::V*bits = new verinum::V[size+1];\n\n      unsigned idx = size;\n      while (*ptr) {\n\t    unsigned val;\n\t    switch (ptr[0]) {\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t  val = *ptr - '0';\n\t\t  bits[--idx] = (val&8) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&4) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&2) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&1) ? verinum::V1 : verinum::V0;\n\t\t  break;\n\t\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n\t\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n\t\t  val = tolower(*ptr) - 'a' + 10;\n\t\t  bits[--idx] = (val&8) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&4) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&2) ? verinum::V1 : verinum::V0;\n\t\t  bits[--idx] = (val&1) ? verinum::V1 : verinum::V0;\n\t\t  break;\n\t\tcase 'x': case 'X':\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  bits[--idx] = verinum::Vx;\n\t\t  break;\n\t\tcase 'z': case 'Z': case '?':\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  bits[--idx] = verinum::Vz;\n\t\t  break;\n\t\tcase '_':\n\t\t  break;\n\t\tdefault:\n\t\t  assert(0);\n\t    }\n\t    ptr += 1;\n      }\n\n      if (gn_strict_expr_width_flag && (based_size == 0))\n\t    size = truncate_to_integer_width(bits, size);\n\n      if (sign_flag && (size < integer_width) && (bits[size-1] == verinum::V1))\n\t    bits[size++] = verinum::V0;\n\n      verinum*out = new verinum(bits, size, false);\n      out->has_sign(sign_flag);\n      delete[]bits;\n      return out;\n}\n\n\n/* Divide the integer given by the string by 2. Return the remainder bit. */\nstatic int dec_buf_div2(char *buf)\n{\n    int partial;\n    int len = strlen(buf);\n    char *dst_ptr;\n    int pos;\n\n    partial = 0;\n    pos = 0;\n\n    /* dst_ptr overwrites buf, but all characters that are overwritten\n       were already used by the reader. */\n    dst_ptr = buf;\n\n    while(buf[pos] == '0')\n\t++pos;\n\n    for(; pos<len; ++pos){\n\tif (buf[pos]=='_')\n\t    continue;\n\n\tassert(isdigit(buf[pos]));\n\n\tpartial= partial*10 + (buf[pos]-'0');\n\n\tif (partial >= 2){\n\t    *dst_ptr = partial/2 + '0';\n\t    partial = partial & 1;\n\n\t    ++dst_ptr;\n\t}\n\telse{\n\t    *dst_ptr = '0';\n\t    ++dst_ptr;\n\t}\n    }\n\n    // If result of division was zero string, it should remain that way.\n    // Don't eat the last zero...\n    if (dst_ptr == buf){\n\t*dst_ptr = '0';\n\t++dst_ptr;\n    }\n    *dst_ptr = 0;\n\n    return partial;\n}\n\n/* Support a single x, z or ? as a decimal constant (from 1364-2005). */\nverinum* make_undef_highz_dec(const char* ptr)\n{\n      bool signed_flag = false;\n\n      assert(*ptr == '\\'');\n      /* The number may have decorations of the form 'sd<code>,\n         possibly with space between the d and the <code>.\n         Also, the 's' is optional, and marks the number as signed. */\n      ptr += 1;\n\n      if (tolower(*ptr) == 's') {\n\t  signed_flag = true;\n\t  ptr += 1;\n      }\n\n      assert(tolower(*ptr) == 'd');\n      ptr += 1;\n\n      while (*ptr && ((*ptr == ' ') || (*ptr == '\\t')))\n\t  ptr += 1;\n\n\t/* Process the code. */\n      verinum::V* bits = new verinum::V[1];\n      switch (*ptr) {\n\t  case 'x':\n\t  case 'X':\n\t    bits[0] = verinum::Vx;\n\t    break;\n\t  case 'z':\n\t  case 'Z':\n\t  case '?':\n\t    bits[0] = verinum::Vz;\n\t    break;\n\t  default:\n\t    assert(0);\n      }\n      ptr += 1;\n      while (*ptr == '_') ptr += 1;\n      assert(*ptr == 0);\n\n      verinum*out = new verinum(bits, 1, false);\n      out->has_sign(signed_flag);\n      delete[]bits;\n      return out;\n}\n\n/*\n * Making a decimal number is much easier than the other base numbers\n * because there are no z or x values to worry about. It is much\n * harder than other base numbers because the width needed in bits is\n * hard to calculate.\n */\n\nverinum*make_unsized_dec(const char*ptr)\n{\n      char buf[4096];\n      bool signed_flag = false;\n      unsigned idx;\n\n      if (ptr[0] == '\\'') {\n\t      /* The number has decorations of the form 'sd<digits>,\n\t\t possibly with space between the d and the <digits>.\n\t\t Also, the 's' is optional, and marks the number as\n\t\t signed. */\n\t    ptr += 1;\n\n\t    if (tolower(*ptr) == 's') {\n\t\t  signed_flag = true;\n\t\t  ptr += 1;\n\t    }\n\n\t    assert(tolower(*ptr) == 'd');\n\t    ptr += 1;\n\n\t    while (*ptr && ((*ptr == ' ') || (*ptr == '\\t')))\n\t\t  ptr += 1;\n\n      } else {\n\t      /* ... or an undecorated decimal number is passed\n\t\t it. These numbers are treated as signed decimal. */\n\t    assert(isdigit(*ptr));\n\t    signed_flag = true;\n      }\n\n\n\t/* Copy the digits into a buffer that I can use to do in-place\n\t   decimal divides. */\n      idx = 0;\n      while ((idx < sizeof buf) && (*ptr != 0)) {\n\t    if (*ptr == '_') {\n\t\t  ptr += 1;\n\t\t  continue;\n\t    }\n\n\t    buf[idx++] = *ptr++;\n      }\n\n      if (idx == sizeof buf) {\n\t    fprintf(stderr, \"Ridiculously long\"\n\t\t    \" decimal constant will be truncated!\\n\");\n\t    idx -= 1;\n      }\n\n      buf[idx] = 0;\n      unsigned tmp_size = idx * 4 + 1;\n      verinum::V *bits = new verinum::V[tmp_size];\n\n      idx = 0;\n      while (idx < tmp_size) {\n\t    int rem = dec_buf_div2(buf);\n\t    bits[idx++] = (rem == 1) ? verinum::V1 : verinum::V0;\n      }\n\n      assert(strcmp(buf, \"0\") == 0);\n\n\t/* Now calculate the minimum number of bits needed to\n\t   represent this unsigned number. */\n      unsigned size = tmp_size;\n      while ((size > 1) && (bits[size-1] == verinum::V0))\n\t    size -= 1;\n\n\t/* Now account for the signedness. Don't leave a 1 in the high\n\t   bit if this is a signed number. */\n      if (signed_flag && (bits[size-1] == verinum::V1)) {\n\t    size += 1;\n\t    assert(size <= tmp_size);\n      }\n\n        /* Since we never have the real number of bits that a decimal\n           number represents we do not check for extra bits. */\n//      if (based_size > 0) { }\n\n      if (gn_strict_expr_width_flag && (based_size == 0))\n\t    size = truncate_to_integer_width(bits, size);\n\n      verinum*res = new verinum(bits, size, false);\n      res->has_sign(signed_flag);\n\n      delete[]bits;\n      return res;\n}\n\n/*\n * Convert a string to a scale value (\"1\" -> 0, \"10\" -> 1, \"100\" -> 2).\n * We have already checked the string is valid.\n */\nstatic int get_timescale_scale(const char *cp)\n{\n\t/* Skip the 1 digit. */\n      assert(*cp == '1');\n      cp += 1;\n\n\t/* Check the number of zeros after the 1. */\n      int scale = strspn(cp, \"0\");\n      assert(scale < 3);\n      cp += scale;\n\n      assert(*cp == '\\0');\n      return scale;\n}\n\n/*\n * Convert a scale and a units string to a time unit or precision.\n * We have already checked the string is valid.\n */\nstatic int get_timescale_const(int scale, const char *units)\n{\n      if (strncmp(\"s\", units, 1) == 0) {\n\t    return scale;\n\n      } else if (strncmp(\"ms\", units, 2) == 0) {\n\t    return scale - 3;\n\n      } else if (strncmp(\"us\", units, 2) == 0) {\n\t    return scale - 6;\n\n      } else if (strncmp(\"ns\", units, 2) == 0) {\n\t    return scale - 9;\n\n      } else if (strncmp(\"ps\", units, 2) == 0) {\n\t    return scale - 12;\n\n      } else if (strncmp(\"fs\", units, 2) == 0) {\n\t    return scale - 15;\n\n      }\n      assert(0);\n      return 0;\n}\n\n/*\n * Process either a pull0 or a pull1.\n */\nstatic void process_ucdrive(const char*txt)\n{\n      UCDriveType ucd = UCD_NONE;\n\n      const char*cp = txt;\n      if (strncmp(\"pull\", cp, 4) != 0) {\n\t    VLerror(yylloc, \"error: pull required for `unconnected_drive \"\n\t                    \"directive.\");\n\t    return;\n      }\n      cp += 4;\n      if (*cp == '0') ucd = UCD_PULL0;\n      else if (*cp == '1') ucd = UCD_PULL1;\n      else {\n\t    VLerror(yylloc, \"error: `unconnected_drive does not support \"\n                            \"'pull%c'.\", *cp);\n\t    return;\n      }\n      cp += 1;\n      if (*cp != '\\0') {\n\t    VLerror(yylloc, \"error: Invalid `unconnected_drive directive \"\n\t                    \"(extra garbage after pull direction).\");\n\t    return;\n      }\n\n      uc_drive = ucd;\n}\n\nint yywrap(void)\n{\n      return 1;\n}\n\n/*\n * The line directive matches lines of the form #line \"foo\" N and\n * calls this function. Here I parse out the file name and line\n * number, and change the yylloc to suite.\n */\nstatic void line_directive()\n{\n      char *cpr;\n\t/* Skip any leading space. */\n      char *cp = strchr(yytext, '#');\n\t/* Skip the #line directive. */\n      assert(strncmp(cp, \"#line\", 5) == 0);\n      cp += 5;\n\t/* Skip the space after the #line directive. */\n      cp += strspn(cp, \" \\t\");\n\n\t/* Find the starting \" and skip it. */\n      char *fn_start = strchr(cp, '\"');\n      if (cp != fn_start) {\n\t    VLerror(yylloc, \"error: Invalid #line directive (file name start).\");\n\t    return;\n      }\n      fn_start += 1;\n\n\t/* Find the last \". */\n      char *fn_end = strrchr(fn_start, '\"');\n      if (!fn_end) {\n\t    VLerror(yylloc, \"error: Invalid #line directive (file name end).\");\n\t    return;\n      }\n\n\t/* Copy the file name and assign it to yylloc. */\n      char*buf = new char[fn_end-fn_start+1];\n      strncpy(buf, fn_start, fn_end-fn_start);\n      buf[fn_end-fn_start] = 0;\n\n\t/* Skip the space after the file name. */\n      cp = fn_end;\n      cp += 1;\n      cpr = cp;\n      cpr += strspn(cp, \" \\t\");\n      if (cp == cpr) {\n\t    VLerror(yylloc, \"error: Invalid #line directive (missing space \"\n\t                    \"after file name).\");\n\t    delete[] buf;\n\t    return;\n      }\n      cp = cpr;\n\n\t/* Get the line number and verify that it is correct. */\n      unsigned long lineno = strtoul(cp, &cpr, 10);\n      if (cp == cpr) {\n\t    VLerror(yylloc, \"error: Invalid line number for #line directive.\");\n\t    delete[] buf;\n\t    return;\n      }\n      cp = cpr;\n\n\t/* Verify that only space is left. */\n      cpr += strspn(cp, \" \\t\");\n      if ((size_t)(cpr-yytext) != strlen(yytext)) {\n\t    VLerror(yylloc, \"error: Invalid #line directive (extra garbage \"\n\t                    \"after line number).\");\n\t    delete[] buf;\n\t    return;\n      }\n\n\t/* Now we can assign the new values to yyloc. */\n      yylloc.text = set_file_name(buf);\n      yylloc.first_line = lineno;\n}\n\n/*\n * The line directive matches lines of the form `line N \"foo\" M and\n * calls this function. Here I parse out the file name and line\n * number, and change the yylloc to suite. M is ignored.\n */\nstatic void line_directive2()\n{\n      char *cpr;\n\t/* Skip any leading space. */\n      char *cp = strchr(yytext, '`');\n\t/* Skip the `line directive. */\n      assert(strncmp(cp, \"`line\", 5) == 0);\n      cp += 5;\n\n\t/* strtol skips leading space. */\n      long lineno = strtol(cp, &cpr, 10);\n      if (cp == cpr) {\n\t    VLerror(yylloc, \"error: Invalid line number for `line directive.\");\n\t    return;\n      }\n      if (lineno < 1) {\n\t    VLerror(yylloc, \"error: Line number for `line directive most be greater than zero.\");\n\t    return;\n      }\n      cp = cpr;\n\n\t/* Skip the space between the line number and the file name. */\n      cpr += strspn(cp, \" \\t\");\n      if (cp == cpr) {\n\t    VLerror(yylloc, \"error: Invalid `line directive (missing space \"\n\t                    \"after line number).\");\n\t    return;\n      }\n      cp = cpr;\n\n\t/* Find the starting \" and skip it. */\n      char *fn_start = strchr(cp, '\"');\n      if (cp != fn_start) {\n\t    VLerror(yylloc, \"error: Invalid `line directive (file name start).\");\n\t    return;\n      }\n      fn_start += 1;\n\n\t/* Find the last \". */\n      char*fn_end = strrchr(fn_start, '\"');\n      if (!fn_end) {\n\t    VLerror(yylloc, \"error: Invalid `line directive (file name end).\");\n\t    return;\n      }\n\n\t/* Skip the space after the file name. */\n      cp = fn_end + 1;\n      cpr = cp;\n      cpr += strspn(cp, \" \\t\");\n      if (cp == cpr) {\n\t    VLerror(yylloc, \"error: Invalid `line directive (missing space \"\n\t                    \"after file name).\");\n\t    return;\n      }\n      cp = cpr;\n\n\t/* Check that the level is correct, we do not need the level. */\n      if (strspn(cp, \"012\") != 1) {\n\t    VLerror(yylloc, \"error: Invalid level for `line directive.\");\n\t    return;\n      }\n      cp += 1;\n\n\t/* Verify that only space and/or a single line comment is left. */\n      cp += strspn(cp, \" \\t\");\n      if (strncmp(cp, \"//\", 2) != 0 &&\n          (size_t)(cp-yytext) != strlen(yytext)) {\n\t    VLerror(yylloc, \"error: Invalid `line directive (extra garbage \"\n\t                    \"after level).\");\n\t    return;\n      }\n\n\t/* Copy the file name and assign it and the line number to yylloc. */\n      char*buf = new char[fn_end-fn_start+1];\n      strncpy(buf, fn_start, fn_end-fn_start);\n      buf[fn_end-fn_start] = 0;\n\n      yylloc.text = set_file_name(buf);\n      yylloc.first_line = lineno-1;\n}\n\n/*\n * Reset all compiler directives. This will be called when a `resetall\n * directive is encountered or when a new compilation unit is started.\n */\nstatic void reset_all()\n{\n      pform_set_default_nettype(NetNet::WIRE, yylloc.text, yylloc.first_line);\n      in_celldefine = false;\n      uc_drive = UCD_NONE;\n      pform_set_timescale(def_ts_units, def_ts_prec, 0, 0);\n}\n\nextern FILE*vl_input;\nvoid reset_lexor()\n{\n      yyrestart(vl_input);\n      yylloc.first_line = 1;\n\n\t/* Announce the first file name. */\n      yylloc.text = set_file_name(strdupnew(vl_file.c_str()));\n\n      if (separate_compilation) {\n\t    reset_all();\n\t    if (!keyword_mask_stack.empty()) {\n\t\t  lexor_keyword_mask = keyword_mask_stack.back();\n\t\t  keyword_mask_stack.clear();\n\t    }\n      }\n}\n\n/*\n * Modern version of flex (>=2.5.9) can clean up the scanner data.\n */\nvoid destroy_lexor()\n{\n# ifdef FLEX_SCANNER\n#   if YY_FLEX_MAJOR_VERSION >= 2 && YY_FLEX_MINOR_VERSION >= 5\n#     if YY_FLEX_MINOR_VERSION > 5 || defined(YY_FLEX_SUBMINOR_VERSION) && YY_FLEX_SUBMINOR_VERSION >= 9\n    yylex_destroy();\n#     endif\n#   endif\n# endif\n}\n"
        },
        {
          "name": "lexor_keyword.gperf",
          "type": "blob",
          "size": 15.5732421875,
          "content": "/*\n * We need this to prevent -Wextra (-W) from complaining that the mask and\n * tokenType values are not initialized for the empty table entries.\n */\n%define initializer-suffix ,0,0\n%language=C++\n%define class-name Lkwd\n\n%{\n/* Command-line: gperf -o -i 7 -C -k '1-4,6,9,$' -H keyword_hash -N check_identifier -t ./lexor_keyword.gperf  */\n\n#include <cstdarg>\n#include \"config.h\"\n#include \"parse_misc.h\"\n#include \"parse.h\"\n#include <cstring>\n#include \"lexor_keyword.h\"\n#include \"compiler.h\"\n\n%}\nstruct lexor_keyword { const char*name; int mask; int tokenType; };\n%%\nabove,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_above\nabs,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_abs\nabsdelay,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_absdelay\nabstol,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_abstol\naccept_on,\t\tGN_KEYWORDS_1800_2009,\t\tK_accept_on\naccess,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_access\nacos,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_acos\nacosh,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_acosh\nac_stim,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_ac_stim\nalias,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_alias\naliasparam,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_aliasparam\nalways,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_always\nalways_comb,\t\tGN_KEYWORDS_1800_2005,\t\tK_always_comb\nalways_ff,\t\tGN_KEYWORDS_1800_2005,\t\tK_always_ff\nalways_latch,\t\tGN_KEYWORDS_1800_2005,\t\tK_always_latch\nanalog,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_analog\nanalysis,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_analysis\nand,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_and\nasin,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_asin\nasinh,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_asinh\n# This is defined by both SystemVerilog 1800-2005 and Verilog-AMS 2.3\nassert,\tGN_KEYWORDS_1800_2005|GN_KEYWORDS_VAMS_2_3,\tK_assert\nassign,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_assign\nassume,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_assume\natan,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_atan\natan2,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_atan2\natanh,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_atanh\nautomatic,\t\tGN_KEYWORDS_1364_2001,\t\tK_automatic\nbefore,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_before\nbegin,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_begin\nbind,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_bind\nbins,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_bins\nbinsof,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_binsof\nbit,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_bit\nbranch,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_branch\nbreak,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_break\nbool,\t\t\tGN_KEYWORDS_ICARUS,\t\tK_bool\nbuf,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_buf\nbufif0,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_bufif0\nbufif1,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_bufif1\nbyte,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_byte\ncase,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_case\ncasex,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_casex\ncasez,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_casez\nceil,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_ceil\ncell,\t\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_cell\nchandle,\t\tGN_KEYWORDS_1800_2005,\t\tK_chandle\nchecker,\t\tGN_KEYWORDS_1800_2009,\t\tK_checker\nclass,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_class\nclocking,\t\tGN_KEYWORDS_1800_2005,\t\tK_clocking\ncmos,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_cmos\nconfig,\t\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_config\nconnect,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_connect\nconnectmodule,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_connectmodule\nconnectrules,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_connectrules\nconst,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_const\nconstraint,\t\tGN_KEYWORDS_1800_2005,\t\tK_constraint\ncontext,\t\tGN_KEYWORDS_1800_2005,\t\tK_context\ncontinue,\t\tGN_KEYWORDS_1800_2005,\t\tK_continue\ncontinuous,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_continuous\ncos,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_cos\ncosh,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_cosh\ncover,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_cover\ncovergroup,\t\tGN_KEYWORDS_1800_2005,\t\tK_covergroup\ncoverpoint,\t\tGN_KEYWORDS_1800_2005,\t\tK_coverpoint\ncross,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_cross\nddt,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_ddt\nddt_nature,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_ddt_nature\nddx,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_ddx\ndeassign,\t\tGN_KEYWORDS_1364_1995,\t\tK_deassign\ndefault,\t\tGN_KEYWORDS_1364_1995,\t\tK_default\ndefparam,\t\tGN_KEYWORDS_1364_1995,\t\tK_defparam\ndesign,\t\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_design\ndisable,\t\tGN_KEYWORDS_1364_1995,\t\tK_disable\ndiscipline,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_discipline\ndiscrete,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_discrete\ndist,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_dist\ndo,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_do\ndomain,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_domain\ndriver_update,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_driver_update\nedge,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_edge\nelse,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_else\nend,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_end\nendcase,\t\tGN_KEYWORDS_1364_1995,\t\tK_endcase\nendchecker,\t\tGN_KEYWORDS_1800_2009,\t\tK_endchecker\nendconfig,\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_endconfig\nendclass,\t\tGN_KEYWORDS_1800_2005,\t\tK_endclass\nendclocking,\t\tGN_KEYWORDS_1800_2005,\t\tK_endclocking\nendconnectrules,\tGN_KEYWORDS_VAMS_2_3,\t\tK_endconnectrules\nenddiscipline,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_enddiscipline\nendfunction,\t\tGN_KEYWORDS_1364_1995,\t\tK_endfunction\nendgenerate,\t\tGN_KEYWORDS_1364_2001,\t\tK_endgenerate\nendgroup,\t\tGN_KEYWORDS_1800_2005,\t\tK_endgroup\nendinterface,\t\tGN_KEYWORDS_1800_2005,\t\tK_endinterface\nendmodule,\t\tGN_KEYWORDS_1364_1995,\t\tK_endmodule\nendnature,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_endnature\nendpackage,\t\tGN_KEYWORDS_1800_2005,\t\tK_endpackage\nendparamset,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_endparamset\nendprimitive,\t\tGN_KEYWORDS_1364_1995,\t\tK_endprimitive\nendprogram,\t\tGN_KEYWORDS_1800_2005,\t\tK_endprogram\nendproperty,\t\tGN_KEYWORDS_1800_2005,\t\tK_endproperty\nendspecify,\t\tGN_KEYWORDS_1364_1995,\t\tK_endspecify\nendsequence,\t\tGN_KEYWORDS_1800_2005,\t\tK_endsequence\nendtable,\t\tGN_KEYWORDS_1364_1995,\t\tK_endtable\nendtask,\t\tGN_KEYWORDS_1364_1995,\t\tK_endtask\nenum,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_enum\nevent,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_event\neventually,\t\tGN_KEYWORDS_1800_2009,\t\tK_eventually\nexclude,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_exclude\nexp,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_exp\nexpect,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_expect\nexport,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_export\nextends,\t\tGN_KEYWORDS_1800_2005,\t\tK_extends\nextern,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_extern\nfinal,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_final\nfinal_step,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_final_step\nfirst_match,\t\tGN_KEYWORDS_1800_2005,\t\tK_first_match\nflicker_noise,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_flicker_noise\nfloor,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_floor\nflow,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_flow\nfor,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_for\nforeach,\t\tGN_KEYWORDS_1800_2005,\t\tK_foreach\nforce,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_force\nforever,\t\tGN_KEYWORDS_1364_1995,\t\tK_forever\nfork,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_fork\nforkjoin,\t\tGN_KEYWORDS_1800_2005,\t\tK_forkjoin\nfrom,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_from\nfunction,\t\tGN_KEYWORDS_1364_1995,\t\tK_function\ngenerate,\t\tGN_KEYWORDS_1364_2001,\t\tK_generate\ngenvar,\t\t\tGN_KEYWORDS_1364_2001,\t\tK_genvar\nglobal,\t\t\tGN_KEYWORDS_1800_2009,\t\tK_global\nground,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_ground\nhighz0,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_highz0\nhighz1,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_highz1\nhypot,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_hypot\nidt,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_idt\nidtmod,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_idtmod\nidt_nature,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_idt_nature\nif,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_if\niff,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_iff\nifnone,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_ifnone\nignore_bins,\t\tGN_KEYWORDS_1800_2005,\t\tK_ignore_bins\nillegal_bins,\t\tGN_KEYWORDS_1800_2005,\t\tK_illegal_bins\nimplies,\t\tGN_KEYWORDS_1800_2009,\t\tK_implies\nimplements,\t\tGN_KEYWORDS_1800_2012,\t\tK_implements\nimport,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_import\nincdir,\t\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_incdir\ninclude,\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_include\ninf,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_inf\ninitial,\t\tGN_KEYWORDS_1364_1995,\t\tK_initial\ninitial_step,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_initial_step\ninout,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_inout\ninput,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_input\ninside,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_inside\ninstance,\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_instance\nint,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_int\ninteger,\t\tGN_KEYWORDS_1364_1995,\t\tK_integer\ninterconnect,\t\tGN_KEYWORDS_1800_2012,\t\tK_interconnect\ninterface,\t\tGN_KEYWORDS_1800_2005,\t\tK_interface\nintersect,\t\tGN_KEYWORDS_1800_2005,\t\tK_intersect\njoin,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_join\njoin_any,\t\tGN_KEYWORDS_1800_2005,\t\tK_join_any\njoin_none,\t\tGN_KEYWORDS_1800_2005,\t\tK_join_none\nlaplace_nd,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_laplace_nd\nlaplace_np,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_laplace_np\nlaplace_zd,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_laplace_zd\nlaplace_zp,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_laplace_zp\nlarge,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_large\nlast_crossing,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_last_crossing\nlet,\t\t\tGN_KEYWORDS_1800_2009,\t\tK_let\nliblist,\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_liblist\nlibrary,\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_library\nlimexp,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_limexp\nln,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_ln\nlocal,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_local\nlocalparam,\t\tGN_KEYWORDS_1364_2001,\t\tK_localparam\nlog,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_log\n# This is defined by SystemVerilog 1800-2005 and as an Icarus extension.\nlogic,\tGN_KEYWORDS_1800_2005|GN_KEYWORDS_ICARUS,\tK_logic\nlongint,\t\tGN_KEYWORDS_1800_2005,\t\tK_longint\nmacromodule,\t\tGN_KEYWORDS_1364_1995,\t\tK_macromodule\nmatches,\t\tGN_KEYWORDS_1800_2005,\t\tK_matches\nmax,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_max\nmedium,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_medium\nmerged,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_merged\nmin,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_min\nmodport,\t\tGN_KEYWORDS_1800_2005,\t\tK_modport\nmodule,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_module\nnand,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_nand\nnature,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_nature\nnegedge,\t\tGN_KEYWORDS_1364_1995,\t\tK_negedge\nnet_resolution,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_net_resolution\nnettype,\t\tGN_KEYWORDS_1800_2012,\t\tK_nettype\nnew,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_new\nnexttime,\t\tGN_KEYWORDS_1800_2009,\t\tK_nexttime\nnmos,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_nmos\nnoise_table,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_noise_table\nnor,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_nor\nnoshowcancelled,\tGN_KEYWORDS_1364_2001,\t\tK_noshowcancelled\nnot,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_not\nnotif0,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_notif0\nnotif1,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_notif1\nnull,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_null\nor,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_or\noutput,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_output\npackage,\t\tGN_KEYWORDS_1800_2005,\t\tK_package\npacked,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_packed\nparameter,\t\tGN_KEYWORDS_1364_1995,\t\tK_parameter\nparamset,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_paramset\npmos,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_pmos\nposedge,\t\tGN_KEYWORDS_1364_1995,\t\tK_posedge\npotential,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_potential\npow,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_pow\nprimitive,\t\tGN_KEYWORDS_1364_1995,\t\tK_primitive\npriority,\t\tGN_KEYWORDS_1800_2005,\t\tK_priority\nprogram,\t\tGN_KEYWORDS_1800_2005,\t\tK_program\nproperty,\t\tGN_KEYWORDS_1800_2005,\t\tK_property\nprotected,\t\tGN_KEYWORDS_1800_2005,\t\tK_protected\npull0,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_pull0\npull1,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_pull1\npulldown,\t\tGN_KEYWORDS_1364_1995,\t\tK_pulldown\npullup,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_pullup\npulsestyle_onevent,\tGN_KEYWORDS_1364_2001,\t\tK_pulsestyle_onevent\npulsestyle_ondetect,\tGN_KEYWORDS_1364_2001,\t\tK_pulsestyle_ondetect\npure,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_pure\nrand,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_rand\nrandc,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_randc\nrandcase,\t\tGN_KEYWORDS_1800_2005,\t\tK_randcase\nrandsequence,\t\tGN_KEYWORDS_1800_2005,\t\tK_randsequence\nrcmos,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_rcmos\nreal,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_real\nrealtime,\t\tGN_KEYWORDS_1364_1995,\t\tK_realtime\nref,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_ref\nreg,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_reg\nreject_on,\t\tGN_KEYWORDS_1800_2009,\t\tK_reject_on\nrelease,\t\tGN_KEYWORDS_1364_1995,\t\tK_release\nrepeat,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_repeat\nresolveto,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_resolveto\nrestrict,\t\tGN_KEYWORDS_1800_2009,\t\tK_restrict\nreturn,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_return\nrnmos,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_rnmos\nrpmos,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_rpmos\nrtran,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_rtran\nrtranif0,\t\tGN_KEYWORDS_1364_1995,\t\tK_rtranif0\nrtranif1,\t\tGN_KEYWORDS_1364_1995,\t\tK_rtranif1\ns_always,\t\tGN_KEYWORDS_1800_2009,\t\tK_s_always\ns_eventually,\t\tGN_KEYWORDS_1800_2009,\t\tK_s_eventually\ns_nexttime,\t\tGN_KEYWORDS_1800_2009,\t\tK_s_nexttime\ns_until,\t\tGN_KEYWORDS_1800_2009,\t\tK_s_until\ns_until_with,\t\tGN_KEYWORDS_1800_2009,\t\tK_s_until_with\nscalared,\t\tGN_KEYWORDS_1364_1995,\t\tK_scalared\nsequence,\t\tGN_KEYWORDS_1800_2005,\t\tK_sequence\nshortint,\t\tGN_KEYWORDS_1800_2005,\t\tK_shortint\nshortreal,\t\tGN_KEYWORDS_1800_2005,\t\tK_shortreal\nshowcancelled,\t\tGN_KEYWORDS_1364_2001,\t\tK_showcancelled\nsigned,\t\t\tGN_KEYWORDS_1364_2001,\t\tK_signed\nsin,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_sin\nsinh,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_sinh\nslew,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_slew\nsmall,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_small\nsoft,\t\t\tGN_KEYWORDS_1800_2012,\t\tK_soft\nsolve,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_solve\nspecify,\t\tGN_KEYWORDS_1364_1995,\t\tK_specify\nspecparam,\t\tGN_KEYWORDS_1364_1995,\t\tK_specparam\nsplit,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_split\nsqrt,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_sqrt\nstatic,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_static\n# This is defined by both SystemVerilog 1800-2005 and Verilog-AMS 2.3\nstring,\tGN_KEYWORDS_1800_2005|GN_KEYWORDS_VAMS_2_3,\tK_string\nstrong,\t\t\tGN_KEYWORDS_1800_2009,\t\tK_strong\nstrong0,\t\tGN_KEYWORDS_1364_1995,\t\tK_strong0\nstrong1,\t\tGN_KEYWORDS_1364_1995,\t\tK_strong1\nstruct,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_struct\nsuper,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_super\nsupply0,\t\tGN_KEYWORDS_1364_1995,\t\tK_supply0\nsupply1,\t\tGN_KEYWORDS_1364_1995,\t\tK_supply1\nsync_accept_on,\t\tGN_KEYWORDS_1800_2009,\t\tK_sync_accept_on\nsync_reject_on,\t\tGN_KEYWORDS_1800_2009,\t\tK_sync_reject_on\ntable,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_table\ntagged,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_tagged\ntan,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_tan\ntanh,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_tanh\ntask,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_task\nthis,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_this\nthroughout,\t\tGN_KEYWORDS_1800_2005,\t\tK_throughout\ntime,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_time\ntimeprecision,\t\tGN_KEYWORDS_1800_2005,\t\tK_timeprecision\ntimer,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_timer\ntimeunit,\t\tGN_KEYWORDS_1800_2005,\t\tK_timeunit\ntran,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_tran\ntranif0,\t\tGN_KEYWORDS_1364_1995,\t\tK_tranif0\ntranif1,\t\tGN_KEYWORDS_1364_1995,\t\tK_tranif1\ntransition,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_transition\ntri,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_tri\ntri0,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_tri0\ntri1,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_tri1\ntriand,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_triand\ntrior,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_trior\ntrireg,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_trireg\ntype,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_type\ntypedef,\t\tGN_KEYWORDS_1800_2005,\t\tK_typedef\nunion,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_union\nunique,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_unique\nunique0,\t\tGN_KEYWORDS_1800_2009,\t\tK_unique0\nunits,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_units\n# Reserved for future use!\nunsigned,\t\tGN_KEYWORDS_1364_2001,\t\tK_unsigned\nuntil,\t\t\tGN_KEYWORDS_1800_2009,\t\tK_until\nuntil_with,\t\tGN_KEYWORDS_1800_2009,\t\tK_until_with\nuntyped,\t\tGN_KEYWORDS_1800_2009,\t\tK_untyped\nuse,\t\t\tGN_KEYWORDS_1364_2001_CONFIG,\tK_use\nuwire,\t\t\tGN_KEYWORDS_1364_2005,\t\tK_uwire\nvar,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_var\nvectored,\t\tGN_KEYWORDS_1364_1995,\t\tK_vectored\nvirtual,\t\tGN_KEYWORDS_1800_2005,\t\tK_virtual\nvoid,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_void\nwait,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_wait\nwait_order,\t\tGN_KEYWORDS_1800_2005,\t\tK_wait_order\nwand,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_wand\nweak,\t\t\tGN_KEYWORDS_1800_2009,\t\tK_weak\nweak0,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_weak0\nweak1,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_weak1\nwhile,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_while\nwhite_noise,\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_white_noise\nwildcard,\t\tGN_KEYWORDS_1800_2005,\t\tK_wildcard\nwire,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_wire\nwith,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_with\nwithin,\t\t\tGN_KEYWORDS_1800_2005,\t\tK_within\n# This is the name originally proposed for uwire and is deprecated!\nwone,\t\t\tGN_KEYWORDS_1364_2005,\t\tK_wone\nwor,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_wor\n# This is defined by Verilog-AMS 2.3 and as an Icarus extension.\nwreal,\tGN_KEYWORDS_VAMS_2_3|GN_KEYWORDS_ICARUS,\tK_wreal\nxnor,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_xnor\nxor,\t\t\tGN_KEYWORDS_1364_1995,\t\tK_xor\nzi_nd,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_zi_nd\nzi_np,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_zi_np\nzi_zd,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_zi_zd\nzi_zp,\t\t\tGN_KEYWORDS_VAMS_2_3,\t\tK_zi_zp\n%%\n\nint lexor_keyword_mask = 0;\n\nint lexor_keyword_code(const char*str, unsigned nstr)\n{\n      const struct lexor_keyword*rc = Lkwd::check_identifier(str, nstr);\n      if (rc == 0)\n\t  return IDENTIFIER;\n      else if ((rc->mask & lexor_keyword_mask) == 0)\n          return IDENTIFIER;\n      else\n\t  return rc->tokenType;\n}\n"
        },
        {
          "name": "lexor_keyword.h",
          "type": "blob",
          "size": 0.9833984375,
          "content": "#ifndef IVL_lexor_keyword_H\n#define IVL_lexor_keyword_H\n/*\n * Copyright (c) 2000-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\nextern int lexor_keyword_code (const char*str, unsigned len);\n\n#endif /* IVL_lexor_keyword_H */\n"
        },
        {
          "name": "libmisc",
          "type": "tree",
          "content": null
        },
        {
          "name": "libveriuser",
          "type": "tree",
          "content": null
        },
        {
          "name": "link_const.cc",
          "type": "blob",
          "size": 8.7705078125,
          "content": "/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * Scan the link for drivers. If there are only constant drivers, then\n * the nexus has a known constant value.\n */\nbool Nexus::drivers_constant() const\n{\n      if (driven_ == VAR)\n\t    return false;\n      if (driven_ != NO_GUESS)\n\t    return true;\n\n      unsigned constant_drivers = 0;\n      for (const Link*cur = first_nlink() ; cur  ;  cur = cur->next_nlink()) {\n\n\t      /* A target of a procedural assign or force statement\n\t\t can't be treated as constant. */\n\t    const NetNet*sig = dynamic_cast<const NetNet*>(cur->get_obj());\n\t    if (sig && (sig->peek_lref() > 0)) {\n\t\t  driven_ = VAR;\n\t\t  return false;\n\t    }\n\n\t      /* If we are connected to a tran, there may be a driver\n\t\t on the other side of the tran. We could try checking\n\t\t for this, but for now, be pessimistic. */\n\t    if (dynamic_cast<const NetTran*>(cur->get_obj())) {\n\t\t  driven_ = VAR;\n\t\t  return false;\n\t    }\n\n\t    Link::DIR cur_dir = cur->get_dir();\n\t    if (cur_dir == Link::INPUT)\n\t\t  continue;\n\n\t      /* If this is an input or inout port of a root module,\n\t\t then this is probably not a constant value. I\n\t\t certainly don't know what the value is, anyhow. This\n\t\t can happen in cases like this:\n\n\t\t module main(sig);\n\t\t     input sig;\n\t\t endmodule\n\n\t\t If main is a root module (it has no parent) then sig\n\t\t is not constant because it connects to an unspecified\n\t\t outside world. */\n\n\t    if (cur_dir == Link::PASSIVE) {\n\t\t  if (sig == 0 || sig->scope()->parent() != 0)\n\t\t\tcontinue;\n\n\t\t  if (sig->port_type() == NetNet::NOT_A_PORT)\n\t\t\tcontinue;\n\n\t\t  if (sig->port_type() == NetNet::POUTPUT)\n\t\t\tcontinue;\n\n\t\t  driven_ = VAR;\n\t\t  return false;\n\t    }\n\n\t      /* If there is an implicit pullup/pulldown on a net,\n\t\t count it as a constant driver. */\n\t    if (sig)\n\t\t  switch (sig->type()) {\n\t\t      case NetNet::SUPPLY0:\n\t\t      case NetNet::TRI0:\n\t\t\tconstant_drivers += 1;\n\t\t\tdriven_ = V0;\n\t\t\tcontinue;\n\t\t      case NetNet::SUPPLY1:\n\t\t      case NetNet::TRI1:\n\t\t\tconstant_drivers += 1;\n\t\t\tdriven_ = V1;\n\t\t\tcontinue;\n\t\t      default:\n\t\t\tbreak;\n\t\t  }\n\n\t    const NetSubstitute*ps = dynamic_cast<const NetSubstitute*>(cur->get_obj());\n\t    if (ps) {\n\t\t  if (ps->pin(1).nexus()->drivers_constant() &&\n\t\t      ps->pin(2).nexus()->drivers_constant() ) {\n\t\t\tconstant_drivers += 1;\n\t\t\tcontinue;\n\t\t  }\n\t\t  driven_ = VAR;\n\t\t  return false;\n\t    }\n\n\t    if (! dynamic_cast<const NetConst*>(cur->get_obj())) {\n\t\t  driven_ = VAR;\n\t\t  return false;\n\t    }\n\n\t    constant_drivers += 1;\n      }\n\n\t/* If there is more than one constant driver for this nexus, we\n\t   would need to resolve the constant value, taking into account\n\t   the drive strengths. This is a lot of work for something that\n\t   will rarely occur, so for now leave the resolution to be done\n\t   at run time. */\n      if (constant_drivers > 1) {\n\t    driven_ = VAR;\n\t    return false;\n      }\n\n      return true;\n}\n\nverinum::V Nexus::driven_value() const\n{\n      switch (driven_) {\n\t  case V0:\n\t    return verinum::V0;\n\t  case V1:\n\t    return verinum::V1;\n\t  case Vx:\n\t    return verinum::Vx;\n\t  case Vz:\n\t    return verinum::Vz;\n\t  case VAR:\n\t    assert(0);\n\t    break;\n\t  case NO_GUESS:\n\t    break;\n      }\n\n      const Link*cur = list_;\n\n      verinum::V val = verinum::Vz;\n\n      for (cur = first_nlink() ; cur  ;  cur = cur->next_nlink()) {\n\n\t    const NetConst*obj;\n\t    const NetNet*sig;\n\t    if ((obj = dynamic_cast<const NetConst*>(cur->get_obj()))) {\n\t\t    // Multiple drivers are not currently supported.\n\t\t  ivl_assert(*obj, val == verinum::Vz);\n\t\t  val = obj->value(cur->get_pin());\n\n\t    } else if ((sig = dynamic_cast<const NetNet*>(cur->get_obj()))) {\n\n\t\t    // If we find an implicit pullup or pulldown on a\n\t\t    // net, this is a good guess for the driven value,\n\t\t    // but keep looking for other drivers.\n\t\t  if ((sig->type() == NetNet::SUPPLY0) ||\n\t\t      (sig->type() == NetNet::TRI0)) {\n\t\t\t  // Multiple drivers are not currently supported.\n\t\t\tivl_assert(*sig, val == verinum::Vz);\n\t\t\tval = verinum::V0;\n\t\t  }\n\t\t  if ((sig->type() == NetNet::SUPPLY1) ||\n\t\t      (sig->type() == NetNet::TRI1)) {\n\t\t\t  // Multiple drivers are not currently supported.\n\t\t\tivl_assert(*sig, val == verinum::Vz);\n\t\t\tval = verinum::V1;\n\t\t  }\n\t    }\n      }\n\n\t/* Cache the result. */\n      switch (val) {\n\t  case verinum::V0:\n\t    driven_ = V0;\n\t    break;\n\t  case verinum::V1:\n\t    driven_ = V1;\n\t    break;\n\t  case verinum::Vx:\n\t    driven_ = Vx;\n\t    break;\n\t  case verinum::Vz:\n\t    driven_ = Vz;\n\t    break;\n      }\n\n      return val;\n}\n\n\nverinum Nexus::driven_vector() const\n{\n      const Link*cur = list_;\n\n      verinum val;\n      verinum pval;\n      unsigned width = 0;\n\n      for (cur = first_nlink() ; cur  ;  cur = cur->next_nlink()) {\n\n\t    const NetSubstitute*ps;\n\t    const NetConst*obj;\n\t    const NetNet*sig;\n\t    if ((obj = dynamic_cast<const NetConst*>(cur->get_obj()))) {\n\t\t    // Multiple drivers are not currently supported.\n\t\t  ivl_assert(*obj, val.len() == 0);\n\t\t  ivl_assert(*obj, cur->get_pin() == 0);\n\t\t  val = obj->value();\n\t\t  width = val.len();\n\n\t    } else if ((ps = dynamic_cast<const NetSubstitute*>(cur->get_obj()))) {\n\t\t  if (cur->get_pin() != 0)\n\t\t\tcontinue;\n\n\t\t    // Multiple drivers are not currently supported.\n\t\t  ivl_assert(*ps, val.len() == 0);\n\t\t  val  = ps->pin(1).nexus()->driven_vector();\n\t\t  pval = ps->pin(2).nexus()->driven_vector();\n\t\t  for (unsigned idx = 0; idx < pval.len(); idx += 1)\n\t\t\tval.set(ps->base() + idx, pval.get(idx));\n\t\t  width = val.len();\n\n\t    } else if ((sig = dynamic_cast<const NetNet*>(cur->get_obj()))) {\n\n\t\t  width = sig->vector_width();\n\n\t\t    // If we find an implicit pullup or pulldown on a\n\t\t    // net, this is a good guess for the driven value,\n\t\t    // but keep looking for other drivers.\n\t\t  if ((sig->type() == NetNet::SUPPLY0) ||\n\t\t      (sig->type() == NetNet::TRI0)) {\n\t\t\t  // Multiple drivers are not currently supported.\n\t\t\tivl_assert(*sig, val.len() == 0);\n\t\t\tval = verinum(verinum::V0, width);\n\t\t  }\n\t\t  if ((sig->type() == NetNet::SUPPLY1) ||\n\t\t      (sig->type() == NetNet::TRI1)) {\n\t\t\t  // Multiple drivers are not currently supported.\n\t\t\tivl_assert(*sig, val.len() == 0);\n\t\t\tval = verinum(verinum::V1, width);\n\t\t  }\n\t    }\n      }\n\n\t// If we have a width but not a value, this must be an undriven net.\n      if (val.len() != width)\n\t    val = verinum(verinum::Vz, width);\n\n      return val;\n}\n\n/*\n * Calculate a vector that represent all the bits of the vector, with\n * each driven bit set to true, otherwise false.\n */\nvector<bool> Nexus::driven_mask(void) const\n{\n      vector<bool> mask (vector_width());\n\n      for (const Link*cur = first_nlink() ; cur ; cur = cur->next_nlink()) {\n\n\t    Link::DIR link_dir = cur->get_dir();\n\t    if (link_dir==Link::PASSIVE)\n\t\t  continue;\n\t    if (link_dir==Link::INPUT)\n\t\t  continue;\n\n\t    const NetPins*obj = cur->get_obj();\n\n\t      // If the link is to a variable (REG or INTEGER) then\n\t      // the variable is driving all the bits. We have our\n\t      // complete answer, mark all the bits as driven and\n\t      // finish. Otherwise, we are not going to get new\n\t      // information from this node, move on.\n\t    if (const NetNet*sig = dynamic_cast<const NetNet*> (obj)) {\n\t\t  NetNet::Type sig_type = sig->type();\n\t\t  if (sig_type==NetNet::REG) {\n\t\t\tfor (size_t idx = 0 ; idx < mask.size() ; idx += 1)\n\t\t\t      mask[idx] = true;\n\t\t\treturn mask;\n\t\t  }\n\t\t  continue;\n\t    }\n\n\t    const NetPartSelect*obj_ps = dynamic_cast<const NetPartSelect*>(obj);\n\t    if(obj_ps) {\n\t\t  if (obj_ps->dir()==NetPartSelect::VP) {\n\t\t\tif(cur->get_pin() != 0)\n\t\t\t      continue;\n\t\t\tfor (size_t idx = 0 ; idx < mask.size() ; idx += 1)\n\t\t\t      mask[idx] = true;\n\t\t\treturn mask;\n\t\t  } else {\n\t\t\tif (cur->get_pin() != 1)\n\t\t\t      continue;\n\t\t  }\n\t\t  for (unsigned idx = 0 ; idx < obj_ps->width() ; idx += 1) {\n\t\t\tsize_t bit = idx + obj_ps->base();\n\t\t\tivl_assert(*obj, bit < mask.size());\n\t\t\tmask[bit] = true;\n\t\t  }\n\t\t  continue;\n\t    }\n\n\t    for (size_t idx = 0 ; idx < mask.size() ; idx += 1)\n\t\t  mask[idx] = true;\n\t    return mask;\n      }\n\n      return mask;\n}\n"
        },
        {
          "name": "load_module.cc",
          "type": "blob",
          "size": 4.7490234375,
          "content": "/*\n * Copyright (c) 2001-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"util.h\"\n# include  \"parse_api.h\"\n# include  \"compiler.h\"\n# include  <iostream>\n# include  <map>\n# include  <cstdlib>\n# include  <cstring>\n# include  <string>\n# include  <sys/types.h>\n# include  <dirent.h>\n# include  <cctype>\n# include  <cassert>\n# include  \"ivl_alloc.h\"\n\nusing namespace std;\n\n/*\n * The module library items are maps of key names to file name within\n * the directory.\n */\nstruct module_library {\n      char*dir;\n      bool key_case_sensitive;\n      map<string,const char*>name_map;\n      struct module_library*next;\n};\n\nstatic struct module_library*library_list = 0;\nstatic struct module_library*library_last = 0;\n\nconst char dir_character = '/';\nextern char depfile_mode;\nextern FILE *depend_file;\n\n/*\n * Use the type name as a key, and search the module library for a\n * file name that has that key.\n */\nbool load_module(const char*type, int&parser_errors)\n{\n      char path[4096];\n      char*ltype = strdup(type);\n\n      parser_errors = 0;\n\n      for (char*tmp = ltype ; *tmp ;  tmp += 1)\n\t    *tmp = tolower(*tmp);\n\n      for (struct module_library*lcur = library_list\n\t\t ; lcur != 0 ;  lcur = lcur->next) {\n\n\t    const char*key = lcur->key_case_sensitive? type : ltype;\n\t    map<string,const char*>::const_iterator cur;\n\t    cur = lcur->name_map.find(key);\n\t    if (cur == lcur->name_map.end())\n\t\t  continue;\n\n\t    snprintf(path, sizeof(path), \"%s%c%s\",\n\t\t     lcur->dir, dir_character, (*cur).second);\n\n\t    if(depend_file) {\n                  if (depfile_mode == 'p') {\n\t\t        fprintf(depend_file, \"M %s\\n\", path);\n                  } else if (depfile_mode != 'i') {\n\t\t        fprintf(depend_file, \"%s\\n\", path);\n                  }\n\t\t  fflush(depend_file);\n\t    }\n\n\t    if (verbose_flag)\n\t\t  cerr << \"Loading library file \" << path << \".\" << endl;\n\n\t    parser_errors = pform_parse(path);\n\n\t    if (verbose_flag)\n\t\t  cerr << \"... Load module complete.\" << endl << flush;\n\n\t    return parser_errors == 0;\n      }\n\n      return false;\n}\n\n/*\n * This function takes the name of a library directory that the caller\n * passed, and builds a name index for it.\n */\nint build_library_index(const char*path, bool key_case_sensitive)\n{\n      DIR*dir = opendir(path);\n      if (dir == 0)\n\t    return -1;\n\n      if (verbose_flag) {\n\t    cerr << \"Indexing library: \" << path << endl;\n      }\n\n      struct module_library*mlp = new struct module_library;\n      mlp->dir = strdup(path);\n      mlp->key_case_sensitive = key_case_sensitive;\n\n\t/* Scan the director for files. check each file name to see if\n\t   it has one of the configured suffixes. If it does, then use\n\t   the root of the name as the key and index the file name. */\n      while (struct dirent*de = readdir(dir)) {\n\t    unsigned namsiz = strlen(de->d_name);\n\t    char*key = 0;\n\n\t    for (list<const char*>::iterator suf = library_suff.begin()\n\t\t       ; suf != library_suff.end() ; ++ suf ) {\n\t\t  const char*sufptr = *suf;\n\t\t  unsigned sufsiz = strlen(sufptr);\n\n\t\t  if (sufsiz >= namsiz)\n\t\t\tcontinue;\n\n\t\t    /* If the directory is case insensitive, then so\n\t\t       is the suffix. */\n\t\t  if (key_case_sensitive) {\n\t\t\tif (strcmp(de->d_name + (namsiz-sufsiz),\n\t\t\t\t   sufptr) != 0)\n\t\t\t      continue;\n\t\t  } else {\n\t\t\tif (strcasecmp(de->d_name + (namsiz-sufsiz),\n\t\t\t\t       sufptr) != 0)\n\t\t\t      continue;\n\t\t  }\n\n\t\t  key = new char[namsiz-sufsiz+1];\n\t\t  strncpy(key, de->d_name, namsiz-sufsiz);\n\t\t  key[namsiz-sufsiz] = 0;\n\n\t\t  break;\n\t    }\n\n\t    if (key == 0)\n\t\t  continue;\n\n\t      /* If the key is not to be case sensitive, then change\n\t\t it to lowercase. */\n\t    if (! key_case_sensitive)\n\t\t  for (char*tmp = key ;  *tmp ;  tmp += 1)\n\t\t\t*tmp = tolower(*tmp);\n\n\t    mlp->name_map[key] = strdup(de->d_name);\n\t    delete[]key;\n      }\n\n      closedir(dir);\n\n      if (library_last) {\n\t    assert(library_list);\n\t    library_last->next = mlp;\n\t    mlp->next = 0;\n\t    library_last = mlp;\n      } else {\n\t    library_list = mlp;\n\t    library_last = mlp;\n\t    mlp->next = 0;\n      }\n\n      return 0;\n}\n"
        },
        {
          "name": "main.cc",
          "type": "blob",
          "size": 37.1142578125,
          "content": "const char COPYRIGHT[] =\n  \"Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\";\n/*\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"version_base.h\"\n# include \"version_tag.h\"\n\nconst char NOTICE[] =\n\"  This program is free software; you can redistribute it and/or modify\\n\"\n\"  it under the terms of the GNU General Public License as published by\\n\"\n\"  the Free Software Foundation; either version 2 of the License, or\\n\"\n\"  (at your option) any later version.\\n\"\n\"\\n\"\n\"  This program is distributed in the hope that it will be useful,\\n\"\n\"  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\"  GNU General Public License for more details.\\n\"\n\"\\n\"\n\"  You should have received a copy of the GNU General Public License along\\n\"\n\"  with this program; if not, write to the Free Software Foundation, Inc.,\\n\"\n\"  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\\n\"\n;\n\n# include  <cstdio>\n# include  <iostream>\n# include  <fstream>\n# include  <queue>\n# include  <cstring>\n# include  <list>\n# include  <map>\n# include  <unistd.h>\n# include  <cstdlib>\n#if defined(HAVE_TIMES)\n# include  <sys/times.h>\n#endif\n#if defined(HAVE_GETOPT_H)\n# include  <getopt.h>\n#endif\n# include  \"pform.h\"\n# include  \"parse_api.h\"\n# include  \"PGenerate.h\"\n# include  \"netlist.h\"\n# include  \"target.h\"\n# include  \"compiler.h\"\n# include  \"discipline.h\"\n# include  \"t-dll.h\"\n\nusing namespace std;\n\n#if defined(__MINGW32__) && !defined(HAVE_GETOPT_H)\nextern \"C\" int getopt(int argc, char*argv[], const char*fmt);\nextern \"C\" int optind;\nextern \"C\" const char*optarg;\n#endif\n\n#if defined(__CYGWIN__) && !defined(HAVE_GETOPT_H)\nextern \"C\" int getopt(int argc, char*argv[], const char*fmt);\nextern \"C\" int optind;\nextern \"C\" const char*optarg;\n#endif\n\n#if defined(TRAP_SIGINT_FOR_DEBUG)\n/*\n * This is a debugging aid. Do not compile it in general, but leave it\n * here for those days when I need the ability to cleanly exit on a\n * signal interrupt.\n*/\n# include  <csignal>\nstatic void signals_handler(int sig)\n{\n      fprintf(stderr, \"Exit on signal %d\\n\", sig);\n      exit(1);\n}\n#endif\n\n# include  \"ivl_alloc.h\"\n\n/* Count errors detected in flag processing. */\nunsigned flag_errors = 0;\nstatic unsigned long pre_process_fail_count = 0;\n\nconst char*basedir = strdup(\".\");\n\n/*\n * These are the language support control flags. These support which\n * language features (the generation) to support. The generation_flag\n * is a major mode, and the gn_* flags control specific sub-features.\n */\ngeneration_t generation_flag = GN_DEFAULT;\nbool gn_icarus_misc_flag = true;\nbool gn_cadence_types_flag = true;\nbool gn_specify_blocks_flag = true;\nbool gn_interconnect_flag = true;\nbool gn_supported_assertions_flag = true;\nbool gn_unsupported_assertions_flag = true;\nbool gn_io_range_error_flag = true;\nbool gn_strict_ca_eval_flag = false;\nbool gn_strict_expr_width_flag = false;\nbool gn_shared_loop_index_flag = true;\nbool gn_verilog_ams_flag = false;\n\n/*\n * For some generations we allow a system function to be called\n * as a task and only print a warning message. The default for\n * this is that it is a run time error.\n */\nivl_sfunc_as_task_t def_sfunc_as_task = IVL_SFUNC_AS_TASK_ERROR;\n\nmap<string,const char*> flags;\nchar*vpi_module_list = 0;\nvoid add_vpi_module(const char*name)\n{\n      if (vpi_module_list == 0) {\n\t    vpi_module_list = strdup(name);\n\n      } else {\n\t    char*tmp = (char*)realloc(vpi_module_list,\n\t\t\t\t      strlen(vpi_module_list)\n\t\t\t\t      + strlen(name)\n\t\t\t\t      + 2);\n\t    strcat(tmp, \",\");\n\t    strcat(tmp, name);\n\t    vpi_module_list = tmp;\n      }\n      flags[\"VPI_MODULE_LIST\"] = vpi_module_list;\n      load_vpi_module(name);\n}\n\nmap<perm_string,unsigned> missing_modules;\nmap<perm_string,bool> library_file_map;\n\nvector<perm_string> source_files;\n\nlist<const char*> library_suff;\n\nlist<perm_string> roots;\n\nchar*ivlpp_string = 0;\n\nchar depfile_mode = 'a';\nchar* depfile_name = NULL;\nFILE *depend_file = NULL;\n\n/*\n * These are the warning enable flags.\n */\nbool warn_implicit  = false;\nbool warn_implicit_dimensions = false;\nbool warn_timescale = false;\nbool warn_portbinding = false;\nbool warn_inf_loop = false;\nbool warn_ob_select = false;\nbool warn_sens_entire_vec = false;\nbool warn_sens_entire_arr = false;\nbool warn_anachronisms = false;\nbool warn_floating_nets = false;\n\n/*\n * Ignore errors about missing modules\n */\nbool ignore_missing_modules = false;\n\n/*\n * Debug message class flags.\n */\nbool debug_scopes = false;\nbool debug_eval_tree = false;\nbool debug_elaborate = false;\nbool debug_emit = false;\nbool debug_synth2 = false;\nbool debug_optimizer = false;\n\n/*\n * Compilation control flags.\n */\nbool separate_compilation = false;\n\n/*\n * Optimization control flags.\n */\nunsigned opt_const_func = 0;\n\n/*\n * Miscellaneous flags.\n */\nbool disable_virtual_pins = false;\nunsigned long array_size_limit = 16777216;  // Minimum required by IEEE-1364?\nunsigned recursive_mod_limit = 10;\nbool disable_concatz_generation = false;\n\n/*\n * Verbose messages enabled.\n */\nbool verbose_flag = false;\n\nunsigned integer_width = 32;\n\n/*\n * Width limit for unsized expressions.\n */\nunsigned width_cap = 65536;\n\nint def_ts_units = 0;\nint def_ts_prec = 0;\n\n/*\n * Keep a heap of identifier strings that I encounter. This is a more\n * efficient way to allocate those strings.\n */\nStringHeapLex lex_strings;\n\nStringHeapLex filename_strings;\n\nStringHeapLex bits_strings;\n\n/*\n * In library searches, Windows file names are never case sensitive.\n */\n#if defined(__MINGW32__)\nconst bool CASE_SENSITIVE = false;\n#else\nconst bool CASE_SENSITIVE = true;\n#endif\n\n/*\n * Are we doing synthesis?\n */\nbool synthesis = false;\n\nextern void cprop(Design*des);\nextern void exposenodes(Design*des);\nextern void synth(Design*des);\nextern void synth2(Design*des);\nextern void syn_rules(Design*des);\nextern void nodangle(Design*des);\n\ntypedef void (*net_func)(Design*);\nstatic struct net_func_map {\n      const char*name;\n      void (*func)(Design*);\n} func_table[] = {\n      { \"cprop\",       &cprop },\n      { \"exposenodes\", &exposenodes },\n      { \"nodangle\",    &nodangle },\n      { \"synth\",       &synth },\n      { \"synth2\",      &synth2 },\n      { \"syn-rules\",   &syn_rules },\n      { 0, 0 }\n};\n\nqueue<net_func> net_func_queue;\n\nnet_func name_to_net_func(const string&name)\n{\n      for (unsigned idx = 0 ;  func_table[idx].name ;  idx += 1)\n\t    if (name == func_table[idx].name)\n\t\t  return func_table[idx].func;\n\n      return 0;\n}\n\nconst char *net_func_to_name(const net_func func)\n{\n      for (unsigned idx = 0 ;  func_table[idx].name ;  idx += 1)\n\t    if (func == func_table[idx].func)\n\t\t  return func_table[idx].name;\n\n      return \"This cannot happen\";\n}\n\nstatic void process_generation_flag(const char*gen)\n{\n      if (strcmp(gen,\"1\") == 0) { // FIXME: Deprecated for 1995\n\t    generation_flag = GN_VER1995;\n\n      } else if (strcmp(gen,\"2\") == 0) { // FIXME: Deprecated for 2001\n\t    generation_flag = GN_VER2001;\n\n      } else if (strcmp(gen,\"2x\") == 0) { // FIXME: Deprecated for 2001\n\t    generation_flag = GN_VER2001;\n\t    gn_icarus_misc_flag = true;\n\n      } else if (strcmp(gen,\"1995\") == 0) {\n\t    generation_flag = GN_VER1995;\n\n      } else if (strcmp(gen,\"2001\") == 0) {\n\t    generation_flag = GN_VER2001;\n\n      } else if (strcmp(gen,\"2001-noconfig\") == 0) {\n\t    generation_flag = GN_VER2001_NOCONFIG;\n\n      } else if (strcmp(gen,\"2005\") == 0) {\n\t    generation_flag = GN_VER2005;\n\n      } else if (strcmp(gen,\"2005-sv\") == 0) {\n\t    generation_flag = GN_VER2005_SV;\n\n      } else if (strcmp(gen,\"2009\") == 0) {\n\t    generation_flag = GN_VER2009;\n\n      } else if (strcmp(gen,\"2012\") == 0) {\n\t    generation_flag = GN_VER2012;\n\n      } else if (strcmp(gen,\"icarus-misc\") == 0) {\n\t    gn_icarus_misc_flag = true;\n\n      } else if (strcmp(gen,\"no-icarus-misc\") == 0) {\n\t    gn_icarus_misc_flag = false;\n\n      } else if (strcmp(gen,\"xtypes\") == 0) {\n\t    gn_cadence_types_flag = true;\n\n      } else if (strcmp(gen,\"no-xtypes\") == 0) {\n\t    gn_cadence_types_flag = false;\n\n      } else if (strcmp(gen,\"specify\") == 0) {\n\t    gn_specify_blocks_flag = true;\n\n      } else if (strcmp(gen,\"no-specify\") == 0) {\n\t    gn_specify_blocks_flag = false;\n\n      } else if (strcmp(gen,\"interconnect\") == 0) {\n\t    gn_interconnect_flag = true;\n\n      } else if (strcmp(gen,\"no-interconnect\") == 0) {\n\t    gn_interconnect_flag = false;\n\n      } else if (strcmp(gen,\"assertions\") == 0) {\n\t    gn_supported_assertions_flag = true;\n\t    gn_unsupported_assertions_flag = true;\n\n      } else if (strcmp(gen,\"supported-assertions\") == 0) {\n\t    gn_supported_assertions_flag = true;\n\t    gn_unsupported_assertions_flag = false;\n\n      } else if (strcmp(gen,\"no-assertions\") == 0) {\n\t    gn_supported_assertions_flag = false;\n\t    gn_unsupported_assertions_flag = false;\n\n      } else if (strcmp(gen,\"verilog-ams\") == 0) {\n\t    gn_verilog_ams_flag = true;\n\n      } else if (strcmp(gen,\"no-verilog-ams\") == 0) {\n\t    gn_verilog_ams_flag = false;\n\n      } else if (strcmp(gen,\"io-range-error\") == 0) {\n\t    gn_io_range_error_flag = true;\n\n      } else if (strcmp(gen,\"no-io-range-error\") == 0) {\n\t    gn_io_range_error_flag = false;\n\n      } else if (strcmp(gen,\"strict-ca-eval\") == 0) {\n\t    gn_strict_ca_eval_flag = true;\n\n      } else if (strcmp(gen,\"no-strict-ca-eval\") == 0) {\n\t    gn_strict_ca_eval_flag = false;\n\n      } else if (strcmp(gen,\"strict-expr-width\") == 0) {\n\t    gn_strict_expr_width_flag = true;\n\n      } else if (strcmp(gen,\"no-strict-expr-width\") == 0) {\n\t    gn_strict_expr_width_flag = false;\n\n      } else if (strcmp(gen,\"shared-loop-index\") == 0) {\n\t    gn_shared_loop_index_flag = true;\n\n      } else if (strcmp(gen,\"no-shared-loop-index\") == 0) {\n\t    gn_shared_loop_index_flag = false;\n\n\t  } else {\n      }\n}\n\nstatic void parm_to_flagmap(const string&flag)\n{\n      string key;\n      const char*value;\n      unsigned off = flag.find('=');\n      if (off > flag.size()) {\n\t    key = flag;\n\t    value = strdup(\"\");\n\n      } else {\n\t    key = flag.substr(0, off);\n\t    value = strdup(flag.substr(off+1).c_str());\n      }\n\n      flags[key] = value;\n}\n\nstatic void find_module_mention(map<perm_string,bool>&check_map, Module*m);\nstatic void find_module_mention(map<perm_string,bool>&check_map, PGenerate*s);\n\n/*\n * Convert a string to a time unit or precision.\n *\n * Returns true on failure.\n */\nstatic bool get_ts_const(const char*&cp, int&res, bool is_units)\n{\n\t/* Check for the 1 digit. */\n      if (*cp != '1') {\n\t    if (is_units) {\n\t\t  cerr << \"Error: Invalid +timescale units constant \"\n\t\t          \"(1st digit).\" << endl;\n\t    } else {\n\t\t  cerr << \"Error: Invalid +timescale precision constant \"\n\t\t          \"(1st digit).\" << endl;\n\t    }\n\t    return true;\n      }\n      cp += 1;\n\n\t/* Check the number of zeros after the 1. */\n      res = strspn(cp, \"0\");\n      if (res > 2) {\n\t    if (is_units) {\n\t\t  cerr << \"Error: Invalid +timescale units constant \"\n\t\t          \"(number of zeros).\" << endl;\n\t    } else {\n\t\t  cerr << \"Error: Invalid +timescale precision constant \"\n\t\t          \"(number of zeros).\" << endl;\n\t    }\n\t    return true;\n      }\n      cp += res;\n\n\t/* Now process the scaling string. */\n      if (strncmp(\"s\", cp, 1) == 0) {\n\t    res -= 0;\n\t    cp += 1;\n\t    return false;\n\n      } else if (strncmp(\"ms\", cp, 2) == 0) {\n\t    res -= 3;\n\t    cp += 2;\n\t    return false;\n\n      } else if (strncmp(\"us\", cp, 2) == 0) {\n\t    res -= 6;\n\t    cp += 2;\n\t    return false;\n\n      } else if (strncmp(\"ns\", cp, 2) == 0) {\n\t    res -= 9;\n\t    cp += 2;\n\t    return false;\n\n      } else if (strncmp(\"ps\", cp, 2) == 0) {\n\t    res -= 12;\n\t    cp += 2;\n\t    return false;\n\n      } else if (strncmp(\"fs\", cp, 2) == 0) {\n\t    res -= 15;\n\t    cp += 2;\n\t    return false;\n\n      }\n\n      if (is_units) {\n\t    cerr << \"Error: Invalid +timescale units scale.\" << endl;\n      } else {\n\t    cerr << \"Error: Invalid +timescale precision scale.\" << endl;\n      }\n      return true;\n}\n\n/*\n * Process a string with the following form (no space allowed):\n *\n *   num = < '1' | '10' | '100' >\n *   scale = < 's' | 'ms' | 'us' | 'ns' | 'ps' | 'fs' >\n *\n *   \"<num> <scale> '/' <num> <scale>\n *\n * and set the default time units and precision if successful.\n *\n * Return true if we have an error processing the timescale string.\n */\nstatic bool set_default_timescale(const char*ts_string)\n{\n\t/* Because this came from a command file we can not have embedded\n\t * space in this string. */\n      const char*cp = ts_string;\n      int units = 0;\n      int prec = 0;\n\n\t/* Get the time units. */\n      if (get_ts_const(cp, units, true)) return true;\n\n\t/* Skip the '/'. */\n      if (*cp != '/') {\n\t    cerr << \"Error: +timescale separator '/' is missing.\" << endl;\n\t    return true;\n      }\n      cp += 1;\n\n\t/* Get the time precision. */\n      if (get_ts_const(cp, prec, false)) return true;\n\n\t/* The time unit must be greater than or equal to the precision. */\n      if (units < prec) {\n\t    cerr << \"Error: +timescale unit must not be less than the \"\n\t            \"precision.\" << endl;\n\t    return true;\n      }\n\n\t/* We have valid units and precision so set the global defaults. */\n      def_ts_units = units;\n      def_ts_prec = prec;\n      return false;\n}\n\n/*\n * Read the contents of a config file. This file is a temporary\n * configuration file made by the compiler driver to carry the bulky\n * flags generated from the user. This reduces the size of the command\n * line needed to invoke ivl.\n *\n * Each line of the iconfig file has the format:\n *\n *      <keyword>:<value>\n *\n * The <value> is all the text after the ':' and up to but not\n * including the end of the line. Thus, white spaces and ':'\n * characters may appear here.\n *\n * The valid keys are:\n *\n *    -y:<dir>\n *    -yl:<dir>\n *    -Y:<string>\n *\n *    -T:<min/typ/max>\n *        Select which expression to use.\n *\n *    -t:<target>    (obsolete)\n *        Usually, \"-t:dll\"\n *\n *    basedir:<path>\n *        Location to look for installed sub-components\n *\n *    debug:<name>\n *        Activate a class of debug messages.\n *\n *    depfile:<path>\n *        Give the path to an output dependency file.\n *\n *    flag:<name>=<string>\n *        Generic compiler flag strings.\n *\n *    functor:<name>\n *        Append a named functor to the processing path.\n *\n *    generation:<1|2|2x|xtypes|no-xtypes|specify|no-specify>\n *        This is the generation flag\n *\n *    ivlpp:<preprocessor command>\n *        This specifies the ivlpp command line used to process\n *        library modules as I read them in.\n *\n *    iwidth:<bits>\n *        This specifies the width of integer variables. (that is,\n *        variables declared using the \"integer\" keyword.)\n *\n *    library_file:<path>\n *        This marks that a source file with the given path is a\n *        library. Any modules in that file are marked as library\n *        modules.\n *\n *    module:<name>\n *        Load a VPI module.\n *\n *    out:<path>\n *        Path to the output file.\n *\n *    sys_func:<path>\n *        Path to a system functions descriptor table\n *\n *    root:<name>\n *        Specify a root module. There may be multiple of this.\n *\n *    warnings:<string>\n *        Warning flag letters.\n *\n *    ignore_missing_modules:<bool>\n *        true to ignore errors about missing modules\n */\nbool had_timescale = false;\nstatic void read_iconfig_file(const char*ipath)\n{\n      char buf[8*1024];\n      vector<pair<char*,bool> > to_build_library_index;\n\n      FILE*ifile = fopen(ipath, \"r\");\n      if (ifile == 0) {\n\t    cerr << \"ERROR: Unable to read config file: \" << ipath << endl;\n\t    return;\n      }\n\n      while (fgets(buf, sizeof buf, ifile) != 0) {\n\t    assert(strlen(buf) < sizeof buf);\n\t    if ((strlen(buf) == ((sizeof buf) - 1))\n\t\t&& buf[sizeof buf -2] != '\\n') {\n\t\t  cerr << \"WARNING: Line buffer overflow reading iconfig file: \"\n\t\t       << ipath\n\t\t       << \".\" << endl;\n\t\t  assert(0);\n\t    }\n\t    if (buf[0] == '#')\n\t\t  continue;\n\t    char*cp = strchr(buf, ':');\n\t    if (cp == 0)\n\t\t  continue;\n\n\t    *cp++ = 0;\n\t    char*ep = cp + strlen(cp);\n\t    while (ep > cp) {\n\t\t  ep -= 1;\n\t\t  switch (*ep) {\n\t\t      case '\\r':\n\t\t      case '\\n':\n\t\t      case ' ':\n\t\t      case '\\t':\n\t\t\t*ep = 0;\n\t\t\tbreak;\n\t\t      default:\n\t\t\tep = cp;\n\t\t  }\n\t    }\n\n\t    if (strcmp(buf, \"basedir\") == 0) {\n\t\t  free((void *)basedir);\n\t\t  basedir = strdup(cp);\n\n\t    } else if (strcmp(buf, \"debug\") == 0) {\n\t\t  if (strcmp(cp, \"scopes\") == 0) {\n\t\t\tdebug_scopes = true;\n\t\t\tcerr << \"debug: Enable scopes debug\" << endl;\n\t\t  } else if (strcmp(cp,\"eval_tree\") == 0) {\n\t\t\tdebug_eval_tree = true;\n\t\t\tcerr << \"debug: Enable eval_tree debug\" << endl;\n\t\t  } else if (strcmp(cp,\"elaborate\") == 0) {\n\t\t\tdebug_elaborate = true;\n\t\t\tcerr << \"debug: Enable elaborate debug\" << endl;\n\t\t  } else if (strcmp(cp,\"emit\") == 0) {\n\t\t\tdebug_emit = true;\n\t\t\tcerr << \"debug: Enable emit debug\" << endl;\n\t\t  } else if (strcmp(cp,\"synth2\") == 0) {\n\t\t\tdebug_synth2 = true;\n\t\t\tcerr << \"debug: Enable synth2 debug\" << endl;\n\t\t  } else if (strcmp(cp,\"optimizer\") == 0) {\n\t\t\tdebug_optimizer = true;\n\t\t\tcerr << \"debug: Enable optimizer debug\" << endl;\n\t\t  } else {\n\t\t  }\n\n\t    } else if (strcmp(buf, \"depmode\") == 0) {\n\t\t  depfile_mode = *cp;\n\n\t    } else if (strcmp(buf, \"depfile\") == 0) {\n\t\t  depfile_name = strdup(cp);\n\n\t    } else if (strcmp(buf, \"flag\") == 0) {\n\t\t  string parm = cp;\n\t\t  parm_to_flagmap(parm);\n\n\t    } else if (strcmp(buf,\"functor\") == 0) {\n\t\tif (strncmp(cp, \"synth\", 5) == 0) {\n\t\t      synthesis = true;  // We are doing synthesis.\n\t\t}\n\t\tnet_func tmp = name_to_net_func(cp);\n\t\tif (tmp == 0) {\n\t\t      cerr << \"No such design transform function ``\"\n\t\t\t   << cp << \"''.\" << endl;\n\t\t      flag_errors += 1;\n\t\t      break;\n\t\t}\n\t\tnet_func_queue.push(tmp);\n\n\t    } else if (strcmp(buf, \"generation\") == 0) {\n\t\t  process_generation_flag(cp);\n\n\t    } else if (strcmp(buf, \"ivlpp\") == 0) {\n\t\t  ivlpp_string = strdup(cp);\n\n\t    } else if (strcmp(buf, \"iwidth\") == 0) {\n\t\t  integer_width = strtoul(cp,0,10);\n\n\t    } else if (strcmp(buf, \"widthcap\") == 0) {\n\t\t  width_cap = strtoul(cp,0,10);\n\n\t    } else if (strcmp(buf, \"library_file\") == 0) {\n\t\t  perm_string path = filename_strings.make(cp);\n\t\t  library_file_map[path] = true;\n\n\t    } else if (strcmp(buf,\"module\") == 0) {\n\t\t  add_vpi_module(cp);\n\n\t    } else if (strcmp(buf, \"out\") == 0) {\n\t\t  free((void *)flags[\"-o\"]);\n\t\t  flags[\"-o\"] = strdup(cp);\n\n\t    } else if (strcmp(buf, \"sys_func\") == 0) {\n\t\t  load_sys_func_table(cp);\n\n\t    } else if (strcmp(buf, \"root\") == 0) {\n\t\t  roots.push_back(lex_strings.make(cp));\n\n\t    } else if (strcmp(buf,\"warnings\") == 0) {\n\t\t    /* Scan the warnings enable string for warning flags. */\n\t\t  for ( ;  *cp ;  cp += 1) switch (*cp) {\n\t\t      case 'f':\n\t\t\twarn_floating_nets = true;\n\t\t\tbreak;\n\t\t      case 'i':\n\t\t\twarn_implicit = true;\n\t\t\tbreak;\n\t\t      case 'd':\n\t\t\twarn_implicit_dimensions = true;\n\t\t\tbreak;\n\t\t      case 'l':\n\t\t\twarn_inf_loop = true;\n\t\t\tbreak;\n\t\t      case 's':\n\t\t\twarn_ob_select = true;\n\t\t\tbreak;\n\t\t      case 'p':\n\t\t\twarn_portbinding = true;\n\t\t\tbreak;\n\t\t      case 't':\n\t\t\twarn_timescale = true;\n\t\t\tbreak;\n\t\t      case 'v':\n\t\t\twarn_sens_entire_vec = true;\n\t\t\tbreak;\n\t\t      case 'a':\n\t\t\twarn_sens_entire_arr = true;\n\t\t\tbreak;\n\t\t      case 'n':\n\t\t\twarn_anachronisms = true;\n\t\t\tbreak;\n\t\t      default:\n\t\t\tbreak;\n\t\t  }\n\n\t    } else if (strcmp(buf, \"ignore_missing_modules\") == 0) {\n\t\t  if (strcmp(cp, \"true\") == 0)\n\t\t    ignore_missing_modules = true;\n\n\t    } else if (strcmp(buf, \"-y\") == 0) {\n\t\t  to_build_library_index.push_back(make_pair(strdup(cp), CASE_SENSITIVE));\n\n\t    } else if (strcmp(buf, \"-yl\") == 0) {\n\t\t  to_build_library_index.push_back(make_pair(strdup(cp), false));\n\n\t    } else if (strcmp(buf, \"-Y\") == 0) {\n\t\t  library_suff.push_back(strdup(cp));\n\n\t    } else if (strcmp(buf,\"-t\") == 0) {\n\t\t    // NO LONGER USED\n\n\t    } else if (strcmp(buf,\"-T\") == 0) {\n\t\t  if (strcmp(cp,\"min\") == 0) {\n\t\t\tmin_typ_max_flag = MIN;\n\t\t\tmin_typ_max_warn = 0;\n\t\t  } else if (strcmp(cp,\"typ\") == 0) {\n\t\t\tmin_typ_max_flag = TYP;\n\t\t\tmin_typ_max_warn = 0;\n\t\t  } else if (strcmp(cp,\"max\") == 0) {\n\t\t\tmin_typ_max_flag = MAX;\n\t\t\tmin_typ_max_warn = 0;\n\t\t  } else {\n\t\t\tcerr << \"Invalid argument (\" << optarg << \") to -T flag.\"\n\t\t\t     << endl;\n\t\t\tflag_errors += 1;\n\t\t  }\n\t    } else if (strcmp(buf,\"defparam\") == 0) {\n\t\t  parm_to_defparam_list(cp);\n\t    } else if (strcmp(buf,\"timescale\") == 0) {\n\t\t  if (had_timescale) {\n\t\t\tcerr << \"Command File: Warning: default timescale \"\n\t\t\t        \"is being set multiple times.\" << endl;\n\t\t\tcerr << \"                     : using the last valid \"\n\t\t\t        \"+timescale found.\" << endl;\n\t\t  }\n\t\t  if (set_default_timescale(cp)) {\n\t\t\tcerr << \"     : with +timescale+\" << cp << \"+\" << endl;\n\t\t\tflag_errors += 1;\n\t\t  } else had_timescale = true;\n\t    }\n      }\n      fclose(ifile);\n      for (vector<pair<char *, bool> >::iterator it = to_build_library_index.begin() ;\n\t   it != to_build_library_index.end() ; ++ it ) {\n\t    build_library_index(it->first, it->second);\n\t    free(it->first);\n      }\n}\n\n/*\n * This function reads a list of source file names. Each name starts\n * with the first non-space character, and ends with the last non-space\n * character. Spaces in the middle are OK.\n */\nstatic void read_sources_file(const char*path)\n{\n      char line_buf[2048];\n\n      FILE*fd = fopen(path, \"r\");\n      if (fd == 0) {\n\t    cerr << \"ERROR: Unable to read source file list: \" << path << endl;\n\t    return;\n      }\n\n      while (fgets(line_buf, sizeof line_buf, fd) != 0) {\n\t      // assertion test that we are not overflowing the line\n\t      // buffer. Really should make this more robust, but\n\t      // better to assert then go weird.\n\t    assert(strlen(line_buf) < sizeof line_buf);\n\t    if ((strlen(line_buf) == ((sizeof line_buf) - 1))\n\t\t&& line_buf[sizeof line_buf -2] != '\\n') {\n\t\t  cerr << \"WARNING: Line buffer overflow reading sources file: \"\n\t\t       << path\n\t\t       << \".\" << endl;\n\t\t  assert(0);\n\t    }\n\t    char*cp = line_buf + strspn(line_buf, \" \\t\\r\\b\\f\");\n\t    char*tail = cp + strlen(cp);\n\t    while (tail > cp) {\n\t\t  if (! isspace((int)tail[-1]))\n\t\t\tbreak;\n\t\t  tail -= 1;\n\t\t  tail[0] = 0;\n\t    }\n\n\t    if (cp < tail)\n\t\t  source_files.push_back(filename_strings.make(cp));\n      }\n\n      fclose(fd);\n}\n\nextern Design* elaborate(list <perm_string> root);\n\n#if defined(HAVE_TIMES)\nstatic double cycles_diff(struct tms *a, struct tms *b)\n{\n      clock_t aa = a->tms_utime\n\t    +      a->tms_stime\n\t    +      a->tms_cutime\n\t    +      a->tms_cstime;\n\n      clock_t bb = b->tms_utime\n\t    +      b->tms_stime\n\t    +      b->tms_cutime\n\t    +      b->tms_cstime;\n\n      return (aa-bb)/(double)sysconf(_SC_CLK_TCK);\n}\n#else // ! defined(HAVE_TIMES)\n// Provide dummies\nstruct tms { int x; };\ninline static void times(struct tms *) { }\ninline static double cycles_diff(struct tms *, struct tms *) { return 0; }\n#endif // ! defined(HAVE_TIMES)\n\nstatic void EOC_cleanup(void)\n{\n      cleanup_sys_func_table();\n\n      for (list<const char*>::iterator suf = library_suff.begin() ;\n           suf != library_suff.end() ; ++ suf ) {\n\t    free((void *)*suf);\n      }\n      library_suff.clear();\n\n      free((void *) basedir);\n      free(ivlpp_string);\n      free(depfile_name);\n\n      for (map<string, const char*>::iterator flg = flags.begin() ;\n           flg != flags.end() ; ++ flg ) {\n\t    free((void *)flg->second);\n      }\n      flags.clear();\n\n      lex_strings.cleanup();\n      bits_strings.cleanup();\n      filename_strings.cleanup();\n}\n\nint main(int argc, char*argv[])\n{\n      bool help_flag = false;\n      bool times_flag = false;\n      bool version_flag = false;\n\n      const char* net_path = 0;\n      const char* pf_path = 0;\n      int opt;\n\n      struct tms cycles[5];\n\n#if defined(TRAP_SIGINT_FOR_DEBUG)\n      signal(SIGINT, &signals_handler);\n#endif\n      if( ::getenv(\"IVL_WAIT_FOR_DEBUGGER\") != 0 ) {\n          fprintf( stderr, \"Waiting for debugger...\\n\");\n          bool debugger_release = false;\n          while( !debugger_release )  {\n#if defined(__MINGW32__)\n              Sleep(1000);\n#else\n              sleep(1);\n#endif\n        }\n      }\n      library_suff.push_back(strdup(\".v\"));\n\n      flags[\"-o\"] = strdup(\"a.out\");\n      min_typ_max_flag = TYP;\n      min_typ_max_warn = 10;\n\n      while ((opt = getopt(argc, argv, \"C:F:f:hN:P:p:Vv\")) != EOF) switch (opt) {\n\n\t  case 'C':\n\t    read_iconfig_file(optarg);\n\t    break;\n\t  case 'F':\n\t    read_sources_file(optarg);\n\t    break;\n\t  case 'f':\n\t    parm_to_flagmap(optarg);\n\t    break;\n\t  case 'h':\n\t    help_flag = true;\n\t    break;\n\t  case 'N':\n\t    net_path = optarg;\n\t    break;\n\t  case 'P':\n\t    pf_path = optarg;\n\t    break;\n\t  case 'p':\n\t    parm_to_flagmap(optarg);\n\t    break;\n\t  case 'v':\n\t    verbose_flag = true;\n#          if defined(HAVE_TIMES)\n\t    times_flag = true;\n#          endif\n\t    flags[\"VVP_EXTRA_ARGS\"] = strdup(\" -v\");\n\t    break;\n\t  case 'V':\n\t    version_flag = true;\n\t    break;\n\t  default:\n\t    flag_errors += 1;\n\t    break;\n      }\n\n      if (flag_errors)\n\t    return flag_errors;\n\n      if (version_flag) {\n\t    cout << \"\\nIcarus Verilog Parser/Elaborator version \"\n\t\t << VERSION << \" (\" << VERSION_TAG << \")\" << endl << endl;\n\t    cout << COPYRIGHT << endl << endl;\n\t    cout << NOTICE << endl;\n\n\t    cout << \" FLAGS DLL \" << flags[\"DLL\"] << endl;\n\n\t    dll_target_obj.test_version(flags[\"DLL\"]);\n\n\t    return 0;\n      }\n\n      if (help_flag) {\n\t    cout << \"Icarus Verilog Parser/Elaborator version \"\n\t\t << VERSION << \" (\" << VERSION_TAG << \")\"  << endl <<\n\"usage: ivl <options> <file>\\n\"\n\"options:\\n\"\n\"\\t-C <name>        Config file from driver.\\n\"\n\"\\t-F <file>        List of source files from driver.\\n\"\n\"\\t-h               Print usage information, and exit.\\n\"\n\"\\t-N <file>        Dump the elaborated netlist to <file>.\\n\"\n\"\\t-P <file>        Write the parsed input to <file>.\\n\"\n\"\\t-p <assign>      Set a parameter value.\\n\"\n\"\\t-v               Print progress indications\"\n#if defined(HAVE_TIMES)\n                                           \" and execution times\"\n#endif\n                                           \".\\n\"\n\"\\t-V               Print version and copyright information, and exit.\\n\"\n\n\t\t  ;\n\t    return 0;\n      }\n\n      int arg = optind;\n      while (arg < argc) {\n\t    perm_string path = filename_strings.make(argv[arg++]);\n\t    source_files.push_back(path);\n      }\n\n      if (source_files.empty()) {\n\t    cerr << \"No input files.\" << endl;\n\t    return 1;\n      }\n\n      separate_compilation = source_files.size() > 1;\n\n      if( depfile_name ) {\n\t      depend_file = fopen(depfile_name, \"a\");\n\t      if(! depend_file) {\n\t\t      perror(depfile_name);\n\t      }\n      }\n\n      lexor_keyword_mask = 0;\n      switch (generation_flag) {\n        case GN_VER2012:\n\t  lexor_keyword_mask |= GN_KEYWORDS_1800_2012;\n\t  // fallthrough\n        case GN_VER2009:\n\t  lexor_keyword_mask |= GN_KEYWORDS_1800_2009;\n\t  // fallthrough\n        case GN_VER2005_SV:\n\t  lexor_keyword_mask |= GN_KEYWORDS_1800_2005;\n\t  // fallthrough\n        case GN_VER2005:\n\t  lexor_keyword_mask |= GN_KEYWORDS_1364_2005;\n\t  // fallthrough\n        case GN_VER2001:\n\t  lexor_keyword_mask |= GN_KEYWORDS_1364_2001_CONFIG;\n\t  // fallthrough\n        case GN_VER2001_NOCONFIG:\n\t  lexor_keyword_mask |= GN_KEYWORDS_1364_2001;\n\t  // fallthrough\n        case GN_VER1995:\n\t  lexor_keyword_mask |= GN_KEYWORDS_1364_1995;\n      }\n\n      if (gn_cadence_types_flag)\n\t    lexor_keyword_mask |= GN_KEYWORDS_ICARUS;\n\n      if (gn_verilog_ams_flag)\n\t    lexor_keyword_mask |= GN_KEYWORDS_VAMS_2_3;\n\n      if (verbose_flag) {\n\t    if (times_flag)\n\t\t  times(cycles+0);\n\n\t    cout << \"Using language generation: \";\n\t    switch (generation_flag) {\n\t\tcase GN_VER1995:\n\t\t  cout << \"IEEE1364-1995\";\n\t\t  break;\n\t\tcase GN_VER2001_NOCONFIG:\n\t\t  cout << \"IEEE1364-2001-noconfig\";\n\t\t  break;\n\t\tcase GN_VER2001:\n\t\t  cout << \"IEEE1364-2001\";\n\t\t  break;\n\t\tcase GN_VER2005:\n\t\t  cout << \"IEEE1364-2005\";\n\t\t  break;\n\t\tcase GN_VER2005_SV:\n\t\t  cout << \"IEEE1800-2005\";\n\t\t  break;\n\t\tcase GN_VER2009:\n\t\t  cout << \"IEEE1800-2009\";\n\t\t  break;\n\t\tcase GN_VER2012:\n\t\t  cout << \"IEEE1800-2012\";\n\t\t  break;\n\t    }\n\n\t    if (gn_verilog_ams_flag)\n\t\t  cout << \",verilog-ams\";\n\n\t    if (gn_specify_blocks_flag)\n\t\t  cout << \",specify\";\n\t    else\n\t\t  cout << \",no-specify\";\n\n\t    if (gn_interconnect_flag)\n\t\t  cout << \",interconnect\";\n\t    else\n\t\t  cout << \",no-interconnect\";\n\n\t    if (gn_cadence_types_flag)\n\t\t  cout << \",xtypes\";\n\t    else\n\t\t  cout << \",no-xtypes\";\n\n\t    if (gn_icarus_misc_flag)\n\t\t  cout << \",icarus-misc\";\n\t    else\n\t\t  cout << \",no-icarus-misc\";\n\n\t    cout << endl << \"PARSING INPUT\" << endl;\n      }\n\n      const char *flag_tmp = flags[\"DISABLE_VIRTUAL_PINS\"];\n      if (flag_tmp) disable_virtual_pins = strcmp(flag_tmp,\"true\")==0;\n\n      flag_tmp = flags[\"ARRAY_SIZE_LIMIT\"];\n      if (flag_tmp) array_size_limit = strtoul(flag_tmp,NULL,0);\n\n      flag_tmp = flags[\"RECURSIVE_MOD_LIMIT\"];\n      if (flag_tmp) recursive_mod_limit = strtoul(flag_tmp,NULL,0);\n\n      flag_tmp = flags[\"DISABLE_CONCATZ_GENERATION\"];\n      if (flag_tmp) disable_concatz_generation = strcmp(flag_tmp,\"true\")==0;\n\n\t/* Parse the input. Make the pform. */\n      int rc = 0;\n      for (unsigned idx = 0; idx < source_files.size(); idx += 1) {\n\t    rc += pform_parse(source_files[idx]);\n      }\n\n      pform_finish();\n\n      if (pf_path) {\n\t    ofstream out (pf_path);\n\t    out << \"PFORM DUMP NATURES:\" << endl;\n\t    for (map<perm_string,ivl_nature_t>::iterator cur = natures.begin()\n\t\t       ; cur != natures.end() ; ++ cur ) {\n\t\t  pform_dump(out, (*cur).second);\n\t    }\n\t    out << \"PFORM DUMP DISCIPLINES:\" << endl;\n\t    for (map<perm_string,ivl_discipline_t>::iterator cur = disciplines.begin()\n\t\t       ; cur != disciplines.end() ; ++ cur ) {\n\t\t  pform_dump(out, (*cur).second);\n\t    }\n\t    out << \"PFORM DUMP COMPILATION UNITS:\" << endl;\n\t    for (vector<PPackage*>::iterator pac = pform_units.begin()\n\t\t       ; pac != pform_units.end() ; ++ pac) {\n\t\t  pform_dump(out, *pac);\n\t    }\n\t    out << \"PFORM DUMP PACKAGES:\" << endl;\n\t    for (vector<PPackage*>::iterator pac = pform_packages.begin()\n\t\t       ; pac != pform_packages.end() ; ++ pac) {\n\t\t  pform_dump(out, *pac);\n\t    }\n\t    out << \"PFORM DUMP MODULES:\" << endl;\n\t    for (map<perm_string,Module*>::iterator mod = pform_modules.begin()\n\t\t       ; mod != pform_modules.end() ; ++ mod ) {\n\t\t  pform_dump(out, (*mod).second);\n\t    }\n\t    out << \"PFORM DUMP PRIMITIVES:\" << endl;\n\t    for (map<perm_string,PUdp*>::iterator idx = pform_primitives.begin()\n\t\t       ; idx != pform_primitives.end() ; ++ idx ) {\n\t\t  (*idx).second->dump(out);\n\t    }\n      }\n\n      if (rc) {\n\t    return rc;\n      }\n\n      if (pre_process_fail_count) {\n\t    cerr << \"Preprocessor failed with \" << pre_process_fail_count\n\t         << \" errors.\" << endl;\n\t    return pre_process_fail_count;\n      }\n\n\n\t/* If the user did not give specific module(s) to start with,\n\t   then look for modules that are not instantiated anywhere.  */\n\n      if (roots.empty()) {\n\t    map<perm_string,bool> mentioned_p;\n\t    map<perm_string,Module*>::iterator mod;\n\t    if (verbose_flag)\n\t\t  cout << \"LOCATING TOP-LEVEL MODULES\" << endl << \"  \";\n\t    for (mod = pform_modules.begin()\n\t\t       ; mod != pform_modules.end() ; ++ mod ) {\n\t\t  find_module_mention(mentioned_p, mod->second);\n\t    }\n\n\t    for (mod = pform_modules.begin()\n\t\t       ; mod != pform_modules.end() ; ++ mod ) {\n\n\t\t  if (!(*mod).second->can_be_toplevel())\n\t\t\tcontinue;\n\n\t\t    /* Don't choose modules instantiated in other\n\t\t       modules. */\n\t\t  if (mentioned_p[(*mod).second->mod_name()])\n\t\t\tcontinue;\n\n\t\t    /* What's left might as well be chosen as a root. */\n\t\t  if (verbose_flag)\n\t\t\tcout << \" \" << (*mod).second->mod_name();\n\t\t  roots.push_back((*mod).second->mod_name());\n\t    }\n\t    if (verbose_flag)\n\t\t  cout << endl;\n      }\n\n\t/* If there is *still* no guess for the root module, then give\n\t   up completely, and complain. */\n\n      if (roots.empty()) {\n\t    cerr << \"No top level modules, and no -s option.\" << endl;\n\t    return ignore_missing_modules ? 0 : 1;\n      }\n\n\n      if (verbose_flag) {\n\t    if (times_flag) {\n\t\t  times(cycles+1);\n\t\t  cerr<<\" ... done, \"\n\t\t      <<cycles_diff(cycles+1, cycles+0)<<\" seconds.\"<<endl;\n\t    }\n\t    cout << \"ELABORATING DESIGN\" << endl;\n      }\n\n\t/* Decide if we are going to allow system functions to be called\n\t * as tasks. */\n      if (gn_system_verilog()) {\n\t    def_sfunc_as_task = IVL_SFUNC_AS_TASK_WARNING;\n      }\n\n\t/* On with the process of elaborating the module. */\n      Design*des = elaborate(roots);\n\n      if ((des == 0) || (des->errors > 0)) {\n\t    if (des != 0) {\n\t\t  cerr << des->errors\n\t\t       << \" error(s) during elaboration.\" << endl;\n\t\t  if (net_path) {\n\t\t\tofstream out (net_path);\n\t\t\tdes->dump(out);\n\t\t  }\n\t    } else {\n\t\t  cerr << \"Elaboration failed\" << endl;\n\t    }\n\n\t    goto errors_summary;\n      }\n\n      des->set_flags(flags);\n\n      switch(min_typ_max_flag) {\n\tcase MIN:\n\t    des->set_delay_sel(Design::MIN);\n\t    break;\n\tcase TYP:\n\t    des->set_delay_sel(Design::TYP);\n\t    break;\n\tcase MAX:\n\t    des->set_delay_sel(Design::MAX);\n\t    break;\n\tdefault:\n\t    assert(0);\n      }\n\n\t/* Done with all the pform data. Delete the modules. */\n      for (map<perm_string,Module*>::iterator idx = pform_modules.begin()\n\t\t ; idx != pform_modules.end() ; ++ idx ) {\n\n\t    delete (*idx).second;\n\t    (*idx).second = 0;\n      }\n\n      if (verbose_flag) {\n\t    if (times_flag) {\n\t\t  times(cycles+2);\n\t\t  cerr<<\" ... done, \"\n\t\t      <<cycles_diff(cycles+2, cycles+1)<<\" seconds.\"<<endl;\n\t    }\n\t    cout << \"RUNNING FUNCTORS\" << endl;\n      }\n\n      while (!net_func_queue.empty()) {\n\t    net_func func = net_func_queue.front();\n\t    net_func_queue.pop();\n\t    if (verbose_flag)\n\t\t  cerr<<\" -F \"<<net_func_to_name(func)<< \" ...\" <<endl;\n\t    func(des);\n      }\n\n      if (verbose_flag) {\n\t    cout << \"CALCULATING ISLANDS\" << endl;\n      }\n      des->join_islands();\n\n      if (net_path) {\n\t    if (verbose_flag)\n\t\t  cerr<<\" dumping netlist to \" <<net_path<< \"...\" <<endl;\n\n\t    ofstream out (net_path);\n\t    des->dump(out);\n      }\n\n      if (des->errors) {\n\t    cerr << des->errors\n\t\t << \" error(s) in post-elaboration processing.\" <<\n\t\t  endl;\n\t    return des->errors;\n      }\n\n      if (verbose_flag) {\n\t    if (times_flag) {\n\t\t  times(cycles+3);\n\t\t  cerr<<\" ... done, \"\n\t\t      <<cycles_diff(cycles+3, cycles+2)<<\" seconds.\"<<endl;\n\t    }\n      }\n\n      if (verbose_flag) {\n\t    cout << \"CODE GENERATION\" << endl;\n      }\n\n      if (int emit_rc = des->emit(&dll_target_obj)) {\n\t    if (emit_rc > 0) {\n\t\t  cerr << \"error: Code generation had \"\n\t\t       << emit_rc << \" error(s).\"\n\t\t       << endl;\n\t\t  delete des;\n\t\t  EOC_cleanup();\n\t\t  return 1;\n\t    } else {\n\t\t  cerr << \"error: Code generator failure: \" << emit_rc << endl;\n\t\t  delete des;\n\t\t  EOC_cleanup();\n\t\t  return -1;\n\t    }\n\t    assert(emit_rc);\n      }\n\n      if (verbose_flag) {\n\t    if (times_flag) {\n\t\t  times(cycles+4);\n\t\t  cerr<<\" ... done, \"\n\t\t      <<cycles_diff(cycles+4, cycles+3)<<\" seconds.\"<<endl;\n\t    } else {\n\t\t  cout << \"DONE.\" << endl;\n\t    }\n      }\n\n      if (verbose_flag) {\n\t    cout << \"STATISTICS\" << endl;\n\t    cout << \"lex_string:\"\n\t\t << \" add_count=\" << lex_strings.add_count()\n\t\t << \" hit_count=\" << lex_strings.add_hit_count()\n\t\t << endl;\n      }\n\n      delete des;\n      EOC_cleanup();\n      return 0;\n\n errors_summary:\n      if (! missing_modules.empty()) {\n\t    cerr << \"*** These modules were missing:\" << endl;\n\n\t    map<perm_string,unsigned>::const_iterator idx;\n\t    for (idx = missing_modules.begin()\n\t\t       ; idx != missing_modules.end() ; ++ idx )\n\t\t  cerr << \"        \" << (*idx).first\n\t\t       << \" referenced \" << (*idx).second\n\t\t       << \" times.\"<< endl;\n\n\t    cerr << \"***\" << endl;\n      }\n\n      int rtn = des? des->errors : 1;\n      delete des;\n      EOC_cleanup();\n      return rtn;\n}\n\nstatic void find_module_mention(map<perm_string,bool>&check_map, Module*mod)\n{\n      list<PGate*> gates = mod->get_gates();\n      list<PGate*>::const_iterator gate;\n      for (gate = gates.begin(); gate != gates.end(); ++ gate ) {\n\t    PGModule*tmp = dynamic_cast<PGModule*>(*gate);\n\t    if (tmp) {\n\t\t    // Note that this module has been instantiated\n\t\t  check_map[tmp->get_type()] = true;\n\t    }\n      }\n\n      list<PGenerate*>::const_iterator cur;\n      for (cur = mod->generate_schemes.begin()\n\t\t ; cur != mod->generate_schemes.end() ; ++ cur ) {\n\t    find_module_mention(check_map, *cur);\n      }\n}\n\nstatic void find_module_mention(map<perm_string,bool>&check_map, PGenerate*schm)\n{\n      list<PGate*>::const_iterator gate;\n      for (gate = schm->gates.begin(); gate != schm->gates.end(); ++ gate ) {\n\t    PGModule*tmp = dynamic_cast<PGModule*>(*gate);\n\t    if (tmp) {\n\t\t    // Note that this module has been instantiated\n\t\t  check_map[tmp->get_type()] = true;\n\t    }\n      }\n\n      list<PGenerate*>::const_iterator cur;\n      for (cur = schm->generate_schemes.begin()\n\t\t ; cur != schm->generate_schemes.end() ; ++ cur ) {\n\t    find_module_mention(check_map, *cur);\n      }\n}\n\nvoid pre_process_failed(const char*text)\n{\n      const char*num_start = strchr(text, '(') + 1;\n      unsigned long res;\n      char*rem;\n      res = strtoul(num_start, &rem, 10);\n      assert(res > 0);\n      assert(rem[0] == ')');\n      pre_process_fail_count += res;\n}\n"
        },
        {
          "name": "map_named_args.cc",
          "type": "blob",
          "size": 1.8115234375,
          "content": "// SPDX-FileCopyrightText: 2023 Lars-Peter Clausen <lars@metafoo.de>\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"PExpr.h\"\n#include \"ivl_assert.h\"\n#include \"map_named_args.h\"\n#include \"netlist.h\"\n\n#include <iostream>\n\nstd::vector<PExpr*> map_named_args(Design *des,\n\t\t\t           const std::vector<perm_string> &names,\n\t\t\t           const std::vector<named_pexpr_t> &parms)\n{\n      std::vector<PExpr*> args(names.size());\n\n      bool has_named = false;\n      for (size_t i = 0; i < parms.size(); i++) {\n\t    if (parms[i].name.nil()) {\n\t\t  if (!parms[i].parm)\n\t\t\tcontinue;\n\n\t\t  if (has_named) {\n\t\t      std::cerr << parms[i].get_fileline() << \": error: \"\n\t\t           << \"Positional argument must preceded \"\n\t\t\t   << \"named arguments.\"\n\t\t\t   << std::endl;\n\t\t  } else if (i < args.size()) {\n\t\t\targs[i] = parms[i].parm;\n\t\t  }\n\n\t\t  continue;\n\t    }\n\t    has_named = true;\n\n\t    bool found = false;\n\t    for (size_t j = 0; j < names.size(); j++) {\n\t\t  if (names[j] == parms[i].name) {\n\t\t\tif (args[j]) {\n\t\t\t      std::cerr << parms[i].get_fileline() << \": error: \"\n\t\t\t           << \"Argument `\"\n\t\t\t\t   << parms[i].name\n\t\t\t\t   << \"` has already been specified.\"\n\t\t\t\t   << std::endl;\n\t\t\t      des->errors++;\n\t\t\t} else {\n\t\t\t      args[j] = parms[i].parm;\n\t\t\t}\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t  }\n\t    }\n\t    if (!found) {\n\t\t  std::cerr << parms[i].get_fileline() << \": error: \"\n\t\t       << \"No argument called `\"\n\t\t       << parms[i].name << \"`.\"\n\t\t       << std::endl;\n\t\t  des->errors++;\n\t    }\n      }\n\n      return args;\n}\n\nstd::vector<PExpr*> map_named_args(Design *des, NetBaseDef *def,\n\t\t\t\t   const std::vector<named_pexpr_t> &parms,\n\t\t\t\t   unsigned int off)\n{\n      std::vector<perm_string> names;\n\n      for (size_t j = off; j < def->port_count(); j++)\n\t    names.push_back(def->port(j)->name());\n\n      return map_named_args(des, names, parms);\n}\n"
        },
        {
          "name": "map_named_args.h",
          "type": "blob",
          "size": 0.5546875,
          "content": "// SPDX-FileCopyrightText: 2023 Lars-Peter Clausen <lars@metafoo.de>\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#ifndef MAP_NAMED_ARGS_H\n#define MAP_NAMED_ARGS_H\n\n#include <vector>\n#include \"pform_types.h\"\n\nclass PExpr;\nclass Design;\nclass NetBaseDef;\n\nstd::vector<PExpr*> map_named_args(Design *des,\n\t\t\t           const std::vector<perm_string> &names,\n\t\t\t           const std::vector<named_pexpr_t> &parms);\n\nstd::vector<PExpr*> map_named_args(Design *des, NetBaseDef *def,\n\t\t\t           const std::vector<named_pexpr_t> &parms,\n\t\t\t\t   unsigned int off);\n\n#endif\n"
        },
        {
          "name": "mkinstalldirs",
          "type": "blob",
          "size": 3.4130859375,
          "content": "#! /bin/sh\n# mkinstalldirs --- make directory hierarchy\n\nscriptversion=2006-05-11.19\n\n# Original author: Noah Friedman <friedman@prep.ai.mit.edu>\n# Created: 1993-05-16\n# Public domain.\n#\n# This file is maintained in Automake, please report\n# bugs to <bug-automake@gnu.org> or send patches to\n# <automake-patches@gnu.org>.\n\nnl='\n'\nIFS=\" \"\"\t$nl\"\nerrstatus=0\ndirmode=\n\nusage=\"\\\nUsage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...\n\nCreate each directory DIR (with mode MODE, if specified), including all\nleading file name components.\n\nReport bugs to <bug-automake@gnu.org>.\"\n\n# process command line arguments\nwhile test $# -gt 0 ; do\n  case $1 in\n    -h | --help | --h*)         # -h for help\n      echo \"$usage\"\n      exit $?\n      ;;\n    -m)                         # -m PERM arg\n      shift\n      test $# -eq 0 && { echo \"$usage\" 1>&2; exit 1; }\n      dirmode=$1\n      shift\n      ;;\n    --version)\n      echo \"$0 $scriptversion\"\n      exit $?\n      ;;\n    --)                         # stop option processing\n      shift\n      break\n      ;;\n    -*)                         # unknown option\n      echo \"$usage\" 1>&2\n      exit 1\n      ;;\n    *)                          # first non-opt arg\n      break\n      ;;\n  esac\ndone\n\nfor file\ndo\n  if test -d \"$file\"; then\n    shift\n  else\n    break\n  fi\ndone\n\ncase $# in\n  0) exit 0 ;;\nesac\n\n# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and\n# mkdir -p a/c at the same time, both will detect that a is missing,\n# one will create a, then the other will try to create a and die with\n# a \"File exists\" error.  This is a problem when calling mkinstalldirs\n# from a parallel make.  We use --version in the probe to restrict\n# ourselves to GNU mkdir, which is thread-safe.\ncase $dirmode in\n  '')\n    if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then\n      echo \"mkdir -p -- $*\"\n      exec mkdir -p -- \"$@\"\n    else\n      # On NextStep and OpenStep, the `mkdir' command does not\n      # recognize any option.  It will interpret all options as\n      # directories to create, and then abort because `.' already\n      # exists.\n      test -d ./-p && rmdir ./-p\n      test -d ./--version && rmdir ./--version\n    fi\n    ;;\n  *)\n    if mkdir -m \"$dirmode\" -p --version . >/dev/null 2>&1 &&\n       test ! -d ./--version; then\n      echo \"mkdir -m $dirmode -p -- $*\"\n      exec mkdir -m \"$dirmode\" -p -- \"$@\"\n    else\n      # Clean up after NextStep and OpenStep mkdir.\n      for d in ./-m ./-p ./--version \"./$dirmode\";\n      do\n        test -d $d && rmdir $d\n      done\n    fi\n    ;;\nesac\n\nfor file\ndo\n  case $file in\n    /*) pathcomp=/ ;;\n    *)  pathcomp= ;;\n  esac\n  oIFS=$IFS\n  IFS=/\n  set fnord $file\n  shift\n  IFS=$oIFS\n\n  for d\n  do\n    test \"x$d\" = x && continue\n\n    pathcomp=$pathcomp$d\n    case $pathcomp in\n      -*) pathcomp=./$pathcomp ;;\n    esac\n\n    if test ! -d \"$pathcomp\"; then\n      echo \"mkdir $pathcomp\"\n\n      mkdir \"$pathcomp\" || lasterr=$?\n\n      if test ! -d \"$pathcomp\"; then\n\terrstatus=$lasterr\n      else\n\tif test ! -z \"$dirmode\"; then\n\t  echo \"chmod $dirmode $pathcomp\"\n\t  lasterr=\n\t  chmod \"$dirmode\" \"$pathcomp\" || lasterr=$?\n\n\t  if test ! -z \"$lasterr\"; then\n\t    errstatus=$lasterr\n\t  fi\n\tfi\n      fi\n    fi\n\n    pathcomp=$pathcomp/\n  done\ndone\n\nexit $errstatus\n\n# Local Variables:\n# mode: shell-script\n# sh-indentation: 2\n# eval: (add-hook 'write-file-hooks 'time-stamp)\n# time-stamp-start: \"scriptversion=\"\n# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n# time-stamp-end: \"$\"\n# End:\n"
        },
        {
          "name": "msys2",
          "type": "tree",
          "content": null
        },
        {
          "name": "named.h",
          "type": "blob",
          "size": 1.1611328125,
          "content": "#ifndef IVL_named_H\n#define IVL_named_H\n/*\n * Copyright (c) 2000-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"StringHeap.h\"\n# include  \"libmisc/LineInfo.h\"\n\n/*\n * There are lots of places where names are attached to objects. This\n * simple template expresses the lot.\n */\n\ntemplate <class T> struct named : public LineInfo {\n      perm_string name;\n      T parm;\n};\n\n#endif /* IVL_named_H */\n"
        },
        {
          "name": "net_analog.cc",
          "type": "blob",
          "size": 1.26953125,
          "content": "/*\n * Copyright (c) 2008 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <typeinfo>\n# include  <cstdlib>\n# include  <climits>\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"ivl_assert.h\"\n\nNetContribution::NetContribution(NetEAccess*l, NetExpr*r)\n: lval_(l), rval_(r)\n{\n}\n\nNetContribution::~NetContribution()\n{\n}\n\nconst NetEAccess* NetContribution::lval() const\n{\n      return lval_;\n}\n\nconst NetExpr* NetContribution::rval() const\n{\n      return rval_;\n}\n"
        },
        {
          "name": "net_assign.cc",
          "type": "blob",
          "size": 7.2333984375,
          "content": "/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"netlist.h\"\n# include  \"netclass.h\"\n# include  \"netdarray.h\"\n# include  \"netparray.h\"\n# include  \"netenum.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * NetAssign\n */\n\nunsigned count_lval_width(const NetAssign_*idx)\n{\n      unsigned wid = 0;\n      while (idx) {\n\t    wid += idx->lwidth();\n\t    idx = idx->more;\n      }\n      return wid;\n}\n\nNetAssign_::NetAssign_(NetAssign_*n)\n: nest_(n), sig_(0), word_(0), base_(0), sel_type_(IVL_SEL_OTHER)\n{\n      lwid_ = 0;\n      more = 0;\n      signed_ = false;\n      turn_sig_to_wire_on_release_ = false;\n}\n\nNetAssign_::NetAssign_(NetNet*s)\n: nest_(0), sig_(s), word_(0), base_(0), sel_type_(IVL_SEL_OTHER)\n{\n      lwid_ = sig_->vector_width();\n      sig_->incr_lref();\n      more = 0;\n      signed_ = false;\n      turn_sig_to_wire_on_release_ = false;\n}\n\nNetAssign_::~NetAssign_()\n{\n      if (sig_) {\n\t    sig_->decr_lref();\n\t    if (turn_sig_to_wire_on_release_ && sig_->peek_lref() == 0)\n\t\t  sig_->type(NetNet::WIRE);\n      }\n\n      ivl_assert(*this, more == 0 );\n      delete word_;\n}\n\nstring NetAssign_::get_fileline() const\n{\n      if (sig_) return sig_->get_fileline();\n      else return nest_->get_fileline();\n}\n\nNetScope*NetAssign_::scope() const\n{\n      if (sig_) return sig_->scope();\n      else return nest_->scope();\n}\n\nvoid NetAssign_::set_word(NetExpr*r)\n{\n      ivl_assert(*this, word_ == 0);\n      word_ = r;\n}\n\nNetExpr* NetAssign_::word()\n{\n      return word_;\n}\n\nconst NetExpr* NetAssign_::word() const\n{\n      return word_;\n}\n\nconst NetExpr* NetAssign_::get_base() const\n{\n      return base_;\n}\n\nivl_select_type_t NetAssign_::select_type() const\n{\n      return sel_type_;\n}\n\nunsigned NetAssign_::lwidth() const\n{\n\t// This gets me the type of the l-value expression, down to\n\t// the type of the member. If this returns nil, then resort to\n\t// the lwid_ value.\n      ivl_type_t ntype = net_type();\n      if (ntype)\n\t    return ntype->packed_width();\n\n      return lwid_;\n}\n\nivl_variable_type_t NetAssign_::expr_type() const\n{\n      ivl_type_t ntype = net_type();\n      if (ntype)\n\t    return ntype->base_type();\n\n      ivl_assert(*this, sig_);\n      return sig_->data_type();\n}\n\nivl_type_t NetAssign_::net_type() const\n{\n\t// This is a concatenation, it does not have a type\n      if (more)\n\t    return nullptr;\n\n       // Selected sub-vector can have its own data type\n      if (base_)\n\t    return part_data_type_;\n\n      ivl_type_t ntype;\n      if (nest_) {\n\t    ntype = nest_->net_type();\n      } else {\n\t    ivl_assert(*this, sig_);\n\n\t    if (sig_->unpacked_dimensions() && !word_)\n\t\t  ntype = sig_->array_type();\n\t    else\n\t\t  ntype = sig_->net_type();\n      }\n\n      if (!member_.nil()) {\n\t    const netclass_t *class_type = dynamic_cast<const netclass_t*>(ntype);\n\t    ivl_assert(*this, class_type);\n\t    ntype = class_type->get_prop_type(member_idx_);\n      }\n\n      if (word_) {\n\t    if (const netdarray_t *darray = dynamic_cast<const netdarray_t*>(ntype))\n\t\t  ntype = darray->element_type();\n\t    else if (const netuarray_t *uarray = dynamic_cast<const netuarray_t*>(ntype))\n\t\t  ntype = uarray->element_type();\n      }\n\n      return ntype;\n}\n\nperm_string NetAssign_::name() const\n{\n      if (sig_) {\n\t    return sig_->name();\n      } else {\n\t    return perm_string::literal(\"\");\n      }\n}\n\nNetNet* NetAssign_::sig() const\n{\n      ivl_assert(*this, sig_ ? nest_ == 0 : nest_ != 0);\n      return sig_;\n}\n\nvoid NetAssign_::set_part(NetExpr*base, unsigned wid,\n                          ivl_select_type_t sel_type)\n{\n      base_ = base;\n      lwid_ = wid;\n      sel_type_ = sel_type;\n}\n\nvoid NetAssign_::set_part(NetExpr*base, ivl_type_t data_type)\n{\n      part_data_type_ = data_type;\n      set_part(base, part_data_type_->packed_width());\n}\n\nvoid NetAssign_::set_property(const perm_string&mname, unsigned idx)\n{\n      member_ = mname;\n      member_idx_ = idx;\n}\n\n/*\n */\nvoid NetAssign_::turn_sig_to_wire_on_release()\n{\n      turn_sig_to_wire_on_release_ = true;\n}\n\nNetAssignBase::NetAssignBase(NetAssign_*lv, NetExpr*rv)\n: lval_(lv), rval_(rv), delay_(0)\n{\n}\n\nNetAssignBase::~NetAssignBase()\n{\n      delete rval_;\n      while (lval_) {\n\t    NetAssign_*tmp = lval_;\n\t    lval_ = tmp->more;\n\t    tmp->more = 0;\n\t    delete tmp;\n      }\n}\n\nNetExpr* NetAssignBase::rval()\n{\n      return rval_;\n}\n\nconst NetExpr* NetAssignBase::rval() const\n{\n      return rval_;\n}\n\nvoid NetAssignBase::set_rval(NetExpr*r)\n{\n      delete rval_;\n      rval_ = r;\n}\n\nNetAssign_* NetAssignBase::l_val(unsigned idx)\n{\n      NetAssign_*cur = lval_;\n      while (idx > 0) {\n\t    if (cur == 0)\n\t\t  return cur;\n\n\t    cur = cur->more;\n\t    idx -= 1;\n      }\n\n      ivl_assert(*this, idx == 0);\n      return cur;\n}\n\nconst NetAssign_* NetAssignBase::l_val(unsigned idx) const\n{\n      const NetAssign_*cur = lval_;\n      while (idx > 0) {\n\t    if (cur == 0)\n\t\t  return cur;\n\n\t    cur = cur->more;\n\t    idx -= 1;\n      }\n\n      ivl_assert(*this, idx == 0);\n      return cur;\n}\n\nunsigned NetAssignBase::l_val_count() const\n{\n      const NetAssign_*cur = lval_;\n      unsigned cnt = 0;\n      while (cur) {\n\t    cnt += 1;\n\t    cur = cur->more;\n      }\n\n      return cnt;\n}\n\nunsigned NetAssignBase::lwidth() const\n{\n      unsigned sum = 0;\n      for (NetAssign_*cur = lval_ ;  cur ;  cur = cur->more)\n\t    sum += cur->lwidth();\n      return sum;\n}\n\nvoid NetAssignBase::set_delay(NetExpr*expr)\n{\n      delay_ = expr;\n}\n\nconst NetExpr* NetAssignBase::get_delay() const\n{\n      return delay_;\n}\n\nNetAssign::NetAssign(NetAssign_*lv, NetExpr*rv)\n: NetAssignBase(lv, rv), op_(0)\n{\n}\n\nNetAssign::NetAssign(NetAssign_*lv, char op, NetExpr*rv)\n: NetAssignBase(lv, rv), op_(op)\n{\n}\n\nNetAssign::~NetAssign()\n{\n}\n\nNetAssignNB::NetAssignNB(NetAssign_*lv, NetExpr*rv, NetEvWait*ev, NetExpr*cnt)\n: NetAssignBase(lv, rv)\n{\n      event_ = ev;\n      count_ = cnt;\n}\n\nNetAssignNB::~NetAssignNB()\n{\n}\n\nunsigned NetAssignNB::nevents() const\n{\n      if (event_) return event_->nevents();\n      return 0;\n}\n\nconst NetEvent*NetAssignNB::event(unsigned idx) const\n{\n      if (event_) return event_->event(idx);\n      return 0;\n}\n\nconst NetExpr*NetAssignNB::get_count() const\n{\n      return count_;\n}\n\nNetCAssign::NetCAssign(NetAssign_*lv, NetExpr*rv)\n: NetAssignBase(lv, rv)\n{\n}\n\nNetCAssign::~NetCAssign()\n{\n}\n\nNetDeassign::NetDeassign(NetAssign_*l)\n: NetAssignBase(l, 0)\n{\n}\n\nNetDeassign::~NetDeassign()\n{\n}\n\nNetForce::NetForce(NetAssign_*lv, NetExpr*rv)\n: NetAssignBase(lv, rv)\n{\n}\n\nNetForce::~NetForce()\n{\n}\n\nNetRelease::NetRelease(NetAssign_*l)\n: NetAssignBase(l, 0)\n{\n}\n\nNetRelease::~NetRelease()\n{\n}\n"
        },
        {
          "name": "net_design.cc",
          "type": "blob",
          "size": 32.6572265625,
          "content": "/*\n * Copyright (c) 2000-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n# include  <set>\n# include  <cstdlib>\n\n/*\n * This source file contains all the implementations of the Design\n * class declared in netlist.h.\n */\n\n# include  \"netlist.h\"\n# include  \"netscalar.h\"\n# include  \"netvector.h\"\n# include  \"util.h\"\n# include  \"compiler.h\"\n# include  \"netmisc.h\"\n# include  \"PExpr.h\"\n# include  \"PTask.h\"\n# include  <sstream>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nDesign:: Design()\n    : errors(0), nodes_(0), procs_(0), aprocs_(0)\n{\n      branches_ = 0;\n      procs_idx_ = 0;\n      des_precision_ = 0;\n      nodes_functor_cur_ = 0;\n      nodes_functor_nxt_ = 0;\n      des_delay_sel_ = Design::TYP;\n}\n\nDesign::~Design()\n{\n}\n\nvoid Design::set_precision(int val)\n{\n      if (val < des_precision_)\n\t    des_precision_ = val;\n}\n\nint Design::get_precision() const\n{\n      return des_precision_;\n}\n\nvoid Design::set_delay_sel(delay_sel_t sel)\n{\n      des_delay_sel_ = sel;\n}\n\nconst char* Design::get_delay_sel() const\n{\n      switch (des_delay_sel_) {\n\tcase Design::MIN:\n\t    return \"MINIMUM\";\n\t    break;\n\tcase Design::TYP:\n\t    return \"TYPICAL\";\n\t    break;\n\tcase Design::MAX:\n\t    return \"MAXIMUM\";\n\t    break;\n\tdefault:\n\t    assert(0);\n\t    return \"TYPICAL\";\n      }\n}\n\n\nuint64_t Design::scale_to_precision(uint64_t val,\n\t\t\t\t    const NetScope*scope) const\n{\n      int units = scope->time_unit();\n      assert( units >= des_precision_ );\n\n      while (units > des_precision_) {\n\t    units -= 1;\n\t    val *= 10;\n      }\n\n      return val;\n}\n\nNetScope* Design::make_root_scope(perm_string root, NetScope*unit_scope,\n\t\t\t\t  bool program_block, bool is_interface)\n{\n      NetScope *root_scope_;\n      root_scope_ = new NetScope(0, hname_t(root), NetScope::MODULE, unit_scope,\n\t\t\t\t false, program_block, is_interface);\n\t/* This relies on the fact that the basename return value is\n\t   permallocated. */\n      root_scope_->set_module_name(root_scope_->basename());\n      root_scopes_.push_back(root_scope_);\n      return root_scope_;\n}\n\nNetScope* Design::find_root_scope()\n{\n      assert(root_scopes_.front());\n      return root_scopes_.front();\n}\n\nlist<NetScope*> Design::find_root_scopes() const\n{\n      return root_scopes_;\n}\n\nNetScope* Design::make_package_scope(perm_string name, NetScope*unit_scope,\n\t\t\t\t     bool is_unit)\n{\n      NetScope*scope;\n\n      scope = new NetScope(0, hname_t(name), NetScope::PACKAGE, unit_scope,\n\t\t\t   false, false, false, is_unit);\n      scope->set_module_name(scope->basename());\n      packages_[name] = scope;\n      return scope;\n}\n\nNetScope* Design::find_package(perm_string name) const\n{\n      map<perm_string,NetScope*>::const_iterator cur = packages_.find(name);\n      if (cur == packages_.end())\n\t    return 0;\n\n      return cur->second;\n}\n\nlist<NetScope*> Design::find_package_scopes() const\n{\n      list<NetScope*>res;\n      for (map<perm_string,NetScope*>::const_iterator cur = packages_.begin()\n\t\t ; cur != packages_.end() ; ++cur) {\n\t    res.push_back (cur->second);\n      }\n\n      return res;\n}\n\n/*\n * This method locates a scope in the design, given its rooted\n * hierarchical name. Each component of the key is used to scan one\n * more step down the tree until the name runs out or the search\n * fails.\n */\nNetScope* Design::find_scope(const std::list<hname_t>&path) const\n{\n      if (path.empty())\n\t    return 0;\n\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin()\n\t\t ; scope != root_scopes_.end(); ++ scope ) {\n\n\t    NetScope*cur = *scope;\n\t    if (path.front() != cur->fullname())\n\t\t  continue;\n\n\t    std::list<hname_t> tmp = path;\n\t    tmp.pop_front();\n\n\t    while (cur) {\n\t\t  if (tmp.empty()) return cur;\n\n\t\t  cur = cur->child( tmp.front() );\n\n\t\t  tmp.pop_front();\n\t    }\n      }\n\n      return 0;\n}\n\n/*\n * This method locates a scope in the design, given its rooted\n * hierarchical name. Each component of the key is used to scan one\n * more step down the tree until the name runs out or the search\n * fails.\n */\nNetScope* Design::find_scope(const hname_t&path) const\n{\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin()\n\t\t ; scope != root_scopes_.end(); ++ scope ) {\n\n\t    NetScope*cur = *scope;\n\t    if (path.peek_name() == cur->basename())\n\t\t  return cur;\n\n      }\n\n      return 0;\n}\n\nstatic bool is_design_unit(NetScope*scope)\n{\n      return (scope->type() == NetScope::MODULE && !scope->nested_module())\n\t  || (scope->type() == NetScope::PACKAGE);\n}\n\nstatic bool is_subroutine(NetScope::TYPE type)\n{\n      return type == NetScope::TASK || type == NetScope::FUNC;\n}\n\n/*\n * This method locates a scope within another scope, given its relative\n * hierarchical name. Each component of the key is used to scan one\n * more step down the tree until the name runs out or the search\n * fails.\n */\nNetScope* Design::find_scope_(NetScope*scope, const std::list<hname_t>&path,\n                              NetScope::TYPE type) const\n{\n      std::list<hname_t> tmp = path;\n\n      do {\n\t    hname_t key = tmp.front();\n\t      /* If we are looking for a module or we are not\n\t       * looking at the last path component check for\n\t       * a name match (second line). */\n\t    if (scope->type() == NetScope::MODULE\n\t\t&& (type == NetScope::MODULE || tmp.size() > 1)\n\t\t&& scope->module_name()==key.peek_name()) {\n\n\t\t    /* Up references may match module name */\n\n\t    } else {\n\t\t  NetScope*found_scope = scope->child(key);\n\t\t  if (found_scope == 0) {\n\t\t\tfound_scope = scope->find_import(this, key.peek_name());\n\t\t\tif (found_scope)\n\t\t\t      found_scope = found_scope->child(key);\n\t\t  }\n\t\t  scope = found_scope;\n\t\t  if (scope == 0) break;\n\t    }\n\t    tmp.pop_front();\n      } while (! tmp.empty());\n\n      return scope;\n}\n\n/*\n * This is a relative lookup of a scope by name. The starting point is\n * the scope parameter within which I start looking for the scope. If\n * I do not find the scope within the passed scope, start looking in\n * parent scopes until I find it, or I run out of parent scopes.\n */\nNetScope* Design::find_scope(NetScope*scope, const std::list<hname_t>&path,\n                             NetScope::TYPE type) const\n{\n      assert(scope);\n      if (path.empty())\n\t    return scope;\n\n\t// Record the compilation unit scope for use later.\n      NetScope*unit_scope = scope->unit();\n\n\t// First search upwards through the hierarchy.\n      while (scope) {\n\t    NetScope*found_scope = find_scope_(scope, path, type);\n\t    if (found_scope)\n\t\t  return found_scope;\n\n\t      // Avoid searching the unit scope twice.\n\t    if (scope == unit_scope)\n\t\t  unit_scope = 0;\n\n\t      // Special case - see IEEE 1800-2012 section 23.8.1.\n\t    if (unit_scope && is_design_unit(scope) && is_subroutine(type)) {\n\t\t  found_scope = find_scope_(unit_scope, path, type);\n\t\t  if (found_scope)\n\t\t\t  return found_scope;\n\n\t\t  unit_scope = 0;\n\t    }\n\n\t    scope = scope->parent();\n      }\n\n\t// If we haven't already done so, search the compilation unit scope.\n      if (unit_scope) {\n\t    NetScope*found_scope = find_scope_(unit_scope, path, type);\n\t    if (found_scope)\n\t\t  return found_scope;\n      }\n\n\t// Last chance. Look for the name starting at the root.\n      return find_scope(path);\n}\n\n/*\n * This method locates a scope within another scope, given its relative\n * hierarchical name. Each component of the key is used to scan one\n * more step down the tree until the name runs out or the search\n * fails.\n */\nNetScope* Design::find_scope_(NetScope*scope, const hname_t&path,\n                              NetScope::TYPE type) const\n{\n\t/* If we are looking for a module or we are not\n\t * looking at the last path component check for\n\t * a name match (second line). */\n      if ((scope->type() == NetScope::MODULE) && (type == NetScope::MODULE)\n\t  && (scope->module_name() == path.peek_name())) {\n\t      /* Up references may match module name */\n\t    return scope;\n      }\n      NetScope*found_scope = scope->child(path);\n      if (found_scope == 0) {\n\t    found_scope = scope->find_import(this, path.peek_name());\n\t    if (found_scope)\n\t\t  found_scope = found_scope->child(path);\n      }\n      return found_scope;\n}\n\n/*\n * This is a relative lookup of a scope by name. The starting point is\n * the scope parameter within which I start looking for the scope. If\n * I do not find the scope within the passed scope, start looking in\n * parent scopes until I find it, or I run out of parent scopes.\n */\nNetScope* Design::find_scope(NetScope*scope, const hname_t&path,\n                             NetScope::TYPE type) const\n{\n      assert(scope);\n\n\t// Record the compilation unit scope for use later.\n      NetScope*unit_scope = scope->unit();\n\n\t// First search upwards through the hierarchy.\n      while (scope) {\n\t    NetScope*found_scope = find_scope_(scope, path, type);\n\t    if (found_scope)\n\t\t  return found_scope;\n\n\t      // Avoid searching the unit scope twice.\n\t    if (scope == unit_scope)\n\t\t  unit_scope = 0;\n\n\t      // Special case - see IEEE 1800-2012 section 23.8.1.\n\t    if (unit_scope && is_design_unit(scope) && is_subroutine(type)) {\n\t\t  found_scope = find_scope_(unit_scope, path, type);\n\t\t  if (found_scope)\n\t\t\t  return found_scope;\n\n\t\t  unit_scope = 0;\n\t    }\n\n\t    scope = scope->parent();\n      }\n\n\t// If we haven't already done so, search the compilation unit scope.\n      if (unit_scope) {\n\t    NetScope*found_scope = find_scope_(unit_scope, path, type);\n\t    if (found_scope)\n\t\t  return found_scope;\n      }\n\n\t// Last chance. Look for the name starting at the root.\n      list<hname_t>path_list;\n      path_list.push_back(path);\n      return find_scope(path_list);\n}\n\n/*\n * This method runs through the scope, noticing the defparam\n * statements that were collected during the elaborate_scope pass and\n * applying them to the target parameters. The implementation actually\n * works by using a specialized method from the NetScope class that\n * does all the work for me.\n */\nvoid Design::run_defparams()\n{\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin();\n\t   scope != root_scopes_.end(); ++ scope )\n\t    (*scope)->run_defparams(this);\n}\n\nvoid NetScope::run_defparams(Design*des)\n{\n      for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t ; cur != children_.end() ; ++ cur )\n\t    cur->second->run_defparams(des);\n\n      while (! defparams.empty()) {\n\t    pair<pform_name_t,PExpr*> pp = defparams.front();\n\t    defparams.pop_front();\n\n\t    pform_name_t path = pp.first;\n\t    PExpr*val = pp.second;\n\n\t    perm_string perm_name = peek_tail_name(path);\n\t    path.pop_back();\n\n\t    list<hname_t> eval_path = eval_scope_path(des, this, path);\n\n\t      /* If there is no path on the name, then the targ_scope\n\t\t is the current scope. */\n\t    NetScope*targ_scope = des->find_scope(this, eval_path);\n\t    if (targ_scope == 0) {\n\n\t\t    // Push the defparam onto a list for retry\n\t\t    // later. It is possible for the scope lookup to\n\t\t    // fail if the scope being defparam'd into is\n\t\t    // generated by an index array for generate.\n\t\t  eval_path.push_back(hname_t(perm_name));\n\t\t  defparams_later.push_back(make_pair(eval_path,val));\n\t\t  continue;\n\t    }\n\n\t    targ_scope->replace_parameter(des, perm_name, val, this, true);\n      }\n\n\t// If some of the defparams didn't find a scope in the name,\n\t// then try again later. It may be that the target scope is\n\t// created later by generate scheme or instance array.\n      if (! defparams_later.empty())\n\t    des->defparams_later.insert(this);\n}\n\nvoid NetScope::run_defparams_later(Design*des)\n{\n      set<NetScope*> target_scopes;\n      list<pair<list<hname_t>,PExpr*> > defparams_even_later;\n\n      while (! defparams_later.empty()) {\n\t    pair<list<hname_t>,PExpr*> cur = defparams_later.front();\n\t    defparams_later.pop_front();\n\n\t    list<hname_t>eval_path = cur.first;\n\t    perm_string name = eval_path.back().peek_name();\n\t    eval_path.pop_back();\n\n\t    PExpr*val = cur.second;\n\n\t    NetScope*targ_scope = des->find_scope(this, eval_path);\n\t    if (targ_scope == 0) {\n\t\t    // If a scope in the target path is not found,\n\t\t    // then push this defparam for handling even\n\t\t    // later. Maybe a later generate scheme or\n\t\t    // instance array will create the scope.\n\t\t  defparams_even_later.push_back(cur);\n\t\t  continue;\n\t    }\n\n\t    targ_scope->replace_parameter(des, name, val, this, true);\n\n\t      // We'll need to re-evaluate parameters in this scope\n\t    target_scopes.insert(targ_scope);\n      }\n\n\t// The scopes that this defparam set touched will be\n\t// re-evaluated later it a top_defparams work item. So do not\n\t// do the evaluation now.\n\n\t// If there are some scopes that still have missing scopes,\n\t// then save them back into the defparams_later list for a\n\t// later pass.\n      defparams_later = defparams_even_later;\n      if (! defparams_later.empty())\n\t    des->defparams_later.insert(this);\n}\n\nvoid Design::evaluate_parameters()\n{\n      for (map<perm_string,NetScope*>::const_iterator cur = packages_.begin()\n\t\t ; cur != packages_.end() ; ++ cur) {\n\t    cur->second->evaluate_parameters(this);\n      }\n\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin()\n\t\t ; scope != root_scopes_.end() ; ++ scope ) {\n\t    (*scope)->evaluate_parameters(this);\n      }\n}\n\nvoid NetScope::evaluate_parameter_logic_(Design*des, param_ref_t cur)\n{\n\t/* Evaluate the parameter expression. */\n      PExpr*val_expr = (*cur).second.val_expr;\n      NetScope*val_scope = (*cur).second.val_scope;\n\n      // The param_type may be nil if the parameter has no declared type. In\n      // this case, we'll try to take our type from the r-value.\n      ivl_type_t param_type = cur->second.ivl_type;\n\n      // Most parameter declarations are packed vectors, of the form:\n      //   parameter [H:L] foo == bar;\n      // so get the netvector_t. Note that this may also be the special\n      // case of a netvector_t with no dimensions, that exists only to carry\n      // signed-ness, e.g.:\n      //  parameter signed foo = bar;\n      // These will be marked as scalar, but also have the implict flag set.\n      const netvector_t* param_vect = dynamic_cast<const netvector_t*> (param_type);\n\n      if (debug_elaborate) {\n\t    cerr << val_expr->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"parameter=\" << cur->first << endl;\n\t    if (param_type)\n\t\t  cerr << val_expr->get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"param_type=\" << *param_type << endl;\n\t    else\n\t\t  cerr << val_expr->get_fileline() << \": \" << __func__ << \": \"\n\t\t       << \"param_type=(nil)\" << endl;\n\t    cerr << val_expr->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"val_expr=\" << *val_expr << endl;\n      }\n\n      ivl_variable_type_t use_type;\n      int lv_width = -2;\n      if (param_type) {\n\t    use_type = param_type->base_type();\n\t    // Is this an implicit netvector_t with no dimenions?\n\t    if (param_vect && param_vect->get_implicit() &&\n\t        param_vect->get_scalar())\n\t\t  lv_width = -2;\n\t    else if (param_type->packed())\n\t\t  lv_width = param_type->packed_width();\n      } else {\n\t    use_type = val_expr->expr_type();\n      }\n\n      if (debug_elaborate) {\n\t    cerr << val_expr->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"use_type = \" << use_type << endl;\n      }\n\n      NetExpr *expr;\n\n      // Handle assignment patterns as a special case as they need the type to\n      // be evaluated correctly.\n      if (param_type && dynamic_cast<PEAssignPattern*>(val_expr)) {\n\t    expr = elab_and_eval(des, val_scope, val_expr, param_type, true);\n      } else {\n\t    expr = elab_and_eval(des, val_scope, val_expr, lv_width, true,\n\t\t\t\t cur->second.is_annotatable, use_type);\n      }\n      if (! expr)\n            return;\n\n      // Make sure to carry the signed-ness from a vector type.\n      if (param_vect)\n\t    expr->cast_signed(param_vect->get_signed());\n\n      if (debug_elaborate) {\n\t    cerr << val_expr->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"expr = \" << *expr << endl;\n\t    cerr << val_expr->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"expr type = \" << expr->expr_type() << endl;\n      }\n\n      switch (expr->expr_type()) {\n\t  case IVL_VT_REAL:\n\t    if (! dynamic_cast<const NetECReal*>(expr)) {\n\t\t  cerr << expr->get_fileline()\n\t\t       << \": error: Unable to evaluate real parameter \"\n\t\t       << (*cur).first << \" value: \" << *expr << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n\n\t    // If the parameter has no type, then infer its type from the\n\t    // r-value expression.\n\t    if (param_type==0) {\n\t\t  param_type = &netreal_t::type_real;\n\t\t  cur->second.ivl_type = param_type;\n\t    }\n\t    break;\n\n\t  case IVL_VT_LOGIC:\n\t  case IVL_VT_BOOL:\n\t    if (! dynamic_cast<const NetEConst*>(expr)) {\n\t\t  cerr << expr->get_fileline()\n\t\t       << \": error: Unable to evaluate parameter \"\n\t\t       << (*cur).first << \" value: \" << *expr << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n\n\t    // If the parameter has no type, then infer its type from the\n\t    // r-value expression.\n\t    if (param_type==0) {\n\t\t  param_type = new netvector_t(expr->expr_type(), expr->expr_width()-1,\n\t\t\t\t\t       0, expr->has_sign());\n\t\t  cur->second.ivl_type = param_type;\n\t    }\n\n\t    if (param_type->base_type() != IVL_VT_NO_TYPE)\n\t\t  expr->cast_signed(param_type->get_signed());\n\n\t    if (!expr->has_width()) {\n\t\t  expr = pad_to_width(expr, integer_width, *expr);\n\t    } else if (param_type->slice_dimensions().size()==0 && !expr->has_width()) {\n\t\t  expr = pad_to_width(expr, integer_width, *expr);\n\t    }\n\t    break;\n\n\t  default:\n\t    cerr << expr->get_fileline()\n\t\t << \": internal error: \"\n\t\t << \"Unhandled expression type \"\n\t\t << expr->expr_type() << \"?\" << endl;\n\t    cerr << expr->get_fileline()\n\t\t << \":               : \"\n\t\t << \"param_type: \" << *param_type << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n\n      // By the time we're done with the above, we should certainly know the\n      // type of the parameter.\n      ivl_assert(*expr, cur->second.ivl_type);\n\n      cur->second.val = expr;\n\n\t// If there are no value ranges to test the value against,\n\t// then we are done.\n      if ((*cur).second.range == 0)\n\t    return;\n\n      NetEConst*val = dynamic_cast<NetEConst*>((*cur).second.val);\n      ivl_assert(*expr, val);\n\n      verinum value = val->value();\n\n      bool from_flag = (*cur).second.range == 0? true : false;\n      for (range_t*value_range = (*cur).second.range\n\t\t ; value_range ; value_range = value_range->next) {\n\n\t      // If we already know that the value is\n\t      // within a \"from\" range, then do not test\n\t      // any more of the from ranges.\n\t    if (from_flag && value_range->exclude_flag==false)\n\t\t  continue;\n\n\t    if (value_range->low_expr) {\n\t\t  NetEConst*tmp = dynamic_cast<NetEConst*>(value_range->low_expr);\n\t\t  ivl_assert(*value_range->low_expr, tmp);\n\t\t  if (value_range->low_open_flag && value <= tmp->value())\n\t\t\tcontinue;\n\t\t  else if (value < tmp->value())\n\t\t\tcontinue;\n\t    }\n\n\t    if (value_range->high_expr) {\n\t\t  NetEConst*tmp = dynamic_cast<NetEConst*>(value_range->high_expr);\n\t\t  ivl_assert(*value_range->high_expr, tmp);\n\t\t  if (value_range->high_open_flag && value >= tmp->value())\n\t\t\tcontinue;\n\t\t  else if (value > tmp->value())\n\t\t\tcontinue;\n\t    }\n\n\t      // Within the range. If this is a \"from\"\n\t      // range, then set the from_flag and continue.\n\t    if (value_range->exclude_flag == false) {\n\t\t  from_flag = true;\n\t\t  continue;\n\t    }\n\n\t      // OH NO! In an excluded range. signal an error.\n\t    from_flag = false;\n\t    break;\n      }\n\n\t// If we found no from range that contains the\n\t// value, then report an error.\n      if (! from_flag) {\n\t    cerr << val->get_fileline() << \": error: \"\n\t\t << \"Parameter value \" << value\n\t\t << \" is out of range for parameter \" << (*cur).first\n\t\t << \".\" << endl;\n\t    des->errors += 1;\n      }\n}\n\nvoid NetScope::evaluate_parameter_real_(Design*des, param_ref_t cur)\n{\n      PExpr*val_expr = (*cur).second.val_expr;\n      NetScope*val_scope = (*cur).second.val_scope;\n      ivl_type_t param_type = cur->second.ivl_type;\n\n      ivl_assert(*val_expr, param_type);\n      NetExpr*expr = elab_and_eval(des, val_scope, val_expr, -1, true,\n                                   cur->second.is_annotatable,\n                                   param_type->base_type());\n      if (! expr)\n            return;\n\n      NetECReal*res = 0;\n\n      switch (expr->expr_type()) {\n\t  case IVL_VT_REAL:\n\t    if (NetECReal*tmp = dynamic_cast<NetECReal*>(expr)) {\n\t\t  res = tmp;\n\t    } else {\n\t\t  cerr << expr->get_fileline()\n\t\t       << \": error: \"\n\t\t       << \"Unable to evaluate real parameter \"\n\t\t       << (*cur).first << \" value: \" << *expr << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n\t    break;\n\n\t  default:\n\t    cerr << expr->get_fileline()\n\t\t << \": internal error: \"\n\t\t << \"Failed to cast expression?\" << endl;\n\t    des->errors += 1;\n\t    return;\n\t    break;\n      }\n\n      (*cur).second.val = res;\n      double value = res->value().as_double();\n\n      bool from_flag = (*cur).second.range == 0? true : false;\n      for (range_t*value_range = (*cur).second.range\n\t\t ; value_range ; value_range = value_range->next) {\n\n\t    if (from_flag && value_range->exclude_flag==false)\n\t\t  continue;\n\n\t    if (value_range->low_expr) {\n\t\t  double tmp;\n\t\t  bool flag = eval_as_double(tmp, value_range->low_expr);\n\t\t  ivl_assert(*value_range->low_expr, flag);\n\t\t  if (value_range->low_open_flag && value <= tmp)\n\t\t\tcontinue;\n\t\t  else if (value < tmp)\n\t\t\tcontinue;\n\t    }\n\n\t    if (value_range->high_expr) {\n\t\t  double tmp;\n\t\t  bool flag = eval_as_double(tmp, value_range->high_expr);\n\t\t  ivl_assert(*value_range->high_expr, flag);\n\t\t  if (value_range->high_open_flag && value >= tmp)\n\t\t\tcontinue;\n\t\t  else if (value > tmp)\n\t\t\tcontinue;\n\t    }\n\n\t    if (value_range->exclude_flag == false) {\n\t\t  from_flag = true;\n\t\t  continue;\n\t    }\n\n\t      // All the above tests failed, so we must have tripped\n\t      // an exclude rule.\n\t    from_flag = false;\n\t    break;\n      }\n\n      if (! from_flag) {\n\t    cerr << res->get_fileline() << \": error: \"\n\t\t << \"Parameter value \" << value\n\t\t << \" is out of range for real parameter \" << (*cur).first\n\t\t << \".\" << endl;\n\t    des->errors += 1;\n      }\n}\n\n/*\n * Evaluate a parameter that is forced to type string. This comes to pass when\n * the input is something like this:\n *\n *     parameter string foo = <expr>;\n *\n * The param_type should be netstring_t, the val_expr is the pform of the\n * input <expr>, and we try to elaborate/evaluate down to a IVL_VT_STRING\n * expression.\n */\nvoid NetScope::evaluate_parameter_string_(Design*des, param_ref_t cur)\n{\n      PExpr*val_expr = (*cur).second.val_expr;\n      NetScope*val_scope = (*cur).second.val_scope;\n      ivl_type_t param_type = cur->second.ivl_type;\n\n      ivl_assert(cur->second, val_expr);\n      ivl_assert(cur->second, param_type);\n\n      NetExpr*expr = elab_and_eval(des, val_scope, val_expr, param_type, true);\n      if (! expr)\n\t    return;\n\n      cur->second.val = expr;\n\n      if (debug_elaborate) {\n\t    cerr << cur->second.get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Parameter type: \" << *param_type << endl;\n\t    cerr << cur->second.get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Parameter value: \" << *val_expr << endl;\n\t    cerr << cur->second.get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"Elaborated value: \" << *expr << endl;\n      }\n}\n\nvoid NetScope::evaluate_type_parameter_(Design *des, param_ref_t cur)\n{\n      const PETypename *type_expr = dynamic_cast<const PETypename*>(cur->second.val_expr);\n      if (!type_expr) {\n\t    cerr << this->get_fileline() << \": error: \"\n\t\t << \"Type parameter `\" << cur->first << \"` value `\"\n\t         << *cur->second.val_expr << \"` is not a type.\"\n\t\t << endl;\n\t    des->errors++;\n\n\t    // Recover\n\t    cur->second.ivl_type = netvector_t::integer_type();\n\t    return;\n      }\n\n      data_type_t *ptype = type_expr->get_type();\n      NetScope *type_scope = cur->second.val_scope;\n      cur->second.ivl_type = ptype->elaborate_type(des, type_scope);\n}\n\nvoid NetScope::evaluate_parameter_(Design*des, param_ref_t cur)\n{\n\n      // If the parameter has already been evaluated, quietly return.\n      if (cur->second.val || cur->second.ivl_type)\n            return;\n\n      if (cur->second.val_expr == 0) {\n\t    cerr << this->get_fileline() << \": error: \"\n\t         << \"Missing value for parameter `\"\n\t         << cur->first << \"`.\" << endl;\n\t    des->errors += 1;\n\n\t    cur->second.val = new NetEConst(verinum(verinum::Vx));\n\t    return;\n      }\n\n      if (cur->second.type_flag) {\n\t    evaluate_type_parameter_(des, cur);\n\t    return;\n      }\n\n      ivl_type_t param_type = cur->second.ivl_type;\n\n      // If the parameter type is present, then elaborate it now. Elaborate\n      // the type in the current scope, and not the scope of the expression.\n      if (cur->second.val_type) {\n\t    param_type = cur->second.val_type->elaborate_type(des, this);\n\t    cur->second.ivl_type = param_type;\n\t    cur->second.val_type = 0;\n      }\n\n      // Guess the varaiable type of the parameter. If the parameter has no\n      // given type, then guess the type from the expression and use that to\n      // evaluate (this is currently handled in evaluate_parameter_logic_()).\n      ivl_variable_type_t use_type;\n      if (param_type)\n\t    use_type = param_type->base_type();\n      else\n\t    use_type = IVL_VT_NO_TYPE;\n\n      if (cur->second.solving) {\n            cerr << cur->second.get_fileline() << \": error: \"\n\t         << \"Recursive parameter reference found involving \"\n                 << cur->first << \".\" << endl;\n\t    des->errors += 1;\n\n      } else {\n            cur->second.solving = true;\n            switch (use_type) {\n                case IVL_VT_NO_TYPE:\n                case IVL_VT_BOOL:\n                case IVL_VT_LOGIC:\n                  evaluate_parameter_logic_(des, cur);\n                  break;\n\n                case IVL_VT_REAL:\n                  evaluate_parameter_real_(des, cur);\n                  break;\n\n\t\tcase IVL_VT_STRING:\n\t\t  evaluate_parameter_string_(des, cur);\n\t\t  break;\n\n                default:\n                  cerr << cur->second.get_fileline() << \": internal error: \"\n                       << \"Unexpected parameter type \" << use_type\n                       << \".\" << endl;\n                  cerr << cur->second.get_fileline() << \":               : \"\n                       << \"Parameter name: \" << cur->first << endl;\n\t\t  if (param_type)\n\t\t\tcerr << cur->second.get_fileline() << \":               : \"\n\t\t\t     << \"Parameter ivl_type: \" << *param_type << endl;\n                  cerr << cur->second.get_fileline() << \":               : \"\n                       << \"Expression is: \" << *cur->second.val_expr << endl;\n                  ivl_assert(cur->second, 0);\n                  break;\n            }\n            cur->second.solving = false;\n      }\n\n        // If we have failed to evaluate the expression, create a dummy\n        // value. This prevents spurious error messages being output.\n      if (cur->second.val == 0) {\n            verinum val(verinum::Vx);\n            cur->second.val = new NetEConst(val);\n      }\n\n        // Flag that the expression has been evaluated.\n      cur->second.val_expr = 0;\n}\n\nvoid NetScope::evaluate_parameters(Design*des)\n{\n      for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t ; cur != children_.end() ; ++ cur )\n\t    cur->second->evaluate_parameters(des);\n\n      if (debug_scopes)\n\t    cerr << \"debug: \"\n\t\t << \"Evaluating parameters in \" << scope_path(this) << endl;\n\n      for (param_ref_t cur = parameters.begin()\n\t\t ; cur != parameters.end() ;  ++ cur) {\n\n            evaluate_parameter_(des, cur);\n      }\n}\n\nvoid Design::residual_defparams()\n{\n      for (list<NetScope*>::const_iterator scope = root_scopes_.begin();\n\t   scope != root_scopes_.end(); ++ scope )\n\t    (*scope)->residual_defparams(this);\n}\n\nvoid NetScope::residual_defparams(Design*des)\n{\n\t// Clean out the list of defparams that never managed to match\n\t// a scope. Print a warning for each.\n      while (! defparams_later.empty()) {\n\t    pair<list<hname_t>,PExpr*> cur = defparams_later.front();\n\t    defparams_later.pop_front();\n\n\t    cerr << cur.second->get_fileline() << \": warning: \"\n\t\t << \"Scope of \" << cur.first << \" not found.\" << endl;\n      }\n\n      for (map<hname_t,NetScope*>::const_iterator cur = children_.begin()\n\t\t ; cur != children_.end() ; ++ cur )\n\t    cur->second->residual_defparams(des);\n}\n\nconst char* Design::get_flag(const string&key) const\n{\n      map<string,const char*>::const_iterator tmp = flags_.find(key);\n      if (tmp == flags_.end())\n\t    return \"\";\n      else\n\t    return (*tmp).second;\n}\n\n/*\n * This method looks for a signal (reg, wire, whatever) starting at\n * the specified scope. If the name is hierarchical, it is split into\n * scope and name and the scope used to find the proper starting point\n * for the real search.\n *\n * It is the job of this function to properly implement Verilog scope\n * rules as signals are concerned.\n */\nNetNet* Design::find_signal(NetScope*scope, pform_name_t path)\n{\n      assert(scope);\n\n      perm_string key = peek_tail_name(path);\n      path.pop_back();\n      if (! path.empty()) {\n\t    list<hname_t> eval_path = eval_scope_path(this, scope, path);\n\t    scope = find_scope(scope, eval_path);\n      }\n\n      while (scope) {\n\t    if (NetNet*net = scope->find_signal(key))\n\t\t  return net;\n\n\t    if (NetScope*import_scope = scope->find_import(this, key)) {\n\t\t  scope = import_scope;\n\t\t  continue;\n\t    }\n\n\t    if (scope->type() == NetScope::MODULE)\n\t\t  break;\n\n\t    scope = scope->parent();\n      }\n\n      return 0;\n}\n\nNetFuncDef* Design::find_function(NetScope*scope, const pform_name_t&name)\n{\n      assert(scope);\n\n      std::list<hname_t> eval_path = eval_scope_path(this, scope, name);\n      NetScope*func = find_scope(scope, eval_path, NetScope::FUNC);\n      if (func && (func->type() == NetScope::FUNC)) {\n              // If a function is used in a parameter definition or in\n              // a signal declaration, it is possible to get here before\n              // the function's signals have been elaborated. If this is\n              // the case, elaborate them now.\n            if (func->elab_stage() < 2) {\n\t\t  func->need_const_func(true);\n                  const PFunction*pfunc = func->func_pform();\n                  assert(pfunc);\n                  pfunc->elaborate_sig(this, func);\n            }\n\t    return func->func_def();\n      }\n      return 0;\n}\n\nNetScope* Design::find_task(NetScope*scope, const pform_name_t&name)\n{\n      std::list<hname_t> eval_path = eval_scope_path(this, scope, name);\n      NetScope*task = find_scope(scope, eval_path, NetScope::TASK);\n      if (task && (task->type() == NetScope::TASK))\n\t    return task;\n\n      return 0;\n}\n\nvoid Design::add_node(NetNode*net)\n{\n      assert(net->design_ == 0);\n      if (nodes_ == 0) {\n\t    net->node_next_ = net;\n\t    net->node_prev_ = net;\n      } else {\n\t    net->node_next_ = nodes_->node_next_;\n\t    net->node_prev_ = nodes_;\n\t    net->node_next_->node_prev_ = net;\n\t    net->node_prev_->node_next_ = net;\n      }\n      nodes_ = net;\n      net->design_ = this;\n}\n\nvoid Design::del_node(NetNode*net)\n{\n      assert(net != 0);\n      assert(net->design_ == this);\n\n\t/* Interact with the Design::functor method by manipulating the\n\t   cur and nxt pointers that it is using. */\n      if (net == nodes_functor_nxt_)\n\t    nodes_functor_nxt_ = nodes_functor_nxt_->node_next_;\n      if (net == nodes_functor_nxt_)\n\t    nodes_functor_nxt_ = 0;\n\n      if (net == nodes_functor_cur_)\n\t    nodes_functor_cur_ = 0;\n\n\t/* Now perform the actual delete. */\n      if (nodes_ == net)\n\t    nodes_ = net->node_prev_;\n\n      if (nodes_ == net) {\n\t    nodes_ = 0;\n      } else {\n\t    net->node_next_->node_prev_ = net->node_prev_;\n\t    net->node_prev_->node_next_ = net->node_next_;\n      }\n\n      net->design_ = 0;\n}\n\nvoid Design::add_branch(NetBranch*bra)\n{\n      bra->next_ = branches_;\n      branches_ = bra;\n}\n\nvoid Design::add_process(NetProcTop*pro)\n{\n      pro->next_ = procs_;\n      procs_ = pro;\n}\n\nvoid Design::add_process(NetAnalogTop*pro)\n{\n      pro->next_ = aprocs_;\n      aprocs_ = pro;\n}\nvoid Design::delete_process(NetProcTop*top)\n{\n      assert(top);\n      if (procs_ == top) {\n\t    procs_ = top->next_;\n\n      } else {\n\t    NetProcTop*cur = procs_;\n\t    while (cur->next_ != top) {\n\t\t  assert(cur->next_);\n\t\t  cur = cur->next_;\n\t    }\n\n\t    cur->next_ = top->next_;\n      }\n\n      if (procs_idx_ == top)\n\t    procs_idx_ = top->next_;\n\n      delete top;\n}\n\nvoid Design::join_islands(void)\n{\n      if (nodes_ == 0)\n\t    return;\n\n      NetNode*cur = nodes_->node_next_;\n      do {\n\t    join_island(cur);\n\t    cur = cur->node_next_;\n      } while (cur != nodes_->node_next_);\n}\n"
        },
        {
          "name": "net_event.cc",
          "type": "blob",
          "size": 10.75390625,
          "content": "/*\n * Copyright (c) 2000-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * NOTE: The name_ is perm-allocated by the caller.\n */\nNetEvent::NetEvent(perm_string n)\n: name_(n)\n{\n      local_flag_ = false;\n      scope_ = 0;\n      snext_ = 0;\n      probes_ = 0;\n      trig_ = 0;\n      waitref_ = 0;\n      exprref_ = 0;\n      wlist_ = 0;\n      nb_trig_ = 0;\n}\n\nNetEvent::~NetEvent()\n{\n      ivl_assert(*this, waitref_ == 0);\n      if (scope_) scope_->rem_event(this);\n      while (probes_) {\n\t    NetEvProbe*tmp = probes_->enext_;\n\t    delete probes_;\n\t    probes_ = tmp;\n      }\n\t/* name_ is lex_strings. */\n}\n\nperm_string NetEvent::name() const\n{\n      return name_;\n}\n\nNetScope* NetEvent::scope()\n{\n      ivl_assert(*this, scope_);\n      return scope_;\n}\n\nconst NetScope* NetEvent::scope() const\n{\n      ivl_assert(*this, scope_);\n      return scope_;\n}\n\nunsigned NetEvent::nprobe() const\n{\n      unsigned cnt = 0;\n      NetEvProbe*cur = probes_;\n      while (cur) {\n\t    cnt += 1;\n\t    cur = cur->enext_;\n      }\n\n      return cnt;\n}\n\nNetEvProbe* NetEvent::probe(unsigned idx)\n{\n      NetEvProbe*cur = probes_;\n      while (cur && idx) {\n\t    cur = cur->enext_;\n\t    idx -= 1;\n      }\n      return cur;\n}\n\nconst NetEvProbe* NetEvent::probe(unsigned idx) const\n{\n      NetEvProbe*cur = probes_;\n      while (cur && idx) {\n\t    cur = cur->enext_;\n\t    idx -= 1;\n      }\n      return cur;\n}\n\nunsigned NetEvent::ntrig() const\n{\n      unsigned cnt = 0;\n      NetEvTrig*cur = trig_;\n      while (cur) {\n\t    cnt += 1;\n\t    cur = cur->enext_;\n      }\n\n      return cnt;\n}\n\nunsigned NetEvent::nwait() const\n{\n      return waitref_;\n}\n\nunsigned NetEvent::nexpr() const\n{\n      return exprref_;\n}\n\n/*\n * A \"similar\" event is one that has an identical non-nil set of\n * probes.\n */\nvoid NetEvent::find_similar_event(list<NetEvent*>&event_list)\n{\n      if (probes_ == 0)\n\t    return;\n\n      set<NetEvent*> candidate_events;\n\n\t/* First, get a list of all the NetEvProbes that are connected\n\t   to my first probe. Then use that to create a set of\n\t   candidate events. These candidate events are a superset of\n\t   the similar events, so I will be culling this list later. */\n      list<NetEvProbe*>first_probes;\n      probes_->find_similar_probes(first_probes);\n\n      for (list<NetEvProbe*>::iterator idx = first_probes.begin()\n\t\t ; idx != first_probes.end() ; ++ idx ) {\n\n\t    candidate_events.insert( (*idx)->event() );\n      }\n\n      if (candidate_events.empty())\n\t    return;\n\n\t/* Now scan the remaining probes, in each case checking that\n\t   the probe event is a candidate event. After each iteration,\n\t   events that don't have a similar probe will be removed from\n\t   the candidate_events set. If the candidate_events set\n\t   becomes empty, then give up. */\n      unsigned probe_count = 1;\n      for (NetEvProbe*cur = probes_->enext_ ; cur;  cur = cur->enext_) {\n\t    list<NetEvProbe*>similar_probes;\n\t    cur->find_similar_probes(similar_probes);\n\n\t    set<NetEvent*> candidate_tmp;\n\t    for (list<NetEvProbe*>::iterator idx = similar_probes.begin()\n\t\t       ; idx != similar_probes.end() ; ++ idx ) {\n\n\t\t  NetEvent*tmp = (*idx)->event();\n\t\t  if (candidate_events.find(tmp) != candidate_events.end())\n\t\t\tcandidate_tmp .insert(tmp);\n\t    }\n\n\t      // None of the candidate events match this probe? Give up!\n\t    if (candidate_tmp.empty())\n\t\t  return;\n\n\t    candidate_events = candidate_tmp;\n\t    probe_count += 1;\n      }\n\n        /* Scan the surviving candidate events. We know that they all\n\t   have probes that match the current event's probes. Check\n\t   for remaining compatibility details and save the survivors\n\t   in the event_list that the caller passed. */\n      for (set<NetEvent*>::iterator idx = candidate_events.begin()\n\t\t ; idx != candidate_events.end() ; ++ idx ) {\n\n\t    NetEvent*tmp = *idx;\n\n\t      // This shouldn't be possible?\n\t    if (tmp == this)\n\t\t  continue;\n\n              /* For automatic tasks, the VVP runtime holds state for events\n                 in the automatically allocated context. This means we can't\n                 merge similar events in different automatic tasks. */\n            if (scope()->is_auto() && (tmp->scope() != scope()))\n                  continue;\n\n\t    unsigned tcnt = 0;\n\t    for (NetEvProbe*cur = tmp->probes_ ; cur ; cur = cur->enext_)\n\t\t  tcnt += 1;\n\n\t    if (tcnt == probe_count)\n\t\t  event_list .push_back(tmp);\n      }\n\n}\n\n\nvoid NetEvent::replace_event(NetEvent*that)\n{\n      while (wlist_) {\n\t    wlist_->obj->replace_event(this, that);\n      }\n}\n\nNexusSet* NetEvent::nex_async_()\n{\n\t/* If there are behavioral trigger statements attached to me,\n\t   then this is not an asynchronous event. */\n      if (trig_ != 0)\n\t    return 0;\n\n\n      NexusSet*tmp = new NexusSet;\n      for (NetEvProbe*cur = probes_ ;  cur != 0 ;  cur = cur->enext_) {\n\t    if (cur->edge() != NetEvProbe::ANYEDGE) {\n\t\t  delete tmp;\n\t\t  return 0;\n\t    }\n\n\t    for (unsigned idx = 0 ;  idx < cur->pin_count() ;  idx += 1) {\n\t\t  Nexus*nex = cur->pin(idx).nexus();\n\t\t  tmp->add(nex, 0, nex->vector_width());\n\t    }\n      }\n\n      return tmp;\n}\n\nNetEvTrig::NetEvTrig(NetEvent*ev)\n: event_(ev)\n{\n      enext_ = event_->trig_;\n      event_->trig_ = this;\n}\n\nNetEvTrig::~NetEvTrig()\n{\n      if (event_->trig_ == this) {\n\t    event_->trig_ = enext_;\n\n      } else {\n\t    NetEvTrig*cur = event_->trig_;\n\t    while (cur->enext_ != this) {\n\t\t  ivl_assert(*this, cur->enext_);\n\t\t  cur = cur->enext_;\n\t    }\n\n\t    cur->enext_ = this->enext_;\n      }\n}\n\nconst NetEvent* NetEvTrig::event() const\n{\n      return event_;\n}\n\nNetEvNBTrig::NetEvNBTrig(NetEvent*ev, NetExpr*dly)\n: event_(ev), dly_(dly)\n{\n      enext_ = event_->nb_trig_;\n      event_->nb_trig_ = this;\n}\n\nNetEvNBTrig::~NetEvNBTrig()\n{\n      if (event_->nb_trig_ == this) {\n\t    event_->nb_trig_ = enext_;\n\n      } else {\n\t    NetEvNBTrig*cur = event_->nb_trig_;\n\t    while (cur->enext_ != this) {\n\t\t  ivl_assert(*this, cur->enext_);\n\t\t  cur = cur->enext_;\n\t    }\n\n\t    cur->enext_ = this->enext_;\n      }\n}\n\nconst NetExpr* NetEvNBTrig::delay() const\n{\n      return dly_;\n}\n\nconst NetEvent* NetEvNBTrig::event() const\n{\n      return event_;\n}\n\nNetEvProbe::NetEvProbe(NetScope*s, perm_string n, NetEvent*tgt,\n\t\t       edge_t t, unsigned p)\n: NetNode(s, n, p), event_(tgt), edge_(t)\n{\n      for (unsigned idx = 0 ;  idx < p ;  idx += 1) {\n\t    pin(idx).set_dir(Link::INPUT);\n      }\n\n      enext_ = event_->probes_;\n      event_->probes_ = this;\n}\n\nNetEvProbe::~NetEvProbe()\n{\n      if (event_->probes_ == this) {\n\t    event_->probes_ = enext_;\n\n      } else {\n\t    NetEvProbe*cur = event_->probes_;\n\t    while (cur->enext_ != this) {\n\t\t  ivl_assert(*this, cur->enext_);\n\t\t  cur = cur->enext_;\n\t    }\n\n\t    cur->enext_ = this->enext_;\n      }\n}\n\nNetEvProbe::edge_t NetEvProbe::edge() const\n{\n      return edge_;\n}\n\nNetEvent* NetEvProbe::event()\n{\n      return event_;\n}\n\nconst NetEvent* NetEvProbe::event() const\n{\n      return event_;\n}\n\n/*\n * A similar NetEvProbe is one that is connected to all the same nexa\n * that this probe is connected to, and also is the same edge\n * type. Don't count myself as a similar probe.\n */\nvoid NetEvProbe::find_similar_probes(list<NetEvProbe*>&plist)\n{\n      Nexus*nex = pin(0).nexus();\n\n      for (Link*lcur = nex->first_nlink(); lcur; lcur = lcur->next_nlink()) {\n\t    NetPins*obj = lcur->get_obj();\n\t      // Skip NexusSet objects\n\t    if (obj == 0)\n\t\t  continue;\n\n\t    if (obj->pin_count() != pin_count())\n\t\t  continue;\n\n\t    NetEvProbe*tmp = dynamic_cast<NetEvProbe*>(obj);\n\t    if (tmp == 0)\n\t\t  continue;\n\n\t    if (tmp == this)\n\t\t  continue;\n\n\t    if (edge() != tmp->edge())\n\t\t  continue;\n\n\t    bool ok_flag = true;\n\t    for (unsigned idx = 1 ;  ok_flag && idx < pin_count() ;  idx += 1)\n\t\t  if (! pin(idx).is_linked(tmp->pin(idx)))\n\t\t\tok_flag = false;\n\n\t    if (ok_flag == true)\n\t\t  plist .push_back(tmp);\n      }\n}\n\nNetEvWait::NetEvWait(NetProc*pr)\n: statement_(pr), has_t0_trigger_(false)\n{\n}\n\nNetEvWait::~NetEvWait()\n{\n      if (! events_.empty()) {\n\t    for (unsigned idx = 0 ;  idx < events_.size() ;  idx += 1) {\n\t\t  NetEvent*tgt = events_[idx];\n\t\t  tgt->waitref_ -= 1;\n\n\t\t  struct NetEvent::wcell_*tmp = tgt->wlist_;\n\t\t  if (tmp->obj == this) {\n\t\t\ttgt->wlist_ = tmp->next;\n\t\t\tdelete tmp;\n\t\t  } else {\n\t\t\tivl_assert(*this, tmp->next);\n\t\t\twhile (tmp->next->obj != this) {\n\t\t\t      tmp = tmp->next;\n\t\t\t      ivl_assert(*this, tmp->next);\n\t\t\t}\n\t\t\ttmp->next = tmp->next->next;\n\t\t\tdelete tmp;\n\t\t  }\n\t\t  delete tgt;\n\t    }\n\t    events_.clear();\n      }\n      delete statement_;\n}\n\nvoid NetEvWait::add_event(NetEvent*tgt)\n{\n\t/* A wait fork is an empty event. */\n      if (! tgt) {\n\t    ivl_assert(*this, events_.empty());\n\t    events_.push_back(0);\n\t    return;\n      }\n\n      events_.push_back(tgt);\n\n\t// Remember to tell the NetEvent that there is someone\n\t// pointing to it.\n      tgt->waitref_ += 1;\n\n      struct NetEvent::wcell_*tmp = new NetEvent::wcell_;\n      tmp->obj = this;\n      tmp->next = tgt->wlist_;\n      tgt->wlist_ = tmp;\n}\n\nvoid NetEvWait::replace_event(NetEvent*src, NetEvent*repl)\n{\n      unsigned idx;\n      for (idx = 0 ;  idx < events_.size() ;  idx += 1) {\n\t    if (events_[idx] == src)\n\t\t  break;\n      }\n\n      ivl_assert(*this, idx < events_.size());\n\n\t// First, remove me from the list held by the src NetEvent.\n      ivl_assert(*this, src->waitref_ > 0);\n      src->waitref_ -= 1;\n      struct NetEvent::wcell_*tmp = src->wlist_;\n      if (tmp->obj == this) {\n\t    src->wlist_ = tmp->next;\n\t    delete tmp;\n      } else {\n\t    ivl_assert(*this, tmp->next);\n\t    while (tmp->next->obj != this) {\n\t\t  tmp = tmp->next;\n\t\t  ivl_assert(*this, tmp->next);\n\t    }\n\t    tmp->next = tmp->next->next;\n\t    delete tmp;\n      }\n\n\t// Replace the src pointer with the repl pointer.\n      events_[idx] = repl;\n\n\t// Remember to tell the replacement NetEvent that there is\n\t// someone pointing to it.\n      repl->waitref_ += 1;\n\n      tmp = new NetEvent::wcell_;\n      tmp->obj = this;\n      tmp->next = repl->wlist_;\n      repl->wlist_ = tmp;\n\n}\n\nNetProc* NetEvWait::statement()\n{\n      return statement_;\n}\n\nconst NetProc* NetEvWait::statement() const\n{\n      return statement_;\n}\n"
        },
        {
          "name": "net_expr.cc",
          "type": "blob",
          "size": 10.703125,
          "content": "/*\n * Copyright (c) 2002-2020 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"netlist.h\"\n# include  \"netenum.h\"\n# include  \"netclass.h\"\n# include  \"netdarray.h\"\n# include  \"netscalar.h\"\n# include  \"compiler.h\"\n# include  \"netmisc.h\"\n# include  <iostream>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nNetExpr::NetExpr(unsigned w)\n: net_type_(0), width_(w), signed_flag_(false)\n{\n}\n\nNetExpr::NetExpr(ivl_type_t t)\n: net_type_(t), width_(0), signed_flag_(false)\n{\n      if (t) {\n\t    width_ = t->packed_width();\n\t    signed_flag_ = t->get_signed();\n      }\n}\n\nNetExpr::~NetExpr()\n{\n}\n\nivl_type_t NetExpr::net_type() const\n{\n      return net_type_;\n}\n\nvoid NetExpr::set_net_type(ivl_type_t type)\n{\n      net_type_ = type;\n      if (type) {\n\t    width_ = type->packed_width();\n\t    signed_flag_ = type->get_signed();\n      }\n}\n\nvoid NetExpr::cast_signed(bool flag)\n{\n      cast_signed_base_(flag);\n}\n\nbool NetExpr::has_width() const\n{\n      return true;\n}\n\n/*\n * the grand default data type is a logic vector.\n */\nivl_variable_type_t NetExpr::expr_type() const\n{\n      if (net_type_)\n\t    return net_type_->base_type();\n      else\n\t    return IVL_VT_LOGIC;\n}\n\nconst netenum_t*NetExpr::enumeration() const\n{\n      return dynamic_cast<const netenum_t*>(net_type_);\n}\n\nNetEArrayPattern::NetEArrayPattern(ivl_type_t lv_type, vector<NetExpr*>&items)\n: NetExpr(lv_type), items_(items)\n{\n}\n\nNetEArrayPattern::~NetEArrayPattern()\n{\n      for (size_t idx = 0 ; idx < items_.size() ; idx += 1)\n\t    delete items_[idx];\n}\n\n/*\n * Create an add/sub node from the two operands.\n */\nNetEBAdd::NetEBAdd(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: NetEBinary(op__, l, r, wid, signed_flag)\n{\n}\n\nNetEBAdd::~NetEBAdd()\n{\n}\n\n\nstatic ivl_variable_type_t arith_expr_type(const NetExpr *l, const NetExpr *r)\n{\n      auto l_expr_type = l->expr_type();\n      auto r_expr_type = r->expr_type();\n\n      if (l_expr_type == IVL_VT_REAL ||\n          r_expr_type == IVL_VT_REAL)\n\t    return IVL_VT_REAL;\n\n      if (l_expr_type == IVL_VT_LOGIC ||\n          r_expr_type == IVL_VT_LOGIC)\n\t    return IVL_VT_LOGIC;\n\n      return IVL_VT_BOOL;\n}\n\nivl_variable_type_t NetEBAdd::expr_type() const\n{\n      return arith_expr_type(left_, right_);\n}\n\n/*\n * Create a comparison operator with two sub-expressions.\n */\nNetEBComp::NetEBComp(char op__, NetExpr*l, NetExpr*r)\n: NetEBinary(op__, l, r, 1, false)\n{\n}\n\nNetEBComp::~NetEBComp()\n{\n}\n\nbool NetEBComp::has_width() const\n{\n      return true;\n}\n\nivl_variable_type_t NetEBComp::expr_type() const\n{\n\t// Case compare always returns BOOL\n      if (op() == 'E' || op() == 'N')\n\t    return IVL_VT_BOOL;\n\n      if (left()->expr_type() == IVL_VT_LOGIC)\n\t    return IVL_VT_LOGIC;\n\n      if (right()->expr_type() == IVL_VT_LOGIC)\n\t    return IVL_VT_LOGIC;\n\n      return IVL_VT_BOOL;\n}\n\nNetEBDiv::NetEBDiv(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: NetEBinary(op__, l, r, wid, signed_flag)\n{\n}\n\nNetEBDiv::~NetEBDiv()\n{\n}\n\nivl_variable_type_t NetEBDiv::expr_type() const\n{\n      if (left_->expr_type() == IVL_VT_REAL)\n\t    return IVL_VT_REAL;\n\n      if (right_->expr_type() == IVL_VT_REAL)\n\t    return IVL_VT_REAL;\n\n      // div is always 4-state, even if both inputs are 2-state because division\n      // by 0 can yield 'x\n      return IVL_VT_LOGIC;\n}\n\nNetEBMinMax::NetEBMinMax(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: NetEBinary(op__, l, r, wid, signed_flag)\n{\n}\n\nNetEBMinMax::~NetEBMinMax()\n{\n}\n\nivl_variable_type_t NetEBMinMax::expr_type() const\n{\n      return arith_expr_type(left_, right_);\n}\n\nNetEBMult::NetEBMult(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: NetEBinary(op__, l, r, wid, signed_flag)\n{\n}\n\nNetEBMult::~NetEBMult()\n{\n}\n\nivl_variable_type_t NetEBMult::expr_type() const\n{\n      return arith_expr_type(left_, right_);\n}\n\nNetEBPow::NetEBPow(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: NetEBinary(op__, l, r, wid, signed_flag)\n{\n}\n\nNetEBPow::~NetEBPow()\n{\n}\n\nivl_variable_type_t NetEBPow::expr_type() const\n{\n      return arith_expr_type(left_, right_);\n}\n\nNetEBShift::NetEBShift(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: NetEBinary(op__, l, r, wid, signed_flag)\n{\n}\n\nNetEBShift::~NetEBShift()\n{\n}\n\nbool NetEBShift::has_width() const\n{\n      return left_->has_width();\n}\n\nivl_variable_type_t NetEBShift::expr_type() const\n{\n      if (left_->expr_type() == IVL_VT_LOGIC ||\n          right_->expr_type() == IVL_VT_LOGIC)\n\t    return IVL_VT_LOGIC;\n\n      return IVL_VT_BOOL;\n}\n\nNetEConcat::NetEConcat(unsigned cnt, unsigned r, ivl_variable_type_t vt)\n: parms_(cnt), repeat_(r), expr_type_(vt)\n{\n      expr_width(0);\n}\n\nNetEConcat::~NetEConcat()\n{\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1)\n\t    delete parms_[idx];\n}\n\nivl_variable_type_t NetEConcat::expr_type() const\n{\n      return expr_type_;\n}\n\nvoid NetEConcat::set(unsigned idx, NetExpr*e)\n{\n      ivl_assert(*this, idx < parms_.size());\n      ivl_assert(*this, parms_[idx] == 0);\n      parms_[idx] = e;\n      expr_width( expr_width() + repeat_ * e->expr_width() );\n}\n\nNetEConstEnum::NetEConstEnum(perm_string n, const netenum_t *enum_set,\n\t\t\t     const verinum &val)\n: NetEConst(enum_set, val), name_(n)\n{\n      ivl_assert(*this, has_width());\n}\n\nNetEConstEnum::~NetEConstEnum()\n{\n}\n\nNetECReal::NetECReal(const verireal&val)\n: value_(val)\n{\n      expr_width(1);\n      cast_signed_base_(true);\n}\n\nNetECReal::~NetECReal()\n{\n}\n\nconst verireal& NetECReal::value() const\n{\n      return value_;\n}\n\nivl_variable_type_t NetECReal::expr_type() const\n{\n      return IVL_VT_REAL;\n}\n\nNetECRealParam::NetECRealParam(const NetScope*s, perm_string n, const verireal&v)\n: NetECReal(v), scope_(s), name_(n)\n{\n}\n\nNetECRealParam::~NetECRealParam()\n{\n}\n\nperm_string NetECRealParam::name() const\n{\n      return name_;\n}\n\nconst NetScope* NetECRealParam::scope() const\n{\n      return scope_;\n}\n\nNetECString::NetECString(const std::string& val)\n: NetEConst(verinum(val))\n{\n}\n\nNetECString::~NetECString()\n{\n}\n\nivl_variable_type_t NetECString::expr_type() const\n{\n      return IVL_VT_STRING;\n}\n\nNetELast::NetELast(NetNet*s)\n: sig_(s)\n{\n}\n\nNetELast::~NetELast()\n{\n}\n\nivl_variable_type_t NetELast::expr_type() const\n{\n      return IVL_VT_BOOL;\n}\n\nNetENetenum::NetENetenum(const netenum_t*s)\n: netenum_(s)\n{\n}\n\nNetENetenum::~NetENetenum()\n{\n}\n\nconst netenum_t* NetENetenum::netenum() const\n{\n      return netenum_;\n}\n\nNetENew::NetENew(ivl_type_t t)\n: NetExpr(t), size_(0), init_val_(0)\n{\n}\n\nNetENew::NetENew(ivl_type_t t, NetExpr*size, NetExpr*init_val)\n: NetExpr(t), size_(size), init_val_(init_val)\n{\n}\n\nNetENew::~NetENew()\n{\n}\n\nivl_variable_type_t NetENew::expr_type() const\n{\n      return size_ ? IVL_VT_DARRAY : IVL_VT_CLASS;\n}\n\nNetENull::NetENull()\n{\n}\n\nNetENull::~NetENull()\n{\n}\n\nNetEProperty::NetEProperty(NetNet*net, size_t pidx, NetExpr*idx)\n: net_(net), pidx_(pidx), index_(idx)\n{\n      const netclass_t*use_type = dynamic_cast<const netclass_t*>(net->net_type());\n      ivl_assert(*this, use_type);\n\n      ivl_type_t prop_type = use_type->get_prop_type(pidx_);\n      if (idx) {\n\t    auto array_type = dynamic_cast<const netarray_t*>(prop_type);\n\t    ivl_assert(*this, array_type);\n\t    set_net_type(array_type->element_type());\n      } else {\n\t    set_net_type(prop_type);\n      }\n}\n\nNetEProperty::~NetEProperty()\n{\n}\n\nNetESelect::NetESelect(NetExpr*exp, NetExpr*base, unsigned wid,\n                       ivl_select_type_t sel_type)\n: expr_(exp), base_(base), sel_type_(sel_type)\n{\n      expr_width(wid);\n}\n\nNetESelect::NetESelect(NetExpr*exp, NetExpr*base, unsigned wid,\n                       ivl_type_t use_type)\n: NetExpr(use_type), expr_(exp), base_(base), sel_type_(IVL_SEL_OTHER)\n{\n      expr_width(wid);\n}\n\nNetESelect::~NetESelect()\n{\n      delete expr_;\n      delete base_;\n}\n\nconst NetExpr*NetESelect::sub_expr() const\n{\n      return expr_;\n}\n\nconst NetExpr*NetESelect::select() const\n{\n      return base_;\n}\n\nivl_select_type_t NetESelect::select_type() const\n{\n      return sel_type_;\n}\n\nivl_variable_type_t NetESelect::expr_type() const\n{\n      if (net_type())\n\t    return net_type()->base_type();\n\n      ivl_variable_type_t type = expr_->expr_type();\n\n\t// Special case: If the sub-expression is an IVL_VT_STRING,\n\t// then this node is representing a character select. The\n\t// width is the width of a byte, and the data type is BOOL.\n      if (type == IVL_VT_STRING && expr_width()==8)\n\t    return IVL_VT_BOOL;\n\n      return type;\n}\n\nNetESFunc::NetESFunc(const char*n, ivl_variable_type_t t,\n\t\t     unsigned width, unsigned np, bool is_overridden)\n: name_(0), type_(t), parms_(np), is_overridden_(is_overridden)\n{\n      name_ = lex_strings.add(n);\n      expr_width(width);\n}\n\nNetESFunc::NetESFunc(const char*n, ivl_type_t rtype, unsigned np)\n: NetExpr(rtype), name_(0), type_(rtype->base_type()), parms_(np),\n  is_overridden_(false)\n{\n      name_ = lex_strings.add(n);\n}\n\nNetESFunc::~NetESFunc()\n{\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1)\n\t    if (parms_[idx]) delete parms_[idx];\n\n\t/* name_ string ls lex_strings allocated. */\n}\n\nconst char* NetESFunc::name() const\n{\n      return name_;\n}\n\nunsigned NetESFunc::nparms() const\n{\n      return parms_.size();\n}\n\nvoid NetESFunc::parm(unsigned idx, NetExpr*v)\n{\n      ivl_assert(*this, idx < parms_.size());\n      if (parms_[idx])\n\t    delete parms_[idx];\n      parms_[idx] = v;\n}\n\nconst NetExpr* NetESFunc::parm(unsigned idx) const\n{\n      ivl_assert(*this, idx < parms_.size());\n      return parms_[idx];\n}\n\nNetExpr* NetESFunc::parm(unsigned idx)\n{\n      ivl_assert(*this, idx < parms_.size());\n      return parms_[idx];\n}\n\nivl_variable_type_t NetESFunc::expr_type() const\n{\n      return type_;\n}\n\nNetEShallowCopy::NetEShallowCopy(NetExpr*arg1, NetExpr*arg2)\n: arg1_(arg1), arg2_(arg2)\n{\n}\n\nNetEShallowCopy::~NetEShallowCopy()\n{\n}\n\nivl_variable_type_t NetEShallowCopy::expr_type() const\n{\n      return arg1_->expr_type();\n}\n\nNetEAccess::NetEAccess(NetBranch*br, ivl_nature_t nat)\n: branch_(br), nature_(nat)\n{\n      cast_signed_base_(true);\n}\n\nNetEAccess::~NetEAccess()\n{\n}\n\nivl_variable_type_t NetEAccess::expr_type() const\n{\n      return IVL_VT_REAL;\n}\n"
        },
        {
          "name": "net_func.cc",
          "type": "blob",
          "size": 3.302734375,
          "content": "/*\n * Copyright (c) 2002-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"netlist.h\"\n# include  \"compiler.h\"\n# include  \"PExpr.h\"\n# include  <iostream>\n\nusing namespace std;\n\n/*\n * To make a NetUserFunc device, make as many pins as there are ports\n * in the function. Get the port count from the function definition,\n * which accounts for all the inputs, plus one for the phantom output\n * that is the result.\n */\nNetUserFunc::NetUserFunc(NetScope*s, perm_string n, NetScope*d,\n                         NetEvWait*trigger__)\n: NetNode(s, n, d->func_def()->port_count()+1),\n  def_(d), trigger_(trigger__)\n{\n      pin(0).set_dir(Link::OUTPUT);\n\n      for (unsigned idx = 1 ;  idx < pin_count() ;  idx += 1) {\n\n\t    pin(idx).set_dir(Link::INPUT);\n\t    pin(idx).drive0(IVL_DR_HiZ);\n\t    pin(idx).drive1(IVL_DR_HiZ);\n      }\n}\n\nNetUserFunc::~NetUserFunc()\n{\n}\n\nunsigned NetUserFunc::port_width(unsigned port) const\n{\n      NetFuncDef*fdef = def_->func_def();\n\n\t/* Port 0 is the return port. */\n      if (port == 0) {\n\t    const NetNet*sig = fdef->return_sig();\n\t    assert(sig);\n\t    return sig->vector_width();\n      }\n\n      port -= 1;\n      assert(port < fdef->port_count());\n      const NetNet*port_sig = fdef->port(port);\n\n      return port_sig->vector_width();\n}\n\nconst NetScope* NetUserFunc::def() const\n{\n      return def_;\n}\n\n/*\n * This method of the PECallFunction class checks that the parameters\n * of the PECallFunction match the function definition. This is used\n * during elaboration to validate the parameters before using them.\n */\nbool PECallFunction::check_call_matches_definition_(Design*des, NetScope*dscope) const\n{\n      assert(dscope);\n\n      if (dscope->type() != NetScope::FUNC) {\n\t    cerr << get_fileline() << \": error: Attempt to call scope \"\n\t\t << scope_path(dscope) << \" as a function.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      return true;\n}\n\n\nNetSysFunc::NetSysFunc(NetScope*s, perm_string n,\n\t\t       const struct sfunc_return_type*def,\n\t\t       unsigned ports, NetEvWait*trigger__)\n: NetNode(s, n, ports), def_(def), trigger_(trigger__)\n{\n      pin(0).set_dir(Link::OUTPUT); // Q\n\n      for (unsigned idx = 1 ;  idx < pin_count() ;  idx += 1) {\n\n\t    pin(idx).set_dir(Link::INPUT);\n\t    pin(idx).drive0(IVL_DR_HiZ);\n\t    pin(idx).drive1(IVL_DR_HiZ);\n      }\n}\n\nNetSysFunc::~NetSysFunc()\n{\n}\n\nconst char*NetSysFunc::func_name() const\n{\n      return def_->name;\n}\n\nivl_variable_type_t NetSysFunc::data_type() const\n{\n      return def_->type;\n}\n\nunsigned NetSysFunc::vector_width() const\n{\n      return def_->wid;\n}\n"
        },
        {
          "name": "net_func_eval.cc",
          "type": "blob",
          "size": 33.2880859375,
          "content": "/*\n * Copyright (c) 2012-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"compiler.h\"\n# include  <typeinfo>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * We only evaluate one function at a time, so to support the disable\n * statement, we just need to record the target block and then early\n * terminate each enclosing block or loop statement until we get back\n * to the target block.\n */\nstatic const NetScope*disable = 0;\nstatic bool loop_break;\nstatic bool loop_continue;\n\nstatic NetExpr* fix_assign_value(const NetNet*lhs, NetExpr*rhs)\n{\n      NetEConst*ce = dynamic_cast<NetEConst*>(rhs);\n      if (ce == 0) return rhs;\n\n      unsigned lhs_width = lhs->vector_width();\n      unsigned rhs_width = rhs->expr_width();\n      if (rhs_width < lhs_width) {\n            rhs = pad_to_width(rhs, lhs_width, *rhs);\n      } else if (rhs_width > lhs_width) {\n            verinum value(ce->value(), lhs_width);\n            ce = new NetEConst(value);\n            ce->set_line(*rhs);\n            delete rhs;\n\t    rhs = ce;\n      }\n      rhs->cast_signed(lhs->get_signed());\n      return rhs;\n}\n\nNetExpr* NetFuncDef::evaluate_function(const LineInfo&loc, const std::vector<NetExpr*>&args) const\n{\n\t// Make the context map.\n      map<perm_string,LocalVar>::iterator ptr;\n      map<perm_string,LocalVar>context_map;\n\n      if (debug_eval_tree) {\n\t    cerr << loc.get_fileline() << \": NetFuncDef::evaluate_function: \"\n\t\t << \"Evaluate function \" << scope()->basename() << endl;\n      }\n\n\t// Put the return value into the map...\n      LocalVar&return_var = context_map[scope()->basename()];\n      return_var.nwords = 0;\n      return_var.value  = 0;\n\n\t// Load the input ports into the map...\n      ivl_assert(loc, port_count() == args.size());\n      for (size_t idx = 0 ; idx < port_count() ; idx += 1) {\n\t    const NetNet*pnet = port(idx);\n\t    perm_string aname = pnet->name();\n\t    LocalVar&input_var = context_map[aname];\n\t    input_var.nwords = 0;\n\t    input_var.value  = fix_assign_value(pnet, args[idx]);\n\n\t    if (debug_eval_tree) {\n\t\t  cerr << loc.get_fileline() << \": NetFuncDef::evaluate_function: \"\n\t\t       << \"   input \" << aname << \" = \" << *args[idx] << endl;\n\t    }\n      }\n\n\t// Ask the scope to collect definitions for local values. This\n\t// fills in the context_map with local variables held by the scope.\n      scope()->evaluate_function_find_locals(loc, context_map);\n\n\t// Execute any variable initialization statements.\n      if (const NetProc*init_proc = scope()->var_init())\n\t    init_proc->evaluate_function(loc, context_map);\n\n      if (debug_eval_tree && proc_==0) {\n\t    cerr << loc.get_fileline() << \": NetFuncDef::evaluate_function: \"\n\t\t << \"Function \" << scope_path(scope())\n\t\t << \" has no statement?\" << endl;\n      }\n\n\t// Perform the evaluation. Note that if there were errors\n\t// when compiling the function definition, we may not have\n\t// a valid statement.\n      bool flag = proc_ && proc_->evaluate_function(loc, context_map);\n\n      if (debug_eval_tree && !flag) {\n\t    cerr << loc.get_fileline() << \": NetFuncDef::evaluate_function: \"\n\t\t << \"Cannot evaluate \" << scope_path(scope()) << \".\" << endl;\n      }\n\n\t// Extract the result...\n      ptr = context_map.find(scope()->basename());\n      NetExpr*res = ptr->second.value;\n      context_map.erase(ptr);\n\n\t// Cleanup the rest of the context.\n      for (ptr = context_map.begin() ; ptr != context_map.end() ; ++ptr) {\n\n\t    unsigned nwords = ptr->second.nwords;\n\t    if (nwords > 0) {\n\t\t  NetExpr**array = ptr->second.array;\n\t\t  for (unsigned idx = 0 ; idx < nwords ; idx += 1) {\n\t\t\tdelete array[idx];\n\t\t  }\n\t\t  delete [] ptr->second.array;\n\t    } else {\n\t\t  delete ptr->second.value;\n\t    }\n      }\n\n      if (disable) {\n\t    if (debug_eval_tree)\n\t\t  cerr << loc.get_fileline() << \": NetFuncDef::evaluate_function: \"\n\t\t       << \"disable of \" << scope_path(disable)\n\t\t       << \" trapped in function \" << scope_path(scope())\n\t\t       << \".\" << endl;\n\t    ivl_assert(loc, disable==scope());\n\t    disable = 0;\n      }\n\n\t// Done.\n      if (flag) {\n\t    if (debug_eval_tree) {\n\t\t  cerr << loc.get_fileline() << \": NetFuncDef::evaluate_function: \"\n\t\t       << \"Evaluated to \";\n\t\t  if (res) cerr << *res;\n\t\t  else cerr << \"<nil>\";\n\t\t  cerr << endl;\n\t    }\n\t    return res;\n      }\n\n      if (debug_eval_tree) {\n\t    cerr << loc.get_fileline() << \": NetFuncDef::evaluate_function: \"\n\t\t << \"Evaluation failed.\" << endl;\n      }\n\n      delete res;\n      return 0;\n}\n\nvoid NetScope::evaluate_function_find_locals(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      for (map<perm_string,NetNet*>::const_iterator cur = signals_map_.begin()\n\t\t ; cur != signals_map_.end() ; ++cur) {\n\n\t    const NetNet*tmp = cur->second;\n\t      // Skip ports, which are handled elsewhere.\n\t    if (tmp->port_type() != NetNet::NOT_A_PORT)\n\t\t  continue;\n\n\t    unsigned nwords = 0;\n\t    if (tmp->unpacked_dimensions() > 0)\n\t\t  nwords = tmp->unpacked_count();\n\n\t    LocalVar&local_var = context_map[tmp->name()];\n\t    local_var.nwords = nwords;\n\n\t    if (nwords > 0) {\n\t\t  NetExpr**array = new NetExpr*[nwords];\n\t\t  for (unsigned idx = 0 ; idx < nwords ; idx += 1) {\n\t\t\tarray[idx] = 0;\n\t\t  }\n\t\t  local_var.array = array;\n\t    } else {\n\t\t  local_var.value = 0;\n\t    }\n\n\t    if (debug_eval_tree) {\n\t\t  cerr << loc.get_fileline() << \": debug: \"\n\t\t       << \"   (local) \" << tmp->name()\n\t\t       << (nwords > 0 ? \"[]\" : \"\") << endl;\n\t    }\n      }\n}\n\nNetExpr* NetExpr::evaluate_function(const LineInfo&,\n\t\t\t\t    map<perm_string,LocalVar>&) const\n{\n      cerr << get_fileline() << \": sorry: I don't know how to evaluate this expression at compile time.\" << endl;\n      cerr << get_fileline() << \":      : Expression type:\" << typeid(*this).name() << endl;\n\n      return 0;\n}\n\nbool NetProc::evaluate_function(const LineInfo&,\n\t\t\t\tmap<perm_string,LocalVar>&) const\n{\n      cerr << get_fileline() << \": sorry: I don't know how to evaluate this statement at compile time.\" << endl;\n      cerr << get_fileline() << \":      : Statement type:\" << typeid(*this).name() << endl;\n\n      return false;\n}\n\nvoid NetAssign::eval_func_lval_op_real_(const LineInfo&loc,\n\t\t\t\t\tverireal&lv, const verireal&rv) const\n{\n      switch (op_) {\n\t  case '+':\n\t    lv = lv + rv;\n\t    break;\n\t  case '-':\n\t    lv = lv - rv;\n\t    break;\n\t  case '*':\n\t    lv = lv * rv;\n\t    break;\n\t  case '/':\n\t    lv = lv / rv;\n\t    break;\n\t  case '%':\n\t    lv = lv % rv;\n\t    break;\n\t  default:\n\t    cerr << \"Illegal assignment operator: \"\n\t\t << human_readable_op(op_) << endl;\n\t    ivl_assert(loc, 0);\n      }\n}\n\nvoid NetAssign::eval_func_lval_op_(const LineInfo&loc,\n\t\t\t\t   verinum&lv, verinum&rv) const\n{\n      unsigned lv_width = lv.len();\n      bool lv_sign = lv.has_sign();\n      switch (op_) {\n\t  case 'l':\n\t  case 'R':\n\t      // The left operand is self-determined.\n\t    break;\n\t  case 'r':\n\t      // The left operand is self-determined, but we need to\n\t      // cast it to unsigned to get a logical shift.\n\t    lv.has_sign(false);\n\t    break;\n          default:\n\t      // The left operand must be cast to the expression type/size\n\t    lv.has_sign(rv.has_sign());\n\t    lv = cast_to_width(lv, rv.len());\n      }\n      switch (op_) {\n\t  case '+':\n\t    lv = lv + rv;\n\t    break;\n\t  case '-':\n\t    lv = lv - rv;\n\t    break;\n\t  case '*':\n\t    lv = lv * rv;\n\t    break;\n\t  case '/':\n\t    lv = lv / rv;\n\t    break;\n\t  case '%':\n\t    lv = lv % rv;\n\t    break;\n\t  case '&':\n\t    for (unsigned idx = 0 ; idx < lv.len() ; idx += 1)\n\t\t  lv.set(idx, lv[idx] & rv[idx]);\n\t    break;\n\t  case '|':\n\t    for (unsigned idx = 0 ; idx < lv.len() ; idx += 1)\n\t\t  lv.set(idx, lv[idx] | rv[idx]);\n\t    break;\n\t  case '^':\n\t    for (unsigned idx = 0 ; idx < lv.len() ; idx += 1)\n\t\t  lv.set(idx, lv[idx] ^ rv[idx]);\n\t    break;\n\t  case 'l':\n\t    lv = lv << rv.as_unsigned();\n\t    break;\n\t  case 'r':\n\t    lv = lv >> rv.as_unsigned();\n\t    break;\n\t  case 'R':\n\t    lv = lv >> rv.as_unsigned();\n\t    break;\n\t  default:\n\t    cerr << \"Illegal assignment operator: \"\n\t\t << human_readable_op(op_) << endl;\n\t    ivl_assert(loc, 0);\n      }\n      lv = cast_to_width(lv, lv_width);\n      lv.has_sign(lv_sign);\n}\n\nbool NetAssign::eval_func_lval_(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map,\n\t\t\t\tconst NetAssign_*lval, NetExpr*rval_result) const\n{\n      map<perm_string,LocalVar>::iterator ptr = context_map.find(lval->name());\n      ivl_assert(*this, ptr != context_map.end());\n\n      LocalVar*var = & ptr->second;\n      while (var->nwords == -1) {\n\t    ivl_assert(*this, var->ref);\n\t    var = var->ref;\n      }\n\n      NetExpr*old_lval;\n      int word = 0;\n      if (var->nwords > 0) {\n\t    NetExpr*word_result = lval->word()->evaluate_function(loc, context_map);\n\t    if (word_result == 0) {\n\t\t  delete rval_result;\n\t\t  return false;\n\t    }\n\n\t    NetEConst*word_const = dynamic_cast<NetEConst*>(word_result);\n\t    ivl_assert(loc, word_const);\n\n\t    if (!word_const->value().is_defined())\n\t\t  return true;\n\n\t    word = word_const->value().as_long();\n\n\t    if (word < 0 || word >= var->nwords)\n\t\t  return true;\n\n\t    old_lval = var->array[word];\n      } else {\n\t    ivl_assert(*this, var->nwords == 0);\n\t    old_lval = var->value;\n      }\n\n      if (const NetExpr*base_expr = lval->get_base()) {\n\t    NetExpr*base_result = base_expr->evaluate_function(loc, context_map);\n\t    if (base_result == 0) {\n\t\t  delete rval_result;\n\t\t  return false;\n\t    }\n\n\t    NetEConst*base_const = dynamic_cast<NetEConst*>(base_result);\n\t    ivl_assert(loc, base_const);\n\n\t    long base = base_const->value().as_long();\n\n\t    if (old_lval == 0)\n\t\t  old_lval = make_const_x(lval->sig()->vector_width());\n\n\t    NetEConst*lval_const = dynamic_cast<NetEConst*>(old_lval);\n\t    ivl_assert(loc, lval_const);\n\t    verinum lval_v = lval_const->value();\n\t    NetEConst*rval_const = dynamic_cast<NetEConst*>(rval_result);\n\t    ivl_assert(loc, rval_const);\n\t    verinum rval_v = rval_const->value();\n\n\t    verinum lpart(verinum::Vx, lval->lwidth());\n\t    if (op_) {\n\t\t  for (unsigned idx = 0 ; idx < lpart.len() ; idx += 1) {\n\t\t\tlong ldx = base + idx;\n\t\t\tif (ldx >= 0 && (unsigned long)ldx < lval_v.len())\n\t\t\t      lpart.set(idx, lval_v[ldx]);\n\t\t  }\n\t\t  eval_func_lval_op_(loc, lpart, rval_v);\n\t    } else {\n\t\t  lpart = cast_to_width(rval_v, lval->lwidth());\n\t    }\n\t    for (unsigned idx = 0 ; idx < lpart.len() ; idx += 1) {\n\t\t  long ldx = base + idx;\n\t\t  if (ldx >= 0 && (unsigned long)ldx < lval_v.len())\n\t\t\tlval_v.set(idx+base, lpart[idx]);\n\t    }\n\n\t    delete base_result;\n\t    delete rval_result;\n\t    rval_result = new NetEConst(lval_v);\n      } else {\n\t    if (op_ == 0) {\n\t\t  rval_result = fix_assign_value(lval->sig(), rval_result);\n\t    } else if (dynamic_cast<NetECReal*>(rval_result)) {\n\t\t  NetECReal*lval_const = dynamic_cast<NetECReal*>(old_lval);\n\t\t  ivl_assert(loc, lval_const);\n\t\t  verireal lval_r = lval_const->value();\n\t\t  NetECReal*rval_const = dynamic_cast<NetECReal*>(rval_result);\n\t\t  ivl_assert(loc, rval_const);\n\t\t  verireal rval_r = rval_const->value();\n\n\t\t  eval_func_lval_op_real_(loc, lval_r, rval_r);\n\n\t\t  delete rval_result;\n\t\t  rval_result = new NetECReal(lval_r);\n\t    } else {\n\t\t  NetEConst*lval_const = dynamic_cast<NetEConst*>(old_lval);\n\t\t  ivl_assert(loc, lval_const);\n\t\t  verinum lval_v = lval_const->value();\n\t\t  NetEConst*rval_const = dynamic_cast<NetEConst*>(rval_result);\n\t\t  ivl_assert(loc, rval_const);\n\t\t  verinum rval_v = rval_const->value();\n\n\t\t  eval_func_lval_op_(loc, lval_v, rval_v);\n\n\t\t  delete rval_result;\n\t\t  rval_result = new NetEConst(lval_v);\n\t    }\n      }\n\n      if (old_lval)\n\t    delete old_lval;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetAssign::evaluate_function: \"\n\t\t << lval->name() << \" = \" << *rval_result << endl;\n      }\n\n      if (var->nwords > 0) {\n\t    var->array[word] = rval_result;\n      } else {\n\t    ivl_assert(*this, var->nwords == 0);\n\t    var->value = rval_result;\n      }\n\n      return true;\n}\n\nbool NetAssign::evaluate_function(const LineInfo&loc,\n\t\t\t\t  map<perm_string,LocalVar>&context_map) const\n{\n      // Evaluate the r-value expression.\n      const NetExpr*use_rval = rval();\n      if (use_rval == 0)\n\t    return false;\n      NetExpr*rval_result = use_rval->evaluate_function(loc, context_map);\n      if (rval_result == 0)\n\t    return false;\n\n\t// Handle the easy case of a single variable on the LHS.\n      if (l_val_count() == 1)\n\t    return eval_func_lval_(loc, context_map, l_val(0), rval_result);\n\n\t// If we get here, the LHS must be a concatenation, so we\n\t// expect the RHS to be a vector value.\n      NetEConst*rval_const = dynamic_cast<NetEConst*>(rval_result);\n      ivl_assert(*this, rval_const);\n\n      if (op_) {\n\t    cerr << get_fileline() << \": sorry: Assignment operators \"\n\t\t    \"inside a constant function are not currently \"\n\t\t    \"supported if the LHS is a concatenation.\" << endl;\n\t    return false;\n      }\n\n      verinum rval_full = rval_const->value();\n      delete rval_result;\n\n      unsigned base = 0;\n      for (unsigned ldx = 0 ; ldx < l_val_count() ; ldx += 1) {\n\t    const NetAssign_*lval = l_val(ldx);\n\n\t    verinum rval_part(verinum::Vx, lval->lwidth());\n\t    for (unsigned idx = 0 ; idx < rval_part.len() ; idx += 1)\n\t\t  rval_part.set(idx, rval_full[base+idx]);\n\n\t    bool flag = eval_func_lval_(loc, context_map, lval,\n\t\t\t\t\tnew NetEConst(rval_part));\n\t    if (!flag) return false;\n\n\t    base += lval->lwidth();\n      }\n\n      return true;\n}\n\n/*\n * Evaluating a NetBlock in a function is a simple matter of\n * evaluating the statements in order.\n */\nbool NetBlock::evaluate_function(const LineInfo&loc,\n\t\t\t\t map<perm_string,LocalVar>&context_map) const\n{\n      if (last_ == 0) return true;\n\n\t// If we need to make a local scope, then this context map\n\t// will be filled in and used for statements within this block.\n      map<perm_string,LocalVar>local_context_map;\n      bool use_local_context_map = false;\n\n      if (subscope_!=0) {\n\t      // First, copy the containing scope symbols into the new\n\t      // scope as references.\n\t    for (map<perm_string,LocalVar>::iterator cur = context_map.begin()\n\t\t       ; cur != context_map.end() ; ++cur) {\n\t\t  LocalVar&cur_var = local_context_map[cur->first];\n\t\t  cur_var.nwords = -1;\n\t\t  if (cur->second.nwords == -1)\n\t\t\tcur_var.ref = cur->second.ref;\n\t\t  else\n\t\t\tcur_var.ref = &cur->second;\n\t    }\n\n\t      // Now collect the new locals.\n\t    subscope_->evaluate_function_find_locals(loc, local_context_map);\n\t    use_local_context_map = true;\n\n\t      // Execute any variable initialization statements.\n\t    if (const NetProc*init_proc = subscope_->var_init())\n\t\t  init_proc->evaluate_function(loc, local_context_map);\n      }\n\n\t// Now use the local context map if there is any local\n\t// context, or the containing context map.\n      map<perm_string,LocalVar>&use_context_map = use_local_context_map? local_context_map : context_map;\n\n      bool flag = true;\n      NetProc*cur = last_;\n      do {\n\t    cur = cur->next_;\n\t    if (debug_eval_tree) {\n\t\t  cerr << get_fileline() << \": NetBlock::evaluate_function: \"\n\t\t       << \"Execute statement (\" << typeid(*cur).name()\n\t\t       << \") at \" << cur->get_fileline() << \".\" << endl;\n\t    }\n\n\t    bool cur_flag = cur->evaluate_function(loc, use_context_map);\n\t    flag = flag && cur_flag;\n      } while (cur != last_ && !disable && !loop_break && !loop_continue);\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetBlock::evaluate_function: \"\n\t\t << \"subscope_=\" << subscope_\n\t\t << \", disable=\" << disable\n\t\t << \", flag=\" << (flag?\"true\":\"false\") << endl;\n      }\n\n      if (disable == subscope_) disable = 0;\n\n      return flag;\n}\n\nbool NetCase::evaluate_function_vect_(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      NetExpr*case_expr = expr_->evaluate_function(loc, context_map);\n      if (case_expr == 0)\n\t    return false;\n\n      NetEConst*case_const = dynamic_cast<NetEConst*> (case_expr);\n      ivl_assert(loc, case_const);\n\n      verinum case_val = case_const->value();\n      delete case_expr;\n\n      NetProc*default_statement = 0;\n\n      for (unsigned cnt = 0 ; cnt < items_.size() ; cnt += 1) {\n            const Item*item = &items_[cnt];\n\n            if (item->guard == 0) {\n                  default_statement = item->statement;\n                  continue;\n            }\n\n            NetExpr*item_expr = item->guard->evaluate_function(loc, context_map);\n            if (item_expr == 0)\n                  return false;\n\n            NetEConst*item_const = dynamic_cast<NetEConst*> (item_expr);\n            ivl_assert(loc, item_const);\n\n            verinum item_val = item_const->value();\n            delete item_expr;\n\n            ivl_assert(loc, item_val.len() == case_val.len());\n\n            bool match = true;\n            for (unsigned idx = 0 ; idx < item_val.len() ; idx += 1) {\n                  verinum::V bit_a = case_val.get(idx);\n                  verinum::V bit_b = item_val.get(idx);\n\n                  if (bit_a == verinum::Vx && type_ == EQX) continue;\n                  if (bit_b == verinum::Vx && type_ == EQX) continue;\n\n                  if (bit_a == verinum::Vz && type_ != EQ) continue;\n                  if (bit_b == verinum::Vz && type_ != EQ) continue;\n\n                  if (bit_a != bit_b) {\n                        match = false;\n                        break;\n                  }\n            }\n            if (!match) continue;\n\n            return item->statement->evaluate_function(loc, context_map);\n      }\n\n      if (default_statement)\n            return default_statement->evaluate_function(loc, context_map);\n\n      return true;\n}\n\nbool NetCase::evaluate_function_real_(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      NetExpr*case_expr = expr_->evaluate_function(loc, context_map);\n      if (case_expr == 0)\n\t    return false;\n\n      NetECReal*case_const = dynamic_cast<NetECReal*> (case_expr);\n      ivl_assert(loc, case_const);\n\n      double case_val = case_const->value().as_double();\n      delete case_expr;\n\n      NetProc*default_statement = 0;\n\n      for (unsigned cnt = 0 ; cnt < items_.size() ; cnt += 1) {\n            const Item*item = &items_[cnt];\n\n            if (item->guard == 0) {\n                  default_statement = item->statement;\n                  continue;\n            }\n\n            NetExpr*item_expr = item->guard->evaluate_function(loc, context_map);\n            if (item_expr == 0)\n                  return false;\n\n            NetECReal*item_const = dynamic_cast<NetECReal*> (item_expr);\n            ivl_assert(loc, item_const);\n\n            double item_val = item_const->value().as_double();\n            delete item_expr;\n\n            if (item_val != case_val) continue;\n\n            return item->statement->evaluate_function(loc, context_map);\n      }\n\n      if (default_statement)\n            return default_statement->evaluate_function(loc, context_map);\n\n      return true;\n}\n\nbool NetCase::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      if (expr_->expr_type() == IVL_VT_REAL)\n\t    return evaluate_function_real_(loc, context_map);\n      else\n\t    return evaluate_function_vect_(loc, context_map);\n}\n\nbool NetCondit::evaluate_function(const LineInfo&loc,\n\t\t\t\t  map<perm_string,LocalVar>&context_map) const\n{\n      NetExpr*cond = expr_->evaluate_function(loc, context_map);\n      if (cond == 0) {\n\t    if (debug_eval_tree) {\n\t\t  cerr << get_fileline() << \": NetCondit::evaluate_function: \"\n\t\t       << \"Unable to evaluate condition (\" << *expr_ <<\")\" << endl;\n\t    }\n\t    return false;\n      }\n\n      NetEConst*cond_const = dynamic_cast<NetEConst*> (cond);\n      ivl_assert(loc, cond_const);\n\n      long val = cond_const->value().as_long();\n      delete cond;\n\n      bool flag;\n\n      if (val)\n\t      // The condition is true, so evaluate the if clause\n\t    flag = (if_ == 0) || if_->evaluate_function(loc, context_map);\n      else\n\t      // The condition is false, so evaluate the else clause\n\t    flag = (else_ == 0) || else_->evaluate_function(loc, context_map);\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetCondit::evaluate_function: \"\n\t\t << \"Finished, flag=\" << (flag?\"true\":\"false\") << endl;\n      }\n      return flag;\n}\n\nbool NetDisable::evaluate_function(const LineInfo&,\n\t\t\t\t   map<perm_string,LocalVar>&) const\n{\n      disable = target_;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetDisable::evaluate_function: \"\n\t\t << \"disable \" << scope_path(disable) << endl;\n      }\n\n      return true;\n}\n\nbool NetBreak::evaluate_function(const LineInfo&,\n\t\t\t         map<perm_string, LocalVar>&) const\n{\n      loop_break = true;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetBreak::evaluate_function\" << endl;\n      }\n\n      return true;\n}\n\nbool NetContinue::evaluate_function(const LineInfo&,\n\t\t\t\t    map<perm_string, LocalVar>&) const\n{\n      loop_continue = true;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetContinue::evaluate_function\" << endl;\n      }\n\n      return true;\n}\n\nbool NetDoWhile::evaluate_function(const LineInfo&loc,\n\t\t\t\t   map<perm_string,LocalVar>&context_map) const\n{\n      bool flag = true;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetDoWhile::evaluate_function: \"\n\t\t << \"Start loop\" << endl;\n      }\n\n      while (!disable) {\n\t      // Evaluate the statement.\n\t    flag = proc_->evaluate_function(loc, context_map);\n\t    if (! flag)\n\t\t   break;\n\n\t    if (loop_break) {\n\t\t  loop_break = false;\n\t\t  break;\n\t    }\n\n\t    loop_continue = false;\n\n\t      // Evaluate the condition expression to try and get the\n\t      // condition for the loop.\n\t    NetExpr*cond = cond_->evaluate_function(loc, context_map);\n\t    if (cond == 0) {\n\t\t  flag = false;\n\t\t  break;\n\t    }\n\n\t    NetEConst*cond_const = dynamic_cast<NetEConst*> (cond);\n\t    ivl_assert(loc, cond_const);\n\n\t    long val = cond_const->value().as_long();\n\t    delete cond;\n\n\t      // If the condition is false, then the loop is done.\n\t    if (val == 0)\n\t\t  break;\n      }\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetDoWhile::evaluate_function: \"\n\t\t << \"Done loop, flag=\" << (flag?\"true\":\"false\") << endl;\n      }\n\n      return flag;\n}\n\nbool NetForever::evaluate_function(const LineInfo&loc,\n\t\t\t\t   map<perm_string,LocalVar>&context_map) const\n{\n      bool flag = true;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": debug: NetForever::evaluate_function: \"\n\t\t << \"Start loop\" << endl;\n      }\n\n      while (flag && !disable) {\n\t    flag = flag && statement_->evaluate_function(loc, context_map);\n\n\t    if (loop_break) {\n\t\t  loop_break = false;\n\t\t  break;\n\t    }\n\n\t    loop_continue = false;\n      }\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": debug: NetForever::evaluate_function: \"\n\t\t << \"Done loop\" << endl;\n      }\n\n      return flag;\n}\n\n/*\n * Process the for-loop to generate a value, as if this were in a function.\n */\nbool NetForLoop::evaluate_function(const LineInfo&loc,\n\t\t\t\t   map<perm_string,LocalVar>&context_map) const\n{\n      bool flag = true;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetForLoop::evaluate_function: \"\n\t\t<< \"Evaluate the for look as a function.\" << endl;\n      }\n\n      if (init_statement_) {\n\t    bool tmp_flag = init_statement_->evaluate_function(loc, context_map);\n\t    flag &= tmp_flag;\n      }\n\n      while (flag && !disable) {\n\t    if (condition_) {\n\t\t  // Evaluate the condition expression to try and get the\n\t\t  // condition for the loop.\n\t\t  NetExpr*cond = condition_->evaluate_function(loc, context_map);\n\t\t  if (cond == nullptr) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t  }\n\n\t\t  NetEConst*cond_const = dynamic_cast<NetEConst*> (cond);\n\t\t  ivl_assert(loc, cond_const);\n\n\t\t  long val = cond_const->value().as_long();\n\t\t  delete cond;\n\n\t\t  // If the condition is false, then break;\n\t\t  if (val == 0)\n\t\t\tbreak;\n\t    }\n\n\t    bool tmp_flag = statement_->evaluate_function(loc, context_map);\n\t    flag &= tmp_flag;\n\n\t    if (disable)\n\t\t  break;\n\n\t    if (loop_break) {\n\t\t  loop_break = false;\n\t\t  break;\n\t    }\n\n\t    loop_continue = false;\n\n\t    if (step_statement_) {\n\t\t  tmp_flag = step_statement_->evaluate_function(loc, context_map);\n\t\t  flag &= tmp_flag;\n\t    }\n      }\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetForLoop::evaluate_function: \"\n\t\t<< \"Done for-loop, flag=\" << (flag?\"true\":\"false\") << endl;\n      }\n\n      return flag;\n}\n\nbool NetRepeat::evaluate_function(const LineInfo&loc,\n\t\t\t\t  map<perm_string,LocalVar>&context_map) const\n{\n      bool flag = true;\n\n\t// Evaluate the condition expression to try and get the\n\t// condition for the loop.\n      NetExpr*count_expr = expr_->evaluate_function(loc, context_map);\n      if (count_expr == 0) return false;\n\n      NetEConst*count_const = dynamic_cast<NetEConst*> (count_expr);\n      ivl_assert(loc, count_const);\n\n      long count = count_const->value().as_long();\n      delete count_expr;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": debug: NetRepeat::evaluate_function: \"\n\t\t << \"Repeating \" << count << \" times.\" << endl;\n      }\n\n      while ((count > 0) && flag && !disable) {\n\t    flag = flag && statement_->evaluate_function(loc, context_map);\n\t    count -= 1;\n\n\t    if (loop_break) {\n\t\t  loop_break = false;\n\t\t  break;\n\t    }\n\n\t    loop_continue = false;\n      }\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": debug: NetRepeat::evaluate_function: \"\n\t\t << \"Finished loop\" << endl;\n      }\n\n      return flag;\n}\n\nbool NetSTask::evaluate_function(const LineInfo&,\n\t\t\t\t map<perm_string,LocalVar>&) const\n{\n\t// system tasks within a constant function are ignored\n      return true;\n}\n\nbool NetWhile::evaluate_function(const LineInfo&loc,\n\t\t\t\t map<perm_string,LocalVar>&context_map) const\n{\n      bool flag = true;\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetWhile::evaluate_function: \"\n\t\t << \"Start loop\" << endl;\n      }\n\n      while (flag && !disable) {\n\t      // Evaluate the condition expression to try and get the\n\t      // condition for the loop.\n\t    NetExpr*cond = cond_->evaluate_function(loc, context_map);\n\t    if (cond == 0) {\n\t\t  flag = false;\n\t\t  break;\n\t    }\n\n\t    NetEConst*cond_const = dynamic_cast<NetEConst*> (cond);\n\t    ivl_assert(loc, cond_const);\n\n\t    long val = cond_const->value().as_long();\n\t    delete cond;\n\n\t      // If the condition is false, then break.\n\t    if (val == 0)\n\t\t  break;\n\n\t      // The condition is true, so evaluate the statement\n\t      // another time.\n\t    bool tmp_flag = proc_->evaluate_function(loc, context_map);\n\t    if (! tmp_flag)\n\t\t  flag = false;\n\n\t    if (loop_break) {\n\t\t  loop_break = false;\n\t\t  break;\n\t    }\n\n\t    loop_continue = false;\n      }\n\n      if (debug_eval_tree) {\n\t    cerr << get_fileline() << \": NetWhile::evaluate_function: \"\n\t\t << \"Done loop, flag=\" << (flag?\"true\":\"false\") << endl;\n      }\n\n      return flag;\n}\n\nNetExpr* NetEBinary::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      NetExpr*lval = left_->evaluate_function(loc, context_map);\n      NetExpr*rval = right_->evaluate_function(loc, context_map);\n\n      if (lval == 0 || rval == 0) {\n\t    delete lval;\n\t    delete rval;\n\t    return 0;\n      }\n\n      NetExpr*res = eval_arguments_(lval, rval);\n      delete lval;\n      delete rval;\n      return res;\n}\n\nNetExpr* NetEConcat::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      vector<NetExpr*>vals(parms_.size());\n      unsigned gap = 0;\n\n      unsigned valid_vals = 0;\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n            ivl_assert(*this, parms_[idx]);\n            vals[idx] = parms_[idx]->evaluate_function(loc, context_map);\n            if (vals[idx] == 0) continue;\n\n            gap += vals[idx]->expr_width();\n\n            valid_vals += 1;\n      }\n\n      NetExpr*res = 0;\n      if (valid_vals == parms_.size()) {\n            res = eval_arguments_(vals, gap);\n      }\n      for (unsigned idx = 0 ;  idx < vals.size() ;  idx += 1) {\n            delete vals[idx];\n      }\n      return res;\n}\n\nNetExpr* NetEConst::evaluate_function(const LineInfo&,\n\t\t\t\t      map<perm_string,LocalVar>&) const\n{\n      NetEConst*res = new NetEConst(value_);\n      res->set_line(*this);\n      return res;\n}\n\nNetExpr* NetECReal::evaluate_function(const LineInfo&,\n\t\t\t\t      map<perm_string,LocalVar>&) const\n{\n      NetECReal*res = new NetECReal(value_);\n      res->set_line(*this);\n      return res;\n}\n\nNetExpr* NetESelect::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      NetExpr*sub_exp = expr_->evaluate_function(loc, context_map);\n      ivl_assert(loc, sub_exp);\n\n      NetEConst*sub_const = dynamic_cast<NetEConst*> (sub_exp);\n      ivl_assert(loc, sub_exp);\n\n      verinum sub = sub_const->value();\n      delete sub_exp;\n\n      long base = 0;\n      if (base_) {\n\t    NetExpr*base_val = base_->evaluate_function(loc, context_map);\n\t    ivl_assert(loc, base_val);\n\n\t    NetEConst*base_const = dynamic_cast<NetEConst*>(base_val);\n\t    ivl_assert(loc, base_const);\n\n\t    base = base_const->value().as_long();\n\t    delete base_val;\n      } else {\n\t    sub.has_sign(has_sign());\n\t    sub = pad_to_width(sub, expr_width());\n      }\n\n      verinum res (verinum::Vx, expr_width());\n      for (unsigned idx = 0 ; idx < res.len() ; idx += 1) {\n\t    long sdx = base + idx;\n\t    if (sdx >= 0 && (unsigned long)sdx < sub.len())\n\t\t  res.set(idx, sub[sdx]);\n      }\n\n      NetEConst*res_const = new NetEConst(res);\n      return res_const;\n}\n\nNetExpr* NetESignal::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      map<perm_string,LocalVar>::iterator ptr = context_map.find(name());\n      if (ptr == context_map.end()) {\n\t    cerr << get_fileline() << \": error: Cannot evaluate \" << name()\n\t\t << \" in this context.\" << endl;\n\t    return 0;\n      }\n\n\t// Follow indirect references to the actual variable.\n      LocalVar*var = & ptr->second;\n      while (var->nwords == -1) {\n\t    ivl_assert(*this, var->ref);\n\t    var = var->ref;\n      }\n\n      NetExpr*value = 0;\n      if (var->nwords > 0) {\n\t    ivl_assert(loc, word_);\n\t    NetExpr*word_result = word_->evaluate_function(loc, context_map);\n\t    if (word_result == 0)\n\t\t  return 0;\n\n\t    NetEConst*word_const = dynamic_cast<NetEConst*>(word_result);\n\t    ivl_assert(loc, word_const);\n\n\t    int word = word_const->value().as_long();\n\n\t    if (word_const->value().is_defined() && (word >= 0) && (word < var->nwords))\n\t\t  value = var->array[word];\n      } else {\n\t    value = var->value;\n      }\n\n      if (value == 0) {\n\t    switch (expr_type()) {\n\t\tcase IVL_VT_REAL:\n\t\t  return new NetECReal( verireal(0.0) );\n\t\tcase IVL_VT_BOOL:\n\t\t  return make_const_0(expr_width());\n\t\tcase IVL_VT_LOGIC:\n\t\t  return make_const_x(expr_width());\n\t\tdefault:\n\t\t  cerr << get_fileline() << \": sorry: I don't know how to initialize \" << *this << endl;\n\t\t  return 0;\n\t    }\n      }\n\n      return value->dup_expr();\n}\n\nNetExpr* NetETernary::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      unique_ptr<NetExpr> cval (cond_->evaluate_function(loc, context_map));\n\n      switch (const_logical(cval.get())) {\n\n\t  case C_0:\n\t    return false_val_->evaluate_function(loc, context_map);\n\t  case C_1:\n\t    return true_val_->evaluate_function(loc, context_map);\n\t  case C_X:\n\t    break;\n\t  default:\n\t    cerr << get_fileline() << \": error: Condition expression is not constant here.\" << endl;\n\t    return 0;\n      }\n\n      NetExpr*tval = true_val_->evaluate_function(loc, context_map);\n      NetExpr*fval = false_val_->evaluate_function(loc, context_map);\n\n      NetExpr*res = blended_arguments_(tval, fval);\n      delete tval;\n      delete fval;\n      return res;\n}\n\nNetExpr* NetEUnary::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      NetExpr*val = expr_->evaluate_function(loc, context_map);\n      if (val == 0) return 0;\n\n      NetExpr*res = eval_arguments_(val);\n      delete val;\n      return res;\n}\n\nNetExpr* NetESFunc::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      ID id = built_in_id_();\n      ivl_assert(*this, id != NOT_BUILT_IN);\n\n      NetExpr*val0 = 0;\n      NetExpr*val1 = 0;\n      NetExpr*res = 0;\n      switch (parms_.size()) {\n\t  case 1:\n\t    val0 = parms_[0]->evaluate_function(loc, context_map);\n\t    if (val0 == 0) break;\n\t    res = evaluate_one_arg_(id, val0);\n\t    break;\n\t  case 2:\n\t    val0 = parms_[0]->evaluate_function(loc, context_map);\n\t    val1 = parms_[1]->evaluate_function(loc, context_map);\n\t    if (val0 == 0 || val1 == 0) break;\n\t    res = evaluate_two_arg_(id, val0, val1);\n\t    break;\n\t  default:\n\t    ivl_assert(*this, 0);\n\t    break;\n      }\n      delete val0;\n      delete val1;\n      return res;\n}\n\nNetExpr* NetEUFunc::evaluate_function(const LineInfo&loc,\n\t\t\t\tmap<perm_string,LocalVar>&context_map) const\n{\n      NetFuncDef*def = func_->func_def();\n      ivl_assert(*this, def);\n\n      vector<NetExpr*>args(parms_.size());\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1)\n\t    args[idx] = parms_[idx]->evaluate_function(loc, context_map);\n\n      NetExpr*res = def->evaluate_function(*this, args);\n      return res;\n}\n"
        },
        {
          "name": "net_link.cc",
          "type": "blob",
          "size": 14.9716796875,
          "content": "/*\n * Copyright (c) 2000-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  \"netlist.h\"\n# include  <sstream>\n# include  <cstring>\n# include  <string>\n# include  <typeinfo>\n# include  <cstdlib>\n# include  \"ivl_alloc.h\"\n\nusing namespace std;\n\nvoid Nexus::connect(Link&r)\n{\n      Nexus*r_nexus = r.next_? r.find_nexus_() : NULL;\n      if (this == r_nexus)\n\t    return;\n\n      delete[] name_;\n      name_ = 0;\n\n\t// Special case: This nexus is empty. Simply copy all the\n\t// links of the other nexus to this one, and delete the old\n\t// nexus.\n      if (list_ == 0) {\n\t    if (r.next_ == 0) {\n\t\t  list_ = &r;\n\t\t  r.next_ = &r;\n\t\t  r.nexus_ = this;\n\t\t  driven_ = NO_GUESS;\n\t    } else {\n\t\t  driven_ = r_nexus->driven_;\n\t\t  list_ = r_nexus->list_;\n\t\t  list_->nexus_ = this;\n\t\t  r_nexus->list_ = 0;\n\t\t  delete r_nexus;\n\t    }\n\t    return;\n      }\n\n\t// Special case: The Link is unconnected. Put it at the end of\n\t// the current list and move the list_ pointer and nexus_ back\n\t// pointer to suit.\n      if (r.next_ == 0) {\n\t    if (r.get_dir() != Link::INPUT)\n\t\t  driven_ = NO_GUESS;\n\n\t    r.nexus_ = this;\n\t    r.next_ = list_->next_;\n\t    list_->next_ = &r;\n\t    list_->nexus_ = 0;\n\t    list_ = &r;\n\t    return;\n      }\n\n      if (r_nexus->driven_ != Vz)\n\t    driven_ = NO_GUESS;\n\n\t// Splice the list of links from the \"tmp\" nexus to the end of\n\t// this nexus. Adjust the nexus pointers as needed.\n      Link*save_first = list_->next_;\n      list_->next_ = r_nexus->list_->next_;\n      r_nexus->list_->next_ = save_first;\n      list_->nexus_ = 0;\n      list_ = r_nexus->list_;\n      list_->nexus_ = this;\n\n      r_nexus->list_ = 0;\n      delete r_nexus;\n}\n\nvoid connect(Link&l, Link&r)\n{\n      Nexus*tmp;\n      assert(&l != &r);\n\t// If either the l or r link already are part of a Nexus, then\n\t// re-use that nexus. Go through some effort so that we are\n\t// not gratuitously creating Nexus object.\n      if (l.next_ && (tmp=l.find_nexus_())) {\n\t    connect(tmp, r);\n      } else if (r.next_ && (tmp=r.find_nexus_())) {\n\t    connect(tmp, l);\n      } else {\n\t      // No existing Nexus (both links are so far unconnected)\n\t      // so start one.\n\t    tmp = new Nexus(l);\n\t    tmp->connect(r);\n      }\n}\n\nLink::Link()\n: dir_(PASSIVE), drive0_(IVL_DR_STRONG), drive1_(IVL_DR_STRONG),\n  next_(0), nexus_(0)\n{\n      node_ = 0;\n      pin_zero_ = true;\n}\n\nLink::~Link()\n{\n      if (next_) {\n\t    Nexus*tmp = nexus();\n\t    tmp->unlink(this);\n\t    if (tmp->list_ == 0)\n\t\t  delete tmp;\n      }\n}\n\nNexus* Link::find_nexus_() const\n{\n      assert(next_);\n      if (nexus_) return nexus_;\n      for (Link*cur = next_ ; cur != this ; cur = cur->next_) {\n\t    if (cur->nexus_) return cur->nexus_;\n      }\n      return 0;\n}\n\nNexus* Link::nexus()\n{\n      if (next_ == 0) {\n\t    assert(nexus_ == 0);\n\t    Nexus*tmp = new Nexus(*this);\n\t    return tmp;\n      }\n\n      return find_nexus_();\n}\n\nconst Nexus* Link::nexus() const\n{\n      if (next_ == 0) return 0;\n      return find_nexus_();\n}\n\nvoid Link::set_dir(DIR d)\n{\n      dir_ = d;\n}\n\nLink::DIR Link::get_dir() const\n{\n      return dir_;\n}\n\nvoid Link::drivers_delays(NetExpr*rise, NetExpr*fall, NetExpr*decay)\n{\n      find_nexus_()->drivers_delays(rise, fall, decay);\n}\n\nvoid Link::drivers_drive(ivl_drive_t drive0__, ivl_drive_t drive1__)\n{\n      find_nexus_()->drivers_drive(drive0__, drive1__);\n}\n\n\nvoid Link::drive0(ivl_drive_t str)\n{\n      drive0_ = str;\n}\n\nvoid Link::drive1(ivl_drive_t str)\n{\n      drive1_ = str;\n}\n\nivl_drive_t Link::drive0() const\n{\n      return drive0_;\n}\n\nivl_drive_t Link::drive1() const\n{\n      return drive1_;\n}\n\nvoid Link::cur_link(NetPins*&net, unsigned &pin)\n{\n      net = get_obj();\n      pin = get_pin();\n}\n\nvoid Link::cur_link(const NetPins*&net, unsigned &pin) const\n{\n      net = get_obj();\n      pin = get_pin();\n}\n\nvoid Link::unlink()\n{\n      if (! is_linked())\n\t    return;\n\n      find_nexus_()->unlink(this);\n}\n\nbool Link::is_equal(const Link&that) const\n{\n      return (get_obj() == that.get_obj()) && (get_pin() == that.get_pin());\n}\n\nbool Link::is_linked() const\n{\n      if (next_ == 0)\n\t    return false;\n      if (next_ == this)\n\t    return false;\n\n      return true;\n}\n\nbool Link::is_linked(const Link&that) const\n{\n\t// If this or that link is linked to nothing, then they cannot\n\t// be linked to each other.\n      if (! this->is_linked())\n\t    return false;\n      if (! that.is_linked())\n\t    return false;\n\n      const Link*cur = next_;\n      while (cur != this) {\n\t    if (cur == &that) return true;\n\t    cur = cur->next_;\n      }\n\n      return false;\n}\n\nNexus::Nexus(Link&that)\n{\n      name_ = 0;\n      driven_ = NO_GUESS;\n      t_cookie_ = 0;\n\n      if (that.next_ == 0) {\n\t    list_ = &that;\n\t    that.next_ = &that;\n\t    that.nexus_ = this;\n\t    driven_ = NO_GUESS;\n\n      } else {\n\t    Nexus*tmp = that.find_nexus_();\n\t    list_ = tmp->list_;\n\t    list_->nexus_ = this;\n\t    driven_ = tmp->driven_;\n\t    name_ = tmp->name_;\n\n\t    tmp->list_ = 0;\n\t    tmp->name_ = 0;\n\t    delete tmp;\n      }\n}\n\nNexus::~Nexus()\n{\n      assert(list_ == 0);\n      delete[] name_;\n}\n\nbool Nexus::assign_lval() const\n{\n      for (const Link*cur = first_nlink() ; cur ; cur = cur->next_nlink()) {\n\n\t    const NetPins*obj;\n\t    unsigned pin;\n\t    cur->cur_link(obj, pin);\n\t    const NetNet*net = dynamic_cast<const NetNet*> (obj);\n\t    if (net == 0)\n\t\t  continue;\n\n\t    if (net->peek_lref() > 0)\n\t\t  return true;\n      }\n\n      return false;\n}\n\nvoid Nexus::count_io(unsigned&inp, unsigned&out) const\n{\n      for (const Link*cur = first_nlink() ;  cur ; cur = cur->next_nlink()) {\n\t    switch (cur->get_dir()) {\n\t\tcase Link::INPUT:\n\t\t  inp += 1;\n\t\t  break;\n\t\tcase Link::OUTPUT:\n\t\t  out += 1;\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t    }\n      }\n}\n\nbool Nexus::has_floating_input() const\n{\n      bool found_input = false;\n      for (const Link*cur = first_nlink() ;  cur ; cur = cur->next_nlink()) {\n\t    if (cur->get_dir() == Link::OUTPUT)\n\t\t  return false;\n\n\t    if (cur->get_dir() == Link::INPUT)\n\t\t  found_input = true;\n      }\n\n      return found_input;\n}\n\nbool Nexus::drivers_present() const\n{\n      for (const Link*cur = first_nlink() ;  cur ; cur = cur->next_nlink()) {\n\t    if (cur->get_dir() == Link::OUTPUT)\n\t\t  return true;\n\n\t    if (cur->get_dir() == Link::INPUT)\n\t\t  continue;\n\n\t      // Must be PASSIVE, so if it is some kind of net, see if\n\t      // it is the sort that might drive the nexus. Note that\n\t      // supply0/1 and tri0/1 nets are classified as OUTPUT.\n\t    const NetPins*obj;\n\t    unsigned pin;\n\t    cur->cur_link(obj, pin);\n\t    if (const NetNet*net = dynamic_cast<const NetNet*>(obj))\n\t\t  switch (net->type()) {\n\t\t      case NetNet::WAND:\n\t\t      case NetNet::WOR:\n\t\t      case NetNet::TRIAND:\n\t\t      case NetNet::TRIOR:\n\t\t      case NetNet::REG:\n\t\t\treturn true;\n\t\t      default:\n\t\t\tbreak;\n\t\t  }\n      }\n\n      return false;\n}\n\nvoid Nexus::drivers_delays(NetExpr*rise, NetExpr*fall, NetExpr*decay)\n{\n      for (Link*cur = first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t    if (cur->get_dir() != Link::OUTPUT)\n\t\t  continue;\n\n\t    NetObj*obj = dynamic_cast<NetObj*>(cur->get_obj());\n\t    if (obj == 0)\n\t\t  continue;\n\n\t    obj->rise_time(rise);\n\t    obj->fall_time(fall);\n\t    obj->decay_time(decay);\n      }\n}\n\nvoid Nexus::drivers_drive(ivl_drive_t drive0, ivl_drive_t drive1)\n{\n      for (Link*cur = first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t    if (cur->get_dir() != Link::OUTPUT)\n\t\t  continue;\n\n\t    cur->drive0(drive0);\n\t    cur->drive1(drive1);\n      }\n}\n\nvoid Nexus::unlink(Link*that)\n{\n      delete[] name_;\n      name_ = 0;\n\n      assert(that);\n\n\t// Special case: the Link is the only link in the nexus. In\n\t// this case, the unlink is trivial. Also clear the Nexus\n\t// pointers.\n      if (that->next_ == that) {\n\t    assert(that->nexus_ == this);\n\t    assert(list_ == that);\n\t    list_ = 0;\n\t    driven_ = NO_GUESS;\n\t    that->nexus_ = 0;\n\t    that->next_ = 0;\n\t    return;\n      }\n\n\t// If the link I'm removing was a driver for this nexus, then\n\t// cancel my guess of the driven value.\n      if (that->get_dir() != Link::INPUT)\n\t    driven_ = NO_GUESS;\n\n\t// Look for the Link that points to \"that\". We know that there\n\t// will be one because the list is a circle. When we find the\n\t// prev pointer, then remove that from the list.\n      Link*prev = list_;\n      while (prev->next_ != that)\n\t    prev = prev->next_;\n\n      prev->next_ = that->next_;\n\n\t// If \"that\" was the last item in the list, then change the\n\t// list_ pointer to point to the new end of the list.\n      if (list_ == that) {\n\t    assert(that->nexus_ == this);\n\t    list_ = prev;\n\t    list_->nexus_ = this;\n      }\n\n      that->nexus_ = 0;\n      that->next_ = 0;\n}\n\nLink* Nexus::first_nlink()\n{\n      if (list_) return list_->next_;\n      else return 0;\n}\n\nconst Link* Nexus::first_nlink() const\n{\n      if (list_) return list_->next_;\n      else return 0;\n}\n\n/*\n * The t_cookie can be set exactly once. This attaches an ivl_nexus_t\n * object to the Nexus, and causes the Link list to be marked up for\n * efficient use by the code generator. The change is to give all the\n * links a valid nexus_ pointer. This breaks most of the other\n * methods, but they are not used during code generation.\n*/\nvoid Nexus::t_cookie(ivl_nexus_t val) const\n{\n      assert(val && !t_cookie_);\n      t_cookie_ = val;\n\n      for (Link*cur = list_->next_ ; cur->nexus_ == 0 ; cur = cur->next_)\n\t    cur->nexus_ = const_cast<Nexus*> (this);\n}\n\nunsigned Nexus::vector_width() const\n{\n      for (const Link*cur = first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t    const NetNet*sig = dynamic_cast<const NetNet*>(cur->get_obj());\n\t    if (sig == 0)\n\t\t  continue;\n\n\t    return sig->vector_width();\n      }\n\n      return 0;\n}\n\nNetNet* Nexus::pick_any_net()\n{\n      for (Link*cur = first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t    NetNet*sig = dynamic_cast<NetNet*>(cur->get_obj());\n\t    if (sig != 0)\n\t\t  return sig;\n      }\n\n      return 0;\n}\n\nNetNode* Nexus::pick_any_node()\n{\n      for (Link*cur = first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t    NetNode*node = dynamic_cast<NetNode*>(cur->get_obj());\n\t    if (node != 0)\n\t\t  return node;\n      }\n\n      return 0;\n}\n\nconst char* Nexus::name() const\n{\n      if (name_)\n\t    return name_;\n\n      const NetNet*sig = 0;\n      unsigned pin = 0;\n      for (const Link*cur = first_nlink()\n\t\t ;  cur  ;  cur = cur->next_nlink()) {\n\n\t    const NetNet*cursig = dynamic_cast<const NetNet*>(cur->get_obj());\n\t    if (cursig == 0)\n\t\t  continue;\n\n\t    if (sig == 0) {\n\t\t  sig = cursig;\n\t\t  pin = cur->get_pin();\n\t\t  continue;\n\t    }\n\n\t    if ((cursig->pin_count() == 1) && (sig->pin_count() > 1))\n\t\t  continue;\n\n\t    if ((cursig->pin_count() > 1) && (sig->pin_count() == 1)) {\n\t\t  sig = cursig;\n\t\t  pin = cur->get_pin();\n\t\t  continue;\n\t    }\n\n\t    if (cursig->local_flag() && !sig->local_flag())\n\t\t  continue;\n\n\t    if (cursig->name() < sig->name())\n\t\t  continue;\n\n\t    sig = cursig;\n\t    pin = cur->get_pin();\n      }\n\n      if (sig == 0) {\n\t    const Link*lnk = first_nlink();\n\t    const NetObj*obj = dynamic_cast<const NetObj*>(lnk->get_obj());\n\t    pin = lnk->get_pin();\n\t    cerr << \"internal error: No signal for nexus of \"\n\t\t << obj->name() << \" pin \" << pin\n\t\t << \" type=\" << typeid(*obj).name() << \"?\" << endl;\n\n\t    ostringstream tmp;\n\t    tmp << \"nex=\" << this << ends;\n\t    const string tmps = tmp.str();\n\t    name_ = new char[strlen(tmps.c_str()) + 1];\n\t    strcpy(name_, tmps.c_str());\n      } else {\n\t    assert(sig);\n\t    ostringstream tmp;\n\t    tmp << scope_path(sig->scope()) << \".\" << sig->name();\n\t    if (sig->pin_count() > 1)\n\t\t  tmp << \"<\" << pin << \">\";\n\t    tmp << ends;\n\n\t    const string tmps = tmp.str();\n\t    name_ = new char[strlen(tmps.c_str()) + 1];\n\t    strcpy(name_, tmps.c_str());\n      }\n\n      return name_;\n}\n\n\nNexusSet::NexusSet()\n{\n}\n\nNexusSet::~NexusSet()\n{\n      for (size_t idx = 0 ; idx < items_.size() ; idx += 1)\n\t    delete items_[idx];\n}\n\nsize_t NexusSet::size() const\n{\n      return items_.size();\n}\n\nvoid NexusSet::add(Nexus*that, unsigned base, unsigned wid)\n{\n      assert(that);\n      elem_t*cur = new elem_t(that, base, wid);\n\n      if (items_.size() == 0) {\n\t    items_.resize(1);\n\t    items_[0] = cur;\n\t    return;\n      }\n\n      unsigned ptr = bsearch_(*cur);\n      if (ptr < items_.size()) {\n\t    delete cur;\n\t    return;\n      }\n\n      assert(ptr == items_.size());\n\n      items_.push_back(cur);\n}\n\nvoid NexusSet::add(NexusSet&that)\n{\n      for (size_t idx = 0 ;  idx < that.items_.size() ;  idx += 1)\n\t    add(that.items_[idx]->lnk.nexus(), that.items_[idx]->base, that.items_[idx]->wid);\n}\n\nvoid NexusSet::rem_(const NexusSet::elem_t*that)\n{\n      if (items_.empty())\n\t    return;\n\n      unsigned ptr = bsearch_(*that);\n      if (ptr >= items_.size())\n\t    return;\n\n      if (items_.size() == 1) {\n\t    delete items_[0];\n\t    items_.clear();\n\t    return;\n      }\n\n      delete items_[ptr];\n      for (unsigned idx = ptr ;  idx < (items_.size()-1) ;  idx += 1)\n\t    items_[idx] = items_[idx+1];\n\n      items_.pop_back();\n}\n\nvoid NexusSet::rem(const NexusSet&that)\n{\n      for (size_t idx = 0 ;  idx < that.items_.size() ;  idx += 1)\n\t    rem_(that.items_[idx]);\n}\n\nunsigned NexusSet::find_nexus(const NexusSet::elem_t&that) const\n{\n      return bsearch_(that);\n}\n\nNexusSet::elem_t& NexusSet::at (unsigned idx)\n{\n      assert(idx <  items_.size());\n      return *items_[idx];\n}\n\nsize_t NexusSet::bsearch_(const NexusSet::elem_t&that) const\n{\n      for (unsigned idx = 0 ;  idx < items_.size() ;  idx += 1) {\n\t    if (*items_[idx] == that)\n\t\t  return idx;\n      }\n\n      return items_.size();\n}\n\nbool NexusSet::elem_t::contains(const struct elem_t&that) const\n{\n      if (! lnk.is_linked(that.lnk))\n\t    return false;\n      if (that.base < base)\n\t    return false;\n      if ((that.base+that.wid) > (base+wid))\n\t    return false;\n\n      return true;\n}\n\nbool NexusSet::contains_(const NexusSet::elem_t&that) const\n{\n      for (unsigned idx = 0 ; idx < items_.size() ; idx += 1) {\n\t    if (items_[idx]->contains(that))\n\t\t  return true;\n      }\n      return false;\n}\n\nbool NexusSet::contains(const NexusSet&that) const\n{\n      for (size_t idx = 0 ;  idx < that.items_.size() ;  idx += 1) {\n\t    if (! contains_(*that.items_[idx]))\n\t\treturn false;\n      }\n\n      return true;\n}\n\nbool NexusSet::intersect(const NexusSet&that) const\n{\n      for (size_t idx = 0 ;  idx < that.items_.size() ;  idx += 1) {\n\t    size_t where = bsearch_(*that.items_[idx]);\n\t    if (where == items_.size())\n\t\t  continue;\n\n\t    return true;\n      }\n\n      return false;\n}\n"
        },
        {
          "name": "net_modulo.cc",
          "type": "blob",
          "size": 2.06640625,
          "content": "/*\n * Copyright (c) 2000-2010 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <typeinfo>\n# include  <iostream>\n# include  <iomanip>\n# include  <cassert>\n\n# include  \"netlist.h\"\n# include  \"compiler.h\"\n\n/*\n *  0 -- Result\n *  1 -- DataA\n *  2 -- DataB\n */\nNetModulo::NetModulo(NetScope*s, perm_string n, unsigned wr,\n\t\t     unsigned wa, unsigned wb)\n: NetNode(s, n, 3),\n  width_r_(wr), width_a_(wa), width_b_(wb)\n{\n      pin(0).set_dir(Link::OUTPUT); // Result\n      pin(1).set_dir(Link::INPUT);  // DataA\n      pin(2).set_dir(Link::INPUT);  // DataB\n      signed_flag_ = false;\n}\n\nNetModulo::~NetModulo()\n{\n}\n\nunsigned NetModulo::width_r() const\n{\n      return width_r_;\n}\n\nunsigned NetModulo::width_a() const\n{\n      return width_a_;\n}\n\nunsigned NetModulo::width_b() const\n{\n      return width_b_;\n}\n\nLink& NetModulo::pin_Result()\n{\n      return pin(0);\n}\n\nvoid NetModulo::set_signed(bool flag)\n{\n      signed_flag_ = flag;\n}\n\nbool NetModulo::get_signed() const\n{\n      return signed_flag_;\n}\n\nconst Link& NetModulo::pin_Result() const\n{\n      return pin(0);\n}\n\nLink& NetModulo::pin_DataA()\n{\n      return pin(1);\n}\n\nconst Link& NetModulo::pin_DataA() const\n{\n      return pin(1);\n}\n\nLink& NetModulo::pin_DataB()\n{\n      return pin(2);\n}\n\nconst Link& NetModulo::pin_DataB() const\n{\n      return pin(2);\n}\n"
        },
        {
          "name": "net_nex_input.cc",
          "type": "blob",
          "size": 17.728515625,
          "content": "/*\n * Copyright (c) 2002-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n# include  <set>\n# include  <cassert>\n# include  <typeinfo>\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n\nusing namespace std;\n\nNexusSet* NetExpr::nex_input(bool, bool, bool) const\n{\n      cerr << get_fileline()\n\t   << \": internal error: nex_input not implemented: \"\n\t   << *this << endl;\n      return new NexusSet;\n}\n\nNexusSet* NetProc::nex_input(bool, bool, bool) const\n{\n      cerr << get_fileline()\n\t   << \": internal error: NetProc::nex_input not implemented\"\n\t   << endl;\n      return new NexusSet;\n}\n\nNexusSet* NetEArrayPattern::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n      for (size_t idx = 0 ; idx < items_.size() ; idx += 1) {\n\t    if (items_[idx]==0) continue;\n\n\t    NexusSet*tmp = items_[idx]->nex_input(rem_out, always_sens, nested_func);\n\t    if (tmp == 0) continue;\n\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n      return result;\n}\n\nNexusSet* NetEBinary::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = left_->nex_input(rem_out, always_sens, nested_func);\n      NexusSet*tmp = right_->nex_input(rem_out, always_sens, nested_func);\n      result->add(*tmp);\n      delete tmp;\n      return result;\n}\n\nNexusSet* NetEConcat::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      if (parms_[0] == NULL) return new NexusSet;\n      NexusSet*result = parms_[0]->nex_input(rem_out, always_sens, nested_func);\n      for (unsigned idx = 1 ;  idx < parms_.size() ;  idx += 1) {\n\t    if (parms_[idx] == NULL) {\n\t\t  delete result;\n\t\t  return new NexusSet;\n\t    }\n\t    NexusSet*tmp = parms_[idx]->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n      return result;\n}\n\nNexusSet* NetEAccess::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\n/*\n * A constant has not inputs, so always return an empty set.\n */\nNexusSet* NetEConst::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetECReal::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetEEvent::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetELast::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetENetenum::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetENew::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetENull::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetEProperty::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetEScope::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetESelect::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = base_? base_->nex_input(rem_out, always_sens, nested_func) : new NexusSet();\n      NexusSet*tmp = expr_->nex_input(rem_out, always_sens, nested_func);\n      bool const_select = result->size() == 0;\n      if (always_sens && const_select) {\n\t    if (NetEConst *val = dynamic_cast <NetEConst*> (base_)) {\n\t\t  assert(select_type() == IVL_SEL_OTHER);\n\t\t  if (NetESignal *sig = dynamic_cast<NetESignal*> (expr_)) {\n\t\t\tdelete tmp;\n\t\t\ttmp = sig->nex_input_base(rem_out, always_sens, nested_func,\n                                                  val->value().as_unsigned(), expr_width());\n\t\t  } else {\n\t\t\tcerr << get_fileline() << \": Sorry, cannot determine the sensitivity \"\n\t\t\t     << \"for the select of \" << *expr_ << \", using all bits.\" << endl;\n\t\t  }\n\t    }\n      }\n      result->add(*tmp);\n      delete tmp;\n\t/* See the comment for NetESignal below. */\n      if (base_ && ! always_sens && warn_sens_entire_vec) {\n\t    cerr << get_fileline() << \": warning: @* is sensitive to all \"\n\t            \"bits in '\" << *expr_ << \"'.\" << endl;\n      }\n      return result;\n}\n\n/*\n * The $fread, etc. system functions can have NULL arguments.\n */\nNexusSet* NetESFunc::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\n      if (parms_.empty()) return result;\n\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\t    if (parms_[idx]) {\n\t\t  NexusSet*tmp = parms_[idx]->nex_input(rem_out, always_sens, nested_func);\n\t\t  result->add(*tmp);\n\t\t  delete tmp;\n\t    }\n      }\n\n      return result;\n}\n\nNexusSet* NetEShallowCopy::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetESignal::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      return nex_input_base(rem_out, always_sens, nested_func, 0, 0);\n}\n\nNexusSet* NetESignal::nex_input_base(bool rem_out, bool always_sens, bool nested_func,\n                                     unsigned base, unsigned width) const\n{\n\t/*\n\t * This is not what I would expect for the various selects (bit,\n\t * part, index, array). This code adds all the bits/array words\n\t * instead of building the appropriate select and then using it\n\t * as the trigger. Other simulators also add everything.\n\t */\n      bool const_select = false;\n      unsigned const_word = 0;\n      NexusSet*result = new NexusSet;\n\t/* Local signals are not added to the sensitivity list. */\n      if (net_->local_flag()) return result;\n\t/* If we have an array index add it to the sensitivity list. */\n      if (word_) {\n\t    NexusSet*tmp;\n\t    tmp = word_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n            if (!always_sens && warn_sens_entire_arr) {\n                  cerr << get_fileline() << \": warning: @* is sensitive to all \"\n                       << net_->unpacked_count() << \" words in array '\"\n                       << name() << \"'.\" << endl;\n            }\n\t    if (always_sens) if (NetEConst *val = dynamic_cast <NetEConst*> (word_)) {\n\t\t  const_select = true;\n\t\t  const_word = val->value().as_unsigned();\n\t    }\n      }\n\n      if ((base == 0) && (width == 0)) width = net_->vector_width();\n\n      if (const_select) {\n\t    result->add(net_->pin(const_word).nexus(), base, width);\n      } else {\n\t    for (unsigned idx = 0 ;  idx < net_->pin_count() ;  idx += 1)\n\t\t  result->add(net_->pin(idx).nexus(), base, width);\n      }\n\n      return result;\n}\n\nNexusSet* NetETernary::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*tmp;\n      NexusSet*result = cond_->nex_input(rem_out, always_sens, nested_func);\n\n      tmp = true_val_->nex_input(rem_out, always_sens, nested_func);\n      result->add(*tmp);\n      delete tmp;\n\n      tmp = false_val_->nex_input(rem_out, always_sens, nested_func);\n      result->add(*tmp);\n      delete tmp;\n\n      return result;\n}\n\n// Get the contribution of a function call in a always_comb block\nstatic void func_always_sens(NetFuncDef *func, NexusSet *result,\n\t\t\t     bool rem_out, bool nested_func)\n{\n\t  // Avoid recursive function calls.\n\tstatic set<NetFuncDef*> func_set;\n\tif (!nested_func)\n\t      func_set.clear();\n\n\tif (!func_set.insert(func).second)\n\t      return;\n\n\tstd::unique_ptr<NexusSet> tmp(func->proc()->nex_input(rem_out, true, true));\n\t  // Remove the function inputs\n\tstd::unique_ptr<NexusSet> in(new NexusSet);\n\tfor (unsigned idx = 0; idx < func->port_count(); idx++) {\n\t      NetNet *net = func->port(idx);\n\t      assert(net->pin_count() == 1);\n\t      in->add(net->pin(0).nexus(), 0, net->vector_width());\n\t}\n\ttmp->rem(*in);\n\tresult->add(*tmp);\n}\n\nNexusSet* NetEUFunc::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\t    NexusSet*tmp = parms_[idx]->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      if (always_sens)\n\t    func_always_sens(func_->func_def(), result, rem_out, nested_func);\n\n      return result;\n}\n\nNexusSet* NetEUnary::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      return expr_->nex_input(rem_out, always_sens, nested_func);\n}\n\nNexusSet* NetAlloc::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetAssign_::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      assert(! nest_);\n      NexusSet*result = new NexusSet;\n\n      if (word_) {\n\t    NexusSet*tmp = word_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n      if (base_) {\n\t    NexusSet*tmp = base_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\nNexusSet* NetAssignBase::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\t// For the deassign and release statements there is no R-value.\n      if (rval_) {\n\t    NexusSet*tmp = rval_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n\t/* It is possible that the lval_ can have nex_input values. In\n\t   particular, index expressions are statement inputs as well,\n\t   so should be addressed here. */\n      for (NetAssign_*cur = lval_ ;  cur ;  cur = cur->more) {\n\t    NexusSet*tmp = cur->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\n/*\n * The nex_input of a begin/end block is the NexusSet of bits that the\n * block reads from outside the block. That means it is the union of\n * the nex_input for all the substatements.\n *\n * The input set for a sequential set is not exactly the union of the\n * input sets because there is the possibility of intermediate values,\n * that don't deserve to be in the input set. To wit:\n *\n *      begin\n *         t = a + b;\n *         c = ~t;\n *      end\n *\n * In this example, \"t\" should not be in the input set because it is\n * used by the sequence as a temporary value.\n */\nNexusSet* NetBlock::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      if (last_ == 0) return new NexusSet;\n\n      if (! always_sens && (type_ != SEQU)) {\n\t    cerr << get_fileline() << \": internal error: Sorry, \"\n\t\t << \"I don't know how to synthesize fork/join blocks.\"\n\t\t << endl;\n\t    return new NexusSet;\n      }\n\n      NetProc*cur = last_->next_;\n\t/* This is the accumulated input set. */\n      NexusSet*result = new NexusSet;\n\t/* This is an accumulated output set. */\n      NexusSet*prev = new NexusSet;\n\n      do {\n\t      /* Get the inputs for the current statement. */\n\t    NexusSet*tmp = cur->nex_input(rem_out, always_sens, nested_func);\n\n\t      /* Add the current input set to the accumulated input set. */\n\t    result->add(*tmp);\n\t    delete tmp;\n\n\t      /* Add the current outputs to the accumulated output set if\n\t       * they are going to be removed from the input set below. */\n\t    if (rem_out) cur->nex_output(*prev);\n\n\t    cur = cur->next_;\n      } while (cur != last_->next_);\n\n        /* Remove from the input set those bits that are outputs\n           from other statements. They aren't really inputs\n           to the block, just internal intermediate values. */\n      if (rem_out) result->rem(*prev);\n      delete prev;\n\n      return result;\n}\n\n/*\n * The inputs to a case statement are the inputs to the expression,\n * the inputs to all the guards, and the inputs to all the guarded\n * statements.\n */\nNexusSet* NetCase::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = expr_->nex_input(rem_out, always_sens, nested_func);\n\n      for (size_t idx = 0 ;  idx < items_.size() ;  idx += 1) {\n\n\t      /* Skip cases that have empty statements. */\n\t    if (items_[idx].statement == 0)\n\t\t  continue;\n\n\t    NexusSet*tmp = items_[idx].statement->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n\n\t      /* Usually, this is the guard expression. The default\n\t\t case is special and is identified by a null\n\t\t guard. The default guard obviously has no input. */\n\t    if (items_[idx].guard) {\n\t\t  tmp = items_[idx].guard->nex_input(rem_out, always_sens, nested_func);\n\t\t  result->add(*tmp);\n\t\t  delete tmp;\n\t    }\n      }\n\n      return result;\n}\n\nNexusSet* NetCondit::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = expr_->nex_input(rem_out, always_sens, nested_func);\n\n      if (if_ != 0) {\n\t    NexusSet*tmp = if_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      if (else_ != 0) {\n\t    NexusSet*tmp = else_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\nNexusSet* NetDisable::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetDoWhile::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = cond_->nex_input(rem_out, always_sens, nested_func);\n\n      if (proc_) {\n\t    NexusSet*tmp = proc_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\nNexusSet* NetEvTrig::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetEvNBTrig::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\nNexusSet* NetEvWait::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\n      if (statement_) {\n\t    NexusSet*tmp = statement_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\nNexusSet* NetForever::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\n      if (statement_) {\n\t    NexusSet*tmp = statement_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\nNexusSet* NetForLoop::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\n      if (init_expr_) {\n\t    NexusSet*tmp = init_expr_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      if (condition_) {\n\t    NexusSet*tmp = condition_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      if (step_statement_) {\n\t    NexusSet*tmp = step_statement_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      if (statement_) {\n\t    NexusSet*tmp = statement_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      if (gn_shared_loop_index_flag) {\n\t    NexusSet*tmp = new NexusSet();\n\t    for (unsigned idx = 0 ; idx < index_->pin_count() ; idx += 1)\n\t\ttmp->add(index_->pin(idx).nexus(), 0, index_->vector_width());\n\n\t    result->rem(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\nNexusSet* NetFree::nex_input(bool, bool, bool) const\n{\n      return new NexusSet;\n}\n\n/*\n * The NetPDelay statement is a statement of the form\n *\n *   #<expr> <statement>\n *\n * The nex_input set is the input set of the <statement>. Do *not*\n * include the input set of the <expr> because it does not affect the\n * result. The statement can be omitted.\n */\nNexusSet* NetPDelay::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\n      if (statement_) {\n\t    NexusSet*tmp = statement_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\nNexusSet* NetRepeat::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = expr_->nex_input(rem_out, always_sens, nested_func);\n\n      if (statement_) {\n\t    NexusSet*tmp = statement_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n\n/*\n * The $display, etc. system tasks can have NULL arguments.\n */\nNexusSet* NetSTask::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = new NexusSet;\n\n      if (parms_.empty()) return result;\n\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1) {\n\t    if (parms_[idx]) {\n\t\t  NexusSet*tmp = parms_[idx]->nex_input(rem_out, always_sens, nested_func);\n\t\t  result->add(*tmp);\n\t\t  delete tmp;\n\t    }\n      }\n\n      return result;\n}\n\n/*\n * The NetUTask represents a call to a user defined task. There are no\n * parameters to consider, because the compiler already removed them\n * and converted them to blocking assignments.\n */\nNexusSet* NetUTask::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet *result = new NexusSet;\n\n      /*\n       * Let the contents of void functions contribute to the sensitivity list\n       * of always_comb blocks\n       */\n      if (always_sens && task_->type() == NetScope::FUNC)\n\t    func_always_sens(task_->func_def(), result, rem_out, nested_func);\n\n      return result;\n}\n\nNexusSet* NetWhile::nex_input(bool rem_out, bool always_sens, bool nested_func) const\n{\n      NexusSet*result = cond_->nex_input(rem_out, always_sens, nested_func);\n\n      if (proc_) {\n\t    NexusSet*tmp = proc_->nex_input(rem_out, always_sens, nested_func);\n\t    result->add(*tmp);\n\t    delete tmp;\n      }\n\n      return result;\n}\n"
        },
        {
          "name": "net_nex_output.cc",
          "type": "blob",
          "size": 4.603515625,
          "content": "/*\n * Copyright (c) 2002-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include <iostream>\n\n# include  <cassert>\n# include  <typeinfo>\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n\nusing namespace std;\n\nvoid NetProc::nex_output(NexusSet&)\n{\n      cerr << get_fileline()\n\t   << \": internal error: NetProc::nex_output not implemented\"\n\t   << endl;\n      cerr << get_fileline()\n\t   << \":               : on object type \" << typeid(*this).name()\n\t   << endl;\n}\n\nvoid NetAlloc::nex_output(NexusSet&)\n{\n}\n\nvoid NetAssign_::nex_output(NexusSet&out)\n{\n      assert(! nest_);\n      assert(sig_);\n      unsigned use_word = 0;\n      unsigned use_base = 0;\n      unsigned use_wid = lwidth();\n      if (word_) {\n\t    long tmp = 0;\n\t    if (eval_as_long(tmp, word_)) {\n\t\t    // A constant word select, so add the selected word.\n\t\t  use_word = tmp;\n\t    } else {\n\t\t    // A variable word select. The obvious thing to do\n\t\t    // is to add the whole array, but this could cause\n\t\t    // NetBlock::nex_input() to overprune the input set.\n\t\t    // As array access is not yet handled in synthesis,\n\t\t    // I'll leave this as TBD - the output set is not\n\t\t    // otherwise used when elaborating an always @*\n\t\t    // block.\n\t\t  return;\n\t    }\n      }\n      Nexus*nex = sig_->pin(use_word).nexus();\n      if (base_) {\n\n\t      // Unable to evaluate the bit/part select of\n\t      // the l-value, so this is a mux. Pretty\n\t      // sure I don't know how to handle this yet\n\t      // in synthesis, so punt for now.\n\n\t      // Even with constant bit/part select, we want to\n\t      // return the entire signal as an output. The\n\t      // context will need to sort out which bits are\n\t      // actually assigned.\n\t    use_base = 0;\n\t    use_wid = nex->vector_width();\n      }\n      out.add(nex, use_base, use_wid);\n}\n\n/*\n * Assignments have as output all the bits of the concatenated signals\n * of the l-value.\n */\nvoid NetAssignBase::nex_output(NexusSet&out)\n{\n      for (NetAssign_*cur = lval_ ;  cur ;  cur = cur->more) {\n\t    cur->nex_output(out);\n      }\n}\n\nvoid NetBlock::nex_output(NexusSet&out)\n{\n      if (last_ == 0) return;\n\n      NetProc*cur = last_;\n      do {\n\t    cur = cur->next_;\n\t    cur->nex_output(out);\n      } while (cur != last_);\n}\n\nvoid NetCase::nex_output(NexusSet&out)\n{\n      for (size_t idx = 0 ;  idx < items_.size() ;  idx += 1) {\n\n\t      // Empty statements clearly have no output.\n\t    if (items_[idx].statement == 0) continue;\n\n\t    items_[idx].statement->nex_output(out);\n      }\n\n}\n\nvoid NetCondit::nex_output(NexusSet&out)\n{\n      if (if_) if_->nex_output(out);\n      if (else_) else_->nex_output(out);\n}\n\nvoid NetDisable::nex_output(NexusSet&)\n{\n}\n\nvoid NetDoWhile::nex_output(NexusSet&out)\n{\n      if (proc_) proc_->nex_output(out);\n}\n\nvoid NetEvTrig::nex_output(NexusSet&)\n{\n}\n\nvoid NetEvNBTrig::nex_output(NexusSet&)\n{\n}\n\nvoid NetEvWait::nex_output(NexusSet&out)\n{\n      if (statement_) statement_->nex_output(out);\n}\n\nvoid NetForever::nex_output(NexusSet&out)\n{\n      if (statement_) statement_->nex_output(out);\n}\n\nvoid NetForLoop::nex_output(NexusSet&out)\n{\n      if (statement_) statement_->nex_output(out);\n}\n\nvoid NetFree::nex_output(NexusSet&)\n{\n}\n\nvoid NetPDelay::nex_output(NexusSet&out)\n{\n      if (statement_) statement_->nex_output(out);\n}\n\nvoid NetRepeat::nex_output(NexusSet&out)\n{\n      if (statement_) statement_->nex_output(out);\n}\n\n/*\n * For the purposes of synthesis, system task calls have no output at\n * all. This is OK because most system tasks are not synthesizable in\n * the first place.\n */\nvoid NetSTask::nex_output(NexusSet&)\n{\n}\n\n/*\n* Consider a task call to not have any outputs. This is not quite\n* right, we should be listing as outputs all the output ports, but for\n* the purposes that this method is used, this will do for now.\n*/\nvoid NetUTask::nex_output(NexusSet&)\n{\n}\n\nvoid NetWhile::nex_output(NexusSet&out)\n{\n      if (proc_) proc_->nex_output(out);\n}\n"
        },
        {
          "name": "net_proc.cc",
          "type": "blob",
          "size": 5.91796875,
          "content": "/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nNetBlock::NetBlock(Type t, NetScope*ss)\n: type_(t), subscope_(ss), last_(0)\n{\n}\n\nNetBlock::~NetBlock()\n{\n      while (last_ != 0) {\n\t    if (last_->next_ == last_) {\n\t\t  delete last_;\n\t\t  last_ = 0;\n\t    } else {\n\t\t  NetProc*cur = last_->next_;\n\t\t  last_->next_ = cur->next_;\n\t\t  cur->next_ = cur;\n\t\t  delete cur;\n\t    }\n      }\n}\n\nvoid NetBlock::append(NetProc*cur)\n{\n      if (last_ == 0) {\n\t    last_ = cur;\n\t    cur->next_ = cur;\n      } else {\n\t    cur->next_ = last_->next_;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n      }\n}\n\nvoid NetBlock::prepend(NetProc*cur)\n{\n      if (last_ == 0) {\n\t    last_ = cur;\n\t    cur->next_ = cur;\n      } else {\n\t    cur->next_ = last_->next_;\n\t    last_->next_ = cur;\n      }\n}\n\nconst NetProc* NetBlock::proc_first() const\n{\n      if (last_ == 0)\n\t    return 0;\n\n      return last_->next_;\n}\n\nconst NetProc* NetBlock::proc_next(const NetProc*cur) const\n{\n      if (cur == last_)\n\t    return 0;\n\n      return cur->next_;\n}\n\nNetCase::NetCase(ivl_case_quality_t q, NetCase::TYPE c, NetExpr*ex, unsigned cnt)\n: quality_(q), type_(c), expr_(ex), items_(cnt)\n{\n      ivl_assert(*this, expr_);\n}\n\nNetCase::~NetCase()\n{\n      delete expr_;\n      for (size_t idx = 0 ;  idx < items_.size() ;  idx += 1) {\n\t    delete items_[idx].guard;\n\t    if (items_[idx].statement) delete items_[idx].statement;\n      }\n}\n\nNetCase::TYPE NetCase::type() const\n{\n      return type_;\n}\n\nvoid NetCase::set_case(unsigned idx, NetExpr*e, NetProc*p)\n{\n      ivl_assert(*this, idx < items_.size());\n      items_[idx].guard = e;\n      items_[idx].statement = p;\n}\n\nvoid NetCase::prune()\n{\n\t// Test whether the case expression has been padded out\n      NetESelect*padded_expr = dynamic_cast<NetESelect*>(expr_);\n      if ((padded_expr == 0) || (padded_expr->select() != 0))\n\t    return;\n\n\t// If so, run through the case item expressions to find\n\t// the minimum number of bits needed to unambiguously\n\t// select the correct case item.\n      const NetExpr*unpadded_expr = padded_expr->sub_expr();\n      unsigned padded_width = padded_expr->expr_width();\n      unsigned prune_width = unpadded_expr->expr_width();\n      for (unsigned idx = 0; idx < items_.size(); idx += 1) {\n\t      // If there is no guard expression, this is the default\n\t      // case, so skip it.\n\t    if (items_[idx].guard == 0)\n\t\t  continue;\n\n\t      // If the guard expression is not constant, assume\n\t      // all bits are needed, so no pruning can be done.\n\t    NetEConst*gc = dynamic_cast<NetEConst*>(items_[idx].guard);\n\t    if (gc == 0)\n\t\t  return;\n\n\t    unsigned sig_bits = gc->value().significant_bits();\n\t    if (sig_bits > prune_width)\n\t\t  prune_width = sig_bits;\n\n\t      // If all the padding bits are needed, no pruning\n\t      // can be done.\n\t    if (prune_width >= padded_width)\n\t\t  return;\n      }\n      ivl_assert(*this, prune_width < padded_width);\n\n      if (debug_elaborate) {\n\t    cerr << get_fileline() << \": debug: pruning case expressions to \"\n\t\t << prune_width << \" bits.\" << endl;\n      }\n\n\t// Prune the case expression\n      expr_ = pad_to_width(unpadded_expr->dup_expr(), prune_width, *expr_);\n      delete padded_expr;\n\n\t// Prune the case item expressions\n      for (unsigned idx = 0; idx < items_.size(); idx += 1) {\n\t    if (items_[idx].guard == 0)\n\t\t  continue;\n\n\t    NetEConst*gc = dynamic_cast<NetEConst*>(items_[idx].guard);\n\t    ivl_assert(*this, gc);\n\n\t    verinum value(gc->value(), prune_width);\n\t    NetEConst*tmp = new NetEConst(value);\n\t    tmp->set_line(*gc);\n\t    delete gc;\n\n\t    items_[idx].guard = tmp;\n      }\n}\n\nNetDisable::NetDisable(NetScope*tgt, bool flow_control)\n: target_(tgt), flow_control_(flow_control)\n{\n}\n\nNetDisable::~NetDisable()\n{\n}\n\nconst NetScope* NetDisable::target() const\n{\n      return target_;\n}\n\nNetForever::NetForever(NetProc*p)\n: statement_(p)\n{\n}\n\nNetForever::~NetForever()\n{\n      delete statement_;\n}\n\nNetForLoop::NetForLoop(NetNet*ind, NetExpr*iexpr, NetExpr*cond, NetProc*sub, NetProc*step)\n: index_(ind), init_expr_(iexpr), condition_(cond), statement_(sub), step_statement_(step)\n{\n      if (index_ && init_expr_) {\n\t    NetAssign_*lv = new NetAssign_(index_);\n\t    NetAssign*use_init_statement = new NetAssign(lv, init_expr_);\n\t    use_init_statement->set_line(*init_expr_);\n\t    init_statement_ = use_init_statement;\n      } else {\n\t    init_statement_ = nullptr;\n      }\n}\n\nNetForLoop::~NetForLoop()\n{\n      delete init_expr_;\n      delete condition_;\n      delete statement_;\n      delete step_statement_;\n}\n\nNetPDelay::NetPDelay(uint64_t d, NetProc*st)\n: delay_(d), expr_(0), statement_(st)\n{\n}\n\nNetPDelay::NetPDelay(NetExpr*d, NetProc*st)\n: delay_(0), expr_(d), statement_(st)\n{\n}\n\nNetPDelay::~NetPDelay()\n{\n      delete expr_;\n}\n\nuint64_t NetPDelay::delay() const\n{\n      ivl_assert(*this, expr_ == 0);\n      return delay_;\n}\n\nconst NetExpr* NetPDelay::expr() const\n{\n      return expr_;\n}\n\nNetRepeat::NetRepeat(NetExpr*e, NetProc*p)\n: expr_(e), statement_(p)\n{\n}\n\nNetRepeat::~NetRepeat()\n{\n      delete expr_;\n      delete statement_;\n}\n\nconst NetExpr* NetRepeat::expr() const\n{\n      return expr_;\n}\n"
        },
        {
          "name": "net_scope.cc",
          "type": "blob",
          "size": 22.423828125,
          "content": "/*\n * Copyright (c) 2000-2024 Stephen Williams (steve@icarus.com)\n * Copyright (c) 2016 CERN Michele Castellana (michele.castellana@cern.ch)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"compiler.h\"\n\n# include  \"netlist.h\"\n# include  \"netclass.h\"\n# include  \"netenum.h\"\n# include  \"netvector.h\"\n# include  \"PExpr.h\"\n# include  \"PPackage.h\"\n# include  \"PWire.h\"\n# include  <cstring>\n# include  <cstdlib>\n# include  <sstream>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nclass PExpr;\n\nDefinitions::Definitions()\n{\n}\n\nDefinitions::~Definitions()\n{\n}\n\nvoid Definitions::add_enumeration_set(const enum_type_t*key, netenum_t*enum_set)\n{\n      netenum_t*&tmp = enum_sets_[key];\n      assert(tmp == 0);\n      tmp = enum_set;\n}\n\nbool Definitions::add_enumeration_name(netenum_t*enum_set, perm_string name)\n{\n      netenum_t::iterator enum_val = enum_set->find_name(name);\n      assert(enum_val != enum_set->end_name());\n\n      NetEConstEnum*val = new NetEConstEnum(name, enum_set, enum_val->second);\n\n      pair<map<perm_string,NetEConstEnum*>::iterator, bool> cur;\n      cur = enum_names_.insert(make_pair(name,val));\n\n\t// Return TRUE if the name is added (i.e. is NOT a duplicate.)\n      return cur.second;\n}\n\nnetenum_t* Definitions::enumeration_for_key(const enum_type_t*key) const\n{\n      map<const enum_type_t*,netenum_t*>::const_iterator cur;\n\n      cur = enum_sets_.find(key);\n      if (cur != enum_sets_.end())\n\t    return cur->second;\n      else\n\t    return 0;\n}\n\n/*\n * This locates the VALUE for the given enumeration literal.\n */\nconst NetExpr* Definitions::enumeration_expr(perm_string key)\n{\n      map<perm_string,NetEConstEnum*>::const_iterator eidx;\n\n      eidx = enum_names_.find(key);\n      if (eidx != enum_names_.end()) {\n\t    return eidx->second;\n      } else {\n\t    return 0;\n      }\n}\n\nvoid Definitions::add_class(netclass_t*net_class)\n{\n      classes_[net_class->get_name()] = net_class;\n}\n\n/*\n * The NetScope class keeps a scope tree organized. Each node of the\n * scope tree points to its parent, its right sibling and its leftmost\n * child. The root node has no parent or siblings. The node stores the\n * name of the scope. The complete hierarchical name of the scope is\n * formed by appending the path of scopes from the root to the scope\n * in question.\n */\n\nNetScope::NetScope(NetScope*up, const hname_t&n, NetScope::TYPE t, NetScope*in_unit,\n\t\t   bool nest, bool program, bool interface, bool compilation_unit)\n: type_(t), name_(n), nested_module_(nest), program_block_(program),\n  is_interface_(interface), is_unit_(compilation_unit), unit_(in_unit), up_(up)\n{\n      imports_ = 0;\n      events_ = 0;\n      lcounter_ = 0;\n      is_auto_ = false;\n      is_cell_ = false;\n      calls_stask_ = false;\n      in_final_ = false;\n\n      if (compilation_unit)\n\t    unit_ = this;\n\n      if (up) {\n\t    need_const_func_ = up->need_const_func_;\n\t    is_const_func_ = up->is_const_func_;\n\t    time_unit_ = up->time_unit();\n\t    time_prec_ = up->time_precision();\n\t    time_from_timescale_ = up->time_from_timescale();\n\t      // Need to check for duplicate names?\n\t    up_->children_[name_] = this;\n\t    if (unit_ == 0)\n\t\t  unit_ = up_->unit_;\n      } else {\n\t    need_const_func_ = false;\n\t    is_const_func_ = false;\n\t    time_unit_ = 0;\n\t    time_prec_ = 0;\n\t    time_from_timescale_ = false;\n      }\n\n      var_init_ = 0;\n      switch (t) {\n\t  case NetScope::TASK:\n\t    task_ = 0;\n\t    break;\n\t  case NetScope::FUNC:\n\t    func_ = 0;\n\t    break;\n\t  case NetScope::MODULE:\n\t  case NetScope::PACKAGE:\n\t    module_name_ = perm_string();\n\t    break;\n\t  case NetScope::CLASS:\n\t    class_def_ = 0;\n\t    break;\n\t  default:  /* BEGIN_END and FORK_JOIN, do nothing */\n\t    break;\n      }\n      func_pform_ = 0;\n      elab_stage_ = 1;\n      lineno_ = 0;\n      def_lineno_ = 0;\n      genvar_tmp_val = 0;\n      tie_hi_ = 0;\n      tie_lo_ = 0;\n}\n\nNetScope::~NetScope()\n{\n      lcounter_ = 0;\n\n\t/* name_ and module_name_ are perm-allocated. */\n}\n\nvoid NetScope::set_line(const LineInfo*info)\n{\n      file_ = info->get_file();\n      def_file_ = file_;\n      lineno_ = info->get_lineno();\n      def_lineno_ = lineno_;\n}\n\nvoid NetScope::set_line(perm_string file, unsigned lineno)\n{\n      file_ = file;\n      def_file_ = file;\n      lineno_ = lineno;\n      def_lineno_ = lineno;\n}\n\nstring NetScope::get_fileline() const\n{\n      ostringstream buf;\n      buf << (file_? file_ : \"\") << \":\" << lineno_;\n      string res = buf.str();\n      return res;\n}\n\nstring NetScope::get_def_fileline() const\n{\n      ostringstream buf;\n      buf << (def_file_? def_file_ : \"\") << \":\" << def_lineno_;\n      string res = buf.str();\n      return res;\n}\n\nvoid NetScope::set_line(perm_string file, perm_string def_file,\n                        unsigned lineno, unsigned def_lineno)\n{\n      file_ = file;\n      def_file_ = def_file;\n      lineno_ = lineno;\n      def_lineno_ = def_lineno;\n}\n\nvoid NetScope::add_imports(const map<perm_string,PPackage*>*imports)\n{\n      if (!imports->empty())\n\t    imports_ = imports;\n}\n\nNetScope*NetScope::find_import(const Design*des, perm_string name)\n{\n      if (imports_ == 0)\n\t    return 0;\n\n      map<perm_string,PPackage*>::const_iterator cur = imports_->find(name);\n      if (cur != imports_->end()) {\n            return des->find_package(cur->second->pscope_name());\n      } else\n            return 0;\n}\n\nvoid NetScope::add_typedefs(const map<perm_string,typedef_t*>*typedefs)\n{\n      if (!typedefs->empty())\n\t    typedefs_ = *typedefs;\n}\n\nNetScope*NetScope::find_typedef_scope(const Design*des, const typedef_t*type)\n{\n      ivl_assert(*this, type);\n\n      NetScope *cur_scope = this;\n      while (cur_scope) {\n\t    auto it = cur_scope->typedefs_.find(type->name);\n\t    if (it != cur_scope->typedefs_.end() && it->second == type)\n\t\t  return cur_scope;\n\t    NetScope*import_scope = cur_scope->find_import(des, type->name);\n\t    if (import_scope)\n\t\t  cur_scope = import_scope;\n\t    else if (cur_scope == unit_)\n\t\t  return 0;\n\t    else\n\t\t  cur_scope = cur_scope->parent();\n\n\t    if (cur_scope == 0)\n\t\t  cur_scope = unit_;\n      }\n\n      return 0;\n}\n\n/*\n * Attach to the a parameter name in the scope a value and a type. The value\n * (val_expr) is the PExpr form that is not yet elaborated. Later, when\n * elaboration happens, the val_expr is elaborated and written to the val\n * member.\n */\nvoid NetScope::set_parameter(perm_string key, bool is_annotatable,\n\t\t\t     const LexicalScope::param_expr_t &param,\n\t\t\t     NetScope::range_t *range_list)\n{\n      param_expr_t&ref = parameters[key];\n      ref.is_annotatable = is_annotatable;\n      ref.val_expr = param.expr;\n      ref.val_type = param.data_type;\n      ref.val_scope = this;\n      ref.local_flag = param.local_flag;\n      ref.overridable = param.overridable;\n      ref.type_flag = param.type_flag;\n      ref.lexical_pos = param.lexical_pos;\n      ivl_assert(param, !ref.range);\n      ref.range = range_list;\n      ref.val = 0;\n      ref.ivl_type = 0;\n      ref.set_line(param);\n}\n\n/*\n * This is a simplified version of set_parameter, for use when the\n * parameter value is already known. It is currently only used to\n * add a genvar to the parameter list.\n */\nvoid NetScope::set_parameter(perm_string key, NetExpr*val,\n\t\t\t     const LineInfo&file_line)\n{\n      param_expr_t&ref = parameters[key];\n      ref.is_annotatable = false;\n      ref.val_expr = 0;\n      ref.val_type = 0;\n      ref.val_scope = this;\n      ref.ivl_type = netvector_t::integer_type();\n      ivl_assert(file_line, ref.ivl_type);\n      ref.val = val;\n      ref.set_line(file_line);\n}\n\nbool NetScope::auto_name(const char*prefix, char pad, const char* suffix)\n{\n\t// Find the current reference to myself in the parent scope.\n      map<hname_t,NetScope*>::iterator self = up_->children_.find(name_);\n      ivl_assert(*this, self != up_->children_.end());\n      ivl_assert(*this, self->second == this);\n\n\t// This is to keep the pad attempts from being stuck in some\n\t// sort of infinite loop. This should not be a practical\n\t// limit, but an extreme one.\n      const size_t max_pad_attempts = 32 + strlen(prefix);\n\n      string use_prefix = prefix;\n\n\t// Try a variety of potential new names. Make sure the new\n\t// name is not in the parent scope. Keep looking until we are\n\t// sure we have a unique name, or we run out of names to try.\n      while (use_prefix.size() <= max_pad_attempts) {\n\t      // Try this name...\n\t    string tmp = use_prefix + suffix;\n\t    perm_string base_name = lex_strings.make(tmp.c_str());\n\t    hname_t new_name(base_name, name_.peek_numbers());\n\t    if (!up_->child(new_name) && !up_->symbol_exists(base_name)) {\n\t\t    // Ah, this name is unique. Rename myself, and\n\t\t    // change my name in the parent scope.\n\t\t  name_ = new_name;\n\t\t  up_->children_.erase(self);\n\t\t  up_->children_[name_] = this;\n\t\t  return true;\n\t    }\n\n\t      // Name collides, so try a different name.\n\t    use_prefix = use_prefix + pad;\n      }\n      return false;\n}\n\n/*\n * Return false if the parameter does not already exist.\n * A parameter is not automatically created.\n */\nvoid NetScope::replace_parameter(Design *des, perm_string key, PExpr*val,\n\t\t\t         NetScope*scope, bool defparam)\n{\n      if (parameters.find(key) == parameters.end()) {\n\t    cerr << val->get_fileline() << \": error: parameter `\"\n\t         << key << \"` not found in `\"\n\t         << scope_path(this) << \"`.\" << endl;\n\t    des->errors++;\n\t    return;\n      }\n\n      param_expr_t&ref = parameters[key];\n      if (ref.local_flag) {\n\t    cerr << val->get_fileline() << \": error: \"\n\t         << \"Cannot override localparam `\" << key << \"` in `\"\n\t         << scope_path(this) << \"`.\" << endl;\n\t    des->errors++;\n\t    return;\n      }\n      if (!ref.overridable) {\n\t    cerr << val->get_fileline() << \": error: \"\n\t\t << \"Cannot override parameter `\" << key << \"` in `\"\n\t\t << scope_path(this) << \"`. Parameter cannot be overridden \"\n\t\t << \"in the scope it has been declared in.\"\n\t\t << endl;\n\t    des->errors++;\n\t    return;\n      }\n\n      if (ref.type_flag && defparam) {\n\t    cerr << val->get_fileline() << \": error: \"\n\t\t << \"Cannot override type parameter `\" << key << \"` in `\"\n\t\t << scope_path(this) << \"`. It is not allowed to override type\"\n\t\t << \" parameters using a defparam statement.\"\n\t\t << endl;\n\t    des->errors++;\n\t    return;\n      }\n\n      ref.val_expr = val;\n      ref.val_scope = scope;\n}\n\nbool NetScope::make_parameter_unannotatable(perm_string key)\n{\n      bool flag = false;\n\n      if (parameters.find(key) != parameters.end()) {\n\t    param_expr_t&ref = parameters[key];\n\t    flag = ref.is_annotatable;\n\t    ref.is_annotatable = false;\n      }\n\n      return flag;\n}\n\n/*\n * NOTE: This method takes a const char* as a key to lookup a\n * parameter, because we don't save that pointer. However, due to the\n * way the map<> template works, we need to *cheat* and use the\n * perm_string::literal method to fake the compiler into doing the\n * compare without actually creating a perm_string.\n */\nconst NetExpr* NetScope::get_parameter(Design*des, const char* key,\n\t\t\t\t       ivl_type_t&ivl_type)\n{\n      return get_parameter(des, perm_string::literal(key), ivl_type);\n}\n\nconst NetExpr* NetScope::get_parameter(Design*des, perm_string key,\n\t\t\t\t       ivl_type_t&ivl_type)\n{\n      map<perm_string,param_expr_t>::iterator idx;\n\n      idx = parameters.find(key);\n      if (idx != parameters.end()) {\n            if (idx->second.val_expr)\n                  evaluate_parameter_(des, idx);\n\n\t    ivl_type = idx->second.ivl_type;\n\t    return idx->second.val;\n      }\n\n      ivl_type = 0;\n      const NetExpr*tmp = enumeration_expr(key);\n      return tmp;\n}\n\nLineInfo NetScope::get_parameter_line_info(perm_string key) const\n{\n      map<perm_string,param_expr_t>::const_iterator idx;\n\n      idx = parameters.find(key);\n      if (idx != parameters.end()) return idx->second;\n\n\t// To get here the parameter must already exist, so we should\n\t// never get here.\n      assert(0);\n\t// But return something to avoid a compiler warning.\n      return LineInfo();\n}\n\nunsigned NetScope::get_parameter_lexical_pos(perm_string key) const\n{\n      map<perm_string,param_expr_t>::const_iterator idx;\n\n      idx = parameters.find(key);\n      if (idx != parameters.end()) return idx->second.lexical_pos;\n\n\t// If we get here, assume an enumeration value.\n      return 0;\n}\n\nvoid NetScope::print_type(ostream&stream) const\n{\n      switch (type_) {\n\tcase BEGIN_END:\n\t    stream << \"sequential block\";\n\t    break;\n\tcase FORK_JOIN:\n\t    stream << \"parallel block\";\n\t    break;\n\tcase FUNC:\n\t    stream << \"function\";\n\t    break;\n\tcase MODULE:\n\t    stream << \"module <\" << module_name_ << \"> instance\";\n\t    break;\n\tcase TASK:\n\t    stream << \"task\";\n\t    break;\n\tcase GENBLOCK:\n\t    stream << \"generate block\";\n\t    break;\n\tcase PACKAGE:\n\t    stream << \"package \" << module_name_;\n\t    break;\n\tcase CLASS:\n\t    stream << \"class\";\n\t    break;\n      }\n}\n\nvoid NetScope::set_task_def(NetTaskDef*def)\n{\n      ivl_assert(*this, type_ == TASK);\n      ivl_assert(*this, task_ == nullptr);\n      task_ = def;\n}\n\nNetTaskDef* NetScope::task_def()\n{\n      ivl_assert(*this, type_ == TASK);\n      return task_;\n}\n\nconst NetTaskDef* NetScope::task_def() const\n{\n      ivl_assert(*this, type_ == TASK);\n      return task_;\n}\n\nvoid NetScope::set_func_def(NetFuncDef*def)\n{\n      ivl_assert(*this, type_ == FUNC);\n      ivl_assert(*this, func_ == nullptr);\n      func_ = def;\n}\n\nNetFuncDef* NetScope::func_def()\n{\n      ivl_assert(*this, type_ == FUNC);\n      return func_;\n}\n\nbool NetScope::in_func() const\n{\n      return (type_ == FUNC) ? true : false;\n}\n\nconst NetFuncDef* NetScope::func_def() const\n{\n      ivl_assert(*this, type_ == FUNC);\n      return func_;\n}\n\nvoid NetScope::set_class_def(netclass_t*def)\n{\n      ivl_assert(*this, type_ == CLASS);\n      ivl_assert(*this, class_def_ == nullptr);\n      class_def_ = def;\n}\n\nconst netclass_t* NetScope::class_def(void) const\n{\n      if (type_==CLASS)\n\t    return class_def_;\n      else\n\t    return 0;\n}\n\nvoid NetScope::set_module_name(perm_string n)\n{\n      ivl_assert(*this, type_==MODULE || type_==PACKAGE);\n      module_name_ = n;\n}\n\nperm_string NetScope::module_name() const\n{\n      ivl_assert(*this, type_==MODULE || type_==PACKAGE);\n      return module_name_;\n}\n\nvoid NetScope::set_num_ports(unsigned int num_ports)\n{\n    ivl_assert(*this, type_ == MODULE);\n    ivl_assert(*this, ports_.empty());\n    ports_.resize( num_ports );\n}\n\nvoid NetScope::add_module_port_net(NetNet*subport)\n{\n      ivl_assert(*this, type_ == MODULE);\n      port_nets.push_back(subport);\n}\n\n\nvoid NetScope::add_module_port_info( unsigned idx, perm_string name, PortType::Enum ptype,\n                                unsigned long width )\n{\n      ivl_assert(*this, type_ == MODULE);\n      ivl_assert(*this, ports_.size() > idx);\n      PortInfo &info = ports_[idx];\n      info.name = name;\n      info.type = ptype;\n      info.width = width;\n      info.buffer = nullptr;\n}\n\nPortInfo* NetScope::get_module_port_info( unsigned idx )\n{\n      ivl_assert(*this, type_ == MODULE);\n      ivl_assert(*this, ports_.size() > idx);\n      return &ports_[idx];\n}\n\nunsigned NetScope::module_port_nets() const\n{\n      ivl_assert(*this, type_ == MODULE);\n      return port_nets.size();\n}\n\n\nconst std::vector<PortInfo> & NetScope::module_port_info() const\n{\n      ivl_assert(*this, type_ == MODULE);\n      return ports_;\n}\n\n\n\nNetNet* NetScope::module_port_net(unsigned idx) const\n{\n      ivl_assert(*this, type_ == MODULE);\n      ivl_assert(*this, idx < port_nets.size());\n      return port_nets[idx];\n}\n\nvoid NetScope::time_unit(int val)\n{\n      time_unit_ = val;\n}\n\nvoid NetScope::time_precision(int val)\n{\n      time_prec_ = val;\n}\n\nvoid NetScope::time_from_timescale(bool val)\n{\n      time_from_timescale_ = val;\n}\n\nint NetScope::time_unit() const\n{\n      return time_unit_;\n}\n\nint NetScope::time_precision() const\n{\n      return time_prec_;\n}\n\nbool NetScope::time_from_timescale() const\n{\n      return time_from_timescale_;\n}\n\nperm_string NetScope::basename() const\n{\n      return name_.peek_name();\n}\n\nvoid NetScope::add_event(NetEvent*ev)\n{\n      ivl_assert(*this, ev->scope_ == nullptr);\n      ev->scope_ = this;\n      ev->snext_ = events_;\n      events_ = ev;\n}\n\nvoid NetScope::rem_event(NetEvent*ev)\n{\n      ivl_assert(*this, ev->scope_ == this);\n      ev->scope_ = 0;\n      if (events_ == ev) {\n\t    events_ = ev->snext_;\n\n      } else {\n\t    NetEvent*cur = events_;\n\t    while (cur->snext_ != ev) {\n\t\t  ivl_assert(*this, cur->snext_);\n\t\t  cur = cur->snext_;\n\t    }\n\t    cur->snext_ = ev->snext_;\n      }\n\n      ev->snext_ = 0;\n}\n\n\nNetEvent* NetScope::find_event(perm_string name)\n{\n      for (NetEvent*cur = events_;  cur ;  cur = cur->snext_)\n\t    if (cur->name() == name)\n\t\t  return cur;\n\n      return 0;\n}\n\nvoid NetScope::add_genvar(perm_string name, LineInfo *li)\n{\n      ivl_assert(*li, (type_ == MODULE) || (type_ == GENBLOCK));\n      genvars_[name] = li;\n}\n\nLineInfo* NetScope::find_genvar(perm_string name)\n{\n      if (genvars_.find(name) != genvars_.end())\n\t    return genvars_[name];\n      else\n            return 0;\n}\n\nvoid NetScope::add_signal_placeholder(PWire*wire)\n{\n      signal_placeholders_[wire->basename()] = wire;\n}\n\nvoid NetScope::rem_signal_placeholder(PWire*wire)\n{\n      signal_placeholders_.erase(wire->basename());\n}\n\nPWire* NetScope::find_signal_placeholder(perm_string name)\n{\n      if (signal_placeholders_.find(name) != signal_placeholders_.end())\n\t    return signal_placeholders_[name];\n      else\n\t    return 0;\n}\n\nvoid NetScope::add_signal(NetNet*net)\n{\n      signals_map_[net->name()]=net;\n}\n\nvoid NetScope::rem_signal(NetNet*net)\n{\n      ivl_assert(*this, net->scope() == this);\n      signals_map_.erase(net->name());\n}\n\n/*\n * This method looks for a signal within the current scope. The name\n * is assumed to be the base name of the signal, so no sub-scopes are\n * searched.\n */\nNetNet* NetScope::find_signal(perm_string key)\n{\n      if (signals_map_.find(key)!=signals_map_.end())\n\t    return signals_map_[key];\n      else\n\t    return 0;\n}\n\nnetclass_t*NetScope::find_class(const Design*des, perm_string name)\n{\n\t// Special case: The scope itself is the class that we are\n\t// looking for. This may happen for example when elaborating\n\t// methods within the class.\n      if (type_==CLASS && name_==hname_t(name))\n\t    return class_def_;\n\n\t// Look for the class directly within this scope.\n      map<perm_string,netclass_t*>::const_iterator cur = classes_.find(name);\n      if (cur != classes_.end())\n\t    return cur->second;\n\n        // Try the imports.\n      NetScope*import_scope = find_import(des, name);\n      if (import_scope)\n            return import_scope->find_class(des, name);\n\n      if (up_==0 && type_==CLASS) {\n\t    ivl_assert(*this, class_def_);\n\n\t    NetScope*def_parent = class_def_->definition_scope();\n\t    return def_parent->find_class(des, name);\n      }\n\n\t// Try looking up for the class.\n      if (up_!=0 && type_!=MODULE)\n\t    return up_->find_class(des, name);\n\n\t// Try the compilation unit.\n      if (unit_ != 0 && this != unit_)\n\t    return unit_->find_class(des, name);\n\n\t// Nowhere left to try...\n      return 0;\n}\n\n/*\n * This method locates a child scope by name. The name is the simple\n * name of the child, no hierarchy is searched.\n */\nNetScope* NetScope::child(const hname_t&name)\n{\n      map<hname_t,NetScope*>::iterator cur = children_.find(name);\n      if (cur == children_.end())\n\t    return 0;\n      else\n\t    return cur->second;\n}\n\nconst NetScope* NetScope::child(const hname_t&name) const\n{\n      map<hname_t,NetScope*>::const_iterator cur = children_.find(name);\n      if (cur == children_.end())\n\t    return 0;\n      else\n\t    return cur->second;\n}\n\n/* Helper function to see if the given scope is defined in a class and if\n * so return the class scope. */\nconst NetScope* NetScope::get_class_scope() const\n{\n      const NetScope*scope = this;\n      while (scope) {\n\t    switch(scope->type()) {\n\t\tcase NetScope::CLASS:\n\t\t  return scope;\n\t\tcase NetScope::TASK:\n\t\tcase NetScope::FUNC:\n\t\tcase NetScope::BEGIN_END:\n\t\tcase NetScope::FORK_JOIN:\n\t\t  break;\n\t\tcase NetScope::MODULE:\n\t\tcase NetScope::GENBLOCK:\n\t\tcase NetScope::PACKAGE:\n\t\t  return 0;\n\t\tdefault:\n\t\t  ivl_assert(*this, 0);\n\t    }\n\t    scope = scope->parent();\n      }\n      return scope;\n}\n\nconst NetScope* NetScope::child_byname(perm_string name) const\n{\n      hname_t hname (name);\n      map<hname_t,NetScope*>::const_iterator cur = children_.lower_bound(hname);\n\n      if (cur == children_.end())\n\t    return 0;\n\n      if (cur->first.peek_name() == name)\n\t    return cur->second;\n\n      return 0;\n}\n\n\nbool NetScope::symbol_exists(perm_string sym)\n{\n      if (signals_map_.find(sym) != signals_map_.end())\n            return true;\n      if (parameters.find(sym) != parameters.end())\n            return true;\n      if (genvars_.find(sym) != genvars_.end())\n            return true;\n      if (classes_.find(sym) != classes_.end())\n          return true;\n      if (typedefs_.find(sym) != typedefs_.end())\n          return true;\n      if (find_event(sym))\n          return true;\n\n      return false;\n}\n\nperm_string NetScope::local_symbol()\n{\n      perm_string sym;\n      do {\n\t    ostringstream res;\n\t    res << \"_ivl_\" << (lcounter_++);\n\t    perm_string sym_tmp = lex_strings.make(res.str());\n\n\t      // If the name already exists, try again.\n\t    if (symbol_exists(sym_tmp))\n\t\t  continue;\n\n\t      // No collisions, this is the one.\n\t    sym = sym_tmp;\n      } while (sym.nil());\n      return sym;\n}\n\nvoid NetScope::add_tie_hi(Design*des)\n{\n      if (tie_hi_ == 0) {\n\t    NetNet*sig = new NetNet(this, lex_strings.make(\"_LOGIC1\"),\n\t\t\t\t    NetNet::WIRE, &netvector_t::scalar_logic);\n\t    sig->local_flag(true);\n\n\t    tie_hi_ = new NetLogic(this, local_symbol(),\n\t\t\t\t   1, NetLogic::PULLUP, 1);\n\t    des->add_node(tie_hi_);\n\n\t    connect(sig->pin(0), tie_hi_->pin(0));\n      }\n}\n\nvoid NetScope::add_tie_lo(Design*des)\n{\n      if (tie_lo_ == 0) {\n\t    NetNet*sig = new NetNet(this, lex_strings.make(\"_LOGIC0\"),\n\t\t\t\t    NetNet::WIRE, &netvector_t::scalar_logic);\n\t    sig->local_flag(true);\n\n\t    tie_lo_ = new NetLogic(this, local_symbol(),\n\t\t\t\t   1, NetLogic::PULLDOWN, 1);\n\t    des->add_node(tie_lo_);\n\n\t    connect(sig->pin(0), tie_lo_->pin(0));\n      }\n}\n"
        },
        {
          "name": "net_tran.cc",
          "type": "blob",
          "size": 4.8095703125,
          "content": "/*\n * Copyright (c) 2008-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include <iostream>\n\n# include  <typeinfo>\n# include  <cstdlib>\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"ivl_target_priv.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nstatic bool has_enable(ivl_switch_type_t tt)\n{\n      switch (tt) {\n\t  case IVL_SW_TRANIF0:\n\t  case IVL_SW_TRANIF1:\n\t  case IVL_SW_RTRANIF0:\n\t  case IVL_SW_RTRANIF1:\n\t    return true;\n\t  default:\n\t    return false;\n      }\n}\n\nNetTran::NetTran(NetScope*scope__, perm_string n, ivl_switch_type_t tt,\n                 unsigned width)\n: NetNode(scope__, n, has_enable(tt)? 3 : 2), type_(tt), wid_(width)\n{\n      pin(0).set_dir(Link::PASSIVE);\n      pin(1).set_dir(Link::PASSIVE);\n      if (pin_count() == 3) {\n\t    pin(2).set_dir(Link::INPUT); // Enable\n      }\n      part_ = 0;\n      off_ = 0;\n}\n\nNetTran::NetTran(NetScope*scope__, perm_string n, unsigned wid, unsigned part, unsigned off)\n: NetNode(scope__, n, 2), type_(IVL_SW_TRAN_VP), wid_(wid), part_(part), off_(off)\n{\n      pin(0).set_dir(Link::PASSIVE);\n      pin(1).set_dir(Link::PASSIVE);\n}\n\nNetTran::~NetTran()\n{\n}\n\nunsigned NetTran::vector_width() const\n{\n      return wid_;\n}\n\nunsigned NetTran::part_width() const\n{\n      return part_;\n}\n\nunsigned NetTran::part_offset() const\n{\n      return off_;\n}\n\nvoid join_island(NetPins*obj)\n{\n      IslandBranch*branch = dynamic_cast<IslandBranch*> (obj);\n\n\t// If this is not even a branch, then stop now.\n      if (branch == 0)\n\t    return;\n\n\t// If this is a branch, but already given to an island, then\n\t// stop.\n      if (branch->island_)\n\t    return;\n\n      list<NetObj*> uncommitted_neighbors;\n\n\t// Look for neighboring objects that might already be in\n\t// islands. If we find something, then join that island.\n      for (unsigned idx = 0 ; idx < obj->pin_count() ; idx += 1) {\n\t    Nexus*nex = obj->pin(idx).nexus();\n\t    for (Link*cur = nex->first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t\t  unsigned pin;\n\t\t  NetPins*tmp_pins;\n\t\t  cur->cur_link(tmp_pins, pin);\n\n\t\t  NetObj*tmp = dynamic_cast<NetObj*> (tmp_pins);\n\t\t  if (tmp == 0)\n\t\t\tcontinue;\n\n\t\t    // Skip self.\n\t\t  if (tmp == obj)\n\t\t\tcontinue;\n\n\t\t    // If tmp is not a branch, then skip it.\n\t\t  IslandBranch*tmp_branch = dynamic_cast<IslandBranch*> (tmp);\n\t\t  if (tmp_branch == 0)\n\t\t\tcontinue;\n\n\t\t    // If tmp is an uncommitted branch, then save\n\t\t    // it. When I finally choose an island for self,\n\t\t    // these branches will be scanned so that they join\n\t\t    // this island as well.\n\t\t  if (tmp_branch->island_ == 0) {\n\t\t\tuncommitted_neighbors.push_back(tmp);\n\t\t\tcontinue;\n\t\t  }\n\n\t\t  ivl_assert(*obj, branch->island_==0 || branch->island_==tmp_branch->island_);\n\n\t\t    // We found an existing island to join. Join it\n\t\t    // now. Keep scanning in order to find more neighbors.\n\t\t  if (branch->island_ == 0) {\n\t\t\tif (debug_elaborate)\n\t\t\t      cerr << obj->get_fileline() << \": debug: \"\n\t\t\t\t   << \"Join branch to existing island.\" << endl;\n\t\t\tbranch->island_ = tmp_branch->island_;\n\t\t\tivl_assert(*obj, branch->island_->discipline == tmp_branch->island_->discipline);\n\n\t\t  } else if (branch->island_ != tmp_branch->island_) {\n\t\t\tcerr << obj->get_fileline() << \": internal error: \"\n\t\t\t     << \"Oops, Found 2 neighboring islands.\" << endl;\n\t\t\tivl_assert(*obj, 0);\n\t\t  }\n\t    }\n      }\n\n\t// If after all that we did not find an island to join, then\n\t// start the island not and join it.\n      if (branch->island_ == 0) {\n\t    branch->island_ = new ivl_island_s;\n\t    branch->island_->discipline = branch->discipline_;\n\t    if (debug_elaborate)\n\t\t  cerr << obj->get_fileline() << \": debug: \"\n\t\t       << \"Create new island for this branch\" << endl;\n      }\n\n\t// Now scan all the uncommitted neighbors I found. Calling\n\t// join_island() on them will cause them to notice me in the\n\t// process, and thus they will join my island. This process\n\t// will recurse until all the connected branches join this island.\n      for (list<NetObj*>::iterator cur = uncommitted_neighbors.begin()\n\t\t ; cur != uncommitted_neighbors.end() ; ++ cur ) {\n\t    join_island(*cur);\n      }\n}\n"
        },
        {
          "name": "net_udp.cc",
          "type": "blob",
          "size": 2.4013671875,
          "content": "/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n * Copyright (c) 2001 Stephan Boettcher <stephan@nevis.columbia.edu>\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n\nusing namespace std;\n\nNetUDP::NetUDP(NetScope*s, perm_string n, unsigned pins, PUdp *u)\n  : NetNode(s, n, pins), udp(u)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      for (unsigned idx = 1 ;  idx < pins ;  idx += 1) {\n\t    pin(idx).set_dir(Link::INPUT);\n      }\n      table_idx = udp->tinput.size() - 1;\n}\n\nbool NetUDP::first(string&inp, char&out) const\n{\n      table_idx = (unsigned) -1;\n      return next(inp, out);\n}\n\nbool NetUDP::next(string&inp, char&out) const\n{\n      table_idx++;\n\n      if (table_idx >= udp->tinput.size()) return false;\n\n      if (is_sequential()) {\n\t    inp = string(\"\") + udp->tcurrent[table_idx] +\n\t          udp->tinput[table_idx];\n\t    assert(inp.length() == pin_count());\n      } else {\n\t    inp = udp->tinput[table_idx];\n\t    assert(inp.length() == (pin_count()-1));\n      }\n\n      out = udp->toutput[table_idx];\n      assert((out == '0') ||\n             (out == '1') ||\n             (out == 'x') ||\n             (is_sequential() && (out == '-')));\n\n      return true;\n}\n\nchar NetUDP::get_initial() const\n{\n      assert (is_sequential());\n\n      switch (udp->initial) {\n\tcase verinum::V0:\n\t    return '0';\n\tcase verinum::V1:\n\t    return '1';\n\tcase verinum::Vx:\n\tcase verinum::Vz:\n\t    return 'x';\n      }\n\n      assert(0);\n      return 'x';\n}\n\nunsigned NetUDP::port_count() const\n{\n      return udp->ports.size();\n}\n\nstring NetUDP::port_name(unsigned idx) const\n{\n      assert(idx < udp->ports.size());\n      return udp->ports[idx];\n}\n"
        },
        {
          "name": "netclass.cc",
          "type": "blob",
          "size": 5.912109375,
          "content": "/*\n * Copyright (c) 2012-2017 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netclass.h\"\n# include  \"netlist.h\"\n# include  <iostream>\n\nusing namespace std;\n\nnetclass_t::netclass_t(perm_string name, const netclass_t*super)\n: name_(name), super_(super), class_scope_(0), definition_scope_(0), virtual_class_(false)\n{\n}\n\nnetclass_t::~netclass_t()\n{\n}\n\nbool netclass_t::set_property(perm_string pname, property_qualifier_t qual,\n\t\t\t      ivl_type_t ptype)\n{\n      map<perm_string,size_t>::const_iterator cur;\n      cur = properties_.find(pname);\n      if (cur != properties_.end())\n\t    return false;\n\n      prop_t tmp;\n      tmp.name = pname;\n      tmp.qual = qual;\n      tmp.type = ptype;\n      tmp.initialized_flag = false;\n      property_table_.push_back(tmp);\n\n      properties_[pname] = property_table_.size()-1;\n      return true;\n}\n\nvoid netclass_t::set_class_scope(NetScope*class_scope__)\n{\n      assert(class_scope_ == 0);\n      class_scope_ = class_scope__;\n}\n\nvoid netclass_t::set_definition_scope(NetScope*use_definition_scope)\n{\n      assert(definition_scope_ == 0);\n      definition_scope_ = use_definition_scope;\n}\n\nivl_variable_type_t netclass_t::base_type() const\n{\n      return IVL_VT_CLASS;\n}\n\nsize_t netclass_t::get_properties(void) const\n{\n      size_t res = properties_.size();\n      if (super_) res += super_->get_properties();\n      return res;\n}\n\nint netclass_t::property_idx_from_name(perm_string pname) const\n{\n      map<perm_string,size_t>::const_iterator cur;\n      cur = properties_.find(pname);\n      if (cur == properties_.end()) {\n\t    if (super_)\n\t\t  return super_->property_idx_from_name(pname);\n\t    else\n\t\t  return -1;\n      }\n\n      int pidx = cur->second;\n      if (super_) pidx += super_->get_properties();\n      return pidx;\n}\n\nconst char*netclass_t::get_prop_name(size_t idx) const\n{\n      size_t super_size = 0;\n      if (super_) super_size = super_->get_properties();\n\n      assert(idx < (super_size + property_table_.size()));\n      if (idx < super_size)\n\t    return super_->get_prop_name(idx);\n      else\n\t    return property_table_[idx-super_size].name;\n}\n\nproperty_qualifier_t netclass_t::get_prop_qual(size_t idx) const\n{\n      size_t super_size = 0;\n      if (super_) super_size = super_->get_properties();\n\n      assert(idx < (super_size+property_table_.size()));\n      if (idx < super_size)\n\t    return super_->get_prop_qual(idx);\n      else\n\t    return property_table_[idx-super_size].qual;\n}\n\nivl_type_t netclass_t::get_prop_type(size_t idx) const\n{\n      size_t super_size = 0;\n      if (super_) super_size = super_->get_properties();\n\n      assert(idx < (super_size+property_table_.size()));\n      if (idx < super_size)\n\t    return super_->get_prop_type(idx);\n      else\n\t    return property_table_[idx-super_size].type;\n}\n\nbool netclass_t::get_prop_initialized(size_t idx) const\n{\n      size_t super_size = 0;\n      if (super_) super_size = super_->get_properties();\n\n      assert(idx < (super_size+property_table_.size()));\n      if (idx < super_size)\n\t    return super_->get_prop_initialized(idx);\n      else\n\t    return property_table_[idx].initialized_flag;\n}\n\nvoid netclass_t::set_prop_initialized(size_t idx) const\n{\n      size_t super_size = 0;\n      if (super_) super_size = super_->get_properties();\n\n      assert(idx >= super_size && idx < (super_size+property_table_.size()));\n      idx -= super_size;\n\n      assert(! property_table_[idx].initialized_flag);\n      property_table_[idx].initialized_flag = true;\n}\n\nbool netclass_t::test_for_missing_initializers() const\n{\n      for (size_t idx = 0 ; idx < property_table_.size() ; idx += 1) {\n\t    if (property_table_[idx].initialized_flag)\n\t\t  continue;\n\t    if (property_table_[idx].qual.test_const())\n\t\t  return true;\n      }\n\n      return false;\n}\n\nNetScope*netclass_t::method_from_name(perm_string name) const\n{\n      NetScope*task = class_scope_->child( hname_t(name) );\n      if ((task == 0) && super_)\n\t    task = super_->method_from_name(name);\n      return task;\n\n}\n\nNetScope* netclass_t::get_constructor() const\n{\n      auto task = class_scope_->child(hname_t(perm_string::literal(\"new\")));\n      if (task)\n\t    return task;\n\n      task = class_scope_->child(hname_t(perm_string::literal(\"new@\")));\n      if (task)\n\t    return task;\n\n      if (super_)\n\t    return super_->get_constructor();\n\n      return nullptr;\n}\n\nNetNet* netclass_t::find_static_property(perm_string name) const\n{\n      NetNet *net = class_scope_->find_signal(name);\n      if (net)\n\t    return net;\n\n      if (super_)\n\t    return super_->find_static_property(name);\n\n      return nullptr;\n}\n\nbool netclass_t::test_scope_is_method(const NetScope*scope) const\n{\n      while (scope && scope != class_scope_) {\n\t    scope = scope->parent();\n      }\n\n      if (scope == 0)\n\t    return false;\n      else\n\t    return true;\n}\n\nconst NetExpr* netclass_t::get_parameter(Design *des, perm_string name,\n\t\t\t\t\t ivl_type_t &par_type) const\n{\n      return class_scope_->get_parameter(des, name, par_type);\n}\n\nbool netclass_t::test_compatibility(ivl_type_t that) const\n{\n      for (const netclass_t *class_type = dynamic_cast<const netclass_t *>(that);\n\t    class_type; class_type = class_type->get_super()) {\n\t    if (class_type == this)\n\t\t  return true;\n      }\n\n      return false;\n}\n"
        },
        {
          "name": "netclass.h",
          "type": "blob",
          "size": 5.40234375,
          "content": "#ifndef IVL_netclass_H\n#define IVL_netclass_H\n/*\n * Copyright (c) 2012-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"LineInfo.h\"\n# include  \"ivl_target.h\"\n# include  \"nettypes.h\"\n# include  \"property_qual.h\"\n# include  <iostream>\n# include  <map>\n\nclass Design;\nclass NetExpr;\nclass NetNet;\nclass NetScope;\nclass PClass;\nclass PExpr;\n\nclass netclass_t : public ivl_type_s {\n    public:\n      netclass_t(perm_string class_name, const netclass_t*super);\n      ~netclass_t();\n\n\t// Set the property of the class during elaboration. Set the\n\t// name and type, and return true. If the name is already\n\t// present, then return false.\n      bool set_property(perm_string pname, property_qualifier_t qual, ivl_type_t ptype);\n\n\t// Set the scope for the class. The scope has no parents and\n\t// is used for the elaboration of methods\n\t// (tasks/functions). In other words, this is the class itself.\n      void set_class_scope(NetScope*cscope);\n\n      inline const NetScope* class_scope(void) const { return class_scope_; }\n\n\t// Set the scope for the class definition. This is the scope\n\t// where the class definition was encountered, and may be used\n\t// to locate symbols that the class definition may inherit\n\t// from its context. This can be nil, or a package or module\n\t// where a class is defined.\n      void set_definition_scope(NetScope*dscope);\n\n      NetScope*definition_scope(void);\n\n\t// As an ivl_type_s object, the netclass is always an\n\t// ivl_VT_CLASS object.\n      ivl_variable_type_t base_type() const;\n\n\t// This is the name of the class type\n      inline perm_string get_name() const { return name_; }\n\n\t// If this is derived from another class, then this method\n\t// returns a pointer to the super-class.\n      inline const netclass_t* get_super() const { return super_; }\n\n\t// Get the number of properties in this class. Include\n\t// properties in the parent class.\n      size_t get_properties(void) const;\n\t// Get information about each property.\n      const char*get_prop_name(size_t idx) const;\n      property_qualifier_t get_prop_qual(size_t idx) const;\n      ivl_type_t get_prop_type(size_t idx) const;\n\n\t// These methods are used by the elaborator to note the\n\t// initializer for constant properties. Properties start out\n\t// as not initialized, and when elaboration detects an\n\t// assignment to the property, it is marked initialized.\n      bool get_prop_initialized(size_t idx) const;\n      void set_prop_initialized(size_t idx) const;\n\n      bool test_for_missing_initializers(void) const;\n\n\t// Map the name of a property to its index. Return <0 if the\n\t// name is not a property in the class.\n      int property_idx_from_name(perm_string pname) const;\n\n\t// The task method scopes from the method name.\n      NetScope*method_from_name(perm_string mname) const;\n\n\t// Returns the constructor task method of the class. Might be nullptr if\n\t// there is nothing to do in the constructor.\n      NetScope* get_constructor() const;\n\n\t// Find the elaborated signal (NetNet) for a static\n\t// property. Search by name. The signal is created by the\n\t// elaborate_sig pass.\n      NetNet*find_static_property(perm_string name) const;\n\n\t// Test if this scope is a method within the class. This is\n\t// used to check scope for handling data protection keywords\n\t// \"local\" and \"protected\".\n      bool test_scope_is_method(const NetScope*scope) const;\n\n      void elaborate_sig(Design*des, PClass*pclass);\n      void elaborate(Design*des, PClass*pclass);\n\n      void emit_scope(struct target_t*tgt) const;\n      bool emit_defs(struct target_t*tgt) const;\n\n      std::ostream& debug_dump(std::ostream&fd) const;\n      void dump_scope(std::ostream&fd) const;\n\n      const NetExpr* get_parameter(Design *des, perm_string name,\n\t\t\t\t   ivl_type_t &par_type) const;\n\n      void set_virtual(bool virtual_class) { virtual_class_ = virtual_class; }\n      bool is_virtual() const { return virtual_class_; }\n\n    protected:\n      bool test_compatibility(ivl_type_t that) const;\n\n    private:\n      perm_string name_;\n\t// If this is derived from another base class, point to it\n\t// here.\n      const netclass_t*super_;\n\t// Map property names to property table index.\n      std::map<perm_string,size_t> properties_;\n\t// Vector of properties.\n      struct prop_t {\n\t    perm_string name;\n\t    property_qualifier_t qual;\n\t    ivl_type_t type;\n\t    mutable bool initialized_flag;\n      };\n      std::vector<prop_t> property_table_;\n\n\t// This holds task/function definitions for methods.\n      NetScope*class_scope_;\n\n\t// This holds the context for the class type definition.\n      NetScope*definition_scope_;\n\n      bool virtual_class_;\n};\n\ninline NetScope*netclass_t::definition_scope(void)\n{\n      return definition_scope_;\n}\n\n#endif /* IVL_netclass_H */\n"
        },
        {
          "name": "netdarray.cc",
          "type": "blob",
          "size": 1.708984375,
          "content": "/*\n * Copyright (c) 2012-2020 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netdarray.h\"\n# include  \"netqueue.h\"\n# include  <iostream>\n\nusing namespace std;\n\nnetdarray_t::netdarray_t(ivl_type_t vec)\n: netarray_t(vec)\n{\n}\n\nnetdarray_t::~netdarray_t()\n{\n}\n\nivl_variable_type_t netdarray_t::base_type(void) const\n{\n      return IVL_VT_DARRAY;\n}\n\nbool netdarray_t::test_equivalence(ivl_type_t that) const\n{\n      // Queues and dynamic arrays are not equivalent, so check for the base\n      // type to make sure both are either dynamic array or queue.\n      if (base_type() != that->base_type())\n\t    return false;\n\n      return test_compatibility(that);\n}\n\nbool netdarray_t::test_compatibility(ivl_type_t that) const\n{\n      // This will match both queues and dynamic arrays\n      const netdarray_t *that_da = dynamic_cast<const netdarray_t*>(that);\n      if (!that_da)\n\t    return false;\n\n      return element_type()->type_equivalent(that_da->element_type());\n}\n"
        },
        {
          "name": "netdarray.h",
          "type": "blob",
          "size": 2.0556640625,
          "content": "#ifndef IVL_netdarray_H\n#define IVL_netdarray_H\n/*\n * Copyright (c) 2012-2015 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"nettypes.h\"\n# include  \"ivl_target.h\"\n\nclass netdarray_t : public netarray_t {\n\n    public:\n      explicit netdarray_t(ivl_type_t vec);\n      ~netdarray_t();\n\n\t// This is the \"base_type()\" virtual method of the\n\t// nettype_base_t. The ivl_target api expects this to return\n\t// IVL_VT_DARRAY for dynamic arrays?\n      ivl_variable_type_t base_type() const;\n\n\t// A dynamic array may have a type that is signed.\n      inline bool get_signed() const { return element_type()->get_signed(); }\n\n\t// This is the base_type() of the element of the array. We\n\t// need this in some cases in order to get the base type of\n\t// the element, and not the IVL_VT_DARRAY of the array itself.\n      inline ivl_variable_type_t element_base_type() const { return element_type()->base_type(); }\n\n\t// This is a convenience function for getting the width of an\n\t// element. Strictly speaking it's not necessary.\n      inline unsigned long element_width(void) const { return element_type()->packed_width(); }\n\n      std::ostream& debug_dump(std::ostream&) const;\n\n    private:\n      bool test_compatibility(ivl_type_t that) const;\n      bool test_equivalence(ivl_type_t that) const;\n};\n\n#endif /* IVL_netdarray_H */\n"
        },
        {
          "name": "netenum.cc",
          "type": "blob",
          "size": 3.830078125,
          "content": "/*\n * Copyright (c) 2010-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netenum.h\"\n# include  \"compiler.h\"\n# include  <cassert>\n\nusing namespace std;\n\nnetenum_t::netenum_t(ivl_type_t btype, size_t name_count, bool integer_flag)\n: base_type_(btype), integer_flag_(integer_flag), names_(name_count),\n  bits_(name_count)\n{\n}\n\nnetenum_t::~netenum_t()\n{\n}\n\nbool netenum_t::get_signed() const\n{\n      return base_type_->get_signed();\n}\n\nbool netenum_t::get_isint() const\n{\n      return integer_flag_;\n}\n\n/*\n * Enumerations are by definition always packed.\n */\nbool netenum_t::packed() const\n{\n      return true;\n}\n\nlong netenum_t::packed_width() const\n{\n\treturn base_type_->packed_width();\n}\n\nnetranges_t netenum_t::slice_dimensions() const\n{\n      return base_type_->slice_dimensions();\n}\n\nbool netenum_t::insert_name(size_t name_idx, perm_string name, const verinum&val)\n{\n      std::pair<std::map<perm_string,verinum>::iterator, bool> res;\n\n      assert(val.has_len() && packed_width() >= 0 &&\n                              val.len() == (unsigned long)packed_width());\n\n\t// Insert a map of the name to the value. This also gets a\n\t// flag that returns true if the  name is unique, or false\n\t// otherwise.\n      res = names_map_.insert( make_pair(name,val) );\n\n      assert(name_idx < names_.size() && names_[name_idx] == 0);\n      names_[name_idx] = name;\n\n      return res.second;\n}\n\nvoid netenum_t::insert_name_close(void)\n{\n      for (size_t idx = 0 ; idx < names_.size() ; idx += 1) {\n\t      // If we failed to elaborate the name then skip this step.\n\t    if (names_[idx].nil()) continue;\n\n\t    netenum_t::iterator cur = names_map_.find(names_[idx]);\n\n\t    vector<char>str (cur->second.len() + 1);\n\t    for (unsigned bit = 0 ; bit < cur->second.len() ; bit += 1) {\n\t\t  switch (cur->second.get(bit)) {\n\t\t      case verinum::V0:\n\t\t\tstr[bit] = '0';\n\t\t\tbreak;\n\t\t      case verinum::V1:\n\t\t\tstr[bit] = '1';\n\t\t\tbreak;\n\t\t      case verinum::Vx:\n\t\t\tstr[bit] = 'x';\n\t\t\tbreak;\n\t\t      case verinum::Vz:\n\t\t\tstr[bit] = 'z';\n\t\t\tbreak;\n\t\t  }\n\t    }\n\t    bits_[idx] = bits_strings.make(&str[0]);\n      }\n}\n\nnetenum_t::iterator netenum_t::find_name(perm_string name) const\n{\n      return names_map_.find(name);\n}\n\n/*\n * Check to see if the given value is already in the enumeration mapping.\n */\nperm_string netenum_t::find_value(const verinum&val) const\n{\n      perm_string res;\n      for(netenum_t::iterator cur = names_map_.begin();\n          cur != names_map_.end(); ++ cur) {\n\t    if (cur->second == val) {\n\t\t  res = cur->first;\n\t\t  break;\n\t    }\n      }\n      return res;\n}\n\nnetenum_t::iterator netenum_t::end_name() const\n{\n      return names_map_.end();\n}\n\nnetenum_t::iterator netenum_t::first_name() const\n{\n      return names_map_.find(names_.front());\n}\n\nnetenum_t::iterator netenum_t::last_name() const\n{\n      return names_map_.find(names_.back());\n}\n\nperm_string netenum_t::name_at(size_t idx) const\n{\n      assert(idx < names_.size());\n      return names_[idx];\n}\n\nperm_string netenum_t::bits_at(size_t idx) const\n{\n      return bits_[idx];\n}\n\nbool netenum_t::matches(const netenum_t*other) const\n{\n      return this == other;\n}\n"
        },
        {
          "name": "netenum.h",
          "type": "blob",
          "size": 2.7412109375,
          "content": "#ifndef IVL_netenum_H\n#define IVL_netenum_H\n/*\n * Copyright (c) 2010-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"ivl_target.h\"\n# include  \"nettypes.h\"\n# include  \"verinum.h\"\n# include  \"StringHeap.h\"\n# include  \"LineInfo.h\"\n# include  <vector>\n# include  <map>\n\nclass NetScope;\n\nclass netenum_t : public LineInfo, public ivl_type_s {\n\n    public:\n      explicit netenum_t(ivl_type_t base_type, size_t name_count,\n\t\t\t bool integer_flag);\n      ~netenum_t();\n\n      virtual ivl_variable_type_t base_type() const;\n      virtual bool packed() const;\n      virtual long packed_width() const;\n      netranges_t slice_dimensions() const;\n      bool get_signed() const;\n      bool get_isint() const;\n\n\t// The size() is the number of enumeration literals.\n      size_t size() const;\n\n\t// Insert the name (and value) at the specific place in the\n\t// enumeration. This must be done exactly once for each\n\t// enumeration value.\n      bool insert_name(size_t idx, perm_string name, const verinum&val);\n\n\t// Indicate that there will be no more names to insert.\n      void insert_name_close(void);\n\n      typedef std::map<perm_string,verinum>::const_iterator iterator;\n      iterator find_name(perm_string name) const;\n      iterator end_name() const;\n      perm_string find_value(const verinum&val) const;\n\n\t// These methods roughly match the .first() and .last() methods.\n      iterator first_name() const;\n      iterator last_name() const;\n\n      perm_string name_at(size_t idx) const;\n      perm_string bits_at(size_t idx) const;\n\n\t// Check if two enumerations have the same definition.\n      bool matches(const netenum_t*other) const;\n\n    private:\n      ivl_type_t base_type_;\n      bool integer_flag_;\n\n      std::map<perm_string,verinum> names_map_;\n      std::vector<perm_string> names_;\n      std::vector<perm_string> bits_;\n};\n\ninline ivl_variable_type_t netenum_t::base_type() const\n{ return base_type_->base_type(); }\n\ninline size_t netenum_t::size() const { return names_.size(); }\n\n#endif /* IVL_netenum_H */\n"
        },
        {
          "name": "netlist.cc",
          "type": "blob",
          "size": 77.66796875,
          "content": "/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include <iostream>\n\n# include  <typeinfo>\n# include  <cstdlib>\n# include  <climits>\n# include  <cstring>\n# include  \"compiler.h\"\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"netclass.h\"\n# include  \"netdarray.h\"\n# include  \"netenum.h\"\n# include  \"netparray.h\"\n# include  \"netscalar.h\"\n# include  \"netqueue.h\"\n# include  \"netstruct.h\"\n# include  \"netvector.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nostream& operator<< (ostream&o, NetNet::Type t)\n{\n      switch (t) {\n\t  case NetNet::NONE:\n\t    o << \"net_none\";\n\t    break;\n\t  case NetNet::IMPLICIT:\n\t    o << \"wire /*implicit*/\";\n\t    break;\n\t  case NetNet::IMPLICIT_REG:\n\t    o << \"reg /*implicit*/\";\n\t    break;\n\t  case NetNet::REG:\n\t    o << \"reg\";\n\t    break;\n\t  case NetNet::SUPPLY0:\n\t    o << \"supply0\";\n\t    break;\n\t  case NetNet::SUPPLY1:\n\t    o << \"supply1\";\n\t    break;\n\t  case NetNet::TRI:\n\t    o << \"tri\";\n\t    break;\n\t  case NetNet::TRI0:\n\t    o << \"tri0\";\n\t    break;\n\t  case NetNet::TRI1:\n\t    o << \"tri1\";\n\t    break;\n\t  case NetNet::TRIAND:\n\t    o << \"triand\";\n\t    break;\n\t  case NetNet::TRIOR:\n\t    o << \"trior\";\n\t    break;\n\t  case NetNet::WAND:\n\t    o << \"wand\";\n\t    break;\n\t  case NetNet::WOR:\n\t    o << \"wor\";\n\t    break;\n\t  case NetNet::WIRE:\n\t    o << \"wire\";\n\t    break;\n\t  case NetNet::UNRESOLVED_WIRE:\n\t    o << \"uwire\";\n      }\n      return o;\n}\n\nunsigned count_signals(const Link&pin)\n{\n      unsigned count = 0;\n\n      const Nexus*nex = pin.nexus();\n      for (const Link*clnk = nex->first_nlink()\n\t\t ; clnk ; clnk = clnk->next_nlink()) {\n\t    const NetPins*cur;\n\t    unsigned cpin;\n\t    clnk->cur_link(cur, cpin);\n\t    if (dynamic_cast<const NetNet*>(cur))\n\t\t  count += 1;\n      }\n\n      return count;\n}\n\nconst NetNet* find_link_signal(const NetObj*net, unsigned pin, unsigned&bidx)\n{\n      const Nexus*nex = net->pin(pin).nexus();\n\n      for (const Link*clnk = nex->first_nlink()\n\t\t ; clnk ; clnk = clnk->next_nlink()) {\n\n\t    const NetPins*cur;\n\t    unsigned cpin;\n\t    clnk->cur_link(cur, cpin);\n\n\t    const NetNet*sig = dynamic_cast<const NetNet*>(cur);\n\t    if (sig) {\n\t\t  bidx = cpin;\n\t\t  return sig;\n\t    }\n      }\n\n      return 0;\n}\n\nLink* find_next_output(Link*lnk)\n{\n      Link*cur = lnk->next_nlink();\n      while (cur != lnk) {\n\t    if (cur->get_dir() == Link::OUTPUT)\n\t\t  return cur;\n\n\t    cur = cur->next_nlink();\n\t    if (cur == 0)\n\t\t  cur = lnk->nexus()->first_nlink();\n      }\n\n      return 0;\n}\n\nvoid NetPins::devirtualize_pins(void)\n{\n      if (pins_) return;\n      if (npins_ > array_size_limit) {\n\t    cerr << get_fileline() << \": error: pin count \" << npins_ <<\n\t\t\" exceeds \" << array_size_limit <<\n\t\t\" (set by -pARRAY_SIZE_LIMIT)\" << endl;\n\t    ivl_assert(*this, 0);\n      }\n      if (debug_optimizer && npins_ > 1000) cerr << \"debug: devirtualizing \" << npins_ << \" pins.\" << endl;\n\n      pins_ = new Link[npins_];\n      pins_[0].pin_zero_ = true;\n      pins_[0].node_ = this;\n      pins_[0].dir_  = default_dir_;\n\n      for (unsigned idx = 1 ;  idx < npins_ ;  idx += 1) {\n\t    pins_[idx].pin_zero_ = false;\n\t    pins_[idx].pin_      = idx;\n\t    pins_[idx].dir_      = default_dir_;\n      }\n}\n\nbool NetPins::pins_are_virtual(void) const\n{\n      return pins_ == NULL;\n}\n\nNetPins::NetPins(unsigned npins)\n: npins_(npins)\n{\n      default_dir_ = Link::PASSIVE;\n      pins_ = NULL;  // Wait until someone asks.\n      if (disable_virtual_pins) devirtualize_pins();  // Ask.  Bummer.\n}\n\nNetPins::~NetPins()\n{\n      if (pins_) {\n\t    ivl_assert(*this, pins_[0].node_ == this);\n\t    ivl_assert(*this, pins_[0].pin_zero_);\n\t    delete[] pins_;\n      }\n}\n\nLink& NetPins::pin(unsigned idx)\n{\n      if (!pins_) devirtualize_pins();\n      if (idx >= npins_) {\n\t    cerr << get_fileline() << \": internal error: pin(\"<<idx<<\")\"\n\t\t << \" out of bounds(\"<<npins_<<\")\" << endl;\n\t    cerr << get_fileline() << \":               : typeid=\"\n\t\t << typeid(*this).name() << endl;\n      }\n\n      ivl_assert(*this, idx < npins_);\n      ivl_assert(*this, idx == 0? (pins_[0].pin_zero_ && pins_[0].node_==this) : pins_[idx].pin_==idx);\n\n      return pins_[idx];\n}\n\nconst Link& NetPins::pin(unsigned idx) const\n{\n      if (!pins_ && !disable_virtual_pins) {\n\t    cerr << get_fileline() << \": internal error: pin is unexpectedly\"\n\t      \" virtual, try again with -pDISABLE_VIRTUAL_PINS=true\" << endl;\n\t    ivl_assert(*this, 0);\n      }\n      ivl_assert(*this, pins_);\n      ivl_assert(*this, idx < npins_);\n      ivl_assert(*this, idx == 0? (pins_[0].pin_zero_ && pins_[0].node_==this) : pins_[idx].pin_==idx);\n      return pins_[idx];\n}\n\nvoid NetPins::set_default_dir(Link::DIR d)\n{\n       default_dir_ = d;\n}\n\nbool NetPins::is_linked(void) const\n{\n      bool linked_flag = false;\n      if (pins_ == NULL) return false;\n      for (unsigned u = 0; u < npins_; u++) {\n\t    if (pins_[u].is_linked()) {\n\t\t  linked_flag = true;\n\t\t  break;\n\t    }\n      }\n      return linked_flag;\n}\n\nNetObj::NetObj(NetScope*s, perm_string n, unsigned np)\n: NetPins(np), scope_(s), name_(n), delay1_(0), delay2_(0), delay3_(0)\n{\n      /* Don't\n      ivl_assert(*this, np > 0);\n       * because it would happen before we get to print a useful\n       * message in the NetNet constructor\n       */\n}\n\nNetObj::~NetObj()\n{\n}\n\nNetScope* NetObj::scope()\n{\n      return scope_;\n}\n\nconst NetScope* NetObj::scope() const\n{\n      return scope_;\n}\n\nNetNode::NetNode(NetScope*s, perm_string n, unsigned npins)\n: NetObj(s, n, npins), node_next_(0), node_prev_(0), design_(0)\n{\n}\n\nNetNode::~NetNode()\n{\n      if (design_)\n\t    design_->del_node(this);\n}\n\nNetBranch::NetBranch(ivl_discipline_t dis)\n: NetPins(2), IslandBranch(dis)\n{\n      pin(0).set_dir(Link::PASSIVE);\n      pin(1).set_dir(Link::PASSIVE);\n}\n\nNetBranch::~NetBranch()\n{\n}\n\nNetBus::NetBus(NetScope*s, unsigned pin_count__)\n: NetObj(s, perm_string::literal(\"\"), pin_count__)\n{\n      for (unsigned idx = 0 ;  idx <pin_count__ ;  idx += 1) {\n\t    pin(idx).set_dir(Link::PASSIVE);\n      }\n}\n\nNetBus::~NetBus()\n{\n}\n\nunsigned NetBus::find_link(const Link&that) const\n{\n      unsigned ptr = 0;\n\n      while (ptr < pin_count()) {\n\t    if (pin(ptr).is_linked(that))\n\t\t  return ptr;\n\n\t    ptr += 1;\n      }\n      return ptr;\n}\n\nNetDelaySrc::NetDelaySrc(NetScope*s, perm_string n, unsigned npins,\n                         bool condit_src, bool conditional, bool parallel)\n: NetObj(s, n, npins + (condit_src?1:0))\n{\n      condit_flag_ = false;\n      conditional_ = conditional;\n      parallel_ = parallel;\n      posedge_ = false;\n      negedge_ = false;\n      for (unsigned idx = 0 ;  idx < npins ;  idx += 1) {\n\t    pin(idx).set_dir(Link::INPUT);\n      }\n\n      if (condit_src) {\n\t    condit_flag_ = true;\n\t    pin(npins).set_dir(Link::INPUT);\n      }\n}\n\nNetDelaySrc::~NetDelaySrc()\n{\n}\n\nvoid NetDelaySrc::set_delays(uint64_t del)\n{\n      for (unsigned idx = 0 ;  idx < 12 ;  idx += 1)\n\t    transition_delays_[idx] = del;\n}\n\nvoid NetDelaySrc::set_delays(uint64_t trise, uint64_t tfall)\n{\n      transition_delays_[IVL_PE_01] = trise;\n      transition_delays_[IVL_PE_10] = tfall;\n      transition_delays_[IVL_PE_0z] = trise;\n      transition_delays_[IVL_PE_z1] = trise;\n      transition_delays_[IVL_PE_1z] = tfall;\n      transition_delays_[IVL_PE_z0] = tfall;\n      transition_delays_[IVL_PE_0x] = trise;\n      transition_delays_[IVL_PE_x1] = trise;\n      transition_delays_[IVL_PE_1x] = tfall;\n      transition_delays_[IVL_PE_x0] = tfall;\n      transition_delays_[IVL_PE_xz] = max(trise,tfall);\n      transition_delays_[IVL_PE_zx] = min(trise,tfall);\n}\n\nvoid NetDelaySrc::set_delays(uint64_t trise, uint64_t tfall, uint64_t tz)\n{\n      transition_delays_[IVL_PE_01] = trise;\n      transition_delays_[IVL_PE_10] = tfall;\n      transition_delays_[IVL_PE_0z] = tz;\n      transition_delays_[IVL_PE_z1] = trise;\n      transition_delays_[IVL_PE_1z] = tz;\n      transition_delays_[IVL_PE_z0] = tfall;\n      transition_delays_[IVL_PE_0x] = min(trise,tz);\n      transition_delays_[IVL_PE_x1] = trise;\n      transition_delays_[IVL_PE_1x] = min(tfall,tz);\n      transition_delays_[IVL_PE_x0] = tfall;\n      transition_delays_[IVL_PE_xz] = tz;\n      transition_delays_[IVL_PE_zx] = min(trise,tfall);\n}\n\nvoid NetDelaySrc::set_delays(uint64_t t01, uint64_t t10, uint64_t t0z,\n\t\t\t     uint64_t tz1, uint64_t t1z, uint64_t tz0)\n{\n      transition_delays_[IVL_PE_01] = t01;\n      transition_delays_[IVL_PE_10] = t10;\n      transition_delays_[IVL_PE_0z] = t0z;\n      transition_delays_[IVL_PE_z1] = tz1;\n      transition_delays_[IVL_PE_1z] = t1z;\n      transition_delays_[IVL_PE_z0] = tz0;\n      transition_delays_[IVL_PE_0x] = min(t01,t0z);\n      transition_delays_[IVL_PE_x1] = max(t01,tz1);\n      transition_delays_[IVL_PE_1x] = min(t10,t1z);\n      transition_delays_[IVL_PE_x0] = max(t10,tz0);\n      transition_delays_[IVL_PE_xz] = max(t1z,t0z);\n      transition_delays_[IVL_PE_zx] = min(tz1,tz0);\n}\n\nvoid NetDelaySrc::set_delays(uint64_t t01, uint64_t t10, uint64_t t0z,\n\t\t\t     uint64_t tz1, uint64_t t1z, uint64_t tz0,\n\t\t\t     uint64_t t0x, uint64_t tx1, uint64_t t1x,\n\t\t\t     uint64_t tx0, uint64_t txz, uint64_t tzx)\n{\n      transition_delays_[IVL_PE_01] = t01;\n      transition_delays_[IVL_PE_10] = t10;\n      transition_delays_[IVL_PE_0z] = t0z;\n      transition_delays_[IVL_PE_z1] = tz1;\n      transition_delays_[IVL_PE_1z] = t1z;\n      transition_delays_[IVL_PE_z0] = tz0;\n      transition_delays_[IVL_PE_0x] = t0x;\n      transition_delays_[IVL_PE_x1] = tx1;\n      transition_delays_[IVL_PE_1x] = t1x;\n      transition_delays_[IVL_PE_x0] = tx0;\n      transition_delays_[IVL_PE_xz] = txz;\n      transition_delays_[IVL_PE_zx] = tzx;\n}\n\nuint64_t NetDelaySrc::get_delay(unsigned idx) const\n{\n      ivl_assert(*this, idx < 12);\n      return transition_delays_[idx];\n}\n\nvoid NetDelaySrc::set_posedge()\n{\n      posedge_ = true;\n}\n\nvoid NetDelaySrc::set_negedge()\n{\n      negedge_ = true;\n}\n\nbool NetDelaySrc::is_posedge() const\n{\n      return posedge_;\n}\n\nbool NetDelaySrc::is_negedge() const\n{\n      return negedge_;\n}\n\nunsigned NetDelaySrc::src_count() const\n{\n      if (condit_flag_)\n\t    return pin_count() - 1;\n      else\n\t    return pin_count();\n}\n\nLink& NetDelaySrc::src_pin(unsigned idx)\n{\n      ivl_assert(*this, idx < src_count());\n      return pin(idx);\n}\n\nconst Link& NetDelaySrc::src_pin(unsigned idx) const\n{\n      ivl_assert(*this, idx < src_count());\n      return pin(idx);\n}\n\nbool NetDelaySrc::is_condit() const\n{\n      return conditional_;\n}\n\nbool NetDelaySrc::has_condit() const\n{\n      return condit_flag_;\n}\n\nLink& NetDelaySrc::condit_pin()\n{\n      ivl_assert(*this, condit_flag_);\n      return pin(pin_count()-1);\n}\n\nconst Link& NetDelaySrc::condit_pin() const\n{\n      ivl_assert(*this, condit_flag_);\n      return pin(pin_count()-1);\n}\n\nbool NetDelaySrc::is_parallel() const\n{\n      return parallel_;\n}\n\nPortType::Enum PortType::merged( Enum lhs, Enum rhs )\n{\n    if( lhs == NOT_A_PORT || rhs == NOT_A_PORT )\n        return NOT_A_PORT;\n    if( lhs == PIMPLICIT )\n        return rhs;\n    if( rhs == PIMPLICIT )\n      return lhs;\n    if( lhs == rhs ) {\n        return lhs;\n    }\n    return PINOUT;\n}\n\nvoid NetNet::initialize_dir_()\n{\n      Link::DIR dir = Link::PASSIVE;\n\n      switch (type_) {\n\t  case REG:\n\t  case IMPLICIT_REG:\n\t  case SUPPLY0:\n\t  case SUPPLY1:\n\t  case TRI0:\n\t  case TRI1:\n\t    dir = Link::OUTPUT;\n\t    break;\n\t  default:\n\t    break;\n      }\n\n      if (pins_are_virtual()) {\n\t    if (0) cerr << \"NetNet setting Link default dir\" << endl;\n\t    set_default_dir(dir);\n      } else {\n\t    for (unsigned idx = 0 ;  idx < pin_count() ;  idx += 1) {\n\t\t  pin(idx).set_dir(dir);\n\t    }\n      }\n}\n\nstatic unsigned calculate_count(const netranges_t &unpacked)\n{\n      unsigned long sum = netrange_width(unpacked);\n      if (sum >= UINT_MAX)\n\t    return 0;\n\n      return sum;\n}\n\nvoid NetNet::calculate_slice_widths_from_packed_dims_(void)\n{\n      ivl_assert(*this, net_type_);\n      if (!net_type_->packed())\n\t    return;\n\n      slice_dims_ = net_type_->slice_dimensions();\n\n\t// Special case: There are no actual packed dimensions, so\n\t// build up a fake dimension of \"1\".\n      if (slice_dims_.empty()) {\n\t    slice_wids_.resize(1);\n\t    slice_wids_[0] = net_type_->packed_width();\n\t    return;\n      }\n\n      slice_wids_.resize(slice_dims_.size());\n\n      ivl_assert(*this, ! slice_wids_.empty());\n      slice_wids_[0] = netrange_width(slice_dims_);\n      netranges_t::const_iterator cur = slice_dims_.begin();\n      for (size_t idx = 1 ; idx < slice_wids_.size() ; idx += 1, ++cur) {\n\t    slice_wids_[idx] = slice_wids_[idx-1] / cur->width();\n      }\n}\n\nNetNet::NetNet(NetScope*s, perm_string n, Type t,\n\t       const netranges_t&unpacked, ivl_type_t use_net_type)\n: NetObj(s, n, calculate_count(unpacked)),\n    type_(t), port_type_(NOT_A_PORT), coerced_to_uwire_(false),\n    local_flag_(false), lexical_pos_(0), net_type_(use_net_type),\n    discipline_(0), unpacked_dims_(unpacked),\n    eref_count_(0), lref_count_(0)\n{\n      calculate_slice_widths_from_packed_dims_();\n\n      ivl_assert(*this, s);\n      if (pin_count() == 0) {\n\t    cerr << \"Invalid array dimensions: \" << unpacked << endl;\n\t    ivl_assert(*this, 0);\n      }\n\n      initialize_dir_();\n\n      if (!unpacked_dims_.empty())\n\t    array_type_ = new netuarray_t(unpacked_dims_, net_type_);\n\n      s->add_signal(this);\n}\n\nNetNet::NetNet(NetScope*s, perm_string n, Type t, ivl_type_t type)\n: NetObj(s, n, 1),\n    type_(t), port_type_(NOT_A_PORT), coerced_to_uwire_(false),\n    local_flag_(false), lexical_pos_(0), net_type_(type),\n    discipline_(0),\n    eref_count_(0), lref_count_(0)\n{\n      calculate_slice_widths_from_packed_dims_();\n\n      initialize_dir_();\n\n      s->add_signal(this);\n}\n\nNetNet::~NetNet()\n{\n      if (eref_count_ > 0) {\n\t    cerr << get_fileline() << \": internal error: attempt to delete \"\n\t\t << \"signal ``\" << name() << \"'' which has \"\n\t\t << \"expression references.\" << endl;\n\t    dump_net(cerr, 4);\n      }\n      ivl_assert(*this, eref_count_ == 0);\n      if (lref_count_ > 0) {\n\t    cerr << get_fileline() << \": internal error: attempt to delete \"\n\t\t << \"signal ``\" << name() << \"'' which has \"\n\t\t << \"assign references.\" << endl;\n\t    dump_net(cerr, 4);\n      }\n      ivl_assert(*this, lref_count_ == 0);\n      if (scope())\n\t    scope()->rem_signal(this);\n\n}\n\nNetNet::Type NetNet::type() const\n{\n      return type_;\n}\n\nvoid NetNet::type(NetNet::Type t)\n{\n      if (type_ == t)\n\t    return;\n\n      if ((t == UNRESOLVED_WIRE) && ((type_ == REG) || (type_ == IMPLICIT_REG)))\n\t    coerced_to_uwire_ = true;\n\n      type_ = t;\n\n      initialize_dir_();\n}\n\n\nNetNet::PortType NetNet::port_type() const\n{\n      return port_type_;\n}\n\nvoid NetNet::port_type(NetNet::PortType t)\n{\n      port_type_ = t;\n}\n\nint NetNet::get_module_port_index() const\n{\n      return port_index_;\n}\n\nvoid NetNet::set_module_port_index(unsigned idx)\n{\n    port_index_ = idx;\n    ivl_assert(*this, port_index_ >= 0);\n}\n\nivl_variable_type_t NetNet::data_type() const\n{\n      ivl_assert(*this, net_type_);\n      return net_type_->base_type();\n}\n\nbool NetNet::get_signed() const\n{\n      ivl_assert(*this, net_type_);\n      return net_type_->get_signed();\n}\n\nbool NetNet::get_scalar() const\n{\n      ivl_assert(*this, net_type_);\n      return net_type_->get_scalar();\n}\n\nconst netenum_t*NetNet::enumeration(void) const\n{\n      return dynamic_cast<const netenum_t*> (net_type_);\n}\n\nconst netstruct_t*NetNet::struct_type(void) const\n{\n      ivl_type_t cur_type = net_type_;\n      while (cur_type) {\n\t    if (const netdarray_t*da = dynamic_cast<const netdarray_t*> (cur_type)) {\n\t\t  cur_type = da->element_type();\n\t\t  continue;\n\t    }\n\t    if (const netparray_t*da = dynamic_cast<const netparray_t*> (cur_type)) {\n\t\t  cur_type = da->element_type();\n\t\t  continue;\n\t    }\n\t    if (const netstruct_t*st = dynamic_cast<const netstruct_t*> (cur_type))\n\t\t  return st;\n\t    else\n\t\t  return 0;\n      }\n\n      ivl_assert(*this, 0);\n      return 0;\n}\n\nconst netdarray_t* NetNet::darray_type(void) const\n{\n      return dynamic_cast<const netdarray_t*> (net_type_);\n}\n\nconst netqueue_t* NetNet::queue_type(void) const\n{\n      return dynamic_cast<const netqueue_t*> (net_type_);\n}\n\nconst netclass_t* NetNet::class_type(void) const\n{\n      return dynamic_cast<const netclass_t*> (net_type_);\n}\n\nconst netarray_t* NetNet::array_type() const\n{\n      if (array_type_)\n\t    return array_type_;\n\n      return darray_type();\n}\n\n/*\n * \"depth\" is the number of index expressions that the user is using\n * to index this identifier. So consider if Net was declared like so:\n *\n *   reg [5:0][3:0] foo;\n *\n * In this case, slice_width(2) == 1  (slice_width(N) where N is the\n * number of dimensions will always be 1.) and represents\n * $bits(foo[a][b]). Then, slice_width(1)==4 ($bits(foo[a]) and slice_width(0)==24.\n *\n * NOTE: The caller should already have accounted for unpacked\n * dimensions. The \"depth\" is only for the packed dimensions.\n */\nunsigned long NetNet::slice_width(size_t depth) const\n{\n      if (depth > slice_wids_.size())\n\t    return 0;\n      if (depth == slice_wids_.size())\n\t    return 1;\n      return slice_wids_[depth];\n}\n\nivl_discipline_t NetNet::get_discipline() const\n{\n      return discipline_;\n}\n\nvoid NetNet::set_discipline(ivl_discipline_t dis)\n{\n      ivl_assert(*this, discipline_ == 0);\n      discipline_ = dis;\n}\n\nbool NetNet::sb_is_valid(const list<long>&indices, long sb) const\n{\n      ivl_assert(*this, indices.size()+1 == packed_dims().size());\n      ivl_assert(*this, packed_dims().size() == 1);\n      const netrange_t&rng = packed_dims().back();\n      if (rng.get_msb() >= rng.get_lsb())\n\t    return (sb <= rng.get_msb()) && (sb >= rng.get_lsb());\n      else\n\t    return (sb <= rng.get_lsb()) && (sb >= rng.get_msb());\n}\n\nlong NetNet::sb_to_idx(const list<long>&indices, long sb) const\n{\n      ivl_assert(*this, indices.size()+1 == packed_dims().size());\n\n      netranges_t::const_iterator pcur = packed_dims().end();\n      -- pcur;\n\n      long acc_off;\n      long acc_wid = pcur->width();\n      if (pcur->get_msb() >= pcur->get_lsb())\n\t    acc_off = sb - pcur->get_lsb();\n      else\n\t    acc_off = pcur->get_lsb() - sb;\n\n\t// The acc_off is the position within the innermost\n\t// dimension. If this is a multi-dimension packed array then\n\t// we need to add in the canonical address of the current slice.\n      if (! indices.empty()) {\n\t    list<long>::const_iterator icur = indices.end();\n\t    do {\n\t\t  -- icur;\n\t\t  -- pcur;\n\n\t\t  long tmp_off;\n\t\t  if (pcur->get_msb() >= pcur->get_lsb())\n\t\t\ttmp_off = *icur - pcur->get_lsb();\n\t\t  else\n\t\t\ttmp_off = pcur->get_lsb() - *icur;\n\n\t\t  acc_off += tmp_off * acc_wid;\n\t\t  acc_wid *= pcur->width();\n\n\t    } while (icur != indices.begin());\n      }\n\n      return acc_off;\n}\n\nbool NetNet::sb_to_slice(const list<long>&indices, long sb, long&loff, unsigned long&lwid) const\n{\n      ivl_assert(*this, indices.size() < packed_dims().size());\n      return prefix_to_slice(packed_dims(), indices, sb, loff, lwid);\n}\n\nunsigned NetNet::unpacked_count() const\n{\n      return netrange_width(unpacked_dims_);\n}\n\nvoid NetNet::incr_eref()\n{\n      eref_count_ += 1;\n}\n\nvoid NetNet::decr_eref()\n{\n      ivl_assert(*this, eref_count_ > 0);\n      eref_count_ -= 1;\n}\n\nunsigned NetNet::peek_eref() const\n{\n      return eref_count_;\n}\n\n/*\n * Test each of the bits in the range. If any bits are set then return true.\n */\nbool NetNet::test_part_driven(unsigned pmsb, unsigned plsb, int widx)\n{\n      if (lref_mask_.empty())\n           return false;\n\n       // If indexing a word that doesn't exist, then pretend this is\n       // never driven.\n      if (widx < 0)\n           return false;\n      if (widx >= (int)pin_count())\n           return false;\n\n      unsigned word_base = vector_width() * widx;\n      for (unsigned idx = plsb ; idx <= pmsb ; idx += 1) {\n           if (lref_mask_[idx+word_base])\n                 return true;\n      }\n\n      return false;\n}\n\n/*\n * Test each of the bits in the range, and set them. If any bits are\n * already set then return true.\n */\nbool NetNet::test_and_set_part_driver(unsigned pmsb, unsigned plsb, int widx)\n{\n      if (lref_mask_.empty())\n\t    lref_mask_.resize(vector_width() * pin_count());\n\n\t// If indexing a word that doesn't exist, then pretend this is\n\t// never driven.\n      if (widx < 0)\n\t    return false;\n      if (widx >= (int)pin_count())\n\t    return false;\n\n      bool rc = false;\n      unsigned word_base = vector_width() * widx;\n      for (unsigned idx = plsb ; idx <= pmsb ; idx += 1) {\n\t    if (lref_mask_[idx+word_base])\n\t\t  rc = true;\n\t    else\n\t\t  lref_mask_[idx+word_base] = true;\n      }\n\n      return rc;\n}\n\nvoid NetNet::incr_lref()\n{\n      lref_count_ += 1;\n}\n\nvoid NetNet::decr_lref()\n{\n      ivl_assert(*this, lref_count_ > 0);\n      lref_count_ -= 1;\n}\n\nunsigned NetNet::get_refs() const\n{\n      return lref_count_ + eref_count_;\n}\n\nvoid NetNet::add_delay_path(NetDelaySrc*path)\n{\n      delay_paths_.push_back(path);\n}\n\nunsigned NetNet::delay_paths(void)const\n{\n      return delay_paths_.size();\n}\n\nconst NetDelaySrc* NetNet::delay_path(unsigned idx) const\n{\n      ivl_assert(*this, idx < delay_paths_.size());\n      return delay_paths_[idx];\n}\n\nNetPartSelect::NetPartSelect(NetNet*sig, unsigned off, unsigned wid,\n\t\t\t     NetPartSelect::dir_t dir__,\n\t\t\t     bool signed_flag__)\n: NetNode(sig->scope(), sig->scope()->local_symbol(), 2),\n    off_(off), wid_(wid), dir_(dir__), signed_flag_(signed_flag__)\n{\n      set_line(*sig);\n\n      switch (dir_) {\n\t  case NetPartSelect::VP:\n\t    pin(0).set_dir(Link::OUTPUT);\n\t    pin(1).set_dir(Link::INPUT);\n\t    break;\n\t  case NetPartSelect::PV:\n\t    pin(0).set_dir(Link::INPUT);\n\t    pin(1).set_dir(Link::OUTPUT);\n\t    break;\n      }\n\n      connect(pin(1), sig->pin(0));\n}\n\nNetPartSelect::NetPartSelect(NetNet*sig, NetNet*sel,\n\t\t\t     unsigned wid, bool signed_flag__)\n: NetNode(sig->scope(), sig->scope()->local_symbol(), 3),\n    off_(0), wid_(wid), dir_(VP), signed_flag_(signed_flag__)\n{\n      switch (dir_) {\n\t  case NetPartSelect::VP:\n\t    pin(0).set_dir(Link::OUTPUT);\n\t    pin(1).set_dir(Link::INPUT);\n\t    break;\n\t  case NetPartSelect::PV:\n\t      /* Only a vector to part can be a variable select. */\n\t    ivl_assert(*this, 0);\n      }\n      pin(2).set_dir(Link::INPUT);\n\n      connect(pin(1), sig->pin(0));\n      connect(pin(2), sel->pin(0));\n}\n\nNetPartSelect::~NetPartSelect()\n{\n}\n\nunsigned NetPartSelect::width() const\n{\n      return wid_;\n}\n\nunsigned NetPartSelect::base() const\n{\n      return off_;\n}\n\nNetSubstitute::NetSubstitute(NetNet*sig, NetNet*sub, unsigned wid, unsigned off)\n: NetNode(sig->scope(), sig->scope()->local_symbol(), 3), wid_(wid), off_(off)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n      pin(2).set_dir(Link::INPUT);\n      connect(pin(1), sig->pin(0));\n      connect(pin(2), sub->pin(0));\n}\n\nNetSubstitute::~NetSubstitute()\n{\n}\n\nNetProc::NetProc()\n: next_(0)\n{\n}\n\nNetProc::~NetProc()\n{\n}\n\nNetProcTop::NetProcTop(NetScope*s, ivl_process_type_t t, NetProc*st)\n: type_(t), statement_(st), scope_(s)\n{\n      synthesized_design_ = 0;\n}\n\nNetProcTop::~NetProcTop()\n{\n      if (!synthesized_design_) {\n\t    delete statement_;\n\t    return;\n      }\n\n      NexusSet nex_set;\n      statement_->nex_output(nex_set);\n\n      delete statement_;\n\n      bool flag = false;\n      for (unsigned idx = 0 ;  idx < nex_set.size() ;  idx += 1) {\n\n\t    NetNet*net = nex_set[idx].lnk.nexus()->pick_any_net();\n\t    if (net->peek_lref() > 0) {\n\t\t  cerr << get_fileline() << \": warning: '\" << net->name()\n\t\t       << \"' is driven by more than one process.\" << endl;\n\t\t  flag = true;\n\t    }\n      }\n      if (flag) {\n\t    cerr << get_fileline() << \": sorry: Cannot synthesize signals \"\n\t\t    \"that are driven by more than one process.\" << endl;\n\t    synthesized_design_->errors += 1;\n      }\n}\n\nNetProc* NetProcTop::statement()\n{\n      return statement_;\n}\n\nconst NetProc* NetProcTop::statement() const\n{\n      return statement_;\n}\n\nNetScope* NetProcTop::scope()\n{\n      return scope_;\n}\n\nconst NetScope* NetProcTop::scope() const\n{\n      return scope_;\n}\n\nNetAnalogTop::NetAnalogTop(NetScope*scope__, ivl_process_type_t t, NetProc*st)\n: type_(t), statement_(st), scope_(scope__)\n{\n      next_ = 0;\n}\n\nNetAnalogTop::~NetAnalogTop()\n{\n}\n\nNetProc* NetAnalogTop::statement()\n{\n      return statement_;\n}\n\nconst NetProc* NetAnalogTop::statement() const\n{\n      return statement_;\n}\n\nNetScope* NetAnalogTop::scope()\n{\n      return scope_;\n}\n\nconst NetScope* NetAnalogTop::scope() const\n{\n      return scope_;\n}\n\nNetCastInt2::NetCastInt2(NetScope*scope__, perm_string n, unsigned width__)\n: NetNode(scope__, n, 2), width_(width__)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetCastInt4::NetCastInt4(NetScope*scope__, perm_string n, unsigned width__)\n: NetNode(scope__, n, 2), width_(width__)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetCastReal::NetCastReal(NetScope*scope__, perm_string n, bool signed_flag__)\n: NetNode(scope__, n, 2), signed_flag_(signed_flag__)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetConcat::NetConcat(NetScope*scope__, perm_string n, unsigned wid, unsigned cnt, bool trans_flag)\n: NetNode(scope__, n, cnt+1), width_(wid), transparent_(trans_flag)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      for (unsigned idx = 1 ;  idx < cnt+1 ;  idx += 1) {\n\t    pin(idx).set_dir(Link::INPUT);\n      }\n}\n\nNetConcat::~NetConcat()\n{\n}\n\nunsigned NetConcat::width() const\n{\n      return width_;\n}\n\nNetReplicate::NetReplicate(NetScope*scope__, perm_string n,\n\t\t\t   unsigned wid, unsigned rpt)\n: NetNode(scope__, n, 2), width_(wid), repeat_(rpt)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetReplicate::~NetReplicate()\n{\n}\n\nunsigned NetReplicate::width() const\n{\n      return width_;\n}\n\nunsigned NetReplicate::repeat() const\n{\n      return repeat_;\n}\n\n/*\n * The NetFF class represents an LPM_FF device. The pinout is assigned\n * like so:\n *    0  -- Clock\n *    1  -- Enable\n *    2  -- Aset\n *    3  -- Aclr\n *    4  -- Sset\n *    5  -- Sclr\n *    6  -- Data\n *    7  -- Q\n *     ...\n */\n\nNetFF::NetFF(NetScope*s, perm_string n, bool negedge__, unsigned width__)\n: NetNode(s, n, 8), negedge_(negedge__), width_(width__)\n{\n      pin_Clock().set_dir(Link::INPUT);\n      pin_Enable().set_dir(Link::INPUT);\n      pin_Aset().set_dir(Link::INPUT);\n      pin_Aclr().set_dir(Link::INPUT);\n      pin_Sset().set_dir(Link::INPUT);\n      pin_Sclr().set_dir(Link::INPUT);\n      pin_Data().set_dir(Link::INPUT);\n      pin_Q().set_dir(Link::OUTPUT);\n}\n\nNetFF::~NetFF()\n{\n}\n\nbool NetFF::is_negedge() const\n{\n      return negedge_;\n}\n\nunsigned NetFF::width() const\n{\n      return width_;\n}\n\nLink& NetFF::pin_Clock()\n{\n      return pin(0);\n}\n\nconst Link& NetFF::pin_Clock() const\n{\n      return pin(0);\n}\n\nLink& NetFF::pin_Enable()\n{\n      return pin(1);\n}\n\nconst Link& NetFF::pin_Enable() const\n{\n      return pin(1);\n}\n\nLink& NetFF::pin_Aset()\n{\n      return pin(2);\n}\n\nconst Link& NetFF::pin_Aset() const\n{\n      return pin(2);\n}\n\nLink& NetFF::pin_Aclr()\n{\n      return pin(3);\n}\n\nconst Link& NetFF::pin_Aclr() const\n{\n      return pin(3);\n}\n\nLink& NetFF::pin_Sset()\n{\n      return pin(4);\n}\n\nconst Link& NetFF::pin_Sset() const\n{\n      return pin(4);\n}\n\nLink& NetFF::pin_Sclr()\n{\n      return pin(5);\n}\n\nconst Link& NetFF::pin_Sclr() const\n{\n      return pin(5);\n}\n\nLink& NetFF::pin_Data()\n{\n      return pin(6);\n}\n\nconst Link& NetFF::pin_Data() const\n{\n      return pin(6);\n}\n\nLink& NetFF::pin_Q()\n{\n      return pin(7);\n}\n\nconst Link& NetFF::pin_Q() const\n{\n      return pin(7);\n}\n\nvoid NetFF::aset_value(const verinum&val)\n{\n      aset_value_ = val;\n}\n\nconst verinum& NetFF::aset_value() const\n{\n      return aset_value_;\n}\n\nvoid NetFF::sset_value(const verinum&val)\n{\n      sset_value_ = val;\n}\n\nconst verinum& NetFF::sset_value() const\n{\n      return sset_value_;\n}\n\n/*\n * The NetLatch class represents an LPM_LATCH device. The pinout is assigned\n * like so:\n *    0  -- Enable\n *    1  -- Data\n *    2  -- Q\n */\n\nNetLatch::NetLatch(NetScope*s, perm_string n, unsigned width__)\n: NetNode(s, n, 3), width_(width__)\n{\n      pin_Enable().set_dir(Link::INPUT);\n      pin_Data().set_dir(Link::INPUT);\n      pin_Q().set_dir(Link::OUTPUT);\n}\n\nNetLatch::~NetLatch()\n{\n}\n\nunsigned NetLatch::width() const\n{\n      return width_;\n}\n\nLink& NetLatch::pin_Enable()\n{\n      return pin(0);\n}\n\nconst Link& NetLatch::pin_Enable() const\n{\n      return pin(0);\n}\n\nLink& NetLatch::pin_Data()\n{\n      return pin(1);\n}\n\nconst Link& NetLatch::pin_Data() const\n{\n      return pin(1);\n}\n\nLink& NetLatch::pin_Q()\n{\n      return pin(2);\n}\n\nconst Link& NetLatch::pin_Q() const\n{\n      return pin(2);\n}\n\nNetAbs::NetAbs(NetScope*s, perm_string n, unsigned w)\n: NetNode(s, n, 2), width_(w)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetAbs::~NetAbs()\n{\n}\n\nunsigned NetAbs::width() const\n{\n      return width_;\n}\n\n/*\n * The NetAddSub class represents an LPM_ADD_SUB device. The pinout is\n * assigned like so:\n *    0  -- Cout\n *    1  -- DataA (normally a vector)\n *    2  -- DataB (normally a vector)\n *    3  -- Result (normally a vector)\n */\nNetAddSub::NetAddSub(NetScope*s, perm_string n, unsigned w)\n: NetNode(s, n, 4), width_(w)\n{\n      pin(0).set_dir(Link::OUTPUT); // Cout\n      pin(1).set_dir(Link::INPUT);  // DataA\n      pin(2).set_dir(Link::INPUT);  // DataB\n      pin(3).set_dir(Link::OUTPUT); // Result\n}\n\nNetAddSub::~NetAddSub()\n{\n}\n\nunsigned NetAddSub::width()const\n{\n      return width_;\n}\n\nLink& NetAddSub::pin_Cout()\n{\n      return pin(0);\n}\n\nconst Link& NetAddSub::pin_Cout() const\n{\n      return pin(0);\n}\n\nLink& NetAddSub::pin_DataA()\n{\n      return pin(1);\n}\n\nconst Link& NetAddSub::pin_DataA() const\n{\n      return pin(1);\n}\n\nLink& NetAddSub::pin_DataB()\n{\n      return pin(2);\n}\n\nconst Link& NetAddSub::pin_DataB() const\n{\n      return pin(2);\n}\n\nLink& NetAddSub::pin_Result()\n{\n      return pin(3);\n}\n\nconst Link& NetAddSub::pin_Result() const\n{\n      return pin(3);\n}\n\nNetArrayDq::NetArrayDq(NetScope*s, perm_string n, NetNet*mem__, unsigned awid)\n: NetNode(s, n, 2),\n  mem_(mem__), awidth_(awid)\n{\n      pin(0).set_dir(Link::OUTPUT); // Result\n      pin(1).set_dir(Link::INPUT);  // Address\n\t// Increment the expression reference count for the target\n\t// memory so that it is not deleted underneath me.\n      mem_->incr_eref();\n}\n\nNetArrayDq::~NetArrayDq()\n{\n}\n\nunsigned NetArrayDq::width() const\n{\n      return mem_->vector_width();\n}\n\nunsigned NetArrayDq::awidth() const\n{\n      return awidth_;\n}\n\nconst NetNet* NetArrayDq::mem() const\n{\n      return mem_;\n}\n\nLink& NetArrayDq::pin_Result()\n{\n      return pin(0);\n}\n\nLink& NetArrayDq::pin_Address()\n{\n      return pin(1);\n}\n\nconst Link& NetArrayDq::pin_Result() const\n{\n      return pin(0);\n}\n\nconst Link& NetArrayDq::pin_Address() const\n{\n      return pin(1);\n}\n\n/*\n * The pinout for the NetCLShift is:\n *    0  -- Result\n *    1  -- Data\n *    2  -- Distance\n */\nNetCLShift::NetCLShift(NetScope*s, perm_string n,\n\t\t       unsigned width__, unsigned width_dist__,\n\t\t       bool right_flag__, bool signed_flag__)\n: NetNode(s, n, 3),\n  width_(width__), width_dist_(width_dist__),\n    right_flag_(right_flag__), signed_flag_(signed_flag__)\n{\n      pin(0).set_dir(Link::OUTPUT); // Result\n      pin(1).set_dir(Link::INPUT);  // Data\n      pin(2).set_dir(Link::INPUT);  // Distance\n}\n\nNetCLShift::~NetCLShift()\n{\n}\n\nunsigned NetCLShift::width() const\n{\n      return width_;\n}\n\nunsigned NetCLShift::width_dist() const\n{\n      return width_dist_;\n}\n\nbool NetCLShift::right_flag() const\n{\n      return right_flag_;\n}\n\nbool NetCLShift::signed_flag() const\n{\n      return signed_flag_;\n}\n\nLink& NetCLShift::pin_Data()\n{\n      return pin(1);\n}\n\nconst Link& NetCLShift::pin_Data() const\n{\n      return pin(1);\n}\n\nLink& NetCLShift::pin_Result()\n{\n      return pin(0);\n}\n\nconst Link& NetCLShift::pin_Result() const\n{\n      return pin(0);\n}\n\nLink& NetCLShift::pin_Distance()\n{\n      return pin(2);\n}\n\nconst Link& NetCLShift::pin_Distance() const\n{\n      return pin(2);\n}\n\nNetCompare::NetCompare(NetScope*s, perm_string n, unsigned wi)\n: NetNode(s, n, 8), width_(wi)\n{\n      signed_flag_ = false;\n      pin(0).set_dir(Link::OUTPUT); // AGB\n      pin(1).set_dir(Link::OUTPUT); // AGEB\n      pin(2).set_dir(Link::OUTPUT); // AEB\n      pin(3).set_dir(Link::OUTPUT); // ANEB\n      pin(4).set_dir(Link::OUTPUT); // ALB\n      pin(5).set_dir(Link::OUTPUT); // ALEB\n      pin(6).set_dir(Link::INPUT);  // DataA\n      pin(7).set_dir(Link::INPUT);  // DataB\n}\n\nNetCompare::~NetCompare()\n{\n}\n\nunsigned NetCompare::width() const\n{\n      return width_;\n}\n\nbool NetCompare::get_signed() const\n{\n      return signed_flag_;\n}\n\nvoid NetCompare::set_signed(bool flag)\n{\n      signed_flag_ = flag;\n}\n\n\nLink& NetCompare::pin_AGB()\n{\n      return pin(0);\n}\n\nconst Link& NetCompare::pin_AGB() const\n{\n      return pin(0);\n}\n\nLink& NetCompare::pin_AGEB()\n{\n      return pin(1);\n}\n\nconst Link& NetCompare::pin_AGEB() const\n{\n      return pin(1);\n}\n\nLink& NetCompare::pin_AEB()\n{\n      return pin(2);\n}\n\nconst Link& NetCompare::pin_AEB() const\n{\n      return pin(2);\n}\n\nLink& NetCompare::pin_ANEB()\n{\n      return pin(3);\n}\n\nconst Link& NetCompare::pin_ANEB() const\n{\n      return pin(3);\n}\n\nLink& NetCompare::pin_ALB()\n{\n      return pin(4);\n}\n\nconst Link& NetCompare::pin_ALB() const\n{\n      return pin(4);\n}\n\nLink& NetCompare::pin_ALEB()\n{\n      return pin(5);\n}\n\nconst Link& NetCompare::pin_ALEB() const\n{\n      return pin(5);\n}\n\nLink& NetCompare::pin_DataA()\n{\n      return pin(6);\n}\n\nconst Link& NetCompare::pin_DataA() const\n{\n      return pin(6);\n}\n\nLink& NetCompare::pin_DataB()\n{\n      return pin(7);\n}\n\nconst Link& NetCompare::pin_DataB() const\n{\n      return pin(7);\n}\n\nNetDivide::NetDivide(NetScope*sc, perm_string n, unsigned wr,\n\t\t     unsigned wa, unsigned wb)\n: NetNode(sc, n, 3),\n    width_r_(wr), width_a_(wa), width_b_(wb), signed_flag_(false)\n{\n      pin(0).set_dir(Link::OUTPUT); // Result\n      pin(1).set_dir(Link::INPUT);  // DataA\n      pin(2).set_dir(Link::INPUT);  // DataB\n}\n\nNetDivide::~NetDivide()\n{\n}\n\nunsigned NetDivide::width_r() const\n{\n      return width_r_;\n}\n\nunsigned NetDivide::width_a() const\n{\n      return width_a_;\n}\n\nunsigned NetDivide::width_b() const\n{\n      return width_b_;\n}\n\nvoid NetDivide::set_signed(bool flag)\n{\n      signed_flag_ = flag;\n}\n\nbool NetDivide::get_signed() const\n{\n      return signed_flag_;\n}\n\nLink& NetDivide::pin_Result()\n{\n      return pin(0);\n}\n\nconst Link& NetDivide::pin_Result() const\n{\n      return pin(0);\n}\n\nLink& NetDivide::pin_DataA()\n{\n      return pin(1);\n}\n\nconst Link& NetDivide::pin_DataA() const\n{\n      return pin(1);\n}\n\nLink& NetDivide::pin_DataB()\n{\n      return pin(2);\n}\n\nconst Link& NetDivide::pin_DataB() const\n{\n      return pin(2);\n}\n\nNetLiteral::NetLiteral(NetScope*sc, perm_string n, const verireal&val)\n: NetNode(sc, n, 1), real_(val)\n{\n      pin(0).set_dir(Link::OUTPUT);\n}\n\nNetLiteral::~NetLiteral()\n{\n}\n\nivl_variable_type_t NetLiteral::data_type() const\n{\n      return IVL_VT_REAL;\n}\n\nconst verireal& NetLiteral::value_real() const\n{\n      return real_;\n}\n\nNetMult::NetMult(NetScope*sc, perm_string n, unsigned wr,\n\t\t unsigned wa, unsigned wb)\n: NetNode(sc, n, 3),\n  signed_(false), width_r_(wr), width_a_(wa), width_b_(wb)\n{\n      pin(0).set_dir(Link::OUTPUT); // Result\n      pin(1).set_dir(Link::INPUT);  // DataA\n      pin(2).set_dir(Link::INPUT);  // DataB\n}\n\nNetMult::~NetMult()\n{\n}\n\nvoid NetMult::set_signed(bool flag)\n{\n      signed_ = flag;\n}\n\nbool NetMult::get_signed() const\n{\n      return signed_;\n}\n\nunsigned NetMult::width_r() const\n{\n      return width_r_;\n}\n\nunsigned NetMult::width_a() const\n{\n      return width_a_;\n}\n\nunsigned NetMult::width_b() const\n{\n      return width_b_;\n}\n\nLink& NetMult::pin_Result()\n{\n      return pin(0);\n}\n\nconst Link& NetMult::pin_Result() const\n{\n      return pin(0);\n}\n\nLink& NetMult::pin_DataA()\n{\n      return pin(1);\n}\n\nconst Link& NetMult::pin_DataA() const\n{\n      return pin(1);\n}\n\nLink& NetMult::pin_DataB()\n{\n      return pin(2);\n}\n\nconst Link& NetMult::pin_DataB() const\n{\n      return pin(2);\n}\n\nNetPow::NetPow(NetScope*sc, perm_string n, unsigned wr,\n\t\t unsigned wa, unsigned wb)\n: NetNode(sc, n, 3),\n  signed_(false), width_r_(wr), width_a_(wa), width_b_(wb)\n{\n      pin(0).set_dir(Link::OUTPUT); // Result\n      pin(1).set_dir(Link::INPUT);  // DataA\n      pin(2).set_dir(Link::INPUT);  // DataB\n}\n\nNetPow::~NetPow()\n{\n}\n\nvoid NetPow::set_signed(bool flag)\n{\n      signed_ = flag;\n}\n\nbool NetPow::get_signed() const\n{\n      return signed_;\n}\n\nunsigned NetPow::width_r() const\n{\n      return width_r_;\n}\n\nunsigned NetPow::width_a() const\n{\n      return width_a_;\n}\n\nunsigned NetPow::width_b() const\n{\n      return width_b_;\n}\n\nLink& NetPow::pin_Result()\n{\n      return pin(0);\n}\n\nconst Link& NetPow::pin_Result() const\n{\n      return pin(0);\n}\n\nLink& NetPow::pin_DataA()\n{\n      return pin(1);\n}\n\nconst Link& NetPow::pin_DataA() const\n{\n      return pin(1);\n}\n\nLink& NetPow::pin_DataB()\n{\n      return pin(2);\n}\n\nconst Link& NetPow::pin_DataB() const\n{\n      return pin(2);\n}\n\n/*\n * The NetMux class represents an LPM_MUX device. The pinout is assigned\n * like so:\n *    0   -- Result\n *    1   -- Sel\n *    2+N -- Data[N]  (N is the size of the mux)\n */\n\nNetMux::NetMux(NetScope*s, perm_string n,\n\t       unsigned wi, unsigned si, unsigned sw)\n: NetNode(s, n, 2+si),\n  width_(wi), size_(si), swidth_(sw)\n{\n      pin(0).set_dir(Link::OUTPUT); // Q\n      pin(1).set_dir(Link::INPUT);  // Sel\n\n      for (unsigned idx = 0 ;  idx < size_ ;  idx += 1) {\n\t    pin_Data(idx).set_dir(Link::INPUT); // Data[idx]\n      }\n}\n\nNetMux::~NetMux()\n{\n}\n\nunsigned NetMux::width()const\n{\n      return width_;\n}\n\nunsigned NetMux::size() const\n{\n      return size_;\n}\n\nunsigned NetMux::sel_width() const\n{\n      return swidth_;\n}\n\nLink& NetMux::pin_Result()\n{\n      return pin(0);\n}\n\nconst Link& NetMux::pin_Result() const\n{\n      return pin(0);\n}\n\nLink& NetMux::pin_Sel()\n{\n      return pin(1);\n}\n\nconst Link& NetMux::pin_Sel() const\n{\n      return pin(1);\n}\n\nLink& NetMux::pin_Data(unsigned s)\n{\n      ivl_assert(*this, s < size_);\n      return pin(2+s);\n}\n\nconst Link& NetMux::pin_Data(unsigned s) const\n{\n      ivl_assert(*this, s < size_);\n      return pin(2+s);\n}\n\nNetSignExtend::NetSignExtend(NetScope*s, perm_string n, unsigned w)\n: NetNode(s, n, 2), width_(w)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetSignExtend::~NetSignExtend()\n{\n}\n\nunsigned NetSignExtend::width() const\n{\n      return width_;\n}\n\nNetBUFZ::NetBUFZ(NetScope*s, perm_string n, unsigned w, bool trans, int port_info_index)\n: NetNode(s, n, 2), width_(w), transparent_(trans), port_info_index_(port_info_index)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetBUFZ::~NetBUFZ()\n{\n}\n\nunsigned NetBUFZ::width() const\n{\n      return width_;\n}\n\nNetCaseCmp::NetCaseCmp(NetScope*s, perm_string n, unsigned wid, kind_t k)\n: NetNode(s, n, 3), width_(wid), kind_(k)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n      pin(2).set_dir(Link::INPUT);\n}\n\nNetCaseCmp::~NetCaseCmp()\n{\n}\n\nunsigned NetCaseCmp::width() const\n{\n      return width_;\n}\n\nNetCondit::NetCondit(NetExpr*ex, NetProc*i, NetProc*e)\n: expr_(ex), if_(i), else_(e)\n{\n}\n\nNetCondit::~NetCondit()\n{\n      delete expr_;\n      delete if_;\n      delete else_;\n}\n\nconst NetExpr* NetCondit::expr() const\n{\n      return expr_;\n}\n\nNetExpr* NetCondit::expr()\n{\n      return expr_;\n}\n\nvoid NetCondit::set_expr(NetExpr*ex)\n{\n      delete expr_;\n      expr_ = ex;\n}\n\nNetProc* NetCondit::if_clause()\n{\n      return if_;\n}\n\nNetProc* NetCondit::else_clause()\n{\n      return else_;\n}\n\nNetConst::NetConst(NetScope*s, perm_string n, verinum::V v)\n: NetNode(s, n, 1), value_(v, 1)\n{\n      pin(0).set_dir(Link::OUTPUT);\n}\n\nNetConst::NetConst(NetScope*s, perm_string n, const verinum&val)\n: NetNode(s, n, 1), value_(val)\n{\n      pin(0).set_dir(Link::OUTPUT);\n}\n\nNetConst::~NetConst()\n{\n}\n\nverinum::V NetConst::value(unsigned idx) const\n{\n      ivl_assert(*this, idx < width());\n      return value_[idx];\n}\n\nNetBaseDef::NetBaseDef(NetScope*s, const vector<NetNet*>&po, const std::vector<NetExpr*>&pd)\n: scope_(s), ports_(po), pdefaults_(pd)\n{\n      proc_ = 0;\n}\n\nNetBaseDef::~NetBaseDef()\n{\n}\n\nconst NetScope* NetBaseDef::scope() const\n{\n      return scope_;\n}\n\nNetScope*NetBaseDef::scope()\n{\n      return scope_;\n}\n\nunsigned NetBaseDef::port_count() const\n{\n      return ports_.size();\n}\n\nNetNet* NetBaseDef::port(unsigned idx) const\n{\n      assert(idx < ports_.size());\n      return ports_[idx];\n}\n\nNetExpr* NetBaseDef::port_defe(unsigned idx) const\n{\n      assert(idx < pdefaults_.size());\n      return pdefaults_[idx];\n}\n\nvoid NetBaseDef::set_proc(NetProc*st)\n{\n      assert(proc_ == 0);\n      assert(st != 0);\n      proc_ = st;\n}\n\nconst NetProc* NetBaseDef::proc() const\n{\n      return proc_;\n}\n\nNetFuncDef::NetFuncDef(NetScope*s, NetNet*result, const vector<NetNet*>&po,\n\t\t       const vector<NetExpr*>&pd)\n: NetBaseDef(s, po, pd), result_sig_(result)\n{\n}\n\nNetFuncDef::~NetFuncDef()\n{\n}\n\nconst NetNet* NetFuncDef::return_sig() const\n{\n      return result_sig_;\n}\n\nNetSTask::NetSTask(const char*na, ivl_sfunc_as_task_t sfat,\n                   const vector<NetExpr*>&pa)\n: name_(0), sfunc_as_task_(sfat), parms_(pa)\n{\n      name_ = lex_strings.add(na);\n      ivl_assert(*this, name_[0] == '$');\n}\n\nNetSTask::~NetSTask()\n{\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1)\n\t    delete parms_[idx];\n\n\t/* The name_ string is perm-allocated in lex_strings. */\n}\n\nconst char*NetSTask::name() const\n{\n      return name_;\n}\n\nivl_sfunc_as_task_t NetSTask::sfunc_as_task() const\n{\n      return sfunc_as_task_;\n}\n\nunsigned NetSTask::nparms() const\n{\n      return parms_.size();\n}\n\nconst NetExpr* NetSTask::parm(unsigned idx) const\n{\n      return parms_[idx];\n}\n\nNetEUFunc::NetEUFunc(NetScope*scope, NetScope*def, NetESignal*res,\n                     vector<NetExpr*>&p, bool nc)\n: NetExpr(res->net_type()), scope_(scope), func_(def), result_sig_(res), parms_(p), need_const_(nc)\n{\n}\n\nNetEUFunc::~NetEUFunc()\n{\n      for (unsigned idx = 0 ;  idx < parms_.size() ;  idx += 1)\n\t    delete parms_[idx];\n}\n#if 0\nconst string NetEUFunc::name() const\n{\n      return func_->name();\n}\n#endif\nconst NetESignal*NetEUFunc::result_sig() const\n{\n      return result_sig_;\n}\n\nunsigned NetEUFunc::parm_count() const\n{\n      return parms_.size();\n}\n\nconst NetExpr* NetEUFunc::parm(unsigned idx) const\n{\n      ivl_assert(*this, idx < parms_.size());\n      return parms_[idx];\n}\n\nconst NetScope* NetEUFunc::func() const\n{\n      return func_;\n}\n\nNetUTask::NetUTask(NetScope*def)\n: task_(def)\n{\n}\n\nNetUTask::~NetUTask()\n{\n}\n\nconst NetScope* NetUTask::task() const\n{\n      return task_;\n}\n\nNetAlloc::NetAlloc(NetScope*scope__)\n: scope_(scope__)\n{\n}\n\nNetAlloc::~NetAlloc()\n{\n}\n#if 0\nconst string NetAlloc::name() const\n{\n      return scope_->name();\n}\n#endif\nconst NetScope* NetAlloc::scope() const\n{\n      return scope_;\n}\n\nNetFree::NetFree(NetScope*scope__)\n: scope_(scope__)\n{\n}\n\nNetFree::~NetFree()\n{\n}\n#if 0\nconst string NetFree::name() const\n{\n      return scope_->name();\n}\n#endif\nconst NetScope* NetFree::scope() const\n{\n      return scope_;\n}\n\n/*\n * Create a bitwise operator node from the opcode and the left and\n * right expressions.\n */\nNetEBBits::NetEBBits(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: NetEBinary(op__, l, r, wid, signed_flag)\n{\n}\n\nNetEBBits::~NetEBBits()\n{\n}\n\nivl_variable_type_t NetEBBits::expr_type() const\n{\n      if (left_->expr_type() == IVL_VT_LOGIC ||\n          right_->expr_type() == IVL_VT_LOGIC)\n\t    return IVL_VT_LOGIC;\n\n      return IVL_VT_BOOL;\n}\n\nNetEBinary::NetEBinary(char op__, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag)\n: op_(op__), left_(l), right_(r)\n{\n      expr_width(wid);\n      cast_signed_base_(signed_flag);\n}\n\nNetEBinary::~NetEBinary()\n{\n      delete left_;\n      delete right_;\n}\n\nbool NetEBinary::has_width() const\n{\n      return left_->has_width() && right_->has_width();\n}\n\nNetEBLogic::NetEBLogic(char op__, NetExpr*l, NetExpr*r)\n: NetEBinary(op__, l, r, 1, false)\n{\n}\n\nNetEBLogic::~NetEBLogic()\n{\n}\n\nivl_variable_type_t NetEBLogic::expr_type() const\n{\n      if (left_->expr_type() == IVL_VT_LOGIC ||\n          right_->expr_type() == IVL_VT_LOGIC)\n\t    return IVL_VT_LOGIC;\n\n      return IVL_VT_BOOL;\n}\n\nNetEConst::NetEConst(const verinum&val)\n: NetExpr(val.len()), value_(val)\n{\n      cast_signed_base_(value_.has_sign());\n}\n\nNetEConst::NetEConst(ivl_type_t type, const verinum&val)\n: NetExpr(type), value_(val)\n{\n      ivl_assert(*this, type->packed());\n      ivl_assert(*this, type->packed_width() >= 0 &&\n                        (unsigned long)type->packed_width() == val.len());\n      ivl_assert(*this, type->get_signed() == val.has_sign());\n}\n\nNetEConst::~NetEConst()\n{\n}\n\nvoid NetEConst::cast_signed(bool flag)\n{\n      cast_signed_base_(flag);\n      value_.has_sign(flag);\n}\n\nconst verinum& NetEConst::value() const\n{\n      return value_;\n}\n\nbool NetEConst::has_width() const\n{\n      return value_.has_len();\n}\n\nivl_variable_type_t NetEConst::expr_type() const\n{\n      if (value_.len() == 0)\n\t    return IVL_VT_LOGIC;\n      if (value_.is_string())\n\t    return IVL_VT_BOOL;\n      if (value_.is_defined())\n\t    return IVL_VT_BOOL;\n\n      return IVL_VT_LOGIC;\n}\n\nvoid NetEConst::trim()\n\n{\n      if (value_.is_string())\n            return;\n\n      value_.has_len(false);\n      value_ = trim_vnum(value_);\n      expr_width(value_.len());\n}\n\nNetEConstParam::NetEConstParam(const NetScope*s, perm_string n, const verinum&v)\n: NetEConst(v), scope_(s), name_(n)\n{\n      cast_signed_base_(v.has_sign());\n}\n\nNetEConstParam::~NetEConstParam()\n{\n}\n\nperm_string NetEConstParam::name() const\n{\n      return name_;\n}\n\nconst NetScope* NetEConstParam::scope() const\n{\n      return scope_;\n}\n\nNetEEvent::NetEEvent(NetEvent*e)\n: event_(e)\n{\n    e->exprref_ += 1;\n}\n\nNetEEvent::~NetEEvent()\n{\n}\n\nconst NetEvent* NetEEvent::event() const\n{\n      return event_;\n}\n\nNetEScope::NetEScope(NetScope*s)\n: scope_(s)\n{\n}\n\nNetEScope::~NetEScope()\n{\n}\n\nconst NetScope* NetEScope::scope() const\n{\n      return scope_;\n}\n\nNetESignal::NetESignal(NetNet*n)\n: NetExpr(n->net_type()), net_(n), word_(0)\n{\n      net_->incr_eref();\n      set_line(*n);\n}\n\nNetESignal::NetESignal(NetNet*n, NetExpr*w)\n: NetExpr(n->vector_width()), net_(n), word_(w)\n{\n      net_->incr_eref();\n      set_line(*n);\n\n      if (word_)\n\t    set_net_type(net_->net_type());\n      else\n\t    set_net_type(net_->array_type());\n}\n\nNetESignal::~NetESignal()\n{\n      net_->decr_eref();\n}\n\nperm_string NetESignal::name() const\n{\n      return net_->name();\n}\n\nconst NetExpr* NetESignal::word_index() const\n{\n      return word_;\n}\n\nunsigned NetESignal::vector_width() const\n{\n      return net_->vector_width();\n}\n\nconst NetNet* NetESignal::sig() const\n{\n      return net_;\n}\n\nNetNet* NetESignal::sig()\n{\n      return net_;\n}\n\n/*\n * The lsi() and msi() methods should be removed from the NetESignal\n * class, to be replaced with packed dimensions aware methods of\n * getting at dimensions.\n */\nlong NetESignal::lsi() const\n{\n      const netranges_t&packed = net_->packed_dims();\n      ivl_assert(*this, packed.size() == 1);\n      return packed.back().get_lsb();\n}\n\nlong NetESignal::msi() const\n{\n      const netranges_t&packed = net_->packed_dims();\n      ivl_assert(*this, packed.size() == 1);\n      return packed.back().get_msb();\n}\n\nivl_variable_type_t NetESignal::expr_type() const\n{\n      if (net_->darray_type())\n\t    return IVL_VT_DARRAY;\n      else\n\t    return net_->data_type();\n}\n\n/*\n* Make a ternary operator from all the sub-expressions. The condition\n* expression is self-determined, but the true and false expressions\n* should have the same width. NOTE: This matching of the widths really\n* has to be done in elaboration.\n*/\nNetETernary::NetETernary(NetExpr*c, NetExpr*t, NetExpr*f,\n                         unsigned wid, bool signed_flag)\n: cond_(c), true_val_(t), false_val_(f)\n{\n      expr_width(wid);\n      cast_signed_base_(signed_flag);\n}\n\nNetETernary::~NetETernary()\n{\n      delete cond_;\n      delete true_val_;\n      delete false_val_;\n}\n\nconst netenum_t* NetETernary::enumeration() const\n{\n\t// If the condition can evaluate to an ambiguous value,\n\t// the result may be blended, and so is not guaranteed\n\t// to be a valid enumeration value.\n      if (cond_->expr_type() != IVL_VT_BOOL)\n\t    return 0;\n\n      if (true_val_->enumeration() != false_val_->enumeration())\n\t    return 0;\n\n      return true_val_->enumeration();\n}\n\nconst NetExpr* NetETernary::cond_expr() const\n{\n      return cond_;\n}\n\nconst NetExpr* NetETernary::true_expr() const\n{\n      return true_val_;\n}\n\nconst NetExpr* NetETernary::false_expr() const\n{\n      return false_val_;\n}\n\nivl_variable_type_t NetETernary::expr_type() const\n{\n      ivl_assert(*this, true_val_);\n      ivl_assert(*this, false_val_);\n      ivl_variable_type_t tru = true_val_->expr_type();\n      ivl_variable_type_t fal = false_val_->expr_type();\n      ivl_variable_type_t sel = cond_->expr_type();\n      if (tru == IVL_VT_LOGIC && fal == IVL_VT_BOOL)\n\t    return IVL_VT_LOGIC;\n      if (tru == IVL_VT_BOOL && fal == IVL_VT_LOGIC)\n\t    return IVL_VT_LOGIC;\n      if (sel == IVL_VT_LOGIC && (tru == IVL_VT_LOGIC || tru == IVL_VT_BOOL) && (fal == IVL_VT_LOGIC || fal == IVL_VT_BOOL))\n\t    return IVL_VT_LOGIC;\n      if (tru == IVL_VT_REAL && (fal == IVL_VT_LOGIC || fal == IVL_VT_BOOL))\n\t    return IVL_VT_REAL;\n      if (fal == IVL_VT_REAL && (tru == IVL_VT_LOGIC || tru == IVL_VT_BOOL))\n\t    return IVL_VT_REAL;\n\n      if (tru != fal) {\n\t    cerr << get_fileline() << \": internal error:\"\n\t\t << \" Unexpected ?: type clash:\"\n\t\t << \" tru=\" << tru << \", fal=\" << fal << endl;\n      }\n      ivl_assert(*this, tru == fal);\n      return tru;\n}\n\nNetEUnary::NetEUnary(char op__, NetExpr*ex, unsigned wid, bool signed_flag)\n: NetExpr(wid), op_(op__), expr_(ex)\n{\n      cast_signed_base_(signed_flag);\n}\n\nNetEUnary::~NetEUnary()\n{\n      delete expr_;\n}\n\nivl_variable_type_t NetEUnary::expr_type() const\n{\n      return expr_->expr_type();\n}\n\nNetEUBits::NetEUBits(char op__, NetExpr*ex, unsigned wid, bool signed_flag)\n: NetEUnary(op__, ex, wid, signed_flag)\n{\n}\n\nNetEUBits::~NetEUBits()\n{\n}\n\nivl_variable_type_t NetEUBits::expr_type() const\n{\n      return expr_->expr_type();\n}\n\nNetEUReduce::NetEUReduce(char op__, NetExpr*ex)\n: NetEUnary(op__, ex, 1, false)\n{\n}\n\nNetEUReduce::~NetEUReduce()\n{\n}\n\nivl_variable_type_t NetEUReduce::expr_type() const\n{\n      return expr_->expr_type();\n}\n\nNetECast::NetECast(char op__, NetExpr*ex, unsigned wid, bool signed_flag)\n: NetEUnary(op__, ex, wid, signed_flag)\n{\n}\n\nNetECast::~NetECast()\n{\n}\n\nivl_variable_type_t NetECast::expr_type() const\n{\n      ivl_variable_type_t ret = IVL_VT_NO_TYPE;\n      switch (op_) {\n\t  case 'v':\n\t    ret = IVL_VT_LOGIC;\n\t    break;\n\t  case 'r':\n\t    ret = IVL_VT_REAL;\n\t    break;\n\t  case '2':\n\t    ret = IVL_VT_BOOL;\n\t    break;\n\t  default:\n\t    ivl_assert(*this, 0);\n      }\n\n      return ret;\n}\n\nNetLogic::NetLogic(NetScope*s, perm_string n, unsigned pins,\n\t\t   TYPE t, unsigned wid, bool is_cassign__)\n: NetNode(s, n, pins), type_(t), width_(wid), is_cassign_(is_cassign__)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      for (unsigned idx = 1 ;  idx < pins ;  idx += 1) {\n\t    pin(idx).set_dir(Link::INPUT);\n      }\n}\n\nNetLogic::TYPE NetLogic::type() const\n{\n      return type_;\n}\n\nunsigned NetLogic::width() const\n{\n      return width_;\n}\n\nbool NetLogic::is_cassign() const\n{\n      return is_cassign_;\n}\n\nNetUReduce::NetUReduce(NetScope*scope__, perm_string n,\n\t\t       NetUReduce::TYPE t, unsigned wid)\n: NetNode(scope__, n, 2), type_(t), width_(wid)\n{\n      pin(0).set_dir(Link::OUTPUT);\n      pin(1).set_dir(Link::INPUT);\n}\n\nNetUReduce::TYPE NetUReduce::type() const\n{\n      return type_;\n}\n\nunsigned NetUReduce::width() const\n{\n      return width_;\n}\n\nNetTaskDef::NetTaskDef(NetScope*n, const vector<NetNet*>&po, const vector<NetExpr*>&pd)\n: NetBaseDef(n, po, pd)\n{\n}\n\nNetTaskDef::~NetTaskDef()\n{\n      delete proc_;\n}\n\n/*\n * These are the delay_type() functions. They are used to determine\n * the type of delay for the given object.\n */\n\n/*\n * This function implements the following table:\n *\n * in_A  in_B   out\n *   NO    NO    NO\n *   NO  ZERO  ZERO\n *   NO   POS   POS\n *   NO   DEF   POS\n * ZERO    NO  ZERO\n * ZERO  ZERO  ZERO\n * ZERO   POS   POS\n * ZERO   DEF   POS\n *  POS    NO   POS\n *  POS  ZERO   POS\n *  POS   POS   POS\n *  POS   DEF   POS\n *  DEF    NO   POS\n *  DEF  ZERO   POS\n *  DEF   POS   POS\n *  DEF   DEF   DEF\n *\n * It is used to combine two delay values.\n */\nstatic DelayType combine_delays(const DelayType a, const DelayType b)\n{\n\t/* The default is POSSIBLE_DELAY. */\n      DelayType result = POSSIBLE_DELAY;\n\n\t/* If both are no or zero delay then we return ZERO_DELAY. */\n      if ((a == NO_DELAY || a == ZERO_DELAY) &&\n          (b == NO_DELAY || b == ZERO_DELAY)) {\n\t    result = ZERO_DELAY;\n      }\n\n\t/* Except if both are no delay then we return NO_DELAY. */\n      if (a == NO_DELAY && b == NO_DELAY) {\n\t    result = NO_DELAY;\n      }\n\n\t/* If both are definite delay then we return DEFINITE_DELAY. */\n      if (a == DEFINITE_DELAY && b == DEFINITE_DELAY) {\n\t    result = DEFINITE_DELAY;\n      }\n\n      return result;\n}\n\n/*\n * This is used to see what we can find out about the delay when it\n * is given as an expression. We also use this for loop expressions.\n */\nstatic DelayType delay_type_from_expr(const NetExpr*expr)\n{\n      DelayType result = POSSIBLE_DELAY;\n\n      if (const NetEConst*e = dynamic_cast<const NetEConst*>(expr)) {\n\t    if (e->value().is_zero()) result = ZERO_DELAY;\n\t    else result = DEFINITE_DELAY;\n      }\n\n      if (const NetECReal*e = dynamic_cast<const NetECReal*>(expr)) {\n\t    if (e->value().as_double() == 0.0) result = ZERO_DELAY;\n\t    else result = DEFINITE_DELAY;\n      }\n\n      return result;\n}\n\n/*\n * The looping structures can use the same basic code so put it here\n * instead of duplicating it for each one (repeat and while).\n */\nstatic DelayType get_loop_delay_type(const NetExpr*expr, const NetProc*proc, bool print_delay)\n{\n      DelayType result;\n\n      switch (delay_type_from_expr(expr)) {\n\t    /* We have a constant false expression so the body never runs. */\n\t  case ZERO_DELAY:\n\t    result = NO_DELAY;\n\t    break;\n\t    /* We have a constant true expression so the body always runs. */\n\t  case DEFINITE_DELAY:\n\t    if (proc) {\n\t\t  result = proc->delay_type(print_delay);\n\t    } else {\n\t\t  result = NO_DELAY;\n\t    }\n\t    break;\n\t    /* We don't know if the body will run so reduce a DEFINITE_DELAY\n\t     * to a POSSIBLE_DELAY. All other stay the same. */\n\t  case POSSIBLE_DELAY:\n\t    if (proc) {\n\t\t  result = combine_delays(NO_DELAY, proc->delay_type(print_delay));\n\t    } else {\n\t\t  result = NO_DELAY;\n\t    }\n\t    break;\n\t    /* This should never happen since delay_type_from_expr() only\n\t     * returns three different values. */\n\t  default:\n\t    result = NO_DELAY;\n\t    ivl_assert(*expr, 0);\n      }\n\n      return result;\n}\n\n/* The default object does not have any delay. */\nDelayType NetProc::delay_type(bool /* print_delay */ ) const\n{\n      return NO_DELAY;\n}\n\nDelayType NetBlock::delay_type(bool print_delay) const\n{\n\t// A join_none has no delay.\n      if (type() == PARA_JOIN_NONE) return NO_DELAY;\n\n      DelayType result;\n\t// A join_any has the minimum delay.\n      if (type() == PARA_JOIN_ANY) {\n\t    result = DEFINITE_DELAY;\n\t    for (const NetProc*cur = proc_first(); cur; cur = proc_next(cur)) {\n\t\t  DelayType dt = cur->delay_type(print_delay);\n\t\t  if (dt < result) result = dt;\n\t\t  if ((dt == NO_DELAY) && !print_delay) break;\n\t    }\n\n\t// A begin or join has the maximum delay.\n      } else {\n\t    result = NO_DELAY;\n\t    for (const NetProc*cur = proc_first(); cur; cur = proc_next(cur)) {\n\t\t  DelayType dt = cur->delay_type(print_delay);\n\t\t  if (dt > result) result = dt;\n\t\t  if ((dt == DEFINITE_DELAY) && !print_delay) break;\n\t    }\n      }\n\n      return result;\n}\n\nDelayType NetCase::delay_type(bool print_delay) const\n{\n      DelayType result = NO_DELAY;\n      bool def_stmt = false;\n      unsigned nstmts = nitems();\n\n      for (unsigned idx = 0; idx < nstmts; idx += 1) {\n\t    if (!expr(idx)) def_stmt = true;\n\t    DelayType dt = stat(idx) ? stat(idx)->delay_type(print_delay) : NO_DELAY;\n            if (idx == 0) {\n\t\t  result = dt;\n            } else {\n\t\t  result = combine_delays(result, dt);\n            }\n      }\n\n// FIXME: If all the cases are covered (e.g. an enum) then this is not true.\n\t/* If we don't have a default statement we don't know for sure\n\t * that we have a delay. */\n      if (!def_stmt) result = combine_delays(NO_DELAY, result);\n\n      return result;\n}\n\nDelayType NetCondit::delay_type(bool print_delay) const\n{\n      DelayType if_type = if_  ? if_->delay_type(print_delay)   : NO_DELAY;\n      DelayType el_type = else_? else_->delay_type(print_delay) : NO_DELAY;\n      return combine_delays(if_type, el_type);\n}\n\n/*\n * A do/while will execute the body at least once.\n */\nDelayType NetDoWhile::delay_type(bool print_delay) const\n{\n      if (proc_) return proc_->delay_type(print_delay);\n\n      return ZERO_DELAY;\n}\n\nDelayType NetEvWait::delay_type(bool print_delay) const\n{\n      if (print_delay) {\n\t    cerr << get_fileline() << \": error: an event control is not allowed \"\n\t            \"in an always_comb, always_ff or always_latch process.\"\n\t         << endl;\n      }\n\n      return DEFINITE_DELAY;\n}\n\nDelayType NetForever::delay_type(bool print_delay) const\n{\n      if (statement_) return statement_->delay_type(print_delay);\n\n      return ZERO_DELAY;\n}\n\nDelayType NetForLoop::delay_type(bool print_delay) const\n{\n      return get_loop_delay_type(condition_, statement_, print_delay);\n}\n\nDelayType NetPDelay::delay_type(bool print_delay) const\n{\n      if (print_delay) {\n\t    cerr << get_fileline() << \": error: a blocking delay is not allowed \"\n\t            \"in an always_comb, always_ff or always_latch process.\"\n\t         << endl;\n      }\n\n      if (expr_) {\n\t    if (statement_) {\n\t\t  return combine_delays(delay_type_from_expr(expr_),\n\t\t                        statement_->delay_type(print_delay));\n\t    } else {\n\t\t  return delay_type_from_expr(expr_);\n\t    }\n      }\n\n      if (delay() > 0) return DEFINITE_DELAY;\n\n      if (statement_) {\n\t    return combine_delays(ZERO_DELAY,\n\t                          statement_->delay_type(print_delay));\n      } else {\n\t    return ZERO_DELAY;\n      }\n}\n\nDelayType NetRepeat::delay_type(bool print_delay) const\n{\n      return get_loop_delay_type(expr_, statement_, print_delay);\n}\n\nDelayType NetTaskDef::delay_type(bool print_delay) const\n{\n      if (proc_) {\n\t    return proc_->delay_type(print_delay);\n      } else {\n\t    return NO_DELAY;\n      }\n}\n\nDelayType NetUTask::delay_type(bool print_delay) const\n{\n\t// Is this a void function call in a final block?\n      if (task()->type() == NetScope::FUNC) {\n\t    return NO_DELAY;\n      } else {\n\t    return task()->task_def()->delay_type(print_delay);\n      }\n}\n\nstatic bool do_expr_event_match(const NetExpr*expr, const NetEvWait*evwt)\n{\n\t// The event wait should only have a single event.\n      if (evwt->nevents() != 1) return false;\n\t// The event should have a single probe.\n      const NetEvent *evt = evwt->event(0);\n      if (evt->nprobe() != 1) return false;\n\t// The probe should be for any edge.\n      const NetEvProbe *prb = evt->probe(0);\n      if (prb->edge() != NetEvProbe::ANYEDGE) return false;\n\t// Create a NexusSet from the event probe signals.\n      NexusSet *ns_evwt = new NexusSet;\n      for (unsigned idx =0; idx < prb->pin_count(); idx += 1) {\n\t    if (! prb->pin(idx).is_linked()) {\n\t\t  delete ns_evwt;\n\t\t  return false;\n\t    }\n\t      // Casting away const is safe since this nexus set is only being read.\n\t    ns_evwt->add(const_cast<Nexus*> (prb->pin(idx).nexus()),\n\t                 0, prb->pin(idx).nexus()->vector_width());\n      }\n\t// Get the NexusSet for the expression.\n      NexusSet *ns_expr = expr->nex_input();\n\t// Make sure the event and expression NexusSets match exactly.\n      if (ns_evwt->size() != ns_expr->size()) {\n\t    delete ns_evwt;\n\t    delete ns_expr;\n\t    return false;\n      }\n      ns_expr->rem(*ns_evwt);\n      delete ns_evwt;\n      if (ns_expr->size() != 0) {\n\t    delete ns_expr;\n\t    return false;\n      }\n      delete ns_expr;\n\n      return true;\n}\n\nstatic bool while_is_wait(const NetExpr*expr, const NetProc*stmt)\n{\n      if (const NetEvWait*evwt = dynamic_cast<const NetEvWait*>(stmt)) {\n\t    if (evwt->statement()) return false;\n\t    const NetEBComp*cond = dynamic_cast<const NetEBComp*>(expr);\n\t    if (! cond) return false;\n\t    if (cond->op() != 'N') return false;\n\t    const NetEConst*cval = dynamic_cast<const NetEConst*>(cond->right());\n\t    if (! cval) return false;\n\t    const verinum val = cval->value();\n\t    if (val.len() != 1) return false;\n\t    if (val.get(0) != verinum::V1) return false;\n\t    if (! do_expr_event_match(cond->left(), evwt)) return false;\n\t    if (evwt->get_lineno() != cond->get_lineno()) return false;\n\t    if (evwt->get_file() != cond->get_file()) return false;\n\t    return true;\n      }\n      return false;\n}\n\nDelayType NetWhile::delay_type(bool print_delay) const\n{\n\t// If the wait was a constant value the compiler already removed it\n\t// so we know we can only have a possible delay.\n      if (while_is_wait(cond_, proc_)) {\n\t    if (print_delay) {\n\t\t  cerr << get_fileline() << \": error: a wait statement is \"\n\t\t          \"not allowed in an \"\n\t\t          \"always_comb, always_ff or always_latch process.\"\n\t\t       << endl;\n\t    }\n\t    return POSSIBLE_DELAY;\n      }\n      return get_loop_delay_type(cond_, proc_, print_delay);\n}\n\n/*\n * These are the check_synth() functions. They are used to print\n * a warning if the item is not synthesizable.\n */\nstatic const char * get_process_type_as_string(ivl_process_type_t pr_type)\n{\n      switch (pr_type) {\n\tcase IVL_PR_ALWAYS_COMB:\n\t    return \"in an always_comb process.\";\n\t    break;\n\tcase IVL_PR_ALWAYS_FF:\n\t    return \"in an always_ff process.\";\n\t    break;\n\tcase IVL_PR_ALWAYS_LATCH:\n\t    return \"in an always_latch process.\";\n\t    break;\n\tdefault:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nstatic void print_synth_warning(const NetProc *net_proc, const char *name,\n                              ivl_process_type_t pr_type)\n{\n      cerr << net_proc->get_fileline() << \": warning: \" << name\n           << \" statement cannot be synthesized \"\n           << get_process_type_as_string(pr_type) << endl;\n}\n\nstatic void check_if_logic_l_value(const NetAssignBase *base,\n                                   ivl_process_type_t pr_type)\n{\n      if (base->l_val_count() != 1) return;\n\n      const NetAssign_*lval = base->l_val(0);\n      if (! lval) return;\n\n      NetNet*sig = lval->sig();\n      if (! sig) return;\n\n      if ((sig->data_type() != IVL_VT_BOOL) &&\n          (sig->data_type() != IVL_VT_LOGIC)) {\n\t    cerr << base->get_fileline() << \": warning: Assigning to a \"\n\t            \"non-integral variable (\"<< sig->name()\n\t         << \") cannot be synthesized \"\n\t         << get_process_type_as_string(pr_type) << endl;\n      }\n}\n\n/* By default elements can be synthesized or ignored. */\nbool NetProc::check_synth(ivl_process_type_t /* pr_type */,\n                          const NetScope* /* scope */ ) const\n{\n      return false;\n}\n\n// FIXME: User function calls still need to be checked (NetEUFunc).\n//      : Non-constant system functions need a warning (NetESFunc).\n//      : Constant functions should already be elaborated.\n\n/* By default assign elements can be synthesized. */\nbool NetAssignBase::check_synth(ivl_process_type_t /* pr_type */,\n                                const NetScope* /* scope */  ) const\n{\n      return false;\n}\n\nbool NetAssign::check_synth(ivl_process_type_t pr_type,\n                            const NetScope* /* scope */ ) const\n{\n      check_if_logic_l_value(this, pr_type);\n\n// FIXME: Check that ff/latch only use this for internal signals.\n      return false;\n}\n\nbool NetAssignNB::check_synth(ivl_process_type_t pr_type,\n                              const NetScope* /* scope */ ) const\n{\n      bool result = false;\n      if (pr_type == IVL_PR_ALWAYS_COMB) {\n\t    cerr << get_fileline() << \": warning: A non-blocking assignment \"\n\t            \"should not be used in an always_comb process.\" << endl;\n      }\n\n      if (event_) {\n\t    cerr << get_fileline() << \": error: A non-blocking assignment \"\n\t            \"cannot be synthesized with an event control \"\n\t         << get_process_type_as_string(pr_type) << endl;\n\t    result = true;\n      }\n\n      check_if_logic_l_value(this, pr_type);\n\n      return result;\n}\n\nbool NetBlock::check_synth(ivl_process_type_t pr_type,\n                           const NetScope* scope) const\n{\n      bool result = false;\n\t// Only a begin/end can be synthesized.\n      if (type() != SEQU) {\n\t    cerr << get_fileline() << \": error: A fork/\";\n\t    switch (type()) {\n\t      case PARA:\n\t\t  cerr << \"join\";\n\t\t  break;\n\t      case PARA_JOIN_ANY:\n\t\t  cerr << \"join_any\";\n\t\t  break;\n\t      case PARA_JOIN_NONE:\n\t\t  cerr << \"join_none\";\n\t\t  break;\n\t      default:\n\t\t  ivl_assert(*this, 0);\n\t    }\n\t    cerr << \" statement cannot be synthesized \"\n                 << get_process_type_as_string(pr_type) << endl;\n\t    result = true;\n      }\n\n      const NetScope*save_scope = scope;\n      if (subscope()) scope = subscope();\n      if (scope != save_scope) {\n\t    result |= scope->check_synth(pr_type, scope);\n      }\n      for (const NetProc*cur = proc_first(); cur; cur = proc_next(cur)) {\n\t    result |= cur->check_synth(pr_type, scope);\n      }\n      return result;\n}\n\nbool NetCase::check_synth(ivl_process_type_t pr_type,\n                          const NetScope* scope) const\n{\n      bool result = false;\n      for (unsigned idx = 0; idx < nitems(); idx += 1) {\n\t    if (stat(idx)) result |= stat(idx)->check_synth(pr_type, scope);\n      }\n// FIXME: Check for ff/latch/comb structures.\n      return result;\n}\n\nbool NetCAssign::check_synth(ivl_process_type_t pr_type,\n                             const NetScope* /* scope */ ) const\n{\n      print_synth_warning(this, \"A procedural assign\", pr_type);\n      return false;\n}\n\nbool NetCondit::check_synth(ivl_process_type_t pr_type,\n                            const NetScope* scope) const\n{\n      bool result = false;\n      if (if_) result |= if_->check_synth(pr_type, scope);\n      if (else_) result |= else_->check_synth(pr_type, scope);\n// FIXME: Check for ff/latch/comb structures.\n      return result;\n}\n\nbool NetDeassign::check_synth(ivl_process_type_t pr_type,\n                              const NetScope* /* scope */ ) const\n{\n      print_synth_warning(this, \"A procedural deassign\", pr_type);\n      return false;\n}\n\nbool NetDisable::check_synth(ivl_process_type_t pr_type,\n                             const NetScope* scope) const\n{\n      while (scope) {\n\t    if (scope != target_) scope = scope->parent();\n\t    else break;\n      }\n\n\n      if (! scope) {\n\t    cerr << get_fileline() << \": warning: A disable statement can \"\n\t            \"only be synthesized when disabling an enclosing block \"\n                 << get_process_type_as_string(pr_type) << endl;\n      }\n      return false;\n}\n\nbool NetDoWhile::check_synth(ivl_process_type_t pr_type,\n                             const NetScope* scope) const\n{\n      bool result = false;\n      print_synth_warning(this, \"A do/while\", pr_type);\n      if (proc_) result |= proc_->check_synth(pr_type, scope);\n      return result;\n}\n\nbool NetEvTrig::check_synth(ivl_process_type_t pr_type,\n                            const NetScope* /* scope */ ) const\n{\n      print_synth_warning(this, \"An event trigger\", pr_type);\n      return false;\n}\n\nbool NetEvNBTrig::check_synth(ivl_process_type_t pr_type,\n                              const NetScope* /* scope */ ) const\n{\n      print_synth_warning(this, \"A non-blocking event trigger\", pr_type);\n      return false;\n}\n\n// The delay check above has already marked this as an error.\nbool NetEvWait::check_synth(ivl_process_type_t pr_type,\n                            const NetScope* scope) const\n{\n      bool result = false;\n      if (statement_) result |= statement_->check_synth(pr_type, scope);\n      return result;\n}\n\nbool NetForce::check_synth(ivl_process_type_t pr_type,\n                           const NetScope* /* scope */ ) const\n{\n      print_synth_warning(this, \"A force\", pr_type);\n      return false;\n}\n\nbool NetForever::check_synth(ivl_process_type_t pr_type,\n                             const NetScope* scope) const\n{\n      bool result = false;\n      print_synth_warning(this, \"A forever\", pr_type);\n      if (statement_) result |= statement_->check_synth(pr_type, scope);\n      return result;\n}\n\n/*\n * A bunch of private routines to verify that a for loop has the correct\n * structure for synthesis.\n */\nstatic void print_for_idx_warning(const NetProc*proc, const char*check,\n                                  ivl_process_type_t pr_type, NetNet*idx)\n{\n      cerr << proc->get_fileline() << \": warning: A for statement must use \"\n              \"the index (\" << idx->name() << \") in the \" << check\n           << \" expression to be synthesized \"\n           << get_process_type_as_string(pr_type) << endl;\n}\n\nstatic void check_for_const_synth(const NetExpr*expr, const NetProc*proc,\n                                  const char*str, ivl_process_type_t pr_type)\n{\n      if (! dynamic_cast<const NetEConst*>(expr)) {\n\t    cerr << proc-> get_fileline() << \": warning: A for \"\n\t            \"statement must \" << str\n\t         << \" value to be synthesized \"\n\t         << get_process_type_as_string(pr_type) << endl;\n      }\n}\n\nstatic void check_for_bin_synth(const NetExpr*left,const NetExpr*right,\n                                const char*str, const char*check,\n                                const NetProc*proc,\n                                ivl_process_type_t pr_type, NetNet*index)\n{\n      const NetESignal*lsig = dynamic_cast<const NetESignal*>(left);\n      const NetESignal*rsig = dynamic_cast<const NetESignal*>(right);\n\n      if (!lsig) {\n            const NetESelect*lsel = dynamic_cast<const NetESelect*>(left);\n            if (lsel && (lsel->expr_width() >= lsel->sub_expr()->expr_width()))\n                  lsig = dynamic_cast<const NetESignal*>(lsel->sub_expr());\n      }\n      if (!rsig) {\n            const NetESelect*rsel = dynamic_cast<const NetESelect*>(right);\n            if (rsel && (rsel->expr_width() >= rsel->sub_expr()->expr_width()))\n                  rsig = dynamic_cast<const NetESignal*>(rsel->sub_expr());\n      }\n\n      if (lsig && (lsig->sig() == index)) {\n\t    check_for_const_synth(right, proc, str, pr_type);\n      } else if (rsig && (rsig->sig() == index)) {\n\t    check_for_const_synth(left, proc, str, pr_type);\n      } else {\n\t    print_for_idx_warning(proc, check, pr_type, index);\n      }\n}\n\nstatic void print_for_step_warning(const NetProc*proc,\n                                   ivl_process_type_t pr_type)\n{\n      cerr << proc->get_fileline() << \": warning: A for statement step must \"\n              \"be a simple assignment statement to be synthesized \"\n           << get_process_type_as_string(pr_type) << endl;\n}\n\nstatic void print_for_step_warning(const NetProc*proc,\n                                   ivl_process_type_t pr_type, NetNet*idx)\n{\n      cerr << proc->get_fileline() << \": warning: A for statement step must \"\n              \"be an assignment to the index variable (\"\n           << idx->name() << \") to be synthesized \"\n           << get_process_type_as_string(pr_type) << endl;\n}\n\nstatic void check_for_bstep_synth(const NetExpr*expr, const NetProc*proc,\n                                  ivl_process_type_t pr_type, NetNet*index)\n{\n      if (const NetECast*tmp = dynamic_cast<const NetECast*>(expr)) {\n\t    expr = tmp->expr();\n      }\n\n      if (const NetEBAdd*tmp = dynamic_cast<const NetEBAdd*>(expr)) {\n\t    check_for_bin_synth(tmp->left(), tmp->right(),\n                                \"change by a constant\", \"step\", proc, pr_type,\n\t                        index);\n      } else {\n\t    cerr << proc->get_fileline() << \": warning: A for statement \"\n\t            \"step must be a simple binary +/- \"\n\t            \"to be synthesized \"\n\t         << get_process_type_as_string(pr_type) << endl;\n      }\n}\n\nstatic void check_for_step_synth(const NetAssign*assign, const NetProc*proc,\n                                 ivl_process_type_t pr_type, NetNet*index)\n{\n      if (assign->l_val_count() != 1) {\n\t    print_for_step_warning(proc, pr_type);\n      } else if (assign->l_val(0)->sig() != index) {\n\t    print_for_step_warning(proc, pr_type, index);\n      } else {\n\t    switch (assign->assign_operator()) {\n\t      case '+':\n\t      case '-':\n\t\t    check_for_const_synth(assign->rval(), proc,\n\t\t                          \"have a constant step\", pr_type);\n\t\t    break;\n\t      case 0:\n\t\t    check_for_bstep_synth(assign->rval(), proc, pr_type, index);\n\t\t    break;\n\t     default:\n\t\t    cerr << proc->get_fileline() << \": warning: A for statement \"\n\t\t            \"step does not support operator '\"\n\t\t         << assign->assign_operator()\n                         << \"' it must be +/- to be synthesized \"\n\t\t         << get_process_type_as_string(pr_type) << endl;\n\t\t   break;\n\t    }\n      }\n}\n\nbool NetForLoop::check_synth(ivl_process_type_t pr_type,\n                             const NetScope* scope) const\n{\n      bool result = false;\n\n// FIXME: What about an enum (NetEConstEnum)?\n      if (! dynamic_cast<const NetEConst*>(init_expr_)) {\n\t    cerr << get_fileline() << \": warning: A for statement must \"\n\t            \"have a constant initial value to be synthesized \"\n                 << get_process_type_as_string(pr_type) << endl;\n      }\n\n// FIXME: Do the following also need to be supported in the condition?\n//        It would seem like they are hard to use to find the bounds.\n//          From NetEBinary\n//            What about NetEBits sig & constant, etc.\n//          From NetEUnary\n//            What about NetEUBits ! sig or ! (sig == constat)\n//            What about NetEUReduce &signal\n      if (const NetESignal*tmp = dynamic_cast<const NetESignal*>(condition_)) {\n\t    if (tmp->sig() != index_) {\n\t\t  print_for_idx_warning(this, \"condition\", pr_type, index_);\n\t    }\n      } else if (const NetEBComp*cmp = dynamic_cast<const NetEBComp*>(condition_)) {\n\t    check_for_bin_synth(cmp->left(), cmp->right(),\n                                \"compare against a constant\", \"condition\",\n\t                        this, pr_type, index_);\n      } else {\n\t    print_for_idx_warning(this, \"condition\", pr_type, index_);\n      }\n\n      if (const NetAssign*tmp = dynamic_cast<const NetAssign*>(step_statement_)) {\n\t    check_for_step_synth(tmp, this, pr_type, index_);\n      } else {\n\t    print_for_step_warning(this, pr_type);\n      }\n\n      if (statement_) result |= statement_->check_synth(pr_type, scope);\n      return result;\n}\n\n// The delay check above has already marked this as an error.\nbool NetPDelay::check_synth(ivl_process_type_t /* pr_type */,\n                            const NetScope* /* scope */ ) const\n{\n      return false;\n}\n\nbool NetRelease::check_synth(ivl_process_type_t pr_type,\n                             const NetScope* /* scope */ ) const\n{\n      print_synth_warning(this, \"A release\", pr_type);\n      return false;\n}\n\nbool NetRepeat::check_synth(ivl_process_type_t pr_type,\n                            const NetScope* scope) const\n{\n      bool result = false;\n      print_synth_warning(this, \"A repeat\", pr_type);\n      if (statement_) result |= statement_->check_synth(pr_type, scope);\n      return result;\n}\n\nbool NetScope::check_synth(ivl_process_type_t pr_type,\n                           const NetScope* /* scope */) const\n{\n      bool result = false;\n\t// Skip local events/signals\n      for (NetEvent*cur = events_ ;  cur ;  cur = cur->snext_) {\n\t    if (cur->local_flag()) continue;\n\t    cerr << cur->get_fileline() << \": warning: An event (\"\n\t         << cur->name() << \") cannot be synthesized \"\n\t         << get_process_type_as_string(pr_type) << endl;\n      }\n      for (signals_map_iter_t cur = signals_map_.begin();\n           cur != signals_map_.end() ; ++ cur) {\n\t    const NetNet*sig = cur->second;\n\t    if ((sig->data_type() != IVL_VT_BOOL) &&\n\t        (sig->data_type() != IVL_VT_LOGIC)) {\n\t\t  cerr << sig->get_fileline() << \": warning: A non-integral \"\n\t\t          \"variable (\" << sig->name() << \") cannot be \"\n\t\t          \"synthesized \"\n\t\t       << get_process_type_as_string(pr_type) << endl;\n\t    }\n      }\n      return result;\n}\n\nbool NetSTask::check_synth(ivl_process_type_t pr_type,\n                           const NetScope* /* scope */) const\n{\n      if (strcmp(name(), \"$ivl_darray_method$delete\") == 0) {\n\t    cerr << get_fileline() << \": warning: Dynamic array \"\n\t            \"delete method cannot be synthesized \"\n\t         << get_process_type_as_string(pr_type) << endl;\n      } else {\n\t    cerr << get_fileline() << \": warning: System task (\"\n\t         << name() << \") cannot be synthesized \"\n\t         << get_process_type_as_string(pr_type) << endl;\n      }\n      return false;\n}\n\n/*\n * This function is called to make sure the task/function can be used\n * in a context where it must be synthesizable, such as in an always_comb\n * or always_ff.\n *\n * If this is a function, then the function must be void.\n */\nbool NetBaseDef::check_synth(ivl_process_type_t pr_type,\n                             const NetScope* /* scope */) const\n{\n      bool result = false;\n      const NetScope *tscope = this->scope();\n      result |= tscope->check_synth(pr_type, tscope);\n      if (! tscope->is_auto()) {\n\t    cerr << tscope->get_def_file() << \":\"\n\t         << tscope->get_def_lineno()\n\t         << \": warning: user task (\" << tscope->basename()\n\t         << \") must be automatic to be synthesized \"\n\t         << get_process_type_as_string(pr_type) << endl;\n      }\n      if (proc_) result |= proc_->check_synth(pr_type, tscope);\n      return result;\n}\n\nbool NetUTask::check_synth(ivl_process_type_t pr_type,\n                           const NetScope* scope) const\n{\n      const NetScope* task_scope = task();\n      if (task_scope->type() == NetScope::FUNC) {\n\t    // This can happen if this a void function.\n\t    return task_scope->func_def()->check_synth(pr_type, scope);\n      } else {\n\t    return task_scope->task_def()->check_synth(pr_type, scope);\n      }\n}\n\nbool NetWhile::check_synth(ivl_process_type_t pr_type,\n                           const NetScope* scope) const\n{\n      bool result = false;\n\t// A wait is already maked as an error in the delay check above.\n      if (! while_is_wait(cond_, proc_)) {\n\t    print_synth_warning(this, \"A while\", pr_type);\n\t    if (proc_) result |= proc_->check_synth(pr_type, scope);\n      }\n      return result;\n}\n"
        },
        {
          "name": "netlist.h",
          "type": "blob",
          "size": 169.8134765625,
          "content": "#ifndef IVL_netlist_H\n#define IVL_netlist_H\n/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n/*\n * The netlist types, as described in this header file, are intended\n * to be the output from elaboration of the source design. The design\n * can be passed around in this form to the various stages and design\n * processors.\n */\n# include  <string>\n# include  <map>\n# include  <list>\n# include  <memory>\n# include  <vector>\n# include  <set>\n# include  <utility>\n# include  \"ivl_target.h\"\n# include  \"ivl_target_priv.h\"\n# include  \"pform_types.h\"\n# include  \"config.h\"\n# include  \"nettypes.h\"\n# include  \"verinum.h\"\n# include  \"verireal.h\"\n# include  \"StringHeap.h\"\n# include  \"HName.h\"\n# include  \"LineInfo.h\"\n# include  \"Attrib.h\"\n# include  \"PScope.h\"\n# include  \"PUdp.h\"\n\n#ifdef HAVE_IOSFWD\n# include  <iosfwd>\n#else\n# include  <iostream>\n#endif\n\nclass Design;\nclass Link;\nclass Nexus;\nclass NetEvent;\nclass NetNet;\nclass NetNode;\nclass NetObj;\nclass NetPins;\nclass NetProc;\nclass NetProcTop;\nclass NetRelease;\nclass NetScope;\nclass NetEvProbe;\nclass NetExpr;\nclass NetEAccess;\nclass NetEConstEnum;\nclass NetESignal;\nclass NetFuncDef;\nclass NetRamDq;\nclass NetTaskDef;\nclass NetEvTrig;\nclass NetEvNBTrig;\nclass NetEvWait;\nclass PClass;\nclass PExpr;\nclass PFunction;\nclass PPackage;\nclass PTaskFunc;\nclass PWire;\nclass data_type_t;\nstruct enum_type_t;\nclass netclass_t;\nclass netdarray_t;\nclass netparray_t;\nclass netuarray_t;\nclass netqueue_t;\nclass netenum_t;\nclass netstruct_t;\nclass netvector_t;\n\nstruct target;\nstruct functor_t;\n\n#if defined(__cplusplus) && defined(_MSC_VER)\n# define ENUM_UNSIGNED_INT : unsigned int\n#else\n# define ENUM_UNSIGNED_INT\n#endif\n\nstd::ostream& operator << (std::ostream&o, ivl_variable_type_t val);\n\nextern void join_island(NetPins*obj);\n\nclass Link {\n\n      friend void connect(Link&, Link&);\n      friend class NetPins;\n      friend class Nexus;\n      friend class NexusSet;\n\n    public:\n      enum DIR ENUM_UNSIGNED_INT { PASSIVE, INPUT, OUTPUT };\n    private: // Only NetPins can create/delete Link objects\n      Link();\n      ~Link();\n\n    public:\n\t// Manipulate the link direction.\n      void set_dir(DIR d);\n      DIR get_dir() const;\n\n\t// Set the delay for all the drivers to this nexus.\n      void drivers_delays(NetExpr*rise, NetExpr*fall, NetExpr*decay);\n\n\t// A link has a drive strength for 0 and 1 values. The drive0\n\t// strength is for when the link has the value 0, and drive1\n\t// strength is for when the link has a value 1.\n      void drive0(ivl_drive_t);\n      void drive1(ivl_drive_t);\n\n\t// This sets the drives for all drivers of this link, and not\n\t// just the current link.\n      void drivers_drive(ivl_drive_t d0, ivl_drive_t d1);\n\n      ivl_drive_t drive0() const;\n      ivl_drive_t drive1() const;\n\n      void cur_link(NetPins*&net, unsigned &pin);\n      void cur_link(const NetPins*&net, unsigned &pin) const;\n\n\t// Get a pointer to the nexus that represents all the links\n\t// connected to me.\n      Nexus* nexus();\n      const Nexus* nexus()const;\n\n\t// Return a pointer to the next link in the nexus.\n      Link* next_nlink();\n      const Link* next_nlink() const;\n\n\t// Remove this link from the set of connected pins. The\n\t// destructor will automatically do this if needed.\n      void unlink();\n\n\t// Return true if this link is connected to anything else.\n      bool is_linked() const;\n\n\t// Return true if these pins are connected.\n      bool is_linked(const Link&that) const;\n\n\t// Return true if this is the same pin of the same object of\n\t// that link.\n      bool is_equal(const Link&that) const;\n\n\t// Return information about the object that this link is\n\t// a part of. Note that the get_obj() method can return NIL if\n\t// this Link is part of a NexusSet. That should be OK, because\n\t// they are collection variables, and not functional parts of\n\t// a design.\n      const NetPins*get_obj() const;\n      NetPins*get_obj();\n      unsigned get_pin() const;\n\n      void dump_link(std::ostream&fd, unsigned ind) const;\n\n    private:\n\t// The NetNode manages these. They point back to the\n\t// NetNode so that following the links can get me here.\n      union {\n\t    NetPins *node_;\n\t    unsigned pin_;\n      };\n\n      bool pin_zero_     : 1;\n      DIR dir_           : 2;\n      ivl_drive_t drive0_ : 3;\n      ivl_drive_t drive1_ : 3;\n\n    private:\n      Nexus* find_nexus_() const;\n\n    private:\n\t// The Nexus uses these to maintain its list of Link\n\t// objects. If this link is not connected to anything,\n\t// then these pointers are both nil.\n      Link *next_;\n      Nexus*nexus_;\n\n    private: // not implemented\n      Link(const Link&);\n      Link& operator= (const Link&);\n};\n\n\nclass NetPins : public LineInfo {\n\n    public:\n      explicit NetPins(unsigned npins);\n      virtual ~NetPins();\n\n      unsigned pin_count() const { return npins_; }\n\n      Link&pin(unsigned idx);\n      const Link&pin(unsigned idx) const;\n\n      void dump_node_pins(std::ostream&, unsigned, const char**pin_names =0) const;\n      void set_default_dir(Link::DIR d);\n\n      bool is_linked() const;\n      bool pins_are_virtual(void) const;\n      void devirtualize_pins(void);\n\n\t// This is for showing a brief description of the object to\n\t// the stream. It is used for debug and diagnostics.\n      virtual void show_type(std::ostream&fd) const;\n\n    private:\n      Link*pins_;\n      const unsigned npins_;\n      Link::DIR default_dir_;\n};\n\n/* =========\n * A NetObj is anything that has any kind of behavior in the\n * netlist. Nodes can be gates, registers, etc. and are linked\n * together to form a design web.\n *\n * The web of nodes that makes up a circuit is held together by the\n * Link class. There is a link for each pin. All mutually connected\n * pins form a ring of links.\n *\n * A link can be INPUT, OUTPUT or PASSIVE. An input never drives the\n * signal, and PASSIVE never receives the value of the signal. Wires\n * are PASSIVE, for example.\n *\n * A NetObj also has delays specified as rise_time, fall_time and\n * decay_time. The rise and fall time are the times to transition to 1\n * or 0 values. The decay_time is the time needed to decay to a 'bz\n * value, or to decay of the net is a trireg. The exact and precise\n * interpretation of the rise/fall/decay times is typically left to\n * the target to properly interpret.\n */\nclass NetObj  : public NetPins, public Attrib {\n\n    public:\n\t// The name of the object must be a permallocated string. A\n\t// lex_strings string, for example.\n      explicit NetObj(NetScope*s, perm_string n, unsigned npins);\n      virtual ~NetObj();\n\n      NetScope* scope();\n      const NetScope* scope() const;\n\n      perm_string name() const { return name_; }\n      void rename(perm_string n) { name_ = n; }\n\n      const NetExpr* rise_time() const { return delay1_; }\n      const NetExpr* fall_time() const { return delay2_; }\n      const NetExpr* decay_time() const { return delay3_; }\n\n      void rise_time(const NetExpr* d) { delay1_ = d; }\n      void fall_time(const NetExpr* d) { delay2_ = d; }\n      void decay_time(const NetExpr* d) { delay3_ = d; }\n\n      void dump_obj_attr(std::ostream&, unsigned) const;\n\n      virtual void show_type(std::ostream&fd) const;\n\n    private:\n      NetScope*scope_;\n      perm_string name_;\n      const NetExpr* delay1_;\n      const NetExpr* delay2_;\n      const NetExpr* delay3_;\n};\n\n/*\n* Objects that can be island branches are derived from this. (It is\n* possible for an object to be a NetObj and an IslandBranch.) This is\n* used to collect island information about the node.\n*/\n\nclass IslandBranch {\n    public:\n      explicit IslandBranch(ivl_discipline_t dis =0) : island_(0), discipline_(dis) { }\n\n      ivl_island_t get_island() const { return island_; }\n\n      friend void join_island(NetPins*);\n\n    private:\n      ivl_island_t island_;\n      ivl_discipline_t discipline_;\n};\n\n/*\n * A NetBranch is a construct of Verilog-A that is a branch between\n * two nodes. The branch has exactly 2 pins and a discipline.\n *\n * pin(0) is the source of flow through a branch and the plus side of\n * potential. Pin(1) is the sink of flow and the minus (or ground) of\n * potential.\n */\nclass NetBranch  : public NetPins, public IslandBranch {\n\n    public:\n      explicit NetBranch(ivl_discipline_t dis);\n      explicit NetBranch(ivl_discipline_t dis, perm_string name);\n      ~NetBranch();\n\n\t// If the branch is named, this returns the name.\n      perm_string name() const { return name_; }\n\n      ivl_branch_s* target_obj() const { return &target_obj_; }\n\n      void dump(std::ostream&, unsigned) const;\n\n    private:\n      perm_string name_;\n\n      mutable ivl_branch_s target_obj_;\n\n\t// The design class uses this member to list the branches.\n      friend class Design;\n      NetBranch*next_;\n};\n\n/*\n * The Nexus represents a collection of links that are joined\n * together. Each link has its own properties, this class holds the\n * properties of the group.\n *\n * The links in a nexus are grouped into a circularly linked list,\n * with the nexus pointing to the last Link. Each link in turn points\n * to the next link in the nexus, with the last link pointing back to\n * the first. The last link also has a non-nil nexus_ pointer back to\n * this nexus.\n *\n * The t_cookie() is an ivl_nexus_t that the code generator uses to\n * store data in the nexus. When a Nexus is created, this cookie is\n * set to nil. The code generator may set the cookie once. This locks\n * the nexus, and rewrites the Link list to be optimal for the code\n * generator. In the process, *all* of the other methods are no longer\n * functional.\n */\nclass Nexus {\n\n      friend void connect(Link&, Link&);\n      friend class Link;\n\n    private:\n\t// Only Link objects can create (or delete) Nexus objects\n      explicit Nexus(Link&r);\n      ~Nexus();\n\n    public:\n\n      void connect(Link&r);\n\n      const char* name() const;\n\n      void drivers_delays(NetExpr*rise, NetExpr*fall, NetExpr*decay);\n      void drivers_drive(ivl_drive_t d0, ivl_drive_t d1);\n\n      Link*first_nlink();\n      const Link* first_nlink()const;\n\n\t/* Get the width of the Nexus, or 0 if there are no vectors\n\t   (in the form of NetNet objects) linked. */\n      unsigned vector_width() const;\n\n      NetNet* pick_any_net();\n\n      NetNode* pick_any_node();\n\n      /* This method counts the number of input and output links for\n         this nexus, and assigns the results to the output arguments. */\n      void count_io(unsigned&inp, unsigned&out) const;\n\n\t/* This method returns true if there are any assignments that\n\t   use this nexus as an l-value. This can be true if the nexus\n\t   is a variable, but also if this is a net with a force. */\n      bool assign_lval() const;\n\n\t/* This method returns true if there are any inputs\n\t   attached to this nexus but no drivers. */\n      bool has_floating_input() const;\n\n\t/* This method returns true if there are any drivers\n\t   (including variables) attached to this nexus. */\n      bool drivers_present() const;\n\n\t/* This method returns true if all the possible drivers of\n\t   this nexus are constant. It will also return true if there\n\t   are no drivers at all. */\n      bool drivers_constant() const;\n\n\t/* Given the nexus has constant drivers, this method returns\n\t   the value that has been driven. */\n      verinum::V driven_value() const;\n      verinum driven_vector() const;\n\n\t/* Return a mask of the bits of this vector that are\n\t   driven. This is usually all false or all true, but in\n\t   special cases it may be a blend. */\n      std::vector<bool> driven_mask(void)const;\n\n\t/* The code generator sets an ivl_nexus_t to attach code\n\t   generation details to the nexus. */\n      ivl_nexus_t t_cookie() const { return t_cookie_; }\n      void t_cookie(ivl_nexus_t) const;\n\n    private:\n      Link*list_;\n      void unlink(Link*);\n\n      mutable char* name_; /* Cache the calculated name for the Nexus. */\n      mutable ivl_nexus_t t_cookie_;\n\n      enum VALUE { NO_GUESS, V0, V1, Vx, Vz, VAR };\n      mutable VALUE driven_;\n\n    private: // not implemented\n      Nexus(const Nexus&);\n      Nexus& operator= (const Nexus&);\n};\n\ninline void connect(Nexus*l, Link&r) { l->connect(r); }\n\nclass NexusSet {\n\n    public:\n      struct elem_t {\n\t    inline elem_t(Nexus*n, unsigned b, unsigned w)\n\t    : base(b), wid(w)\n\t    {\n\t\t  lnk.set_dir(Link::PASSIVE);\n\t\t  n->connect(lnk);\n\t    }\n\t    inline elem_t() : base(0), wid(0)\n\t    {\n\t    }\n\t    inline bool operator == (const struct elem_t&that) const\n\t    { return lnk.is_linked(that.lnk) && base==that.base && wid==that.wid; }\n\n\t    bool contains(const struct elem_t&that) const;\n\n\t    Link lnk;\n\t    unsigned base;\n\t    unsigned wid;\n\t  private:\n\t    elem_t(const elem_t&);\n\t    elem_t& operator= (elem_t&);\n      };\n\n    public:\n      ~NexusSet();\n      NexusSet();\n\n      size_t size() const;\n\n\t// Add the nexus/part to the set, if it is not already present.\n      void add(Nexus*that, unsigned base, unsigned wid);\n      void add(NexusSet&that);\n\n\t// Remove the nexus from the set, if it is present.\n      void rem(const NexusSet&that);\n\n      unsigned find_nexus(const elem_t&that) const;\n\n      elem_t& at(unsigned idx);\n      inline elem_t& operator[] (unsigned idx) { return at(idx); }\n\n\t// Return true if this set contains every nexus/part in that\n\t// set. That means that every bit of that set is accounted for\n\t// this set.\n      bool contains(const NexusSet&that) const;\n\n\t// Return true if this set contains any nexus in that set.\n      bool intersect(const NexusSet&that) const;\n\n    private:\n\t// NexSet items are canonical part selects of vectors.\n      std::vector<struct elem_t*> items_;\n\n      size_t bsearch_(const struct elem_t&that) const;\n      void rem_(const struct elem_t*that);\n      bool contains_(const elem_t&that) const;\n\n    private: // not implemented\n      NexusSet(const NexusSet&);\n      NexusSet& operator= (const NexusSet&);\n};\n\n/*\n * A NetBus is a transparent device that is merely a bunch of pins\n * used to tie some pins to. It is a convenient way to collect a\n * bundle of pins and pass that bundle around.\n */\nclass NetBus  : public NetObj {\n\n    public:\n      NetBus(NetScope*scope, unsigned pin_count);\n      ~NetBus();\n\n      unsigned find_link(const Link&that) const;\n\n    private: // not implemented\n      NetBus(const NetBus&);\n      NetBus& operator= (const NetBus&);\n};\n\n/*\n * A NetNode is a device of some sort, where each pin has a different\n * meaning. (i.e., pin(0) is the output to an and gate.) NetNode\n * objects are listed in the nodes_ of the Design object.\n */\nclass NetNode  : public NetObj {\n\n    public:\n\t// The name parameter must be a permallocated string.\n      explicit NetNode(NetScope*s, perm_string n, unsigned npins);\n\n      virtual ~NetNode();\n\n      virtual bool emit_node(struct target_t*) const;\n      virtual void dump_node(std::ostream&, unsigned) const;\n\n\t// This is used to scan a modifiable netlist, one node at a time.\n      virtual void functor_node(Design*, functor_t*);\n\n    private:\n      friend class Design;\n      NetNode*node_next_, *node_prev_;\n      Design*design_;\n};\n\n/*\n * A NetDelaySrc is an input-only device that calculates a path delay\n * based on the time that the inputs change. This class is used by the\n * NetNet class, and NetDelaySrc objects cannot exist outside of its\n * association with NetNet objects.\n */\nclass NetDelaySrc  : public NetObj {\n\n    public:\n      explicit NetDelaySrc(NetScope*s, perm_string n, unsigned nsrc,\n                           bool condit_src, bool conditional, bool parallel);\n      ~NetDelaySrc();\n\n\t// These functions set the delays from the values in the\n\t// source. These set_delays functions implement the various\n\t// rules wrt collections of transitions.\n\n\t// One transition specified.\n      void set_delays(uint64_t del);\n\t// Two transitions: rise and fall\n      void set_delays(uint64_t rise, uint64_t fall);\n\t// Three transitions\n      void set_delays(uint64_t rise, uint64_t fall, uint64_t tz);\n      void set_delays(uint64_t t01, uint64_t t10, uint64_t t0z,\n\t\t      uint64_t tz1, uint64_t t1z, uint64_t tz0);\n      void set_delays(uint64_t t01, uint64_t t10, uint64_t t0z,\n\t\t      uint64_t tz1, uint64_t t1z, uint64_t tz0,\n\t\t      uint64_t t0x, uint64_t tx1, uint64_t t1x,\n\t\t      uint64_t tx0, uint64_t txz, uint64_t tzx);\n\n      uint64_t get_delay(unsigned pe) const;\n\n      void set_posedge();\n      void set_negedge();\n      bool is_posedge() const;\n      bool is_negedge() const;\n\n      unsigned src_count() const;\n      Link&src_pin(unsigned);\n      const Link&src_pin(unsigned) const;\n\n      bool is_condit() const;\n      bool has_condit() const;\n      Link&condit_pin();\n      const Link&condit_pin() const;\n\n      bool is_parallel() const;\n\n      void dump(std::ostream&, unsigned ind) const;\n\n    private:\n      uint64_t transition_delays_[12];\n      bool condit_flag_;\n      bool conditional_;\n      bool parallel_;\n      bool posedge_;\n      bool negedge_;\n\n    private: // Not implemented\n      NetDelaySrc(const NetDelaySrc&);\n      NetDelaySrc& operator= (const NetDelaySrc&);\n};\n\n/*\n * NetNet is a special kind of NetObj that doesn't really do anything,\n * but carries the properties of the wire/reg/trireg, including its\n * name. Scalars and vectors are all the same thing here, a NetNet\n * with a single pin. The difference between a scalar and vector is\n * the width of the atomic vector datum it carries.\n *\n * NetNet objects can also appear as side effects of synthesis or\n * other abstractions.\n *\n * Note that INTEGER types are an alias for a ``reg signed [31:0]''.\n *\n * NetNet objects have a name and exist within a scope, so the\n * constructor takes a pointer to the containing scope. The object\n * automatically adds itself to the scope.\n *\n * NetNet objects are located by searching NetScope objects.\n *\n * The pins of a NetNet object are usually PASSIVE: they do not drive\n * anything and they are not a data sink, per se. The pins follow the\n * values on the nexus. The exceptions are reg, trireg, tri0, tri1,\n * supply0, and supply1 objects, whose pins are classed as OUTPUT.\n */\n\nclass PortType\n{\npublic:\n\tenum Enum ENUM_UNSIGNED_INT { NOT_A_PORT, PIMPLICIT, PINPUT, POUTPUT, PINOUT, PREF };\n\n    /*\n     * Merge Port types (used to construct a sane combined port-type\n     * for module ports with complex defining expressions).\n     *\n     */\n    static Enum merged( Enum lhs, Enum rhs );\n};\n\nextern std::ostream& operator << (std::ostream&, PortType::Enum);\n\n  /*\n   * Information on actual ports (rather than port-connected signals) of\n   * module.\n   * N.b. must be POD as passed through a \"C\" interface in the t-dll-api.\n   */\nstruct PortInfo\n{\n    PortType::Enum  type;\n    unsigned long   width;\n    perm_string     name;\n    ivl_net_logic_t buffer;\n};\n\n\nclass NetNet  : public NetObj, public PortType {\n\n    public:\n      enum Type ENUM_UNSIGNED_INT { NONE, IMPLICIT, IMPLICIT_REG, WIRE, TRI, TRI1,\n\t\t  SUPPLY0, SUPPLY1, WAND, TRIAND, TRI0, WOR, TRIOR, REG,\n\t\t  UNRESOLVED_WIRE };\n\n      typedef PortType::Enum PortType;\n\n    public:\n\t// This form is the more generic form of the constructor. For\n\t// now, the unpacked type is not buried into an ivl_type_s object.\n      explicit NetNet(NetScope*s, perm_string n, Type t,\n\t\t      const netranges_t &unpacked,\n\t\t      ivl_type_t type);\n\n      explicit NetNet(NetScope*s, perm_string n, Type t, ivl_type_t type);\n\n      virtual ~NetNet();\n\n      Type type() const;\n      void type(Type t);\n\n        // This method returns true if we have changed the net type from being\n        // a variable to being an unresolved wire. This happens in SystemVerilog\n        // when we find a continuous assignment to a variable.\n      bool coerced_to_uwire() { return coerced_to_uwire_; }\n\n      PortType port_type() const;\n      void port_type(PortType t);\n\n      unsigned lexical_pos() const { return lexical_pos_; }\n      void lexical_pos(unsigned lp) { lexical_pos_ = lp; }\n\n      // If this net net is a port (i.e. a *sub*port net of a module port)\n      // its port index is number of the module it connects through\n      int get_module_port_index() const;                // -1 Not connected to port...\n      void set_module_port_index(unsigned idx);\n\n      ivl_variable_type_t data_type() const;\n\n\t/* If a NetNet is signed, then its value is to be treated as\n\t   signed. Otherwise, it is unsigned. */\n      bool get_signed() const;\n\n      void set_const(bool is_const) { is_const_ = is_const; }\n      bool get_const() const { return is_const_; }\n\n      bool get_scalar() const;\n\n      inline const ivl_type_s* net_type(void) const { return net_type_; }\n      const netenum_t*enumeration(void) const;\n      const netstruct_t*struct_type(void) const;\n      const netdarray_t*darray_type(void) const;\n      const netqueue_t*queue_type(void) const;\n      const netclass_t*class_type(void) const;\n      const netarray_t*array_type(void) const;\n\n\t/* Attach a discipline to the net. */\n      ivl_discipline_t get_discipline() const;\n      void set_discipline(ivl_discipline_t dis);\n\n\t/* This method returns a reference to the packed dimensions\n\t   for the vector. These are arranged as a list where the\n\t   first range in the list (front) is the left-most range in\n\t   the Verilog declaration. These packed dims are compressed\n\t   to represent the dimensions of all the subtypes. */\n      const netranges_t& packed_dims() const { return slice_dims_; }\n\n      const netranges_t& unpacked_dims() const { return unpacked_dims_; }\n\n\t/* The vector_width returns the bit width of the packed array,\n\t   vector or scalar that is this NetNet object.  */\n      inline unsigned long vector_width() const { return slice_width(0); }\n\n\t/* Given a prefix of indices, figure out how wide the\n\t   resulting slice would be. This is a generalization of the\n\t   vector_width(), where the depth would be 0. */\n      unsigned long slice_width(size_t depth) const;\n\n\t/* This method converts a signed index (the type that might be\n\t   found in the Verilog source) to canonical. It accounts\n\t   for variation in the definition of the\n\t   reg/wire/whatever. Note that a canonical index of a\n\t   multi-dimensioned packed array is a single dimension. For\n\t   example, \"reg [4:1][3:0]...\" has the canonical dimension\n\t   [15:0] and the sb_to_idx() method will convert [2][2] to\n\t   the canonical index [6]. */\n      long sb_to_idx(const std::list<long>&prefix, long sb) const;\n\n\t/* This method converts a partial packed indices list and a\n\t   tail index, and generates a canonical slice offset and\n\t   width. */\n      bool sb_to_slice(const std::list<long>&prefix, long sb, long&off, unsigned long&wid) const;\n\n\t/* This method checks that the signed index is valid for this\n\t   signal. If it is, the above sb_to_idx can be used to get\n\t   the pin# from the index. */\n      bool sb_is_valid(const std::list<long>&prefix, long sb) const;\n\n\t/* This method returns 0 for scalars and vectors, and greater\n\t   for arrays. The value is the number of array\n\t   indices. (Currently only one array index is supported.) */\n      inline unsigned unpacked_dimensions() const { return unpacked_dims_.size(); }\n\n\t/* This method returns 0 for scalars, but vectors and other\n\t   PACKED arrays have packed dimensions. */\n      inline size_t packed_dimensions() const { return slice_dims_.size(); }\n\n\t// This is the number of array elements.\n      unsigned unpacked_count() const;\n\n      bool local_flag() const { return local_flag_; }\n      void local_flag(bool f) { local_flag_ = f; }\n\n\t// NetESignal objects may reference this object. Keep a\n\t// reference count so that I keep track of them.\n      void incr_eref();\n      void decr_eref();\n      unsigned peek_eref() const;\n\n\t// Assignment statements count their lrefs here. And by\n\t// assignment statements, we mean BEHAVIORAL assignments.\n      void incr_lref();\n      void decr_lref();\n      unsigned peek_lref() const { return lref_count_; }\n\n\t// Treating this node as a uwire, this function tests whether\n\t// any bits in the canonical part are already driven. This is\n\t// only useful for UNRESOLVED_WIRE objects. The msb and lsb\n\t// are the part select of the signal, and the widx is the word\n\t// index if this is an unpacked array.\n      bool test_part_driven(unsigned msb, unsigned lsb, int widx =0);\n\n\t// Treating this node as a uwire, this function tests whether\n\t// any bits in the canonical part are already driven and sets\n\t// them if not. This is only useful for UNRESOLVED_WIRE objects.\n\t// The msb and lsb are the part select of the signal, and the\n\t// widx is the word index if this is an unpacked array.\n      bool test_and_set_part_driver(unsigned msb, unsigned lsb, int widx =0);\n\n      unsigned get_refs() const;\n\n\t/* Manage path delays */\n      void add_delay_path(class NetDelaySrc*path);\n      unsigned delay_paths(void) const;\n      const class NetDelaySrc*delay_path(unsigned idx) const;\n\n      virtual void dump_net(std::ostream&, unsigned) const;\n\n    private:\n      void initialize_dir_();\n\n    private:\n      Type   type_    : 5;\n      PortType port_type_ : 3;\n      bool coerced_to_uwire_: 1;\n      bool local_flag_: 1;\n      unsigned lexical_pos_;\n      ivl_type_t net_type_;\n      netuarray_t *array_type_ = nullptr;\n      ivl_discipline_t discipline_;\n\n        // Whether the net is variable declared with the const keyword.\n      bool is_const_ = false;\n\n      netranges_t unpacked_dims_;\n\n\t// These are the widths of the various slice depths. There is\n\t// one entry in this vector for each packed dimension. The\n\t// value at N is the slice width if N indices are provided.\n\t//\n\t// For example: slice_wids_[0] is vector_width().\n      void calculate_slice_widths_from_packed_dims_(void);\n      netranges_t slice_dims_;\n      std::vector<unsigned long> slice_wids_;\n\n      unsigned eref_count_;\n      unsigned lref_count_;\n\n\t// When the signal is an unresolved wire, we need more detail\n\t// which bits are assigned. This mask is true for each bit\n\t// that is known to be driven.\n      std::vector<bool> lref_mask_;\n\n      std::vector<class NetDelaySrc*> delay_paths_;\n      int       port_index_ = -1;\n};\n\n/*\n * This object type is used for holding local variable values when\n * evaluating constant user functions.\n */\nstruct LocalVar {\n      int nwords;  // zero for a simple variable, -1 for reference\n      union {\n\t    NetExpr*  value;  // a simple variable\n\t    NetExpr** array;  // an array variable\n\t    LocalVar* ref;    // A reference to a previous scope\n      };\n};\n\nclass NetBaseDef {\n    public:\n      NetBaseDef(NetScope*n, const std::vector<NetNet*>&po,\n\t\t const std::vector<NetExpr*>&pd);\n      virtual ~NetBaseDef();\n\n      const NetScope*scope() const;\n      NetScope*scope();\n\n      unsigned port_count() const;\n      NetNet*port(unsigned idx) const;\n      NetExpr*port_defe(unsigned idx) const;\n\n      void set_proc(NetProc*p);\n\n\t//const string& name() const;\n      const NetProc*proc() const;\n\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n      NetScope*scope_;\n      std::vector<NetNet*>ports_;\n      std::vector<NetExpr*>pdefaults_;\n\n    protected:\n      NetProc*proc_;\n};\n\n/*\n * Some definitions (and methods to manipulate them) are common to a\n * couple of types. Keep them here.\n */\nclass Definitions {\n\n    public:\n      Definitions();\n      ~Definitions();\n\n\t// Add the enumeration to the set of enumerations in this\n\t// scope. Include a key that the elaboration can use to look\n\t// up this enumeration based on the pform type.\n      void add_enumeration_set(const enum_type_t*key, netenum_t*enum_set);\n\n      bool add_enumeration_name(netenum_t*enum_set, perm_string enum_name);\n\n\t// Look up the enumeration set that was added with the given\n\t// key. This is used by enum_type_t::elaborate_type to locate\n\t// a previously elaborated enumeration.\n      netenum_t* enumeration_for_key(const enum_type_t*key) const;\n\n\t// Look up an enumeration literal in this scope. If the\n\t// literal is present, return the expression that defines its\n\t// value.\n      const NetExpr* enumeration_expr(perm_string key);\n\n\t// Definitions scopes can also hold classes, by name.\n      void add_class(netclass_t*class_type);\n\n    protected:\n\t// Enumerations. The enum_sets_ is a list of all the\n\t// enumerations present in this scope. The enum_names_ is a\n\t// map of all the enumeration names back to the sets that\n\t// contain them.\n      std::map<const enum_type_t*,netenum_t*> enum_sets_;\n      std::map<perm_string,NetEConstEnum*> enum_names_;\n\n\t// This is a map of all the classes (by name) in this scope.\n      std::map<perm_string,netclass_t*> classes_;\n\n};\n\n/*\n * This object type is used to contain a logical scope within a\n * design. The scope doesn't represent any executable hardware, but is\n * just a handle that netlist processors can use to grab at the design.\n */\nclass NetScope : public Definitions, public Attrib {\n\n    public:\n      enum TYPE { MODULE, CLASS, TASK, FUNC, BEGIN_END, FORK_JOIN, GENBLOCK, PACKAGE };\n\n\t/* Create a new scope associated with a given compilation unit,\n\t   and attach it to the given parent. If no compilation unit is\n\t   specified, the parent's compilation unit is used. The name\n\t   is expected to have been permallocated. */\n      NetScope(NetScope*up, const hname_t&name, TYPE t, NetScope*in_unit=0,\n\t       bool nest=false, bool program=false, bool interface=false,\n               bool compilation_unit=false);\n      ~NetScope();\n\n\t/* Rename the scope using the name generated by inserting as\n\t   many pad characters as required between prefix and suffix\n\t   to make the name unique in the parent scope. Return false\n\t   if a unique name couldn't be generated. */\n      bool auto_name(const char* prefix, char pad, const char* suffix);\n\n      void add_imports(const std::map<perm_string,PPackage*>*imports);\n      NetScope*find_import(const Design*des, perm_string name);\n\n      void add_typedefs(const std::map<perm_string,typedef_t*>*typedefs);\n\n        /* Search the scope hierarchy for the scope where 'type' was defined. */\n      NetScope*find_typedef_scope(const Design*des, const typedef_t*type);\n\n\t/* Parameters exist within a scope, and these methods allow\n\t   one to manipulate the set. In these cases, the name is the\n\t   *simple* name of the parameter, the hierarchy is implicit in\n\t   the scope. */\n\n      struct range_t;\n      void set_parameter(perm_string name, bool is_annotatable,\n\t\t\t const LexicalScope::param_expr_t &param,\n\t\t\t NetScope::range_t *range_list);\n      void set_parameter(perm_string name, NetExpr*val,\n\t\t\t const LineInfo&file_line);\n\n      const NetExpr*get_parameter(Design*des, const char* name,\n\t\t\t\t  ivl_type_t&ivl_type);\n      const NetExpr*get_parameter(Design*des, perm_string name,\n\t\t\t\t  ivl_type_t&ivl_type);\n\n\t/* These are used by defparam elaboration to replace the\n\t   expression with a new expression, without affecting the\n\t   range or signed_flag. Return false if the name does not\n\t   exist. */\n      void replace_parameter(Design *des, perm_string name, PExpr*val,\n\t\t\t     NetScope*scope, bool defparam = false);\n\n\t/* This is used to ensure the value of a parameter cannot be\n\t   changed at run-time. This is required if a specparam is used\n\t   in an expression that must be evaluated at compile-time.\n\t   Returns true if the named parameter is a specparam and has\n\t   not already been set to be unannotatable. */\n      bool make_parameter_unannotatable(perm_string name);\n\n\t/* These methods set or access events that live in this\n\t   scope. */\n\n      void add_event(NetEvent*);\n      void rem_event(NetEvent*);\n      NetEvent*find_event(perm_string name);\n\n\t/* These methods add or find a genvar that lives in this scope. */\n      void add_genvar(perm_string name, LineInfo *li);\n      LineInfo* find_genvar(perm_string name);\n\n\t/* These methods manage unelaborated signals. These are added to\n\t   the scope as placeholders during the scope elaboration phase,\n\t   to allow signal declarations to refer to other signals (e.g.\n\t   when using $bits in a range definition), regardless of the\n\t   order in which the signals are elaborated. */\n      void add_signal_placeholder(PWire*);\n      void rem_signal_placeholder(PWire*);\n      PWire* find_signal_placeholder(perm_string name);\n\n\t/* These methods manage signals. The add_ and rem_signal\n\t   methods are used by the NetNet objects to make themselves\n\t   available to the scope, and the find_signal method can be\n\t   used to locate signals within a scope. */\n\n      void add_signal(NetNet*);\n      void rem_signal(NetNet*);\n      NetNet* find_signal(perm_string name);\n\n      netclass_t* find_class(const Design*des, perm_string name);\n\n\t/* The unit(), parent(), and child() methods allow users of\n\t   NetScope objects to locate nearby scopes. */\n      NetScope* unit() { return unit_; }\n      NetScope* parent() { return up_; }\n      NetScope* child(const hname_t&name);\n      const NetScope* unit() const { return unit_; }\n      const NetScope* parent() const { return up_; }\n      const NetScope* child(const hname_t&name) const;\n\n\t/* A helper function to find the enclosing class scope. */\n      const NetScope* get_class_scope() const;\n\n\t// Look for a child scope by name. This ignores the number\n\t// part of the child scope name, so there may be multiple\n\t// matches. Only return one. This function is only really\n\t// useful for some elaboration error checking.\n      const NetScope* child_byname(perm_string name) const;\n\n\t// Nested modules have slightly different scope search rules.\n      inline bool nested_module() const { return nested_module_; }\n\t// Program blocks and interfaces have elaboration constraints.\n      inline bool program_block() const { return program_block_; }\n      inline bool is_interface() const { return is_interface_; }\n      inline bool is_unit() const { return is_unit_; }\n      inline TYPE type() const { return type_; }\n      void print_type(std::ostream&) const;\n\n\t// This provides a link to the variable initialization process\n\t// for use when evaluating a constant function. Note this is\n\t// only used for static functions - the variable initialization\n\t// for automatic functions is included in the function definition.\n      void set_var_init(const NetProc*proc) { var_init_ = proc; }\n      const NetProc* var_init() const { return var_init_; }\n\n      void set_task_def(NetTaskDef*);\n      void set_func_def(NetFuncDef*);\n      void set_class_def(netclass_t*);\n      void set_module_name(perm_string);\n\n      NetTaskDef* task_def();\n      NetFuncDef* func_def();\n\n\t// This is used by the evaluate_function setup to collect\n\t// local variables from the scope.\n      void evaluate_function_find_locals(const LineInfo&loc,\n\t\t\t\t\t std::map<perm_string,LocalVar>&ctx) const;\n\n      void set_line(perm_string file, perm_string def_file,\n                    unsigned lineno, unsigned def_lineno);\n      void set_line(perm_string file, unsigned lineno);\n      void set_line(const LineInfo *info);\n      perm_string get_file() const { return file_; };\n      perm_string get_def_file() const { return def_file_; };\n      unsigned get_lineno() const { return lineno_; };\n      unsigned get_def_lineno() const { return def_lineno_; };\n\n      std::string get_fileline() const;\n      std::string get_def_fileline() const;\n\n      bool in_func() const;\n\n\t/* Provide a link back to the pform to allow early elaboration of\n           constant functions. */\n      void set_func_pform(const PFunction*pfunc) { func_pform_ = pfunc; };\n      const PFunction*func_pform() const { return func_pform_; };\n\n        /* Allow tracking of elaboration stages. The three stages are:\n             1 - scope elaboration\n             2 - signal elaboration\n             3 - statement elaboration\n           This is only used for functions, to support early elaboration.\n        */\n      void set_elab_stage(unsigned stage) { elab_stage_ = stage; };\n      unsigned elab_stage() const { return elab_stage_; };\n\n\t/* Is this a function called in a constant expression. */\n      void need_const_func(bool need_const) { need_const_func_ = need_const; };\n      bool need_const_func() const { return need_const_func_; };\n\n\t/* Is this a constant function. */\n      void is_const_func(bool is_const) { is_const_func_ = is_const; };\n      bool is_const_func() const { return is_const_func_; };\n\n\t/* Is the task or function automatic. */\n      void is_auto(bool is_auto__) { is_auto_ = is_auto__; };\n      bool is_auto() const { return is_auto_; };\n\n\t/* Is the module a cell (is in a `celldefine) */\n      void is_cell(bool is_cell__) { is_cell_ = is_cell__; };\n      bool is_cell() const { return is_cell_; };\n\n\t/* Is there a call to a system task in this scope. */\n      void calls_sys_task(bool calls_stask__) { calls_stask_ = calls_stask__; };\n      bool calls_sys_task() const { return calls_stask_; };\n\n        /* Is this scope elaborating a final procedure? */\n      void in_final(bool in_final__) { in_final_ = in_final__; };\n      bool in_final() const { return in_final_; };\n\n      const NetTaskDef* task_def() const;\n      const NetFuncDef* func_def() const;\n      const netclass_t* class_def() const;\n\n\t/* If the scope represents a module instance, the module_name\n\t   is the name of the module itself. */\n      perm_string module_name() const;\n\t/* If the scope is a module then it may have ports that we need\n\t * to keep track of. */\n\n      void set_num_ports(unsigned int num_ports);\n      void add_module_port_net(NetNet*port);\n      unsigned module_port_nets() const;\n      NetNet*module_port_net(unsigned idx) const;\n\n      void add_module_port_info( unsigned idx,\n                            perm_string name,  // May be \"\" for undeclared port\n                            PortType::Enum type,\n                            unsigned long width );\n\n      PortInfo* get_module_port_info(unsigned idx);\n\n      const std::vector<PortInfo> &module_port_info() const;\n\n\t/* Scopes have their own time units and time precision. The\n\t   unit and precision are given as power of 10, i.e., -3 is\n\t   units of milliseconds.\n\n\t   If a NetScope is created with a parent scope, the new scope\n\t   will initially inherit the unit and precision of the\n\t   parent scope. */\n\n      void time_unit(int);\n      void time_precision(int);\n      void time_from_timescale(bool);\n\n      int time_unit() const;\n      int time_precision() const;\n      bool time_from_timescale() const;\n\n\t/* The fullname of the scope is the hierarchical name\n\t   component (which includes the name and array index) whereas\n\t   the basename is just my name. */\n      perm_string basename() const;\n      const hname_t& fullname() const { return name_; }\n\n      void run_defparams(class Design*);\n      void run_defparams_later(class Design*);\n\n      void evaluate_parameters(class Design*);\n\n\t// Look for defparams that never matched, and print warnings.\n      void residual_defparams(class Design*);\n\n      bool symbol_exists(perm_string sym);\n\n\t/* This method generates a non-hierarchical name that is\n\t   guaranteed to be unique within this scope. */\n      perm_string local_symbol();\n\n      void dump(std::ostream&) const;\n\t// Check to see if the scope has items that are not allowed\n\t// in an always_comb/ff/latch process.\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      void emit_scope(struct target_t*tgt) const;\n      bool emit_defs(struct target_t*tgt) const;\n\n\t/* This method runs the functor on me. Recurse through the\n\t   children of this node as well. */\n      void run_functor(Design*des, functor_t*fun);\n\n\t/* These are used in synthesis. They provide shared pullup and\n\t   pulldown nodes for this scope. */\n      void add_tie_hi(Design*des);\n      void add_tie_lo(Design*des);\n      Link&tie_hi() const { return tie_hi_->pin(0); };\n      Link&tie_lo() const { return tie_lo_->pin(0); };\n\n\t/* This member is used during elaboration to pass defparam\n\t   assignments from the scope pass to the parameter evaluation\n\t   step. After that, it is not used. */\n\n      std::list<std::pair<pform_name_t,PExpr*> > defparams;\n      std::list<std::pair<std::list<hname_t>,PExpr*> > defparams_later;\n\n    public:\n      struct range_t {\n\t    bool exclude_flag;\n\t      // Lower bound\n\t    bool low_open_flag;\n\t    NetExpr*low_expr;\n\t      // Upper bound\n\t    bool high_open_flag;\n\t    NetExpr*high_expr;\n\t      // Link to the next range specification\n\t    struct range_t*next;\n      };\n\n\t/* After everything is all set up, the code generators like\n\t   access to these things to make up the parameter lists. */\n      struct param_expr_t : public LineInfo {\n\t    param_expr_t() : val_expr(0), val_type(0), val_scope(0),\n\t\t             solving(false), is_annotatable(false),\n\t\t             local_flag(false),\n\t\t             range(0), val(0), ivl_type(0) { }\n\t    // Source expression and data type (before elaboration)\n\t    PExpr*val_expr;\n\t    data_type_t*val_type;\n\t    // Scope information\n            NetScope*val_scope;\n\t    // Evaluation status\n\t    bool solving;\n\t    // specparam status\n\t    bool is_annotatable;\n\t    // Is this a localparam?\n\t    bool local_flag;\n\t    // Can it be overridden?\n\t    bool overridable = false;\n\t    // Is it a type parameter\n\t    bool type_flag = false;\n\t    // The lexical position of the declaration\n\t    unsigned lexical_pos = 0;\n\t    // range constraints\n\t    struct range_t*range;\n\n\t    // Expression value. Elaborated version of val_expr.\n\t    // For type parameters this will always be 0.\n\t    NetExpr*val;\n\n\t    // For non-type parameter this contains the elaborate type of the\n\t    // parameter itself. For type parameters this contains the\n\t    // elaborated assigned type value.\n\t    ivl_type_t ivl_type;\n      };\n      std::map<perm_string,param_expr_t>parameters;\n\n      typedef std::map<perm_string,param_expr_t>::iterator param_ref_t;\n\n      LineInfo get_parameter_line_info(perm_string name) const;\n\n      unsigned get_parameter_lexical_pos(perm_string name) const;\n\n\t/* Module instance arrays are collected here for access during\n\t   the multiple elaboration passes. */\n      typedef std::vector<NetScope*> scope_vec_t;\n      std::map<perm_string, scope_vec_t>instance_arrays;\n\n\t/* Loop generate uses this as scratch space during\n\t   elaboration. Expression evaluation can use this to match\n\t   names. */\n      perm_string genvar_tmp;\n      long genvar_tmp_val;\n\n      std::map<perm_string,LocalVar> loop_index_tmp;\n\n    private:\n      void evaluate_type_parameter_(Design*des, param_ref_t cur);\n      void evaluate_parameter_logic_(Design*des, param_ref_t cur);\n      void evaluate_parameter_real_(Design*des, param_ref_t cur);\n      void evaluate_parameter_string_(Design*des, param_ref_t cur);\n      void evaluate_parameter_(Design*des, param_ref_t cur);\n\n    private:\n      TYPE type_;\n      hname_t name_;\n\n\t// True if the scope is a nested module/program block\n      bool nested_module_;\n\t// True if the scope is a program block\n      bool program_block_;\n\t// True if the scope is an interface\n      bool is_interface_;\n\t// True if the scope is a compilation unit\n      bool is_unit_;\n\n      perm_string file_;\n      perm_string def_file_;\n      unsigned lineno_;\n      unsigned def_lineno_;\n\n      signed char time_unit_, time_prec_;\n      bool time_from_timescale_;\n\n      const std::map<perm_string,PPackage*>*imports_;\n\n      std::map<perm_string,typedef_t*>typedefs_;\n\n      NetEvent *events_;\n\n      std::map<perm_string,LineInfo*> genvars_;\n\n      std::map<perm_string,PWire*> signal_placeholders_;\n\n      typedef std::map<perm_string,NetNet*>::const_iterator signals_map_iter_t;\n      std::map <perm_string,NetNet*> signals_map_;\n      perm_string module_name_;\n      std::vector<NetNet*> port_nets;\n\n      std::vector<PortInfo> ports_;\n\n      const NetProc*var_init_;\n\n      union {\n\t    NetTaskDef*task_;\n\t    NetFuncDef*func_;\n\t    netclass_t*class_def_;\n      };\n      const PFunction*func_pform_;\n      unsigned elab_stage_;\n\n      NetScope*unit_;\n      NetScope*up_;\n      std::map<hname_t,NetScope*> children_;\n\n      unsigned lcounter_;\n      bool need_const_func_, is_const_func_, is_auto_, is_cell_, calls_stask_;\n\n      /* Final procedures sets this to notify statements that\n\t they are part of a final procedure. */\n      bool in_final_;\n\n      NetNode*tie_hi_;\n      NetNode*tie_lo_;\n};\n\n/*\n * This class implements the LPM_ABS component. The node has a single\n * input, a signed expression, that it converts to the absolute\n * value. The gate is simple: pin(0) is the output and pin(1) is the input.\n */\nclass NetAbs  : public NetNode {\n\n    public:\n      NetAbs(NetScope*s, perm_string n, unsigned width);\n      ~NetAbs();\n\n      unsigned width() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned width_;\n};\n\n/*\n * This class implements the LPM_ADD_SUB component as described in the\n * EDIF LPM Version 2 1 0 standard. It is used as a structural\n * implementation of the + and - operators.\n */\nclass NetAddSub  : public NetNode {\n\n    public:\n      NetAddSub(NetScope*s, perm_string n, unsigned width);\n      ~NetAddSub();\n\n\t// Get the width of the device (that is, the width of the\n\t// operands and results).\n      unsigned width() const;\n\n      Link& pin_Cout();\n      Link& pin_DataA();\n      Link& pin_DataB();\n      Link& pin_Result();\n\n      const Link& pin_Cout() const;\n      const Link& pin_DataA() const;\n      const Link& pin_DataB() const;\n      const Link& pin_Result() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned width_;\n};\n\n/*\n * The NetArrayDq node represents an array dereference. The NetNet\n * that this object refers to is an array, and the Address pin selects\n * which word of the array to place on the Result.\n*/\nclass NetArrayDq  : public NetNode {\n\n    public:\n      NetArrayDq(NetScope*s, perm_string name, NetNet*mem, unsigned awid);\n      ~NetArrayDq();\n\n      unsigned width() const;\n      unsigned awidth() const;\n      unsigned size() const;\n      const NetNet*mem() const;\n\n      Link& pin_Address();\n      Link& pin_Result();\n\n      const Link& pin_Address() const;\n      const Link& pin_Result() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      NetNet*mem_;\n      unsigned awidth_;\n\n};\n\n/*\n * Convert an IVL_VT_REAL input to a logical value with the\n * given width. The input is pin(1) and the output is pin(0).\n */\nclass NetCastInt4  : public NetNode {\n\n    public:\n      NetCastInt4(NetScope*s, perm_string n, unsigned width);\n\n      unsigned width() const { return width_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      unsigned width_;\n};\n\nclass NetCastInt2  : public NetNode {\n\n    public:\n      NetCastInt2(NetScope*s, perm_string n, unsigned width);\n\n      unsigned width() const { return width_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      unsigned width_;\n};\n\n/*\n * Convert an input to IVL_VT_REAL. The input is pin(1), which can be\n * any vector type (VT_BOOL or VT_LOGIC) and the output is pin(0),\n * which is IVL_VT_REAL. The conversion interprets the input as an\n * unsigned value unless the signed_flag is true.\n */\nclass NetCastReal  : public NetNode {\n\n    public:\n      NetCastReal(NetScope*s, perm_string n, bool signed_flag);\n\n      bool signed_flag() const { return signed_flag_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      bool signed_flag_;\n};\n\n/*\n * This type represents the LPM_CLSHIFT device.\n */\nclass NetCLShift  : public NetNode {\n\n    public:\n      NetCLShift(NetScope*s, perm_string n, unsigned width,\n\t\t unsigned width_dist, bool right_flag, bool signed_flag);\n      ~NetCLShift();\n\n      unsigned width() const;\n      unsigned width_dist() const;\n\n      bool right_flag() const;\n      bool signed_flag() const;\n\n      Link& pin_Data();\n      Link& pin_Result();\n      Link& pin_Distance();\n\n      const Link& pin_Data() const;\n      const Link& pin_Result() const;\n      const Link& pin_Distance() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      unsigned width_;\n      unsigned width_dist_;\n      bool right_flag_;\n      bool signed_flag_;\n};\n\n/*\n * This class supports the LPM_COMPARE device.\n *\n * The width of the device is the width of the inputs. If one of the\n * inputs is narrower than the other, it is up to the generator to\n * make sure all the data pins are properly driven.\n *\n * The signed() property is true if the comparison is to be done to\n * signed arguments. The result is always UNsigned.\n *\n * NOTE: This is not the same as the device used to support case\n * compare. Case comparisons handle Vx and Vz values, whereas this\n * device need not.\n */\nclass NetCompare  : public NetNode {\n\n    public:\n      NetCompare(NetScope*scope, perm_string n, unsigned width);\n      ~NetCompare();\n\n      unsigned width() const;\n\n      bool get_signed() const;\n      void set_signed(bool);\n\n      Link& pin_AGB();\n      Link& pin_AGEB();\n      Link& pin_AEB();\n      Link& pin_ANEB();\n      Link& pin_ALB();\n      Link& pin_ALEB();\n\n      Link& pin_DataA();\n      Link& pin_DataB();\n\n      const Link& pin_AGB() const;\n      const Link& pin_AGEB() const;\n      const Link& pin_AEB() const;\n      const Link& pin_ANEB() const;\n      const Link& pin_ALB() const;\n      const Link& pin_ALEB() const;\n\n      const Link& pin_DataA() const;\n      const Link& pin_DataB() const;\n\n      virtual void functor_node(Design*, functor_t*);\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      unsigned width_;\n      bool signed_flag_;\n};\n\n\n/*\n * This node is a means to connect net inputs together to form a wider\n * vector. The output (pin 0) is a concatenation of the input vectors,\n * with pin-1 at the LSB, pin-2 next, and so on. This node is most\n * like the NetLogic node, as it has one output at pin 0 and the\n * remaining pins are the input that are combined to make the\n * output. It is separated out because it it generally a special case\n * for the code generators.\n *\n * When constructing the node, the width is the vector_width of the\n * output, and the cnt is the number of pins. (the number of input\n * vectors.)\n */\nclass NetConcat  : public NetNode {\n\n    public:\n      NetConcat(NetScope*scope, perm_string n, unsigned wid, unsigned cnt,\n\t\tbool transparent_flag = false);\n      ~NetConcat();\n\n      unsigned width() const;\n\t// This is true if the concatenation is a transparent\n\t// concatenation, meaning strengths are passed through as\n\t// is. In this case, the output strengths of this node will be\n\t// ignored.\n      bool transparent() const { return transparent_; }\n\n      void dump_node(std::ostream&, unsigned ind) const;\n      bool emit_node(struct target_t*) const;\n      void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned width_;\n      bool transparent_;\n};\n\n\n/*\n * This class represents a theoretical (though not necessarily\n * practical) integer divider gate. This is not to represent any real\n * hardware, but to support the / operator in Verilog, when it shows\n * up in structural contexts.\n *\n * The operands of the operation are the DataA<i> and DataB<i> inputs,\n * and the Result<i> output reflects the value DataA/DataB.\n */\n\nclass NetDivide  : public NetNode {\n\n    public:\n      NetDivide(NetScope*scope, perm_string n,\n\t\tunsigned width, unsigned wa, unsigned wb);\n      ~NetDivide();\n\n      unsigned width_r() const;\n      unsigned width_a() const;\n      unsigned width_b() const;\n\n      void set_signed(bool);\n      bool get_signed() const;\n\n      Link& pin_DataA();\n      Link& pin_DataB();\n      Link& pin_Result();\n\n      const Link& pin_DataA() const;\n      const Link& pin_DataB() const;\n      const Link& pin_Result() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned width_r_;\n      unsigned width_a_;\n      unsigned width_b_;\n\n      bool signed_flag_;\n};\n\n/*\n * This class represents a theoretical (though not necessarily\n * practical) integer modulo gate. This is not to represent any real\n * hardware, but to support the % operator in Verilog, when it shows\n * up in structural contexts.\n *\n * The operands of the operation are the DataA<i> and DataB<i> inputs,\n * and the Result<i> output reflects the value DataA%DataB.\n */\n\nclass NetModulo  : public NetNode {\n\n    public:\n      NetModulo(NetScope*s, perm_string n,\n\t\tunsigned width, unsigned wa, unsigned wb);\n      ~NetModulo();\n\n      unsigned width_r() const;\n      unsigned width_a() const;\n      unsigned width_b() const;\n\n      void set_signed(bool);\n      bool get_signed() const;\n\n      Link& pin_DataA();\n      Link& pin_DataB();\n      Link& pin_Result();\n\n      const Link& pin_DataA() const;\n      const Link& pin_DataB() const;\n      const Link& pin_Result() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned width_r_;\n      unsigned width_a_;\n      unsigned width_b_;\n\n      bool signed_flag_;\n};\n\n/*\n * This class represents an LPM_FF device. There is no literal gate\n * type in Verilog that maps, but gates of this type can be inferred.\n */\nclass NetFF  : public NetNode {\n\n    public:\n      NetFF(NetScope*s, perm_string n, bool negedge, unsigned vector_width);\n      ~NetFF();\n\n      bool is_negedge() const;\n      unsigned width() const;\n\n      Link& pin_Clock();\n      Link& pin_Enable();\n      Link& pin_Aset();\n      Link& pin_Aclr();\n      Link& pin_Sset();\n      Link& pin_Sclr();\n      Link& pin_Data();\n      Link& pin_Q();\n\n      const Link& pin_Clock() const;\n      const Link& pin_Enable() const;\n      const Link& pin_Aset() const;\n      const Link& pin_Aclr() const;\n      const Link& pin_Sset() const;\n      const Link& pin_Sclr() const;\n      const Link& pin_Data() const;\n      const Link& pin_Q() const;\n\n      void aset_value(const verinum&val);\n      const verinum& aset_value() const;\n\n      void sset_value(const verinum&val);\n      const verinum& sset_value() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      bool negedge_;\n      unsigned width_;\n      verinum aset_value_;\n      verinum sset_value_;\n};\n\n\n/*\n * This class represents an LPM_LATCH device. There is no literal gate\n * type in Verilog that maps, but gates of this type can be inferred.\n */\nclass NetLatch  : public NetNode {\n\n    public:\n      NetLatch(NetScope*s, perm_string n, unsigned vector_width);\n      ~NetLatch();\n\n      unsigned width() const;\n\n      Link& pin_Enable();\n      Link& pin_Data();\n      Link& pin_Q();\n\n      const Link& pin_Enable() const;\n      const Link& pin_Data() const;\n      const Link& pin_Q() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned width_;\n};\n\n/*\n * This class implements a basic LPM_MULT combinational multiplier. It\n * is used as a structural representation of the * operator. The\n * device has inputs A and B and output Result all with independent\n * widths.\n *\n * NOTE: Check this width thing. I think that the independence of the\n * widths is not necessary or even useful.\n */\nclass NetMult  : public NetNode {\n\n    public:\n      NetMult(NetScope*sc, perm_string n, unsigned width,\n\t      unsigned wa, unsigned wb);\n      ~NetMult();\n\n      bool get_signed() const;\n      void set_signed(bool);\n\n\t// Get the width of the device bussed inputs. There are these\n\t// parameterized widths:\n      unsigned width_r() const; // Result\n      unsigned width_a() const; // DataA\n      unsigned width_b() const; // DataB\n\n      Link& pin_DataA();\n      Link& pin_DataB();\n      Link& pin_Result();\n\n      const Link& pin_DataA() const;\n      const Link& pin_DataB() const;\n      const Link& pin_Result() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      bool signed_;\n      unsigned width_r_;\n      unsigned width_a_;\n      unsigned width_b_;\n};\n\n\n/*\n * This class represents an LPM_MUX device. This device has some\n * number of Result points (the width of the device) and some number\n * of input choices. There is also a selector of some width. The\n * parameters are:\n *\n *      width  -- Width of the result and each possible Data input\n *      size   -- Number of Data input (each of width)\n *      selw   -- Width in bits of the select input\n *\n * All the data inputs must have the same type, and are the type of\n * the result. The actual type does not matter, as the mux does not\n * process data, just selects alternatives.\n *\n * The select input must be an integral type of some sort. Not real.\n */\nclass NetMux  : public NetNode {\n\n    public:\n      NetMux(NetScope*scope, perm_string n,\n\t     unsigned width, unsigned size, unsigned selw);\n      ~NetMux();\n\n      unsigned width() const;\n      unsigned size() const;\n      unsigned sel_width() const;\n\n      Link& pin_Result();\n      Link& pin_Data(unsigned si);\n      Link& pin_Sel();\n\n      const Link& pin_Result() const;\n      const Link& pin_Data(unsigned) const;\n      const Link& pin_Sel() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned width_;\n      unsigned size_;\n      unsigned swidth_;\n};\n\n\n/*\n * This class implements a basic LPM_POW combinational power. It\n * is used as a structural representation of the ** operator. The\n * device has inputs A and B and output Result all with independent\n * widths.\n *\n * NOTE: Check this width thing. I think that the independence of the\n * widths is not necessary or even useful.\n */\nclass NetPow  : public NetNode {\n\n    public:\n      NetPow(NetScope*sc, perm_string n, unsigned width,\n\t      unsigned wa, unsigned wb);\n      ~NetPow();\n\n      bool get_signed() const;\n      void set_signed(bool);\n\n\t// Get the width of the device bussed inputs. There are these\n\t// parameterized widths:\n      unsigned width_r() const; // Result\n      unsigned width_a() const; // DataA\n      unsigned width_b() const; // DataB\n\n      Link& pin_DataA();\n      Link& pin_DataB();\n      Link& pin_Result();\n\n      const Link& pin_DataA() const;\n      const Link& pin_DataB() const;\n      const Link& pin_Result() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      bool signed_;\n      unsigned width_r_;\n      unsigned width_a_;\n      unsigned width_b_;\n};\n\n\n/*\n * The NetReplicate node takes a vector input and makes it into a larger\n * vector by repeating the input vector some number of times. The\n * repeat count is a fixed value. This is just like the repeat\n * concatenation of Verilog: {<repeat>{<vector>}}.\n *\n * When constructing this node, the wid is the vector width of the\n * output, and the rpt is the repeat count. The wid must be an even\n * multiple of the cnt, and wid/cnt is the expected input width.\n *\n * The device has exactly 2 pins: pin(0) is the output and pin(1) the\n * input.\n */\nclass NetReplicate  : public NetNode {\n\n    public:\n      NetReplicate(NetScope*scope, perm_string n, unsigned wid, unsigned rpt);\n      ~NetReplicate();\n\n      unsigned width() const;\n      unsigned repeat() const;\n\n      void dump_node(std::ostream&, unsigned ind) const;\n      bool emit_node(struct target_t*) const;\n\n    private:\n      unsigned width_;\n      unsigned repeat_;\n};\n\n/*\n * This node represents the call of a user defined function in a\n * structural context. The pin count is the same as the port count,\n * with pin0 the return value.\n */\nclass NetUserFunc  : public NetNode {\n\n    public:\n      NetUserFunc(NetScope*s, perm_string n, NetScope*def, NetEvWait*trigger__);\n      ~NetUserFunc();\n\n      unsigned port_width(unsigned port) const;\n\n      const NetScope* def() const;\n\n      const NetEvWait* trigger() const { return trigger_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      NetScope*def_;\n      NetEvWait*trigger_;\n};\n\n/*\n * The number of ports includes the return value, so will always be at\n * least 1.\n */\nclass NetSysFunc  : public NetNode {\n\n    public:\n      NetSysFunc(NetScope*s, perm_string n,\n\t\t const struct sfunc_return_type*def,\n\t\t unsigned ports, NetEvWait*trigger__);\n      ~NetSysFunc();\n\n      ivl_variable_type_t data_type() const;\n      unsigned vector_width() const;\n      const char* func_name() const;\n\n      const NetEvWait* trigger() const { return trigger_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      const struct sfunc_return_type*def_;\n      NetEvWait*trigger_;\n};\n\nclass NetTran  : public NetNode, public IslandBranch {\n\n    public:\n\t// Tran devices other than TRAN_VP\n      NetTran(NetScope*scope, perm_string n, ivl_switch_type_t type,\n              unsigned wid);\n\t// Create a TRAN_VP\n      NetTran(NetScope*scope, perm_string n, unsigned wid,\n\t      unsigned part, unsigned off);\n      ~NetTran();\n\n      ivl_switch_type_t type() const { return type_; }\n\n\t// These are only used for IVL_SW_TRAN_PV\n      unsigned vector_width() const;\n      unsigned part_width() const;\n      unsigned part_offset() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      ivl_switch_type_t type_;\n      unsigned wid_;\n      unsigned part_;\n      unsigned off_;\n};\n\n/* =========\n * There are cases where expressions need to be represented. The\n * NetExpr class is the root of a hierarchy that serves that purpose.\n *\n * The expr_width() is the width of the expression, which is calculated\n * before the expression is elaborated.\n */\nclass NetExpr  : public LineInfo {\n    public:\n      explicit NetExpr(unsigned w =0);\n      explicit NetExpr(ivl_type_t t);\n      virtual ~NetExpr() =0;\n\n      virtual void expr_scan(struct expr_scan_t*) const =0;\n      virtual void dump(std::ostream&) const;\n\n\t// This is the advanced description of the type. I think I\n\t// want to replace the other type description members with\n\t// this single method. The default for this method returns\n\t// nil.\n      ivl_type_t net_type() const;\n\n\t// Expressions have type.\n      virtual ivl_variable_type_t expr_type() const;\n\n\t// How wide am I?\n      unsigned expr_width() const { return width_; }\n\n\t// This method returns true if the expression is\n\t// signed. Unsigned expressions return false.\n      bool has_sign() const { return signed_flag_; }\n      virtual void cast_signed(bool flag);\n\n\t// This returns true if the expression has a definite\n\t// width. This is generally true, but in some cases the\n\t// expression is amorphous and desires a width from its\n\t// environment. For example, 'd5 has indefinite width, but\n\t// 5'd5 has a definite width.\n\n\t// This method is only really used within concatenation\n\t// expressions to check validity.\n      virtual bool has_width() const;\n\n\t// Return the enumeration set that defines this expressions\n\t// enumeration type, or return nil if the expression is not\n\t// part of the enumeration.\n      virtual const netenum_t*enumeration() const;\n\n\t// This method evaluates the expression and returns an\n\t// equivalent expression that is reduced as far as compile\n\t// time knows how. Essentially, this is designed to fold\n\t// constants.\n      virtual NetExpr*eval_tree();\n\n\t// Make a duplicate of myself, and subexpressions if I have\n\t// any. This is a deep copy operation.\n      virtual NetExpr*dup_expr() const =0;\n\n\t// Evaluate the expression at compile time, a la within a\n\t// constant function. This is used by the constant function\n\t// evaluation function code, and the return value is an\n\t// allocated constant, or nil if the expression cannot be\n\t// evaluated for any reason.\n      virtual NetExpr*evaluate_function(const LineInfo&loc,\n\t\t\t\t\tstd::map<perm_string,LocalVar>&ctx) const;\n\n\t// Get the Nexus that are the input to this\n\t// expression. Normally this descends down to the reference to\n\t// a signal that reads from its input.\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const =0;\n\n\t// Return a version of myself that is structural. This is used\n\t// for converting expressions to gates. The arguments are:\n\t//\n\t//  des, scope:  The context where this work is done\n\t//\n        //  root: The root expression of which this expression is a part.\n        //\n\t//  rise/fall/decay: Attach these delays to the driver for the\n\t//                   expression output.\n\t//\n\t//  drive0/drive1: Attach these strengths to the driver for\n\t//                 the expression output.\n      virtual NetNet*synthesize(Design*des, NetScope*scope, NetExpr*root);\n\n    protected:\n      void expr_width(unsigned wid) { width_ = wid; }\n      void cast_signed_base_(bool flag) { signed_flag_ = flag; }\n      void set_net_type(ivl_type_t type);\n\n    private:\n      ivl_type_t net_type_;\n      unsigned width_;\n      bool signed_flag_;\n\n    private: // not implemented\n      NetExpr(const NetExpr&);\n      NetExpr& operator=(const NetExpr&);\n};\n\nclass NetEArrayPattern  : public NetExpr {\n\n    public:\n      NetEArrayPattern(ivl_type_t lv_type, std::vector<NetExpr*>&items);\n      ~NetEArrayPattern();\n\n      inline size_t item_size() const { return items_.size(); }\n      const NetExpr* item(size_t idx) const { return items_[idx]; }\n\n      void expr_scan(struct expr_scan_t*) const;\n      void dump(std::ostream&) const;\n\n      NetEArrayPattern* dup_expr() const;\n      NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                          bool nested_func = false) const;\n      NetNet* synthesize(Design *des, NetScope *scope, NetExpr *root);\n\n    private:\n      std::vector<NetExpr*> items_;\n};\n\n/*\n * The expression constant is slightly special, and is sometimes\n * returned from other classes that can be evaluated at compile\n * time. This class represents constant values in expressions.\n */\nclass NetEConst  : public NetExpr {\n\n    public:\n      explicit NetEConst(ivl_type_t type, const verinum&val);\n      explicit NetEConst(const verinum&val);\n      ~NetEConst();\n\n      const verinum&value() const;\n\n      virtual void cast_signed(bool flag);\n      virtual bool has_width() const;\n      virtual ivl_variable_type_t expr_type() const;\n\n        /* This method allows the constant value to be converted\n           to an unsized value. This is used after evaluating a\n           unsized constant expression. */\n      void trim();\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n      virtual NetEConst* dup_expr() const;\n      virtual NetNet*synthesize(Design*, NetScope*scope, NetExpr*);\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual NetExpr*evaluate_function(const LineInfo&loc,\n\t\t\t\t\tstd::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      verinum value_;\n};\n\nclass NetEConstEnum  : public NetEConst {\n\n    public:\n      explicit NetEConstEnum(perm_string name, const netenum_t*enum_set,\n\t\t\t     const verinum&val);\n      ~NetEConstEnum();\n\n      perm_string name() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n      virtual NetEConstEnum* dup_expr() const;\n\n    private:\n      perm_string name_;\n};\n\nclass NetEConstParam  : public NetEConst {\n\n    public:\n      explicit NetEConstParam(const NetScope*scope, perm_string name,\n\t\t\t      const verinum&val);\n      ~NetEConstParam();\n\n      perm_string name() const;\n      const NetScope*scope() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n      virtual NetEConstParam* dup_expr() const;\n\n    private:\n      const NetScope*scope_;\n      perm_string name_;\n};\n\n/*\n * This class represents a constant real value.\n */\nclass NetECReal  : public NetExpr {\n\n    public:\n      explicit NetECReal(const verireal&val);\n      ~NetECReal();\n\n      const verireal&value() const;\n\n\t// The type of this expression is ET_REAL\n      ivl_variable_type_t expr_type() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n      virtual NetECReal* dup_expr() const;\n      virtual NetNet*synthesize(Design*, NetScope*scope, NetExpr*);\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual NetExpr*evaluate_function(const LineInfo&loc,\n\t\t\t\t\tstd::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      verireal value_;\n};\n\nclass NetECString  : public NetEConst {\n    public:\n      explicit NetECString(const std::string& val);\n      ~NetECString();\n\n      // The type of a string is IVL_VT_STRING\n      ivl_variable_type_t expr_type() const;\n};\n\nclass NetECRealParam  : public NetECReal {\n\n    public:\n      explicit NetECRealParam(const NetScope*scope, perm_string name,\n\t\t\t      const verireal&val);\n      ~NetECRealParam();\n\n      perm_string name() const;\n      const NetScope*scope() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n      virtual NetECRealParam* dup_expr() const;\n\n    private:\n      const NetScope*scope_;\n      perm_string name_;\n};\n\n/*\n * The NetPartSelect device represents a netlist part select of a\n * signal vector. Pin 0 is a vector that is a part select of pin 1,\n * which connected to the NetNet of the signal being selected from.\n *\n * The part to be selected is the canonical (0-based) offset and the\n * specified number of bits (wid).\n *\n * If the offset is non-constant, then pin(2) is the input vector for\n * the selector. If this pin is present, then use the non-constant\n * selector as the input.\n *\n * The NetPartSelect can be output from the signal (i.e. reading a\n * part) or input into the signal. The DIR method gives the type of\n * the node.\n *\n * VP (Vector-to-Part)\n *  Output pin 0 is the part select, and input pin 1 is connected to\n *  the NetNet object.\n *\n * PV (Part-to-Vector)\n *  Output pin 1 is connected to the NetNet, and input pin 0 is the\n *  part select. In this case, the node is driving the NetNet.\n *\n * Note that whatever the direction that data is intended to flow,\n * pin-0 is the part select and pin-1 is connected to the NetNet.\n */\nclass NetPartSelect  : public NetNode {\n\n    public:\n\t// enum for the device direction\n      enum dir_t { VP, PV};\n\n      explicit NetPartSelect(NetNet*sig,\n\t\t\t     unsigned off, unsigned wid, dir_t dir,\n\t\t\t     bool signed_flag__ = false);\n      explicit NetPartSelect(NetNet*sig, NetNet*sel,\n\t\t\t     unsigned wid, bool signed_flag__ = false);\n      ~NetPartSelect();\n\n      unsigned base()  const;\n      unsigned width() const;\n      inline dir_t dir()   const { return dir_; }\n\t/* Is the select signal signed? */\n      inline bool signed_flag() const { return signed_flag_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      bool emit_node(struct target_t*tgt) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned off_;\n      unsigned wid_;\n      dir_t    dir_;\n      bool signed_flag_;\n};\n\n/*\n * This device supports simple substitution of a part within a wider\n * vector. For example, this:\n *\n *      wire [7:0] foo = NetSubstitute(bar, bat, off);\n *\n * means that bar is a vector the same width as foo, bat is a narrower\n * vector. The off is a constant offset into the bar vector. This\n * looks something like this:\n *\n *      foo = bar;\n *      foo[off +: <width_of_bat>] = bat;\n *\n * There is no direct way in Verilog to express this (as a single\n * device), it instead turns up in certain synthesis situation,\n * i.e. the example above.\n */\nclass NetSubstitute : public NetNode {\n\n    public:\n      NetSubstitute(NetNet*sig, NetNet*sub, unsigned wid, unsigned off);\n      ~NetSubstitute();\n\n      inline unsigned width() const { return wid_; }\n      inline unsigned base() const  { return off_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*tgt) const;\n      virtual void functor_node(Design*des, functor_t*fun);\n\n    private:\n      unsigned wid_;\n      unsigned off_;\n};\n\n/*\n * The NetBUFZ is a magic device that represents the continuous\n * assign, with the output being the target register and the input\n * the logic that feeds it. The netlist preserves the directional\n * nature of that assignment with the BUFZ. The target may elide it if\n * that makes sense for the technology.\n *\n * A NetBUFZ is transparent if strengths are passed through it without\n * change. A NetBUFZ is non-transparent if values other than HiZ are\n * converted to the strength of the output.\n */\nclass NetBUFZ  : public NetNode {\n\n    public:\n      explicit NetBUFZ(NetScope*s, perm_string n, unsigned wid, bool transp, int port_info_index = -1);\n      ~NetBUFZ();\n\n      unsigned width() const;\n      bool transparent() const { return transparent_; }\n      int port_info_index() const { return port_info_index_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      unsigned width_;\n      bool transparent_;\n      int port_info_index_;\n};\n\n/*\n * This node is used to represent case equality in combinational\n * logic. Although this is not normally synthesizable, it makes sense\n * to support an abstract gate that can compare x and z. This node\n * always generates a single bit result, no matter the width of the\n * input. The elaboration, btw, needs to make sure the input widths\n * match.\n *\n * The case compare can be generated to handle ===/!==, or also\n * to test guards in the case/casez/casex statements.\n *\n * This pins are assigned as:\n *\n *     0   -- Output (always returns 0 or 1)\n *     1   -- Input\n *     2   -- Input (wildcard input for EQX and EQZ variants)\n */\nclass NetCaseCmp  : public NetNode {\n\n    public:\n      enum kind_t {\n\t    EEQ, // ===\n\t    NEQ, // !==\n\t    WEQ, // ==?\n\t    WNE, // !=?\n\t    XEQ, // casex guard tests\n\t    ZEQ  // casez guard tests\n      };\n\n    public:\n      explicit NetCaseCmp(NetScope*s, perm_string n, unsigned wid, kind_t eeq);\n      ~NetCaseCmp();\n\n      unsigned width() const;\n\t// What kind of case compare?\n      inline kind_t kind() const { return kind_; }\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n\n    private:\n      unsigned width_;\n      const kind_t kind_;\n};\n\nextern std::ostream& operator << (std::ostream&fd, NetCaseCmp::kind_t that);\n\n/* NOTE: This class should be replaced with the NetLiteral class\n * below, that is more general in that it supports different types of\n * values.\n *\n * This class represents instances of the LPM_CONSTANT device. The\n * node has only outputs and a constant value. The width is available\n * by getting the pin_count(), and the value bits are available one at\n * a time. There is no meaning to the aggregation of bits to form a\n * wide NetConst object, although some targets may have an easier time\n * detecting interesting constructs if they are combined.\n */\nclass NetConst  : public NetNode {\n\n    public:\n      explicit NetConst(NetScope*s, perm_string n, verinum::V v);\n      explicit NetConst(NetScope*s, perm_string n, const verinum&val);\n      ~NetConst();\n\n      inline const verinum&value(void) const { return value_; }\n      verinum::V value(unsigned idx) const;\n      inline unsigned width() const { return value_.len(); }\n      inline bool is_string() const { return value_.is_string(); }\n\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*, functor_t*);\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n\n    private:\n      verinum value_;\n};\n\n/*\n * This class represents instances of the LPM_CONSTANT device. The\n * node has only outputs and a constant value. The width is available\n * by getting the pin_count(), and the value bits are available one at\n * a time. There is no meaning to the aggregation of bits to form a\n * wide NetConst object, although some targets may have an easier time\n * detecting interesting constructs if they are combined.\n */\nclass NetLiteral  : public NetNode {\n\n    public:\n\t// A read-valued literal.\n      explicit NetLiteral(NetScope*s, perm_string n, const verireal&val);\n      ~NetLiteral();\n\n      ivl_variable_type_t data_type() const;\n\n      const verireal& value_real() const;\n\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*, functor_t*);\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n\n    private:\n      verireal real_;\n};\n\n/*\n * This class represents all manner of logic gates. Pin 0 is OUTPUT and\n * all the remaining pins are INPUT. The BUFIF[01] gates have the\n * more specific pinout as follows:\n *\n *     bufif<N>\n *       0  -- output\n *       1  -- input data\n *       2  -- enable\n *\n * The pullup and pulldown gates have no inputs at all, and pin0 is\n * the output 1 or 0, depending on the gate type. It is the strength\n * of that value that is important.\n *\n * All these devices process vectors bitwise, so each bit can be\n * logically separated. The exception is the CONCAT gate, which is\n * really an abstract gate that takes the inputs and turns it into a\n * vector of bits.\n */\nclass NetLogic  : public NetNode {\n\n    public:\n      enum TYPE { AND, BUF, BUFIF0, BUFIF1, CMOS, EQUIV, IMPL, NAND, NMOS,\n\t\t  NOR, NOT, NOTIF0, NOTIF1, OR, PULLDOWN, PULLUP, RCMOS,\n\t\t  RNMOS, RPMOS, PMOS, XNOR, XOR };\n\n      explicit NetLogic(NetScope*s, perm_string n, unsigned pins,\n\t\t\tTYPE t, unsigned wid, bool is_cassign__=false);\n\n      TYPE type() const;\n      unsigned width() const;\n      bool is_cassign() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*, functor_t*);\n\n    private:\n      TYPE type_;\n      unsigned width_;\n      bool is_cassign_;\n};\n\n/*\n * This class represents a structural sign extension. The pin-0 is a\n * vector of the input pin-1 sign-extended. The input is taken to be\n * signed. This generally matches a hardware implementation of\n * replicating the top bit enough times to create the desired output\n * width.\n */\nclass NetSignExtend  : public NetNode {\n\n    public:\n      explicit NetSignExtend(NetScope*s, perm_string n, unsigned wid);\n      ~NetSignExtend();\n\n      unsigned width() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*, functor_t*);\n\n    private:\n      unsigned width_;\n};\n\n/*\n * This class represents *reduction* logic operators. Certain boolean\n * logic operators have reduction forms which take in a vector and\n * return a single bit that is calculated by applying the logic\n * operation through the width of the input vector. These correspond\n * to reduction unary operators in Verilog.\n */\nclass NetUReduce  : public NetNode {\n\n    public:\n      enum TYPE {NONE, AND, OR, XOR, NAND, NOR, XNOR};\n\n      NetUReduce(NetScope*s, perm_string n, TYPE t, unsigned wid);\n\n      TYPE type() const;\n      unsigned width() const;\n\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n      virtual bool emit_node(struct target_t*) const;\n      virtual void functor_node(Design*, functor_t*);\n\n    private:\n      TYPE type_;\n      unsigned width_;\n};\n\n/*\n * The UDP is a User Defined Primitive from the Verilog source. Do not\n * expand it out any further than this in the netlist, as this can be\n * used to represent target device primitives.\n *\n * The UDP can be combinational or sequential. The sequential UDP\n * includes the current output in the truth table, and supports edges,\n * whereas the combinational does not and is entirely level sensitive.\n * In any case, pin 0 is an output, and all the remaining pins are\n * inputs.\n *\n * Set_table takes as input a string with one letter per pin. The\n * parser translates the written sequences to one of these. The\n * valid characters are:\n *\n *      0, 1, x  -- The levels\n *      r   -- (01)\n *      R   -- (x1)\n *      f   -- (10)\n *      F   -- (x0)\n *      P   -- (0x)\n *      N   -- (1x)\n *\n * It also takes one of the following glob letters to represent more\n * than one item.\n *\n *      p   -- 01, 0x or x1 // check this with the lexer\n *      n   -- 10, 1x or x0 // check this with the lexer\n *      ?   -- 0, 1, or x\n *      *   -- any edge\n *      +   -- 01 or x1\n *      _   -- 10 or x0  (Note that this is not the output '-'.)\n *      %   -- 0x or 1x\n *\n * SEQUENTIAL\n * These objects have a single bit of memory. The logic table includes\n * an entry for the current value, and allows edges on the inputs. In\n * canonical form, only the entries that generate 0, 1 or - (no change)\n * are listed.\n *\n * COMBINATIONAL\n * The logic table is a map between the input levels and the\n * output. Each input pin can have the value 0, 1 or x and the output\n * can have the values 0 or 1. If the input matches nothing, the\n * output is x. In canonical form, only the entries that generate 0 or\n * 1 are listed.\n *\n */\n\nclass NetUDP  : public NetNode {\n\n    public:\n      explicit NetUDP(NetScope*s, perm_string n, unsigned pins, PUdp*u);\n\n      virtual bool emit_node(struct target_t*) const;\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n\n\t/* Use these methods to scan the truth table of the\n\t   device. \"first\" returns the first item in the table, and\n\t   \"next\" returns the next item in the table. The method will\n\t   return false when the scan is done. */\n      bool first(std::string&inp, char&out) const;\n      bool next(std::string&inp, char&out) const;\n      unsigned rows() const { return udp->tinput.size(); }\n\n      unsigned nin() const { return pin_count()-1; }\n      bool is_sequential() const { return udp->sequential; }\n      perm_string udp_name() const { return udp->name_; }\n      perm_string udp_file() const { return udp->get_file(); }\n      unsigned udp_lineno() const { return udp->get_lineno(); }\n      char get_initial() const;\n\n      unsigned port_count() const;\n      std::string port_name(unsigned idx) const;\n\n    private:\n      mutable unsigned table_idx;\n      PUdp *udp;\n};\n\nenum DelayType { NO_DELAY, ZERO_DELAY, POSSIBLE_DELAY, DEFINITE_DELAY };\n\n/* =========\n * A process is a behavioral-model description. A process is a\n * statement that may be compound. The various statement types may\n * refer to places in a netlist (by pointing to nodes) but is not\n * linked into the netlist. However, elaborating a process may cause\n * special nodes to be created to handle things like events.\n */\nclass NetProc : public virtual LineInfo {\n\n    public:\n      explicit NetProc();\n      virtual ~NetProc();\n\n\t// Find the nexa that are input by the statement. This is used\n\t// for example by @* to find the inputs to the process for the\n\t// sensitivity list.\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n\t// Find the nexa that are set by the statement. Add the output\n\t// values to the set passed as a parameter.\n      virtual void nex_output(NexusSet&);\n\n\t// This method is called to emit the statement to the\n\t// target. The target returns true if OK, false for errors.\n      virtual bool emit_proc(struct target_t*) const;\n\n\t// This method is used by the NetFuncDef object to evaluate a\n\t// constant function at compile time. The loc is the location\n\t// of the function call, and is used for error messages. The\n\t// ctx is a map of name to expression. This is for mapping\n\t// identifiers to values. The function returns true if the\n\t// processing succeeds, or false otherwise.\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n\t// This method is called by functors that want to scan a\n\t// process in search of matchable patterns.\n      virtual int match_proc(struct proc_match_t*);\n\n\t// Return true if this represents the root of a combinational\n\t// process. Most process types are not.\n      virtual bool is_asynchronous();\n\n\t// Return true if this represents the root of a synchronous\n\t// process. Most process types are not.\n      virtual bool is_synchronous();\n\n\t// Synthesize as asynchronous logic, and return true on success.\n\t//\n\t// nex_map holds the set of nexuses that are driven by this\n\t// process, nex_out holds the accumulated outputs from this and\n\t// preceding sequential processes (i.e statements in the same\n\t// block), enables holds the accumulated clock/gate enables,\n\t// and bitmasks holds the accumulated masks that flag which bits\n\t// are unconditionally driven (i.e. driven by every clause in\n\t// every statement). On output, the values passed in to nex_out,\n\t// enables, and bitmasks may either be merged with or replaced\n\t// by the values originating from this process, depending on the\n\t// type of statement this process represents.\n\t//\n\t// The clock/gate enables generated by synthesis operate at a\n\t// vector level (i.e. they are asserted if any bit(s) in the\n\t// vector are driven).\n      typedef std::vector<bool> mask_t;\n      virtual bool synth_async(Design*des, NetScope*scope,\n\t\t\t       NexusSet&nex_map, NetBus&nex_out,\n\t\t\t       NetBus&enables, std::vector<mask_t>&bitmasks);\n\n\t// Synthesize as synchronous logic, and return true on success.\n\t// That means binding the outputs to the data port of a FF, and\n\t// the event inputs to a FF clock. Only some key NetProc sub-types\n\t// that have specific meaning in synchronous statements. The\n\t// remainder reduce to a call to synth_async that connects the\n\t// output to the Data input of the FF.\n\t//\n\t// The nex_map, nex_out, ff_ce, and bitmasks arguments serve\n\t// the same purpose as in the synth_async method (where ff_ce\n\t// is equivalent to enables). The events argument is filled\n\t// in by the NetEvWait implementation of this method with the\n\t// probes that it does not itself pick off as a clock. These\n\t// events should be picked off by e.g. condit statements as\n\t// asynchronous set/reset inputs to the flipflop being generated.\n      virtual bool synth_sync(Design*des, NetScope*scope,\n\t\t\t      bool&ff_negedge,\n\t\t\t      NetNet*ff_clock, NetBus&ff_ce,\n\t\t\t      NetBus&ff_aclr,  NetBus&ff_aset,\n\t\t\t      std::vector<verinum>&ff_aset_value,\n\t\t\t      NexusSet&nex_map, NetBus&nex_out,\n\t\t\t      std::vector<mask_t>&bitmasks,\n\t\t\t      const std::vector<NetEvProbe*>&events);\n\n      virtual void dump(std::ostream&, unsigned ind) const;\n\n\t// Recursively checks to see if there is delay in this element.\n      virtual DelayType delay_type(bool print_delay=false) const;\n\t// Check to see if the item is synthesizable.\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    protected:\n      bool synth_async_block_substatement_(Design*des, NetScope*scope,\n\t\t\t\t\t   NexusSet&nex_map,\n\t\t\t\t\t   NetBus&nex_out,\n\t\t\t\t\t   NetBus&enables,\n\t\t\t\t\t   std::vector<mask_t>&bitmasks,\n\t\t\t\t\t   NetProc*substmt);\n    private:\n      friend class NetBlock;\n      NetProc*next_;\n\n    private: // not implemented\n      NetProc(const NetProc&);\n      NetProc& operator= (const NetProc&);\n};\n\nclass NetAlloc  : public NetProc {\n\n    public:\n      explicit NetAlloc(NetScope*);\n      ~NetAlloc();\n\n      const std::string name() const;\n\n      const NetScope* scope() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n\n    private:\n      NetScope*scope_;\n};\n\n/*\n * Procedural assignment is broken into a suite of classes. These\n * classes represent the various aspects of the assignment statement\n * in behavioral code. (The continuous assignment is *not*\n * represented here.)\n *\n * The NetAssignBase carries the common aspects of an assignment,\n * including the r-value. This class has no cares of blocking vs\n * non-blocking, however it carries nearly all the other properties\n * of the assignment statement. It is abstract because it does not\n * differentiate the virtual behaviors.\n *\n * The NetAssign and NetAssignNB classes are the concrete classes that\n * give the assignment its final, precise meaning. These classes fill\n * in the NetProc behaviors.\n *\n * The l-value of the assignment is a collection of NetAssign_\n * objects that are connected to the structural netlist where the\n * assignment has its effect. The NetAssign_ class is not to be\n * derived from.\n *\n * The collection is arranged from lsb up to msb, and represents the\n * concatenation of l-values. The elaborator may collapse some\n * concatenations into a single NetAssign_. The \"more\" member of the\n * NetAssign_ object points to the next most significant bits of l-value.\n *\n * NOTE: The elaborator will make an effort to match the width of the\n * r-value to the width of the l-value, but targets and functions\n * should know that this is not a guarantee.\n */\n\nclass NetAssign_ {\n\n    public:\n      explicit NetAssign_(NetAssign_*nest);\n      explicit NetAssign_(NetNet*sig);\n      ~NetAssign_();\n\n\t// This is so NetAssign_ objects can be passed to ivl_assert\n\t// and other macros that call this method.\n      std::string get_fileline() const;\n\n\t// If this expression exists, then it is used to select a word\n\t// from an array/memory.\n      NetExpr*word();\n      const NetExpr*word() const;\n\n      NetScope*scope()const;\n\n\t// Get the base index of the part select, or 0 if there is no\n\t// part select.\n      const NetExpr* get_base() const;\n      ivl_select_type_t select_type() const;\n\n      void set_word(NetExpr*);\n\t// Set a part select expression for the l-value vector. Note\n\t// that the expression calculates a CANONICAL bit address.\n      void set_part(NetExpr* loff, unsigned wid,\n                    ivl_select_type_t = IVL_SEL_OTHER);\n\t// Set a part select expression for the l-value vector. Note\n\t// that the expression calculates a CANONICAL bit address.\n\t// The part select has a specific type and the width of the select will\n\t// be that of the type.\n      void set_part(NetExpr *loff, ivl_type_t data_type);\n\t// Set the member or property name if the signal type is a\n\t// class.\n      void set_property(const perm_string&name, unsigned int idx);\n      inline int get_property_idx(void) const { return member_idx_; }\n\n\t// Determine if the assigned object is signed or unsigned.\n\t// This is used when determining the expression type for\n\t// a compressed assignment statement.\n      bool get_signed() const { return signed_; }\n      void set_signed(bool flag) { signed_ = flag; }\n\n\t// Get the width of the r-value that this node expects. This\n\t// method accounts for the presence of the mux, so it is not\n\t// necessarily the same as the pin_count().\n      unsigned lwidth() const;\n      ivl_variable_type_t expr_type() const;\n\n\t// Get the expression type of the l-value. This may be\n\t// different from the type of the contained signal if for\n\t// example a darray is indexed.\n      ivl_type_t net_type() const;\n\n\t// Get the name of the underlying object.\n      perm_string name() const;\n\n      NetNet* sig() const;\n      inline const NetAssign_* nest() const { return nest_; }\n\n\t// Mark that the synthesizer has worked with this l-value, so\n\t// when it is released, the l-value signal should be turned\n\t// into a wire.\n      void turn_sig_to_wire_on_release();\n\n\t// It is possible that l-values can have *inputs*, as well as\n\t// being outputs. For example foo[idx] = ... is the l-value\n\t// (NetAssign_ object) with a foo l-value and the input\n\t// expression idx.\n      NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                          bool nested_func = false) const;\n\n\t// Figuring out nex_output to process ultimately comes down to\n\t// this method.\n      void nex_output(NexusSet&);\n\n\t// This pointer is for keeping simple lists.\n      NetAssign_* more;\n\n      void dump_lval(std::ostream&o) const;\n\n    private:\n\t// Nested l-value. If this is set, sig_ must NOT be set!\n      NetAssign_*nest_;\n      NetNet *sig_;\n\t// Memory word index\n      NetExpr*word_;\n\t// member/property if signal is a class.\n      perm_string member_;\n      int member_idx_ = -1;\n\n      bool signed_;\n      bool turn_sig_to_wire_on_release_;\n\t// indexed part select base\n      NetExpr*base_;\n      unsigned lwid_;\n      ivl_select_type_t sel_type_;\n      ivl_type_t part_data_type_ = nullptr;\n};\n\nclass NetAssignBase : public NetProc {\n\n    public:\n      NetAssignBase(NetAssign_*lv, NetExpr*rv);\n      virtual ~NetAssignBase() =0;\n\n\t// This is the (procedural) value that is to be assigned when\n\t// the assignment is executed.\n      NetExpr*rval();\n      const NetExpr*rval() const;\n\n      void set_rval(NetExpr*);\n\n      NetAssign_* l_val(unsigned);\n      const NetAssign_* l_val(unsigned) const;\n      unsigned l_val_count() const;\n\n      void set_delay(NetExpr*);\n      const NetExpr* get_delay() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&o);\n\n\n\t// This returns the total width of the accumulated l-value. It\n\t// accounts for any grouping of NetAssign_ objects that might happen.\n      unsigned lwidth() const;\n\n      bool synth_async(Design*des, NetScope*scope,\n\t\t       NexusSet&nex_map, NetBus&nex_out,\n\t\t       NetBus&enables, std::vector<mask_t>&bitmasks);\n\n\t// This dumps all the lval structures.\n      void dump_lval(std::ostream&) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n      NetAssign_*lval_;\n      NetExpr   *rval_;\n      NetExpr   *delay_;\n};\n\nclass NetAssign : public NetAssignBase {\n\n    public:\n      explicit NetAssign(NetAssign_*lv, NetExpr*rv);\n      explicit NetAssign(NetAssign_*lv, char op, NetExpr*rv);\n      ~NetAssign();\n\n      bool is_asynchronous();\n\n      inline char assign_operator(void) const { return op_; }\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual int match_proc(struct proc_match_t*);\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      void eval_func_lval_op_real_(const LineInfo&loc, verireal&lv, const verireal&rv) const;\n      void eval_func_lval_op_(const LineInfo&loc, verinum&lv, verinum&rv) const;\n      bool eval_func_lval_(const LineInfo&loc, std::map<perm_string,LocalVar>&ctx,\n\t\t\t   const NetAssign_*lval, NetExpr*rval_result) const;\n\n      char op_;\n};\n\nclass NetAssignNB  : public NetAssignBase {\n    public:\n      explicit NetAssignNB(NetAssign_*lv, NetExpr*rv, NetEvWait*ev,\n                           NetExpr*cnt);\n      ~NetAssignNB();\n\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual int match_proc(struct proc_match_t*);\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n      unsigned nevents() const;\n      const NetEvent*event(unsigned) const;\n      const NetExpr* get_count() const;\n\n    private:\n      NetEvWait*event_;\n      NetExpr*count_;\n};\n\n/*\n * A block is stuff like begin-end blocks, that contain an ordered\n * list of NetProc statements.\n *\n * NOTE: The emit method calls the target->proc_block function but\n * does not recurse. It is up to the target-supplied proc_block\n * function to call emit_recurse.\n */\nclass NetBlock  : public NetProc {\n\n    public:\n      enum Type { SEQU, PARA, PARA_JOIN_ANY, PARA_JOIN_NONE };\n\n      NetBlock(Type t, NetScope*subscope);\n      ~NetBlock();\n\n      Type type() const    { return type_; }\n      NetScope* subscope() const { return subscope_; }\n\n      void append(NetProc*);\n      void prepend(NetProc*);\n\n      const NetProc*proc_first() const;\n      const NetProc*proc_next(const NetProc*cur) const;\n\n      bool evaluate_function(const LineInfo&loc,\n\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n\t// synthesize as asynchronous logic, and return true.\n      bool synth_async(Design*des, NetScope*scope,\n\t\t       NexusSet&nex_map, NetBus&nex_out,\n\t\t       NetBus&enables, std::vector<mask_t>&bitmasks);\n\n      bool synth_sync(Design*des, NetScope*scope,\n\t\t      bool&ff_negedge,\n\t\t      NetNet*ff_clk, NetBus&ff_ce,\n\t\t      NetBus&ff_aclr,NetBus&ff_aset,\n\t\t      std::vector<verinum>&ff_aset_value,\n\t\t      NexusSet&nex_map, NetBus&nex_out,\n\t\t      std::vector<mask_t>&bitmasks,\n\t\t      const std::vector<NetEvProbe*>&events);\n\n\t// This version of emit_recurse scans all the statements of\n\t// the begin-end block sequentially. It is typically of use\n\t// for sequential blocks.\n      void emit_recurse(struct target_t*) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual int match_proc(struct proc_match_t*);\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n      const Type type_;\n      NetScope*subscope_;\n\n      NetProc*last_;\n};\n\nclass NetBreak : public NetProc {\n    public:\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool emit_proc(struct target_t*) const;\n      bool evaluate_function(const LineInfo &loc,\n\t\t\t     std::map<perm_string,LocalVar> &ctx) const final;\n};\n\n/*\n * A CASE statement in the Verilog source leads, eventually, to one of\n * these. This is different from a simple conditional because of the\n * way the comparisons are performed. Also, it is likely that the\n * target may be able to optimize differently.\n *\n * Case statements can have unique, unique0, or priority attached to\n * them. If not otherwise adorned, it is QBASIC.\n *\n * Case can be one of three types:\n *    EQ  -- All bits must exactly match\n *    EQZ -- z bits are don't care\n *    EQX -- x and z bits are don't care.\n */\nclass NetCase  : public NetProc {\n\n    public:\n      enum TYPE { EQ, EQX, EQZ };\n\n      NetCase(ivl_case_quality_t q, TYPE c, NetExpr*ex, unsigned cnt);\n      ~NetCase();\n\n      void set_case(unsigned idx, NetExpr*ex, NetProc*st);\n\n      void prune();\n\n      inline ivl_case_quality_t case_quality() const { return quality_; }\n      TYPE type() const;\n      const NetExpr*expr() const { return expr_; }\n      inline unsigned nitems() const { return items_.size(); }\n\n      inline const NetExpr*expr(unsigned idx) const { return items_[idx].guard;}\n      inline const NetProc*stat(unsigned idx) const { return items_[idx].statement; }\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&out);\n\n      bool synth_async(Design*des, NetScope*scope,\n\t\t       NexusSet&nex_map, NetBus&nex_out,\n\t\t       NetBus&enables, std::vector<mask_t>&bitmasks);\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      bool evaluate_function_vect_(const LineInfo&loc,\n\t\t\t\t   std::map<perm_string,LocalVar>&ctx) const;\n      bool evaluate_function_real_(const LineInfo&loc,\n\t\t\t\t   std::map<perm_string,LocalVar>&ctx) const;\n\n      bool synth_async_casez_(Design*des, NetScope*scope,\n\t\t\t      NexusSet&nex_map, NetBus&nex_out,\n\t\t\t      NetBus&enables, std::vector<mask_t>&bitmasks);\n\n      ivl_case_quality_t quality_;\n      TYPE type_;\n\n      struct Item {\n\t    inline Item() : guard(0), statement(0) { }\n\t    NetExpr*guard;\n\t    NetProc*statement;\n      };\n\n      NetExpr* expr_;\n      std::vector<Item>items_;\n};\n\n/*\n * The cassign statement causes the r-val net to be forced onto the\n * l-val reg when it is executed. The code generator is expected to\n * know what that means.\n */\nclass NetCAssign  : public NetAssignBase {\n\n    public:\n      explicit NetCAssign(NetAssign_*lv, NetExpr*rv);\n      ~NetCAssign();\n\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool emit_proc(struct target_t*) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private: // not implemented\n      NetCAssign(const NetCAssign&);\n      NetCAssign& operator= (const NetCAssign&);\n};\n\n\n/*\n * A condit represents a conditional. It has an expression to test,\n * and a pair of statements to select from. If the original statement\n * has empty clauses, then the NetProc for it will be a null pointer.\n */\nclass NetCondit  : public NetProc {\n\n    public:\n      explicit NetCondit(NetExpr*ex, NetProc*i, NetProc*e);\n      ~NetCondit();\n\n      const NetExpr*expr() const;\n      NetExpr*expr();\n\n      NetProc* if_clause();\n      NetProc* else_clause();\n\n\t// Replace the condition expression.\n      void set_expr(NetExpr*ex);\n\n      bool emit_recurse_if(struct target_t*) const;\n      bool emit_recurse_else(struct target_t*) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&o);\n\n      bool is_asynchronous();\n      bool synth_async(Design*des, NetScope*scope,\n\t\t       NexusSet&nex_map, NetBus&nex_out,\n\t\t       NetBus&enables, std::vector<mask_t>&bitmasks);\n\n      bool synth_sync(Design*des, NetScope*scope,\n\t\t      bool&ff_negedge,\n\t\t      NetNet*ff_clk, NetBus&ff_ce,\n\t\t      NetBus&ff_aclr,NetBus&ff_aset,\n\t\t      std::vector<verinum>&ff_aset_value,\n\t\t      NexusSet&nex_map, NetBus&nex_out,\n\t\t      std::vector<mask_t>&bitmasks,\n\t\t      const std::vector<NetEvProbe*>&events);\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual int match_proc(struct proc_match_t*);\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      NetExpr* expr_;\n      NetProc*if_;\n      NetProc*else_;\n};\n\nclass NetContinue : public NetProc {\n    public:\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool emit_proc(struct target_t*) const;\n      bool evaluate_function(const LineInfo &loc,\n\t\t\t     std::map<perm_string,LocalVar> &ctx) const final;\n};\n\n/*\n * This represents the analog contribution statement. The l-val is a\n * branch expression, and the r-value is an arbitrary expression that\n * may include branches and real values.\n */\nclass NetContribution : public NetProc {\n\n    public:\n      explicit NetContribution(NetEAccess*lval, NetExpr*rval);\n      ~NetContribution();\n\n      const NetEAccess* lval() const;\n      const NetExpr* rval() const;\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n\n    private:\n      NetEAccess*lval_;\n      NetExpr*rval_;\n};\n\n/*\n * The procedural deassign statement (the opposite of assign) releases\n * any assign expressions attached to the bits of the reg. The\n * lval is the expression of the \"deassign <expr>;\" statement with the\n * expr elaborated to a net.\n */\nclass NetDeassign : public NetAssignBase {\n\n    public:\n      explicit NetDeassign(NetAssign_*l);\n      ~NetDeassign();\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private: // not implemented\n      NetDeassign(const NetDeassign&);\n      NetDeassign& operator= (const NetDeassign&);\n};\n\n/*\n * This node represents the behavioral disable statement. The Verilog\n * source that produces it looks like:\n *\n *          disable <scope>;\n *\n * Where the scope is a named block or a task. It cannot be a module\n * instance scope because module instances cannot be disabled.\n */\nclass NetDisable  : public NetProc {\n\n    public:\n      explicit NetDisable(NetScope*tgt, bool flow_control = false);\n      ~NetDisable();\n\n      const NetScope*target() const;\n      bool flow_control() const { return flow_control_; }\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      NetScope*target_;\n       // If false all threads in the target_ scope are disabled. If true only\n       // the closest thread in thread hierarchy of the target_ scope is\n       // disabled. The latter is used to implement flow control statements like\n       // `return`.\n      bool flow_control_;\n\n    private: // not implemented\n      NetDisable(const NetDisable&);\n      NetDisable& operator= (const NetDisable&);\n};\n\n/*\n * The do/while statement is a condition that is tested at the end of\n * each iteration, and a statement (a NetProc) that is executed once and\n * then again as long as the condition is true.\n */\nclass NetDoWhile  : public NetProc {\n\n    public:\n      NetDoWhile(NetExpr*c, NetProc*p)\n      : cond_(c), proc_(p) { }\n\n      const NetExpr*expr() const { return cond_; }\n\n      void emit_proc_recurse(struct target_t*) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      NetExpr* cond_;\n      NetProc*proc_;\n};\n\n/*\n * A NetEvent is an object that represents an event object, that is\n * objects declared like so in Verilog:\n *\n *        event foo;\n *\n * Once an object of this type exists, behavioral code can wait on the\n * event or trigger the event. Event waits refer to this object, as do\n * the event trigger statements. The NetEvent class may have a name and\n * a scope. The name is a simple name (no hierarchy) and the scope is\n * the NetScope that contains the object. The scope member is written\n * by the NetScope object when the NetEvent is stored.\n *\n * The NetEvWait class represents a thread wait for an event. When\n * this statement is executed, it starts waiting on the\n * event. Conceptually, it puts itself on the event list for the\n * referenced event. When the event is triggered, the wait ends its\n * block and starts the associated statement.\n *\n * The NetEvTrig class represents trigger statements. Executing this\n * statement causes the referenced event to be triggered, which in\n * turn awakens the waiting threads. Each NetEvTrig object references\n * exactly one event object.\n *\n * The NetEvNBTrig class represents non-blocking trigger statements.\n * Executing this statement causes the referenced event to be triggered\n * at some time in the future, which in turn awakens the waiting threads.\n * Each NetEvNBTrig object references exactly one event object.\n *\n * The NetEvProbe class is the structural equivalent of the NetEvTrig,\n * in that it is a node and watches bit values that it receives. It\n * checks for edges then if appropriate triggers the associated\n * NetEvent. Each NetEvProbe references exactly one event object, and\n * the NetEvent objects have a list of NetEvProbe objects that\n * reference it.\n */\nclass NetEvent : public LineInfo {\n\n      friend class NetScope;\n      friend class NetEvProbe;\n      friend class NetEvTrig;\n      friend class NetEvNBTrig;\n      friend class NetEvWait;\n      friend class NetEEvent;\n\n    public:\n\t// The name of the event is the basename, and should not\n\t// include the scope. Also, the name passed here should be\n\t// perm-allocated.\n      explicit NetEvent (perm_string n);\n      ~NetEvent();\n\n      perm_string name() const;\n\n      unsigned lexical_pos() const { return lexical_pos_; }\n      void lexical_pos(unsigned lp) { lexical_pos_ = lp; }\n\n      bool local_flag() const { return local_flag_; }\n      void local_flag(bool f) { local_flag_ = f; }\n\n\t// Get information about probes connected to me.\n      unsigned nprobe() const;\n      NetEvProbe* probe(unsigned);\n      const NetEvProbe* probe(unsigned) const;\n\n\t// Return the number of NetEvWait nodes that reference me.\n      unsigned nwait() const;\n      unsigned ntrig() const;\n      unsigned nexpr() const;\n\n      NetScope* scope();\n      const NetScope* scope() const;\n\n      void nex_output(NexusSet&);\n\n\t// Locate the first event that matches my behavior and\n\t// monitors the same signals.\n      void find_similar_event(std::list<NetEvent*>&);\n\n\t// This method replaces pointers to me with pointers to\n\t// that. It is typically used to replace similar events\n\t// located by the find_similar_event method.\n      void replace_event(NetEvent*that);\n\n    private:\n\t// This returns a nexus set if it represents possibly\n\t// asynchronous inputs, otherwise 0.\n      NexusSet*nex_async_();\n\n    private:\n      perm_string name_;\n      unsigned lexical_pos_;\n      bool local_flag_;\n\n\t// The NetScope class uses these to list the events.\n      NetScope*scope_;\n      NetEvent*snext_;\n\n\t// Use these methods to list the probes attached to me.\n      NetEvProbe*probes_;\n\n\t// Use these methods to list the triggers attached to me.\n      NetEvTrig* trig_;\n\n\t// Use these methods to list the non-blocking triggers attached to me.\n      NetEvNBTrig* nb_trig_;\n\n\t// Use This member to count references by NetEvWait objects.\n      unsigned waitref_;\n      struct wcell_ {\n\t    NetEvWait*obj;\n\t    struct wcell_*next;\n      };\n      struct wcell_ *wlist_;\n\n\t// expression references, ala. task/funcs\n      unsigned exprref_;\n\n    private: // not implemented\n      NetEvent(const NetEvent&);\n      NetEvent& operator= (const NetEvent&);\n};\n\nclass NetEvTrig  : public NetProc {\n\n      friend class NetEvent;\n\n    public:\n      explicit NetEvTrig(NetEvent*tgt);\n      ~NetEvTrig();\n\n      const NetEvent*event() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n      NetEvent*event_;\n\t// This is used to place me in the NetEvents lists of triggers.\n      NetEvTrig*enext_;\n};\n\nclass NetEvNBTrig  : public NetProc {\n\n      friend class NetEvent;\n\n    public:\n      explicit NetEvNBTrig(NetEvent*tgt, NetExpr*dly);\n      ~NetEvNBTrig();\n\n      const NetExpr*delay() const;\n      const NetEvent*event() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n      NetEvent*event_;\n      NetExpr*dly_;\n\t// This is used to place me in the NetEvents lists of triggers.\n      NetEvNBTrig*enext_;\n};\n\nclass NetEvWait  : public NetProc {\n\n    public:\n      explicit NetEvWait(NetProc*st);\n      ~NetEvWait();\n\n      void add_event(NetEvent*tgt);\n      void replace_event(NetEvent*orig, NetEvent*repl);\n      inline void set_t0_trigger() { has_t0_trigger_ = true; };\n\n      inline unsigned nevents() const { return events_.size(); }\n      inline const NetEvent*event(unsigned idx) const { return events_[idx]; }\n      inline NetEvent*event(unsigned idx) { return events_[idx]; }\n      inline bool has_t0_trigger() const { return has_t0_trigger_; };\n\n      NetProc*statement();\n      const NetProc*statement() const;\n\n      virtual bool emit_proc(struct target_t*) const;\n      bool emit_recurse(struct target_t*) const;\n      virtual int match_proc(struct proc_match_t*);\n\n\t// It is possible that this is the root of a combinational\n\t// process. This method checks.\n      virtual bool is_asynchronous();\n\n\t// It is possible that this is the root of a synchronous\n\t// process? This method checks.\n      virtual bool is_synchronous();\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&out);\n\n      virtual bool synth_async(Design*des, NetScope*scope,\n\t\t\t       NexusSet&nex_map, NetBus&nex_out,\n\t\t\t       NetBus&enables, std::vector<mask_t>&bitmasks);\n\n      virtual bool synth_sync(Design*des, NetScope*scope,\n\t\t\t      bool&ff_negedge,\n\t\t\t      NetNet*ff_clk, NetBus&ff_ce,\n\t\t\t      NetBus&ff_aclr,NetBus&ff_aset,\n\t\t\t      std::vector<verinum>&ff_aset_value,\n\t\t\t      NexusSet&nex_map, NetBus&nex_out,\n\t\t\t      std::vector<mask_t>&bitmasks,\n\t\t\t      const std::vector<NetEvProbe*>&events);\n\n      virtual void dump(std::ostream&, unsigned ind) const;\n\t// This will ignore any statement.\n      virtual void dump_inline(std::ostream&) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n      NetProc*statement_;\n\t// Events that I might wait for.\n      std::vector<NetEvent*>events_;\n      bool has_t0_trigger_;\n};\n\nstd::ostream& operator << (std::ostream&out, const NetEvWait&obj);\n\nclass NetEvProbe  : public NetNode {\n\n      friend class NetEvent;\n\n    public:\n      enum edge_t { ANYEDGE, POSEDGE, NEGEDGE, EDGE };\n\n      explicit NetEvProbe(NetScope*s, perm_string n,\n\t\t\t  NetEvent*tgt, edge_t t, unsigned p);\n      ~NetEvProbe();\n\n      edge_t edge() const;\n      NetEvent* event();\n      const NetEvent* event() const;\n\n      void find_similar_probes(std::list<NetEvProbe*>&);\n\n      virtual bool emit_node(struct target_t*) const;\n      virtual void dump_node(std::ostream&, unsigned ind) const;\n\n    private:\n      NetEvent*event_;\n      edge_t edge_;\n\t// The NetEvent class uses this to list me.\n      NetEvProbe*enext_;\n};\n\n/*\n * The force statement causes the r-val net to be forced onto the\n * l-val net when it is executed. The code generator is expected to\n * know what that means.\n */\nclass NetForce  : public NetAssignBase {\n\n    public:\n      explicit NetForce(NetAssign_*l, NetExpr*r);\n      ~NetForce();\n\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool emit_proc(struct target_t*) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n};\n\n/*\n * A forever statement is executed over and over again forever. Or\n * until its block is disabled.\n */\nclass NetForever : public NetProc {\n\n    public:\n      explicit NetForever(NetProc*s);\n      ~NetForever();\n\n      void emit_recurse(struct target_t*) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      NetProc*statement_;\n};\n\nclass NetForLoop : public NetProc {\n\n    public:\n      explicit NetForLoop(NetNet*index, NetExpr*initial_expr, NetExpr*cond,\n\t\t\t  NetProc*sub, NetProc*step);\n      ~NetForLoop();\n\n      void emit_recurse(struct target_t*) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n      bool emit_recurse_init(struct target_t*) const;\n      bool emit_recurse_stmt(struct target_t*) const;\n      bool emit_recurse_step(struct target_t*) const;\n      bool emit_recurse_condition(struct expr_scan_t*) const;\n\n\t// synthesize as asynchronous logic, and return true.\n      bool synth_async(Design*des, NetScope*scope,\n\t\t       NexusSet&nex_map, NetBus&nex_out,\n\t\t       NetBus&enables, std::vector<mask_t>&bitmasks);\n\n    private:\n      NetNet*index_;\n      NetExpr*init_expr_;\n      NetProc*init_statement_; // Generated form index_ and init_expr_.\n      NetExpr*condition_;\n      NetProc*statement_;\n      NetProc*step_statement_;\n};\n\nclass NetFree   : public NetProc {\n\n    public:\n      explicit NetFree(NetScope*);\n      ~NetFree();\n\n      const std::string name() const;\n\n      const NetScope* scope() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n\n    private:\n      NetScope*scope_;\n};\n\n/*\n * A function definition is elaborated just like a task, though by now\n * it is certain that the first parameter (a phantom parameter) is the\n * output and all the remaining parameters are the inputs. This makes\n * for easy code generation in targets that support behavioral\n * descriptions.\n *\n * The NetNet array that is passed in as a parameter is the set of\n * signals that make up its parameter list. These are all internal to\n * the scope of the function.\n */\nclass NetFuncDef : public NetBaseDef {\n\n    public:\n      NetFuncDef(NetScope*, NetNet*result, const std::vector<NetNet*>&po,\n\t\t const std::vector<NetExpr*>&pd);\n      ~NetFuncDef();\n\n\t// Return true if the function returns \"void\". We still treat\n\t// it as a function since we need to check that the contents\n\t// meet the requirements of a function, but we need to know\n\t// that it is void because it can be evaluated differently.\n      inline bool is_void() const { return result_sig_ == 0; }\n\n\t// Non-void functions have a return value as a signal.\n      const NetNet*return_sig() const;\n\n\t// When we want to evaluate the function during compile time,\n\t// use this method to pass in the argument and get out a\n\t// result. The result should be a constant. If the function\n\t// cannot evaluate to a constant, this returns nil.\n      NetExpr* evaluate_function(const LineInfo&loc, const std::vector<NetExpr*>&args) const;\n\n      void dump(std::ostream&, unsigned ind) const;\n\n    private:\n      NetNet*result_sig_;\n};\n\n/*\n * This class represents delay statements of the form:\n *\n *     #<expr> <statement>\n *\n * Where the statement may be null. The delay is evaluated at\n * elaboration time to make a constant unsigned long that is the delay\n * in simulation ticks.\n *\n * If the delay expression is non-constant, construct the NetPDelay\n * object with a NetExpr* instead of the d value, and use the expr()\n * method to get the expression. If expr() returns 0, use the delay()\n * method to get the constant delay.\n */\nclass NetPDelay  : public NetProc {\n\n    public:\n      NetPDelay(uint64_t d, NetProc*st);\n      NetPDelay(NetExpr* d, NetProc*st);\n      ~NetPDelay();\n\n      uint64_t delay() const;\n      const NetExpr*expr() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n      bool emit_proc_recurse(struct target_t*) const;\n\n    private:\n      uint64_t delay_;\n      NetExpr*expr_;\n      NetProc*statement_;\n};\n\n/*\n * A repeat statement is executed some fixed number of times.\n */\nclass NetRepeat : public NetProc {\n\n    public:\n      explicit NetRepeat(NetExpr*e, NetProc*s);\n      ~NetRepeat();\n\n      const NetExpr*expr() const;\n      void emit_recurse(struct target_t*) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      NetExpr*expr_;\n      NetProc*statement_;\n};\n\n/*\n * The procedural release statement (the opposite of force) releases\n * any force expressions attached to the bits of the wire or reg. The\n * lval is the expression of the \"release <expr>;\" statement with the\n * expr elaborated to a net.\n */\nclass NetRelease : public NetAssignBase {\n\n    public:\n      explicit NetRelease(NetAssign_*l);\n      ~NetRelease();\n\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n};\n\n\n/*\n * The NetSTask class is a call to a system task. These kinds of tasks\n * are generally handled very simply in the target. They certainly are\n * handled differently from user defined tasks because ivl knows all\n * about the user defined tasks.\n */\nclass NetSTask  : public NetProc {\n\n    public:\n      NetSTask(const char*na, ivl_sfunc_as_task_t sfat,\n               const std::vector<NetExpr*>&);\n      ~NetSTask();\n\n      const char* name() const;\n      ivl_sfunc_as_task_t sfunc_as_task() const;\n\n      unsigned nparms() const;\n\n      const NetExpr* parm(unsigned idx) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      const char* name_;\n      ivl_sfunc_as_task_t sfunc_as_task_;\n      std::vector<NetExpr*>parms_;\n};\n\n/*\n * This class represents an elaborated class definition. NetUTask\n * classes may refer to objects of this type to get the meaning of the\n * defined task.\n *\n * The task also introduces a scope, and the parameters are actually\n * reg objects in the new scope. The task is called by the calling\n * thread assigning (blocking assignment) to the in and inout\n * parameters, then invoking the thread, and finally assigning out the\n * output and inout variables. The variables accessible as ports are\n * also elaborated and accessible as ordinary reg objects.\n */\nclass NetTaskDef : public NetBaseDef {\n\n    public:\n      NetTaskDef(NetScope*n, const std::vector<NetNet*>&po,\n\t\t const std::vector<NetExpr*>&pd);\n      ~NetTaskDef();\n\n      void dump(std::ostream&, unsigned) const;\n      DelayType delay_type(bool print_delay=false) const;\n\n    private: // not implemented\n      NetTaskDef(const NetTaskDef&);\n      NetTaskDef& operator= (const NetTaskDef&);\n};\n\n/*\n * The NetELast expression node takes as an argument a net, that is\n * intended to be a queue or dynamic array object. The return value is\n * the index of the last item in the node. This is intended to\n * implement the '$' is the expression \"foo[$]\".\n */\nclass NetELast : public NetExpr {\n\n    public:\n      explicit NetELast(NetNet*sig);\n      ~NetELast();\n\n      inline const NetNet*sig() const { return sig_; }\n\n      virtual ivl_variable_type_t expr_type() const;\n      virtual void dump(std::ostream&) const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetELast*dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n    private:\n      NetNet*sig_;\n};\n\n/*\n * This node represents a function call in an expression. The object\n * contains a pointer to the function definition, which is used to\n * locate the value register and input expressions.\n */\nclass NetEUFunc  : public NetExpr {\n\n    public:\n      NetEUFunc(NetScope*, NetScope*, NetESignal*, std::vector<NetExpr*>&, bool);\n      ~NetEUFunc();\n\n      const NetESignal*result_sig() const;\n\n      unsigned parm_count() const;\n      const NetExpr* parm(unsigned idx) const;\n\n      const NetScope* func() const;\n\n      virtual void dump(std::ostream&) const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetEUFunc*dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual NetExpr* eval_tree();\n      virtual NetExpr*evaluate_function(const LineInfo&loc,\n\t\t\t\t\tstd::map<perm_string,LocalVar>&ctx) const;\n\n      virtual NetNet* synthesize(Design*des, NetScope*scope, NetExpr*root);\n\n    private:\n      NetScope*scope_;\n      NetScope*func_;\n      NetESignal*result_sig_;\n      std::vector<NetExpr*> parms_;\n      bool need_const_;\n\n    private: // not implemented\n      NetEUFunc(const NetEUFunc&);\n      NetEUFunc& operator= (const NetEUFunc&);\n};\n\n/*\n * A call to a nature access function for a branch.\n */\nclass NetEAccess : public NetExpr {\n\n    public:\n      explicit NetEAccess(NetBranch*br, ivl_nature_t nat);\n      ~NetEAccess();\n\n      ivl_nature_t get_nature() const { return nature_; }\n      NetBranch*   get_branch() const { return branch_; }\n\n      virtual ivl_variable_type_t expr_type() const;\n      virtual void dump(std::ostream&) const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetEAccess*dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n    private:\n      NetBranch*branch_;\n      ivl_nature_t nature_;\n};\n\n/*\n * A call to a user defined task is elaborated into this object. This\n * contains a pointer to the elaborated task definition, but is a\n * NetProc object so that it can be linked into statements.\n */\nclass NetUTask  : public NetProc {\n\n    public:\n      explicit NetUTask(NetScope*);\n      ~NetUTask();\n\n      const std::string name() const;\n\n      const NetScope* task() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n\n    private:\n      NetScope*task_;\n};\n\n/*\n * The while statement is a condition that is tested in the front of\n * each iteration, and a statement (a NetProc) that is executed as\n * long as the condition is true.\n */\nclass NetWhile  : public NetProc {\n\n    public:\n      NetWhile(NetExpr*c, NetProc*p)\n      : cond_(c), proc_(p) { }\n\n      const NetExpr*expr() const { return cond_; }\n\n      void emit_proc_recurse(struct target_t*) const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void nex_output(NexusSet&);\n      virtual bool emit_proc(struct target_t*) const;\n      virtual void dump(std::ostream&, unsigned ind) const;\n      virtual DelayType delay_type(bool print_delay=false) const;\n      virtual bool check_synth(ivl_process_type_t pr_type, const NetScope*scope) const;\n      virtual bool evaluate_function(const LineInfo&loc,\n\t\t\t\t     std::map<perm_string,LocalVar>&ctx) const;\n\n    private:\n      NetExpr*cond_;\n      NetProc*proc_;\n};\n\n\n/*\n * The is the top of any process. It carries the type (initial or\n * always) and a pointer to the statement, probably a block, that\n * makes up the process.\n */\nclass NetProcTop  : public LineInfo, public Attrib {\n\n    public:\n      NetProcTop(NetScope*s, ivl_process_type_t t, class NetProc*st);\n      ~NetProcTop();\n\n      ivl_process_type_t type() const { return type_; }\n      NetProc*statement();\n      const NetProc*statement() const;\n\n      NetScope*scope();\n      const NetScope*scope() const;\n\n\t/* Return true if this process represents combinational logic. */\n      bool is_asynchronous() const;\n\n\t/* Create asynchronous logic from this thread and return true,\n\t   or return false if that cannot be done. */\n      bool synth_async(Design*des);\n\n\t/* Return true if this process represents synchronous logic. */\n      bool is_synchronous();\n\n\t/* Create synchronous logic from this thread and return true,\n\t   or return false if that cannot be done. */\n      bool synth_sync(Design*des);\n\n      void dump(std::ostream&, unsigned ind) const;\n      bool emit(struct target_t*tgt) const;\n\n    private:\n      bool tie_off_floating_inputs_(Design*des,\n\t\t\t\t    NexusSet&nex_map, NetBus&nex_in,\n\t\t\t\t    const std::vector<NetProc::mask_t>&bitmasks,\n\t\t\t\t    bool is_ff_input);\n\n      const ivl_process_type_t type_;\n      NetProc*const statement_;\n      Design*synthesized_design_;\n\n      NetScope*scope_;\n      friend class Design;\n      NetProcTop*next_;\n};\n\nclass NetAnalogTop  : public LineInfo, public Attrib {\n\n    public:\n      NetAnalogTop(NetScope*scope, ivl_process_type_t t, NetProc*st);\n      ~NetAnalogTop();\n\n      ivl_process_type_t type() const { return type_; }\n\n      NetProc*statement();\n      const NetProc*statement() const;\n\n      NetScope*scope();\n      const NetScope*scope() const;\n\n      void dump(std::ostream&, unsigned ind) const;\n      bool emit(struct target_t*tgt) const;\n\n    private:\n      const ivl_process_type_t type_;\n      NetProc* statement_;\n\n      NetScope*scope_;\n      friend class Design;\n      NetAnalogTop*next_;\n};\n\n/*\n * This class represents a binary operator, with the left and right\n * operands and a single character for the operator. The operator\n * values are:\n *\n *   ^  -- Bit-wise exclusive OR\n *   +  -- Arithmetic add\n *   -  -- Arithmetic minus\n *   *  -- Arithmetic multiply\n *   /  -- Arithmetic divide\n *   %  -- Arithmetic modulus\n *   p  -- Arithmetic power (**)\n *   &  -- Bit-wise AND\n *   |  -- Bit-wise OR\n *   <  -- Less than\n *   >  -- Greater than\n *   e  -- Logical equality (==)\n *   E  -- Case equality (===)\n *   L  -- Less or equal\n *   G  -- Greater or equal\n *   n  -- Logical inequality (!=)\n *   N  -- Case inequality (!==)\n *   a  -- Logical AND (&&)\n *   A  -- Bitwise NAND (~&)\n *   o  -- Logical OR (||)\n *   O  -- Bit-wise NOR (~|)\n *   l  -- Left shift (<<)\n *   r  -- Right shift (>>)\n *   R  -- signed right shift (>>>)\n *   X  -- Bitwise exclusive NOR (~^)\n *   m  -- min(a,b)\n *   M  -- max(a,b)\n */\nclass NetEBinary  : public NetExpr {\n\n    public:\n      NetEBinary(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBinary();\n\n      const NetExpr*left() const { return left_; }\n      const NetExpr*right() const { return right_; }\n\n      char op() const { return op_; }\n\n\t// A binary expression node only has a definite\n\t// self-determinable width if the operands both have definite\n\t// widths.\n      virtual bool has_width() const;\n\n      virtual NetEBinary* dup_expr() const;\n      virtual NetExpr* eval_tree();\n      virtual NetExpr* evaluate_function(const LineInfo&loc,\n\t\t\t\t\t std::map<perm_string,LocalVar>&ctx) const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n    protected:\n      char op_;\n      NetExpr* left_;\n      NetExpr* right_;\n\n      virtual NetExpr* eval_arguments_(const NetExpr*l, const NetExpr*r) const;\n};\n\n/*\n * The addition operators have slightly more complex width\n * calculations because there is the optional carry bit that can be\n * used. The operators covered by this class are:\n *   +  -- Arithmetic add\n *   -  -- Arithmetic minus\n */\nclass NetEBAdd : public NetEBinary {\n\n    public:\n      NetEBAdd(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBAdd();\n\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual NetEBAdd* dup_expr() const;\n      virtual NetExpr* eval_tree();\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n\n    private:\n      virtual NetExpr* eval_arguments_(const NetExpr*l, const NetExpr*r) const;\n      NetECReal* eval_tree_real_(const NetExpr*l, const NetExpr*r) const;\n};\n\n/*\n * This class represents the integer division operators.\n *   /  -- Divide\n *   %  -- Modulus\n */\nclass NetEBDiv : public NetEBinary {\n\n    public:\n      NetEBDiv(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBDiv();\n\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual NetEBDiv* dup_expr() const;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n\n    private:\n      virtual NetExpr* eval_arguments_(const NetExpr*l, const NetExpr*r) const;\n      NetExpr* eval_tree_real_(const NetExpr*l, const NetExpr*r) const;\n};\n\n/*\n * The bitwise binary operators are represented by this class. This is\n * a specialization of the binary operator, so is derived from\n * NetEBinary. The particular constraints on these operators are that\n * operand and result widths match exactly, and each bit slice of the\n * operation can be represented by a simple gate. The operators\n * covered by this class are:\n *\n *   ^  -- Bit-wise exclusive OR\n *   &  -- Bit-wise AND\n *   |  -- Bit-wise OR\n *   O  -- Bit-wise NOR\n *   X  -- Bit-wise XNOR (~^)\n */\nclass NetEBBits : public NetEBinary {\n\n    public:\n      NetEBBits(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBBits();\n\n      virtual NetEBBits* dup_expr() const override;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root) override;\n\n      ivl_variable_type_t expr_type() const override;\n\n    private:\n      virtual NetEConst* eval_arguments_(const NetExpr*l, const NetExpr*r) const override;\n};\n\n/*\n * The binary comparison operators are handled by this class. This\n * this case the bit width of the expression is 1 bit, and the\n * operands take their natural widths. The supported operators are:\n *\n *   <  -- Less than\n *   >  -- Greater than\n *   e  -- Logical equality (==)\n *   E  -- Case equality (===)\n *   L  -- Less or equal (<=)\n *   G  -- Greater or equal (>=)\n *   n  -- Logical inequality (!=)\n *   N  -- Case inequality (!==)\n */\nclass NetEBComp : public NetEBinary {\n\n    public:\n      NetEBComp(char op, NetExpr*l, NetExpr*r);\n      ~NetEBComp();\n\n\t/* A compare expression has a definite width. */\n      virtual bool has_width() const;\n      virtual ivl_variable_type_t expr_type() const;\n      virtual NetEBComp* dup_expr() const;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n\n    private:\n      NetEConst* must_be_leeq_(const NetExpr*le, const verinum&rv, bool eq_flag) const;\n\n      virtual NetEConst*eval_arguments_(const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_eqeq_(bool ne_flag, const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_eqeq_real_(bool ne_flag, const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_less_(const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_leeq_(const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_leeq_real_(const NetExpr*le, const NetExpr*ri, bool eq_flag) const;\n      NetEConst*eval_gt_(const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_gteq_(const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_eqeqeq_(bool ne_flag, const NetExpr*le, const NetExpr*re) const;\n      NetEConst*eval_weqeq_(bool ne_flag, const NetExpr*le, const NetExpr*re) const;\n};\n\n/*\n * The binary logical operators are those that return boolean\n * results. The supported operators are:\n *\n *   a  -- Logical AND (&&)\n *   o  -- Logical OR (||)\n */\nclass NetEBLogic : public NetEBinary {\n\n    public:\n      NetEBLogic(char op, NetExpr*l, NetExpr*r);\n      ~NetEBLogic();\n\n      virtual NetEBLogic* dup_expr() const override;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root) override;\n\n      ivl_variable_type_t expr_type() const override;\n\n    private:\n      virtual NetEConst* eval_arguments_(const NetExpr*l, const NetExpr*r) const override;\n};\n\n/*\n * Support the binary min(l,r) and max(l,r) operators. The opcodes\n * supported are:\n *\n *   m -- min\n *   M -- max\n */\nclass NetEBMinMax : public NetEBinary {\n\n    public:\n      NetEBMinMax(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBMinMax();\n\n      virtual ivl_variable_type_t expr_type() const;\n\n    private:\n      virtual NetExpr* eval_arguments_(const NetExpr*l, const NetExpr*r) const;\n      NetExpr* eval_tree_real_(const NetExpr*l, const NetExpr*r) const;\n};\n\n/*\n * Support the binary multiplication (*) operator.\n */\nclass NetEBMult : public NetEBinary {\n\n    public:\n      NetEBMult(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBMult();\n\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual NetEBMult* dup_expr() const;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n\n    private:\n      virtual NetExpr* eval_arguments_(const NetExpr*l, const NetExpr*r) const;\n      NetExpr* eval_tree_real_(const NetExpr*l, const NetExpr*r) const;\n};\n\n/*\n * Support the binary power (**) operator.\n */\nclass NetEBPow : public NetEBinary {\n\n    public:\n      NetEBPow(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBPow();\n\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual NetEBPow* dup_expr() const;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n\n    private:\n      virtual NetExpr* eval_arguments_(const NetExpr*l, const NetExpr*r) const;\n      NetExpr* eval_tree_real_(const NetExpr*l, const NetExpr*r) const;\n};\n\n\n/*\n * Support the binary shift operators. The supported operators are:\n *\n *   l  -- left shift (<<)\n *   r  -- right shift (>>)\n *   R  -- right shift arithmetic (>>>)\n */\nclass NetEBShift : public NetEBinary {\n\n    public:\n      NetEBShift(char op, NetExpr*l, NetExpr*r, unsigned wid, bool signed_flag);\n      ~NetEBShift();\n\n\t// A shift expression only needs the left expression to have a\n\t// definite width to give the expression a definite width.\n      virtual bool has_width() const override;\n\n      virtual NetEBShift* dup_expr() const override;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root) override;\n\n      ivl_variable_type_t expr_type() const override;\n\n    private:\n      virtual NetEConst* eval_arguments_(const NetExpr*l, const NetExpr*r) const override;\n};\n\n\n/*\n * This expression node supports the concat expression. This is an\n * operator that just glues the results of many expressions into a\n * single value.\n *\n * Note that the class stores the parameter expressions in source code\n * order. That is, the parm(0) is placed in the most significant\n * position of the result.\n */\nclass NetEConcat  : public NetExpr {\n\n    public:\n      NetEConcat(unsigned cnt, unsigned repeat, ivl_variable_type_t vt);\n      ~NetEConcat();\n\n\t// Manipulate the parameters.\n      void set(unsigned idx, NetExpr*e);\n\n      unsigned repeat() const { return repeat_; }\n      unsigned nparms() const { return parms_.size() ; }\n      NetExpr* parm(unsigned idx) const { return parms_[idx]; }\n\n      virtual ivl_variable_type_t expr_type() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual NetEConcat* dup_expr() const;\n      virtual NetEConst*  eval_tree();\n      virtual NetExpr* evaluate_function(const LineInfo&loc,\n\t\t\t\t\t std::map<perm_string,LocalVar>&ctx) const;\n      virtual NetNet*synthesize(Design*, NetScope*scope, NetExpr*root);\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n    private:\n      std::vector<NetExpr*>parms_;\n      unsigned repeat_;\n      ivl_variable_type_t expr_type_;\n\n      NetEConst* eval_arguments_(const std::vector<NetExpr*>&vals, unsigned gap) const;\n};\n\n\n/*\n * This expression node supports bit/part selects from general\n * expressions. The sub-expression is self-sized, and has bits\n * selected from it. The base is the expression that identifies the\n * lsb of the expression, and the wid is the width of the part select,\n * or 1 for a bit select. No matter what the subexpression is, the\n * base is translated in canonical bits. It is up to the elaborator\n * to figure this out and adjust the expression if the subexpression\n * has a non-canonical base or direction.\n *\n * If the base expression is null, then this expression node can be\n * used to express width expansion, signed or unsigned depending on\n * the has_sign() flag.\n *\n * An alternative form of this expression node is used for dynamic\n * array word selects and for packed struct member selects. In this\n * case use_type indicates the type of the selected element/member.\n */\nclass NetESelect  : public NetExpr {\n\n    public:\n      NetESelect(NetExpr*exp, NetExpr*base, unsigned wid,\n                 ivl_select_type_t sel_type = IVL_SEL_OTHER);\n      NetESelect(NetExpr*exp, NetExpr*base, unsigned wid,\n                 ivl_type_t use_type);\n      ~NetESelect();\n\n      const NetExpr*sub_expr() const;\n      const NetExpr*select() const;\n      ivl_select_type_t select_type() const;\n\n\t// The type of a bit/part select is the base type of the\n\t// sub-expression. The type of an array/member select is\n\t// the base type of the element/member.\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetEConst* eval_tree();\n      virtual NetExpr*evaluate_function(const LineInfo&loc,\n\t\t\t\t\tstd::map<perm_string,LocalVar>&ctx) const;\n      virtual NetESelect* dup_expr() const;\n      virtual NetNet*synthesize(Design*des, NetScope*scope, NetExpr*root);\n      virtual void dump(std::ostream&) const;\n\n    private:\n      NetExpr*expr_;\n      NetExpr*base_;\n      ivl_select_type_t sel_type_;\n};\n\n/*\n * This node is for representation of named events.\n */\nclass NetEEvent : public NetExpr {\n\n    public:\n      explicit NetEEvent(NetEvent*);\n      ~NetEEvent();\n\n      const NetEvent* event() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetEEvent* dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void dump(std::ostream&os) const;\n\n    private:\n      NetEvent*event_;\n};\n\n/*\n * This class is a special (and magical) expression node type that\n * represents enumeration types. These can only be found as parameters\n * to NetSTask objects.\n */\nclass NetENetenum  : public NetExpr {\n\n    public:\n      explicit NetENetenum(const netenum_t*);\n      ~NetENetenum();\n\n      const netenum_t* netenum() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetENetenum* dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void dump(std::ostream&os) const;\n\n    private:\n      const netenum_t*netenum_;\n};\n\nclass NetENew : public NetExpr {\n    public:\n\t// Make class object\n      explicit NetENew(ivl_type_t);\n\t// dynamic array of objects.\n      explicit NetENew(ivl_type_t, NetExpr*size, NetExpr* init_val=0);\n      ~NetENew();\n\n      inline const NetExpr*size_expr() const { return size_; }\n      inline const NetExpr*init_expr() const { return init_val_; }\n\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetENew* dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void dump(std::ostream&os) const;\n\n    private:\n      NetExpr*size_;\n      NetExpr*init_val_;\n};\n\n/*\n * The NetENull node represents the SystemVerilog (null)\n * expression. This is always a null class handle.\n */\nclass NetENull : public NetExpr {\n\n    public:\n      NetENull();\n      ~NetENull();\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetENull* dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void dump(std::ostream&os) const;\n};\n\n/*\n * The NetEProperty represents a SystemVerilog property select of a\n * class object. In SV, the expression would look like \"a.b\", where\n * the \"a\" is the signal (the NetNet) and \"b\" is the property name.\n *\n * The canon_index is an optional expression to address an element for\n * parameters that are arrays.\n */\nclass NetEProperty : public NetExpr {\n    public:\n      NetEProperty(NetNet*n, size_t pidx_, NetExpr*canon_index =0);\n      ~NetEProperty();\n\n      inline const NetNet* get_sig() const { return net_; }\n      inline size_t property_idx() const { return pidx_; }\n      inline const NetExpr*get_index() const { return index_; }\n\n    public: // Overridden methods\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetEProperty* dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void dump(std::ostream&os) const;\n\n    private:\n      NetNet*net_;\n      size_t pidx_;\n      NetExpr*index_;\n};\n\n/*\n * This class is a special (and magical) expression node type that\n * represents scope names. These can only be found as parameters to\n * NetSTask objects.\n */\nclass NetEScope  : public NetExpr {\n\n    public:\n      explicit NetEScope(NetScope*);\n      ~NetEScope();\n\n      const NetScope* scope() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetEScope* dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void dump(std::ostream&os) const;\n\n    private:\n      NetScope*scope_;\n};\n\n/*\n * This node represents a system function call in an expression. The\n * object contains the name of the system function, which the backend\n * uses to do VPI matching.\n */\nclass NetESFunc  : public NetExpr {\n\n    public:\n      NetESFunc(const char*name, ivl_variable_type_t t,\n\t\tunsigned width, unsigned nprms, bool is_overridden =false);\n      NetESFunc(const char*name, ivl_type_t rtype, unsigned nprms);\n      ~NetESFunc();\n\n      const char* name() const;\n\n      unsigned nparms() const;\n      void parm(unsigned idx, NetExpr*expr);\n      NetExpr* parm(unsigned idx);\n      const NetExpr* parm(unsigned idx) const;\n\n      virtual NetExpr* eval_tree();\n      virtual NetExpr* evaluate_function(const LineInfo&loc,\n\t\t\t\t\t std::map<perm_string,LocalVar>&ctx) const;\n\n      virtual ivl_variable_type_t expr_type() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void dump(std::ostream&) const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetESFunc*dup_expr() const;\n      virtual NetNet*synthesize(Design*, NetScope*scope, NetExpr*root);\n\n    private:\n\t/* Use the 32 bit ID as follows:\n\t *   The lower sixteen bits are used to identify the individual\n\t *   functions.\n\t *\n\t *   The top sixteen bits are used to indicate the number of\n\t *   arguments the function can take by bit position. If more\n\t *   than one bit is set the argument can take a different number\n\t *   of arguments. This varies from 0 to 14 with the MSB indicating\n\t *   fifteen or more (an unbounded value). For example all bit set\n\t *   except for the LSB indicate 1 or more arguments are allowed.\n\t */\n      enum ID { NOT_BUILT_IN = 0x0,\n                  /* Available in all version of Verilog/SystemVerilog. */\n                ITOR   = 0x00020001,  /* $itor takes one argument. */\n                RTOI   = 0x00020002,  /* $rtoi takes one argument. */\n                  /* Available in Verilog 2005 and later. */\n                ACOS   = 0x00020003,  /* $acos takes one argument. */\n                ACOSH  = 0x00020004,  /* $acosh takes one argument. */\n                ASIN   = 0x00020005,  /* $asin takes one argument. */\n                ASINH  = 0x00020006,  /* $asinh takes one argument. */\n                ATAN   = 0x00020007,  /* $atan takes one argument. */\n                ATANH  = 0x00020008,  /* $atanh takes one argument. */\n                ATAN2  = 0x00040009,  /* $atan2 takes two argument. */\n                CEIL   = 0x0002000a,  /* $ceil takes one argument. */\n                CLOG2  = 0x0002000b,  /* $clog2 takes one argument. */\n                COS    = 0x0002000c,  /* $cos takes one argument. */\n                COSH   = 0x0002000d,  /* $cosh takes one argument. */\n                EXP    = 0x0002000e,  /* $exp takes one argument. */\n                FLOOR  = 0x0002000f,  /* $floor takes one argument. */\n                HYPOT  = 0x00040010,  /* $hypot takes two argument. */\n                LN     = 0x00020011,  /* $ln takes one argument. */\n                LOG10  = 0x00020012,  /* $log10 takes one argument. */\n                POW    = 0x00040013,  /* $pow takes two argument. */\n                SIN    = 0x00020014,  /* $sin takes one argument. */\n                SINH   = 0x00020015,  /* $sinh takes one argument. */\n                SQRT   = 0x00020016,  /* $sqrt takes one argument. */\n                TAN    = 0x00020017,  /* $tan takes one argument. */\n                TANH   = 0x00020018,  /* $tanh takes one argument. */\n                  /* Added in SystemVerilog 2005 and later. */\n                DIMS   = 0x00020019,  /* $dimensions takes one argument. */\n                HIGH   = 0x0006001a,  /* $high takes one or two arguments. */\n                INCR   = 0x0006001b,  /* $increment takes one or two arguments. */\n                LEFT   = 0x0006001c,  /* $left takes one or two arguments. */\n                LOW    = 0x0006001d,  /* $low takes one or two arguments. */\n                RIGHT  = 0x0006001e,  /* $right takes one or two arguments. */\n                SIZE   = 0x0006001f,  /* $size takes one or two arguments. */\n                UPDIMS = 0x00020020,  /* $unpacked_dimensions takes one argument. */\n                ISUNKN = 0x00020021,  /* $isunknown takes one argument. */\n                ONEHT  = 0x00020022,  /* $onehot takes one argument. */\n                ONEHT0 = 0x00020023,  /* $onehot0 takes one argument. */\n                  /* Added in SystemVerilog 2009 and later. */\n                CTONES = 0x00020024,  /* $countones takes one argument. */\n                  /* Added in SystemVerilog 2012 and later. */\n                CTBITS = 0xfffc0025,  /* $countbits takes two or more arguments. */\n                  /* Added as Icarus extensions to Verilog-A. */\n                ABS    = 0x00020026,  /* $abs takes one argument. */\n                MAX    = 0x00040027,  /* $max takes two argument. */\n                MIN    = 0x00040028,  /* $min takes two argument. */\n                  /* A dummy value to properly close the enum. */\n\t\tDUMMY  = 0xffffffff };\n\n      bool takes_nargs_(ID func, unsigned nargs) {\n\t    if (nargs > 15) nargs = 15;\n\t    return func & (1U << (nargs + 16));\n      }\n\n      const char* name_;\n      ivl_variable_type_t type_;\n      std::vector<NetExpr*>parms_;\n      bool is_overridden_;\n\n      ID built_in_id_() const;\n\n      NetExpr* evaluate_one_arg_(ID id, const NetExpr*arg) const;\n      NetExpr* evaluate_two_arg_(ID id, const NetExpr*arg0,\n\t\t\t\t\tconst NetExpr*arg1) const;\n\n      NetEConst* evaluate_rtoi_(const NetExpr*arg) const;\n      NetECReal* evaluate_itor_(const NetExpr*arg) const;\n\n      NetEConst* evaluate_clog2_(const NetExpr*arg) const;\n\n      NetECReal* evaluate_math_one_arg_(ID id, const NetExpr*arg) const;\n      NetECReal* evaluate_math_two_arg_(ID id, const NetExpr*arg0,\n\t\t\t\t\t       const NetExpr*arg1) const;\n\n      NetExpr* evaluate_abs_(const NetExpr*arg) const;\n      NetExpr* evaluate_min_max_(ID id, const NetExpr*arg0,\n\t\t\t\t\tconst NetExpr*arg1) const;\n\n\t/* Constant SystemVerilog functions. */\n      NetEConst* evaluate_countones_(const NetExpr*arg) const;\n      NetEConst* evaluate_dimensions_(const NetExpr*arg) const;\n      NetEConst* evaluate_isunknown_(const NetExpr*arg) const;\n      NetEConst* evaluate_onehot_(const NetExpr*arg) const;\n      NetEConst* evaluate_onehot0_(const NetExpr*arg) const;\n      NetEConst* evaluate_unpacked_dimensions_(const NetExpr*arg) const;\n\n\t/* This value is used as a default when the array functions are\n\t * called with a single argument. */\n      static const NetEConst*const_one_;\n\n      NetEConst* evaluate_array_funcs_(ID id,\n                                       const NetExpr*arg0,\n                                       const NetExpr*arg1) const;\n      NetEConst* evaluate_countbits_(void) const;\n\n    public:\n      bool is_built_in() const { return built_in_id_() != NOT_BUILT_IN; };\n\n    private: // not implemented\n      NetESFunc(const NetESFunc&);\n      NetESFunc& operator= (const NetESFunc&);\n};\n\nclass NetEShallowCopy : public NetExpr {\n    public:\n\t// Make a shallow copy from arg2 into arg1.\n      explicit NetEShallowCopy(NetExpr*arg1, NetExpr*arg2);\n      ~NetEShallowCopy();\n\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual NetEShallowCopy* dup_expr() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n\n      virtual void dump(std::ostream&os) const;\n\n      void expr_scan_oper1(struct expr_scan_t*) const;\n      void expr_scan_oper2(struct expr_scan_t*) const;\n\n    private:\n      NetExpr*arg1_;\n      NetExpr*arg2_;\n};\n\n/*\n * This class represents the ternary (?:) operator. It has 3\n * expressions, one of which is a condition used to select which of\n * the other two expressions is the result.\n */\nclass NetETernary  : public NetExpr {\n\n    public:\n      NetETernary(NetExpr*c, NetExpr*t, NetExpr*f, unsigned wid, bool signed_flag);\n      ~NetETernary();\n\n      const netenum_t* enumeration() const;\n\n      const NetExpr*cond_expr() const;\n      const NetExpr*true_expr() const;\n      const NetExpr*false_expr() const;\n\n      virtual NetETernary* dup_expr() const;\n      virtual NetExpr* eval_tree();\n      virtual NetExpr*evaluate_function(const LineInfo&loc,\n\t\t\t\t\tstd::map<perm_string,LocalVar>&ctx) const;\n      virtual ivl_variable_type_t expr_type() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n      virtual NetNet*synthesize(Design*, NetScope*scope, NetExpr*root);\n\n    public:\n      static bool test_operand_compat(ivl_variable_type_t tru, ivl_variable_type_t fal);\n\n    private:\n      NetExpr* blended_arguments_(const NetExpr*t, const NetExpr*f) const;\n\n      NetExpr*cond_;\n      NetExpr*true_val_;\n      NetExpr*false_val_;\n};\n\n/*\n * This class represents a unary operator, with the single operand\n * and a single character for the operator. The operator values are:\n *\n *   ~  -- Bit-wise negation\n *   !  -- Logical negation\n *   &  -- Reduction AND\n *   |  -- Reduction OR\n *   ^  -- Reduction XOR\n *   +  --\n *   -  --\n *   A  -- Reduction NAND (~&)\n *   N  -- Reduction NOR (~|)\n *   X  -- Reduction NXOR (~^ or ^~)\n *   m  -- abs(x)  (i.e. \"magnitude\")\n *   v  -- Cast from real to integer (vector)\n *   2  -- Cast from real or logic (vector) to bool (vector)\n *   r  -- Cast from integer (vector) to real\n *   i  -- post-increment\n *   I  -- pre-increment\n *   d  -- post-decrement\n *   D  -- pre-decrement\n */\nclass NetEUnary  : public NetExpr {\n\n    public:\n      NetEUnary(char op, NetExpr*ex, unsigned wid, bool signed_flag);\n      ~NetEUnary();\n\n      char op() const { return op_; }\n      const NetExpr* expr() const { return expr_; }\n\n      virtual NetEUnary* dup_expr() const;\n      virtual NetExpr* eval_tree();\n      virtual NetExpr* evaluate_function(const LineInfo&loc,\n\t\t\t\t\t std::map<perm_string,LocalVar>&ctx) const;\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n\n      virtual ivl_variable_type_t expr_type() const;\n      virtual NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                                  bool nested_func = false) const;\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n    protected:\n      char op_;\n      NetExpr* expr_;\n\n    private:\n      virtual NetExpr* eval_arguments_(const NetExpr*ex) const;\n      virtual NetExpr* eval_tree_real_(const NetExpr*ex) const;\n};\n\nclass NetEUBits : public NetEUnary {\n\n    public:\n      NetEUBits(char op, NetExpr*ex, unsigned wid, bool signed_flag);\n      ~NetEUBits();\n\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n\n      virtual NetEUBits* dup_expr() const;\n      virtual ivl_variable_type_t expr_type() const;\n};\n\nclass NetEUReduce : public NetEUnary {\n\n    public:\n      NetEUReduce(char op, NetExpr*ex);\n      ~NetEUReduce();\n\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n      virtual NetEUReduce* dup_expr() const;\n      virtual ivl_variable_type_t expr_type() const;\n\n    private:\n      virtual NetEConst* eval_arguments_(const NetExpr*ex) const;\n      virtual NetEConst* eval_tree_real_(const NetExpr*ex) const;\n};\n\nclass NetECast : public NetEUnary {\n\n    public:\n      NetECast(char op, NetExpr*ex, unsigned wid, bool signed_flag);\n      ~NetECast();\n\n      virtual NetNet* synthesize(Design*, NetScope*scope, NetExpr*root);\n      virtual NetECast* dup_expr() const;\n      virtual ivl_variable_type_t expr_type() const;\n      virtual void dump(std::ostream&) const;\n\n    private:\n      virtual NetExpr* eval_arguments_(const NetExpr*ex) const;\n};\n\n/*\n * When a signal shows up in an expression, this type represents\n * it. From this the expression can get any kind of access to the\n * structural signal, including arrays.\n *\n * The NetESignal may refer to an array, if the word_index is\n * included. This expression calculates the index of the word in the\n * array. It may only be nil if the expression refers to the whole\n * array, and that is legal only in limited situation.\n */\nclass NetESignal  : public NetExpr {\n\n    public:\n      explicit NetESignal(NetNet*n);\n      NetESignal(NetNet*n, NetExpr*word_index);\n      ~NetESignal();\n\n      perm_string name() const;\n\n      virtual NetESignal* dup_expr() const;\n      NetNet* synthesize(Design*des, NetScope*scope, NetExpr*root);\n      NexusSet* nex_input(bool rem_out = true, bool always_sens = false,\n                          bool nested_func = false) const;\n      NexusSet* nex_input_base(bool rem_out, bool always_sens, bool nested_func,\n                               unsigned base, unsigned width) const;\n\n      virtual NetExpr*evaluate_function(const LineInfo&loc,\n\t\t\t\t\tstd::map<perm_string,LocalVar>&ctx) const;\n\n\t// This is the expression for selecting an array word, if this\n\t// signal refers to an array.\n      const NetExpr* word_index() const;\n\n\t// This is the width of the vector that this signal refers to.\n      unsigned vector_width() const;\n\t// Point back to the signal that this expression node references.\n      const NetNet* sig() const;\n      NetNet* sig();\n\t// Declared vector dimensions for the signal.\n      long msi() const;\n      long lsi() const;\n\n      virtual ivl_variable_type_t expr_type() const;\n\n      virtual void expr_scan(struct expr_scan_t*) const;\n      virtual void dump(std::ostream&) const;\n\n    private:\n      NetNet*net_;\n\t// Expression to select a word from the net.\n      NetExpr*word_;\n};\n\n/*\n * The Design object keeps a list of work items for processing\n * elaboration. This is the type of those work items.\n */\nstruct elaborator_work_item_t {\n      explicit elaborator_work_item_t(Design*d)\n      : des(d) { }\n      virtual ~elaborator_work_item_t() { }\n      virtual void elaborate_runrun() =0;\n    protected:\n      Design*des;\n};\n\n/*\n * This class contains an entire design. It includes processes and a\n * netlist, and can be passed around from function to function.\n */\nclass Design {\n\n    public:\n      Design();\n      ~Design();\n\n\t/* We need to pass the tool delay selection for $sdf_annotate. */\n      enum delay_sel_t { MIN, TYP, MAX };\n      void set_delay_sel(delay_sel_t sel);\n      const char* get_delay_sel() const;\n\n\t/* The flags are a generic way of accepting command line\n\t   parameters/flags and passing them to the processing steps\n\t   that deal with the design. The compilation driver sets the\n\t   entire flags map after elaboration is done. Subsequent\n\t   steps can then use the get_flag() function to get the value\n\t   of an interesting key. */\n\n      void set_flags(const std::map<std::string,const char*>&f) { flags_ = f; }\n\n      const char* get_flag(const std::string&key) const;\n\n      NetScope* make_root_scope(perm_string name, NetScope*unit_scope,\n\t\t\t\tbool program_block, bool is_interface);\n      NetScope* find_root_scope();\n      std::list<NetScope*> find_root_scopes() const;\n\n      NetScope* make_package_scope(perm_string name, NetScope*unit_scope,\n\t\t\t\t   bool is_unit);\n      std::list<NetScope*> find_package_scopes() const;\n\n\t/* Attempt to set the precision to the specified value. If the\n\t   precision is already more precise, the keep the precise\n\t   setting. This is intended to hold the simulation precision\n\t   for use throughout the entire design. */\n\n      void set_precision(int val);\n      int  get_precision() const;\n\n\t/* This function takes a delay value and a scope, and returns\n\t   the delay value scaled to the precision of the design. */\n      uint64_t scale_to_precision(uint64_t, const NetScope*)const;\n\n\t/* Look up a scope. If no starting scope is passed, then the\n\t   path is taken as an absolute scope name. Otherwise, the\n\t   scope is located starting at the passed scope and working\n\t   up if needed. */\n      NetScope* find_scope(const hname_t&path) const;\n      NetScope* find_scope(NetScope*, const hname_t&name,\n                           NetScope::TYPE type = NetScope::MODULE) const;\n\n      NetScope* find_package(perm_string name) const;\n\n\t// Note: Try to remove these versions of find_scope. Avoid\n\t// using these in new code, use the above forms (or\n\t// symbol_search) instead.\n      NetScope* find_scope(const std::list<hname_t>&path) const;\n      NetScope* find_scope(NetScope*, const std::list<hname_t>&path,\n                           NetScope::TYPE type = NetScope::MODULE) const;\n\n\t/* These members help manage elaboration of scopes. When we\n\t   get to a point in scope elaboration where we want to put\n\t   off a scope elaboration, an object of scope_elaboration_t\n\t   is pushed onto the scope_elaborations list. The scope\n\t   elaborator will go through this list elaborating scopes\n\t   until the list is empty. */\n      std::list<elaborator_work_item_t*>elaboration_work_list;\n      void run_elaboration_work(void);\n\n      std::set<NetScope*> defparams_later;\n\n\t// PARAMETERS\n\n      void run_defparams();\n      void evaluate_parameters();\n\t// Look for defparams that never matched, and print warnings.\n      void residual_defparams();\n\n\t/* This method locates a signal, starting at a given\n\t   scope. The name parameter may be partially hierarchical, so\n\t   this method, unlike the NetScope::find_signal method,\n\t   handles global name binding. */\n\n      NetNet*find_signal(NetScope*scope, pform_name_t path);\n\n\t// Functions\n      NetFuncDef* find_function(NetScope*scope, const pform_name_t&key);\n\n\t// Tasks\n      NetScope* find_task(NetScope*scope, const pform_name_t&name);\n\n\t// NODES\n      void add_node(NetNode*);\n      void del_node(NetNode*);\n\n\t// BRANCHES\n      void add_branch(NetBranch*);\n\n\t// PROCESSES\n      void add_process(NetProcTop*);\n      void add_process(NetAnalogTop*);\n      void delete_process(NetProcTop*);\n      bool check_proc_delay() const;\n      bool check_proc_synth() const;\n\n      NetNet* find_discipline_reference(ivl_discipline_t dis, NetScope*scope);\n\n\t// Iterate over the design...\n      void dump(std::ostream&) const;\n      void functor(struct functor_t*);\n      void join_islands(void);\n      int emit(struct target_t*) const;\n\n\t// This is incremented by elaboration when an error is\n\t// detected. It prevents code being emitted.\n      unsigned errors;\n\n      void fork_enter() { in_fork++; };\n      void fork_exit() { in_fork--; };\n      bool is_in_fork() { return in_fork != 0; }\n\n      unsigned int in_fork = 0;\n\n    private:\n      NetScope* find_scope_(NetScope*, const hname_t&name,\n                            NetScope::TYPE type = NetScope::MODULE) const;\n\n      NetScope* find_scope_(NetScope*, const std::list<hname_t>&path,\n                            NetScope::TYPE type = NetScope::MODULE) const;\n\n\t// Keep a tree of scopes. The NetScope class handles the wide\n\t// tree and per-hop searches for me.\n      std::list<NetScope*>root_scopes_;\n\n\t// Keep a map of all the elaborated packages. Note that\n\t// packages do not nest.\n      std::map<perm_string,NetScope*>packages_;\n\n\t// List the nodes in the design.\n      NetNode*nodes_;\n\t// These are in support of the node functor iterator.\n      NetNode*nodes_functor_cur_;\n      NetNode*nodes_functor_nxt_;\n\n\t// List the branches in the design.\n      NetBranch*branches_;\n\n\t// List the processes in the design.\n      NetProcTop*procs_;\n      NetProcTop*procs_idx_;\n\n\t// List the ANALOG processes in the design.\n      NetAnalogTop*aprocs_;\n\n\t// Map of discipline take to NetNet for the reference node.\n      std::map<perm_string,NetNet*>discipline_references_;\n\n\t// Map the design arguments to values.\n      std::map<std::string,const char*> flags_;\n\n      int des_precision_;\n      delay_sel_t des_delay_sel_;\n\n    private: // not implemented\n      Design(const Design&);\n      Design& operator= (const Design&);\n};\n\n\n/* =======\n */\n\ninline bool operator == (const Link&l, const Link&r)\n{ return l.is_equal(r); }\n\ninline bool operator != (const Link&l, const Link&r)\n{ return ! l.is_equal(r); }\n\n/* Connect the pins of two nodes together. Either may already be\n   connected to other things, connect is transitive. */\nextern void connect(Link&, Link&);\n\n/* Return true if l and r are connected. */\ninline bool connected(const Link&l, const Link&r)\n{ return l.is_linked(r); }\n\n/* Return the number of signals in the nexus. */\nextern unsigned count_signals(const Link&pin);\n\n/* Find the next link that is an output into the nexus. */\nextern Link* find_next_output(Link*lnk);\n\n/* Find the signal connected to the given node pin. There should\n   always be exactly one signal. The bidx parameter gets filled with\n   the signal index of the Net, in case it is a vector. */\nconst NetNet* find_link_signal(const NetObj*net, unsigned pin,\n\t\t\t       unsigned&bidx);\n\ninline std::ostream& operator << (std::ostream&o, const NetExpr&exp)\n{ exp.dump(o); return o; }\n\nextern std::ostream& operator << (std::ostream&, NetNet::Type);\n\n/*\n * Manipulator to dump a scope complete path to the output. The\n * manipulator is \"scope_path\" and works like this:\n *\n *   out << .... << scope_path(sc) << ... ;\n */\nstruct __ScopePathManip { const NetScope*scope; };\ninline __ScopePathManip scope_path(const NetScope*scope)\n{ __ScopePathManip tmp; tmp.scope = scope; return tmp; }\n\nextern std::ostream& operator << (std::ostream&o, __ScopePathManip);\n\nstruct __ObjectPathManip { const NetObj*obj; };\ninline __ObjectPathManip scope_path(const NetObj*obj)\n{ __ObjectPathManip tmp; tmp.obj = obj; return tmp; }\n\nextern std::ostream& operator << (std::ostream&o, __ObjectPathManip);\n\n/*\n * If this link has a nexus_ pointer, then it is the last Link in the\n * list. next_nlink() returns 0 for the last Link.\n */\ninline Link* Link::next_nlink()\n{\n      if (nexus_) return 0;\n      else return next_;\n}\n\ninline const Link* Link::next_nlink() const\n{\n      if (nexus_) return 0;\n      else return next_;\n}\n\ninline NetPins*Link::get_obj()\n{\n      if (pin_zero_)\n\t    return node_;\n      Link*tmp = this - pin_;\n      assert(tmp->pin_zero_);\n      return tmp->node_;\n}\n\ninline const NetPins*Link::get_obj() const\n{\n      if (pin_zero_)\n\t    return node_;\n      const Link*tmp = this - pin_;\n      assert(tmp->pin_zero_);\n      return tmp->node_;\n}\n\ninline unsigned Link::get_pin() const\n{\n      if (pin_zero_)\n\t    return 0;\n      else\n\t    return pin_;\n}\n\n#undef ENUM_UNSIGNED_INT\n#endif /* IVL_netlist_H */\n"
        },
        {
          "name": "netmisc.cc",
          "type": "blob",
          "size": 57.0927734375,
          "content": "/*\n * Copyright (c) 2001-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <cstdlib>\n# include  <climits>\n# include  \"netlist.h\"\n# include  \"netparray.h\"\n# include  \"netvector.h\"\n# include  \"netmisc.h\"\n# include  \"PExpr.h\"\n# include  \"pform_types.h\"\n# include  \"compiler.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nNetNet* sub_net_from(Design*des, NetScope*scope, long val, NetNet*sig)\n{\n      netvector_t*zero_vec = new netvector_t(sig->data_type(),\n\t\t\t\t\t     sig->vector_width()-1, 0);\n      NetNet*zero_net = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t   NetNet::WIRE, zero_vec);\n      zero_net->set_line(*sig);\n      zero_net->local_flag(true);\n\n      if (sig->data_type() == IVL_VT_REAL) {\n\t    verireal zero (val);\n\t    NetLiteral*zero_obj = new NetLiteral(scope, scope->local_symbol(), zero);\n\t    zero_obj->set_line(*sig);\n\t    des->add_node(zero_obj);\n\n\t    connect(zero_net->pin(0), zero_obj->pin(0));\n\n      } else {\n\t    verinum zero ((int64_t)val);\n\t    zero = cast_to_width(zero, sig->vector_width());\n\t    zero.has_sign(sig->get_signed());\n\t    NetConst*zero_obj = new NetConst(scope, scope->local_symbol(), zero);\n\t    zero_obj->set_line(*sig);\n\t    des->add_node(zero_obj);\n\n\t    connect(zero_net->pin(0), zero_obj->pin(0));\n      }\n\n      NetAddSub*adder = new NetAddSub(scope, scope->local_symbol(), sig->vector_width());\n      adder->set_line(*sig);\n      des->add_node(adder);\n      adder->attribute(perm_string::literal(\"LPM_Direction\"), verinum(\"SUB\"));\n\n      connect(zero_net->pin(0), adder->pin_DataA());\n      connect(adder->pin_DataB(), sig->pin(0));\n\n      netvector_t*tmp_vec = new netvector_t(sig->data_type(),\n\t\t\t\t\t    sig->vector_width()-1, 0);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t      NetNet::WIRE, tmp_vec);\n      tmp->set_line(*sig);\n      tmp->local_flag(true);\n\n      connect(adder->pin_Result(), tmp->pin(0));\n\n      return tmp;\n}\n\nNetNet* cast_to_int2(Design*des, NetScope*scope, NetNet*src, unsigned wid)\n{\n      if (src->data_type() == IVL_VT_BOOL)\n\t    return src;\n\n      netvector_t*tmp_vec = new netvector_t(IVL_VT_BOOL, wid-1, 0,\n\t\t\t\t\t    src->get_signed());\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(), NetNet::WIRE, tmp_vec);\n      tmp->set_line(*src);\n      tmp->local_flag(true);\n\n      NetCastInt2*cast = new NetCastInt2(scope, scope->local_symbol(), wid);\n      cast->set_line(*src);\n      des->add_node(cast);\n\n      connect(cast->pin(0), tmp->pin(0));\n      connect(cast->pin(1), src->pin(0));\n\n      return tmp;\n}\n\nNetNet* cast_to_int4(Design*des, NetScope*scope, NetNet*src, unsigned wid)\n{\n      if (src->data_type() != IVL_VT_REAL)\n\t    return src;\n\n      netvector_t*tmp_vec = new netvector_t(IVL_VT_LOGIC, wid-1, 0);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(), NetNet::WIRE, tmp_vec);\n      tmp->set_line(*src);\n      tmp->local_flag(true);\n\n      NetCastInt4*cast = new NetCastInt4(scope, scope->local_symbol(), wid);\n      cast->set_line(*src);\n      des->add_node(cast);\n\n      connect(cast->pin(0), tmp->pin(0));\n      connect(cast->pin(1), src->pin(0));\n\n      return tmp;\n}\n\nNetNet* cast_to_real(Design*des, NetScope*scope, NetNet*src)\n{\n      if (src->data_type() == IVL_VT_REAL)\n\t    return src;\n\n      netvector_t*tmp_vec = new netvector_t(IVL_VT_REAL);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(), NetNet::WIRE, tmp_vec);\n      tmp->set_line(*src);\n      tmp->local_flag(true);\n\n      NetCastReal*cast = new NetCastReal(scope, scope->local_symbol(), src->get_signed());\n      cast->set_line(*src);\n      des->add_node(cast);\n\n      connect(cast->pin(0), tmp->pin(0));\n      connect(cast->pin(1), src->pin(0));\n\n      return tmp;\n}\n\nNetExpr* cast_to_int2(NetExpr*expr, unsigned width)\n{\n\t// Special case: The expression is already BOOL\n      if (expr->expr_type() == IVL_VT_BOOL)\n\t    return expr;\n\n      if (debug_elaborate)\n\t    cerr << expr->get_fileline() << \": debug: \"\n\t\t << \"Cast expression to int2, width=\" << width << \".\" << endl;\n\n      NetECast*cast = new NetECast('2', expr, width, expr->has_sign());\n      cast->set_line(*expr);\n      return cast;\n}\n\nNetExpr* cast_to_int4(NetExpr*expr, unsigned width)\n{\n\t// Special case: The expression is already LOGIC or BOOL\n      if (expr->expr_type() == IVL_VT_LOGIC || expr->expr_type() == IVL_VT_BOOL)\n\t    return expr;\n\n      if (debug_elaborate)\n\t    cerr << expr->get_fileline() << \": debug: \"\n\t\t << \"Cast expression to int4, width=\" << width << \".\" << endl;\n\n      NetECast*cast = new NetECast('v', expr, width, expr->has_sign());\n      cast->set_line(*expr);\n      return cast;\n}\n\nNetExpr* cast_to_real(NetExpr*expr)\n{\n      if (expr->expr_type() == IVL_VT_REAL)\n\t    return expr;\n\n      if (debug_elaborate)\n\t    cerr << expr->get_fileline() << \": debug: \"\n\t\t << \"Cast expression to real.\" << endl;\n\n      NetECast*cast = new NetECast('r', expr, 1, true);\n      cast->set_line(*expr);\n      return cast;\n}\n\n/*\n * Add a signed constant to an existing expression. Generate a new\n * NetEBAdd node that has the input expression and an expression made\n * from the constant value.\n */\nstatic NetExpr* make_add_expr(NetExpr*expr, long val)\n{\n      if (val == 0)\n\t    return expr;\n\n\t// If the value to be added is <0, then instead generate a\n\t// SUBTRACT node and turn the value positive.\n      char add_op = '+';\n      if (val < 0) {\n\t    add_op = '-';\n\t    val = -val;\n      }\n\n      verinum val_v (val, expr->expr_width());\n      val_v.has_sign(expr->has_sign());\n\n      NetEConst*val_c = new NetEConst(val_v);\n      val_c->set_line(*expr);\n\n      NetEBAdd*res = new NetEBAdd(add_op, expr, val_c, expr->expr_width(),\n                                  expr->has_sign());\n      res->set_line(*expr);\n\n      return res;\n}\n\nstatic NetExpr* make_add_expr(const LineInfo*loc, NetExpr*expr1, NetExpr*expr2)\n{\n      bool use_signed = expr1->has_sign() && expr2->has_sign();\n      unsigned use_wid = expr1->expr_width();\n\n      if (expr2->expr_width() > use_wid)\n\t    use_wid = expr2->expr_width();\n\n      expr1 = pad_to_width(expr1, use_wid, *loc);\n      expr2 = pad_to_width(expr2, use_wid, *loc);\n\n      NetEBAdd*tmp = new NetEBAdd('+', expr1, expr2, use_wid, use_signed);\n      return tmp;\n}\n\n/*\n * Subtract an existing expression from a signed constant.\n */\nstatic NetExpr* make_sub_expr(long val, NetExpr*expr)\n{\n      verinum val_v (val, expr->expr_width());\n      val_v.has_sign(expr->has_sign());\n\n      NetEConst*val_c = new NetEConst(val_v);\n      val_c->set_line(*expr);\n\n      NetEBAdd*res = new NetEBAdd('-', val_c, expr, expr->expr_width(),\n                                  expr->has_sign());\n      res->set_line(*expr);\n\n      return res;\n}\n\n/*\n * Subtract a signed constant from an existing expression.\n */\nstatic NetExpr* make_sub_expr(NetExpr*expr, long val)\n{\n      verinum val_v (val, expr->expr_width());\n      val_v.has_sign(expr->has_sign());\n\n      NetEConst*val_c = new NetEConst(val_v);\n      val_c->set_line(*expr);\n\n      NetEBAdd*res = new NetEBAdd('-', expr, val_c, expr->expr_width(),\n                                  expr->has_sign());\n      res->set_line(*expr);\n\n      return res;\n}\n\n\n/*\n * Multiply an existing expression by a signed positive number.\n * This does a lossless multiply, so the arguments will need to be\n * sized to match the output size.\n */\nstatic NetExpr* make_mult_expr(NetExpr*expr, unsigned long val)\n{\n      const unsigned val_wid = ceil(log2((double)val)) ;\n      unsigned use_wid = expr->expr_width() + val_wid;\n      verinum val_v (val, use_wid);\n      val_v.has_sign(expr->has_sign());\n\n      NetEConst*val_c = new NetEConst(val_v);\n      val_c->set_line(*expr);\n\n\t// We know by definitions that the expr argument needs to be\n\t// padded to be the right argument width for this lossless multiply.\n      expr = pad_to_width(expr, use_wid, *expr);\n\n      NetEBMult*res = new NetEBMult('*', expr, val_c, use_wid, expr->has_sign());\n      res->set_line(*expr);\n\n      return res;\n}\n\n/*\n * This routine is used to calculate the number of bits needed to\n * contain the given number.\n */\nstatic unsigned num_bits(long arg)\n{\n      unsigned res = 0;\n\n\t/* For a negative value we have room for one extra value, but\n\t * we have a signed result so we need an extra bit for this. */\n      if (arg < 0) {\n\t    arg = -arg - 1;\n\t    res += 1;\n      }\n\n\t/* Calculate the number of bits needed here. */\n      while (arg) {\n\t    res += 1;\n\t    arg >>= 1;\n      }\n\n      return res;\n}\n\n/*\n * This routine generates the normalization expression needed for a variable\n * bit select or a variable base expression for an indexed part\n * select. This function doesn't actually look at the variable\n * dimensions, it just does the final calculation using msb/lsb of the\n * last slice, and the off of the slice in the variable.\n */\nNetExpr *normalize_variable_base(NetExpr *base, long msb, long lsb,\n\t\t\t\t unsigned long wid, bool is_up, long soff)\n{\n      bool msb_lo = msb < lsb;\n\n\t// Calculate the canonical offset.\n      long offset = soff;\n      if (msb_lo) {\n\t      // E.g. logic [0:15] up_vect - prepare to calculate offset - base\n\t    offset += lsb;\n\t    if (is_up)   // E.g. up_vect[msb_base_expr +: width_expr]\n\t\t  offset -= wid - 1;\n      } else {\n\t      // E.g. logic [15:0] down_vect - prepare to calculate offset + base\n\t    offset -= lsb;\n\t    if (!is_up)  // E.g. down_vect[msb_base_expr -: width_expr]\n\t\t  offset -= wid - 1;\n\t      // There is no need to calculate 0 + base.\n\t    if (offset == 0) return base;\n      }\n\n\t// Calculate the space needed for the offset.\n      unsigned off_wid = num_bits(offset);\n\t// Get the width of the base expression.\n      unsigned base_wid = base->expr_width();\n\n\t// If the result could be negative, then we need to do signed math\n\t// to get the location value correct.\n      bool add_base_sign = !base->has_sign() && (offset < 0 || (msb_lo && off_wid <= base_wid));\n\n\t// If base is signed, we must add a sign bit to offset as well.\n      bool add_off_sign = offset >= 0 && (base->has_sign() || add_base_sign);\n\n\t// We need enough space for the larger of the offset or the\n\t// base expression, plus an extra bit for arithmetic overflow.\n      unsigned min_wid = 1 + max(off_wid + add_off_sign, base_wid + add_base_sign);\n      base = pad_to_width(base, min_wid, *base);\n      if (add_base_sign) {\n\t      /* We need this extra select to hide the signed\n\t       * property from the padding above. It will be\n\t       * removed automatically during code generation. */\n\t    NetESelect *tmp = new NetESelect(base, 0 , min_wid);\n\t    tmp->set_line(*base);\n\t    tmp->cast_signed(true);\n\t    base = tmp;\n      }\n\n\t// Normalize the expression.\n      return msb_lo ? make_sub_expr(offset, base) : make_add_expr(base, offset);\n}\n\nNetExpr *normalize_variable_bit_base(const list<long>&indices, NetExpr*base,\n\t\t\t\t     const NetNet*reg)\n{\n      const netranges_t&packed_dims = reg->packed_dims();\n      ivl_assert(*base, indices.size()+1 == packed_dims.size());\n\n\t// Get the canonical offset of the slice within which we are\n\t// addressing. We need that address as a slice offset to\n\t// calculate the proper complete address\n      const netrange_t&rng = packed_dims.back();\n      long slice_off = reg->sb_to_idx(indices, rng.get_lsb());\n\n      return normalize_variable_base(base, rng.get_msb(), rng.get_lsb(), 1, true, slice_off);\n}\n\nNetExpr *normalize_variable_part_base(const list<long>&indices, NetExpr*base,\n\t\t\t\t      const NetNet*reg,\n\t\t\t\t      unsigned long wid, bool is_up)\n{\n      const netranges_t&packed_dims = reg->packed_dims();\n      ivl_assert(*base, indices.size()+1 == packed_dims.size());\n\n\t// Get the canonical offset of the slice within which we are\n\t// addressing. We need that address as a slice offset to\n\t// calculate the proper complete address\n      const netrange_t&rng = packed_dims.back();\n      long slice_off = reg->sb_to_idx(indices, rng.get_lsb());\n\n      return normalize_variable_base(base, rng.get_msb(), rng.get_lsb(), wid, is_up, slice_off);\n}\n\nNetExpr *normalize_variable_slice_base(const list<long>&indices, NetExpr*base,\n\t\t\t\t       const NetNet*reg, unsigned long&lwid)\n{\n      const netranges_t&packed_dims = reg->packed_dims();\n      ivl_assert(*base, indices.size() < packed_dims.size());\n\n      netranges_t::const_iterator pcur = packed_dims.end();\n      for (size_t idx = indices.size() ; idx < packed_dims.size(); idx += 1) {\n\t    -- pcur;\n      }\n\n      long sb = min(pcur->get_lsb(), pcur->get_msb());\n      long loff;\n      reg->sb_to_slice(indices, sb, loff, lwid);\n\n      unsigned min_wid = base->expr_width();\n      if ((sb < 0) && !base->has_sign()) min_wid += 1;\n      if (min_wid < num_bits(pcur->get_lsb())) min_wid = pcur->get_lsb();\n      if (min_wid < num_bits(pcur->get_msb())) min_wid = pcur->get_msb();\n      base = pad_to_width(base, min_wid, *base);\n      if ((sb < 0) && !base->has_sign()) {\n\t    NetESelect *tmp = new NetESelect(base, 0 , min_wid);\n\t    tmp->set_line(*base);\n\t    tmp->cast_signed(true);\n            base = tmp;\n      }\n\n      if (pcur->get_msb() >= pcur->get_lsb()) {\n\t    if (pcur->get_lsb() != 0)\n\t\t  base = make_sub_expr(base, pcur->get_lsb());\n\t    base = make_mult_expr(base, lwid);\n\t    min_wid = base->expr_width();\n\t    if (min_wid < num_bits(loff)) min_wid = num_bits(loff);\n\t    if (loff != 0) min_wid += 1;\n\t    base = pad_to_width(base, min_wid, *base);\n\t    base = make_add_expr(base, loff);\n      } else {\n\t    if (pcur->get_msb() != 0)\n\t\t  base = make_sub_expr(base, pcur->get_msb());\n\t    base = make_mult_expr(base, lwid);\n\t    min_wid = base->expr_width();\n\t    if (min_wid < num_bits(loff)) min_wid = num_bits(loff);\n\t    if (loff != 0) min_wid += 1;\n\t    base = pad_to_width(base, min_wid, *base);\n\t    base = make_sub_expr(loff, base);\n      }\n      return base;\n}\n\nostream& operator << (ostream&o, __IndicesManip<long> val)\n{\n      for (list<long>::const_iterator cur = val.val.begin()\n\t\t ; cur != val.val.end() ; ++cur) {\n\t    o << \"[\" << *cur << \"]\";\n      }\n      return o;\n}\n\nostream& operator << (ostream&o, __IndicesManip<NetExpr*> val)\n{\n      for (list<NetExpr*>::const_iterator cur = val.val.begin()\n\t\t ; cur != val.val.end() ; ++cur) {\n\t    o << \"[\" << *(*cur) << \"]\";\n      }\n      return o;\n}\n\n/*\n * The src is the input index expression list from the expression, and\n * the count is the number that are to be elaborated into the indices\n * list. At the same time, create a indices_const list that contains\n * the evaluated values for the expression, if they can be evaluated.\n */\nvoid indices_to_expressions(Design*des, NetScope*scope,\n\t\t\t      // loc is for error messages.\n\t\t\t    const LineInfo*loc,\n\t\t\t      // src is the index list, and count is\n\t\t\t      // the number of items in the list to use.\n\t\t\t    const list<index_component_t>&src, unsigned count,\n\t\t\t      // True if the expression MUST be constant.\n\t\t\t    bool need_const,\n\t\t\t      // These are the outputs.\n\t\t\t    indices_flags&flags,\n\t\t\t    list<NetExpr*>&indices, list<long>&indices_const)\n{\n      ivl_assert(*loc, count <= src.size());\n\n      flags.invalid   = false;\n      flags.variable  = false;\n      flags.undefined = false;\n      for (list<index_component_t>::const_iterator cur = src.begin()\n\t\t ; count > 0 ;  ++cur, --count) {\n\t    ivl_assert(*loc, cur->sel != index_component_t::SEL_NONE);\n\n\t    if (cur->sel != index_component_t::SEL_BIT) {\n\t\t  cerr << loc->get_fileline() << \": error: \"\n\t\t       << \"Array cannot be indexed by a range.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n\t    ivl_assert(*loc, cur->msb);\n\n\t    NetExpr*word_index = elab_and_eval(des, scope, cur->msb, -1, need_const);\n\n\t    if (word_index == 0)\n\t\t  flags.invalid = true;\n\n\t      // Track if we detect any non-constant expressions\n\t      // here. This may allow for a special case.\n\t    NetEConst*word_const = dynamic_cast<NetEConst*> (word_index);\n\t    if (word_const == 0)\n\t\t  flags.variable = true;\n\t    else if (!word_const->value().is_defined())\n\t\t  flags.undefined = true;\n\t    else if (!flags.variable && !flags.undefined)\n\t\t  indices_const.push_back(word_const->value().as_long());\n\n\t    indices.push_back(word_index);\n      }\n}\n\nstatic void make_strides(const netranges_t&dims, vector<long>&stride)\n{\n      stride[dims.size()-1] = 1;\n      for (size_t idx = stride.size()-1 ; idx > 0 ; --idx) {\n\t    long tmp = dims[idx].width();\n\t    if (idx < stride.size())\n\t\t  tmp *= stride[idx];\n\t    stride[idx-1] = tmp;\n      }\n}\n\n/*\n * Take in a vector of constant indices and convert them to a single\n * number that is the canonical address (zero based, 1-d) of the\n * word. If any of the indices are out of bounds, return nil instead\n * of an expression.\n */\nstatic NetExpr* normalize_variable_unpacked(const netranges_t&dims, list<long>&indices)\n{\n\t// Make strides for each index. The stride is the distance (in\n\t// words) to the next element in the canonical array.\n      vector<long> stride (dims.size());\n      make_strides(dims, stride);\n\n      int64_t canonical_addr = 0;\n\n      int idx = 0;\n      for (list<long>::const_iterator cur = indices.begin()\n\t\t ; cur != indices.end() ; ++cur, ++idx) {\n\t    long tmp = *cur;\n\n\t    if (dims[idx].get_lsb() <= dims[idx].get_msb())\n\t\t  tmp -= dims[idx].get_lsb();\n\t    else\n\t\t  tmp -= dims[idx].get_msb();\n\n\t      // Notice of this index is out of range.\n\t    if (tmp < 0 || tmp >= (long)dims[idx].width()) {\n\t\t  return 0;\n\t    }\n\n\t    canonical_addr += tmp * stride[idx];\n      }\n\n      NetEConst*canonical_expr = new NetEConst(verinum(canonical_addr));\n      return canonical_expr;\n}\n\nNetExpr* normalize_variable_unpacked(const NetNet*net, list<long>&indices)\n{\n      const netranges_t&dims = net->unpacked_dims();\n      return normalize_variable_unpacked(dims, indices);\n}\n\nNetExpr* normalize_variable_unpacked(const netsarray_t*stype, list<long>&indices)\n{\n      const netranges_t&dims = stype->static_dimensions();\n      return normalize_variable_unpacked(dims, indices);\n}\n\nNetExpr* normalize_variable_unpacked(const LineInfo&loc, const netranges_t&dims, list<NetExpr*>&indices)\n{\n\t// Make strides for each index. The stride is the distance (in\n\t// words) to the next element in the canonical array.\n      vector<long> stride (dims.size());\n      make_strides(dims, stride);\n\n      NetExpr*canonical_expr = 0;\n\n      int idx = 0;\n      for (list<NetExpr*>::const_iterator cur = indices.begin()\n\t\t ; cur != indices.end() ; ++cur, ++idx) {\n\t    NetExpr*tmp = *cur;\n\t      // If the expression elaboration generated errors, then\n\t      // give up. Presumably, the error during expression\n\t      // elaboration already generated the error message.\n\t    if (tmp == 0)\n\t\t  return 0;\n\n\t    int64_t use_base;\n\t    if (! dims[idx].defined())\n\t\t  use_base = 0;\n\t    else if (dims[idx].get_lsb() <= dims[idx].get_msb())\n\t\t  use_base = dims[idx].get_lsb();\n\t    else\n\t\t  use_base = dims[idx].get_msb();\n\n\t    int64_t use_stride = stride[idx];\n\n\t      // Account for that we are doing arithmetic and should\n\t      // have a proper width to make sure there are no\n\t      // losses. So calculate a min_wid width.\n\t    unsigned tmp_wid;\n\t    unsigned min_wid = tmp->expr_width();\n\t    if (use_base != 0 && ((tmp_wid = num_bits(use_base)) >= min_wid))\n\t\t  min_wid = tmp_wid + 1;\n\t    if ((tmp_wid = num_bits(dims[idx].width()+1)) >= min_wid)\n\t\t  min_wid = tmp_wid + 1;\n\t    if (use_stride != 1)\n\t\t  min_wid += num_bits(use_stride);\n\n\t    tmp = pad_to_width(tmp, min_wid, loc);\n\n\t      // Now generate the math to calculate the canonical address.\n\t    NetExpr*tmp_scaled = 0;\n\t    if (NetEConst*tmp_const = dynamic_cast<NetEConst*> (tmp)) {\n\t\t    // Special case: the index is constant, so this\n\t\t    // iteration can be replaced with a constant\n\t\t    // expression.\n\t\t  int64_t val = tmp_const->value().as_long();\n\t\t  val -= use_base;\n\t\t  val *= use_stride;\n\t\t    // Very special case: the index is zero, so we can\n\t\t    // skip this iteration\n\t\t  if (val == 0)\n\t\t\tcontinue;\n\t\t  tmp_scaled = new NetEConst(verinum(val));\n\n\t    } else {\n\t\t  tmp_scaled = tmp;\n\t\t  if (use_base != 0)\n\t\t\ttmp_scaled = make_add_expr(tmp_scaled, -use_base);\n\t\t  if (use_stride != 1)\n\t\t\ttmp_scaled = make_mult_expr(tmp_scaled, use_stride);\n\t    }\n\n\t    if (canonical_expr == 0) {\n\t\t  canonical_expr = tmp_scaled;\n\t    } else {\n\t\t  bool expr_has_sign = canonical_expr->has_sign() &&\n\t\t                        tmp_scaled->has_sign();\n\t\t  canonical_expr = new NetEBAdd('+', canonical_expr, tmp_scaled,\n\t\t\t\t\t\tcanonical_expr->expr_width()+1,\n\t\t                                expr_has_sign);\n\t    }\n      }\n\n\t// If we don't have an expression at this point, all the indices were\n\t// constant zero. But this variant of normalize_variable_unpacked()\n\t// is only used when at least one index is not a constant.\n\tivl_assert(loc, canonical_expr);\n\n      return canonical_expr;\n}\n\nNetExpr* normalize_variable_unpacked(const NetNet*net, list<NetExpr*>&indices)\n{\n      const netranges_t&dims = net->unpacked_dims();\n      return normalize_variable_unpacked(*net, dims, indices);\n}\n\nNetExpr* normalize_variable_unpacked(const LineInfo&loc, const netsarray_t*stype, list<NetExpr*>&indices)\n{\n      const netranges_t&dims = stype->static_dimensions();\n      return normalize_variable_unpacked(loc, dims, indices);\n}\n\nNetExpr* make_canonical_index(Design*des, NetScope*scope,\n\t\t\t      const LineInfo*loc,\n\t\t\t      const std::list<index_component_t>&src,\n\t\t\t      const netsarray_t*stype,\n\t\t\t      bool need_const)\n{\n      NetExpr*canon_index = 0;\n\n      list<long> indices_const;\n      list<NetExpr*> indices_expr;\n      indices_flags flags;\n      indices_to_expressions(des, scope, loc,\n\t\t\t     src, src.size(),\n\t\t\t     need_const,\n\t\t\t     flags,\n\t\t\t     indices_expr, indices_const);\n\n      if (flags.undefined) {\n\t    cerr << loc->get_fileline() << \": warning: \"\n\t\t << \"ignoring undefined value array access.\" << endl;\n\n      } else if (flags.variable) {\n\t    canon_index = normalize_variable_unpacked(*loc, stype, indices_expr);\n\n      } else {\n\t    canon_index = normalize_variable_unpacked(stype, indices_const);\n      }\n\n      return canon_index;\n}\n\nNetEConst* make_const_x(unsigned long wid)\n{\n      verinum xxx (verinum::Vx, wid);\n      NetEConst*resx = new NetEConst(xxx);\n      return resx;\n}\n\nNetEConst* make_const_0(unsigned long wid)\n{\n      verinum xxx (verinum::V0, wid);\n      NetEConst*resx = new NetEConst(xxx);\n      return resx;\n}\n\nNetEConst* make_const_val(unsigned long value)\n{\n      verinum tmp (value, integer_width);\n      NetEConst*res = new NetEConst(tmp);\n      return res;\n}\n\nNetEConst* make_const_val_s(long value)\n{\n      verinum tmp (value, integer_width);\n      tmp.has_sign(true);\n      NetEConst*res = new NetEConst(tmp);\n      return res;\n}\n\nstatic NetNet* make_const_net(Design*des, NetScope*scope, verinum val)\n{\n      NetConst*res = new NetConst(scope, scope->local_symbol(), val);\n      des->add_node(res);\n\n      netvector_t*sig_vec = new netvector_t(IVL_VT_LOGIC, val.len() - 1, 0);\n      NetNet*sig = new NetNet(scope, scope->local_symbol(), NetNet::WIRE, sig_vec);\n      sig->local_flag(true);\n\n      connect(sig->pin(0), res->pin(0));\n      return sig;\n}\n\nNetNet* make_const_0(Design*des, NetScope*scope, unsigned long wid)\n{\n      return make_const_net(des, scope, verinum(verinum::V0, wid));\n}\n\nNetNet* make_const_x(Design*des, NetScope*scope, unsigned long wid)\n{\n      return make_const_net(des, scope, verinum(verinum::Vx, wid));\n}\n\nNetNet* make_const_z(Design*des, NetScope*scope, unsigned long wid)\n{\n      return make_const_net(des, scope, verinum(verinum::Vz, wid));\n}\n\nNetExpr* condition_reduce(NetExpr*expr)\n{\n      if (expr->expr_type() == IVL_VT_REAL) {\n\t    if (NetECReal *tmp = dynamic_cast<NetECReal*>(expr)) {\n\t\t  verinum::V res;\n\t\t  if (tmp->value().as_double() == 0.0) res = verinum::V0;\n\t\t  else res = verinum::V1;\n\t\t  verinum vres (res, 1, true);\n\t\t  NetExpr *rtn = new NetEConst(vres);\n\t\t  rtn->set_line(*expr);\n\t\t  delete expr;\n\t\t  return rtn;\n\t    }\n\n\t    NetExpr *rtn = new NetEBComp('n', expr,\n\t                                 new NetECReal(verireal(0.0)));\n\t    rtn->set_line(*expr);\n\t    return rtn;\n      }\n\n      if (expr->expr_width() == 1)\n\t    return expr;\n\n      verinum zero (verinum::V0, expr->expr_width());\n      zero.has_sign(expr->has_sign());\n\n      NetEConst*ezero = new NetEConst(zero);\n      ezero->set_line(*expr);\n\n      NetEBComp*cmp = new NetEBComp('n', expr, ezero);\n      cmp->set_line(*expr);\n      cmp->cast_signed(false);\n\n      return cmp;\n}\n\nNetExpr* elab_and_eval(Design*des, NetScope*scope, PExpr*pe,\n\t\t       int context_width, bool need_const, bool annotatable,\n\t\t       ivl_variable_type_t cast_type, bool force_unsigned)\n{\n      PExpr::width_mode_t mode = PExpr::SIZED;\n      if ((context_width == -2) && !gn_strict_expr_width_flag)\n            mode = PExpr::EXPAND;\n\n      pe->test_width(des, scope, mode);\n\n      if (pe->expr_type() == IVL_VT_CLASS) {\n\t    cerr << pe->get_fileline() << \": Error: \"\n\t         << \"Class/null r-value not allowed in this context.\" << endl;\n\t    des->errors += 1;\n\t    return 0;\n      }\n\n        // Get the final expression width. If the expression is unsized,\n        // this may be different from the value returned by test_width().\n      unsigned expr_width = pe->expr_width();\n\n        // If context_width is positive, this is the RHS of an assignment,\n        // so the LHS width must also be included in the width calculation.\n      unsigned pos_context_width = context_width > 0 ? context_width : 0;\n      if ((pe->expr_type() != IVL_VT_REAL) && (expr_width < pos_context_width))\n            expr_width = pos_context_width;\n\n\t// If this is the RHS of a compressed assignment, the LHS also\n\t// affects the expression type (signed/unsigned).\n      if (force_unsigned)\n\t    pe->cast_signed(false);\n\n      if (debug_elaborate) {\n            cerr << pe->get_fileline() << \": elab_and_eval: test_width of \"\n                 << *pe << endl;\n            cerr << pe->get_fileline() << \":              : \"\n                 << \"returns type=\" << pe->expr_type()\n\t\t << \", context_width=\" << context_width\n                 << \", signed=\" << pe->has_sign()\n                 << \", expr_width=\" << expr_width\n                 << \", mode=\" << PExpr::width_mode_name(mode) << endl;\n\t    cerr << pe->get_fileline() << \":              : \"\n\t\t << \"cast_type=\" << cast_type << endl;\n      }\n\n        // If we can get the same result using a smaller expression\n        // width, do so.\n\n      unsigned min_width = pe->min_width();\n      if ((min_width != UINT_MAX) && (pe->expr_type() != IVL_VT_REAL)\n          && (pos_context_width > 0) && (expr_width > pos_context_width)) {\n            expr_width = max(min_width, pos_context_width);\n\n            if (debug_elaborate) {\n                  cerr << pe->get_fileline() << \":              : \"\n                       << \"pruned to width=\" << expr_width << endl;\n            }\n      }\n\n      if ((mode >= PExpr::LOSSLESS) && (expr_width > width_cap)\n          && (expr_width > pos_context_width)) {\n            cerr << pe->get_fileline() << \": warning: excessive unsized \"\n                 << \"expression width detected.\" << endl;\n            cerr << pe->get_fileline() << \":        : The expression width \"\n                 << \"is capped at \" << width_cap << \" bits.\" << endl;\n\t    expr_width = width_cap;\n      }\n\n      unsigned flags = PExpr::NO_FLAGS;\n      if (need_const)\n            flags |= PExpr::NEED_CONST;\n      if (annotatable)\n            flags |= PExpr::ANNOTATABLE;\n\n      if (debug_elaborate) {\n\t    cerr << pe->get_fileline() << \": elab_and_eval: \"\n\t\t << \"Calculated width is \" << expr_width << \".\" << endl;\n      }\n\n      NetExpr*tmp = pe->elaborate_expr(des, scope, expr_width, flags);\n      if (tmp == 0) return 0;\n\n      if ((cast_type != IVL_VT_NO_TYPE) && (cast_type != tmp->expr_type())) {\n            switch (tmp->expr_type()) {\n                case IVL_VT_BOOL:\n                case IVL_VT_LOGIC:\n                case IVL_VT_REAL:\n                  break;\n                default:\n                  cerr << tmp->get_fileline() << \": error: \"\n                          \"The expression '\" << *pe << \"' cannot be implicitly \"\n                          \"cast to the target type.\" << endl;\n                  des->errors += 1;\n                  delete tmp;\n                  return 0;\n            }\n            switch (cast_type) {\n                case IVL_VT_REAL:\n                  tmp = cast_to_real(tmp);\n                  break;\n                case IVL_VT_BOOL:\n                  tmp = cast_to_int2(tmp, pos_context_width);\n                  break;\n                case IVL_VT_LOGIC:\n                  tmp = cast_to_int4(tmp, pos_context_width);\n                  break;\n                default:\n                  break;\n            }\n      }\n\n      eval_expr(tmp, context_width);\n\n      if (NetEConst*ce = dynamic_cast<NetEConst*>(tmp)) {\n            if ((mode >= PExpr::LOSSLESS) && (context_width < 0))\n                  ce->trim();\n      }\n\n      return tmp;\n}\n\nNetExpr* elab_and_eval(Design*des, NetScope*scope, PExpr*pe,\n\t\t       ivl_type_t lv_net_type, bool need_const)\n{\n      if (debug_elaborate) {\n\t    cerr << pe->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"pe=\" << *pe\n\t\t << \", lv_net_type=\" << *lv_net_type << endl;\n      }\n\n\t// Elaborate the expression using the more general\n\t// elaborate_expr method.\n      unsigned flags = PExpr::NO_FLAGS;\n      if (need_const)\n            flags |= PExpr::NEED_CONST;\n\n      NetExpr*tmp = pe->elaborate_expr(des, scope, lv_net_type, flags);\n      if (tmp == 0) return 0;\n\n      ivl_variable_type_t cast_type = ivl_type_base(lv_net_type);\n      ivl_variable_type_t expr_type = tmp->expr_type();\n\n      bool compatible;\n        // For arrays we need strict type checking here. Long term strict type\n\t// checking should be used for all expressions, but at the moment not\n\t// all expressions do have a ivl_type_t attached to it.\n      if (dynamic_cast<const netuarray_t*>(lv_net_type)) {\n\t    if (tmp->net_type())\n\t\t  compatible = lv_net_type->type_compatible(tmp->net_type());\n\t    else\n\t\t  compatible = false;\n      } else if (cast_type == IVL_VT_NO_TYPE) {\n\t    compatible = true;\n      } else {\n\t    compatible = cast_type == expr_type;\n      }\n\n      if (!compatible) {\n\t      // Catch some special cases.\n\t    switch (cast_type) {\n\t\tcase IVL_VT_DARRAY:\n\t\tcase IVL_VT_QUEUE:\n\t\t  if ((expr_type == IVL_VT_DARRAY) || (expr_type == IVL_VT_QUEUE))\n\t\t\treturn tmp;\n\n\t\t  // This is needed to handle the special case of `'{}` which\n\t\t  // gets elaborated to NetENull.\n\t\t  if (dynamic_cast<PEAssignPattern*>(pe))\n\t\t\treturn tmp;\n\t\t  // fall through\n\t\tcase IVL_VT_STRING:\n\t\t  if (dynamic_cast<PEConcat*>(pe))\n\t\t\treturn tmp;\n\t\t  break;\n\t\tcase IVL_VT_CLASS:\n\t\t  if (dynamic_cast<PENull*>(pe))\n\t\t\treturn tmp;\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t    }\n\n\t    cerr << tmp->get_fileline() << \": error: \"\n\t\t    \"The expression '\" << *pe << \"' cannot be implicitly \"\n\t\t    \"cast to the target type.\" << endl;\n\t    des->errors += 1;\n\t    delete tmp;\n\t    return 0;\n      }\n\n      if (lv_net_type->packed())\n\t    eval_expr(tmp, lv_net_type->packed_width());\n      else\n\t    eval_expr(tmp, -1);\n\n      return tmp;\n}\n\nNetExpr* elab_sys_task_arg(Design*des, NetScope*scope, perm_string name,\n                           unsigned arg_idx, PExpr*pe, bool need_const)\n{\n      if (!pe)\n\t    return nullptr;\n\n      PExpr::width_mode_t mode = PExpr::SIZED;\n      pe->test_width(des, scope, mode);\n\n      if (debug_elaborate) {\n\t    cerr << pe->get_fileline() << \": \" << __func__ << \": \"\n\t\t << \"test_width of \" << name\n                 << \" argument \" << (arg_idx+1) << \" \" << *pe << endl;\n            cerr << pe->get_fileline() << \":        \"\n                 << \"returns type=\" << pe->expr_type()\n                 << \", width=\" << pe->expr_width()\n                 << \", signed=\" << pe->has_sign()\n                 << \", mode=\" << PExpr::width_mode_name(mode) << endl;\n      }\n\n      unsigned flags = PExpr::SYS_TASK_ARG;\n      if (need_const)\n            flags |= PExpr::NEED_CONST;\n\n      NetExpr*tmp = pe->elaborate_expr(des, scope, pe->expr_width(), flags);\n      if (tmp == 0) return 0;\n\n      eval_expr(tmp, -1);\n\n      if (NetEConst*ce = dynamic_cast<NetEConst*>(tmp)) {\n              // For lossless/unsized constant expressions, we can now\n              // determine the exact width required to hold the result.\n              // But leave literal numbers exactly as the user supplied\n              // them.\n            if ((mode >= PExpr::LOSSLESS) && !dynamic_cast<PENumber*>(pe) && tmp->expr_width()>32)\n                  ce->trim();\n      }\n\n      return tmp;\n}\n\nbool evaluate_range(Design*des, NetScope*scope, const LineInfo*li,\n\t\t    const pform_range_t&range, long&index_l, long&index_r)\n{\n      bool dimension_ok = true;\n\n        // Unsized and queue dimensions should be handled before calling\n        // this function. If we find them here, we are in a context where\n        // they are not allowed.\n      if (range.first == 0) {\n            cerr << li->get_fileline() << \": error: \"\n                    \"An unsized dimension is not allowed here.\" << endl;\n            dimension_ok = false;\n            des->errors += 1;\n      } else if (dynamic_cast<PENull*>(range.first)) {\n            cerr << li->get_fileline() << \": error: \"\n                    \"A queue dimension is not allowed here.\" << endl;\n            dimension_ok = false;\n            des->errors += 1;\n      } else {\n            NetExpr*texpr = elab_and_eval(des, scope, range.first, -1, true);\n            if (! eval_as_long(index_l, texpr)) {\n                  cerr << range.first->get_fileline() << \": error: \"\n                          \"Dimensions must be constant.\" << endl;\n                  cerr << range.first->get_fileline() << \"       : \"\n                       << (range.second ? \"This MSB\" : \"This size\")\n                       << \" expression violates the rule: \"\n                       << *range.first << endl;\n                  dimension_ok = false;\n                  des->errors += 1;\n            }\n            delete texpr;\n\n            if (range.second == 0) {\n                    // This is a SystemVerilog [size] dimension. The IEEE\n                    // standard does not allow this in a packed dimension,\n                    // but we do. At least one commercial simulator does too.\n                  if (!dimension_ok) {\n                        // bail out\n                  } else if (index_l > 0) {\n                        index_r = index_l - 1;\n                        index_l = 0;\n                  } else {\n                        cerr << range.first->get_fileline() << \": error: \"\n                                \"Dimension size must be greater than zero.\" << endl;\n                        cerr << range.first->get_fileline() << \"       : \"\n                                \"This size expression violates the rule: \"\n                             << *range.first << endl;\n                        dimension_ok = false;\n                        des->errors += 1;\n                  }\n            } else {\n                  texpr = elab_and_eval(des, scope, range.second, -1, true);\n                  if (! eval_as_long(index_r, texpr)) {\n                        cerr << range.second->get_fileline() << \": error: \"\n                                \"Dimensions must be constant.\" << endl;\n                        cerr << range.second->get_fileline() << \"       : \"\n                                \"This LSB expression violates the rule: \"\n                             << *range.second << endl;\n                        dimension_ok = false;\n                        des->errors += 1;\n                  }\n                  delete texpr;\n            }\n      }\n\n        /* Error recovery */\n      if (!dimension_ok) {\n            index_l = 0;\n            index_r = 0;\n      }\n\n      return dimension_ok;\n}\n\nbool evaluate_ranges(Design*des, NetScope*scope, const LineInfo*li,\n\t\t     netranges_t&llist, const list<pform_range_t>&rlist)\n{\n      bool dimensions_ok = true;\n\n      for (list<pform_range_t>::const_iterator cur = rlist.begin()\n\t\t ; cur != rlist.end() ; ++cur) {\n            long index_l, index_r;\n            dimensions_ok &= evaluate_range(des, scope, li, *cur, index_l, index_r);\n            llist.push_back(netrange_t(index_l, index_r));\n      }\n\n      return dimensions_ok;\n}\n\nvoid eval_expr(NetExpr*&expr, int context_width)\n{\n      assert(expr);\n      if (dynamic_cast<NetECReal*>(expr)) return;\n\n      NetExpr*tmp = expr->eval_tree();\n      if (tmp != 0) {\n\t    tmp->set_line(*expr);\n\t    delete expr;\n\t    expr = tmp;\n      }\n\n      if (context_width <= 0) return;\n\n      NetEConst *ce = dynamic_cast<NetEConst*>(expr);\n      if (ce == 0) return;\n\n        // The expression is a constant, so resize it if needed.\n      if (ce->expr_width() < (unsigned)context_width) {\n            expr = pad_to_width(expr, context_width, *expr);\n      } else if (ce->expr_width() > (unsigned)context_width) {\n            verinum value(ce->value(), context_width);\n            ce = new NetEConst(value);\n            ce->set_line(*expr);\n            delete expr;\n            expr = ce;\n      }\n}\n\nbool eval_as_long(long&value, const NetExpr*expr)\n{\n      if (const NetEConst*tmp = dynamic_cast<const NetEConst*>(expr) ) {\n\t    value = tmp->value().as_long();\n\t    return true;\n      }\n\n      if (const NetECReal*rtmp = dynamic_cast<const NetECReal*>(expr)) {\n\t    value = rtmp->value().as_long();\n\t    return true;\n      }\n\n      return false;\n}\n\nbool eval_as_double(double&value, NetExpr*expr)\n{\n      if (NetEConst*tmp = dynamic_cast<NetEConst*>(expr) ) {\n\t    value = tmp->value().as_double();\n\t    return true;\n      }\n\n      if (NetECReal*rtmp = dynamic_cast<NetECReal*>(expr)) {\n\t    value = rtmp->value().as_double();\n\t    return true;\n      }\n\n      return false;\n}\n\n/*\n * At the parser level, a name component is a name with a collection\n * of expressions. For example foo[N] is the name \"foo\" and the index\n * expression \"N\". This function takes as input the name component and\n * returns the path component name. It will evaluate the index\n * expression if it is present.\n */\nhname_t eval_path_component(Design*des, NetScope*scope,\n\t\t\t    const name_component_t&comp,\n\t\t\t    bool&error_flag)\n{\n\t// No index expression, so the path component is an undecorated\n\t// name, for example \"foo\".\n      if (comp.index.empty())\n\t    return hname_t(comp.name);\n\n      vector<int> index_values;\n\n      for (list<index_component_t>::const_iterator cur = comp.index.begin()\n\t\t ; cur != comp.index.end() ; ++cur) {\n\t    const index_component_t&index = *cur;\n\n\t    if (index.sel != index_component_t::SEL_BIT) {\n\t\t  cerr << index.msb->get_fileline() << \": error: \"\n\t\t       << \"Part select is not valid for this kind of object.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return hname_t(comp.name, 0);\n\t    }\n\n\t      // The parser will assure that path components will have only\n\t      // bit select index expressions. For example, \"foo[n]\" is OK,\n\t      // but \"foo[n:m]\" is not.\n\t    assert(index.sel == index_component_t::SEL_BIT);\n\n\t      // Evaluate the bit select to get a number.\n\t    NetExpr*tmp = elab_and_eval(des, scope, index.msb, -1);\n\t    ivl_assert(*index.msb, tmp);\n\n\t    if (NetEConst*ctmp = dynamic_cast<NetEConst*>(tmp)) {\n\t\t  index_values.push_back(ctmp->value().as_long());\n\t\t  delete ctmp;\n\t\t  continue;\n\t    }\n#if 1\n\t      // Darn, the expression doesn't evaluate to a constant. That's\n\t      // an error to be reported. And make up a fake index value to\n\t      // return to the caller.\n\t    cerr << index.msb->get_fileline() << \": error: \"\n\t\t << \"Scope index expression is not constant: \"\n\t\t << *index.msb << endl;\n\t    des->errors += 1;\n#endif\n\t    error_flag = true;\n\n\t    delete tmp;\n      }\n\n      return hname_t(comp.name, index_values);\n}\n\nstd::list<hname_t> eval_scope_path(Design*des, NetScope*scope,\n\t\t\t\t   const pform_name_t&path)\n{\n      bool path_error_flag = false;\n      list<hname_t> res;\n\n      typedef pform_name_t::const_iterator pform_path_it;\n\n      for (pform_path_it cur = path.begin() ; cur != path.end(); ++ cur ) {\n\t    const name_component_t&comp = *cur;\n\t    res.push_back( eval_path_component(des,scope,comp,path_error_flag) );\n      }\n#if 0\n      if (path_error_flag) {\n\t    cerr << \"XXXXX: Errors evaluating path \" << path << endl;\n      }\n#endif\n      return res;\n}\n\n/*\n * Human readable version of op. Used in elaboration error messages.\n */\nconst char *human_readable_op(const char op, bool unary)\n{\n\tconst char *type;\n\tswitch (op) {\n\t    case '~': type = \"~\";  break;  // Negation\n\n\t    case '+': type = \"+\";  break;\n\t    case '-': type = \"-\";  break;\n\t    case '*': type = \"*\";  break;\n\t    case '/': type = \"/\";  break;\n\t    case '%': type = \"%\";  break;\n\n\t    case '<': type = \"<\";  break;\n\t    case '>': type = \">\";  break;\n\t    case 'L': type = \"<=\"; break;\n\t    case 'G': type = \">=\"; break;\n\n\t    case '^': type = \"^\";  break;  // XOR\n\t    case 'X': type = \"~^\"; break;  // XNOR\n\t    case '&': type = \"&\";  break;  // Bitwise AND\n\t    case 'A': type = \"~&\"; break;  // NAND (~&)\n\t    case '|': type = \"|\";  break;  // Bitwise OR\n\t    case 'O': type = \"~|\"; break;  // NOR\n\n\t    case '!': type = \"!\"; break;    // Logical NOT\n\t    case 'a': type = \"&&\"; break;   // Logical AND\n\t    case 'o': type = \"||\"; break;   // Logical OR\n\t    case 'q': type = \"->\"; break;   // Logical implication\n\t    case 'Q': type = \"<->\"; break;  // Logical equivalence\n\n\t    case 'e': type = \"==\";  break;\n\t    case 'n': type = \"!=\";  break;\n\t    case 'E': type = \"===\"; break;  // Case equality\n\t    case 'N':\n\t\tif (unary) type = \"~|\";     // NOR\n\t\telse type = \"!==\";          // Case inequality\n\t\tbreak;\n\t    case 'w': type = \"==?\"; break;  // Wild equality\n\t    case 'W': type = \"!=?\"; break;  // Wild inequality\n\n\t    case 'l': type = \"<<(<)\"; break;  // Left shifts\n\t    case 'r': type = \">>\";    break;  // Logical right shift\n\t    case 'R': type = \">>>\";   break;  // Arithmetic right shift\n\n\t    case 'p': type = \"**\"; break; // Power\n\n\t    case 'i':\n\t    case 'I': type = \"++\"; break; /* increment */\n\t    case 'd':\n\t    case 'D': type = \"--\"; break; /* decrement */\n\n\t    default:\n\t      type = \"???\";\n\t      assert(0);\n\t}\n\treturn type;\n}\n\nconst_bool const_logical(const NetExpr*expr)\n{\n      switch (expr->expr_type()) {\n\t  case IVL_VT_REAL: {\n\t    const NetECReal*val = dynamic_cast<const NetECReal*> (expr);\n\t    if (val == 0) return C_NON;\n\t    if (val->value().as_double() == 0.0) return C_0;\n\t    else return C_1;\n\t  }\n\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC: {\n\t    const NetEConst*val = dynamic_cast<const NetEConst*> (expr);\n\t    if (val == 0) return C_NON;\n\t    verinum cval = val->value();\n\t    const_bool res = C_0;\n\t    for (unsigned idx = 0; idx < cval.len(); idx += 1) {\n\t\t  switch (cval.get(idx)) {\n\t\t      case verinum::V1:\n\t\t\treturn C_1;\n\t\t\tbreak;\n\n\t\t      case verinum::V0:\n\t\t\tbreak;\n\n\t\t      default:\n\t\t\tif (res == C_0) res = C_X;\n\t\t\tbreak;\n\t\t  }\n\t    }\n\t    return res;\n\t  }\n\n\t  default:\n\t    break;\n      }\n\n      return C_NON;\n}\n\nuint64_t get_scaled_time_from_real(Design*des, NetScope*scope, NetECReal*val)\n{\n      verireal fn = val->value();\n\n      int shift = scope->time_unit() - scope->time_precision();\n      ivl_assert(*scope, shift >= 0);\n      int64_t delay = fn.as_long64(shift);\n\n\n      shift = scope->time_precision() - des->get_precision();\n      ivl_assert(*scope, shift >= 0);\n      for (int lp = 0; lp < shift; lp += 1) delay *= 10;\n\n      return delay;\n}\n\n/*\n * This function looks at the NetNet signal to see if there are any\n * NetPartSelect::PV nodes driving this signal. If so, See if they can\n * be collapsed into a single concatenation.\n */\nvoid collapse_partselect_pv_to_concat(Design*des, NetNet*sig)\n{\n      NetScope*scope = sig->scope();\n      vector<NetPartSelect*> ps_map (sig->vector_width());\n\n      Nexus*nex = sig->pin(0).nexus();\n\n      for (Link*cur = nex->first_nlink(); cur ; cur = cur->next_nlink()) {\n\t    NetPins*obj;\n\t    unsigned obj_pin;\n\t    cur->cur_link(obj, obj_pin);\n\n\t      // Look for NetPartSelect devices, where this signal is\n\t      // connected to pin 1 of a NetPartSelect::PV.\n\t    NetPartSelect*ps_obj = dynamic_cast<NetPartSelect*> (obj);\n\t    if (ps_obj == 0)\n\t\t  continue;\n\t    if (ps_obj->dir() != NetPartSelect::PV)\n\t\t  continue;\n\t    if (obj_pin != 1)\n\t\t  continue;\n\n\t      // Don't support overrun selects here.\n\t    if (ps_obj->base()+ps_obj->width() > ps_map.size())\n\t\t  continue;\n\n\t    ivl_assert(*ps_obj, ps_obj->base() < ps_map.size());\n\t    ps_map[ps_obj->base()] = ps_obj;\n      }\n\n\t// Check the collected NetPartSelect::PV objects to see if\n\t// they cover the vector.\n      unsigned idx = 0;\n      unsigned device_count = 0;\n      while (idx < ps_map.size()) {\n\t    NetPartSelect*ps_obj = ps_map[idx];\n\t    if (ps_obj == 0)\n\t\t  return;\n\n\t    idx += ps_obj->width();\n\t    device_count += 1;\n      }\n\n      ivl_assert(*sig, idx == ps_map.size());\n\n\t/* The vlog95 and possibly other code generators do not want\n\t * to have a group of part selects turned into a transparent\n\t * concatenation. */\n      if (disable_concatz_generation) {\n// HERE: If the part selects have matching strengths then we can use\n//       a normal concat with a buf-Z after if the strengths are not\n//       both strong. We would ideally delete any buf-Z driving the\n//       concat, but that is not required for the vlog95 generator.\n\t    return;\n      }\n\n\t// Ah HAH! The NetPartSelect::PV objects exactly cover the\n\t// target signal. We can replace all of them with a single\n\t// concatenation.\n\n      if (debug_elaborate) {\n\t    cerr << sig->get_fileline() << \": debug: \"\n\t\t << \"Collapse \" << device_count\n\t\t << \" NetPartSelect::PV devices into a concatenation.\" << endl;\n      }\n\n      NetConcat*cat = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t    ps_map.size(), device_count,\n\t\t\t\t    true);\n      des->add_node(cat);\n      cat->set_line(*sig);\n\n      connect(cat->pin(0), sig->pin(0));\n\n      idx = 0;\n      unsigned concat_position = 1;\n      while (idx < ps_map.size()) {\n\t    assert(ps_map[idx]);\n\t    NetPartSelect*ps_obj = ps_map[idx];\n\t    connect(cat->pin(concat_position), ps_obj->pin(0));\n\t    concat_position += 1;\n\t    idx += ps_obj->width();\n\t    delete ps_obj;\n      }\n}\n\n/*\n * Evaluate the prefix indices. All but the final index in a\n * chain of indices must be a single value and must evaluate\n * to constants at compile time. For example:\n *    [x]          - OK\n *    [1][2][x]    - OK\n *    [1][x:y]     - OK\n *    [2:0][x]     - BAD\n *    [y][x]       - BAD\n * Leave the last index for special handling.\n */\nbool evaluate_index_prefix(Design*des, NetScope*scope,\n\t\t\t   list<long>&prefix_indices,\n\t\t\t   const list<index_component_t>&indices)\n{\n      list<index_component_t>::const_iterator icur = indices.begin();\n      for (size_t idx = 0 ; (idx+1) < indices.size() ; idx += 1, ++icur) {\n\t    assert(icur != indices.end());\n\t    if (icur->sel != index_component_t::SEL_BIT) {\n\t\t  cerr << icur->msb->get_fileline() << \": error: \"\n\t\t\t\"All but the final index in a chain of indices must be \"\n\t\t\t\"a single value, not a range.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    NetExpr*texpr = elab_and_eval(des, scope, icur->msb, -1, true);\n\n\t    long tmp;\n\t    if (texpr == 0 || !eval_as_long(tmp, texpr)) {\n\t\t  cerr << icur->msb->get_fileline() << \": error: \"\n\t\t\t\"Array index expressions must be constant here.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\n\t    prefix_indices.push_back(tmp);\n\t    delete texpr;\n      }\n\n      return true;\n}\n\n/*\n * Evaluate the indices. The chain of indices are applied to the\n * packed indices of a NetNet to generate a canonical expression to\n * replace the exprs.\n */\nNetExpr*collapse_array_exprs(Design*des, NetScope*scope,\n\t\t\t     const LineInfo*loc, NetNet*net,\n\t\t\t     const list<index_component_t>&indices)\n{\n\t// First elaborate all the expressions as far as possible.\n      list<NetExpr*> exprs;\n      list<long> exprs_const;\n      indices_flags flags;\n      indices_to_expressions(des, scope, loc, indices,\n                             net->packed_dimensions(),\n                             false, flags, exprs, exprs_const);\n      ivl_assert(*loc, exprs.size() == net->packed_dimensions());\n\n\t// Special Case: there is only 1 packed dimension, so the\n\t// single expression should already be naturally canonical.\n      if (net->slice_width(1) == 1) {\n\t    return *exprs.begin();\n      }\n\n      const netranges_t&pdims = net->packed_dims();\n      netranges_t::const_iterator pcur = pdims.begin();\n\n      list<NetExpr*>::iterator ecur = exprs.begin();\n      NetExpr* base = 0;\n      for (size_t idx = 0 ; idx < net->packed_dimensions() ; idx += 1, ++pcur, ++ecur) {\n\t    unsigned cur_slice_width = net->slice_width(idx+1);\n\t    long lsb = pcur->get_lsb();\n\t    long msb = pcur->get_msb();\n\t      // This normalizes the expression of this index based on\n\t      // the msb/lsb values.\n\t    NetExpr*tmp = normalize_variable_base(*ecur, msb, lsb,\n\t\t\t\t\t\t  cur_slice_width, msb > lsb);\n\n\t      // If this slice has width, then scale it.\n\t    if (net->slice_width(idx+1) != 1) {\n\t\t  unsigned min_wid = tmp->expr_width();\n\t\t  if (num_bits(cur_slice_width) >= min_wid) {\n\t\t\tmin_wid = num_bits(cur_slice_width)+1;\n\t\t\ttmp = pad_to_width(tmp, min_wid, *loc);\n\t\t  }\n\n\t\t  tmp = make_mult_expr(tmp, cur_slice_width);\n\t    }\n\n\t      // Now add it to the position we've accumulated so far.\n\t    if (base) {\n\t\t  base = make_add_expr(loc, base, tmp);\n\t    } else {\n\t\t  base = tmp;\n\t    }\n      }\n\n      return base;\n}\n\n/*\n * Given a list of indices, treat them as packed indices and convert\n * them to an expression that normalizes the list to a single index\n * expression over a canonical equivalent 1-dimensional array.\n */\nNetExpr*collapse_array_indices(Design*des, NetScope*scope, NetNet*net,\n\t\t\t       const list<index_component_t>&indices)\n{\n      list<long>prefix_indices;\n      bool rc = evaluate_index_prefix(des, scope, prefix_indices, indices);\n      assert(rc);\n\n      const index_component_t&back_index = indices.back();\n      assert(back_index.sel == index_component_t::SEL_BIT);\n      assert(back_index.msb && !back_index.lsb);\n\n      NetExpr*base = elab_and_eval(des, scope, back_index.msb, -1, true);\n\n      NetExpr*res = normalize_variable_bit_base(prefix_indices, base, net);\n\n      eval_expr(res, -1);\n      return res;\n}\n\n\nstatic void assign_unpacked_with_bufz_dim(Design *des, NetScope *scope,\n\t\t\t\t\t  const LineInfo *loc,\n\t\t\t\t\t  NetNet *lval, NetNet *rval,\n\t\t\t\t\t  const std::vector<long> &stride,\n\t\t\t\t\t  unsigned int dim = 0,\n\t\t\t\t\t  unsigned int idx_l = 0,\n\t\t\t\t\t  unsigned int idx_r = 0)\n{\n      int inc_l, inc_r;\n      bool up_l, up_r;\n\n      const auto &l_dims = lval->unpacked_dims();\n      const auto &r_dims = rval->unpacked_dims();\n\n      up_l = l_dims[dim].get_msb() < l_dims[dim].get_lsb();\n      up_r = r_dims[dim].get_msb() < r_dims[dim].get_lsb();\n\n      inc_l = inc_r = stride[dim];\n\n      /*\n       * Arrays dimensions get connected left-to-right. This means if the\n       * left-to-right order differs for a particular dimension between the two\n       * arrays the elements for that dimension will get connected in reverse\n       * order.\n       */\n\n      if (!up_l) {\n\t    /* Go to the last element and count down */\n\t    idx_l += inc_l * (l_dims[dim].width() - 1);\n\t    inc_l = -inc_l;\n      }\n\n      if (!up_r) {\n\t    /* Go to the last element and count down */\n\t    idx_r += inc_r * (r_dims[dim].width() - 1);\n\t    inc_r = -inc_r;\n      }\n\n      for (unsigned int idx = 0; idx < l_dims[dim].width(); idx++) {\n\t    if (dim == l_dims.size() - 1) {\n\t\t  NetBUFZ *driver = new NetBUFZ(scope, scope->local_symbol(),\n\t\t\t\t\t\tlval->vector_width(), false);\n\t\t  driver->set_line(*loc);\n\t\t  des->add_node(driver);\n\n\t\t  connect(lval->pin(idx_l), driver->pin(0));\n\t\t  connect(driver->pin(1), rval->pin(idx_r));\n\t    } else {\n\t\t  assign_unpacked_with_bufz_dim(des, scope, loc, lval, rval,\n\t\t\t\t\t\tstride, dim + 1, idx_l, idx_r);\n\t    }\n\n\t    idx_l += inc_l;\n\t    idx_r += inc_r;\n      }\n}\n\nvoid assign_unpacked_with_bufz(Design*des, NetScope*scope,\n\t\t\t       const LineInfo*loc,\n\t\t\t       NetNet*lval, NetNet*rval)\n{\n      ivl_assert(*loc, lval->pin_count()==rval->pin_count());\n\n      const auto &dims = lval->unpacked_dims();\n      vector<long> stride(dims.size());\n\n      make_strides(dims, stride);\n      assign_unpacked_with_bufz_dim(des, scope, loc, lval, rval, stride);\n}\n\n/*\n * synthesis sometimes needs to unpack assignment to a part\n * select. That looks like this:\n *\n *    foo[N] <= <expr> ;\n *\n * The NetAssignBase::synth_async() method will turn that into a\n * netlist like this:\n *\n *   NetAssignBase(PV) --> base()==<N>\n *    (0)      (1)\n *     |        |\n *     v        v\n *   <expr>    foo\n *\n * This search will return a pointer to the NetAssignBase(PV) object,\n * but only if it matches this pattern.\n */\nNetPartSelect* detect_partselect_lval(Link&pin)\n{\n      NetPartSelect*found_ps = 0;\n\n      Nexus*nex = pin.nexus();\n      for (Link*cur = nex->first_nlink() ; cur ; cur = cur->next_nlink()) {\n\t    NetPins*obj;\n\t    unsigned obj_pin;\n\t    cur->cur_link(obj, obj_pin);\n\n\t      // Skip NexusSet objects.\n\t    if (obj == 0)\n\t\t  continue;\n\n\t      // NetNet pins have no effect on this search.\n\t    if (dynamic_cast<NetNet*> (obj))\n\t\t  continue;\n\n\t    if (NetPartSelect*ps = dynamic_cast<NetPartSelect*> (obj)) {\n\n\t\t    // If this is the input side of a NetPartSelect, skip.\n\t\t  if (ps->pin(obj_pin).get_dir()==Link::INPUT)\n\t\t\tcontinue;\n\n\t\t    // Oops, driven by the wrong size of a\n\t\t    // NetPartSelect, so this is not going to work out.\n\t\t  if (ps->dir()==NetPartSelect::VP)\n\t\t\treturn 0;\n\n\t\t    // So now we know this is a NetPartSelect::PV. It\n\t\t    // is a candidate for our part-select assign. If\n\t\t    // we already have a candidate, then give up.\n\t\t  if (found_ps)\n\t\t\treturn 0;\n\n\t\t    // This is our candidate. Carry on.\n\t\t  found_ps = ps;\n\t\t  continue;\n\n\t    }\n\n\t      // If this is a driver to the Nexus that is not a\n\t      // NetPartSelect device. This cannot happen to\n\t      // part selected lval nets, so quit now.\n\t    if (obj->pin(obj_pin).get_dir() == Link::OUTPUT)\n\t\t  return 0;\n\n      }\n\n      return found_ps;\n}\n\nconst netclass_t* find_class_containing_scope(const LineInfo&loc, const NetScope*scope)\n{\n      while (scope && scope->type() != NetScope::CLASS)\n\t    scope = scope->parent();\n\n      if (scope == 0)\n\t    return 0;\n\n      const netclass_t*found_in = scope->class_def();\n      ivl_assert(loc, found_in);\n      return found_in;\n}\n/*\n * Find the scope that contains this scope, that is the method for a\n * class scope. Look for the scope whose PARENT is the scope for a\n * class. This is going to be a method.\n */\nNetScope* find_method_containing_scope(const LineInfo&, NetScope*scope)\n{\n      NetScope*up = scope->parent();\n\n      while (up && up->type() != NetScope::CLASS) {\n\t    scope = up;\n\t    up = up->parent();\n      }\n\n      if (up == 0) return 0;\n\n\t// Should I check if this scope is a TASK or FUNC?\n\n      return scope;\n}\n\n\n/*\n * Print a warning if we find a mixture of default and explicit timescale\n * based delays in the design, since this is likely an error.\n */\nvoid check_for_inconsistent_delays(NetScope*scope)\n{\n      static bool used_implicit_timescale = false;\n      static bool used_explicit_timescale = false;\n      static bool display_ts_dly_warning = true;\n\n      if (scope->time_from_timescale())\n\t    used_explicit_timescale = true;\n      else\n\t    used_implicit_timescale = true;\n\n      if (display_ts_dly_warning &&\n\t  used_explicit_timescale &&\n\t  used_implicit_timescale) {\n\t    if (gn_system_verilog()) {\n\t\t  cerr << \"warning: Found both default and explicit \"\n\t\t\t  \"timescale based delays. Use\" << endl;\n\t\t  cerr << \"       : -Wtimescale to find the design \"\n\t\t\t  \"element(s) with no explicit\" << endl;\n\t\t  cerr << \"       : timescale.\" << endl;\n\t    } else {\n\t\t  cerr << \"warning: Found both default and \"\n\t\t\t  \"`timescale based delays. Use\" << endl;\n\t\t  cerr << \"       : -Wtimescale to find the \"\n\t\t\t  \"module(s) with no `timescale.\" << endl;\n\t    }\n\t    display_ts_dly_warning = false;\n      }\n}\n\n\n/*\n * Calculate the bit vector range for a parameter, from the type of the\n * parameter. This is expecting that the type is a vector type. The parameter\n * is presumably declared something like this:\n *\n *    parameter [4:1] foo = <value>;\n *\n * In this case, the par_type is a netvector with a single dimension. The\n * par_msv gets 4, and par_lsv get 1. The caller uses these values to\n * interpret things like bit selects.\n */\nbool calculate_param_range(const LineInfo&line, ivl_type_t par_type,\n\t\t\t   long&par_msv, long&par_lsv, long length)\n{\n      const netvector_t*vector_type = dynamic_cast<const netvector_t*> (par_type);\n      if (vector_type == 0) {\n\t    // If the parameter doesn't have an explicit range, then\n\t    // just return range values of [length-1:0].\n\t    par_msv = length-1;\n\t    par_lsv = 0;\n\t    return true;\n      }\n\n      ivl_assert(line, vector_type->packed());\n      const netranges_t& packed_dims = vector_type->packed_dims();\n\n      // This is a netvector_t with 0 dimensions, then the parameter was\n      // declared with a statement like this:\n      //\n      //    parameter signed foo = <value>;\n      //\n      // The netvector_t is just here to carry the signed-ness, which we don't\n      // even need here. So act like the type is defined by the r-value\n      // length.\n      if (packed_dims.size() == 0) {\n\t    par_msv = length-1;\n\t    par_lsv = 0;\n\t    return true;\n      }\n      ivl_assert(line, packed_dims.size() == 1);\n\n      netrange_t use_range = packed_dims[0];\n      par_msv = use_range.get_msb();\n      par_lsv = use_range.get_lsb();\n\n      return true;\n}\n"
        },
        {
          "name": "netmisc.h",
          "type": "blob",
          "size": 18.05859375,
          "content": "#ifndef IVL_netmisc_H\n#define IVL_netmisc_H\n/*\n * Copyright (c) 1999-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netlist.h\"\n\nclass netsarray_t;\n\n/*\n * Search for a hierarchical name. The input path is one or more name\n * components (name_component_t) which describe a path to the object. The\n * simplest case is the path is a single name_component_t. This is the most\n * usual case. More complex cases might include a string of name components\n * that end in an item or scope, like this:\n *\n *   a.b[1].c\n *\n * In this case, the \"path input would include a.b.c, with index expressions\n * on name_component_t for \"b\". In this case, usually \"c\" is the found item\n * and \"a\" and \"b\" are scopes that lead up to the item.\n *\n * The search will stop when it finds a component in the path that is an\n * object of some sort (other then a scope. So for example, if a.b is an\n * array, then the search for a.b[1].c will stop at a.b, leave a.b[1] in\n * path_head, and \"c\" in path_tail. It is up to the caller to then note that\n * \"c\" must be a method of some sort.\n */\nstruct symbol_search_results {\n      inline symbol_search_results() {\n\t    scope = 0;\n\t    net = 0;\n\t    par_val = 0;\n\t    type = 0;\n\t    eve = 0;\n\t    decl_after_use = 0;\n      }\n\n      inline bool is_scope() const {\n\t    if (net) return false;\n\t    if (eve) return false;\n\t    if (par_val) return false;\n\t    if (scope) return true;\n\t    return false;\n      }\n\n      inline bool is_found() const {\n\t    if (net) return true;\n\t    if (eve) return true;\n\t    if (par_val) return true;\n\t    if (scope) return true;\n\t    return false;\n      }\n\n\t// Scope where symbol was located. This is set in all cases,\n\t// assuming the search succeeded.\n      NetScope*scope;\n\t// If this was a net, the signal itself.\n      NetNet*net;\n\t// If this was a parameter, the value expression and the\n\t// optional value dimensions.\n      const NetExpr*par_val;\n      ivl_type_t type;\n\t// If this is a named event, ...\n      NetEvent*eve;\n\t// If a symbol was located but skipped because its lexical position\n\t// is after the lexical position of the name being searched, it is\n\t// stored here. If more than one such symbol is found, the first\n\t// one is retained.\n      const LineInfo*decl_after_use;\n\n        // Store bread crumbs of the search here. The path_tail is the parts\n        // of the original path that were not found, or are after an object\n        // (and so are probably members or methods).\n      pform_name_t path_tail;\n        // The path_head is the parts of the original path that were found.\n        // The last item in path_head is the final name (possibly before the\n        // path_tail items) that identifies the object. This name may contain\n        // index expressions. If the search result is a scope, then this name\n        // is also the name of the scope identified.\n      pform_name_t path_head;\n};\n\n/*\n * Test the search results and return true if this represents a function\n * return value. That will be the case if the object is a net, the scope\n * containing the object is a FUNCtion, and the containing scope and the\n * object have the same name.\n */\nstatic inline bool test_function_return_value(const symbol_search_results&search_results)\n{\n      if (!search_results.net) return false;\n      if (search_results.scope->type()!=NetScope::FUNC) return false;\n      if (search_results.net->name() != search_results.scope->basename()) return false;\n      return true;\n}\n\nextern bool symbol_search(const LineInfo*li, Design*des, NetScope*scope,\n\t\t\t  pform_name_t path, unsigned lexical_pos,\n\t\t\t  struct symbol_search_results*res,\n\t\t\t  NetScope*start_scope = nullptr, bool prefix_scope = false);\n\nextern bool symbol_search(const LineInfo *li, Design *des, NetScope *scope,\n\t\t\t  const pform_scoped_name_t &path, unsigned lexical_pos,\n\t\t\t  struct symbol_search_results*res);\n\n/*\n * This function transforms an expression by either zero or sign extending\n * the high bits until the expression has the desired width. This may mean\n * not transforming the expression at all, if it is already wide enough.\n * The extension method and the returned expression type is determined by\n * signed_flag.\n */\nextern NetExpr*pad_to_width(NetExpr*expr, unsigned wid, bool signed_flag,\n\t\t\t    const LineInfo&info, ivl_type_t use_type = 0);\n/*\n * This version determines the extension method from the base expression type.\n */\ninline NetExpr*pad_to_width(NetExpr*expr, unsigned wid, const LineInfo&info, ivl_type_t use_type = 0)\n{\n      return pad_to_width(expr, wid, expr->has_sign(), info, use_type);\n}\n\n/*\n * This function transforms an expression by either zero or sign extending\n * or discarding the high bits until the expression has the desired width.\n * This may mean not transforming the expression at all, if it is already\n * the correct width. The extension method (if needed) and the returned\n * expression type is determined by signed_flag.\n */\nextern NetExpr*cast_to_width(NetExpr*expr, unsigned wid, bool signed_flag,\n\t\t\t     const LineInfo&info);\n\nextern NetNet*pad_to_width(Design*des, NetNet*n, unsigned w,\n                           const LineInfo&info);\n\nextern NetNet*pad_to_width_signed(Design*des, NetNet*n, unsigned w,\n                                  const LineInfo&info);\n\n/*\n * Generate the nodes necessary to cast an expression (a net) to a\n * real value.\n */\nextern NetNet*cast_to_int4(Design*des, NetScope*scope, NetNet*src, unsigned wid);\nextern NetNet*cast_to_int2(Design*des, NetScope*scope, NetNet*src, unsigned wid);\nextern NetNet*cast_to_real(Design*des, NetScope*scope, NetNet*src);\n\nextern NetExpr*cast_to_int4(NetExpr*expr, unsigned width);\nextern NetExpr*cast_to_int2(NetExpr*expr, unsigned width);\nextern NetExpr*cast_to_real(NetExpr*expr);\n\n/*\n * Take the input expression and return a variation that assures that\n * the expression is 1-bit wide and logical. This reflects the needs\n * of conditions i.e. for \"if\" statements or logical operators.\n */\nextern NetExpr*condition_reduce(NetExpr*expr);\n\n/*\n * This function transforms an expression by cropping the high bits\n * off with a part select. The result has the width w passed in. This\n * function does not pad, use pad_to_width if padding is desired.\n */\nextern NetNet*crop_to_width(Design*des, NetNet*n, unsigned w);\n\nextern bool calculate_part(const LineInfo*li, Design*des, NetScope*scope,\n\t\t\t   const index_component_t&index,\n\t\t\t   long&off, unsigned long&wid);\n\n/*\n * These functions generate an equation to normalize an expression using\n * the provided vector/array information.\n */\nextern NetExpr*normalize_variable_base(NetExpr *base, long msb, long lsb,\n                                       unsigned long wid, bool is_up,\n\t\t\t\t       long slice_off =0);\n\n/*\n * Calculate a canonicalizing expression for a bit select, when the\n * base expression is the last index of an otherwise complete bit\n * select. For example:\n *   reg [3:0][7:0] foo;\n *   ... foo[1][x] ...\n * base is (x) and the generated expression will be (x+8).\n */\nextern NetExpr*normalize_variable_bit_base(const std::list<long>&indices, NetExpr *base,\n\t\t\t\t\t   const NetNet*reg);\n\n/*\n * This is similar to normalize_variable_bit_base, but the tail index\n * it a base and width, instead of a bit. This is used for handling\n * indexed part selects:\n *   reg [3:0][7:0] foo;\n *   ... foo[1][x +: 2]\n * base is (x), wid input is (2), and is_up is (true). The output\n * expression is (x+8).\n */\nextern NetExpr *normalize_variable_part_base(const std::list<long>&indices, NetExpr*base,\n\t\t\t\t\t     const NetNet*reg,\n\t\t\t\t\t     unsigned long wid, bool is_up);\n/*\n * Calculate a canonicalizing expression for a slice select. The\n * indices array is less than needed to fully address a bit, so the\n * result is a slice of the packed array. The return value is an\n * expression that gets to the base of the slice, and (lwid) becomes\n * the width of the slice, in bits. For example:\n *   reg [4:1][7:0] foo\n *   ...foo[x]...\n * base is (x) and the generated expression will be (x*8 - 8), with\n * lwid set to (8).\n */\nextern NetExpr*normalize_variable_slice_base(const std::list<long>&indices, NetExpr *base,\n\t\t\t\t\t     const NetNet*reg, unsigned long&lwid);\n\n/*\n * The as_indices() manipulator is a convenient way to emit a list of\n * index values in the form [<>][<>]....\n */\ntemplate <class TYPE> struct __IndicesManip {\n      explicit inline __IndicesManip(const std::list<TYPE>&v) : val(v) { }\n      const std::list<TYPE>&val;\n};\ntemplate <class TYPE> inline __IndicesManip<TYPE> as_indices(const std::list<TYPE>&indices)\n{ return __IndicesManip<TYPE>(indices); }\n\nextern std::ostream& operator << (std::ostream&o, __IndicesManip<long>);\nextern std::ostream& operator << (std::ostream&o, __IndicesManip<NetExpr*>);\n\n/*\n * Given a list of index expressions, generate elaborated expressions\n * and constant values, if possible.\n */\nstruct indices_flags {\n      bool invalid;    // at least one index failed elaboration\n      bool variable;   // at least one index is a dynamic value\n      bool undefined;  // at least one index is an undefined value\n};\nextern void indices_to_expressions(Design*des, NetScope*scope,\n\t\t\t\t     // loc is for error messages.\n\t\t\t\t   const LineInfo*loc,\n\t\t\t\t     // src is the index list, and count is\n\t\t\t\t     // the number of items in the list to use.\n\t\t\t\t   const std::list<index_component_t>&src, unsigned count,\n\t\t\t\t     // True if the expression MUST be constant.\n\t\t\t\t   bool need_const,\n\t\t\t\t     // These are the outputs.\n\t\t\t\t   indices_flags&flags,\n\t\t\t\t   std::list<NetExpr*>&indices,std::list<long>&indices_const);\n\nextern NetExpr*normalize_variable_unpacked(const NetNet*net, std::list<long>&indices);\nextern NetExpr*normalize_variable_unpacked(const netsarray_t*net, std::list<long>&indices);\n\nextern NetExpr*normalize_variable_unpacked(const NetNet*net, std::list<NetExpr*>&indices);\nextern NetExpr*normalize_variable_unpacked(const LineInfo&loc, const netsarray_t*net, std::list<NetExpr*>&indices);\n\nextern NetExpr*make_canonical_index(Design*des, NetScope*scope,\n\t\t\t\t      // loc for error messages\n\t\t\t\t    const LineInfo*loc,\n\t\t\t\t      // src is the index list\n\t\t\t\t    const std::list<index_component_t>&src,\n\t\t\t\t      // This is the reference type\n\t\t\t\t    const netsarray_t*stype,\n\t\t\t\t      // True if the expression MUST be constant.\n\t\t\t\t    bool need_const);\n\n/*\n * This function takes as input a NetNet signal and adds a constant\n * value to it. If the val is 0, then simply return sig. Otherwise,\n * return a new NetNet value that is the output of an addition.\n *\n * Not currently used.\n */\n#if 0\nextern NetNet*add_to_net(Design*des, NetNet*sig, long val);\n#endif\nextern NetNet*sub_net_from(Design*des, NetScope*scope, long val, NetNet*sig);\n\n/*\n * Make a NetEConst object that contains only X bits.\n */\nextern NetEConst*make_const_x(unsigned long wid);\nextern NetEConst*make_const_0(unsigned long wid);\nextern NetEConst*make_const_val(unsigned long val);\nextern NetEConst*make_const_val_s(long val);\n\n/*\n * Make a const net.\n */\nextern NetNet* make_const_0(Design*des, NetScope*scope, unsigned long wid);\nextern NetNet* make_const_x(Design*des, NetScope*scope, unsigned long wid);\nextern NetNet* make_const_z(Design*des, NetScope*scope, unsigned long wid);\n\n/*\n * In some cases the lval is accessible as a pointer to the head of\n * a list of NetAssign_ objects. This function returns the width of\n * the l-value represented by this list.\n */\nextern unsigned count_lval_width(const class NetAssign_*first);\n\n/*\n * This function elaborates an expression, and tries to evaluate it\n * right away. If the expression can be evaluated, this returns a\n * constant expression. If it cannot be evaluated, it returns whatever\n * it can. If the expression cannot be elaborated, return 0.\n *\n * The context_width is the width of the context where the expression is\n * being elaborated, or -1 if the expression is self-determined, or -2\n * if the expression is lossless self-determined (this last option is\n * treated as standard self-determined if the gn_strict_expr_width flag\n * is set).\n *\n * cast_type allows the expression to be cast to a different type\n * (before it is evaluated). If cast to a vector type, the vector\n * width will be set to the context_width. The default value of\n * IVL_VT_NO_TYPE causes the expression to retain its self-determined\n * type.\n */\nclass PExpr;\n\nextern NetExpr* elab_and_eval(Design*des, NetScope*scope,\n\t\t\t      PExpr*pe, int context_width,\n                              bool need_const =false,\n                              bool annotatable =false,\n\t\t\t      ivl_variable_type_t cast_type =IVL_VT_NO_TYPE,\n\t\t\t      bool force_unsigned =false);\n\n/*\n * This form of elab_and_eval uses the ivl_type_t to carry type\n * information instead of the piecemeal form. We should transition to\n * this form as we reasonably can.\n */\nextern NetExpr* elab_and_eval(Design*des, NetScope*scope,\n\t\t\t      PExpr*expr, ivl_type_t lv_net_type,\n\t\t\t      bool need_const);\n\n/*\n * This function is a variant of elab_and_eval that elaborates and\n * evaluates the arguments of a system task.\n */\nextern NetExpr* elab_sys_task_arg(Design*des, NetScope*scope,\n                                  perm_string name, unsigned arg_idx,\n                                  PExpr*pe, bool need_const =false);\n/*\n * This function elaborates an expression as if it is for the r-value\n * of an assignment, The lv_type and lv_width are the type and width\n * of the l-value, and the expr is the expression to elaborate. The\n * result is the NetExpr elaborated and evaluated. (See elab_expr.cc)\n *\n * I would rather that all calls to elaborate_rval_expr use the\n * lv_net_type argument to express the l-value type, but, for now,\n * that it not possible. Those cases will be indicated by the\n * lv_net_type being set to nil.\n */\nextern NetExpr* elaborate_rval_expr(Design*des, NetScope*scope,\n\t\t\t\t    ivl_type_t lv_net_type,\n\t\t\t\t    ivl_variable_type_t lv_type,\n\t\t\t\t    unsigned lv_width, PExpr*expr,\n\t\t\t\t    bool need_const =false,\n\t\t\t\t    bool force_unsigned =false);\n/*\n * Same as above, but lv_width and lv_type are derived from the lv_net_type.\n */\nextern NetExpr* elaborate_rval_expr(Design *des, NetScope *scope,\n\t\t\t\t    ivl_type_t lv_net_type, PExpr *expr,\n\t\t\t\t    bool need_const = false,\n\t\t\t\t    bool force_unsigned = false);\n\nextern bool evaluate_range(Design*des, NetScope*scope, const LineInfo*li,\n                           const pform_range_t&range,\n                           long&index_l, long&index_r);\n\nextern bool evaluate_ranges(Design*des, NetScope*scope, const LineInfo*li,\n\t\t\t    netranges_t&llist,\n\t\t\t    const std::list<pform_range_t>&rlist);\n/*\n * This procedure evaluates an expression and if the evaluation is\n * successful the original expression is replaced with the new one.\n */\nvoid eval_expr(NetExpr*&expr, int context_width =-1);\n\n/*\n * Get the long integer value for the passed in expression, if\n * possible. If it is not possible (the expression is not evaluated\n * down to a constant) then return false and leave value unchanged.\n */\nbool eval_as_long(long&value, const NetExpr*expr);\nbool eval_as_double(double&value, NetExpr*expr);\n\n/*\n * Evaluate an entire scope path in the context of the given scope.\n */\nextern std::list<hname_t> eval_scope_path(Design*des, NetScope*scope,\n\t\t\t\t\t  const pform_name_t&path);\nextern hname_t eval_path_component(Design*des, NetScope*scope,\n\t\t\t\t   const name_component_t&comp,\n\t\t\t\t   bool&error_flag);\n\n/*\n * If this scope is contained within a class scope (i.e. a method of a\n * class) then return the class definition that contains it.\n */\nextern const netclass_t*find_class_containing_scope(const LineInfo&loc,const NetScope*scope);\nextern NetScope* find_method_containing_scope(const LineInfo&log, NetScope*scope);\n\n/*\n * Return true if the data type is a type that is normally available\n * in vector for. IVL_VT_BOOL and IVL_VT_LOGIC are vectorable,\n * IVL_VT_REAL is not.\n */\nextern bool type_is_vectorable(ivl_variable_type_t type);\n\n/*\n * Return a human readable version of the operator.\n */\nconst char *human_readable_op(const char op, bool unary = false);\n\n/*\n * Is the expression a constant value and if so what is its logical\n * value.\n *\n * C_NON - the expression is not a constant value.\n * C_0   - the expression is constant and it has a false value.\n * C_1   - the expression is constant and it has a true value.\n * C_X   - the expression is constant and it has an 'bX value.\n */\nenum const_bool { C_NON, C_0, C_1, C_X };\nconst_bool const_logical(const NetExpr*expr);\n\n/*\n * When scaling a real value to a time we need to do some standard\n * processing.\n */\nextern uint64_t get_scaled_time_from_real(Design*des,\n                                          NetScope*scope,\n                                          NetECReal*val);\n\nextern void collapse_partselect_pv_to_concat(Design*des, NetNet*sig);\n\nextern bool evaluate_index_prefix(Design*des, NetScope*scope,\n\t\t\t\t  std::list<long>&prefix_indices,\n\t\t\t\t  const std::list<index_component_t>&indices);\n\nextern NetExpr*collapse_array_indices(Design*des, NetScope*scope, NetNet*net,\n\t\t\t\t      const std::list<index_component_t>&indices);\n\nextern NetExpr*collapse_array_exprs(Design*des, NetScope*scope,\n\t\t\t\t    const LineInfo*loc, NetNet*net,\n\t\t\t\t    const std::list<index_component_t>&indices);\n\nextern void assign_unpacked_with_bufz(Design*des, NetScope*scope,\n\t\t\t\t      const LineInfo*loc,\n\t\t\t\t      NetNet*lval, NetNet*rval);\n\nextern NetPartSelect* detect_partselect_lval(Link&pin);\n\n/*\n * Print a warning if we find a mixture of default and explicit timescale\n * based delays in the design, since this is likely an error.\n */\nextern void check_for_inconsistent_delays(NetScope*scope);\n\n#endif /* IVL_netmisc_H */\n"
        },
        {
          "name": "netparray.cc",
          "type": "blob",
          "size": 2.4326171875,
          "content": "/*\n * Copyright (c) 2012 Picture Elements, Inc.\n *    Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netparray.h\"\n\nusing namespace std;\n\nnetsarray_t::~netsarray_t()\n{\n}\n\nnetparray_t::~netparray_t()\n{\n}\n\n/*\n * The packed width of a packed array is the packed width of the\n * element times the dimension width of the array itself.\n */\n\nbool netparray_t::packed(void) const\n{\n      return true;\n}\n\nlong netparray_t::packed_width(void) const\n{\n      return netrange_width(static_dimensions(),\n\t\t\t    element_type()->packed_width());\n}\n\nnetranges_t netparray_t::slice_dimensions() const\n{\n      const netranges_t&packed_dims = static_dimensions();\n\n      netranges_t elem_dims = element_type()->slice_dimensions();\n\n      netranges_t res (packed_dims.size() + elem_dims.size());\n\n      for (size_t idx = 0 ; idx < packed_dims.size() ; idx += 1)\n\t    res[idx] = packed_dims[idx];\n      for (size_t idx = 0 ; idx < elem_dims.size() ; idx += 1)\n\t    res[idx+packed_dims.size()] = elem_dims[idx];\n\n      return res;\n}\n\nbool netparray_t::test_compatibility(ivl_type_t that) const\n{\n      return packed_type_compatible(that);\n}\n\nbool netparray_t::test_equivalence(ivl_type_t that) const\n{\n      return packed_types_equivalent(this, that);\n}\n\nnetuarray_t::~netuarray_t()\n{\n}\n\nnetranges_t netuarray_t::slice_dimensions() const\n{\n      return static_dimensions();\n}\n\nbool netuarray_t::test_equivalence(ivl_type_t that) const\n{\n      const netuarray_t *that_a = dynamic_cast<const netuarray_t *>(that);\n      if (!that_a)\n\t    return false;\n\n      if (!netrange_equivalent(static_dimensions(), that_a->static_dimensions()))\n\t    return false;\n\n      return element_type()->type_equivalent(that_a->element_type());\n}\n"
        },
        {
          "name": "netparray.h",
          "type": "blob",
          "size": 2.58203125,
          "content": "#ifndef IVL_netarray_H\n#define IVL_netarray_H\n/*\n * Copyright (c) 2012-2014 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2012 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA\n */\n\n# include  \"nettypes.h\"\n# include  <vector>\n\n/*\n * Arrays with static dimensions (packed and unpacked) share this\n * common base type.\n */\nclass netsarray_t : public netarray_t {\n\n    public:\n      explicit netsarray_t(const netranges_t&packed, ivl_type_t etype);\n      ~netsarray_t();\n\n    public:\n\t// Virtual methods from the ivl_type_s type...\n\n    public:\n      inline const netranges_t& static_dimensions() const\n      { return dims_; }\n\n    private:\n      netranges_t dims_;\n\n};\n\ninline netsarray_t::netsarray_t(const netranges_t&pd, ivl_type_t etype)\n: netarray_t(etype), dims_(pd)\n{\n}\n\n/*\n * Packed arrays.\n */\nclass netparray_t : public netsarray_t {\n\n    public:\n      explicit netparray_t(const netranges_t&packed, ivl_type_t etype);\n      ~netparray_t();\n\n    public:\n\t// Virtual methods from the ivl_type_s type...\n      bool packed(void) const;\n      long packed_width(void) const;\n      netranges_t slice_dimensions() const;\n\n    private:\n      bool test_compatibility(ivl_type_t that) const;\n      bool test_equivalence(ivl_type_t that) const;\n};\n\ninline netparray_t::netparray_t(const netranges_t&pd, ivl_type_t etype)\n: netsarray_t(pd, etype)\n{\n}\n\n/*\n * Unpacked arrays are very similar, but lack packed slices.\n */\nclass netuarray_t : public netsarray_t {\n\n    public:\n      explicit netuarray_t(const netranges_t&packed, ivl_type_t etype);\n      ~netuarray_t();\n\n    public:\n\t// Virtual methods from the ivl_type_s type...\n      netranges_t slice_dimensions() const;\n\n    private:\n      bool test_equivalence(ivl_type_t that) const;\n};\n\ninline netuarray_t::netuarray_t(const netranges_t&pd, ivl_type_t etype)\n: netsarray_t(pd, etype)\n{\n}\n\n#endif /* IVL_netarray_H */\n"
        },
        {
          "name": "netqueue.cc",
          "type": "blob",
          "size": 1.10546875,
          "content": "/*\n * Copyright (c) 2014-2020 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netqueue.h\"\n# include  <iostream>\n\nusing namespace std;\n\nnetqueue_t::netqueue_t(ivl_type_t vec, long max_idx)\n: netdarray_t(vec), max_idx_(max_idx)\n{\n}\n\nnetqueue_t::~netqueue_t()\n{\n}\n\nivl_variable_type_t netqueue_t::base_type() const\n{\n      return IVL_VT_QUEUE;\n}\n"
        },
        {
          "name": "netqueue.h",
          "type": "blob",
          "size": 1.5966796875,
          "content": "#ifndef IVL__netqueue_H\n#define IVL__netqueue_H\n/*\n * Copyright (c) 2014-2020 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netdarray.h\"\n# include  \"ivl_target.h\"\n\n/*\n * A queue type is actually a dynamic array with a few extra\n * methods. This will probably result in a different implementation at\n * run-time, but for the most part this applies during elaboration.\n */\nclass netqueue_t : public netdarray_t {\n\n    public:\n      explicit netqueue_t(ivl_type_t vec, long max_idx);\n      ~netqueue_t();\n\n\t// This is the \"base_type()\" virtual method of the\n\t// nettype_base_t. The ivl_target api expects this to return\n\t// IVL_VT_QUEUE for queues.\n      ivl_variable_type_t base_type() const;\n\n      long max_idx(void) const { return max_idx_; }\n\n      std::ostream& debug_dump(std::ostream&) const;\n\n    private:\n      long max_idx_;\n};\n\n#endif\n"
        },
        {
          "name": "netscalar.cc",
          "type": "blob",
          "size": 1.2021484375,
          "content": "/*\n * Copyright (c) 2013 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netscalar.h\"\n\nusing namespace std;\n\nnetreal_t netreal_t::type_real;\nnetreal_t netreal_t::type_shortreal;\nnetstring_t netstring_t::type_string;\n\nnetreal_t::~netreal_t()\n{\n}\n\nivl_variable_type_t netreal_t::base_type() const\n{\n      return IVL_VT_REAL;\n}\n\nnetstring_t::~netstring_t()\n{\n}\n\nivl_variable_type_t netstring_t::base_type() const\n{\n      return IVL_VT_STRING;\n}\n"
        },
        {
          "name": "netscalar.h",
          "type": "blob",
          "size": 1.58203125,
          "content": "#ifndef IVL_netscalar_H\n#define IVL_netscalar_H\n/*\n * Copyright (c) 2013-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"nettypes.h\"\n\nclass netreal_t : public ivl_type_s {\n\n    public:\n      inline explicit netreal_t() { }\n      ~netreal_t();\n\n      ivl_variable_type_t base_type() const;\n      bool get_signed() const { return true; }\n      bool get_scalar() const { return true; }\n\n      std::ostream& debug_dump(std::ostream&) const;\n\n    public:\n      static netreal_t type_real;\n      static netreal_t type_shortreal;\n};\n\nclass netstring_t : public ivl_type_s {\n\n    public:\n      inline explicit netstring_t() { }\n      ~netstring_t();\n\n      ivl_variable_type_t base_type() const;\n\n      std::ostream& debug_dump(std::ostream&) const;\n\n    public:\n      static netstring_t type_string;\n};\n\n#endif /* IVL_netscalar_H */\n"
        },
        {
          "name": "netstruct.cc",
          "type": "blob",
          "size": 4.06640625,
          "content": "/*\n * Copyright (c) 2011-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netlist.h\"\n# include  \"netstruct.h\"\n# include  \"netvector.h\"\n# include  <iostream>\n\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nnetstruct_t::netstruct_t()\n: union_(false), packed_(false), signed_(false)\n{\n}\n\nnetstruct_t::~netstruct_t()\n{\n}\n\nvoid netstruct_t::union_flag(bool flag)\n{\n\t// This MUST be called before any members are pushed into the\n\t// definition. This is because the append relies on this flag\n\t// being accurate.\n      ivl_assert(*this, members_.empty());\n      union_ = flag;\n}\n\nvoid netstruct_t::packed(bool flag)\n{\n      ivl_assert(*this, members_.empty());\n      packed_ = flag;\n}\n\nvoid netstruct_t::append_member(Design*des, const netstruct_t::member_t&val)\n{\n      ivl_assert(*this, val.net_type);\n\n      members_.push_back(val);\n      if (packed_) {\n\t    if (! members_.back().net_type->packed()) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Member \" << members_.back().name\n\t\t       << \" of packed struct/union\"\n\t\t       << \" must be packed.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n      if (union_ && packed_ && members_.size() > 1) {\n\t    unsigned long expect_wid = members_.front().net_type->packed_width();\n\t    unsigned long got_wid = members_.back().net_type->packed_width();\n\t    if (expect_wid != got_wid) {\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Member \" << val.name\n\t\t       << \" of packed union\"\n\t\t       << \" is \" << got_wid\n\t\t       << \" bits, expecting \" << expect_wid << \" bits.\" << endl;\n\t\t  des->errors += 1;\n\t    }\n      }\n}\n\nconst netstruct_t::member_t* netstruct_t::packed_member(perm_string name, unsigned long&off) const\n{\n      unsigned long count_off = 0;\n      for (size_t idx = members_.size() ; idx > 0 ; idx -= 1) {\n\t    if (members_[idx-1].name == name) {\n\t\t  off = count_off;\n\t\t  return &members_[idx-1];\n\t    }\n\t      // If this is not a union, then the members are lined up\n\t      // from LSB to MSB.  If this is a union, then all\n\t      // members are at offset 0.\n\t    if (!union_)\n\t\t  count_off += members_[idx-1].net_type->packed_width();\n      }\n\n      return 0;\n}\n\nlong netstruct_t::packed_width(void) const\n{\n      if (! packed_)\n\t    return -1;\n\n\t// If this is a packed union, then all the members are the\n\t// same width, so it is sufficient to return the width of any\n\t// single member.\n      if (union_)\n\t    return members_.front().net_type->packed_width();\n\n\t// The width of a packed struct is the sum of member widths.\n      long res = 0;\n      for (size_t idx = 0 ; idx < members_.size() ; idx += 1)\n\t    res += members_[idx].net_type->packed_width();\n\n      return res;\n}\n\nnetranges_t netstruct_t::slice_dimensions() const\n{\n      netranges_t tmp;\n      tmp .push_back(netrange_t(packed_width()-1, 0));\n      return tmp;\n}\n\nivl_variable_type_t netstruct_t::base_type() const\n{\n      if (! packed_)\n\t    return IVL_VT_NO_TYPE;\n\n      for (size_t idx = 0 ;  idx < members_.size() ; idx += 1) {\n\t    if (members_[idx].data_type() != IVL_VT_BOOL)\n\t\t  return members_[idx].data_type();\n      }\n\n      return IVL_VT_BOOL;\n}\n\nbool netstruct_t::test_compatibility(ivl_type_t that) const\n{\n      return packed_type_compatible(that);\n}\n\nbool netstruct_t::test_equivalence(ivl_type_t that) const\n{\n      if (!packed_)\n\t    return this == that;\n\n      return packed_types_equivalent(this, that);\n}\n"
        },
        {
          "name": "netstruct.h",
          "type": "blob",
          "size": 3.0869140625,
          "content": "#ifndef IVL_netstruct_H\n#define IVL_netstruct_H\n/*\n * Copyright (c) 2011-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"LineInfo.h\"\n# include  <vector>\n# include  \"ivl_target.h\"\n# include  \"nettypes.h\"\n\nclass Design;\n\nclass netstruct_t : public LineInfo, public ivl_type_s {\n\n    public:\n      struct member_t {\n\t    perm_string name;\n\t    ivl_type_t net_type;\n\t    inline ivl_variable_type_t data_type() const\n\t    { return net_type->base_type(); };\n\t    bool get_signed() const\n\t    { return net_type->get_signed(); }\n      };\n\n    public:\n      netstruct_t();\n      ~netstruct_t();\n\n\t// If this is a union (instead of struct) then this flag is\n\t// set. We handle union and struct together because they are\n\t// so similar.\n      void union_flag(bool);\n      bool union_flag(void) const;\n\n      void packed(bool flag);\n      bool packed(void) const;\n\n        // When the struct is accessed as a primary it can be signed or unsigned\n      void set_signed(bool flag) { signed_ = flag; }\n      bool get_signed(void) const { return signed_; }\n\n\t// Append a new member to the struct/union. This must be done\n\t// after the union_flag and packed settings are set. This\n\t// function does error checking, and the \"des\" argument is\n\t// only present so that it can set error flags.\n      void append_member(Design*des, const member_t&);\n\n\t// Given the name of a member, return a pointer to the member\n\t// description, and set the off value to be the offset into\n\t// the packed value where the member begins.\n      const struct member_t* packed_member(perm_string name, unsigned long&off) const;\n      const std::vector<member_t>& members() const { return members_; }\n\n\t// Return the width (in bits) of the packed record, or -1 if\n\t// the record is not packed.\n      long packed_width() const;\n      netranges_t slice_dimensions() const;\n\n\t// Return the base type of the packed record, or\n\t// IVL_VT_NO_TYPE if the record is not packed.\n      ivl_variable_type_t base_type() const;\n\n    private:\n      bool test_compatibility(ivl_type_t that) const;\n      bool test_equivalence(ivl_type_t that) const;\n\n    private:\n      bool union_;\n      bool packed_;\n      bool signed_;\n      std::vector<member_t>members_;\n};\n\ninline bool netstruct_t::union_flag(void) const { return union_; }\ninline bool netstruct_t::packed(void) const { return packed_; }\n\n#endif /* IVL_netstruct_H */\n"
        },
        {
          "name": "nettypes.cc",
          "type": "blob",
          "size": 5.556640625,
          "content": "/*\n * Copyright (c) 2012-2016 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"nettypes.h\"\n# include  \"netenum.h\"\n# include  <iostream>\n# include  <cassert>\n\nusing namespace std;\n\nivl_type_s::~ivl_type_s()\n{\n}\n\n/*\n * The derived class may override this to provide a more accurate\n * response.\n */\nbool ivl_type_s::packed(void) const\n{\n      return false;\n}\n\nlong ivl_type_s::packed_width(void) const\n{\n      return 1;\n}\n\nnetranges_t ivl_type_s::slice_dimensions() const\n{\n      return netranges_t();\n}\n\nivl_variable_type_t ivl_type_s::base_type() const\n{\n      return IVL_VT_NO_TYPE;\n}\n\nbool ivl_type_s::get_signed() const\n{\n      return false;\n}\n\nbool ivl_type_s::get_scalar() const\n{\n      return false;\n}\n\nbool ivl_type_s::type_compatible(ivl_type_t that) const\n{\n      if (this == that)\n\t    return true;\n\n      return test_compatibility(that);\n}\n\nbool ivl_type_s::test_compatibility(ivl_type_t that) const\n{\n      return test_equivalence(that);\n}\n\nbool ivl_type_s::type_equivalent(ivl_type_t that) const\n{\n      if (this == that)\n\t    return true;\n\n      return test_equivalence(that);\n}\n\nbool ivl_type_s::test_equivalence(ivl_type_t) const\n{\n\treturn false;\n}\n\nnetarray_t::~netarray_t()\n{\n}\n\nivl_variable_type_t netarray_t::base_type() const\n{\n      return element_type_->base_type();\n}\n\nunsigned long netrange_width(const netranges_t &packed,\n\t\t\t     unsigned int base_width)\n{\n      unsigned wid = base_width;\n      for (netranges_t::const_iterator cur = packed.begin()\n\t\t ; cur != packed.end() ; ++cur) {\n\t    unsigned use_wid = cur->width();\n\t    wid *= use_wid;\n      }\n\n      return wid;\n}\n\nbool netrange_equivalent(const netranges_t &a, const netranges_t &b)\n{\n\tif (a.size() != b.size())\n\t\treturn false;\n\n\tfor (size_t i = 0; i < a.size(); i++) {\n\t\tif (!a[i].equivalent(b[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*\n * Given a netrange_t list (which represent packed dimensions) and a\n * prefix of calculated index values, calculate the canonical offset\n * and width of the resulting slice. In this case, the \"sb\" argument\n * is an extra index of the prefix.\n */\nbool prefix_to_slice(const netranges_t&dims, const std::list<long>&prefix,\n\t\t     long sb, long&loff, unsigned long&lwid)\n{\n      assert(prefix.size() < dims.size());\n\n\t// Figure out the width of the slice, given the number of\n\t// prefix numbers there are. We don't need to look at the\n\t// actual values yet, but we do need to know how many there\n\t// are compared to the actual dimensions of the target. So do\n\t// this by multiplying the widths of the dims that are NOT\n\t// accounted for by the prefix or sb indices.\n      size_t acc_wid = 1;\n      netranges_t::const_iterator pcur = dims.end();\n      for (size_t idx = prefix.size()+1 ; idx < dims.size() ; idx += 1) {\n\t    -- pcur;\n\t    acc_wid *= pcur->width();\n      }\n\n      lwid = acc_wid; // lwid is now the final slice width.\n\n\t// pcur is pointing to the dimension AFTER the dimension that\n\t// we have an index for, so step back one, then this will be\n\t// used with the sb index. Start accumulating in the acc_off\n\t// the offset into the n-dimensional vector.\n      -- pcur;\n      if (sb < pcur->get_msb() && sb < pcur->get_lsb())\n\t    return false;\n      if (sb > pcur->get_msb() && sb > pcur->get_lsb())\n\t    return false;\n\n      long acc_off = 0;\n      if (pcur->get_msb() >= pcur->get_lsb())\n\t    acc_off += (sb - pcur->get_lsb()) * acc_wid;\n      else\n\t    acc_off += (pcur->get_lsb() - sb) * acc_wid;\n\n\t// If there are no more prefix items, we are done.\n      if (prefix.empty()) {\n\t    loff = acc_off;\n\t    return true;\n      }\n\n\t// Now similarly go through the prefix numbers, working\n\t// through the dimensions until we run out. Accumulate a\n\t// growing slice width (acc_wid) that is used to calculate the\n\t// growing offset (acc_off).\n      list<long>::const_iterator icur = prefix.end();\n      do {\n\t    -- icur;\n\t    acc_wid *= pcur->width();\n\t    -- pcur;\n\t    if (pcur->get_msb() >= pcur->get_lsb())\n\t\t  acc_off += (*icur - pcur->get_lsb()) * acc_wid;\n\t    else\n\t\t  acc_off += (pcur->get_lsb() - *icur) * acc_wid;\n\n      } while (icur != prefix.begin());\n\n\t// Got our final offset.\n      loff = acc_off;\n\n      return true;\n}\n\nbool packed_types_equivalent(ivl_type_t a, ivl_type_t b)\n{\n      if (!a->packed() || !b->packed())\n\t    return false;\n\n      if (a->base_type() != b->base_type())\n\t    return false;\n\n      if (a->packed_width() != b->packed_width())\n\t    return false;\n\n      if (a->get_signed() != b->get_signed())\n\t    return false;\n\n      // Special case, even though enums are packed they are not equivalent,\n      // they are only assignment compatible to other packed types\n      if (dynamic_cast<const netenum_t*>(b))\n\t    return false;\n\n      return true;\n}\n\nbool packed_type_compatible(ivl_type_t type)\n{\n      if (type->packed())\n\t    return true;\n\n      if (type->base_type() == IVL_VT_REAL)\n\t    return true;\n\n      return false;\n}\n"
        },
        {
          "name": "nettypes.h",
          "type": "blob",
          "size": 5.5068359375,
          "content": "#ifndef IVL_nettypes_H\n#define IVL_nettypes_H\n/*\n * Copyright (c) 2012-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"ivl_target.h\"\n# include  <list>\n# include  <vector>\n# include  <climits>\n# include  <ostream>\n# include  <cassert>\n\nclass netrange_t;\nclass LineInfo;\n\ntypedef std::vector<netrange_t> netranges_t;\n\n/*\n * This is a fully abstract type that is a type that can be attached\n * to a NetNet object.\n */\nclass ivl_type_s {\n    public:\n      virtual ~ivl_type_s() =0;\n      virtual bool packed(void) const;\n      virtual long packed_width(void) const;\n      virtual netranges_t slice_dimensions() const;\n\n\t// Some types have a base variable type. This is the bit type\n\t// for packed data types, or IVL_VT_DARRAY or IVL_VT_CLASS for\n\t// those specific types.\n      virtual ivl_variable_type_t base_type() const;\n      virtual bool get_signed() const;\n      virtual bool get_scalar() const;\n\n\t// Return true if \"that\" type is assignment compatible with this\n\t// type.\n      bool type_compatible(ivl_type_t that) const;\n        // Return true if \"that\" type is equivalent with this type as defined by\n\t// the standard\n      bool type_equivalent(ivl_type_t that) const;\n\n      virtual std::ostream& debug_dump(std::ostream&) const;\n\n    private:\n\t// The \"type_compatible\" and \"type_equivalent\" methods uses this virtual\n\t// method to invoke type-specific tests of compatibility.\n      virtual bool test_compatibility(ivl_type_t that) const;\n      virtual bool test_equivalence(ivl_type_t that) const;\n};\n\n/*\n * Convenience functions for making ivl_type_t objects from various inputs.\n */\nextern ivl_type_t make_ivl_type(ivl_variable_type_t vt,\n\t\t\t\tconst netranges_t&packed_dimensions,\n\t\t\t\tbool signed_flag =false, bool isint_flag =false);\n\n/*\n * There are a couple types of array types. This class represents the\n * common bits of array types.\n */\nclass netarray_t : public ivl_type_s {\n\n    public:\n      inline explicit netarray_t(ivl_type_t etype) : element_type_(etype) { }\n      ~netarray_t();\n\n    public:\n\t// Some virtual methods have a common implementation for arrays.\n\n\t// The base_type() for arrays is the base_Typeof the element.\n      ivl_variable_type_t base_type() const;\n\n    public:\n      inline ivl_type_t element_type() const { return element_type_; }\n\n    private:\n      ivl_type_t element_type_;\n};\n\ninline static std::ostream& operator << (std::ostream&out, const ivl_type_s&obj)\n{\n      return obj.debug_dump(out);\n}\n\nclass netrange_t {\n\n    public:\n\t// Create an undefined range. An undefined range is a range\n\t// used to declare dynamic arrays, etc.\n      inline netrange_t() : msb_(LONG_MAX), lsb_(LONG_MAX) { }\n\t// Create a properly defined netrange\n      inline netrange_t(long m, long l) : msb_(m), lsb_(l) { }\n\t// Copy constructor.\n      inline netrange_t(const netrange_t&that)\n      : msb_(that.msb_), lsb_(that.lsb_) { }\n\n      inline netrange_t& operator = (const netrange_t&that)\n      { msb_ = that.msb_; lsb_ = that.lsb_; return *this; }\n\n      inline bool defined() const\n      { return msb_!=LONG_MAX || lsb_!= LONG_MAX; }\n\n      inline unsigned long width()const\n      { if (!defined()) return 0;\n\telse if (msb_ >= lsb_) return msb_-lsb_+1;\n\telse return lsb_-msb_+1;\n      }\n\n      inline long get_msb() const { assert(defined()); return msb_; }\n      inline long get_lsb() const { assert(defined()); return lsb_; }\n\n      inline bool operator == (const netrange_t&that) const\n      { if (msb_ != that.msb_) return false;\n\tif (lsb_ != that.lsb_) return false;\n\treturn true;\n      }\n\n      inline bool operator != (const netrange_t&that) const\n      { if (msb_ != that.msb_) return true;\n\tif (lsb_ != that.lsb_) return true;\n\treturn false;\n      }\n\n      bool equivalent(const netrange_t &that) const {\n\t    return width() == that.width();\n      }\n\n    private:\n      long msb_;\n      long lsb_;\n};\n\nextern std::ostream&operator << (std::ostream&out, const netranges_t&rlist);\n\nextern unsigned long netrange_width(const netranges_t &dims,\n\t\t\t\t    unsigned int base_width = 1);\nextern bool netrange_equivalent(const netranges_t &a, const netranges_t &b);\n\n/*\n * There are a few cases where we need to know about the single-level\n * dimensions of a parameter declaration, for example:\n *\n *   parameter [msv:lsv] foo ...;\n */\nextern bool calculate_param_range(const LineInfo&line, ivl_type_t par_type,\n\t\t\t\t  long&par_msv, long&par_lsv, long length);\n\n/*\n * Take as input a list of packed dimensions and a list of prefix\n * indices, and calculate the offset/width of the resulting slice into\n * the packed array.\n */\nextern bool prefix_to_slice(const netranges_t&dims,\n\t\t\t    const std::list<long>&prefix, long sb,\n\t\t\t    long&loff, unsigned long&lwid);\n\n\nextern bool packed_types_equivalent(ivl_type_t a, ivl_type_t b);\nextern bool packed_type_compatible(ivl_type_t type);\n\n#endif /* IVL_nettypes_H */\n"
        },
        {
          "name": "netvector.cc",
          "type": "blob",
          "size": 2.9384765625,
          "content": "/*\n * Copyright (c) 2012-2013 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netvector.h\"\n# include  \"compiler.h\"\n# include  <iostream>\n\nusing namespace std;\n\nnetvector_t netvector_t::atom2s64 (IVL_VT_BOOL, 63, 0, true);\nnetvector_t netvector_t::atom2u64 (IVL_VT_BOOL, 63, 0, false);\nnetvector_t netvector_t::atom2s32 (IVL_VT_BOOL, 31, 0, true);\nnetvector_t netvector_t::atom2u32 (IVL_VT_BOOL, 31, 0, false);\nnetvector_t netvector_t::atom2s16 (IVL_VT_BOOL, 15, 0, true);\nnetvector_t netvector_t::atom2u16 (IVL_VT_BOOL, 15, 0, false);\nnetvector_t netvector_t::atom2s8  (IVL_VT_BOOL,  7, 0, true);\nnetvector_t netvector_t::atom2u8  (IVL_VT_BOOL,  7, 0, false);\n\nnetvector_t netvector_t::time_signed (IVL_VT_LOGIC, 63, 0, true);\nnetvector_t netvector_t::time_unsigned (IVL_VT_LOGIC, 63, 0, false);\n\nstatic netvector_t* save_integer_type[2];\nconst netvector_t* netvector_t::integer_type(bool is_signed)\n{\n      if (save_integer_type[is_signed])\n\t    return save_integer_type[is_signed];\n\n      save_integer_type[is_signed] = new netvector_t(IVL_VT_LOGIC, integer_width-1, 0, is_signed);\n      save_integer_type[is_signed]->set_isint(true);\n      return save_integer_type[is_signed];\n}\n\n//netvector_t netvector_t::scalar_bool (IVL_VT_BOOL);\nnetvector_t netvector_t::scalar_logic (IVL_VT_LOGIC);\n\nnetvector_t::netvector_t(ivl_variable_type_t type, long msb, long lsb, bool flag)\n: type_(type), signed_(flag), isint_(false), implicit_(false)\n{\n      packed_dims_.push_back(netrange_t(msb,lsb));\n}\n\nnetvector_t::netvector_t(ivl_variable_type_t type)\n: type_(type), signed_(false), isint_(false), implicit_(false)\n{\n}\n\nnetvector_t::~netvector_t()\n{\n}\n\nivl_variable_type_t netvector_t::base_type() const\n{\n      return type_;\n}\n\n/*\n * vectors are by definition packed.\n */\nbool netvector_t::packed(void) const\n{\n      return true;\n}\n\nlong netvector_t::packed_width() const\n{\n      return netrange_width(packed_dims_);\n}\n\nnetranges_t netvector_t::slice_dimensions() const\n{\n      return packed_dims_;\n}\n\nbool netvector_t::test_compatibility(ivl_type_t that) const\n{\n      return packed_type_compatible(that);\n}\n\nbool netvector_t::test_equivalence(const ivl_type_t that) const\n{\n      return packed_types_equivalent(this, that);\n}\n"
        },
        {
          "name": "netvector.h",
          "type": "blob",
          "size": 3.4853515625,
          "content": "#ifndef IVL_netvector_H\n#define IVL_netvector_H\n/*\n * Copyright (c) 2012-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"nettypes.h\"\n# include  \"ivl_target.h\"\n# include  <vector>\n\nclass netvector_t : public ivl_type_s {\n\n    public:\n      explicit netvector_t(const netranges_t&packed, ivl_variable_type_t type);\n\n\t// special case: there is a single packed dimension and we\n\t// know it in the form [<msb>:<lsb>]. This step saves me\n\t// creating a netrange_t for this single item.\n      explicit netvector_t(ivl_variable_type_t type, long msb, long lsb,\n\t\t\t   bool signed_flag =false);\n\n\t// Special case: scalar object--no packed dimensions at all.\n      explicit netvector_t(ivl_variable_type_t type);\n\n      ~netvector_t();\n\n\t// Vectors can be interpreted as signed or unsigned when\n\t// handled as vectors.\n      inline void set_signed(bool flag) { signed_ = flag; }\n      inline bool get_signed(void) const { return signed_; }\n\n      inline void set_isint(bool flag) { isint_ = flag; }\n      inline bool get_isint(void) const { return isint_; }\n\n      inline bool get_scalar(void) const { return packed_dims_.empty(); }\n\n      void set_implicit(bool implicit) { implicit_ = implicit; }\n      bool get_implicit() const { return implicit_; }\n\n      ivl_variable_type_t base_type() const;\n      const netranges_t&packed_dims() const;\n\n      bool packed(void) const;\n      long packed_width() const;\n      netranges_t slice_dimensions() const;\n\n      std::ostream& debug_dump(std::ostream&) const;\n\n    public:\n\t// Some commonly used predefined types\n      static netvector_t atom2s64;\n      static netvector_t atom2u64;\n      static netvector_t atom2s32;\n      static netvector_t atom2u32;\n      static netvector_t atom2s16;\n      static netvector_t atom2u16;\n      static netvector_t atom2s8;\n      static netvector_t atom2u8;\n      static netvector_t time_signed;\n      static netvector_t time_unsigned;\n      static netvector_t scalar_bool;\n      static netvector_t scalar_logic;\n      static const netvector_t*integer_type(bool is_signed = true);\n\n    private:\n      bool test_compatibility(ivl_type_t that) const;\n      bool test_equivalence(ivl_type_t that) const;\n\n    private:\n      netranges_t packed_dims_;\n      ivl_variable_type_t type_;\n      bool signed_    : 1;\n      bool isint_     : 1;\t\t// original type of integer\n      bool implicit_  : 1;\n};\n\ninline netvector_t::netvector_t(const netranges_t &pd,\n\t\t\t\tivl_variable_type_t type)\n: packed_dims_(pd), type_(type), signed_(false), isint_(false), implicit_(false)\n{\n}\n\ninline const netranges_t& netvector_t::packed_dims() const\n{\n      return packed_dims_;\n}\n\ninline static std::ostream& operator << (std::ostream&out, const netvector_t&obj)\n{\n      return obj.debug_dump(out);\n}\n\n#endif /* IVL_netvector_H */\n"
        },
        {
          "name": "nodangle.cc",
          "type": "blob",
          "size": 9.1103515625,
          "content": "/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n/*\n * This functor scans the design looking for dangling objects and\n * excess local signals. These deletions are not necessarily required\n * for proper functioning of anything, but they can clean up the\n * appearance of design files that are generated.\n */\n# include  \"functor.h\"\n# include  \"netlist.h\"\n# include  \"compiler.h\"\n\nusing namespace std;\n\nclass nodangle_f  : public functor_t {\n    public:\n      void event(Design*des, NetEvent*ev);\n      void signal(Design*des, NetNet*sig);\n\n      unsigned iteration;\n      unsigned stotal, etotal;\n      bool scontinue, econtinue;\n      bool scomplete, ecomplete;\n};\n\nvoid nodangle_f::event(Design*, NetEvent*ev)\n{\n      if (ecomplete) return;\n\n\t/* If there are no references to this event, then go right\n\t   ahead and delete it. There is no use looking further at\n\t   it. */\n      if ((ev->nwait() + ev->ntrig() + ev->nexpr()) == 0) {\n\t    delete ev;\n\t    etotal += 1;\n\t    return;\n      }\n\n      if (iteration == 0) {\n              /* Try to remove duplicate probes from the event. This\n                 is done as a separate initial pass to ensure similar\n                 events are detected as soon as possible in subsequent\n                 iterations. */\n            for (unsigned idx = 0 ;  idx < ev->nprobe() ;  idx += 1) {\n                  unsigned jdx = idx + 1;\n                  while (jdx < ev->nprobe()) {\n                        NetEvProbe*ip = ev->probe(idx);\n                        NetEvProbe*jp = ev->probe(jdx);\n\n                        if (ip->edge() != jp->edge()) {\n                              jdx += 1;\n                              continue;\n                        }\n\n                        bool fully_connected = true;\n                        for (unsigned jpin = 0; jpin < jp->pin_count(); jpin += 1) {\n                              unsigned ipin = 0;\n                              bool connected_flag = false;\n                              for (ipin = 0 ; ipin < ip->pin_count(); ipin += 1)\n                                    if (connected(ip->pin(ipin), jp->pin(jpin))) {\n                                          connected_flag = true;\n                                          break;\n                                    }\n\n                              if (!connected_flag) {\n                                    fully_connected = false;\n                                    break;\n                              }\n                        }\n\n                        if (fully_connected) {\n                              delete jp;\n                        } else {\n                              jdx += 1;\n                        }\n                  }\n            }\n            econtinue = true;\n      } else {\n              /* Postpone examining events in an automatic scope until the\n                 third (optional) pass. This will mean similar events are\n                 biased towards being stored in static scopes. */\n            if (ev->scope()->is_auto()) {\n                  if (iteration == 1) {\n                        econtinue = true;\n                        return;\n                  }\n            } else {\n                  if (iteration == 2) {\n                        return;\n                  }\n            }\n\n              /* Try to find all the events that are similar to me, and\n                 replace their references with references to me. */\n            list<NetEvent*> match;\n            ev->find_similar_event(match);\n            for (list<NetEvent*>::iterator idx = match.begin()\n                       ; idx != match.end() ; ++ idx ) {\n\n                  NetEvent*tmp = *idx;\n                  assert(tmp != ev);\n\t\t  tmp ->replace_event(ev);\n            }\n      }\n}\n\nstatic bool floating_net_tested(NetNet*sig)\n{\n      static set<NetNet*> tested_set;\n\n      pair< set<NetNet*>::iterator, bool > cur = tested_set.insert(sig);\n      return !cur.second;\n}\n\nstatic void check_is_floating(NetNet*sig)\n{\n\t// Some signal types are implicitly driven if nothing else.\n      if (sig->type() == NetNet::SUPPLY0) return;\n      if (sig->type() == NetNet::SUPPLY1) return;\n      if (sig->type() == NetNet::TRI0) return;\n      if (sig->type() == NetNet::TRI1) return;\n      if (sig->type() == NetNet::IMPLICIT_REG) return;\n      if (sig->type() == NetNet::REG) return ;\n\n\t// Assignments drive a signal.\n      if (sig->peek_lref() > 0) return;\n\n      for (unsigned idx = 0 ; idx < sig->pin_count() ; idx += 1) {\n\t    if (sig->pin(idx).get_dir() == Link::OUTPUT)\n\t\t  continue;\n\n\t    if (sig->pin(idx).nexus()->drivers_present())\n\t\t  continue;\n\n\t    if (sig->port_type() == PortType::NOT_A_PORT && sig->pin_count()==1) {\n\t\t  cerr << sig->get_fileline() << \": warning: \"\n\t\t       << \"Signal \" << scope_path(sig->scope())\n\t\t       << \".\" << sig->name()\n\t\t       << \" has no drivers.\" << endl;\n\t    } else if (sig->port_type()==PortType::NOT_A_PORT) {\n\t\t  cerr << sig->get_fileline() << \": warning: \"\n\t\t       << \"Signal \" << scope_path(sig->scope())\n\t\t       << \".\" << sig->name()\n\t\t       << \"[\" << idx << \"]\"\n\t\t       << \" has no drivers.\" << endl;\n\t    } else {\n\t\t  cerr << sig->get_fileline() << \": warning: \"\n\t\t       << \"Port \" << sig->name()\n\t\t       << \" of \" << scope_path(sig->scope())\n\t\t       << \" has no drivers.\" << endl;\n\t    }\n      }\n\n}\n\nvoid nodangle_f::signal(Design*, NetNet*sig)\n{\n      if (scomplete) return;\n\n      if (warn_floating_nets && !sig->local_flag() && !floating_net_tested(sig)) {\n\t    check_is_floating(sig);\n      }\n\n\t/* Cannot delete signals referenced in an expression\n\t   or an l-value. */\n      if (sig->get_refs() > 0)\n\t    return;\n\n\t/* Cannot delete the ports of tasks, functions or modules. There\n\t   are too many places where they are referenced. */\n      if ((sig->port_type() != NetNet::NOT_A_PORT) &&\n\t  ((sig->scope()->type() == NetScope::TASK) ||\n\t   (sig->scope()->type() == NetScope::FUNC) ||\n\t   (sig->scope()->type() == NetScope::MODULE)))\n\t    return;\n\n\t/* Can't delete ports of cells. */\n      if ((sig->port_type() != NetNet::NOT_A_PORT)\n\t  && (sig->scope()->attribute(perm_string::literal(\"ivl_synthesis_cell\")) != verinum()))\n\t    return;\n\n\t/* Don't delete signals that are marked with the\n\t   ivl_do_not_elide property. */\n      if (!sig->local_flag()\n\t  && (sig->attribute(perm_string::literal(\"ivl_do_not_elide\")) != verinum()))\n\t    return;\n\n\t/* Check to see if the signal is completely unconnected. If\n\t   all the bits are unlinked, then delete it. */\n      if (! sig->is_linked()) {\n\t    delete sig;\n\t    stotal += 1;\n\t    return;\n      }\n\n\t/* The remaining things can only be done to synthesized\n\t   signals, not ones that appear in the original Verilog. */\n      if (! sig->local_flag())\n\t    return;\n\n\t/* Check to see if there is some significant signal connected\n\t   to every pin of this signal. */\n      unsigned significant_flags = 0;\n      for (unsigned idx = 0 ;  idx < sig->pin_count() ;  idx += 1) {\n\t    Nexus*nex = sig->pin(idx).nexus();\n\n\t    for (Link*cur = nex->first_nlink()\n\t\t       ; cur ;  cur = cur->next_nlink()) {\n\n\t\t  if (cur == &sig->pin(idx))\n\t\t\tcontinue;\n\n\t\t  NetNet*cursig = dynamic_cast<NetNet*>(cur->get_obj());\n\t\t  if (cursig == 0)\n\t\t\tcontinue;\n\n\t\t  if (cursig->local_flag())\n\t\t\tcontinue;\n\n\t\t  significant_flags += 1;\n\t\t  break;\n\t    }\n\n\t    if (significant_flags <= idx)\n\t\t  break;\n      }\n\n\t/* If every pin is connected to another significant signal,\n\t   then I can delete this one. */\n      if (significant_flags == sig->pin_count()) {\n\t    delete sig;\n\t    stotal += 1;\n      }\n}\n\nvoid nodangle(Design*des)\n{\n      nodangle_f fun;\n      fun.iteration = 0;\n      fun.stotal = 0;\n      fun.etotal = 0;\n      fun.scomplete = false;\n      fun.ecomplete = false;\n      do {\n\t    if (verbose_flag) {\n\t\t  cout << \" ... scan for dangling signal and event nodes. \"\n\t\t       << \"(scomplete=\" << (fun.scomplete? \"T\" : \"F\")\n\t\t       << \", ecomplete=\" << (fun.ecomplete? \"T\" : \"F\")\n\t\t       << \")\" << endl << flush;\n\t    }\n\n            fun.scontinue = false;\n            fun.econtinue = false;\n\t    des->functor(&fun);\n\t    fun.iteration += 1;\n            fun.scomplete = !fun.scontinue;\n            fun.ecomplete = !fun.econtinue;\n\n\t    if (verbose_flag) {\n\t\t  cout << \" ... \" << fun.iteration << \" iterations\"\n\t\t       << \" deleted \" << fun.stotal << \" dangling signals\"\n\t\t       << \" and \" << fun.etotal << \" events.\" << endl << flush;\n\t    }\n\n      } while (fun.scontinue || fun.econtinue);\n\n      if (verbose_flag) {\n\t    cout << \" ... done\" << endl << flush;\n      }\n}\n"
        },
        {
          "name": "pad_to_width.cc",
          "type": "blob",
          "size": 5.41796875,
          "content": "/*\n * Copyright (c) 1999-2016 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"netenum.h\"\n# include  \"netlist.h\"\n# include  \"netvector.h\"\n# include  \"netmisc.h\"\n\n\nNetExpr*pad_to_width(NetExpr*expr, unsigned wid, bool signed_flag,\n\t\t     const LineInfo&info, ivl_type_t use_type)\n{\n      if (wid <= expr->expr_width() && !use_type) {\n\t    expr->cast_signed(signed_flag);\n\t    return expr;\n      }\n\n\t/* If the expression is a const, then replace it with a wider\n\t   const. This is a more efficient result. */\n      if (NetEConst*tmp = dynamic_cast<NetEConst*>(expr)) {\n\t    verinum oval = tmp->value();\n\t    oval.has_sign(signed_flag);\n\t    oval = pad_to_width(oval, wid);\n\t    if (const netenum_t *enum_type = dynamic_cast<const netenum_t *>(use_type)) {\n\t\t  // The name of the enum is set to <nil> here, but the name is\n\t\t  // only used in debugging output, so this is ok\n\t\t  tmp = new NetEConstEnum(perm_string(), enum_type, oval);\n\t    } else {\n\t\t  tmp = new NetEConst(oval);\n\t    }\n\t    tmp->set_line(info);\n\t    delete expr;\n\t    return tmp;\n      }\n\n      NetESelect*tmp = new NetESelect(expr, 0, wid, use_type);\n      tmp->cast_signed(signed_flag);\n      tmp->set_line(info);\n      return tmp;\n}\n\nNetExpr*cast_to_width(NetExpr*expr, unsigned wid, bool signed_flag,\n\t\t      const LineInfo&info)\n{\n        /* If the expression is a const, then replace it with a new\n           const. This is a more efficient result. */\n      if (NetEConst*tmp = dynamic_cast<NetEConst*>(expr)) {\n            tmp->cast_signed(signed_flag);\n            if (wid != tmp->expr_width()) {\n                  tmp = new NetEConst(verinum(tmp->value(), wid));\n                  tmp->set_line(info);\n                  delete expr;\n            }\n            return tmp;\n      }\n\n      NetESelect*tmp = new NetESelect(expr, 0, wid);\n      tmp->cast_signed(signed_flag);\n      tmp->set_line(info);\n\n      return tmp;\n}\n\n/*\n * Pad a NetNet to the desired vector width by concatenating a\n * NetConst of constant zeros. Use a NetConcat node to do the\n * concatenation.\n */\nNetNet*pad_to_width(Design*des, NetNet*net, unsigned wid, const LineInfo&info)\n{\n      NetScope*scope = net->scope();\n\n      if (net->vector_width() >= wid)\n\t    return net;\n\n\t// Make the NetConcat and connect the input net to the lsb input.\n      NetConcat*cc = new NetConcat(scope, scope->local_symbol(), wid, 2);\n      cc->set_line(info);\n      des->add_node(cc);\n      connect(cc->pin(1), net->pin(0));\n\n\t// Make a NetConst of the desired width and connect in to the\n\t// lsb input of the NetConcat.\n      verinum pad(verinum::V0, wid - net->vector_width());\n      NetConst*con = new NetConst(scope, scope->local_symbol(), pad);\n      con->set_line(info);\n      des->add_node(con);\n      connect(cc->pin(2), con->pin(0));\n\n\t// Make a NetNet for the NetConst to NetConcat link.\n      netvector_t*tmp_vec = new netvector_t(net->data_type(),\n\t\t\t\t\t    wid - net->vector_width() - 1, 0);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t      NetNet::WIRE, tmp_vec);\n      tmp->set_line(info);\n      tmp->local_flag(true);\n      connect(cc->pin(2), tmp->pin(0));\n\n\t// Create a NetNet of the output width and connect it to the\n\t// NetConcat node output pin.\n      tmp_vec = new netvector_t(net->data_type(), wid-1, 0);\n      tmp = new NetNet(scope, scope->local_symbol(),\n\t\t       NetNet::WIRE, tmp_vec);\n      tmp->set_line(info);\n      tmp->local_flag(true);\n      connect(cc->pin(0), tmp->pin(0));\n\n      return tmp;\n}\n\nNetNet*pad_to_width_signed(Design*des, NetNet*net, unsigned wid,\n                           const LineInfo&info)\n{\n      NetScope*scope = net->scope();\n\n      if (net->vector_width() >= wid)\n\t    return net;\n\n      NetSignExtend*se\n\t    = new NetSignExtend(scope, scope->local_symbol(), wid);\n      se->set_line(info);\n      des->add_node(se);\n\n      netvector_t*tmp_vec = new netvector_t(net->data_type(), wid-1, 0);\n      tmp_vec->set_signed(true);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(), NetNet::WIRE, tmp_vec);\n      tmp->set_line(info);\n      tmp->local_flag(true);\n\n      connect(tmp->pin(0), se->pin(0));\n      connect(se->pin(1), net->pin(0));\n\n      return tmp;\n}\n\nNetNet*crop_to_width(Design*des, NetNet*net, unsigned wid)\n{\n      NetScope*scope = net->scope();\n\n      if (net->vector_width() <= wid)\n\t    return net;\n\n      NetPartSelect*ps = new NetPartSelect(net, 0, wid, NetPartSelect::VP);\n      ps->set_line(*net);\n      des->add_node(ps);\n\n      netvector_t*tmp_vec = new netvector_t(net->data_type(), wid-1, 0);\n      NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t      NetNet::WIRE, tmp_vec);\n      tmp->set_line(*net);\n      tmp->local_flag(true);\n      connect(ps->pin(0), tmp->pin(0));\n\n      return tmp;\n}\n"
        },
        {
          "name": "parse.y",
          "type": "blob",
          "size": 204.4423828125,
          "content": "\n%{\n/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2012-2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <climits>\n# include  <cstdarg>\n# include  \"parse_misc.h\"\n# include  \"compiler.h\"\n# include  \"pform.h\"\n# include  \"Statement.h\"\n# include  \"PSpec.h\"\n# include  \"PTimingCheck.h\"\n# include  \"PPackage.h\"\n# include  <stack>\n# include  <cstring>\n# include  <sstream>\n# include  <memory>\n\nusing namespace std;\n\nclass PSpecPath;\n\nextern void lex_end_table();\n\nstatic data_type_t* param_data_type = 0;\nstatic bool param_is_local = false;\nstatic bool param_is_type = false;\nstatic bool in_gen_region = false;\nstatic std::list<pform_range_t>* specparam_active_range = 0;\n\n/* Port declaration lists use this structure for context. */\nstatic struct {\n      NetNet::Type port_net_type;\n      NetNet::PortType port_type;\n      data_type_t* data_type;\n} port_declaration_context = {NetNet::NONE, NetNet::NOT_A_PORT, 0};\n\n/* Modport port declaration lists use this structure for context. */\nenum modport_port_type_t { MP_NONE, MP_SIMPLE, MP_TF, MP_CLOCKING };\nstatic struct {\n      modport_port_type_t type;\n      union {\n\t    NetNet::PortType direction;\n\t    bool is_import;\n      };\n} last_modport_port = { MP_NONE, {NetNet::NOT_A_PORT}};\n\n/* The task and function rules need to briefly hold the pointer to the\n   task/function that is currently in progress. */\nstatic PTask* current_task = 0;\nstatic PFunction* current_function = 0;\nstatic stack<PBlock*> current_block_stack;\n\n/* The variable declaration rules need to know if a lifetime has been\n   specified. */\nstatic LexicalScope::lifetime_t var_lifetime;\n\nstatic void check_in_gen_region(const struct vlltype &loc)\n{\n      if (in_gen_region) {\n\t    cerr << loc << \": error: generate/endgenerate regions cannot nest.\" << endl;\n\t    error_count += 1;\n      }\n      in_gen_region = true;\n}\n\nstatic pform_name_t* pform_create_this(void)\n{\n      name_component_t name (perm_string::literal(THIS_TOKEN));\n      pform_name_t*res = new pform_name_t;\n      res->push_back(name);\n      return res;\n}\n\nstatic pform_name_t* pform_create_super(void)\n{\n      name_component_t name (perm_string::literal(SUPER_TOKEN));\n      pform_name_t*res = new pform_name_t;\n      res->push_back(name);\n      return res;\n}\n\n/* The rules sometimes push attributes into a global context where\n   sub-rules may grab them. This makes parser rules a little easier to\n   write in some cases. */\nstatic std::list<named_pexpr_t>*attributes_in_context = 0;\n\n/* Later version of bison (including 1.35) will not compile in stack\n   extension if the output is compiled with C++ and either the YYSTYPE\n   or YYLTYPE are provided by the source code. However, I can get the\n   old behavior back by defining these symbols. */\n# define YYSTYPE_IS_TRIVIAL 1\n# define YYLTYPE_IS_TRIVIAL 1\n\n/* Recent version of bison expect that the user supply a\n   YYLLOC_DEFAULT macro that makes up a yylloc value from existing\n   values. I need to supply an explicit version to account for the\n   text field, that otherwise won't be copied.\n\n   The YYLLOC_DEFAULT blends the file range for the tokens of Rhs\n   rule, which has N tokens.\n*/\n# define YYLLOC_DEFAULT(Current, Rhs, N)  do {\t\t\t\t\\\n      if (N) {\t\t\t\t\t\t\t        \\\n\t    (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;\t\\\n\t    (Current).first_column = YYRHSLOC (Rhs, 1).first_column;\t\\\n\t    (Current).last_line    = YYRHSLOC (Rhs, N).last_line;\t\\\n\t    (Current).last_column  = YYRHSLOC (Rhs, N).last_column;\t\\\n\t    (Current).lexical_pos  = YYRHSLOC (Rhs, 1).lexical_pos;\t\\\n\t    (Current).text         = YYRHSLOC (Rhs, 1).text;\t\t\\\n      } else {\t\t\t\t\t\t\t\t\\\n\t    (Current).first_line   = YYRHSLOC (Rhs, 0).last_line;\t\\\n\t    (Current).first_column = YYRHSLOC (Rhs, 0).last_column;\t\\\n\t    (Current).last_line    = YYRHSLOC (Rhs, 0).last_line;\t\\\n\t    (Current).last_column  = YYRHSLOC (Rhs, 0).last_column;\t\\\n\t    (Current).lexical_pos  = YYRHSLOC (Rhs, 0).lexical_pos;\t\\\n\t    (Current).text         = YYRHSLOC (Rhs, 0).text;\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n\n/*\n * These are some common strength pairs that are used as defaults when\n * the user is not otherwise specific.\n */\nstatic const struct str_pair_t pull_strength = { IVL_DR_PULL,  IVL_DR_PULL };\nstatic const struct str_pair_t str_strength = { IVL_DR_STRONG, IVL_DR_STRONG };\n\nstatic std::list<pform_port_t>* make_port_list(char*id, unsigned idn,\n\t\t\t\t\t       std::list<pform_range_t>*udims,\n\t\t\t\t\t       PExpr*expr)\n{\n      std::list<pform_port_t>*tmp = new std::list<pform_port_t>;\n      pform_ident_t tmp_name = { lex_strings.make(id), idn };\n      tmp->push_back(pform_port_t(tmp_name, udims, expr));\n      delete[]id;\n      return tmp;\n}\nstatic std::list<pform_port_t>* make_port_list(list<pform_port_t>*tmp,\n\t\t\t\t\t       char*id, unsigned idn,\n\t\t\t\t\t       std::list<pform_range_t>*udims,\n\t\t\t\t\t       PExpr*expr)\n{\n      pform_ident_t tmp_name = { lex_strings.make(id), idn };\n      tmp->push_back(pform_port_t(tmp_name, udims, expr));\n      delete[]id;\n      return tmp;\n}\n\nstatic std::list<pform_ident_t>* list_from_identifier(char*id, unsigned idn)\n{\n      std::list<pform_ident_t>*tmp = new std::list<pform_ident_t>;\n      tmp->push_back({ lex_strings.make(id), idn });\n      delete[]id;\n      return tmp;\n}\n\nstatic std::list<pform_ident_t>* list_from_identifier(list<pform_ident_t>*tmp,\n                                                      char*id, unsigned idn)\n{\n      tmp->push_back({ lex_strings.make(id), idn });\n      delete[]id;\n      return tmp;\n}\n\ntemplate <class T> void append(vector<T>&out, const std::vector<T>&in)\n{\n      for (size_t idx = 0 ; idx < in.size() ; idx += 1)\n\t    out.push_back(in[idx]);\n}\n\n/*\n * The parser parses an empty argument list as an argument list with an single\n * empty argument. Fix this up here and replace it with an empty list.\n */\nstatic void argument_list_fixup(list<named_pexpr_t> *lst)\n{\n      if (lst->size() == 1 && lst->front().name.nil() && !lst->front().parm)\n\t    lst->clear();\n}\n\n/*\n * This is a shorthand for making a PECallFunction that takes a single\n * arg. This is used by some of the code that detects built-ins.\n */\nstatic PECallFunction*make_call_function(perm_string tn, PExpr*arg)\n{\n      std::vector<named_pexpr_t> parms(1);\n      parms[0].parm = arg;\n      parms[0].set_line(*arg);\n      PECallFunction*tmp = new PECallFunction(tn, parms);\n      return tmp;\n}\n\nstatic PECallFunction*make_call_function(perm_string tn, PExpr*arg1, PExpr*arg2)\n{\n      std::vector<named_pexpr_t> parms(2);\n      parms[0].parm = arg1;\n      parms[0].set_line(*arg1);\n      parms[1].parm = arg2;\n      parms[1].set_line(*arg2);\n      PECallFunction*tmp = new PECallFunction(tn, parms);\n      return tmp;\n}\n\nstatic std::list<named_pexpr_t>* make_named_numbers(const struct vlltype &loc,\n\t\t\t\t\t\t    perm_string name,\n\t\t\t\t\t\t    long first, long last,\n\t\t\t\t\t\t    PExpr *val = nullptr)\n{\n      std::list<named_pexpr_t>*lst = new std::list<named_pexpr_t>;\n      named_pexpr_t tmp;\n\t// We are counting up.\n      if (first <= last) {\n\t    for (long idx = first ; idx <= last ; idx += 1) {\n\t\t  ostringstream buf;\n\t\t  buf << name.str() << idx << ends;\n\t\t  tmp.name = lex_strings.make(buf.str());\n\t\t  tmp.parm = val;\n\t\t  FILE_NAME(&tmp, loc);\n\t\t  val = 0;\n\t\t  lst->push_back(tmp);\n\t    }\n\t// We are counting down.\n      } else {\n\t    for (long idx = first ; idx >= last ; idx -= 1) {\n\t\t  ostringstream buf;\n\t\t  buf << name.str() << idx << ends;\n\t\t  tmp.name = lex_strings.make(buf.str());\n\t\t  tmp.parm = val;\n\t\t  FILE_NAME(&tmp, loc);\n\t\t  val = 0;\n\t\t  lst->push_back(tmp);\n\t    }\n      }\n      return lst;\n}\n\nstatic std::list<named_pexpr_t>* make_named_number(const struct vlltype &loc,\n\t\t\t\t\t\t   perm_string name,\n\t\t\t\t\t\t   PExpr *val = nullptr)\n{\n      std::list<named_pexpr_t>*lst = new std::list<named_pexpr_t>;\n      named_pexpr_t tmp;\n      tmp.name = name;\n      tmp.parm = val;\n      FILE_NAME(&tmp, loc);\n      lst->push_back(tmp);\n      return lst;\n}\n\nstatic long check_enum_seq_value(const YYLTYPE&loc, verinum *arg, bool zero_ok)\n{\n      long value = 1;\n\t// We can never have an undefined value in an enumeration name\n\t// declaration sequence.\n      if (! arg->is_defined()) {\n\t    yyerror(loc, \"error: Undefined value used in enum name sequence.\");\n\t// We can never have a negative value in an enumeration name\n\t// declaration sequence.\n      } else if (arg->is_negative()) {\n\t    yyerror(loc, \"error: Negative value used in enum name sequence.\");\n      } else {\n\t    value = arg->as_ulong();\n\t      // We cannot have a zero enumeration name declaration count.\n\t    if (! zero_ok && (value == 0)) {\n\t\t  yyerror(loc, \"error: Zero count used in enum name sequence.\");\n\t\t  value = 1;\n\t    }\n      }\n      return value;\n}\n\nstatic void check_end_label(const struct vlltype&loc, const char *type,\n\t\t\t    const char *begin, const char *end)\n{\n      if (!end)\n\t    return;\n\n      if (!begin)\n\t    yyerror(loc, \"error: Unnamed %s must not have end label.\", type);\n      else if (strcmp(begin, end) != 0)\n\t    yyerror(loc, \"error: %s end label `%s` doesn't match %s name\"\n\t                 \" `%s`.\", type, end, type, begin);\n\n      if (!gn_system_verilog())\n\t    yyerror(loc, \"error: %s end label requires SystemVerilog.\", type);\n\n      delete[] end;\n}\n\nstatic void check_for_loop(const struct vlltype&loc, PExpr*init,\n\t\t\t   PExpr*cond, Statement*step)\n{\n      if (generation_flag >= GN_VER2012)\n\t    return;\n\n      if (!init)\n\t    yyerror(loc, \"error: null for-loop initialization requires \"\n                         \"SystemVerilog 2012 or later.\");\n      if (!cond)\n\t    yyerror(loc, \"error: null for-loop termination requires \"\n                         \"SystemVerilog 2012 or later.\");\n      if (!step)\n\t    yyerror(loc, \"error: null for-loop step requires \"\n                         \"SystemVerilog 2012 or later.\");\n}\n\nstatic void current_task_set_statement(const YYLTYPE&loc, std::vector<Statement*>*s)\n{\n      if (s == 0) {\n\t      /* if the statement list is null, then the parser\n\t\t detected the case that there are no statements in the\n\t\t task. If this is SystemVerilog, handle it as an\n\t\t an empty block. */\n\t    pform_requires_sv(loc, \"Task body with no statements\");\n\n\t    PBlock*tmp = new PBlock(PBlock::BL_SEQ);\n\t    FILE_NAME(tmp, loc);\n\t    current_task->set_statement(tmp);\n\t    return;\n      }\n      assert(s);\n\n        /* An empty vector represents one or more null statements. Handle\n           this as a simple null statement. */\n      if (s->empty())\n            return;\n\n\t/* A vector of 1 is handled as a simple statement. */\n      if (s->size() == 1) {\n\t    current_task->set_statement((*s)[0]);\n\t    return;\n      }\n\n      pform_requires_sv(loc, \"Task body with multiple statements\");\n\n      PBlock*tmp = new PBlock(PBlock::BL_SEQ);\n      FILE_NAME(tmp, loc);\n      tmp->set_statement(*s);\n      current_task->set_statement(tmp);\n}\n\nstatic void current_function_set_statement(const YYLTYPE&loc, std::vector<Statement*>*s)\n{\n      if (s == 0) {\n\t      /* if the statement list is null, then the parser\n\t\t detected the case that there are no statements in the\n\t\t task. If this is SystemVerilog, handle it as an\n\t\t an empty block. */\n\t    pform_requires_sv(loc, \"Function body with no statements\");\n\n\t    PBlock*tmp = new PBlock(PBlock::BL_SEQ);\n\t    FILE_NAME(tmp, loc);\n\t    current_function->set_statement(tmp);\n\t    return;\n      }\n      assert(s);\n\n        /* An empty vector represents one or more null statements. Handle\n           this as a simple null statement. */\n      if (s->empty())\n            return;\n\n\t/* A vector of 1 is handled as a simple statement. */\n      if (s->size() == 1) {\n\t    current_function->set_statement((*s)[0]);\n\t    return;\n      }\n\n      pform_requires_sv(loc, \"Function body with multiple statements\");\n\n      PBlock*tmp = new PBlock(PBlock::BL_SEQ);\n      FILE_NAME(tmp, loc);\n      tmp->set_statement(*s);\n      current_function->set_statement(tmp);\n}\n\nstatic void port_declaration_context_init(void)\n{\n      port_declaration_context.port_type = NetNet::PINOUT;\n      port_declaration_context.port_net_type = NetNet::IMPLICIT;\n      port_declaration_context.data_type = nullptr;\n}\n\nModule::port_t *module_declare_port(const YYLTYPE&loc, char *id,\n\t\t\t            NetNet::PortType port_type,\n\t\t\t\t    NetNet::Type net_type,\n\t\t\t\t    data_type_t *data_type,\n\t\t\t\t    std::list<pform_range_t> *unpacked_dims,\n\t\t\t\t    PExpr *default_value,\n\t\t\t\t    std::list<named_pexpr_t> *attributes)\n{\n      pform_ident_t name = { lex_strings.make(id), loc.lexical_pos };\n      delete[] id;\n\n      Module::port_t *port = pform_module_port_reference(loc, name.first);\n\n      switch (port_type) {\n\t  case NetNet::PINOUT:\n\t    if (default_value)\n\t\t  yyerror(loc, \"error: Default port value not allowed for inout ports.\");\n\t    if (unpacked_dims) {\n\t\t  yyerror(loc, \"sorry: Inout ports with unpacked dimensions are not supported.\");\n\t\t  delete unpacked_dims;\n\t\t  unpacked_dims = nullptr;\n\t    }\n\t    break;\n\t  case NetNet::PINPUT:\n\t    if (default_value) {\n\t\t  pform_requires_sv(loc, \"Input port default value\");\n\t\t  port->default_value = default_value;\n\t    }\n\t    break;\n\t  case NetNet::POUTPUT:\n\t    if (default_value)\n\t\t  pform_make_var_init(loc, name, default_value);\n\n\t      // Output types without an implicit net type but with a data type\n\t      // are variables. Unlike the other port types, which are nets in\n\t      // that case.\n\t    if (net_type == NetNet::IMPLICIT) {\n\t\t  if (vector_type_t*dtype = dynamic_cast<vector_type_t*> (data_type)) {\n\t\t\tif (!dtype->implicit_flag)\n\t\t\t      net_type = NetNet::IMPLICIT_REG;\n\t\t  } else if (data_type) {\n\t\t\tnet_type = NetNet::IMPLICIT_REG;\n\t\t  }\n\t    }\n\t    break;\n\t  default:\n\t    break;\n      }\n\n      pform_module_define_port(loc, name, port_type, net_type, data_type,\n\t\t\t       unpacked_dims, attributes);\n\n      port_declaration_context.port_type = port_type;\n      port_declaration_context.port_net_type = net_type;\n      port_declaration_context.data_type = data_type;\n\n      return port;\n}\n\n%}\n\n%union {\n      bool flag;\n\n      char letter;\n      int  int_val;\n\n      enum atom_type_t::type_code atom_type;\n\n\t/* text items are C strings allocated by the lexor using\n\t   strdup. They can be put into lists with the texts type. */\n      char*text;\n      std::list<perm_string>*perm_strings;\n\n      std::list<pform_ident_t>*identifiers;\n\n      std::list<pform_port_t>*port_list;\n\n      std::vector<pform_tf_port_t>* tf_ports;\n\n      pform_name_t*pform_name;\n\n      ivl_discipline_t discipline;\n\n      hname_t*hier;\n\n      std::list<std::string>*strings;\n\n      struct str_pair_t drive;\n\n      PCase::Item*citem;\n      std::vector<PCase::Item*>*citems;\n\n      lgate*gate;\n      std::vector<lgate>*gates;\n\n      Module::port_t *mport;\n      LexicalScope::range_t* value_range;\n      std::vector<Module::port_t*>*mports;\n\n      std::list<PLet::let_port_t*>*let_port_lst;\n      PLet::let_port_t*let_port_itm;\n\n      named_pexpr_t*named_pexpr;\n      std::list<named_pexpr_t>*named_pexprs;\n      struct parmvalue_t*parmvalue;\n      std::list<pform_range_t>*ranges;\n\n      PExpr*expr;\n      std::list<PExpr*>*exprs;\n\n      PEEvent*event_expr;\n      std::vector<PEEvent*>*event_exprs;\n\n      ivl_case_quality_t case_quality;\n      NetNet::Type nettype;\n      PGBuiltin::Type gatetype;\n      NetNet::PortType porttype;\n      ivl_variable_type_t vartype;\n      PBlock::BL_TYPE join_keyword;\n\n      PWire*wire;\n      std::vector<PWire*>*wires;\n\n      PCallTask *subroutine_call;\n\n      PEventStatement*event_statement;\n      Statement*statement;\n      std::vector<Statement*>*statement_list;\n\n      decl_assignment_t*decl_assignment;\n      std::list<decl_assignment_t*>*decl_assignments;\n\n      struct_member_t*struct_member;\n      std::list<struct_member_t*>*struct_members;\n      struct_type_t*struct_type;\n\n      data_type_t*data_type;\n      class_type_t*class_type;\n      real_type_t::type_t real_type;\n      property_qualifier_t property_qualifier;\n      PPackage*package;\n\n      struct {\n\t    char*text;\n\t    typedef_t*type;\n      } type_identifier;\n\n      struct {\n\t    data_type_t*type;\n\t    std::list<named_pexpr_t> *args;\n      } class_declaration_extends;\n\n      struct {\n\t    char*text;\n\t    PExpr*expr;\n      } genvar_iter;\n\n      struct {\n\t    bool packed_flag;\n\t    bool signed_flag;\n      } packed_signing;\n\n      verinum* number;\n\n      verireal* realtime;\n\n      PSpecPath* specpath;\n      std::list<index_component_t> *dimensions;\n\n      PTimingCheck::event_t* timing_check_event;\n      PTimingCheck::optional_args_t* spec_optional_args;\n\n      LexicalScope::lifetime_t lifetime;\n\n      enum typedef_t::basic_type typedef_basic_type;\n};\n\n%token <text>      IDENTIFIER SYSTEM_IDENTIFIER STRING TIME_LITERAL\n%token <type_identifier> TYPE_IDENTIFIER\n%token <package>   PACKAGE_IDENTIFIER\n%token <discipline> DISCIPLINE_IDENTIFIER\n%token <text>   PATHPULSE_IDENTIFIER\n%token <number> BASED_NUMBER DEC_NUMBER UNBASED_NUMBER\n%token <realtime> REALTIME\n%token K_PLUS_EQ K_MINUS_EQ K_INCR K_DECR\n%token K_LE K_GE K_EG K_EQ K_NE K_CEQ K_CNE K_WEQ K_WNE K_LP K_LS K_RS K_RSS K_SG\n /* K_CONTRIBUTE is <+, the contribution assign. */\n%token K_CONTRIBUTE\n%token K_PO_POS K_PO_NEG K_POW\n%token K_PSTAR K_STARP K_DOTSTAR\n%token K_LOR K_LAND K_NAND K_NOR K_NXOR K_TRIGGER K_NB_TRIGGER K_LEQUIV\n%token K_SCOPE_RES\n%token K_edge_descriptor\n\n%token K_CONSTRAINT_IMPL\n\n /* The base tokens from 1364-1995. */\n%token K_always K_and K_assign K_begin K_buf K_bufif0 K_bufif1 K_case\n%token K_casex K_casez K_cmos K_deassign K_default K_defparam K_disable\n%token K_edge K_else K_end K_endcase K_endfunction K_endmodule\n%token K_endprimitive K_endspecify K_endtable K_endtask K_event K_for\n%token K_force K_forever K_fork K_function K_highz0 K_highz1 K_if\n%token K_ifnone K_initial K_inout K_input K_integer K_join K_large\n%token K_macromodule K_medium K_module K_nand K_negedge K_nmos K_nor\n%token K_not K_notif0 K_notif1 K_or K_output K_parameter K_pmos K_posedge\n%token K_primitive K_pull0 K_pull1 K_pulldown K_pullup K_rcmos K_real\n%token K_realtime K_reg K_release K_repeat K_rnmos K_rpmos K_rtran\n%token K_rtranif0 K_rtranif1 K_scalared K_small K_specify K_specparam\n%token K_strong0 K_strong1 K_supply0 K_supply1 K_table K_task K_time\n%token K_tran K_tranif0 K_tranif1 K_tri K_tri0 K_tri1 K_triand K_trior\n%token K_trireg K_vectored K_wait K_wand K_weak0 K_weak1 K_while K_wire\n%token K_wor K_xnor K_xor\n\n%token K_Shold K_Snochange K_Speriod K_Srecovery K_Ssetup K_Ssetuphold\n%token K_Sskew K_Swidth\n\n /* Icarus specific tokens. */\n%token KK_attribute K_bool K_logic\n\n /* The new tokens from 1364-2001. */\n%token K_automatic K_endgenerate K_generate K_genvar K_localparam\n%token K_noshowcancelled K_pulsestyle_onevent K_pulsestyle_ondetect\n%token K_showcancelled K_signed K_unsigned\n\n%token K_Sfullskew K_Srecrem K_Sremoval K_Stimeskew\n\n /* The 1364-2001 configuration tokens. */\n%token K_cell K_config K_design K_endconfig K_incdir K_include K_instance\n%token K_liblist K_library K_use\n\n /* The new tokens from 1364-2005. */\n%token K_wone K_uwire\n\n /* The new tokens from 1800-2005. */\n%token K_alias K_always_comb K_always_ff K_always_latch K_assert\n%token K_assume K_before K_bind K_bins K_binsof K_bit K_break K_byte\n%token K_chandle K_class K_clocking K_const K_constraint K_context\n%token K_continue K_cover K_covergroup K_coverpoint K_cross K_dist K_do\n%token K_endclass K_endclocking K_endgroup K_endinterface K_endpackage\n%token K_endprogram K_endproperty K_endsequence K_enum K_expect K_export\n%token K_extends K_extern K_final K_first_match K_foreach K_forkjoin\n%token K_iff K_ignore_bins K_illegal_bins K_import K_inside K_int\n /* Icarus already has defined \"logic\" above! */\n%token K_interface K_intersect K_join_any K_join_none K_local\n%token K_longint K_matches K_modport K_new K_null K_package K_packed\n%token K_priority K_program K_property K_protected K_pure K_rand K_randc\n%token K_randcase K_randsequence K_ref K_return K_sequence K_shortint\n%token K_shortreal K_solve K_static K_string K_struct K_super\n%token K_tagged K_this K_throughout K_timeprecision K_timeunit K_type\n%token K_typedef K_union K_unique K_var K_virtual K_void K_wait_order\n%token K_wildcard K_with K_within\n\n /* The new tokens from 1800-2009. */\n%token K_accept_on K_checker K_endchecker K_eventually K_global K_implies\n%token K_let K_nexttime K_reject_on K_restrict K_s_always K_s_eventually\n%token K_s_nexttime K_s_until K_s_until_with K_strong K_sync_accept_on\n%token K_sync_reject_on K_unique0 K_until K_until_with K_untyped K_weak\n\n /* The new tokens from 1800-2012. */\n%token K_implements K_interconnect K_nettype K_soft\n\n /* The new tokens for Verilog-AMS 2.3. */\n%token K_above K_abs K_absdelay K_abstol K_access K_acos K_acosh\n /* 1800-2005 has defined \"assert\" above! */\n%token K_ac_stim K_aliasparam K_analog K_analysis K_asin K_asinh\n%token K_atan K_atan2 K_atanh K_branch K_ceil K_connect K_connectmodule\n%token K_connectrules K_continuous K_cos K_cosh K_ddt K_ddt_nature K_ddx\n%token K_discipline K_discrete K_domain K_driver_update K_endconnectrules\n%token K_enddiscipline K_endnature K_endparamset K_exclude K_exp\n%token K_final_step K_flicker_noise K_floor K_flow K_from K_ground\n%token K_hypot K_idt K_idtmod K_idt_nature K_inf K_initial_step\n%token K_laplace_nd K_laplace_np K_laplace_zd K_laplace_zp\n%token K_last_crossing K_limexp K_ln K_log K_max K_merged K_min K_nature\n%token K_net_resolution K_noise_table K_paramset K_potential K_pow\n /* 1800-2005 has defined \"string\" above! */\n%token K_resolveto K_sin K_sinh K_slew K_split K_sqrt K_tan K_tanh\n%token K_timer K_transition K_units K_white_noise K_wreal\n%token K_zi_nd K_zi_np K_zi_zd K_zi_zp\n\n%type <flag>    from_exclude block_item_decls_opt\n%type <number>  number pos_neg_number\n%type <flag>    signing unsigned_signed_opt signed_unsigned_opt\n%type <flag>    import_export\n%type <flag>    K_genvar_opt K_static_opt K_virtual_opt K_const_opt\n%type <flag>    udp_reg_opt edge_operator\n%type <drive>   drive_strength drive_strength_opt dr_strength0 dr_strength1\n%type <letter>  udp_input_sym udp_output_sym\n%type <text>    udp_input_list udp_sequ_entry udp_comb_entry\n%type <identifiers> udp_input_declaration_list\n%type <strings> udp_entry_list udp_comb_entry_list udp_sequ_entry_list\n%type <strings> udp_body\n%type <identifiers> udp_port_list\n%type <wires>   udp_port_decl udp_port_decls\n%type <statement> udp_initial udp_init_opt\n\n%type <wire> net_variable\n%type <wires> net_variable_list\n\n%type <text> event_variable label_opt class_declaration_endlabel_opt\n%type <text> block_identifier_opt\n%type <text> identifier_name\n%type <identifiers> event_variable_list\n%type <identifiers> list_of_identifiers\n%type <perm_strings> loop_variables\n%type <port_list> list_of_port_identifiers list_of_variable_port_identifiers\n\n%type <decl_assignments> net_decl_assigns\n%type <decl_assignment> net_decl_assign\n\n%type <mport> port port_opt port_reference port_reference_list\n%type <mport> port_declaration\n%type <mports> list_of_ports module_port_list_opt list_of_port_declarations module_attribute_foreign\n%type <value_range> parameter_value_range parameter_value_ranges\n%type <value_range> parameter_value_ranges_opt\n%type <expr> value_range_expression\n\n%type <named_pexprs> enum_name_list enum_name\n%type <data_type> enum_data_type enum_base_type\n\n%type <tf_ports> tf_item_declaration tf_item_list tf_item_list_opt\n%type <tf_ports> tf_port_declaration tf_port_item tf_port_item_list\n%type <tf_ports> tf_port_list tf_port_list_opt tf_port_list_parens_opt\n\n%type <named_pexpr> named_expression named_expression_opt port_name\n%type <named_pexprs> port_name_list parameter_value_byname_list\n%type <exprs> port_conn_expression_list_with_nuls\n\n%type <named_pexpr> attribute\n%type <named_pexprs> attribute_list attribute_instance_list attribute_list_opt\n\n%type <named_pexpr> argument\n%type <named_pexprs> argument_list\n%type <named_pexprs> argument_list_parens argument_list_parens_opt\n\n%type <citem>  case_item\n%type <citems> case_items\n\n%type <gate>  gate_instance\n%type <gates> gate_instance_list\n%type <let_port_lst> let_port_list_opt let_port_list\n%type <let_port_itm> let_port_item\n\n%type <pform_name> hierarchy_identifier implicit_class_handle class_hierarchy_identifier\n%type <pform_name> spec_notifier_opt spec_notifier\n%type <timing_check_event> spec_reference_event\n%type <spec_optional_args> setuphold_opt_args recrem_opt_args setuphold_recrem_opt_notifier\n%type <spec_optional_args> setuphold_recrem_opt_timestamp_cond setuphold_recrem_opt_timecheck_cond\n%type <spec_optional_args> setuphold_recrem_opt_delayed_reference setuphold_recrem_opt_delayed_data\n%type <spec_optional_args> timeskew_opt_args fullskew_opt_args\n%type <spec_optional_args> timeskew_fullskew_opt_notifier timeskew_fullskew_opt_event_based_flag\n%type <spec_optional_args> timeskew_fullskew_opt_remain_active_flag\n\n%type <expr>  assignment_pattern expression expression_opt expr_mintypmax\n%type <expr>  expr_primary_or_typename expr_primary\n%type <expr>  class_new dynamic_array_new\n%type <expr>  var_decl_initializer_opt initializer_opt\n%type <expr>  inc_or_dec_expression inside_expression lpvalue\n%type <expr>  branch_probe_expression streaming_concatenation\n%type <expr>  delay_value delay_value_simple\n%type <exprs> delay1 delay3 delay3_opt delay_value_list\n%type <exprs> expression_list_with_nuls expression_list_proper\n%type <exprs> cont_assign cont_assign_list\n\n%type <decl_assignment> variable_decl_assignment\n%type <decl_assignments> list_of_variable_decl_assignments\n\n%type <data_type>  data_type data_type_opt data_type_or_implicit data_type_or_implicit_or_void\n%type <data_type>  data_type_or_implicit_no_opt\n%type <data_type>  simple_type_or_string let_formal_type\n%type <data_type>  packed_array_data_type\n%type <data_type>  ps_type_identifier\n%type <data_type>  simple_packed_type\n%type <data_type>  class_scope\n%type <struct_member>  struct_union_member\n%type <struct_members> struct_union_member_list\n%type <struct_type>    struct_data_type\n%type <packed_signing> packed_signing\n\n%type <class_declaration_extends> class_declaration_extends_opt\n\n%type <property_qualifier> class_item_qualifier property_qualifier\n%type <property_qualifier> class_item_qualifier_list property_qualifier_list\n%type <property_qualifier> class_item_qualifier_opt property_qualifier_opt\n%type <property_qualifier> random_qualifier\n\n%type <ranges> variable_dimension\n%type <ranges> dimensions_opt dimensions\n\n%type <nettype>  net_type net_type_opt net_type_or_var net_type_or_var_opt\n%type <gatetype> gatetype switchtype\n%type <porttype> port_direction port_direction_opt\n%type <vartype> integer_vector_type\n%type <parmvalue> parameter_value_opt\n\n%type <event_exprs> event_expression_list\n%type <event_expr> event_expression\n%type <event_statement> event_control\n%type <statement> statement statement_item statement_or_null\n%type <statement> compressed_statement\n%type <statement> loop_statement for_step for_step_opt jump_statement\n%type <statement> concurrent_assertion_statement\n%type <statement> deferred_immediate_assertion_statement\n%type <statement> simple_immediate_assertion_statement\n%type <statement> procedural_assertion_statement\n%type <statement_list> statement_or_null_list statement_or_null_list_opt\n\n%type <statement> analog_statement\n\n%type <subroutine_call> subroutine_call\n\n%type <join_keyword> join_keyword\n\n%type <letter> spec_polarity\n%type <perm_strings>  specify_path_identifiers\n\n%type <specpath> specify_simple_path specify_simple_path_decl\n%type <specpath> specify_edge_path specify_edge_path_decl\n\n%type <real_type> non_integer_type\n%type <int_val> assert_or_assume\n%type <int_val> deferred_mode\n%type <atom_type> atom_type\n%type <int_val> module_start module_end\n\n%type <lifetime> lifetime lifetime_opt\n\n%type <case_quality> unique_priority\n\n%type <genvar_iter> genvar_iteration\n\n%type <package> package_scope\n\n%type <letter> compressed_operator\n\n%type <typedef_basic_type> typedef_basic_type\n\n%token K_TAND\n%nonassoc K_PLUS_EQ K_MINUS_EQ K_MUL_EQ K_DIV_EQ K_MOD_EQ K_AND_EQ K_OR_EQ\n%nonassoc K_XOR_EQ K_LS_EQ K_RS_EQ K_RSS_EQ K_NB_TRIGGER\n%right K_TRIGGER K_LEQUIV\n%right '?' ':' K_inside\n%left K_LOR\n%left K_LAND\n%left '|'\n%left '^' K_NXOR K_NOR\n%left '&' K_NAND\n%left K_EQ K_NE K_CEQ K_CNE K_WEQ K_WNE\n%left K_GE K_LE '<' '>'\n%left K_LS K_RS K_RSS\n%left '+' '-'\n%left '*' '/' '%'\n%left K_POW\n%left UNARY_PREC\n\n\n /* to resolve dangling else ambiguity. */\n%nonassoc less_than_K_else\n%nonassoc K_else\n\n /* to resolve exclude (... ambiguity */\n%nonassoc '('\n%nonassoc K_exclude\n\n /* to resolve timeunits declaration/redeclaration ambiguity */\n%nonassoc no_timeunits_declaration\n%nonassoc one_timeunits_declaration\n%nonassoc K_timeunit K_timeprecision\n\n%%\n\n\n  /* IEEE1800-2005: A.1.2 */\n  /* source_text ::= [ timeunits_declaration ] { description } */\nsource_text\n  : timeunits_declaration_opt\n      { pform_set_scope_timescale(yyloc); }\n    description_list\n  | /* empty */\n  ;\n\nassert_or_assume\n  : K_assert\n      { $$ = 1; } /* IEEE1800-2012: Table 20-7 */\n  | K_assume\n      { $$ = 4; } /* IEEE1800-2012: Table 20-7 */\n  ;\n\nassertion_item /* IEEE1800-2012: A.6.10 */\n  : concurrent_assertion_item\n  | deferred_immediate_assertion_item\n  ;\n\nassignment_pattern /* IEEE1800-2005: A.6.7.1 */\n  : K_LP expression_list_proper '}'\n      { PEAssignPattern*tmp = new PEAssignPattern(*$2);\n\tFILE_NAME(tmp, @1);\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | K_LP '}'\n      { PEAssignPattern*tmp = new PEAssignPattern;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\n  /* Some rules have a ... [ block_identifier ':' ] ... part. This\n     implements it in a LALR way. */\nblock_identifier_opt /* */\n  : IDENTIFIER ':'\n      { $$ = $1; }\n  |\n      { $$ = 0; }\n  ;\n\nclass_declaration /* IEEE1800-2005: A.1.2 */\n  : K_virtual_opt K_class lifetime_opt identifier_name class_declaration_extends_opt ';'\n      { /* Up to 1800-2017 the grammar in the LRM allowed an optional lifetime\n\t * qualifier for class declarations. But the LRM never specified what\n\t * this qualifier should do. Starting with 1800-2023 the qualifier has\n\t * been removed from the grammar. Allow it for backwards compatibility,\n\t * but print a warning.\n\t */\n\tif ($3 != LexicalScope::INHERITED) {\n\t      cerr << @1 << \": warning: Class lifetime qualifier is deprecated \"\n\t\t\t    \"and has no effect.\" << endl;\n\t      warn_count += 1;\n\t}\n\tperm_string name = lex_strings.make($4);\n\tclass_type_t *class_type= new class_type_t(name);\n\tFILE_NAME(class_type, @4);\n\tpform_set_typedef(@4, name, class_type, nullptr);\n\tpform_start_class_declaration(@2, class_type, $5.type, $5.args, $1);\n      }\n    class_items_opt K_endclass\n      { // Process a class.\n\tpform_end_class_declaration(@9);\n      }\n    class_declaration_endlabel_opt\n      { // Wrap up the class.\n\tcheck_end_label(@11, \"class\", $4, $11);\n\tdelete[] $4;\n      }\n  ;\n\nclass_constraint /* IEEE1800-2005: A.1.8 */\n  : constraint_prototype\n  | constraint_declaration\n  ;\n\n  // This is used in places where a new type can be declared or an existig type\n  // is referenced. E.g. typedefs.\nidentifier_name\n  : IDENTIFIER { $$ = $1; }\n  | TYPE_IDENTIFIER { $$ = $1.text; }\n  ;\n\n  /* The endlabel after a class declaration is a little tricky because\n     the class name is detected by the lexor as a TYPE_IDENTIFIER if it\n     does indeed match a name. */\nclass_declaration_endlabel_opt\n  : ':' identifier_name { $$ = $2; }\n  | { $$ = 0; }\n  ;\n\n  /* This rule implements [ extends class_type ] in the\n     class_declaration. It is not a rule of its own in the LRM.\n\n     Note that for this to be correct, the identifier after the\n     extends keyword must be a class name. Therefore, match\n     TYPE_IDENTIFIER instead of IDENTIFIER, and this rule will return\n     a data_type. */\n\nclass_declaration_extends_opt /* IEEE1800-2005: A.1.2 */\n  : K_extends ps_type_identifier argument_list_parens_opt\n      { $$.type = $2;\n\t$$.args = $3;\n      }\n  |\n      { $$ = {nullptr, nullptr};\n      }\n  ;\n\n  /* The class_items_opt and class_items rules together implement the\n     rule snippet { class_item } (zero or more class_item) of the\n     class_declaration. */\nclass_items_opt /* IEEE1800-2005: A.1.2 */\n  : class_items\n  |\n  ;\n\nclass_items /* IEEE1800-2005: A.1.2 */\n  : class_items class_item\n  | class_item\n  ;\n\nclass_item /* IEEE1800-2005: A.1.8 */\n\n    /* IEEE1800 A.1.8: class_constructor_declaration */\n  : method_qualifier_opt K_function K_new\n      { assert(current_function==0);\n\tcurrent_function = pform_push_constructor_scope(@3);\n      }\n    tf_port_list_parens_opt ';'\n    block_item_decls_opt\n    statement_or_null_list_opt\n    K_endfunction endnew_opt\n      { current_function->set_ports($5);\n\tpform_set_constructor_return(current_function);\n\tpform_set_this_class(@3, current_function);\n\tcurrent_function_set_statement(@3, $8);\n\tpform_pop_scope();\n\tcurrent_function = 0;\n      }\n\n    /* IEEE1800-2017: A.1.9 Class items: Class properties... */\n\n  | property_qualifier_opt data_type list_of_variable_decl_assignments ';'\n      { pform_class_property(@2, $1, $2, $3); }\n\n  | K_const class_item_qualifier_opt data_type list_of_variable_decl_assignments ';'\n      { pform_class_property(@1, $2 | property_qualifier_t::make_const(), $3, $4); }\n\n    /* IEEEE1800-2017: A.1.9 Class items: class_item ::= { property_qualifier} data_declaration */\n\n    /* TODO: Restrict the access based on the property qualifier. */\n  | property_qualifier_opt type_declaration\n\n    /* IEEE1800-1017: A.1.9 Class items: Class methods... */\n\n  | method_qualifier_opt task_declaration\n      { /* The task_declaration rule puts this into the class */ }\n\n  | method_qualifier_opt function_declaration\n      { /* The function_declaration rule puts this into the class */ }\n\n    /* External class method definitions... */\n\n  | K_extern method_qualifier_opt K_function K_new tf_port_list_parens_opt ';'\n      { yyerror(@1, \"sorry: External constructors are not yet supported.\"); }\n  | K_extern method_qualifier_opt K_function data_type_or_implicit_or_void\n    IDENTIFIER tf_port_list_parens_opt ';'\n      { yyerror(@1, \"sorry: External methods are not yet supported.\");\n\tdelete[] $5;\n      }\n  | K_extern method_qualifier_opt K_task IDENTIFIER tf_port_list_parens_opt ';'\n      { yyerror(@1, \"sorry: External methods are not yet supported.\");\n\tdelete[] $4;\n      }\n\n    /* Class constraints... */\n\n  | class_constraint\n\n    /* Here are some error matching rules to help recover from various\n       syntax errors within a class declaration. */\n\n  | property_qualifier_opt data_type error ';'\n      { yyerror(@3, \"error: Errors in variable names after data type.\");\n\tyyerrok;\n      }\n\n  | property_qualifier_opt IDENTIFIER error ';'\n      { yyerror(@3, \"error: %s doesn't name a type.\", $2);\n\tyyerrok;\n      }\n\n  | method_qualifier_opt K_function K_new error K_endfunction endnew_opt\n      { yyerror(@1, \"error: I give up on this class constructor declaration.\");\n\tyyerrok;\n      }\n\n  | parameter_declaration\n\n    /* Empty class item */\n  | ';'\n\n  | error ';'\n      { yyerror(@2, \"error: Invalid class item.\");\n\tyyerrok;\n      }\n\n  ;\n\nclass_item_qualifier /* IEEE1800-2005 A.1.8 */\n  : K_static     { $$ = property_qualifier_t::make_static(); }\n  | K_protected  { $$ = property_qualifier_t::make_protected(); }\n  | K_local      { $$ = property_qualifier_t::make_local(); }\n  ;\n\nclass_item_qualifier_list\n  : class_item_qualifier_list class_item_qualifier { $$ = $1 | $2; }\n  | class_item_qualifier { $$ = $1; }\n  ;\n\nclass_item_qualifier_opt\n  : class_item_qualifier_list { $$ = $1; }\n  | { $$ = property_qualifier_t::make_none(); }\n  ;\n\nclass_scope\n  : ps_type_identifier K_SCOPE_RES { $$ = $1; }\n\nclass_new /* IEEE1800-2005 A.2.4 */\n  : K_new argument_list_parens_opt\n      { PENewClass*tmp = new PENewClass(*$2);\n\tFILE_NAME(tmp, @1);\n\tdelete $2;\n\t$$ = tmp;\n      }\n    // This can't be a class_scope_opt because it will lead to shift/reduce\n    // conflicts with array_new\n  | class_scope K_new argument_list_parens_opt\n      { PENewClass *new_expr = new PENewClass(*$3, $1);\n\tFILE_NAME(new_expr, @2);\n\tdelete $3;\n\t$$ = new_expr;\n      }\n  | K_new hierarchy_identifier\n      { PEIdent*tmpi = new PEIdent(*$2, @2.lexical_pos);\n\tFILE_NAME(tmpi, @2);\n\tPENewCopy*tmp = new PENewCopy(tmpi);\n\tFILE_NAME(tmp, @1);\n\tdelete $2;\n\t$$ = tmp;\n      }\n  ;\n\n  /* The concurrent_assertion_item pulls together the\n     concurrent_assertion_statement and checker_instantiation rules. */\n\nconcurrent_assertion_item /* IEEE1800-2012 A.2.10 */\n  : block_identifier_opt concurrent_assertion_statement\n      { delete $1;\n\tdelete $2;\n      }\n  ;\n\nconcurrent_assertion_statement /* IEEE1800-2012 A.2.10 */\n  : assert_or_assume K_property '(' property_spec ')' statement_or_null %prec less_than_K_else\n      { /* */\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: concurrent_assertion_item not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n        $$ = 0;\n      }\n  | assert_or_assume K_property '(' property_spec ')' K_else statement_or_null\n      { /* */\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: concurrent_assertion_item not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n        $$ = 0;\n      }\n  | assert_or_assume K_property '(' property_spec ')' statement_or_null K_else statement_or_null\n      { /* */\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: concurrent_assertion_item not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n        $$ = 0;\n      }\n  | K_cover K_property '(' property_spec ')' statement_or_null\n      { /* */\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: concurrent_assertion_item not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n        $$ = 0;\n      }\n      /* For now, cheat, and use property_spec for the sequence specification.\n         They are syntactically identical. */\n  | K_cover K_sequence '(' property_spec ')' statement_or_null\n      { /* */\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: concurrent_assertion_item not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n        $$ = 0;\n      }\n  | K_restrict K_property '(' property_spec ')' ';'\n      { /* */\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@2, \"sorry: concurrent_assertion_item not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n        $$ = 0;\n      }\n  | assert_or_assume K_property '(' error ')' statement_or_null %prec less_than_K_else\n      { yyerrok;\n        yyerror(@2, \"error: Error in property_spec of concurrent assertion item.\");\n        $$ = 0;\n      }\n  | assert_or_assume K_property '(' error ')' K_else statement_or_null\n      { yyerrok;\n        yyerror(@2, \"error: Error in property_spec of concurrent assertion item.\");\n        $$ = 0;\n      }\n  | assert_or_assume K_property '(' error ')' statement_or_null K_else statement_or_null\n      { yyerrok;\n        yyerror(@2, \"error: Error in property_spec of concurrent assertion item.\");\n        $$ = 0;\n      }\n  | K_cover K_property '(' error ')' statement_or_null\n      { yyerrok;\n        yyerror(@2, \"error: Error in property_spec of concurrent assertion item.\");\n        $$ = 0;\n      }\n  | K_cover K_sequence '(' error ')' statement_or_null\n      { yyerrok;\n        yyerror(@2, \"error: Error in property_spec of concurrent assertion item.\");\n        $$ = 0;\n      }\n  | K_restrict K_property '(' error ')' ';'\n      { yyerrok;\n        yyerror(@2, \"error: Error in property_spec of concurrent assertion item.\");\n        $$ = 0;\n      }\n  ;\n\nconstraint_block_item /* IEEE1800-2005 A.1.9 */\n  : constraint_expression\n  ;\n\nconstraint_block_item_list\n  : constraint_block_item_list constraint_block_item\n  | constraint_block_item\n  ;\n\nconstraint_block_item_list_opt\n  :\n  | constraint_block_item_list\n  ;\n\nconstraint_declaration /* IEEE1800-2005: A.1.9 */\n  : K_static_opt K_constraint IDENTIFIER '{' constraint_block_item_list_opt '}'\n      { yyerror(@2, \"sorry: Constraint declarations not supported.\"); }\n\n  /* Error handling rules... */\n\n  | K_static_opt K_constraint IDENTIFIER '{' error '}'\n      { yyerror(@4, \"error: Errors in the constraint block item list.\"); }\n  ;\n\nconstraint_expression /* IEEE1800-2005 A.1.9 */\n  : expression ';'\n  | expression K_dist '{' '}' ';'\n  | expression constraint_trigger\n  | K_if '(' expression ')' constraint_set %prec less_than_K_else\n  | K_if '(' expression ')' constraint_set K_else constraint_set\n  | K_foreach '(' IDENTIFIER '[' loop_variables ']' ')' constraint_set\n  ;\n\nconstraint_trigger\n  : K_CONSTRAINT_IMPL '{' constraint_expression_list '}'\n  ;\n\nconstraint_expression_list /* */\n  : constraint_expression_list constraint_expression\n  | constraint_expression\n  ;\n\nconstraint_prototype /* IEEE1800-2005: A.1.9 */\n  : K_static_opt K_constraint IDENTIFIER ';'\n      { yyerror(@2, \"sorry: Constraint prototypes not supported.\"); }\n  ;\n\nconstraint_set /* IEEE1800-2005 A.1.9 */\n  : constraint_expression\n  | '{' constraint_expression_list '}'\n  ;\n\ndata_declaration /* IEEE1800-2005: A.2.1.3 */\n   : attribute_list_opt K_const_opt data_type list_of_variable_decl_assignments ';'\n      { data_type_t *data_type = $3;\n\tif (!data_type) {\n\t      data_type = new vector_type_t(IVL_VT_LOGIC, false, 0);\n\t      FILE_NAME(data_type, @3);\n\t}\n\tpform_makewire(@3, 0, str_strength, $4, NetNet::IMPLICIT_REG, data_type,\n\t\t       $1, $2);\n      }\n  | attribute_list_opt K_const_opt K_var data_type_or_implicit list_of_variable_decl_assignments ';'\n      { data_type_t *data_type = $4;\n\tif (!data_type) {\n\t      data_type = new vector_type_t(IVL_VT_LOGIC, false, 0);\n\t      FILE_NAME(data_type, @3);\n\t}\n\tpform_make_var(@3, $5, data_type, $1, $2);\n      }\n  | attribute_list_opt K_event event_variable_list ';'\n      { if ($3) pform_make_events(@2, $3);\n      }\n  | attribute_list_opt package_import_declaration\n  ;\n\npackage_scope\n  : PACKAGE_IDENTIFIER K_SCOPE_RES\n      { lex_in_package_scope($1);\n        $$ = $1;\n      }\n  ;\n\nps_type_identifier /* IEEE1800-2017: A.9.3 */\n : TYPE_IDENTIFIER\n      { pform_set_type_referenced(@1, $1.text);\n\tdelete[]$1.text;\n\t$$ = new typeref_t($1.type);\n\tFILE_NAME($$, @1);\n      }\n  | package_scope TYPE_IDENTIFIER\n      { lex_in_package_scope(0);\n\t$$ = new typeref_t($2.type, $1);\n\tFILE_NAME($$, @2);\n\tdelete[] $2.text;\n      }\n  ;\n\n/* Data types that can have packed dimensions directly attached to it */\npacked_array_data_type /* IEEE1800-2005: A.2.2.1 */\n  : enum_data_type\n      { $$ = $1; }\n  | struct_data_type\n      { if (!$1->packed_flag) {\n\t      yyerror(@1, \"sorry: Unpacked structs not supported.\");\n        }\n\t$$ = $1;\n      }\n  | ps_type_identifier\n  ;\n\nsimple_packed_type /* Integer and vector types */\n  : integer_vector_type unsigned_signed_opt dimensions_opt\n      { vector_type_t*tmp = new vector_type_t($1, $2, $3);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | atom_type signed_unsigned_opt\n      { atom_type_t*tmp = new atom_type_t($1, $2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_time unsigned_signed_opt\n      { atom_type_t*tmp = new atom_type_t(atom_type_t::TIME, $2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\ndata_type /* IEEE1800-2005: A.2.2.1 */\n  : simple_packed_type\n      { $$ = $1;\n      }\n  | non_integer_type\n      { real_type_t*tmp = new real_type_t($1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | packed_array_data_type dimensions_opt\n      { if ($2) {\n\t      parray_type_t*tmp = new parray_type_t($1, $2);\n\t      FILE_NAME(tmp, @1);\n\t      $$ = tmp;\n        } else {\n\t      $$ = $1;\n        }\n      }\n  | K_string\n      { string_type_t*tmp = new string_type_t;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\n/* Data type or nothing, but not implicit */\ndata_type_opt\n  : data_type { $$ = $1; }\n  | { $$ = 0; }\n\n  /* The data_type_or_implicit rule is a little more complex then the\n     rule documented in the IEEE format syntax in order to allow for\n     signaling the special case that the data_type is completely\n     absent. The context may need that information to decide to resort\n     to left context. */\n\nscalar_vector_opt /*IEEE1800-2005: optional support for packed array */\n  : K_vectored\n      { /* Ignore */ }\n  | K_scalared\n      { /* Ignore */ }\n  |\n      { /* Ignore */ }\n  ;\n\ndata_type_or_implicit /* IEEE1800-2005: A.2.2.1 */\n  : data_type_or_implicit_no_opt\n  | { $$ = nullptr; }\n\ndata_type_or_implicit_no_opt\n  : data_type\n      { $$ = $1; }\n  | signing dimensions_opt\n      { vector_type_t*tmp = new vector_type_t(IVL_VT_LOGIC, $1, $2);\n\ttmp->implicit_flag = true;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | scalar_vector_opt dimensions\n      { vector_type_t*tmp = new vector_type_t(IVL_VT_LOGIC, false, $2);\n\ttmp->implicit_flag = true;\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  ;\n\n\ndata_type_or_implicit_or_void\n  : data_type_or_implicit\n      { $$ = $1; }\n  | K_void\n      { void_type_t*tmp = new void_type_t;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\ndeferred_immediate_assertion_item /* IEEE1800-2012: A.6.10 */\n  : block_identifier_opt deferred_immediate_assertion_statement\n      { delete $1;\n\tdelete $2;\n      }\n  ;\n\ndeferred_immediate_assertion_statement /* IEEE1800-2012 A.6.10 */\n  : assert_or_assume deferred_mode '(' expression ')' statement_or_null %prec less_than_K_else\n      {\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: Deferred assertions are not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n\tdelete $4;\n\tdelete $6;\n\t$$ = 0;\n      }\n  | assert_or_assume deferred_mode '(' expression ')' K_else statement_or_null\n      {\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: Deferred assertions are not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n\tdelete $4;\n\tdelete $7;\n\t$$ = 0;\n      }\n  | assert_or_assume deferred_mode '(' expression ')' statement_or_null K_else statement_or_null\n      {\n\tif (gn_unsupported_assertions_flag) {\n\t      yyerror(@1, \"sorry: Deferred assertions are not supported.\"\n\t\t      \" Try -gno-assertions or -gsupported-assertions\"\n\t\t      \" to turn this message off.\");\n\t}\n\tdelete $4;\n\tdelete $6;\n\tdelete $8;\n\t$$ = 0;\n      }\n  | K_cover deferred_mode '(' expression ')' statement_or_null\n      {\n\t  /* Coverage collection is not currently supported. */\n\tdelete $4;\n\tdelete $6;\n\t$$ = 0;\n      }\n  | assert_or_assume deferred_mode '(' error ')' statement_or_null %prec less_than_K_else\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $6;\n      }\n  | assert_or_assume deferred_mode '(' error ')' K_else statement_or_null\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $7;\n      }\n  | assert_or_assume deferred_mode '(' error ')' statement_or_null K_else statement_or_null\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $6;\n      }\n  | K_cover deferred_mode '(' error ')' statement_or_null\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $6;\n      }\n  ;\n\ndeferred_mode\n  : '#' DEC_NUMBER\n      { if (!$2->is_zero()) {\n\t      yyerror(@2, \"error: Delay value must be zero for deferred assertion.\");\n\t}\n        delete $2;\n\t$$ = 0; }\n  | K_final\n      { $$ = 1; }\n  ;\n\n  /* NOTE: The \"module\" rule of the description combines the\n     module_declaration, program_declaration, and interface_declaration\n     rules from the standard description. */\n\ndescription /* IEEE1800-2005: A.1.2 */\n  : module\n  | udp_primitive\n  | config_declaration\n  | nature_declaration\n  | package_declaration\n  | discipline_declaration\n  | package_item\n  | KK_attribute '(' IDENTIFIER ',' STRING ',' STRING ')'\n      { perm_string tmp3 = lex_strings.make($3);\n\tpform_set_type_attrib(tmp3, $5, $7);\n\tdelete[] $3;\n\tdelete[] $5;\n      }\n  | ';'\n      { }\n  ;\n\ndescription_list\n  : description\n  | description_list description\n  ;\n\n\n   /* This implements the [ : IDENTIFIER ] part of the constructor\n      rule documented in IEEE1800-2005: A.1.8 */\nendnew_opt : ':' K_new | ;\n\n  /* The dynamic_array_new rule is kinda like an expression, but it is\n     treated differently by rules that use this \"expression\". Watch out! */\n\ndynamic_array_new /* IEEE1800-2005: A.2.4 */\n  : K_new '[' expression ']'\n      { $$ = new PENewArray($3, 0);\n\tFILE_NAME($$, @1);\n      }\n  | K_new '[' expression ']' '(' expression ')'\n      { $$ = new PENewArray($3, $6);\n\tFILE_NAME($$, @1);\n      }\n  ;\n\nfor_step /* IEEE1800-2005: A.6.8 */\n  : lpvalue '=' expression\n      { PAssign*tmp = new PAssign($1,$3);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | inc_or_dec_expression\n      { $$ = pform_compressed_assign_from_inc_dec(@1, $1); }\n  | compressed_statement\n      { $$ = $1; }\n  ;\n\nfor_step_opt\n  : for_step { $$ = $1; }\n  | { $$ = nullptr; }\n  ;\n\n  /* The function declaration rule matches the function declaration\n     header, then pushes the function scope. This causes the\n     definitions in the func_body to take on the scope of the function\n     instead of the module. */\nfunction_declaration /* IEEE1800-2005: A.2.6 */\n  : K_function lifetime_opt data_type_or_implicit_or_void IDENTIFIER ';'\n      { assert(current_function == 0);\n\tcurrent_function = pform_push_function_scope(@1, $4, $2);\n      }\n    tf_item_list_opt\n    statement_or_null_list_opt\n    K_endfunction\n      { current_function->set_ports($7);\n\tcurrent_function->set_return($3);\n\tcurrent_function_set_statement($8? @8 : @4, $8);\n\tpform_set_this_class(@4, current_function);\n\tpform_pop_scope();\n\tcurrent_function = 0;\n      }\n    label_opt\n      { // Last step: check any closing name.\n\tcheck_end_label(@11, \"function\", $4, $11);\n\tdelete[]$4;\n      }\n\n  | K_function lifetime_opt data_type_or_implicit_or_void IDENTIFIER\n      { assert(current_function == 0);\n\tcurrent_function = pform_push_function_scope(@1, $4, $2);\n      }\n    '(' tf_port_list_opt ')' ';'\n    block_item_decls_opt\n    statement_or_null_list_opt\n    K_endfunction\n      { current_function->set_ports($7);\n\tcurrent_function->set_return($3);\n\tcurrent_function_set_statement($11? @11 : @4, $11);\n\tpform_set_this_class(@4, current_function);\n\tpform_pop_scope();\n\tcurrent_function = 0;\n\tif ($7 == 0) {\n\t      pform_requires_sv(@4, \"Functions with no ports\");\n\t}\n      }\n    label_opt\n      { // Last step: check any closing name.\n\tcheck_end_label(@14, \"function\", $4, $14);\n\tdelete[]$4;\n      }\n\n  /* Detect and recover from some errors. */\n\n  | K_function lifetime_opt data_type_or_implicit_or_void IDENTIFIER error K_endfunction\n      { /* */\n\tif (current_function) {\n\t      pform_pop_scope();\n\t      current_function = 0;\n\t}\n\tassert(current_function == 0);\n\tyyerror(@1, \"error: Syntax error defining function.\");\n\tyyerrok;\n      }\n    label_opt\n      { // Last step: check any closing name.\n\tcheck_end_label(@8, \"function\", $4, $8);\n\tdelete[]$4;\n      }\n\n  ;\n\ngenvar_iteration /* IEEE1800-2012: A.4.2 */\n  : IDENTIFIER '=' expression\n      { $$.text = $1;\n        $$.expr = $3;\n      }\n  | IDENTIFIER compressed_operator expression\n      { $$.text = $1;\n        $$.expr = pform_genvar_compressed(@1, $1, $2, $3);;\n      }\n  | IDENTIFIER K_INCR\n      { $$.text = $1;\n        $$.expr = pform_genvar_inc_dec(@1, $1, true);\n      }\n  | IDENTIFIER K_DECR\n      { $$.text = $1;\n        $$.expr = pform_genvar_inc_dec(@1, $1, false);\n      }\n  | K_INCR IDENTIFIER\n      { $$.text = $2;\n        $$.expr = pform_genvar_inc_dec(@1, $2, true);\n      }\n  | K_DECR IDENTIFIER\n      { $$.text = $2;\n        $$.expr = pform_genvar_inc_dec(@1, $2, false);\n      }\n  ;\n\nimport_export /* IEEE1800-2012: A.2.9 */\n  : K_import { $$ = true; }\n  | K_export { $$ = false; }\n  ;\n\nimplicit_class_handle /* IEEE1800-2005: A.8.4 */\n  : K_this '.' { $$ = pform_create_this(); }\n  | K_super '.' { $$ = pform_create_super(); }\n  | K_this '.' K_super '.' { $$ = pform_create_super(); }\n  ;\n\n/* `this` or `super` followed by an identifier */\nclass_hierarchy_identifier\n  : implicit_class_handle hierarchy_identifier\n      { $1->splice($1->end(), *$2);\n\tdelete $2;\n\t$$ = $1;\n      }\n  ;\n\n  /* SystemVerilog adds support for the increment/decrement\n     expressions, which look like a++, --a, etc. These are primaries\n     but are in their own rules because they can also be\n     statements. Note that the operator can only take l-value\n     expressions. */\n\ninc_or_dec_expression /* IEEE1800-2005: A.4.3 */\n  : K_INCR lpvalue %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('I', $2);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | lpvalue K_INCR %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('i', $1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_DECR lpvalue %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('D', $2);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | lpvalue K_DECR %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('d', $1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\ninside_expression /* IEEE1800-2005 A.8.3 */\n  : expression K_inside '{' open_range_list '}'\n      { yyerror(@2, \"sorry: \\\"inside\\\" expressions not supported yet.\");\n\t$$ = 0;\n      }\n  ;\n\ninteger_vector_type /* IEEE1800-2005: A.2.2.1 */\n  : K_reg   { $$ = IVL_VT_LOGIC; } /* A synonym for logic. */\n  | K_bit   { $$ = IVL_VT_BOOL; }\n  | K_logic { $$ = IVL_VT_LOGIC; }\n  | K_bool  { $$ = IVL_VT_BOOL; } /* Icarus Verilog xtypes extension */\n  ;\n\njoin_keyword /* IEEE1800-2005: A.6.3 */\n  : K_join\n      { $$ = PBlock::BL_PAR; }\n  | K_join_none\n      { $$ = PBlock::BL_JOIN_NONE; }\n  | K_join_any\n      { $$ = PBlock::BL_JOIN_ANY; }\n  ;\n\njump_statement /* IEEE1800-2005: A.6.5 */\n  : K_break ';'\n      { PBreak*tmp = new PBreak;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_continue ';'\n      { PContinue*tmp = new PContinue;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_return ';'\n      { PReturn*tmp = new PReturn(0);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_return expression ';'\n      { PReturn*tmp = new PReturn($2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\nlifetime /* IEEE1800-2005: A.2.1.3 */\n  : K_automatic { $$ = LexicalScope::AUTOMATIC; }\n  | K_static    { $$ = LexicalScope::STATIC; }\n  ;\n\nlifetime_opt /* IEEE1800-2005: A.2.1.3 */\n  : lifetime { $$ = $1; }\n  |          { $$ = LexicalScope::INHERITED; }\n  ;\n\n  /* Loop statements are kinds of statements. */\n\nloop_statement /* IEEE1800-2005: A.6.8 */\n  : K_for '(' lpvalue '=' expression ';' expression_opt ';' for_step_opt ')'\n    statement_or_null\n      { check_for_loop(@1, $5, $7, $9);\n\tPForStatement*tmp = new PForStatement($3, $5, $7, $9, $11);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n      // The initialization statement is optional.\n  | K_for '(' ';' expression_opt ';' for_step_opt ')'\n    statement_or_null\n      { check_for_loop(@1, nullptr, $4, $6);\n\tPForStatement*tmp = new PForStatement(nullptr, nullptr, $4, $6, $8);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n      // Handle for_variable_declaration syntax by wrapping the for(...)\n      // statement in a synthetic named block. We can name the block\n      // after the variable that we are creating, that identifier is\n      // safe in the controlling scope.\n  | K_for '(' K_var_opt data_type IDENTIFIER '=' expression ';' expression_opt ';' for_step_opt ')'\n      { static unsigned for_counter = 0;\n\tchar for_block_name [64];\n\tsnprintf(for_block_name, sizeof for_block_name, \"$ivl_for_loop%u\", for_counter);\n\tfor_counter += 1;\n\tPBlock*tmp = pform_push_block_scope(@1, for_block_name, PBlock::BL_SEQ);\n\tcurrent_block_stack.push(tmp);\n\n\tlist<decl_assignment_t*>assign_list;\n\tdecl_assignment_t*tmp_assign = new decl_assignment_t;\n\ttmp_assign->name = { lex_strings.make($5), @5.lexical_pos };\n\tassign_list.push_back(tmp_assign);\n\tpform_make_var(@5, &assign_list, $4);\n      }\n    statement_or_null\n      { pform_name_t tmp_hident;\n\ttmp_hident.push_back(name_component_t(lex_strings.make($5)));\n\n\tPEIdent*tmp_ident = pform_new_ident(@5, tmp_hident);\n\tFILE_NAME(tmp_ident, @5);\n\n\tcheck_for_loop(@1, $7, $9, $11);\n\tPForStatement*tmp_for = new PForStatement(tmp_ident, $7, $9, $11, $14);\n\tFILE_NAME(tmp_for, @1);\n\n\tpform_pop_scope();\n\tvector<Statement*>tmp_for_list (1);\n\ttmp_for_list[0] = tmp_for;\n\tPBlock*tmp_blk = current_block_stack.top();\n\tcurrent_block_stack.pop();\n\ttmp_blk->set_statement(tmp_for_list);\n\t$$ = tmp_blk;\n\tdelete[]$5;\n      }\n\n  | K_forever statement_or_null\n      { PForever*tmp = new PForever($2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  | K_repeat '(' expression ')' statement_or_null\n      { PRepeat*tmp = new PRepeat($3, $5);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  | K_while '(' expression ')' statement_or_null\n      { PWhile*tmp = new PWhile($3, $5);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  | K_do statement_or_null K_while '(' expression ')' ';'\n      { PDoWhile*tmp = new PDoWhile($5, $2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n      // When matching a foreach loop, implicitly create a named block\n      // to hold the definitions for the index variables.\n  | K_foreach '(' IDENTIFIER '[' loop_variables ']' ')'\n      { static unsigned foreach_counter = 0;\n\tchar for_block_name[64];\n\tsnprintf(for_block_name, sizeof for_block_name, \"$ivl_foreach%u\", foreach_counter);\n\tforeach_counter += 1;\n\n\tPBlock*tmp = pform_push_block_scope(@1, for_block_name, PBlock::BL_SEQ);\n\tcurrent_block_stack.push(tmp);\n\n\tpform_make_foreach_declarations(@1, $5);\n      }\n    statement_or_null\n      { PForeach*tmp_for = pform_make_foreach(@1, $3, $5, $9);\n\n\tpform_pop_scope();\n\tvector<Statement*>tmp_for_list(1);\n\ttmp_for_list[0] = tmp_for;\n\tPBlock*tmp_blk = current_block_stack.top();\n\tcurrent_block_stack.pop();\n\ttmp_blk->set_statement(tmp_for_list);\n\t$$ = tmp_blk;\n      }\n\n  /* Error forms for loop statements. */\n\n  | K_for '(' lpvalue '=' expression ';' expression_opt ';' error ')'\n    statement_or_null\n      { $$ = 0;\n\tyyerror(@1, \"error: Error in for loop step assignment.\");\n      }\n\n  | K_for '(' lpvalue '=' expression ';' error ';' for_step_opt ')'\n    statement_or_null\n      { $$ = 0;\n\tyyerror(@1, \"error: Error in for loop condition expression.\");\n      }\n\n  | K_for '(' error ')' statement_or_null\n      { $$ = 0;\n\tyyerror(@1, \"error: Incomprehensible for loop.\");\n      }\n\n  | K_while '(' error ')' statement_or_null\n      { $$ = 0;\n\tyyerror(@1, \"error: Error in while loop condition.\");\n      }\n\n  | K_do statement_or_null K_while '(' error ')' ';'\n      { $$ = 0;\n\tyyerror(@1, \"error: Error in do/while loop condition.\");\n      }\n\n  | K_foreach '(' IDENTIFIER '[' error ']' ')' statement_or_null\n      { $$ = 0;\n        yyerror(@4, \"error: Errors in foreach loop variables list.\");\n      }\n  ;\n\n\nlist_of_variable_decl_assignments /* IEEE1800-2005 A.2.3 */\n  : variable_decl_assignment\n      { std::list<decl_assignment_t*>*tmp = new std::list<decl_assignment_t*>;\n\ttmp->push_back($1);\n\t$$ = tmp;\n      }\n  | list_of_variable_decl_assignments ',' variable_decl_assignment\n      { std::list<decl_assignment_t*>*tmp = $1;\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  ;\n\ninitializer_opt\n : '=' expression { $$ = $2; }\n | { $$ = nullptr; }\n ;\n\nvar_decl_initializer_opt\n : initializer_opt\n | '=' class_new { $$ = $2; }\n | '=' dynamic_array_new { $$ = $2; }\n ;\n\nvariable_decl_assignment /* IEEE1800-2005 A.2.3 */\n  : IDENTIFIER dimensions_opt var_decl_initializer_opt\n      { if ($3 && pform_peek_scope()->var_init_needs_explicit_lifetime()\n\t    && (var_lifetime == LexicalScope::INHERITED)) {\n\t      cerr << @1 << \": warning: Static variable initialization requires \"\n\t\t\t    \"explicit lifetime in this context.\" << endl;\n\t      warn_count += 1;\n\t}\n\n\tdecl_assignment_t*tmp = new decl_assignment_t;\n\ttmp->name = { lex_strings.make($1), @1.lexical_pos };\n\tif ($2) {\n\t      tmp->index = *$2;\n\t      delete $2;\n\t}\n\ttmp->expr.reset($3);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  ;\n\n\nloop_variables /* IEEE1800-2005: A.6.8 */\n  : loop_variables ',' IDENTIFIER\n      { std::list<perm_string>*tmp = $1;\n\ttmp->push_back(lex_strings.make($3));\n\tdelete[]$3;\n\t$$ = tmp;\n      }\n  | loop_variables ','\n      { std::list<perm_string>*tmp = $1;\n\ttmp->push_back(perm_string());\n\t$$ = tmp;\n      }\n  | IDENTIFIER\n      { std::list<perm_string>*tmp = new std::list<perm_string>;\n\ttmp->push_back(lex_strings.make($1));\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  |\n      { std::list<perm_string>*tmp = new std::list<perm_string>;\n\ttmp->push_back(perm_string());\n\t$$ = tmp;\n      }\n  ;\n\nmethod_qualifier /* IEEE1800-2005: A.1.8 */\n  : K_virtual\n  | class_item_qualifier\n  ;\n\nmethod_qualifier_opt\n  : method_qualifier\n  |\n  ;\n\nmodport_declaration /* IEEE1800-2012: A.2.9 */\n  : K_modport\n      { if (!pform_in_interface())\n\t      yyerror(@1, \"error: modport declarations are only allowed \"\n\t\t\t  \"in interfaces.\");\n      }\n    modport_item_list ';'\n\nmodport_item_list\n  : modport_item\n  | modport_item_list ',' modport_item\n  ;\n\nmodport_item\n  : IDENTIFIER\n      { pform_start_modport_item(@1, $1); }\n    '(' modport_ports_list ')'\n      { pform_end_modport_item(@1); }\n  ;\n\n  /* The modport_ports_list is a LALR(2) grammar. When the parser sees a\n     ',' it needs to look ahead to the next token to decide whether it is\n     a continuation of the preceding modport_ports_declaration, or the\n     start of a new modport_ports_declaration. bison only supports LALR(1),\n     so we have to handcraft a mini parser for this part of the syntax.\n     last_modport_port holds the state for this mini parser.*/\n\nmodport_ports_list\n  : modport_ports_declaration\n  | modport_ports_list ',' modport_ports_declaration\n  | modport_ports_list ',' named_expression\n      { if (last_modport_port.type == MP_SIMPLE) {\n\t      pform_add_modport_port(@3, last_modport_port.direction,\n\t\t\t\t     $3->name, $3->parm);\n\t} else {\n\t      yyerror(@3, \"error: modport expression not allowed here.\");\n\t}\n\tdelete $3;\n      }\n  | modport_ports_list ',' modport_tf_port\n      { if (last_modport_port.type != MP_TF)\n\t      yyerror(@3, \"error: task/function declaration not allowed here.\");\n      }\n  | modport_ports_list ',' IDENTIFIER\n      { if (last_modport_port.type == MP_SIMPLE) {\n\t      pform_add_modport_port(@3, last_modport_port.direction,\n\t\t\t\t     lex_strings.make($3), 0);\n\t} else if (last_modport_port.type != MP_TF) {\n\t      yyerror(@3, \"error: List of identifiers not allowed here.\");\n\t}\n\tdelete[] $3;\n      }\n  | modport_ports_list ','\n      { yyerror(@2, \"error: Superfluous comma in port declaration list.\"); }\n  ;\n\nmodport_ports_declaration\n  : attribute_list_opt port_direction IDENTIFIER\n      { last_modport_port.type = MP_SIMPLE;\n\tlast_modport_port.direction = $2;\n\tpform_add_modport_port(@3, $2, lex_strings.make($3), 0);\n\tdelete[] $3;\n\tdelete $1;\n      }\n  | attribute_list_opt port_direction named_expression\n      { last_modport_port.type = MP_SIMPLE;\n\tlast_modport_port.direction = $2;\n\tpform_add_modport_port(@3, $2, $3->name, $3->parm);\n\tdelete $3;\n\tdelete $1;\n      }\n  | attribute_list_opt import_export IDENTIFIER\n      { last_modport_port.type = MP_TF;\n\tlast_modport_port.is_import = $2;\n\tyyerror(@3, \"sorry: modport task/function ports are not yet supported.\");\n\tdelete[] $3;\n\tdelete $1;\n      }\n  | attribute_list_opt import_export modport_tf_port\n      { last_modport_port.type = MP_TF;\n\tlast_modport_port.is_import = $2;\n\tyyerror(@3, \"sorry: modport task/function ports are not yet supported.\");\n\tdelete $1;\n      }\n  | attribute_list_opt K_clocking IDENTIFIER\n      { last_modport_port.type = MP_CLOCKING;\n\tlast_modport_port.direction = NetNet::NOT_A_PORT;\n\tyyerror(@3, \"sorry: modport clocking declaration is not yet supported.\");\n\tdelete[] $3;\n\tdelete $1;\n      }\n  ;\n\nmodport_tf_port\n  : K_task IDENTIFIER tf_port_list_parens_opt\n  | K_function data_type_or_implicit_or_void IDENTIFIER tf_port_list_parens_opt\n  ;\n\nnon_integer_type /* IEEE1800-2005: A.2.2.1 */\n  : K_real { $$ = real_type_t::REAL; }\n  | K_realtime { $$ = real_type_t::REAL; }\n  | K_shortreal { $$ = real_type_t::SHORTREAL; }\n  ;\n\nnumber\n  : BASED_NUMBER\n      { $$ = $1; based_size = 0;}\n  | DEC_NUMBER\n      { $$ = $1; based_size = 0;}\n  | DEC_NUMBER BASED_NUMBER\n      { $$ = pform_verinum_with_size($1,$2, @2.text, @2.first_line);\n\tbased_size = 0; }\n  | UNBASED_NUMBER\n      { $$ = $1; based_size = 0;}\n  | DEC_NUMBER UNBASED_NUMBER\n      { yyerror(@1, \"error: Unbased SystemVerilog literal cannot have a size.\");\n\t$$ = $1; based_size = 0;}\n  ;\n\nopen_range_list /* IEEE1800-2005 A.2.11 */\n  : open_range_list ',' value_range\n  | value_range\n  ;\n\npackage_declaration /* IEEE1800-2005 A.1.2 */\n  : K_package lifetime_opt IDENTIFIER ';'\n      { pform_start_package_declaration(@1, $3, $2); }\n    timeunits_declaration_opt\n      { pform_set_scope_timescale(@1); }\n    package_item_list_opt\n    K_endpackage label_opt\n      { pform_end_package_declaration(@1);\n\tcheck_end_label(@10, \"package\", $3, $10);\n\tdelete[]$3;\n      }\n  ;\n\nmodule_package_import_list_opt\n  :\n  | package_import_list\n  ;\n\npackage_import_list\n  : package_import_declaration\n  | package_import_list package_import_declaration\n  ;\n\npackage_import_declaration /* IEEE1800-2005 A.2.1.3 */\n  : K_import package_import_item_list ';'\n      { }\n  ;\n\npackage_import_item\n  : package_scope IDENTIFIER\n      { lex_in_package_scope(0);\n\tpform_package_import(@1, $1, $2);\n\tdelete[]$2;\n      }\n  | package_scope TYPE_IDENTIFIER\n      { lex_in_package_scope(0);\n\tpform_package_import(@1, $1, $2.text);\n\tdelete[]$2.text;\n      }\n  | package_scope '*'\n      { lex_in_package_scope(0);\n        pform_package_import(@1, $1, 0);\n      }\n  ;\n\npackage_import_item_list\n  : package_import_item_list',' package_import_item\n  | package_import_item\n  ;\n\npackage_export_declaration /* IEEE1800-2017 A.2.1.3 */\n  : K_export package_export_item_list ';'\n  | K_export '*' K_SCOPE_RES '*' ';' { pform_package_export(@$, nullptr, nullptr); }\n  ;\n\npackage_export_item\n  : PACKAGE_IDENTIFIER K_SCOPE_RES IDENTIFIER\n      { pform_package_export(@2, $1, $3);\n\tdelete[] $3;\n      }\n  | PACKAGE_IDENTIFIER K_SCOPE_RES TYPE_IDENTIFIER\n      { pform_package_export(@2, $1, $3.text);\n\tdelete[] $3.text;\n      }\n  | PACKAGE_IDENTIFIER K_SCOPE_RES '*'\n      { pform_package_export(@2, $1, nullptr);\n      }\n  ;\n\npackage_export_item_list\n  : package_export_item_list ',' package_export_item\n  | package_export_item\n  ;\n\npackage_item /* IEEE1800-2005 A.1.10 */\n  : timeunits_declaration\n  | parameter_declaration\n  | type_declaration\n  | function_declaration\n  | task_declaration\n  | data_declaration\n  | class_declaration\n  | package_export_declaration\n  ;\n\npackage_item_list\n  : package_item_list package_item\n  | package_item\n  ;\n\npackage_item_list_opt : package_item_list | ;\n\nport_direction /* IEEE1800-2005 A.1.3 */\n  : K_input  { $$ = NetNet::PINPUT; }\n  | K_output { $$ = NetNet::POUTPUT; }\n  | K_inout  { $$ = NetNet::PINOUT; }\n  | K_ref\n      { $$ = NetNet::PREF;\n\n\tif (!pform_requires_sv(@1, \"Reference port (ref)\")) {\n\t      $$ = NetNet::PINPUT;\n\t}\n      }\n  ;\n\n  /* port_direction_opt is used in places where the port direction is\n     optional. The default direction is selected by the context,\n     which needs to notice the PIMPLICIT direction. */\n\nport_direction_opt\n  : port_direction { $$ = $1; }\n  |                { $$ = NetNet::PIMPLICIT; }\n  ;\n\nprocedural_assertion_statement /* IEEE1800-2012 A.6.10 */\n  : block_identifier_opt concurrent_assertion_statement\n      { $$ = $2; }\n  | block_identifier_opt simple_immediate_assertion_statement\n      { $$ = $2; }\n  | block_identifier_opt deferred_immediate_assertion_statement\n      { $$ = $2; }\n  ;\n\nproperty_expr /* IEEE1800-2012 A.2.10 */\n  : expression\n  ;\n\n  /* The property_qualifier rule is as literally described in the LRM,\n     but the use is usually as { property_qualifier }, which is\n     implemented by the property_qualifier_opt rule below. */\n\nproperty_qualifier /* IEEE1800-2005 A.1.8 */\n  : class_item_qualifier\n  | random_qualifier\n  ;\n\nproperty_qualifier_opt /* IEEE1800-2005 A.1.8: ... { property_qualifier } */\n  : property_qualifier_list { $$ = $1; }\n  | { $$ = property_qualifier_t::make_none(); }\n  ;\n\nproperty_qualifier_list /* IEEE1800-2005 A.1.8 */\n  : property_qualifier_list property_qualifier { $$ = $1 | $2; }\n  | property_qualifier { $$ = $1; }\n  ;\n\n  /* The property_spec rule uses some helper rules to implement this\n     rule from the LRM:\n     [ clocking_event ] [ disable iff ( expression_or_dist ) ] property_expr\n     This does it is a YACC friendly way. */\n\nproperty_spec /* IEEE1800-2012 A.2.10 */\n  : clocking_event_opt property_spec_disable_iff_opt property_expr\n  ;\n\nproperty_spec_disable_iff_opt /* */\n  : K_disable K_iff '(' expression ')'\n  |\n  ;\n\nrandom_qualifier /* IEEE1800-2005 A.1.8 */\n  : K_rand { $$ = property_qualifier_t::make_rand(); }\n  | K_randc { $$ = property_qualifier_t::make_randc(); }\n  ;\n\nsigning /* IEEE1800-2005: A.2.2.1 */\n  : K_signed   { $$ = true; }\n  | K_unsigned { $$ = false; }\n  ;\n\nsimple_immediate_assertion_statement /* IEEE1800-2012 A.6.10 */\n  : assert_or_assume '(' expression ')' statement_or_null %prec less_than_K_else\n      {\n\tif (gn_supported_assertions_flag) {\n\t      std::list<named_pexpr_t> arg_list;\n\t      PCallTask*tmp1 = new PCallTask(lex_strings.make(\"$error\"), arg_list);\n\t      FILE_NAME(tmp1, @1);\n\t      PCondit*tmp2 = new PCondit($3, $5, tmp1);\n\t      FILE_NAME(tmp2, @1);\n\t      $$ = tmp2;\n\t} else {\n\t      delete $3;\n\t      delete $5;\n\t      $$ = 0;\n\t}\n      }\n  | assert_or_assume '(' expression ')' K_else statement_or_null\n      {\n\tif (gn_supported_assertions_flag) {\n\t      PCondit*tmp = new PCondit($3, 0, $6);\n\t      FILE_NAME(tmp, @1);\n\t      $$ = tmp;\n\t} else {\n\t      delete $3;\n\t      delete $6;\n\t      $$ = 0;\n\t}\n      }\n  | assert_or_assume '(' expression ')' statement_or_null K_else statement_or_null\n      {\n\tif (gn_supported_assertions_flag) {\n\t      PCondit*tmp = new PCondit($3, $5, $7);\n\t      FILE_NAME(tmp, @1);\n\t      $$ = tmp;\n\t} else {\n\t      delete $3;\n\t      delete $5;\n\t      delete $7;\n\t      $$ = 0;\n\t}\n      }\n  | K_cover '(' expression ')' statement_or_null\n      {\n\t  /* Coverage collection is not currently supported. */\n\tdelete $3;\n\tdelete $5;\n\t$$ = 0;\n      }\n  | assert_or_assume '(' error ')' statement_or_null %prec less_than_K_else\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $5;\n      }\n  | assert_or_assume '(' error ')' K_else statement_or_null\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $6;\n      }\n  | assert_or_assume '(' error ')' statement_or_null K_else statement_or_null\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $5;\n      }\n  | K_cover '(' error ')' statement_or_null\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $5;\n      }\n  ;\n\nsimple_type_or_string /* IEEE1800-2005: A.2.2.1 */\n  : integer_vector_type\n      { vector_type_t*tmp = new vector_type_t($1, false, 0);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | non_integer_type\n      { real_type_t*tmp = new real_type_t($1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | atom_type\n      { atom_type_t*tmp = new atom_type_t($1, true);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_time\n      { atom_type_t*tmp = new atom_type_t(atom_type_t::TIME, false);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_string\n      { string_type_t*tmp = new string_type_t;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | ps_type_identifier\n  ;\n\nstatement /* IEEE1800-2005: A.6.4 */\n  : attribute_list_opt statement_item\n      { pform_bind_attributes($2->attributes, $1);\n\t$$ = $2;\n      }\n  ;\n\n  /* Many places where statements are allowed can actually take a\n     statement or a null statement marked with a naked semi-colon. */\n\nstatement_or_null /* IEEE1800-2005: A.6.4 */\n  : statement\n      { $$ = $1; }\n  | attribute_list_opt ';'\n      { $$ = 0; }\n  ;\n\nstream_expression\n  : expression\n  ;\n\nstream_expression_list\n  : stream_expression_list ',' stream_expression\n  | stream_expression\n  ;\n\nstream_operator\n  : K_LS\n  | K_RS\n  ;\n\nstreaming_concatenation /* IEEE1800-2005: A.8.1 */\n  : '{' stream_operator '{' stream_expression_list '}' '}'\n      { /* streaming concatenation is a SystemVerilog thing. */\n\tif (pform_requires_sv(@2, \"Streaming concatenation\")) {\n\t      yyerror(@2, \"sorry: Streaming concatenation not supported.\");\n\t      $$ = 0;\n\t} else {\n\t      $$ = 0;\n\t}\n      }\n  ;\n\n  /* The task declaration rule matches the task declaration\n     header, then pushes the function scope. This causes the\n     definitions in the task_body to take on the scope of the task\n     instead of the module. */\n\ntask_declaration /* IEEE1800-2005: A.2.7 */\n\n  : K_task lifetime_opt IDENTIFIER ';'\n      { assert(current_task == 0);\n\tcurrent_task = pform_push_task_scope(@1, $3, $2);\n      }\n    tf_item_list_opt\n    statement_or_null_list_opt\n    K_endtask\n      { current_task->set_ports($6);\n\tcurrent_task_set_statement(@3, $7);\n\tpform_set_this_class(@3, current_task);\n\tpform_pop_scope();\n\tcurrent_task = 0;\n\tif ($7 && $7->size() > 1) {\n\t      pform_requires_sv(@7, \"Task body with multiple statements\");\n\t}\n\tdelete $7;\n      }\n    label_opt\n      { // Last step: check any closing name. This is done late so\n\t// that the parser can look ahead to detect the present\n\t// label_opt but still have the pform_endmodule() called\n\t// early enough that the lexor can know we are outside the\n\t// module.\n\tcheck_end_label(@10, \"task\", $3, $10);\n\tdelete[]$3;\n      }\n\n  | K_task lifetime_opt IDENTIFIER '('\n      { assert(current_task == 0);\n\tcurrent_task = pform_push_task_scope(@1, $3, $2);\n      }\n    tf_port_list_opt ')' ';'\n    block_item_decls_opt\n    statement_or_null_list_opt\n    K_endtask\n      { current_task->set_ports($6);\n\tcurrent_task_set_statement(@3, $10);\n\tpform_set_this_class(@3, current_task);\n\tpform_pop_scope();\n\tif (generation_flag < GN_VER2005 && $6 == 0) {\n\t      cerr << @3 << \": warning: task definition for \\\"\" << $3\n\t\t   << \"\\\" has an empty port declaration list!\" << endl;\n\t}\n\tcurrent_task = 0;\n\tif ($10) delete $10;\n      }\n    label_opt\n      { // Last step: check any closing name. This is done late so\n\t// that the parser can look ahead to detect the present\n\t// label_opt but still have the pform_endmodule() called\n\t// early enough that the lexor can know we are outside the\n\t// module.\n\tcheck_end_label(@13, \"task\", $3, $13);\n\tdelete[]$3;\n      }\n\n  | K_task lifetime_opt IDENTIFIER error K_endtask\n      {\n\tif (current_task) {\n\t      pform_pop_scope();\n\t      current_task = 0;\n\t}\n      }\n    label_opt\n      { // Last step: check any closing name. This is done late so\n\t// that the parser can look ahead to detect the present\n\t// label_opt but still have the pform_endmodule() called\n\t// early enough that the lexor can know we are outside the\n\t// module.\n\tcheck_end_label(@7, \"task\", $3, $7);\n\tdelete[]$3;\n      }\n\n  ;\n\n\ntf_port_declaration /* IEEE1800-2005: A.2.7 */\n  : port_direction K_var_opt data_type_or_implicit list_of_port_identifiers ';'\n      { $$ = pform_make_task_ports(@1, $1, $3, $4, true);\n      }\n  ;\n\n\n  /* These rules for tf_port_item are slightly expanded from the\n     strict rules in the LRM to help with LALR parsing.\n\n     NOTE: Some of these rules should be folded into the \"data_type\"\n     variant which uses the data_type rule to match data type\n     declarations. That some rules do not use the data_type production\n     is a consequence of legacy. */\n\ntf_port_item /* IEEE1800-2005: A.2.7 */\n\n  : port_direction_opt K_var_opt data_type_or_implicit IDENTIFIER dimensions_opt initializer_opt\n      { std::vector<pform_tf_port_t>*tmp;\n\tNetNet::PortType use_port_type = $1;\n        if ((use_port_type == NetNet::PIMPLICIT) && (gn_system_verilog() || ($3 == 0)))\n              use_port_type = port_declaration_context.port_type;\n\tlist<pform_port_t>* port_list = make_port_list($4, @4.lexical_pos, $5, 0);\n\n\tif (use_port_type == NetNet::PIMPLICIT) {\n\t      yyerror(@1, \"error: Missing task/function port direction.\");\n\t      use_port_type = NetNet::PINPUT; // for error recovery\n\t}\n\tif (($3 == 0) && ($1==NetNet::PIMPLICIT)) {\n\t\t// Detect special case this is an undecorated\n\t\t// identifier and we need to get the declaration from\n\t\t// left context.\n\t      if ($5 != 0) {\n\t\t    yyerror(@5, \"internal error: How can there be an unpacked range here?\\n\");\n\t      }\n\t      tmp = pform_make_task_ports(@4, use_port_type,\n\t\t\t\t\t  port_declaration_context.data_type,\n\t\t\t\t\t  port_list);\n\n\t} else {\n\t\t// Otherwise, the decorations for this identifier\n\t\t// indicate the type. Save the type for any right\n\t\t// context that may come later.\n\t      port_declaration_context.port_type = use_port_type;\n\t      if ($3 == 0) {\n\t\t    $3 = new vector_type_t(IVL_VT_LOGIC, false, 0);\n\t\t    FILE_NAME($3, @4);\n\t      }\n\t      port_declaration_context.data_type = $3;\n\t      tmp = pform_make_task_ports(@3, use_port_type, $3, port_list);\n\t}\n\n\t$$ = tmp;\n\tif ($6) {\n\t      pform_requires_sv(@6, \"Task/function default argument\");\n\t      assert(tmp->size()==1);\n\t      tmp->front().defe = $6;\n\t}\n      }\n\n  /* Rules to match error cases... */\n\n  | port_direction_opt K_var_opt data_type_or_implicit IDENTIFIER error\n      { yyerror(@3, \"error: Error in task/function port item after port name %s.\", $4);\n\tyyerrok;\n\t$$ = 0;\n      }\n  ;\n\ntf_port_list /* IEEE1800-2005: A.2.7 */\n  :   { port_declaration_context.port_type = gn_system_verilog() ? NetNet::PINPUT : NetNet::PIMPLICIT;\n\tport_declaration_context.data_type = 0;\n      }\n    tf_port_item_list\n      { $$ = $2; }\n  ;\n\ntf_port_item_list\n  : tf_port_item_list ',' tf_port_item\n      { std::vector<pform_tf_port_t>*tmp;\n\tif ($1 && $3) {\n\t      size_t s1 = $1->size();\n\t      tmp = $1;\n\t      tmp->resize(tmp->size()+$3->size());\n\t      for (size_t idx = 0 ; idx < $3->size() ; idx += 1)\n\t\t    tmp->at(s1+idx) = $3->at(idx);\n\t      delete $3;\n\t} else if ($1) {\n\t      tmp = $1;\n\t} else {\n\t      tmp = $3;\n\t}\n\t$$ = tmp;\n      }\n\n  | tf_port_item\n      { $$ = $1; }\n\n  /* Rules to handle some errors in tf_port_list items. */\n\n  | error ',' tf_port_item\n      { yyerror(@2, \"error: Syntax error in task/function port declaration.\");\n\t$$ = $3;\n      }\n  | tf_port_item_list ','\n      { yyerror(@2, \"error: Superfluous comma in port declaration list.\");\n\t$$ = $1;\n      }\n  | tf_port_item_list ';'\n      { yyerror(@2, \"error: ';' is an invalid port declaration separator.\");\n\t$$ = $1;\n      }\n  ;\n\ntimeunits_declaration /* IEEE1800-2005: A.1.2 */\n  : K_timeunit TIME_LITERAL ';'\n      { pform_set_timeunit($2, allow_timeunit_decl); }\n  | K_timeunit TIME_LITERAL '/' TIME_LITERAL ';'\n      { bool initial_decl = allow_timeunit_decl && allow_timeprec_decl;\n        pform_set_timeunit($2, initial_decl);\n        pform_set_timeprec($4, initial_decl);\n      }\n  | K_timeprecision TIME_LITERAL ';'\n      { pform_set_timeprec($2, allow_timeprec_decl); }\n  ;\n\n  /* Allow zero, one, or two declarations. The second declaration might\n     be a repeat declaration, but the pform functions take care of that. */\ntimeunits_declaration_opt\n  : /* empty */           %prec no_timeunits_declaration\n  | timeunits_declaration %prec one_timeunits_declaration\n  | timeunits_declaration timeunits_declaration\n  ;\n\nvalue_range /* IEEE1800-2005: A.8.3 */\n  : expression\n      { }\n  | '[' expression ':' expression ']'\n      { }\n  ;\n\nvariable_dimension /* IEEE1800-2005: A.2.5 */\n  : '[' expression ':' expression ']'\n      { std::list<pform_range_t> *tmp = new std::list<pform_range_t>;\n\tpform_range_t index ($2,$4);\n\ttmp->push_back(index);\n\t$$ = tmp;\n      }\n  | '[' expression ']'\n      { // SystemVerilog canonical range\n\tif (!gn_system_verilog()) {\n\t      warn_count += 1;\n\t      cerr << @2 << \": warning: Use of SystemVerilog [size] dimension. \"\n\t\t   << \"Use at least -g2005-sv to remove this warning.\" << endl;\n\t}\n\tlist<pform_range_t> *tmp = new std::list<pform_range_t>;\n\tpform_range_t index ($2,0);\n\ttmp->push_back(index);\n\t$$ = tmp;\n      }\n  | '[' ']'\n      { std::list<pform_range_t> *tmp = new std::list<pform_range_t>;\n\tpform_range_t index (0,0);\n\tpform_requires_sv(@$, \"Dynamic array declaration\");\n\ttmp->push_back(index);\n\t$$ = tmp;\n      }\n  | '[' '$' ']'\n      { // SystemVerilog queue\n\tlist<pform_range_t> *tmp = new std::list<pform_range_t>;\n\tpform_range_t index (new PENull,0);\n\tpform_requires_sv(@$, \"Queue declaration\");\n\ttmp->push_back(index);\n\t$$ = tmp;\n      }\n  | '[' '$' ':' expression ']'\n      { // SystemVerilog queue with a max size\n\tlist<pform_range_t> *tmp = new std::list<pform_range_t>;\n\tpform_range_t index (new PENull,$4);\n\tpform_requires_sv(@$, \"Queue declaration\");\n\ttmp->push_back(index);\n\t$$ = tmp;\n      }\n  ;\n\nvariable_lifetime_opt\n  : lifetime\n      { if (pform_requires_sv(@1, \"Overriding default variable lifetime\") &&\n\t    $1 != pform_peek_scope()->default_lifetime) {\n\t      yyerror(@1, \"sorry: Overriding the default variable lifetime \"\n\t\t\t  \"is not yet supported.\");\n\t}\n\tvar_lifetime = $1;\n      }\n  |\n  ;\n\n  /* Verilog-2001 supports attribute lists, which can be attached to a\n     variety of different objects. The syntax inside the (* *) is a\n     comma separated list of names or names with assigned values. */\nattribute_list_opt\n  : attribute_instance_list\n      { $$ = $1; }\n  |\n      { $$ = 0; }\n  ;\n\nattribute_instance_list\n  : K_PSTAR K_STARP { $$ = 0; }\n  | K_PSTAR attribute_list K_STARP { $$ = $2; }\n  | attribute_instance_list K_PSTAR K_STARP { $$ = $1; }\n  | attribute_instance_list K_PSTAR attribute_list K_STARP\n      { std::list<named_pexpr_t>*tmp = $1;\n\tif (tmp) {\n\t    tmp->splice(tmp->end(), *$3);\n\t    delete $3;\n\t    $$ = tmp;\n\t} else $$ = $3;\n      }\n  ;\n\nattribute_list\n  : attribute_list ',' attribute\n      { std::list<named_pexpr_t>*tmp = $1;\n        tmp->push_back(*$3);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  | attribute\n      { std::list<named_pexpr_t>*tmp = new std::list<named_pexpr_t>;\n        tmp->push_back(*$1);\n\tdelete $1;\n\t$$ = tmp;\n      }\n  ;\n\n\nattribute\n  : IDENTIFIER initializer_opt\n      { named_pexpr_t*tmp = new named_pexpr_t;\n\tFILE_NAME(tmp, @$);\n\ttmp->name = lex_strings.make($1);\n\ttmp->parm = $2;\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  ;\n\n\n  /* The block_item_decl is used in function definitions, task\n     definitions, module definitions and named blocks. Wherever a new\n     scope is entered, the source may declare new registers and\n     integers. This rule matches those declarations. The containing\n     rule has presumably set up the scope. */\n\nblock_item_decl\n\n  /* variable declarations. Note that data_type can be 0 if we are\n     recovering from an error. */\n\n  : K_const_opt K_var variable_lifetime_opt data_type_or_implicit list_of_variable_decl_assignments ';'\n      { data_type_t *data_type = $4;\n\tif (!data_type) {\n\t      data_type = new vector_type_t(IVL_VT_LOGIC, false, 0);\n\t      FILE_NAME(data_type, @2);\n\t}\n\tpform_make_var(@2, $5, data_type, attributes_in_context, $1);\n\tvar_lifetime = LexicalScope::INHERITED;\n      }\n\n  | K_const_opt variable_lifetime_opt data_type list_of_variable_decl_assignments ';'\n      { if ($3) pform_make_var(@3, $4, $3, attributes_in_context, $1);\n\tvar_lifetime = LexicalScope::INHERITED;\n      }\n\n  /* The extra `reg` is not valid (System)Verilog, this is a iverilog extension. */\n  | K_const_opt variable_lifetime_opt K_reg data_type list_of_variable_decl_assignments ';'\n      { if ($4) pform_make_var(@4, $5, $4, attributes_in_context, $1);\n\tvar_lifetime = LexicalScope::INHERITED;\n      }\n\n  | K_event event_variable_list ';'\n      { if ($2) pform_make_events(@1, $2);\n      }\n\n  | parameter_declaration\n\n  /* Blocks can have type declarations. */\n\n  | type_declaration\n\n  /* Blocks can have imports. */\n\n  | package_import_declaration\n\n  /* Recover from errors that happen within variable lists. Use the\n     trailing semi-colon to resync the parser. */\n\n  | K_const_opt K_var variable_lifetime_opt data_type_or_implicit error ';'\n      { yyerror(@1, \"error: Syntax error in variable list.\");\n\tyyerrok;\n      }\n  | K_const_opt variable_lifetime_opt data_type error ';'\n      { yyerror(@1, \"error: Syntax error in variable list.\");\n\tyyerrok;\n      }\n  | K_event error ';'\n      { yyerror(@1, \"error: Syntax error in event variable list.\");\n\tyyerrok;\n      }\n\n  | parameter error ';'\n      { yyerror(@1, \"error: Syntax error in parameter list.\");\n\tyyerrok;\n      }\n  | localparam error ';'\n      { yyerror(@1, \"error: Syntax error localparam list.\");\n\tyyerrok;\n      }\n  ;\n\nblock_item_decls\n  : block_item_decl\n  | block_item_decls block_item_decl\n  ;\n\nblock_item_decls_opt\n  : block_item_decls { $$ = true; }\n  | { $$ = false; }\n  ;\n\n  /* We need to handle K_enum separately because\n   * `typedef enum <TYPE_IDENTIFIER>` can either be the start of a enum forward\n   * declaration or a enum type declaration with a type identifier as its base\n   * type. And this abmiguity can not be resolved if we reduce the K_enum to\n   * typedef_basic_type. */\ntypedef_basic_type\n  : K_struct { $$ = typedef_t::STRUCT; }\n  | K_union { $$ = typedef_t::UNION; }\n  | K_class { $$ = typedef_t::CLASS; }\n  ;\n\n  /* Type declarations are parsed here. The rule actions call pform\n     functions that add the declaration to the current lexical scope. */\ntype_declaration\n  : K_typedef data_type identifier_name dimensions_opt ';'\n      { perm_string name = lex_strings.make($3);\n\tpform_set_typedef(@3, name, $2, $4);\n\tdelete[]$3;\n      }\n\n  /* These are forward declarations... */\n\n  | K_typedef identifier_name ';'\n      { perm_string name = lex_strings.make($2);\n\tpform_forward_typedef(@2, name, typedef_t::ANY);\n\tdelete[]$2;\n      }\n  | K_typedef typedef_basic_type identifier_name ';'\n      { perm_string name = lex_strings.make($3);\n\tpform_forward_typedef(@3, name, $2);\n\tdelete[]$3;\n      }\n  | K_typedef K_enum identifier_name ';'\n      { perm_string name = lex_strings.make($3);\n\tpform_forward_typedef(@3, name, typedef_t::ENUM);\n\tdelete[]$3;\n      }\n  | K_typedef error ';'\n      { yyerror(@2, \"error: Syntax error in typedef clause.\");\n\tyyerrok;\n      }\n\n  ;\n\n  /* The structure for an enumeration data type is the keyword \"enum\",\n     followed by the enumeration values in curly braces. Also allow\n     for an optional base type. The default base type is \"int\", but it\n     can be any of the integral or vector types. */\n\nenum_base_type /* IEEE 1800-2012 A.2.2.1 */\n  : simple_packed_type\n      { $$ = $1;\n      }\n  | ps_type_identifier dimensions_opt\n      { if ($2) {\n\t      $$ = new parray_type_t($1, $2);\n\t      FILE_NAME($$, @1);\n        } else {\n\t      $$ = $1;\n        }\n      }\n  |\n      { $$ = new atom_type_t(atom_type_t::INT, true);\n        FILE_NAME($$, @0);\n      }\n  ;\n\nenum_data_type /* IEEE 1800-2012 A.2.2.1 */\n  : K_enum enum_base_type '{' enum_name_list '}'\n      { enum_type_t*enum_type = new enum_type_t($2);\n\tFILE_NAME(enum_type, @1);\n\tenum_type->names.reset($4);\n\tpform_put_enum_type_in_scope(enum_type);\n\t$$ = enum_type;\n      }\n  ;\n\nenum_name_list\n  : enum_name\n      { $$ = $1;\n      }\n  | enum_name_list ',' enum_name\n      { std::list<named_pexpr_t>*lst = $1;\n\tlst->splice(lst->end(), *$3);\n\tdelete $3;\n\t$$ = lst;\n      }\n  ;\n\npos_neg_number\n  : number\n      { $$ = $1;\n      }\n  | '-' number\n      { verinum tmp = -(*($2));\n\t*($2) = tmp;\n\t$$ = $2;\n      }\n  ;\n\nenum_name\n  : IDENTIFIER initializer_opt\n      { perm_string name = lex_strings.make($1);\n\tdelete[]$1;\n\t$$ = make_named_number(@$, name, $2);\n      }\n  | IDENTIFIER '[' pos_neg_number ']' initializer_opt\n      { perm_string name = lex_strings.make($1);\n\tlong count = check_enum_seq_value(@1, $3, false);\n\t$$ = make_named_numbers(@$, name, 0, count-1, $5);\n\tdelete[]$1;\n\tdelete $3;\n      }\n  | IDENTIFIER '[' pos_neg_number ':' pos_neg_number ']' initializer_opt\n      { perm_string name = lex_strings.make($1);\n\t$$ = make_named_numbers(@$, name, check_enum_seq_value(@1, $3, true),\n\t                                  check_enum_seq_value(@1, $5, true), $7);\n\tdelete[]$1;\n\tdelete $3;\n\tdelete $5;\n      }\n  ;\n\n/* `signed` and `unsigned` are only valid if preceded by `packed` */\npacked_signing /* IEEE 1800-2012 A.2.2.1 */\n  : K_packed unsigned_signed_opt\n      { $$.packed_flag = true;\n        $$.signed_flag = $2;\n      }\n  |\n      { $$.packed_flag = false;\n        $$.signed_flag = false;\n      }\n  ;\n\nstruct_data_type /* IEEE 1800-2012 A.2.2.1 */\n  : K_struct packed_signing '{' struct_union_member_list '}'\n      { struct_type_t*tmp = new struct_type_t;\n\tFILE_NAME(tmp, @1);\n\ttmp->packed_flag = $2.packed_flag;\n\ttmp->signed_flag = $2.signed_flag;\n\ttmp->union_flag = false;\n\ttmp->members .reset($4);\n\t$$ = tmp;\n      }\n  | K_union packed_signing '{' struct_union_member_list '}'\n      { struct_type_t*tmp = new struct_type_t;\n\tFILE_NAME(tmp, @1);\n\ttmp->packed_flag = $2.packed_flag;\n\ttmp->signed_flag = $2.signed_flag;\n\ttmp->union_flag = true;\n\ttmp->members .reset($4);\n\t$$ = tmp;\n      }\n  | K_struct packed_signing '{' error '}'\n      { yyerror(@3, \"error: Errors in struct member list.\");\n\tyyerrok;\n\tstruct_type_t*tmp = new struct_type_t;\n\tFILE_NAME(tmp, @1);\n\ttmp->packed_flag = $2.packed_flag;\n\ttmp->signed_flag = $2.signed_flag;\n\ttmp->union_flag = false;\n\t$$ = tmp;\n      }\n  | K_union packed_signing '{' error '}'\n      { yyerror(@3, \"error: Errors in union member list.\");\n\tyyerrok;\n\tstruct_type_t*tmp = new struct_type_t;\n\tFILE_NAME(tmp, @1);\n\ttmp->packed_flag = $2.packed_flag;\n\ttmp->signed_flag = $2.signed_flag;\n\ttmp->union_flag = true;\n\t$$ = tmp;\n      }\n  ;\n\n  /* This is an implementation of the rule snippet:\n       struct_union_member { struct_union_member }\n     that is used in the rule matching struct and union types\n     in IEEE 1800-2012 A.2.2.1. */\nstruct_union_member_list\n  : struct_union_member_list struct_union_member\n      { std::list<struct_member_t*>*tmp = $1;\n\tif ($2) tmp->push_back($2);\n\t$$ = tmp;\n      }\n  | struct_union_member\n      { std::list<struct_member_t*>*tmp = new std::list<struct_member_t*>;\n\tif ($1) tmp->push_back($1);\n\t$$ = tmp;\n      }\n  ;\n\nstruct_union_member /* IEEE 1800-2012 A.2.2.1 */\n  : attribute_list_opt data_type list_of_variable_decl_assignments ';'\n      { struct_member_t*tmp = new struct_member_t;\n\tFILE_NAME(tmp, @2);\n\ttmp->type  .reset($2);\n\ttmp->names .reset($3);\n\t$$ = tmp;\n      }\n  | error ';'\n      { yyerror(@2, \"error: Error in struct/union member.\");\n\tyyerrok;\n\t$$ = 0;\n      }\n  ;\n\ncase_item\n  : expression_list_proper ':' statement_or_null\n      { PCase::Item*tmp = new PCase::Item;\n\ttmp->expr = *$1;\n\ttmp->stat = $3;\n\tdelete $1;\n\t$$ = tmp;\n      }\n  | K_default ':' statement_or_null\n      { PCase::Item*tmp = new PCase::Item;\n\ttmp->stat = $3;\n\t$$ = tmp;\n      }\n  | K_default  statement_or_null\n      { PCase::Item*tmp = new PCase::Item;\n\ttmp->stat = $2;\n\t$$ = tmp;\n      }\n  | error ':' statement_or_null\n      { yyerror(@2, \"error: Incomprehensible case expression.\");\n\tyyerrok;\n      }\n  ;\n\ncase_items\n  : case_items case_item\n      { $1->push_back($2);\n\t$$ = $1;\n      }\n  | case_item\n      { $$ = new std::vector<PCase::Item*>(1, $1);\n      }\n  ;\n\ncharge_strength\n  : '(' K_small ')'\n  | '(' K_medium ')'\n  | '(' K_large ')'\n  ;\n\ncharge_strength_opt\n  : charge_strength\n  |\n  ;\n\ndefparam_assign\n  : hierarchy_identifier '=' expression\n      { pform_set_defparam(*$1, $3);\n\tdelete $1;\n      }\n  ;\n\ndefparam_assign_list\n  : defparam_assign\n  | dimensions defparam_assign\n      { yyerror(@1, \"error: defparam may not include a range.\");\n\tdelete $1;\n      }\n  | defparam_assign_list ',' defparam_assign\n  ;\n\ndelay1\n  : '#' delay_value_simple\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($2);\n\t$$ = tmp;\n      }\n  | '#' '(' delay_value ')'\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  ;\n\ndelay3\n  : '#' delay_value_simple\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($2);\n\t$$ = tmp;\n      }\n  | '#' '(' delay_value ')'\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  | '#' '(' delay_value ',' delay_value ')'\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($3);\n\ttmp->push_back($5);\n\t$$ = tmp;\n      }\n  | '#' '(' delay_value ',' delay_value ',' delay_value ')'\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($3);\n\ttmp->push_back($5);\n\ttmp->push_back($7);\n\t$$ = tmp;\n      }\n  ;\n\ndelay3_opt\n  : delay3 { $$ = $1; }\n  |        { $$ = 0; }\n  ;\n\ndelay_value_list\n  : delay_value\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($1);\n\t$$ = tmp;\n      }\n  | delay_value_list ',' delay_value\n      { std::list<PExpr*>*tmp = $1;\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  ;\n\ndelay_value\n  : expression\n      { PExpr*tmp = $1;\n\t$$ = tmp;\n      }\n  | expression ':' expression ':' expression\n      { $$ = pform_select_mtm_expr($1, $3, $5); }\n  ;\n\n\ndelay_value_simple\n  : DEC_NUMBER\n      { verinum*tmp = $1;\n\tif (tmp == 0) {\n\t      yyerror(@1, \"internal error: decimal delay.\");\n\t      $$ = 0;\n\t} else {\n\t      $$ = new PENumber(tmp);\n\t      FILE_NAME($$, @1);\n\t}\n\tbased_size = 0;\n      }\n  | REALTIME\n      { verireal*tmp = $1;\n\tif (tmp == 0) {\n\t      yyerror(@1, \"internal error: real time delay.\");\n\t      $$ = 0;\n\t} else {\n\t      $$ = new PEFNumber(tmp);\n\t      FILE_NAME($$, @1);\n\t}\n      }\n  | IDENTIFIER\n      { PEIdent*tmp = new PEIdent(lex_strings.make($1), @1.lexical_pos);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete[]$1;\n      }\n  | TIME_LITERAL\n      { int unit;\n\n\tbased_size = 0;\n\t$$         = 0;\n\tif ($1 == 0 || !get_time_unit($1, unit))\n\t      yyerror(@1, \"internal error: time literal delay.\");\n\telse {\n#ifdef __FreeBSD__\n\t\t// Using raw pow() in FreeBSD gives a value that is off by one and this causes\n\t\t// rounding issues later, so for now use powl() to get the correct result.\n\t      long double ldp = powl(10.0, (long double)(unit - pform_get_timeunit()));\n\t      double p = (double) ldp;\n#else\n\t      double p = pow(10.0, (double)(unit - pform_get_timeunit()));\n#endif\n\t      double time = atof($1) * p;\n\n\t      verireal *v = new verireal(time);\n\t      $$ = new PEFNumber(v);\n\t      FILE_NAME($$, @1);\n\t}\n      }\n  ;\n\n  /* The discipline and nature declarations used to take no ';' after\n     the identifier. The 2.3 LRM adds the ';', but since there are\n     programs written to the 2.1 and 2.2 standard that don't, we\n     choose to make the ';' optional in this context. */\noptional_semicolon : ';' | ;\n\ndiscipline_declaration\n  : K_discipline IDENTIFIER optional_semicolon\n      { pform_start_discipline($2); }\n    discipline_items K_enddiscipline\n      { pform_end_discipline(@1); delete[] $2; }\n  ;\n\ndiscipline_items\n  : discipline_items discipline_item\n  | discipline_item\n  ;\n\ndiscipline_item\n  : K_domain K_discrete ';'\n      { pform_discipline_domain(@1, IVL_DIS_DISCRETE); }\n  | K_domain K_continuous ';'\n      { pform_discipline_domain(@1, IVL_DIS_CONTINUOUS); }\n  | K_potential IDENTIFIER ';'\n      { pform_discipline_potential(@1, $2); delete[] $2; }\n  | K_flow IDENTIFIER ';'\n      { pform_discipline_flow(@1, $2); delete[] $2; }\n  ;\n\nnature_declaration\n  : K_nature IDENTIFIER optional_semicolon\n      { pform_start_nature($2); }\n    nature_items\n    K_endnature\n      { pform_end_nature(@1); delete[] $2; }\n  ;\n\nnature_items\n  : nature_items nature_item\n  | nature_item\n  ;\n\nnature_item\n  : K_units '=' STRING ';'\n      { delete[] $3; }\n  | K_abstol '=' expression ';'\n  | K_access '=' IDENTIFIER ';'\n      { pform_nature_access(@1, $3); delete[] $3; }\n  | K_idt_nature '=' IDENTIFIER ';'\n      { delete[] $3; }\n  | K_ddt_nature '=' IDENTIFIER ';'\n      { delete[] $3; }\n  ;\n\nconfig_declaration\n  : K_config IDENTIFIER ';'\n    K_design lib_cell_identifiers ';'\n    list_of_config_rule_statements\n    K_endconfig\n      { cerr << @1 << \": sorry: config declarations are not supported and \"\n                \"will be skipped.\" << endl;\n\tdelete[] $2;\n      }\n  ;\n\nlib_cell_identifiers\n  : /* The BNF implies this can be blank, but I'm not sure exactly what\n     * this means. */\n  | lib_cell_identifiers lib_cell_id\n  ;\n\nlist_of_config_rule_statements\n  : /* config rules are optional. */\n  | list_of_config_rule_statements config_rule_statement\n  ;\n\nconfig_rule_statement\n  : K_default K_liblist list_of_libraries ';'\n  | K_instance hierarchy_identifier K_liblist list_of_libraries ';'\n      { delete $2; }\n  | K_instance hierarchy_identifier K_use lib_cell_id opt_config ';'\n      { delete $2; }\n  | K_cell lib_cell_id K_liblist list_of_libraries ';'\n  | K_cell lib_cell_id K_use lib_cell_id opt_config ';'\n  ;\n\nopt_config\n  : /* The use clause takes an optional :config. */\n  | ':' K_config\n  ;\n\nlib_cell_id\n  : IDENTIFIER\n      { delete[] $1; }\n  | IDENTIFIER '.' IDENTIFIER\n      { delete[] $1; delete[] $3; }\n  ;\n\nlist_of_libraries\n  : /* A NULL library means use the parents cell library. */\n  | list_of_libraries IDENTIFIER\n      { delete[] $2; }\n  ;\n\ndrive_strength\n  : '(' dr_strength0 ',' dr_strength1 ')'\n      { $$.str0 = $2.str0;\n\t$$.str1 = $4.str1;\n      }\n  | '(' dr_strength1 ',' dr_strength0 ')'\n      { $$.str0 = $4.str0;\n\t$$.str1 = $2.str1;\n      }\n  | '(' dr_strength0 ',' K_highz1 ')'\n      { $$.str0 = $2.str0;\n\t$$.str1 = IVL_DR_HiZ;\n      }\n  | '(' dr_strength1 ',' K_highz0 ')'\n      { $$.str0 = IVL_DR_HiZ;\n\t$$.str1 = $2.str1;\n      }\n  | '(' K_highz1 ',' dr_strength0 ')'\n      { $$.str0 = $4.str0;\n\t$$.str1 = IVL_DR_HiZ;\n      }\n  | '(' K_highz0 ',' dr_strength1 ')'\n      { $$.str0 = IVL_DR_HiZ;\n\t$$.str1 = $4.str1;\n      }\n  ;\n\ndrive_strength_opt\n  : drive_strength\n      { $$ = $1; }\n  |\n      { $$.str0 = IVL_DR_STRONG; $$.str1 = IVL_DR_STRONG; }\n  ;\n\ndr_strength0\n  : K_supply0 { $$.str0 = IVL_DR_SUPPLY; }\n  | K_strong0 { $$.str0 = IVL_DR_STRONG; }\n  | K_pull0   { $$.str0 = IVL_DR_PULL; }\n  | K_weak0   { $$.str0 = IVL_DR_WEAK; }\n  ;\n\ndr_strength1\n  : K_supply1 { $$.str1 = IVL_DR_SUPPLY; }\n  | K_strong1 { $$.str1 = IVL_DR_STRONG; }\n  | K_pull1   { $$.str1 = IVL_DR_PULL; }\n  | K_weak1   { $$.str1 = IVL_DR_WEAK; }\n  ;\n\nclocking_event_opt /* */\n  : event_control\n  |\n  ;\n\nevent_control /* A.K.A. clocking_event */\n  : '@' hierarchy_identifier\n      { PEIdent*tmpi = pform_new_ident(@2, *$2);\n\tFILE_NAME(tmpi, @2);\n\tPEEvent*tmpe = new PEEvent(PEEvent::ANYEDGE, tmpi);\n\tPEventStatement*tmps = new PEventStatement(tmpe);\n\tFILE_NAME(tmps, @1);\n\t$$ = tmps;\n\tdelete $2;\n      }\n  | '@' '(' event_expression_list ')'\n      { PEventStatement*tmp = new PEventStatement(*$3);\n\tFILE_NAME(tmp, @1);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  | '@' '(' error ')'\n      { yyerror(@1, \"error: Malformed event control expression.\");\n\t$$ = 0;\n      }\n  ;\n\nevent_expression_list\n  : event_expression\n      { $$ = new std::vector<PEEvent*>(1, $1);\n      }\n  | event_expression_list K_or event_expression\n      { $1->push_back($3);\n\t$$ = $1;\n      }\n  | event_expression_list ',' event_expression\n      { $1->push_back($3);\n\t$$ = $1;\n      }\n  ;\n\nevent_expression\n  : K_posedge expression\n      { PEEvent*tmp = new PEEvent(PEEvent::POSEDGE, $2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_negedge expression\n      { PEEvent*tmp = new PEEvent(PEEvent::NEGEDGE, $2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_edge expression\n      { PEEvent*tmp = new PEEvent(PEEvent::EDGE, $2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tpform_requires_sv(@1, \"Edge event\");\n      }\n  | expression\n      { PEEvent*tmp = new PEEvent(PEEvent::ANYEDGE, $1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\n  /* A branch probe expression applies a probe function (potential or\n     flow) to a branch. The branch may be implicit as a pair of nets\n     or explicit as a named branch. Elaboration will check that the\n     function name really is a nature attribute identifier. */\nbranch_probe_expression\n  : IDENTIFIER '(' IDENTIFIER ',' IDENTIFIER ')'\n      { $$ = pform_make_branch_probe_expression(@1, $1, $3, $5); }\n  | IDENTIFIER '(' IDENTIFIER ')'\n      { $$ = pform_make_branch_probe_expression(@1, $1, $3); }\n  ;\n\nexpression\n  : expr_primary_or_typename\n      { $$ = $1; }\n  | inc_or_dec_expression\n      { $$ = $1; }\n  | inside_expression\n      { $$ = $1; }\n  | '+' attribute_list_opt expr_primary %prec UNARY_PREC\n      { $$ = $3; }\n  | '-' attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('-', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | '~' attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('~', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | '&' attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('&', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | '!' attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('!', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | '|' attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('|', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | '^' attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('^', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | '~' '&' attribute_list_opt expr_primary %prec UNARY_PREC\n      { yyerror(@1, \"error: '~' '&'  is not a valid expression. \"\n\t\t\"Please use operator '~&' instead.\");\n\t$$ = 0;\n      }\n  | '~' '|' attribute_list_opt expr_primary %prec UNARY_PREC\n      { yyerror(@1, \"error: '~' '|'  is not a valid expression. \"\n\t\t\"Please use operator '~|' instead.\");\n\t$$ = 0;\n      }\n  | '~' '^' attribute_list_opt expr_primary %prec UNARY_PREC\n      { yyerror(@1, \"error: '~' '^'  is not a valid expression. \"\n\t\t\"Please use operator '~^' instead.\");\n\t$$ = 0;\n      }\n  | K_NAND attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('A', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | K_NOR attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('N', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | K_NXOR attribute_list_opt expr_primary %prec UNARY_PREC\n      { PEUnary*tmp = new PEUnary('X', $3);\n\tFILE_NAME(tmp, @3);\n\t$$ = tmp;\n      }\n  | '!' error %prec UNARY_PREC\n      { yyerror(@1, \"error: Operand of unary ! \"\n\t\t\"is not a primary expression.\");\n\t$$ = 0;\n      }\n  | '^' error %prec UNARY_PREC\n      { yyerror(@1, \"error: Operand of reduction ^ \"\n\t\t\"is not a primary expression.\");\n\t$$ = 0;\n      }\n  | expression '^' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('^', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_POW attribute_list_opt expression\n      { PEBinary*tmp = new PEBPower('p', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '*' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('*', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '/' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('/', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '%' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('%', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '+' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('+', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '-' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('-', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '&' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('&', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '|' attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('|', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_NAND attribute_list_opt expression\n      { if (gn_icarus_misc_flag) {\n\t      PEBinary*tmp = new PEBinary('A', $1, $4);\n\t      FILE_NAME(tmp, @2);\n\t      $$ = tmp;\n\t} else {\n\t      yyerror(@2, \"error: The binary NAND operator \"\n\t\t\t  \"is an Icarus Verilog extension. \"\n\t\t\t  \"Use -gicarus-misc to enable it.\");\n\t      $$ = 0;\n\t}\n      }\n  | expression K_NOR attribute_list_opt expression\n      { if (gn_icarus_misc_flag) {\n\t      PEBinary*tmp = new PEBinary('O', $1, $4);\n\t      FILE_NAME(tmp, @2);\n\t      $$ = tmp;\n\t} else {\n\t      yyerror(@2, \"error: The binary NOR operator \"\n\t\t\t  \"is an Icarus Verilog extension. \"\n\t\t\t  \"Use -gicarus-misc to enable it.\");\n\t      $$ = 0;\n\t}\n      }\n  | expression K_NXOR attribute_list_opt expression\n      { PEBinary*tmp = new PEBinary('X', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '<' attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('<', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '>' attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('>', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_LS attribute_list_opt expression\n      { PEBinary*tmp = new PEBShift('l', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_RS attribute_list_opt expression\n      { PEBinary*tmp = new PEBShift('r', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_RSS attribute_list_opt expression\n      { PEBinary*tmp = new PEBShift('R', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_EQ attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('e', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_CEQ attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('E', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_WEQ attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('w', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_LE attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('L', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_GE attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('G', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_NE attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('n', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_CNE attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('N', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_WNE attribute_list_opt expression\n      { PEBinary*tmp = new PEBComp('W', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_LOR attribute_list_opt expression\n      { PEBinary*tmp = new PEBLogic('o', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_LAND attribute_list_opt expression\n      { PEBinary*tmp = new PEBLogic('a', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression K_TRIGGER attribute_list_opt expression\n      { PEBinary*tmp = new PEBLogic('q', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n\n  | expression K_LEQUIV attribute_list_opt expression\n      { PEBinary*tmp = new PEBLogic('Q', $1, $4);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | expression '?' attribute_list_opt expression ':' expression\n      { PETernary*tmp = new PETernary($1, $4, $6);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  ;\n\nexpression_opt\n  : expression { $$ = $1; }\n  | { $$ = nullptr; }\n  ;\n\nexpr_mintypmax\n  : expression\n      { $$ = $1; }\n  | expression ':' expression ':' expression\n      { switch (min_typ_max_flag) {\n\t    case MIN:\n\t      $$ = $1;\n\t      delete $3;\n\t      delete $5;\n\t      break;\n\t    case TYP:\n\t      delete $1;\n\t      $$ = $3;\n\t      delete $5;\n\t      break;\n\t    case MAX:\n\t      delete $1;\n\t      delete $3;\n\t      $$ = $5;\n\t      break;\n\t}\n\tif (min_typ_max_warn > 0) {\n\t      cerr << $$->get_fileline() << \": warning: Choosing \";\n\t      switch (min_typ_max_flag) {\n\t          case MIN:\n\t\t    cerr << \"min\";\n\t\t    break;\n\t\t  case TYP:\n\t\t    cerr << \"typ\";\n\t\t    break;\n\t\t  case MAX:\n\t\t    cerr << \"max\";\n\t\t    break;\n\t      }\n\t      cerr << \" expression.\" << endl;\n\t      min_typ_max_warn -= 1;\n\t}\n      }\n  ;\n\n\n  /* Many contexts take a comma separated list of expressions. Null\n     expressions can happen anywhere in the list, so there are two\n     extra rules in expression_list_with_nuls for parsing and\n     installing those nulls.\n\n     The expression_list_proper rules do not allow null items in the\n     expression list, so can be used where nul expressions are not allowed. */\n\nexpression_list_with_nuls\n  : expression_list_with_nuls ',' expression\n      { std::list<PExpr*>*tmp = $1;\n\tif (tmp->empty()) tmp->push_back(0);\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  | expression\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($1);\n\t$$ = tmp;\n      }\n  |\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\t$$ = tmp;\n      }\n  | expression_list_with_nuls ','\n      { std::list<PExpr*>*tmp = $1;\n\tif (tmp->empty()) tmp->push_back(0);\n\ttmp->push_back(0);\n\t$$ = tmp;\n      }\n  ;\n\nargument\n  : expression\n      { named_pexpr_t *tmp = new named_pexpr_t;\n\tFILE_NAME(tmp, @$);\n\ttmp->name = perm_string();\n\ttmp->parm = $1;\n\t$$ = tmp;\n      }\n  | named_expression_opt\n      { $$ = $1;\n      }\n  |\n      { named_pexpr_t *tmp = new named_pexpr_t;\n\ttmp->name = perm_string();\n\ttmp->parm = nullptr;\n\t$$ = tmp;\n      }\n  ;\n\nargument_list\n : argument\n      { std::list<named_pexpr_t> *expr = new std::list<named_pexpr_t>;\n\texpr->push_back(*$1);\n\tdelete $1;\n\t$$ = expr;\n      }\n | argument_list ',' argument\n      { $1->push_back(*$3);\n\tdelete $3;\n\t$$ = $1;\n      }\n ;\n\n  /* An argument list enclosed in parenthesis. The parser will parse '()' as a\n   * argument list with an single empty item. We fix this up once the list\n   * parsing is done by replacing it with the empty list.\n   */\nargument_list_parens\n  : '(' argument_list ')'\n      { argument_list_fixup($2);\n\t$$ = $2; }\n  ;\n\n  /* A task or function can be invoked with the task/function name followed by\n   * an argument list in parenthesis or with just the task/function name by\n   * itself. When an argument list is used it might be empty. */\nargument_list_parens_opt\n  : argument_list_parens\n      { $$ = $1; }\n  |\n      { $$ = new std::list<named_pexpr_t>; }\n  ;\n\nexpression_list_proper\n  : expression_list_proper ',' expression\n      { std::list<PExpr*>*tmp = $1;\n        tmp->push_back($3);\n        $$ = tmp;\n      }\n  | expression\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($1);\n\t$$ = tmp;\n      }\n  ;\n\nexpr_primary_or_typename\n  : expr_primary\n\n  /* There are a few special cases (notably $bits argument) where the\n     expression may be a type name. Let the elaborator sort this out. */\n  | data_type\n      { PETypename*tmp = new PETypename($1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  ;\n\nexpr_primary\n  : number\n      { assert($1);\n\tPENumber*tmp = new PENumber($1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | REALTIME\n      { PEFNumber*tmp = new PEFNumber($1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | STRING\n      { PEString*tmp = new PEString($1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | TIME_LITERAL\n      { int unit;\n\n        based_size = 0;\n        $$         = 0;\n        if ($1 == 0 || !get_time_unit($1, unit))\n              yyerror(@1, \"internal error: time literal.\");\n        else {\n#ifdef __FreeBSD__\n                // Using raw pow() in FreeBSD gives a value that is off by one and this causes\n                // rounding issues below, so for now use powl() to get the correct result.\n              long double ldp = powl(10.0, (double)(unit - pform_get_timeunit()));\n              double p = (double) ldp;\n#else\n              double p = pow(10.0, (double)(unit - pform_get_timeunit()));\n#endif\n              double time = atof($1) * p;\n              // The time value needs to be rounded at the correct digit\n              // since this is a normal real value and not a delay that\n              // will be rounded later. This style of rounding is not safe\n              // for all real values!\n              int rdigit = pform_get_timeunit() - pform_get_timeprec();\n              assert(rdigit >= 0);\n              double scale = pow(10.0, (double)rdigit);\n              time = round(time*scale)/scale;\n\n              verireal *v = new verireal(time);\n              $$ = new PEFNumber(v);\n              FILE_NAME($$, @1);\n        }\n      }\n  | SYSTEM_IDENTIFIER\n      { perm_string tn = lex_strings.make($1);\n\tPECallFunction*tmp = new PECallFunction(tn);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete[]$1;\n      }\n\n  /* The hierarchy_identifier rule matches simple identifiers as well as\n     indexed arrays and part selects */\n\n  | hierarchy_identifier\n      { PEIdent*tmp = pform_new_ident(@1, *$1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete $1;\n      }\n  /* These are array methods that cannot be matched with the above rule */\n  | hierarchy_identifier '.' K_and\n      { pform_name_t * nm = $1;\n\tnm->push_back(name_component_t(lex_strings.make(\"and\")));\n\tPEIdent*tmp = pform_new_ident(@1, *nm);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete nm;\n      }\n  | hierarchy_identifier '.' K_or\n      { pform_name_t * nm = $1;\n\tnm->push_back(name_component_t(lex_strings.make(\"or\")));\n\tPEIdent*tmp = pform_new_ident(@1, *nm);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete nm;\n      }\n  | hierarchy_identifier '.' K_unique\n      { pform_name_t * nm = $1;\n\tnm->push_back(name_component_t(lex_strings.make(\"unique\")));\n\tPEIdent*tmp = pform_new_ident(@1, *nm);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete nm;\n      }\n  | hierarchy_identifier '.' K_xor\n      { pform_name_t * nm = $1;\n\tnm->push_back(name_component_t(lex_strings.make(\"xor\")));\n\tPEIdent*tmp = pform_new_ident(@1, *nm);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete nm;\n      }\n\n  | package_scope hierarchy_identifier\n      { lex_in_package_scope(0);\n\t$$ = pform_package_ident(@2, $1, $2);\n\tdelete $2;\n      }\n\n  /* An identifier followed by an expression list in parentheses is a\n     function call. If a system identifier, then a system function\n     call. It can also be a call to a class method (function). */\n\n  | hierarchy_identifier attribute_list_opt argument_list_parens\n      { PECallFunction*tmp = pform_make_call_function(@1, *$1, *$3);\n\tdelete $1;\n\tdelete $2;\n\tdelete $3;\n\t$$ = tmp;\n      }\n  | class_hierarchy_identifier argument_list_parens\n      { PECallFunction*tmp = pform_make_call_function(@1, *$1, *$2);\n\tdelete $1;\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | SYSTEM_IDENTIFIER argument_list_parens\n      { perm_string tn = lex_strings.make($1);\n\tPECallFunction *tmp = new PECallFunction(tn, *$2);\n\tif ($2->empty())\n\t      pform_requires_sv(@1, \"Empty function argument list\");\n\tFILE_NAME(tmp, @1);\n\tdelete[]$1;\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | package_scope hierarchy_identifier { lex_in_package_scope(0); } argument_list_parens\n      { PECallFunction*tmp = new PECallFunction($1, *$2, *$4);\n\tFILE_NAME(tmp, @2);\n\tdelete $2;\n\tdelete $4;\n\t$$ = tmp;\n      }\n  | K_this\n      { PEIdent*tmp = new PEIdent(perm_string::literal(THIS_TOKEN), UINT_MAX);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | class_hierarchy_identifier\n      { PEIdent*tmp = new PEIdent(*$1, @1.lexical_pos);\n\tFILE_NAME(tmp, @1);\n\tdelete $1;\n\t$$ = tmp;\n      }\n\n  /* Many of the VAMS built-in functions are available as builtin\n     functions with $system_function equivalents. */\n\n  | K_acos '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$acos\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_acosh '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$acosh\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_asin '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$asin\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_asinh '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$asinh\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_atan '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$atan\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_atanh '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$atanh\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_atan2 '(' expression ',' expression ')'\n      { perm_string tn = perm_string::literal(\"$atan2\");\n\tPECallFunction*tmp = make_call_function(tn, $3, $5);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_ceil '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$ceil\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_cos '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$cos\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_cosh '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$cosh\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_exp '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$exp\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_floor '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$floor\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_hypot '(' expression ',' expression ')'\n      { perm_string tn = perm_string::literal(\"$hypot\");\n\tPECallFunction*tmp = make_call_function(tn, $3, $5);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_ln '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$ln\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_log '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$log10\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_pow '(' expression ',' expression ')'\n      { perm_string tn = perm_string::literal(\"$pow\");\n        PECallFunction*tmp = make_call_function(tn, $3, $5);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_sin '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$sin\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_sinh '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$sinh\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_sqrt '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$sqrt\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_tan '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$tan\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_tanh '(' expression ')'\n      { perm_string tn = perm_string::literal(\"$tanh\");\n\tPECallFunction*tmp = make_call_function(tn, $3);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  /* These mathematical functions are conveniently expressed as unary\n     and binary expressions. They behave much like unary/binary\n     operators, even though they are parsed as functions.  */\n\n  | K_abs '(' expression ')'\n      { PEUnary*tmp = new PEUnary('m', $3);\n        FILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_max '(' expression ',' expression ')'\n      { PEBinary*tmp = new PEBinary('M', $3, $5);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  | K_min '(' expression ',' expression ')'\n      { PEBinary*tmp = new PEBinary('m', $3, $5);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n\n  /* Parenthesized expressions are primaries. */\n\n  | '(' expr_mintypmax ')'\n      { $$ = $2; }\n\n  /* Various kinds of concatenation expressions. */\n\n  | '{' expression_list_proper '}'\n      { PEConcat*tmp = new PEConcat(*$2);\n\tFILE_NAME(tmp, @1);\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | '{' expression '{' expression_list_proper '}' '}'\n      { PExpr*rep = $2;\n\tPEConcat*tmp = new PEConcat(*$4, rep);\n\tFILE_NAME(tmp, @1);\n\tdelete $4;\n\t$$ = tmp;\n      }\n  | '{' expression '{' expression_list_proper '}' error '}'\n      { PExpr*rep = $2;\n\tPEConcat*tmp = new PEConcat(*$4, rep);\n\tFILE_NAME(tmp, @1);\n\tdelete $4;\n\t$$ = tmp;\n\tyyerror(@5, \"error: Syntax error between internal '}' \"\n\t\t\"and closing '}' of repeat concatenation.\");\n\tyyerrok;\n      }\n\n  | '{' '}'\n      { // This is the empty queue syntax.\n\tif (gn_system_verilog()) {\n\t      std::list<PExpr*> empty_list;\n\t      PEConcat*tmp = new PEConcat(empty_list);\n\t      FILE_NAME(tmp, @1);\n\t      $$ = tmp;\n\t} else {\n\t      yyerror(@1, \"error: Concatenations are not allowed to be empty.\");\n\t      $$ = 0;\n\t}\n      }\n\n  /* Cast expressions are primaries */\n\n  | expr_primary '\\'' '(' expression ')'\n      { PExpr*base = $4;\n\tif (pform_requires_sv(@1, \"Size cast\")) {\n\t      PECastSize*tmp = new PECastSize($1, base);\n\t      FILE_NAME(tmp, @1);\n\t      $$ = tmp;\n\t} else {\n\t      $$ = base;\n\t}\n      }\n\n  | simple_type_or_string '\\'' '(' expression ')'\n      { PExpr*base = $4;\n\tif (pform_requires_sv(@1, \"Type cast\")) {\n\t      PECastType*tmp = new PECastType($1, base);\n\t      FILE_NAME(tmp, @1);\n\t      $$ = tmp;\n\t} else {\n\t      $$ = base;\n\t}\n      }\n  | signing '\\'' '(' expression ')'\n      { PExpr*base = $4;\n\tif (pform_requires_sv(@1, \"Signing cast\")) {\n\t      PECastSign*tmp = new PECastSign($1, base);\n\t      FILE_NAME(tmp, @1);\n\t      $$ = tmp;\n\t} else {\n\t      $$ = base;\n\t}\n      }\n\n  /* Aggregate literals are primaries. */\n\n  | assignment_pattern\n      { $$ = $1; }\n\n  /* SystemVerilog supports streaming concatenation */\n  | streaming_concatenation\n      { $$ = $1; }\n\n  | K_null\n      { PENull*tmp = new PENull;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  ;\n\n  /* A tf_item_list is shared between functions and tasks to match\n     declarations of ports. We check later to make sure there are no\n     output or inout ports actually used for functions. */\ntf_item_list_opt /* IEEE1800-2017: A.2.7 */\n  : tf_item_list\n      { $$ = $1; }\n  |\n      { $$ = 0; }\n  ;\n\ntf_item_list /* IEEE1800-2017: A.2.7 */\n  : tf_item_declaration\n      { $$ = $1; }\n  | tf_item_list tf_item_declaration\n      { if ($1 && $2) {\n\t      std::vector<pform_tf_port_t>*tmp = $1;\n\t      size_t s1 = tmp->size();\n\t      tmp->resize(s1 + $2->size());\n\t      for (size_t idx = 0 ; idx < $2->size() ; idx += 1)\n\t\t    tmp->at(s1+idx) = $2->at(idx);\n\t      delete $2;\n\t      $$ = tmp;\n\t} else if ($1) {\n\t      $$ = $1;\n\t} else {\n\t      $$ = $2;\n\t}\n      }\n ;\n\ntf_item_declaration /* IEEE1800-2017: A.2.7 */\n  : tf_port_declaration { $$ = $1; }\n  | block_item_decl     { $$ = 0; }\n  ;\n\n  /* A gate_instance is a module instantiation or a built in part\n     type. In any case, the gate has a set of connections to ports. */\ngate_instance\n  : IDENTIFIER '(' port_conn_expression_list_with_nuls ')'\n      { lgate*tmp = new lgate;\n\ttmp->name = $1;\n\ttmp->parms = $3;\n\tFILE_NAME(tmp, @1);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n\n  | IDENTIFIER dimensions '(' port_conn_expression_list_with_nuls ')'\n      { lgate*tmp = new lgate;\n\ttmp->name = $1;\n\ttmp->parms = $4;\n\ttmp->ranges = $2;\n\tFILE_NAME(tmp, @1);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n\n  | '(' port_conn_expression_list_with_nuls ')'\n      { lgate*tmp = new lgate;\n\ttmp->name = \"\";\n\ttmp->parms = $2;\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  /* Degenerate modules can have no ports. */\n\n  | IDENTIFIER dimensions\n      { lgate*tmp = new lgate;\n\ttmp->name = $1;\n\ttmp->parms = 0;\n\ttmp->parms_by_name = 0;\n\ttmp->ranges = $2;\n\tFILE_NAME(tmp, @1);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n\n  /* Modules can also take ports by port-name expressions. */\n\n  | IDENTIFIER '(' port_name_list ')'\n      { lgate*tmp = new lgate;\n\ttmp->name = $1;\n\ttmp->parms = 0;\n\ttmp->parms_by_name = $3;\n\tFILE_NAME(tmp, @1);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n\n  | IDENTIFIER dimensions '(' port_name_list ')'\n      { lgate*tmp = new lgate;\n\ttmp->name = $1;\n\ttmp->parms = 0;\n\ttmp->parms_by_name = $4;\n\ttmp->ranges = $2;\n\tFILE_NAME(tmp, @1);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n\n  | IDENTIFIER '(' error ')'\n      { lgate*tmp = new lgate;\n\ttmp->name = $1;\n\ttmp->parms = 0;\n\ttmp->parms_by_name = 0;\n\tFILE_NAME(tmp, @1);\n\tyyerror(@2, \"error: Syntax error in instance port \"\n\t        \"expression(s).\");\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n\n  | IDENTIFIER dimensions '(' error ')'\n      { lgate*tmp = new lgate;\n\ttmp->name = $1;\n\ttmp->parms = 0;\n\ttmp->parms_by_name = 0;\n\ttmp->ranges = $2;\n\tFILE_NAME(tmp, @1);\n\tyyerror(@3, \"error: Syntax error in instance port \"\n\t        \"expression(s).\");\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  ;\n\ngate_instance_list\n  : gate_instance_list ',' gate_instance\n      { $1->push_back(*$3);\n\tdelete $3;\n\t$$ = $1;\n      }\n  | gate_instance\n      { $$ = new std::vector<lgate>(1, *$1);\n\tdelete $1;\n      }\n  ;\n\ngatetype\n  : K_and    { $$ = PGBuiltin::AND; }\n  | K_nand   { $$ = PGBuiltin::NAND; }\n  | K_or     { $$ = PGBuiltin::OR; }\n  | K_nor    { $$ = PGBuiltin::NOR; }\n  | K_xor    { $$ = PGBuiltin::XOR; }\n  | K_xnor   { $$ = PGBuiltin::XNOR; }\n  | K_buf    { $$ = PGBuiltin::BUF; }\n  | K_bufif0 { $$ = PGBuiltin::BUFIF0; }\n  | K_bufif1 { $$ = PGBuiltin::BUFIF1; }\n  | K_not    { $$ = PGBuiltin::NOT; }\n  | K_notif0 { $$ = PGBuiltin::NOTIF0; }\n  | K_notif1 { $$ = PGBuiltin::NOTIF1; }\n  ;\n\nswitchtype\n  : K_nmos     { $$ = PGBuiltin::NMOS; }\n  | K_rnmos    { $$ = PGBuiltin::RNMOS; }\n  | K_pmos     { $$ = PGBuiltin::PMOS; }\n  | K_rpmos    { $$ = PGBuiltin::RPMOS; }\n  | K_cmos     { $$ = PGBuiltin::CMOS; }\n  | K_rcmos    { $$ = PGBuiltin::RCMOS; }\n  | K_tran     { $$ = PGBuiltin::TRAN; }\n  | K_rtran    { $$ = PGBuiltin::RTRAN; }\n  | K_tranif0  { $$ = PGBuiltin::TRANIF0; }\n  | K_tranif1  { $$ = PGBuiltin::TRANIF1; }\n  | K_rtranif0 { $$ = PGBuiltin::RTRANIF0; }\n  | K_rtranif1 { $$ = PGBuiltin::RTRANIF1; }\n  ;\n\n\n  /* A general identifier is a hierarchical name, with the right most\n     name the base of the identifier. This rule builds up a\n     hierarchical name from the left to the right, forming a list of\n     names. */\n\nhierarchy_identifier\n  : IDENTIFIER\n      { $$ = new pform_name_t;\n\t$$->push_back(name_component_t(lex_strings.make($1)));\n\tdelete[]$1;\n      }\n  | hierarchy_identifier '.' IDENTIFIER\n      { pform_name_t * tmp = $1;\n\ttmp->push_back(name_component_t(lex_strings.make($3)));\n\tdelete[]$3;\n\t$$ = tmp;\n      }\n  | hierarchy_identifier '[' expression ']'\n      { pform_name_t * tmp = $1;\n\tname_component_t&tail = tmp->back();\n\tindex_component_t itmp;\n\titmp.sel = index_component_t::SEL_BIT;\n\titmp.msb = $3;\n\ttail.index.push_back(itmp);\n\t$$ = tmp;\n      }\n  | hierarchy_identifier '[' '$' ']'\n      { pform_requires_sv(@3, \"Last element expression ($)\");\n        pform_name_t * tmp = $1;\n\tname_component_t&tail = tmp->back();\n\tindex_component_t itmp;\n\titmp.sel = index_component_t::SEL_BIT_LAST;\n\titmp.msb = 0;\n\titmp.lsb = 0;\n\ttail.index.push_back(itmp);\n\t$$ = tmp;\n      }\n  | hierarchy_identifier '[' expression ':' expression ']'\n      { pform_name_t * tmp = $1;\n\tname_component_t&tail = tmp->back();\n\tindex_component_t itmp;\n\titmp.sel = index_component_t::SEL_PART;\n\titmp.msb = $3;\n\titmp.lsb = $5;\n\ttail.index.push_back(itmp);\n\t$$ = tmp;\n      }\n  | hierarchy_identifier '[' expression K_PO_POS expression ']'\n      { pform_name_t * tmp = $1;\n\tname_component_t&tail = tmp->back();\n\tindex_component_t itmp;\n\titmp.sel = index_component_t::SEL_IDX_UP;\n\titmp.msb = $3;\n\titmp.lsb = $5;\n\ttail.index.push_back(itmp);\n\t$$ = tmp;\n      }\n  | hierarchy_identifier '[' expression K_PO_NEG expression ']'\n      { pform_name_t * tmp = $1;\n\tname_component_t&tail = tmp->back();\n\tindex_component_t itmp;\n\titmp.sel = index_component_t::SEL_IDX_DO;\n\titmp.msb = $3;\n\titmp.lsb = $5;\n\ttail.index.push_back(itmp);\n\t$$ = tmp;\n      }\n  ;\n\n  /* This is a list of identifiers. The result is a list of strings,\n     each one of the identifiers in the list. These are simple,\n     non-hierarchical names separated by ',' characters. */\nlist_of_identifiers\n  : IDENTIFIER\n      { $$ = list_from_identifier($1, @1.lexical_pos); }\n  | list_of_identifiers ',' IDENTIFIER\n      { $$ = list_from_identifier($1, $3, @3.lexical_pos); }\n  ;\n\nlist_of_port_identifiers\n  : IDENTIFIER dimensions_opt\n      { $$ = make_port_list($1, @1.lexical_pos, $2, 0); }\n  | list_of_port_identifiers ',' IDENTIFIER dimensions_opt\n      { $$ = make_port_list($1, $3, @3.lexical_pos, $4, 0); }\n  ;\n\nlist_of_variable_port_identifiers\n  : IDENTIFIER dimensions_opt initializer_opt\n      { $$ = make_port_list($1, @1.lexical_pos, $2, $3); }\n  | list_of_variable_port_identifiers ',' IDENTIFIER dimensions_opt initializer_opt\n      { $$ = make_port_list($1, $3, @3.lexical_pos, $4, $5); }\n  ;\n\n\n  /* The list_of_ports and list_of_port_declarations rules are the\n     port list formats for module ports. The list_of_ports_opt rule is\n     only used by the module start rule.\n\n     The first, the list_of_ports, is the 1364-1995 format, a list of\n     port names, including .name() syntax.\n\n     The list_of_port_declarations the 1364-2001 format, an in-line\n     declaration of the ports.\n\n     In both cases, the list_of_ports and list_of_port_declarations\n     returns an array of Module::port_t* items that include the name\n     of the port internally and externally. The actual creation of the\n     nets/variables is done in the declaration, whether internal to\n     the port list or in amongst the module items. */\n\nlist_of_ports\n  : port_opt\n      { std::vector<Module::port_t*>*tmp = new std::vector<Module::port_t*>(1);\n\t(*tmp)[0] = $1;\n\t$$ = tmp;\n      }\n  | list_of_ports ',' port_opt\n      { std::vector<Module::port_t*>*tmp = $1;\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  ;\n\nlist_of_port_declarations\n  : port_declaration\n      { std::vector<Module::port_t*>*tmp = new std::vector<Module::port_t*>(1);\n\t(*tmp)[0] = $1;\n\t$$ = tmp;\n      }\n  | list_of_port_declarations ',' port_declaration\n      { std::vector<Module::port_t*>*tmp = $1;\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  | list_of_port_declarations ',' attribute_list_opt IDENTIFIER dimensions_opt initializer_opt\n      { std::vector<Module::port_t*> *ports = $1;\n\n\tModule::port_t* port;\n\tport = module_declare_port(@4, $4, port_declaration_context.port_type,\n\t\t\t\t   port_declaration_context.port_net_type,\n\t\t\t\t   port_declaration_context.data_type,\n\t\t\t\t   $5, $6, $3);\n\tports->push_back(port);\n\t$$ = ports;\n      }\n  | list_of_port_declarations ','\n      { yyerror(@2, \"error: Superfluous comma in port declaration list.\"); }\n  | list_of_port_declarations ';'\n      { yyerror(@2, \"error: ';' is an invalid port declaration separator.\"); }\n  ;\n\n  // All of port direction, port kind and data type are optional, but at least\n  // one has to be specified, so we need multiple rules.\nport_declaration\n  : attribute_list_opt port_direction net_type_or_var_opt data_type_or_implicit IDENTIFIER dimensions_opt initializer_opt\n      { $$ = module_declare_port(@5, $5, $2, $3, $4, $6, $7, $1);\n      }\n  | attribute_list_opt net_type_or_var data_type_or_implicit IDENTIFIER dimensions_opt initializer_opt\n      { pform_requires_sv(@4, \"Partial ANSI port declaration\");\n\t$$ = module_declare_port(@4, $4, port_declaration_context.port_type,\n\t\t\t         $2, $3, $5, $6, $1);\n      }\n  | attribute_list_opt data_type_or_implicit_no_opt IDENTIFIER dimensions_opt initializer_opt\n      { pform_requires_sv(@3, \"Partial ANSI port declaration\");\n\t$$ = module_declare_port(@3, $3, port_declaration_context.port_type,\n\t\t\t         NetNet::IMPLICIT, $2, $4, $5, $1);\n      }\n  | attribute_list_opt port_direction K_wreal IDENTIFIER\n      { real_type_t*real_type = new real_type_t(real_type_t::REAL);\n\tFILE_NAME(real_type, @3);\n\t$$ = module_declare_port(@4, $4, $2, NetNet::WIRE,\n\t\t\t\t real_type, nullptr, nullptr, $1);\n      }\n  ;\n\n  /*\n   * The signed_opt rule will return \"true\" if K_signed is present,\n   * for \"false\" otherwise. This rule corresponds to the declaration\n   * defaults for reg/bit/logic.\n   *\n   * The signed_unsigned_opt rule with match K_signed or K_unsigned\n   * and return true or false as appropriate. The default is\n   * \"true\". This corresponds to the declaration defaults for\n   * byte/shortint/int/longint.\n   */\nunsigned_signed_opt\n  : K_signed   { $$ = true; }\n  | K_unsigned { $$ = false; }\n  |            { $$ = false; }\n  ;\n\nsigned_unsigned_opt\n  : K_signed   { $$ = true; }\n  | K_unsigned { $$ = false; }\n  |            { $$ = true; }\n  ;\n\n  /*\n   * In some places we can take any of the 4 2-value atom-type\n   * names. All the context needs to know if that type is its width.\n   */\natom_type\n  : K_byte     { $$ = atom_type_t::BYTE; }\n  | K_shortint { $$ = atom_type_t::SHORTINT; }\n  | K_int      { $$ = atom_type_t::INT; }\n  | K_longint  { $$ = atom_type_t::LONGINT; }\n  | K_integer  { $$ = atom_type_t::INTEGER; }\n  ;\n\n  /* An lpvalue is the expression that can go on the left side of a\n     procedural assignment. This rule handles only procedural\n     assignments. It is more limited than the general expr_primary\n     rule to reflect the rules for assignment l-values. */\nlpvalue\n  : hierarchy_identifier\n      { PEIdent*tmp = pform_new_ident(@1, *$1);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete $1;\n      }\n\n  | class_hierarchy_identifier\n      { PEIdent*tmp = new PEIdent(*$1, @1.lexical_pos);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n\tdelete $1;\n      }\n\n  | '{' expression_list_proper '}'\n      { PEConcat*tmp = new PEConcat(*$2);\n\tFILE_NAME(tmp, @1);\n\tdelete $2;\n\t$$ = tmp;\n      }\n\n  | streaming_concatenation\n      { yyerror(@1, \"sorry: Streaming concatenation not supported in l-values.\");\n\t$$ = 0;\n      }\n  ;\n\n\n  /* Continuous assignments have a list of individual assignments. */\n\ncont_assign\n  : lpvalue '=' expression\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($1);\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  ;\n\ncont_assign_list\n  : cont_assign_list ',' cont_assign\n      { std::list<PExpr*>*tmp = $1;\n\ttmp->splice(tmp->end(), *$3);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  | cont_assign\n      { $$ = $1; }\n  ;\n\n  /* This is the global structure of a module. A module is a start\n     section, with optional ports, then an optional list of module\n     items, and finally an end marker. */\n\nmodule\n  : attribute_list_opt module_start lifetime_opt IDENTIFIER\n      { pform_startmodule(@2, $4, $2==K_program, $2==K_interface, $3, $1);\n        port_declaration_context_init(); }\n    module_package_import_list_opt\n    module_parameter_port_list_opt\n    module_port_list_opt\n    module_attribute_foreign ';'\n      { pform_module_set_ports($8); }\n    timeunits_declaration_opt\n      { pform_set_scope_timescale(@2); }\n    module_item_list_opt\n    module_end\n      { Module::UCDriveType ucd;\n\t  // The lexor detected `unconnected_drive directives and\n\t  // marked what it found in the uc_drive variable. Use that\n\t  // to generate a UCD flag for the module.\n\tswitch (uc_drive) {\n\t    case UCD_NONE:\n\t    default:\n\t      ucd = Module::UCD_NONE;\n\t      break;\n\t    case UCD_PULL0:\n\t      ucd = Module::UCD_PULL0;\n\t      break;\n\t    case UCD_PULL1:\n\t      ucd = Module::UCD_PULL1;\n\t      break;\n\t}\n\t  // Check that program/endprogram and module/endmodule\n\t  // keywords match.\n\tif ($2 != $15) {\n\t      switch ($2) {\n\t\t  case K_module:\n\t\t    yyerror(@15, \"error: module not closed by endmodule.\");\n\t\t    break;\n\t\t  case K_program:\n\t\t    yyerror(@15, \"error: program not closed by endprogram.\");\n\t\t    break;\n\t\t  case K_interface:\n\t\t    yyerror(@15, \"error: interface not closed by endinterface.\");\n\t\t    break;\n\t\t  default:\n\t\t    break;\n\t      }\n\t}\n\tpform_endmodule($4, in_celldefine, ucd);\n      }\n    label_opt\n      { // Last step: check any closing name. This is done late so\n\t// that the parser can look ahead to detect the present\n\t// label_opt but still have the pform_endmodule() called\n\t// early enough that the lexor can know we are outside the\n\t// module.\n\tswitch ($2) {\n\t    case K_module:\n\t      check_end_label(@17, \"module\", $4, $17);\n\t      break;\n\t    case K_program:\n\t      check_end_label(@17, \"program\", $4, $17);\n\t      break;\n\t    case K_interface:\n\t      check_end_label(@17, \"interface\", $4, $17);\n\t      break;\n\t    default:\n\t      break;\n\t}\n\tdelete[]$4;\n      }\n  ;\n\n  /* Modules start with a module/macromodule, program, or interface\n     keyword, and end with a endmodule, endprogram, or endinterface\n     keyword. The syntax for modules programs, and interfaces is\n     almost identical, so let semantics sort out the differences. */\nmodule_start\n  : K_module\n      { pform_error_in_generate(@1, \"module declaration\");\n        $$ = K_module;\n      }\n  | K_macromodule\n      { pform_error_in_generate(@1, \"module declaration\");\n        $$ = K_module;\n      }\n  | K_program\n      { pform_error_in_generate(@1, \"program declaration\");\n        $$ = K_program;\n      }\n  | K_interface\n      { pform_error_in_generate(@1, \"interface declaration\");\n        $$ = K_interface;\n      }\n  ;\n\nmodule_end\n  : K_endmodule    { $$ = K_module; }\n  | K_endprogram   { $$ = K_program; }\n  | K_endinterface { $$ = K_interface; }\n  ;\n\nlabel_opt\n  : ':' IDENTIFIER { $$ = $2; }\n  |                { $$ = 0; }\n  ;\n\nmodule_attribute_foreign\n  : K_PSTAR IDENTIFIER K_integer IDENTIFIER '=' STRING ';' K_STARP { $$ = 0; }\n  | { $$ = 0; }\n  ;\n\nmodule_port_list_opt\n  : '(' list_of_ports ')'\n      { $$ = $2; }\n  | '(' list_of_port_declarations ')'\n      { $$ = $2; }\n  |\n      { $$ = 0; }\n  | '(' error ')'\n      { yyerror(@2, \"Errors in port declarations.\");\n\tyyerrok;\n\t$$ = 0;\n      }\n  ;\n\n  /* Module declarations include optional ANSI style module parameter\n     ports. These are simply advance ways to declare parameters, so\n     that the port declarations may use them. */\nmodule_parameter_port_list_opt\n  :\n  | '#' '('\n      { pform_start_parameter_port_list(); }\n    module_parameter_port_list\n      { pform_end_parameter_port_list(); }\n    ')'\n  ;\n\ntype_param\n  : K_type { param_is_type = true; }\n  ;\n\nmodule_parameter\n  : parameter param_type parameter_assign\n  | localparam param_type parameter_assign\n      { pform_requires_sv(@1, \"Local parameter in module parameter port list\");\n      }\n  ;\n\nmodule_parameter_port_list\n  : module_parameter\n  | data_type_opt\n      { param_data_type = $1;\n        param_is_local = false;\n        param_is_type = false;\n      }\n    parameter_assign\n      { pform_requires_sv(@3, \"Omitting initial `parameter` in parameter port \"\n\t\t\t      \"list\");\n      }\n  | type_param\n      { param_is_local = false; }\n    parameter_assign\n  | module_parameter_port_list ',' module_parameter\n  | module_parameter_port_list ',' data_type_opt\n      { if ($3) {\n\t      pform_requires_sv(@3, \"Omitting `parameter`/`localparam` before \"\n\t\t\t\t    \"data type in parameter port list\");\n\t      param_data_type = $3;\n\t      param_is_type = false;\n        }\n      }\n    parameter_assign\n  | module_parameter_port_list ',' type_param parameter_assign\n  ;\n\nmodule_item\n\n  /* Modules can contain further sub-module definitions. */\n  : module\n\n  | attribute_list_opt net_type data_type_or_implicit delay3_opt net_variable_list ';'\n\n      { data_type_t*data_type = $3;\n        pform_check_net_data_type(@2, $2, $3);\n\tif (data_type == 0) {\n\t      data_type = new vector_type_t(IVL_VT_LOGIC, false, 0);\n\t      FILE_NAME(data_type, @2);\n\t}\n\tpform_set_data_type(@2, data_type, $5, $2, $1);\n\tif ($4 != 0) {\n\t      yyerror(@2, \"sorry: Net delays not supported.\");\n\t      delete $4;\n\t}\n\tdelete $1;\n      }\n\n  | attribute_list_opt K_wreal delay3 net_variable_list ';'\n      { real_type_t*tmpt = new real_type_t(real_type_t::REAL);\n\tpform_set_data_type(@2, tmpt, $4, NetNet::WIRE, $1);\n\tif ($3 != 0) {\n\t      yyerror(@3, \"sorry: Net delays not supported.\");\n\t      delete $3;\n\t}\n\tdelete $1;\n      }\n\n  | attribute_list_opt K_wreal net_variable_list ';'\n      { real_type_t*tmpt = new real_type_t(real_type_t::REAL);\n\tpform_set_data_type(@2, tmpt, $3, NetNet::WIRE, $1);\n\tdelete $1;\n      }\n\n  /* Very similar to the rule above, but this takes a list of\n     net_decl_assigns, which are <name> = <expr> assignment\n     declarations. */\n\n  | attribute_list_opt net_type data_type_or_implicit delay3_opt net_decl_assigns ';'\n      { data_type_t*data_type = $3;\n        pform_check_net_data_type(@2, $2, $3);\n\tif (data_type == 0) {\n\t      data_type = new vector_type_t(IVL_VT_LOGIC, false, 0);\n\t      FILE_NAME(data_type, @2);\n\t}\n\tpform_makewire(@2, $4, str_strength, $5, $2, data_type, $1);\n\tdelete $1;\n      }\n\n  /* This form doesn't have the range, but does have strengths. This\n     gives strength to the assignment drivers. */\n\n  | attribute_list_opt net_type data_type_or_implicit drive_strength net_decl_assigns ';'\n      { data_type_t*data_type = $3;\n        pform_check_net_data_type(@2, $2, $3);\n\tif (data_type == 0) {\n\t      data_type = new vector_type_t(IVL_VT_LOGIC, false, 0);\n\t      FILE_NAME(data_type, @2);\n\t}\n\tpform_makewire(@2, 0, $4, $5, $2, data_type, $1);\n\tdelete $1;\n      }\n\n  | attribute_list_opt K_wreal net_decl_assigns ';'\n      { real_type_t*data_type = new real_type_t(real_type_t::REAL);\n\tpform_makewire(@2, 0, str_strength, $3, NetNet::WIRE, data_type, $1);\n\tdelete $1;\n      }\n\n  | K_trireg charge_strength_opt dimensions_opt delay3_opt list_of_identifiers ';'\n      { yyerror(@1, \"sorry: trireg nets not supported.\");\n\tdelete $3;\n\tdelete $4;\n      }\n\n\n  /* The next two rules handle port declarations that include a net type, e.g.\n       input wire signed [h:l] <list>;\n     This creates the wire and sets the port type all at once. */\n\n  | attribute_list_opt port_direction net_type_or_var data_type_or_implicit list_of_port_identifiers ';'\n      { pform_module_define_port(@2, $5, $2, $3, $4, $1); }\n\n  | attribute_list_opt port_direction K_wreal list_of_port_identifiers ';'\n      { real_type_t*real_type = new real_type_t(real_type_t::REAL);\n\tpform_module_define_port(@2, $4, $2, NetNet::WIRE, real_type, $1);\n      }\n\n  /* The next three rules handle port declarations that include a variable\n     type, e.g.\n       output reg signed [h:l] <list>;\n     and also handle incomplete port declarations, e.g.\n       input signed [h:l] <list>;\n   */\n  | attribute_list_opt K_inout data_type_or_implicit list_of_port_identifiers ';'\n      { NetNet::Type use_type = $3 ? NetNet::IMPLICIT : NetNet::NONE;\n\tif (vector_type_t*dtype = dynamic_cast<vector_type_t*> ($3)) {\n\t      if (dtype->implicit_flag)\n\t\t    use_type = NetNet::NONE;\n\t}\n\tif (use_type == NetNet::NONE)\n\t      pform_set_port_type(@2, $4, NetNet::PINOUT, $3, $1);\n\telse\n\t      pform_module_define_port(@2, $4, NetNet::PINOUT, use_type, $3, $1);\n      }\n\n  | attribute_list_opt K_input data_type_or_implicit list_of_port_identifiers ';'\n      { NetNet::Type use_type = $3 ? NetNet::IMPLICIT : NetNet::NONE;\n\tif (vector_type_t*dtype = dynamic_cast<vector_type_t*> ($3)) {\n\t      if (dtype->implicit_flag)\n\t\t    use_type = NetNet::NONE;\n\t}\n\tif (use_type == NetNet::NONE)\n\t      pform_set_port_type(@2, $4, NetNet::PINPUT, $3, $1);\n\telse\n\t      pform_module_define_port(@2, $4, NetNet::PINPUT, use_type, $3, $1);\n      }\n\n  | attribute_list_opt K_output data_type_or_implicit list_of_variable_port_identifiers ';'\n      { NetNet::Type use_type = $3 ? NetNet::IMPLICIT : NetNet::NONE;\n\tif (vector_type_t*dtype = dynamic_cast<vector_type_t*> ($3)) {\n\t      if (dtype->implicit_flag)\n\t\t    use_type = NetNet::NONE;\n\t      else\n\t\t    use_type = NetNet::IMPLICIT_REG;\n\n\t\t// The SystemVerilog types that can show up as\n\t\t// output ports are implicitly (on the inside)\n\t\t// variables because \"reg\" is not valid syntax\n\t\t// here.\n\t} else if ($3) {\n\t      use_type = NetNet::IMPLICIT_REG;\n\t}\n\tif (use_type == NetNet::NONE)\n\t      pform_set_port_type(@2, $4, NetNet::POUTPUT, $3, $1);\n\telse\n\t      pform_module_define_port(@2, $4, NetNet::POUTPUT, use_type, $3, $1);\n      }\n\n  | attribute_list_opt port_direction net_type_or_var data_type_or_implicit error ';'\n      { yyerror(@2, \"error: Invalid variable list in port declaration.\");\n\tif ($1) delete $1;\n\tif ($4) delete $4;\n\tyyerrok;\n      }\n\n  | attribute_list_opt K_inout data_type_or_implicit error ';'\n      { yyerror(@2, \"error: Invalid variable list in port declaration.\");\n\tif ($1) delete $1;\n\tif ($3) delete $3;\n\tyyerrok;\n      }\n\n  | attribute_list_opt K_input data_type_or_implicit error ';'\n      { yyerror(@2, \"error: Invalid variable list in port declaration.\");\n\tif ($1) delete $1;\n\tif ($3) delete $3;\n\tyyerrok;\n      }\n\n  | attribute_list_opt K_output data_type_or_implicit error ';'\n      { yyerror(@2, \"error: Invalid variable list in port declaration.\");\n\tif ($1) delete $1;\n\tif ($3) delete $3;\n\tyyerrok;\n      }\n\n  | K_let IDENTIFIER let_port_list_opt '=' expression ';'\n      { perm_string tmp2 = lex_strings.make($2);\n        pform_make_let(@1, tmp2, $3, $5);\n      }\n\n  /* Maybe this is a discipline declaration? If so, then the lexor\n     will see the discipline name as an identifier. We match it to the\n     discipline or type name semantically. */\n  | DISCIPLINE_IDENTIFIER list_of_identifiers ';'\n      { pform_attach_discipline(@1, $1, $2); }\n\n  /* block_item_decl rule is shared with task blocks and named\n     begin/end. Careful to pass attributes to the block_item_decl. */\n\n  | attribute_list_opt { attributes_in_context = $1; } block_item_decl\n      { delete attributes_in_context;\n\tattributes_in_context = 0;\n      }\n\n  /* */\n\n  | K_defparam\n      { if (pform_in_interface())\n\t      yyerror(@1, \"error: Parameter overrides are not allowed \"\n\t\t\t  \"in interfaces.\");\n      }\n    defparam_assign_list ';'\n\n  /* Most gate types have an optional drive strength and optional\n     two/three-value delay. These rules handle the different cases.\n     We check that the actual number of delays is correct later. */\n\n  | attribute_list_opt gatetype gate_instance_list ';'\n      { pform_makegates(@2, $2, str_strength, 0, $3, $1); }\n\n  | attribute_list_opt gatetype delay3 gate_instance_list ';'\n      { pform_makegates(@2, $2, str_strength, $3, $4, $1); }\n\n  | attribute_list_opt gatetype drive_strength gate_instance_list ';'\n      { pform_makegates(@2, $2, $3, 0, $4, $1); }\n\n  | attribute_list_opt gatetype drive_strength delay3 gate_instance_list ';'\n      { pform_makegates(@2, $2, $3, $4, $5, $1); }\n\n  /* The switch type gates do not support a strength. */\n  | attribute_list_opt switchtype gate_instance_list ';'\n      { pform_makegates(@2, $2, str_strength, 0, $3, $1); }\n\n  | attribute_list_opt switchtype delay3 gate_instance_list ';'\n      { pform_makegates(@2, $2, str_strength, $3, $4, $1); }\n\n  /* Pullup and pulldown devices cannot have delays, and their\n     strengths are limited. */\n\n  | K_pullup gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLUP, pull_strength, 0, $2, 0); }\n  | K_pulldown gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLDOWN, pull_strength, 0, $2, 0); }\n\n  | K_pullup '(' dr_strength1 ')' gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLUP, $3, 0, $5, 0); }\n\n  | K_pullup '(' dr_strength1 ',' dr_strength0 ')' gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLUP, $3, 0, $7, 0); }\n\n  | K_pullup '(' dr_strength0 ',' dr_strength1 ')' gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLUP, $5, 0, $7, 0); }\n\n  | K_pulldown '(' dr_strength0 ')' gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLDOWN, $3, 0, $5, 0); }\n\n  | K_pulldown '(' dr_strength1 ',' dr_strength0 ')' gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLDOWN, $5, 0, $7, 0); }\n\n  | K_pulldown '(' dr_strength0 ',' dr_strength1 ')' gate_instance_list ';'\n      { pform_makegates(@1, PGBuiltin::PULLDOWN, $3, 0, $7, 0); }\n\n  /* This rule handles instantiations of modules and user defined\n     primitives. These devices to not have delay lists or strengths,\n     but then can have parameter lists. */\n\n  | attribute_list_opt\n\t  IDENTIFIER parameter_value_opt gate_instance_list ';'\n      { perm_string tmp1 = lex_strings.make($2);\n\t\t  pform_make_modgates(@2, tmp1, $3, $4, $1);\n\t\t  delete[]$2;\n      }\n\n        | attribute_list_opt\n\t  IDENTIFIER parameter_value_opt error ';'\n      { yyerror(@2, \"error: Invalid module instantiation\");\n\t\t  delete[]$2;\n\t\t  if ($1) delete $1;\n      }\n\n  /* Continuous assignment can have an optional drive strength, then\n     an optional delay3 that applies to all the assignments in the\n     cont_assign_list. */\n\n  | K_assign drive_strength_opt delay3_opt cont_assign_list ';'\n      { pform_make_pgassign_list(@1, $4, $3, $2); }\n\n  /* Always and initial items are behavioral processes. */\n\n  | attribute_list_opt K_always statement_item\n      { PProcess*tmp = pform_make_behavior(IVL_PR_ALWAYS, $3, $1);\n\tFILE_NAME(tmp, @2);\n      }\n  | attribute_list_opt K_always_comb statement_item\n      { PProcess*tmp = pform_make_behavior(IVL_PR_ALWAYS_COMB, $3, $1);\n\tFILE_NAME(tmp, @2);\n      }\n  | attribute_list_opt K_always_ff statement_item\n      { PProcess*tmp = pform_make_behavior(IVL_PR_ALWAYS_FF, $3, $1);\n\tFILE_NAME(tmp, @2);\n      }\n  | attribute_list_opt K_always_latch statement_item\n      { PProcess*tmp = pform_make_behavior(IVL_PR_ALWAYS_LATCH, $3, $1);\n\tFILE_NAME(tmp, @2);\n      }\n  | attribute_list_opt K_initial statement_item\n      { PProcess*tmp = pform_make_behavior(IVL_PR_INITIAL, $3, $1);\n\tFILE_NAME(tmp, @2);\n      }\n  | attribute_list_opt K_final statement_item\n      { PProcess*tmp = pform_make_behavior(IVL_PR_FINAL, $3, $1);\n\tFILE_NAME(tmp, @2);\n      }\n\n  | attribute_list_opt K_analog analog_statement\n      { pform_make_analog_behavior(@2, IVL_PR_ALWAYS, $3); }\n\n  | attribute_list_opt assertion_item\n\n  | timeunits_declaration\n      { pform_error_in_generate(@1, \"timeunit declaration\"); }\n\n  | class_declaration\n\n  | task_declaration\n\n  | function_declaration\n\n  /* A generate region can contain further module items. Actually, it\n     is supposed to be limited to certain kinds of module items, but\n     the semantic tests will check that for us. Do check that the\n     generate/endgenerate regions do not nest. Generate schemes nest,\n     but generate regions do not. */\n\n  | K_generate { check_in_gen_region(@1); } generate_item_list_opt K_endgenerate { in_gen_region = false; }\n\n  | K_genvar list_of_identifiers ';'\n      { pform_genvars(@1, $2); }\n\n  | K_for '(' K_genvar_opt IDENTIFIER '=' expression ';'\n              expression ';'\n              genvar_iteration ')'\n      { pform_start_generate_for(@2, $3, $4, $6, $8, $10.text, $10.expr); }\n    generate_block\n      { pform_endgenerate(false); }\n\n  | generate_if\n    generate_block\n    K_else\n      { pform_start_generate_else(@1); }\n    generate_block\n      { pform_endgenerate(true); }\n\n  | generate_if\n    generate_block %prec less_than_K_else\n      { pform_endgenerate(true); }\n\n  | K_case '(' expression ')'\n      { pform_start_generate_case(@1, $3); }\n    generate_case_items\n    K_endcase\n      { pform_endgenerate(true); }\n\n  /* Elaboration system tasks. */\n  | SYSTEM_IDENTIFIER argument_list_parens_opt ';'\n      { pform_make_elab_task(@1, lex_strings.make($1), *$2);\n\tdelete[]$1;\n\tdelete $2;\n      }\n\n  | modport_declaration\n\n  /* 1364-2001 and later allow specparam declarations outside specify blocks. */\n\n  | attribute_list_opt K_specparam\n      { if (pform_in_interface())\n\t      yyerror(@2, \"error: specparam declarations are not allowed \"\n\t\t\t  \"in interfaces.\");\n        pform_error_in_generate(@2, \"specparam declaration\");\n      }\n    specparam_decl ';'\n\n  /* specify blocks are parsed but ignored. */\n\n  | K_specify\n      { if (pform_in_interface())\n\t      yyerror(@1, \"error: specify blocks are not allowed \"\n\t\t\t  \"in interfaces.\");\n        pform_error_in_generate(@1, \"specify block\");\n      }\n\n    specify_item_list_opt K_endspecify\n\n  | K_specify error K_endspecify\n      { yyerror(@1, \"error: Syntax error in specify block\");\n\tyyerrok;\n      }\n\n  /* These rules match various errors that the user can type into\n     module items. These rules try to catch them at a point where a\n     reasonable error message can be produced. */\n\n  | error ';'\n      { yyerror(@2, \"error: Invalid module item.\");\n\tyyerrok;\n      }\n\n  | K_assign error '=' expression ';'\n      { yyerror(@1, \"error: Syntax error in left side of \"\n\t            \"continuous assignment.\");\n\tyyerrok;\n      }\n\n  | K_assign error ';'\n      { yyerror(@1, \"error: Syntax error in continuous assignment\");\n\tyyerrok;\n      }\n\n  | K_function error K_endfunction label_opt\n      { yyerror(@1, \"error: I give up on this function definition.\");\n\tif ($4) {\n\t    pform_requires_sv(@4, \"Function end label\");\n\t    delete[]$4;\n\t}\n\tyyerrok;\n      }\n\n  /* These rules are for the Icarus Verilog specific $attribute\n     extensions. Then catch the parameters of the $attribute keyword. */\n\n  | KK_attribute '(' IDENTIFIER ',' STRING ',' STRING ')' ';'\n      { perm_string tmp3 = lex_strings.make($3);\n\tperm_string tmp5 = lex_strings.make($5);\n\tpform_set_attrib(tmp3, tmp5, $7);\n\tdelete[] $3;\n\tdelete[] $5;\n      }\n  | KK_attribute '(' error ')' ';'\n      { yyerror(@1, \"error: Malformed $attribute parameter list.\"); }\n\n  | ';'\n      { }\n\n  ;\n\nlet_port_list_opt\n  : '(' let_port_list ')'\n      { $$ = $2; }\n  | '(' ')'\n      { $$ = 0; }\n  |\n      { $$ = 0; }\n  ;\n\nlet_port_list\n  : let_port_item\n      { std::list<PLet::let_port_t*>*tmp = new std::list<PLet::let_port_t*>;\n\ttmp->push_back($1);\n\t$$ = tmp;\n      }\n  | let_port_list ',' let_port_item\n      { std::list<PLet::let_port_t*>*tmp = $1;\n        tmp->push_back($3);\n        $$ = tmp;\n      }\n  ;\n\n  // FIXME: What about the attributes?\nlet_port_item\n  : attribute_list_opt let_formal_type IDENTIFIER dimensions_opt initializer_opt\n      { perm_string tmp3 = lex_strings.make($3);\n        $$ = pform_make_let_port($2, tmp3, $4, $5);\n      }\n  ;\n\nlet_formal_type\n  : data_type_or_implicit\n      { $$ = $1; }\n  | K_untyped\n      { $$ = 0; }\n  ;\n\nmodule_item_list\n  : module_item_list module_item\n  | module_item\n  ;\n\nmodule_item_list_opt\n  : module_item_list\n  |\n  ;\n\ngenerate_if\n  : K_if '(' expression ')'\n      { pform_start_generate_if(@1, $3); }\n  ;\n\ngenerate_case_items\n  : generate_case_items generate_case_item\n  | generate_case_item\n  ;\n\ngenerate_case_item\n  : expression_list_proper ':'\n      { pform_generate_case_item(@1, $1); }\n    generate_block\n      { pform_endgenerate(false); }\n  | K_default ':'\n      { pform_generate_case_item(@1, 0); }\n    generate_block\n      { pform_endgenerate(false); }\n  ;\n\ngenerate_item\n  : module_item\n  /* Handle some anachronistic syntax cases. */\n  | K_begin generate_item_list_opt K_end\n      { /* Detect and warn about anachronistic begin/end use */\n\tif (generation_flag > GN_VER2001 && warn_anachronisms) {\n\t      warn_count += 1;\n\t      cerr << @1 << \": warning: Anachronistic use of begin/end to surround generate schemes.\" << endl;\n\t}\n      }\n  | K_begin ':' IDENTIFIER\n      { pform_start_generate_nblock(@1, $3); }\n    generate_item_list_opt K_end\n      { /* Detect and warn about anachronistic named begin/end use */\n\tif (generation_flag > GN_VER2001 && warn_anachronisms) {\n\t      warn_count += 1;\n\t      cerr << @1 << \": warning: Anachronistic use of named begin/end to surround generate schemes.\" << endl;\n\t}\n\tpform_endgenerate(false);\n      }\n  ;\n\ngenerate_item_list\n  : generate_item_list generate_item\n  | generate_item\n  ;\n\ngenerate_item_list_opt\n  :   { pform_generate_single_item = false; }\n    generate_item_list\n  |\n  ;\n\n  /* A generate block is the thing within a generate scheme. It may be\n     a single module item, an anonymous block of module items, or a\n     named module item. In all cases, the meat is in the module items\n     inside, and the processing is done by the module_item rules. We\n     only need to take note here of the scope name, if any. */\n\ngenerate_block\n  :   { pform_generate_single_item = true; }\n    module_item\n      { pform_generate_single_item = false; }\n  | K_begin label_opt generate_item_list_opt K_end label_opt\n      { if ($2)\n\t    pform_generate_block_name($2);\n\tcheck_end_label(@5, \"block\", $2, $5);\n\tdelete[]$2;\n      }\n  ;\n\n  /* A net declaration assignment allows the programmer to combine the\n     net declaration and the continuous assignment into a single\n     statement.\n\n     Note that the continuous assignment statement is generated as a\n     side effect, and all I pass up is the name of the l-value. */\n\nnet_decl_assign\n  : IDENTIFIER '=' expression\n      { decl_assignment_t*tmp = new decl_assignment_t;\n\ttmp->name = { lex_strings.make($1), @1.lexical_pos };\n\ttmp->expr.reset($3);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  ;\n\nnet_decl_assigns\n  : net_decl_assigns ',' net_decl_assign\n      { std::list<decl_assignment_t*>*tmp = $1;\n\ttmp->push_back($3);\n\t$$ = tmp;\n      }\n  | net_decl_assign\n      { std::list<decl_assignment_t*>*tmp = new std::list<decl_assignment_t*>;\n\ttmp->push_back($1);\n\t$$ = tmp;\n      }\n  ;\n\nnet_type\n  : K_wire    { $$ = NetNet::WIRE; }\n  | K_tri     { $$ = NetNet::TRI; }\n  | K_tri1    { $$ = NetNet::TRI1; }\n  | K_supply0 { $$ = NetNet::SUPPLY0; }\n  | K_wand    { $$ = NetNet::WAND; }\n  | K_triand  { $$ = NetNet::TRIAND; }\n  | K_tri0    { $$ = NetNet::TRI0; }\n  | K_supply1 { $$ = NetNet::SUPPLY1; }\n  | K_wor     { $$ = NetNet::WOR; }\n  | K_trior   { $$ = NetNet::TRIOR; }\n  | K_wone    { $$ = NetNet::UNRESOLVED_WIRE;\n\t\tcerr << @1.text << \":\" << @1.first_line << \": warning: \"\n\t\t        \"'wone' is deprecated, please use 'uwire' \"\n\t\t        \"instead.\" << endl;\n\t      }\n  | K_uwire   { $$ = NetNet::UNRESOLVED_WIRE; }\n  ;\n\nnet_type_opt\n  : net_type { $$ = $1; }\n  |          { $$ = NetNet::IMPLICIT; }\n  ;\n\nnet_type_or_var\n  : net_type { $$ = $1; }\n  | K_var    { $$ = NetNet::REG; }\n\nnet_type_or_var_opt\n  : net_type_opt { $$ = $1; }\n  | K_var        { $$ = NetNet::REG; }\n  ;\n\n  /* The param_type rule is just the data_type_or_implicit rule wrapped\n     with an assignment to para_data_type with the figured data type.\n     This is used by parameter_assign, which is found to the right of\n     the param_type in various rules. */\n\nparam_type\n  : data_type_or_implicit\n      { param_is_type = false;\n        param_data_type = $1;\n      }\n  | type_param\n\nparameter\n  : K_parameter\n      { param_is_local = false; }\n  ;\n\nlocalparam\n  : K_localparam\n      { param_is_local = true; }\n  ;\n\nparameter_declaration\n  : parameter_or_localparam param_type parameter_assign_list ';'\n\nparameter_or_localparam\n  : parameter\n  | localparam\n  ;\n\n  /* parameter and localparam assignment lists are broken into\n     separate BNF so that I can call slightly different parameter\n     handling code. localparams parse the same as parameters, they\n     just behave differently when someone tries to override them. */\n\nparameter_assign_list\n  : parameter_assign\n  | parameter_assign_list ',' parameter_assign\n  ;\n\nparameter_assign\n  : IDENTIFIER dimensions_opt initializer_opt parameter_value_ranges_opt\n      { pform_set_parameter(@1, lex_strings.make($1), param_is_local,\n\t\t\t    param_is_type, param_data_type, $2, $3, $4);\n\tdelete[]$1;\n      }\n  ;\n\nparameter_value_ranges_opt : parameter_value_ranges { $$ = $1; } | { $$ = 0; } ;\n\nparameter_value_ranges\n  : parameter_value_ranges parameter_value_range\n      { $$ = $2; $$->next = $1; }\n  | parameter_value_range\n      { $$ = $1; $$->next = 0; }\n  ;\n\nparameter_value_range\n  : from_exclude '[' value_range_expression ':' value_range_expression ']'\n      { $$ = pform_parameter_value_range($1, false, $3, false, $5); }\n  | from_exclude '[' value_range_expression ':' value_range_expression ')'\n      { $$ = pform_parameter_value_range($1, false, $3, true, $5); }\n  | from_exclude '(' value_range_expression ':' value_range_expression ']'\n      { $$ = pform_parameter_value_range($1, true, $3, false, $5); }\n  | from_exclude '(' value_range_expression ':' value_range_expression ')'\n      { $$ = pform_parameter_value_range($1, true, $3, true, $5); }\n  | K_exclude expression\n      { $$ = pform_parameter_value_range(true, false, $2, false, $2); }\n  ;\n\nvalue_range_expression\n  : expression { $$ = $1; }\n  | K_inf      { $$ = 0; }\n  | '+' K_inf  { $$ = 0; }\n  | '-' K_inf  { $$ = 0; }\n  ;\n\nfrom_exclude : K_from { $$ = false; } | K_exclude { $$ = true; } ;\n\n  /* The parameters of a module instance can be overridden by writing\n     a list of expressions in a syntax much like a delay list. (The\n     difference being the list can have any length.) The pform that\n     attaches the expression list to the module checks that the\n     expressions are constant.\n\n     Although the BNF in IEEE1364-1995 implies that parameter value\n     lists must be in parentheses, in practice most compilers will\n     accept simple expressions outside of parentheses if there is only\n     one value, so I'll accept simple numbers here. This also catches\n     the case of a UDP with a single delay value, so we need to accept\n     real values as well as decimal ones.\n\n     The parameter value by name syntax is OVI enhancement BTF-B06 as\n     approved by WG1364 on 6/28/1998. */\n\nparameter_value_opt\n  : '#' '(' expression_list_with_nuls ')'\n      { struct parmvalue_t*tmp = new struct parmvalue_t;\n\ttmp->by_order = $3;\n\ttmp->by_name = 0;\n\t$$ = tmp;\n      }\n  | '#' '(' parameter_value_byname_list ')'\n      { struct parmvalue_t*tmp = new struct parmvalue_t;\n\ttmp->by_order = 0;\n\ttmp->by_name = $3;\n\t$$ = tmp;\n      }\n  | '#' DEC_NUMBER\n      { assert($2);\n\tPENumber*tmp = new PENumber($2);\n\tFILE_NAME(tmp, @1);\n\n\tstruct parmvalue_t*lst = new struct parmvalue_t;\n\tlst->by_order = new std::list<PExpr*>;\n\tlst->by_order->push_back(tmp);\n\tlst->by_name = 0;\n\t$$ = lst;\n\tbased_size = 0;\n      }\n  | '#' REALTIME\n      { assert($2);\n\tPEFNumber*tmp = new PEFNumber($2);\n\tFILE_NAME(tmp, @1);\n\n\tstruct parmvalue_t*lst = new struct parmvalue_t;\n\tlst->by_order = new std::list<PExpr*>;\n\tlst->by_order->push_back(tmp);\n\tlst->by_name = 0;\n\t$$ = lst;\n      }\n  | '#' error\n      { yyerror(@1, \"error: Syntax error in parameter value assignment list.\");\n\t$$ = 0;\n      }\n  |\n      { $$ = 0; }\n  ;\n\nnamed_expression\n  : '.' IDENTIFIER '(' expression ')'\n      { named_pexpr_t*tmp = new named_pexpr_t;\n\tFILE_NAME(tmp, @$);\n\ttmp->name = lex_strings.make($2);\n\ttmp->parm = $4;\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n\nnamed_expression_opt\n  : named_expression\n  | '.' IDENTIFIER '(' ')'\n      { named_pexpr_t*tmp = new named_pexpr_t;\n\tFILE_NAME(tmp, @$);\n\ttmp->name = lex_strings.make($2);\n\ttmp->parm = 0;\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n  ;\n\nparameter_value_byname_list\n  : named_expression_opt\n      { std::list<named_pexpr_t>*tmp = new std::list<named_pexpr_t>;\n\ttmp->push_back(*$1);\n\tdelete $1;\n\t$$ = tmp;\n      }\n  | parameter_value_byname_list ',' named_expression_opt\n      { std::list<named_pexpr_t>*tmp = $1;\n\ttmp->push_back(*$3);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  ;\n\n\n  /* The port (of a module) is a fairly complex item. Each port is\n     handled as a Module::port_t object. A simple port reference has a\n     name and a PExpr object, but more complex constructs are possible\n     where the name can be attached to a list of PWire objects.\n\n     The port_reference returns a Module::port_t, and so does the\n     port_reference_list. The port_reference_list may have built up a\n     list of PWires in the port_t object, but it is still a single\n     Module::port_t object.\n\n     The port rule below takes the built up Module::port_t object and\n     tweaks its name as needed. */\n\nport\n  : port_reference\n      { $$ = $1; }\n\n  /* This syntax attaches an external name to the port reference so\n     that the caller can bind by name to non-trivial port\n     references. The port_t object gets its PWire from the\n     port_reference, but its name from the IDENTIFIER. */\n\n  | '.' IDENTIFIER '(' port_reference ')'\n      { Module::port_t*tmp = $4;\n\ttmp->name = lex_strings.make($2);\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n\n  /* A port can also be a concatenation of port references. In this\n     case the port does not have a name available to the outside, only\n     positional parameter passing is possible here. */\n\n  | '{' port_reference_list '}'\n      { Module::port_t*tmp = $2;\n\ttmp->name = perm_string();\n\t$$ = tmp;\n      }\n\n  /* This attaches a name to a port reference concatenation list so\n     that parameter passing be name is possible. */\n\n  | '.' IDENTIFIER '(' '{' port_reference_list '}' ')'\n      { Module::port_t*tmp = $5;\n\ttmp->name = lex_strings.make($2);\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n  ;\n\nport_opt\n  : port { $$ = $1; }\n  |      { $$ = 0; }\n  ;\n\n  /* The port_name rule is used with a module is being *instantiated*,\n     and not when it is being declared. See the port rule if you are\n     looking for the ports of a module declaration. */\n\nport_name\n  : attribute_list_opt named_expression_opt\n      { delete $1;\n\t$$ = $2;\n      }\n  | attribute_list_opt '.' IDENTIFIER '(' error ')'\n      { yyerror(@3, \"error: Invalid port connection expression.\");\n\tnamed_pexpr_t*tmp = new named_pexpr_t;\n\tFILE_NAME(tmp, @$);\n\ttmp->name = lex_strings.make($3);\n\ttmp->parm = 0;\n\tdelete[]$3;\n\tdelete $1;\n\t$$ = tmp;\n      }\n  | attribute_list_opt '.' IDENTIFIER\n      { pform_requires_sv(@3, \"Implicit named port connections\");\n\tnamed_pexpr_t*tmp = new named_pexpr_t;\n\tFILE_NAME(tmp, @$);\n\ttmp->name = lex_strings.make($3);\n\ttmp->parm = new PEIdent(lex_strings.make($3), @3.lexical_pos, true);\n\tFILE_NAME(tmp->parm, @3);\n\tdelete[]$3;\n\tdelete $1;\n\t$$ = tmp;\n      }\n  | K_DOTSTAR\n      { named_pexpr_t*tmp = new named_pexpr_t;\n\tFILE_NAME(tmp, @$);\n\ttmp->name = lex_strings.make(\"*\");\n\ttmp->parm = 0;\n\t$$ = tmp;\n      }\n  ;\n\nport_name_list\n  : port_name_list ',' port_name\n      { std::list<named_pexpr_t>*tmp = $1;\n        tmp->push_back(*$3);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  | port_name\n      { std::list<named_pexpr_t>*tmp = new std::list<named_pexpr_t>;\n        tmp->push_back(*$1);\n\tdelete $1;\n\t$$ = tmp;\n      }\n  ;\n\nport_conn_expression_list_with_nuls\n  : port_conn_expression_list_with_nuls ',' attribute_list_opt expression\n      { std::list<PExpr*>*tmp = $1;\n\ttmp->push_back($4);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  | attribute_list_opt expression\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($2);\n\tdelete $1;\n\t$$ = tmp;\n      }\n  |\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n        tmp->push_back(0);\n\t$$ = tmp;\n      }\n  | port_conn_expression_list_with_nuls ','\n      { std::list<PExpr*>*tmp = $1;\n\ttmp->push_back(0);\n\t$$ = tmp;\n      }\n  ;\n\n  /* A port reference is an internal (to the module) name of the port,\n     possibly with a part of bit select to attach it to specific bits\n     of a signal fully declared inside the module.\n\n     The parser creates a PEIdent for every port reference, even if the\n     signal is bound to different ports. The elaboration figures out\n     the mess that this creates. The port_reference (and the\n     port_reference_list below) puts the port reference PEIdent into the\n     port_t object to pass it up to the module declaration code. */\n\nport_reference\n  : IDENTIFIER\n      { Module::port_t*ptmp;\n\tperm_string name = lex_strings.make($1);\n\tptmp = pform_module_port_reference(@1, name);\n\tdelete[]$1;\n\t$$ = ptmp;\n      }\n  | IDENTIFIER '[' expression ':' expression ']'\n      { index_component_t itmp;\n\titmp.sel = index_component_t::SEL_PART;\n\titmp.msb = $3;\n\titmp.lsb = $5;\n\n\tname_component_t ntmp (lex_strings.make($1));\n\tntmp.index.push_back(itmp);\n\n\tpform_name_t pname;\n\tpname.push_back(ntmp);\n\n\tPEIdent*wtmp = new PEIdent(pname, @1.lexical_pos);\n\tFILE_NAME(wtmp, @1);\n\n\tModule::port_t*ptmp = new Module::port_t;\n\tptmp->name = perm_string();\n\tptmp->expr.push_back(wtmp);\n\tptmp->default_value = 0;\n\n\tdelete[]$1;\n\t$$ = ptmp;\n      }\n  | IDENTIFIER '[' expression ']'\n      { index_component_t itmp;\n\titmp.sel = index_component_t::SEL_BIT;\n\titmp.msb = $3;\n\titmp.lsb = 0;\n\n\tname_component_t ntmp (lex_strings.make($1));\n\tntmp.index.push_back(itmp);\n\n\tpform_name_t pname;\n\tpname.push_back(ntmp);\n\n\tPEIdent*tmp = new PEIdent(pname, @1.lexical_pos);\n\tFILE_NAME(tmp, @1);\n\n\tModule::port_t*ptmp = new Module::port_t;\n\tptmp->name = perm_string();\n\tptmp->expr.push_back(tmp);\n\tptmp->default_value = 0;\n\tdelete[]$1;\n\t$$ = ptmp;\n      }\n  | IDENTIFIER '[' error ']'\n      { yyerror(@1, \"error: Invalid port bit select\");\n\tModule::port_t*ptmp = new Module::port_t;\n\tPEIdent*wtmp = new PEIdent(lex_strings.make($1), @1.lexical_pos);\n\tFILE_NAME(wtmp, @1);\n\tptmp->name = lex_strings.make($1);\n\tptmp->expr.push_back(wtmp);\n\tptmp->default_value = 0;\n\tdelete[]$1;\n\t$$ = ptmp;\n      }\n  ;\n\n\nport_reference_list\n  : port_reference\n      { $$ = $1; }\n  | port_reference_list ',' port_reference\n      { Module::port_t*tmp = $1;\n\tappend(tmp->expr, $3->expr);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  ;\n\n  /* The range is a list of variable dimensions. */\ndimensions_opt\n  :            { $$ = 0; }\n  | dimensions { $$ = $1; }\n  ;\n\ndimensions\n  : variable_dimension\n      { $$ = $1; }\n  | dimensions variable_dimension\n      { std::list<pform_range_t> *tmp = $1;\n\tif ($2) {\n\t      tmp->splice(tmp->end(), *$2);\n\t      delete $2;\n\t}\n\t$$ = tmp;\n      }\n  ;\n\nnet_variable\n  : IDENTIFIER dimensions_opt\n      { pform_ident_t name = { lex_strings.make($1), @1.lexical_pos };\n\t$$ = pform_makewire(@1, name, NetNet::IMPLICIT, $2);\n\tdelete [] $1;\n      }\n  ;\n\nnet_variable_list\n  : net_variable\n      { std::vector<PWire*> *tmp = new std::vector<PWire*>;\n\ttmp->push_back($1);\n\t$$ = tmp;\n      }\n  | net_variable_list ',' net_variable\n      { $1->push_back($3);\n\t$$ = $1;\n      }\n  ;\n\nevent_variable\n  : IDENTIFIER dimensions_opt\n      { if ($2) {\n\t      yyerror(@2, \"sorry: event arrays are not supported.\");\n\t      delete $2;\n\t}\n\t$$ = $1;\n      }\n  ;\n\nevent_variable_list\n  : event_variable\n      { $$ = list_from_identifier($1, @1.lexical_pos); }\n  | event_variable_list ',' event_variable\n      { $$ = list_from_identifier($1, $3, @3.lexical_pos); }\n  ;\n\nspecify_item\n  : K_specparam specparam_decl ';'\n  | specify_simple_path_decl ';'\n      { pform_module_specify_path($1); }\n  | specify_edge_path_decl ';'\n      { pform_module_specify_path($1); }\n  | K_if '(' expression ')' specify_simple_path_decl ';'\n      { PSpecPath*tmp = $5;\n\tif (tmp) {\n\t      tmp->conditional = true;\n\t      tmp->condition = $3;\n\t}\n\tpform_module_specify_path(tmp);\n      }\n  | K_if '(' expression ')' specify_edge_path_decl ';'\n      { PSpecPath*tmp = $5;\n\tif (tmp) {\n\t      tmp->conditional = true;\n\t      tmp->condition = $3;\n\t}\n\tpform_module_specify_path(tmp);\n      }\n  | K_ifnone specify_simple_path_decl ';'\n      { PSpecPath*tmp = $2;\n\tif (tmp) {\n\t      tmp->conditional = true;\n\t      tmp->condition = 0;\n\t}\n\tpform_module_specify_path(tmp);\n      }\n  | K_ifnone specify_edge_path_decl ';'\n      { yywarn(@1, \"sorry: ifnone with an edge-sensitive path is not supported.\");\n\tyyerrok;\n      }\n  | K_Sfullskew '(' spec_reference_event ',' spec_reference_event\n    ',' delay_value ',' delay_value fullskew_opt_args ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\tdelete $9; // delay_value\n\n\tdelete $10->notifier;\n\tdelete $10->event_based_flag;\n\tdelete $10->remain_active_flag;\n\n\tdelete $10; // fullskew_opt_args\n      }\n  | K_Shold '(' spec_reference_event ',' spec_reference_event\n    ',' delay_value spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\tdelete $8; // spec_notifier_opt\n      }\n  | K_Snochange '(' spec_reference_event ',' spec_reference_event\n\t  ',' delay_value ',' delay_value spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\tdelete $9; // delay_value\n\tdelete $10; // spec_notifier_opt\n      }\n  | K_Speriod '(' spec_reference_event ',' delay_value\n    spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // delay_value\n\tdelete $6; // spec_notifier_opt\n      }\n  | K_Srecovery '(' spec_reference_event ',' spec_reference_event\n    ',' delay_value spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\tdelete $8; // spec_notifier_opt\n      }\n  | K_Srecrem '(' spec_reference_event ',' spec_reference_event\n    ',' expr_mintypmax ',' expr_mintypmax recrem_opt_args ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported. \";\n\tif ($10->delayed_reference != nullptr || $10->delayed_data != nullptr)\n\t{\n\t\tcerr << \"Delayed reference and data signals become copies of the\"\n\t\t<< \" original reference and data signals.\" << endl;\n\t}\n\telse\n\t{\n\t\tcerr << endl;\n\t}\n\n\tPRecRem*recrem = pform_make_recrem(@1, $3, $5, $7, $9, $10);\n\tpform_module_timing_check(recrem);\n\n\tdelete $10; // setuphold_recrem_opt_notifier\n      }\n  | K_Sremoval '(' spec_reference_event ',' spec_reference_event\n    ',' delay_value spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\tdelete $8; // spec_notifier_opt\n      }\n  | K_Ssetup '(' spec_reference_event ',' spec_reference_event\n    ',' delay_value spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\tdelete $8; // spec_notifier_opt\n      }\n  | K_Ssetuphold '(' spec_reference_event ',' spec_reference_event\n    ',' expr_mintypmax ',' expr_mintypmax setuphold_opt_args ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported. \";\n\tif ($10->delayed_reference != nullptr || $10->delayed_data != nullptr)\n\t{\n\t\tcerr << \"Delayed reference and data signals become copies of the\"\n\t\t<< \" original reference and data signals.\" << endl;\n\t}\n\telse\n\t{\n\t\tcerr << endl;\n\t}\n\n\tPSetupHold*setuphold = pform_make_setuphold(@1, $3, $5, $7, $9, $10);\n\tpform_module_timing_check(setuphold);\n\n\tdelete $10; // setuphold_recrem_opt_notifier\n      }\n  | K_Sskew '(' spec_reference_event ',' spec_reference_event\n    ',' delay_value spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\tdelete $8; // spec_notifier_opt\n      }\n  | K_Stimeskew '(' spec_reference_event ',' spec_reference_event\n    ',' delay_value timeskew_opt_args ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // spec_reference_event\n\tdelete $7; // delay_value\n\n\tdelete $8->notifier;\n\tdelete $8->event_based_flag;\n\tdelete $8->remain_active_flag;\n\n\tdelete $8; // timeskew_opt_args\n      }\n  | K_Swidth '(' spec_reference_event ',' delay_value ',' expression\n    spec_notifier_opt ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // delay_value\n\tdelete $7; // expression\n\tdelete $8;\n      }\n  | K_Swidth '(' spec_reference_event ',' delay_value ')' ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $3; // spec_reference_event\n\tdelete $5; // delay_value\n      }\n  | K_pulsestyle_onevent specify_path_identifiers ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $2; // specify_path_identifiers\n      }\n  | K_pulsestyle_ondetect specify_path_identifiers ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $2; // specify_path_identifiers\n      }\n  | K_showcancelled specify_path_identifiers ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $2; // specify_path_identifiers\n      }\n  | K_noshowcancelled specify_path_identifiers ';'\n      {\n\tcerr << @3 << \": warning: Timing checks are not supported.\" << endl;\n\tdelete $2; // specify_path_identifiers\n      }\n  ;\n\nspecify_item_list\n  : specify_item\n  | specify_item_list specify_item\n  ;\n\nspecify_item_list_opt\n  : /* empty */\n      {  }\n  | specify_item_list\n      {  }\n\nspecify_edge_path_decl\n  : specify_edge_path '=' '(' delay_value_list ')'\n      { $$ = pform_assign_path_delay($1, $4); }\n  | specify_edge_path '=' delay_value_simple\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($3);\n\t$$ = pform_assign_path_delay($1, tmp);\n      }\n  ;\n\nedge_operator\n  : K_posedge { $$ = true; }\n  | K_negedge { $$ = false; }\n  ;\n\nspecify_edge_path\n  : '('               specify_path_identifiers spec_polarity\n    K_EG '(' specify_path_identifiers polarity_operator expression ')' ')'\n      { int edge_flag = 0;\n\t$$ = pform_make_specify_edge_path(@1, edge_flag, $2, $3, false, $6, $8);\n      }\n  | '(' edge_operator specify_path_identifiers spec_polarity\n    K_EG '(' specify_path_identifiers polarity_operator expression ')' ')'\n      { int edge_flag = $2? 1 : -1;\n\t$$ = pform_make_specify_edge_path(@1, edge_flag, $3, $4, false, $7, $9);\n      }\n  | '('               specify_path_identifiers spec_polarity\n    K_SG  '(' specify_path_identifiers polarity_operator expression ')' ')'\n      { int edge_flag = 0;\n\t$$ = pform_make_specify_edge_path(@1, edge_flag, $2, $3, true, $6, $8);\n      }\n  | '(' edge_operator specify_path_identifiers spec_polarity\n    K_SG '(' specify_path_identifiers polarity_operator expression ')' ')'\n      { int edge_flag = $2? 1 : -1;\n\t$$ = pform_make_specify_edge_path(@1, edge_flag, $3, $4, true, $7, $9);\n      }\n  ;\n\npolarity_operator\n  : K_PO_POS\n  | K_PO_NEG\n  | ':'\n  ;\n\nspecify_simple_path_decl\n  : specify_simple_path '=' '(' delay_value_list ')'\n      { $$ = pform_assign_path_delay($1, $4); }\n  | specify_simple_path '=' delay_value_simple\n      { std::list<PExpr*>*tmp = new std::list<PExpr*>;\n\ttmp->push_back($3);\n\t$$ = pform_assign_path_delay($1, tmp);\n      }\n  | specify_simple_path '=' '(' error ')'\n      { yyerror(@3, \"Syntax error in delay value list.\");\n\tyyerrok;\n\t$$ = 0;\n      }\n  ;\n\nspecify_simple_path\n  : '(' specify_path_identifiers spec_polarity K_EG specify_path_identifiers ')'\n      { $$ = pform_make_specify_path(@1, $2, $3, false, $5); }\n  | '(' specify_path_identifiers spec_polarity K_SG specify_path_identifiers ')'\n      { $$ = pform_make_specify_path(@1, $2, $3, true, $5); }\n  | '(' error ')'\n      { yyerror(@1, \"Invalid simple path\");\n\tyyerrok;\n      }\n  ;\n\nspecify_path_identifiers\n  : IDENTIFIER\n      { std::list<perm_string>*tmp = new std::list<perm_string>;\n\ttmp->push_back(lex_strings.make($1));\n\t$$ = tmp;\n\tdelete[]$1;\n      }\n  | IDENTIFIER '[' expr_primary ']'\n      { if (gn_specify_blocks_flag) {\n\t      yywarn(@4, \"warning: Bit selects are not currently supported \"\n\t\t\t \"in path declarations. The declaration \"\n\t\t\t \"will be applied to the whole vector.\");\n\t}\n\tstd::list<perm_string>*tmp = new std::list<perm_string>;\n\ttmp->push_back(lex_strings.make($1));\n\t$$ = tmp;\n\tdelete[]$1;\n      }\n  | IDENTIFIER '[' expr_primary polarity_operator expr_primary ']'\n      { if (gn_specify_blocks_flag) {\n\t      yywarn(@4, \"warning: Part selects are not currently supported \"\n\t\t\t \"in path declarations. The declaration \"\n\t\t\t \"will be applied to the whole vector.\");\n\t}\n\tstd::list<perm_string>*tmp = new std::list<perm_string>;\n\ttmp->push_back(lex_strings.make($1));\n\t$$ = tmp;\n\tdelete[]$1;\n      }\n  | specify_path_identifiers ',' IDENTIFIER\n      { std::list<perm_string>*tmp = $1;\n\ttmp->push_back(lex_strings.make($3));\n\t$$ = tmp;\n\tdelete[]$3;\n      }\n  | specify_path_identifiers ',' IDENTIFIER '[' expr_primary ']'\n      { if (gn_specify_blocks_flag) {\n\t      yywarn(@4, \"warning: Bit selects are not currently supported \"\n\t\t\t \"in path declarations. The declaration \"\n\t\t\t \"will be applied to the whole vector.\");\n\t}\n\tstd::list<perm_string>*tmp = $1;\n\ttmp->push_back(lex_strings.make($3));\n\t$$ = tmp;\n\tdelete[]$3;\n      }\n  | specify_path_identifiers ',' IDENTIFIER '[' expr_primary polarity_operator expr_primary ']'\n      { if (gn_specify_blocks_flag) {\n\t      yywarn(@4, \"warning: Part selects are not currently supported \"\n\t\t\t \"in path declarations. The declaration \"\n\t\t\t \"will be applied to the whole vector.\");\n\t}\n\tstd::list<perm_string>*tmp = $1;\n\ttmp->push_back(lex_strings.make($3));\n\t$$ = tmp;\n\tdelete[]$3;\n      }\n  ;\n\nspecparam\n  : IDENTIFIER '=' expr_mintypmax\n      { pform_set_specparam(@1, lex_strings.make($1), specparam_active_range, $3);\n\tdelete[]$1;\n      }\n  | PATHPULSE_IDENTIFIER '=' expression\n      { delete[]$1;\n\tdelete $3;\n      }\n  | PATHPULSE_IDENTIFIER '=' '(' expression ',' expression ')'\n      { delete[]$1;\n\tdelete $4;\n\tdelete $6;\n      }\n  ;\n\nspecparam_list\n  : specparam\n  | specparam_list ',' specparam\n  ;\n\nspecparam_decl\n  : specparam_list\n  | dimensions\n      { specparam_active_range = $1; }\n    specparam_list\n      { specparam_active_range = 0; }\n  ;\n\nspec_polarity\n  : '+'  { $$ = '+'; }\n  | '-'  { $$ = '-'; }\n  |      { $$ = 0;   }\n  ;\n\n// TODO spec_controlled_reference_event\nspec_reference_event\n  : hierarchy_identifier\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$1;\n\tevent->posedge = false;\n\tevent->negedge = false;\n\tevent->condition = nullptr;\n\tdelete $1;\n\t$$ = event;\n      }\n  | hierarchy_identifier K_TAND expression\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$1;\n\tevent->posedge = false;\n\tevent->negedge = false;\n\tevent->condition = std::unique_ptr<PExpr>($3);\n\tdelete $1;\n\t$$ = event;\n      }\n  | K_posedge hierarchy_identifier\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$2;\n\tevent->posedge = true;\n\tevent->negedge = false;\n\tevent->condition = nullptr;\n\tdelete $2;\n\t$$ = event;\n      }\n  | K_negedge hierarchy_identifier\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$2;\n\tevent->posedge = false;\n\tevent->negedge = true;\n\tevent->condition = nullptr;\n\tdelete $2;\n\t$$ = event;\n      }\n  | K_posedge hierarchy_identifier K_TAND expression\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$2;\n\tevent->posedge = true;\n\tevent->negedge = false;\n\tevent->condition = std::unique_ptr<PExpr>($4);\n\tdelete $2;\n\t$$ = event;\n      }\n  | K_negedge hierarchy_identifier K_TAND expression\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$2;\n\tevent->posedge = false;\n\tevent->negedge = true;\n\tevent->condition = std::unique_ptr<PExpr>($4);\n\tdelete $2;\n\t$$ = event;\n      }\n  | K_edge '[' edge_descriptor_list ']' hierarchy_identifier\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$5;\n\tevent->posedge = false;\n\tevent->negedge = false;\n\t// TODO add edge descriptors\n\tevent->condition = nullptr;\n\tdelete $5;\n\t$$ = event;\n      }\n  | K_edge '[' edge_descriptor_list ']' hierarchy_identifier K_TAND expression\n      { PTimingCheck::event_t* event = new PTimingCheck::event_t;\n\tevent->name = *$5;\n\tevent->posedge = false;\n\tevent->negedge = false;\n\t// TODO add edge descriptors\n\tevent->condition = std::unique_ptr<PExpr>($7);\n\tdelete $5;\n\t$$ = event;\n      }\n  ;\n\n  /* The edge_descriptor is detected by the lexor as the various\n     2-letter edge sequences that are supported here. For now, we\n     don't care what they are, because we do not yet support specify\n     edge events. */\nedge_descriptor_list\n  : edge_descriptor_list ',' K_edge_descriptor\n  | K_edge_descriptor\n  ;\n\nsetuphold_opt_args\n  : setuphold_recrem_opt_notifier\n    { $$ = $1; }\n  |\n    { $$ = new PTimingCheck::optional_args_t; }\n  ;\n\nrecrem_opt_args\n  : setuphold_recrem_opt_notifier\n    { $$ = $1; }\n  |\n    { $$ = new PTimingCheck::optional_args_t; }\n  ;\n\n  /* The following rules are used for the optional arguments\n     in $recrem and $setuphold */\nsetuphold_recrem_opt_notifier\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' hierarchy_identifier // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->notifier = $2;\n        $$ = args;\n      }\n  | ',' setuphold_recrem_opt_timestamp_cond // Empty\n      { $$ = $2; }\n  | ',' hierarchy_identifier setuphold_recrem_opt_timestamp_cond\n        {\n          $$ = $3;\n          $$->notifier = $2;\n        }\n  ;\n\nsetuphold_recrem_opt_timestamp_cond\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' expression // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->timestamp_cond = $2;\n        $$ = args;\n      }\n  | ',' setuphold_recrem_opt_timecheck_cond // Empty\n      { $$ = $2; }\n  | ',' expression setuphold_recrem_opt_timecheck_cond\n        {\n          $$ = $3;\n          $$->timestamp_cond = $2;\n        }\n  ;\n\nsetuphold_recrem_opt_timecheck_cond\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' expression // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->timecheck_cond = $2;\n        $$ = args;\n      }\n  | ',' setuphold_recrem_opt_delayed_reference // Empty\n      { $$ = $2; }\n  | ',' expression setuphold_recrem_opt_delayed_reference\n        {\n          $$ = $3;\n          $$->timecheck_cond = $2;\n        }\n  ;\n\nsetuphold_recrem_opt_delayed_reference\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' hierarchy_identifier // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->delayed_reference = $2;\n        $$ = args;\n      }\n  | ',' setuphold_recrem_opt_delayed_data // Empty\n      { $$ = $2; }\n  | ',' hierarchy_identifier setuphold_recrem_opt_delayed_data\n        {\n          $$ = $3;\n          $$->delayed_reference = $2;\n        }\n  ;\n\nsetuphold_recrem_opt_delayed_data\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' hierarchy_identifier // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->delayed_data = $2;\n        $$ = args;\n      }\n  ;\n\ntimeskew_opt_args\n  : timeskew_fullskew_opt_notifier\n    { $$ = $1; }\n  |\n    { $$ = new PTimingCheck::optional_args_t; }\n  ;\n\nfullskew_opt_args\n  : timeskew_fullskew_opt_notifier\n    { $$ = $1; }\n  |\n    { $$ = new PTimingCheck::optional_args_t; }\n  ;\n\n  /* The following rules are used for the optional arguments\n     in $timeskew and $fullskew */\ntimeskew_fullskew_opt_notifier\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' hierarchy_identifier // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->notifier = $2;\n        $$ = args;\n      }\n  | ',' timeskew_fullskew_opt_event_based_flag // Empty\n      { $$ = $2; }\n  | ',' hierarchy_identifier timeskew_fullskew_opt_event_based_flag\n        {\n          $$ = $3;\n          $$->notifier = $2;\n        }\n  ;\n\ntimeskew_fullskew_opt_event_based_flag\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' expression // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->event_based_flag = $2;\n        $$ = args;\n      }\n  | ',' timeskew_fullskew_opt_remain_active_flag // Empty\n      { $$ = $2; }\n  | ',' expression timeskew_fullskew_opt_remain_active_flag\n        {\n          $$ = $3;\n          $$->event_based_flag = $2;\n        }\n  ;\n\ntimeskew_fullskew_opt_remain_active_flag\n  : ',' // Empty and end of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        $$ = args;\n      }\n  | ',' expression // End of list\n      {\n        PTimingCheck::optional_args_t* args = new PTimingCheck::optional_args_t;\n        args->remain_active_flag = $2;\n        $$ = args;\n      }\n  ;\n\nspec_notifier_opt\n  : /* empty */\n      { $$ = nullptr; }\n  | spec_notifier\n      { $$ = $1; }\n  ;\n\nspec_notifier\n  : ','\n      { $$ = nullptr; }\n  | ','  hierarchy_identifier\n      { $$ = $2; }\n  ;\n\nsubroutine_call\n  : hierarchy_identifier argument_list_parens_opt\n      { PCallTask*tmp = pform_make_call_task(@1, *$1, *$2);\n\tdelete $1;\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | class_hierarchy_identifier argument_list_parens_opt\n      { PCallTask*tmp = new PCallTask(*$1, *$2);\n\tFILE_NAME(tmp, @1);\n\tdelete $1;\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | SYSTEM_IDENTIFIER argument_list_parens_opt\n      { PCallTask*tmp = new PCallTask(lex_strings.make($1), *$2);\n\tFILE_NAME(tmp,@1);\n\tdelete[]$1;\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | hierarchy_identifier '(' error ')'\n      { yyerror(@3, \"error: Syntax error in task arguments.\");\n\tstd::list<named_pexpr_t> pt;\n\tPCallTask*tmp = pform_make_call_task(@1, *$1, pt);\n\tdelete $1;\n\t$$ = tmp;\n      }\n  ;\n\nstatement_item /* This is roughly statement_item in the LRM */\n\n  /* assign and deassign statements are procedural code to do\n     structural assignments, and to turn that structural assignment\n     off. This is stronger than any other assign, but weaker than the\n     force assignments. */\n\n  : K_assign lpvalue '=' expression ';'\n      { PCAssign*tmp = new PCAssign($2, $4);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  | K_deassign lpvalue ';'\n      { PDeassign*tmp = new PDeassign($2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n\n  /* Force and release statements are similar to assignments,\n     syntactically, but they will be elaborated differently. */\n\n  | K_force lpvalue '=' expression ';'\n      { PForce*tmp = new PForce($2, $4);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_release lpvalue ';'\n      { PRelease*tmp = new PRelease($2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  /* begin-end blocks come in a variety of forms, including named and\n     anonymous. The named blocks can also carry their own reg\n     variables, which are placed in the scope created by the block\n     name. These are handled by pushing the scope name, then matching\n     the declarations. The scope is popped at the end of the block. */\n\n  /* In SystemVerilog an unnamed block can contain variable declarations. */\n  | K_begin label_opt\n      { PBlock*tmp = pform_push_block_scope(@1, $2, PBlock::BL_SEQ);\n\tcurrent_block_stack.push(tmp);\n      }\n    block_item_decls_opt\n      {\n        if (!$2) {\n\t      if ($4) {\n\t\t    pform_block_decls_requires_sv();\n\t      } else {\n\t\t    /* If there are no declarations in the scope then just delete it. */\n\t\t    pform_pop_scope();\n\t\t    assert(! current_block_stack.empty());\n\t\t    PBlock*tmp = current_block_stack.top();\n\t\t    current_block_stack.pop();\n\t\t    delete tmp;\n\t      }\n\t}\n      }\n    statement_or_null_list_opt K_end label_opt\n      { PBlock*tmp;\n\tif ($2 || $4) {\n\t      pform_pop_scope();\n\t      assert(! current_block_stack.empty());\n\t      tmp = current_block_stack.top();\n\t      current_block_stack.pop();\n\t} else {\n\t      tmp = new PBlock(PBlock::BL_SEQ);\n\t      FILE_NAME(tmp, @1);\n\t}\n\tif ($6) tmp->set_statement(*$6);\n\tdelete $6;\n\tcheck_end_label(@8, \"block\", $2, $8);\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n\n  /* fork-join blocks are very similar to begin-end blocks. In fact,\n     from the parser's perspective there is no real difference. All we\n     need to do is remember that this is a parallel block so that the\n     code generator can do the right thing. */\n\n  /* In SystemVerilog an unnamed block can contain variable declarations. */\n  | K_fork label_opt\n      { PBlock*tmp = pform_push_block_scope(@1, $2, PBlock::BL_PAR);\n\tcurrent_block_stack.push(tmp);\n      }\n    block_item_decls_opt\n      {\n        if (!$2) {\n\t      if ($4) {\n\t\t    pform_requires_sv(@4, \"Variable declaration in unnamed block\");\n\t      } else {\n\t\t    /* If there are no declarations in the scope then just delete it. */\n\t\t    pform_pop_scope();\n\t\t    assert(! current_block_stack.empty());\n\t\t    PBlock*tmp = current_block_stack.top();\n\t\t    current_block_stack.pop();\n\t\t    delete tmp;\n\t      }\n\t}\n      }\n    statement_or_null_list_opt join_keyword label_opt\n      { PBlock*tmp;\n\tif ($2 || $4) {\n\t      pform_pop_scope();\n\t      assert(! current_block_stack.empty());\n\t      tmp = current_block_stack.top();\n\t      current_block_stack.pop();\n\t      tmp->set_join_type($7);\n\t} else {\n\t      tmp = new PBlock($7);\n\t      FILE_NAME(tmp, @1);\n\t}\n\tif ($6) tmp->set_statement(*$6);\n\tdelete $6;\n\tcheck_end_label(@8, \"fork\", $2, $8);\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n\n  | K_disable hierarchy_identifier ';'\n      { PDisable*tmp = new PDisable(*$2);\n\tFILE_NAME(tmp, @1);\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | K_disable K_fork ';'\n      { pform_name_t tmp_name;\n\tPDisable*tmp = new PDisable(tmp_name);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_TRIGGER hierarchy_identifier ';'\n      { PTrigger*tmp = pform_new_trigger(@2, 0, *$2, @2.lexical_pos);\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | K_TRIGGER package_scope hierarchy_identifier\n      { lex_in_package_scope(0);\n\tPTrigger*tmp = pform_new_trigger(@3, $2, *$3, @3.lexical_pos);\n\tdelete $3;\n\t$$ = tmp;\n      }\n    /* FIXME: Does this need support for package resolution like above? */\n  | K_NB_TRIGGER hierarchy_identifier ';'\n      { PNBTrigger*tmp = pform_new_nb_trigger(@2, 0, *$2, @2.lexical_pos);\n\tdelete $2;\n\t$$ = tmp;\n      }\n  | K_NB_TRIGGER delay1 hierarchy_identifier ';'\n      { PNBTrigger*tmp = pform_new_nb_trigger(@3, $2, *$3, @3.lexical_pos);\n\tdelete $3;\n\t$$ = tmp;\n      }\n  | K_NB_TRIGGER event_control hierarchy_identifier ';'\n      { PNBTrigger*tmp = pform_new_nb_trigger(@3, 0, *$3, @3.lexical_pos);\n\tdelete $3;\n\t$$ = tmp;\n        yywarn(@1, \"sorry: ->> with event control is not currently supported.\");\n      }\n  | K_NB_TRIGGER K_repeat '(' expression ')' event_control hierarchy_identifier ';'\n      { PNBTrigger*tmp = pform_new_nb_trigger(@7, 0, *$7, @7.lexical_pos);\n\tdelete $7;\n\t$$ = tmp;\n        yywarn(@1, \"sorry: ->> with repeat event control is not currently supported.\");\n      }\n\n  | procedural_assertion_statement\n      { $$ = $1; }\n\n  | loop_statement\n      { $$ = $1; }\n\n  | jump_statement\n      { $$ = $1; }\n\n  | unique_priority K_case '(' expression ')' case_items K_endcase\n      { PCase*tmp = new PCase($1, NetCase::EQ, $4, $6);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | unique_priority K_casex '(' expression ')' case_items K_endcase\n      { PCase*tmp = new PCase($1, NetCase::EQX, $4, $6);\n\tFILE_NAME(tmp, @2);\n\t$$ = tmp;\n      }\n  | unique_priority K_casez '(' expression ')' case_items K_endcase\n      { PCase*tmp = new PCase($1, NetCase::EQZ, $4, $6);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | unique_priority K_case '(' expression ')' error K_endcase\n      { yyerrok; }\n  | unique_priority K_casex '(' expression ')' error K_endcase\n      { yyerrok; }\n  | unique_priority K_casez '(' expression ')' error K_endcase\n      { yyerrok; }\n\n  | K_if '(' expression ')' statement_or_null %prec less_than_K_else\n      { PCondit*tmp = new PCondit($3, $5, 0);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_if '(' expression ')' statement_or_null K_else statement_or_null\n      { PCondit*tmp = new PCondit($3, $5, $7);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | K_if '(' error ')' statement_or_null %prec less_than_K_else\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $5;\n      }\n  | K_if '(' error ')' statement_or_null K_else statement_or_null\n      { yyerror(@1, \"error: Malformed conditional expression.\");\n\t$$ = $5;\n      }\n  /* SystemVerilog adds the compressed_statement */\n\n  | compressed_statement ';'\n      { $$ = $1; }\n\n  /* increment/decrement expressions can also be statements. When used\n     as statements, we can rewrite a++ as a += 1, and so on. */\n\n  | inc_or_dec_expression ';'\n      { $$ = pform_compressed_assign_from_inc_dec(@1, $1); }\n\n  /* */\n\n  | delay1 statement_or_null\n      { PExpr*del = $1->front();\n\tassert($1->size() == 1);\n\tdelete $1;\n\tPDelayStatement*tmp = new PDelayStatement(del, $2);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  | event_control statement_or_null\n      { PEventStatement*tmp = $1;\n\tif (tmp == 0) {\n\t      yyerror(@1, \"error: Invalid event control.\");\n\t      $$ = 0;\n\t} else {\n\t      tmp->set_statement($2);\n\t      $$ = tmp;\n\t}\n      }\n  | '@' '*' statement_or_null\n      { PEventStatement*tmp = new PEventStatement;\n\tFILE_NAME(tmp, @1);\n\ttmp->set_statement($3);\n\t$$ = tmp;\n      }\n  | '@' '(' '*' ')' statement_or_null\n      { PEventStatement*tmp = new PEventStatement;\n\tFILE_NAME(tmp, @1);\n\ttmp->set_statement($5);\n\t$$ = tmp;\n      }\n\n  /* Various assignment statements */\n\n  | lpvalue '=' expression ';'\n      { PAssign*tmp = new PAssign($1,$3);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  | error '=' expression ';'\n      { yyerror(@2, \"Syntax in assignment statement l-value.\");\n\tyyerrok;\n\t$$ = new PNoop;\n      }\n  | lpvalue K_LE expression ';'\n      { PAssignNB*tmp = new PAssignNB($1,$3);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | error K_LE expression ';'\n      { yyerror(@2, \"Syntax in assignment statement l-value.\");\n\tyyerrok;\n\t$$ = new PNoop;\n      }\n  | lpvalue '=' delay1 expression ';'\n      { PExpr*del = $3->front(); $3->pop_front();\n\tassert($3->empty());\n\tPAssign*tmp = new PAssign($1,del,$4);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | lpvalue K_LE delay1 expression ';'\n      { PExpr*del = $3->front(); $3->pop_front();\n\tassert($3->empty());\n\tPAssignNB*tmp = new PAssignNB($1,del,$4);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | lpvalue '=' event_control expression ';'\n      { PAssign*tmp = new PAssign($1,0,$3,$4);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | lpvalue '=' K_repeat '(' expression ')' event_control expression ';'\n      { PAssign*tmp = new PAssign($1,$5,$7,$8);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n  | lpvalue K_LE event_control expression ';'\n      { PAssignNB*tmp = new PAssignNB($1,0,$3,$4);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n  | lpvalue K_LE K_repeat '(' expression ')' event_control expression ';'\n      { PAssignNB*tmp = new PAssignNB($1,$5,$7,$8);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  /* The IEEE1800 standard defines dynamic_array_new assignment as a\n     different rule from regular assignment. That implies that the\n     dynamic_array_new is not an expression in general, which makes\n     some sense. Elaboration should make sure the lpvalue is an array name. */\n\n  | lpvalue '=' dynamic_array_new ';'\n      { PAssign*tmp = new PAssign($1,$3);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  /* The class new and dynamic array new expressions are special, so\n     sit in rules of their own. */\n\n  | lpvalue '=' class_new ';'\n      { PAssign*tmp = new PAssign($1,$3);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n\n  | K_wait '(' expression ')' statement_or_null\n      { PEventStatement*tmp;\n\tPEEvent*etmp = new PEEvent(PEEvent::POSITIVE, $3);\n\ttmp = new PEventStatement(etmp);\n\tFILE_NAME(tmp,@1);\n\ttmp->set_statement($5);\n\t$$ = tmp;\n      }\n  | K_wait K_fork ';'\n      { PEventStatement*tmp = new PEventStatement((PEEvent*)0);\n\tFILE_NAME(tmp,@1);\n\t$$ = tmp;\n      }\n  | K_void '\\'' '(' subroutine_call ')' ';'\n      { $4->void_cast();\n\t$$ = $4;\n      }\n\n  | subroutine_call ';'\n      { $$ = $1;\n      }\n\n  | hierarchy_identifier K_with '{' constraint_block_item_list_opt '}' ';'\n      { /* ....randomize with { <constraints> } */\n\tif ($1 && peek_tail_name(*$1) == \"randomize\") {\n\t      if (pform_requires_sv(@2, \"Randomize with constraint\"))\n\t\t    yyerror(@2, \"sorry: Randomize with constraint not supported.\");\n\t} else {\n\t      yyerror(@2, \"error: Constraint block can only be applied to randomize method.\");\n\t}\n\tlist<named_pexpr_t> pt;\n\tPCallTask*tmp = new PCallTask(*$1, pt);\n\tFILE_NAME(tmp, @1);\n\tdelete $1;\n\t$$ = tmp;\n      }\n\n    /* IEEE1800 A.1.8: class_constructor_declaration with a call to\n       parent constructor. Note that the implicit_class_handle must\n       be K_super (\"this.new\" makes little sense) but that would\n       cause a conflict. Anyhow, this statement must be in the\n       beginning of a constructor, but let the elaborator figure that\n       out. */\n\n  | implicit_class_handle K_new argument_list_parens_opt ';'\n      { PChainConstructor*tmp = new PChainConstructor(*$3);\n\tFILE_NAME(tmp, @3);\n\tif (peek_head_name(*$1) == THIS_TOKEN) {\n\t      yyerror(@1, \"error: this.new is invalid syntax. Did you mean super.new?\");\n\t}\n\tdelete $1;\n\t$$ = tmp;\n      }\n  | error ';'\n      { yyerror(@2, \"error: Malformed statement\");\n\tyyerrok;\n\t$$ = new PNoop;\n      }\n\n  ;\n\ncompressed_operator\n  : K_PLUS_EQ  { $$ = '+'; }\n  | K_MINUS_EQ { $$ = '-'; }\n  | K_MUL_EQ   { $$ = '*'; }\n  | K_DIV_EQ   { $$ = '/'; }\n  | K_MOD_EQ   { $$ = '%'; }\n  | K_AND_EQ   { $$ = '&'; }\n  | K_OR_EQ    { $$ = '|'; }\n  | K_XOR_EQ   { $$ = '^'; }\n  | K_LS_EQ    { $$ = 'l'; }\n  | K_RS_EQ    { $$ = 'r'; }\n  | K_RSS_EQ   { $$ = 'R'; }\n  ;\n\ncompressed_statement\n  : lpvalue compressed_operator expression\n      { PAssign*tmp = new PAssign($1, $2, $3);\n\tFILE_NAME(tmp, @1);\n\t$$ = tmp;\n      }\n   ;\n\nstatement_or_null_list_opt\n  : statement_or_null_list\n      { $$ = $1; }\n  |\n      { $$ = 0; }\n  ;\n\nstatement_or_null_list\n  : statement_or_null_list statement_or_null\n      { std::vector<Statement*>*tmp = $1;\n\tif ($2) tmp->push_back($2);\n\t$$ = tmp;\n      }\n  | statement_or_null\n      { std::vector<Statement*>*tmp = new std::vector<Statement*>(0);\n\tif ($1) tmp->push_back($1);\n\t$$ = tmp;\n      }\n  ;\n\nanalog_statement\n  : branch_probe_expression K_CONTRIBUTE expression ';'\n      { $$ = pform_contribution_statement(@2, $1, $3); }\n  ;\n\ntf_port_list_opt\n  : tf_port_list { $$ = $1; }\n  |              { $$ = 0; }\n  ;\n\n  /* A task or function prototype can be declared with the task/function name\n   * followed by a port list in parenthesis or or just the task/function name by\n   * itself. When a port list is used it might be empty. */\ntf_port_list_parens_opt\n  : '(' tf_port_list_opt ')' { $$ = $2; }\n  |                          { $$ = 0; }\n\n  /* Note that the lexor notices the \"table\" keyword and starts\n     the UDPTABLE state. It needs to happen there so that all the\n     characters in the table are interpreted in that mode. It is still\n     up to this rule to take us out of the UDPTABLE state. */\nudp_body\n  : K_table udp_entry_list K_endtable\n      { lex_end_table();\n\t$$ = $2;\n      }\n  | K_table K_endtable\n      { lex_end_table();\n\tyyerror(@1, \"error: Empty UDP table.\");\n\t$$ = 0;\n      }\n  | K_table error K_endtable\n      { lex_end_table();\n\tyyerror(@2, \"errors in UDP table\");\n\tyyerrok;\n\t$$ = 0;\n      }\n  ;\n\nudp_entry_list\n  : udp_comb_entry_list\n  | udp_sequ_entry_list\n  ;\n\nudp_comb_entry\n  : udp_input_list ':' udp_output_sym ';'\n      { char*tmp = new char[strlen($1)+3];\n\tstrcpy(tmp, $1);\n\tchar*tp = tmp+strlen(tmp);\n\t*tp++ = ':';\n\t*tp++ = $3;\n\t*tp++ = 0;\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  ;\n\nudp_comb_entry_list\n  : udp_comb_entry\n      { std::list<string>*tmp = new std::list<string>;\n\ttmp->push_back($1);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  | udp_comb_entry_list udp_comb_entry\n      { std::list<string>*tmp = $1;\n\ttmp->push_back($2);\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n  ;\n\nudp_sequ_entry_list\n  : udp_sequ_entry\n      { std::list<string>*tmp = new std::list<string>;\n\ttmp->push_back($1);\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  | udp_sequ_entry_list udp_sequ_entry\n      { std::list<string>*tmp = $1;\n\ttmp->push_back($2);\n\tdelete[]$2;\n\t$$ = tmp;\n      }\n  ;\n\nudp_sequ_entry\n  : udp_input_list ':' udp_input_sym ':' udp_output_sym ';'\n      { char*tmp = new char[strlen($1)+5];\n\tstrcpy(tmp, $1);\n\tchar*tp = tmp+strlen(tmp);\n\t*tp++ = ':';\n\t*tp++ = $3;\n\t*tp++ = ':';\n\t*tp++ = $5;\n\t*tp++ = 0;\n\t$$ = tmp;\n      }\n  ;\n\nudp_initial\n  : K_initial IDENTIFIER '=' number ';'\n      { PExpr*etmp = new PENumber($4);\n\tPEIdent*itmp = new PEIdent(lex_strings.make($2), @2.lexical_pos);\n\tPAssign*atmp = new PAssign(itmp, etmp);\n\tFILE_NAME(atmp, @2);\n\tdelete[]$2;\n\t$$ = atmp;\n      }\n  ;\n\nudp_init_opt\n  : udp_initial { $$ = $1; }\n  |             { $$ = 0; }\n  ;\n\nudp_input_list\n  : udp_input_sym\n      { char*tmp = new char[2];\n\ttmp[0] = $1;\n\ttmp[1] = 0;\n\t$$ = tmp;\n      }\n  | udp_input_list udp_input_sym\n      { char*tmp = new char[strlen($1)+2];\n\tstrcpy(tmp, $1);\n\tchar*tp = tmp+strlen(tmp);\n\t*tp++ = $2;\n\t*tp++ = 0;\n\tdelete[]$1;\n\t$$ = tmp;\n      }\n  ;\n\nudp_input_sym\n  : '0' { $$ = '0'; }\n  | '1' { $$ = '1'; }\n  | 'x' { $$ = 'x'; }\n  | '?' { $$ = '?'; }\n  | 'b' { $$ = 'b'; }\n  | '*' { $$ = '*'; }\n  | '%' { $$ = '%'; }\n  | 'f' { $$ = 'f'; }\n  | 'F' { $$ = 'F'; }\n  | 'l' { $$ = 'l'; }\n  | 'h' { $$ = 'h'; }\n  | 'B' { $$ = 'B'; }\n  | 'r' { $$ = 'r'; }\n  | 'R' { $$ = 'R'; }\n  | 'M' { $$ = 'M'; }\n  | 'n' { $$ = 'n'; }\n  | 'N' { $$ = 'N'; }\n  | 'p' { $$ = 'p'; }\n  | 'P' { $$ = 'P'; }\n  | 'Q' { $$ = 'Q'; }\n  | 'q' { $$ = 'q'; }\n  | '_' { $$ = '_'; }\n  | '+' { $$ = '+'; }\n  | DEC_NUMBER\n        { yyerror(@1, \"internal error: Input digits parse as decimal number!\");\n          $$ = '0';\n        }\n  ;\n\nudp_output_sym\n  : '0' { $$ = '0'; }\n  | '1' { $$ = '1'; }\n  | 'x' { $$ = 'x'; }\n  | '-' { $$ = '-'; }\n  | DEC_NUMBER\n        { yyerror(@1, \"internal error: Output digits parse as decimal number!\");\n          $$ = '0';\n        }\n  ;\n\n  /* Port declarations create wires for the inputs and the output. The\n     makes for these ports are scoped within the UDP, so there is no\n     hierarchy involved. */\nudp_port_decl\n  : K_input list_of_identifiers ';'\n      { $$ = pform_make_udp_input_ports($2); }\n  | K_output IDENTIFIER ';'\n      { perm_string pname = lex_strings.make($2);\n\tPWire*pp = new PWire(pname, @2.lexical_pos, NetNet::IMPLICIT, NetNet::POUTPUT);\n\tvector<PWire*>*tmp = new std::vector<PWire*>(1);\n\t(*tmp)[0] = pp;\n\t$$ = tmp;\n\tdelete[]$2;\n      }\n  | K_reg IDENTIFIER ';'\n      { perm_string pname = lex_strings.make($2);\n\tPWire*pp = new PWire(pname, @2.lexical_pos, NetNet::REG, NetNet::PIMPLICIT);\n\tvector<PWire*>*tmp = new std::vector<PWire*>(1);\n\t(*tmp)[0] = pp;\n\t$$ = tmp;\n\tdelete[]$2;\n      }\n  | K_output K_reg IDENTIFIER ';'\n      { perm_string pname = lex_strings.make($3);\n\tPWire*pp = new PWire(pname, @3.lexical_pos, NetNet::REG, NetNet::POUTPUT);\n\tvector<PWire*>*tmp = new std::vector<PWire*>(1);\n\t(*tmp)[0] = pp;\n\t$$ = tmp;\n\tdelete[]$3;\n      }\n    ;\n\nudp_port_decls\n  : udp_port_decl\n      { $$ = $1; }\n  | udp_port_decls udp_port_decl\n      { std::vector<PWire*>*tmp = $1;\n\tsize_t s1 = $1->size();\n\ttmp->resize(s1+$2->size());\n\tfor (size_t idx = 0 ; idx < $2->size() ; idx += 1)\n\t      tmp->at(s1+idx) = $2->at(idx);\n\t$$ = tmp;\n\tdelete $2;\n      }\n  ;\n\nudp_port_list\n  : IDENTIFIER\n      { $$ = list_from_identifier($1, @1.lexical_pos); }\n  | udp_port_list ',' IDENTIFIER\n      { $$ = list_from_identifier($1, $3, @3.lexical_pos); }\n  ;\n\nudp_reg_opt\n  : K_reg  { $$ = true; }\n  |        { $$ = false; };\n\nudp_input_declaration_list\n  : K_input IDENTIFIER\n      { $$ = list_from_identifier($2, @2.lexical_pos); }\n  | udp_input_declaration_list ',' K_input IDENTIFIER\n      { $$ = list_from_identifier($1, $4, @4.lexical_pos); }\n  ;\n\nudp_primitive\n        /* This is the syntax for primitives that uses the IEEE1364-1995\n\t   format. The ports are simply names in the port list, and the\n\t   declarations are in the body. */\n\n  : K_primitive IDENTIFIER '(' udp_port_list ')' ';'\n    udp_port_decls\n    udp_init_opt\n    udp_body\n    K_endprimitive label_opt\n      { perm_string tmp2 = lex_strings.make($2);\n\tpform_make_udp(@2, tmp2, $4, $7, $9, $8);\n\tcheck_end_label(@11, \"primitive\", $2, $11);\n\tdelete[]$2;\n      }\n\n        /* This is the syntax for IEEE1364-2001 format definitions. The port\n\t   names and declarations are all in the parameter list. */\n\n  | K_primitive IDENTIFIER\n    '(' K_output udp_reg_opt IDENTIFIER initializer_opt ','\n    udp_input_declaration_list ')' ';'\n    udp_body\n    K_endprimitive label_opt\n      { perm_string tmp2 = lex_strings.make($2);\n\tpform_ident_t tmp6 = { lex_strings.make($6) , @6.lexical_pos };\n\tpform_make_udp(@2, tmp2, $5, tmp6, $7, $9, $12);\n\tcheck_end_label(@14, \"primitive\", $2, $14);\n\tdelete[]$2;\n\tdelete[]$6;\n      }\n  ;\n\nunique_priority\n  :             { $$ = IVL_CASE_QUALITY_BASIC; }\n  | K_unique    { $$ = IVL_CASE_QUALITY_UNIQUE; }\n  | K_unique0   { $$ = IVL_CASE_QUALITY_UNIQUE0; }\n  | K_priority  { $$ = IVL_CASE_QUALITY_PRIORITY; }\n  ;\n\n  /* Many keywords can be optional in the syntax, although their\n     presence is significant. This is a fairly common pattern so\n     collect those rules here. */\n\nK_const_opt\n : K_const { $$ = true; }\n |         { $$ = false; }\n ;\n\nK_genvar_opt\n : K_genvar { $$ = true; }\n |          { $$ = false; }\n ;\n\nK_static_opt\n : K_static { $$ = true; }\n |          { $$ = false; }\n ;\n\nK_virtual_opt\n  : K_virtual { $$ = true; }\n  |           { $$ = false; }\n  ;\n\nK_var_opt\n  : K_var\n  |\n  ;\n"
        },
        {
          "name": "parse_api.h",
          "type": "blob",
          "size": 2.3544921875,
          "content": "#ifndef IVL_parse_api_H\n#define IVL_parse_api_H\n/*\n * Copyright (c) 2001-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <cstdio>\n# include  \"StringHeap.h\"\n# include  <string>\n# include  <ostream>\n# include  <map>\n# include  <set>\n\nclass Design;\nclass Module;\nclass PClass;\nclass PPackage;\nclass PTaskFunc;\nclass PUdp;\nclass data_type_t;\nstruct enum_type_t;\n\n/*\n * These are maps of the modules and primitives parsed from the\n * Verilog source into pform for elaboration. The parser adds modules\n * to these maps as it compiles modules in the Verilog source.\n */\nextern std::map<perm_string,Module*> pform_modules;\nextern std::map<perm_string,PUdp*>   pform_primitives;\nextern std::vector<PPackage*>        pform_units;\nextern std::vector<PPackage*>        pform_packages;\n\nextern void pform_dump(std::ostream&out, const PClass*pac);\nextern void pform_dump(std::ostream&out, const PPackage*pac);\nextern void pform_dump(std::ostream&out, const PTaskFunc*tf);\n\n/*\n * This code actually invokes the parser to make modules. If the path\n * parameter is \"-\", the parser reads from stdin, otherwise it attempts\n * to open and read the specified file. When reading from a file, if\n * the ivlpp_string variable is not set to null, the file will be piped\n * through the command specified by ivlpp_string before being parsed.\n */\nextern int pform_parse(const char*path);\n\nextern void pform_finish();\n\nextern std::string vl_file;\n\nextern void pform_set_timescale(int units, int prec, const char*file,\n                                unsigned lineno);\nextern int def_ts_units;\nextern int def_ts_prec;\n\n#endif /* IVL_parse_api_H */\n"
        },
        {
          "name": "parse_misc.cc",
          "type": "blob",
          "size": 1.9990234375,
          "content": "/*\n * Copyright (c) 1998-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <cstdarg>\n# include  \"parse_misc.h\"\n# include  <cstdio>\n# include  <iostream>\n\nusing namespace std;\n\nextern const char*vl_file;\nunsigned error_count = 0;\nunsigned warn_count = 0;\nunsigned long based_size = 0;\n\nstd::ostream& operator << (std::ostream&o, const YYLTYPE&loc)\n{\n      if (loc.text)\n\t    o << loc.text << \":\";\n      else\n\t    o << \"<>:\";\n      o << loc.first_line;\n      return o;\n}\n\nvoid VLwarn(const char*msg)\n{\n      warn_count += 1;\n      cerr << yylloc.text << \":\" << yylloc.first_line << \": \" << msg << endl;\n}\n\nvoid VLerror(const char*msg)\n{\n      error_count += 1;\n      cerr << yylloc.text << \":\" << yylloc.first_line << \": \" << msg << endl;\n}\n\nvoid VLerror(const YYLTYPE&loc, const char*msg, ...)\n{\n      va_list ap;\n      va_start(ap, msg);\n\n      fprintf(stderr, \"%s:%d: \", loc.text, loc.first_line);\n      vfprintf(stderr, msg, ap);\n      va_end(ap);\n      fprintf(stderr, \"\\n\");\n\n      error_count += 1;\n      based_size = 0; /* Clear the base information if we have an error. */\n}\n\nvoid VLwarn(const YYLTYPE&loc, const char*msg)\n{\n      warn_count += 1;\n      cerr << loc << \": \" << msg << endl;\n}\n\nint VLwrap()\n{\n      return -1;\n}\n"
        },
        {
          "name": "parse_misc.h",
          "type": "blob",
          "size": 3.671875,
          "content": "#ifndef IVL_parse_misc_H\n#define IVL_parse_misc_H\n/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <list>\n# include  <ostream>\n# include  \"compiler.h\"\n# include  \"pform.h\"\n\n/*\n * The vlltype supports the passing of detailed source file location\n * information between the lexical analyzer and the parser. Defining\n * YYLTYPE compels the lexor to use this type and not something other.\n */\nstruct vlltype {\n      int first_line;\n      int first_column;\n      int last_line;\n      int last_column;\n      unsigned lexical_pos;\n      const char*text;\n      std::string get_fileline() const;\n};\n# define YYLTYPE struct vlltype\n\nclass LineInfo;\ninline void FILE_NAME(LineInfo*tmp, const struct vlltype&where)\n{\n      tmp->set_lineno(where.first_line);\n      tmp->set_file(filename_strings.make(where.text));\n}\n\n  /* This for compatibility with new and older bison versions. */\n#ifndef yylloc\n# define yylloc VLlloc\n#endif\nextern YYLTYPE yylloc;\n\n/*\n * Interface into the lexical analyzer. ...\n */\nextern int  VLlex();\nextern void VLerror(const char*msg);\nextern void VLerror(const YYLTYPE&loc, const char*msg, ...) __attribute__((format(printf,2,3)));\n#define yywarn VLwarn\nextern void VLwarn(const char*msg);\nextern void VLwarn(const YYLTYPE&loc, const char*msg);\n\nextern void destroy_lexor();\n\nextern std::ostream& operator << (std::ostream&, const YYLTYPE&loc);\n\nextern unsigned error_count, warn_count;\nextern unsigned long based_size;\n\nextern bool in_celldefine;\nenum UCDriveType { UCD_NONE, UCD_PULL0, UCD_PULL1 };\nextern UCDriveType uc_drive;\n\n/*\n * The parser signals back to the lexor that the next identifier\n * should be in the package scope. For example, if the source is\n *    <package> :: <foo>\n * Then the parser calls this function to set the package context so\n * that the lexor can interpret <foo> in the package context.\n */\nextern void lex_in_package_scope(PPackage*pkg);\n\n/*\n * Test if this identifier is a type identifier in the current\n * context. The pform code needs to help the lexor here because the\n * parser detects typedefs and marks the typedef'ed identifiers as\n * type names.\n */\nextern typedef_t* pform_test_type_identifier(const YYLTYPE&loc, const char*txt);\nextern typedef_t* pform_test_type_identifier(PPackage*pkg, const char*txt);\n\n/*\n * Test if this identifier is a package name. The pform needs to help\n * the lexor here because the parser detects packages and saves them.\n */\nextern PPackage* pform_test_package_identifier(const char*txt);\n\n/*\n * Export these functions because we have to generate PENumber class\n * in pform.cc for user defparam definition from command file.\n */\nextern verinum*make_unsized_dec(const char*txt);\nextern verinum*make_undef_highz_dec(const char*txt);\nextern verinum*make_unsized_binary(const char*txt);\nextern verinum*make_unsized_octal(const char*txt);\nextern verinum*make_unsized_hex(const char*txt);\n\nextern char* strdupnew(char const *str);\n\n#endif /* IVL_parse_misc_H */\n"
        },
        {
          "name": "pform.cc",
          "type": "blob",
          "size": 100.900390625,
          "content": "/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <cstdarg>\n# include  \"compiler.h\"\n# include  \"pform.h\"\n# include  \"parse_misc.h\"\n# include  \"parse_api.h\"\n# include  \"PClass.h\"\n# include  \"PEvent.h\"\n# include  \"PPackage.h\"\n# include  \"PUdp.h\"\n# include  \"PGenerate.h\"\n# include  \"PModport.h\"\n# include  \"PSpec.h\"\n# include  \"PTimingCheck.h\"\n# include  \"discipline.h\"\n# include  <list>\n# include  <map>\n# include  <cassert>\n# include  <stack>\n# include  <typeinfo>\n# include  <sstream>\n# include  <cstring>\n# include  <cstdlib>\n# include  <cctype>\n\n# include  \"ivl_assert.h\"\n# include  \"ivl_alloc.h\"\n\nusing namespace std;\n\n/*\n * The \"// synthesis translate_on/off\" meta-comments cause this flag\n * to be turned off or on. The pform_make_behavior and similar\n * functions look at this flag and may choose to add implicit ivl\n * synthesis flags.\n */\nstatic bool pform_mc_translate_flag = true;\nvoid pform_mc_translate_on(bool flag) { pform_mc_translate_flag = flag; }\n\n/*\n * The pform_modules is a map of the modules that have been defined in\n * the top level. This should not contain nested modules/programs.\n * pform_primitives is similar, but for UDP primitives.\n */\nmap<perm_string,Module*> pform_modules;\nmap<perm_string,PUdp*> pform_primitives;\n\n/*\n * The pform_units is a list of the SystemVerilog compilation unit scopes.\n * The current compilation unit is the last element in the list. All items\n * declared or defined at the top level (outside any design element) are\n * added to the current compilation unit scope.\n */\nvector<PPackage*> pform_units;\n\nstatic bool is_compilation_unit(LexicalScope*scope)\n{\n\t// A compilation unit is the only scope that doesn't have a parent.\n      assert(scope);\n      return scope->parent_scope() == 0;\n}\n\nstd::string vlltype::get_fileline() const\n{\n      ostringstream buf;\n      buf << (text? text : \"\") << \":\" << first_line;\n      string res = buf.str();\n      return res;\n\n}\n\nstatic bool is_hex_digit_str(const char *str)\n{\n      while (*str) {\n\t    if (!isxdigit(*str)) return false;\n\t    str++;\n      }\n      return true;\n}\n\nstatic bool is_dec_digit_str(const char *str)\n{\n      while (*str) {\n\t    if (!isdigit(*str)) return false;\n\t    str++;\n      }\n      return true;\n}\n\nstatic bool is_oct_digit_str(const char *str)\n{\n      while (*str) {\n\t    if (*str < '0' || *str > '7') return false;\n\t    str++;\n      }\n      return true;\n}\n\nstatic bool is_bin_digit_str(const char *str)\n{\n      while (*str) {\n\t    if (*str != '0' && *str != '1') return false;\n\t    str++;\n      }\n      return true;\n}\n\n/*\n * Parse configuration file with format <key>=<value>, where key\n * is the hierarchical name of a valid parameter name, and value\n * is the value user wants to assign to. The value should be constant.\n */\nvoid parm_to_defparam_list(const string&param)\n{\n    char* key;\n    char* value;\n    unsigned off = param.find('=');\n    if (off > param.size()) {\n        key = strdup(param.c_str());\n        value = (char*)malloc(1);\n        *value = '\\0';\n\n    } else {\n        key = strdup(param.substr(0, off).c_str());\n        value = strdup(param.substr(off+1).c_str());\n    }\n\n    // Resolve hierarchical name for defparam. Remember\n    // to deal with bit select for generate scopes. Bit\n    // select expression should be constant integer.\n    pform_name_t name;\n    char *nkey = key;\n    char *ptr = strchr(key, '.');\n    while (ptr != 0) {\n        *ptr++ = '\\0';\n        // Find if bit select is applied, this would be something\n        // like - scope[2].param = 10\n        char *bit_l = strchr(nkey, '[');\n        if (bit_l !=0) {\n            *bit_l++ = '\\0';\n            char *bit_r = strchr(bit_l, ']');\n            if (bit_r == 0) {\n                cerr << \"<command line>: error: missing ']' for defparam: \" << nkey << endl;\n                free(key);\n                free(value);\n                return;\n            }\n            *bit_r = '\\0';\n            int i = 0;\n            while (*(bit_l+i) != '\\0')\n                if (!isdigit(*(bit_l+i++))) {\n                    cerr << \"<command line>: error: scope index expression is not constant: \" << nkey << endl;\n                    free(key);\n                    free(value);\n                    return;\n                }\n            name_component_t tmp(lex_strings.make(nkey));\n            index_component_t index;\n            index.sel = index_component_t::SEL_BIT;\n            verinum *seln = new verinum(atoi(bit_l));\n            PENumber *sel = new PENumber(seln);\n            index.msb = sel;\n            index.lsb = sel;\n            tmp.index.push_back(index);\n            name.push_back(tmp);\n        }\n        else    // no bit select\n            name.push_back(name_component_t(lex_strings.make(nkey)));\n\n        nkey = ptr;\n        ptr = strchr(nkey, '.');\n    }\n    name.push_back(name_component_t(lex_strings.make(nkey)));\n    free(key);\n\n    // Resolve value to PExpr class. Should support all kind of constant\n    // format including based number, dec number, real number and string.\n\n    // Is it a string?\n    if (*value == '\"') {\n\tchar *buf = strdup (value);\n\tchar *buf_ptr = buf+1;\n\t// Parse until another '\"' or '\\0'\n\twhile (*buf_ptr != '\"' && *buf_ptr != '\\0') {\n\t    buf_ptr++;\n\t    // Check for escape, especially '\\\"', which does not mean the\n\t    // end of string.\n\t    if (*buf_ptr == '\\\\' && *(buf_ptr+1) != '\\0')\n\t\tbuf_ptr += 2;\n\t}\n\tif (*buf_ptr == '\\0')\t// String end without '\"'\n\t    cerr << \"<command line>: error: missing close quote of string for defparam: \" << name << endl;\n\telse if (*(buf_ptr+1) != 0) { // '\"' appears within string with no escape\n\t    cerr << buf_ptr << endl;\n\t    cerr << \"<command line>: error: \\'\\\"\\' appears within string value for defparam: \" << name\n\t\t << \". Ignore characters after \\'\\\"\\'\" << endl;\n\t}\n\n\t*buf_ptr = '\\0';\n\tbuf_ptr = buf+1;\n\t// Remember to use 'new' to allocate string for PEString\n\t// because 'delete' is used by its destructor.\n\tchar *nchar = strcpy(new char [strlen(buf_ptr)+1], buf_ptr);\n\tPExpr* ndec = new PEString(nchar);\n\tModule::user_defparms.push_back( make_pair(name, ndec) );\n\tfree(buf);\n\tfree(value);\n\treturn;\n    }\n\n    // Is it a based number?\n    char *num = strchr(value, '\\'');\n    if (num != 0) {\n\tverinum *val;\n\tconst char *base = num + 1;\n\tif (*base == 's' || *base == 'S')\n\t    base++;\n\tswitch (*base) {\n\t  case 'h':\n\t  case 'H':\n\t    if (is_hex_digit_str(base+1)) {\n\t\tval = make_unsized_hex(num);\n\t    } else {\n\t\tcerr << \"<command line>: error: invalid digit in hex value specified for defparam: \" << name << endl;\n\t\tfree(value);\n\t\treturn;\n\t    }\n\t    break;\n\t  case 'd':\n\t  case 'D':\n\t    if (is_dec_digit_str(base+1)) {\n\t\tval = make_unsized_dec(num);\n\t    } else {\n\t\tcerr << \"<command line>: error: invalid digit in decimal value specified for defparam: \" << name << endl;\n\t\tfree(value);\n\t\treturn;\n\t    }\n\t    break;\n\t  case 'o':\n\t  case 'O':\n\t    if (is_oct_digit_str(base+1)) {\n\t\tval = make_unsized_octal(num);\n\t    } else {\n\t\tcerr << \"<command line>: error: invalid digit in octal value specified for defparam: \" << name << endl;\n\t\tfree(value);\n\t\treturn;\n\t    }\n\t    break;\n\t  case 'b':\n\t  case 'B':\n\t    if (is_bin_digit_str(base+1)) {\n\t\tval = make_unsized_binary(num);\n\t    } else {\n\t\tcerr << \"<command line>: error: invalid digit in binary value specified for defparam: \" << name << endl;\n\t\tfree(value);\n\t\treturn;\n\t    }\n\t    break;\n\t  default:\n\t    cerr << \"<command line>: error: invalid numeric base specified for defparam: \" << name << endl;\n\t    free(value);\n\t    return;\n\t}\n\tif (num != value) {  // based number with size\n\t    *num = 0;\n\t    if (is_dec_digit_str(value)) {\n\t\tverinum *siz = make_unsized_dec(value);\n\t\tval = pform_verinum_with_size(siz, val, \"<command line>\", 0);\n\t    } else {\n\t\tcerr << \"<command line>: error: invalid size for value specified for defparam: \" << name << endl;\n\t\tfree(value);\n\t\treturn;\n\t    }\n\t}\n\tPExpr* ndec = new PENumber(val);\n\tModule::user_defparms.push_back( make_pair(name, ndec) );\n\tfree(value);\n\treturn;\n    }\n\n    // Is it a decimal number?\n    num = (value[0] == '-') ? value + 1 : value;\n    if (num[0] != '\\0' && is_dec_digit_str(num)) {\n\tverinum *val = make_unsized_dec(num);\n\tif (value[0] == '-') *val = -(*val);\n\tPExpr* ndec = new PENumber(val);\n\tModule::user_defparms.push_back( make_pair(name, ndec) );\n\tfree(value);\n\treturn;\n    }\n\n    // Is it a real number?\n    char *end = 0;\n    double rval = strtod(value, &end);\n    if (end != value && *end == 0) {\n\tverireal *val = new verireal(rval);\n\tPExpr* nreal = new PEFNumber(val);\n\tModule::user_defparms.push_back( make_pair(name, nreal) );\n\tfree(value);\n\treturn;\n    }\n\n    // None of the above.\n    cerr << \"<command line>: error: invalid value specified for defparam: \" << name << endl;\n    free(value);\n}\n\n/*\n * The lexor accesses the vl_* variables.\n */\nstring vl_file = \"\";\n\nextern int VLparse();\n\n  /* This tracks the current module being processed. There can only be\n     exactly one module currently being parsed, since Verilog does not\n     allow nested module definitions. */\nstatic list<Module*>pform_cur_module;\n\nbool pform_library_flag = false;\n\n/*\n * Give each unnamed block that has a variable declaration a unique name.\n */\nstatic unsigned scope_unnamed_block_with_decl = 1;\n\n  /* This tracks the current generate scheme being processed. This is\n     always within a module. */\nstatic PGenerate*pform_cur_generate = 0;\n\n  /* This indicates whether a new generate construct can be directly\n     nested in the current generate construct. */\nbool pform_generate_single_item = false;\n\n  /* Blocks within the same conditional generate construct may have\n     the same name. Here we collect the set of names used in each\n     construct, so they can be added to the local scope without\n     conflicting with each other. Generate constructs may nest, so\n     we need a stack. */\nstatic list<set<perm_string> > conditional_block_names;\n\n  /* This tracks the current modport list being processed. This is\n     always within an interface. */\nstatic PModport*pform_cur_modport = 0;\n\nstatic NetNet::Type pform_default_nettype = NetNet::WIRE;\n\n/*\n * These variables track the time scale set by the most recent `timescale\n * directive. Time scales set by SystemVerilog timeunit and timeprecision\n * declarations are stored directly in the current lexical scope.\n */\nstatic int pform_time_unit;\nstatic int pform_time_prec;\n\n/*\n * These variables track where the most recent `timescale directive\n * occurred. This allows us to warn about time scales that are inherited\n * from another file.\n */\nstatic char*pform_timescale_file = 0;\nstatic unsigned pform_timescale_line;\n\n/*\n * These variables track whether we can accept new timeunits declarations.\n */\nbool allow_timeunit_decl = true;\nbool allow_timeprec_decl = true;\n\n// Track whether the current parameter declaration is in a parameter port list\nstatic bool pform_in_parameter_port_list = false;\n\n/*\n * The lexical_scope keeps track of the current lexical scope that is\n * being parsed. The lexical scope may stack, so the current scope may\n * have a parent, that is restored when the current scope ends.\n *\n * Items that have scoped names are put in the lexical_scope object.\n */\nstatic LexicalScope* lexical_scope = 0;\n\nLexicalScope* pform_peek_scope(void)\n{\n      assert(lexical_scope);\n      return lexical_scope;\n}\n\nstatic void pform_check_possible_imports(LexicalScope *scope)\n{\n      map<perm_string,PPackage*>::const_iterator cur;\n      for (cur = scope->possible_imports.begin(); cur != scope->possible_imports.end(); ++cur) {\n            if (scope->local_symbols.find(cur->first) == scope->local_symbols.end())\n                  scope->explicit_imports[cur->first] = cur->second;\n      }\n      scope->possible_imports.clear();\n}\n\nvoid pform_pop_scope()\n{\n      LexicalScope*scope = lexical_scope;\n      assert(scope);\n\n      pform_check_possible_imports(scope);\n\n      lexical_scope = scope->parent_scope();\n      assert(lexical_scope);\n}\n\nstatic LexicalScope::lifetime_t find_lifetime(LexicalScope::lifetime_t lifetime)\n{\n      if (lifetime != LexicalScope::INHERITED)\n\t    return lifetime;\n\n      return lexical_scope->default_lifetime;\n}\n\nstatic PScopeExtra* find_nearest_scopex(LexicalScope*scope)\n{\n      PScopeExtra*scopex = dynamic_cast<PScopeExtra*> (scope);\n      while (scope && !scopex) {\n\t    scope = scope->parent_scope();\n\t    scopex = dynamic_cast<PScopeExtra*> (scope);\n      }\n      return scopex;\n}\n\nstatic void add_local_symbol(LexicalScope*scope, perm_string name, PNamedItem*item)\n{\n      assert(scope);\n\n\t// Check for conflict with another local symbol.\n      map<perm_string,PNamedItem*>::const_iterator cur_sym\n\t    = scope->local_symbols.find(name);\n      if (cur_sym != scope->local_symbols.end()) {\n\t    cerr << item->get_fileline() << \": error: \"\n\t\t    \"'\" << name << \"' has already been declared \"\n\t\t    \"in this scope.\" << endl;\n\t    cerr << cur_sym->second->get_fileline() << \":      : \"\n\t\t    \"It was declared here as \"\n\t\t << cur_sym->second->symbol_type() << \".\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n\n\t// Check for conflict with an explicit import.\n      map<perm_string,PPackage*>::const_iterator cur_pkg\n\t    = scope->explicit_imports.find(name);\n      if (cur_pkg != scope->explicit_imports.end()) {\n\t    cerr << item->get_fileline() << \": error: \"\n\t\t    \"'\" << name << \"' has already been \"\n\t\t    \"imported into this scope from package '\"\n\t\t << cur_pkg->second->pscope_name() << \"'.\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n\n      scope->local_symbols[name] = item;\n}\n\nstatic void check_potential_imports(const struct vlltype&loc, perm_string name, bool tf_call)\n{\n      LexicalScope*scope = lexical_scope;\n      while (scope) {\n\t    if (scope->local_symbols.find(name) != scope->local_symbols.end())\n\t\t  return;\n\t    if (scope->explicit_imports.find(name) != scope->explicit_imports.end())\n\t\t  return;\n\t    if (pform_find_potential_import(loc, scope, name, tf_call, true))\n\t\t  return;\n\n\t    scope = scope->parent_scope();\n      }\n}\n\n/*\n * Set the local time unit/precision. This version is used for setting\n * the time scale for design elements (modules, packages, etc.) and is\n * called after any initial timeunit and timeprecision declarations\n * have been parsed.\n */\nvoid pform_set_scope_timescale(const struct vlltype&loc)\n{\n      PScopeExtra*scope = dynamic_cast<PScopeExtra*>(lexical_scope);\n      ivl_assert(loc, scope);\n\n      PScopeExtra*parent = find_nearest_scopex(scope->parent_scope());\n\n      bool used_global_timescale = false;\n      if (scope->time_unit_is_default) {\n            if (is_compilation_unit(scope)) {\n                  scope->time_unit = def_ts_units;\n            } else if (!is_compilation_unit(parent)) {\n                  scope->time_unit = parent->time_unit;\n                  scope->time_unit_is_default = parent->time_unit_is_default;\n            } else if (pform_timescale_file != 0) {\n                  scope->time_unit = pform_time_unit;\n                  scope->time_unit_is_default = false;\n                  used_global_timescale = true;\n            } else /* parent is compilation unit */ {\n                  scope->time_unit = parent->time_unit;\n                  scope->time_unit_is_default = parent->time_unit_is_default;\n            }\n      }\n      if (scope->time_prec_is_default) {\n            if (is_compilation_unit(scope)) {\n                  scope->time_precision = def_ts_prec;\n            } else if (!is_compilation_unit(parent)) {\n                  scope->time_precision = parent->time_precision;\n                  scope->time_prec_is_default = parent->time_prec_is_default;\n            } else if (pform_timescale_file != 0) {\n                  scope->time_precision = pform_time_prec;\n                  scope->time_prec_is_default = false;\n                  used_global_timescale = true;\n            } else {\n                  scope->time_precision = parent->time_precision;\n                  scope->time_prec_is_default = parent->time_prec_is_default;\n            }\n      }\n\n      if (gn_system_verilog() && (scope->time_unit < scope->time_precision)) {\n\t    if (scope->time_unit_is_local || scope->time_prec_is_local) {\n\t\t  VLerror(\"error: A timeprecision is missing or is too large!\");\n\t    }\n      } else {\n            ivl_assert(loc, scope->time_unit >= scope->time_precision);\n      }\n\n      if (warn_timescale && used_global_timescale\n\t  && (strcmp(pform_timescale_file, loc.text) != 0)) {\n\n\t    cerr << loc.get_fileline() << \": warning: \"\n\t\t << \"timescale for \" << scope->pscope_name()\n\t\t << \" inherited from another file.\" << endl;\n\t    cerr << pform_timescale_file << \":\" << pform_timescale_line\n\t\t << \": ...: The inherited timescale is here.\" << endl;\n      }\n\n      allow_timeunit_decl = false;\n      allow_timeprec_decl = false;\n}\n\n/*\n * Set the local time unit/precision. This version is used for setting\n * the time scale for subsidiary items (classes, subroutines, etc.),\n * which simply inherit their time scale from their parent scope.\n */\nstatic void pform_set_scope_timescale(PScope*scope, const PScope*parent)\n{\n      scope->time_unit            = parent->time_unit;\n      scope->time_precision       = parent->time_precision;\n      scope->time_unit_is_default = parent->time_unit_is_default;\n      scope->time_prec_is_default = parent->time_prec_is_default;\n}\n\nPClass* pform_push_class_scope(const struct vlltype&loc, perm_string name)\n{\n      PClass*class_scope = new PClass(name, lexical_scope);\n      class_scope->default_lifetime = LexicalScope::AUTOMATIC;\n      FILE_NAME(class_scope, loc);\n\n      PScopeExtra*scopex = find_nearest_scopex(lexical_scope);\n      ivl_assert(loc, scopex);\n      ivl_assert(loc, !pform_cur_generate);\n\n      pform_set_scope_timescale(class_scope, scopex);\n\n      scopex->classes[name] = class_scope;\n      scopex->classes_lexical .push_back(class_scope);\n\n      lexical_scope = class_scope;\n      return class_scope;\n}\n\nPPackage* pform_push_package_scope(const struct vlltype&loc, perm_string name,\n\t\t\t\t   LexicalScope::lifetime_t lifetime)\n{\n      PPackage*pkg_scope = new PPackage(name, lexical_scope);\n      pkg_scope->default_lifetime = find_lifetime(lifetime);\n      FILE_NAME(pkg_scope, loc);\n\n      allow_timeunit_decl = true;\n      allow_timeprec_decl = true;\n\n      lexical_scope = pkg_scope;\n      return pkg_scope;\n}\n\nPTask* pform_push_task_scope(const struct vlltype&loc, char*name,\n\t\t\t     LexicalScope::lifetime_t lifetime)\n{\n      perm_string task_name = lex_strings.make(name);\n\n      LexicalScope::lifetime_t default_lifetime = find_lifetime(lifetime);\n      bool is_auto = default_lifetime == LexicalScope::AUTOMATIC;\n\n      PTask*task = new PTask(task_name, lexical_scope, is_auto);\n      task->default_lifetime = default_lifetime;\n      FILE_NAME(task, loc);\n\n      PScopeExtra*scopex = find_nearest_scopex(lexical_scope);\n      ivl_assert(loc, scopex);\n      if (is_compilation_unit(scopex) && !gn_system_verilog()) {\n\t    cerr << task->get_fileline() << \": error: task declarations \"\n\t\t  \"must be contained within a module.\" << endl;\n\t    error_count += 1;\n      }\n\n      pform_set_scope_timescale(task, scopex);\n\n      if (pform_cur_generate) {\n\t    add_local_symbol(pform_cur_generate, task_name, task);\n\t    pform_cur_generate->tasks[task_name] = task;\n      } else {\n\t    add_local_symbol(scopex, task_name, task);\n\t    scopex->tasks[task_name] = task;\n      }\n\n      lexical_scope = task;\n\n      return task;\n}\n\nPFunction* pform_push_function_scope(const struct vlltype&loc, const char*name,\n                                     LexicalScope::lifetime_t lifetime)\n{\n      perm_string func_name = lex_strings.make(name);\n\n      LexicalScope::lifetime_t default_lifetime = find_lifetime(lifetime);\n      bool is_auto = default_lifetime == LexicalScope::AUTOMATIC;\n\n      PFunction*func = new PFunction(func_name, lexical_scope, is_auto);\n      func->default_lifetime = default_lifetime;\n      FILE_NAME(func, loc);\n\n      PScopeExtra*scopex = find_nearest_scopex(lexical_scope);\n      ivl_assert(loc, scopex);\n      if (is_compilation_unit(scopex) && !gn_system_verilog()) {\n\t    cerr << func->get_fileline() << \": error: function declarations \"\n\t\t  \"must be contained within a module.\" << endl;\n\t    error_count += 1;\n      }\n\n      pform_set_scope_timescale(func, scopex);\n\n      if (pform_cur_generate) {\n\t    add_local_symbol(pform_cur_generate, func_name, func);\n\t    pform_cur_generate->funcs[func_name] = func;\n\n      } else {\n\t    add_local_symbol(scopex, func_name, func);\n\t    scopex->funcs[func_name] = func;\n      }\n\n      lexical_scope = func;\n\n      return func;\n}\n\nPBlock* pform_push_block_scope(const struct vlltype&loc, char*name,\n\t\t\t       PBlock::BL_TYPE bt)\n{\n      perm_string block_name;\n      if (name) block_name = lex_strings.make(name);\n      else {\n\t      // Create a unique name for this unnamed block.\n\t    char tmp[32];\n\t    snprintf(tmp, sizeof tmp, \"$unm_blk_%u\",\n\t             scope_unnamed_block_with_decl);\n\t    block_name = lex_strings.make(tmp);\n\t    scope_unnamed_block_with_decl += 1;\n      }\n\n      PBlock*block = new PBlock(block_name, lexical_scope, bt);\n      FILE_NAME(block, loc);\n      block->default_lifetime = find_lifetime(LexicalScope::INHERITED);\n      if (name) add_local_symbol(lexical_scope, block_name, block);\n      lexical_scope = block;\n\n      return block;\n}\n\n/*\n * Create a new identifier.\n */\nPEIdent* pform_new_ident(const struct vlltype&loc, const pform_name_t&name)\n{\n      if (gn_system_verilog())\n\t    check_potential_imports(loc, name.front().name, false);\n\n      return new PEIdent(name, loc.lexical_pos);\n}\n\nPTrigger* pform_new_trigger(const struct vlltype&loc, PPackage*pkg,\n\t\t\t    const pform_name_t&name, unsigned lexical_pos)\n{\n      if (gn_system_verilog())\n\t    check_potential_imports(loc, name.front().name, false);\n\n      PTrigger*tmp = new PTrigger(pkg, name, lexical_pos);\n      FILE_NAME(tmp, loc);\n      return tmp;\n}\n\nPNBTrigger* pform_new_nb_trigger(const struct vlltype&loc,\n\t\t\t         const list<PExpr*>*dly,\n\t\t\t         const pform_name_t&name,\n\t\t\t         unsigned lexical_pos)\n{\n      if (gn_system_verilog())\n\t    check_potential_imports(loc, name.front().name, false);\n\n      PExpr*tmp_dly = 0;\n      if (dly) {\n\t    ivl_assert(loc, dly->size() == 1);\n\t    tmp_dly = dly->front();\n      }\n\n      PNBTrigger*tmp = new PNBTrigger(name, lexical_pos, tmp_dly);\n      FILE_NAME(tmp, loc);\n      return tmp;\n}\n\nPGenerate* pform_parent_generate(void)\n{\n      return pform_cur_generate;\n}\n\nbool pform_error_in_generate(const vlltype&loc, const char *type)\n{\n\tif (!pform_parent_generate())\n\t\treturn false;\n\n\tVLerror(loc, \"error: %s is not allowed in generate block.\", type);\n\treturn true;\n}\n\nvoid pform_bind_attributes(map<perm_string,PExpr*>&attributes,\n\t\t\t   list<named_pexpr_t>*attr, bool keep_attrs)\n{\n      if (attr == 0)\n\t    return;\n\n      while (! attr->empty()) {\n\t    named_pexpr_t tmp = attr->front();\n\t    attr->pop_front();\n\t    attributes[tmp.name] = tmp.parm;\n      }\n      if (!keep_attrs)\n\t    delete attr;\n}\n\nbool pform_in_program_block()\n{\n      if (pform_cur_module.empty())\n\t    return false;\n      if (pform_cur_module.front()->program_block)\n\t    return true;\n      return false;\n}\n\nbool pform_in_interface()\n{\n      if (pform_cur_module.empty())\n\t    return false;\n      if (pform_cur_module.front()->is_interface)\n\t    return true;\n      return false;\n}\n\nstatic bool pform_at_module_level()\n{\n      return (lexical_scope == pform_cur_module.front())\n          || (lexical_scope == pform_cur_generate);\n}\n\nPWire*pform_get_wire_in_scope(perm_string name)\n{\n      return lexical_scope->wires_find(name);\n}\n\nstatic void pform_put_wire_in_scope(perm_string name, PWire*net)\n{\n      add_local_symbol(lexical_scope, name, net);\n      lexical_scope->wires[name] = net;\n}\n\nvoid pform_put_enum_type_in_scope(enum_type_t*enum_set)\n{\n      if (std::find(lexical_scope->enum_sets.begin(),\n\t\t    lexical_scope->enum_sets.end(), enum_set) !=\n          lexical_scope->enum_sets.end())\n\t    return;\n\n      set<perm_string> enum_names;\n      list<named_pexpr_t>::const_iterator cur;\n      for (cur = enum_set->names->begin(); cur != enum_set->names->end(); ++cur) {\n\t    if (enum_names.count(cur->name)) {\n\t\t  cerr << enum_set->get_fileline() << \": error: \"\n\t\t\t  \"Duplicate enumeration name '\"\n\t\t       << cur->name << \"'.\" << endl;\n\t\t  error_count += 1;\n\t    } else {\n\t\t  add_local_symbol(lexical_scope, cur->name, enum_set);\n\t\t  enum_names.insert(cur->name);\n\t    }\n      }\n\n      lexical_scope->enum_sets.push_back(enum_set);\n}\n\nstatic typedef_t *pform_get_typedef(const struct vlltype&loc, perm_string name)\n{\n      typedef_t *&td = lexical_scope->typedefs[name];\n      if (!td) {\n\t    td = new typedef_t(name);\n\t    FILE_NAME(td, loc);\n\t    add_local_symbol(lexical_scope, name, td);\n      }\n      return td;\n}\n\nvoid pform_forward_typedef(const struct vlltype&loc, perm_string name,\n\t\t\t   enum typedef_t::basic_type basic_type)\n{\n      typedef_t *td = pform_get_typedef(loc, name);\n\n      if (!td->set_basic_type(basic_type)) {\n\t    cout << loc << \" error: Incompatible basic type `\" << basic_type\n\t         << \"` for `\" << name\n\t\t << \"`. Previously declared in this scope as `\"\n\t\t << td->get_basic_type() << \"` at \" << td->get_fileline() << \".\"\n\t         << endl;\n\t    error_count++;\n      }\n}\n\nvoid pform_set_typedef(const struct vlltype&loc, perm_string name,\n\t\t       data_type_t*data_type,\n\t\t       std::list<pform_range_t>*unp_ranges)\n{\n      typedef_t *td = pform_get_typedef(loc, name);\n\n      if(unp_ranges)\n\t    data_type = new uarray_type_t(data_type, unp_ranges);\n\n      if (!td->set_data_type(data_type)) {\n\t    cerr << loc << \" error: Type identifier `\" << name\n\t\t << \"` has already been declared in this scope at \"\n\t\t << td->get_data_type()->get_fileline() << \".\"\n\t\t << endl;\n\t    error_count++;\n\t    delete data_type;\n      }\n}\n\nvoid pform_set_type_referenced(const struct vlltype&loc, const char*name)\n{\n      perm_string lex_name = lex_strings.make(name);\n      check_potential_imports(loc, lex_name, false);\n}\n\ntypedef_t* pform_test_type_identifier(const struct vlltype&loc, const char*txt)\n{\n      perm_string name = lex_strings.make(txt);\n\n      LexicalScope*cur_scope = lexical_scope;\n      do {\n\t    LexicalScope::typedef_map_t::iterator cur;\n\n\t      // First look to see if this identifier is imported from\n\t      // a package. If it is, see if it is a type in that\n\t      // package. If it is, then great. If imported as\n\t      // something other than a type, then give up now because\n\t      // the name has at least shadowed any other possible\n\t      // meaning for this name.\n\t    map<perm_string,PPackage*>::iterator cur_pkg;\n\t    cur_pkg = cur_scope->explicit_imports.find(name);\n\t    if (cur_pkg != cur_scope->explicit_imports.end()) {\n\t\t  PPackage*pkg = cur_pkg->second;\n\t\t  cur = pkg->typedefs.find(name);\n\t\t  if (cur != pkg->typedefs.end())\n\t\t\treturn cur->second;\n\n\t\t    // Not a type. Give up.\n\t\t  return 0;\n\t    }\n\n\t    cur = cur_scope->typedefs.find(name);\n\t    if (cur != cur_scope->typedefs.end())\n\t\t  return cur->second;\n\n            PPackage*pkg = pform_find_potential_import(loc, cur_scope, name, false, false);\n            if (pkg) {\n\t          cur = pkg->typedefs.find(name);\n\t          if (cur != pkg->typedefs.end())\n\t\t        return cur->second;\n\n\t\t    // Not a type. Give up.\n\t\t  return 0;\n            }\n\n\t    cur_scope = cur_scope->parent_scope();\n      } while (cur_scope);\n\n      return 0;\n}\n\nPECallFunction* pform_make_call_function(const struct vlltype&loc,\n\t\t\t\t\t const pform_name_t&name,\n\t\t\t\t\t const list<named_pexpr_t> &parms)\n{\n      if (gn_system_verilog())\n\t    check_potential_imports(loc, name.front().name, true);\n\n      PECallFunction*tmp = new PECallFunction(name, parms);\n      FILE_NAME(tmp, loc);\n      return tmp;\n}\n\nPCallTask* pform_make_call_task(const struct vlltype&loc,\n\t\t\t\tconst pform_name_t&name,\n\t\t\t\tconst list<named_pexpr_t> &parms)\n{\n      if (gn_system_verilog())\n\t    check_potential_imports(loc, name.front().name, true);\n\n      PCallTask*tmp = new PCallTask(name, parms);\n      FILE_NAME(tmp, loc);\n      return tmp;\n}\n\nvoid pform_make_var(const struct vlltype&loc,\n\t\t    std::list<decl_assignment_t*>*assign_list,\n\t\t    data_type_t*data_type, std::list<named_pexpr_t>*attr,\n\t\t    bool is_const)\n{\n      static const struct str_pair_t str = { IVL_DR_STRONG, IVL_DR_STRONG };\n\n      pform_makewire(loc, 0, str, assign_list, NetNet::REG, data_type, attr,\n\t\t     is_const);\n}\n\nvoid pform_make_foreach_declarations(const struct vlltype&loc,\n\t\t\t\t     std::list<perm_string>*loop_vars)\n{\n      list<decl_assignment_t*>assign_list;\n      for (list<perm_string>::const_iterator cur = loop_vars->begin()\n\t\t ; cur != loop_vars->end() ; ++ cur) {\n\t    if (cur->nil())\n\t\t  continue;\n\t    decl_assignment_t*tmp_assign = new decl_assignment_t;\n\t    tmp_assign->name = { lex_strings.make(*cur), 0 };\n\t    assign_list.push_back(tmp_assign);\n      }\n\n      pform_make_var(loc, &assign_list, &size_type);\n}\n\nPForeach* pform_make_foreach(const struct vlltype&loc,\n\t\t\t     char*name,\n\t\t\t     list<perm_string>*loop_vars,\n\t\t\t     Statement*stmt)\n{\n      perm_string use_name = lex_strings.make(name);\n      delete[]name;\n\n      if (loop_vars==0 || loop_vars->empty()) {\n\t    cerr << loc.get_fileline() << \": error: \"\n\t\t << \"No loop variables at all in foreach index.\" << endl;\n\t    error_count += 1;\n      }\n\n      ivl_assert(loc, loop_vars);\n      PForeach*fe = new PForeach(use_name, *loop_vars, stmt);\n      FILE_NAME(fe, loc);\n\n      delete loop_vars;\n\n      return fe;\n}\n\nstatic void pform_put_behavior_in_scope(PProcess*pp)\n{\n      lexical_scope->behaviors.push_back(pp);\n}\n\nvoid pform_put_behavior_in_scope(AProcess*pp)\n{\n      lexical_scope->analog_behaviors.push_back(pp);\n}\n\nvoid pform_set_default_nettype(NetNet::Type type,\n\t\t\t       const char*file, unsigned lineno)\n{\n      pform_default_nettype = type;\n\n      if (! pform_cur_module.empty()) {\n\t    cerr << file<<\":\"<<lineno << \": error: \"\n\t\t << \"`default_nettype directives must appear\" << endl;\n\t    cerr << file<<\":\"<<lineno << \":      : \"\n\t\t << \"outside module definitions. The containing\" << endl;\n\t    cerr << file<<\":\"<<lineno << \":      : \"\n\t\t << \"module \" << pform_cur_module.back()->mod_name()\n\t\t << \" starts on line \"\n\t\t << pform_cur_module.back()->get_fileline() << \".\" << endl;\n\t    error_count += 1;\n      }\n}\n\nstatic void pform_declare_implicit_nets(PExpr*expr)\n{\n\t/* If implicit net creation is turned off, then stop now. */\n      if (pform_default_nettype == NetNet::NONE)\n\t    return;\n\n      if (expr)\n            expr->declare_implicit_nets(lexical_scope, pform_default_nettype);\n}\n\n/*\n * The lexor calls this function to set the active timescale when it\n * detects a `timescale directive. The function saves the directive\n * values (for use by subsequent design elements) and if warnings are\n * enabled checks to see if some design elements have no timescale.\n */\nvoid pform_set_timescale(int unit, int prec,\n\t\t\t const char*file, unsigned lineno)\n{\n      assert(unit >= prec);\n      pform_time_unit = unit;\n      pform_time_prec = prec;\n\n      if (pform_timescale_file) {\n\t    free(pform_timescale_file);\n      }\n\n      if (file) pform_timescale_file = strdup(file);\n      else pform_timescale_file = 0;\n      pform_timescale_line = lineno;\n}\n\nbool get_time_unit(const char*cp, int &unit)\n{\n\tconst char *c;\n\tbool        rc = true;\n\n\tif (strchr(cp, '_')) {\n\t\tVLerror(yylloc, \"error: Invalid timeunit constant ('_' is not \"\n\t\t\t\t\"supported).\");\n\t\treturn false;\n\t}\n\n\tc = strpbrk(cp, \"munpfs\");\n\tif (!c)\n\t\treturn false;\n\n\tif (*c == 's')\n\t\tunit = 0;\n\telse if (!strncmp(c, \"ms\", 2))\n\t\tunit = -3;\n\telse if (!strncmp(c, \"us\", 2))\n\t\tunit = -6;\n\telse if (!strncmp(c, \"ns\", 2))\n\t\tunit = -9;\n\telse if (!strncmp(c, \"ps\", 2))\n\t\tunit = -12;\n\telse if (!strncmp(c, \"fs\", 2))\n\t\tunit = -15;\n\telse {\n\t\trc = false;\n\n\t\tostringstream msg;\n\t\tmsg << \"error: Invalid timeunit scale '\" << cp << \"'.\";\n\t\tVLerror(msg.str().c_str());\n\t}\n\n\treturn rc;\n}\n\n/*\n * Get a timeunit or timeprecision value from a string.  This is\n * similar to the code in lexor.lex for the `timescale directive.\n */\nstatic bool get_time_unit_prec(const char*cp, int &res, bool is_unit)\n{\n\t/* We do not support a '_' in these time constants. */\n      if (strchr(cp, '_')) {\n\t    if (is_unit) {\n\t\t  VLerror(yylloc, \"error: Invalid timeunit constant ('_' \"\n\t\t                  \"is not supported).\");\n\t    } else {\n\t\t  VLerror(yylloc, \"error: Invalid timeprecision constant ('_' \"\n\t\t                  \"is not supported).\");\n\t    }\n\t    return true;\n      }\n\n\t/* Check for the 1 digit. */\n      if (*cp != '1') {\n\t    if (is_unit) {\n\t\t  VLerror(yylloc, \"error: Invalid timeunit constant \"\n                                  \"(1st digit).\");\n\t    } else {\n\t\t  VLerror(yylloc, \"error: Invalid timeprecision constant \"\n                                  \"(1st digit).\");\n\t    }\n\t    return true;\n      }\n      cp += 1;\n\n\t/* Check the number of zeros after the 1. */\n      res = strspn(cp, \"0\");\n      if (res > 2) {\n\t    if (is_unit) {\n\t\t  VLerror(yylloc, \"error: Invalid timeunit constant \"\n\t\t                  \"(number of zeros).\");\n\t    } else {\n\t\t  VLerror(yylloc, \"error: Invalid timeprecision constant \"\n\t\t                  \"(number of zeros).\");\n\t    }\n\t    return true;\n      }\n      cp += res;\n\n\t/* Now process the scaling string. */\n      if (strncmp(\"s\", cp, 1) == 0) {\n\t    res -= 0;\n\t    return false;\n\n      } else if (strncmp(\"ms\", cp, 2) == 0) {\n\t    res -= 3;\n\t    return false;\n\n      } else if (strncmp(\"us\", cp, 2) == 0) {\n\t    res -= 6;\n\t    return false;\n\n      } else if (strncmp(\"ns\", cp, 2) == 0) {\n\t    res -= 9;\n\t    return false;\n\n      } else if (strncmp(\"ps\", cp, 2) == 0) {\n\t    res -= 12;\n\t    return false;\n\n      } else if (strncmp(\"fs\", cp, 2) == 0) {\n\t    res -= 15;\n\t    return false;\n\n      }\n\n      ostringstream msg;\n      msg << \"error: Invalid \";\n      if (is_unit) msg << \"timeunit\";\n      else msg << \"timeprecision\";\n      msg << \" scale '\" << cp << \"'.\";\n      VLerror(msg.str().c_str());\n      return true;\n}\n\nvoid pform_set_timeunit(const char*txt, bool initial_decl)\n{\n      int val;\n\n      if (get_time_unit_prec(txt, val, true)) return;\n\n      PScopeExtra*scope = dynamic_cast<PScopeExtra*>(lexical_scope);\n      if (!scope)\n\t    return;\n\n      if (initial_decl) {\n            scope->time_unit = val;\n            scope->time_unit_is_local = true;\n            scope->time_unit_is_default = false;\n            allow_timeunit_decl = false;\n      } else if (!scope->time_unit_is_local) {\n            VLerror(yylloc, \"error: Repeat timeunit found and the initial \"\n                            \"timeunit for this scope is missing.\");\n      } else if (scope->time_unit != val) {\n            VLerror(yylloc, \"error: Repeat timeunit does not match the \"\n                            \"initial timeunit for this scope.\");\n      }\n}\n\nint pform_get_timeunit()\n{\n      PScopeExtra*scopex = find_nearest_scopex(lexical_scope);\n      assert(scopex);\n      return scopex->time_unit;\n}\n\nint pform_get_timeprec()\n{\n      PScopeExtra*scopex = find_nearest_scopex(lexical_scope);\n      assert(scopex);\n      return scopex->time_precision;\n}\n\nvoid pform_set_timeprec(const char*txt, bool initial_decl)\n{\n      int val;\n\n      if (get_time_unit_prec(txt, val, false)) return;\n\n      PScopeExtra*scope = dynamic_cast<PScopeExtra*>(lexical_scope);\n      if (!scope)\n\t    return;\n\n      if (initial_decl) {\n            scope->time_precision = val;\n            scope->time_prec_is_local = true;\n            scope->time_prec_is_default = false;\n            allow_timeprec_decl = false;\n      } else if (!scope->time_prec_is_local) {\n            VLerror(yylloc, \"error: Repeat timeprecision found and the initial \"\n                            \"timeprecision for this scope is missing.\");\n      } else if (scope->time_precision != val) {\n            VLerror(yylloc, \"error: Repeat timeprecision does not match the \"\n                            \"initial timeprecision for this scope.\");\n      }\n}\n\nverinum* pform_verinum_with_size(verinum*siz, verinum*val,\n\t\t\t\t const char*file, unsigned lineno)\n{\n      assert(siz->is_defined());\n      unsigned long size = siz->as_ulong();\n\n      if (size == 0) {\n\t    cerr << file << \":\" << lineno << \": error: Sized numeric constant \"\n\t\t    \"must have a size greater than zero.\" << endl;\n\t    error_count += 1;\n      }\n\n      verinum::V pad;\n\n      if (val->len() == 0) {\n\t    pad = verinum::Vx;\n      } else {\n\n\t    switch (val->get(val->len()-1)) {\n\t\tcase verinum::Vz:\n\t\t  pad = verinum::Vz;\n\t\t  break;\n\t\tcase verinum::Vx:\n\t\t  pad = verinum::Vx;\n\t\t  break;\n\t\tdefault:\n\t\t  pad = verinum::V0;\n\t\t  break;\n\t    }\n      }\n\n      verinum*res = new verinum(pad, size, true);\n\n      unsigned copy = val->len();\n      if (res->len() < copy)\n\t    copy = res->len();\n\n      for (unsigned idx = 0 ;  idx < copy ;  idx += 1) {\n\t    res->set(idx, val->get(idx));\n      }\n\n      res->has_sign(val->has_sign());\n\n      bool trunc_flag = false;\n      for (unsigned idx = copy ;  idx < val->len() ;  idx += 1) {\n\t    if (val->get(idx) != pad) {\n\t\t  trunc_flag = true;\n\t\t  break;\n\t    }\n      }\n\n      if (trunc_flag) {\n\t    cerr << file << \":\" << lineno << \": warning: Numeric constant \"\n\t\t << \"truncated to \" << copy << \" bits.\" << endl;\n      }\n\n      delete siz;\n      delete val;\n      return res;\n}\n\nvoid pform_startmodule(const struct vlltype&loc, const char*name,\n\t\t       bool program_block, bool is_interface,\n\t\t       LexicalScope::lifetime_t lifetime,\n\t\t       list<named_pexpr_t>*attr)\n{\n      if (! pform_cur_module.empty() && !gn_system_verilog()) {\n\t    cerr << loc << \": error: Module definition \" << name\n\t\t << \" cannot nest into module \" << pform_cur_module.front()->mod_name() << \".\" << endl;\n\t    error_count += 1;\n      }\n\n\n      if (lifetime != LexicalScope::INHERITED) {\n\t    pform_requires_sv(loc, \"Default subroutine lifetime\");\n      }\n\n      if (gn_system_verilog() && ! pform_cur_module.empty()) {\n\t    if (pform_cur_module.front()->program_block) {\n\t\t  cerr << loc << \": error: module, program, or interface \"\n\t\t\t\t \"declarations are not allowed in program \"\n\t\t\t\t \"blocks.\" << endl;\n\t\t  error_count += 1;\n\t    }\n\t    if (pform_cur_module.front()->is_interface\n\t\t&& !(program_block || is_interface)) {\n\t\t  cerr << loc << \": error: module declarations are not \"\n\t\t\t\t \"allowed in interfaces.\" << endl;\n\t\t  error_count += 1;\n\t    }\n      }\n\n      perm_string lex_name = lex_strings.make(name);\n      Module*cur_module = new Module(lexical_scope, lex_name);\n      cur_module->program_block = program_block;\n      cur_module->is_interface = is_interface;\n      cur_module->default_lifetime = find_lifetime(lifetime);\n\n      FILE_NAME(cur_module, loc);\n\n      cur_module->library_flag = pform_library_flag;\n\n      pform_cur_module.push_front(cur_module);\n\n      allow_timeunit_decl = true;\n      allow_timeprec_decl = true;\n\n      pform_generate_single_item = false;\n\n      add_local_symbol(lexical_scope, lex_name, cur_module);\n\n      lexical_scope = cur_module;\n\n      pform_bind_attributes(cur_module->attributes, attr);\n}\n\nvoid pform_start_parameter_port_list()\n{\n      pform_in_parameter_port_list = true;\n      pform_peek_scope()->has_parameter_port_list = true;\n}\n\nvoid pform_end_parameter_port_list()\n{\n      pform_in_parameter_port_list = false;\n}\n\n/*\n * This function is called by the parser to make a simple port\n * reference. This is a name without a .X(...), so the internal name\n * should be generated to be the same as the X.\n */\nModule::port_t* pform_module_port_reference(const struct vlltype&loc,\n\t\t\t\t\t    perm_string name)\n{\n      Module::port_t*ptmp = new Module::port_t;\n      PEIdent*tmp = new PEIdent(name, loc.lexical_pos);\n      FILE_NAME(tmp, loc);\n      ptmp->name = name;\n      ptmp->expr.push_back(tmp);\n      ptmp->default_value = 0;\n\n      return ptmp;\n}\n\nvoid pform_module_set_ports(vector<Module::port_t*>*ports)\n{\n      assert(! pform_cur_module.empty());\n\n\t/* The parser parses ``module foo()'' as having one\n\t   unconnected port, but it is really a module with no\n\t   ports. Fix it up here. */\n      if (ports && (ports->size() == 1) && ((*ports)[0] == 0)) {\n\t    delete ports;\n\t    ports = 0;\n      }\n\n      if (ports != 0) {\n\t    pform_cur_module.front()->ports = *ports;\n\t    delete ports;\n      }\n}\n\nvoid pform_endmodule(const char*name, bool inside_celldefine,\n                     Module::UCDriveType uc_drive_def)\n{\n\t// The parser will not call pform_endmodule() without first\n\t// calling pform_startmodule(). Thus, it is impossible for the\n\t// pform_cur_module stack to be empty at this point.\n      assert(! pform_cur_module.empty());\n      Module*cur_module  = pform_cur_module.front();\n      pform_cur_module.pop_front();\n      perm_string mod_name = cur_module->mod_name();\n\n\t// Oops, there may be some sort of nesting problem. If\n\t// SystemVerilog is activated, it is possible for modules to\n\t// be nested. But if the nested module is broken, the parser\n\t// will recover and treat is as an invalid module item,\n\t// leaving the pform_cur_module stack in an inconsistent\n\t// state. For example, this:\n\t//    module foo;\n\t//      module bar blah blab blah error;\n\t//    endmodule\n\t// may leave the pform_cur_module stack with the dregs of the\n\t// bar module. Try to find the foo module in the stack, and\n\t// print error messages as we go.\n      if (strcmp(name, mod_name) != 0) {\n\t    while (!pform_cur_module.empty()) {\n\t\t  Module*tmp_module = pform_cur_module.front();\n\t\t  perm_string tmp_name = tmp_module->mod_name();\n\t\t  pform_cur_module.pop_front();\n\t\t  ostringstream msg;\n\t\t  msg << \"error: Module \" << mod_name\n\t\t      << \" was nested within \" << tmp_name\n\t\t      << \" but broken.\";\n\t\t  VLerror(msg.str().c_str());\n\n\t\t  ivl_assert(*cur_module, lexical_scope == cur_module);\n\t\t  pform_pop_scope();\n\t\t  delete cur_module;\n\n\t\t  cur_module = tmp_module;\n\t\t  mod_name = tmp_name;\n\t\t  if (strcmp(name, mod_name) == 0)\n\t\t\tbreak;\n\t    }\n      }\n      assert(strcmp(name, mod_name) == 0);\n\n      cur_module->is_cell = inside_celldefine;\n      cur_module->uc_drive = uc_drive_def;\n\n\t// If this is a root module, then there is no parent module\n\t// and we try to put this newly defined module into the global\n\t// root list of modules. Otherwise, this is a nested module\n\t// and we put it into the parent module scope to be elaborated\n\t// if needed.\n      map<perm_string,Module*>&use_module_map = (pform_cur_module.empty())\n\t    ? pform_modules\n\t    : pform_cur_module.front()->nested_modules;\n\n      map<perm_string,Module*>::const_iterator test =\n\t    use_module_map.find(mod_name);\n\n      if (test != use_module_map.end()) {\n\t    ostringstream msg;\n\t    msg << \"error: Module \" << name << \" was already declared here: \"\n\t\t<< test->second->get_fileline() << endl;\n\t    VLerror(msg.str().c_str());\n      } else {\n\t    use_module_map[mod_name] = cur_module;\n      }\n\n\t// The current lexical scope should be this module by now.\n      ivl_assert(*cur_module, lexical_scope == cur_module);\n      pform_pop_scope();\n}\n\nvoid pform_genvars(const struct vlltype&li, list<pform_ident_t>*names)\n{\n      list<pform_ident_t>::const_iterator cur;\n      for (cur = names->begin(); cur != names->end() ; *cur++) {\n\t    PGenvar*genvar = new PGenvar();\n\t    FILE_NAME(genvar, li);\n\n\t    if (pform_cur_generate) {\n\t\t  add_local_symbol(pform_cur_generate, cur->first, genvar);\n\t\t  pform_cur_generate->genvars[cur->first] = genvar;\n\t    } else {\n\t\t  add_local_symbol(pform_cur_module.front(), cur->first, genvar);\n\t\t  pform_cur_module.front()->genvars[cur->first] = genvar;\n\t    }\n      }\n\n      delete names;\n}\n\nstatic unsigned detect_directly_nested_generate()\n{\n      if (pform_cur_generate && pform_generate_single_item)\n\t    switch (pform_cur_generate->scheme_type) {\n\t\tcase PGenerate::GS_CASE_ITEM:\n\t\t  // fallthrough\n\t\tcase PGenerate::GS_CONDIT:\n\t\t  // fallthrough\n\t\tcase PGenerate::GS_ELSE:\n\t\t  pform_cur_generate->directly_nested = true;\n\t\t  return pform_cur_generate->id_number;\n\t\tdefault:\n\t\t  break;\n\t    }\n\n      return ++lexical_scope->generate_counter;\n}\n\nvoid pform_start_generate_for(const struct vlltype&li,\n\t\t\t      bool local_index,\n\t\t\t      char*ident1, PExpr*init,\n\t\t\t      PExpr*test,\n\t\t\t      char*ident2, PExpr*next)\n{\n      PGenerate*gen = new PGenerate(lexical_scope, ++lexical_scope->generate_counter);\n      lexical_scope = gen;\n\n      FILE_NAME(gen, li);\n\n      pform_cur_generate = gen;\n\n      pform_cur_generate->scheme_type = PGenerate::GS_LOOP;\n\n      pform_cur_generate->local_index = local_index;\n      pform_cur_generate->loop_index = lex_strings.make(ident1);\n      pform_cur_generate->loop_init = init;\n      pform_cur_generate->loop_test = test;\n      pform_cur_generate->loop_step = next;\n\n      delete[]ident1;\n      delete[]ident2;\n}\n\nvoid pform_start_generate_if(const struct vlltype&li, PExpr*test)\n{\n      unsigned id_number = detect_directly_nested_generate();\n\n      PGenerate*gen = new PGenerate(lexical_scope, id_number);\n      lexical_scope = gen;\n\n      FILE_NAME(gen, li);\n\n      pform_cur_generate = gen;\n\n      pform_cur_generate->scheme_type = PGenerate::GS_CONDIT;\n\n      pform_cur_generate->loop_init = 0;\n      pform_cur_generate->loop_test = test;\n      pform_cur_generate->loop_step = 0;\n\n      conditional_block_names.push_front(set<perm_string>());\n}\n\nvoid pform_start_generate_else(const struct vlltype&li)\n{\n      ivl_assert(li, pform_cur_generate);\n      ivl_assert(li, pform_cur_generate->scheme_type == PGenerate::GS_CONDIT);\n\n      PGenerate*cur = pform_cur_generate;\n      pform_endgenerate(false);\n\n      PGenerate*gen = new PGenerate(lexical_scope, cur->id_number);\n      lexical_scope = gen;\n\n      FILE_NAME(gen, li);\n\n      pform_cur_generate = gen;\n\n      pform_cur_generate->scheme_type = PGenerate::GS_ELSE;\n\n      pform_cur_generate->loop_init = 0;\n      pform_cur_generate->loop_test = cur->loop_test;\n      pform_cur_generate->loop_step = 0;\n}\n\n/*\n * The GS_CASE version of the PGenerate contains only case items. The\n * items in turn contain the generated items themselves.\n */\nvoid pform_start_generate_case(const struct vlltype&li, PExpr*expr)\n{\n      unsigned id_number = detect_directly_nested_generate();\n\n      PGenerate*gen = new PGenerate(lexical_scope, id_number);\n      lexical_scope = gen;\n\n      FILE_NAME(gen, li);\n\n      pform_cur_generate = gen;\n\n      pform_cur_generate->scheme_type = PGenerate::GS_CASE;\n\n      pform_cur_generate->loop_init = 0;\n      pform_cur_generate->loop_test = expr;\n      pform_cur_generate->loop_step = 0;\n\n      conditional_block_names.push_front(set<perm_string>());\n}\n\n/*\n * The named block generate case.\n */\nvoid pform_start_generate_nblock(const struct vlltype&li, char*name)\n{\n      PGenerate*gen = new PGenerate(lexical_scope, ++lexical_scope->generate_counter);\n      lexical_scope = gen;\n\n      FILE_NAME(gen, li);\n\n      pform_cur_generate = gen;\n\n      pform_cur_generate->scheme_type = PGenerate::GS_NBLOCK;\n\n      pform_cur_generate->loop_init = 0;\n      pform_cur_generate->loop_test = 0;\n      pform_cur_generate->loop_step = 0;\n\n      pform_cur_generate->scope_name = lex_strings.make(name);\n      delete[]name;\n\n      add_local_symbol(pform_cur_generate->parent_scope(),\n                       pform_cur_generate->scope_name,\n                       pform_cur_generate);\n}\n\n/*\n * The generate case item is a special case schema that takes its id\n * from the case schema that it is a part of. The idea is that the\n * case schema can only instantiate exactly one item, so the items\n * need not have a unique number.\n */\nvoid pform_generate_case_item(const struct vlltype&li, list<PExpr*>*expr_list)\n{\n      ivl_assert(li, pform_cur_generate);\n      ivl_assert(li, pform_cur_generate->scheme_type == PGenerate::GS_CASE);\n\n      PGenerate*gen = new PGenerate(lexical_scope, pform_cur_generate->id_number);\n      lexical_scope = gen;\n\n      FILE_NAME(gen, li);\n\n      gen->directly_nested = pform_cur_generate->directly_nested;\n\n      pform_cur_generate = gen;\n\n      pform_cur_generate->scheme_type = PGenerate::GS_CASE_ITEM;\n\n      pform_cur_generate->loop_init = 0;\n      pform_cur_generate->loop_test = 0;\n      pform_cur_generate->loop_step = 0;\n\n      if (expr_list != 0) {\n\t    list<PExpr*>::iterator expr_cur = expr_list->begin();\n\t    pform_cur_generate->item_test.resize(expr_list->size());\n\t    for (unsigned idx = 0 ; idx < expr_list->size() ; idx += 1) {\n\t\t  pform_cur_generate->item_test[idx] = *expr_cur;\n\t\t  ++ expr_cur;\n\t    }\n\t    ivl_assert(li, expr_cur == expr_list->end());\n      }\n}\n\nvoid pform_generate_block_name(char*name)\n{\n      assert(pform_cur_generate != 0);\n      assert(pform_cur_generate->scope_name == 0);\n      perm_string scope_name = lex_strings.make(name);\n      pform_cur_generate->scope_name = scope_name;\n\n      if (pform_cur_generate->scheme_type == PGenerate::GS_CONDIT\n       || pform_cur_generate->scheme_type == PGenerate::GS_ELSE\n       || pform_cur_generate->scheme_type == PGenerate::GS_CASE_ITEM) {\n\n            if (conditional_block_names.front().count(scope_name))\n                  return;\n\n            conditional_block_names.front().insert(scope_name);\n      }\n\n      LexicalScope*parent_scope = pform_cur_generate->parent_scope();\n      assert(parent_scope);\n      if (pform_cur_generate->scheme_type == PGenerate::GS_CASE_ITEM)\n\t      // Skip over the PGenerate::GS_CASE container.\n\t    parent_scope = parent_scope->parent_scope();\n\n      add_local_symbol(parent_scope, scope_name, pform_cur_generate);\n}\n\nvoid pform_endgenerate(bool end_conditional)\n{\n      assert(pform_cur_generate != 0);\n      assert(! pform_cur_module.empty());\n\n      if (end_conditional)\n            conditional_block_names.pop_front();\n\n\t// If there is no explicit block name then generate a temporary\n\t// name. This will be replaced by the correct name later, once\n\t// we know all the explicit names in the surrounding scope. If\n\t// the naming scheme used here is changed, PGenerate::elaborate\n\t// must be changed to match.\n      if (pform_cur_generate->scope_name == 0) {\n\t    char tmp[16];\n\t    snprintf(tmp, sizeof tmp, \"$gen%u\", pform_cur_generate->id_number);\n\t    pform_cur_generate->scope_name = lex_strings.make(tmp);\n      }\n\n\t// The current lexical scope should be this generate construct by now\n      ivl_assert(*pform_cur_generate, lexical_scope == pform_cur_generate);\n      pform_pop_scope();\n\n      PGenerate*parent_generate = dynamic_cast<PGenerate*>(lexical_scope);\n      if (parent_generate) {\n\t    assert(pform_cur_generate->scheme_type == PGenerate::GS_CASE_ITEM\n\t\t   || parent_generate->scheme_type != PGenerate::GS_CASE);\n\t    parent_generate->generate_schemes.push_back(pform_cur_generate);\n      } else {\n\t    assert(pform_cur_generate->scheme_type != PGenerate::GS_CASE_ITEM);\n\t    pform_cur_module.front()->generate_schemes.push_back(pform_cur_generate);\n      }\n      pform_cur_generate = parent_generate;\n}\n\nvoid pform_make_elab_task(const struct vlltype&li,\n                          perm_string name,\n                          const list<named_pexpr_t> &params)\n{\n      PCallTask*elab_task = new PCallTask(name, params);\n      FILE_NAME(elab_task, li);\n\n      lexical_scope->elab_tasks.push_back(elab_task);\n}\n\nMIN_TYP_MAX min_typ_max_flag = TYP;\nunsigned min_typ_max_warn = 10;\n\nPExpr* pform_select_mtm_expr(PExpr*min, PExpr*typ, PExpr*max)\n{\n      PExpr*res = 0;\n\n      switch (min_typ_max_flag) {\n\t  case MIN:\n\t    res = min;\n\t    delete typ;\n\t    delete max;\n\t    break;\n\t  case TYP:\n\t    res = typ;\n\t    delete min;\n\t    delete max;\n\t    break;\n\t  case MAX:\n\t    res = max;\n\t    delete min;\n\t    delete typ;\n\t    break;\n      }\n\n      if (min_typ_max_warn > 0) {\n\t    cerr << res->get_fileline() << \": warning: Choosing \";\n\t    switch (min_typ_max_flag) {\n\t\tcase MIN:\n\t\t  cerr << \"min\";\n\t\t  break;\n\t\tcase TYP:\n\t\t  cerr << \"typ\";\n\t\t  break;\n\t\tcase MAX:\n\t\t  cerr << \"max\";\n\t\t  break;\n\t    }\n\n\t    cerr << \" expression.\" << endl;\n\t    min_typ_max_warn -= 1;\n      }\n\n      return res;\n}\n\nstatic void process_udp_table(PUdp*udp, list<string>*table,\n\t\t\t      const struct vlltype&loc)\n{\n      const bool synchronous_flag = udp->sequential;\n\n\t/* Interpret and check the table entry strings, to make sure\n\t   they correspond to the inputs, output and output type. Make\n\t   up vectors for the fully interpreted result that can be\n\t   placed in the PUdp object.\n\n\t   The table strings are made up by the parser to be two or\n\t   three substrings separated by ':', i.e.:\n\n\t   0101:1:1  (synchronous device entry)\n\t   0101:0    (combinational device entry)\n\n\t   The parser doesn't check that we got the right kind here,\n\t   so this loop must watch out. */\n      std::vector<string> &input   = udp->tinput;\n      std::vector<char>   &current = udp->tcurrent;\n      std::vector<char>   &output  = udp->toutput;\n\n      input.resize(table->size());\n      current.resize(table->size());\n      output.resize(table->size());\n\n      { unsigned idx = 0;\n        for (list<string>::iterator cur = table->begin() ;\n             cur != table->end() ; ++cur , idx += 1) {\n\t      string tmp = *cur;\n\n\t\t/* Pull the input values from the string. */\n\t      if (tmp.find(':') != (udp->ports.size()-1)) {\n\t\t    cerr << loc << \": error: \"\n\t\t         << \"The UDP input port count (\" << (udp->ports.size()-1)\n\t\t         << \") does not match the number of input table entries (\"\n\t\t         << tmp.find(':') << \") in primitive \\\"\"\n\t\t         << udp->name_ << \"\\\".\" << endl;\n\t\t    error_count += 1;\n\t\t    break;\n\t      }\n\t      input[idx] = tmp.substr(0, udp->ports.size()-1);\n\t      tmp = tmp.substr(udp->ports.size()-1);\n\n\n\t\t/* If this is a synchronous device, get the current\n\t\t   output string. */\n\t      if (synchronous_flag) {\n\t\t    assert(tmp[0] == ':');\n\t\t    assert(tmp.size() == 4);\n\t\t    current[idx] = tmp[1];\n\t\t    tmp = tmp.substr(2);\n\n\t      }\n\n\t\t/* Finally, extract the desired output. */\n\t      assert(tmp[0] == ':');\n\t      assert(tmp.size() == 2);\n\t      output[idx] = tmp[1];\n\t}\n      }\n\n}\n\nvoid pform_make_udp(const struct vlltype&loc, perm_string name,\n\t\t    list<pform_ident_t>*parms, vector<PWire*>*decl,\n\t\t    list<string>*table, Statement*init_expr)\n{\n      unsigned local_errors = 0;\n      ivl_assert(loc, !parms->empty());\n\n      ivl_assert(loc, decl);\n\n\t/* Put the declarations into a map, so that I can check them\n\t   off with the parameters in the list. If the port is already\n\t   in the map, merge the port type. I will rebuild a list\n\t   of parameters for the PUdp object. */\n      map<perm_string,PWire*> defs;\n      for (unsigned idx = 0 ;  idx < decl->size() ;  idx += 1) {\n\n\t    perm_string port_name = (*decl)[idx]->basename();\n\n\t    if (PWire*cur = defs[port_name]) {\n\t\t  ivl_assert(loc, (*decl)[idx]);\n\t\t  if ((*decl)[idx]->get_port_type() != NetNet::PIMPLICIT) {\n\t\t\tbool rc = cur->set_port_type((*decl)[idx]->get_port_type());\n\t\t\tivl_assert(loc, rc);\n\t\t  }\n\t\t  if ((*decl)[idx]->get_wire_type() != NetNet::IMPLICIT) {\n\t\t\tbool rc = cur->set_wire_type((*decl)[idx]->get_wire_type());\n\t\t\tivl_assert(loc, rc);\n\t\t  }\n\n\t    } else {\n\t\t  defs[port_name] = (*decl)[idx];\n\t    }\n      }\n\n\n\t/* Put the parameters into a vector of wire descriptions. Look\n\t   in the map for the definitions of the name. In this loop,\n\t   the parms list in the list of ports in the port list of the\n\t   UDP declaration, and the defs map maps that name to a\n\t   PWire* created by an input or output declaration. */\n      std::vector<PWire*> pins(parms->size());\n      std::vector<perm_string> pin_names(parms->size());\n      { list<pform_ident_t>::iterator cur;\n        unsigned idx;\n        for (cur = parms->begin(), idx = 0\n\t\t   ; cur != parms->end()\n\t\t   ; ++ idx, ++ cur) {\n\t      pins[idx] = defs[cur->first];\n\t      pin_names[idx] = cur->first;\n\t}\n      }\n\n\t/* Check that the output is an output and the inputs are\n\t   inputs. I can also make sure that only the single output is\n\t   declared a register, if anything. The possible errors are:\n\n\t      -- an input port (not the first) is missing an input\n\t         declaration.\n\n\t      -- An input port is declared output.\n\n\t*/\n      ivl_assert(loc, pins.size() > 0);\n      do {\n\t    if (pins[0] == 0) {\n\t\t  cerr << loc << \": error: \"\n\t\t       << \"Output port of primitive \" << name\n\t\t       << \" missing output declaration.\" << endl;\n\t\t  cerr << loc << \":      : \"\n\t\t       << \"Try: output \" << pin_names[0] << \";\"\n\t\t       << endl;\n\t\t  error_count += 1;\n\t\t  local_errors += 1;\n\t\t  break;\n\t    }\n\t    if (pins[0]->get_port_type() != NetNet::POUTPUT) {\n\t\t  cerr << loc << \": error: \"\n\t\t       << \"The first port of a primitive\"\n\t\t       << \" must be an output.\" << endl;\n\t\t  cerr << loc << \":      : \"\n\t\t       << \"Try: output \" << pin_names[0] << \";\"\n\t\t       << endl;\n\t\t  error_count += 1;\n\t\t  local_errors += 1;\n\t\t  break;;\n\t    }\n      } while (0);\n\n      for (unsigned idx = 1 ;  idx < pins.size() ;  idx += 1) {\n\t    if (pins[idx] == 0) {\n\t\t  cerr << loc << \": error: \"\n\t\t       << \"Port \" << (idx+1)\n\t\t       << \" of primitive \" << name << \" missing\"\n\t\t       << \" input declaration.\" << endl;\n\t\t  cerr << loc << \":      : \"\n\t\t       << \"Try: input \" << pin_names[idx] << \";\"\n\t\t       << endl;\n\t\t  error_count += 1;\n\t\t  local_errors += 1;\n\t\t  continue;\n\t    }\n\t    if (pins[idx]->get_port_type() != NetNet::PINPUT) {\n\t\t  cerr << loc << \": error: \"\n\t\t       << \"Input port \" << (idx+1)\n\t\t       << \" of primitive \" << name\n\t\t       << \" has an output (or missing) declaration.\" << endl;\n\t\t  cerr << loc << \":      : \"\n\t\t       << \"Note that only the first port can be an output.\"\n\t\t       << endl;\n\t\t  cerr << loc << \":      : \"\n\t\t       << \"Try \\\"input \" << name << \";\\\"\"\n\t\t       << endl;\n\t\t  error_count += 1;\n\t\t  local_errors += 1;\n\t\t  continue;\n\t    }\n\n\t    if (pins[idx]->get_wire_type() == NetNet::REG) {\n\t\t  cerr << loc << \": error: \"\n\t\t       << \"Port \" << (idx+1)\n\t\t       << \" of primitive \" << name << \" is an input port\"\n\t\t       << \" with a reg declaration.\" << endl;\n\t\t  cerr << loc << \":      : \"\n\t\t       << \"primitive inputs cannot be reg.\"\n\t\t       << endl;\n\t\t  error_count += 1;\n\t\t  local_errors += 1;\n\t\t  continue;\n\t    }\n      }\n\n      if (local_errors > 0) {\n\t    delete parms;\n\t    delete decl;\n\t    delete table;\n\t    delete init_expr;\n\t    return;\n      }\n\n\n\t/* Verify the \"initial\" statement, if present, to be sure that\n\t   it only assigns to the output and the output is\n\t   registered. Then save the initial value that I get. */\n      verinum::V init = verinum::Vx;\n      if (init_expr) {\n\t      // XXXX\n\t    ivl_assert(loc, pins[0]->get_wire_type() == NetNet::REG);\n\n\t    PAssign*pa = dynamic_cast<PAssign*>(init_expr);\n\t    ivl_assert(*init_expr, pa);\n\n\t    const PEIdent*id = dynamic_cast<const PEIdent*>(pa->lval());\n\t    ivl_assert(*init_expr, id);\n\n\t      // XXXX\n\t      //ivl_assert(*init_expr, id->name() == pins[0]->name());\n\n\t    const PENumber*np = dynamic_cast<const PENumber*>(pa->rval());\n\t    ivl_assert(*init_expr, np);\n\n\t    init = np->value()[0];\n      }\n\n\t// Put the primitive into the primitives table\n      if (pform_primitives[name]) {\n\t    VLwarn(\"warning: UDP primitive already exists.\");\n\n      } else {\n\t    PUdp*udp = new PUdp(name, parms->size());\n\t    FILE_NAME(udp, loc);\n\n\t      // Detect sequential udp.\n\t    if (pins[0]->get_wire_type() == NetNet::REG)\n\t\t  udp->sequential = true;\n\n\t      // Make the port list for the UDP\n\t    for (unsigned idx = 0 ;  idx < pins.size() ;  idx += 1)\n\t\t  udp->ports[idx] = pins[idx]->basename();\n\n\t    process_udp_table(udp, table, loc);\n\t    udp->initial  = init;\n\n\t    pform_primitives[name] = udp;\n      }\n\n\n\t/* Delete the excess tables and lists from the parser. */\n      delete parms;\n      delete decl;\n      delete table;\n      delete init_expr;\n}\n\nvoid pform_make_udp(const struct vlltype&loc, perm_string name,\n\t\t    bool synchronous_flag, const pform_ident_t&out_name,\n\t\t    PExpr*init_expr, list<pform_ident_t>*parms,\n\t\t    list<string>*table)\n{\n\n      std::vector<PWire*> pins(parms->size() + 1);\n\n\t/* Make the PWire for the output port. */\n      pins[0] = new PWire(out_name.first, out_name.second,\n\t\t\t  synchronous_flag? NetNet::REG : NetNet::WIRE,\n\t\t\t  NetNet::POUTPUT);\n      FILE_NAME(pins[0], loc);\n\n\t/* Make the PWire objects for the input ports. */\n      { list<pform_ident_t>::iterator cur;\n        unsigned idx;\n        for (cur = parms->begin(), idx = 1\n\t\t   ;  cur != parms->end()\n\t\t   ;  idx += 1, ++ cur) {\n\t      ivl_assert(loc, idx < pins.size());\n\t      pins[idx] = new PWire(cur->first, cur->second, NetNet::WIRE,\n\t\t\t\t    NetNet::PINPUT);\n\t      FILE_NAME(pins[idx], loc);\n\t}\n\tivl_assert(loc, idx == pins.size());\n      }\n\n\t/* Verify the initial expression, if present, to be sure that\n\t   it only assigns to the output and the output is\n\t   registered. Then save the initial value that I get. */\n      verinum::V init = verinum::Vx;\n      if (init_expr) {\n\t      // XXXX\n\t    ivl_assert(*init_expr, pins[0]->get_wire_type() == NetNet::REG);\n\n\t    PAssign*pa = dynamic_cast<PAssign*>(init_expr);\n\t    ivl_assert(*init_expr, pa);\n\n\t    const PEIdent*id = dynamic_cast<const PEIdent*>(pa->lval());\n\t    ivl_assert(*init_expr, id);\n\n\t      // XXXX\n\t      //ivl_assert(*init_expr, id->name() == pins[0]->name());\n\n\t    const PENumber*np = dynamic_cast<const PENumber*>(pa->rval());\n\t    ivl_assert(*init_expr, np);\n\n\t    init = np->value()[0];\n      }\n\n\t// Put the primitive into the primitives table\n      if (pform_primitives[name]) {\n\t    ostringstream msg;\n\t    msg << \"error: Primitive \" << name << \" was already declared here: \"\n\t\t<< pform_primitives[name]->get_fileline() << endl;\n\t      // Some compilers warn if there is just a single C string.\n\t    VLerror(loc, msg.str().c_str(), \"\");\n\n      } else {\n\t    PUdp*udp = new PUdp(name, pins.size());\n\t    FILE_NAME(udp, loc);\n\n\t      // Detect sequential udp.\n\t    udp->sequential = synchronous_flag;\n\n\t      // Make the port list for the UDP\n\t    for (unsigned idx = 0 ;  idx < pins.size() ;  idx += 1)\n\t\t  udp->ports[idx] = pins[idx]->basename();\n\n\t    ivl_assert(loc, udp);\n\t    if (table) {\n\t\t  process_udp_table(udp, table, loc);\n\t\t  udp->initial  = init;\n\n\t\t  pform_primitives[name] = udp;\n\t    } else {\n\t\t  ostringstream msg;\n\t\t  msg << \"error: Invalid table for UDP primitive \" << name\n\t\t      << \".\" << endl;\n\t\t    // Some compilers warn if there is just a single C string.\n\t\t  VLerror(loc, msg.str().c_str(), \"\");\n\t    }\n      }\n\n      delete parms;\n      delete table;\n      delete init_expr;\n}\n\n/*\n * This function attaches a range to a given name. The function is\n * only called by the parser within the scope of the net declaration,\n * and the name that I receive only has the tail component.\n */\nstatic void pform_set_net_range(PWire *wire,\n\t\t\t        const vector_type_t *vec_type,\n\t\t\t\tPWSRType rt = SR_NET,\n\t\t\t\tstd::list<named_pexpr_t>*attr = 0)\n{\n      pform_bind_attributes(wire->attributes, attr, true);\n\n      if (!vec_type)\n\t    return;\n\n      list<pform_range_t> *range = vec_type->pdims.get();\n      if (range)\n\t    wire->set_range(*range, rt);\n      wire->set_signed(vec_type->signed_flag);\n}\n\n/*\n * This is invoked to make a named event. This is the declaration of\n * the event, and not necessarily the use of it.\n */\nstatic void pform_make_event(const struct vlltype&loc, const pform_ident_t&name)\n{\n      PEvent*event = new PEvent(name.first, name.second);\n      FILE_NAME(event, loc);\n\n      add_local_symbol(lexical_scope, name.first, event);\n      lexical_scope->events[name.first] = event;\n}\n\nvoid pform_make_events(const struct vlltype&loc, const list<pform_ident_t>*names)\n{\n      for (auto cur = names->begin() ;  cur != names->end() ; ++ cur ) {\n\t    pform_make_event(loc, *cur);\n      }\n\n      delete names;\n}\n\n/*\n * pform_makegates is called when a list of gates (with the same type)\n * are ready to be instantiated. The function runs through the list of\n * gates and calls the pform_makegate function to make the individual gate.\n */\nstatic void pform_makegate(PGBuiltin::Type type,\n\t\t\t   struct str_pair_t str,\n\t\t\t   list<PExpr*>* delay,\n\t\t\t   const lgate&info,\n\t\t\t   list<named_pexpr_t>*attr)\n{\n      if (info.parms_by_name) {\n\t    cerr << info.get_fileline() << \": error: Gates do not have port names.\"\n\t\t << endl;\n\t    error_count += 1;\n\t    return;\n      }\n\n      if (info.parms) {\n\t    for (list<PExpr*>::iterator cur = info.parms->begin()\n\t\t       ; cur != info.parms->end() ; ++cur) {\n\t\t  pform_declare_implicit_nets(*cur);\n\t    }\n      }\n\n      perm_string dev_name = lex_strings.make(info.name);\n      PGBuiltin*cur = new PGBuiltin(type, dev_name, info.parms, delay);\n      cur->set_ranges(info.ranges);\n\n\t// The pform_makegates() that calls me will take care of\n\t// deleting the attr pointer, so tell the\n\t// pform_bind_attributes function to keep the attr object.\n      pform_bind_attributes(cur->attributes, attr, true);\n\n      cur->strength0(str.str0);\n      cur->strength1(str.str1);\n      cur->set_line(info);\n\n      if (pform_cur_generate) {\n\t    if (dev_name != \"\") add_local_symbol(pform_cur_generate, dev_name, cur);\n\t    pform_cur_generate->add_gate(cur);\n      } else {\n\t    if (dev_name != \"\") add_local_symbol(pform_cur_module.front(), dev_name, cur);\n\t    pform_cur_module.front()->add_gate(cur);\n      }\n}\n\nvoid pform_makegates(const struct vlltype&loc,\n\t\t     PGBuiltin::Type type,\n\t\t     struct str_pair_t str,\n\t\t     list<PExpr*>*delay,\n\t\t     std::vector<lgate>*gates,\n\t\t     list<named_pexpr_t>*attr)\n{\n      ivl_assert(loc, !pform_cur_module.empty());\n      if (pform_cur_module.front()->program_block) {\n\t    cerr << loc << \": error: Gates and switches may not be instantiated in \"\n\t\t << \"program blocks.\" << endl;\n\t    error_count += 1;\n      }\n      if (pform_cur_module.front()->is_interface) {\n\t    cerr << loc << \": error: Gates and switches may not be instantiated in \"\n\t\t << \"interfaces.\" << endl;\n\t    error_count += 1;\n      }\n\n      for (unsigned idx = 0 ;  idx < gates->size() ;  idx += 1) {\n\t    pform_makegate(type, str, delay, (*gates)[idx], attr);\n      }\n\n      if (attr) delete attr;\n      delete gates;\n}\n\n/*\n * A module is different from a gate in that there are different\n * constraints, and sometimes different syntax. The X_modgate\n * functions handle the instantiations of modules (and UDP objects) by\n * making PGModule objects.\n *\n * The first pform_make_modgate handles the case of a module\n * instantiated with ports passed by position. The \"wires\" is an\n * ordered array of port expressions.\n *\n * The second pform_make_modgate handles the case of a module\n * instantiated with ports passed by name. The \"bind\" argument is the\n * ports matched with names.\n */\nstatic void pform_make_modgate(perm_string type,\n\t\t\t       perm_string name,\n\t\t\t       struct parmvalue_t*overrides,\n\t\t\t       list<PExpr*>*wires,\n\t\t\t       list<pform_range_t>*ranges,\n\t\t\t       const LineInfo&li,\n\t\t\t       std::list<named_pexpr_t>*attr)\n{\n      for (list<PExpr*>::iterator idx = wires->begin()\n\t\t ; idx != wires->end() ; ++idx) {\n\t    pform_declare_implicit_nets(*idx);\n      }\n\n      PGModule*cur = new PGModule(type, name, wires);\n      cur->set_line(li);\n      cur->set_ranges(ranges);\n\n      if (overrides && overrides->by_name) {\n\t    unsigned cnt = overrides->by_name->size();\n\t    named_pexpr_t *byname = new named_pexpr_t[cnt];\n\n\t    std::copy(overrides->by_name->begin(), overrides->by_name->end(),\n\t\t      byname);\n\n\t    cur->set_parameters(byname, cnt);\n\n      } else if (overrides && overrides->by_order) {\n\t    cur->set_parameters(overrides->by_order);\n      }\n\n      if (pform_cur_generate) {\n\t    if (name != \"\") add_local_symbol(pform_cur_generate, name, cur);\n\t    pform_cur_generate->add_gate(cur);\n      } else {\n\t    if (name != \"\") add_local_symbol(pform_cur_module.front(), name, cur);\n\t    pform_cur_module.front()->add_gate(cur);\n      }\n      pform_bind_attributes(cur->attributes, attr);\n}\n\nstatic void pform_make_modgate(perm_string type,\n\t\t\t       perm_string name,\n\t\t\t       struct parmvalue_t*overrides,\n\t\t\t       list<named_pexpr_t>*bind,\n\t\t\t       list<pform_range_t>*ranges,\n\t\t\t       const LineInfo&li,\n\t\t\t       std::list<named_pexpr_t>*attr)\n{\n      unsigned npins = bind->size();\n      named_pexpr_t *pins = new named_pexpr_t[npins];\n      for (const auto &bind_cur : *bind)\n            pform_declare_implicit_nets(bind_cur.parm);\n\n      std::copy(bind->begin(), bind->end(), pins);\n\n      PGModule*cur = new PGModule(type, name, pins, npins);\n      cur->set_line(li);\n      cur->set_ranges(ranges);\n\n      if (overrides && overrides->by_name) {\n\t    unsigned cnt = overrides->by_name->size();\n\t    named_pexpr_t *byname = new named_pexpr_t[cnt];\n\n\t    std::copy(overrides->by_name->begin(), overrides->by_name->end(),\n\t\t      byname);\n\n\t    cur->set_parameters(byname, cnt);\n\n      } else if (overrides && overrides->by_order) {\n\n\t    cur->set_parameters(overrides->by_order);\n      }\n\n      if (pform_cur_generate) {\n\t    add_local_symbol(pform_cur_generate, name, cur);\n\t    pform_cur_generate->add_gate(cur);\n      } else {\n\t    add_local_symbol(pform_cur_module.front(), name, cur);\n\t    pform_cur_module.front()->add_gate(cur);\n      }\n      pform_bind_attributes(cur->attributes, attr);\n}\n\nvoid pform_make_modgates(const struct vlltype&loc,\n\t\t\t perm_string type,\n\t\t\t struct parmvalue_t*overrides,\n\t\t\t std::vector<lgate>*gates,\n\t\t\t std::list<named_pexpr_t>*attr)\n{\n\t// The grammer should not allow module gates to happen outside\n\t// an active module. But if really bad input errors combine in\n\t// an ugly way with error recovery, then catch this\n\t// implausible situation and return an error.\n      if (pform_cur_module.empty()) {\n\t    cerr << loc << \": internal error: \"\n\t\t << \"Module instantiations outside module scope are not possible.\"\n\t\t << endl;\n\t    error_count += 1;\n\t    delete gates;\n\t    return;\n      }\n      ivl_assert(loc, !pform_cur_module.empty());\n\n\t// Detect some more realistic errors.\n\n      if (pform_cur_module.front()->program_block) {\n\t    cerr << loc << \": error: Module instantiations are not allowed in \"\n\t\t << \"program blocks.\" << endl;\n\t    error_count += 1;\n      }\n      if (pform_cur_module.front()->is_interface) {\n\t    cerr << loc << \": error: Module instantiations are not allowed in \"\n\t\t << \"interfaces.\" << endl;\n\t    error_count += 1;\n      }\n\n      for (unsigned idx = 0 ;  idx < gates->size() ;  idx += 1) {\n\t    lgate cur = (*gates)[idx];\n\t    perm_string cur_name = lex_strings.make(cur.name);\n\n\t    if (cur.parms_by_name) {\n\t\t  pform_make_modgate(type, cur_name, overrides,\n\t\t\t\t     cur.parms_by_name, cur.ranges,\n\t\t\t\t     cur, attr);\n\n\t    } else if (cur.parms) {\n\n\t\t    /* If there are no parameters, the parser will be\n\t\t       tricked into thinking it is one empty\n\t\t       parameter. This fixes that. */\n\t\t  if ((cur.parms->size() == 1) && (cur.parms->front() == 0)) {\n\t\t\tdelete cur.parms;\n\t\t\tcur.parms = new list<PExpr*>;\n\t\t  }\n\t\t  pform_make_modgate(type, cur_name, overrides,\n\t\t\t\t     cur.parms, cur.ranges,\n\t\t\t\t     cur, attr);\n\n\t    } else {\n\t\t  list<PExpr*>*wires = new list<PExpr*>;\n\t\t  pform_make_modgate(type, cur_name, overrides,\n\t\t\t\t     wires, cur.ranges,\n\t\t\t\t     cur, attr);\n\t    }\n      }\n\n      delete gates;\n}\n\nstatic PGAssign* pform_make_pgassign(PExpr*lval, PExpr*rval,\n\t\t\t      list<PExpr*>*del,\n\t\t\t      struct str_pair_t str)\n{\n        /* Implicit declaration of nets on the LHS of a continuous\n           assignment was introduced in IEEE1364-2001. */\n      if (generation_flag != GN_VER1995)\n            pform_declare_implicit_nets(lval);\n\n      list<PExpr*>*wires = new list<PExpr*>;\n      wires->push_back(lval);\n      wires->push_back(rval);\n\n      PGAssign*cur;\n\n      if (del == 0)\n\t    cur = new PGAssign(wires);\n      else\n\t    cur = new PGAssign(wires, del);\n\n      cur->strength0(str.str0);\n      cur->strength1(str.str1);\n\n      if (pform_cur_generate)\n\t    pform_cur_generate->add_gate(cur);\n      else\n\t    pform_cur_module.front()->add_gate(cur);\n\n      return cur;\n}\n\nvoid pform_make_pgassign_list(const struct vlltype&loc,\n\t\t\t      list<PExpr*>*alist,\n\t\t\t      list<PExpr*>*del,\n\t\t\t      struct str_pair_t str)\n{\n      ivl_assert(loc, alist->size() % 2 == 0);\n      while (! alist->empty()) {\n\t    PExpr*lval = alist->front(); alist->pop_front();\n\t    PExpr*rval = alist->front(); alist->pop_front();\n\t    PGAssign*tmp = pform_make_pgassign(lval, rval, del, str);\n\t    FILE_NAME(tmp, loc);\n      }\n}\n\n/*\n * This function makes the initial assignment to a variable as given\n * in the source. It handles the case where a variable is assigned\n * where it is declared, e.g.\n *\n *    reg foo = <expr>;\n *\n * In Verilog-2001 this is only supported at the module level, and is\n * equivalent to the combination of statements:\n *\n *    reg foo;\n *    initial foo = <expr>;\n *\n * In SystemVerilog, variable initializations are allowed in any scope.\n * For static variables, initializations are performed before the start\n * of simulation. For automatic variables, initializations are performed\n * each time the enclosing block is entered. Here we store the variable\n * assignments in the current scope, and later elaboration creates an\n * initialization block that will be executed at the appropriate time.\n *\n * This syntax is not part of the IEEE1364-1995 standard, but is\n * approved by OVI as enhancement BTF-B14.\n */\nvoid pform_make_var_init(const struct vlltype&li, const pform_ident_t&name,\n\t\t\t PExpr*expr)\n{\n      if (! pform_at_module_level() && !gn_system_verilog()) {\n\t    VLerror(li, \"error: Variable declaration assignments are only \"\n                        \"allowed at the module level.\");\n\t    delete expr;\n\t    return;\n      }\n\n      PEIdent*lval = new PEIdent(name.first, name.second);\n      FILE_NAME(lval, li);\n      PAssign*ass = new PAssign(lval, expr, !gn_system_verilog(), true);\n      FILE_NAME(ass, li);\n\n      lexical_scope->var_inits.push_back(ass);\n}\n\n/*\n * This function makes a single signal (a wire, a reg, etc) as\n * requested by the parser. The name is unscoped, so I attach the\n * current scope to it (with the scoped_name function) and I try to\n * resolve it with an existing PWire in the scope.\n *\n * The wire might already exist because of an implicit declaration in\n * a module port, i.e.:\n *\n *     module foo (bar...\n *\n *         reg bar;\n *\n * The output (or other port direction indicator) may or may not have\n * been seen already, so I do not do any checking with it yet. But I\n * do check to see if the name has already been declared, as this\n * function is called for every declaration.\n */\n\n\nstatic PWire* pform_get_or_make_wire(const struct vlltype&li,\n\t\t\t\t     const pform_ident_t&name,\n\t\t\t\t     NetNet::Type type,\n\t\t\t\t     NetNet::PortType ptype,\n\t\t\t\t     PWSRType rt)\n{\n      PWire *cur = 0;\n\n\t// If this is not a full declaration check if there is already a signal\n\t// with the same name that can be extended.\n      if (rt != SR_BOTH)\n\t    cur = pform_get_wire_in_scope(name.first);\n\n\t// If the wire already exists but isn't yet fully defined,\n\t// carry on adding details.\n      if (rt == SR_NET && cur && !cur->is_net()) {\n\t      // At the moment there can only be one location for the PWire, if\n\t      // there is both a port and signal declaration use the location of\n\t      // the signal.\n\t    FILE_NAME(cur, li);\n\t    cur->set_net(type);\n\t    return cur;\n      }\n\n      if (rt == SR_PORT && cur && !cur->is_port()) {\n\t    cur->set_port(ptype);\n\t    return cur;\n      }\n\n\t// If the wire already exists and is fully defined, this\n\t// must be a redeclaration. Start again with a new wire.\n\t// The error will be reported when we add the new wire\n\t// to the scope. Do not delete the old wire - it will\n\t// remain in the local symbol map.\n\n      cur = new PWire(name.first, name.second, type, ptype, rt);\n      FILE_NAME(cur, li);\n\n      pform_put_wire_in_scope(name.first, cur);\n\n      return cur;\n}\n\n\n/*\n * This function is used by the parser when I have port definition of\n * the form like this:\n *\n *     input wire signed [7:0] nm;\n *\n * The port_type, type, signed_flag and range are known all at once,\n * so we can create the PWire object all at once instead of piecemeal\n * as is done for the old method.\n */\nvoid pform_module_define_port(const struct vlltype&li,\n\t\t\t      const pform_ident_t&name,\n\t\t\t      NetNet::PortType port_kind,\n\t\t\t      NetNet::Type type,\n\t\t\t      data_type_t*vtype,\n\t\t\t      list<pform_range_t>*urange,\n\t\t\t      list<named_pexpr_t>*attr,\n\t\t\t      bool keep_attr)\n{\n      pform_check_net_data_type(li, type, vtype);\n\n      PWire *cur = pform_get_or_make_wire(li, name, type, port_kind, SR_BOTH);\n\n      pform_set_net_range(cur, dynamic_cast<vector_type_t*> (vtype), SR_BOTH);\n\n      if (vtype)\n\t    cur->set_data_type(vtype);\n\n      if (urange) {\n\t    cur->set_unpacked_idx(*urange);\n\t    delete urange;\n      }\n\n      pform_bind_attributes(cur->attributes, attr, keep_attr);\n}\n\nvoid pform_module_define_port(const struct vlltype&li,\n\t\t\t      list<pform_port_t>*ports,\n\t\t\t      NetNet::PortType port_kind,\n\t\t\t      NetNet::Type type,\n\t\t\t      data_type_t*vtype,\n\t\t\t      list<named_pexpr_t>*attr)\n{\n      for (list<pform_port_t>::iterator cur = ports->begin()\n\t\t ; cur != ports->end() ; ++ cur ) {\n\n\t    data_type_t*use_type = vtype;\n\n\t    pform_module_define_port(li, cur->name, port_kind, type, use_type,\n\t\t\t\t     cur->udims, attr, true);\n\n\t    if (cur->expr)\n\t\t  pform_make_var_init(li, cur->name, cur->expr);\n      }\n\n      delete ports;\n      delete attr;\n}\n\n/*\n * this is the basic form of pform_makewire. This takes a single simple\n * name, port type, net type, data type, and attributes, and creates\n * the variable/net. Other forms of pform_makewire ultimately call\n * this one to create the wire and stash it.\n */\nPWire *pform_makewire(const vlltype&li, const pform_ident_t&name,\n\t\t      NetNet::Type type, std::list<pform_range_t> *indices)\n{\n      PWire*cur = pform_get_or_make_wire(li, name, type, NetNet::NOT_A_PORT, SR_NET);\n      ivl_assert(li, cur);\n\n      if (indices && !indices->empty())\n\t    cur->set_unpacked_idx(*indices);\n\n      return cur;\n}\n\nvoid pform_makewire(const struct vlltype&li,\n\t\t    std::list<PExpr*>*delay,\n\t\t    str_pair_t str,\n\t\t    std::list<decl_assignment_t*>*assign_list,\n\t\t    NetNet::Type type,\n\t\t    data_type_t*data_type,\n\t\t    list<named_pexpr_t>*attr,\n\t\t    bool is_const)\n{\n      if (is_compilation_unit(lexical_scope) && !gn_system_verilog()) {\n\t    VLerror(li, \"error: Variable declarations must be contained within a module.\");\n\t    return;\n      }\n\n      std::vector<PWire*> *wires = new std::vector<PWire*>;\n\n      for (list<decl_assignment_t*>::iterator cur = assign_list->begin()\n\t\t ; cur != assign_list->end() ; ++ cur) {\n\t    decl_assignment_t* curp = *cur;\n\t    PWire *wire = pform_makewire(li, curp->name, type, &curp->index);\n\t    wires->push_back(wire);\n      }\n\n      pform_set_data_type(li, data_type, wires, type, attr, is_const);\n\n      while (! assign_list->empty()) {\n\t    decl_assignment_t*first = assign_list->front();\n\t    assign_list->pop_front();\n            if (PExpr*expr = first->expr.release()) {\n                  if (type == NetNet::REG || type == NetNet::IMPLICIT_REG) {\n                        pform_make_var_init(li, first->name, expr);\n                  } else {\n\t\t        PEIdent*lval = new PEIdent(first->name.first,\n\t\t\t\t\t\t   first->name.second);\n\t\t        FILE_NAME(lval, li);\n\t\t        PGAssign*ass = pform_make_pgassign(lval, expr, delay, str);\n\t\t        FILE_NAME(ass, li);\n                  }\n            }\n\t    delete first;\n      }\n}\n\n/*\n * This function is called by the parser to create task ports. The\n * resulting wire (which should be a register) is put into a list to\n * be packed into the task parameter list.\n *\n * It is possible that the wire (er, register) was already created,\n * but we know that if the name matches it is a part of the current\n * task, so in that case I just assign direction to it.\n *\n * The following example demonstrates some of the issues:\n *\n *   task foo;\n *      input a;\n *      reg a, b;\n *      input b;\n *      [...]\n *   endtask\n *\n * This function is called when the parser matches the \"input a\" and\n * the \"input b\" statements. For ``a'', this function is called before\n * the wire is declared as a register, so I create the foo.a\n * wire. For ``b'', I will find that there is already a foo.b and I\n * just set the port direction. In either case, the ``reg a, b''\n * statement is caught by the block_item non-terminal and processed\n * there.\n *\n * Ports are implicitly type reg, because it must be possible for the\n * port to act as an l-value in a procedural assignment. It is obvious\n * for output and inout ports that the type is reg, because the task\n * only contains behavior (no structure) to a procedural assignment is\n * the *only* way to affect the output. It is less obvious for input\n * ports, but in practice an input port receives its value as if by a\n * procedural assignment from the calling behavior.\n *\n * This function also handles the input ports of function\n * definitions. Input ports to function definitions have the same\n * constraints as those of tasks, so this works fine. Functions have\n * no output or inout ports.\n */\nvector<pform_tf_port_t>*pform_make_task_ports(const struct vlltype&loc,\n\t\t\t\t      NetNet::PortType pt,\n\t\t\t\t      data_type_t*vtype,\n\t\t\t\t      list<pform_port_t>*ports,\n\t\t\t\t      bool allow_implicit)\n{\n      ivl_assert(loc, pt != NetNet::PIMPLICIT && pt != NetNet::NOT_A_PORT);\n      ivl_assert(loc, ports);\n\n      vector<pform_tf_port_t>*res = new vector<pform_tf_port_t>(0);\n      PWSRType rt = SR_BOTH;\n\n      // If this is a non-ansi port declaration and the type is an implicit type\n      // this is only a port declaration.\n      vector_type_t*vec_type = dynamic_cast<vector_type_t*>(vtype);\n      if (allow_implicit && (!vtype || (vec_type && vec_type->implicit_flag)))\n\t    rt = SR_PORT;\n\n      for (list<pform_port_t>::iterator cur = ports->begin();\n\t   cur != ports->end(); ++cur) {\n\t    PWire*curw = pform_get_or_make_wire(loc, cur->name,\n\t\t\t\t\t\tNetNet::IMPLICIT_REG, pt, rt);\n\t    if (rt == SR_BOTH)\n\t\t  curw->set_data_type(vtype);\n\n\t    pform_set_net_range(curw, vec_type, rt);\n\n\t    if (cur->udims) {\n\t\t  if (pform_requires_sv(loc, \"Task/function port with unpacked dimensions\"))\n\t\t\tcurw->set_unpacked_idx(*cur->udims);\n\t    }\n\n\t    res->push_back(pform_tf_port_t(curw));\n      }\n\n      delete ports;\n      return res;\n}\n\n/*\n * The parser calls this in the rule that matches increment/decrement\n * statements. The rule that does the matching creates a PEUnary with\n * all the information we need, but here we convert that expression to\n * a compressed assignment statement.\n */\nPAssign* pform_compressed_assign_from_inc_dec(const struct vlltype&loc, PExpr*exp)\n{\n      PEUnary*expu = dynamic_cast<PEUnary*> (exp);\n      ivl_assert(*exp, expu != 0);\n\n      char use_op = 0;\n      switch (expu->get_op()) {\n\t  case 'i':\n\t  case 'I':\n\t    use_op = '+';\n\t    break;\n\t  case 'd':\n\t  case 'D':\n\t    use_op = '-';\n\t    break;\n\t  default:\n\t    ivl_assert(*exp, 0);\n\t    break;\n      }\n\n      PExpr*lval = expu->get_expr();\n      PExpr*rval = new PENumber(new verinum((uint64_t)1, 1));\n      FILE_NAME(rval, loc);\n\n      PAssign*tmp = new PAssign(lval, use_op, rval);\n      FILE_NAME(tmp, loc);\n\n      delete exp;\n      return tmp;\n}\n\nPExpr* pform_genvar_inc_dec(const struct vlltype&loc, const char*name, bool inc_flag)\n{\n      pform_requires_sv(loc, \"Increment/decrement operator\");\n\n      PExpr*lval = new PEIdent(lex_strings.make(name), loc.lexical_pos);\n      PExpr*rval = new PENumber(new verinum(1));\n      FILE_NAME(lval, loc);\n      FILE_NAME(rval, loc);\n\n      PEBinary*tmp = new PEBinary(inc_flag ? '+' : '-', lval, rval);\n      FILE_NAME(tmp, loc);\n\n      return tmp;\n}\n\nPExpr* pform_genvar_compressed(const struct vlltype &loc, const char *name,\n\t\t\t       char op, PExpr *rval)\n{\n      pform_requires_sv(loc, \"Compressed assignment operator\");\n\n      PExpr *lval = new PEIdent(lex_strings.make(name), loc.lexical_pos);\n      FILE_NAME(lval, loc);\n\n      PExpr *expr;\n      switch (op) {\n\t  case 'l':\n\t  case 'r':\n\t  case 'R':\n\t    expr = new PEBShift(op, lval, rval);\n\t    break;\n\t  default:\n\t    expr = new PEBinary(op, lval, rval);\n\t    break;\n      }\n      FILE_NAME(expr, loc);\n\n      return expr;\n}\n\nvoid pform_set_attrib(perm_string name, perm_string key, char*value)\n{\n      if (PWire*cur = lexical_scope->wires_find(name)) {\n\t    cur->attributes[key] = new PEString(value);\n\n      } else if (PGate*curg = pform_cur_module.front()->get_gate(name)) {\n\t    curg->attributes[key] = new PEString(value);\n\n      } else {\n\t    delete[] value;\n\t    VLerror(\"error: Unable to match name for setting attribute.\");\n\n      }\n}\n\n/*\n * Set the attribute of a TYPE. This is different from an object in\n * that this applies to every instantiation of the given type.\n */\nvoid pform_set_type_attrib(perm_string name, const string&key,\n\t\t\t   char*value)\n{\n      map<perm_string,PUdp*>::const_iterator udp = pform_primitives.find(name);\n      if (udp == pform_primitives.end()) {\n\t    VLerror(\"error: Type name is not (yet) defined.\");\n\t    delete[] value;\n\t    return;\n      }\n\n      (*udp).second ->attributes[key] = new PEString(value);\n}\n\nLexicalScope::range_t* pform_parameter_value_range(bool exclude_flag,\n\t\t\t\t\t     bool low_open, PExpr*low_expr,\n\t\t\t\t\t     bool hig_open, PExpr*hig_expr)\n{\n\t// Detect +-inf and make the the *_open flags false to force\n\t// the range interpretation as inf.\n      if (low_expr == 0) low_open = false;\n      if (hig_expr == 0) hig_open = false;\n\n      LexicalScope::range_t*tmp = new LexicalScope::range_t;\n      tmp->exclude_flag = exclude_flag;\n      tmp->low_open_flag = low_open;\n      tmp->low_expr = low_expr;\n      tmp->high_open_flag = hig_open;\n      tmp->high_expr = hig_expr;\n      tmp->next = 0;\n      return tmp;\n}\n\nstatic void pform_set_type_parameter(const struct vlltype&loc, perm_string name,\n\t\t\t\t     const LexicalScope::range_t*value_range)\n{\n      pform_requires_sv(loc, \"Type parameter\");\n\n      if (value_range)\n\t    VLerror(loc, \"error: Type parameter must not have value range.\");\n\n      type_parameter_t *type = new type_parameter_t(name);\n      pform_set_typedef(loc, name, type, 0);\n}\n\nvoid pform_set_parameter(const struct vlltype&loc,\n\t\t\t perm_string name, bool is_local, bool is_type,\n\t\t\t data_type_t*data_type, list<pform_range_t>*udims,\n\t\t\t PExpr*expr, LexicalScope::range_t*value_range)\n{\n      LexicalScope*scope = lexical_scope;\n      if (is_compilation_unit(scope) && !gn_system_verilog()) {\n\t    VLerror(loc, \"error: %s declarations must be contained within a module.\",\n\t\t         is_local ? \"localparam\" : \"parameter\");\n\t    return;\n      }\n\n      if (expr == 0) {\n\t    if (is_local) {\n\t\t  VLerror(loc, \"error: localparam must have a value.\");\n\t    } else if (!pform_in_parameter_port_list) {\n\t\t  VLerror(loc, \"error: parameter declared outside parameter \"\n\t\t\t        \"port list must have a default value.\");\n\t    } else {\n\t\t  pform_requires_sv(loc, \"parameter without default value\");\n\t    }\n      }\n\n      vector_type_t*vt = dynamic_cast<vector_type_t*>(data_type);\n      if (vt && vt->pdims && vt->pdims->size() > 1) {\n\t    if (pform_requires_sv(loc, \"packed array parameter\")) {\n\t\t  VLerror(loc, \"sorry: packed array parameters are not supported yet.\");\n\t    }\n\t    return;\n      }\n\n      if (udims) {\n\t    if (pform_requires_sv(loc, \"unpacked array parameter\")) {\n\t\t  VLerror(loc, \"sorry: unpacked array parameters are not supported yet.\");\n\t    }\n\t    return;\n      }\n\n      bool overridable = !is_local;\n\n      if (scope == pform_cur_generate && !is_local) {\n\t    if (!gn_system_verilog()) {\n\t\t  VLerror(loc, \"parameter declarations are not permitted in generate blocks\");\n\t\t  return;\n\t    }\n\t    // SystemVerilog allows `parameter` in generate blocks, but it has\n\t    // the same semantics as `localparam` in that scope.\n\t    overridable = false;\n      }\n\n      bool in_module = dynamic_cast<Module*>(scope) &&\n\t\t       scope == pform_cur_module.front();\n\n      if (!pform_in_parameter_port_list && in_module &&\n          scope->has_parameter_port_list)\n\t    overridable = false;\n\n      if (pform_in_class())\n\t    overridable = false;\n\n      Module::param_expr_t*parm = new Module::param_expr_t();\n      FILE_NAME(parm, loc);\n\n      if (is_type)\n\t    pform_set_type_parameter(loc, name, value_range);\n      else\n\t    add_local_symbol(scope, name, parm);\n\n      parm->expr = expr;\n      parm->data_type = data_type;\n      parm->range = value_range;\n      parm->local_flag = is_local;\n      parm->overridable = overridable;\n      parm->type_flag = is_type;\n      parm->lexical_pos = loc.lexical_pos;\n\n      scope->parameters[name] = parm;\n\n      // Only a module keeps the position of the parameter.\n      if (overridable && in_module)\n\t    pform_cur_module.front()->param_names.push_back(name);\n}\n\nvoid pform_set_specparam(const struct vlltype&loc, perm_string name,\n\t\t\t list<pform_range_t>*range, PExpr*expr)\n{\n      ivl_assert(loc, !pform_cur_module.empty());\n      Module*scope = pform_cur_module.front();\n      if (scope != lexical_scope) {\n\t    delete range;\n\t    delete expr;\n\t    return;\n      }\n\n      ivl_assert(loc, expr);\n      Module::param_expr_t*parm = new Module::param_expr_t();\n      FILE_NAME(parm, loc);\n\n      add_local_symbol(scope, name, parm);\n      pform_cur_module.front()->specparams[name] = parm;\n\n      parm->expr = expr;\n      parm->range = 0;\n\n      if (range) {\n\t    ivl_assert(loc, range->size() == 1);\n\t    parm->data_type = new vector_type_t(IVL_VT_LOGIC, false, range);\n\t    parm->range = 0;\n      }\n}\n\nvoid pform_set_defparam(const pform_name_t&name, PExpr*expr)\n{\n      assert(expr);\n      if (pform_cur_generate)\n            pform_cur_generate->defparms.push_back(make_pair(name,expr));\n      else\n            pform_cur_module.front()->defparms.push_back(make_pair(name,expr));\n}\n\nvoid pform_make_let(const struct vlltype&loc,\n                    perm_string name,\n                    list<PLet::let_port*>*ports,\n                    PExpr*expr)\n{\n      LexicalScope*scope =  pform_peek_scope();\n\n      cerr << loc.get_fileline() << \": sorry: let declarations (\"\n           << name << \") are not currently supported.\" << endl;\n      error_count += 1;\n\n      PLet*res = new PLet(name, scope, ports, expr);\n      FILE_NAME(res, loc);\n\n/*\n      cerr << \"Found: \";\n      res->dump(cerr, 0);\n*/\n\n      delete res;\n      delete ports;\n      delete expr;\n}\n\nPLet::let_port_t* pform_make_let_port(data_type_t*data_type,\n                                      perm_string name,\n                                      list<pform_range_t>*range,\n                                      PExpr*def)\n{\n      PLet::let_port_t*res = new PLet::let_port_t;\n\n      res->type_ = data_type;\n      res->name_ = name;\n      res->range_ = range;\n      res->def_ = def;\n\n      return res;\n}\n\n/*\n * Specify paths.\n */\nextern PSpecPath* pform_make_specify_path(const struct vlltype&li,\n\t\t\t\t\t  list<perm_string>*src, char pol,\n\t\t\t\t\t  bool full_flag, list<perm_string>*dst)\n{\n      PSpecPath*path = new PSpecPath(*src, *dst, pol, full_flag);\n      FILE_NAME(path, li);\n\n      delete src;\n      delete dst;\n\n      return path;\n}\n\nextern PSpecPath*pform_make_specify_edge_path(const struct vlltype&li,\n\t\t\t\t\t int edge_flag, /*posedge==true */\n\t\t\t\t\t list<perm_string>*src, char pol,\n\t\t\t\t\t bool full_flag, list<perm_string>*dst,\n\t\t\t\t\t PExpr*data_source_expression)\n{\n      PSpecPath*tmp = pform_make_specify_path(li, src, pol, full_flag, dst);\n      tmp->edge = edge_flag;\n      tmp->data_source_expression = data_source_expression;\n      return tmp;\n}\n\nextern PSpecPath* pform_assign_path_delay(PSpecPath*path, list<PExpr*>*del)\n{\n      if (path == 0)\n\t    return 0;\n\n      ivl_assert(*path, path->delays.empty());\n\n      path->delays.resize(del->size());\n      for (unsigned idx = 0 ;  idx < path->delays.size() ;  idx += 1) {\n\t    path->delays[idx] = del->front();\n\t    del->pop_front();\n      }\n\n      delete del;\n\n      return path;\n}\n\n\nextern void pform_module_specify_path(PSpecPath*obj)\n{\n      if (obj == 0)\n\t    return;\n      pform_cur_module.front()->specify_paths.push_back(obj);\n}\n\n/*\n * Timing checks.\n */\n extern PRecRem* pform_make_recrem(const struct vlltype&li,\n\t\t\t PTimingCheck::event_t*reference_event,\n\t\t\t PTimingCheck::event_t*data_event,\n\t\t\t PExpr*setup_limit,\n\t\t\t PExpr*hold_limit,\n\t\t\t PTimingCheck::optional_args_t* args)\n{\n      ivl_assert(li, args);\n\n      PRecRem*recrem = new PRecRem(\n\t      reference_event,\n\t      data_event,\n\t      setup_limit,\n\t      hold_limit,\n\t      args->notifier,\n\t      args->timestamp_cond,\n\t      args->timecheck_cond,\n\t      args->delayed_reference,\n\t      args->delayed_data\n      );\n\n      FILE_NAME(recrem, li);\n\n      return recrem;\n}\nextern PSetupHold* pform_make_setuphold(const struct vlltype&li,\n\t\t\t PTimingCheck::event_t*reference_event,\n\t\t\t PTimingCheck::event_t*data_event,\n\t\t\t PExpr*setup_limit,\n\t\t\t PExpr*hold_limit,\n\t\t\t PTimingCheck::optional_args_t* args)\n{\n      ivl_assert(li, args);\n\n      PSetupHold*setuphold = new PSetupHold(\n\t      reference_event,\n\t      data_event,\n\t      setup_limit,\n\t      hold_limit,\n\t      args->notifier,\n\t      args->timestamp_cond,\n\t      args->timecheck_cond,\n\t      args->delayed_reference,\n\t      args->delayed_data\n      );\n\n      FILE_NAME(setuphold, li);\n\n      return setuphold;\n}\n\nextern void pform_module_timing_check(PTimingCheck*obj)\n{\n      if (!obj)\n\t    return;\n\n      pform_cur_module.front()->timing_checks.push_back(obj);\n}\n\n\nvoid pform_set_port_type(const struct vlltype&li,\n\t\t\t list<pform_port_t>*ports,\n\t\t\t NetNet::PortType pt,\n\t\t\t data_type_t*dt,\n\t\t\t list<named_pexpr_t>*attr)\n{\n      ivl_assert(li, pt != NetNet::PIMPLICIT && pt != NetNet::NOT_A_PORT);\n\n      vector_type_t *vt = dynamic_cast<vector_type_t*> (dt);\n\n      bool have_init_expr = false;\n      for (list<pform_port_t>::iterator cur = ports->begin()\n\t\t ; cur != ports->end() ; ++ cur ) {\n\n\t    PWire *wire = pform_get_or_make_wire(li, cur->name,\n\t\t\t\t\t\t NetNet::IMPLICIT, pt, SR_PORT);\n\t    pform_set_net_range(wire, vt, SR_PORT, attr);\n\n\t    if (cur->udims) {\n\t\t  cerr << li << \": warning: \"\n\t\t       << \"Array dimensions in incomplete port declarations \"\n\t\t       << \"are currently ignored.\" << endl;\n\t\t  cerr << li << \":        : \"\n\t\t       << \"The dimensions specified in the net or variable \"\n\t\t       << \"declaration will be used.\" << endl;\n\t\t  delete cur->udims;\n\t    }\n\t    if (cur->expr) {\n\t\t  have_init_expr = true;\n\t\t  delete cur->expr;\n\t    }\n      }\n      if (have_init_expr) {\n\t    cerr << li << \": error: \"\n\t\t << \"Incomplete port declarations cannot be initialized.\"\n\t\t << endl;\n\t    error_count += 1;\n      }\n\n      delete ports;\n      delete dt;\n      delete attr;\n}\n\n/*\n * This function detects the derived class for the given type and\n * dispatches the type to the proper subtype function.\n */\nvoid pform_set_data_type(const struct vlltype&li, data_type_t*data_type,\n\t\t\t std::vector<PWire*> *wires, NetNet::Type net_type,\n\t\t\t list<named_pexpr_t>*attr, bool is_const)\n{\n      if (data_type == 0) {\n\t    VLerror(li, \"internal error: data_type==0.\");\n\t    ivl_assert(li, 0);\n      }\n\n      vector_type_t*vec_type = dynamic_cast<vector_type_t*> (data_type);\n\n      for (std::vector<PWire*>::iterator it= wires->begin();\n\t   it != wires->end() ; ++it) {\n\t    PWire *wire = *it;\n\n\t    pform_set_net_range(wire, vec_type);\n\n\t    // If these fail there is a bug somewhere else. pform_set_data_type()\n\t    // is only ever called on a fresh wire that already exists.\n\t    bool rc = wire->set_wire_type(net_type);\n\t    ivl_assert(li, rc);\n\n\t    wire->set_data_type(data_type);\n\t    wire->set_const(is_const);\n\n\t    pform_bind_attributes(wire->attributes, attr, true);\n      }\n\n      delete wires;\n}\n\nvector<PWire*>* pform_make_udp_input_ports(list<pform_ident_t>*names)\n{\n      vector<PWire*>*out = new vector<PWire*>(names->size());\n\n      unsigned idx = 0;\n      for (list<pform_ident_t>::iterator cur = names->begin()\n\t\t ; cur != names->end() ; ++ cur ) {\n\t    PWire*pp = new PWire(cur->first, cur->second,\n\t\t\t\t NetNet::IMPLICIT,\n\t\t\t\t NetNet::PINPUT);\n\t    (*out)[idx] = pp;\n\t    idx += 1;\n      }\n\n      delete names;\n      return out;\n}\n\nPProcess* pform_make_behavior(ivl_process_type_t type, Statement*st,\n\t\t\t      list<named_pexpr_t>*attr)\n{\n\t// Add an implicit @* around the statement for the always_comb and\n\t// always_latch statements.\n      if ((type == IVL_PR_ALWAYS_COMB) || (type == IVL_PR_ALWAYS_LATCH)) {\n\t    PEventStatement *tmp = new PEventStatement(true);\n\t    tmp->set_line(*st);\n\t    tmp->set_statement(st);\n\t    st = tmp;\n      }\n\n      PProcess*pp = new PProcess(type, st);\n\n\t// If we are in a part of the code where the meta-comment\n\t// synthesis translate_off is in effect, then implicitly add\n\t// the ivl_synthesis_off attribute to any behavioral code that\n\t// we run into.\n      if (pform_mc_translate_flag == false) {\n\t    if (attr == 0) attr = new list<named_pexpr_t>;\n\t    named_pexpr_t tmp;\n\t    tmp.name = perm_string::literal(\"ivl_synthesis_off\");\n\t    tmp.parm = 0;\n\t    attr->push_back(tmp);\n      }\n\n      pform_bind_attributes(pp->attributes, attr);\n\n      pform_put_behavior_in_scope(pp);\n\n      ivl_assert(*st, ! pform_cur_module.empty());\n      if (pform_cur_module.front()->program_block &&\n          ((type == IVL_PR_ALWAYS) || (type == IVL_PR_ALWAYS_COMB) ||\n           (type == IVL_PR_ALWAYS_FF) || (type == IVL_PR_ALWAYS_LATCH))) {\n\t    cerr << st->get_fileline() << \": error: Always statements are not allowed\"\n\t\t << \" in program blocks.\" << endl;\n\t    error_count += 1;\n      }\n\n      return pp;\n}\n\nvoid pform_start_modport_item(const struct vlltype&loc, const char*name)\n{\n      Module*scope = pform_cur_module.front();\n      ivl_assert(loc, scope && scope->is_interface);\n      ivl_assert(loc, pform_cur_modport == 0);\n\n      perm_string use_name = lex_strings.make(name);\n      pform_cur_modport = new PModport(use_name);\n      FILE_NAME(pform_cur_modport, loc);\n\n      add_local_symbol(scope, use_name, pform_cur_modport);\n      scope->modports[use_name] = pform_cur_modport;\n\n      delete[] name;\n}\n\nvoid pform_end_modport_item(const struct vlltype&loc)\n{\n      ivl_assert(loc, pform_cur_modport);\n      pform_cur_modport = 0;\n}\n\nvoid pform_add_modport_port(const struct vlltype&loc,\n                            NetNet::PortType port_type,\n                            perm_string name, PExpr*expr)\n{\n      ivl_assert(loc, pform_cur_modport);\n\n      if (pform_cur_modport->simple_ports.find(name)\n\t  != pform_cur_modport->simple_ports.end()) {\n\t    cerr << loc << \": error: duplicate declaration of port '\"\n\t\t << name << \"' in modport list '\"\n\t\t << pform_cur_modport->name() << \"'.\" << endl;\n\t    error_count += 1;\n      }\n      pform_cur_modport->simple_ports[name] = make_pair(port_type, expr);\n}\n\nbool pform_requires_sv(const struct vlltype&loc, const char *feature)\n{\n      if (gn_system_verilog())\n\t    return true;\n\n      VLerror(loc, \"error: %s requires SystemVerilog.\", feature);\n\n      return false;\n}\n\nvoid pform_block_decls_requires_sv(void)\n{\n      for (auto const& wire : lexical_scope->wires) {\n\t    struct vlltype loc;\n\t    loc.text = wire.second->get_file();\n\t    loc.first_line = wire.second->get_lineno();\n\t    pform_requires_sv(loc, \"Variable declaration in unnamed block\");\n      }\n}\n\nvoid pform_check_net_data_type(const struct vlltype&loc, NetNet::Type net_type,\n\t\t\t       const data_type_t *data_type)\n{\n      // For SystemVerilog the type is checked during elaboration since due to\n      // forward typedefs and type parameters the actual type might not be known\n      // yet.\n      if (gn_system_verilog())\n\t    return;\n\n      switch (net_type) {\n      case NetNet::REG:\n      case NetNet::IMPLICIT_REG:\n\t    return;\n      default:\n\t    break;\n      }\n\n      if (!data_type)\n\t    return;\n\n      const vector_type_t*vec_type = dynamic_cast<const vector_type_t*>(data_type);\n      if (vec_type && vec_type->implicit_flag)\n\t    return;\n\n      if (!gn_cadence_types_flag)\n\t    VLerror(loc, \"Net data type requires SystemVerilog or -gxtypes.\");\n\n      if (vec_type)\n\t    return;\n\n      const real_type_t*rtype = dynamic_cast<const real_type_t*>(data_type);\n      if (rtype && rtype->type_code() == real_type_t::REAL)\n\t    return;\n\n      pform_requires_sv(loc, \"Net data type\");\n}\n\nFILE*vl_input = 0;\nextern void reset_lexor();\n\nint pform_parse(const char*path)\n{\n      vl_file = path;\n      if (strcmp(path, \"-\") == 0) {\n\t    vl_input = stdin;\n      } else if (ivlpp_string) {\n\t    char*cmdline = (char*)malloc(strlen(ivlpp_string) +\n\t\t\t\t\t        strlen(path) + 4);\n\t    strcpy(cmdline, ivlpp_string);\n\t    strcat(cmdline, \" \\\"\");\n\t    strcat(cmdline, path);\n\t    strcat(cmdline, \"\\\"\");\n\n\t    if (verbose_flag)\n\t\t  cerr << \"Executing: \" << cmdline << endl<< flush;\n\n\t    vl_input = popen(cmdline, \"r\");\n\t    if (vl_input == 0) {\n\t\t  cerr << \"Unable to preprocess \" << path << \".\" << endl;\n\t\t  return 1;\n\t    }\n\n\t    if (verbose_flag)\n\t\t  cerr << \"...parsing output from preprocessor...\" << endl << flush;\n\n\t    free(cmdline);\n      } else {\n\t    vl_input = fopen(path, \"r\");\n\t    if (vl_input == 0) {\n\t\t  cerr << \"Unable to open \" << path << \".\" << endl;\n\t\t  return 1;\n\t    }\n      }\n\n      if (pform_units.empty() || separate_compilation) {\n\t    char unit_name[20];\n\t    static unsigned nunits = 0;\n\t    if (separate_compilation)\n\t\t  snprintf(unit_name, sizeof(unit_name)-1, \"$unit#%u\", ++nunits);\n\t    else\n\t\t  snprintf(unit_name, sizeof(unit_name)-1, \"$unit\");\n\n\t    PPackage*unit = new PPackage(lex_strings.make(unit_name), 0);\n\t    unit->default_lifetime = LexicalScope::STATIC;\n\t    unit->set_file(filename_strings.make(path));\n\t    unit->set_lineno(1);\n\t    pform_units.push_back(unit);\n\n            pform_cur_module.clear();\n            pform_cur_generate = 0;\n            pform_cur_modport = 0;\n\n\t    pform_set_timescale(def_ts_units, def_ts_prec, 0, 0);\n\n\t    allow_timeunit_decl = true;\n\t    allow_timeprec_decl = true;\n\n\t    lexical_scope = unit;\n      }\n      reset_lexor();\n      error_count = 0;\n      warn_count = 0;\n      int rc = VLparse();\n\n      if (vl_input != stdin) {\n\t    if (ivlpp_string)\n\t\t  pclose(vl_input);\n\t    else\n\t\t  fclose(vl_input);\n      }\n\n      if (rc) {\n\t    cerr << \"I give up.\" << endl;\n\t    error_count += 1;\n      }\n\n      destroy_lexor();\n      return error_count;\n}\n\nvoid pform_finish()\n{\n      // Wait until all parsing is done and all symbols in the unit scope are\n      // known before importing possible imports.\n      for (auto unit : pform_units)\n\t    pform_check_possible_imports(unit);\n}\n"
        },
        {
          "name": "pform.h",
          "type": "blob",
          "size": 21.4189453125,
          "content": "#ifndef IVL_pform_H\n#define IVL_pform_H\n/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netlist.h\"\n# include  \"HName.h\"\n# include  \"named.h\"\n# include  \"Module.h\"\n# include  \"Statement.h\"\n# include  \"AStatement.h\"\n# include  \"PGate.h\"\n# include  \"PExpr.h\"\n# include  \"PTask.h\"\n# include  \"PUdp.h\"\n# include  \"PWire.h\"\n# include  \"PTimingCheck.h\"\n# include  \"verinum.h\"\n# include  \"discipline.h\"\n# include  <iostream>\n# include  <string>\n# include  <list>\n# include  <memory>\n# include  <cstdio>\n\n/*\n * These classes implement the parsed form (P-form for short) of the\n * original Verilog source. the parser generates the pform for the\n * convenience of later processing steps.\n */\n\n\n/*\n * Wire objects represent the named wires (of various flavor) declared\n * in the source.\n *\n * Gate objects are the functional modules that are connected together\n * by wires.\n *\n * Wires and gates, connected by joints, represent a netlist. The\n * netlist is therefore a representation of the desired circuit.\n */\nclass PGate;\nclass PExpr;\nclass PPackage;\nclass PSpecPath;\nclass PClass;\nclass PPackage;\nstruct vlltype;\nstruct lgate;\n\n/*\n * The min:typ:max expression s selected at parse time using the\n * enumeration. When the compiler makes a choice, it also prints a\n * warning if min_typ_max_warn > 0.\n */\nextern enum MIN_TYP_MAX { MIN, TYP, MAX } min_typ_max_flag;\nextern unsigned min_typ_max_warn;\nPExpr* pform_select_mtm_expr(PExpr*min, PExpr*typ, PExpr*max);\n\n/*\n * This flag is true if the lexor thinks we are in a library source\n * file.\n */\nextern bool pform_library_flag;\n\n/*\n * These type are lexical types -- that is, types that are used as\n * lexical values to decorate the parse tree during parsing. They are\n * not in any way preserved once parsing is done.\n */\n\n/* This is information about port name information for named port\n   connections. */\n\n\nstruct parmvalue_t {\n      std::list<PExpr*>*by_order;\n      std::list<named_pexpr_t>*by_name;\n};\n\nstruct str_pair_t { ivl_drive_t str0, str1; };\n\n  /* Use this function to transform the parted form of the attribute\n     list to the attribute map that is used later. */\nextern void pform_bind_attributes(std::map<perm_string,PExpr*>&attributes,\n\t\t\t\t  std::list<named_pexpr_t>*attr,\n\t\t\t\t  bool keep_attr =false);\n\n  /* The lexor calls this function to change the default nettype. */\nextern void pform_set_default_nettype(NetNet::Type net,\n\t\t\t\t     const char*file,\n\t\t\t\t     unsigned lineno);\n\n  /* Return true if currently processing a program block. This can be\n     used to reject statements that cannot exist in program blocks. */\nextern bool pform_in_program_block(void);\n\n  /* Return true if currently processing an interface. This can be\n     used to reject statements that cannot exist in interfaces. */\nextern bool pform_in_interface(void);\n\n/*\n * Look for the given wire in the current lexical scope. If the wire\n * (including variables of any type) cannot be found in the current\n * scope, then return 0.\n */\nextern PWire* pform_get_wire_in_scope(perm_string name);\n\nextern PWire* pform_get_make_wire_in_scope(const struct vlltype&li,\n                                           perm_string name,\n                                           NetNet::Type net_type,\n                                           ivl_variable_type_t vt_type);\n\n/*\n * The parser uses startmodule and endmodule together to build up a\n * module as it parses it. The startmodule tells the pform code that a\n * module has been noticed in the source file and the following events\n * are to apply to the scope of that module. The endmodule causes the\n * pform to close up and finish the named module.\n *\n * The program_block flag indicates that the module is actually a program\n * block. The is_interface flag indicates that the module is actually\n * an interface. These flags have implications during parse and during\n * elaboration/code generation.\n */\nextern void pform_startmodule(const struct vlltype&loc, const char*name,\n\t\t\t      bool program_block, bool is_interface,\n\t\t\t      LexicalScope::lifetime_t lifetime,\n\t\t\t      std::list<named_pexpr_t>*attr);\nextern void pform_module_set_ports(std::vector<Module::port_t*>*);\nextern void pform_set_scope_timescale(const struct vlltype&loc);\n\n/* These functions are used when we have a complete port definition, either\n   in an ansi style or non-ansi style declaration. In this case, we have\n   everything needed to define the port, all in one place. */\nextern void pform_module_define_port(const struct vlltype&li,\n\t\t\t\t     const pform_ident_t&name,\n\t\t\t\t     NetNet::PortType,\n\t\t\t\t     NetNet::Type type,\n\t\t\t\t     data_type_t*vtype,\n\t\t\t\t     std::list<pform_range_t>*urange,\n\t\t\t\t     std::list<named_pexpr_t>*attr,\n\t\t\t\t     bool keep_attr =false);\nextern void pform_module_define_port(const struct vlltype&li,\n\t\t\t\t     std::list<pform_port_t>*ports,\n\t\t\t\t     NetNet::PortType,\n\t\t\t\t     NetNet::Type type,\n\t\t\t\t     data_type_t*vtype,\n\t\t\t\t     std::list<named_pexpr_t>*attr);\n\nextern Module::port_t* pform_module_port_reference(const struct vlltype&loc,\n\t\t\t\t\t\t   perm_string name);\nextern void pform_endmodule(const char*, bool inside_celldefine,\n                            Module::UCDriveType uc_drive_def);\n\nextern void pform_start_class_declaration(const struct vlltype&loc,\n\t\t\t\t\t  class_type_t*type,\n\t\t\t\t\t  data_type_t*base_type,\n\t\t\t\t\t  std::list<named_pexpr_t> *base_args,\n\t\t\t\t\t  bool virtual_class);\nextern void pform_class_property(const struct vlltype&loc,\n\t\t\t\t property_qualifier_t pq,\n\t\t\t\t data_type_t*data_type,\n\t\t\t\t std::list<decl_assignment_t*>*decls);\nextern void pform_set_this_class(const struct vlltype&loc, PTaskFunc*net);\nextern void pform_set_constructor_return(PFunction*net);\n\nextern void pform_end_class_declaration(const struct vlltype&loc);\nextern bool pform_in_class();\n\nextern void pform_make_udp(const struct vlltype&loc, perm_string name,\n\t\t\t   std::list<pform_ident_t>*parms,\n\t\t\t   std::vector<PWire*>*decl, std::list<std::string>*table,\n\t\t\t   Statement*init);\n\nextern void pform_make_udp(const struct vlltype&loc, perm_string name,\n\t\t\t   bool sync_flag, const pform_ident_t&out_name,\n\t\t\t   PExpr*sync_init,\n\t\t\t   std::list<pform_ident_t>*parms,\n\t\t\t   std::list<std::string>*table);\n/*\n * Package related functions.\n */\nextern void pform_start_package_declaration(const struct vlltype&loc,\n\t\t\t\t\t    const char*type,\n\t\t\t\t\t    LexicalScope::lifetime_t lifetime);\nextern void pform_end_package_declaration(const struct vlltype&loc);\nextern void pform_package_import(const struct vlltype&loc,\n\t\t\t\t PPackage*pkg, const char*ident);\nextern void pform_package_export(const struct vlltype &loc, PPackage *pkg,\n\t\t\t         const char *ident);\nPPackage *pform_package_importable(PPackage *pkg, perm_string name);\nPPackage *pform_find_potential_import(const struct vlltype&loc, LexicalScope*scope,\n\t\t\t\t      perm_string name, bool tf_call, bool make_explicit);\n\n\nextern PExpr* pform_package_ident(const struct vlltype&loc,\n\t\t\t\t  PPackage*pkg, pform_name_t*ident);\n\n/*\n * Interface related functions.\n */\nextern void pform_start_modport_item(const struct vlltype&loc, const char*name);\nextern void pform_end_modport_item(const struct vlltype&loc);\nextern void pform_add_modport_port(const struct vlltype&loc,\n\t                           NetNet::PortType port_type,\n\t                           perm_string name, PExpr*expr);\n\n/*\n * This creates an identifier aware of names that may have been\n * imported from other packages.\n */\nextern PEIdent* pform_new_ident(const struct vlltype&loc, const pform_name_t&name);\n\nextern PTrigger* pform_new_trigger(const struct vlltype&loc, PPackage*pkg,\n\t\t\t\t   const pform_name_t&name, unsigned lexical_pos);\nextern PNBTrigger* pform_new_nb_trigger(const struct vlltype&loc,\n\t\t\t\t        const std::list<PExpr*>*dly,\n\t\t\t\t        const pform_name_t&name,\n\t\t\t\t        unsigned lexical_pos);\n\n/*\n * Enter/exit name scopes. The push_scope function pushes the scope\n * name string onto the scope hierarchy. The pop pulls it off and\n * deletes it. Thus, the string pushed must be allocated.\n */\nextern void pform_pop_scope();\n\n/*\n * Peek at the current (most recently active) scope.\n */\nextern LexicalScope* pform_peek_scope();\n\nextern PClass* pform_push_class_scope(const struct vlltype&loc, perm_string name);\n\nextern PFunction*pform_push_constructor_scope(const struct vlltype&loc);\n\nextern PPackage* pform_push_package_scope(const struct vlltype&loc, perm_string name,\n\t\t\t\t\t  LexicalScope::lifetime_t lifetime);\n\nextern PTask*pform_push_task_scope(const struct vlltype&loc, char*name,\n\t\t\t\t   LexicalScope::lifetime_t lifetime);\n\nextern PFunction*pform_push_function_scope(const struct vlltype&loc, const char*name,\n\t\t\t\t\t   LexicalScope::lifetime_t lifetime);\n\nextern PBlock*pform_push_block_scope(const struct vlltype&loc, char*name,\n\t\t\t\t     PBlock::BL_TYPE tt);\n\nextern void pform_put_behavior_in_scope(AProcess*proc);\n\nextern verinum* pform_verinum_with_size(verinum*s, verinum*val,\n\t\t\t\t\tconst char*file, unsigned lineno);\n\n/*\n * This function takes the list of names as new genvars to declare in\n * the current module or generate scope.\n */\nextern void pform_genvars(const struct vlltype&li, std::list<pform_ident_t>*names);\n\n/*\n * This flag is set by the parser to indicate the current generate block\n * was not enclosed in a begin-end pair. This is a pre-requisite for\n * directly nesting generate constructs.\n */\nextern bool pform_generate_single_item;\n\nextern void pform_start_generate_for(const struct vlltype&li,\n\t\t\t\t     bool local_index,\n\t\t\t\t     char*ident1,\n\t\t\t\t     PExpr*init,\n\t\t\t\t     PExpr*test,\n\t\t\t\t     char*ident2,\n\t\t\t\t     PExpr*next);\nextern void pform_start_generate_if(const struct vlltype&li, PExpr*test);\nextern void pform_start_generate_else(const struct vlltype&li);\nextern void pform_start_generate_case(const struct vlltype&lp, PExpr*test);\nextern void pform_start_generate_nblock(const struct vlltype&lp, char*name);\nextern void pform_generate_case_item(const struct vlltype&lp, std::list<PExpr*>*test);\nextern void pform_generate_block_name(char*name);\nextern void pform_endgenerate(bool end_conditional);\n\n/*\n * This function returns the lexically containing generate scheme, if\n * there is one. The parser may use this to check if we are within a\n * generate scheme.\n */\nextern PGenerate* pform_parent_generate(void);\n\nbool pform_error_in_generate(const vlltype&loc, const char *type);\n\nextern void pform_make_elab_task(const struct vlltype&li,\n                                 perm_string name,\n                                 const std::list<named_pexpr_t> &params);\n\nextern void pform_set_typedef(const struct vlltype&loc, perm_string name,\n\t\t\t      data_type_t*data_type,\n\t\t\t      std::list<pform_range_t>*unp_ranges = nullptr);\nextern void pform_forward_typedef(const struct vlltype&loc, perm_string name,\n\t\t\t      enum typedef_t::basic_type basic_type);\n\nextern void pform_set_type_referenced(const struct vlltype&loc, const char*name);\n\n/*\n * This function makes a PECallFunction of the named function.\n */\nextern PECallFunction* pform_make_call_function(const struct vlltype&loc,\n\t\t\t\t\t\tconst pform_name_t&name,\n\t\t\t\t\t\tconst std::list<named_pexpr_t> &parms);\nextern PCallTask* pform_make_call_task(const struct vlltype&loc,\n\t\t\t\t       const pform_name_t&name,\n\t\t\t\t       const std::list<named_pexpr_t> &parms);\n\nextern void pform_make_foreach_declarations(const struct vlltype&loc,\n\t\t\t\t\t    std::list<perm_string>*loop_vars);\nextern PForeach* pform_make_foreach(const struct vlltype&loc,\n\t\t\t\t    char*ident,\n\t\t\t\t    std::list<perm_string>*loop_vars,\n\t\t\t\t    Statement*stmt);\n\n/*\n * The makewire functions announce to the pform code new wires. These\n * go into a module that is currently opened.\n */\nextern PWire *pform_makewire(const struct vlltype&li,\n                             const pform_ident_t&name,\n\t\t\t     NetNet::Type type,\n\t\t\t     std::list<pform_range_t> *indices);\n\n/* This form handles assignment declarations. */\n\nextern void pform_makewire(const struct vlltype&li,\n\t\t\t   std::list<PExpr*>*delay,\n\t\t\t   str_pair_t str,\n\t\t\t   std::list<decl_assignment_t*>*assign_list,\n\t\t\t   NetNet::Type type,\n\t\t\t   data_type_t*data_type,\n\t\t\t   std::list<named_pexpr_t>*attr = 0,\n\t\t\t   bool is_const = false);\n\nextern void pform_make_var(const struct vlltype&loc,\n\t\t\t   std::list<decl_assignment_t*>*assign_list,\n\t\t\t   data_type_t*data_type,\n\t\t\t   std::list<named_pexpr_t>*attr = 0,\n\t\t\t   bool is_const = false);\n\nextern void pform_make_var_init(const struct vlltype&li,\n\t\t\t\tconst pform_ident_t&name,\n\t\t\t\tPExpr*expr);\n\n/* This function is used when we have an incomplete port definition in\n   a non-ansi style declaration. Look up the names of the wires, and set\n   the port type, i.e. input, output or inout, and, if specified, the\n   range and signedness. If the wire does not exist, create it. */\nextern void pform_set_port_type(const struct vlltype&li,\n\t\t\t\tstd::list<pform_port_t>*ports,\n\t\t\t\tNetNet::PortType,\n\t\t\t\tdata_type_t*dt,\n\t\t\t\tstd::list<named_pexpr_t>*attr);\n\nextern void pform_set_data_type(const struct vlltype&li,\n\t\t\t\tdata_type_t *data_type,\n\t\t\t\tstd::vector<PWire*> *wires,\n\t\t\t\tNetNet::Type net_type,\n\t\t\t\tstd::list<named_pexpr_t>*attr,\n\t\t\t\tbool is_const = false);\n\nextern void pform_set_string_type(const struct vlltype&li, const string_type_t*string_type, std::list<perm_string>*names, NetNet::Type net_type, std::list<named_pexpr_t>*attr);\n\nextern void pform_set_class_type(const struct vlltype&li, class_type_t*class_type, std::list<perm_string>*names, NetNet::Type net_type, std::list<named_pexpr_t>*addr);\n\n\n  /* pform_set_attrib and pform_set_type_attrib exist to support the\n     $attribute syntax, which can only set string values to\n     attributes. The functions keep the value strings that are\n     passed in. */\nextern void pform_set_attrib(perm_string name, perm_string key,\n\t\t\t     char*value);\nextern void pform_set_type_attrib(perm_string name, const std::string&key,\n\t\t\t\t  char*value);\n\nextern LexicalScope::range_t* pform_parameter_value_range(bool exclude_flag,\n\t\t\t\t\t\t    bool low_open, PExpr*low_expr,\n\t\t\t\t\t\t    bool hig_open, PExpr*hig_expr);\n\nextern void pform_set_parameter(const struct vlltype&loc,\n\t\t\t\tperm_string name,\n\t\t\t\tbool is_local, bool is_type,\n\t\t\t\tdata_type_t*data_type, std::list<pform_range_t>*udims,\n\t\t\t\tPExpr*expr, LexicalScope::range_t*value_range);\nextern void pform_set_specparam(const struct vlltype&loc,\n\t\t\t\t perm_string name,\n\t\t\t\t std::list<pform_range_t>*range,\n\t\t\t\t PExpr*expr);\nextern void pform_set_defparam(const pform_name_t&name, PExpr*expr);\n\nextern void pform_make_let(const struct vlltype&loc,\n                           perm_string name,\n                           std::list<PLet::let_port_t*>*ports,\n                           PExpr*expr);\n\nextern PLet::let_port_t* pform_make_let_port(data_type_t*data_type,\n                                             perm_string name,\n                                             std::list<pform_range_t>*range,\n                                             PExpr*def);\n\n/*\n * Functions related to specify blocks.\n */\nextern PSpecPath*pform_make_specify_path(const struct vlltype&li,\n\t\t\t\t\t std::list<perm_string>*src, char pol,\n\t\t\t\t\t bool full_flag, std::list<perm_string>*dst);\nextern PSpecPath*pform_make_specify_edge_path(const struct vlltype&li,\n\t\t\t\t\t int edge_flag, /*posedge==true */\n\t\t\t\t\t std::list<perm_string>*src, char pol,\n\t\t\t\t\t bool full_flag, std::list<perm_string>*dst,\n\t\t\t\t\t PExpr*data_source_expression);\nextern PSpecPath*pform_assign_path_delay(PSpecPath*obj, std::list<PExpr*>*delays);\n\nextern void pform_module_specify_path(PSpecPath*obj);\n\n/*\n * Functions related to timing checks.\n */\nextern PRecRem* pform_make_recrem(const struct vlltype&li,\n\t\t\t    PTimingCheck::event_t*reference_event,\n\t\t\t    PTimingCheck::event_t*data_event,\n\t\t\t    PExpr*setup_limit,\n\t\t\t    PExpr*hold_limit,\n\t\t\t    PTimingCheck::optional_args_t* args\n\t\t\t    );\nextern PSetupHold* pform_make_setuphold(const struct vlltype&li,\n\t\t\t    PTimingCheck::event_t*reference_event,\n\t\t\t    PTimingCheck::event_t*data_event,\n\t\t\t    PExpr*setup_limit,\n\t\t\t    PExpr*hold_limit,\n\t\t\t    PTimingCheck::optional_args_t* args\n\t\t\t    );\nextern void pform_module_timing_check(PTimingCheck*obj);\n\n/*\n * pform_make_behavior creates processes that are declared with always\n * or initial items.\n */\nextern PProcess*  pform_make_behavior(ivl_process_type_t, Statement*,\n\t\t\t\t      std::list<named_pexpr_t>*attr);\nextern void pform_mc_translate_on(bool flag);\n\nextern std::vector<PWire*>* pform_make_udp_input_ports(std::list<pform_ident_t>*);\n\nextern void pform_make_events(const struct vlltype&loc,\n\t\t\t      const std::list<pform_ident_t>*names);\n/*\n * The makegate function creates a new gate (which need not have a\n * name) and connects it to the specified wires.\n */\nextern void pform_makegates(const struct vlltype&loc,\n\t\t\t    PGBuiltin::Type type,\n\t\t\t    struct str_pair_t str,\n\t\t\t    std::list<PExpr*>*delay,\n\t\t\t    std::vector<lgate>*gates,\n\t\t\t    std::list<named_pexpr_t>*attr);\n\nextern void pform_make_modgates(const struct vlltype&loc,\n\t\t\t\tperm_string type,\n\t\t\t\tstruct parmvalue_t*overrides,\n\t\t\t\tstd::vector<lgate>*gates,\n\t\t\t\tstd::list<named_pexpr_t>*attr);\n\n/* Make a continuous assignment node, with optional bit- or part- select. */\nextern void pform_make_pgassign_list(const struct vlltype&loc,\n\t\t\t\t     std::list<PExpr*>*alist,\n\t\t\t\t     std::list<PExpr*>*del,\n\t\t\t\t     struct str_pair_t str);\n\nextern std::vector<pform_tf_port_t>*pform_make_task_ports(const struct vlltype&loc,\n\t\t\t\t\t     NetNet::PortType pt,\n\t\t\t\t\t     data_type_t*vtype,\n\t\t\t\t\t     std::list<pform_port_t>*ports,\n\t\t\t\t\t     bool allow_implicit = false);\n\n/*\n * The parser uses this function to convert a unary\n * increment/decrement expression to the equivalent compressed\n * assignment statement.\n */\nextern PAssign* pform_compressed_assign_from_inc_dec(const struct vlltype&loc,\n\t\t\t\t\t\t     PExpr*exp);\n\n/*\n * The parser uses this function to convert a genvar increment/decrement\n * expression to the equivalent binary add/subtract expression.\n */\nextern PExpr* pform_genvar_inc_dec(const struct vlltype&loc, const char*name,\n                                   bool inc_flag);\n\nextern PExpr* pform_genvar_compressed(const struct vlltype &loc,\n\t\t\t\t      const char *name, char op, PExpr *rval);\n\n/*\n * These are functions that the outside-the-parser code uses the do\n * interesting things to the Verilog. The parse function reads and\n * parses the source file and places all the modules it finds into the\n * mod list. The dump function dumps a module to the output stream.\n */\nextern void pform_dump(std::ostream&out, Module*mod);\n\n/* ** pform_discipline.cc\n * Functions for handling the parse of natures and disciplines. These\n * functions are in pform_disciplines.cc\n */\n\nextern void pform_start_nature(const char*name);\nextern void pform_end_nature(const struct vlltype&loc);\n\nextern void pform_nature_access(const struct vlltype&loc, const char*name);\n\nextern void pform_start_discipline(const char*name);\nextern void pform_end_discipline(const struct vlltype&loc);\n\nextern void pform_discipline_domain(const struct vlltype&loc, ivl_dis_domain_t use_domain);\nextern void pform_discipline_potential(const struct vlltype&loc, const char*name);\nextern void pform_discipline_flow(const struct vlltype&loc, const char*name);\n\nextern void pform_attach_discipline(const struct vlltype&loc,\n\t\t\t\t    ivl_discipline_t discipline, std::list<pform_ident_t>*names);\n\nextern void pform_dump(std::ostream&out, const ivl_nature_s*);\nextern void pform_dump(std::ostream&out, const ivl_discipline_s*);\n\n/* ** pform_analog.cc\n*/\nextern void pform_make_analog_behavior(const struct vlltype&loc,\n\t\t\t\t       ivl_process_type_t type, Statement*st);\n\nextern AContrib*pform_contribution_statement(const struct vlltype&loc,\n\t\t\t\t\t     PExpr*lval, PExpr*rval);\n\nextern PExpr* pform_make_branch_probe_expression(const struct vlltype&loc,\n\t\t\t\t\t\t char*name, char*n1, char*n2);\n\nextern PExpr* pform_make_branch_probe_expression(const struct vlltype&loc,\n\t\t\t\t\t\t char*name, char*branch);\n\n/*\n * Parse configuration file with format <key>=<value>, where key\n * is the hierarchical name of a valid parameter name and value\n * is the value user wants to assign to. The value should be constant.\n */\nextern void parm_to_defparam_list(const std::string&param);\n\n/*\n * Tasks to set the timeunit or timeprecision for SystemVerilog.\n */\nextern bool get_time_unit(const char*cp, int &unit);\nextern int  pform_get_timeunit();\nextern int  pform_get_timeprec();\nextern void pform_set_timeunit(const char*txt, bool initial_decl);\nextern void pform_set_timeprec(const char*txt, bool initial_decl);\n/*\n * Flags to determine whether this is an initial declaration.\n */\nextern bool allow_timeunit_decl;\nextern bool allow_timeprec_decl;\n\nvoid pform_put_enum_type_in_scope(enum_type_t*enum_set);\n\nbool pform_requires_sv(const struct vlltype&loc, const char *feature);\nvoid pform_block_decls_requires_sv(void);\n\nvoid pform_start_parameter_port_list();\nvoid pform_end_parameter_port_list();\n\nvoid pform_check_net_data_type(const struct vlltype&loc, NetNet::Type net_type,\n\t\t\t       const data_type_t *data_type);\n\n#endif /* IVL_pform_H */\n"
        },
        {
          "name": "pform_analog.cc",
          "type": "blob",
          "size": 2.2744140625,
          "content": "/*\n * Copyright (c) 2008-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <cstdarg>\n# include  \"config.h\"\n# include  \"compiler.h\"\n# include  \"pform.h\"\n# include  \"parse_misc.h\"\n# include  \"AStatement.h\"\n\nusing namespace std;\n\nAContrib* pform_contribution_statement(const struct vlltype&loc,\n\t\t\t\t\t PExpr*lval, PExpr*rval)\n{\n      AContrib*tmp = new AContrib(lval, rval);\n      FILE_NAME(tmp, loc);\n      return tmp;\n}\n\nvoid pform_make_analog_behavior(const struct vlltype&loc, ivl_process_type_t pt,\n\t\t\t\tStatement*statement)\n{\n      AProcess*proc = new AProcess(pt, statement);\n      FILE_NAME(proc, loc);\n\n      pform_put_behavior_in_scope(proc);\n}\n\nPExpr* pform_make_branch_probe_expression(const struct vlltype&loc,\n\t\t\t\t\t  char*name, char*n1, char*n2)\n{\n      vector<named_pexpr_t> parms (2);\n      parms[0].parm = new PEIdent(lex_strings.make(n1), loc.lexical_pos);\n      FILE_NAME(parms[0].parm, loc);\n\n      parms[1].parm = new PEIdent(lex_strings.make(n2), loc.lexical_pos);\n      FILE_NAME(parms[1].parm, loc);\n\n      PECallFunction*res = new PECallFunction(lex_strings.make(name), parms);\n      FILE_NAME(res, loc);\n      return res;\n}\n\nPExpr* pform_make_branch_probe_expression(const struct vlltype&loc,\n\t\t\t\t\t  char*name, char*branch_name)\n{\n      vector<named_pexpr_t> parms (1);\n      parms[0].parm = new PEIdent(lex_strings.make(branch_name), loc.lexical_pos);\n      FILE_NAME(parms[0].parm, loc);\n\n      PECallFunction*res = new PECallFunction(lex_strings.make(name), parms);\n      FILE_NAME(res, loc);\n\n      return res;\n}\n"
        },
        {
          "name": "pform_disciplines.cc",
          "type": "blob",
          "size": 6.748046875,
          "content": "/*\n * Copyright (c) 2008-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <cstdarg>\n# include  \"config.h\"\n# include  \"compiler.h\"\n# include  \"pform.h\"\n# include  \"parse_misc.h\"\n# include  \"discipline.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\nmap<perm_string,ivl_nature_t> natures;\nmap<perm_string,ivl_discipline_t> disciplines;\nmap<perm_string,ivl_nature_t> access_function_nature;\n\nstatic perm_string nature_name = perm_string();\nstatic perm_string nature_access = perm_string();\n\nvoid pform_start_nature(const char*name)\n{\n      nature_name = lex_strings.make(name);\n}\n\nvoid pform_nature_access(const struct vlltype&loc, const char*name)\n{\n      if (nature_access) {\n\t    cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t << \"Too many access names for nature \"\n\t\t << nature_name << \".\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n\n      nature_access = lex_strings.make(name);\n}\n\nvoid pform_end_nature(const struct vlltype&loc)\n{\n\t// The nature access function is required. If it is missing,\n\t// then signal an error. For a temporary expedient, we can set\n\t// the nature name as the access function, but don't expect it\n\t// to work.\n      if (! nature_access) {\n\t    cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t << \"Missing access name for nature \"\n\t\t << nature_name << \".\" << endl;\n\t    error_count += 1;\n\t    nature_access = nature_name;\n      }\n\n      ivl_nature_s*tmp = new ivl_nature_s(nature_name, nature_access);\n      FILE_NAME(tmp, loc);\n\n      natures[nature_name] = tmp;\n\n\t// Make sure the access function is not used by multiple\n\t// different natures.\n      if (ivl_nature_t dup_access_nat = access_function_nature[nature_access]) {\n\t    cerr << tmp->get_fileline() << \": error: \"\n\t\t << \"Access function name \" << nature_access\n\t\t << \" is already used by nature \" << dup_access_nat->name()\n\t\t << \" declared at \" << dup_access_nat->get_fileline()\n\t\t << \".\" << endl;\n\t    error_count += 1;\n      }\n\n\t// Map the access function back to the nature so that\n\t// expressions that use the access function can find it.\n      access_function_nature[nature_access] = tmp;\n\n      nature_name = perm_string();\n      nature_access = perm_string();\n}\n\n\nstatic perm_string discipline_name;\nstatic ivl_dis_domain_t discipline_domain = IVL_DIS_NONE;\nstatic ivl_nature_t discipline_potential = 0;\nstatic ivl_nature_t discipline_flow = 0;\n\nvoid pform_start_discipline(const char*name)\n{\n      discipline_name = lex_strings.make(name);\n      discipline_domain = IVL_DIS_NONE;\n}\n\nvoid pform_discipline_domain(const struct vlltype&loc, ivl_dis_domain_t use_domain)\n{\n      ivl_assert(loc, use_domain != IVL_DIS_NONE);\n\n      if (discipline_domain != IVL_DIS_NONE) {\n\t    cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t << \"Too many domain attributes for discipline \"\n\t\t << discipline_name << \".\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n\n      discipline_domain = use_domain;\n}\n\nvoid pform_discipline_potential(const struct vlltype&loc, const char*name)\n{\n      if (discipline_potential) {\n\t    cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t << \"Too many potential natures for discipline \"\n\t\t << discipline_name << \".\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n\n      perm_string key = lex_strings.make(name);\n      discipline_potential = natures[key];\n\n      if (discipline_potential == 0) {\n\t    cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t << \"nature \" << key << \" is not declared.\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n}\n\nvoid pform_discipline_flow(const struct vlltype&loc, const char*name)\n{\n      if (discipline_flow) {\n\t    cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t << \"Too many flow natures for discipline \"\n\t\t << discipline_name << \".\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n\n      perm_string key = lex_strings.make(name);\n      discipline_flow = natures[key];\n\n      if (discipline_flow == 0) {\n\t    cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t << \"nature \" << key << \" is not declared.\" << endl;\n\t    error_count += 1;\n\t    return;\n      }\n}\n\nvoid pform_end_discipline(const struct vlltype&loc)\n{\n\t// If the domain is not otherwise specified, then take it to\n\t// be continuous if potential or flow natures are given.\n      if (discipline_domain == IVL_DIS_NONE && (discipline_potential||discipline_flow))\n\t    discipline_domain = IVL_DIS_CONTINUOUS;\n\n      ivl_discipline_t tmp = new ivl_discipline_s(discipline_name,\n\t\t\t\t\t\t  discipline_domain,\n\t\t\t\t\t\t  discipline_potential,\n\t\t\t\t\t\t  discipline_flow);\n      disciplines[discipline_name] = tmp;\n\n      FILE_NAME(tmp, loc);\n\n\t/* Clear the static variables for the next item. */\n      discipline_name = perm_string();\n      discipline_domain = IVL_DIS_NONE;\n      discipline_potential = 0;\n      discipline_flow = 0;\n}\n\n/*\n * The parser uses this function to attach a discipline to a wire. The\n * wire may be declared by now, or will be declared further later. If\n * it is already declared, we just attach the discipline. If it is not\n * declared yet, then this is the declaration and we create the signal\n * in the current lexical scope.\n */\nvoid pform_attach_discipline(const struct vlltype&loc,\n\t\t\t     ivl_discipline_t discipline, list<pform_ident_t>*names)\n{\n      for (list<pform_ident_t>::iterator cur = names->begin()\n\t\t ; cur != names->end() ; ++ cur ) {\n\n\t    PWire* cur_net = pform_get_wire_in_scope(cur->first);\n\t    if (cur_net == 0) {\n\t\t    /* Not declared yet, declare it now. */\n\t\t  cur_net = pform_makewire(loc, *cur, NetNet::WIRE, 0);\n\t\t  ivl_assert(loc, cur_net);\n\t    }\n\n\t    if (ivl_discipline_t tmp = cur_net->get_discipline()) {\n\t\t  cerr << loc.text << \":\" << loc.first_line << \": error: \"\n\t\t       << \"discipline \" << discipline->name()\n\t\t       << \" cannot override existing discipline \" << tmp->name()\n\t\t       << \" on net \" << cur_net->basename() << endl;\n\t\t  error_count += 1;\n\n\t    } else {\n\t\t  data_type_t *type = new real_type_t(real_type_t::REAL);\n\t\t  FILE_NAME(type, loc);\n\t\t  cur_net->set_data_type(type);\n\t\t  cur_net->set_discipline(discipline);\n\t    }\n      }\n}\n"
        },
        {
          "name": "pform_dump.cc",
          "type": "blob",
          "size": 44.8427734375,
          "content": "/*\n * Copyright (c) 1998-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n/*\n * This file provides the pform_dump function, that dumps the module\n * passed as a parameter. The dump is as much as possible in Verilog\n * syntax, so that a human can tell that it really does describe the\n * module in question.\n */\n# include  \"pform.h\"\n# include  \"PClass.h\"\n# include  \"PEvent.h\"\n# include  \"PGenerate.h\"\n# include  \"PPackage.h\"\n# include  \"PSpec.h\"\n# include  \"PTask.h\"\n# include  \"discipline.h\"\n# include  \"ivl_target_priv.h\"\n# include  <iostream>\n# include  <iomanip>\n# include  <typeinfo>\n\nusing namespace std;\n\nostream& operator << (ostream&out, const PExpr&obj)\n{\n      obj.dump(out);\n      return out;\n}\n\nostream& operator << (ostream&out, const PEventStatement&obj)\n{\n      obj.dump_inline(out);\n      return out;\n}\n\nostream& operator << (ostream&o, const PDelays&d)\n{\n      d.dump_delays(o);\n      return o;\n}\n\nostream& operator<< (ostream&out, const index_component_t&that)\n{\n      out << \"[\";\n      switch (that.sel) {\n\t  case index_component_t::SEL_BIT:\n\t    out << *that.msb;\n\t    break;\n\t  case index_component_t::SEL_BIT_LAST:\n\t    out << \"$\";\n\t    break;\n\t  case index_component_t::SEL_PART:\n\t    out << *that.msb << \":\" << *that.lsb;\n\t    break;\n\t  case index_component_t::SEL_IDX_UP:\n\t    out << *that.msb << \"+:\" << *that.lsb;\n\t    break;\n\t  case index_component_t::SEL_IDX_DO:\n\t    out << *that.msb << \"-:\" << *that.lsb;\n\t    break;\n\t  default:\n\t    out << \"???\";\n\t    break;\n      }\n      out << \"]\";\n      return out;\n}\n\nostream& operator<< (ostream&out, const name_component_t&that)\n{\n      if (that.name == THIS_TOKEN)\n\t    out << \"this\";\n      else if (that.name == SUPER_TOKEN)\n\t    out << \"super\";\n      else\n\t    out << that.name.str();\n\n      typedef std::list<index_component_t>::const_iterator index_it_t;\n      for (index_it_t idx = that.index.begin()\n\t\t ; idx != that.index.end() ; ++ idx ) {\n\n\t    out << *idx;\n      }\n      return out;\n}\n\nostream& operator<< (ostream&o, const pform_name_t&that)\n{\n      pform_name_t::const_iterator cur;\n      if (that.empty()) {\n\t    o << \"<nil>\";\n\t    return o;\n      }\n\n      cur = that.begin();\n      o << *cur;\n\n      ++ cur;\n      while (cur != that.end()) {\n\t    o << \".\" << *cur;\n\t    ++ cur;\n      }\n\n      return o;\n}\n\nostream& operator<< (ostream &o, const pform_scoped_name_t &that)\n{\n      if (that.package) {\n\t    o << that.package->pscope_name() << \"::\";\n      }\n\n      o << that.name;\n      return o;\n}\n\nstd::ostream& operator << (std::ostream&out, ivl_process_type_t pt)\n{\n      switch (pt) {\n\t  case IVL_PR_INITIAL:\n\t    out << \"initial\";\n\t    break;\n\t  case IVL_PR_ALWAYS:\n\t    out << \"always\";\n\t    break;\n\t  case IVL_PR_ALWAYS_COMB:\n\t    out << \"always_comb\";\n\t    break;\n\t  case IVL_PR_ALWAYS_FF:\n\t    out << \"always_ff\";\n\t    break;\n\t  case IVL_PR_ALWAYS_LATCH:\n\t    out << \"always_latch\";\n\t    break;\n\t  case IVL_PR_FINAL:\n\t    out << \"final\";\n\t    break;\n      }\n      return out;\n}\n\nstd::ostream& operator << (std::ostream&out, ivl_dis_domain_t dom)\n{\n      switch (dom) {\n\t  case IVL_DIS_NONE:\n\t    out << \"no-domain\";\n\t    break;\n\t  case IVL_DIS_DISCRETE:\n\t    out << \"discrete\";\n\t    break;\n\t  case IVL_DIS_CONTINUOUS:\n\t    out << \"continuous\";\n\t    break;\n\t  default:\n\t    assert(0);\n\t    break;\n      }\n      return out;\n}\n\nstatic std::ostream& operator << (std::ostream &out, const std::vector<PExpr*> &exprs)\n{\n      for (size_t idx = 0; idx < exprs.size(); idx++) {\n\t    if (idx != 0)\n\t\t  out << \", \";\n\t    if (exprs[idx])\n\t\t  exprs[idx]->dump(out);\n      }\n\n      return out;\n}\n\nstatic std::ostream& operator << (std::ostream &out,\n\t\t\t          const std::vector<named_pexpr_t> &exprs)\n{\n      for (size_t idx = 0; idx < exprs.size(); idx++) {\n\t    if (idx != 0)\n\t\t  out << \", \";\n\t    if (!exprs[idx].name.nil())\n\t\t  out << \".\" << exprs[idx].name << \"(\";\n\t    if (exprs[idx].parm)\n\t\t  exprs[idx].parm->dump(out);\n\t    if (!exprs[idx].name.nil())\n\t\t  out << \")\";\n      }\n\n      return out;\n}\n\nvoid data_type_t::pform_dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << typeid(*this).name() << endl;\n}\n\nostream& data_type_t::debug_dump(ostream&out) const\n{\n      out << typeid(*this).name();\n      return out;\n}\n\nstd::ostream& typeref_t::debug_dump(ostream&out) const\n{\n      if (scope)\n\t    out << scope->pscope_name() << \"::\";\n      out << type->name;\n\n      return out;\n}\n\nostream& atom_type_t::debug_dump(ostream&out) const\n{\n      if (signed_flag)\n\t    out << \"signed \";\n      else\n\t    out << \"unsigned \";\n\n      switch (type_code) {\n      case INTEGER:\n\t    out << \"integer\";\n\t    break;\n      case TIME:\n\t    out << \"time\";\n\t    break;\n      case LONGINT:\n\t    out << \"longint\";\n\t    break;\n      case INT:\n\t    out << \"int\";\n\t    break;\n      case SHORTINT:\n\t    out << \"shortint\";\n\t    break;\n      case BYTE:\n\t    out << \"byte\";\n\t    break;\n      default:\n\t    assert(0);\n\t    break;\n      }\n      return out;\n}\n\nvoid void_type_t::pform_dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << \"void\" << endl;\n}\n\nvoid parray_type_t::pform_dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << \"Packed array \" << \"[...]\"\n\t  << \" of:\" << endl;\n      base_type->pform_dump(out, indent+4);\n}\n\nostream& real_type_t::debug_dump(ostream&out) const\n{\n      switch (type_code_) {\n\t  case REAL:\n\t    out << \"real\";\n\t    break;\n\t  case SHORTREAL:\n\t    out << \"shortreal\";\n\t    break;\n      }\n      return out;\n}\n\nvoid struct_type_t::pform_dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << \"Struct \" << (packed_flag?\"packed\":\"unpacked\")\n\t  << \" with \" << (members.get()==0? 0 : members->size()) << \" members\" << endl;\n      if (members.get()==0)\n\t    return;\n\n      for (list<struct_member_t*>::iterator cur = members->begin()\n\t\t ; cur != members->end() ; ++ cur) {\n\t    struct_member_t*curp = *cur;\n\t    curp->pform_dump(out, indent+4);\n      }\n}\n\nvoid uarray_type_t::pform_dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << \"Unpacked array \" << \"[...]\"\n\t  << \" of:\" << endl;\n      base_type->pform_dump(out, indent+4);\n}\n\nvoid vector_type_t::pform_dump(ostream&fd, unsigned indent) const\n{\n      fd << setw(indent) << \"\" << \"vector of \" << base_type;\n      if (pdims.get()) {\n\t    for (list<pform_range_t>::iterator cur = pdims->begin()\n\t\t       ; cur != pdims->end() ; ++cur) {\n\t\t  fd << \"[\";\n\t\t  if (cur->first)  fd << *(cur->first);\n\t\t  if (cur->second) fd << \":\" << *(cur->second);\n\t\t  fd << \"]\";\n\t    }\n      }\n      fd << endl;\n}\n\nostream& vector_type_t::debug_dump(ostream&fd) const\n{\n      if (signed_flag)\n\t    fd << \"signed \";\n      if (!pdims.get()) {\n\t    fd << \"/* vector_type_t nil */\";\n\t    return fd;\n      }\n\n      for (list<pform_range_t>::iterator cur = pdims->begin()\n\t\t ; cur != pdims->end() ; ++cur) {\n\t    fd << \"[\";\n\t    if (cur->first)  fd << *(cur->first);\n\t    if (cur->second) fd << \":\" << *(cur->second);\n\t    fd << \"]\";\n      }\n      return fd;\n}\n\nvoid class_type_t::pform_dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << \"class \" << name;\n\n      if (base_type) out << \" extends <type>\";\n      if (! base_args.empty()) {\n\t    out << \" (\" << base_args << \")\";\n      }\n\n      out << \" {\";\n      for (map<perm_string,prop_info_t>::const_iterator cur = properties.begin()\n\t\t ; cur != properties.end() ; ++cur) {\n\t    out << \" \" << cur->first;\n      }\n\n      out << \" }\" << endl;\n\n      if (base_type) base_type->pform_dump(out, indent+4);\n}\n\nvoid class_type_t::pform_dump_init(ostream&out, unsigned indent) const\n{\n      for (vector<Statement*>::const_iterator cur = initialize.begin()\n\t\t ; cur != initialize.end() ; ++cur) {\n\t    Statement*curp = *cur;\n\t    curp->dump(out,indent+4);\n      }\n}\n\nvoid struct_member_t::pform_dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << (type.get()? typeid(*type).name() : \"<nil type>\");\n      for (list<decl_assignment_t*>::iterator cur = names->begin()\n\t\t ; cur != names->end() ; ++cur) {\n\t    decl_assignment_t*curp = *cur;\n\t    out << \" \" << curp->name.first;\n      }\n      out << \";\" << endl;\n}\n\nstatic void dump_attributes_map(ostream&out,\n\t\t\t\tconst map<perm_string,PExpr*>&attributes,\n\t\t\t\tint ind)\n{\n      for (map<perm_string,PExpr*>::const_iterator idx = attributes.begin()\n\t\t ; idx != attributes.end() ; ++ idx ) {\n\n\t    out << setw(ind) << \"\" << \"(* \" << (*idx).first;\n\t    if ((*idx).second) {\n\t\t  out << \" = \" << *(*idx).second;\n\t    }\n\t    out << \" *)\" << endl;\n      }\n}\n\nvoid PExpr::dump(ostream&out) const\n{\n      out << typeid(*this).name();\n}\n\nvoid PEAssignPattern::dump(ostream&out) const\n{\n      out << \"'{\" << parms_ << \"}\";\n}\n\nvoid PEConcat::dump(ostream&out) const\n{\n      if (repeat_)\n\t    out << \"{\" << *repeat_;\n\n      if (parms_.empty()) {\n\t    out << \"{}\";\n\t    return;\n      }\n\n      out << \"{\" << parms_ << \"}\";\n\n      if (repeat_) out << \"}\";\n}\n\nvoid PECallFunction::dump(ostream &out) const\n{\n      out << path_ << \"(\" << parms_ << \")\";\n}\n\nvoid PECastSize::dump(ostream &out) const\n{\n      out << *size_ << \"'(\";\n      base_->dump(out);\n      out << \")\";\n}\n\nvoid PECastType::dump(ostream &out) const\n{\n      target_->pform_dump(out, 0);\n      out << \"'(\";\n      base_->dump(out);\n      out << \")\";\n}\n\nvoid PECastSign::dump(ostream &out) const\n{\n      if (!signed_flag_)\n\t    out << \"un\";\n      out << \"signed'(\";\n      base_->dump(out);\n      out << \")\";\n}\n\nvoid PEEvent::dump(ostream&out) const\n{\n      switch (type_) {\n\t  case PEEvent::ANYEDGE:\n\t    break;\n\t  case PEEvent::POSEDGE:\n\t    out << \"posedge \";\n\t    break;\n\t  case PEEvent::NEGEDGE:\n\t    out << \"negedge \";\n\t    break;\n\t  case PEEvent::EDGE:\n\t    out << \"edge \";\n\t    break;\n\t  case PEEvent::POSITIVE:\n\t    out << \"positive \";\n\t    break;\n      }\n      out << *expr_;\n\n}\n\nvoid PEFNumber::dump(ostream &out) const\n{\n      out << value();\n}\n\nvoid PENewArray::dump(ostream&out) const\n{\n      out << \"new [\" << *size_ << \"]\";\n      if (init_)\n\t    out << \"(\" << *init_ << \")\";\n}\n\nvoid PENewClass::dump(ostream&out) const\n{\n      out << \"class_new(\" << parms_ << \")\";\n}\n\nvoid PENewCopy::dump(ostream&out) const\n{\n      out << \"copy_new(\";\n      src_->dump(out);\n      out << \")\";\n}\n\nvoid PENull::dump(ostream&out) const\n{\n      out << \"null\";\n}\n\nvoid PENumber::dump(ostream&out) const\n{\n      out << value();\n}\n\nvoid PEIdent::dump(ostream&out) const\n{\n      out << path_;\n}\n\nvoid PEString::dump(ostream&out) const\n{\n      out << \"\\\"\" << text_ << \"\\\"\";\n}\n\nvoid PETernary::dump(ostream&out) const\n{\n      out << \"(\" << *expr_ << \")?(\" << *tru_ << \"):(\" << *fal_ << \")\";\n}\n\nvoid PETypename::dump(ostream&fd) const\n{\n      fd << \"<type>\";\n}\n\nvoid PEUnary::dump(ostream&out) const\n{\n      switch (op_) {\n\t  case 'm':\n\t    out << \"abs\";\n\t    break;\n\t  default:\n\t    out << op_;\n\t    break;\n      }\n      out << \"(\" << *expr_ << \")\";\n}\n\nvoid PEBinary::dump(ostream&out) const\n{\n\t/* Handle some special cases, where the operators are written\n\t   in function notation. */\n      if (op_ == 'm') {\n\t    out << \"min(\" << *left_ << \",\" << *right_ << \")\";\n\t    return;\n      }\n      if (op_ == 'M') {\n\t    out << \"min(\" << *left_ << \",\" << *right_ << \")\";\n\t    return;\n      }\n\n      if (left_)\n\t    out << \"(\" << *left_ << \")\";\n      else\n\t    out << \"(<nil>)\";\n      switch (op_) {\n\t  case 'a':\n\t    out << \"&&\";\n\t    break;\n\t  case 'e':\n\t    out << \"==\";\n\t    break;\n\t  case 'E':\n\t    out << \"===\";\n\t    break;\n\t  case 'G':\n\t    out << \">=\";\n\t    break;\n\t  case 'l':\n\t    out << \"<<\";\n\t    break;\n\t  case 'L':\n\t    out << \"<=\";\n\t    break;\n\t  case 'n':\n\t    out << \"!=\";\n\t    break;\n\t  case 'N':\n\t    out << \"!==\";\n\t    break;\n\t  case 'p':\n\t    out << \"**\";\n\t    break;\n\t  case 'R':\n\t    out << \">>>\";\n\t    break;\n\t  case 'r':\n\t    out << \">>\";\n\t    break;\n\t  default:\n\t    out << op_;\n\t    break;\n      }\n      if (right_)\n\t    out << \"(\" << *right_ << \")\";\n      else\n\t    out << \"(<nil>)\";\n}\n\n\nvoid PWire::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << type_;\n\n      switch (port_type_) {\n\t  case NetNet::PIMPLICIT:\n\t    out << \" implicit input\";\n\t    break;\n\t  case NetNet::PINPUT:\n\t    out << \" input\";\n\t    break;\n\t  case NetNet::POUTPUT:\n\t    out << \" output\";\n\t    break;\n\t  case NetNet::PINOUT:\n\t    out << \" inout\";\n\t    break;\n\t  case NetNet::PREF:\n\t    out << \" ref\";\n\t    break;\n\t  case NetNet::NOT_A_PORT:\n\t    break;\n      }\n\n      if (signed_) {\n\t    out << \" signed\";\n      }\n      if (is_scalar_) {\n\t    out << \" scalar\";\n      }\n      if (set_data_type_) {\n\t    out << \" set_data_type_=\" << *set_data_type_;\n      }\n\n      if (discipline_) {\n\t    out << \" discipline<\" << discipline_->name() << \">\";\n      }\n\n      if (port_set_) {\n\t    if (port_.empty()) {\n\t\t  out << \" port<scalar>\";\n\t    } else {\n\t\t  out << \" port\";\n\t\t  for (list<pform_range_t>::const_iterator cur = port_.begin()\n\t\t\t     ; cur != port_.end() ; ++cur) {\n\t\t\tout << \"[\";\n\t\t\tif (cur->first)  out << *cur->first;\n\t\t\tif (cur->second) out << \":\" << *cur->second;\n\t\t\tout << \"]\";\n\t\t  }\n\t    }\n      }\n      if (net_set_) {\n\t    if (net_.empty()) {\n\t\t  out << \" net<scalar>\";\n\t    } else {\n\t\t  out << \" net\";\n\t\t  for (list<pform_range_t>::const_iterator cur = net_.begin()\n\t\t\t     ; cur != net_.end() ; ++cur) {\n\t\t\tout << \"[\";\n\t\t\tif (cur->first)  out << *cur->first;\n\t\t\tif (cur->second) out << \":\" << *cur->second;\n\t\t\tout << \"]\";\n\t\t  }\n\t    }\n      }\n\n      out << \" \" << name_;\n\n\t// If the wire has unpacked indices, dump them.\n      for (list<pform_range_t>::const_iterator cur = unpacked_.begin()\n\t\t ; cur != unpacked_.end() ; ++cur) {\n\t    out << \"[\";\n\t    if (cur->first) out << *cur->first;\n\t    if (cur->second) out << \":\" << *cur->second;\n\t    out << \"]\";\n      }\n\n      out << \";\" << endl;\n      if (set_data_type_) {\n\t    set_data_type_->pform_dump(out, 8);\n      }\n\n      dump_attributes_map(out, attributes, 8);\n}\n\nvoid PGate::dump_pins(ostream&out) const\n{\n      if (pin_count()) {\n\t    if (pin(0)) out << *pin(0);\n\n\t    for (unsigned idx = 1 ;  idx < pin_count() ;  idx += 1) {\n\t\t  out << \", \";\n\t\t  if (pin(idx)) out << *pin(idx);\n\t    }\n      }\n}\n\nvoid PDelays::dump_delays(ostream&out) const\n{\n      if (delay_[0] && delay_[1] && delay_[2])\n\t    out << \"#(\" << *delay_[0] << \",\" << *delay_[1] << \",\" <<\n\t\t  *delay_[2] << \")\";\n      else if (delay_[0] && delay_[1])\n\t    out << \"#(\" << *delay_[0] << \",\" << *delay_[1] << \")\";\n      else if (delay_[0])\n\t    out << \"#\" << *delay_[0];\n      else\n\t    out << \"#0\";\n\n}\n\nvoid PGate::dump_delays(ostream&out) const\n{\n      delay_.dump_delays(out);\n}\n\nvoid PGate::dump_ranges(ostream&out) const\n{\n      if (ranges_ == 0) return;\n      for (list<pform_range_t>::iterator cur = ranges_->begin()\n\t\t ; cur != ranges_->end() ; ++cur) {\n\t    out << \"[\";\n\t    if (cur->first)  out << *(cur->first);\n\t    if (cur->second) out << \":\" << *(cur->second);\n\t    out << \"]\";\n      }\n}\n\nvoid PGate::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << typeid(*this).name() << \" \";\n      delay_.dump_delays(out);\n      out << \" \" << get_name() << \"(\";\n      dump_pins(out);\n      out << \");\" << endl;\n\n}\n\nvoid PGAssign::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\";\n      out << \"assign (\" << strength0() << \"0 \" << strength1() << \"1) \";\n      dump_delays(out);\n      out << \" \" << *pin(0) << \" = \" << *pin(1) << \";\" << endl;\n}\n\nvoid PGBuiltin::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\";\n      switch (type()) {\n\t  case PGBuiltin::BUFIF0:\n\t    out << \"bufif0 \";\n\t    break;\n\t  case PGBuiltin::BUFIF1:\n\t    out << \"bufif1 \";\n\t    break;\n\t  case PGBuiltin::NOTIF0:\n\t    out << \"notif0 \";\n\t    break;\n\t  case PGBuiltin::NOTIF1:\n\t    out << \"notif1 \";\n\t    break;\n\t  case PGBuiltin::NAND:\n\t    out << \"nand \";\n\t    break;\n\t  case PGBuiltin::NMOS:\n\t    out << \"nmos \";\n\t    break;\n\t  case PGBuiltin::RNMOS:\n\t    out << \"rnmos \";\n\t    break;\n\t  case PGBuiltin::RPMOS:\n\t    out << \"rpmos \";\n\t    break;\n\t  case PGBuiltin::PMOS:\n\t    out << \"pmos \";\n\t    break;\n\t  case PGBuiltin::RCMOS:\n\t    out << \"rcmos \";\n\t    break;\n\t  case PGBuiltin::CMOS:\n\t    out << \"cmos \";\n\t    break;\n\t  default:\n\t    out << \"builtin gate \";\n      }\n\n      out << \"(\" << strength0() << \"0 \" << strength1() << \"1) \";\n      dump_delays(out);\n      out << \" \" << get_name();\n      dump_ranges(out);\n      out << \"(\";\n      dump_pins(out);\n      out << \");\" << endl;\n}\n\nvoid PGModule::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << type_ << \" \";\n\n\t// If parameters are overridden by order, dump them.\n      if (overrides_ && (! overrides_->empty())) {\n\t    assert(parms_ == 0);\n            out << \"#(\";\n\n\t    list<PExpr*>::const_iterator idx = overrides_->begin();\n\n\t    if (*idx == 0)\n\t\t  out << \"<nil>\";\n\t    else\n\t\t  out << *idx;\n\t    for ( ;  idx != overrides_->end() ;  ++ idx) {\n\t          out << \",\" << *idx;\n\t    }\n\t    out << \") \";\n      }\n\n\t// If parameters are overridden by name, dump them.\n      if (parms_) {\n\t    assert(overrides_ == 0);\n\t    out << \"#(\" << parms_ << \") \";\n      }\n\n      out << get_name();\n      dump_ranges(out);\n      out << \"(\";\n      if (pins_) {\n\t    out << \".\" << pins_[0].name << \"(\";\n\t    if (pins_[0].parm) out << *pins_[0].parm;\n\t    out << \")\";\n\t    for (unsigned idx = 1 ;  idx < npins_ ;  idx += 1) {\n\t\t  out << \", .\" << pins_[idx].name << \"(\";\n\t\t  if (pins_[idx].parm)\n\t\t\tout << *pins_[idx].parm;\n\t\t  out << \")\";\n\t    }\n      } else {\n\t    dump_pins(out);\n      }\n      out << \");\" << endl;\n      dump_attributes_map(out, attributes, 8);\n}\n\nvoid Statement::dump(ostream&out, unsigned ind) const\n{\n\t/* I give up. I don't know what type this statement is,\n\t   so just print the C++ typeid and let the user figure\n\t   it out. */\n      out << setw(ind) << \"\";\n      out << \"/* \" << get_fileline() << \": \" << typeid(*this).name()\n\t  << \" */ ;\" << endl;\n      dump_attributes_map(out, attributes, ind+2);\n}\n\nvoid AContrib::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\";\n      out << *lval_ << \" <+ \" << *rval_\n\t  << \"; /* \" << get_fileline() << \" */\"\n\t  << endl;\n}\n\nvoid PAssign::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\";\n      if (lval()) out << *lval();\n      else out << \"<dummy>\";\n      out << \" = \";\n      if (delay_) out << \"#\" << *delay_ << \" \";\n      if (count_) out << \"repeat(\" << *count_ << \") \";\n      if (event_) out << *event_ << \" \";\n      PExpr*rexpr = rval();\n      if (rexpr) out << *rval() << \";\";\n      else out << \"<no rval>;\";\n      out << \"  /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid PAssignNB::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << *lval() << \" <= \";\n      if (delay_) out << \"#\" << *delay_ << \" \";\n      if (count_) out << \"repeat(\" << *count_ << \") \";\n      if (event_) out << *event_ << \" \";\n      out << *rval() << \";\" << \"  /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid PBlock::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"begin\";\n      if (pscope_name() != 0)\n\t    out << \" : \" << pscope_name();\n      out << endl;\n\n      if (pscope_name() != 0) {\n            dump_parameters_(out, ind+2);\n\n            dump_events_(out, ind+2);\n\n\t    dump_wires_(out, ind+2);\n\n\t    dump_var_inits_(out, ind+2);\n      }\n\n      for (unsigned idx = 0 ;  idx < list_.size() ;  idx += 1) {\n\t    if (list_[idx])\n\t\t  list_[idx]->dump(out, ind+2);\n\t    else\n\t\t  out << setw(ind+2) << \"\" << \"/* NOOP */ ;\" << endl;\n      }\n\n      out << setw(ind) << \"\" << \"end\" << endl;\n}\n\nvoid PBreak::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"break;\" << endl;\n}\n\nvoid PCallTask::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << path_;\n\n      if (! parms_.empty()) {\n\t    out << \"(\" << parms_ << \")\";\n      }\n\n      out << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid PCase::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\";\n      switch (quality_) {\n\t  case IVL_CASE_QUALITY_BASIC:\n\t    break;\n\t  case IVL_CASE_QUALITY_UNIQUE:\n\t    out << \"unique \";\n\t    break;\n\t  case IVL_CASE_QUALITY_UNIQUE0:\n\t    out << \"unique0 \";\n\t    break;\n\t  case IVL_CASE_QUALITY_PRIORITY:\n\t    out << \"priority \";\n\t    break;\n      }\n      switch (type_) {\n\t  case NetCase::EQ:\n\t    out << \"case\";\n\t    break;\n\t  case NetCase::EQX:\n\t    out << \"casex\";\n\t    break;\n\t  case NetCase::EQZ:\n\t    out << \"casez\";\n\t    break;\n      }\n      out << \" (\" << *expr_ << \") /* \" << get_fileline() << \" */\" << endl;\n      dump_attributes_map(out, attributes, ind+2);\n\n      for (unsigned idx = 0 ;  idx < items_->size() ;  idx += 1) {\n\t    PCase::Item*cur = (*items_)[idx];\n\n\t    if (cur->expr.empty()) {\n\t\t  out << setw(ind+2) << \"\" << \"default:\";\n\n\t    } else {\n\t\t  list<PExpr*>::iterator idx_exp = cur->expr.begin();\n\t\t  out << setw(ind+2) << \"\";\n\t\t  (*idx_exp)->dump(out);\n\n\t\t  for (++idx_exp ; idx_exp != cur->expr.end() ; ++idx_exp) {\n\t\t\tout << \", \";\n\t\t\t(*idx_exp)->dump(out);\n\t\t  }\n\n\t\t  out << \":\";\n\t    }\n\n\t    if (cur->stat) {\n\t\t  out << endl;\n\t\t  cur->stat->dump(out, ind+6);\n\t    } else {\n\t\t  out << \" ;\" << endl;\n\t    }\n      }\n\n      out << setw(ind) << \"\" << \"endcase\" << endl;\n}\n\nvoid PChainConstructor::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"super.new(\" << parms_ << \")\" <<endl;\n}\n\nvoid PCondit::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"if (\" << *expr_ << \")\" << endl;\n      if (if_)\n\t    if_->dump(out, ind+3);\n      else\n\t    out << setw(ind) << \";\" << endl;\n      if (else_) {\n\t    out << setw(ind) << \"\" << \"else\" << endl;\n\t    else_->dump(out, ind+3);\n      }\n}\n\nvoid PContinue::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"continue;\" << endl;\n}\n\nvoid PCAssign::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"assign \" << *lval_ << \" = \" << *expr_\n\t  << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid PDeassign::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"deassign \" << *lval_ << \"; /* \"\n\t  << get_fileline() << \" */\" << endl;\n}\n\nvoid PDelayStatement::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"#\" << *delay_ << \" /* \" <<\n\t    get_fileline() << \" */\";\n      if (statement_) {\n\t    out << endl;\n\t    statement_->dump(out, ind+2);\n      } else {\n\t    out << \" /* noop */;\" << endl;\n      }\n}\n\nvoid PDisable::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"disable \";\n      if (scope_.empty()) out << scope_;\n      else out << \"fork\";\n      out << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid PDoWhile::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"do\" << endl;\n      if (statement_)\n\t    statement_->dump(out, ind+3);\n      else\n\t    out << setw(ind+3) << \"\" << \"/* NOOP */\" << endl;\n      out << setw(ind) << \"\" << \"while (\" << *cond_ << \");\" << endl;\n}\n\nvoid PEventStatement::dump(ostream&out, unsigned ind) const\n{\n      if (expr_.size() == 0) {\n\t    out << setw(ind) << \"\" << \"@* \";\n\n      } else if ((expr_.size() == 1) && (expr_[0] == 0)) {\n\t    out << setw(ind) << \"\" << \"wait fork \";\n\n      } else {\n\t    out << setw(ind) << \"\" << \"@(\" << *(expr_[0]);\n\t    if (expr_.size() > 1)\n\t\t  for (unsigned idx = 1 ;  idx < expr_.size() ;  idx += 1)\n\t\t\tout << \" or \" << *(expr_[idx]);\n\n\t    out << \")\";\n      }\n\n      if (statement_) {\n\t    out << endl;\n\t    statement_->dump(out, ind+2);\n      } else {\n\t    out << \" ;\" << endl;\n      }\n}\n\nvoid PEventStatement::dump_inline(ostream&out) const\n{\n      assert(statement_ == 0);\n\n      if (expr_.size() == 0) {\n\t    out << \"@* \";\n\n      } else {\n\t    out << \"@(\" << *(expr_[0]);\n\t    if (expr_.size() > 1)\n\t\t  for (unsigned idx = 1 ;  idx < expr_.size() ;  idx += 1)\n\t\t\tout << \" or \" << *(expr_[idx]);\n\n\t    out << \")\";\n      }\n}\n\nvoid PForce::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"force \" << *lval_ << \" = \" << *expr_\n\t  << \"; /* \" << get_fileline() << \" */\" << endl;\n}\n\nvoid PForeach::dump(ostream&fd, unsigned ind) const\n{\n      fd << setw(ind) << \"\" << \"foreach \"\n\t << \"variable=\" << array_var_\n\t << \", indices=[\";\n      for (size_t idx = 0 ; idx < index_vars_.size() ; idx += 1) {\n\t    if (idx > 0) fd << \",\";\n\t    fd << index_vars_[idx];\n      }\n\n      fd << \"] /* \" << get_fileline() << \" */\" << endl;\n      if (statement_)\n\t    statement_->dump(fd, ind+3);\n      else\n\t    fd << setw(ind+3) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PForever::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"forever /* \" << get_fileline() << \" */\" << endl;\n      if (statement_)\n\t    statement_->dump(out, ind+3);\n      else\n\t    out << setw(ind+3) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PForStatement::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"for (\";\n      if (name1_)\n\t    out << *name1_;\n      else\n\t    out << \"<no-name1>\";\n      out << \" = \";\n      if (expr1_)\n\t    out << *expr1_;\n      else\n\t    out << \"<no-expr1>\";\n      out << \"; \";\n      if (cond_)\n\t    out << *cond_;\n      else\n\t    out << \"<no-cond>\";\n      out << \"; <for_step>)\" << endl;\n      if (step_)\n\t    step_->dump(out, ind+6);\n      else\n\t    out << setw(ind+6) << \"\" << \"<no for_step statement>\" << endl;\n      if (statement_)\n\t    statement_->dump(out, ind+3);\n      else\n\t    out << setw(ind+3) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PFunction::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"function \";\n      if (is_auto_) out << \"automatic \";\n\n      out << pscope_name() << \";\" << endl;\n      if (method_of())\n\t    out << setw(ind) << \"\" << \"method of \" << method_of()->name << \";\" << endl;\n\n      if (return_type_)\n\t    return_type_->pform_dump(out, ind+8);\n      else\n\t    out << setw(ind+8) << \"\" << \"<implicit type>\" << endl;\n\n      dump_ports_(out, ind+2);\n\n      dump_parameters_(out, ind+2);\n\n      dump_events_(out, ind+2);\n\n      dump_wires_(out, ind+2);\n\n      dump_var_inits_(out, ind+2);\n\n      if (statement_)\n\t    statement_->dump(out, ind+2);\n      else\n\t    out << setw(ind+2) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PLet::let_port_t::dump(ostream&out, unsigned) const\n{\n      if (type_) out << *type_ << \" \";\n      out << name_;\n\t// FIXME: This has not been tested and is likely wrong!\n      if (range_) out << \" \" << range_;\n      if (def_) out << \"=\" << *def_;\n}\n\nvoid PLet::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"let \";\n      out << pscope_name();\n      if (ports_) {\n\t    out << \"(\";\n\t    typedef std::list<let_port_t*>::const_iterator port_itr_t;\n\t    port_itr_t idx = ports_->begin();\n\t    (*idx)->dump(out, 0);\n\t    for (++idx; idx != ports_->end(); ++idx ) {\n\t\t  out << \", \";\n\t\t  (*idx)->dump(out, 0);\n\t    }\n\t    out << \")\";\n      }\n      out << \" = \" << *expr_ << \";\" << endl;\n}\n\nvoid PRelease::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"release \" << *lval_ << \"; /* \"\n\t  << get_fileline() << \" */\" << endl;\n}\n\nvoid PRepeat::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"repeat (\" << *expr_ << \")\" << endl;\n      if (statement_)\n\t    statement_->dump(out, ind+3);\n      else\n\t    out << setw(ind+3) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PReturn::dump(ostream&fd, unsigned ind) const\n{\n      fd << setw(ind) << \"\" << \"return (\";\n      if (expr_) fd << *expr_;\n      fd << \")\" << endl;\n}\n\nvoid PTask::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"task \";\n      if (is_auto_) out << \"automatic \";\n      out << pscope_name() << \";\" << endl;\n      if (method_of())\n\t    out << setw(ind) << \"\" << \"method of \" << method_of()->name << \";\" << endl;\n      dump_ports_(out, ind+2);\n\n      dump_parameters_(out, ind+2);\n\n      dump_events_(out, ind+2);\n\n      dump_wires_(out, ind+2);\n\n      dump_var_inits_(out, ind+2);\n\n      if (statement_)\n\t    statement_->dump(out, ind+2);\n      else\n\t    out << setw(ind+2) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PTaskFunc::dump_ports_(std::ostream&out, unsigned ind) const\n{\n      if (ports_ == 0)\n\t    return;\n\n      for (unsigned idx = 0 ; idx < ports_->size() ; idx += 1) {\n\t    if (ports_->at(idx).port == 0) {\n\t\t  out << setw(ind) << \"\" << \"ERROR PORT\" << endl;\n\t\t  continue;\n\t    }\n\n\t    out << setw(ind) << \"\";\n\t    switch (ports_->at(idx).port->get_port_type()) {\n\t\tcase NetNet::PINPUT:\n\t\t  out << \"input \";\n\t\t  break;\n\t\tcase NetNet::POUTPUT:\n\t\t  out << \"output \";\n\t\t  break;\n\t\tcase NetNet::PINOUT:\n\t\t  out << \"inout \";\n\t\t  break;\n\t\tcase NetNet::PIMPLICIT:\n\t\t  out << \"PIMPLICIT\";\n\t\t  break;\n\t\tcase NetNet::NOT_A_PORT:\n\t\t  out << \"NOT_A_PORT\";\n\t\t  break;\n\t\tdefault:\n\t\t  assert(0);\n\t\t  break;\n\t    }\n\t    out << ports_->at(idx).port->basename();\n\t    if (ports_->at(idx).defe) {\n\t\t  out << \" = \" << *ports_->at(idx).defe;\n\t    }\n\t    out << \";\" << endl;\n      }\n}\n\nvoid PTrigger::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"-> \" << event_ << \";\" << endl;\n}\n\nvoid PNBTrigger::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"->> \";\n      if (dly_) out << \"#\" << *dly_ << \" \";\n      out << event_ << \";\" << endl;\n}\n\nvoid PWhile::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"while (\" << *cond_ << \")\" << endl;\n      if (statement_)\n\t    statement_->dump(out, ind+3);\n      else\n\t    out << setw(ind+3) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PProcess::dump(ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << type_\n\t  << \" /* \" << get_fileline() << \" */\" << endl;\n\n      dump_attributes_map(out, attributes, ind+2);\n\n      if (statement_)\n\t    statement_->dump(out, ind+2);\n      else\n\t    out << setw(ind+2) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid AProcess::dump(ostream&out, unsigned ind) const\n{\n      switch (type_) {\n\t  case IVL_PR_INITIAL:\n\t    out << setw(ind) << \"\" << \"analog initial\";\n\t    break;\n\t  case IVL_PR_ALWAYS:\n\t    out << setw(ind) << \"\" << \"analog\";\n\t    break;\n\t  case IVL_PR_ALWAYS_COMB:\n\t  case IVL_PR_ALWAYS_FF:\n\t  case IVL_PR_ALWAYS_LATCH:\n\t    assert(0);\n\t    break;\n\t  case IVL_PR_FINAL:\n\t    out << setw(ind) << \"\" << \"analog final\";\n\t    break;\n      }\n\n      out << \" /* \" << get_fileline() << \" */\" << endl;\n\n      dump_attributes_map(out, attributes, ind+2);\n\n      if (statement_)\n\t    statement_->dump(out, ind+2);\n      else\n\t    out << setw(ind+2) << \"\" << \"/* NOOP */\" << endl;\n}\n\nvoid PSpecPath::dump(std::ostream&out, unsigned ind) const\n{\n      out << setw(ind) << \"\" << \"specify path \";\n\n      if (condition)\n\t    out << \"if (\" << *condition << \") \";\n\n      out << \"(\";\n      if (edge) {\n\t    if (edge > 0)\n\t\t  out << \"posedge \";\n\t    else\n\t\t  out << \"negedge \";\n      }\n\n      for (unsigned idx = 0 ;  idx < src.size() ;  idx += 1) {\n\t    if (idx > 0) out << \", \";\n\t    assert(src[idx]);\n\t    out << src[idx];\n      }\n\n      out << \" \";\n      if (polarity_) out << polarity_;\n      if (full_flag_) out << \"*> \";\n      else out << \"=> \";\n\n      if (data_source_expression)\n\t    out << \"(\";\n\n      for (unsigned idx = 0 ; idx < dst.size() ;  idx += 1) {\n\t    if (idx > 0) out << \", \";\n\t    assert(dst[idx]);\n\t    out << dst[idx];\n      }\n\n      if (data_source_expression)\n\t    out << \" : \" << *data_source_expression << \")\";\n\n      out << \") = (\";\n      for (unsigned idx = 0 ;  idx < delays.size() ;  idx += 1) {\n\t    if (idx > 0) out << \", \";\n\t    assert(delays[idx]);\n\t    out << *delays[idx];\n      }\n      out << \");\" << endl;\n}\n\nvoid PRecRem::dump(std::ostream&out, unsigned ind) const\n{\n\t    out << setw(ind) << \"\" << \"recrem \";\n}\n\nvoid PSetupHold::dump(std::ostream&out, unsigned ind) const\n{\n\t    out << setw(ind) << \"\" << \"setuphold \";\n}\n\nvoid PGenerate::dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << \"generate(\" << id_number << \")\";\n\n      PGenerate*parent = dynamic_cast<PGenerate*>(parent_scope());\n      switch (scheme_type) {\n\t  case GS_NONE:\n\t    break;\n\t  case GS_LOOP:\n\t    out << \" for (\"\n\t\t<< loop_index\n\t\t<< \"=\" << *loop_init\n\t\t<< \"; \" << *loop_test\n\t\t<< \"; \" << loop_index\n\t\t<< \"=\" << *loop_step << \")\";\n\t    break;\n\t  case GS_CONDIT:\n\t    out << \" if (\" << *loop_test << \")\";\n\t    break;\n\t  case GS_ELSE:\n\t    out << \" else !(\" << *loop_test << \")\";\n\t    break;\n\t  case GS_CASE:\n\t    out << \" case (\" << *loop_test << \")\";\n\t    break;\n\t  case GS_CASE_ITEM:\n            assert(parent);\n\t    if (loop_test)\n\t\t  out << \" (\" << *loop_test << \") == (\" << *parent->loop_test << \")\";\n\t    else\n\t\t  out << \" default:\";\n\t    break;\n\t  case GS_NBLOCK:\n\t    out << \" begin\";\n      }\n\n      if (scope_name)\n\t    out << \" : \" << scope_name;\n\n      out << endl;\n\n      dump_parameters_(out, indent+2);\n\n      typedef list<PGenerate::named_expr_t>::const_iterator parm_hiter_t;\n      for (parm_hiter_t cur = defparms.begin()\n\t\t ; cur != defparms.end() ;  ++ cur ) {\n\t    out << setw(indent+2) << \"\" << \"defparam \" << (*cur).first << \" = \";\n\t    if ((*cur).second)\n\t\t  out << *(*cur).second << \";\" << endl;\n\t    else\n\t\t  out << \"/* ERROR */;\" << endl;\n      }\n\n      dump_events_(out, indent+2);\n\n      dump_wires_(out, indent+2);\n\n      for (list<PGate*>::const_iterator idx = gates.begin()\n\t\t ; idx != gates.end() ; ++ idx ) {\n\t    (*idx)->dump(out, indent+2);\n      }\n\n      dump_var_inits_(out, indent+2);\n\n      for (list<PProcess*>::const_iterator idx = behaviors.begin()\n\t\t ; idx != behaviors.end() ; ++ idx ) {\n\t    (*idx)->dump(out, indent+2);\n      }\n\n      for (list<AProcess*>::const_iterator idx = analog_behaviors.begin()\n\t\t ; idx != analog_behaviors.end() ; ++ idx ) {\n\t    (*idx)->dump(out, indent+2);\n      }\n\n      for (list<PCallTask*>::const_iterator idx = elab_tasks.begin()\n\t\t ; idx != elab_tasks.end() ; ++ idx ) {\n\t    (*idx)->dump(out, indent+2);\n      }\n\n      typedef map<perm_string,LineInfo*>::const_iterator genvar_iter_t;\n      for (genvar_iter_t cur = genvars.begin()\n\t\t ; cur != genvars.end() ; ++ cur ) {\n\t    out << setw(indent+2) << \"\" << \"genvar \" << ((*cur).first) << \";\" << endl;\n      }\n\n      for (list<PGenerate*>::const_iterator idx = generate_schemes.begin()\n\t\t ; idx != generate_schemes.end() ; ++ idx ) {\n\t    (*idx)->dump(out, indent+2);\n      }\n\n      if (scheme_type == GS_NBLOCK) {\n\t    out << setw(indent) << \"\" << \"end endgenerate\" << endl;\n      } else {\n\t    out << setw(indent) << \"\" << \"endgenerate\" << endl;\n      }\n}\n\nvoid LexicalScope::dump_typedefs_(ostream&out, unsigned indent) const\n{\n      typedef typedef_map_t::const_iterator iter_t;\n      for (iter_t cur = typedefs.begin() ; cur != typedefs.end() ; ++ cur) {\n\t    out << setw(indent) << \"\" << \"typedef of \" << cur->first << \":\" << endl;\n\t    cur->second->get_data_type()->pform_dump(out, indent+4);\n      }\n}\n\nvoid LexicalScope::dump_parameters_(ostream&out, unsigned indent) const\n{\n      typedef map<perm_string,param_expr_t*>::const_iterator parm_iter_t;\n      for (parm_iter_t cur = parameters.begin()\n\t\t ; cur != parameters.end() ; ++ cur ) {\n\t    out << setw(indent) << \"\";\n\t    if (cur->second->local_flag)\n\t\t  out << \"localparam \";\n\t    else\n\t\t  out << \"parameter \";\n\t    if (cur->second->data_type)\n\t          cur->second->data_type->debug_dump(out);\n\t    else\n\t\t  out << \"(nil type)\";\n\t    if ((*cur).second->expr)\n\t\t  out << \" \" << (*cur).first << \" = \"\n\t\t      << *(*cur).second->expr;\n\t    for (LexicalScope::range_t*tmp = (*cur).second->range\n\t\t       ; tmp ; tmp = tmp->next) {\n\t\t  if (tmp->exclude_flag)\n\t\t\tout << \" exclude \";\n\t\t  else\n\t\t\tout << \" from \";\n\t\t  if (tmp->low_open_flag)\n\t\t\tout << \"(\";\n\t\t  else\n\t\t\tout << \"[\";\n\t\t  if (tmp->low_expr)\n\t\t\tout << *(tmp->low_expr);\n\t\t  else if (tmp->low_open_flag==false)\n\t\t\tout << \"-inf\";\n\t\t  else\n\t\t\tout << \"<nil>\";\n\t\t  out << \":\";\n\t\t  if (tmp->high_expr)\n\t\t\tout << *(tmp->high_expr);\n\t\t  else if (tmp->high_open_flag==false)\n\t\t\tout << \"inf\";\n\t\t  else\n\t\t\tout << \"<nil>\";\n\t\t  if (tmp->high_open_flag)\n\t\t\tout << \")\";\n\t\t  else\n\t\t\tout << \"]\";\n\t    }\n\t    out << \";\" << endl;\n      }\n}\n\nvoid LexicalScope::dump_enumerations_(ostream&out, unsigned indent) const\n{\n      for (vector<enum_type_t*>::const_iterator cur = enum_sets.begin()\n\t\t ; cur != enum_sets.end() ; ++ cur) {\n\t    out << setw(indent) << \"\" << \"enum {\" << endl;\n\n\t    for (list<named_pexpr_t>::const_iterator idx = (*cur)->names->begin()\n\t\t       ; idx != (*cur)->names->end() ; ++ idx) {\n\t\t  out << setw(indent+4) << \"\" << idx->name\n\t\t      << \" = \" << idx->parm << endl;\n\t    }\n\n\t    out << setw(indent) << \"\" << \"}\" << endl;\n      }\n}\n\nvoid LexicalScope::dump_events_(ostream&out, unsigned indent) const\n{\n      for (map<perm_string,PEvent*>::const_iterator cur = events.begin()\n\t\t ; cur != events.end() ; ++ cur ) {\n\t    PEvent*ev = (*cur).second;\n\t    out << setw(indent) << \"\" << \"event \" << ev->name() << \"; // \"\n\t\t<< ev->get_fileline() << endl;\n      }\n}\n\nvoid LexicalScope::dump_wires_(ostream&out, unsigned indent) const\n{\n\t// Iterate through and display all the wires.\n      for (map<perm_string,PWire*>::const_iterator wire = wires.begin()\n\t\t ; wire != wires.end() ; ++ wire ) {\n\n\t    (*wire).second->dump(out, indent);\n      }\n}\n\nvoid LexicalScope::dump_var_inits_(ostream&out, unsigned indent) const\n{\n\t// Iterate through and display all the register initializations.\n      for (unsigned idx = 0; idx < var_inits.size(); idx += 1) {\n\t    var_inits[idx]->dump(out, indent);\n      }\n}\n\nvoid PScopeExtra::dump_classes_(ostream&out, unsigned indent) const\n{\n\t// Dump the task definitions.\n      typedef map<perm_string,PClass*>::const_iterator class_iter_t;\n      for (class_iter_t cur = classes.begin()\n\t\t ; cur != classes.end() ; ++ cur ) {\n\t    cur->second->dump(out, indent);\n      }\n}\n\nvoid PScopeExtra::dump_tasks_(ostream&out, unsigned indent) const\n{\n\t// Dump the task definitions.\n      typedef map<perm_string,PTask*>::const_iterator task_iter_t;\n      for (task_iter_t cur = tasks.begin()\n\t\t ; cur != tasks.end() ; ++ cur ) {\n\t    out << setw(indent) << \"\" << \"task \" << (*cur).first << \";\" << endl;\n\t    (*cur).second->dump(out, indent+2);\n\t    out << setw(indent) << \"\" << \"endtask;\" << endl;\n      }\n}\n\nvoid PScopeExtra::dump_funcs_(ostream&out, unsigned indent) const\n{\n\t// Dump the task definitions.\n      typedef map<perm_string,PFunction*>::const_iterator task_iter_t;\n      for (task_iter_t cur = funcs.begin()\n\t\t ; cur != funcs.end() ; ++ cur ) {\n\t    out << setw(indent) << \"\" << \"function \" << (*cur).first << \";\" << endl;\n\t    (*cur).second->dump(out, indent+2);\n\t    out << setw(indent) << \"\" << \"endfunction;\" << endl;\n      }\n}\n\nvoid PClass::dump(ostream&out, unsigned indent) const\n{\n      out << setw(indent) << \"\" << \"class \" << type->name << \";\" << endl;\n      type->pform_dump(out, indent+2);\n      type->pform_dump_init(out, indent+2);\n      dump_tasks_(out, indent+2);\n      dump_funcs_(out, indent+2);\n      out << setw(indent) << \"\" << \"endclass\" << endl;\n}\n\nvoid Module::dump_specparams_(ostream&out, unsigned indent) const\n{\n      typedef map<perm_string,param_expr_t*>::const_iterator parm_iter_t;\n      for (parm_iter_t cur = specparams.begin()\n\t\t ; cur != specparams.end() ; ++ cur ) {\n\t    out << setw(indent) << \"\" << \"specparam \";\n\t    if (cur->second->data_type)\n\t\t  cur->second->data_type->debug_dump(out);\n\t    else\n\t\t  out << \"(nil type)\";\n\n\t    out << (*cur).first << \" = \";\n\t    if ((*cur).second->expr)\n\t\t  out << *(*cur).second->expr << \";\" << endl;\n\t    else\n\t\t  out << \"/* ERROR */;\" << endl;\n      }\n}\n\nvoid Module::dump_timingchecks_(ostream&out, unsigned indent) const\n{\n      out << \"    PFORM DUMP TIMINGCHECKS\" << endl;\n\n      for (const auto cur : timing_checks) {\n\t\tcur->dump(out, indent);\n      }\n}\n\nvoid Module::dump(ostream&out) const\n{\n      if (attributes.begin() != attributes.end()) {\n\t    out << \"(* \";\n\t    for (map<perm_string,PExpr*>::const_iterator idx = attributes.begin()\n\t\t ; idx != attributes.end() ; ++ idx ) {\n\t\t    if (idx != attributes.begin()) {\n\t\t\tout << \" , \";\n\t\t    }\n\t\t    out << (*idx).first;\n\t\t    if ((*idx).second) {\n\t\t\tout << \" = \" << *(*idx).second;\n\t\t    }\n\t    }\n\t    out << \" *)  \";\n      }\n\n      out << \"module \" << mod_name() << \";\";\n      if (is_cell) out << \"  // Is in `celldefine.\";\n      out << endl;\n\n      for (unsigned idx = 0 ;  idx < ports.size() ;  idx += 1) {\n\t    port_t*cur = ports[idx];\n\n\t    if (cur == 0) {\n\t\t  out << \"    unconnected\" << endl;\n\t\t  continue;\n\t    }\n\n\t    out << \"    .\" << cur->name << \"(\" << *cur->expr[0];\n\t    for (unsigned wdx = 1 ;  wdx < cur->expr.size() ;  wdx += 1) {\n\t\t  out << \", \" << *cur->expr[wdx];\n\t    }\n\n\t    out << \")\" << endl;\n      }\n\n      for (map<perm_string,Module*>::const_iterator cur = nested_modules.begin()\n\t\t ; cur != nested_modules.end() ; ++cur) {\n\t    out << setw(4) << \"\" << \"Nested module \" << cur->first << \";\" << endl;\n      }\n\n      dump_typedefs_(out, 4);\n\n      dump_parameters_(out, 4);\n\n      dump_specparams_(out, 4);\n\n      dump_timingchecks_(out, 4);\n\n      dump_enumerations_(out, 4);\n\n      dump_classes_(out, 4);\n\n      typedef map<perm_string,LineInfo*>::const_iterator genvar_iter_t;\n      for (genvar_iter_t cur = genvars.begin()\n\t\t ; cur != genvars.end() ; ++ cur ) {\n\t    out << \"    genvar \" << ((*cur).first) << \";\" << endl;\n      }\n\n      typedef list<PGenerate*>::const_iterator genscheme_iter_t;\n      for (genscheme_iter_t cur = generate_schemes.begin()\n\t\t ; cur != generate_schemes.end() ; ++ cur ) {\n\t    (*cur)->dump(out, 4);\n      }\n\n      typedef list<Module::named_expr_t>::const_iterator parm_hiter_t;\n      for (parm_hiter_t cur = defparms.begin()\n\t\t ; cur != defparms.end() ;  ++ cur ) {\n\t    out << \"    defparam \" << (*cur).first << \" = \";\n\t    if ((*cur).second)\n\t\t  out << *(*cur).second << \";\" << endl;\n\t    else\n\t\t  out << \"/* ERROR */;\" << endl;\n      }\n\n      dump_events_(out, 4);\n\n\t// Iterate through and display all the wires.\n      dump_wires_(out, 4);\n\n\t// Dump the task definitions.\n      dump_tasks_(out, 4);\n\n\t// Dump the function definitions.\n      dump_funcs_(out, 4);\n\n\n\t// Iterate through and display all the gates\n      for (list<PGate*>::const_iterator gate = gates_.begin()\n\t\t ; gate != gates_.end() ; ++ gate ) {\n\n\t    (*gate)->dump(out);\n      }\n\n      dump_var_inits_(out, 4);\n\n      for (list<PProcess*>::const_iterator behav = behaviors.begin()\n\t\t ; behav != behaviors.end() ; ++ behav ) {\n\n\t    (*behav)->dump(out, 4);\n      }\n\n      for (list<AProcess*>::const_iterator idx = analog_behaviors.begin()\n\t\t ; idx != analog_behaviors.end() ; ++ idx) {\n\t    (*idx)->dump(out, 4);\n      }\n\n      for (list<PCallTask*>::const_iterator idx = elab_tasks.begin()\n\t\t ; idx != elab_tasks.end() ; ++ idx ) {\n\t    (*idx)->dump(out, 4);\n      }\n\n      for (list<PSpecPath*>::const_iterator spec = specify_paths.begin()\n\t\t ; spec != specify_paths.end() ; ++ spec ) {\n\n\t    (*spec)->dump(out, 4);\n      }\n\n      out << \"endmodule\" << endl;\n}\n\nvoid pform_dump(ostream&out, Module*mod)\n{\n      mod->dump(out);\n}\n\nvoid PUdp::dump(ostream&out) const\n{\n      out << \"primitive \" << name_ << \"(\" << ports[0];\n      for (unsigned idx = 1 ;  idx < ports.size() ;  idx += 1)\n\t    out << \", \" << ports[idx];\n      out << \");\" << endl;\n\n      if (sequential)\n\t    out << \"    reg \" << ports[0] << \";\" << endl;\n\n      out << \"    table\" << endl;\n      for (unsigned idx = 0 ;  idx < tinput.size() ;  idx += 1) {\n\t    out << \"     \";\n\t    for (unsigned chr = 0 ;  chr < tinput[idx].length() ;  chr += 1)\n\t\t  out << \" \" << tinput[idx][chr];\n\n\t    if (sequential)\n\t\t  out << \" : \" << tcurrent[idx];\n\n\t    out << \" : \" << toutput[idx] << \" ;\" << endl;\n      }\n      out << \"    endtable\" << endl;\n\n      if (sequential)\n\t    out << \"    initial \" << ports[0] << \" = 1'b\" << initial\n\t\t<< \";\" << endl;\n\n\t// Dump the attributes for the primitive as attribute\n\t// statements.\n      for (map<string,PExpr*>::const_iterator idx = attributes.begin()\n\t\t ; idx != attributes.end() ; ++ idx ) {\n\t    out << \"    attribute \" << (*idx).first;\n\t    if ((*idx).second)\n\t\t  out << \" = \" << *(*idx).second;\n\t    out << endl;\n      }\n\n      out << \"endprimitive\" << endl;\n}\n\nvoid pform_dump(std::ostream&out, const ivl_nature_s*nat)\n{\n      out << \"nature \" << nat->name() << endl;\n      out << \"    access \" << nat->access() << \";\" << endl;\n      out << \"endnature\" << endl;\n}\n\nvoid pform_dump(std::ostream&out, const ivl_discipline_s*dis)\n{\n      out << \"discipline \" << dis->name() << endl;\n      out << \"    domain \" << dis->domain() << \";\" << endl;\n      if (const ivl_nature_s*tmp = dis->potential())\n\t    out << \"    potential \" << tmp->name() << \";\" << endl;\n      if (const ivl_nature_s*tmp = dis->flow())\n\t    out << \"    flow \" << tmp->name() << \";\" << endl;\n      out << \"enddiscipline\" << endl;\n}\n\nvoid pform_dump(std::ostream&fd, const PClass*cl)\n{\n      cl->dump(fd, 0);\n}\n\nvoid pform_dump(std::ostream&out, const PPackage*pac)\n{\n      pac->pform_dump(out);\n}\n\nvoid PPackage::pform_dump(std::ostream&out) const\n{\n      out << \"package \" << pscope_name() << endl;\n      dump_parameters_(out, 4);\n      dump_typedefs_(out, 4);\n      dump_enumerations_(out, 4);\n      dump_wires_(out, 4);\n      dump_tasks_(out, 4);\n      dump_funcs_(out, 4);\n      dump_var_inits_(out, 4);\n      out << \"endpackage\" << endl;\n}\n\nvoid pform_dump(std::ostream&fd, const PTaskFunc*obj)\n{\n      obj->dump(fd, 0);\n}\n"
        },
        {
          "name": "pform_package.cc",
          "type": "blob",
          "size": 8.166015625,
          "content": "/*\n * Copyright (c) 2012-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <cstdarg>\n# include  \"pform.h\"\n# include  \"PPackage.h\"\n# include  \"parse_misc.h\"\n# include  \"parse_api.h\"\n# include  <map>\n# include  <sstream>\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * This is a list of packages in the order that they were defined.\n */\nvector<PPackage*> pform_packages;\n\n/*\n * This allows us to easily check for name collisions.\n */\nstatic map<perm_string,PPackage*> packages_by_name;\n\nstatic PPackage*pform_cur_package = 0;\n\nvoid pform_start_package_declaration(const struct vlltype&loc, const char*name,\n\t\t\t\t     LexicalScope::lifetime_t lifetime)\n{\n      ivl_assert(loc, pform_cur_package == 0);\n\n      perm_string use_name = lex_strings.make(name);\n      PPackage*pkg_scope = pform_push_package_scope(loc, use_name, lifetime);\n      FILE_NAME(pkg_scope, loc);\n      pform_cur_package = pkg_scope;\n}\n\nvoid pform_end_package_declaration(const struct vlltype&loc)\n{\n      ivl_assert(loc, pform_cur_package);\n      perm_string use_name = pform_cur_package->pscope_name();\n\n      map<perm_string,PPackage*>::const_iterator test = packages_by_name.find(use_name);\n      if (test != packages_by_name.end()) {\n\t    ostringstream msg;\n\t    msg << \"error: Package \" << use_name << \" was already declared here: \"\n\t\t<< test->second->get_fileline() << ends;\n\t    VLerror(loc, \"%s\", msg.str().c_str());\n      }\n\n\n      packages_by_name[use_name] = pform_cur_package;\n      pform_packages.push_back(pform_cur_package);\n      pform_cur_package = 0;\n      pform_pop_scope();\n}\n\nPPackage *pform_find_potential_import(const struct vlltype&loc, LexicalScope*scope,\n\t\t\t\t      perm_string name, bool tf_call, bool make_explicit)\n{\n      ivl_assert(loc, scope);\n\n      PPackage *found_pkg = nullptr;\n      for (auto search_pkg : scope->potential_imports) {\n\t    PPackage *decl_pkg = pform_package_importable(search_pkg, name);\n\t    if (!decl_pkg)\n\t\t  continue;\n\n\t    if (found_pkg && found_pkg != decl_pkg && make_explicit) {\n\t\t  cerr << loc.get_fileline() << \": error: \"\n\t\t\t  \"Ambiguous use of '\" << name << \"'. \"\n\t\t\t  \"It is exported by both '\"\n\t\t\t<< found_pkg->pscope_name()\n\t\t\t<< \"' and by '\"\n\t\t\t<< search_pkg->pscope_name()\n\t\t\t<< \"'.\" << endl;\n\t\t  error_count++;\n\t\t  continue;\n\t    }\n\n\t    found_pkg = decl_pkg;\n\t    if (make_explicit) {\n\t\t  if (tf_call)\n\t\t\tscope->possible_imports[name] = found_pkg;\n\t\t  else {\n\t\t\tscope->explicit_imports[name] = found_pkg;\n\t\t\tscope->explicit_imports_from[name].insert(search_pkg);\n\t\t  }\n\t    }\n      }\n\n      return found_pkg;\n}\n\nPPackage *pform_package_importable(PPackage *pkg, perm_string name)\n{\n\tif (pkg->local_symbols.find(name) != pkg->local_symbols.end())\n\t\t  return pkg;\n\n\tauto import_pkg = pkg->explicit_imports.find(name);\n\tif (import_pkg == pkg->explicit_imports.end())\n\t\treturn nullptr;\n\n\tfor (auto &exp : pkg->exports) {\n\t\t  // *::* will match all imports, P::* will match all imports\n\t\t  // from a package and P::ID will match a specific identifier\n\t\t  // from a package.\n\t\tif ((!exp.pkg || exp.pkg == import_pkg->second) &&\n\t\t    (exp.name.nil() || exp.name == name))\n\t\t\treturn import_pkg->second;\n\t}\n\n\treturn nullptr;\n}\n\n/*\n * Do the import early, during processing. This requires that the\n * package is declared in pform ahead of time (it is) and that we can\n * simply transfer definitions to the current scope (we can).\n */\nvoid pform_package_import(const struct vlltype&loc, PPackage*pkg, const char*ident)\n{\n      LexicalScope*scope = pform_peek_scope();\n\n      if (ident) {\n\t    perm_string use_ident = lex_strings.make(ident);\n\n\t      // Check that the requested symbol is available.\n\t    PPackage *pkg_decl = pform_package_importable(pkg, use_ident);\n\t    if (!pkg_decl) {\n\t\t  cerr << loc.get_fileline() << \": error: \"\n\t\t\t  \"'\" << use_ident << \"' is not exported by '\"\n\t\t       << pkg->pscope_name() << \"'.\" << endl;\n\t\t  error_count += 1;\n\t\t  return;\n\t    }\n\n\t      // Check for conflict with local symbol.\n\t    auto cur_sym = scope->local_symbols.find(use_ident);\n\t    if (cur_sym != scope->local_symbols.end()) {\n\t\t  cerr << loc.get_fileline() << \": error: \"\n\t\t\t  \"'\" << use_ident << \"' has already been declared \"\n\t\t\t  \"in this scope.\" << endl;\n\t\t  cerr << cur_sym->second->get_fileline() << \":      : \"\n\t\t\t  \"It was declared here as \"\n\t\t       << cur_sym->second->symbol_type() << \".\" << endl;\n\t\t  error_count += 1;\n\t\t  return;\n\t    }\n\n\t      // Check for conflict with previous import.\n\t    map<perm_string,PPackage*>::const_iterator cur_pkg\n\t\t  = scope->explicit_imports.find(use_ident);\n\t    if (cur_pkg != scope->explicit_imports.end()) {\n\t\t  if (cur_pkg->second != pkg_decl) {\n\t\t\tcerr << loc.get_fileline() << \": error: \"\n\t\t\t\t\"'\" << use_ident << \"' has already been \"\n\t\t\t\t\"imported into this scope from package '\"\n\t\t\t     << cur_pkg->second->pscope_name() << \"'.\" << endl;\n\t\t\terror_count += 1;\n\t\t  }\n\t    }\n\n\t    scope->explicit_imports[use_ident] = pkg_decl;\n\t    scope->explicit_imports_from[use_ident].insert(pkg);\n\n      } else {\n\t    list<PPackage*>::const_iterator cur_pkg\n\t\t  = find(scope->potential_imports.begin(),\n                         scope->potential_imports.end(),\n                         pkg);\n\t    if (cur_pkg == scope->potential_imports.end())\n\t\t  scope->potential_imports.push_back(pkg);\n      }\n}\n\nstatic bool pform_package_exportable(const struct vlltype &loc, PPackage *pkg,\n\t\t\t\t     const perm_string &ident)\n{\n      auto import_pkg = pform_cur_package->explicit_imports_from.find(ident);\n      if (import_pkg != pform_cur_package->explicit_imports_from.end()) {\n\t    auto &pkg_list = import_pkg->second;\n\t    if (pkg_list.find(pkg) != pkg_list.end())\n\t\t  return true;\n      }\n\n      if (pform_cur_package->local_symbols.find(ident) == pform_cur_package->local_symbols.end()) {\n\t    if (pform_find_potential_import(loc, pform_cur_package,\n\t\t\t\t\t    ident, false, true))\n\t\t  return true;\n      }\n\n      cerr << loc.get_fileline() << \": error: \"\n\t      \"`\" << ident << \"` has not been imported from \"\n\t   << pkg->pscope_name() << \".\" << endl;\n      error_count++;\n\n      return false;\n}\n\nvoid pform_package_export(const struct vlltype &loc, PPackage *pkg, const char *ident)\n{\n      ivl_assert(loc, pform_cur_package);\n\n      perm_string use_ident;\n      if (ident) {\n\t    use_ident = lex_strings.make(ident);\n\t    if (!pform_package_exportable(loc, pkg, use_ident))\n\t\t  return;\n      }\n      pform_cur_package->exports.push_back(PPackage::export_t{pkg, use_ident});\n}\n\nPExpr* pform_package_ident(const struct vlltype&loc,\n\t\t\t   PPackage*pkg, pform_name_t*ident_name)\n{\n      ivl_assert(loc, ident_name);\n      PEIdent*tmp = new PEIdent(pkg, *ident_name, loc.lexical_pos);\n      FILE_NAME(tmp, loc);\n      return tmp;\n}\n\ntypedef_t* pform_test_type_identifier(PPackage*pkg, const char*txt)\n{\n      perm_string use_name = lex_strings.make(txt);\n      LexicalScope::typedef_map_t::const_iterator cur;\n\n      cur = pkg->typedefs.find(use_name);\n      if (cur != pkg->typedefs.end())\n\t    return cur->second;\n\n      return 0;\n}\n\n/*\n * The lexor uses this function to know if the identifier names the\n * package. It will call this a PACKAGE_IDENTIFIER token in that case,\n * instead of a generic IDENTIFIER.\n */\nPPackage* pform_test_package_identifier(const char*pkg_name)\n{\n      perm_string use_name = lex_strings.make(pkg_name);\n      map<perm_string,PPackage*>::const_iterator pcur = packages_by_name.find(use_name);\n      if (pcur == packages_by_name.end())\n\t    return 0;\n\n      assert(pcur->second);\n      return pcur->second;\n}\n"
        },
        {
          "name": "pform_pclass.cc",
          "type": "blob",
          "size": 5.5126953125,
          "content": "/*\n * Copyright (c) 2012-2024 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <cstdarg>\n# include  \"pform.h\"\n# include  \"PClass.h\"\n# include  \"parse_misc.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * The functions here help the parser put together class type declarations.\n */\nstatic PClass*pform_cur_class = 0;\n\n/*\n * The base_type is set to the base class if this declaration is\n * starting a derived class. For example, for the syntax:\n *\n *    class foo extends bar (exprs) ...\n *\n * the base_type is the type of the class \"bar\", and the base_exprs,\n * if present, are the \"exprs\" that would be passed to a chained\n * constructor.\n */\nvoid pform_start_class_declaration(const struct vlltype&loc,\n\t\t\t\t   class_type_t*type,\n\t\t\t\t   data_type_t*base_type,\n\t\t\t\t   list<named_pexpr_t> *base_args,\n\t\t\t\t   bool virtual_class)\n{\n      PClass*class_scope = pform_push_class_scope(loc, type->name);\n      class_scope->type = type;\n      ivl_assert(loc, pform_cur_class == 0);\n      pform_cur_class = class_scope;\n\n      ivl_assert(loc, type->base_type == 0);\n      type->base_type.reset(base_type);\n      type->virtual_class = virtual_class;\n\n\n      ivl_assert(loc, type->base_args.empty());\n      if (base_args) {\n\t    type->base_args.insert(type->base_args.begin(), base_args->begin(),\n\t\t\t           base_args->end());\n\t    delete base_args;\n      }\n}\n\nvoid pform_class_property(const struct vlltype&loc,\n\t\t\t  property_qualifier_t property_qual,\n\t\t\t  data_type_t*data_type,\n\t\t\t  list<decl_assignment_t*>*decls)\n{\n      ivl_assert(loc, pform_cur_class);\n\n\t// Add the non-static properties to the class type\n\t// object. Unwind the list of names to make a map of name to\n\t// type.\n      for (list<decl_assignment_t*>::iterator cur = decls->begin()\n\t\t ; cur != decls->end() ; ++cur) {\n\n\t    decl_assignment_t*curp = *cur;\n\t    data_type_t*use_type = data_type;\n\n\t    if (! curp->index.empty()) {\n\t\t  list<pform_range_t>*pd = new list<pform_range_t> (curp->index);\n\t\t  use_type = new uarray_type_t(use_type, pd);\n\t\t  FILE_NAME(use_type, loc);\n\t    }\n\n\t    pform_cur_class->type->properties[curp->name.first]\n\t\t  = class_type_t::prop_info_t(property_qual,use_type);\n\t    FILE_NAME(&pform_cur_class->type->properties[curp->name.first], loc);\n\n\t    if (PExpr*rval = curp->expr.release()) {\n\t\t  PExpr*lval = new PEIdent(curp->name.first, curp->name.second);\n\t\t  FILE_NAME(lval, loc);\n\t\t  PAssign*tmp = new PAssign(lval, rval);\n\t\t  FILE_NAME(tmp, loc);\n\n\t\t  if (property_qual.test_static())\n\t\t\tpform_cur_class->type->initialize_static.push_back(tmp);\n\t\t  else\n\t\t\tpform_cur_class->type->initialize.push_back(tmp);\n\t    }\n      }\n}\n\nvoid pform_set_this_class(const struct vlltype&loc, PTaskFunc*net)\n{\n      if (pform_cur_class == 0)\n\t    return;\n\n      list<pform_port_t>*this_name = new list<pform_port_t>;\n      this_name->push_back(pform_port_t({ perm_string::literal(THIS_TOKEN), 0 }, 0, 0));\n      vector<pform_tf_port_t>*this_port = pform_make_task_ports(loc,\n\t\t\t\t\t\t       NetNet::PINPUT,\n\t\t\t\t\t\t       pform_cur_class->type,\n\t\t\t\t\t\t       this_name);\n\t// The pform_make_task_ports() function deletes the this_name\n\t// object.\n\n      ivl_assert(loc, this_port->at(0).defe == 0);\n      PWire*this_wire = this_port->at(0).port;\n      delete this_port;\n\n      net->set_this(pform_cur_class->type, this_wire);\n}\n\nvoid pform_set_constructor_return(PFunction*net)\n{\n      ivl_assert(*net, pform_cur_class);\n      net->set_return(pform_cur_class->type);\n}\n\n/*\n * A constructor is basically a function with special implications.\n */\nPFunction*pform_push_constructor_scope(const struct vlltype&loc)\n{\n      ivl_assert(loc, pform_cur_class);\n      PFunction*func = pform_push_function_scope(loc, \"new\", LexicalScope::AUTOMATIC);\n      return func;\n}\n\nvoid pform_end_class_declaration(const struct vlltype&loc)\n{\n      ivl_assert(loc, pform_cur_class);\n\n\t// If there were initializer statements, then collect them\n\t// into an implicit constructor function. Also make sure that an\n\t// explicit constructor exists if base class constructor arguments are\n\t// specified, so that the base class constructor will be called.\n      if (!pform_cur_class->type->initialize.empty() ||\n          !pform_cur_class->type->base_args.empty()) {\n\t    PFunction*func = pform_push_function_scope(loc, \"new@\", LexicalScope::AUTOMATIC);\n\t    func->set_ports(0);\n\t    pform_set_constructor_return(func);\n\t    pform_set_this_class(loc, func);\n\n\t    class_type_t*use_class = pform_cur_class->type;\n\t    if (use_class->initialize.size() == 1) {\n\t\t  func->set_statement(use_class->initialize.front());\n\t    } else {\n\t\t  PBlock*tmp = new PBlock(PBlock::BL_SEQ);\n\t\t  tmp->set_statement(use_class->initialize);\n\t\t  func->set_statement(tmp);\n\t    }\n\t    pform_pop_scope();\n      }\n\n      pform_cur_class = 0;\n      pform_pop_scope();\n}\n\nbool pform_in_class()\n{\n      return pform_cur_class != 0;\n}\n"
        },
        {
          "name": "pform_types.cc",
          "type": "blob",
          "size": 1.912109375,
          "content": "/*\n * Copyright (c) 2007-2019 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n\n# include  \"pform_types.h\"\n\ndata_type_t::~data_type_t()\n{\n}\n\nPNamedItem::SymbolType data_type_t::symbol_type() const\n{\n      return TYPE;\n}\n\nstring_type_t::~string_type_t()\n{\n}\n\natom_type_t size_type (atom_type_t::INT, true);\n\nPNamedItem::SymbolType enum_type_t::symbol_type() const\n{\n      return ENUM;\n}\n\nPNamedItem::SymbolType class_type_t::symbol_type() const\n{\n      return CLASS;\n}\n\nbool typedef_t::set_data_type(data_type_t *t)\n{\n      if (data_type.get())\n\t    return false;\n\n      data_type.reset(t);\n\n      return true;\n}\n\nbool typedef_t::set_basic_type(enum basic_type bt)\n{\n      if (bt == ANY)\n\t    return true;\n      if (basic_type != ANY && bt != basic_type)\n\t    return false;\n\n      basic_type = bt;\n\n      return true;\n}\n\nstd::ostream& operator<< (std::ostream&out, enum typedef_t::basic_type bt)\n{\n\tswitch (bt) {\n\tcase typedef_t::ANY:\n\t\tout << \"any\";\n\t\tbreak;\n\tcase typedef_t::ENUM:\n\t\tout << \"enum\";\n\t\tbreak;\n\tcase typedef_t::STRUCT:\n\t\tout << \"struct\";\n\t\tbreak;\n\tcase typedef_t::UNION:\n\t\tout << \"union\";\n\t\tbreak;\n\tcase typedef_t::CLASS:\n\t\tout << \"class\";\n\t\tbreak;\n\t}\n\n\treturn out;\n}\n"
        },
        {
          "name": "pform_types.h",
          "type": "blob",
          "size": 15.1162109375,
          "content": "#ifndef IVL_pform_types_H\n#define IVL_pform_types_H\n/*\n * Copyright (c) 2007-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n// This for the perm_string type.\n# include  \"StringHeap.h\"\n# include  \"PNamedItem.h\"\n# include  \"verinum.h\"\n# include  \"named.h\"\n# include  \"netstruct.h\"\n# include  \"property_qual.h\"\n# include  \"ivl_target.h\"\n# include  <iostream>\n# include  <list>\n# include  <vector>\n# include  <map>\n# include  <memory>\n\n/*\n * parse-form types.\n */\n\nclass Design;\nclass NetScope;\nclass Definitions;\nclass PExpr;\nclass PScope;\nclass PPackage;\nclass PWire;\nclass Statement;\nclass netclass_t;\nclass netenum_t;\ntypedef named<PExpr*> named_pexpr_t;\n\n/*\n * The pform_ident_t holds the identifier name and its lexical position\n * (the lexical_pos supplied by the scanner).\n */\ntypedef std::pair<perm_string, unsigned> pform_ident_t;\n\n/*\n * The pform_range_t holds variable dimensions for type\n * declarations. The two expressions are interpreted as the first and\n * last values of the range. For example:\n *\n *   [<expr1> : <expr2>]  -- Normal array range\n *       first == <expr1>\n *       second = <expr2>\n *\n *   [<expr>] -- SystemVerilog canonical range\n *       first = PENumber(0)\n *       second = <expr> - 1;\n *\n *   [ ] -- Dynamic array\n *       first = 0\n *       second = 0\n *\n *   [ $ ] -- Queue type\n *       first = PENull\n *       second = 0\n */\ntypedef std::pair<PExpr*,PExpr*> pform_range_t;\n\n/* The lgate is gate instantiation information. */\nstruct lgate : public LineInfo {\n      explicit lgate() : parms(0), parms_by_name(0), ranges(0) { }\n\n      std::string name;\n      std::list<PExpr*>*parms;\n      std::list<named_pexpr_t>*parms_by_name;\n\n      std::list<pform_range_t>*ranges;\n};\n\n/*\n * The pform_port_t holds the name and optional unpacked dimensions\n * and initialization expression for a single port in a list of port\n * declarations.\n */\nstruct pform_port_t {\n      pform_port_t(pform_ident_t n, std::list<pform_range_t>*ud, PExpr*e)\n\t: name(n), udims(ud), expr(e) { }\n      ~pform_port_t() { }\n\n      pform_ident_t name;\n      std::list<pform_range_t>*udims;\n      PExpr*expr;\n};\n\n/*\n * Semantic NOTES:\n * - The SEL_BIT is a single expression. This might me a bit select\n * of a vector, or a word select of an array.\n *\n * - The SEL_BIT_LAST index component is an array/queue [$] index,\n * that is the last item in the variable.\n */\nstruct index_component_t {\n      enum ctype_t { SEL_NONE, SEL_BIT, SEL_BIT_LAST, SEL_PART, SEL_IDX_UP, SEL_IDX_DO };\n\n      index_component_t() : sel(SEL_NONE), msb(0), lsb(0) { };\n      ~index_component_t() { }\n\n      ctype_t sel;\n      class PExpr*msb;\n      class PExpr*lsb;\n};\n\nstruct name_component_t {\n      inline name_component_t() { }\n      inline explicit name_component_t(perm_string n) : name(n) { }\n      ~name_component_t() { }\n\n      // Return true if this component is nil.\n      inline bool empty() const { return name.nil(); }\n\n      perm_string name;\n      std::list<index_component_t>index;\n};\n\nstruct decl_assignment_t {\n      pform_ident_t name;\n      std::list<pform_range_t>index;\n      std::unique_ptr<PExpr> expr;\n};\n\nstruct pform_tf_port_t {\n      PWire*port;\n      PExpr*defe;\n\n      inline pform_tf_port_t() : port(0), defe(0) { }\n      inline explicit pform_tf_port_t(PWire*p) : port(p), defe(0) { }\n};\n\n/*\n * This is the base class for data types that are matched by the\n * \"data_type\" rule in the parse rule. We make the type virtual so\n * that dynamic types will work.\n */\nclass data_type_t : public PNamedItem {\n    public:\n      inline explicit data_type_t() { }\n      virtual ~data_type_t() = 0;\n      // This method is used by the pform dumper to diagnostic dump. The\n      //  pform_dump dumps type type in pform format, and the debug_dump\n      // prints the output in a linear form.\n      virtual void pform_dump(std::ostream&out, unsigned indent) const;\n      virtual std::ostream& debug_dump(std::ostream&out) const;\n\n      ivl_type_t elaborate_type(Design*des, NetScope*scope);\n\n      virtual SymbolType symbol_type() const;\n\n    private:\n\t// Elaborate the type to an ivl_type_s type.\n      virtual ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n      virtual NetScope *find_scope(Design* des, NetScope *scope) const;\n\n      bool elaborating = false;\n\n\t// Keep per-scope elaboration results cached.\n      std::map<Definitions*,ivl_type_t> cache_type_elaborate_;\n};\n\nstruct typedef_t : public PNamedItem {\n      explicit typedef_t(perm_string n) : basic_type(ANY), name(n) { };\n\n      ivl_type_t elaborate_type(Design*des, NetScope*scope);\n\n      enum basic_type {\n\t    ANY,\n\t    ENUM,\n\t    STRUCT,\n\t    UNION,\n\t    CLASS\n      };\n\n      bool set_data_type(data_type_t *t);\n      const data_type_t *get_data_type() const { return data_type.get(); }\n\n      bool set_basic_type(basic_type bt);\n      enum basic_type get_basic_type() const { return basic_type; }\n\nprotected:\n      enum basic_type basic_type;\n      std::unique_ptr<data_type_t> data_type;\npublic:\n      perm_string name;\n};\n\nstruct typeref_t : public data_type_t {\n      explicit typeref_t(typedef_t *t, PScope *s = 0) : scope(s), type(t) {}\n\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n      NetScope *find_scope(Design* des, NetScope *scope) const;\n\n      std::ostream& debug_dump(std::ostream&out) const;\n\nprivate:\n      PScope *scope;\n      typedef_t *type;\n};\n\nstruct type_parameter_t : data_type_t {\n      explicit type_parameter_t(perm_string n) : name(n) { }\n      ivl_type_t elaborate_type_raw(Design *des, NetScope *scope) const;\n\n      perm_string name;\n};\n\nstruct void_type_t : public data_type_t {\n      virtual void pform_dump(std::ostream&out, unsigned indent) const;\n};\n\n/*\n * The enum_type_t holds the parsed declaration to represent an\n * enumeration. Since this is in the pform, it represents the type\n * before elaboration so the range, for example, may not be complete\n * until it is elaborated in a scope.\n */\nstruct enum_type_t : public data_type_t {\n      explicit enum_type_t(data_type_t *btype) : base_type(btype) { }\n\n\t// Return the elaborated version of the type.\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n\n      SymbolType symbol_type() const;\n\n      std::unique_ptr<data_type_t> base_type;\n      std::unique_ptr< std::list<named_pexpr_t> > names;\n};\n\nstruct struct_member_t : public LineInfo {\n      std::unique_ptr<data_type_t> type;\n      std::unique_ptr< std::list<decl_assignment_t*> > names;\n      void pform_dump(std::ostream&out, unsigned indent) const;\n};\n\nstruct struct_type_t : public data_type_t {\n      virtual void pform_dump(std::ostream&out, unsigned indent) const;\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n\n      bool packed_flag;\n      bool union_flag;\n      bool signed_flag;\n      std::unique_ptr< std::list<struct_member_t*> > members;\n};\n\nstruct atom_type_t : public data_type_t {\n      enum type_code {\n\t    INTEGER,\n\t    TIME,\n\t    BYTE,\n\t    SHORTINT,\n\t    INT,\n\t    LONGINT\n      };\n\n      explicit atom_type_t(enum type_code tc, bool flag) : type_code(tc),\n\t\t\t\t\t\t\t   signed_flag(flag) { }\n\n      enum type_code type_code;\n      bool signed_flag;\n\n      virtual std::ostream& debug_dump(std::ostream&out) const;\n\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n};\n\nextern atom_type_t size_type;\n\n/*\n * The vector_type_t class represents types in the old Verilog\n * way. Some typical examples:\n *\n *   logic signed [7:0] foo\n *   bit unsigned foo\n *   reg foo\n *\n * There is one special case:\n *\n * If there are no reg/logic/bit/bool keywords, then Verilog will\n * assume the type is logic, but the context may need to know about\n * this case, so the implicit_flag member is set to true in that case.\n */\nstruct vector_type_t : public data_type_t {\n      inline explicit vector_type_t(ivl_variable_type_t bt, bool sf,\n\t\t\t\t    std::list<pform_range_t>*pd)\n      : base_type(bt), signed_flag(sf), integer_flag(false), implicit_flag(false), pdims(pd) { }\n      virtual void pform_dump(std::ostream&out, unsigned indent) const;\n      virtual std::ostream& debug_dump(std::ostream&out) const;\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n\n      ivl_variable_type_t base_type;\n      bool signed_flag;\n      bool integer_flag; // True if \"integer\" was used\n      bool implicit_flag; // True if this type is implicitly logic/reg\n      std::unique_ptr< std::list<pform_range_t> > pdims;\n};\n\nstruct array_base_t : public data_type_t {\n    public:\n      inline explicit array_base_t(data_type_t*btype, std::list<pform_range_t>*pd)\n      : base_type(btype), dims(pd) { }\n\n      std::unique_ptr<data_type_t> base_type;\n      std::unique_ptr< std::list<pform_range_t> > dims;\n};\n\n/*\n * The parray_type_t is a generalization of the vector_type_t in that\n * the base type is another general data type. Ultimately, the subtype\n * must also be packed (as this is a packed array) but that may be\n * worked out during elaboration.\n */\nstruct parray_type_t : public array_base_t {\n      inline explicit parray_type_t(data_type_t*btype, std::list<pform_range_t>*pd)\n      : array_base_t(btype, pd) { }\n\n      virtual void pform_dump(std::ostream&out, unsigned indent) const;\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n};\n\n/*\n * The uarray_type_t represents unpacked array types.\n */\nstruct uarray_type_t : public array_base_t {\n      inline explicit uarray_type_t(data_type_t*btype, std::list<pform_range_t>*pd)\n      : array_base_t(btype, pd) { }\n\n    public:\n      virtual void pform_dump(std::ostream&out, unsigned indent) const;\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n};\n\nstruct real_type_t : public data_type_t {\n public:\n      enum type_t { REAL, SHORTREAL };\n      inline explicit real_type_t(type_t tc) : type_code_(tc) { }\n      virtual std::ostream& debug_dump(std::ostream&out) const;\n\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n\n      inline type_t type_code() const { return type_code_; }\n\n private:\n      type_t type_code_;\n};\n\nstruct string_type_t : public data_type_t {\n      inline explicit string_type_t() { }\n      ~string_type_t();\n\n      ivl_type_t elaborate_type_raw(Design*des, NetScope*scope) const;\n};\n\nstruct class_type_t : public data_type_t {\n\n      inline explicit class_type_t(perm_string n) : name(n) { }\n\n      void pform_dump(std::ostream&out, unsigned indent) const;\n      void pform_dump_init(std::ostream&out, unsigned indent) const;\n\n\t// This is the named type that is supposed to be the base\n\t// class that we are extending. This is nil if there is no\n\t// hierarchy. If there are arguments to the base class, then\n\t// put them in the base_args vector.\n      std::unique_ptr<data_type_t> base_type;\n      std::vector<named_pexpr_t> base_args;\n\n      bool virtual_class;\n\n\t// This is a map of the properties. Map the name to the type.\n      struct prop_info_t : public LineInfo {\n\t    inline prop_info_t() : qual(property_qualifier_t::make_none()) { }\n\t    inline prop_info_t(property_qualifier_t q, data_type_t*t) : qual(q), type(t) { }\n\t    prop_info_t(prop_info_t&&) = default;\n\t    prop_info_t& operator=(prop_info_t&&) = default;\n\t    property_qualifier_t qual;\n\t    std::unique_ptr<data_type_t> type;\n      };\n      std::map<perm_string, struct prop_info_t> properties;\n\n\t// This is an ordered list of property initializers. The name\n\t// is the name of the property to be assigned, and the val is\n\t// the expression that is assigned.\n      std::vector<Statement*> initialize;\n\n\t// This is an ordered list of property initializers for static\n\t// properties. These are run in a synthetic \"initial\" block\n\t// without waiting for any constructor.\n      std::vector<Statement*> initialize_static;\n\n      ivl_type_t elaborate_type_raw(Design*, NetScope*) const;\n\n      perm_string name;\n\n      virtual SymbolType symbol_type() const;\n};\n\nivl_type_t elaborate_array_type(Design *des, NetScope *scope,\n\t\t\t        const LineInfo &li, ivl_type_t base_type,\n\t\t\t        const std::list<pform_range_t> &dims);\n\n/*\n * The pform_name_t is the general form for a hierarchical\n * identifier. It is an ordered list of name components. Each name\n * component is an identifier and an optional list of bit/part\n * selects. The simplest name component is a simple identifier:\n *\n *    foo\n *\n * The bit/part selects come from the source and are made part of the\n * name component. A bit select is a single number that may be a bit\n * select of a vector or a word select of an array:\n *\n *    foo[5]     -- a bit select/word index\n *    foo[6:4]   -- a part select\n *\n * The index components of a name component are collected into an\n * ordered list, so there may be many, for example:\n *\n *    foo[5][6:4] -- a part select of an array word\n *\n * The pform_name_t, then, is an ordered list of these name\n * components. The list of names comes from a hierarchical name in the\n * source, like this:\n *\n *    foo[5].bar[6:4]  -- a part select of a vector in sub-scope foo[5].\n */\ntypedef std::list<name_component_t> pform_name_t;\n\nstruct pform_scoped_name_t {\n      pform_scoped_name_t() = default;\n      pform_scoped_name_t(PPackage *p, const pform_name_t &n) : package(p),\n\t\t\t\t\t\t\t        name(n) {}\n      pform_scoped_name_t(const pform_name_t &n) : name(n) {}\n\n      const name_component_t& back() const { return name.back(); }\n      size_t size() const { return name.size(); }\n\n      PPackage *package = nullptr;\n      pform_name_t name;\n};\n\ninline perm_string peek_head_name(const pform_name_t&that)\n{\n      return that.front().name;\n}\n\ninline perm_string peek_tail_name(const pform_name_t&that)\n{\n      return that.back().name;\n}\n\ninline perm_string peek_head_name(const pform_scoped_name_t &that)\n{\n      return peek_head_name(that.name);\n}\n\ninline perm_string peek_tail_name(const pform_scoped_name_t &that)\n{\n      return peek_tail_name(that.name);\n}\n\n/*\n * In pform names, the \"super\" and \"this\" keywords are converted to\n * These tokens so that they don't interfere with the namespace and\n * are handled specially.\n */\n# define SUPER_TOKEN \"#\"\n# define THIS_TOKEN  \"@\"\n\nstatic inline std::ostream& operator<< (std::ostream&out, const data_type_t&that)\n{\n      return that.debug_dump(out);\n}\n\nextern std::ostream& operator<< (std::ostream&out, const pform_name_t&);\nextern std::ostream& operator<< (std::ostream&out, const pform_scoped_name_t&);\nextern std::ostream& operator<< (std::ostream&out, const name_component_t&that);\nextern std::ostream& operator<< (std::ostream&out, const index_component_t&that);\nextern std::ostream& operator<< (std::ostream&out, enum typedef_t::basic_type bt);\n\n#endif /* IVL_pform_types_H */\n"
        },
        {
          "name": "property_qual.h",
          "type": "blob",
          "size": 2.3349609375,
          "content": "#ifndef IVL_property_qual_H\n#define IVL_property_qual_H\n/*\n * Copyright (c) 2013-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\nclass property_qualifier_t {\n    public:\n      static inline property_qualifier_t make_none()\n      { property_qualifier_t res; res.mask_ = 0; return res; }\n\n      static inline property_qualifier_t make_static()\n      { property_qualifier_t res; res.mask_ = 1; return res; }\n\n      static inline property_qualifier_t make_protected()\n      { property_qualifier_t res; res.mask_ = 2; return res; }\n\n      static inline property_qualifier_t make_local()\n      { property_qualifier_t res; res.mask_ = 4; return res; }\n\n      static inline property_qualifier_t make_rand()\n      { property_qualifier_t res; res.mask_ = 8; return res; }\n\n      static inline property_qualifier_t make_randc()\n      { property_qualifier_t res; res.mask_ = 16; return res; }\n\n      static inline property_qualifier_t make_const()\n      { property_qualifier_t res; res.mask_ = 32; return res; }\n\n      inline property_qualifier_t operator | (property_qualifier_t r)\n      { property_qualifier_t res; res.mask_ = mask_ | r.mask_; return res; }\n\n    public:\n      inline bool test_static() const    { return mask_ & 1; }\n      inline bool test_protected() const { return mask_ & 2; }\n      inline bool test_local() const     { return mask_ & 4; }\n      inline bool test_rand() const      { return mask_ & 8; }\n      inline bool test_randc() const     { return mask_ & 16; }\n      inline bool test_const() const     { return mask_ & 32; }\n\n    private:\n      int mask_;\n};\n\n#endif /* IVL_property_qual_H */\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "solaris",
          "type": "tree",
          "content": null
        },
        {
          "name": "sv_vpi_user.h",
          "type": "blob",
          "size": 2.548828125,
          "content": "#ifndef SV_VPI_USER_H\n#define SV_VPI_USER_H\n/*\n * Copyright (c) 2010-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"vpi_user.h\"\n\n#if defined(__MINGW32__) || defined (__CYGWIN__)\n#  define DLLEXPORT __declspec(dllexport)\n#else\n#  define DLLEXPORT\n#endif\n\n#ifdef __cplusplus\n# define EXTERN_C_START extern \"C\" {\n# define EXTERN_C_END }\n#else\n# define EXTERN_C_START\n# define EXTERN_C_END\n#endif\n\n#ifndef __GNUC__\n# undef  __attribute__\n# define __attribute__(x)\n#endif\n\nEXTERN_C_START\n\n/********* OBJECT TYPES ***********/\n#define vpiPackage          600\n#define vpiInterface        601\n#define vpiProgram          602\n#define vpiArrayType        606\n#define   vpiStaticArray      1\n#define   vpiDynamicArray     2\n#define   vpiAssocArray       3\n#define   vpiQueueArray       4\n#define vpiLongIntVar       610\n#define vpiShortIntVar      611\n#define vpiIntVar           612\n#define vpiByteVar          614\n#define vpiLogicVar         vpiReg\n#define vpiClassVar         615\n#define vpiStringVar        616\n#define vpiBitVar           620\n#define vpiArrayVar         vpiRegArray\n\n/********* TYPESPECS *************/\n#define vpiClassTypespec    630\n#define vpiEnumTypespec     633\n#define vpiEnumConst        634\n\n#define vpiClassDefn        652\n\n/********* One-to-One ***********/\n#define vpiBaseTypespec     703\n\n/********* Many-to-One ***********/\n#define vpiMember           742\n\n/********* One-to-One and One-to-Many ***********/\n#define vpiInstance         745\n\n/********* generic object properties ***********/\n#define vpiNullConst         11\n\n/********* task/function properties **********/\n#define vpiOtherFunc          6\n\n/* Icarus-specific function type to use string as the return type */\n#define vpiStringFunc       10\n#define vpiSysFuncString    vpiSysFuncString\n\nEXTERN_C_END\n\n#endif /* SV_VPI_USER_H */\n"
        },
        {
          "name": "symbol_search.cc",
          "type": "blob",
          "size": 12.560546875,
          "content": "/*\n * Copyright (c) 2003-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2012 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netlist.h\"\n# include  \"netclass.h\"\n# include  \"netparray.h\"\n# include  \"netmisc.h\"\n# include  \"compiler.h\"\n# include  \"PPackage.h\"\n# include  \"PWire.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * Search for the hierarchical name. The path may have multiple components. If\n * that's the case, then recursively pull the path apart until we find the\n * first item in the path, look that up, and work our way up. In most cases,\n * the path will be a string of scopes, with an object at the end. But if we\n * find an object before the end, then the tail will have to be figured out by\n * the initial caller.\n */\n\nbool symbol_search(const LineInfo*li, Design*des, NetScope*scope,\n\t\t   pform_name_t path, unsigned lexical_pos,\n\t\t   struct symbol_search_results*res,\n\t\t   NetScope*start_scope, bool prefix_scope)\n{\n      assert(scope);\n\n      if (debug_elaborate) {\n\t    cerr << li->get_fileline() << \": symbol_search: \"\n\t\t << \"scope: \" << scope_path(scope) << endl;\n\t    cerr << li->get_fileline() << \": symbol_search: \"\n\t\t << \"path: \" << path << endl;\n\t    if (start_scope)\n\t\t  cerr << li->get_fileline() << \": symbol_search: \"\n\t\t       << \"start_scope: \" << scope_path(start_scope) << endl;\n      }\n\n      assert(li);\n      ivl_assert(*li, ! path.empty());\n      name_component_t path_tail = path.back();\n      path.pop_back();\n\n      // If this is a recursive call, then we need to know that so\n      // that we can enable the search for scopes. Set the\n      // recurse_flag to true if this is a recurse.\n      if (start_scope==0)\n\t    start_scope = scope;\n\n      // If there are components ahead of the tail, symbol_search\n      // recursively. Ideally, the result is a scope that we search\n      // for the tail key, but there are other special cases as well.\n      if (! path.empty()) {\n\t    bool flag = symbol_search(li, des, scope, path, lexical_pos,\n\t\t\t\t      res, start_scope, prefix_scope);\n\t    if (! flag)\n\t\t  return false;\n\n\t    // The prefix is found to be something besides a scope. Put the\n\t    // tail into the path_tail of the result, and return success. The\n\t    // caller needs to deal with that tail bit. Note that the\n\t    // path_tail is a single item, but we might have been called\n\t    // recursively, so the complete tail will be built up as we unwind.\n\t    if (res->is_found() && !res->is_scope()) {\n\t\t  if (!path_tail.empty())\n\t\t\tres->path_tail.push_back(path_tail);\n\t\t  return true;\n\t    }\n\n\t    // The prefix is found to be a scope, so switch to that\n\t    // scope, set the hier_path to turn off upwards searches,\n\t    // and continue our search for the tail.\n\t    if (res->is_scope()) {\n\t\t  scope = res->scope;\n\t\t  prefix_scope = true;\n\n\t\t  if (debug_scopes || debug_elaborate) {\n\t\t\tcerr << li->get_fileline() << \": symbol_search: \"\n\t\t\t     << \"Prefix scope \" << scope_path(scope) << endl;\n\t\t  }\n\n\t\t  if (scope->is_auto()) {\n\t\t\tcerr << li->get_fileline() << \": error: Hierarchical \"\n\t\t\t      \"reference to automatically allocated item \"\n\t\t\t      \"`\" << path_tail.name << \"' in path `\" << path << \"'\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\n\t    } else {\n\t\t  // Prefix is present, but is NOT a scope. Fail! Actually, this\n\t\t  // should not happen, since this is the \"not found\" case, and we\n\t\t  // should have returned already.\n\t\t  ivl_assert(*li, 0);\n\t\t  return false;\n\t    }\n      }\n\n      bool passed_module_boundary = false;\n\n      // At this point, we've stripped right-most components until the search\n      // found the scope part of the path, or there is no scope part of the\n      // path. For example, if the path in was s1.s2.x, we found the scope\n      // s1.s2, res->is_scope() is true, and path_tail is x. We look for x\n      // now. The preceeding code set prefix_scope=true to ease our test below.\n      //\n      // If the input was x (without prefixes) then we don't know if x is a\n      // scope or item. In this case, res->is_found() is false and we may need\n      // to scan upwards to find the scope or item.\n      while (scope) {\n\t    if (debug_scopes || debug_elaborate) {\n\t\t  cerr << li->get_fileline() << \": symbol_search: \"\n\t\t       << \"Looking for \" << path_tail\n\t\t       << \" in scope \" << scope_path(scope)\n\t\t       << \" prefix_scope=\" << prefix_scope << endl;\n\t    }\n            if (scope->genvar_tmp.str() && path_tail.name == scope->genvar_tmp)\n                  return false;\n\n\t    // These items cannot be seen outside the bounding module where\n\t    // the search starts. But we continue searching up because scope\n\t    // names can match. For example:\n\t    //\n\t    //    module top;\n\t    //        int not_ok;\n\t    //        dut foo(...);\n\t    //    endmodule\n\t    //    module dut;\n\t    //        ... not_ok; // <-- Should NOT match.\n\t    //        ... top.not_ok; // Matches.\n\t    //    endmodule\n\t    if (!passed_module_boundary) {\n\t\t  // Special case `super` keyword. Return the `this` object, but\n\t\t  // with the type of the base class.\n\t\t  if (path_tail.name == \"#\") {\n\t\t\tif (NetNet *net = scope->find_signal(perm_string::literal(THIS_TOKEN))) {\n\t\t\t      const netclass_t *class_type = dynamic_cast<const netclass_t*>(net->net_type());\n\t\t\t      path.push_back(path_tail);\n\t\t\t      res->scope = scope;\n\t\t\t      res->net = net;\n\t\t\t      res->type = class_type->get_super();\n\t\t\t      res->path_head = path;\n\t\t\t      return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t  }\n\n\t\t  if (NetNet*net = scope->find_signal(path_tail.name)) {\n\t\t\tif (prefix_scope || (net->lexical_pos() <= lexical_pos)) {\n\t\t\t      path.push_back(path_tail);\n\t\t\t      res->scope = scope;\n\t\t\t      res->net = net;\n\t\t\t      res->type = net->net_type();\n\t\t\t      res->path_head = path;\n\t\t\t      return true;\n\t\t\t} else if (!res->decl_after_use) {\n\t\t\t      res->decl_after_use = net;\n\t\t\t}\n\t\t  }\n\n\t\t  if (NetEvent*eve = scope->find_event(path_tail.name)) {\n\t\t\tif (prefix_scope || (eve->lexical_pos() <= lexical_pos)) {\n\t\t\t      path.push_back(path_tail);\n\t\t\t      res->scope = scope;\n\t\t\t      res->eve = eve;\n\t\t\t      res->path_head = path;\n\t\t\t      return true;\n\t\t\t} else if (!res->decl_after_use) {\n\t\t\t      res->decl_after_use = eve;\n\t\t\t}\n\t\t  }\n\n\t\t  if (const NetExpr*par = scope->get_parameter(des, path_tail.name, res->type)) {\n\t\t\tif (prefix_scope || (scope->get_parameter_lexical_pos(path_tail.name) <= lexical_pos)) {\n\t\t\t      path.push_back(path_tail);\n\t\t\t      res->scope = scope;\n\t\t\t      res->par_val = par;\n\t\t\t      res->path_head = path;\n\t\t\t      return true;\n\t\t\t} else if (!res->decl_after_use) {\n\t\t\t      res->decl_after_use = par;\n\t\t\t}\n\t\t  }\n\n\t\t    // Static items are just normal signals and are found above.\n\t\t  if (scope->type() == NetScope::CLASS) {\n\t\t\tconst netclass_t *clsnet = scope->class_def();\n\t\t\tint pidx = clsnet->property_idx_from_name(path_tail.name);\n\t\t\tif (pidx >= 0) {\n\t\t\t      // This is a class property being accessed in a\n\t\t\t      // class method. Return `this` for the net and the\n\t\t\t      // property name for the path tail.\n\t\t\t      NetScope *scope_method = find_method_containing_scope(*li, start_scope);\n\t\t\t      ivl_assert(*li, scope_method);\n\t\t\t      res->net = scope_method->find_signal(perm_string::literal(THIS_TOKEN));\n\t\t\t      ivl_assert(*li, res->net);\n\t\t\t      res->scope = scope;\n\t\t\t      ivl_assert(*li, path.empty());\n\t\t\t      res->path_head.push_back(name_component_t(perm_string::literal(THIS_TOKEN)));\n\t\t\t      res->path_tail.push_front(path_tail);\n\t\t\t      res->type = clsnet;\n\t\t\t      return true;\n\t\t\t}\n\t\t  }\n\n\t\t    // Finally check the rare case of a signal that hasn't\n\t\t    // been elaborated yet.\n\t\t  if (PWire*wire = scope->find_signal_placeholder(path_tail.name)) {\n\t\t\tif (prefix_scope || (wire->lexical_pos() <= lexical_pos)) {\n\t\t\t      NetNet*net = wire->elaborate_sig(des, scope);\n\t\t\t      if (!net)\n\t\t\t\t    return false;\n\t\t\t      path.push_back(path_tail);\n\t\t\t      res->scope = scope;\n\t\t\t      res->net = net;\n\t\t\t      res->type = net->net_type();\n\t\t\t      res->path_head = path;\n\t\t\t      return true;\n\t\t\t}\n\t\t  }\n\t    }\n\n\t    // Could not find an object. Maybe this is a child scope name? If\n\t    // so, evaluate the path components to find the exact scope this\n\t    // refers to. This item might be:\n\t    //     <scope>.s\n\t    //     <scope>.s[n]\n\t    // etc. The scope->child_byname tests if the name exists, and if\n\t    // it does, the eval_path_component() evaluates any [n]\n\t    // expressions to constants to generate an hname_t object for a\n\t    // more complete scope name search. Note that the index\n\t    // expressions for scope names must be constant.\n\t    if (scope->child_byname(path_tail.name)) {\n\t\t  bool flag = false;\n\t\t  hname_t path_item = eval_path_component(des, start_scope, path_tail, flag);\n\t\t  if (flag) {\n\t\t\tcerr << li->get_fileline() << \": XXXXX: Errors evaluating scope index\" << endl;\n\t\t  } else if (NetScope*chld = scope->child(path_item)) {\n\t\t\tpath.push_back(path_tail);\n\t\t\tres->scope = chld;\n\t\t\tres->path_head = path;\n\t\t\treturn true;\n\t\t  }\n\t    }\n\n\t    // Don't scan up if we are searching within a prefixed scope.\n\t    if (prefix_scope)\n\t\t  break;\n\n\t    // Imports are not visible through hierachical names\n\t    if (NetScope*import_scope = scope->find_import(des, path_tail.name)) {\n\t\t  scope = import_scope;\n\t\t  continue;\n\t    }\n\n\t    // Special case: We can match the module name of a parent\n\t    // module. That means if the current scope is a module of type\n\t    // \"mod\", then \"mod\" matches the current scope. This is fairly\n\t    // obscure, but looks like this:\n\t    //\n\t    //  module foo;\n\t    //    reg x;\n\t    //    ... foo.x; // This matches x in myself.\n\t    //  endmodule\n\t    //\n\t    // This feature recurses, so code in subscopes of foo can refer to\n\t    // foo by the name \"foo\" as well. In general, anything within\n\t    // \"foo\" can use the name \"foo\" to reference it.\n\t    if (scope->type()==NetScope::MODULE && scope->module_name()==path_tail.name) {\n\t\t  path.push_back(path_tail);\n\t\t  res->scope = scope;\n\t\t  res->path_head = path;\n\t\t  return true;\n\t    }\n\n\t    // If there is no prefix, then we are free to scan upwards looking\n\t    // for a scope name. Note that only scopes can be searched for up\n\t    // past module boundaries. To handle that, set a flag to indicate\n\t    // that we passed a module boundary on the way up.\n\t    if (scope->type()==NetScope::MODULE && !scope->nested_module())\n\t\t  passed_module_boundary = true;\n\n\t    scope = scope->parent();\n\n\t    // Last chance - try the compilation unit. Note that modules may\n\t    // reference nets/variables in the compilation unit, even if they\n\t    // cannot reference variables in containing scope.\n\t    //\n\t    //    int ok = 1;\n\t    //    module top;\n\t    //        int not_ok = 2;\n\t    //        dut foo();\n\t    //    endmodule\n\t    //\n\t    //    module dut;\n\t    //        ... = ok; // This reference is OK\n\t    //        ... = not_ok; // This reference is NOT OK.\n\t    //    endmodule\n\t    if (scope == 0 && start_scope != 0) {\n\t\t  scope = start_scope->unit();\n\t\t  start_scope = 0;\n\t\t  passed_module_boundary = false;\n\t    }\n      }\n\n\n      // Last chance: this is a single name, so it might be the name\n      // of a root scope. Ask the design if this is a root\n      // scope. This is only possible if there is no prefix.\n      if (prefix_scope==false) {\n\t    hname_t path_item (path_tail.name);\n\t    scope = des->find_scope(path_item);\n\t    if (scope) {\n\t\t  path.push_back(path_tail);\n\t\t  res->scope = scope;\n\t\t  res->path_head = path;\n\t\t  return true;\n\t    }\n      }\n\n      return false;\n}\n\nbool symbol_search(const LineInfo *li, Design *des, NetScope *scope,\n\t\t   const pform_scoped_name_t &path, unsigned lexical_pos,\n\t\t   struct symbol_search_results *res)\n{\n      NetScope *search_scope = scope;\n      bool prefix_scope = false;\n\n      if (path.package) {\n\t    search_scope = des->find_package(path.package->pscope_name());\n\t    if (!search_scope)\n\t\t  return false;\n\t    prefix_scope = true;\n      }\n\n      return symbol_search(li, des, search_scope, path.name, lexical_pos,\n\t\t\t   res, search_scope, prefix_scope);\n}\n"
        },
        {
          "name": "syn-rules.y",
          "type": "blob",
          "size": 9.5322265625,
          "content": "\n%{\n/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n/*\n * This file implements synthesis based on matching threads and\n * converting them to equivalent devices. The trick here is that the\n * proc_match_t functor can be used to scan a process and generate a\n * string of tokens. That string of tokens can then be matched by the\n * rules to determine what kind of device is to be made.\n */\n\n# include  \"netlist.h\"\n# include  \"netmisc.h\"\n# include  \"functor.h\"\n# include  <cassert>\n\nusing namespace std;\n\nstruct syn_token_t {\n      int token;\n\n      NetAssignBase*assign;\n      NetProcTop*top;\n      NetEvWait*evwait;\n      NetEvent*event;\n      NetExpr*expr;\n\n      syn_token_t*next_;\n};\n#define YYSTYPE syn_token_t*\n\nstatic int yylex();\nstatic void yyerror(const char*);\nstatic Design*des_;\n\nstatic void make_DFF_CE(Design*des, NetProcTop*top,\n\t\t\tNetEvent*eclk, NetExpr*cexp, NetAssignBase*asn);\n\n%}\n\n%token S_ALWAYS S_ASSIGN S_ASSIGN_MEM S_ASSIGN_MUX S_ELSE S_EVENT\n%token S_EXPR S_IF S_INITIAL\n\n%%\n\nstart\n\n  /* These rules match simple DFF devices. Clocked assignments are\n     simply implemented as DFF, and a CE is easily expressed with a\n     conditional statement. The typical Verilog that get these are:\n\n     always @(posedge CLK) Q = D\n     always @(negedge CLK) Q = D\n\n     always @(posedge CLK) if (CE) Q = D;\n     always @(negedge CLK) if (CE) Q = D;\n\n     The width of Q and D cause a wide register to be created. The\n     code generators generally implement that as an array of\n     flip-flops. */\n\n\t: S_ALWAYS '@' '(' S_EVENT ')' S_ASSIGN ';'\n\t\t{ make_DFF_CE(des_, $1->top, $4->event, 0, $6->assign);\n\t\t}\n\n\t| S_ALWAYS '@' '(' S_EVENT ')' S_IF S_EXPR S_ASSIGN ';' ';'\n\t\t{ make_DFF_CE(des_, $1->top, $4->event, $7->expr, $8->assign);\n\t\t}\n\n  /* Unconditional assignments in initial blocks should be made into\n     initializers wherever possible. */\n\n\t;\n%%\n\n\n  /* Various actions. */\n\nstatic void hookup_DFF_CE(NetFF*ff, NetESignal*d, NetEvProbe*pclk,\n                          NetNet*ce, NetAssign_*a, unsigned rval_pinoffset)\n{\n\n      if (rval_pinoffset != 0) {\n\t    cerr << a->get_fileline() << \": sorry: \"\n                 << \"unable to hook up an R-value with offset \"\n\t         << rval_pinoffset << \" to signal \" << a->name()\n\t         << \".\" << endl;\n\t    return;\n      }\n\t// a->sig() is a *NetNet, which doesn't have the loff_ and\n\t// lwid_ context.  Add the correction for loff_ ourselves.\n\n\t// This extra calculation allows for assignments like:\n\t//    lval[7:1] <= foo;\n\t// where lval is really a \"reg [7:0]\". In other words, part\n\t// selects in the l-value are handled by loff and the lwidth().\n\n      connect(ff->pin_Data(), d->sig()->pin(0));\n      connect(ff->pin_Q(), a->sig()->pin(0));\n\n      connect(ff->pin_Clock(), pclk->pin(0));\n      if (ce) connect(ff->pin_Enable(), ce->pin(0));\n\n\t/* This lval_ represents a reg that is a WIRE in the\n\t   synthesized results. This function signals the destructor\n\t   to change the REG that this l-value refers to into a\n\t   WIRE. It is done then, at the last minute, so that pending\n\t   synthesis can continue to work with it as a WIRE. */\n      a->turn_sig_to_wire_on_release();\n}\n\nstatic void make_DFF_CE(Design*des, NetProcTop*top,\n\t\t\tNetEvent*eclk, NetExpr*cexp, NetAssignBase*asn)\n{\n      assert(asn);\n\n      NetEvProbe*pclk = eclk->probe(0);\n      NetESignal*d = dynamic_cast<NetESignal*> (asn->rval());\n      NetNet*ce = cexp? cexp->synthesize(des, top->scope(), cexp) : 0;\n\n      if (d == 0) {\n\t    cerr << asn->get_fileline() << \": internal error: \"\n\t\t << \" not a simple signal? \" << *asn->rval() << endl;\n      }\n\n      assert(d);\n\n      NetAssign_*a;\n      unsigned rval_pinoffset=0;\n      for (unsigned i=0; (a=asn->l_val(i)); i++) {\n\n\t// asn->l_val(i) are the set of *NetAssign_'s that form the list\n\t// of lval expressions.  Treat each one independently, keeping\n\t// track of which bits of rval to use for each set of DFF inputs.\n\t// For example, given:\n\t//      {carry,data} <= x + y + z;\n\t// run through this loop twice, where a and rval_pinoffset are\n\t// first data and 0, then carry and 1.\n\t// FIXME:  ff gets its pin names wrong when loff_ is nonzero.\n\n\t    if (a->sig()) {\n              // cerr << \"new NetFF named \" << a->name() << endl;\n\t      bool negedge = pclk->edge() == NetEvProbe::NEGEDGE;\n              NetFF*ff = new NetFF(top->scope(), a->name(), negedge,\n\t\t\t\t   a->sig()->vector_width());\n              hookup_DFF_CE(ff, d, pclk, ce, a, rval_pinoffset);\n              des->add_node(ff);\n\t    }\n            rval_pinoffset += a->lwidth();\n      }\n      des->delete_process(top);\n}\n\n\nstatic syn_token_t*first_ = 0;\nstatic syn_token_t*last_ = 0;\nstatic syn_token_t*ptr_ = 0;\n\n/*\n * The match class is used to take a process and turn it into a stream\n * of tokens. This stream is used by the yylex function to feed tokens\n * to the parser.\n */\nstruct tokenize : public proc_match_t {\n      tokenize() { }\n      ~tokenize() { }\n\n      int assign(NetAssign*dev)\n      {\n\t    syn_token_t*cur;\n\t    cur = new syn_token_t;\n\t    // Bit Muxes can't be synthesized (yet), but it's too much\n\t    // work to detect them now.\n\t    // cur->token = dev->l_val(0)->bmux() ? S_ASSIGN_MUX : S_ASSIGN;\n\t    cur->token = S_ASSIGN;\n\t    cur->assign = dev;\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\t    return 0;\n      }\n\n      int assign_nb(NetAssignNB*dev)\n      {\n\t    syn_token_t*cur;\n\t    cur = new syn_token_t;\n\t    // Bit Muxes can't be synthesized (yet), but it's too much\n\t    // work to detect them now.\n\t    // cur->token = dev->l_val(0)->bmux() ? S_ASSIGN_MUX : S_ASSIGN;\n\t    cur->token = S_ASSIGN;\n\t    cur->assign = dev;\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\t    return 0;\n      }\n\n      int condit(NetCondit*dev)\n      {\n\t    syn_token_t*cur;\n\n\t    cur = new syn_token_t;\n\t    cur->token = S_IF;\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\n\t    cur = new syn_token_t;\n\t    cur->token = S_EXPR;\n\t    cur->expr = dev->expr();\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\n\t    /* Because synthesis is broken this is needed to prevent\n\t     * a seg. fault. */\n\t    if (!dev->if_clause()) return 0;\n\t    dev -> if_clause() -> match_proc(this);\n\n\t    if (dev->else_clause()) {\n\t\t  cur = new syn_token_t;\n\t\t  cur->token = S_ELSE;\n\t\t  cur->next_ = 0;\n\t\t  last_->next_ = cur;\n\t\t  last_ = cur;\n\n\t\t  dev -> else_clause() -> match_proc(this);\n\t    }\n\n\t    cur = new syn_token_t;\n\t    cur->token = ';';\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\t    return 0;\n      }\n\n      int event_wait(NetEvWait*dev)\n      {\n\t    syn_token_t*cur;\n\n\t    cur = new syn_token_t;\n\t    cur->token = '@';\n\t    cur->evwait = dev;\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\n\t    cur = new syn_token_t;\n\t    cur->token = '(';\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\n\t    for (unsigned idx = 0;  idx < dev->nevents(); idx += 1) {\n\t\t  cur = new syn_token_t;\n\t\t  cur->token = S_EVENT;\n\t\t  cur->event = dev->event(idx);\n\t\t  cur->next_ = 0;\n\t\t  last_->next_ = cur;\n\t\t  last_ = cur;\n\t    }\n\n\t    cur = new syn_token_t;\n\t    cur->token = ')';\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\n\t    dev -> statement() -> match_proc(this);\n\n\t    cur = new syn_token_t;\n\t    cur->token = ';';\n\t    cur->next_ = 0;\n\t    last_->next_ = cur;\n\t    last_ = cur;\n\t    return 0;\n      }\n};\n\nstatic void syn_start_process(NetProcTop*t)\n{\n      first_ = new syn_token_t;\n      last_ = first_;\n      ptr_ = first_;\n\n\t// Can the following be converted into S_ALWAYS?\n      if ((t->type() == IVL_PR_ALWAYS_COMB) ||\n          (t->type() == IVL_PR_ALWAYS_FF) ||\n          (t->type() == IVL_PR_ALWAYS_LATCH)) {\n\t    cerr << t->get_fileline() << \": internal error: \"\n\t\t << \" Need to check if this can be synthesized.\" << endl;\n\t    assert(0);\n      }\n\n      first_->token = (t->type() == IVL_PR_ALWAYS)? S_ALWAYS : S_INITIAL;\n      first_->top = t;\n      first_->next_ = 0;\n\n      tokenize go;\n      t -> statement() -> match_proc(&go);\n}\n\nstatic void syn_done_process()\n{\n      while (first_) {\n\t    syn_token_t*cur = first_;\n\t    first_ = cur->next_;\n\t    delete cur;\n      }\n}\n\nstatic int yylex()\n{\n      if (ptr_ == 0) {\n\t    yylval = 0;\n\t    return 0;\n      }\n\n      yylval = ptr_;\n      ptr_ = ptr_->next_;\n      return yylval->token;\n}\n\nstruct syn_rules_f  : public functor_t {\n      ~syn_rules_f() { }\n\n      void process(class Design*, class NetProcTop*top)\n      {\n\t      /* If the scope that contains this process as a cell\n\t\t attribute attached to it, then skip synthesis. */\n\t    if (top->scope()->attribute(perm_string::literal(\"ivl_synthesis_cell\")).len() > 0)\n\t\t  return;\n\n\t    syn_start_process(top);\n\t    yyparse();\n\t    syn_done_process();\n      }\n};\n\nvoid syn_rules(Design*d)\n{\n      des_ = d;\n      syn_rules_f obj;\n      des_->functor(&obj);\n}\n\nstatic void yyerror(const char*)\n{\n}\n"
        },
        {
          "name": "sync.cc",
          "type": "blob",
          "size": 1.7255859375,
          "content": "/*\n * Copyright (c) 2002-2010 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"functor.h\"\n# include  \"netlist.h\"\n# include  <cassert>\n\n/*\n * Most process statements are not roots of synchronous logic.\n */\nbool NetProc::is_synchronous()\n{\n      return false;\n}\n\nbool NetEvWait::is_synchronous()\n{\n      for (unsigned idx = 0 ;  idx < events_.size() ;  idx += 1) {\n\t    NetEvent*ev = events_[idx];\n\n\t    if (ev->nprobe() == 0)\n\t\t  return false;\n\n\t    for (unsigned pdx = 0 ;  pdx < ev->nprobe() ;  pdx += 1) {\n\t\t  NetEvProbe*pr = ev->probe(pdx);\n\n\t\t    /* No level sensitive clocks. */\n\t\t  if (pr->edge() == NetEvProbe::ANYEDGE)\n\t\t\treturn false;\n\t    }\n\n      }\n\n\t/* So we know that there is a clock source. Check that the\n\t   input to the storage is asynchronous. */\n      return true; //statement_->is_asynchronous();\n}\n\nbool NetProcTop::is_synchronous()\n{\n      if (type_ == IVL_PR_INITIAL)\n\t    return false;\n\n      return statement_->is_synchronous();\n}\n"
        },
        {
          "name": "synth.cc",
          "type": "blob",
          "size": 4.109375,
          "content": "/*\n * Copyright (c) 1999-2017 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"functor.h\"\n# include  \"netlist.h\"\n\n/*\n * This functor scans the behavioral code, looking for expressions to\n * synthesize. Although it uses the proc_match_t class, it doesn't\n * actually match anything, but transforms expressions into structural\n * netlists. The product of this should be a process where all the\n * expressions have been reduced to a signal ident, which references\n * the NetNet of the now synthesized expression.\n */\nclass do_expr  : public proc_match_t {\n\n    public:\n      do_expr(Design*d, NetScope*s)\n      : des_(d), scope_(s) { }\n\n    private:\n\n      Design*des_;\n      NetScope*scope_;\n\n      virtual int assign(NetAssign*);\n      virtual int assign_nb(NetAssignNB*);\n      virtual int event_wait(NetEvWait*);\n      virtual int condit(NetCondit*);\n};\n\n\nint do_expr::assign(NetAssign*stmt)\n{\n      if (dynamic_cast<NetESignal*>(stmt->rval()))\n\t    return 0;\n\n      NetNet*tmp = stmt->rval()->synthesize(des_, scope_, stmt->rval());\n      if (tmp == 0)\n\t    return 0;\n\n      NetESignal*tmpe = new NetESignal(tmp);\n      stmt->set_rval(tmpe);\n\n      return 0;\n}\n\nint do_expr::assign_nb(NetAssignNB*stmt)\n{\n      if (dynamic_cast<NetESignal*>(stmt->rval()))\n\t    return 0;\n\n      NetNet*tmp = stmt->rval()->synthesize(des_, scope_, stmt->rval());\n      if (tmp == 0)\n\t    return 0;\n\n      NetESignal*tmpe = new NetESignal(tmp);\n      stmt->set_rval(tmpe);\n\n      return 0;\n}\n\nint do_expr::condit(NetCondit*stmt)\n{\n\t/* synthesize the condition expression, if necessary. */\n      if (! dynamic_cast<NetESignal*>(stmt->expr())) {\n\t    NetNet*tmp = stmt->expr()->synthesize(des_, scope_, stmt->expr());\n\n\t    if (tmp) {\n\t\t  NetESignal*tmpe = new NetESignal(tmp);\n\t\t  stmt->set_expr(tmpe);\n\t    }\n\n      }\n\n\t/* Now recurse through the if and else clauses. */\n      if (NetProc*tmp = stmt->if_clause())\n\t    tmp->match_proc(this);\n\n      if (NetProc*tmp = stmt->else_clause())\n\t    tmp->match_proc(this);\n\n      return 0;\n}\n\nint do_expr::event_wait(NetEvWait*stmt)\n{\n      NetProc*tmp = stmt->statement();\n      if (tmp)\n\t    return tmp->match_proc(this);\n      else\n\t    return 0;\n}\n\nclass synth_f  : public functor_t {\n\n    public:\n      synth_f() { top_ = NULL; }\n      void process(Design*, NetProcTop*);\n\n    private:\n      void proc_always_(Design*);\n      void proc_initial_(Design*);\n      void proc_final_(Design*);\n\n      NetProcTop*top_;\n};\n\n\n/*\n * Look at a process, and divide the problem into always and initial\n * threads.\n */\nvoid synth_f::process(Design*des, NetProcTop*top)\n{\n      top_ = top;\n      switch (top->type()) {\n\t  case IVL_PR_ALWAYS:\n\t  case IVL_PR_ALWAYS_COMB:\n\t  case IVL_PR_ALWAYS_FF:\n\t  case IVL_PR_ALWAYS_LATCH:\n\t    proc_always_(des);\n\t    break;\n\t  case IVL_PR_INITIAL:\n\t    proc_initial_(des);\n\t    break;\n\t  case IVL_PR_FINAL:\n\t    proc_final_(des);\n\t    break;\n      }\n}\n\nvoid synth_f::proc_always_(Design*des)\n{\n      do_expr expr_pat(des, top_->scope());\n      top_->statement()->match_proc(&expr_pat);\n}\n\nvoid synth_f::proc_initial_(Design*des)\n{\n      do_expr expr_pat(des, top_->scope());\n      top_->statement()->match_proc(&expr_pat);\n}\n\nvoid synth_f::proc_final_(Design*des)\n{\n      do_expr expr_pat(des, top_->scope());\n      top_->statement()->match_proc(&expr_pat);\n}\n\nvoid synth(Design*des)\n{\n      synth_f synth_obj;\n      des->functor(&synth_obj);\n}\n"
        },
        {
          "name": "synth2.cc",
          "type": "blob",
          "size": 76.4443359375,
          "content": "/*\n * Copyright (c) 2002-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"functor.h\"\n# include  \"netlist.h\"\n# include  \"netvector.h\"\n# include  \"netmisc.h\"\n# include  \"compiler.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/* General notes on enables and bitmasks.\n *\n * When synthesising an asynchronous process that contains conditional\n * statements (if/case statements), we need to determine the conditions\n * that cause each nexus driven by that process to be updated. If a\n * nexus is not updated under all circumstances, we must infer a latch.\n * To this end, we generate an enable signal for each output nexus. As\n * we walk the statement tree for the process, for each substatement we\n * pass the enable signals generated so far into the synth_async method,\n * and on return from the synth_async method, the enable signals will be\n * updated to reflect any conditions introduced by that substatement.\n * Once we have synthesised all the statements for that process, if an\n * enable signal is not tied high, we must infer a latch for that nexus.\n *\n * When synthesising a synchronous process, we use the synth_async method\n * to synthesise the combinatorial inputs to the D pins of the flip-flops\n * we infer for that process. In this case the enable signal can be used\n * as a clock enable for the flip-flop. This saves us explicitly feeding\n * back the flip-flop output to undriven inputs of any synthesised muxes.\n *\n * The strategy described above is not sufficient when not all bits in\n * a nexus are treated identically (i.e. different conditional clauses\n * drive differing parts of the same vector). To handle this properly,\n * we would (potentially) need to generate a separate enable signal for\n * each bit in the vector. This would be a lot of work, particularly if\n * we wanted to eliminate duplicates. For now, the strategy employed is\n * to maintain a bitmask for each output nexus that identifies which bits\n * in the nexus are unconditionally driven (driven by every clause). When\n * we finish synthesising an asynchronous process, if the bitmask is not\n * all ones, we must infer a latch. This currently results in an error,\n * because to safely synthesise such a latch we would need the bit-level\n * gate enables. When we finish synthesising a synchronous process, if\n * the bitmask is not all ones, we explicitly feed the flip-flop outputs\n * back to undriven inputs of any synthesised muxes to ensure undriven\n * parts of the vector retain their previous state when the flip-flop is\n * clocked.\n *\n * The enable signals are passed as links to the current output nexus\n * for each signal. If an enable signal is not linked, this is treated\n * as if the signal was tied low.\n *\n * The bitmasks are passed as bool vectors. 'true' indicates a bit is\n * unconditionally driven. An empty vector (size = 0) indicates that\n * the current substatement doesn't drive any bits in the nexus.\n */\n\nstatic void qualify_enable(Design*des, NetScope*scope, NetNet*qualifier,\n\t\t\t   bool active_state, NetLogic::TYPE gate_type,\n\t\t\t   Link&enable_i, Link&enable_o)\n{\n      if (enable_i.is_linked(scope->tie_lo())) {\n\t    connect(enable_o, scope->tie_lo());\n\t    return;\n      }\n\n      if (active_state == false) {\n\t    NetLogic*gate = new NetLogic(scope, scope->local_symbol(),\n\t\t\t\t\t 2, NetLogic::NOT, 1);\n\t    des->add_node(gate);\n\t    connect(gate->pin(1), qualifier->pin(0));\n\n\t    NetNet*sig = new NetNet(scope, scope->local_symbol(), NetNet::WIRE,\n\t\t\t\t    &netvector_t::scalar_logic);\n\t    sig->local_flag(true);\n\t    connect(sig->pin(0), gate->pin(0));\n\n\t    qualifier = sig;\n      }\n\n      if (enable_i.is_linked(scope->tie_hi())) {\n\t    connect(enable_o, qualifier->pin(0));\n\t    return;\n      }\n\n      NetLogic*gate = new NetLogic(scope, scope->local_symbol(),\n\t\t\t\t   3, gate_type, 1);\n      des->add_node(gate);\n      connect(gate->pin(1), qualifier->pin(0));\n      connect(gate->pin(2), enable_i);\n      connect(enable_o, gate->pin(0));\n\n      NetNet*sig = new NetNet(scope, scope->local_symbol(), NetNet::WIRE,\n\t\t\t      &netvector_t::scalar_logic);\n      sig->local_flag(true);\n      connect(sig->pin(0), gate->pin(0));\n}\n\nstatic void multiplex_enables(Design*des, NetScope*scope, NetNet*select,\n\t\t\t      Link&enable_1, Link&enable_0, Link&enable_o)\n{\n      if (!enable_1.is_linked() &&\n\t  !enable_0.is_linked() )\n\t    return;\n\n      if ( enable_1.is_linked(scope->tie_hi()) &&\n\t   enable_0.is_linked(scope->tie_hi()) ) {\n\t    connect(enable_o, scope->tie_hi());\n\t    return;\n      }\n\n      if (enable_1.is_linked(scope->tie_lo()) || !enable_1.is_linked()) {\n\t    qualify_enable(des, scope, select, false, NetLogic::AND,\n\t\t\t   enable_0, enable_o);\n\t    return;\n      }\n      if (enable_0.is_linked(scope->tie_lo()) || !enable_0.is_linked()) {\n\t    qualify_enable(des, scope, select, true,  NetLogic::AND,\n\t\t\t   enable_1, enable_o);\n\t    return;\n      }\n      if (enable_1.is_linked(scope->tie_hi())) {\n\t    qualify_enable(des, scope, select, true,  NetLogic::OR,\n\t\t\t   enable_0, enable_o);\n\t    return;\n      }\n      if (enable_0.is_linked(scope->tie_hi())) {\n\t    qualify_enable(des, scope, select, false, NetLogic::OR,\n\t\t\t   enable_1, enable_o);\n\t    return;\n      }\n\n      NetMux*mux = new NetMux(scope, scope->local_symbol(), 1, 2, 1);\n      des->add_node(mux);\n      connect(mux->pin_Sel(),\tselect->pin(0));\n      connect(mux->pin_Data(1), enable_1);\n      connect(mux->pin_Data(0), enable_0);\n      connect(enable_o, mux->pin_Result());\n\n      NetNet*sig = new NetNet(scope, scope->local_symbol(), NetNet::WIRE,\n\t\t\t      &netvector_t::scalar_logic);\n      sig->local_flag(true);\n      connect(sig->pin(0), mux->pin_Result());\n}\n\nstatic void merge_sequential_enables(Design*des, NetScope*scope,\n\t\t\t\t     Link&top_enable, Link&sub_enable)\n{\n      if (!sub_enable.is_linked())\n\t    return;\n\n      if (top_enable.is_linked(scope->tie_hi()))\n\t    return;\n\n      if (sub_enable.is_linked(scope->tie_hi()))\n\t    top_enable.unlink();\n\n      if (top_enable.is_linked()) {\n\t    NetLogic*gate = new NetLogic(scope, scope->local_symbol(),\n\t\t\t\t\t 3, NetLogic::OR, 1);\n\t    des->add_node(gate);\n\t    connect(gate->pin(1), sub_enable);\n\t    connect(gate->pin(2), top_enable);\n\t    top_enable.unlink();\n\t    connect(top_enable, gate->pin(0));\n\n\t    NetNet*sig = new NetNet(scope, scope->local_symbol(), NetNet::WIRE,\n\t\t\t\t    &netvector_t::scalar_logic);\n\t    sig->local_flag(true);\n\t    connect(sig->pin(0), gate->pin(0));\n      } else {\n\t    connect(top_enable, sub_enable);\n      }\n}\n\nstatic void merge_sequential_masks(NetProc::mask_t&top_mask, const NetProc::mask_t&sub_mask)\n{\n      if (sub_mask.size() == 0)\n\t    return;\n\n      if (top_mask.size() == 0) {\n\t    top_mask = sub_mask;\n\t    return;\n      }\n\n      assert(top_mask.size() == sub_mask.size());\n      for (unsigned idx = 0 ; idx < top_mask.size() ; idx += 1) {\n\t    if (sub_mask[idx] == true)\n\t\t  top_mask[idx] = true;\n      }\n}\n\nstatic void merge_parallel_masks(NetProc::mask_t&top_mask, const NetProc::mask_t&sub_mask)\n{\n      if (sub_mask.size() == 0)\n\t    return;\n\n      if (top_mask.size() == 0) {\n\t    top_mask = sub_mask;\n\t    return;\n      }\n\n      assert(top_mask.size() == sub_mask.size());\n      for (unsigned idx = 0 ; idx < top_mask.size() ; idx += 1) {\n\t    if (sub_mask[idx] == false)\n\t\t  top_mask[idx] = false;\n      }\n}\n\nstatic bool all_bits_driven(const NetProc::mask_t&mask)\n{\n      if (mask.size() == 0)\n\t    return false;\n\n      for (unsigned idx = 0 ; idx < mask.size() ; idx += 1) {\n\t    if (mask[idx] == false)\n\t\t  return false;\n      }\n      return true;\n}\n\nbool NetProcTop::tie_off_floating_inputs_(Design*des,\n\t\t\t\t\t  NexusSet&nex_map, NetBus&nex_in,\n\t\t\t\t\t  const vector<NetProc::mask_t>&bitmasks,\n\t\t\t\t\t  bool is_ff_input)\n{\n      bool flag = true;\n      for (unsigned idx = 0 ; idx < nex_in.pin_count() ; idx += 1) {\n\t    if (nex_in.pin(idx).nexus()->has_floating_input()) {\n\t\t  if (all_bits_driven(bitmasks[idx])) {\n\t\t\t  // If all bits are unconditionally driven, we can\n\t\t\t  // use the enable signal to prevent the flip-flop/\n\t\t\t  // latch from updating when an undriven mux input\n\t\t\t  // is selected, so we can just tie off the input.\n\t\t\tunsigned width = nex_map[idx].wid;\n\t\t\tNetLogic*gate = new NetLogic(scope(), scope()->local_symbol(),\n\t\t\t\t\t\t     1, NetLogic::PULLDOWN, width);\n\t\t\tdes->add_node(gate);\n\t\t\tconnect(nex_in.pin(idx), gate->pin(0));\n\n\t\t\tif (nex_in.pin(idx).nexus()->pick_any_net())\n\t\t\t      continue;\n\n\t\t\tivl_variable_type_t data_type = IVL_VT_LOGIC;\n\t\t\tnetvector_t*tmp_vec = new netvector_t(data_type, width-1,0);\n\t\t\tNetNet*sig = new NetNet(scope(), scope()->local_symbol(),\n\t\t\t\t\t\tNetNet::WIRE, tmp_vec);\n\t\t\tsig->local_flag(true);\n\t\t\tconnect(sig->pin(0), gate->pin(0));\n\t\t  } else if (is_ff_input) {\n\t\t\t  // For a flip-flop, we can feed back the output\n\t\t\t  // to ensure undriven bits hold their last value.\n\t\t\tconnect(nex_in.pin(idx), nex_map[idx].lnk);\n\t\t  } else {\n\t\t\t  // This infers a latch, but without generating\n\t\t\t  // gate enable signals at the bit-level, we\n\t\t\t  // can't safely latch the undriven bits (we\n\t\t\t  // shouldn't generate combinatorial loops).\n\t\t\tcerr << get_fileline() << \": warning: A latch \"\n\t\t\t     << \"has been inferred for some bits of '\"\n\t\t\t     << nex_map[idx].lnk.nexus()->pick_any_net()->name()\n\t\t\t     << \"'.\" << endl;\n\n\t\t\tcerr << get_fileline() << \": sorry: Bit-level \"\n\t\t\t\t\"latch gate enables are not currently \"\n\t\t\t\t\"supported in synthesis.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\tflag = false;\n\t\t  }\n\t    }\n      }\n      return flag;\n}\n\nbool NetProc::synth_async(Design*, NetScope*, NexusSet&, NetBus&, NetBus&, vector<mask_t>&)\n{\n      return false;\n}\n\n/*\n * Async synthesis of assignments is done by synthesizing the rvalue\n * expression, then connecting the l-value directly to the output of\n * the r-value.\n *\n * The nex_map is the O-set for the statement, and lists the positions\n * of the outputs as the caller wants results linked up. The nex_out,\n * however, is the set of nexa that are to actually get linked to the\n * r-value.\n */\nbool NetAssignBase::synth_async(Design*des, NetScope*scope,\n\t\t\t\tNexusSet&nex_map, NetBus&nex_out,\n\t\t\t\tNetBus&enables, vector<mask_t>&bitmasks)\n{\n      if (dynamic_cast<NetCAssign*>(this) || dynamic_cast<NetDeassign*>(this) ||\n          dynamic_cast<NetForce*>(this) || dynamic_cast<NetRelease*>(this)) {\n\t    cerr << get_fileline() << \": sorry: Procedural continuous \"\n\t\t    \"assignment is not currently supported in synthesis.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n\t/* If the lval is a concatenation, synthesise each part\n\t   separately. */\n      if (lval_->more ) {\n\t      /* Temporarily set the lval_ and rval_ fields for each\n\t\t part in turn and recurse. Restore them when done. */\n\t    NetAssign_*full_lval = lval_;\n\t    NetExpr*full_rval = rval_;\n\t    unsigned offset = 0;\n\t    bool flag = true;\n\t    while (lval_) {\n\t\t  unsigned width = lval_->lwidth();\n\t\t  NetEConst*base = new NetEConst(verinum(offset));\n\t\t  base->set_line(*this);\n\t\t  rval_ = new NetESelect(full_rval->dup_expr(), base, width);\n\t\t  rval_->set_line(*this);\n\t\t  eval_expr(rval_, width);\n\t\t  NetAssign_*more = lval_->more;\n\t\t  lval_->more = 0;\n\t\t  if (!synth_async(des, scope, nex_map, nex_out, enables, bitmasks))\n\t\t\tflag = false;\n\t\t  lval_ = lval_->more = more;\n\t\t  offset += width;\n\t    }\n\t    lval_ = full_lval;\n\t    rval_ = full_rval;\n\t    return flag;\n      }\n\n      assert(rval_);\n      NetNet*rsig = rval_->synthesize(des, scope, rval_);\n      assert(rsig);\n\n      if (lval_->word() && ! dynamic_cast<NetEConst*>(lval_->word())) {\n\t    cerr << get_fileline() << \": sorry: Assignment to variable \"\n\t\t    \"location in memory is not currently supported in \"\n\t\t    \"synthesis.\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      NetNet*lsig = lval_->sig();\n      if (!lsig) {\n\t    cerr << get_fileline() << \": error: \"\n\t\t    \"NetAssignBase::synth_async on unsupported lval \";\n\t    dump_lval(cerr);\n\t    cerr << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetAssignBase::synth_async: \"\n\t\t << \"l-value signal is \" << lsig->vector_width() << \" bits, \"\n\t\t << \"r-value signal is \" << rsig->vector_width() << \" bits.\" << endl;\n\t    cerr << get_fileline() << \": NetAssignBase::synth_async: \"\n\t\t << \"lval_->lwidth()=\" << lval_->lwidth() << endl;\n\t    cerr << get_fileline() << \": NetAssignBase::synth_async: \"\n\t\t << \"lsig = \" << scope_path(scope) << \".\" << lsig->name() << endl;\n\t    if (const NetExpr*base = lval_->get_base()) {\n\t\t  cerr << get_fileline() << \": NetAssignBase::synth_async: \"\n\t\t       << \"base_=\" << *base << endl;\n\t    }\n\t    cerr << get_fileline() << \": NetAssignBase::synth_async: \"\n\t\t << \"nex_map.size()==\" << nex_map.size()\n\t\t << \", nex_out.pin_count()==\" << nex_out.pin_count() << endl;\n      }\n\n      unsigned ptr = 0;\n      if (nex_out.pin_count() > 1) {\n\t    NexusSet tmp_set;\n\t    nex_output(tmp_set);\n\t    ivl_assert(*this, tmp_set.size() == 1);\n\t    ptr = nex_map.find_nexus(tmp_set[0]);\n\t    ivl_assert(*this, nex_out.pin_count() > ptr);\n\t    ivl_assert(*this, enables.pin_count() > ptr);\n\t    ivl_assert(*this, bitmasks.size() > ptr);\n      } else {\n\t    ivl_assert(*this, nex_out.pin_count() == 1);\n\t    ivl_assert(*this, enables.pin_count() == 1);\n\t    ivl_assert(*this, bitmasks.size() == 1);\n      }\n\n      unsigned lval_width = lval_->lwidth();\n      unsigned lsig_width = lsig->vector_width();\n      ivl_assert(*this, nex_map[ptr].wid == lsig_width);\n\n\t// Here we note if the l-value is actually a bit/part\n\t// select. If so, generate a NetPartSelect to perform the select.\n      bool is_part_select = lval_width != lsig_width;\n\n      long base_off = 0;\n      if (is_part_select && !scope->loop_index_tmp.empty()) {\n\t      // If we are within a NetForLoop, there may be an index\n\t      // value. That is collected from the scope member\n\t      // loop_index_tmp, and the evaluate_function method\n\t      // knows how to apply it.\n\t    ivl_assert(*this, !scope->loop_index_tmp.empty());\n\t    ivl_assert(*this, lval_width < lsig_width);\n\n\t      // Evaluate the index expression to a constant.\n\t    const NetExpr*base_expr_raw = lval_->get_base();\n\t    ivl_assert(*this, base_expr_raw);\n\t    NetExpr*base_expr = base_expr_raw->evaluate_function(*this, scope->loop_index_tmp);\n\t    if (! eval_as_long(base_off, base_expr)) {\n\t\t  ivl_assert(*this, 0);\n\t    }\n\t    ivl_assert(*this, base_off >= 0);\n\n\t    ivl_variable_type_t tmp_data_type = rsig->data_type();\n\t    netvector_t*tmp_type = new netvector_t(tmp_data_type, lsig_width-1,0);\n\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::WIRE, tmp_type);\n\t    tmp->local_flag(true);\n\t    tmp->set_line(*this);\n\n\t    NetPartSelect*ps = new NetPartSelect(tmp, base_off, lval_width, NetPartSelect::PV);\n\t    ps->set_line(*this);\n\t    des->add_node(ps);\n\n\t    connect(ps->pin(0), rsig->pin(0));\n\t    rsig = tmp;\n\n      } else if (is_part_select) {\n\t      // In this case, there is no loop_index_tmp, so we are\n\t      // not within a NetForLoop. Generate a NetSubstitute\n\t      // object to handle the bit/part-select in the l-value.\n\t    ivl_assert(*this, scope->loop_index_tmp.empty());\n\t    ivl_assert(*this, lval_width < lsig_width);\n\n\t    const NetExpr*base_expr_raw = lval_->get_base();\n\t    ivl_assert(*this, base_expr_raw);\n\t    NetExpr*base_expr = base_expr_raw->evaluate_function(*this, scope->loop_index_tmp);\n\t    if (! eval_as_long(base_off, base_expr)) {\n\t\t  cerr << get_fileline() << \": sorry: assignment to variable \"\n\t\t\t  \"bit location is not currently supported in \"\n\t\t\t  \"synthesis.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    ivl_assert(*this, base_off >= 0);\n\n\t    ivl_variable_type_t tmp_data_type = rsig->data_type();\n\t    netvector_t*tmp_type = new netvector_t(tmp_data_type, lsig_width-1,0);\n\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::WIRE, tmp_type);\n\t    tmp->local_flag(true);\n\t    tmp->set_line(*this);\n\n\t    NetNet*isig = nex_out.pin(ptr).nexus()->pick_any_net();\n\t    if (isig) {\n\t\t  if (debug_synth2) {\n\t\t\tcerr << get_fileline() << \": NetAssignBase::synth_async: \"\n\t\t\t     << \" Found an isig:\" << endl;\n\t\t\tnex_out.pin(ptr).dump_link(cerr, 8);\n\t\t  }\n\t    } else {\n\t\t  if (debug_synth2) {\n\t\t\tcerr << get_fileline() << \": NetAssignBase::synth_async: \"\n\t\t\t     << \" Found no isig, resorting to lsig.\" << endl;\n\t\t  }\n\t\t  isig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::WIRE, tmp_type);\n\t\t  isig->local_flag(true);\n\t\t  isig->set_line(*this);\n\t\t  connect(isig->pin(0), nex_out.pin(ptr));\n\t    }\n\t    ivl_assert(*this, isig);\n\t    NetSubstitute*ps = new NetSubstitute(isig, rsig, lsig_width, base_off);\n\t    ps->set_line(*this);\n\t    des->add_node(ps);\n\n\t    connect(ps->pin(0), tmp->pin(0));\n\t    rsig = tmp;\n      }\n\n      rsig = crop_to_width(des, rsig, lsig_width);\n\n      ivl_assert(*this, rsig->pin_count()==1);\n      nex_out.pin(ptr).unlink();\n      enables.pin(ptr).unlink();\n      connect(nex_out.pin(ptr), rsig->pin(0));\n      connect(enables.pin(ptr), scope->tie_hi());\n\n      mask_t&bitmask = bitmasks[ptr];\n      if (is_part_select) {\n\t    if (bitmask.size() == 0) {\n\t\t  bitmask = mask_t (lsig_width, false);\n\t    }\n\t    ivl_assert(*this, bitmask.size() == lsig_width);\n\t    for (unsigned idx = 0; idx < lval_width; idx += 1) {\n\t\t  bitmask[base_off + idx] = true;\n\t    }\n      } else if (bitmask.size() > 0) {\n\t    for (unsigned idx = 0; idx < bitmask.size(); idx += 1) {\n\t\t  bitmask[idx] = true;\n\t    }\n      } else {\n\t    bitmask = mask_t (lsig_width, true);\n      }\n\n\t/* This lval_ represents a reg that is a WIRE in the\n\t   synthesized results. This function signals the destructor\n\t   to change the REG that this l-value refers to into a\n\t   WIRE. It is done then, at the last minute, so that pending\n\t   synthesis can continue to work with it as a REG. */\n      lval_->turn_sig_to_wire_on_release();\n\n      return true;\n}\n\nbool NetProc::synth_async_block_substatement_(Design*des, NetScope*scope,\n\t\t\t\t\t      NexusSet&nex_map,\n\t\t\t\t\t      NetBus&nex_out,\n\t\t\t\t\t      NetBus&enables,\n\t\t\t\t\t      vector<mask_t>&bitmasks,\n\t\t\t\t\t      NetProc*substmt)\n{\n      ivl_assert(*this, nex_map.size() == nex_out.pin_count());\n      ivl_assert(*this, nex_map.size() == enables.pin_count());\n      ivl_assert(*this, nex_map.size() == bitmasks.size());\n\n\t// Create a temporary map of the output only from this statement.\n      NexusSet tmp_map;\n      substmt->nex_output(tmp_map);\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetProc::synth_async_block_substatement_: \"\n\t\t << \"tmp_map.size()==\" << tmp_map.size()\n\t\t << \" for statement at \" << substmt->get_fileline()\n\t\t << endl;\n\t    for (unsigned idx  = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t\t  cerr << get_fileline() << \": NetProc::synth_async_block_substatement_: \"\n\t\t       << \"incoming nex_out[\" << idx << \"] dump link\" << endl;\n\t\t  nex_out.pin(idx).dump_link(cerr, 8);\n\t    }\n      }\n\n\t// Create temporary variables to collect the output from the synthesis.\n      NetBus tmp_out (scope, tmp_map.size());\n      NetBus tmp_ena (scope, tmp_map.size());\n      vector<mask_t> tmp_masks (tmp_map.size());\n\n\t// Map (and move) the accumulated nex_out for this block\n\t// to the version that we can pass to the next statement.\n\t// We will move the result back later.\n      for (unsigned idx = 0 ; idx < tmp_out.pin_count() ; idx += 1) {\n\t    unsigned ptr = nex_map.find_nexus(tmp_map[idx]);\n\t    ivl_assert(*this, ptr < nex_out.pin_count());\n\t    connect(tmp_out.pin(idx), nex_out.pin(ptr));\n\t    nex_out.pin(ptr).unlink();\n      }\n\n      if (debug_synth2) {\n\t    for (unsigned idx = 0 ; idx < nex_map.size() ; idx += 1) {\n\t\t  cerr << get_fileline() << \": NetProc::synth_async_block_substatement_: nex_map[\" << idx << \"] dump link, base=\" << nex_map[idx].base << \", wid=\" << nex_map[idx].wid << endl;\n\t\t  nex_map[idx].lnk.dump_link(cerr, 8);\n\t     }\n\t    for (unsigned idx = 0 ; idx < tmp_map.size() ; idx += 1) {\n\t\t  cerr << get_fileline() << \": NetProc::synth_async_block_substatement_: tmp_map[\" << idx << \"] dump link, base=\" << tmp_map[idx].base << \", wid=\" << tmp_map[idx].wid << endl;\n\t\t  tmp_map[idx].lnk.dump_link(cerr, 8);\n\t     }\n\t    for (unsigned idx = 0 ; idx < tmp_out.pin_count() ; idx += 1) {\n\t\t  cerr << get_fileline() << \": NetProc::synth_async_block_substatement_: tmp_out[\" << idx << \"] dump link\" << endl;\n\t\t  tmp_out.pin(idx).dump_link(cerr, 8);\n\t    }\n      }\n\n\n      bool flag = substmt->synth_async(des, scope, tmp_map, tmp_out, tmp_ena, tmp_masks);\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetProc::synth_async_block_substatement_: \"\n\t\t  \"substmt->synch_async(...) --> \" << (flag? \"true\" : \"false\")\n\t\t << \" for statement at \" << substmt->get_fileline() << \".\" << endl;\n      }\n\n      if (!flag) return false;\n\n\t// Now map the output from the substatement back to the\n\t// outputs for this block.\n      for (unsigned idx = 0 ;  idx < tmp_out.pin_count() ;  idx += 1) {\n\t    unsigned ptr = nex_map.find_nexus(tmp_map[idx]);\n\t    ivl_assert(*this, ptr < nex_out.pin_count());\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetProc::synth_async_block_substatement_: \"\n\t\t       << \"tmp_out.pin(\" << idx << \"):\" << endl;\n\t\t  tmp_out.pin(idx).dump_link(cerr, 8);\n\t    }\n\t    connect(nex_out.pin(ptr), tmp_out.pin(idx));\n\n\t    merge_sequential_enables(des, scope, enables.pin(ptr), tmp_ena.pin(idx));\n\n\t    merge_sequential_masks(bitmasks[ptr], tmp_masks[idx]);\n      }\n\n      return true;\n}\n\n/*\n * Sequential blocks are translated to asynchronous logic by\n * translating each statement of the block, in order, into gates.\n * The nex_out for the block is the union of the nex_out for all\n * the substatements.\n */\nbool NetBlock::synth_async(Design*des, NetScope*scope,\n\t\t\t   NexusSet&nex_map, NetBus&nex_out,\n\t\t\t   NetBus&enables, vector<mask_t>&bitmasks)\n{\n      if (last_ == 0) {\n\t    return true;\n      }\n\n      bool flag = true;\n      NetProc*cur = last_;\n      do {\n\t    cur = cur->next_;\n\n\t    bool sub_flag = synth_async_block_substatement_(des, scope, nex_map, nex_out,\n\t\t\t\t\t\t\t    enables, bitmasks, cur);\n\t    flag = flag && sub_flag;\n\n      } while (cur != last_);\n\n      return flag;\n}\n\n/*\n * This function is used to fix up a MUX selector to be no longer than\n * it needs to be. The general idea is that if the selector needs to\n * be only N bits, but is actually M bits, we translate it to this:\n *\n *     osig = { |esig[M-1:N-1], esig[N-2:0] }\n *\n * This obviously implies that (N >= 2) and (M >= N). In the code\n * below, N is sel_need, and M is sel_got (= esig->vector_width()).\n */\nstatic NetNet* mux_selector_reduce_width(Design*des, NetScope*scope,\n\t\t\t\t\t const LineInfo&loc,\n\t\t\t\t\t NetNet*esig, unsigned sel_need)\n{\n      const unsigned sel_got = esig->vector_width();\n\n      ivl_assert(*esig, sel_got >= sel_need);\n\n\t// If the actual width matches the desired width (M==N) then\n\t// osig is esig itself. We're done.\n      if (sel_got == sel_need)\n\t    return esig;\n\n      if (debug_synth2) {\n\t    cerr << loc.get_fileline() << \": mux_selector_reduce_width: \"\n\t\t << \"Reduce selector width=\" << sel_got\n\t\t << \" to \" << sel_need << \" bits.\" << endl;\n      }\n\n      ivl_assert(*esig, sel_need >= 2);\n\n\t// This is the output signal, osig.\n      ivl_variable_type_t osig_data_type = IVL_VT_LOGIC;\n      netvector_t*osig_vec = new netvector_t(osig_data_type, sel_need-1, 0);\n      NetNet*osig = new NetNet(scope, scope->local_symbol(),\n\t\t\t       NetNet::TRI, osig_vec);\n      osig->local_flag(true);\n      osig->set_line(loc);\n\n\t// Create the concat: osig = {...,...}\n      NetConcat*osig_cat = new NetConcat(scope, scope->local_symbol(),\n\t\t\t\t\t sel_need, 2, !disable_concatz_generation);\n      osig_cat->set_line(loc);\n      des->add_node(osig_cat);\n      connect(osig_cat->pin(0), osig->pin(0));\n\n\t// Create the part select esig[N-2:0]...\n      NetPartSelect*ps0 = new NetPartSelect(esig, 0, sel_need-1,\n\t\t\t\t\t    NetPartSelect::VP);\n      ps0->set_line(loc);\n      des->add_node(ps0);\n      connect(ps0->pin(1), esig->pin(0));\n\n      netvector_t*ps0_vec = new netvector_t(osig_data_type, sel_need-2, 0);\n      NetNet*ps0_sig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t  NetNet::TRI, ps0_vec);\n      ps0_sig->local_flag(true);\n      ps0_sig->set_line(loc);\n      connect(ps0_sig->pin(0), ps0->pin(0));\n\n\t// osig = {..., esig[N-2:0]}\n      connect(osig_cat->pin(1), ps0_sig->pin(0));\n\n\t// Create the part select esig[M-1:N-1]\n      NetPartSelect*ps1 = new NetPartSelect(esig, sel_need-1,\n\t\t\t\t\t    sel_got-sel_need+1,\n\t\t\t\t\t    NetPartSelect::VP);\n      ps1->set_line(loc);\n      des->add_node(ps1);\n      connect(ps1->pin(1), esig->pin(0));\n\n      netvector_t*ps1_vec = new netvector_t(osig_data_type, sel_got-sel_need, 0);\n      NetNet*ps1_sig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t  NetNet::TRI, ps1_vec);\n      ps1_sig->local_flag(true);\n      ps1_sig->set_line(loc);\n      connect(ps1_sig->pin(0), ps1->pin(0));\n\n\t// Create the reduction OR: | esig[M-1:N-1]\n      NetUReduce*ered = new NetUReduce(scope, scope->local_symbol(),\n\t\t\t\t       NetUReduce::OR, sel_got-sel_need+1);\n      ered->set_line(loc);\n      des->add_node(ered);\n      connect(ered->pin(1), ps1_sig->pin(0));\n\n      NetNet*ered_sig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t   NetNet::TRI, &netvector_t::scalar_logic);\n      ered_sig->local_flag(true);\n      ered_sig->set_line(loc);\n      connect(ered->pin(0), ered_sig->pin(0));\n\n\t// osig = { |esig[M-1:N-1], esig[N-2:0] }\n      connect(osig_cat->pin(2), ered_sig->pin(0));\n\n      return osig;\n}\n\nbool NetCase::synth_async(Design*des, NetScope*scope,\n\t\t\t  NexusSet&nex_map, NetBus&nex_out,\n\t\t\t  NetBus&enables, vector<mask_t>&bitmasks)\n{\n      if (type()==NetCase::EQZ || type()==NetCase::EQX)\n\t    return synth_async_casez_(des, scope, nex_map, nex_out,\n\t\t\t\t      enables, bitmasks);\n\n\t// Special case: If the case expression is constant, then this\n\t// is a pattern where the guards are non-constant and tested\n\t// against a constant case. Handle this as chained conditions\n\t// instead.\n      if (dynamic_cast<NetEConst*> (expr_))\n\t    return synth_async_casez_(des, scope, nex_map, nex_out,\n\t\t\t\t      enables, bitmasks);\n\n      ivl_assert(*this, nex_map.size() == nex_out.pin_count());\n      ivl_assert(*this, nex_map.size() == enables.pin_count());\n      ivl_assert(*this, nex_map.size() == bitmasks.size());\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetCase::synth_async: \"\n\t\t << \"Selector expression: \" << *expr_ << endl;\n      }\n\n\t/* Synthesize the select expression. */\n      NetNet*esig = expr_->synthesize(des, scope, expr_);\n\n      unsigned sel_width = esig->vector_width();\n      ivl_assert(*this, sel_width > 0);\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetCase::synth_async: \"\n\t\t << \"selector width (sel_width) = \" << sel_width << endl;\n      }\n\n      vector<unsigned> mux_width (nex_out.pin_count());\n      for (unsigned idx = 0 ;  idx < nex_out.pin_count() ;  idx += 1) {\n\t    mux_width[idx] = nex_map[idx].wid;\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCase::synth_async: \"\n\t\t       << \"idx=\" << idx\n\t\t       << \", mux_width[idx]=\" << mux_width[idx] << endl;\n\t    }\n      }\n\n\t// The incoming nex_out is taken as the input for this\n\t// statement. Since there are collection of statements\n\t// that start at this same point, we save all these\n\t// inputs and reuse them for each statement. Unlink the\n\t// nex_out now, so we can hook up the mux outputs.\n      NetBus statement_input (scope, nex_out.pin_count());\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t    connect(statement_input.pin(idx), nex_out.pin(idx));\n\t    nex_out.pin(idx).unlink();\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCase::synth_async: \"\n\t\t       << \"statement_input.pin(\" << idx << \"):\" << endl;\n\t\t  statement_input.pin(idx).dump_link(cerr, 8);\n\t    }\n      }\n\n\t/* Collect all the statements into a map of index to statement.\n\t   The guard expression it evaluated to be the index of the mux\n\t   value, and the statement is bound to that index. */\n\n      unsigned long max_guard_value = 0;\n      map<unsigned long,NetProc*>statement_map;\n      NetProc*default_statement = 0;\n\n      for (size_t item = 0 ;  item < items_.size() ;  item += 1) {\n\t    if (items_[item].guard == 0) {\n\t\t  default_statement = items_[item].statement;\n\t\t  continue;\n\t    }\n\n\t    NetEConst*ge = dynamic_cast<NetEConst*>(items_[item].guard);\n\t    if (ge == 0) {\n\t\t  cerr << items_[item].guard->get_fileline() << \": sorry: \"\n\t\t       << \"variable case item expressions with a variable \"\n\t\t       << \"case select expression are not supported in \"\n\t\t       << \"synthesis. \" << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\t    ivl_assert(*this, ge);\n\t    verinum gval = ge->value();\n\n\t    unsigned long sel_idx = gval.as_ulong();\n\n\t    if (statement_map[sel_idx]) {\n\t\t  cerr << ge->get_fileline() << \": warning: duplicate case \"\n\t\t       << \"value '\" << sel_idx << \"' detected. This case is \"\n\t\t       << \"unreachable.\" << endl;\n\t\t  delete items_[item].statement;\n\t\t  items_[item].statement = 0;\n\t\t  continue;\n\t    }\n\n\t    if (sel_idx > max_guard_value)\n\t\t  max_guard_value = sel_idx;\n\n\t    if (items_[item].statement) {\n\t\t  statement_map[sel_idx] = items_[item].statement;\n\t\t  continue;\n\t    }\n\n\t      // Handle the special case of an empty statement.\n\t    statement_map[sel_idx] = this;\n      }\n\n\t// The minimum selector width is the number of inputs that\n\t// are selected, rounded up to the nearest power of 2.\n      unsigned sel_need = max(ceil(log2(max_guard_value + 1)), 1.0);\n\n\t// If the sel_width can select more than just the explicit\n\t// guard values, and there is a default statement, then adjust\n\t// the sel_need to allow for the implicit selections.\n      if (default_statement && (sel_width > sel_need))\n\t    sel_need += 1;\n\n\t// The mux size is always an exact power of 2.\n      if (sel_need >= 8*sizeof(unsigned)) {\n\t   cerr << get_fileline() << \": sorry: mux select width of \"\n\t\t<< sel_need << \" bits is too large for synthesis.\" << endl;\n\t   des->errors += 1;\n\t   return false;\n      }\n      unsigned mux_size = 1U << sel_need;\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetCase::synth_async: \"\n\t\t << \"Adjusted mux_size is \" << mux_size\n\t\t << \" (max_guard_value=\" << max_guard_value\n\t\t << \", sel_need=\" << sel_need\n\t\t << \", sel_width=\" << sel_width << \").\" << endl;\n      }\n\n      if (sel_width > sel_need) {\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCase::synth_async: \"\n\t\t       << \"Selector is \" << sel_width << \" bits, \"\n\t\t       << \"need only \" << sel_need << \" bits.\" << endl;\n\t    }\n\t    esig = mux_selector_reduce_width(des, scope, *this, esig, sel_need);\n      }\n\n\t/* If there is a default clause, synthesize it once and we'll\n\t   link it in wherever it is needed. If there isn't, create\n\t   a dummy default to pass on the accumulated nex_out from\n\t   preceding statements. */\n      NetBus default_out (scope, nex_out.pin_count());\n      NetBus default_ena (scope, nex_out.pin_count());\n      vector<mask_t> default_masks (nex_out.pin_count());\n\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t    connect(default_out.pin(idx), statement_input.pin(idx));\n\t    connect(default_ena.pin(idx), scope->tie_lo());\n      }\n\n      if (default_statement) {\n\n\t    bool flag = synth_async_block_substatement_(des, scope, nex_map, default_out,\n\t\t\t\t\t\t\tdefault_ena, default_masks,\n\t\t\t\t\t\t\tdefault_statement);\n\t    if (!flag) return false;\n\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCase::synth_async: \"\n\t\t       << \"synthesize default clause at \" << default_statement->get_fileline()\n\t\t       << \" is done.\" << endl;\n\t    }\n      }\n\n      vector<NetMux*> out_mux (nex_out.pin_count());\n      vector<NetMux*> ena_mux (nex_out.pin_count());\n      vector<bool>  full_case (nex_out.pin_count());\n      for (size_t mdx = 0 ; mdx < nex_out.pin_count() ; mdx += 1) {\n\t    out_mux[mdx] = new NetMux(scope, scope->local_symbol(),\n\t\t\t\t      mux_width[mdx], mux_size, sel_need);\n\t    des->add_node(out_mux[mdx]);\n\n\t      // The select signal is already synthesized, and is\n\t      // common for every mux of this case statement. Simply\n\t      // hook it up.\n\t    connect(out_mux[mdx]->pin_Sel(), esig->pin(0));\n\n\t      // The outputs are in the nex_out, and connected to the\n\t      // mux Result pins.\n\t    connect(out_mux[mdx]->pin_Result(), nex_out.pin(mdx));\n\n\t      // Make sure the output is now connected to a net. If\n\t      // not, then create a fake one to carry the net-ness of\n\t      // the pin.\n\t    if (out_mux[mdx]->pin_Result().nexus()->pick_any_net() == 0) {\n\t\t  ivl_variable_type_t mux_data_type = IVL_VT_LOGIC;\n\t\t  netvector_t*tmp_vec = new netvector_t(mux_data_type, mux_width[mdx]-1,0);\n\t\t  NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t\t  NetNet::WIRE, tmp_vec);\n\t\t  tmp->local_flag(true);\n\t\t  ivl_assert(*this, tmp->vector_width() != 0);\n\t\t  connect(out_mux[mdx]->pin_Result(), tmp->pin(0));\n\t    }\n\n\t      // Create a mux for the enables, but don't hook it up\n\t      // until we know we need it.\n\t    ena_mux[mdx] = new NetMux(scope, scope->local_symbol(),\n\t\t\t\t      1, mux_size, sel_need);\n\n\t      // Assume a full case to start with. We'll check this as\n\t      // we synthesise each clause.\n\t    full_case[mdx] = true;\n      }\n\n      for (unsigned idx = 0 ;  idx < mux_size ;  idx += 1) {\n\n\t    NetProc*stmt = statement_map[idx];\n\t    if (stmt==0) {\n\t\t  ivl_assert(*this, default_out.pin_count() == out_mux.size());\n\t\t  for (unsigned mdx = 0 ; mdx < nex_out.pin_count() ; mdx += 1) {\n\t\t\tconnect(out_mux[mdx]->pin_Data(idx), default_out.pin(mdx));\n\t\t\tconnect(ena_mux[mdx]->pin_Data(idx), default_ena.pin(mdx));\n\t\t\tmerge_parallel_masks(bitmasks[mdx], default_masks[mdx]);\n\t\t\tif (!default_ena.pin(mdx).is_linked(scope->tie_hi()))\n\t\t\t      full_case[mdx] = false;\n\t\t  }\n\t\t  continue;\n\t    }\n\t    ivl_assert(*this, stmt);\n\t    if (stmt == this) {\n\t\t    // Handle the special case of an empty statement.\n\t\t  ivl_assert(*this, statement_input.pin_count() == out_mux.size());\n\t\t  for (unsigned mdx = 0 ; mdx < nex_out.pin_count() ; mdx += 1) {\n\t\t\tconnect(out_mux[mdx]->pin_Data(idx), statement_input.pin(mdx));\n\t\t\tconnect(ena_mux[mdx]->pin_Data(idx), scope->tie_lo());\n\t\t\tbitmasks[mdx] = mask_t (mux_width[mdx], false);\n\t\t\tfull_case[mdx] = false;\n\t\t  }\n\t\t  continue;\n\t    }\n\n\t    NetBus tmp_out (scope, nex_out.pin_count());\n\t    NetBus tmp_ena (scope, nex_out.pin_count());\n\t    for (unsigned mdx = 0 ; mdx < nex_out.pin_count() ; mdx += 1) {\n\t\t  connect(tmp_out.pin(mdx), statement_input.pin(mdx));\n\t\t  connect(tmp_ena.pin(mdx), scope->tie_lo());\n\t    }\n\t    vector<mask_t> tmp_masks (nex_out.pin_count());\n\t    bool flag = synth_async_block_substatement_(des, scope, nex_map, tmp_out,\n\t\t\t\t\t\t\ttmp_ena, tmp_masks, stmt);\n\t    if (!flag) return false;\n\n\t    for (size_t mdx = 0 ; mdx < nex_out.pin_count() ; mdx += 1) {\n\t\t  connect(out_mux[mdx]->pin_Data(idx), tmp_out.pin(mdx));\n\t\t  connect(ena_mux[mdx]->pin_Data(idx), tmp_ena.pin(mdx));\n\t\t  merge_parallel_masks(bitmasks[mdx], tmp_masks[mdx]);\n\t\t  if (!tmp_ena.pin(mdx).is_linked(scope->tie_hi()))\n\t\t\tfull_case[mdx] = false;\n\t    }\n      }\n\n      for (unsigned mdx = 0 ; mdx < nex_out.pin_count() ; mdx += 1) {\n\t      // Optimize away the enable mux if we have a full case,\n\t      // otherwise hook it up.\n\t    if (full_case[mdx]) {\n\t\t  connect(enables.pin(mdx), scope->tie_hi());\n\t\t  delete ena_mux[mdx];\n\t\t  continue;\n\t    }\n\n\t    des->add_node(ena_mux[mdx]);\n\n\t    connect(ena_mux[mdx]->pin_Sel(), esig->pin(0));\n\n\t    connect(enables.pin(mdx), ena_mux[mdx]->pin_Result());\n\n\t    NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t    NetNet::WIRE, &netvector_t::scalar_logic);\n\t    tmp->local_flag(true);\n\t    connect(ena_mux[mdx]->pin_Result(), tmp->pin(0));\n      }\n      return true;\n}\n\n/*\n * casez statements are hard to implement as a single wide mux because\n * the test doesn't really map to a select input. Instead, implement\n * it as a chain of binary muxes. This gives the synthesizer more\n * flexibility, and is more typically what is desired from a casez anyhow.\n */\nbool NetCase::synth_async_casez_(Design*des, NetScope*scope,\n\t\t\t\t NexusSet&nex_map, NetBus&nex_out,\n\t\t\t\t NetBus&enables, vector<mask_t>&bitmasks)\n{\n      ivl_assert(*this, nex_map.size() == nex_out.pin_count());\n      ivl_assert(*this, nex_map.size() == enables.pin_count());\n      ivl_assert(*this, nex_map.size() == bitmasks.size());\n\n\t/* Synthesize the select expression. */\n      NetNet*esig = expr_->synthesize(des, scope, expr_);\n\n      unsigned sel_width = esig->vector_width();\n      ivl_assert(*this, sel_width > 0);\n\n      vector<unsigned>mux_width (nex_out.pin_count());\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t    mux_width[idx] = nex_map[idx].wid;\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCase::synth_async_casez_: \"\n\t\t       << \"idx=\" << idx\n\t\t       << \", mux_width[idx]=\" << mux_width[idx] << endl;\n\t    }\n      }\n\n\t// The incoming nex_out is taken as the input for this\n\t// statement. Since there are collection of statements\n\t// that start at this same point, we save all these\n\t// inputs and reuse them for each statement. Unlink the\n\t// nex_out now, so we can hook up the mux outputs.\n      NetBus statement_input (scope, nex_out.pin_count());\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t    connect(statement_input.pin(idx), nex_out.pin(idx));\n\t    nex_out.pin(idx).unlink();\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCase::synth_async_casez_: \"\n\t\t       << \"statement_input.pin(\" << idx << \"):\" << endl;\n\t\t  statement_input.pin(idx).dump_link(cerr, 8);\n\t    }\n\n      }\n\n\t// Look for a default statement.\n      NetProc*default_statement = 0;\n      for (size_t item = 0 ; item < items_.size() ; item += 1) {\n\t    if (items_[item].guard != 0)\n\t\t  continue;\n\n\t    ivl_assert(*this, default_statement==0);\n\t    default_statement = items_[item].statement;\n      }\n\n\t/* If there is a default clause, synthesize it once and we'll\n\t   link it in wherever it is needed. If there isn't, create\n\t   a dummy default to pass on the accumulated nex_out from\n\t   preceding statements. */\n      NetBus default_out (scope, nex_out.pin_count());\n\n      for (unsigned idx = 0 ; idx < default_out.pin_count() ; idx += 1)\n\t    connect(default_out.pin(idx), statement_input.pin(idx));\n\n      if (default_statement) {\n\t    bool flag = synth_async_block_substatement_(des, scope, nex_map, default_out,\n\t\t\t\t\t\t\tenables, bitmasks, default_statement);\n\t    if (!flag) return false;\n\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCase::synth_async_casez_: \"\n\t\t       << \"synthesize default clause at \" << default_statement->get_fileline()\n\t\t       << \" is done.\" << endl;\n\t    }\n      }\n\n      netvector_t*condit_type = new netvector_t(IVL_VT_LOGIC, 0, 0);\n\n      NetCaseCmp::kind_t case_kind = NetCaseCmp::EEQ;\n      switch (type()) {\n\t  case NetCase::EQ:\n\t    case_kind = NetCaseCmp::EEQ;\n\t    break;\n\t  case NetCase::EQX:\n\t    case_kind = NetCaseCmp::XEQ;\n\t    break;\n\t  case NetCase::EQZ:\n\t    case_kind = NetCaseCmp::ZEQ;\n\t    break;\n\t  default:\n\t    assert(0);\n      }\n\n\t// Process the items from last to first. We generate a\n\t// true/false mux, with the select being the comparison of\n\t// the case select with the guard expression. The true input\n\t// (data1) is the current statement, and the false input is\n\t// the result of a later statement.\n      vector<NetMux*>prev_mux (nex_out.pin_count());\n      for (size_t idx = 0 ; idx < items_.size() ; idx += 1) {\n\t    size_t item = items_.size()-idx-1;\n\t    if (items_[item].guard == 0)\n\t\t  continue;\n\n\t    NetProc*stmt = items_[item].statement;\n\t    ivl_assert(*this, stmt);\n\n\t    NetExpr*guard_expr = items_[item].guard;\n\t    NetNet*guard = guard_expr->synthesize(des, scope, guard_expr);\n\n\t    NetCaseCmp*condit_dev = new NetCaseCmp(scope, scope->local_symbol(),\n\t\t\t\t\t\t   sel_width, case_kind);\n\t    des->add_node(condit_dev);\n\t    condit_dev->set_line(*this);\n\t      // Note that the expression that may have wildcards must\n\t      // go in the pin(2) input. This is the definition of the\n\t      // NetCaseCmp statement.\n\t    connect(condit_dev->pin(1), esig->pin(0));\n\t    connect(condit_dev->pin(2), guard->pin(0));\n\n\t    NetNet*condit = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t       NetNet::TRI, condit_type);\n\t    condit->set_line(*this);\n\t    condit->local_flag(true);\n\t    connect(condit_dev->pin(0), condit->pin(0));\n\n\t      // Synthesize the guarded statement.\n\t    NetBus tmp_out (scope, nex_out.pin_count());\n\t    NetBus tmp_ena (scope, nex_out.pin_count());\n\t    vector<mask_t> tmp_masks (nex_out.pin_count());\n\n\t    for (unsigned pdx = 0 ; pdx < nex_out.pin_count() ; pdx += 1)\n\t\t  connect(tmp_out.pin(pdx), statement_input.pin(pdx));\n\n\t    synth_async_block_substatement_(des, scope, nex_map, tmp_out,\n\t\t\t\t\t    tmp_ena, tmp_masks, stmt);\n\n\t    NetBus prev_ena (scope, nex_out.pin_count());\n\t    for (unsigned mdx = 0 ; mdx < nex_out.pin_count() ; mdx += 1) {\n\t\t  NetMux*mux = new NetMux(scope, scope->local_symbol(),\n\t\t\t\t\t  mux_width[mdx], 2, 1);\n\t\t  des->add_node(mux);\n\t\t  mux->set_line(*this);\n\t\t  connect(mux->pin_Sel(), condit->pin(0));\n\n\t\t  connect(mux->pin_Data(1), tmp_out.pin(mdx));\n\n\t\t    // If there is a previous mux, then use that as the\n\t\t    // false clause input. Otherwise, use the default.\n\t\t  if (prev_mux[mdx])\n\t\t\tconnect(mux->pin_Data(0), prev_mux[mdx]->pin_Result());\n\t\t  else\n\t\t\tconnect(mux->pin_Data(0), default_out.pin(mdx));\n\n\t\t    // Make a NetNet for the result.\n\t\t  ivl_variable_type_t mux_data_type = IVL_VT_LOGIC;\n\t\t  netvector_t*tmp_vec = new netvector_t(mux_data_type, mux_width[mdx]-1,0);\n\t\t  NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t\t  NetNet::WIRE, tmp_vec);\n\t\t  tmp->local_flag(true);\n\t\t  tmp->set_line(*this);\n\t\t  ivl_assert(*this, tmp->vector_width() != 0);\n\t\t  connect(mux->pin_Result(), tmp->pin(0));\n\n\t\t    // This mux becomes the \"false\" input to the next mux.\n\t\t  prev_mux[mdx] = mux;\n\n\t\t  connect(prev_ena.pin(mdx), enables.pin(mdx));\n\t\t  enables.pin(mdx).unlink();\n\n\t\t  multiplex_enables(des, scope, condit, tmp_ena.pin(mdx),\n\t\t\t\t    prev_ena.pin(mdx), enables.pin(mdx));\n\n\t\t  merge_parallel_masks(bitmasks[mdx], tmp_masks[mdx]);\n\t    }\n      }\n\n\t// Connect the last mux to the output.\n      for (size_t mdx = 0 ; mdx < prev_mux.size() ; mdx += 1)\n\t    connect(prev_mux[mdx]->pin_Result(), nex_out.pin(mdx));\n\n      return true;\n}\n\n/*\n * A condit statement (if (cond) ... else ... ;) infers an A-B mux,\n * with the cond expression acting as a select input. If the cond\n * expression is true, the if_ clause is selected, and if false, the\n * else_ clause is selected.\n */\nbool NetCondit::synth_async(Design*des, NetScope*scope,\n\t\t\t    NexusSet&nex_map, NetBus&nex_out,\n\t\t\t    NetBus&enables, vector<mask_t>&bitmasks)\n{\n\t// Handle the unlikely case that both clauses are empty.\n      if ((if_ == 0) && (else_ == 0))\n\t    return true;\n\n      ivl_assert(*this, nex_map.size() == nex_out.pin_count());\n      ivl_assert(*this, nex_map.size() == enables.pin_count());\n      ivl_assert(*this, nex_map.size() == bitmasks.size());\n\n\t// Synthesize the condition. This will act as a select signal\n\t// for a binary mux.\n      NetNet*ssig = expr_->synthesize(des, scope, expr_);\n      ivl_assert(*this, ssig);\n\n\t// The incoming nex_out is taken as the input for this\n\t// statement. Since there are two statements that start\n\t// at this same point, we save all these inputs and reuse\n\t// them for both statements. Unlink the nex_out now, so\n\t// we can hook up the mux outputs.\n      NetBus statement_input (scope, nex_out.pin_count());\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t    connect(statement_input.pin(idx), nex_out.pin(idx));\n\t    nex_out.pin(idx).unlink();\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCondit::synth_async: \"\n\t\t       << \"statement_input.pin(\" << idx << \"):\" << endl;\n\t\t  statement_input.pin(idx).dump_link(cerr, 8);\n\t    }\n      }\n\n      NetBus a_out (scope, nex_out.pin_count());\n      NetBus a_ena (scope, nex_out.pin_count());\n      vector<mask_t> a_masks (nex_out.pin_count());\n      if (if_) {\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCondit::synth_async: \"\n\t\t       << \"Synthesize if clause at \" << if_->get_fileline()\n\t\t       << endl;\n\t    }\n\n\t    for (unsigned idx = 0 ; idx < a_out.pin_count() ; idx += 1) {\n\t\t  connect(a_out.pin(idx), statement_input.pin(idx));\n\t    }\n\n\t    bool flag = synth_async_block_substatement_(des, scope, nex_map, a_out,\n\t\t\t\t\t\t\ta_ena, a_masks, if_);\n\t    if (!flag) return false;\n\n      } else {\n\t    for (unsigned idx = 0 ; idx < a_out.pin_count() ; idx += 1) {\n\t\t  connect(a_out.pin(idx), statement_input.pin(idx));\n\t\t  connect(a_ena.pin(idx), scope->tie_lo());\n\t    }\n      }\n\n      NetBus b_out(scope, nex_out.pin_count());\n      NetBus b_ena(scope, nex_out.pin_count());\n      vector<mask_t> b_masks (nex_out.pin_count());\n      if (else_) {\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCondit::synth_async: \"\n\t\t       << \"Synthesize else clause at \" << else_->get_fileline()\n\t\t       << endl;\n\t    }\n\n\t    for (unsigned idx = 0 ; idx < b_out.pin_count() ; idx += 1) {\n\t\t  connect(b_out.pin(idx), statement_input.pin(idx));\n\t    }\n\n\t    bool flag = synth_async_block_substatement_(des, scope, nex_map, b_out,\n\t\t\t\t\t\t\tb_ena, b_masks, else_);\n\t    if (!flag) return false;\n\n      } else {\n\t    for (unsigned idx = 0 ; idx < b_out.pin_count() ; idx += 1) {\n\t\t  connect(b_out.pin(idx), statement_input.pin(idx));\n\t\t  connect(b_ena.pin(idx), scope->tie_lo());\n\t    }\n      }\n\n\t/* The nex_out output, a_out input, and b_out input all have the\n\t   same pin count (usually, but not always 1) because they are\n\t   net arrays of the same dimension. The for loop below creates\n\t   a NetMux for each pin of the output. (Note that pins may\n\t   be, in fact usually are, vectors.) */\n\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\n\t    bool a_driven = a_out.pin(idx).nexus()->pick_any_net();\n\t    bool b_driven = b_out.pin(idx).nexus()->pick_any_net();\n\t    if (!a_driven && !b_driven) {\n\t\t  connect(nex_out.pin(idx), statement_input.pin(idx));\n\t\t  continue;\n\t    }\n\n\t    merge_parallel_masks(bitmasks[idx], a_masks[idx]);\n\t    merge_parallel_masks(bitmasks[idx], b_masks[idx]);\n\n\t      // If one clause is empty and the other clause unconditionally\n\t      // drives all bits of the vector, we can rely on the enable\n\t      // to prevent the flip-flop or latch updating when the empty\n\t      // clause is selected, and hence don't need a mux.\n\t    if (!a_driven && all_bits_driven(b_masks[idx])) {\n\t\t  connect(nex_out.pin(idx), b_out.pin(idx));\n\t\t  continue;\n\t    }\n\t    if (!b_driven && all_bits_driven(a_masks[idx])) {\n\t\t  connect(nex_out.pin(idx), a_out.pin(idx));\n\t\t  continue;\n\t    }\n\n\t      // Guess the mux type from the type of the output.\n\t    ivl_variable_type_t mux_data_type = IVL_VT_LOGIC;\n\t    if (NetNet*tmp = nex_out.pin(idx).nexus()->pick_any_net()) {\n\t\t  mux_data_type = tmp->data_type();\n\t    }\n\n\t    unsigned mux_off = 0;\n\t    unsigned mux_width = nex_map[idx].wid;\n\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetCondit::synth_async: \"\n\t\t       << \"Calculated mux_width=\" << mux_width\n\t\t       << endl;\n\t    }\n\n\t    NetPartSelect*apv = detect_partselect_lval(a_out.pin(idx));\n\t    if (debug_synth2 && apv) {\n\t\t  cerr << get_fileline() << \": NetCondit::synth_async: \"\n\t\t       << \"Assign-to-part apv base=\" << apv->base()\n\t\t       << \", width=\" << apv->width() << endl;\n\t    }\n\n\t    NetPartSelect*bpv = detect_partselect_lval(b_out.pin(idx));\n\t    if (debug_synth2 && bpv) {\n\t\t  cerr << get_fileline() << \": NetCondit::synth_async: \"\n\t\t       << \"Assign-to-part bpv base=\" << bpv->base()\n\t\t       << \", width=\" << bpv->width() << endl;\n\t    }\n\n\t    unsigned mux_lwidth = mux_width;\n\t    ivl_assert(*this, mux_width != 0);\n\n\t    if (apv && bpv && apv->width()==bpv->width() && apv->base()==bpv->base()) {\n\t\t    // The a and b sides are both assigning to the\n\t\t    // same bits of the output, so we can use that to\n\t\t    // create a much narrower mux that only\n\t\t    // manipulates the width of the part.\n\t\t  mux_width = apv->width();\n\t\t  mux_off = apv->base();\n\t\t  a_out.pin(idx).unlink();\n\t\t  b_out.pin(idx).unlink();\n\t\t  connect(a_out.pin(idx), apv->pin(0));\n\t\t  connect(b_out.pin(idx), bpv->pin(0));\n\t\t  delete apv;\n\t\t  delete bpv;\n\t    } else {\n\t\t    // The part selects are of no use. Forget them.\n\t\t  if (apv) delete apv;\n\t\t  if (bpv) delete bpv;\n\t    }\n\n\t    NetMux*mux = new NetMux(scope, scope->local_symbol(),\n\t\t\t\t    mux_width, 2, 1);\n\t    mux->set_line(*this);\n\t    des->add_node(mux);\n\n\t    netvector_t*tmp_type = 0;\n\t    if (mux_width==1)\n\t\t  tmp_type = new netvector_t(mux_data_type);\n\t    else\n\t\t  tmp_type = new netvector_t(mux_data_type, mux_width-1,0);\n\n\t      // Bind some temporary signals to carry pin type.\n\t    NetNet*otmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t     NetNet::WIRE, tmp_type);\n\t    otmp->local_flag(true);\n\t    otmp->set_line(*this);\n\t    connect(mux->pin_Result(),otmp->pin(0));\n\n\t    connect(mux->pin_Sel(),   ssig->pin(0));\n\t    connect(mux->pin_Data(1), a_out.pin(idx));\n\t    connect(mux->pin_Data(0), b_out.pin(idx));\n\n\t      // If we are only muxing a part of the output vector, make a\n\t      // NetSubstitute to blend the mux output with the accumulated\n\t      // output from previous statements.\n\t    if (mux_width < mux_lwidth) {\n\t\t  tmp_type = new netvector_t(mux_data_type, mux_lwidth-1,0);\n\n\t\t  NetNet*itmp = statement_input.pin(idx).nexus()->pick_any_net();\n\t\t  if (itmp == 0) {\n\t\t\titmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t\t  NetNet::WIRE, tmp_type);\n\t\t\titmp->local_flag(true);\n\t\t\titmp->set_line(*this);\n\t\t\tconnect(itmp->pin(0), statement_input.pin(idx));\n\t\t  }\n\n\t\t  NetNet*tmp = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t\t  NetNet::WIRE, tmp_type);\n\t\t  tmp->local_flag(true);\n\t\t  tmp->set_line(*this);\n\t\t  NetSubstitute*ps = new NetSubstitute(itmp, otmp, mux_lwidth, mux_off);\n\t\t  des->add_node(ps);\n\t\t  connect(ps->pin(0), tmp->pin(0));\n\t\t  otmp = tmp;\n\t    }\n\n\t    connect(nex_out.pin(idx), otmp->pin(0));\n      }\n\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t    multiplex_enables(des, scope, ssig, a_ena.pin(idx), b_ena.pin(idx), enables.pin(idx));\n      }\n\n      return true;\n}\n\nbool NetEvWait::synth_async(Design*des, NetScope*scope,\n\t\t\t    NexusSet&nex_map, NetBus&nex_out,\n\t\t\t    NetBus&enables, vector<mask_t>&bitmasks)\n{\n      bool flag = statement_->synth_async(des, scope, nex_map, nex_out, enables, bitmasks);\n      return flag;\n}\n\nbool NetForLoop::synth_async(Design*des, NetScope*scope,\n\t\t\t     NexusSet&nex_map, NetBus&nex_out,\n\t\t\t     NetBus&enables, vector<mask_t>&bitmasks)\n{\n      if (!index_) {\n\t    cerr << get_fileline() << \": sorry: Unable to synthesize for-loop without explicit index variable.\" << endl;\n\t    return false;\n      }\n\n      if (!step_statement_) {\n\t    cerr << get_fileline() << \": sorry: Unable to synthesize for-loop without for_step statement.\" << endl;\n\t    return false;\n      }\n\n      ivl_assert(*this, index_ && init_expr_);\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetForLoop::synth_async: \"\n\t\t << \"Index variable is \" << index_->name() << endl;\n\t    cerr << get_fileline() << \": NetForLoop::synth_async: \"\n\t\t << \"Initialization expression: \" << *init_expr_ << endl;\n      }\n\n\t// Get the step assignment statement and break it into the\n\t// l-value (should be the index) and the r-value, which is the\n\t// step expressions.\n      NetAssign*step_assign = dynamic_cast<NetAssign*> (step_statement_);\n      char assign_operator = step_assign->assign_operator();\n      ivl_assert(*this, step_assign);\n      NetExpr*step_expr = step_assign->rval();\n\n\t// Tell the scope that this index value is like a genvar.\n      LocalVar index_var;\n      index_var.nwords = 0;\n\n      map<perm_string,LocalVar> index_args;\n\n\t// Calculate the initial value for the index.\n      index_var.value = init_expr_->evaluate_function(*this, index_args);\n      ivl_assert(*this, index_var.value);\n      index_args[index_->name()] = index_var;\n\n      for (;;) {\n\t      // Evaluate the condition expression. If it is false,\n\t      // then we are going to break out of this synthesis loop.\n\t    NetExpr*tmp = condition_->evaluate_function(*this, index_args);\n\t    ivl_assert(*this, tmp);\n\n\t    long cond_value;\n\t    bool rc = eval_as_long(cond_value, tmp);\n\t    ivl_assert(*this, rc);\n\t    delete tmp;\n\t    if (!cond_value) break;\n\n\t    scope->genvar_tmp = index_->name();\n\t    rc = eval_as_long(scope->genvar_tmp_val, index_var.value);\n\t    ivl_assert(*this, rc);\n\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": NetForLoop::synth_async: \"\n\t\t       << \"Synthesis iteration with \" << index_->name()\n\t\t       << \"=\" << *index_var.value << endl;\n\t    }\n\n\t      // Synthesize the iterated expression. Stash the loop\n\t      // index value so that the substatements can see this\n\t      // value and use it during its own synthesis.\n\t    ivl_assert(*this, scope->loop_index_tmp.empty());\n\t    scope->loop_index_tmp = index_args;\n\n\t    NetBus tmp_ena (scope, nex_out.pin_count());\n\t    vector<mask_t> tmp_masks (nex_out.pin_count());\n\n\t    rc = synth_async_block_substatement_(des, scope, nex_map, nex_out,\n\t\t\t\t\t\t tmp_ena, tmp_masks, statement_);\n\n\t    for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1) {\n\t\t  merge_sequential_enables(des, scope, enables.pin(idx), tmp_ena.pin(idx));\n\t\t  merge_sequential_masks(bitmasks[idx], tmp_masks[idx]);\n\t    }\n\n\t    scope->loop_index_tmp.clear();\n\n\t      // Evaluate the step_expr to generate the next index value.\n\t    tmp = step_expr->evaluate_function(*this, index_args);\n\t    ivl_assert(*this, tmp);\n\n\t      // If there is an assign_operator, then replace the\n\t      // index_var.value with (value <op> tmp) and evaluate\n\t      // that to get the next value. \"value\" is the existing\n\t      // value, and \"tmp\" is the step value. We are replacing\n\t      // (value += tmp) with (value = value + tmp) and\n\t      // evaluating it.\n\t    switch (assign_operator) {\n\t\tcase 0:\n\t\t  break;\n\t\tcase '+':\n\t\tcase '-':\n\t\t  index_var.value = new NetEBAdd(assign_operator, tmp, index_var.value, 32, true);\n\t\t  tmp = index_var.value->evaluate_function(*this, index_args);\n\t\t  break;\n\n\t\tdefault:\n\t\t  cerr << get_fileline() << \": internal error: \"\n\t\t       << \"NetForLoop::synth_async: What to do with assign_operator=\" << assign_operator << endl;\n\t\t  ivl_assert(*this, 0);\n\t    }\n\t    delete index_var.value;\n\t    index_var.value = tmp;\n\t    index_args[index_->name()] = index_var;\n      }\n\n      delete index_var.value;\n\n      return true;\n}\n\n/*\n * This method is called when the process is shown to be\n * asynchronous. Figure out the nexus set of outputs from this\n * process, and pass that to the synth_async method for the statement\n * of the process. The statement will connect its output to the\n * nex_out set, using the nex_map as a guide. Starting from the top,\n * the nex_map is the same as the nex_map.\n */\nbool NetProcTop::synth_async(Design*des)\n{\n      NexusSet nex_set;\n      statement_->nex_output(nex_set);\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetProcTop::synth_async: \"\n\t\t << \"Process has \" << nex_set.size() << \" outputs.\" << endl;\n      }\n\n      NetBus nex_out (scope(), nex_set.size());\n      NetBus enables (scope(), nex_set.size());\n      vector<NetProc::mask_t> bitmasks (nex_set.size());\n\n\t// Save links to the initial nex_out. These will be used later\n\t// to detect floating part-substitute and mux inputs that need\n\t// to be tied off.\n      NetBus nex_in (scope(), nex_out.pin_count());\n      for (unsigned idx = 0 ; idx < nex_out.pin_count() ; idx += 1)\n\t    connect(nex_in.pin(idx), nex_out.pin(idx));\n\n      bool flag = statement_->synth_async(des, scope(), nex_set, nex_out, enables, bitmasks);\n      if (!flag) return false;\n\n      flag = tie_off_floating_inputs_(des, nex_set, nex_in, bitmasks, false);\n      if (!flag) return false;\n\n      for (unsigned idx = 0 ;  idx < nex_set.size() ;  idx += 1) {\n\n\t    if (enables.pin(idx).is_linked(scope()->tie_hi())) {\n\t\t  connect(nex_set[idx].lnk, nex_out.pin(idx));\n\t    } else {\n\t\t  cerr << get_fileline() << \": warning: \"\n\t\t       << \"A latch has been inferred for '\"\n\t\t       << nex_set[idx].lnk.nexus()->pick_any_net()->name()\n\t\t       << \"'.\" << endl;\n\n\t\t  if (enables.pin(idx).nexus()->pick_any_net()->local_flag()) {\n\t\t\tcerr << get_fileline() << \": warning: The latch \"\n\t\t\t        \"enable is connected to a synthesized \"\n\t\t\t        \"expression. The latch may be sensitive \"\n\t\t\t        \"to glitches.\" << endl;\n\t\t  }\n\n\t\t  if (debug_synth2) {\n\t\t\tcerr << get_fileline() << \": debug: \"\n\t\t\t     << \"Top level making a \"\n\t\t\t     << nex_set[idx].wid << \"-wide \"\n\t\t\t     << \"NetLatch device.\" << endl;\n\t\t  }\n\n\t\t  NetLatch*latch = new NetLatch(scope(), scope()->local_symbol(),\n\t\t\t\t\t\tnex_set[idx].wid);\n\t\t  des->add_node(latch);\n\t\t  latch->set_line(*this);\n\n\t\t  NetNet*tmp = nex_out.pin(idx).nexus()->pick_any_net();\n\t\t  tmp->set_line(*this);\n\t\t  assert(tmp);\n\n\t\t  tmp = crop_to_width(des, tmp, latch->width());\n\n\t\t  connect(nex_set[idx].lnk, latch->pin_Q());\n\t\t  connect(tmp->pin(0), latch->pin_Data());\n\n\t\t  assert (enables.pin(idx).is_linked());\n\t\t  connect(enables.pin(idx), latch->pin_Enable());\n\t    }\n      }\n\n      synthesized_design_ = des;\n      return true;\n}\n\n\nbool NetProc::synth_sync(Design*des, NetScope*scope,\n\t\t\t bool& /* ff_negedge */,\n\t\t\t NetNet* /* ff_clk */, NetBus&ff_ce,\n\t\t\t NetBus& /* ff_aclr*/, NetBus& /* ff_aset*/,\n\t\t\t vector<verinum>& /*ff_aset_value*/,\n\t\t\t NexusSet&nex_map, NetBus&nex_out,\n\t\t\t vector<mask_t>&bitmasks,\n\t\t\t const vector<NetEvProbe*>&events)\n{\n      if (events.size() > 0) {\n\t    cerr << get_fileline() << \": error: Events are unaccounted\"\n\t\t << \" for in process synthesis.\" << endl;\n\t    des->errors += 1;\n      }\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetProc::synth_sync: \"\n\t\t << \"This statement is an async input to a sync process.\" << endl;\n      }\n\n\t/* Synthesize the input to the DFF. */\n      return synth_async(des, scope, nex_map, nex_out, ff_ce, bitmasks);\n}\n\n/*\n * This method is called when a block is encountered near the surface\n * of a synchronous always statement. For example, this code will be\n * invoked for input like this:\n *\n *     always @(posedge clk...) begin\n *\t     <statement1>\n *\t     <statement2>\n *\t     ...\n *     end\n *\n * This needs to be split into a DFF bank for each statement, because\n * the statements may each infer different reset and enables signals.\n */\nbool NetBlock::synth_sync(Design*des, NetScope*scope,\n\t\t\t  bool&ff_negedge,\n\t\t\t  NetNet*ff_clk, NetBus&ff_ce,\n\t\t\t  NetBus&ff_aclr,NetBus&ff_aset,\n\t\t\t  vector<verinum>&ff_aset_value,\n\t\t\t  NexusSet&nex_map, NetBus&nex_out,\n\t\t\t  vector<mask_t>&bitmasks,\n\t\t\t  const vector<NetEvProbe*>&events_in)\n{\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetBlock::synth_sync: \"\n\t\t << \"Examine this block for synchronous logic.\" << endl;\n      }\n\n      if (last_ == 0) {\n\t    return true;\n      }\n\n      bool flag = true;\n\n      NetProc*cur = last_;\n      do {\n\t    cur = cur->next_;\n\n\t      // Create a temporary nex_map for the substatement.\n\t    NexusSet tmp_map;\n\t    cur->nex_output(tmp_map);\n\n\t      // Create temporary variables to collect the output from the synthesis.\n\t    NetBus tmp_out (scope, tmp_map.size());\n\t    NetBus tmp_ce  (scope, tmp_map.size());\n\t    vector<mask_t> tmp_masks (tmp_map.size());\n\n\t      // Map (and move) the accumulated nex_out for this block\n\t      // to the version that we can pass to the next statement.\n\t      // We will move the result back later.\n\t    for (unsigned idx = 0 ; idx < tmp_out.pin_count() ; idx += 1) {\n\t\t  unsigned ptr = nex_map.find_nexus(tmp_map[idx]);\n\t\t  ivl_assert(*this, ptr < nex_out.pin_count());\n\t\t  connect(tmp_out.pin(idx), nex_out.pin(ptr));\n\t\t  nex_out.pin(ptr).unlink();\n\t    }\n\n\t      /* Now go on with the synchronous synthesis for this\n\t\t subset of the statement. The tmp_map is the output\n\t\t nexa that we expect, and the tmp_out is where we want\n\t\t those outputs connected. */\n\t    bool ok_flag = cur->synth_sync(des, scope,\n\t\t\t\t\t   ff_negedge, ff_clk, tmp_ce,\n\t\t\t\t\t   ff_aclr, ff_aset, ff_aset_value,\n\t\t\t\t\t   tmp_map, tmp_out, tmp_masks,\n\t\t\t\t\t   events_in);\n\t    flag = flag && ok_flag;\n\n\t    if (ok_flag == false)\n\t\t  continue;\n\n\t      // Now map the output from the substatement back to the\n\t      // outputs for this block.\n\t    for (unsigned idx = 0 ;  idx < tmp_out.pin_count() ; idx += 1) {\n\t\t  unsigned ptr = nex_map.find_nexus(tmp_map[idx]);\n\t\t  ivl_assert(*this, ptr < nex_out.pin_count());\n\t\t  connect(nex_out.pin(ptr), tmp_out.pin(idx));\n\n\t\t  merge_sequential_enables(des, scope, ff_ce.pin(ptr), tmp_ce.pin(idx));\n\n\t\t  merge_sequential_masks(bitmasks[ptr], tmp_masks[idx]);\n\t    }\n\n      } while (cur != last_);\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetBlock::synth_sync: \"\n\t\t << \"Done Examining this block for synchronous logic.\" << endl;\n      }\n\n      return flag;\n}\n\n/*\n * This method handles the case where I find a conditional near the\n * surface of a synchronous thread. This conditional can be a CE or an\n * asynchronous set/reset, depending on whether the pin of the\n * expression is connected to an event, or not.\n */\nbool NetCondit::synth_sync(Design*des, NetScope*scope,\n\t\t\t   bool&ff_negedge,\n\t\t\t   NetNet*ff_clk, NetBus&ff_ce,\n\t\t\t   NetBus&ff_aclr,NetBus&ff_aset,\n\t\t\t   vector<verinum>&ff_aset_value,\n\t\t\t   NexusSet&nex_map, NetBus&nex_out,\n\t\t\t   vector<mask_t>&bitmasks,\n\t\t\t   const vector<NetEvProbe*>&events_in)\n{\n\t/* First try to turn the condition expression into an\n\t   asynchronous set/reset. If the condition expression has\n\t   inputs that are included in the sensitivity list, then it\n\t   is likely intended as an asynchronous input. */\n\n      NexusSet*expr_input = expr_->nex_input();\n      assert(expr_input);\n      for (unsigned idx = 0 ;  idx < events_in.size() ;  idx += 1) {\n\n\t    NetEvProbe*ev = events_in[idx];\n\t    NexusSet pin_set;\n\t    pin_set.add(ev->pin(0).nexus(), 0, 0);\n\n\t    if (! expr_input->contains(pin_set))\n\t\t  continue;\n\n\t      // Synthesize the set/reset input expression.\n\t    NetNet*rst = expr_->synthesize(des, scope, expr_);\n\t    ivl_assert(*this, rst->pin_count() == 1);\n\n\t      // Check that the edge used on the set/reset input is correct.\n\t    switch (ev->edge()) {\n\t      case NetEvProbe::POSEDGE:\n\t\t  if (ev->pin(0).nexus() != rst->pin(0).nexus()) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Condition for posedge asynchronous set/reset \"\n\t\t\t     << \"must exactly match the event expression.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\t\t  break;\n\t      case NetEvProbe::NEGEDGE: {\n\t\t  bool is_inverter = false;\n\t\t  NetNode*node = rst->pin(0).nexus()->pick_any_node();\n\t\t  if (NetLogic*gate = dynamic_cast<NetLogic*>(node)) {\n\t\t\tif (gate->type() == NetLogic::NOT)\n\t\t\t\tis_inverter = true;\n\t\t  }\n\t\t  if (NetUReduce*gate = dynamic_cast<NetUReduce*>(node)) {\n\t\t\tif (gate->type() == NetUReduce::NOR)\n\t\t\t\tis_inverter = true;\n\t\t  }\n\t\t  if (!is_inverter || ev->pin(0).nexus() != node->pin(1).nexus()) {\n\t\t\tcerr << get_fileline() << \": error: \"\n\t\t\t     << \"Condition for negedge asynchronous set/reset must be \"\n\t\t\t     << \"a simple inversion of the event expression.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\t\t  break;\n\t      }\n\t      default:\n\t\t  cerr << get_fileline() << \": error: \"\n\t\t       << \"Asynchronous set/reset event must be \"\n\t\t       << \"edge triggered.\" << endl;\n\t\t  des->errors += 1;\n\t\t  return false;\n\t    }\n\n\t      // Synthesize the true clause to figure out what kind of\n\t      // set/reset we have. This should synthesize down to a\n\t      // constant. If not, we have an asynchronous LOAD, a\n\t      // very different beast.\n\t    ivl_assert(*this, if_);\n\t    NetBus tmp_out(scope, nex_out.pin_count());\n\t    NetBus tmp_ena(scope, nex_out.pin_count());\n\t    vector<mask_t> tmp_masks (nex_out.pin_count());\n\t    bool flag = if_->synth_async(des, scope, nex_map, tmp_out, tmp_ena, tmp_masks);\n\t    if (!flag) return false;\n\n\t    ivl_assert(*this, tmp_out.pin_count() == ff_aclr.pin_count());\n\t    ivl_assert(*this, tmp_out.pin_count() == ff_aset.pin_count());\n\n\t    for (unsigned pin = 0 ; pin < tmp_out.pin_count() ; pin += 1) {\n\t\t  Nexus*rst_nex = tmp_out.pin(pin).nexus();\n\n\t\t  if (!all_bits_driven(tmp_masks[pin])) {\n\t\t\tcerr << get_fileline() << \": sorry: Not all bits of '\"\n\t\t\t     << nex_map[pin].lnk.nexus()->pick_any_net()->name()\n\t\t\t     << \"' are asynchronously set or reset. This is \"\n\t\t\t     << \"not currently supported in synthesis.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\n\t\t  if (! rst_nex->drivers_constant() ||\n\t\t      ! tmp_ena.pin(pin).is_linked(scope->tie_hi()) ) {\n\t\t\tcerr << get_fileline() << \": sorry: Asynchronous load \"\n\t\t\t     << \"is not currently supported in synthesis.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\n\t\t  if (ff_aclr.pin(pin).is_linked() ||\n\t\t      ff_aset.pin(pin).is_linked()) {\n\t\t\tcerr << get_fileline() << \": sorry: More than \"\n\t\t\t\t\"one asynchronous set/reset clause is \"\n\t\t\t\t\"not currently supported in synthesis.\" << endl;\n\t\t\tdes->errors += 1;\n\t\t\treturn false;\n\t\t  }\n\n\t\t  verinum rst_drv = rst_nex->driven_vector();\n\n\t\t  verinum zero (verinum::V0, rst_drv.len());\n\t\t  verinum ones (verinum::V1, rst_drv.len());\n\n\t\t  if (rst_drv==zero) {\n\t\t\t  // Don't yet support multiple asynchronous reset inputs.\n\t\t\tivl_assert(*this, ! ff_aclr.pin(pin).is_linked());\n\n\t\t\tivl_assert(*this, rst->pin_count()==1);\n\t\t\tconnect(ff_aclr.pin(pin), rst->pin(0));\n\n\t\t  } else {\n\t\t\t  // Don't yet support multiple asynchronous set inputs.\n\t\t\tivl_assert(*this, ! ff_aset.pin(pin).is_linked());\n\n\t\t\tivl_assert(*this, rst->pin_count()==1);\n\t\t\tconnect(ff_aset.pin(pin), rst->pin(0));\n\t\t\tif (rst_drv!=ones)\n\t\t\t      ff_aset_value[pin] = rst_drv;\n\t\t  }\n\t    }\n\n\t    if (else_ == 0)\n\t\t  return true;\n\n\t    vector<NetEvProbe*> events;\n\t    for (unsigned jdx = 0 ;  jdx < events_in.size() ;  jdx += 1) {\n\t\t  if (jdx != idx)\n\t\t\tevents.push_back(events_in[jdx]);\n\t    }\n\t    return else_->synth_sync(des, scope,\n\t\t\t\t     ff_negedge, ff_clk, ff_ce,\n\t\t\t\t     ff_aclr, ff_aset, ff_aset_value,\n\t\t\t\t     nex_map, nex_out, bitmasks, events);\n      }\n\n      delete expr_input;\n\n#if 0\n\t/* Detect the case that this is a *synchronous* set/reset. It\n\t   is not asynchronous because we know the condition is not\n\t   included in the sensitivity list, but if the if_ case is\n\t   constant (has no inputs) then we can model this as a\n\t   synchronous set/reset.\n\n\t   This is only synchronous set/reset if there is a true and a\n\t   false clause, and no inputs. The \"no inputs\" requirement is\n\t   met if the assignments are of all constant values. */\n      assert(if_ != 0);\n      NexusSet*a_set = if_->nex_input();\n\n      if ((a_set->count() == 0) && if_ && else_) {\n\n\t    NetNet*rst = expr_->synthesize(des);\n\t    assert(rst->pin_count() == 1);\n\n\t      /* Synthesize the true clause to figure out what\n\t\t kind of set/reset we have. */\n\t    NetNet*asig = new NetNet(scope, scope->local_symbol(),\n\t\t\t\t     NetNet::WIRE, nex_map->pin_count());\n\t    asig->local_flag(true);\n\t    bool flag = if_->synth_async(des, scope, nex_map, asig);\n\n\t    if (!flag) {\n\t\t  /* This path leads nowhere */\n\t\t  delete asig;\n\t    } else {\n\t\t  assert(asig->pin_count() == ff->width());\n\n\t\t    /* Collect the set/reset value into a verinum. If\n\t\t       this turns out to be entirely 0 values, then\n\t\t       use the Sclr input. Otherwise, use the Aset\n\t\t       input and save the set value. */\n\t\t  verinum tmp (verinum::V0, ff->width());\n\t\t  for (unsigned bit = 0 ;  bit < ff->width() ;\tbit += 1) {\n\n\t\t\tassert(asig->pin(bit).nexus()->drivers_constant());\n\t\t\ttmp.set(bit, asig->pin(bit).nexus()->driven_value());\n\t\t  }\n\n\t\t  assert(tmp.is_defined());\n\t\t  if (tmp.is_zero()) {\n\t\t\tconnect(ff->pin_Sclr(), rst->pin(0));\n\n\t\t  } else {\n\t\t\tconnect(ff->pin_Sset(), rst->pin(0));\n\t\t\tff->sset_value(tmp);\n\t\t  }\n\n\t\t  delete a_set;\n\n\t\t  assert(else_ != 0);\n\t\t  flag = else_->synth_sync(des, scope, ff, nex_map,\n\t\t\t\t\t   nex_out, std::vector<NetEvProbe*>())\n\t\t\t&& flag;\n\t\t  DEBUG_SYNTH2_EXIT(\"NetCondit\",flag)\n\t\t  return flag;\n\t    }\n      }\n\n      delete a_set;\n#endif\n\n#if 0\n\t/* This gives a false positive for strange coding styles,\n\t   such as ivltests/conditsynth3.v. */\n\n\t/* Failed to find an asynchronous set/reset, so any events\n\t   input are probably in error. */\n      if (events_in.size() > 0) {\n\t    cerr << get_fileline() << \": error: Events are unaccounted\"\n\t\t << \" for in process synthesis.\" << endl;\n\t    des->errors += 1;\n      }\n#endif\n\n      return synth_async(des, scope, nex_map, nex_out, ff_ce, bitmasks);\n}\n\nbool NetEvWait::synth_sync(Design*des, NetScope*scope,\n\t\t\t   bool&ff_negedge,\n\t\t\t   NetNet*ff_clk, NetBus&ff_ce,\n\t\t\t   NetBus&ff_aclr,NetBus&ff_aset,\n\t\t\t   vector<verinum>&ff_aset_value,\n\t\t\t   NexusSet&nex_map, NetBus&nex_out,\n\t\t\t   vector<mask_t>&bitmasks,\n\t\t\t   const vector<NetEvProbe*>&events_in)\n{\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetEvWait::synth_sync: \"\n\t\t << \"Synchronous process an event statement.\" << endl;\n      }\n\n      if (events_in.size() > 0) {\n\t    cerr << get_fileline() << \": error: Events are unaccounted\"\n\t\t << \" for in process synthesis.\" << endl;\n\t    des->errors += 1;\n      }\n\n      assert(events_in.size() == 0);\n\n\t/* This can't be other than one unless there are named events,\n\t   which I cannot synthesize. */\n      ivl_assert(*this, events_.size() == 1);\n      NetEvent*ev = events_[0];\n\n      assert(ev->nprobe() >= 1);\n      vector<NetEvProbe*>events (ev->nprobe() - 1);\n\n\t/* Get the input set from the substatement. This will be used\n\t   to figure out which of the probes is the clock. */\n      NexusSet*statement_input = statement_ -> nex_input();\n\n\t/* Search for a clock input. The clock input is the edge event\n\t   that is not also an input to the substatement. */\n      NetEvProbe*pclk = 0;\n      unsigned event_idx = 0;\n      for (unsigned idx = 0 ;  idx < ev->nprobe() ;  idx += 1) {\n\t    NetEvProbe*tmp = ev->probe(idx);\n\t    assert(tmp->pin_count() == 1);\n\n\t    NexusSet tmp_nex;\n\t    tmp_nex .add( tmp->pin(0).nexus(), 0, 0 );\n\n\t    if (! statement_input ->contains(tmp_nex)) {\n\t\t  if (pclk != 0) {\n\t\t\tcerr << get_fileline() << \": error: Too many \"\n\t\t\t     << \"clocks for synchronous logic.\" << endl;\n\t\t\tcerr << get_fileline() << \":\t  : Perhaps an\"\n\t\t\t     << \" asynchronous set/reset is misused?\" << endl;\n\t\t\tdes->errors += 1;\n\t\t  }\n\t\t  pclk = tmp;\n\n\t    } else {\n\t\t  events[event_idx++] = tmp;\n\t    }\n      }\n\n      if (pclk == 0) {\n\t    cerr << get_fileline() << \": error: None of the edges\"\n\t\t << \" are valid clock inputs.\" << endl;\n\t    cerr << get_fileline() << \":      : Perhaps the clock\"\n\t\t << \" is read by a statement or expression?\" << endl;\n\t    des->errors += 1;\n\t    return false;\n      }\n\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetEvWait::synth_sync: \"\n\t\t << \"Found and synthesized the FF clock.\" << endl;\n      }\n\n      connect(ff_clk->pin(0), pclk->pin(0));\n      if (pclk->edge() == NetEvProbe::NEGEDGE) {\n\t    ff_negedge = true;\n\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Detected a NEGEDGE clock for the synthesized ff.\"\n\t\t       << endl;\n\t    }\n      }\n\n\t/* Synthesize the input to the DFF. */\n      return statement_->synth_sync(des, scope,\n\t\t\t\t    ff_negedge, ff_clk, ff_ce,\n\t\t\t\t    ff_aclr, ff_aset, ff_aset_value,\n\t\t\t\t    nex_map, nex_out, bitmasks, events);\n}\n\n/*\n * This method is called for a process that is determined to be\n * synchronous. Create a NetFF device to hold the output from the\n * statement, and synthesize that statement in place.\n */\nbool NetProcTop::synth_sync(Design*des)\n{\n      if (debug_synth2) {\n\t    cerr << get_fileline() << \": NetProcTop::synth_sync: \"\n\t\t << \"Process is apparently synchronous. Making NetFFs.\"\n\t\t << endl;\n      }\n\n      NexusSet nex_set;\n      statement_->nex_output(nex_set);\n      vector<verinum> aset_value(nex_set.size());\n\n\t/* Make a model FF that will connect to the first item in the\n\t   set, and will also take the initial connection of clocks\n\t   and resets. */\n\n\t// Create a net to carry the clock for the synthesized FFs.\n      NetNet*clock = new NetNet(scope(), scope()->local_symbol(),\n\t\t\t\tNetNet::TRI, &netvector_t::scalar_logic);\n      clock->local_flag(true);\n      clock->set_line(*this);\n\n      NetBus ce    (scope(), nex_set.size());\n      NetBus nex_d (scope(), nex_set.size());\n      NetBus nex_q (scope(), nex_set.size());\n      NetBus aclr  (scope(), nex_set.size());\n      NetBus aset  (scope(), nex_set.size());\n      vector<NetProc::mask_t> bitmasks (nex_set.size());\n\n\t// Save links to the initial nex_d. These will be used later\n\t// to detect floating part-substitute and mux inputs that need\n\t// to be tied off.\n      NetBus nex_in (scope(), nex_d.pin_count());\n      for (unsigned idx = 0 ; idx < nex_in.pin_count() ; idx += 1)\n\t    connect(nex_in.pin(idx), nex_d.pin(idx));\n\n\t// The Q of the NetFF devices is connected to the output that\n\t// we are. The nex_q is a bundle of the outputs.\n      for (unsigned idx = 0 ; idx < nex_q.pin_count() ; idx += 1)\n\t    connect(nex_q.pin(idx), nex_set[idx].lnk);\n\n\t// Connect the D of the NetFF devices later.\n\n\t/* Synthesize the input to the DFF. */\n      bool negedge = false;\n      bool flag = statement_->synth_sync(des, scope(),\n\t\t\t\t\t negedge, clock, ce,\n\t\t\t\t\t aclr, aset, aset_value,\n\t\t\t\t\t nex_set, nex_d, bitmasks,\n\t\t\t\t\t vector<NetEvProbe*>());\n      if (! flag) {\n\t    delete clock;\n\t    return false;\n      }\n\n      flag = tie_off_floating_inputs_(des, nex_set, nex_in, bitmasks, true);\n      if (!flag) return false;\n\n      for (unsigned idx = 0 ;  idx < nex_set.size() ;  idx += 1) {\n\n\t      //ivl_assert(*this, nex_set[idx].nex);\n\t    if (debug_synth2) {\n\t\t  cerr << get_fileline() << \": debug: \"\n\t\t       << \"Top level making a \"\n\t\t       << nex_set[idx].wid << \"-wide \"\n\t\t       << \"NetFF device.\" << endl;\n\t    }\n\n\t    NetFF*ff2 = new NetFF(scope(), scope()->local_symbol(),\n\t\t\t\t  negedge, nex_set[idx].wid);\n\t    des->add_node(ff2);\n\t    ff2->set_line(*this);\n\t    ff2->aset_value(aset_value[idx]);\n\n\t    NetNet*tmp = nex_d.pin(idx).nexus()->pick_any_net();\n\t    tmp->set_line(*this);\n\t    assert(tmp);\n\n\t    tmp = crop_to_width(des, tmp, ff2->width());\n\n\t    connect(nex_q.pin(idx), ff2->pin_Q());\n\t    connect(tmp->pin(0),    ff2->pin_Data());\n\n\t    connect(clock->pin(0),  ff2->pin_Clock());\n\t    if (ce.pin(idx).is_linked())\n\t\t  connect(ce.pin(idx),\t  ff2->pin_Enable());\n\t    if (aclr.pin(idx).is_linked())\n\t\t  connect(aclr.pin(idx),  ff2->pin_Aclr());\n\t    if (aset.pin(idx).is_linked())\n\t\t  connect(aset.pin(idx),  ff2->pin_Aset());\n#if 0\n\t    if (ff->pin_Sset().is_linked())\n\t\t  connect(ff->pin_Sset(), ff2->pin_Sset());\n\t    if (ff->pin_Sclr().is_linked())\n\t\t  connect(ff->pin_Sclr(), ff2->pin_Sclr());\n#endif\n      }\n\n\t// The \"clock\" net was just to carry the connection back\n\t// to the flip-flop. Delete it now. The connection will\n\t// persist.\n      delete clock;\n\n      synthesized_design_ = des;\n      return true;\n}\n\nclass synth2_f\t: public functor_t {\n\n    public:\n      void process(Design*, NetProcTop*);\n\n    private:\n};\n\n\n/*\n * Look at a process. If it is asynchronous, then synthesize it as an\n * asynchronous process and delete the process itself for its gates.\n */\nvoid synth2_f::process(Design*des, NetProcTop*top)\n{\n      if (top->attribute(perm_string::literal(\"ivl_synthesis_off\")).as_ulong() != 0)\n\t    return;\n\n\t/* If the scope that contains this process as a cell attribute\n\t   attached to it, then skip synthesis. */\n      if (top->scope()->attribute(perm_string::literal(\"ivl_synthesis_cell\")).len() > 0)\n\t    return;\n\n\t/* Create shared pullup and pulldown nodes (if they don't already\n\t   exist) for use when creating clock/gate enables. */\n      top->scope()->add_tie_hi(des);\n      top->scope()->add_tie_lo(des);\n\n      if (top->is_synchronous()) {\n\t    bool flag = top->synth_sync(des);\n\t    if (! flag) {\n\t\t  cerr << top->get_fileline() << \": error: \"\n\t\t       << \"Unable to synthesize synchronous process.\"\n\t\t       << endl;\n\t\t  des->errors += 1;\n\t\t  return;\n\t    }\n\t    des->delete_process(top);\n\t    return;\n      }\n\n      if (! top->is_asynchronous()) {\n\t    bool synth_error_flag = false;\n\t    if (top->attribute(perm_string::literal(\"ivl_combinational\")).as_ulong() != 0) {\n\t\t  cerr << top->get_fileline() << \": error: \"\n\t\t       << \"Process is marked combinational,\"\n\t\t       << \" but isn't really.\" << endl;\n\t\t  des->errors += 1;\n\t\t  synth_error_flag = true;\n\t    }\n\n\t    if (top->attribute(perm_string::literal(\"ivl_synthesis_on\")).as_ulong() != 0) {\n\t\t  cerr << top->get_fileline() << \": error: \"\n\t\t       << \"Process is marked for synthesis,\"\n\t\t       << \" but I can't do it.\" << endl;\n\t\t  des->errors += 1;\n\t\t  synth_error_flag = true;\n\t    }\n\n\t    if (! synth_error_flag)\n\t\t  cerr << top->get_fileline() << \": warning: \"\n\t\t       << \"Process not synthesized.\" << endl;\n\n\t    return;\n      }\n\n      if (! top->synth_async(des)) {\n\t    cerr << top->get_fileline() << \": error: \"\n\t\t << \"Unable to synthesize asynchronous process.\"\n\t\t << endl;\n\t    des->errors += 1;\n\t    return;\n      }\n\n      des->delete_process(top);\n}\n\nvoid synth2(Design*des)\n{\n      synth2_f synth_obj;\n      des->functor(&synth_obj);\n}\n"
        },
        {
          "name": "sys_funcs.cc",
          "type": "blob",
          "size": 6.90625,
          "content": "/*\n * Copyright (c) 2004-2019 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"compiler.h\"\n# include  <cstdio>\n# include  <cstring>\n# include  <cstdlib>\n\n/*\n * Manage the information about system functions. This information is\n * collected from the sources before elaboration and made available\n * via the lookup_sys_func function.\n */\n\nstatic const struct sfunc_return_type default_return_type =\n    { 0, IVL_VT_LOGIC, 32, false, false };\n\nstruct sfunc_return_type_cell : sfunc_return_type {\n      struct sfunc_return_type_cell*next;\n};\n\nstatic struct sfunc_return_type_cell*sfunc_list_head = 0;\nstatic struct sfunc_return_type_cell*sfunc_list_tail = 0;\n\nvoid append_to_list(struct sfunc_return_type_cell*cell)\n{\n      if (sfunc_list_tail) {\n\t    sfunc_list_tail->next = cell;\n\t    sfunc_list_tail = cell;\n      } else {\n\t    sfunc_list_head = cell;\n\t    sfunc_list_tail = cell;\n      }\n      cell->next = 0;\n}\n\nvoid cleanup_sys_func_table()\n{\n      struct sfunc_return_type_cell *next, *cur = sfunc_list_head;\n      while (cur) {\n\t    next = cur->next;\n\t    delete cur;\n\t    cur = next;\n      }\n}\n\nstatic struct sfunc_return_type* find_in_sys_func_list(const char*name)\n{\n      struct sfunc_return_type_cell*cur = sfunc_list_head;\n      while (cur) {\n\t    if (strcmp(cur->name, name) == 0)\n\t\t  return cur;\n\n\t    cur = cur->next;\n      }\n\n      return 0;\n}\n\nconst struct sfunc_return_type* lookup_sys_func(const char*name)\n{\n\t/* First, try to find the name in the function list. */\n      struct sfunc_return_type*def = find_in_sys_func_list(name);\n      if (def)\n\t    return def;\n\n\t/* No luck finding, so return the default description. */\n      return &default_return_type;\n}\n\nvoid add_sys_func(const struct sfunc_return_type&ret_type)\n{\n      struct sfunc_return_type*def = find_in_sys_func_list(ret_type.name);\n      if (def) {\n              /* Keep the original definition, but flag that it\n                 overrides a later definition. */\n            def->override_flag = true;\n            return;\n      }\n      struct sfunc_return_type_cell*cell = new struct sfunc_return_type_cell;\n      cell->name = lex_strings.add(ret_type.name);\n      cell->type = ret_type.type;\n      cell->wid  = ret_type.wid;\n      cell->signed_flag = ret_type.signed_flag;\n      cell->override_flag = ret_type.override_flag;\n      append_to_list(cell);\n}\n\n/*\n * This function loads a system functions descriptor file with the\n * format:\n *\n *    <name> <type> [<arguments>]\n *\n * The driver passes us user-provided tables first, so we add new entries\n * to the end of the list. This allows user-defined functions to override\n * built-in functions.\n */\nint load_sys_func_table(const char*path)\n{\n      struct sfunc_return_type_cell*cell;\n      FILE*fd = fopen(path, \"r\");\n\n      if (fd == 0) {\n\t    if (verbose_flag) {\n\t\t  fprintf(stderr, \"%s: Unable to open System Function Table file.\\n\", path);\n\t    }\n\t    return -1;\n      }\n\n      if (verbose_flag) {\n\t    fprintf(stderr, \"%s: Processing System Function Table file.\\n\", path);\n      }\n\n      char buf[256];\n      while (fgets(buf, sizeof buf, fd)) {\n\t    char*name = buf + strspn(buf, \" \\t\\r\\n\");\n\n\t      /* Skip empty lines. */\n\t    if (name[0] == 0)\n\t\t  continue;\n\t      /* Skip comment lines. */\n\t    if (name[0] == '#')\n\t\t  continue;\n\n\t    char*cp = name + strcspn(name, \" \\t\\r\\n\");\n\t    if (cp[0]) *cp++ = 0;\n\n\t    cp += strspn(cp, \" \\t\\r\\n\");\n\n\t    char*stype = cp;\n\t    if (stype[0] == 0) {\n\t\t  fprintf(stderr, \"%s:%s: No function type?\\n\",\n\t\t\t  path, name);\n\t\t  continue;\n\t    }\n\n\t    cp = stype + strcspn(stype, \" \\t\\r\\n\");\n\t    if (cp[0]) *cp++ = 0;\n\n            struct sfunc_return_type*def = find_in_sys_func_list(name);\n            if (def) {\n                    /* Keep the original definition, but flag that it\n                       overrides a later definition. */\n                  def->override_flag = true;\n                  continue;\n            }\n\n\t    if (strcmp(stype,\"vpiSysFuncReal\") == 0) {\n\t\t  cell = new struct sfunc_return_type_cell;\n\t\t  cell->name = lex_strings.add(name);\n\t\t  cell->type = IVL_VT_REAL;\n\t\t  cell->wid  = 1;\n\t\t  cell->signed_flag = true;\n\t\t  cell->override_flag = false;\n\t\t  append_to_list(cell);\n\t\t  continue;\n\t    }\n\n\t    if (strcmp(stype,\"vpiSysFuncInt\") == 0) {\n\t\t  cell = new struct sfunc_return_type_cell;\n\t\t  cell->name = lex_strings.add(name);\n\t\t  cell->type = IVL_VT_LOGIC;\n\t\t  cell->wid  = 32;\n\t\t  cell->signed_flag = true;\n\t\t  cell->override_flag = false;\n\t\t  append_to_list(cell);\n\t\t  continue;\n\t    }\n\n\t      /* If this is a sized integer, then parse the additional\n\t\t arguments, the width (decimal) and the optional\n\t\t signed/unsigned flag. */\n\t    if (strcmp(stype,\"vpiSysFuncSized\") == 0) {\n\t\t  cp += strspn(cp, \" \\t\\r\\n\");\n\t\t  char*swidth = cp;\n\t\t  unsigned width = 32;\n\t\t  bool signed_flag = false;\n\n\t\t  cp = swidth + strcspn(swidth, \" \\t\\r\\n\");\n\t\t  if (cp[0]) *cp++ = 0;\n\n\t\t  width = strtoul(swidth, 0, 10);\n\n\t\t  cp += strspn(cp, \" \\t\\r\\n\");\n\t\t  char*flag = cp;\n\n\t\t  while (flag[0]) {\n\t\t\tcp = flag + strcspn(flag, \" \\t\\r\\n\");\n\t\t\tif (cp[0]) *cp++ = 0;\n\n\t\t\tif (strcmp(flag,\"signed\") == 0) {\n\t\t\t      signed_flag = true;\n\n\t\t\t} else if (strcmp(flag,\"unsigned\") == 0) {\n\t\t\t      signed_flag = false;\n\t\t\t}\n\n\t\t\tflag = cp + strspn(cp, \" \\t\\r\\n\");\n\t\t  }\n\n\t\t  cell = new struct sfunc_return_type_cell;\n\t\t  cell->name = lex_strings.add(name);\n\t\t  cell->type = IVL_VT_LOGIC;\n\t\t  cell->wid  = width;\n\t\t  cell->signed_flag = signed_flag;\n\t\t  cell->override_flag = false;\n\t\t  append_to_list(cell);\n\t\t  continue;\n\t    }\n\n\t    if (strcmp(stype,\"vpiSysFuncVoid\") == 0) {\n\t\t  cell = new struct sfunc_return_type_cell;\n\t\t  cell->name = lex_strings.add(name);\n\t\t  cell->type = IVL_VT_VOID;\n\t\t  cell->wid  = 0;\n\t\t  cell->signed_flag = false;\n\t\t  cell->override_flag = false;\n\t\t  append_to_list(cell);\n\t\t  continue;\n\t    }\n\n\t    if (strcmp(stype,\"vpiSysFuncString\") == 0) {\n\t\t  cell = new struct sfunc_return_type_cell;\n\t\t  cell->name = lex_strings.add(name);\n\t\t  cell->type = IVL_VT_STRING;\n\t\t  cell->wid  = 0;   // string is a dynamic length type\n\t\t  cell->signed_flag = false;\n\t\t  cell->override_flag = false;\n\t\t  append_to_list(cell);\n\t\t  continue;\n\t    }\n\n\t    fprintf(stderr, \"%s:%s: Unknown type: %s\\n\",\n\t\t    path, name, stype);\n      }\n      fclose(fd);\n\n      return 0;\n}\n"
        },
        {
          "name": "t-dll-analog.cc",
          "type": "blob",
          "size": 2.318359375,
          "content": "/*\n * Copyright (c) 2008-2010 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.will need a Picture Elements Binary Software\n *    License.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  <cstring>\n# include  \"target.h\"\n# include  \"ivl_target.h\"\n# include  \"compiler.h\"\n# include  \"t-dll.h\"\n# include  <cstdlib>\n# include  \"ivl_alloc.h\"\n\nbool dll_target::process(const NetAnalogTop*net)\n{\n      bool rc_flag = true;\n\n      ivl_process_t obj = (struct ivl_process_s*)\n\t    calloc(1, sizeof(struct ivl_process_s));\n\n      obj->type_ = net->type();\n      obj->analog_flag = 1;\n\n      FILE_NAME(obj, net);\n\n\t/* Save the scope of the process. */\n      obj->scope_ = lookup_scope_(net->scope());\n\n      obj->nattr = net->attr_cnt();\n      obj->attr = fill_in_attributes(net);\n\n      assert(stmt_cur_ == 0);\n      stmt_cur_ = (struct ivl_statement_s*)calloc(1, sizeof*stmt_cur_);\n      rc_flag = net->statement()->emit_proc(this) && rc_flag;\n\n      assert(stmt_cur_);\n      obj->stmt_ = stmt_cur_;\n      stmt_cur_ = 0;\n\n\t/* Save the process in the design. */\n      obj->next_ = des_.threads_;\n      des_.threads_ = obj;\n\n      return rc_flag;\n}\n\nbool dll_target::proc_contribution(const NetContribution*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_CONTRIB;\n\n      assert(expr_ == 0);\n      net->lval()->expr_scan(this);\n      stmt_cur_->u_.contrib_.lval = expr_;\n      expr_ = 0;\n\n      net->rval()->expr_scan(this);\n      stmt_cur_->u_.contrib_.rval = expr_;\n      expr_ = 0;\n\n      return true;\n}\n"
        },
        {
          "name": "t-dll-api.cc",
          "type": "blob",
          "size": 67.9443359375,
          "content": "/*\n * Copyright (c) 2000-2024 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n * Copyright (c) 2016 CERN Michele Castellana (michele.castellana@cern.ch)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include  \"StringHeap.h\"\n# include  \"t-dll.h\"\n# include  \"discipline.h\"\n# include  \"netclass.h\"\n# include  \"netdarray.h\"\n# include  \"netenum.h\"\n# include  \"netvector.h\"\n# include  <cstdlib>\n# include  <cstdio>\n# include  <cstring>\n# include  \"ivl_alloc.h\"\n\nusing namespace std;\n\nstatic StringHeap api_strings;\n\n/* THE FOLLOWING ARE FUNCTIONS THAT ARE CALLED FROM THE TARGET. */\n\nextern \"C\" ivl_island_t ivl_branch_island(ivl_branch_t net)\n{\n      assert(net);\n      return net->island;\n}\n\nextern \"C\" ivl_nexus_t ivl_branch_terminal(ivl_branch_t net, int idx)\n{\n      assert(net);\n      assert(idx >= 0);\n      assert(idx < 2);\n      return net->pins[idx];\n}\nextern \"C\" const char*ivl_design_delay_sel(ivl_design_t des)\n{\n      assert(des);\n      assert(des->self);\n      return des->self->get_delay_sel();\n}\n\nextern \"C\" const char*ivl_design_flag(ivl_design_t des, const char*key)\n{\n      assert(des);\n      assert(des->self);\n      return des->self->get_flag(key);\n}\n\nextern \"C\" int ivl_design_process(ivl_design_t des,\n\t\t\t\t  ivl_process_f func,\n\t\t\t\t  void*cd)\n{\n      assert(des);\n      for (ivl_process_t idx = des->threads_;  idx;  idx = idx->next_) {\n\t    int rc = (func)(idx, cd);\n\t    if (rc != 0)\n\t\t  return rc;\n      }\n\n      return 0;\n}\n\nextern \"C\" ivl_scope_t ivl_design_root(ivl_design_t des)\n{\n      cerr << \"ANACHRONISM: ivl_design_root called. \"\n       \"Use ivl_design_roots instead.\" << endl;\n      assert(des);\n      assert (des->roots.size() > 0);\n      return des->roots[0];\n}\n\nextern \"C\" void ivl_design_roots(ivl_design_t des, ivl_scope_t **scopes,\n\t\t\t\t unsigned int *nscopes)\n{\n      assert(des);\n      assert (nscopes && scopes);\n      if (des->root_scope_list.size() == 0) {\n\t    size_t fill = 0;\n\t    des->root_scope_list.resize(des->packages.size() + des->roots.size());\n\n\t    for (size_t idx = 0 ; idx < des->packages.size() ; idx += 1)\n\t\t  des->root_scope_list[fill++] = des->packages[idx];\n\t    for (size_t idx = 0 ; idx < des->roots.size() ; idx += 1)\n\t\t  des->root_scope_list[fill++] = des->roots[idx];\n      }\n\n      *scopes = &des->root_scope_list[0];\n      *nscopes = des->root_scope_list.size();\n}\n\nextern \"C\" int ivl_design_time_precision(ivl_design_t des)\n{\n      assert(des);\n      return des->time_precision;\n}\n\nextern \"C\" unsigned ivl_design_consts(ivl_design_t des)\n{\n      assert(des);\n      return des->consts.size();\n}\n\nextern \"C\" ivl_net_const_t ivl_design_const(ivl_design_t des, unsigned idx)\n{\n      assert(des);\n      assert(idx < des->consts.size());\n      return des->consts[idx];\n}\n\nextern \"C\" unsigned ivl_design_disciplines(ivl_design_t des)\n{\n      assert(des);\n      return des->disciplines.size();\n}\n\nextern \"C\" ivl_discipline_t ivl_design_discipline(ivl_design_t des, unsigned idx)\n{\n      assert(des);\n      assert(idx < des->disciplines.size());\n      return des->disciplines[idx];\n}\n\nextern \"C\" ivl_dis_domain_t ivl_discipline_domain(ivl_discipline_t net)\n{\n      assert(net);\n      return net->domain();\n}\n\nextern \"C\" ivl_nature_t ivl_discipline_flow(ivl_discipline_t net)\n{\n      assert(net);\n      return net->flow();\n}\n\nextern \"C\" const char* ivl_discipline_name(ivl_discipline_t net)\n{\n      assert(net);\n      return net->name();\n}\n\nextern \"C\" ivl_nature_t ivl_discipline_potential(ivl_discipline_t net)\n{\n      assert(net);\n      return net->potential();\n}\n\nextern \"C\" ivl_expr_type_t ivl_expr_type(ivl_expr_t net)\n{\n      if (net == 0)\n\t    return IVL_EX_NONE;\n      return net->type_;\n}\n\nextern \"C\" const char*ivl_expr_file(ivl_expr_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_expr_lineno(ivl_expr_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_variable_type_t ivl_const_type(ivl_net_const_t net)\n{\n      assert(net);\n      return net->type;\n}\n\nextern \"C\" const char*ivl_const_bits(ivl_net_const_t net)\n{\n      assert(net);\n      switch (net->type) {\n\n\t  case IVL_VT_BOOL:\n\t  case IVL_VT_LOGIC:\n\t  case IVL_VT_STRING:\n\t    if (net->width_ <= sizeof(net->b.bit_))\n\t\t  return net->b.bit_;\n\t    else\n\t\t  return net->b.bits_;\n\n\t  default:\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_expr_t ivl_const_delay(ivl_net_const_t net, unsigned transition)\n{\n      assert(net);\n      assert(transition < 3);\n      return net->delay[transition];\n}\n\nextern \"C\" const char*ivl_const_file(ivl_net_const_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_const_lineno(ivl_net_const_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_nexus_t ivl_const_nex(ivl_net_const_t net)\n{\n      assert(net);\n      return net->pin_;\n}\n\nextern \"C\" double ivl_const_real(ivl_net_const_t net)\n{\n      assert(net);\n      assert(net->type == IVL_VT_REAL);\n      return net->b.real_value;\n}\n\nextern \"C\" ivl_scope_t ivl_const_scope(ivl_net_const_t net)\n{\n      assert(net);\n      return net->scope;\n}\n\nextern \"C\" int ivl_const_signed(ivl_net_const_t net)\n{\n      assert(net);\n      return net->signed_;\n}\n\nextern \"C\" unsigned ivl_const_width(ivl_net_const_t net)\n{\n      assert(net);\n      return net->width_;\n}\n\nextern \"C\" unsigned ivl_enum_names(ivl_enumtype_t net)\n{\n      assert(net);\n      return net->size();\n}\n\nextern \"C\" const char* ivl_enum_name(ivl_enumtype_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->size());\n      return net->name_at(idx);\n}\n\nextern \"C\" const char* ivl_enum_bits(ivl_enumtype_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->size());\n      return net->bits_at(idx);\n}\n\nextern \"C\" ivl_variable_type_t ivl_enum_type(ivl_enumtype_t net)\n{\n      assert(net);\n      return net->base_type();\n}\n\nextern \"C\" unsigned ivl_enum_width(ivl_enumtype_t net)\n{\n      assert(net);\n      return net->packed_width();\n}\n\nextern \"C\" int ivl_enum_signed(ivl_enumtype_t net)\n{\n      assert(net);\n      return net->get_signed();\n}\n\nextern \"C\" const char*ivl_enum_file(ivl_enumtype_t net)\n{\n      assert(net);\n      return net->get_file().str();\n}\n\nextern \"C\" unsigned ivl_enum_lineno(ivl_enumtype_t net)\n{\n      assert(net);\n      return net->get_lineno();\n}\n\nextern \"C\" const char* ivl_event_name(ivl_event_t net)\n{\n      assert(net);\n      static char*name_buffer = 0;\n      static unsigned name_size = 0;\n\n      ivl_scope_t scope = net->scope;\n      const char*sn = ivl_scope_name(scope);\n\n      unsigned need = strlen(sn) + 1 + strlen(net->name) + 1;\n      if (need > name_size) {\n\t    name_buffer = (char*)realloc(name_buffer, need);\n\t    name_size = need;\n      }\n\n      strcpy(name_buffer, sn);\n      char*tmp = name_buffer + strlen(sn);\n      *tmp++ = '.';\n      strcpy(tmp, net->name);\n\n      cerr << \"ANACHRONISM: Call to anachronistic ivl_event_name.\" << endl;\n\n      return name_buffer;\n}\n\nextern \"C\" const char* ivl_event_basename(ivl_event_t net)\n{\n      assert(net);\n      return net->name;\n}\n\nextern \"C\" const char*ivl_event_file(ivl_event_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_event_lineno(ivl_event_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_scope_t ivl_event_scope(ivl_event_t net)\n{\n      assert(net);\n      return net->scope;\n}\n\nextern \"C\" unsigned ivl_event_nany(ivl_event_t net)\n{\n      assert(net);\n      return net->nany;\n}\n\nextern \"C\" ivl_nexus_t ivl_event_any(ivl_event_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nany);\n      return net->pins[idx];\n}\n\nextern \"C\" unsigned ivl_event_nedg(ivl_event_t net)\n{\n      assert(net);\n      return net->nedg;\n}\n\nextern \"C\" ivl_nexus_t ivl_event_edg(ivl_event_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nedg);\n      return net->pins[net->nany + net->nneg + net->npos + idx];\n}\n\nextern \"C\" unsigned ivl_event_nneg(ivl_event_t net)\n{\n      assert(net);\n      return net->nneg;\n}\n\nextern \"C\" ivl_nexus_t ivl_event_neg(ivl_event_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nneg);\n      return net->pins[net->nany + idx];\n}\n\nextern \"C\" unsigned ivl_event_npos(ivl_event_t net)\n{\n      assert(net);\n      return net->npos;\n}\n\nextern \"C\" ivl_nexus_t ivl_event_pos(ivl_event_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->npos);\n      return net->pins[net->nany + net->nneg + idx];\n}\n\nextern \"C\" const char* ivl_expr_bits(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_NUMBER);\n      return net->u_.number_.bits_;\n}\n\nextern \"C\" ivl_branch_t ivl_expr_branch(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_BACCESS);\n      return net->u_.branch_.branch;\n}\n\nextern \"C\" ivl_scope_t ivl_expr_def(ivl_expr_t net)\n{\n      assert(net);\n\n      switch (net->type_) {\n\n\t  case IVL_EX_UFUNC:\n\t    return net->u_.ufunc_.def;\n\n\t  default:\n\t    assert(0);\n      }\n\n      return 0;\n}\n\nextern \"C\" uint64_t ivl_expr_delay_val(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_DELAY);\n      return net->u_.delay_.value;\n}\n\nextern \"C\" double ivl_expr_dvalue(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_REALNUM);\n      return net->u_.real_.value;\n}\n\nextern \"C\" ivl_enumtype_t ivl_expr_enumtype(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_ENUMTYPE);\n      return net->u_.enumtype_.type;\n}\n\nextern \"C\" ivl_type_t ivl_expr_net_type(ivl_expr_t net)\n{\n      assert(net);\n      return net->net_type;\n}\n\nextern \"C\" const char* ivl_expr_name(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\n\t  case IVL_EX_SFUNC:\n\t    return net->u_.sfunc_.name_;\n\n\t  case IVL_EX_SIGNAL:\n\t    return net->u_.signal_.sig->name_;\n\n\t  case IVL_EX_PROPERTY:\n\t      { ivl_signal_t sig = ivl_expr_signal(net);\n\t\tivl_type_t use_type = ivl_signal_net_type(sig);\n\t\tunsigned idx = ivl_expr_property_idx(net);\n\t\treturn ivl_type_prop_name(use_type, idx);\n\t      }\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_nature_t ivl_expr_nature(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_BACCESS);\n      return net->u_.branch_.nature;\n}\n\nextern \"C\" char ivl_expr_opcode(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_EX_BINARY:\n\t    return net->u_.binary_.op_;\n\n\t  case IVL_EX_UNARY:\n\t    return net->u_.unary_.op_;\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_expr_t ivl_expr_oper1(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_EX_BINARY:\n\t    return net->u_.binary_.lef_;\n\n\t  case IVL_EX_PROPERTY:\n\t    return net->u_.property_.index;\n\n\t  case IVL_EX_SELECT:\n\t    return net->u_.select_.expr_;\n\n\t  case IVL_EX_UNARY:\n\t    return net->u_.unary_.sub_;\n\n\t  case IVL_EX_MEMORY:\n\t    return net->u_.memory_.idx_;\n\n\t  case IVL_EX_NEW:\n\t    return net->u_.new_.size;\n\n\t  case IVL_EX_SHALLOWCOPY:\n\t    return net->u_.shallow_.dest;\n\n\t  case IVL_EX_SIGNAL:\n\t    return net->u_.signal_.word;\n\n\t  case IVL_EX_TERNARY:\n\t    return net->u_.ternary_.cond;\n\n\t  default:\n\t    assert(0);\n      }\n\n      return 0;\n}\n\nextern \"C\" ivl_expr_t ivl_expr_oper2(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_EX_BINARY:\n\t    return net->u_.binary_.rig_;\n\n\t  case IVL_EX_NEW:\n\t    return net->u_.new_.init_val;\n\n\t  case IVL_EX_SELECT:\n\t    return net->u_.select_.base_;\n\n\t  case IVL_EX_SHALLOWCOPY:\n\t    return net->u_.shallow_.src;\n\n\t  case IVL_EX_TERNARY:\n\t    return net->u_.ternary_.true_e;\n\n\t  default:\n\t    assert(0);\n      }\n\n      return 0;\n}\n\nextern \"C\" ivl_expr_t ivl_expr_oper3(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\n\t  case IVL_EX_TERNARY:\n\t    return net->u_.ternary_.false_e;\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_parameter_t ivl_expr_parameter(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_EX_NUMBER:\n\t    return net->u_.number_.parameter;\n\t  case IVL_EX_STRING:\n\t    return net->u_.string_.parameter;\n\t  case IVL_EX_REALNUM:\n\t    return net->u_.real_.parameter;\n\t  default:\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_expr_t ivl_expr_parm(ivl_expr_t net, unsigned idx)\n{\n      assert(net);\n      switch (net->type_) {\n\n\t  case IVL_EX_ARRAY_PATTERN:\n\t    assert(idx < net->u_.array_pattern_.parms);\n\t    return net->u_.array_pattern_.parm[idx];\n\n\t  case IVL_EX_CONCAT:\n\t    assert(idx < net->u_.concat_.parms);\n\t    return net->u_.concat_.parm[idx];\n\n\t  case IVL_EX_SFUNC:\n\t    assert(idx < net->u_.sfunc_.parms);\n\t    return net->u_.sfunc_.parm[idx];\n\n\t  case IVL_EX_UFUNC:\n\t    assert(idx < net->u_.ufunc_.parms);\n\t    return net->u_.ufunc_.parm[idx];\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_expr_parms(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\n\t  case IVL_EX_ARRAY_PATTERN:\n\t    return net->u_.array_pattern_.parms;\n\n\t  case IVL_EX_CONCAT:\n\t    return net->u_.concat_.parms;\n\n\t  case IVL_EX_SFUNC:\n\t    return net->u_.sfunc_.parms;\n\n\t  case IVL_EX_UFUNC:\n\t    return net->u_.ufunc_.parms;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_expr_repeat(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_CONCAT);\n      return net->u_.concat_.rept;\n}\n\nextern \"C\" ivl_event_t ivl_expr_event(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_EVENT);\n      return net->u_.event_.event;\n}\n\nextern \"C\" int ivl_expr_property_idx(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_PROPERTY);\n      return net->u_.property_.prop_idx;\n}\n\nextern \"C\" ivl_scope_t ivl_expr_scope(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_SCOPE);\n      return net->u_.scope_.scope;\n}\n\nextern \"C\" ivl_select_type_t ivl_expr_sel_type(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_SELECT);\n      return net->u_.select_.sel_type_;\n}\n\nextern \"C\" ivl_signal_t ivl_expr_signal(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\n\t  case IVL_EX_SIGNAL:\n\t  case IVL_EX_ARRAY:\n\t    return net->u_.signal_.sig;\n\n\t  case IVL_EX_PROPERTY:\n\t    return net->u_.property_.sig;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" int ivl_expr_signed(ivl_expr_t net)\n{\n      assert(net);\n      return net->signed_;\n}\n\nextern \"C\" int ivl_expr_sized(ivl_expr_t net)\n{\n      assert(net);\n      return net->sized_;\n}\n\nextern \"C\" const char* ivl_expr_string(ivl_expr_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_EX_STRING);\n      return net->u_.string_.value_;\n}\n\nextern \"C\" unsigned long ivl_expr_uvalue(ivl_expr_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\n\t  case IVL_EX_ULONG:\n\t    return net->u_.ulong_.value;\n\n\t  case IVL_EX_NUMBER: {\n\t\tunsigned long val = 0;\n\t\tfor (unsigned long idx = 0 ;  idx < net->width_ ;  idx += 1) {\n\t\t      if (net->u_.number_.bits_[idx] == '1')\n\t\t\t    val |= 1UL << idx;\n\t\t}\n\n\t\treturn val;\n\t  }\n\n\t  default:\n\t    assert(0);\n      }\n\n      assert(0);\n      return 0;\n}\n\nextern \"C\" ivl_variable_type_t ivl_expr_value(ivl_expr_t net)\n{\n      assert(net);\n      return net->value_;\n}\n\nextern \"C\" unsigned ivl_expr_width(ivl_expr_t net)\n{\n      assert(net);\n      return net->width_;\n}\n\n/*\n *  ivl_file_table_index puts entries in the map as needed and returns\n *  the appropriate index.\n *  ivl_file_table_size returns the number of entries in the table.\n *  ivl_file_table_item returns the file name for the given index.\n */\nstruct ltstr\n{\n      bool operator()(const char*s1, const char*s2) const\n      {\n\t    return strcmp(s1, s2) < 0;\n      }\n};\nstatic map<const char*, unsigned, ltstr> fn_map;\nstatic vector<const char*> fn_vector;\n\nstatic void ivl_file_table_init()\n{\n        /* The first two index entries do not depend on a real\n         * file name and are always available. */\n      fn_vector.push_back(\"N/A\");\n      fn_map[\"N/A\"] = 0;\n      fn_vector.push_back(\"<interactive>\");\n      fn_map[\"<interactive>\"] = 1;\n}\n\nextern \"C\" const char* ivl_file_table_item(unsigned idx)\n{\n      if (fn_vector.empty()) {\n\t    ivl_file_table_init();\n      }\n\n      assert(idx < fn_vector.size());\n      return fn_vector[idx];\n}\n\nextern \"C\" unsigned ivl_file_table_index(const char*name)\n{\n      if (fn_vector.empty()) {\n\t    ivl_file_table_init();\n      }\n\n      if (name == NULL) return 0;\n\n        /* The new index is the current map size. This is inserted only\n         * if the file name is not currently in the map. */\n      pair<map<const char*, unsigned, ltstr>::iterator, bool> result;\n      result = fn_map.insert(make_pair(name, fn_vector.size()));\n      if (result.second) {\n\t    fn_vector.push_back(name);\n      }\n      return result.first->second;\n}\n\nextern \"C\" unsigned ivl_file_table_size()\n{\n      if (fn_vector.empty()) {\n\t    ivl_file_table_init();\n      }\n\n      return fn_vector.size();\n}\n\nextern \"C\" int ivl_island_flag_set(ivl_island_t net, unsigned flag, int value)\n{\n      assert(net);\n      if (flag >= net->flags.size()) {\n\t    if (value == 0)\n\t\t  return 0;\n\t    else\n\t\t  net->flags.resize(flag+1, false);\n      }\n\n      int old_flag = net->flags[flag];\n      net->flags[flag] = value != 0;\n      return old_flag;\n}\n\nextern \"C\" int ivl_island_flag_test(ivl_island_t net, unsigned flag)\n{\n      assert(net);\n      if (flag >= net->flags.size())\n\t    return 0;\n      else\n\t    return net->flags[flag];\n}\n\nextern \"C\" const char*ivl_logic_file(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_logic_lineno(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" unsigned ivl_logic_is_cassign(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->is_cassign;\n}\n\nextern \"C\" const char* ivl_logic_attr(ivl_net_logic_t net, const char*key)\n{\n      assert(net);\n      unsigned idx;\n\n      for (idx = 0 ;  idx < net->nattr ;  idx += 1) {\n\n\t    if (strcmp(net->attr[idx].key, key) == 0)\n\t\t  return net->attr[idx].type == IVL_ATT_STR\n\t\t\t? net->attr[idx].val.str\n\t\t\t: 0;\n      }\n\n      return 0;\n}\n\nextern \"C\" unsigned ivl_logic_attr_cnt(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->nattr;\n}\n\nextern \"C\" ivl_attribute_t ivl_logic_attr_val(ivl_net_logic_t net,\n\t\t\t\t\t      unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nattr);\n      return net->attr + idx;\n}\n\nextern \"C\" ivl_drive_t ivl_logic_drive0(ivl_net_logic_t net)\n{\n      ivl_nexus_t nex = ivl_logic_pin(net, 0);\n\n      for (unsigned idx = 0 ;  idx < ivl_nexus_ptrs(nex) ;  idx += 1) {\n\t    ivl_nexus_ptr_t cur = ivl_nexus_ptr(nex, idx);\n\t    if (ivl_nexus_ptr_log(cur) != net)\n\t\t  continue;\n\t    if (ivl_nexus_ptr_pin(cur) != 0)\n\t\t  continue;\n\t    return ivl_nexus_ptr_drive0(cur);\n      }\n\n      assert(0);\n      return IVL_DR_STRONG;\n}\n\nextern \"C\" ivl_drive_t ivl_logic_drive1(ivl_net_logic_t net)\n{\n      ivl_nexus_t nex = ivl_logic_pin(net, 0);\n\n      for (unsigned idx = 0 ;  idx < ivl_nexus_ptrs(nex) ;  idx += 1) {\n\t    ivl_nexus_ptr_t cur = ivl_nexus_ptr(nex, idx);\n\t    if (ivl_nexus_ptr_log(cur) != net)\n\t\t  continue;\n\t    if (ivl_nexus_ptr_pin(cur) != 0)\n\t\t  continue;\n\t    return ivl_nexus_ptr_drive1(cur);\n      }\n\n      assert(0);\n      return IVL_DR_STRONG;\n}\n\nextern \"C\" const char* ivl_logic_name(ivl_net_logic_t net)\n{\n      assert(net);\n      cerr << \"ANACHRONISM: Call to anachronistic ivl_logic_name.\" << endl;\n      return net->name_;\n}\n\nextern \"C\" const char* ivl_logic_basename(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->name_;\n}\n\nextern \"C\" ivl_scope_t ivl_logic_scope(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->scope_;\n}\n\nextern \"C\" ivl_logic_t ivl_logic_type(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->type_;\n}\n\nextern \"C\" unsigned ivl_logic_pins(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->npins_;\n}\n\nextern \"C\" ivl_nexus_t ivl_logic_pin(ivl_net_logic_t net, unsigned pin)\n{\n      assert(net);\n      assert(pin < net->npins_);\n      return net->pins_[pin];\n}\n\nextern \"C\" ivl_udp_t ivl_logic_udp(ivl_net_logic_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_LO_UDP);\n      assert(net->udp);\n      return net->udp;\n}\n\nextern \"C\" ivl_expr_t ivl_logic_delay(ivl_net_logic_t net, unsigned transition)\n{\n      assert(net);\n      assert(transition < 3);\n      return net->delay[transition];\n}\n\nextern \"C\" unsigned ivl_logic_width(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->width_;\n}\n\nextern \"C\" unsigned ivl_logic_port_buffer(ivl_net_logic_t net)\n{\n      assert(net);\n      return net->is_port_buffer;\n}\n\nextern \"C\" int  ivl_udp_sequ(ivl_udp_t net)\n{\n      assert(net);\n      return net->sequ;\n}\n\nextern \"C\" unsigned ivl_udp_nin(ivl_udp_t net)\n{\n      assert(net);\n      return net->nin;\n}\n\nextern \"C\" char ivl_udp_init(ivl_udp_t net)\n{\n      assert(net);\n      return net->init;\n}\n\nextern \"C\" const char* ivl_udp_port(ivl_udp_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx <= net->nin);\n      assert(net->ports);\n      assert(net->ports[idx].c_str());\n      return net->ports[idx].c_str();\n}\n\nextern \"C\" const char* ivl_udp_row(ivl_udp_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nrows);\n      assert(net->table);\n      assert(net->table[idx]);\n      return net->table[idx];\n}\n\nextern \"C\" unsigned    ivl_udp_rows(ivl_udp_t net)\n{\n      assert(net);\n      return net->nrows;\n}\n\nextern \"C\" const char* ivl_udp_name(ivl_udp_t net)\n{\n      assert(net);\n      assert(net->name);\n      return net->name;\n}\n\nextern \"C\" const char* ivl_udp_file(ivl_udp_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_udp_lineno(ivl_udp_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" const char* ivl_lpm_basename(ivl_lpm_t net)\n{\n      assert(net);\n      return net->name;\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_async_clr(ivl_lpm_t net)\n{\n      assert(net);\n      switch(net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.aclr;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_sync_clr(ivl_lpm_t net)\n{\n      assert(net);\n      switch(net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.sclr;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_expr_t ivl_lpm_delay(ivl_lpm_t net, unsigned transition)\n{\n      assert(net);\n      assert(transition < 3);\n      return net->delay[transition];\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_async_set(ivl_lpm_t net)\n{\n      assert(net);\n      switch(net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.aset;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_sync_set(ivl_lpm_t net)\n{\n      assert(net);\n      switch(net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.sset;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_signal_t ivl_lpm_array(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_ARRAY:\n\t    return net->u_.array.sig;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_lpm_base(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_PART_VP:\n\t  case IVL_LPM_PART_PV:\n\t    return net->u_.part.base;\n\t  case IVL_LPM_SUBSTITUTE:\n\t    return net->u_.substitute.base;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_lpm_negedge(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.negedge_flag;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_clk(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.clk;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_expr_t ivl_lpm_aset_value(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.aset_value;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\nextern \"C\" ivl_expr_t ivl_lpm_sset_value(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.sset_value;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_scope_t ivl_lpm_define(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_UFUNC:\n\t    return net->u_.ufunc.def;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_enable(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.we;\n\t  case IVL_LPM_LATCH:\n\t    return net->u_.latch.e;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" const char* ivl_lpm_file(ivl_lpm_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_lpm_lineno(ivl_lpm_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_data(ivl_lpm_t net, unsigned idx)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_ABS:\n\t  case IVL_LPM_CAST_INT:\n\t  case IVL_LPM_CAST_INT2:\n\t  case IVL_LPM_CAST_REAL:\n\t    assert(idx == 0);\n\t    return net->u_.arith.a;\n\n\t  case IVL_LPM_ADD:\n\t  case IVL_LPM_CMP_EEQ:\n\t  case IVL_LPM_CMP_EQ:\n\t  case IVL_LPM_CMP_EQX:\n\t  case IVL_LPM_CMP_EQZ:\n\t  case IVL_LPM_CMP_GE:\n\t  case IVL_LPM_CMP_GT:\n\t  case IVL_LPM_CMP_NE:\n\t  case IVL_LPM_CMP_NEE:\n\t  case IVL_LPM_CMP_WEQ:\n\t  case IVL_LPM_CMP_WNE:\n\t  case IVL_LPM_DIVIDE:\n\t  case IVL_LPM_MOD:\n\t  case IVL_LPM_MULT:\n\t  case IVL_LPM_POW:\n\t  case IVL_LPM_SUB:\n\t    assert(idx <= 1);\n\t    if (idx == 0)\n\t\t  return net->u_.arith.a;\n\t    else\n\t\t  return net->u_.arith.b;\n\n\t  case IVL_LPM_MUX:\n\t    assert(idx < net->u_.mux.size);\n\t    return net->u_.mux.d[idx];\n\n\t  case IVL_LPM_RE_AND:\n\t  case IVL_LPM_RE_OR:\n\t  case IVL_LPM_RE_XOR:\n\t  case IVL_LPM_RE_NAND:\n\t  case IVL_LPM_RE_NOR:\n\t  case IVL_LPM_RE_XNOR:\n\t  case IVL_LPM_SIGN_EXT:\n\t    assert(idx == 0);\n\t    return net->u_.reduce.a;\n\n\t  case IVL_LPM_SHIFTL:\n\t  case IVL_LPM_SHIFTR:\n\t    assert(idx <= 1);\n\t    if (idx == 0)\n\t\t  return net->u_.shift.d;\n\t    else\n\t\t  return net->u_.shift.s;\n\n\t  case IVL_LPM_FF:\n\t    assert(idx == 0);\n\t    return net->u_.ff.d.pin;\n\t  case IVL_LPM_LATCH:\n\t    assert(idx == 0);\n\t    return net->u_.latch.d.pin;\n\n\t  case IVL_LPM_CONCAT:\n\t  case IVL_LPM_CONCATZ:\n\t    assert(idx < net->u_.concat.inputs);\n\t    return net->u_.concat.pins[idx+1];\n\n\t  case IVL_LPM_PART_VP:\n\t  case IVL_LPM_PART_PV:\n\t    assert(idx <= 1);\n\t    if (idx == 0)\n\t\t  return net->u_.part.a;\n\t    else\n\t\t  return net->u_.part.s;\n\n\t  case IVL_LPM_REPEAT:\n\t    assert(idx == 0);\n\t    return net->u_.repeat.a;\n\n\t  case IVL_LPM_SFUNC:\n\t      // Skip the return port.\n\t    assert(idx < (net->u_.sfunc.ports-1));\n\t    return net->u_.sfunc.pins[idx+1];\n\n\t  case IVL_LPM_SUBSTITUTE:\n\t    assert(idx <= 1);\n\t    if (idx == 0)\n\t\t  return net->u_.substitute.a;\n\t    else\n\t\t  return net->u_.substitute.s;\n\n\t  case IVL_LPM_UFUNC:\n\t      // Skip the return port.\n\t    assert(idx < (net->u_.ufunc.ports-1));\n\t    return net->u_.ufunc.pins[idx+1];\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_datab(ivl_lpm_t net, unsigned idx)\n{\n      cerr << \"ANACHRONISM: Call to anachronistic ivl_lpm_datab.\" << endl;\n      assert(net);\n      switch (net->type) {\n\n\t  case IVL_LPM_ADD:\n\t  case IVL_LPM_CMP_EQ:\n\t  case IVL_LPM_CMP_GE:\n\t  case IVL_LPM_CMP_GT:\n\t  case IVL_LPM_CMP_NE:\n\t  case IVL_LPM_DIVIDE:\n\t  case IVL_LPM_MOD:\n\t  case IVL_LPM_MULT:\n\t  case IVL_LPM_POW:\n\t  case IVL_LPM_SUB:\n\t    assert(idx == 0);\n\t    return net->u_.arith.b;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\n\n/*\n * This function returns the hierarchical name for the LPM device. The\n * name needs to be built up from the scope name and the lpm base\n * name.\n *\n * Anachronism: This function is provided for\n * compatibility. Eventually, it will be removed.\n */\nextern \"C\" const char* ivl_lpm_name(ivl_lpm_t net)\n{\n      assert(net);\n      static char*name_buffer = 0;\n      static unsigned name_size = 0;\n\n      ivl_scope_t scope = ivl_lpm_scope(net);\n      const char*sn = ivl_scope_name(scope);\n\n      unsigned need = strlen(sn) + 1 + strlen(net->name) + 1;\n      if (need > name_size) {\n\t    name_buffer = (char*)realloc(name_buffer, need);\n\t    name_size = need;\n      }\n\n      strcpy(name_buffer, sn);\n      char*tmp = name_buffer + strlen(sn);\n      *tmp++ = '.';\n      strcpy(tmp, net->name);\n      return name_buffer;\n}\n\n\nextern \"C\" ivl_nexus_t ivl_lpm_q(ivl_lpm_t net)\n{\n      assert(net);\n\n      switch (net->type) {\n\t  case IVL_LPM_ABS:\n\t  case IVL_LPM_ADD:\n\t  case IVL_LPM_CAST_INT:\n\t  case IVL_LPM_CAST_INT2:\n\t  case IVL_LPM_CAST_REAL:\n\t  case IVL_LPM_CMP_GE:\n\t  case IVL_LPM_CMP_GT:\n\t  case IVL_LPM_CMP_EQ:\n\t  case IVL_LPM_CMP_NE:\n\t  case IVL_LPM_CMP_EEQ:\n\t  case IVL_LPM_CMP_EQX:\n\t  case IVL_LPM_CMP_EQZ:\n\t  case IVL_LPM_CMP_NEE:\n\t  case IVL_LPM_CMP_WEQ:\n\t  case IVL_LPM_CMP_WNE:\n\t  case IVL_LPM_DIVIDE:\n\t  case IVL_LPM_MOD:\n\t  case IVL_LPM_MULT:\n\t  case IVL_LPM_POW:\n\t  case IVL_LPM_SUB:\n\t    return net->u_.arith.q;\n\n\t  case IVL_LPM_FF:\n\t    return net->u_.ff.q.pin;\n\t  case IVL_LPM_LATCH:\n\t    return net->u_.latch.q.pin;\n\n\t  case IVL_LPM_MUX:\n\t    return net->u_.mux.q;\n\n\t  case IVL_LPM_RE_AND:\n\t  case IVL_LPM_RE_OR:\n\t  case IVL_LPM_RE_XOR:\n\t  case IVL_LPM_RE_NAND:\n\t  case IVL_LPM_RE_NOR:\n\t  case IVL_LPM_RE_XNOR:\n\t  case IVL_LPM_SIGN_EXT:\n\t    return net->u_.reduce.q;\n\n\t  case IVL_LPM_SHIFTL:\n\t  case IVL_LPM_SHIFTR:\n\t    return net->u_.shift.q;\n\n\t  case IVL_LPM_SFUNC:\n\t    return net->u_.sfunc.pins[0];\n\n\t  case IVL_LPM_UFUNC:\n\t    return net->u_.ufunc.pins[0];\n\n\t  case IVL_LPM_CONCAT:\n\t  case IVL_LPM_CONCATZ:\n\t    return net->u_.concat.pins[0];\n\n\t  case IVL_LPM_PART_VP:\n\t  case IVL_LPM_PART_PV:\n\t    return net->u_.part.q;\n\n\t  case IVL_LPM_REPEAT:\n\t    return net->u_.repeat.q;\n\n\t  case IVL_LPM_SUBSTITUTE:\n\t    return net->u_.substitute.q;\n\n\t  case IVL_LPM_ARRAY:\n\t    return net->u_.array.q;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_drive_t ivl_lpm_drive0(ivl_lpm_t net)\n{\n      ivl_nexus_t nex = ivl_lpm_q(net);\n\n      for (unsigned idx = 0 ; idx < ivl_nexus_ptrs(nex) ; idx += 1) {\n\t    ivl_nexus_ptr_t cur = ivl_nexus_ptr(nex, idx);\n\t    if (ivl_nexus_ptr_lpm(cur) != net)\n\t\t  continue;\n\t    if (ivl_nexus_ptr_pin(cur) != 0)\n\t\t  continue;\n\t    return ivl_nexus_ptr_drive0(cur);\n      }\n\n      assert(0);\n      return IVL_DR_STRONG;\n}\n\nextern \"C\" ivl_drive_t ivl_lpm_drive1(ivl_lpm_t net)\n{\n      ivl_nexus_t nex = ivl_lpm_q(net);\n\n      for (unsigned idx = 0 ; idx < ivl_nexus_ptrs(nex) ; idx += 1) {\n\t    ivl_nexus_ptr_t cur = ivl_nexus_ptr(nex, idx);\n\t    if (ivl_nexus_ptr_lpm(cur) != net)\n\t\t  continue;\n\t    if (ivl_nexus_ptr_pin(cur) != 0)\n\t\t  continue;\n\t    return ivl_nexus_ptr_drive1(cur);\n      }\n\n      assert(0);\n      return IVL_DR_STRONG;\n}\n\nextern \"C\" ivl_scope_t ivl_lpm_scope(ivl_lpm_t net)\n{\n      assert(net);\n      return net->scope;\n}\n\nextern \"C\" ivl_nexus_t ivl_lpm_select(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\n\t  case IVL_LPM_MUX:\n\t    return net->u_.mux.s;\n\n\t  case IVL_LPM_ARRAY:\n\t    return net->u_.array.a;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_lpm_selects(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_MUX:\n\t    return net->u_.mux.swid;\n\t  case IVL_LPM_ARRAY:\n\t    return net->u_.array.swid;\n\t  case IVL_LPM_CONCAT:\n\t  case IVL_LPM_CONCATZ:\n\t    cerr << \"error: ivl_lpm_selects() is no longer supported for \"\n\t            \"IVL_LPM_CONCAT, use ivl_lpm_size() instead.\" << endl;\n\t    // fallthrough\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" int ivl_lpm_signed(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_FF:\n\t  case IVL_LPM_MUX:\n\t    return 0;\n\t  case IVL_LPM_ABS:\n\t  case IVL_LPM_ADD:\n\t  case IVL_LPM_CAST_REAL:\n\t  case IVL_LPM_CMP_EEQ:\n\t  case IVL_LPM_CMP_EQ:\n\t  case IVL_LPM_CMP_EQX:\n\t  case IVL_LPM_CMP_EQZ:\n\t  case IVL_LPM_CMP_GE:\n\t  case IVL_LPM_CMP_GT:\n\t  case IVL_LPM_CMP_NE:\n\t  case IVL_LPM_CMP_NEE:\n\t  case IVL_LPM_CMP_WEQ:\n\t  case IVL_LPM_CMP_WNE:\n\t  case IVL_LPM_DIVIDE:\n\t  case IVL_LPM_MOD:\n\t  case IVL_LPM_MULT:\n\t  case IVL_LPM_POW:\n\t  case IVL_LPM_SUB:\n\t  case IVL_LPM_CAST_INT2:\n\t    return net->u_.arith.signed_flag;\n\t  case IVL_LPM_RE_AND:\n\t  case IVL_LPM_RE_OR:\n\t  case IVL_LPM_RE_XOR:\n\t  case IVL_LPM_RE_NAND:\n\t  case IVL_LPM_RE_NOR:\n\t  case IVL_LPM_RE_XNOR:\n\t    return 0;\n\t  case IVL_LPM_SHIFTL:\n\t  case IVL_LPM_SHIFTR:\n\t    return net->u_.shift.signed_flag;\n\t  case IVL_LPM_CAST_INT:\n\t  case IVL_LPM_SIGN_EXT: // Sign extend is always signed.\n\t    return 1;\n\t  case IVL_LPM_SFUNC:\n\t    return 0;\n\t  case IVL_LPM_UFUNC:\n\t    return 0;\n\t  case IVL_LPM_CONCAT: // Concatenations are always unsigned\n\t  case IVL_LPM_CONCATZ: // Concatenations are always unsigned\n\t    return 0;\n\t  case IVL_LPM_PART_VP:\n\t  case IVL_LPM_PART_PV:\n\t    return net->u_.part.signed_flag;\n\t  case IVL_LPM_REPEAT:\n\t  case IVL_LPM_SUBSTITUTE:\n\t    return 0;\n\t  case IVL_LPM_ARRAY: // Array ports take the signedness of the array.\n\t    return net->u_.array.sig->net_type->get_signed()? 1 : 0;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_lpm_size(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_MUX:\n\t    return net->u_.mux.size;\n\t  case IVL_LPM_SFUNC:\n\t    return net->u_.sfunc.ports - 1;\n\t  case IVL_LPM_UFUNC:\n\t    return net->u_.ufunc.ports - 1;\n\t  case IVL_LPM_REPEAT:\n\t    return net->u_.repeat.count;\n\t  case IVL_LPM_CONCAT:\n\t  case IVL_LPM_CONCATZ:\n\t    return net->u_.concat.inputs;\n\t  case IVL_LPM_ABS:\n\t  case IVL_LPM_CAST_INT:\n\t  case IVL_LPM_CAST_INT2:\n\t  case IVL_LPM_CAST_REAL:\n\t  case IVL_LPM_RE_AND:\n\t  case IVL_LPM_RE_OR:\n\t  case IVL_LPM_RE_XOR:\n\t  case IVL_LPM_RE_NAND:\n\t  case IVL_LPM_RE_NOR:\n\t  case IVL_LPM_RE_XNOR:\n\t  case IVL_LPM_SIGN_EXT:\n\t  case IVL_LPM_FF:\n\t    return 1;\n\t  case IVL_LPM_ADD:\n\t  case IVL_LPM_CMP_EEQ:\n\t  case IVL_LPM_CMP_EQ:\n\t  case IVL_LPM_CMP_EQX:\n\t  case IVL_LPM_CMP_EQZ:\n\t  case IVL_LPM_CMP_GE:\n\t  case IVL_LPM_CMP_GT:\n\t  case IVL_LPM_CMP_NE:\n\t  case IVL_LPM_CMP_NEE:\n\t  case IVL_LPM_DIVIDE:\n\t  case IVL_LPM_MOD:\n\t  case IVL_LPM_MULT:\n\t  case IVL_LPM_POW:\n\t  case IVL_LPM_SUB:\n\t  case IVL_LPM_SHIFTL:\n\t  case IVL_LPM_SHIFTR:\n\t  case IVL_LPM_PART_VP:\n\t  case IVL_LPM_PART_PV:\n\t    return 2;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" const char* ivl_lpm_string(ivl_lpm_t net)\n{\n      assert(net);\n      assert(net->type == IVL_LPM_SFUNC);\n      return net->u_.sfunc.fun_name;\n}\n\nextern \"C\" ivl_lpm_type_t ivl_lpm_type(ivl_lpm_t net)\n{\n      assert(net);\n      return net->type;\n}\n\nextern \"C\" unsigned ivl_lpm_width(ivl_lpm_t net)\n{\n      assert(net);\n      return net->width;\n}\n\nextern \"C\" ivl_event_t ivl_lpm_trigger(ivl_lpm_t net)\n{\n      assert(net);\n      switch (net->type) {\n\t  case IVL_LPM_SFUNC:\n\t    return net->u_.sfunc.trigger;\n\t  case IVL_LPM_UFUNC:\n\t    return net->u_.ufunc.trigger;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\n/*\n * Deprecated\n */\nextern \"C\" ivl_expr_t ivl_lval_mux(ivl_lval_t)\n{\n      return 0;\n}\n\nextern \"C\" ivl_expr_t ivl_lval_idx(ivl_lval_t net)\n{\n      assert(net);\n\n      if (net->type_ == IVL_LVAL_ARR)\n\t    return net->idx;\n      return 0x0;\n}\n\nextern \"C\" ivl_expr_t ivl_lval_part_off(ivl_lval_t net)\n{\n      assert(net);\n      return net->loff;\n}\n\nextern \"C\" ivl_select_type_t ivl_lval_sel_type(ivl_lval_t net)\n{\n      assert(net);\n      return net->sel_type;\n}\n\nextern \"C\" unsigned ivl_lval_width(ivl_lval_t net)\n{\n      assert(net);\n      return net->width_;\n}\n\nextern \"C\" int ivl_lval_property_idx(ivl_lval_t net)\n{\n      assert(net);\n      return net->property_idx;\n}\n\nextern \"C\" ivl_signal_t ivl_lval_sig(ivl_lval_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_LVAL_REG:\n\t  case IVL_LVAL_ARR:\n\t    return net->n.sig;\n\t  default:\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_lval_t ivl_lval_nest(ivl_lval_t net)\n{\n      assert(net);\n      if (net->type_ == IVL_LVAL_LVAL)\n\t    return net->n.nest;\n\n      return 0;\n}\n\nextern \"C\" const char* ivl_nature_name(ivl_nature_t net)\n{\n      assert(net);\n      return net->name();\n}\n\n/*\n * The nexus name is rarely needed. (Shouldn't be needed at all!) This\n * function will calculate the name if it is not already calculated.\n */\nextern \"C\" const char* ivl_nexus_name(ivl_nexus_t net)\n{\n      assert(net);\n      if (net->name_ == 0) {\n\t    char tmp[2 * sizeof(net) + 5];\n\t    snprintf(tmp, sizeof tmp, \"n%p\", (void *)net);\n\t    net->name_ = api_strings.add(tmp);\n      }\n      return net->name_;\n}\n\nextern \"C\" void* ivl_nexus_get_private(ivl_nexus_t net)\n{\n      assert(net);\n      return net->private_data;\n}\n\nextern \"C\" void ivl_nexus_set_private(ivl_nexus_t net, void*data)\n{\n      assert(net);\n      net->private_data = data;\n}\n\nextern \"C\" unsigned ivl_nexus_ptrs(ivl_nexus_t net)\n{\n      assert(net);\n      return net->ptrs_.size();\n}\n\nextern \"C\" ivl_nexus_ptr_t ivl_nexus_ptr(ivl_nexus_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->ptrs_.size());\n      return & net->ptrs_[idx];\n}\n\nextern \"C\" ivl_drive_t ivl_nexus_ptr_drive0(ivl_nexus_ptr_t net)\n{\n      assert(net);\n      return (ivl_drive_t)(net->drive0);\n}\n\nextern \"C\" ivl_drive_t ivl_nexus_ptr_drive1(ivl_nexus_ptr_t net)\n{\n      assert(net);\n      return (ivl_drive_t)(net->drive1);\n}\n\nextern \"C\" unsigned ivl_nexus_ptr_pin(ivl_nexus_ptr_t net)\n{\n      assert(net);\n      return net->pin_;\n}\n\nextern \"C\" ivl_branch_t ivl_nexus_ptr_branch(ivl_nexus_ptr_t net)\n{\n      if (net == 0)\n\t    return 0;\n      if (net->type_ != __NEXUS_PTR_BRA)\n\t    return 0;\n      return net->l.bra;\n}\n\nextern \"C\" ivl_net_const_t ivl_nexus_ptr_con(ivl_nexus_ptr_t net)\n{\n      if (net == 0)\n\t    return 0;\n      if (net->type_ != __NEXUS_PTR_CON)\n\t    return 0;\n      return net->l.con;\n}\n\nextern \"C\" ivl_net_logic_t ivl_nexus_ptr_log(ivl_nexus_ptr_t net)\n{\n      if (net == 0)\n\t    return 0;\n      if (net->type_ != __NEXUS_PTR_LOG)\n\t    return 0;\n      return net->l.log;\n}\n\nextern \"C\" ivl_lpm_t ivl_nexus_ptr_lpm(ivl_nexus_ptr_t net)\n{\n      if (net == 0)\n\t    return 0;\n      if (net->type_ != __NEXUS_PTR_LPM)\n\t    return 0;\n      return net->l.lpm;\n}\n\nextern \"C\" ivl_signal_t ivl_nexus_ptr_sig(ivl_nexus_ptr_t net)\n{\n      if (net == 0)\n\t    return 0;\n      if (net->type_ != __NEXUS_PTR_SIG)\n\t    return 0;\n      return net->l.sig;\n}\n\nextern \"C\" ivl_switch_t ivl_nexus_ptr_switch(ivl_nexus_ptr_t net)\n{\n      if (net == 0)\n\t    return 0;\n      if (net->type_ != __NEXUS_PTR_SWI)\n\t    return 0;\n      return net->l.swi;\n}\n\nextern \"C\" const char* ivl_parameter_basename(ivl_parameter_t net)\n{\n      assert(net);\n      return net->basename;\n}\n\nextern \"C\" int ivl_parameter_local(ivl_parameter_t net)\n{\n      assert(net);\n      return net->local;\n}\n\nextern \"C\" int ivl_parameter_is_type(ivl_parameter_t net)\n{\n      assert(net);\n      return net->is_type;\n}\n\nextern \"C\" int ivl_parameter_signed(ivl_parameter_t net)\n{\n      assert(net);\n      return net->signed_flag;\n}\n\nextern \"C\" int ivl_parameter_msb(ivl_parameter_t net)\n{\n      assert(net);\n      return net->msb;\n}\n\nextern \"C\" int ivl_parameter_lsb(ivl_parameter_t net)\n{\n      assert(net);\n      return net->lsb;\n}\n\n/*\n * No need to waste space with storing the width of the parameter since\n * it can easily be computed when needed.\n */\nextern \"C\" unsigned ivl_parameter_width(ivl_parameter_t net)\n{\n      unsigned result = 1;\n      assert(net);\n      if (net->msb >= net->lsb) result += net->msb - net->lsb;\n      else result += net->lsb - net->msb;\n      return result;\n}\n\nextern \"C\" ivl_expr_t ivl_parameter_expr(ivl_parameter_t net)\n{\n      assert(net);\n      return net->value;\n}\n\nextern \"C\" const char* ivl_parameter_file(ivl_parameter_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_parameter_lineno(ivl_parameter_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_scope_t ivl_parameter_scope(ivl_parameter_t net)\n{\n      assert(net);\n      return net->scope;\n}\n\nextern \"C\" ivl_nexus_t ivl_path_condit(ivl_delaypath_t obj)\n{\n      assert(obj);\n      return obj->condit;\n}\n\nextern \"C\" int ivl_path_is_condit(ivl_delaypath_t obj)\n{\n      assert(obj);\n      return obj->conditional ? 1 : 0;\n}\n\nextern \"C\" int ivl_path_is_parallel(ivl_delaypath_t obj)\n{\n      assert(obj);\n      return obj->parallel ? 1 : 0;\n}\n\nextern uint64_t ivl_path_delay(ivl_delaypath_t obj, ivl_path_edge_t edg)\n{\n      assert(obj);\n      return obj->delay[edg];\n}\n\nextern ivl_scope_t ivl_path_scope(ivl_delaypath_t obj)\n{\n      assert(obj);\n      assert(obj->scope);\n      return obj->scope;\n}\n\nextern ivl_nexus_t ivl_path_source(ivl_delaypath_t net)\n{\n      assert(net);\n      return net->src;\n}\n\nextern int ivl_path_source_posedge(ivl_delaypath_t net)\n{\n      assert(net);\n      return net->posedge ? 1 : 0;\n}\n\nextern int ivl_path_source_negedge(ivl_delaypath_t net)\n{\n      assert(net);\n      return net->negedge ? 1 : 0;\n}\n\nextern \"C\" const char*ivl_process_file(ivl_process_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_process_lineno(ivl_process_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_process_type_t ivl_process_type(ivl_process_t net)\n{\n      assert(net);\n      return net->type_;\n}\n\nextern \"C\" int ivl_process_analog(ivl_process_t net)\n{\n      assert(net);\n      return net->analog_flag != 0;\n}\n\nextern \"C\" ivl_scope_t ivl_process_scope(ivl_process_t net)\n{\n      assert(net);\n      return net->scope_;\n}\n\nextern \"C\" ivl_statement_t ivl_process_stmt(ivl_process_t net)\n{\n      assert(net);\n      return net->stmt_;\n}\n\nextern \"C\" unsigned ivl_process_attr_cnt(ivl_process_t net)\n{\n      assert(net);\n      return net->nattr;\n}\n\nextern \"C\" ivl_attribute_t ivl_process_attr_val(ivl_process_t net,\n\t\t\t\t\t\tunsigned idx)\n{\n      assert(net);\n      assert(idx < net->nattr);\n      return net->attr + idx;\n}\n\nextern \"C\" unsigned ivl_scope_attr_cnt(ivl_scope_t net)\n{\n      assert(net);\n      return net->nattr;\n}\n\nextern \"C\" ivl_attribute_t ivl_scope_attr_val(ivl_scope_t net,\n\t\t\t\t\t      unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nattr);\n      return net->attr + idx;\n}\n\nextern \"C\" const char* ivl_scope_basename(ivl_scope_t net)\n{\n      assert(net);\n      return net->name_;\n}\n\nextern \"C\" int ivl_scope_children(ivl_scope_t net,\n\t\t\t\t  ivl_scope_f func,\n\t\t\t\t  void*cd)\n{\n      for (map<hname_t,ivl_scope_t>::iterator cur = net->children.begin()\n\t\t ; cur != net->children.end() ; ++ cur ) {\n\t    int rc = func(cur->second, cd);\n\t    if (rc != 0)\n\t\t  return rc;\n      }\n\n      return 0;\n}\n\nextern \"C\" size_t ivl_scope_childs(ivl_scope_t net)\n{\n      assert(net);\n      assert(net->child.size() == net->children.size());\n      return net->child.size();\n}\n\nextern \"C\" ivl_scope_t ivl_scope_child(ivl_scope_t net, size_t idx)\n{\n      assert(net);\n      assert(idx < net->child.size());\n      return net->child[idx];\n}\n\nextern \"C\" ivl_type_t ivl_scope_class(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->classes.size());\n      return net->classes[idx];\n}\n\nextern \"C\" unsigned ivl_scope_classes(ivl_scope_t net)\n{\n      assert(net);\n      return net->classes.size();\n}\n\n\nextern \"C\" ivl_statement_t ivl_scope_def(ivl_scope_t net)\n{\n      assert(net);\n      return net->def;\n}\n\nextern \"C\" const char*ivl_scope_def_file(ivl_scope_t net)\n{\n      assert(net);\n      return net->def_file.str();\n}\n\nextern \"C\" unsigned ivl_scope_def_lineno(ivl_scope_t net)\n{\n      assert(net);\n      return net->def_lineno;\n}\n\nextern \"C\" unsigned ivl_scope_enumerates(ivl_scope_t net)\n{\n      assert(net);\n      return net->enumerations_.size();\n}\n\nextern \"C\" ivl_enumtype_t ivl_scope_enumerate(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->enumerations_.size());\n      return net->enumerations_[idx];\n}\n\nextern \"C\" unsigned ivl_scope_events(ivl_scope_t net)\n{\n      assert(net);\n      return net->nevent_;\n}\n\nextern \"C\" ivl_event_t ivl_scope_event(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nevent_);\n      return net->event_[idx];\n}\n\nextern \"C\" const char*ivl_scope_file(ivl_scope_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" ivl_variable_type_t ivl_scope_func_type(ivl_scope_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_SCT_FUNCTION);\n      return net->func_type;\n}\n\nextern \"C\" int ivl_scope_func_signed(ivl_scope_t net)\n{\n      assert(net);\n      assert(net->type_==IVL_SCT_FUNCTION);\n      assert(net->func_type==IVL_VT_LOGIC || net->func_type==IVL_VT_BOOL);\n      return net->func_signed? 1 : 0;\n}\n\nextern \"C\" unsigned ivl_scope_func_width(ivl_scope_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_SCT_FUNCTION);\n      assert(net->func_type==IVL_VT_LOGIC || net->func_type==IVL_VT_BOOL);\n      return net->func_width;\n}\n\nextern \"C\" unsigned ivl_scope_is_auto(ivl_scope_t net)\n{\n      assert(net);\n      return net->is_auto;\n}\n\nextern \"C\" unsigned ivl_scope_is_cell(ivl_scope_t net)\n{\n      assert(net);\n      return net->is_cell;\n}\n\nextern \"C\" unsigned ivl_scope_lineno(ivl_scope_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" unsigned ivl_scope_logs(ivl_scope_t net)\n{\n      assert(net);\n      return net->nlog_;\n}\n\nextern \"C\" ivl_net_logic_t ivl_scope_log(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nlog_);\n      return net->log_[idx];\n}\n\nextern \"C\" unsigned ivl_scope_lpms(ivl_scope_t net)\n{\n      assert(net);\n      return net->nlpm_;\n}\n\nextern \"C\" ivl_lpm_t ivl_scope_lpm(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nlpm_);\n      return net->lpm_[idx];\n}\n\nstatic unsigned scope_name_len(ivl_scope_t net)\n{\n      unsigned len = 0;\n\n      for (ivl_scope_t cur = net ;  cur ;  cur = cur->parent)\n\t    len += strlen(cur->name_) + 1;\n\n      return len;\n}\n\nstatic void push_scope_basename(ivl_scope_t net, char*buf)\n{\n      assert(net);\n      if (net->parent == 0) {\n\t    strcpy(buf, net->name_);\n\t    return;\n      }\n\n      push_scope_basename(net->parent, buf);\n      strcat(buf, \".\");\n      strcat(buf, net->name_);\n}\n\nextern \"C\" const char* ivl_scope_name(ivl_scope_t net)\n{\n      assert(net);\n      static char*name_buffer = 0;\n      static unsigned name_size = 0;\n\n      if (net->parent == 0)\n\t    return net->name_;\n\n      unsigned needlen = scope_name_len(net);\n\n      if (name_size < needlen) {\n\t    name_buffer = (char*)realloc(name_buffer, needlen);\n\t    name_size = needlen;\n      }\n\n\n      push_scope_basename(net, name_buffer);\n\n      return name_buffer;\n}\n\nextern \"C\" unsigned ivl_scope_params(ivl_scope_t net)\n{\n      assert(net);\n      return net->param.size();\n}\n\nextern \"C\" ivl_parameter_t ivl_scope_param(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->param.size());\n      return & (net->param[idx]);\n}\n\nextern \"C\" ivl_scope_t ivl_scope_parent(ivl_scope_t net)\n{\n      assert(net);\n      return net->parent;\n}\n\n\nextern \"C\" unsigned ivl_scope_mod_module_ports(ivl_scope_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_SCT_MODULE );\n      return static_cast<unsigned>(net->module_ports_info.size());\n}\n\nextern \"C\" const char *ivl_scope_mod_module_port_name(ivl_scope_t net, unsigned idx )\n{\n      assert(net);\n      assert(net->type_ == IVL_SCT_MODULE );\n      assert(idx < net->module_ports_info.size());\n\n      return net->module_ports_info[idx].name;\n}\n\nextern \"C\" ivl_signal_port_t ivl_scope_mod_module_port_type(ivl_scope_t net, unsigned idx )\n{\n      assert(net);\n      switch( net->module_ports_info[idx].type )\n      {\n      case PortType::PINPUT : return IVL_SIP_INPUT;\n      case PortType::POUTPUT : return IVL_SIP_OUTPUT;\n      case PortType::PINOUT : return IVL_SIP_INOUT;\n      default : return IVL_SIP_NONE;\n      }\n}\n\nextern \"C\" unsigned ivl_scope_mod_module_port_width(ivl_scope_t net, unsigned idx )\n{\n    assert(net);\n    return net->module_ports_info[idx].width;\n}\n\nextern \"C\" ivl_net_logic_t ivl_scope_mod_module_port_buffer(ivl_scope_t net, unsigned idx )\n{\n    assert(net);\n    return (ivl_net_logic_t)net->module_ports_info[idx].buffer;\n}\n\nextern \"C\" unsigned ivl_scope_ports(ivl_scope_t net)\n{\n      assert(net);\n      if (net->type_ == IVL_SCT_MODULE ||\n          net->type_ == IVL_SCT_FUNCTION ||\n          net->type_ == IVL_SCT_TASK) return net->ports;\n      return 0;\n}\n\nextern \"C\" ivl_signal_t ivl_scope_port(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(net->type_ == IVL_SCT_FUNCTION ||\n             net->type_ == IVL_SCT_TASK);\n      assert(idx < net->ports);\n      return net->u_.port[idx];\n}\n\nextern \"C\" ivl_nexus_t ivl_scope_mod_port(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(net->type_ == IVL_SCT_MODULE);\n      assert(idx < net->ports);\n      return net->u_.nex[idx];\n}\n\nextern \"C\" unsigned ivl_scope_sigs(ivl_scope_t net)\n{\n      assert(net);\n      return net->sigs_.size();\n}\n\nextern \"C\" ivl_signal_t ivl_scope_sig(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->sigs_.size());\n      return net->sigs_[idx];\n}\n\nextern \"C\" unsigned ivl_scope_switches(ivl_scope_t net)\n{\n      assert(net);\n      return net->switches.size();\n}\n\nextern \"C\" ivl_switch_t ivl_scope_switch(ivl_scope_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->switches.size());\n      return net->switches[idx];\n}\n\nextern \"C\" int ivl_scope_time_precision(ivl_scope_t net)\n{\n      assert(net);\n      return net->time_precision;\n}\n\nextern \"C\" int ivl_scope_time_units(ivl_scope_t net)\n{\n      assert(net);\n      return net->time_units;\n}\n\nextern \"C\" ivl_scope_type_t ivl_scope_type(ivl_scope_t net)\n{\n      assert(net);\n      return net->type_;\n}\n\nextern \"C\" const char* ivl_scope_tname(ivl_scope_t net)\n{\n      assert(net);\n      return net->tname_;\n}\n\nextern \"C\" int ivl_signal_array_base(ivl_signal_t net)\n{\n      assert(net);\n      return net->array_base;\n}\n\nextern \"C\" unsigned ivl_signal_array_count(ivl_signal_t net)\n{\n      assert(net);\n      return net->array_words;\n}\n\nextern \"C\" unsigned ivl_signal_array_addr_swapped(ivl_signal_t net)\n{\n      assert(net);\n      return net->array_addr_swapped;\n}\n\nextern \"C\" unsigned ivl_signal_dimensions(ivl_signal_t net)\n{\n      assert(net);\n      return net->array_dimensions_;\n}\n\nextern \"C\" ivl_discipline_t ivl_signal_discipline(ivl_signal_t net)\n{\n      assert(net);\n      return net->discipline;\n}\n\nextern \"C\" const char* ivl_signal_attr(ivl_signal_t net, const char*key)\n{\n      assert(net);\n      if (net->nattr == 0)\n\t    return 0;\n\n      for (unsigned idx = 0 ;  idx < net->nattr ;  idx += 1)\n\n\t    if (strcmp(key, net->attr[idx].key) == 0)\n\t\t  return net->attr[idx].type == IVL_ATT_STR\n\t\t\t? net->attr[idx].val.str\n\t\t\t: 0;\n\n      return 0;\n}\n\nextern \"C\" unsigned ivl_signal_attr_cnt(ivl_signal_t net)\n{\n      assert(net);\n      return net->nattr;\n}\n\nextern \"C\" ivl_attribute_t ivl_signal_attr_val(ivl_signal_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->nattr);\n      return net->attr + idx;\n}\n\nextern \"C\" const char* ivl_signal_basename(ivl_signal_t net)\n{\n      assert(net);\n      return net->name_;\n}\n\nextern \"C\" const char* ivl_signal_name(ivl_signal_t net)\n{\n      assert(net);\n      static char*name_buffer = 0;\n      static unsigned name_size = 0;\n\n      unsigned needlen = scope_name_len(net->scope_);\n      needlen += strlen(net->name_) + 2;\n\n      if (name_size < needlen) {\n\t    name_buffer = (char*)realloc(name_buffer, needlen);\n\t    name_size = needlen;\n      }\n\n      push_scope_basename(net->scope_, name_buffer);\n      strcat(name_buffer, \".\");\n      strcat(name_buffer, net->name_);\n\n      return name_buffer;\n}\n\nextern \"C\" ivl_nexus_t ivl_signal_nex(ivl_signal_t net, unsigned word)\n{\n      assert(net);\n      assert(word < net->array_words);\n      if (net->array_words > 1) {\n\t    if (net->pins) {\n\t\treturn net->pins[word];\n\t    } else {\n\t\t// net->pins can be NULL for a virtualized reg array.\n\t\tassert(net->type_ == IVL_SIT_REG);\n\t\treturn NULL;\n\t    }\n      } else {\n\t    return net->pin;\n      }\n}\n\nextern \"C\" unsigned ivl_signal_packed_dimensions(ivl_signal_t net)\n{\n      assert(net);\n      return net->packed_dims.size();\n}\n\nextern \"C\" int ivl_signal_packed_msb(ivl_signal_t net, unsigned dim)\n{\n      assert(net);\n      assert(dim < net->packed_dims.size());\n      return net->packed_dims[dim].get_msb();\n}\n\nextern \"C\" int ivl_signal_packed_lsb(ivl_signal_t net, unsigned dim)\n{\n      assert(net);\n      assert(dim < net->packed_dims.size());\n      return net->packed_dims[dim].get_lsb();\n}\n\nextern \"C\" int ivl_signal_msb(ivl_signal_t net)\n{\n      assert(net);\n      if (net->packed_dims.empty())\n\t    return 0;\n\n      assert(net->packed_dims.size() == 1);\n      return net->packed_dims[0].get_msb();\n}\n\nextern \"C\" int ivl_signal_lsb(ivl_signal_t net)\n{\n      assert(net);\n      if (net->packed_dims.empty())\n\t    return 0;\n\n      assert(net->packed_dims.size() == 1);\n      return net->packed_dims[0].get_lsb();\n}\n\nextern \"C\" ivl_scope_t ivl_signal_scope(ivl_signal_t net)\n{\n      assert(net);\n      return net->scope_;\n}\n\nextern \"C\" unsigned ivl_signal_width(ivl_signal_t net)\n{\n      assert(net);\n      assert(net->net_type);\n      return net->net_type->packed_width();\n}\n\nextern \"C\" ivl_signal_port_t ivl_signal_port(ivl_signal_t net)\n{\n      assert(net);\n      return net->port_;\n}\n\nextern \"C\" int ivl_signal_module_port_index(ivl_signal_t net)\n{\n      assert(net);\n      return net->module_port_index_;\n}\n\nextern \"C\" int ivl_signal_local(ivl_signal_t net)\n{\n      assert(net);\n      return net->local_;\n}\n\nextern \"C\" int ivl_signal_signed(ivl_signal_t net)\n{\n      assert(net);\n      assert(net->net_type);\n      return net->net_type->get_signed()? 1 : 0;\n}\n\nextern \"C\" unsigned ivl_signal_forced_net(ivl_signal_t net)\n{\n      assert(net);\n      return net->forced_net_;\n}\n\nextern \"C\" const char* ivl_signal_file(ivl_signal_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_signal_lineno(ivl_signal_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" int ivl_signal_integer(ivl_signal_t net)\n{\n      assert(net);\n      if (const netvector_t*vec = dynamic_cast<const netvector_t*> (net->net_type))\n\t    return vec->get_isint()? 1 : 0;\n      else if (const netenum_t*enm = dynamic_cast<const netenum_t*> (net->net_type))\n\t    return enm->get_isint()? 1 : 0;\n      else\n\t    return 0;\n}\n\nextern \"C\" ivl_variable_type_t ivl_signal_data_type(ivl_signal_t net)\n{\n      assert(net);\n      assert(net->net_type);\n      return net->net_type->base_type();\n}\n\nextern \"C\" ivl_type_t ivl_signal_net_type(ivl_signal_t net)\n{\n      assert(net);\n      return net->net_type;\n}\n\nextern \"C\" unsigned ivl_signal_npath(ivl_signal_t net)\n{\n      assert(net);\n      return net->npath;\n}\n\nextern \"C\" ivl_delaypath_t ivl_signal_path(ivl_signal_t net, unsigned idx)\n{\n      assert(net);\n      assert(idx < net->npath);\n      return net->path + idx;\n}\n\nextern \"C\" ivl_signal_type_t ivl_signal_type(ivl_signal_t net)\n{\n      assert(net);\n      return net->type_;\n}\n\nextern \"C\" ivl_statement_type_t ivl_statement_type(ivl_statement_t net)\n{\n      assert(net);\n      return net->type_;\n}\n\nextern \"C\" const char* ivl_stmt_file(ivl_statement_t net)\n{\n      assert(net);\n      return net->file.str();\n}\n\nextern \"C\" unsigned ivl_stmt_lineno(ivl_statement_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_scope_t ivl_stmt_block_scope(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_BLOCK:\n\t  case IVL_ST_FORK:\n\t  case IVL_ST_FORK_JOIN_ANY:\n\t  case IVL_ST_FORK_JOIN_NONE:\n\t    return net->u_.block_.scope;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_stmt_block_count(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_BLOCK:\n\t  case IVL_ST_FORK:\n\t  case IVL_ST_FORK_JOIN_ANY:\n\t  case IVL_ST_FORK_JOIN_NONE:\n\t    return net->u_.block_.nstmt_;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_statement_t ivl_stmt_block_stmt(ivl_statement_t net,\n\t\t\t\t\t       unsigned i)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_BLOCK:\n\t  case IVL_ST_FORK:\n\t  case IVL_ST_FORK_JOIN_ANY:\n\t  case IVL_ST_FORK_JOIN_NONE:\n\t    return net->u_.block_.stmt_ + i;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_scope_t ivl_stmt_call(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ALLOC:\n\t    return net->u_.alloc_.scope;\n\n\t  case IVL_ST_DISABLE:\n\t    return net->u_.disable_.scope;\n\n\t  case IVL_ST_FREE:\n\t    return net->u_.free_.scope;\n\n\t  case IVL_ST_UTASK:\n\t    return net->u_.utask_.def;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" bool ivl_stmt_flow_control(ivl_statement_t net)\n{\n      return net->u_.disable_.flow_control;\n}\n\nextern \"C\" unsigned ivl_stmt_case_count(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_CASE:\n\t  case IVL_ST_CASER:\n\t  case IVL_ST_CASEX:\n\t  case IVL_ST_CASEZ:\n\t    return net->u_.case_.ncase;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_expr_t ivl_stmt_case_expr(ivl_statement_t net, unsigned idx)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_CASE:\n\t  case IVL_ST_CASER:\n\t  case IVL_ST_CASEX:\n\t  case IVL_ST_CASEZ:\n\t    assert(idx < net->u_.case_.ncase);\n\t    return net->u_.case_.case_ex[idx];\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_case_quality_t ivl_stmt_case_quality(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_CASE:\n\t  case IVL_ST_CASER:\n\t  case IVL_ST_CASEX:\n\t  case IVL_ST_CASEZ:\n\t    return net->u_.case_.quality;\n\n\t  default:\n\t    assert(0);\n\t    return IVL_CASE_QUALITY_BASIC;\n      }\n}\n\nextern \"C\" ivl_statement_t ivl_stmt_case_stmt(ivl_statement_t net, unsigned idx)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_CASE:\n\t  case IVL_ST_CASER:\n\t  case IVL_ST_CASEX:\n\t  case IVL_ST_CASEZ:\n\t    assert(idx < net->u_.case_.ncase);\n\t    return net->u_.case_.case_st + idx;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_expr_t ivl_stmt_cond_expr(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN_NB:\n\t    return net->u_.assign_.count;\n\n\t  case IVL_ST_CONDIT:\n\t    return net->u_.condit_.cond_;\n\n\t  case IVL_ST_CASE:\n\t  case IVL_ST_CASER:\n\t  case IVL_ST_CASEX:\n\t  case IVL_ST_CASEZ:\n\t    return net->u_.case_.cond;\n\n\t  case IVL_ST_DO_WHILE:\n\t  case IVL_ST_REPEAT:\n\t  case IVL_ST_WHILE:\n\t    return net->u_.while_.cond_;\n\n\t  case IVL_ST_FORLOOP:\n\t    return net->u_.forloop_.condition;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_statement_t ivl_stmt_cond_false(ivl_statement_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_ST_CONDIT);\n      if (net->u_.condit_.stmt_[1].type_ == IVL_ST_NONE)\n\t    return 0;\n      else\n\t    return net->u_.condit_.stmt_ + 1;\n}\n\nextern \"C\" ivl_statement_t ivl_stmt_cond_true(ivl_statement_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_ST_CONDIT);\n      if (net->u_.condit_.stmt_[0].type_ == IVL_ST_NONE)\n\t    return 0;\n      else\n\t    return net->u_.condit_.stmt_ + 0;\n}\n\nextern \"C\" ivl_expr_t ivl_stmt_delay_expr(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN:\n\t  case IVL_ST_ASSIGN_NB:\n\t    return net->u_.assign_.delay;\n\n\t  case IVL_ST_DELAYX:\n\t    return net->u_.delayx_.expr;\n\n\t  case IVL_ST_NB_TRIGGER:\n\t    return net->u_.wait_.delay;\n\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" uint64_t ivl_stmt_delay_val(ivl_statement_t net)\n{\n      assert(net);\n      assert(net->type_ == IVL_ST_DELAY);\n      return net->u_.delay_.value;\n}\n\nextern \"C\" ivl_statement_t ivl_stmt_init_stmt(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_FORLOOP:\n\t    return net->u_.forloop_.init_stmt;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_stmt_needs_t0_trigger(ivl_statement_t net)\n{\n      assert(net);\n      if (net->type_ == IVL_ST_WAIT) {\n\t    return net->u_.wait_.needs_t0_trigger;\n      } else {\n\t    return 0;\n      }\n}\n\nextern \"C\" unsigned ivl_stmt_nevent(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN_NB:\n\t    return net->u_.assign_.nevent;\n\n\t  case IVL_ST_NB_TRIGGER:\n\t    return 1;\n\n\t  case IVL_ST_TRIGGER:\n\t    return 1;\n\n\t  case IVL_ST_WAIT:\n\t    return net->u_.wait_.nevent;\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_event_t ivl_stmt_events(ivl_statement_t net, unsigned idx)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN_NB:\n\t    assert(idx < net->u_.assign_.nevent);\n\t    if (net->u_.assign_.nevent == 1)\n\t\t  return net->u_.assign_.event;\n\t    else\n\t\t  return net->u_.assign_.events[idx];\n\n\t  case IVL_ST_NB_TRIGGER:\n\t    assert(idx == 0);\n\t    return net->u_.wait_.event;\n\n\t  case IVL_ST_TRIGGER:\n\t    assert(idx == 0);\n\t    return net->u_.wait_.event;\n\n\t  case IVL_ST_WAIT:\n\t    assert(idx < net->u_.wait_.nevent);\n\t    if (net->u_.wait_.nevent == 1)\n\t\t  return net->u_.wait_.event;\n\t    else\n\t\t  return net->u_.wait_.events[idx];\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_expr_t ivl_stmt_lexp(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_CONTRIB:\n\t    return net->u_.contrib_.lval;\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_lval_t ivl_stmt_lval(ivl_statement_t net, unsigned idx)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN:\n\t  case IVL_ST_ASSIGN_NB:\n\t  case IVL_ST_CASSIGN:\n\t  case IVL_ST_DEASSIGN:\n\t  case IVL_ST_FORCE:\n\t  case IVL_ST_RELEASE:\n\t    assert(idx < net->u_.assign_.lvals_);\n\t    return net->u_.assign_.lval_ + idx;\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" unsigned ivl_stmt_lvals(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN:\n\t  case IVL_ST_ASSIGN_NB:\n\t  case IVL_ST_CASSIGN:\n\t  case IVL_ST_DEASSIGN:\n\t  case IVL_ST_FORCE:\n\t  case IVL_ST_RELEASE:\n\t    return net->u_.assign_.lvals_;\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" unsigned ivl_stmt_lwidth(ivl_statement_t net)\n{\n      assert(net);\n      assert((net->type_ == IVL_ST_ASSIGN)\n\t     || (net->type_ == IVL_ST_ASSIGN_NB)\n\t     || (net->type_ == IVL_ST_CASSIGN)\n\t     || (net->type_ == IVL_ST_DEASSIGN)\n\t     || (net->type_ == IVL_ST_FORCE)\n\t     || (net->type_ == IVL_ST_RELEASE));\n\n      unsigned sum = 0;\n\n      unsigned nlvals;\n      struct ivl_lval_s*lvals;\n      nlvals = net->u_.assign_.lvals_;\n      lvals  = net->u_.assign_.lval_;\n\n      for (unsigned idx = 0 ;  idx < nlvals ;  idx += 1) {\n\t    ivl_lval_t cur = lvals + idx;\n\t    switch(cur->type_) {\n\t\tcase IVL_LVAL_REG:\n\t\tcase IVL_LVAL_ARR:\n\t\tcase IVL_LVAL_LVAL:\n\t\t  sum += ivl_lval_width(cur);\n\t\t  break;\n\t\tdefault:\n\t\t  assert(0);\n\t    }\n      }\n\n      return sum;\n}\n\nextern \"C\" const char* ivl_stmt_name(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_STASK:\n\t    return net->u_.stask_.name_;\n\t  default:\n\t    assert(0);\n      }\n\n      return 0;\n}\n\nextern \"C\" char ivl_stmt_opcode(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN:\n\t    return net->u_.assign_.oper;\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_expr_t ivl_stmt_parm(ivl_statement_t net, unsigned idx)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_STASK:\n\t    assert(idx < net->u_.stask_.nparm_);\n\t    return net->u_.stask_.parms_[idx];\n\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" unsigned ivl_stmt_parm_count(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_STASK:\n\t    return net->u_.stask_.nparm_;\n\t  default:\n\t    assert(0);\n      }\n      return 0;\n}\n\nextern \"C\" ivl_expr_t ivl_stmt_rval(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_ASSIGN:\n\t  case IVL_ST_ASSIGN_NB:\n\t  case IVL_ST_CASSIGN:\n\t  case IVL_ST_FORCE:\n\t    return net->u_.assign_.rval_;\n\t  case IVL_ST_CONTRIB:\n\t    return net->u_.contrib_.rval;\n\t  default:\n\t    assert(0);\n      }\n\n      return 0;\n}\n\nextern \"C\" ivl_sfunc_as_task_t ivl_stmt_sfunc_as_task(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_STASK:\n\t    return net->u_.stask_.sfunc_as_task_;\n\t  default:\n\t    assert(0);\n      }\n\n      return IVL_SFUNC_AS_TASK_ERROR;\n}\n\nextern \"C\" ivl_statement_t ivl_stmt_step_stmt(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_FORLOOP:\n\t    return net->u_.forloop_.step;\n\t  default:\n\t    assert(0);\n\t    return 0;\n      }\n}\n\nextern \"C\" ivl_statement_t ivl_stmt_sub_stmt(ivl_statement_t net)\n{\n      assert(net);\n      switch (net->type_) {\n\t  case IVL_ST_DELAY:\n\t    return net->u_.delay_.stmt_;\n\t  case IVL_ST_DELAYX:\n\t    return net->u_.delayx_.stmt_;\n\t  case IVL_ST_FOREVER:\n\t    return net->u_.forever_.stmt_;\n\t  case IVL_ST_FORLOOP:\n\t    return net->u_.forloop_.stmt;\n\t  case IVL_ST_WAIT:\n\t    return net->u_.wait_.stmt_;\n\t  case IVL_ST_DO_WHILE:\n\t  case IVL_ST_REPEAT:\n\t  case IVL_ST_WHILE:\n\t    return net->u_.while_.stmt_;\n\t  default:\n\t    assert(0);\n      }\n\n      return 0;\n}\n\nextern \"C\" const char*ivl_switch_basename(ivl_switch_t net)\n{\n      assert(net);\n      return net->name;\n}\n\nextern \"C\" ivl_scope_t ivl_switch_scope(ivl_switch_t net)\n{\n      assert(net);\n      return net->scope;\n}\n\nextern \"C\" ivl_switch_type_t ivl_switch_type(ivl_switch_t net)\n{\n      assert(net);\n      return net->type;\n}\n\nextern \"C\" ivl_nexus_t ivl_switch_a(ivl_switch_t net)\n{\n      assert(net);\n      return net->pins[0];\n}\n\nextern \"C\" ivl_nexus_t ivl_switch_b(ivl_switch_t net)\n{\n      assert(net);\n      return net->pins[1];\n}\n\nextern \"C\" ivl_nexus_t ivl_switch_enable(ivl_switch_t net)\n{\n      assert(net);\n      return net->pins[2];\n}\n\nextern \"C\" unsigned ivl_switch_width(ivl_switch_t net)\n{\n      assert(net);\n      return net->width;\n}\n\nextern \"C\" unsigned ivl_switch_part(ivl_switch_t net)\n{\n      assert(net);\n      return net->part;\n}\n\nextern \"C\" unsigned ivl_switch_offset(ivl_switch_t net)\n{\n      assert(net);\n      return net->offset;\n}\n\nextern \"C\" ivl_expr_t ivl_switch_delay(ivl_switch_t net, unsigned transition)\n{\n      assert(net);\n      assert(transition < 3);\n      return net->delay[transition];\n}\n\nextern \"C\" const char* ivl_switch_file(ivl_switch_t net)\n{\n      assert(net);\n      return net->file;\n}\n\nextern \"C\" ivl_island_t ivl_switch_island(ivl_switch_t net)\n{\n      assert(net);\n      return net->island;\n}\n\nextern \"C\" unsigned ivl_switch_lineno(ivl_switch_t net)\n{\n      assert(net);\n      return net->lineno;\n}\n\nextern \"C\" ivl_variable_type_t ivl_type_base(ivl_type_t net)\n{\n      if (net == 0) return IVL_VT_NO_TYPE;\n      else return net->base_type();\n}\n\nextern \"C\" ivl_type_t ivl_type_element(ivl_type_t net)\n{\n      if (const netarray_t*da = dynamic_cast<const netarray_t*> (net))\n\t    return da->element_type();\n\n      assert(0);\n      return 0;\n}\n\nextern \"C\" unsigned ivl_type_packed_width(ivl_type_t net)\n{\n      return net->packed_width();\n}\n\nextern \"C\" unsigned ivl_type_packed_dimensions(ivl_type_t net)\n{\n      assert(net);\n      netranges_t slice = net->slice_dimensions();\n      return slice.size();\n}\n\nextern \"C\" int ivl_type_packed_lsb(ivl_type_t net, unsigned dim)\n{\n      assert(net);\n      netranges_t slice = net->slice_dimensions();\n      assert(dim < slice.size());\n      return slice[dim].get_lsb();\n}\n\nextern \"C\" int ivl_type_packed_msb(ivl_type_t net, unsigned dim)\n{\n      assert(net);\n      netranges_t slice = net->slice_dimensions();\n      assert(dim < slice.size());\n      return slice[dim].get_msb();\n}\n\nextern \"C\" const char* ivl_type_name(ivl_type_t net)\n{\n      if (const netclass_t*class_type = dynamic_cast<const netclass_t*>(net))\n\t    return class_type->get_name();\n\n      return 0;\n}\n\nextern \"C\" int ivl_type_properties(ivl_type_t net)\n{\n      const netclass_t*class_type = dynamic_cast<const netclass_t*>(net);\n      assert(class_type);\n\n      return class_type->get_properties();\n}\n\nextern \"C\" const char* ivl_type_prop_name(ivl_type_t net, int idx)\n{\n      if (idx < 0) return 0;\n      const netclass_t*class_type = dynamic_cast<const netclass_t*>(net);\n      assert(class_type);\n\n      return class_type->get_prop_name(idx);\n}\n\nextern \"C\" ivl_type_t ivl_type_prop_type(ivl_type_t net, int idx)\n{\n      const netclass_t*class_type = dynamic_cast<const netclass_t*>(net);\n      assert(class_type);\n\n      return class_type->get_prop_type(idx);\n}\n\nextern \"C\" int ivl_type_signed(ivl_type_t net)\n{\n      assert(net);\n      return net->get_signed()? 1 : 0;\n}\n"
        },
        {
          "name": "t-dll-expr.cc",
          "type": "blob",
          "size": 19.5322265625,
          "content": "/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  <cstring>\n# include  \"t-dll.h\"\n# include  \"netlist.h\"\n# include  \"netclass.h\"\n# include  <cassert>\n# include  <cstdlib>\n# include  \"ivl_alloc.h\"\n# include  \"ivl_assert.h\"\n\nusing namespace std;\n\n/*\n * This is a little convenience function for converting a NetExpr\n * expression type to the expression type used by ivl_expr_t objects.\n */\nstatic ivl_variable_type_t get_expr_type(const NetExpr*net)\n{\n      return net->expr_type();\n}\n\n/*\n * These methods implement the expression scan that generates the\n * ivl_expr_t representing the expression. Each method leaves the\n * expr_ member filled with the ivl_expr_t that represents it. Each\n * method expects that the expr_ member empty (0) when it starts.\n */\n\n/*\n * This function takes an expression in the expr_ member that is\n * already built up, and adds a subtraction of the given constant.\n */\nvoid dll_target::sub_off_from_expr_(long off)\n{\n      assert(expr_ != 0);\n\n      char*bits;\n      ivl_expr_t tmpc = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      tmpc->type_   = IVL_EX_NUMBER;\n      tmpc->value_  = IVL_VT_VECTOR;\n      tmpc->net_type= 0;\n      tmpc->width_  = expr_->width_;\n      tmpc->signed_ = expr_->signed_;\n      tmpc->sized_  = 1;\n      tmpc->u_.number_.bits_ = bits = (char*)malloc(tmpc->width_);\n      for (unsigned idx = 0 ;  idx < tmpc->width_ ;  idx += 1) {\n\t    bits[idx] = (off & 1)? '1' : '0';\n\t    off >>= 1;\n      }\n\n\t/* Now make the subtracter (x-4 in the above example)\n\t   that has as input A the index expression and input B\n\t   the constant to subtract. */\n      ivl_expr_t tmps = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      tmps->type_  = IVL_EX_BINARY;\n      tmps->value_ = IVL_VT_VECTOR;\n      tmps->net_type= 0;\n      tmps->width_ = tmpc->width_;\n      tmps->signed_ = tmpc->signed_;\n      tmps->sized_ = 1;\n      tmps->u_.binary_.op_  = '-';\n      tmps->u_.binary_.lef_ = expr_;\n      tmps->u_.binary_.rig_ = tmpc;\n\n\t/* Replace (x) with (x-off) */\n      expr_ = tmps;\n}\n\nvoid dll_target::mul_expr_by_const_(long val)\n{\n      assert(expr_ != 0);\n\n      char*bits;\n      ivl_expr_t tmpc = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      tmpc->type_   = IVL_EX_NUMBER;\n      tmpc->value_  = IVL_VT_VECTOR;\n      tmpc->net_type= 0;\n      tmpc->width_  = expr_->width_;\n      tmpc->signed_ = expr_->signed_;\n      tmpc->sized_  = 1;\n      tmpc->u_.number_.bits_ = bits = (char*)malloc(tmpc->width_);\n      for (unsigned idx = 0 ;  idx < tmpc->width_ ;  idx += 1) {\n\t    bits[idx] = (val & 1)? '1' : '0';\n\t    val >>= 1;\n      }\n\n\t/* Now make the subtracter (x-4 in the above example)\n\t   that has as input A the index expression and input B\n\t   the constant to subtract. */\n      ivl_expr_t tmps = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      tmps->type_  = IVL_EX_BINARY;\n      tmps->value_ = IVL_VT_VECTOR;\n      tmpc->net_type= 0;\n      tmps->width_ = tmpc->width_;\n      tmps->signed_ = tmpc->signed_;\n      tmps->sized_ = 1;\n      tmps->u_.binary_.op_  = '*';\n      tmps->u_.binary_.lef_ = expr_;\n      tmps->u_.binary_.rig_ = tmpc;\n\n\t/* Replace (x) with (x*valf) */\n      expr_ = tmps;\n}\n\nivl_expr_t dll_target::expr_from_value_(const verinum&val)\n{\n      ivl_expr_t expr = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      unsigned idx;\n      char*bits;\n      expr->type_ = IVL_EX_NUMBER;\n      expr->value_= IVL_VT_VECTOR;\n      expr->net_type=0;\n      expr->width_= val.len();\n      expr->signed_ = val.has_sign()? 1 : 0;\n      expr->sized_= 1;\n      expr->u_.number_.bits_ = bits = (char*)malloc(expr->width_ + 1);\n      for (idx = 0 ;  idx < expr->width_ ;  idx += 1)\n\t    switch (val.get(idx)) {\n\t\tcase verinum::V0:\n\t\t  bits[idx] = '0';\n\t\t  break;\n\t\tcase verinum::V1:\n\t\t  bits[idx] = '1';\n\t\t  break;\n\t\tcase verinum::Vx:\n\t\t  bits[idx] = 'x';\n\t\t  break;\n\t\tcase verinum::Vz:\n\t\t  bits[idx] = 'z';\n\t\t  break;\n\t\tdefault:\n\t\t  assert(0);\n\t    }\n\n      bits[expr->width_] = 0;\n\n      return expr;\n}\n\nvoid dll_target::expr_access_func(const NetEAccess*net)\n{\n      assert(expr_ == 0);\n\t// Make a stub Branch Access Function expression node.\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->type_  = IVL_EX_BACCESS;\n      expr_->value_ = IVL_VT_REAL;\n      expr_->net_type=0;\n      expr_->width_ = 1;\n      expr_->signed_= 1;\n      expr_->sized_ = 1;\n      FILE_NAME(expr_, net);\n\n      expr_->u_.branch_.branch = net->get_branch()->target_obj();\n      expr_->u_.branch_.nature = net->get_nature();\n}\n\nvoid dll_target::expr_array_pattern(const NetEArrayPattern*net)\n{\n      assert(expr_ == 0);\n      ivl_expr_t expr_tmp = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_tmp->type_ = IVL_EX_ARRAY_PATTERN;\n      expr_tmp->value_= net->expr_type();\n      expr_tmp->net_type = net->net_type();\n      expr_tmp->width_   = 1;\n      expr_tmp->signed_  = 0;\n      expr_tmp->sized_   = 0;\n      FILE_NAME(expr_tmp, net);\n\n      expr_tmp->u_.array_pattern_.parms = net->item_size();\n      expr_tmp->u_.array_pattern_.parm = new ivl_expr_t [net->item_size()];\n\n      for (size_t idx = 0 ; idx < net->item_size() ; idx += 1) {\n\t    const NetExpr*tmp = net->item(idx);\n\t    tmp->expr_scan(this);\n\t    expr_tmp->u_.array_pattern_.parm[idx] = expr_;\n\t    expr_ = 0;\n      }\n\n      expr_ = expr_tmp;\n}\n\nvoid dll_target::expr_binary(const NetEBinary*net)\n{\n      assert(expr_ == 0);\n\n      net->left()->expr_scan(this);\n      ivl_expr_t left = expr_;\n\n      expr_ = 0;\n      net->right()->expr_scan(this);\n      ivl_expr_t rght = expr_;\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr_->type_ = IVL_EX_BINARY;\n      expr_->value_= get_expr_type(net);\n      expr_->net_type=0;\n      expr_->width_= net->expr_width();\n      expr_->signed_ = net->has_sign()? 1 : 0;\n      expr_->sized_= 1;\n      FILE_NAME(expr_, net);\n\n      expr_->u_.binary_.op_ = net->op();\n      expr_->u_.binary_.lef_ = left;\n      expr_->u_.binary_.rig_ = rght;\n}\n\nvoid dll_target::expr_concat(const NetEConcat*net)\n{\n      assert(expr_ == 0);\n\n      ivl_expr_t cur = new struct ivl_expr_s;\n      assert(cur);\n\n      cur->type_  = IVL_EX_CONCAT;\n      cur->value_ = net->expr_type();\n      cur->net_type=0;\n      cur->width_ = net->expr_width();\n      cur->signed_ = net->has_sign() ? 1 : 0;\n      cur->sized_ = 1;\n      FILE_NAME(cur, net);\n\n      cur->u_.concat_.rept  = net->repeat();\n      cur->u_.concat_.parms = net->nparms();\n      cur->u_.concat_.parm  = new ivl_expr_t [net->nparms()];\n\n      for (unsigned idx = 0 ;  idx < net->nparms() ;  idx += 1) {\n\t    expr_ = 0;\n\t    net->parm(idx)->expr_scan(this);\n\t    assert(expr_);\n\t    cur->u_.concat_.parm[idx] = expr_;\n      }\n\n      expr_ = cur;\n}\n\nvoid dll_target::expr_const(const NetEConst*net)\n{\n      assert(expr_ == 0);\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->value_= net->expr_type();\n      expr_->net_type=0;\n      FILE_NAME(expr_, net);\n\n      if (net->value().is_string()) {\n\t    expr_->type_ = IVL_EX_STRING;\n\t    expr_->width_= net->expr_width();\n\t    expr_->u_.string_.value_ =strdup(net->value().as_string().c_str());\n\n      } else {\n\t    verinum val = net->value();\n\t    unsigned idx;\n\t    char*bits;\n\t    expr_->type_ = IVL_EX_NUMBER;\n\t    expr_->width_= net->expr_width();\n\t    expr_->signed_ = net->has_sign()? 1 : 0;\n\t    expr_->sized_= net->has_width()? 1 : 0;\n\t    expr_->u_.number_.bits_ = bits = (char*)malloc(expr_->width_);\n\t    for (idx = 0 ;  idx < expr_->width_ ;  idx += 1)\n\t\t  switch (val.get(idx)) {\n\t\t      case verinum::V0:\n\t\t\tbits[idx] = '0';\n\t\t\tbreak;\n\t\t      case verinum::V1:\n\t\t\tbits[idx] = '1';\n\t\t\tbreak;\n\t\t      case verinum::Vx:\n\t\t\tbits[idx] = 'x';\n\t\t\tbreak;\n\t\t      case verinum::Vz:\n\t\t\tbits[idx] = 'z';\n\t\t\tbreak;\n\t\t      default:\n\t\t\tassert(0);\n\t\t  }\n\n      }\n}\n\nvoid dll_target::expr_param(const NetEConstParam*net)\n{\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      ivl_parameter_t par = scope_find_param(scop, net->name());\n\n      if (par == 0) {\n\t    cerr << net->get_fileline() << \": internal error: \"\n\t\t << \"Parameter \" << net->name() << \" missing from \"\n\t\t << ivl_scope_name(scop) << endl;\n      }\n      assert(par);\n      expr_const(net);\n      expr_->u_.string_.parameter = par;\n}\n\nvoid dll_target::expr_rparam(const NetECRealParam*net)\n{\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      ivl_parameter_t par = scope_find_param(scop, net->name());\n\n      if (par == 0) {\n\t    cerr << net->get_fileline() << \": internal error: \"\n\t\t << \"Parameter \" << net->name() << \" missing from \"\n\t\t << ivl_scope_name(scop) << endl;\n      }\n      assert(par);\n      assert(par->value);\n      expr_ = par->value;\n}\n\nvoid dll_target::expr_creal(const NetECReal*net)\n{\n      assert(expr_ == 0);\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->width_  = net->expr_width();\n      expr_->signed_ = 1;\n      expr_->sized_  = 1;\n      expr_->type_ = IVL_EX_REALNUM;\n      FILE_NAME(expr_, net);\n      expr_->value_= IVL_VT_REAL;\n      expr_->net_type=0;\n      expr_->u_.real_.value = net->value().as_double();\n}\n\nvoid dll_target::expr_last(const NetELast*net)\n{\n      assert(expr_ == 0);\n      ivl_expr_t expr = new struct ivl_expr_s;\n      expr->type_   = IVL_EX_SFUNC;\n      expr->value_  = IVL_VT_LOGIC;\n      expr->width_  = 32;\n      expr->signed_ = 1;\n      expr->sized_  = 1;\n      expr->net_type  = 0;\n      FILE_NAME(expr, net);\n\n      expr->u_.sfunc_.name_ = \"$high\";\n\n      ivl_signal_t sig = find_signal(des_, net->sig());\n\n      ivl_expr_t esig = new struct ivl_expr_s;\n      esig->type_   = IVL_EX_SIGNAL;\n      esig->value_  = IVL_VT_DARRAY;\n      esig->net_type= sig->net_type;\n      esig->width_  = 1;\n      esig->signed_ = sig->net_type->get_signed()? 1 : 0;\n      FILE_NAME(esig, net);\n      esig->u_.signal_.word = 0;\n      esig->u_.signal_.sig = sig;\n\n      expr->u_.sfunc_.parms = 1;\n      expr->u_.sfunc_.parm = new ivl_expr_t[1];\n      expr->u_.sfunc_.parm[0] = esig;\n\n      expr_ = expr;\n}\n\nvoid dll_target::expr_new(const NetENew*net)\n{\n      ivl_expr_t size = 0;\n      ivl_expr_t init_val = 0;\n\n      if (net->size_expr()) {\n\t    net->size_expr()->expr_scan(this);\n\t    size = expr_;\n\t    expr_ = 0;\n      }\n\n      if (net->init_expr()) {\n\t    net->init_expr()->expr_scan(this);\n\t    init_val = expr_;\n\t    expr_ = 0;\n      }\n\n      assert(expr_ == 0);\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->width_  = net->expr_width();\n      expr_->signed_ = 0;\n      expr_->sized_  = 1;\n      expr_->type_   = IVL_EX_NEW;\n      FILE_NAME(expr_, net);\n      expr_->value_  = net->expr_type(); // May be IVL_VT_DARRAY or _CLASS\n      expr_->net_type= net->net_type();\n      expr_->u_.new_.size = size;\n      expr_->u_.new_.init_val = init_val;\n}\n\nvoid dll_target::expr_null(const NetENull*net)\n{\n      assert(expr_ == 0);\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->width_  = net->expr_width();\n      expr_->signed_ = 0;\n      expr_->sized_  = 1;\n      expr_->type_   = IVL_EX_NULL;\n      FILE_NAME(expr_, net);\n      expr_->value_  = IVL_VT_CLASS;\n      expr_->net_type= 0;\n}\n\nvoid dll_target::expr_property(const NetEProperty*net)\n{\n      ivl_expr_t index = 0;\n      if (const NetExpr*index_expr = net->get_index()) {\n\t    index_expr->expr_scan(this);\n\t    index = expr_;\n\t    expr_ = 0;\n      }\n      assert(expr_ == 0);\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->width_  = net->expr_width();\n      expr_->signed_ = net->has_sign();\n      expr_->sized_  = 1;\n      expr_->type_   = IVL_EX_PROPERTY;\n      FILE_NAME(expr_, net);\n      expr_->value_  = net->expr_type();\n      expr_->net_type= net->net_type();\n      expr_->u_.property_.sig = find_signal(des_, net->get_sig());\n      expr_->u_.property_.prop_idx = net->property_idx();\n      expr_->u_.property_.index = index;\n}\n\nvoid dll_target::expr_event(const NetEEvent*net)\n{\n      assert(expr_ == 0);\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr_->type_ = IVL_EX_EVENT;\n      FILE_NAME(expr_, net);\n      expr_->value_= IVL_VT_VOID;\n      expr_->net_type=0;\n\n        /* Locate the event by name. Save the ivl_event_t in the\n           expression so that the generator can find it easily. */\n      const NetEvent*ev = net->event();\n      ivl_scope_t ev_scope = lookup_scope_(ev->scope());\n\n      for (unsigned idx = 0 ;  idx < ev_scope->nevent_ ;  idx += 1) {\n            const char*ename = ivl_event_basename(ev_scope->event_[idx]);\n            if (strcmp(ev->name(), ename) == 0) {\n                  expr_->u_.event_.event = ev_scope->event_[idx];\n                  break;\n            }\n      }\n}\n\nvoid dll_target::expr_scope(const NetEScope*net)\n{\n      assert(expr_ == 0);\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr_->type_ = IVL_EX_SCOPE;\n      FILE_NAME(expr_, net);\n      expr_->value_= IVL_VT_VOID;\n      expr_->net_type=0;\n      expr_->u_.scope_.scope = lookup_scope_(net->scope());\n}\n\nvoid dll_target::expr_scopy(const NetEShallowCopy*net)\n{\n      assert(expr_ == 0);\n\n      net->expr_scan_oper1(this);\n      ivl_expr_t expr1 = expr_;\n      expr_ = 0;\n\n      net->expr_scan_oper2(this);\n      ivl_expr_t expr2 = expr_;\n      expr_ = 0;\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->type_ = IVL_EX_SHALLOWCOPY;\n      FILE_NAME(expr_, net);\n      expr_->value_ = net->expr_type();\n      expr_->net_type = net->net_type();\n\n      expr_->u_.shallow_.dest = expr1;\n      expr_->u_.shallow_.src  = expr2;\n}\n\nvoid dll_target::expr_netenum(const NetENetenum*net)\n{\n      assert(expr_ == 0);\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr_->type_ = IVL_EX_ENUMTYPE;\n      FILE_NAME(expr_, net);\n      expr_->value_= IVL_VT_VOID;\n      expr_->net_type=0;\n      expr_->u_.enumtype_.type = net->netenum();\n}\n\nvoid dll_target::expr_select(const NetESelect*net)\n{\n      assert(expr_ == 0);\n\n      net->sub_expr()->expr_scan(this);\n      ivl_expr_t expr = expr_;\n\n      expr_ = 0;\n      if (net->select())\n\t    net->select()->expr_scan(this);\n\n      ivl_expr_t base = expr_;\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr_->type_ = IVL_EX_SELECT;\n      expr_->value_= net->expr_type();\n      expr_->net_type=0;\n      expr_->width_= net->expr_width();\n      expr_->signed_ = net->has_sign()? 1 : 0;\n      expr_->sized_= 1;\n      FILE_NAME(expr_, net);\n\n      expr_->u_.select_.sel_type_ = net->select_type();\n      expr_->u_.select_.expr_ = expr;\n      expr_->u_.select_.base_ = base;\n}\n\nvoid dll_target::expr_sfunc(const NetESFunc*net)\n{\n      assert(expr_ == 0);\n\n      ivl_expr_t expr = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr->type_ = IVL_EX_SFUNC;\n      expr->value_= net->expr_type();\n      expr->net_type=net->net_type();\n      expr->width_= net->expr_width();\n      expr->signed_ = net->has_sign()? 1 : 0;\n      expr->sized_= 1;\n      FILE_NAME(expr, net);\n\t/* system function names are lex_strings strings. */\n      expr->u_.sfunc_.name_ = net->name();\n\n      unsigned cnt = net->nparms();\n      expr->u_.sfunc_.parms = cnt;\n      expr->u_.sfunc_.parm = new ivl_expr_t[cnt];\n\n\t/* make up the parameter expressions. */\n      for (unsigned idx = 0 ;  idx < cnt ;  idx += 1) {\n\t    net->parm(idx)->expr_scan(this);\n\t    assert(expr_);\n\t    expr->u_.sfunc_.parm[idx] = expr_;\n\t    expr_ = 0;\n      }\n\n      expr_ = expr;\n}\n\nvoid dll_target::expr_ternary(const NetETernary*net)\n{\n      assert(expr_ == 0);\n\n      ivl_expr_t expr = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr->type_  = IVL_EX_TERNARY;\n      expr->value_= net->expr_type();\n      expr->net_type=0;\n      expr->width_ = net->expr_width();\n      expr->signed_ = net->has_sign()? 1 : 0;\n      expr->sized_ = 1;\n      FILE_NAME(expr, net);\n\n      net->cond_expr()->expr_scan(this);\n      assert(expr_);\n      expr->u_.ternary_.cond = expr_;\n      expr_ = 0;\n\n      net->true_expr()->expr_scan(this);\n      assert(expr_);\n      expr->u_.ternary_.true_e = expr_;\n      expr_ = 0;\n\n      net->false_expr()->expr_scan(this);\n      assert(expr_);\n      expr->u_.ternary_.false_e = expr_;\n\n      expr_ = expr;\n}\n\nvoid dll_target::expr_signal(const NetESignal*net)\n{\n      ivl_signal_t sig = find_signal(des_, net->sig());\n\n      assert(expr_ == 0);\n\n\t/* If there is a word expression, generate it. */\n      ivl_expr_t word_expr = 0;\n      if (const NetExpr*word = net->word_index()) {\n\t    word->expr_scan(this);\n\t    assert(expr_);\n\t    word_expr = expr_;\n\t    expr_ = 0;\n      }\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr_->type_ = IVL_EX_SIGNAL;\n      expr_->value_= net->expr_type();\n      expr_->net_type=0;\n      expr_->width_= net->expr_width();\n      expr_->signed_ = net->has_sign()? 1 : 0;\n      expr_->sized_= 1;\n      FILE_NAME(expr_, net);\n      expr_->u_.signal_.word = word_expr;\n      expr_->u_.signal_.sig = sig;\n\n\t/* Make account for the special case that this is a reference\n\t   to an array as a whole. We detect this case by noting that\n\t   this is an array (more than 0 array dimensions) and that\n\t   there is no word select expression. For this case, we have\n\t   an IVL_EX_ARRAY expression instead of a SIGNAL expression. */\n      if (sig->array_dimensions_ > 0 && word_expr == 0) {\n\t    expr_->type_ = IVL_EX_ARRAY;\n\t    expr_->width_ = 0; // Doesn't make much sense for arrays.\n      }\n}\n\n\nvoid dll_target::expr_ufunc(const NetEUFunc*net)\n{\n      assert(expr_ == 0);\n\n      ivl_expr_t expr = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n\n      expr->type_ = IVL_EX_UFUNC;\n      expr->value_= net->expr_type();\n      expr->net_type=0;\n      expr->width_= net->expr_width();\n      expr->signed_ = net->has_sign()? 1 : 0;\n      expr->sized_= 1;\n      FILE_NAME(expr, net);\n\n      expr->u_.ufunc_.def = lookup_scope_(net->func());\n      if (expr->u_.ufunc_.def == 0) {\n\t    cerr << net->get_fileline() << \": internal error: \"\n\t\t << \"dll_target::expr_ufunc: \"\n\t\t << \"Unable to match scope \" << scope_path(net->func()) << endl;\n      }\n      ivl_assert(*net, expr->u_.ufunc_.def);\n      ivl_assert(*net, expr->u_.ufunc_.def->type_ == IVL_SCT_FUNCTION);\n\n      unsigned cnt = net->parm_count();\n      expr->u_.ufunc_.parms = cnt;\n      expr->u_.ufunc_.parm = new ivl_expr_t[cnt];\n\n\t/* make up the parameter expressions. */\n      for (unsigned idx = 0 ;  idx < cnt ;  idx += 1) {\n\t    net->parm(idx)->expr_scan(this);\n\t    assert(expr_);\n\t    expr->u_.ufunc_.parm[idx] = expr_;\n\t    expr_ = 0;\n      }\n\n      expr_ = expr;\n}\n\nvoid dll_target::expr_unary(const NetEUnary*net)\n{\n      assert(expr_ == 0);\n\n      net->expr()->expr_scan(this);\n      assert(expr_);\n\n      ivl_expr_t sub = expr_;\n\n      expr_ = (ivl_expr_t)calloc(1, sizeof(struct ivl_expr_s));\n      expr_->type_ = IVL_EX_UNARY;\n      expr_->value_= net->expr_type();\n      expr_->net_type=0;\n      expr_->width_ = net->expr_width();\n      expr_->signed_ = net->has_sign()? 1 : 0;\n      expr_->sized_ = 1;\n      FILE_NAME(expr_, net);\n      expr_->u_.unary_.op_ = net->op();\n      expr_->u_.unary_.sub_ = sub;\n}\n"
        },
        {
          "name": "t-dll-proc.cc",
          "type": "blob",
          "size": 28.8671875,
          "content": "/*\n * Copyright (c) 2000-2022 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.will need a Picture Elements Binary Software\n *    License.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  <cstring>\n# include  \"target.h\"\n# include  \"ivl_target.h\"\n# include  \"compiler.h\"\n# include  \"t-dll.h\"\n# include  \"netclass.h\"\n# include  <cstdlib>\n# include  \"ivl_alloc.h\"\n# include  \"ivl_assert.h\"\n\nbool dll_target::process(const NetProcTop*net)\n{\n      bool rc_flag = true;\n\n      ivl_process_t obj = (struct ivl_process_s*)\n\t    calloc(1, sizeof(struct ivl_process_s));\n\n      obj->type_ = net->type();\n      obj->analog_flag = 0;\n\n      FILE_NAME(obj, net);\n\n\t/* Save the scope of the process. */\n      obj->scope_ = lookup_scope_(net->scope());\n\n      obj->nattr = net->attr_cnt();\n      obj->attr = fill_in_attributes(net);\n\n\t/* This little bit causes the process to be completely\n\t   generated so that it can be passed to the DLL. The\n\t   stmt_cur_ member is used to hold a pointer to the current\n\t   statement in progress, and the emit_proc() method fills in\n\t   that object.\n\n\t   We know a few things about the current statement: we are\n\t   not in the middle of one, and when we are done, we have our\n\t   statement back. The asserts check these conditions. */\n\n      assert(stmt_cur_ == 0);\n      stmt_cur_ = (struct ivl_statement_s*)calloc(1, sizeof*stmt_cur_);\n      rc_flag = net->statement()->emit_proc(this) && rc_flag;\n\n      assert(stmt_cur_);\n      obj->stmt_ = stmt_cur_;\n      stmt_cur_ = 0;\n\n\t/* Save the process in the design. */\n      obj->next_ = des_.threads_;\n      des_.threads_ = obj;\n\n      return rc_flag;\n}\n\nvoid dll_target::task_def(const NetScope*net)\n{\n      ivl_scope_t scop = lookup_scope_(net);\n      const NetTaskDef*def = net->task_def();\n\n      assert(def);\n      assert(def->proc());\n      assert(stmt_cur_ == 0);\n      stmt_cur_ = (struct ivl_statement_s*)calloc(1, sizeof*stmt_cur_);\n      def->proc()->emit_proc(this);\n\n      assert(stmt_cur_);\n      scop->def = stmt_cur_;\n      stmt_cur_ = 0;\n\n      scop->ports = def->port_count();\n      if (scop->ports > 0) {\n\t    scop->u_.port = new ivl_signal_t[scop->ports];\n\t    for (unsigned idx = 0 ;  idx < scop->ports ;  idx += 1)\n\t\t  scop->u_.port[idx] = find_signal(des_, def->port(idx));\n      }\n\n}\n\nbool dll_target::func_def(const NetScope*net)\n{\n      ivl_scope_t scop = lookup_scope_(net);\n      const NetFuncDef*def = net->func_def();\n\n      assert(def);\n      assert(def->proc());\n      assert(stmt_cur_ == 0);\n      stmt_cur_ = (struct ivl_statement_s*)calloc(1, sizeof*stmt_cur_);\n      def->proc()->emit_proc(this);\n\n      assert(stmt_cur_);\n      scop->def = stmt_cur_;\n      stmt_cur_ = 0;\n\n      scop->ports = def->port_count() + 1;\n      if (scop->ports > 0) {\n\t    scop->u_.port = new ivl_signal_t[scop->ports];\n\t    for (unsigned idx = 1 ;  idx < scop->ports ;  idx += 1)\n\t\t  scop->u_.port[idx] = find_signal(des_, def->port(idx-1));\n      }\n\n\t/* FIXME: the ivl_target API expects port-0 to be the output\n\t   port. This assumes that the return value is a signal, which\n\t   is *not* correct. Someday, I'm going to have to change\n\t   this, but that will break code generators that use this\n\t   result. */\n      if (const NetNet*ret_sig = def->return_sig())\n\t    scop->u_.port[0] = find_signal(des_, ret_sig);\n      else\n\t    scop->u_.port[0] = 0;\n\n\t/* If there is no return value, then this is a void function. */\n\n      return true;\n\n}\n\n/*\n * This private function makes the assignment lvals for the various\n * kinds of assignment statements.\n */\nbool dll_target::make_assign_lvals_(const NetAssignBase*net)\n{\n      bool flag = true;\n      assert(stmt_cur_);\n\n      unsigned cnt = net->l_val_count();\n\n      stmt_cur_->u_.assign_.lvals_ = cnt;\n      stmt_cur_->u_.assign_.lval_  = new struct ivl_lval_s[cnt];\n      stmt_cur_->u_.assign_.delay  = 0;\n\n      for (unsigned idx = 0 ;  idx < cnt ;  idx += 1) {\n\t    struct ivl_lval_s*cur = stmt_cur_->u_.assign_.lval_ + idx;\n\t    const NetAssign_*asn = net->l_val(idx);\n\t    flag &= make_single_lval_(net, cur, asn);\n      }\n\n      return flag;\n}\n\nbool dll_target::make_single_lval_(const LineInfo*li, struct ivl_lval_s*cur, const NetAssign_*asn)\n{\n      bool flag = true;\n\n      const NetExpr*loff = asn->get_base();\n\n      if (loff == 0) {\n\t    cur->loff = 0;\n\t    cur->sel_type = IVL_SEL_OTHER;\n      } else {\n\t    loff->expr_scan(this);\n\t    cur->loff = expr_;\n\t    cur->sel_type = asn->select_type();\n\t    expr_ = 0;\n      }\n\n      cur->width_ = asn->lwidth();\n\n      if (asn->sig()) {\n\t    cur->type_ = IVL_LVAL_REG;\n\t    cur->n.sig = find_signal(des_, asn->sig());\n\n      } else {\n\t    const NetAssign_*asn_nest = asn->nest();\n\t    ivl_assert(*li, asn_nest);\n\t    struct ivl_lval_s*cur_nest = new struct ivl_lval_s;\n\t    make_single_lval_(li, cur_nest, asn_nest);\n\n\t    cur->type_ = IVL_LVAL_LVAL;\n\t    cur->n.nest = cur_nest;\n      }\n\n      cur->idx = 0;\n\t// If there is a word select expression, it is\n\t// really an array index. Note that the word index\n\t// expression is already converted to canonical\n\t// form by elaboration.\n      if (asn->word()) {\n\t    assert(expr_ == 0);\n\t    asn->word()->expr_scan(this);\n\t    cur->type_ = IVL_LVAL_ARR;\n\t    cur->idx = expr_;\n\t    expr_ = 0;\n      }\n\n      cur->property_idx = asn->get_property_idx();\n\n      return flag;\n}\n\nvoid dll_target::proc_alloc(const NetAlloc*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_ALLOC;\n      stmt_cur_->u_.alloc_.scope = lookup_scope_(net->scope());\n}\n\n/*\n */\nbool dll_target::proc_assign(const NetAssign*net)\n{\n      bool flag = true;\n\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n\n      stmt_cur_->type_ = IVL_ST_ASSIGN;\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->u_.assign_.delay = 0;\n\n\t/* Make the lval fields. */\n      flag &= make_assign_lvals_(net);\n\n      stmt_cur_->u_.assign_.oper = net->assign_operator();\n      assert(expr_ == 0);\n      net->rval()->expr_scan(this);\n      stmt_cur_->u_.assign_.rval_ = expr_;\n      expr_ = 0;\n\n      const NetExpr*del = net->get_delay();\n      if (del) {\n\t    del->expr_scan(this);\n\t    stmt_cur_->u_.assign_.delay = expr_;\n\t    expr_ = 0;\n      }\n\n      return flag;\n}\n\n\nvoid dll_target::proc_assign_nb(const NetAssignNB*net)\n{\n      const NetExpr* delay_exp = net->get_delay();\n      const NetExpr* cnt_exp = net->get_count();\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n\n      stmt_cur_->type_ = IVL_ST_ASSIGN_NB;\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->u_.assign_.delay  = 0;\n      stmt_cur_->u_.assign_.count  = 0;\n      stmt_cur_->u_.assign_.nevent  = 0;\n\n\t/* Make the lval fields. */\n      make_assign_lvals_(net);\n\n\t/* Make the rval field. */\n      assert(expr_ == 0);\n      net->rval()->expr_scan(this);\n      stmt_cur_->u_.assign_.rval_ = expr_;\n      expr_ = 0;\n\n\t/* Process a delay if it exists. */\n      if (const NetEConst*delay_num = dynamic_cast<const NetEConst*>(delay_exp)) {\n\t    verinum val = delay_num->value();\n\t    ivl_expr_t de = new struct ivl_expr_s;\n\t    de->type_ = IVL_EX_DELAY;\n\t    de->width_  = 8 * sizeof(uint64_t);\n\t    de->signed_ = 0;\n\t    de->u_.delay_.value = val.as_ulong64();\n\t    stmt_cur_->u_.assign_.delay = de;\n\n      } else if (delay_exp != 0) {\n\t    delay_exp->expr_scan(this);\n\t    stmt_cur_->u_.assign_.delay = expr_;\n\t    expr_ = 0;\n      }\n\n\t/* Process a count if it exists. */\n      if (const NetEConst*cnt_num = dynamic_cast<const NetEConst*>(cnt_exp)) {\n\t    verinum val = cnt_num->value();\n\t    ivl_expr_t cnt = new struct ivl_expr_s;\n\t    cnt->type_ = IVL_EX_ULONG;\n\t    cnt->width_  = 8 * sizeof(unsigned long);\n\t    cnt->signed_ = 0;\n\t    cnt->u_.ulong_.value = val.as_ulong();\n\t    stmt_cur_->u_.assign_.count = cnt;\n\n      } else if (cnt_exp != 0) {\n\t    cnt_exp->expr_scan(this);\n\t    stmt_cur_->u_.assign_.count = expr_;\n\t    expr_ = 0;\n      }\n\n\t/* Process the events if they exist. This is a copy of code\n\t * from NetEvWait below. */\n      if (net->nevents() > 0) {\n\t    stmt_cur_->u_.assign_.nevent = net->nevents();\n\t    if (net->nevents() > 1) {\n\t\t  stmt_cur_->u_.assign_.events = (ivl_event_t*)\n\t\t        calloc(net->nevents(), sizeof(ivl_event_t*));\n\t    }\n\n\t    for (unsigned edx = 0 ;  edx < net->nevents() ;  edx += 1) {\n\n\t\t    /* Locate the event by name. Save the ivl_event_t in the\n\t\t       statement so that the generator can find it easily. */\n\t\t  const NetEvent*ev = net->event(edx);\n\t\t  ivl_scope_t ev_scope = lookup_scope_(ev->scope());\n\t\t  ivl_event_t ev_tmp=0;\n\n\t\t  assert(ev_scope);\n\t\t  assert(ev_scope->nevent_ > 0);\n\t\t  for (unsigned idx = 0;  idx < ev_scope->nevent_; idx += 1) {\n\t\t\tconst char*ename =\n\t\t\t      ivl_event_basename(ev_scope->event_[idx]);\n\t\t\tif (strcmp(ev->name(), ename) == 0) {\n\t\t\t      ev_tmp = ev_scope->event_[idx];\n\t\t\t      break;\n\t\t\t}\n\t\t  }\n\t\t  // XXX should we assert(ev_tmp)?\n\n\t\t  if (net->nevents() == 1)\n\t\t\tstmt_cur_->u_.assign_.event = ev_tmp;\n\t\t  else\n\t\t\tstmt_cur_->u_.assign_.events[edx] = ev_tmp;\n\n\t\t    /* If this is an event with a probe, then connect up the\n\t\t       pins. This wasn't done during the ::event method because\n\t\t       the signals weren't scanned yet. */\n\n\t\t  if (ev->nprobe() >= 1) {\n\t\t\tunsigned iany = 0;\n\t\t\tunsigned ineg = ev_tmp->nany;\n\t\t\tunsigned ipos = ineg + ev_tmp->nneg;\n\t\t\tunsigned iedg = ipos + ev_tmp->npos;\n\n\t\t\tfor (unsigned idx = 0;  idx < ev->nprobe();  idx += 1) {\n\t\t\t      const NetEvProbe*pr = ev->probe(idx);\n\t\t\t      unsigned base = 0;\n\n\t\t\t      switch (pr->edge()) {\n\t\t\t\t  case NetEvProbe::ANYEDGE:\n\t\t\t\t    base = iany;\n\t\t\t\t    iany += pr->pin_count();\n\t\t\t\t    break;\n\t\t\t\t  case NetEvProbe::NEGEDGE:\n\t\t\t\t    base = ineg;\n\t\t\t\t    ineg += pr->pin_count();\n\t\t\t\t    break;\n\t\t\t\t  case NetEvProbe::POSEDGE:\n\t\t\t\t    base = ipos;\n\t\t\t\t    ipos += pr->pin_count();\n\t\t\t\t    break;\n\t\t\t\t  case NetEvProbe::EDGE:\n\t\t\t\t    base = iedg;\n\t\t\t\t    iedg += pr->pin_count();\n\t\t\t\t    break;\n\t\t\t      }\n\n\t\t\t      for (unsigned bit = 0; bit < pr->pin_count();\n\t\t\t\t   bit += 1) {\n\t\t\t\t    ivl_nexus_t nex = (ivl_nexus_t)\n\t\t\t\t          pr->pin(bit).nexus()->t_cookie();\n\t\t\t\t    assert(nex);\n\t\t\t\t    ev_tmp->pins[base+bit] = nex;\n\t\t\t      }\n\t\t\t}\n\t\t  }\n\t    }\n      }\n}\n\nbool dll_target::proc_block(const NetBlock*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n\t/* First, count the statements in the block. */\n      unsigned count = 0;\n      for (const NetProc*cur = net->proc_first()\n\t\t ;  cur ;  cur = net->proc_next(cur))\n\t    count += 1;\n\n\t/* If the block has no statements, then turn it into a no-op */\n      if (count == 0) {\n\t    stmt_cur_->type_ = IVL_ST_NOOP;\n\t    return true;\n      }\n\n\t/* If there is exactly one statement and the block is not a\n\t   fork/join_none, there is no need for the block wrapper,\n\t   generate the contained statement instead. */\n      if ((count == 1) && (net->subscope() == 0) &&\n\t  (net->type() != NetBlock::PARA_JOIN_NONE)) {\n\t    return net->proc_first()->emit_proc(this);\n      }\n\n\n\t/* Handle the general case. The block has some statements in\n\t   it, so fill in the block fields of the existing statement,\n\t   and generate the contents for the statement array. */\n\n      switch (net->type()) {\n\t  case NetBlock::SEQU:\n\t    stmt_cur_->type_ = IVL_ST_BLOCK;\n\t    break;\n\t  case NetBlock::PARA:\n\t    stmt_cur_->type_ = IVL_ST_FORK;\n\t    break;\n\t  case NetBlock::PARA_JOIN_ANY:\n\t    stmt_cur_->type_ = IVL_ST_FORK_JOIN_ANY;\n\t    break;\n\t  case NetBlock::PARA_JOIN_NONE:\n\t    stmt_cur_->type_ = IVL_ST_FORK_JOIN_NONE;\n\t    break;\n      }\n      stmt_cur_->u_.block_.nstmt_ = count;\n      stmt_cur_->u_.block_.stmt_ = (struct ivl_statement_s*)\n\t    calloc(count, sizeof(struct ivl_statement_s));\n\n      if (net->subscope())\n\t    stmt_cur_->u_.block_.scope = lookup_scope_(net->subscope());\n      else\n\t    stmt_cur_->u_.block_.scope = 0;\n\n      struct ivl_statement_s*save_cur_ = stmt_cur_;\n      unsigned idx = 0;\n      bool flag = true;\n\n      for (const NetProc*cur = net->proc_first()\n\t\t ;  cur ;  cur = net->proc_next(cur), idx += 1) {\n\t    assert(idx < count);\n\t    stmt_cur_ = save_cur_->u_.block_.stmt_ + idx;\n\t    bool rc = cur->emit_proc(this);\n\t    flag = flag && rc;\n      }\n      assert(idx == count);\n\n      stmt_cur_ = save_cur_;\n\n      return flag;\n}\n\nbool dll_target::proc_break(const NetBreak*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n      stmt_cur_->type_ = IVL_ST_BREAK;\n      return true;\n}\n\n/*\n * A. case statement is in turn an array of statements with gate\n * expressions. This builds arrays of the right size and builds the\n * ivl_expr_t and ivl_statement_s arrays for the substatements.\n */\nvoid dll_target::proc_case(const NetCase*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      switch (net->type()) {\n\t  case NetCase::EQ:\n\t    stmt_cur_->type_ = IVL_ST_CASE;\n\t    break;\n\t  case NetCase::EQX:\n\t    stmt_cur_->type_ = IVL_ST_CASEX;\n\t    break;\n\t  case NetCase::EQZ:\n\t    stmt_cur_->type_ = IVL_ST_CASEZ;\n\t    break;\n      }\n      assert(stmt_cur_->type_ != IVL_ST_NONE);\n\n      stmt_cur_->u_.case_.quality = net->case_quality();\n      assert(expr_ == 0);\n      assert(net->expr());\n      net->expr()->expr_scan(this);\n      stmt_cur_->u_.case_.cond = expr_;\n      expr_ = 0;\n\n\t/* If the condition expression is a real valued expression,\n\t   then change the case statement to a CASER statement. */\n      if (stmt_cur_->u_.case_.cond->value_ == IVL_VT_REAL)\n\t    stmt_cur_->type_ = IVL_ST_CASER;\n\n      unsigned ncase = net->nitems();\n      stmt_cur_->u_.case_.ncase = ncase;\n\n      stmt_cur_->u_.case_.case_ex = new ivl_expr_t[ncase];\n      stmt_cur_->u_.case_.case_st = new struct ivl_statement_s[ncase];\n\n      ivl_statement_t save_cur = stmt_cur_;\n\n      for (unsigned idx = 0 ;  idx < ncase ;  idx += 1) {\n\t    const NetExpr*ex = net->expr(idx);\n\t    if (ex) {\n\t\t  ex->expr_scan(this);\n\t\t  save_cur->u_.case_.case_ex[idx] = expr_;\n\t\t  expr_ = 0;\n\t    } else {\n\t\t  save_cur->u_.case_.case_ex[idx] = 0;\n\t    }\n\n\t    stmt_cur_ = save_cur->u_.case_.case_st + idx;\n\t    stmt_cur_->type_ = IVL_ST_NONE;\n\t    if (net->stat(idx) == 0) {\n\t\t  stmt_cur_->type_ = IVL_ST_NOOP;\n\t    } else {\n\t\t  net->stat(idx)->emit_proc(this);\n\t    }\n      }\n\n      stmt_cur_ = save_cur;\n}\n\nbool dll_target::proc_cassign(const NetCAssign*net)\n{\n\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_CASSIGN;\n\n\t/* Make the l-value fields. */\n      make_assign_lvals_(net);\n\n      assert(expr_ == 0);\n      net->rval()->expr_scan(this);\n      stmt_cur_->u_.assign_.rval_ = expr_;\n      expr_ = 0;\n\n      return true;\n}\n\nbool dll_target::proc_condit(const NetCondit*net)\n{\n      bool rc_flag = true;\n\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_CONDIT;\n      stmt_cur_->u_.condit_.stmt_ = (struct ivl_statement_s*)\n\t    calloc(2, sizeof(struct ivl_statement_s));\n\n      assert(expr_ == 0);\n      net->expr()->expr_scan(this);\n      stmt_cur_->u_.condit_.cond_ = expr_;\n      if (expr_ == 0)\n\t    rc_flag = false;\n      expr_ = 0;\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n\n      stmt_cur_ = save_cur_->u_.condit_.stmt_+0;\n      rc_flag = net->emit_recurse_if(this) && rc_flag;\n\n      stmt_cur_ = save_cur_->u_.condit_.stmt_+1;\n      rc_flag = net->emit_recurse_else(this) && rc_flag;\n\n      stmt_cur_ = save_cur_;\n      return rc_flag;\n}\n\nbool dll_target::proc_continue(const NetContinue*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n      stmt_cur_->type_ = IVL_ST_CONTINUE;\n      return true;\n}\n\nbool dll_target::proc_deassign(const NetDeassign*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_DEASSIGN;\n\n\t/* Make the l-value fields. */\n      make_assign_lvals_(net);\n\n      return true;\n}\n\nbool dll_target::proc_delay(const NetPDelay*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      ivl_statement_t tmp = (struct ivl_statement_s*)\n\t    calloc(1, sizeof(struct ivl_statement_s));\n\n      if (const NetExpr*expr = net->expr()) {\n\n\t    stmt_cur_->type_ = IVL_ST_DELAYX;\n\t    assert(expr_ == 0);\n\t    expr->expr_scan(this);\n\t    stmt_cur_->u_.delayx_.expr = expr_;\n\t    expr_ = 0;\n\n\t    stmt_cur_->u_.delayx_.stmt_ = tmp;\n\n      } else {\n\t    stmt_cur_->type_ = IVL_ST_DELAY;\n\t    stmt_cur_->u_.delay_.stmt_  = tmp;\n\t    stmt_cur_->u_.delay_.value = net->delay();\n      }\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n      stmt_cur_ = tmp;\n      bool flag = net->emit_proc_recurse(this);\n\n\t/* If the recurse doesn't turn this new item into something,\n\t   then either it failed or there is no statement\n\t   there. Either way, draw a no-op into the statement. */\n      if (stmt_cur_->type_ == IVL_ST_NONE) {\n\t    stmt_cur_->type_ = IVL_ST_NOOP;\n      }\n\n      stmt_cur_ = save_cur_;\n\n      return flag;\n}\n\nbool dll_target::proc_disable(const NetDisable*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_DISABLE;\n      stmt_cur_->u_.disable_.flow_control = net->flow_control();\n      const NetScope* dis_scope = net->target();\n\t/* A normal disable. */\n      if (dis_scope) stmt_cur_->u_.disable_.scope = lookup_scope_(dis_scope);\n\t/* A SystemVerilog disable fork. */\n      else stmt_cur_->u_.disable_.scope = 0;\n      return true;\n}\n\nvoid dll_target::proc_do_while(const NetDoWhile*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_DO_WHILE;\n      stmt_cur_->u_.while_.stmt_ = (struct ivl_statement_s*)\n\t    calloc(1, sizeof(struct ivl_statement_s));\n\n      assert(expr_ == 0);\n      net->expr()->expr_scan(this);\n      stmt_cur_->u_.while_.cond_ = expr_;\n      expr_ = 0;\n\n\t/* Now generate the statement of the do/while loop. We know it is\n\t   a single statement, and we know that the\n\t   emit_proc_recurse() will call emit_proc() for it. */\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n      stmt_cur_ = save_cur_->u_.while_.stmt_;\n      net->emit_proc_recurse(this);\n      stmt_cur_ = save_cur_;\n}\n\nbool dll_target::proc_force(const NetForce*net)\n{\n\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_FORCE;\n\n\t/* Make the l-value fields. */\n      make_assign_lvals_(net);\n\n      assert(expr_ == 0);\n      net->rval()->expr_scan(this);\n      stmt_cur_->u_.assign_.rval_ = expr_;\n      expr_ = 0;\n\n      return true;\n}\n\nvoid dll_target::proc_forever(const NetForever*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_FOREVER;\n\n      ivl_statement_t tmp = (struct ivl_statement_s*)\n\t    calloc(1, sizeof(struct ivl_statement_s));\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n      stmt_cur_ = tmp;\n\n      net->emit_recurse(this);\n\n      save_cur_->u_.forever_.stmt_ = stmt_cur_;\n      stmt_cur_ = save_cur_;\n}\n\nbool dll_target::proc_forloop(const NetForLoop*net)\n{\n      ivl_statement_t tmp;\n      bool rc, res=true;\n\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n      stmt_cur_->type_ = IVL_ST_FORLOOP;\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n\n      // Note that the init statement is optional. If it is not present,\n      // then the emit_recurse_init will not generate a statement.\n      tmp = (struct ivl_statement_s*)calloc(1, sizeof(struct ivl_statement_s));\n      stmt_cur_ = tmp;\n      rc = net->emit_recurse_init(this);\n      if (stmt_cur_->type_ != IVL_ST_NONE)\n\t    save_cur_->u_.forloop_.init_stmt = stmt_cur_;\n      else {\n\t    free(tmp);\n\t    save_cur_->u_.forloop_.init_stmt = nullptr;\n      }\n      res = res && rc;\n\n      tmp = (struct ivl_statement_s*)calloc(1, sizeof(struct ivl_statement_s));\n      stmt_cur_ = tmp;\n      rc = net->emit_recurse_stmt(this);\n      save_cur_->u_.forloop_.stmt = stmt_cur_;\n      res = res && rc;\n\n      tmp = (struct ivl_statement_s*)calloc(1, sizeof(struct ivl_statement_s));\n      stmt_cur_ = tmp;\n      rc = net->emit_recurse_step(this);\n      if (stmt_cur_->type_ != IVL_ST_NONE)\n\t    save_cur_->u_.forloop_.step = stmt_cur_;\n      else {\n\t    free(tmp);\n\t    save_cur_->u_.forloop_.step = nullptr;\n      }\n      res = res && rc;\n\n      assert(expr_ == nullptr);\n      rc = net->emit_recurse_condition(this);\n      save_cur_->u_.forloop_.condition = expr_;\n      expr_ = nullptr;\n      res = res && rc;\n\n      stmt_cur_ = save_cur_;\n      return res;\n}\n\nvoid dll_target::proc_free(const NetFree*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_FREE;\n      stmt_cur_->u_.free_.scope = lookup_scope_(net->scope());\n}\n\nbool dll_target::proc_release(const NetRelease*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_RELEASE;\n\n\t/* Make the l-value fields. */\n      make_assign_lvals_(net);\n\n      return true;\n}\n\nvoid dll_target::proc_repeat(const NetRepeat*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_REPEAT;\n\n      assert(expr_ == 0);\n      net->expr()->expr_scan(this);\n      stmt_cur_->u_.while_.cond_ = expr_;\n      expr_ = 0;\n\n      ivl_statement_t tmp = (struct ivl_statement_s*)\n\t    calloc(1, sizeof(struct ivl_statement_s));\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n      stmt_cur_ = tmp;\n\n      net->emit_recurse(this);\n\n      save_cur_->u_.while_.stmt_ = stmt_cur_;\n      stmt_cur_ = save_cur_;\n}\n\nvoid dll_target::proc_stask(const NetSTask*net)\n{\n      unsigned nparms = net->nparms();\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_STASK;\n\t/* System task names are lex_strings strings. */\n      stmt_cur_->u_.stask_.name_ = net->name();\n      stmt_cur_->u_.stask_.sfunc_as_task_ = net->sfunc_as_task();\n      stmt_cur_->u_.stask_.nparm_= nparms;\n      stmt_cur_->u_.stask_.parms_= (ivl_expr_t*)\n\t    calloc(nparms, sizeof(ivl_expr_t));\n\n      for (unsigned idx = 0 ;  idx < nparms ;  idx += 1) {\n\t    if (net->parm(idx))\n\t\t  net->parm(idx)->expr_scan(this);\n\t    stmt_cur_->u_.stask_.parms_[idx] = expr_;\n\t    expr_ = 0;\n      }\n\n}\n\nbool dll_target::proc_trigger(const NetEvTrig*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_TRIGGER;\n      stmt_cur_->u_.wait_.nevent = 1;\n\n\t/* Locate the event by name. Save the ivl_event_t in the\n\t   statement so that the generator can find it easily. */\n      const NetEvent*ev = net->event();\n      ivl_scope_t ev_scope = lookup_scope_(ev->scope());\n\n      for (unsigned idx = 0 ;  idx < ev_scope->nevent_ ;  idx += 1) {\n\t    const char*ename = ivl_event_basename(ev_scope->event_[idx]);\n\t    if (strcmp(ev->name(), ename) == 0) {\n\t\t  stmt_cur_->u_.wait_.event = ev_scope->event_[idx];\n\t\t  break;\n\t    }\n      }\n\n      return true;\n}\n\nbool dll_target::proc_nb_trigger(const NetEvNBTrig*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_NB_TRIGGER;\n      stmt_cur_->u_.wait_.nevent = 1;\n      stmt_cur_->u_.wait_.delay = 0;\n\n      if (const NetExpr*expr = net->delay()) {\n\t    assert(expr_ == 0);\n\t    expr->expr_scan(this);\n\t    stmt_cur_->u_.wait_.delay = expr_;\n\t    expr_ = 0;\n      }\n\n\t/* Locate the event by name. Save the ivl_event_t in the\n\t   statement so that the generator can find it easily. */\n      const NetEvent*ev = net->event();\n      ivl_scope_t ev_scope = lookup_scope_(ev->scope());\n\n      for (unsigned idx = 0 ;  idx < ev_scope->nevent_ ;  idx += 1) {\n\t    const char*ename = ivl_event_basename(ev_scope->event_[idx]);\n\t    if (strcmp(ev->name(), ename) == 0) {\n\t\t  stmt_cur_->u_.wait_.event = ev_scope->event_[idx];\n\t\t  break;\n\t    }\n      }\n\n      return true;\n}\n\nvoid dll_target::proc_utask(const NetUTask*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_UTASK;\n      stmt_cur_->u_.utask_.def = lookup_scope_(net->task());\n}\n\nbool dll_target::proc_wait(const NetEvWait*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_WAIT;\n      stmt_cur_->u_.wait_.stmt_ = (struct ivl_statement_s*)\n\t    calloc(1, sizeof(struct ivl_statement_s));\n\n      stmt_cur_->u_.wait_.nevent = net->nevents();\n\n\t/* This is a wait fork statement. */\n      if ((net->nevents() == 1) && (net->event(0) == 0)) {\n\t    stmt_cur_->u_.wait_.needs_t0_trigger = 0;\n\t    stmt_cur_->u_.wait_.event = 0;\n\t    stmt_cur_->type_ = IVL_ST_WAIT;\n\t    stmt_cur_->u_.wait_.stmt_->type_ = IVL_ST_NOOP;\n\t    return true;\n      }\n\n      stmt_cur_->u_.wait_.needs_t0_trigger = net->has_t0_trigger();\n\n\t// This event processing code is also in the NB assign above.\n      if (net->nevents() > 1) {\n\t    stmt_cur_->u_.wait_.events = (ivl_event_t*)\n\t\t  calloc(net->nevents(), sizeof(ivl_event_t*));\n      }\n\n      for (unsigned edx = 0 ;  edx < net->nevents() ;  edx += 1) {\n\n\t      /* Locate the event by name. Save the ivl_event_t in the\n\t\t statement so that the generator can find it easily. */\n\t    const NetEvent*ev = net->event(edx);\n\t    ivl_scope_t ev_scope = lookup_scope_(ev->scope());\n\t    ivl_event_t ev_tmp=0;\n\n\t    assert(ev_scope);\n\t    assert(ev_scope->nevent_ > 0);\n\t    for (unsigned idx = 0 ;  idx < ev_scope->nevent_ ;  idx += 1) {\n\t\t  const char*ename = ivl_event_basename(ev_scope->event_[idx]);\n\t\t  if (strcmp(ev->name(), ename) == 0) {\n\t\t\tev_tmp = ev_scope->event_[idx];\n\t\t\tbreak;\n\t\t  }\n\t    }\n\t    // XXX should we assert(ev_tmp)?\n\n\t    if (net->nevents() == 1)\n\t\t  stmt_cur_->u_.wait_.event = ev_tmp;\n\t    else\n\t\t  stmt_cur_->u_.wait_.events[edx] = ev_tmp;\n\n\t      /* If this is an event with a probe, then connect up the\n\t\t pins. This wasn't done during the ::event method because\n\t\t the signals weren't scanned yet. */\n\n\t    if (ev->nprobe() >= 1) {\n\t\t  unsigned iany = 0;\n\t\t  unsigned ineg = ev_tmp->nany;\n\t\t  unsigned ipos = ineg + ev_tmp->nneg;\n\t\t  unsigned iedg = ipos + ev_tmp->npos;\n\n\t\t  for (unsigned idx = 0 ;  idx < ev->nprobe() ;  idx += 1) {\n\t\t\tconst NetEvProbe*pr = ev->probe(idx);\n\t\t\tunsigned base = 0;\n\n\t\t\tswitch (pr->edge()) {\n\t\t\t    case NetEvProbe::ANYEDGE:\n\t\t\t      base = iany;\n\t\t\t      iany += pr->pin_count();\n\t\t\t      break;\n\t\t\t    case NetEvProbe::NEGEDGE:\n\t\t\t      base = ineg;\n\t\t\t      ineg += pr->pin_count();\n\t\t\t      break;\n\t\t\t    case NetEvProbe::POSEDGE:\n\t\t\t      base = ipos;\n\t\t\t      ipos += pr->pin_count();\n\t\t\t      break;\n\t\t\t    case NetEvProbe::EDGE:\n\t\t\t      base = iedg;\n\t\t\t      iedg += pr->pin_count();\n\t\t\t      break;\n\t\t\t}\n\n\t\t\tfor (unsigned bit = 0; bit < pr->pin_count(); bit += 1) {\n\t\t\t      ivl_nexus_t nex = (ivl_nexus_t)\n\t\t\t\t    pr->pin(bit).nexus()->t_cookie();\n\t\t\t      ivl_assert(*ev, nex);\n\t\t\t      ev_tmp->pins[base+bit] = nex;\n\t\t\t}\n\t\t  }\n\t    }\n      }\n\n\t/* The ivl_statement_t for the wait statement is not complete\n\t   until we calculate the sub-statement. */\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n      stmt_cur_ = stmt_cur_->u_.wait_.stmt_;\n      bool flag = net->emit_recurse(this);\n      if (flag && (stmt_cur_->type_ == IVL_ST_NONE))\n\t    stmt_cur_->type_ = IVL_ST_NOOP;\n\n      stmt_cur_ = save_cur_;\n\n      return flag;\n}\n\nvoid dll_target::proc_while(const NetWhile*net)\n{\n      assert(stmt_cur_);\n      assert(stmt_cur_->type_ == IVL_ST_NONE);\n      FILE_NAME(stmt_cur_, net);\n\n      stmt_cur_->type_ = IVL_ST_WHILE;\n      stmt_cur_->u_.while_.stmt_ = (struct ivl_statement_s*)\n\t    calloc(1, sizeof(struct ivl_statement_s));\n\n      assert(expr_ == 0);\n      net->expr()->expr_scan(this);\n      stmt_cur_->u_.while_.cond_ = expr_;\n      expr_ = 0;\n\n\t/* Now generate the statement of the while loop. We know it is\n\t   a single statement, and we know that the\n\t   emit_proc_recurse() will call emit_proc() for it. */\n\n      ivl_statement_t save_cur_ = stmt_cur_;\n      stmt_cur_ = save_cur_->u_.while_.stmt_;\n      net->emit_proc_recurse(this);\n      stmt_cur_ = save_cur_;\n}\n"
        },
        {
          "name": "t-dll.cc",
          "type": "blob",
          "size": 76.421875,
          "content": "/*\n * Copyright (c) 2000-2022 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  <cstring>\n# include  <cstdio> // sprintf()\n# include  \"compiler.h\"\n# include  \"t-dll.h\"\n# include  \"netclass.h\"\n# include  \"netqueue.h\"\n# include  \"netmisc.h\"\n# include  \"discipline.h\"\n# include  <cstdlib>\n# include  \"ivl_assert.h\"\n# include  \"ivl_alloc.h\"\n\nusing namespace std;\n\nstruct dll_target dll_target_obj;\n\n#if defined(__WIN32__)\n\ninline ivl_dll_t ivl_dlopen(const char *name)\n{\n      ivl_dll_t res =  (ivl_dll_t) LoadLibrary(name);\n      return res;\n}\n\n\ninline void * ivl_dlsym(ivl_dll_t dll, const char *nm)\n{\n      return (void*)GetProcAddress((HMODULE)dll, nm);\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{\n      FreeLibrary((HMODULE)dll);\n}\n\nconst char *dlerror(void)\n{\n  static char msg[256];\n  unsigned long err = GetLastError();\n  FormatMessage(\n\t\tFORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\tNULL,\n\t\terr,\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n\t\t(LPTSTR) &msg,\n\t\tsizeof(msg) - 1,\n\t\tNULL\n\t\t);\n  return msg;\n}\n#elif defined(HAVE_DLFCN_H)\ninline ivl_dll_t ivl_dlopen(const char*name)\n{ return dlopen(name,RTLD_LAZY); }\n\ninline void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym = dlsym(dll, nm);\n\t/* Not found? try without the leading _ */\n      if (sym == 0 && nm[0] == '_')\n\t    sym = dlsym(dll, nm+1);\n      return sym;\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{ dlclose(dll); }\n\n#elif defined(HAVE_DL_H)\ninline ivl_dll_t ivl_dlopen(const char*name)\n{ return shl_load(name, BIND_IMMEDIATE, 0); }\n\ninline void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym;\n      int rc = shl_findsym(&dll, nm, TYPE_PROCEDURE, &sym);\n      return (rc == 0) ? sym : 0;\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{ shl_unload(dll); }\n\ninline const char*dlerror(void)\n{ return strerror( errno ); }\n#endif\n\nivl_scope_s::ivl_scope_s()\n: func_type(IVL_VT_NO_TYPE)\n{\n      func_signed = false;\n      func_width = 0;\n}\n\n/*\n * The custom new operator for the ivl_nexus_s type allows us to\n * allocate nexus objects in blocks. There are generally lots of them\n * permanently allocated, and allocating them in blocks reduces the\n * allocation overhead.\n */\n\ntemplate <class TYPE> void* pool_permalloc(size_t s)\n{\n      static TYPE * pool_ptr = 0;\n      static int pool_remaining = 0;\n      static const size_t POOL_SIZE = 4096;\n\n      assert(s == sizeof(TYPE));\n      if (pool_remaining <= 0) {\n\t    pool_ptr = new TYPE[POOL_SIZE];\n\t    pool_remaining = POOL_SIZE;\n      }\n\n      TYPE*tmp = pool_ptr;\n      pool_ptr += 1;\n      pool_remaining -= 1;\n\n      return tmp;\n}\n\nvoid* ivl_nexus_s::operator new(size_t s)\n{\n      return pool_permalloc<struct ivl_nexus_s>(s);\n}\n\nvoid ivl_nexus_s::operator delete(void*, size_t)\n{\n      assert(0);\n}\n\nvoid* ivl_net_const_s::operator new(size_t s)\n{\n      return pool_permalloc<struct ivl_net_const_s>(s);\n}\n\nvoid ivl_net_const_s::operator delete(void*, size_t)\n{\n      assert(0);\n}\n\nstatic StringHeapLex net_const_strings;\n\nstatic perm_string make_scope_name(const hname_t&name)\n{\n      if (! name.has_numbers())\n\t    return name.peek_name();\n\n      char buf[1024];\n      snprintf(buf, sizeof buf, \"%s\", name.peek_name().str());\n\n      char*cp = buf + strlen(buf);\n      size_t ncp = sizeof buf - (cp-buf);\n\n      for (size_t idx = 0 ; idx < name.has_numbers() ; idx += 1) {\n\t    int len = snprintf(cp, ncp, \"[%d]\", name.peek_number(idx));\n\t    cp += len;\n\t    ncp -= len;\n      }\n\n      return lex_strings.make(buf);\n}\n\nstatic void drive_from_link(const Link&lnk, ivl_drive_t&drv0, ivl_drive_t&drv1)\n{\n      drv0 = lnk.drive0();\n      drv1 = lnk.drive1();\n}\n\nivl_attribute_s* dll_target::fill_in_attributes(const Attrib*net)\n{\n      ivl_attribute_s*attr;\n      unsigned nattr = net->attr_cnt();\n\n      if (nattr == 0)\n\t    return 0;\n\n      attr = new struct ivl_attribute_s[nattr];\n\n      for (unsigned idx = 0 ;  idx < nattr ;  idx += 1) {\n\t    verinum tmp = net->attr_value(idx);\n\t    attr[idx].key = net->attr_key(idx);\n\t    if (tmp.is_string()) {\n\t\t  attr[idx].type = IVL_ATT_STR;\n\t\t  attr[idx].val.str = strings_.add(tmp.as_string().c_str());\n\n\t    } else if (tmp == verinum()) {\n\t\t  attr[idx].type = IVL_ATT_VOID;\n\n\t    } else {\n\t\t  attr[idx].type = IVL_ATT_NUM;\n\t\t  attr[idx].val.num = tmp.as_long();\n\t    }\n      }\n\n      return attr;\n}\n\n/*\n * This function locates an ivl_scope_t object that matches the\n * NetScope object. The search works by looking for the parent scope,\n * then scanning the parent scope for the NetScope object.\n */\nstatic ivl_scope_t find_scope_from_root(ivl_scope_t root, const NetScope*cur)\n{\n      if (const NetScope*par = cur->parent()) {\n\t    ivl_scope_t parent = find_scope_from_root(root, par);\n\t    if (parent == 0) {\n\t\t  return 0;\n\t    }\n\n\t    map<hname_t,ivl_scope_t>::iterator idx = parent->children.find(cur->fullname());\n\t    if (idx == parent->children.end())\n\t\t  return 0;\n\t    else\n\t\t  return idx->second;\n\n      } else {\n\t    perm_string cur_name = make_scope_name(cur->fullname());\n\t    if (strcmp(root->name_, cur_name) == 0)\n\t\t  return root;\n      }\n\n      return 0;\n}\n\nivl_scope_t dll_target::find_scope(ivl_design_s &des, const NetScope*cur)\n{\n      assert(cur);\n\n\t// If the scope is a PACKAGE, then it is a special kind of\n\t// root scope and it in the packages array instead.\n      if (cur->type() == NetScope::PACKAGE) {\n\t    perm_string cur_name = cur->module_name();\n\t    for (size_t idx = 0 ; idx < des.packages.size() ; idx += 1) {\n\t\t  if (des.packages[idx]->name_ == cur_name)\n\t\t\treturn des.packages[idx];\n\t    }\n\t    return 0;\n      }\n\n      for (unsigned idx = 0; idx < des.roots.size(); idx += 1) {\n\t    assert(des.roots[idx]);\n\t    ivl_scope_t scop = find_scope_from_root(des.roots[idx], cur);\n\t    if (scop)\n\t\t  return scop;\n      }\n\n      for (size_t idx = 0; idx < des.packages.size(); idx += 1) {\n\t    assert(des.packages[idx]);\n\t    ivl_scope_t scop = find_scope_from_root(des.packages[idx], cur);\n\t    if (scop)\n\t\t  return scop;\n      }\n\n      return 0;\n}\n\nivl_scope_t dll_target::lookup_scope_(const NetScope*cur)\n{\n      return find_scope(des_, cur);\n}\n\n/*\n * This is a convenience function to locate an ivl_signal_t object\n * given the NetESignal that has the signal name.\n */\nivl_signal_t dll_target::find_signal(ivl_design_s &des, const NetNet*net)\n{\n      ivl_scope_t scop = find_scope(des, net->scope());\n      assert(scop);\n\n      perm_string nname = net->name();\n\n      for (unsigned idx = 0 ;  idx < scop->sigs_.size() ;  idx += 1) {\n\t    if (strcmp(scop->sigs_[idx]->name_, nname) == 0)\n\t\t  return scop->sigs_[idx];\n      }\n\n      assert(0);\n      return 0;\n}\n\nstatic ivl_nexus_t nexus_sig_make(ivl_signal_t net, unsigned pin)\n{\n      ivl_nexus_t tmp = new struct ivl_nexus_s;\n      tmp->ptrs_.resize(1);\n      tmp->ptrs_[0].pin_   = pin;\n      tmp->ptrs_[0].type_  = __NEXUS_PTR_SIG;\n      tmp->ptrs_[0].l.sig  = net;\n\n      ivl_drive_t drive = IVL_DR_HiZ;\n      switch (ivl_signal_type(net)) {\n\t  case IVL_SIT_REG:\n\t    drive = IVL_DR_STRONG;\n\t    break;\n\t  default:\n\t    break;\n      }\n      tmp->ptrs_[0].drive0 = drive;\n      tmp->ptrs_[0].drive1 = drive;\n\n      return tmp;\n}\n\nstatic void nexus_sig_add(ivl_nexus_t nex, ivl_signal_t net, unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n      ivl_drive_t drive = IVL_DR_HiZ;\n      switch (ivl_signal_type(net)) {\n\t  case IVL_SIT_REG:\n\t    drive = IVL_DR_STRONG;\n\t    break;\n\t  default:\n\t    break;\n      }\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_SIG;\n      nex->ptrs_[top].drive0 = drive;\n      nex->ptrs_[top].drive1 = drive;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.sig= net;\n}\n\nstatic void nexus_bra_add(ivl_nexus_t nex, ivl_branch_t net, unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n      nex->ptrs_[top].type_= __NEXUS_PTR_BRA;\n      nex->ptrs_[top].drive0 = 0;\n      nex->ptrs_[top].drive1 = 0;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.bra= net;\n}\n\n/*\n * Add the pin of the logic object to the nexus, and return the nexus\n * pointer used for the pin.\n *\n * NOTE: This pointer is only valid until another pin is added to the\n * nexus.\n */\nstatic ivl_nexus_ptr_t nexus_log_add(ivl_nexus_t nex,\n\t\t\t\t     ivl_net_logic_t net,\n\t\t\t\t     unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_LOG;\n      nex->ptrs_[top].drive0 = (pin == 0)? IVL_DR_STRONG : IVL_DR_HiZ;\n      nex->ptrs_[top].drive1 = (pin == 0)? IVL_DR_STRONG : IVL_DR_HiZ;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.log= net;\n\n      return & (nex->ptrs_[top]);\n}\n\nstatic void nexus_con_add(ivl_nexus_t nex, ivl_net_const_t net, unsigned pin,\n\t\t\t  ivl_drive_t drive0, ivl_drive_t drive1)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_CON;\n      nex->ptrs_[top].drive0 = drive0;\n      nex->ptrs_[top].drive1 = drive1;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.con= net;\n}\n\nstatic void nexus_lpm_add(ivl_nexus_t nex, ivl_lpm_t net, unsigned pin,\n\t\t\t  ivl_drive_t drive0, ivl_drive_t drive1)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_LPM;\n      nex->ptrs_[top].drive0 = drive0;\n      nex->ptrs_[top].drive1 = drive1;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.lpm= net;\n}\n\nstatic void nexus_switch_add(ivl_nexus_t nex, ivl_switch_t net, unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_SWI;\n      nex->ptrs_[top].drive0 = IVL_DR_HiZ;\n      nex->ptrs_[top].drive1 = IVL_DR_HiZ;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.swi= net;\n}\n\nvoid scope_add_logic(ivl_scope_t scope, ivl_net_logic_t net)\n{\n      if (scope->nlog_ == 0) {\n\t    scope->nlog_ = 1;\n\t    scope->log_ = (ivl_net_logic_t*)malloc(sizeof(ivl_net_logic_t));\n\t    scope->log_[0] = net;\n\n      } else {\n\t    scope->nlog_ += 1;\n\t    scope->log_ = (ivl_net_logic_t*)\n\t\t  realloc(scope->log_, scope->nlog_*sizeof(ivl_net_logic_t));\n\t    scope->log_[scope->nlog_-1] = net;\n      }\n\n}\n\nvoid scope_add_event(ivl_scope_t scope, ivl_event_t net)\n{\n      if (scope->nevent_ == 0) {\n\t    scope->nevent_ = 1;\n\t    scope->event_ = (ivl_event_t*)malloc(sizeof(ivl_event_t));\n\t    scope->event_[0] = net;\n\n      } else {\n\t    scope->nevent_ += 1;\n\t    scope->event_ = (ivl_event_t*)\n\t\t  realloc(scope->event_, scope->nevent_*sizeof(ivl_event_t));\n\t    scope->event_[scope->nevent_-1] = net;\n      }\n\n}\n\nstatic void scope_add_lpm(ivl_scope_t scope, ivl_lpm_t net)\n{\n      if (scope->nlpm_ == 0) {\n\t    assert(scope->lpm_ == 0);\n\t    scope->nlpm_ = 1;\n\t    scope->lpm_ = (ivl_lpm_t*)malloc(sizeof(ivl_lpm_t));\n\t    scope->lpm_[0] = net;\n\n      } else {\n\t    assert(scope->lpm_);\n\t    scope->nlpm_ += 1;\n\t    scope->lpm_   = (ivl_lpm_t*)\n\t\t  realloc(scope->lpm_,\n\t\t\t  scope->nlpm_*sizeof(ivl_lpm_t));\n\t    scope->lpm_[scope->nlpm_-1] = net;\n      }\n}\n\nstatic void scope_add_switch(ivl_scope_t scope, ivl_switch_t net)\n{\n      scope->switches.push_back(net);\n}\n\nivl_parameter_t dll_target::scope_find_param(ivl_scope_t scope,\n\t\t\t\t\t     const char*name)\n{\n      unsigned idx = 0;\n      while (idx < scope->param.size()) {\n\t    if (strcmp(name, scope->param[idx].basename) == 0)\n\t\t  return &scope->param[idx];\n\n\t    idx += 1;\n      }\n\n      return 0;\n}\n\n/*\n * This method scans the parameters of the scope, and makes\n * ivl_parameter_t objects. This involves saving the name and scanning\n * the expression value.\n */\nvoid dll_target::make_scope_parameters(ivl_scope_t scop, const NetScope*net)\n{\n      if (net->parameters.empty()) {\n\t    scop->param.clear();\n\t    return;\n      }\n\n      scop->param.resize(net->parameters.size());\n\n      unsigned idx = 0;\n      typedef map<perm_string,NetScope::param_expr_t>::const_iterator pit_t;\n\n      for (pit_t cur_pit = net->parameters.begin()\n\t\t ; cur_pit != net->parameters.end() ; ++ cur_pit ) {\n\n\t    assert(idx < scop->param.size());\n\t    ivl_parameter_t cur_par = &scop->param[idx];\n\t    cur_par->basename = cur_pit->first;\n\t    cur_par->local = cur_pit->second.local_flag ||\n\t\t\t     !cur_pit->second.overridable;\n\t    cur_par->is_type = cur_pit->second.type_flag;\n\n\t    if (cur_pit->second.ivl_type == 0) {\n\t\t  cerr << \"?:?: internal error: \"\n\t\t       << \"No type for parameter \" << cur_pit->first\n\t\t       << \" in scope \" << net->fullname() << \"?\" << endl;\n\t    }\n\t    assert(cur_pit->second.ivl_type);\n\n\t    cur_par->signed_flag = cur_pit->second.ivl_type->get_signed();\n\t    cur_par->scope = scop;\n\t    FILE_NAME(cur_par, &(cur_pit->second));\n\n\t      // Type parameters don't have a range or expression\n\t    if (!cur_pit->second.type_flag) {\n\t\t  calculate_param_range(cur_pit->second,\n\t\t\t\t\tcur_pit->second.ivl_type,\n\t\t\t\t\tcur_par->msb, cur_par->lsb,\n\t\t\t\t\tcur_pit->second.val->expr_width());\n\n\t\t  NetExpr*etmp = cur_pit->second.val;\n\t\t  if (etmp == 0) {\n\t\t\tcerr << \"?:?: internal error: What is the parameter \"\n\t\t\t     << \"expression for \" << cur_pit->first\n\t\t\t     << \" in \" << net->fullname() << \"?\" << endl;\n\t\t  }\n\t\t  assert(etmp);\n\t\t  make_scope_param_expr(cur_par, etmp);\n\t    }\n\n\t    idx += 1;\n      }\n}\n\nvoid dll_target::make_scope_param_expr(ivl_parameter_t cur_par, NetExpr*etmp)\n{\n      if (const NetEConst*e = dynamic_cast<const NetEConst*>(etmp)) {\n\n\t    expr_const(e);\n\t    assert(expr_);\n\n\t    switch (expr_->type_) {\n\t\tcase IVL_EX_STRING:\n\t\t  expr_->u_.string_.parameter = cur_par;\n\t\t  break;\n\t\tcase IVL_EX_NUMBER:\n\t\t  expr_->u_.number_.parameter = cur_par;\n\t\t  break;\n\t\tdefault:\n\t\t  assert(0);\n\t    }\n\n      } else if (const NetECReal*er = dynamic_cast<const NetECReal*>(etmp)) {\n\n\t    expr_creal(er);\n\t    assert(expr_);\n\t    assert(expr_->type_ == IVL_EX_REALNUM);\n\t    expr_->u_.real_.parameter = cur_par;\n\n      }\n\n      if (expr_ == 0) {\n\t    cerr << etmp->get_fileline() << \": internal error: \"\n\t\t << \"Parameter expression not reduced to constant? \"\n\t\t << *etmp << endl;\n      }\n      ivl_assert(*etmp, expr_);\n\n      cur_par->value = expr_;\n      expr_ = 0;\n}\n\nstatic void fill_in_scope_function(ivl_scope_t scope, const NetScope*net)\n{\n      scope->type_ = IVL_SCT_FUNCTION;\n      const NetFuncDef*def = net->func_def();\n      assert(def);\n\n      if (def->is_void()) {\n\t      // Special case: If there is no return signal, this is\n\t      // apparently a VOID function.\n\t    scope->func_type = IVL_VT_VOID;\n\t    scope->func_signed = 0;\n\t    scope->func_width = 0;\n      } else {\n\t    const NetNet*return_sig = def->return_sig();\n\t    scope->func_type = return_sig->data_type();\n\t    scope->func_signed = return_sig->get_signed();\n\t    scope->func_width = return_sig->vector_width();\n      }\n\n      scope->tname_ = def->scope()->basename();\n}\n\nvoid dll_target::add_root(const NetScope *s)\n{\n      ivl_scope_t root_ = new struct ivl_scope_s;\n      perm_string name = s->basename();\n      root_->name_ = name;\n      FILE_NAME(root_, s);\n      root_->parent = 0;\n      root_->nlog_ = 0;\n      root_->log_ = 0;\n      root_->nevent_ = 0;\n      root_->event_ = 0;\n      root_->nlpm_ = 0;\n      root_->lpm_ = 0;\n      root_->def = 0;\n      make_scope_parameters(root_, s);\n      root_->tname_ = root_->name_;\n      root_->time_precision = s->time_precision();\n      root_->time_units = s->time_unit();\n      root_->nattr = s->attr_cnt();\n      root_->attr  = fill_in_attributes(s);\n      root_->is_auto = 0;\n      root_->is_cell = s->is_cell();\n      switch (s->type()) {\n\t  case NetScope::PACKAGE:\n\t    root_->type_ = IVL_SCT_PACKAGE;\n\t    break;\n\t  case NetScope::MODULE:\n\t    root_->type_ = IVL_SCT_MODULE;\n\t    break;\n\t  case NetScope::CLASS:\n\t    root_->type_ = IVL_SCT_CLASS;\n\t    break;\n\t  default:\n\t    assert(0);\n      }\n\n      switch (s->type()) {\n\t  case NetScope::MODULE:\n\t    root_->ports = s->module_port_nets();\n\t    if (root_->ports > 0) {\n\t\t  root_->u_.net = new NetNet*[root_->ports];\n\t\t  for (unsigned idx = 0; idx < root_->ports; idx += 1) {\n\t\t\troot_->u_.net[idx] = s->module_port_net(idx);\n\t\t  }\n\t    }\n\t    root_->module_ports_info = s->module_port_info();\n\n\t    des_.roots.push_back(root_);\n\t    break;\n\n\t  case NetScope::PACKAGE:\n\t    root_->ports = 0;\n\t    des_.packages.push_back(root_);\n\t    break;\n\n\t  default:\n\t    assert(0);\n\t    break;\n      }\n}\n\nbool dll_target::start_design(const Design*des)\n{\n      const char*dll_path_ = des->get_flag(\"DLL\");\n\n      dll_ = ivl_dlopen(dll_path_);\n\n      if ((dll_ == 0) && (dll_path_[0] != '/')) {\n\t    size_t len = strlen(basedir) + 1 + strlen(dll_path_) + 1;\n\t    char*tmp = new char[len];\n\t    snprintf(tmp, len, \"%s/%s\", basedir, dll_path_);\n\t    dll_ = ivl_dlopen(tmp);\n\t    delete[]tmp;\n      }\n\n      if (dll_ == 0) {\n\t    cerr << \"error: \" << dll_path_ << \" failed to load.\" << endl;\n\t    cerr << dll_path_ << \": \" << dlerror() << endl;\n\t    return false;\n      }\n\n      stmt_cur_ = 0;\n\n\t// Initialize the design object.\n      des_.self = des;\n      des_.time_precision = des->get_precision();\n\n      des_.disciplines.resize(disciplines.size());\n      unsigned idx = 0;\n      for (map<perm_string,ivl_discipline_t>::const_iterator cur = disciplines.begin()\n\t\t ; cur != disciplines.end() ; ++ cur ) {\n\t    des_.disciplines[idx] = cur->second;\n\t    idx += 1;\n      }\n      assert(idx == des_.disciplines.size());\n\n      list<NetScope *> scope_list;\n\n      scope_list = des->find_package_scopes();\n      for (list<NetScope*>::const_iterator cur = scope_list.begin()\n\t\t ; cur != scope_list.end(); ++ cur ) {\n\t    add_root(*cur);\n      }\n\n      scope_list = des->find_root_scopes();\n      for (list<NetScope*>::const_iterator cur = scope_list.begin()\n\t\t ; cur != scope_list.end(); ++ cur ) {\n\t    add_root(*cur);\n      }\n\n      target_ = (target_design_f)ivl_dlsym(dll_, LU \"target_design\" TU);\n      if (target_ == 0) {\n\t    cerr << dll_path_ << \": error: target_design entry \"\n\t\t  \"point is missing.\" << endl;\n\t    return false;\n      }\n\n      return true;\n}\n\n/*\n * Here ivl is telling us that the design is scanned completely, and\n * here is where we call the API to process the constructed design.\n */\nint dll_target::end_design(const Design*)\n{\n      int rc;\n      if (errors == 0) {\n\t    if (verbose_flag) {\n\t\t  cout << \" ... invoking target_design\" << endl;\n\t    }\n\n\t    rc = (target_)(&des_);\n      } else {\n\t    if (verbose_flag) {\n\t\t  cout << \" ... skipping target_design due to errors.\" << endl;\n\t    }\n\t    rc = errors;\n      }\n\n      ivl_dlclose(dll_);\n      return rc;\n}\n\nvoid dll_target::switch_attributes(struct ivl_switch_s *obj,\n\t\t\t\t   const NetNode*net)\n{\n      obj->nattr = net->attr_cnt();\n      obj->attr  = fill_in_attributes(net);\n}\n\nvoid dll_target::logic_attributes(struct ivl_net_logic_s *obj,\n\t\t\t\t  const NetNode*net)\n{\n      obj->nattr = net->attr_cnt();\n      obj->attr  = fill_in_attributes(net);\n}\n\nvoid dll_target::make_delays_(ivl_expr_t*delay, const NetObj*net)\n{\n      delay[0] = 0;\n      delay[1] = 0;\n      delay[2] = 0;\n\n\t/* Translate delay expressions to ivl_target form. Try to\n\t   preserve pointer equality, not as a rule but to save on\n\t   expression trees. */\n      if (net->rise_time()) {\n\t    expr_ = 0;\n\t    net->rise_time()->expr_scan(this);\n\t    delay[0] = expr_;\n\t    expr_ = 0;\n      }\n      if (net->fall_time()) {\n\t    if (net->fall_time() == net->rise_time()) {\n\t\t  delay[1] = delay[0];\n\t    } else {\n\t\t  expr_ = 0;\n\t\t  net->fall_time()->expr_scan(this);\n\t\t  delay[1] = expr_;\n\t\t  expr_ = 0;\n\t    }\n      }\n      if (net->decay_time()) {\n\t    if (net->decay_time() == net->rise_time()) {\n\t\t  delay[2] = delay[0];\n\t    } else {\n\t\t  expr_ = 0;\n\t\t  net->decay_time()->expr_scan(this);\n\t\t  delay[2] = expr_;\n\t\t  expr_ = 0;\n\t    }\n      }\n}\n\nvoid dll_target::make_logic_delays_(struct ivl_net_logic_s*obj,\n                                    const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nvoid dll_target::make_switch_delays_(struct ivl_switch_s*obj,\n                                    const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nvoid dll_target::make_lpm_delays_(struct ivl_lpm_s*obj,\n\t\t\t\t  const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nvoid dll_target::make_const_delays_(struct ivl_net_const_s*obj,\n\t\t\t\t    const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nbool dll_target::branch(const NetBranch*net)\n{\n      struct ivl_branch_s*obj = net->target_obj();\n      ivl_assert(*net, net->pin_count() == 2);\n\n      assert(net->pin(0).nexus()->t_cookie());\n      obj->pins[0] = net->pin(0).nexus()->t_cookie();\n      nexus_bra_add(obj->pins[0], obj, 0);\n\n      assert(net->pin(1).nexus()->t_cookie());\n      obj->pins[1] = net->pin(1).nexus()->t_cookie();\n      nexus_bra_add(obj->pins[1], obj, 1);\n\n      obj->island = net->get_island();\n\n      return true;\n}\n\n/*\n * Add a bufz object to the scope that contains it.\n *\n * Note that in the ivl_target API a BUFZ device is a special kind of\n * ivl_net_logic_t device, so create an ivl_net_logic_t cookie to\n * handle it.\n */\nbool dll_target::bufz(const NetBUFZ*net)\n{\n      struct ivl_net_logic_s *obj = new struct ivl_net_logic_s;\n\n      assert(net->pin_count() == 2);\n\n      obj->type_ = net->transparent()? IVL_LO_BUFT : IVL_LO_BUFZ;\n      obj->width_= net->width();\n      obj->is_cassign = 0;\n      obj->is_port_buffer = net->port_info_index() >= 0;\n      obj->npins_= 2;\n      obj->pins_ = new ivl_nexus_t[2];\n      FILE_NAME(obj, net);\n\n\t/* Get the ivl_nexus_t objects connected to the two pins.\n\n\t   (We know a priori that the ivl_nexus_t objects have been\n\t   allocated, because the signals have been scanned before\n\t   me. This saves me the trouble of allocating them.) */\n\n      assert(net->pin(0).nexus()->t_cookie());\n      obj->pins_[0] = net->pin(0).nexus()->t_cookie();\n      ivl_nexus_ptr_t out_ptr = nexus_log_add(obj->pins_[0], obj, 0);\n\n      out_ptr->drive0 = net->pin(0).drive0();\n      out_ptr->drive1 = net->pin(0).drive1();\n\n      assert(net->pin(1).nexus()->t_cookie());\n      obj->pins_[1] = net->pin(1).nexus()->t_cookie();\n      nexus_log_add(obj->pins_[1], obj, 1);\n\n\t/* Attach the logic device to the scope that contains it. */\n\n      assert(net->scope());\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      assert(scop);\n\n      obj->scope_ = scop;\n\n      obj->name_ = net->name();\n      logic_attributes(obj, net);\n\n      make_logic_delays_(obj, net);\n\n      scope_add_logic(scop, obj);\n\n\t// Add bufz to the corresponding port_info entry,\n\t// if it is an input / output buffer\n\t// This is needed for the SDF interconnect feature\n\t// to access the buffers directly from the port_info\n      if (obj->is_port_buffer) {\n\t    scop->module_ports_info[net->port_info_index()].buffer = obj;\n      }\n\n      return true;\n}\n\nbool dll_target::class_type(const NetScope*in_scope, netclass_t*net)\n{\n      ivl_scope_t use_scope = find_scope(des_, in_scope);\n      use_scope->classes.push_back(net);\n      return true;\n}\n\nbool dll_target::enumeration(const NetScope*in_scope, netenum_t*net)\n{\n      ivl_scope_t use_scope = find_scope(des_, in_scope);\n      use_scope->enumerations_.push_back(net);\n      return true;\n}\n\nvoid dll_target::event(const NetEvent*net)\n{\n      struct ivl_event_s *obj = new struct ivl_event_s;\n\n      FILE_NAME(obj, net);\n\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      obj->name = net->name();\n      obj->scope = scop;\n      scope_add_event(scop, obj);\n\n      obj->nany = 0;\n      obj->nneg = 0;\n      obj->npos = 0;\n      obj->nedg = 0;\n\n      if (net->nprobe() >= 1) {\n\n\t    for (unsigned idx = 0 ;  idx < net->nprobe() ;  idx += 1) {\n\t\t  const NetEvProbe*pr = net->probe(idx);\n\t\t  switch (pr->edge()) {\n\t\t      case NetEvProbe::ANYEDGE:\n\t\t\tobj->nany += pr->pin_count();\n\t\t\tbreak;\n\t\t      case NetEvProbe::NEGEDGE:\n\t\t\tobj->nneg += pr->pin_count();\n\t\t\tbreak;\n\t\t      case NetEvProbe::POSEDGE:\n\t\t\tobj->npos += pr->pin_count();\n\t\t\tbreak;\n\t\t      case NetEvProbe::EDGE:\n\t\t\tobj->nedg += pr->pin_count();\n\t\t\tbreak;\n\t\t  }\n\t    }\n\n\t    unsigned npins = obj->nany + obj->nneg + obj->npos + obj->nedg;\n\t    obj->pins = (ivl_nexus_t*)calloc(npins, sizeof(ivl_nexus_t));\n\n      } else {\n\t    obj->pins  = 0;\n      }\n\n}\n\nvoid dll_target::logic(const NetLogic*net)\n{\n      struct ivl_net_logic_s *obj = new struct ivl_net_logic_s;\n\n      obj->width_ = net->width();\n      obj->is_port_buffer = 0;\n\n      FILE_NAME(obj, net);\n\n      switch (net->type()) {\n\t  case NetLogic::AND:\n\t    obj->type_ = IVL_LO_AND;\n\t    break;\n\t  case NetLogic::BUF:\n\t    obj->type_ = IVL_LO_BUF;\n\t    break;\n\t  case NetLogic::BUFIF0:\n\t    obj->type_ = IVL_LO_BUFIF0;\n\t    break;\n\t  case NetLogic::BUFIF1:\n\t    obj->type_ = IVL_LO_BUFIF1;\n\t    break;\n\t  case NetLogic::CMOS:\n\t    obj->type_ = IVL_LO_CMOS;\n\t    break;\n\t  case NetLogic::EQUIV:\n\t    obj->type_ = IVL_LO_EQUIV;\n\t    break;\n\t  case NetLogic::IMPL:\n\t    obj->type_ = IVL_LO_IMPL;\n\t    break;\n\t  case NetLogic::NAND:\n\t    obj->type_ = IVL_LO_NAND;\n\t    break;\n\t  case NetLogic::NMOS:\n\t    obj->type_ = IVL_LO_NMOS;\n\t    break;\n\t  case NetLogic::NOR:\n\t    obj->type_ = IVL_LO_NOR;\n\t    break;\n\t  case NetLogic::NOT:\n\t    obj->type_ = IVL_LO_NOT;\n\t    break;\n\t  case NetLogic::NOTIF0:\n\t    obj->type_ = IVL_LO_NOTIF0;\n\t    break;\n\t  case NetLogic::NOTIF1:\n\t    obj->type_ = IVL_LO_NOTIF1;\n\t    break;\n\t  case NetLogic::OR:\n\t    obj->type_ = IVL_LO_OR;\n\t    break;\n\t  case NetLogic::PULLDOWN:\n\t    obj->type_ = IVL_LO_PULLDOWN;\n\t    break;\n\t  case NetLogic::PULLUP:\n\t    obj->type_ = IVL_LO_PULLUP;\n\t    break;\n\t  case NetLogic::RCMOS:\n\t    obj->type_ = IVL_LO_RCMOS;\n\t    break;\n\t  case NetLogic::RNMOS:\n\t    obj->type_ = IVL_LO_RNMOS;\n\t    break;\n\t  case NetLogic::RPMOS:\n\t    obj->type_ = IVL_LO_RPMOS;\n\t    break;\n\t  case NetLogic::PMOS:\n\t    obj->type_ = IVL_LO_PMOS;\n\t    break;\n\t  case NetLogic::XNOR:\n\t    obj->type_ = IVL_LO_XNOR;\n\t    break;\n\t  case NetLogic::XOR:\n\t    obj->type_ = IVL_LO_XOR;\n\t    break;\n\t  default:\n\t    assert(0);\n\t    obj->type_ = IVL_LO_NONE;\n\t    break;\n      }\n\t/* Some of the logical gates are used to represent operators in a\n\t * continuous assignment, so set a flag if that is the case. */\n      obj->is_cassign = net->is_cassign();\n\n\t/* Connect all the ivl_nexus_t objects to the pins of the\n\t   device. */\n\n      obj->npins_ = net->pin_count();\n      obj->pins_ = new ivl_nexus_t[obj->npins_];\n\n      for (unsigned idx = 0 ;  idx < obj->npins_ ;  idx += 1) {\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\t    obj->pins_[idx] = nex->t_cookie();\n\t    ivl_nexus_ptr_t tmp = nexus_log_add(obj->pins_[idx], obj, idx);\n\t    if (idx == 0) {\n\t\t  tmp->drive0 = net->pin(0).drive0();\n\t\t  tmp->drive1 = net->pin(0).drive1();\n\t    }\n      }\n\n      assert(net->scope());\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      assert(scop);\n\n      obj->scope_= scop;\n      obj->name_ = net->name();\n\n      logic_attributes(obj, net);\n\n      make_logic_delays_(obj, net);\n\n      scope_add_logic(scop, obj);\n}\n\nbool dll_target::tran(const NetTran*net)\n{\n      struct ivl_switch_s*obj = new struct ivl_switch_s;\n      obj->type = net->type();\n      obj->width = net->vector_width();\n      obj->part = 0;\n      obj->offset = 0;\n      obj->name = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      obj->island = net->get_island();\n      assert(obj->scope);\n      assert(obj->island);\n      FILE_NAME(obj, net);\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n      obj->pins[0] = nex->t_cookie();\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n      obj->pins[1] = nex->t_cookie();\n\n      nexus_switch_add(obj->pins[0], obj, 0);\n      nexus_switch_add(obj->pins[1], obj, 1);\n\n      if (net->pin_count() > 2) {\n\t    nex = net->pin(2).nexus();\n\t    assert(nex->t_cookie());\n\t    obj->pins[2] = nex->t_cookie();\n\t    nexus_switch_add(obj->pins[2], obj, 2);\n      } else {\n\t    obj->pins[2] = 0;\n      }\n\n      if (obj->type == IVL_SW_TRAN_VP) {\n\t    obj->part  = net->part_width();\n\t    obj->offset= net->part_offset();\n      }\n\n      switch_attributes(obj, net);\n      make_switch_delays_(obj, net);\n      scope_add_switch(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::substitute(const NetSubstitute*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SUBSTITUTE;\n      obj->name = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.substitute.base = net->base();\n\n      obj->u_.substitute.q = net->pin(0).nexus()->t_cookie();\n      obj->u_.substitute.a = net->pin(1).nexus()->t_cookie();\n      obj->u_.substitute.s = net->pin(2).nexus()->t_cookie();\n      nexus_lpm_add(obj->u_.substitute.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n      nexus_lpm_add(obj->u_.substitute.a, obj, 0, IVL_DR_HiZ,    IVL_DR_HiZ);\n      nexus_lpm_add(obj->u_.substitute.s, obj, 0, IVL_DR_HiZ,    IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::sign_extend(const NetSignExtend*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SIGN_EXT;\n      obj->width = net->width();\n      obj->name = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.a, obj, 1, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::ureduce(const NetUReduce*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      switch (net->type()) {\n\t  case NetUReduce::NONE:\n\t    assert(0);\n\t    delete obj;\n\t    return false;\n\t  case NetUReduce::AND:\n\t    obj->type = IVL_LPM_RE_AND;\n\t    break;\n\t  case NetUReduce::OR:\n\t    obj->type = IVL_LPM_RE_OR;\n\t    break;\n\t  case NetUReduce::XOR:\n\t    obj->type = IVL_LPM_RE_XOR;\n\t    break;\n\t  case NetUReduce::NAND:\n\t    obj->type = IVL_LPM_RE_NAND;\n\t    break;\n\t  case NetUReduce::NOR:\n\t    obj->type = IVL_LPM_RE_NOR;\n\t    break;\n\t  case NetUReduce::XNOR:\n\t    obj->type = IVL_LPM_RE_XNOR;\n\t    break;\n      }\n\n      obj->name = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.a, obj, 1, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nvoid dll_target::net_case_cmp(const NetCaseCmp*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      switch (net->kind()) {\n\t  case NetCaseCmp::EEQ:\n\t    obj->type = IVL_LPM_CMP_EEQ;\n\t    break;\n\t  case NetCaseCmp::NEQ:\n\t    obj->type = IVL_LPM_CMP_NEE;\n\t    break;\n\t  case NetCaseCmp::WEQ:\n\t    obj->type = IVL_LPM_CMP_WEQ;\n\t    break;\n\t  case NetCaseCmp::WNE:\n\t    obj->type = IVL_LPM_CMP_WNE;\n\t    break;\n\t  case NetCaseCmp::XEQ:\n\t      obj->type = IVL_LPM_CMP_EQX;\n\t    break;\n\t  case NetCaseCmp::ZEQ:\n\t    obj->type = IVL_LPM_CMP_EQZ;\n\t    break;\n      }\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.arith.signed_flag = 0;\n\n      const Nexus*nex;\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin(2).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nivl_event_t dll_target::make_lpm_trigger(const NetEvWait*net)\n{\n      ivl_event_t trigger = 0;\n      if (net) {\n            const NetEvent*ev = net->event(0);\n\n              /* Locate the event by name. */\n            ivl_scope_t ev_scope = lookup_scope_(ev->scope());\n\n            assert(ev_scope);\n            assert(ev_scope->nevent_ > 0);\n            for (unsigned idx = 0;  idx < ev_scope->nevent_; idx += 1) {\n                  const char*ename =\n                        ivl_event_basename(ev_scope->event_[idx]);\n                  if (strcmp(ev->name(), ename) == 0) {\n                        trigger = ev_scope->event_[idx];\n                        break;\n                  }\n            }\n\n              /* Connect up the probe pins. This wasn't done during the\n                 ::event method because the signals weren't scanned yet. */\n            assert(ev->nprobe() == 1);\n            const NetEvProbe*pr = ev->probe(0);\n            for (unsigned bit = 0; bit < pr->pin_count(); bit += 1) {\n                  ivl_nexus_t nex = (ivl_nexus_t)\n                        pr->pin(bit).nexus()->t_cookie();\n                  assert(nex);\n                  trigger->pins[bit] = nex;\n            }\n      }\n      return trigger;\n}\n\nbool dll_target::net_sysfunction(const NetSysFunc*net)\n{\n      unsigned idx;\n      const Nexus*nex;\n\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SFUNC;\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->u_.sfunc.ports = net->pin_count();\n\n      assert(net->pin_count() >= 1);\n      obj->width = net->vector_width();\n\n      obj->u_.sfunc.fun_name = net->func_name();\n\n      obj->u_.sfunc.pins = new ivl_nexus_t[net->pin_count()];\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.sfunc.pins[0] = nex->t_cookie();\n      nexus_lpm_add(obj->u_.sfunc.pins[0], obj, 0,\n\t\t    IVL_DR_STRONG, IVL_DR_STRONG);\n\n      for (idx = 1 ;  idx < net->pin_count() ;  idx += 1) {\n\t    nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.sfunc.pins[idx] = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.sfunc.pins[idx], obj, 0,\n\t\t\t  IVL_DR_HiZ, IVL_DR_HiZ);\n      }\n\n\t/* Save information about the trigger event if it exists. */\n      obj->u_.sfunc.trigger = make_lpm_trigger(net->trigger());\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n      return true;\n}\n\n/*\n * An IVL_LPM_UFUNC represents a node in a combinational expression\n * that calls a user defined function. I create an LPM object that has\n * the right connections, and refers to the ivl_scope_t of the\n * definition.\n */\nbool dll_target::net_function(const NetUserFunc*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_UFUNC;\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n\t/* Get the definition of the function and save it. */\n      const NetScope*def = net->def();\n      assert(def);\n\n      obj->u_.ufunc.def = lookup_scope_(def);\n\n\t/* Save information about the ports in the ivl_lpm_s\n\t   structure. Note that port 0 is the return value. */\n      obj->u_.ufunc.ports = net->pin_count();\n\n      assert(net->pin_count() >= 1);\n      obj->width = net->port_width(0);\n\n\t/* Now collect all the pins and connect them to the nexa of\n\t   the net. The output pins have strong drive, and the\n\t   remaining input pins are HiZ. */\n\n      obj->u_.ufunc.pins = new ivl_nexus_t[net->pin_count()];\n\n      for (unsigned idx = 0 ;  idx < net->pin_count() ;  idx += 1) {\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\t    ivl_nexus_t nn = nex->t_cookie();\n\t    assert(nn);\n\n\t    obj->u_.ufunc.pins[idx] = nn;\n\t    ivl_drive_t drive = idx == 0 ? IVL_DR_STRONG : IVL_DR_HiZ;\n\t    nexus_lpm_add(obj->u_.ufunc.pins[idx], obj, idx, drive, drive);\n      }\n\n\t/* Save information about the trigger event if it exists. */\n      obj->u_.ufunc.trigger = make_lpm_trigger(net->trigger());\n\n      make_lpm_delays_(obj, net);\n\n\t/* All done. Add this LPM to the scope. */\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nvoid dll_target::udp(const NetUDP*net)\n{\n      struct ivl_net_logic_s *obj = new struct ivl_net_logic_s;\n\n      obj->type_ = IVL_LO_UDP;\n      obj->is_port_buffer = 0;\n      FILE_NAME(obj, net);\n\n\t/* The NetUDP class hasn't learned about width yet, so we\n\t   assume a width of 1. */\n      obj->width_ = 1;\n      obj->is_cassign = 0;\n\n      static map<perm_string,ivl_udp_t> udps;\n      ivl_udp_t u;\n\n      if (udps.find(net->udp_name()) != udps.end()) {\n\t    u = udps[net->udp_name()];\n      } else {\n\t    u = new struct ivl_udp_s;\n\t    u->nrows = net->rows();\n\t    u->table = (ivl_udp_s::ccharp_t*)malloc((u->nrows+1)*sizeof(char*));\n\t    u->table[u->nrows] = 0x0;\n\t    u->nin = net->nin();\n\t    u->sequ = net->is_sequential();\n\t    u->file = net->udp_file();\n\t    u->lineno = net->udp_lineno();\n\t    if (u->sequ) u->init = net->get_initial();\n\t    else u->init = 'x';\n\t    u->name = net->udp_name();\n\t    string inp;\n\t    char out;\n\t    unsigned int i = 0;\n\t    if (net->first(inp, out)) do {\n\t\t  string tt = inp+out;\n\t\t  u->table[i++] = strings_.add(tt.c_str());\n\t    } while (net->next(inp, out));\n\t    assert(i==u->nrows);\n\t    assert((u->nin + 1) == net->port_count());\n\t    u->ports = new string [u->nin + 1];\n\t    for(unsigned idx = 0; idx <= u->nin; idx += 1) {\n\t\t  u->ports[idx] = net->port_name(idx);\n\t    }\n\n\t    udps[net->udp_name()] = u;\n      }\n\n      obj->udp = u;\n\n      // Some duplication of code here, see: dll_target::logic()\n\n        /* Connect all the ivl_nexus_t objects to the pins of the\n\t   device. */\n\n      obj->npins_ = net->pin_count();\n      obj->pins_ = new ivl_nexus_t[obj->npins_];\n      for (unsigned idx = 0 ;  idx < obj->npins_ ;  idx += 1) {\n\t      /* Skip unconnected input pins. These will take on HiZ\n\t\t values by the code generators. */\n\t    if (! net->pin(idx).is_linked()) {\n\t\t  obj->pins_[idx] = 0;\n\t\t  continue;\n\t    }\n\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    ivl_assert(*net, nex && nex->t_cookie());\n\t    obj->pins_[idx] = nex->t_cookie();\n\t    nexus_log_add(obj->pins_[idx], obj, idx);\n      }\n\n      assert(net->scope());\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      assert(scop);\n\n      obj->scope_= scop;\n      obj->name_ = net->name();\n      FILE_NAME(obj, net);\n\n      make_logic_delays_(obj, net);\n\n      obj->nattr = 0;\n      obj->attr = 0;\n\n      scope_add_logic(scop, obj);\n}\n\nvoid dll_target::lpm_abs(const NetAbs*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_ABS;\n      obj->name = net->name(); // NetAddSub names are permallocated.\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->u_.arith.signed_flag = 0;\n      obj->width = net->width();\n\n      const Nexus*nex;\n\t/* the output is pin(0) */\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n\t/* pin(1) is the input data. */\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_add_sub(const NetAddSub*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      if (net->attribute(perm_string::literal(\"LPM_Direction\")) == verinum(\"SUB\"))\n\t    obj->type = IVL_LPM_SUB;\n      else\n\t    obj->type = IVL_LPM_ADD;\n      obj->name = net->name(); // NetAddSub names are permallocated.\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->u_.arith.signed_flag = 0;\n\n\t/* Choose the width of the adder. If the carry bit is\n\t   connected, then widen the adder by one and plan on leaving\n\t   the fake inputs unconnected. */\n      obj->width = net->width();\n      if (net->pin_Cout().is_linked()) {\n\t    obj->width += 1;\n      }\n\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t/* If the carry output is connected, then connect the extra Q\n\t   pin to the carry nexus and zero the a and b inputs. */\n      if (net->pin_Cout().is_linked()) {\n\t    cerr << \"XXXX: t-dll.cc: Forgot how to connect cout.\" << endl;\n      }\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nbool dll_target::lpm_array_dq(const NetArrayDq*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_ARRAY;\n      obj->name = net->name();\n      obj->u_.array.sig = find_signal(des_, net->mem());\n      assert(obj->u_.array.sig);\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n      obj->width = net->width();\n      obj->u_.array.swid = net->awidth();\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      const Nexus*nex;\n\n      nex = net->pin_Address().nexus();\n      assert(nex->t_cookie());\n      obj->u_.array.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.array.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n      obj->u_.array.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.array.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      return true;\n}\n\n/*\n * The lpm_clshift device represents both left and right shifts,\n * depending on what is connected to the Direction pin. We convert\n * this device into SHIFTL or SHIFTR devices.\n */\nvoid dll_target::lpm_clshift(const NetCLShift*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SHIFTL;\n      obj->name = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n\t/* Look at the direction input of the device, and select the\n\t   shift direction accordingly. */\n      if (net->right_flag())\n\t    obj->type = IVL_LPM_SHIFTR;\n      if (net->signed_flag())\n\t    obj->u_.shift.signed_flag = 1;\n      else\n\t    obj->u_.shift.signed_flag = 0;\n\n      obj->width = net->width();\n      obj->u_.shift.select = net->width_dist();\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.shift.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.shift.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_Data().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.shift.d = nex->t_cookie();\n      nexus_lpm_add(obj->u_.shift.d, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_Distance().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.shift.s = nex->t_cookie();\n      nexus_lpm_add(obj->u_.shift.s, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nbool dll_target::lpm_arith1_(ivl_lpm_type_t lpm_type, unsigned width, bool signed_flag, const NetNode*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = lpm_type;\n      obj->name = net->name(); // NetCastInt2 names are permallocated\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = width;\n      obj->u_.arith.signed_flag = signed_flag? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n      obj->u_.arith.a = nex->t_cookie();\n\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::lpm_cast_int2(const NetCastInt2*net)\n{\n      return lpm_arith1_(IVL_LPM_CAST_INT2, net->width(), true, net);\n}\n\nbool dll_target::lpm_cast_int4(const NetCastInt4*net)\n{\n      return lpm_arith1_(IVL_LPM_CAST_INT, net->width(), true, net);\n}\n\nbool dll_target::lpm_cast_real(const NetCastReal*net)\n{\n      return lpm_arith1_(IVL_LPM_CAST_REAL, 0, net->signed_flag(), net);\n}\n\n/*\n * Make out of the NetCompare object an ivl_lpm_s object. The\n * comparators in ivl_target do not support < or <=, but they can be\n * trivially converted to > and >= by swapping the operands.\n */\nvoid dll_target::lpm_compare(const NetCompare*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->name = net->name(); // NetCompare names are permallocated\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      bool swap_operands = false;\n\n      obj->width = net->width();\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n\n\n      if (net->pin_AGEB().is_linked()) {\n\t    nex = net->pin_AGEB().nexus();\n\t    obj->type = IVL_LPM_CMP_GE;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else if (net->pin_AGB().is_linked()) {\n\t    nex = net->pin_AGB().nexus();\n\t    obj->type = IVL_LPM_CMP_GT;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else if (net->pin_ALEB().is_linked()) {\n\t    nex = net->pin_ALEB().nexus();\n\t    obj->type = IVL_LPM_CMP_GE;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n\t    swap_operands = true;\n\n      } else if (net->pin_ALB().is_linked()) {\n\t    nex = net->pin_ALB().nexus();\n\t    obj->type = IVL_LPM_CMP_GT;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n\t    swap_operands = true;\n\n      } else if (net->pin_AEB().is_linked()) {\n\t    nex = net->pin_AEB().nexus();\n\t    obj->type = IVL_LPM_CMP_EQ;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else if (net->pin_ANEB().is_linked()) {\n\t    nex = net->pin_ANEB().nexus();\n\t    obj->type = IVL_LPM_CMP_NE;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else {\n\t    assert(0);\n      }\n\n      if (swap_operands) {\n\t    ivl_nexus_t tmp = obj->u_.arith.a;\n\t    obj->u_.arith.a = obj->u_.arith.b;\n\t    obj->u_.arith.b = tmp;\n      }\n\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_divide(const NetDivide*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_DIVIDE;\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n\n      obj->width = wid;\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_modulo(const NetModulo*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_MOD;\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n\n      obj->width = wid;\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_ff(const NetFF*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_FF;\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n\n      scope_add_lpm(obj->scope, obj);\n\n      const Nexus*nex;\n\n\t/* Set the clock polarity. */\n      obj->u_.ff.negedge_flag = net->is_negedge();\n\n\t/* Set the clk signal to point to the nexus, and the nexus to\n\t   point back to this device. */\n      nex = net->pin_Clock().nexus();\n      assert(nex->t_cookie());\n      obj->u_.ff.clk = nex->t_cookie();\n      assert(obj->u_.ff.clk);\n      nexus_lpm_add(obj->u_.ff.clk, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t/* If there is a clock enable, then connect it up to the FF\n\t   device. */\n      if (net->pin_Enable().is_linked()) {\n\t    nex = net->pin_Enable().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.we = nex->t_cookie();\n\t    assert(obj->u_.ff.we);\n\t    nexus_lpm_add(obj->u_.ff.we, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      } else {\n\t    obj->u_.ff.we = 0;\n      }\n\n      if (net->pin_Aclr().is_linked()) {\n\t    nex = net->pin_Aclr().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.aclr = nex->t_cookie();\n\t    assert(obj->u_.ff.aclr);\n\t    nexus_lpm_add(obj->u_.ff.aclr, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      } else {\n\t    obj->u_.ff.aclr = 0;\n      }\n\n      if (net->pin_Aset().is_linked()) {\n\t    nex = net->pin_Aset().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.aset = nex->t_cookie();\n\t    assert(obj->u_.ff.aset);\n\t    nexus_lpm_add(obj->u_.ff.aset, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t    verinum tmp = net->aset_value();\n\t    if (tmp.len() > 0)\n\t\t  obj->u_.ff.aset_value = expr_from_value_(tmp);\n\t    else\n\t\t  obj->u_.ff.aset_value = 0;\n\n      } else {\n\t    obj->u_.ff.aset = 0;\n\t    obj->u_.ff.aset_value = 0;\n      }\n\n      if (net->pin_Sclr().is_linked()) {\n\t    nex = net->pin_Sclr().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.sclr = nex->t_cookie();\n\t    assert(obj->u_.ff.sclr);\n\t    nexus_lpm_add(obj->u_.ff.sclr, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      } else {\n\t    obj->u_.ff.sclr = 0;\n      }\n\n      if (net->pin_Sset().is_linked()) {\n\t    nex = net->pin_Sset().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.sset = nex->t_cookie();\n\t    assert(obj->u_.ff.sset);\n\t    nexus_lpm_add(obj->u_.ff.sset, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t    verinum tmp = net->sset_value();\n\t    if (tmp.len() > 0)\n\t\t  obj->u_.ff.sset_value = expr_from_value_(tmp);\n\t    else\n\t\t  obj->u_.ff.sset_value = 0;\n\n      } else {\n\t    obj->u_.ff.sset = 0;\n\t    obj->u_.ff.sset_value = 0;\n      }\n\n      nex = net->pin_Q().nexus();\n      assert(nex->t_cookie());\n      obj->u_.ff.q.pin = nex->t_cookie();\n      nexus_lpm_add(obj->u_.ff.q.pin, obj, 0,\n\t\t    IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_Data().nexus();\n      assert(nex->t_cookie());\n      obj->u_.ff.d.pin = nex->t_cookie();\n      nexus_lpm_add(obj->u_.ff.d.pin, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n}\n\nvoid dll_target::lpm_latch(const NetLatch*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_LATCH;\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n\n      scope_add_lpm(obj->scope, obj);\n\n      const Nexus*nex;\n\n      nex = net->pin_Enable().nexus();\n      assert(nex->t_cookie());\n      obj->u_.latch.e = nex->t_cookie();\n      assert(obj->u_.latch.e);\n      nexus_lpm_add(obj->u_.latch.e, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_Q().nexus();\n      assert(nex->t_cookie());\n      obj->u_.latch.q.pin = nex->t_cookie();\n      nexus_lpm_add(obj->u_.latch.q.pin, obj, 0,\n\t\t    IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_Data().nexus();\n      assert(nex->t_cookie());\n      obj->u_.latch.d.pin = nex->t_cookie();\n      nexus_lpm_add(obj->u_.latch.d.pin, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n}\n\n/*\n * Make the NetMult object into an IVL_LPM_MULT node.\n */\nvoid dll_target::lpm_mult(const NetMult*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_MULT;\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n\n      obj->width = wid;\n      obj->u_.arith.signed_flag = 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\n/*\n * Hook up the mux devices so that the select expression selects the\n * correct sub-expression with the ivl_lpm_data2 function.\n */\nvoid dll_target::lpm_mux(const NetMux*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_MUX;\n      obj->name  = net->name(); // The NetMux permallocates its name.\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.mux.size  = net->size();\n      obj->u_.mux.swid  = net->sel_width();\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      const Nexus*nex;\n\n\t/* Connect the output bits. */\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n      obj->u_.mux.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.mux.q, obj, 0,\n\t\t    net->pin_Result().drive0(),\n\t\t    net->pin_Result().drive1());\n\n\t/* Connect the select bits. */\n      nex = net->pin_Sel().nexus();\n      assert(nex->t_cookie());\n      obj->u_.mux.s = nex->t_cookie();\n      nexus_lpm_add(obj->u_.mux.s, obj, 0,\n\t\t    IVL_DR_HiZ, IVL_DR_HiZ);\n\n      unsigned selects = obj->u_.mux.size;\n\n      obj->u_.mux.d = new ivl_nexus_t [selects];\n\n      for (unsigned sdx = 0 ;  sdx < selects ;  sdx += 1) {\n\t    nex = net->pin_Data(sdx).nexus();\n\t    ivl_nexus_t tmp = nex->t_cookie();\n\t    obj->u_.mux.d[sdx] = tmp;\n\t    if (tmp == 0) {\n\t\t  cerr << net->get_fileline() << \": internal error: \"\n\t\t       << \"dll_target::lpm_mux: \"\n\t\t       << \"Missing data port \" << sdx\n\t\t       << \" of mux \" << obj->name << \".\" << endl;\n\t    }\n\t    ivl_assert(*net, tmp);\n\t    nexus_lpm_add(tmp, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      }\n\n}\n\n/*\n * Make the NetPow object into an IVL_LPM_POW node.\n */\nvoid dll_target::lpm_pow(const NetPow*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_POW;\n      FILE_NAME(obj, net);\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      obj->width = wid;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nbool dll_target::concat(const NetConcat*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = net->transparent()? IVL_LPM_CONCATZ : IVL_LPM_CONCAT;\n      obj->name = net->name(); // NetConcat names are permallocated\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n\n      obj->u_.concat.inputs = net->pin_count() - 1;\n      obj->u_.concat.pins = new ivl_nexus_t[obj->u_.concat.inputs+1];\n\n      for (unsigned idx = 0 ;  idx < obj->u_.concat.inputs+1 ; idx += 1) {\n\t    ivl_drive_t dr = idx == 0? IVL_DR_STRONG : IVL_DR_HiZ;\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.concat.pins[idx] = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.concat.pins[idx], obj, 0, dr, dr);\n      }\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::part_select(const NetPartSelect*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      switch (net->dir()) {\n\t  case NetPartSelect::VP:\n\t    obj->type = IVL_LPM_PART_VP;\n\t    break;\n\t  case NetPartSelect::PV:\n\t    obj->type = IVL_LPM_PART_PV;\n\t    break;\n      }\n      obj->name = net->name(); // NetPartSelect names are permallocated.\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n\t/* Part selects are always unsigned, so we use this to indicate\n\t * if the part select base signal is signed or not. */\n      if (net->signed_flag())\n\t    obj->u_.part.signed_flag = 1;\n      else\n\t    obj->u_.part.signed_flag = 0;\n\n\t/* Choose the width of the part select. */\n      obj->width = net->width();\n      obj->u_.part.base  = net->base();\n      obj->u_.part.s = 0;\n\n      const Nexus*nex;\n\n      switch (obj->type) {\n\t  case IVL_LPM_PART_VP:\n\t      /* NetPartSelect:pin(0) is the output pin. */\n\t    nex = net->pin(0).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.q = nex->t_cookie();\n\n\t      /* NetPartSelect:pin(1) is the input pin. */\n\t    nex = net->pin(1).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.a = nex->t_cookie();\n\n\t      /* If the part select has an additional pin, that pin is\n\t\t a variable select base. */\n\t    if (net->pin_count() >= 3) {\n\t\t  nex = net->pin(2).nexus();\n\t\t  assert(nex->t_cookie());\n\t\t  obj->u_.part.s = nex->t_cookie();\n\t    }\n\t    break;\n\n\t  case IVL_LPM_PART_PV:\n\t      /* NetPartSelect:pin(1) is the output pin. */\n\t    nex = net->pin(1).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.q = nex->t_cookie();\n\n\t      /* NetPartSelect:pin(0) is the input pin. */\n\t    nex = net->pin(0).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.a = nex->t_cookie();\n\t    break;\n\n\t  default:\n\t    assert(0);\n      }\n\n      nexus_lpm_add(obj->u_.part.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n      nexus_lpm_add(obj->u_.part.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t/* The select input is optional. */\n      if (obj->u_.part.s)\n\t  nexus_lpm_add(obj->u_.part.s, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::replicate(const NetReplicate*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_REPEAT;\n      obj->name = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.repeat.count = net->repeat();\n\n      ivl_drive_t dr = IVL_DR_STRONG;\n      const Nexus*nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.repeat.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.repeat.q, obj, 0, dr, dr);\n\n      dr = IVL_DR_HiZ;\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.repeat.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.repeat.a, obj, 0, dr, dr);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\n/*\n * The assignment l-values are captured by the assignment statements\n * themselves in the process handling.\n */\nvoid dll_target::net_assign(const NetAssign_*) const\n{\n}\n\nbool dll_target::net_const(const NetConst*net)\n{\n      unsigned idx;\n      char*bits;\n      static char*bits_tmp = 0;\n      static unsigned bits_cnt = 0;\n\n      struct ivl_net_const_s *obj = new struct ivl_net_const_s;\n\n      if (net->is_string()) {\n\t    obj->type = IVL_VT_STRING;\n\t    assert((net->width() % 8) == 0);\n      } else obj->type = IVL_VT_BOOL;\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      FILE_NAME(obj, net);\n\n\t/* constants have a single vector output. */\n      assert(net->pin_count() == 1);\n\n      obj->width_ = net->width();\n      obj->signed_ = net->value().has_sign();\n      if (obj->width_ <= sizeof(obj->b.bit_)) {\n\t    bits = obj->b.bit_;\n\n      } else {\n\t    if (obj->width_ >= bits_cnt) {\n\t\t  bits_tmp = (char*)realloc(bits_tmp, obj->width_+1);\n\t\t  bits_cnt = obj->width_+1;\n\t    }\n\t    bits = bits_tmp;\n      }\n\n      for (idx = 0 ;  idx < obj->width_ ;  idx += 1)\n\t    switch (net->value(idx)) {\n\t\tcase verinum::V0:\n\t\t  bits[idx] = '0';\n\t\t  break;\n\t\tcase verinum::V1:\n\t\t  bits[idx] = '1';\n\t\t  break;\n\t\tcase verinum::Vx:\n\t\t  if (obj->type == IVL_VT_BOOL)\n\t\t\tobj->type = IVL_VT_LOGIC;\n\t\t  bits[idx] = 'x';\n\t\t  assert(! net->is_string());\n\t\t  break;\n\t\tcase verinum::Vz:\n\t\t  if (obj->type == IVL_VT_BOOL)\n\t\t\tobj->type = IVL_VT_LOGIC;\n\t\t  bits[idx] = 'z';\n\t\t  assert(! net->is_string());\n\t\t  break;\n\t    }\n\n      if (obj->width_ > sizeof(obj->b.bit_)) {\n\t    bits[obj->width_] = 0;\n\t    obj->b.bits_ = net_const_strings.make(bits);\n      }\n\n\t/* Connect to all the nexus objects. Note that the one-bit\n\t   case can be handled more efficiently without allocating\n\t   array space. */\n\n      ivl_drive_t drv0, drv1;\n      drive_from_link(net->pin(0), drv0, drv1);\n      const Nexus*nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n      obj->pin_ = nex->t_cookie();\n      nexus_con_add(obj->pin_, obj, 0, drv0, drv1);\n\n      des_.consts.push_back(obj);\n\n      make_const_delays_(obj, net);\n\n      return true;\n}\n\nbool dll_target::net_literal(const NetLiteral*net)\n{\n\n      struct ivl_net_const_s *obj = new struct ivl_net_const_s;\n\n      obj->type = IVL_VT_REAL;\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      FILE_NAME(obj, net);\n      obj->width_  = 1;\n      obj->signed_ = 1;\n      obj->b.real_value = net->value_real().as_double();\n\n\t/* Connect to all the nexus objects. Note that the one-bit\n\t   case can be handled more efficiently without allocating\n\t   array space. */\n\n      ivl_drive_t drv0, drv1;\n      drive_from_link(net->pin(0), drv0, drv1);\n      const Nexus*nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n      obj->pin_ = nex->t_cookie();\n      nexus_con_add(obj->pin_, obj, 0, drv0, drv1);\n\n      des_.consts.push_back(obj);\n\n      make_const_delays_(obj, net);\n\n      return true;\n}\n\nvoid dll_target::net_probe(const NetEvProbe*)\n{\n}\n\nvoid dll_target::scope(const NetScope*net)\n{\n      if (net->parent() == 0) {\n\n\t      // Root scopes are already created...\n\n      } else {\n\t    perm_string sname = make_scope_name(net->fullname());\n\t    ivl_scope_t scop = new struct ivl_scope_s;\n\t    scop->name_ = sname;\n\t    FILE_NAME(scop, net);\n\t    scop->parent = find_scope(des_, net->parent());\n\t    assert(scop->parent);\n\t    scop->parent->children[net->fullname()] = scop;\n\t    scop->parent->child .push_back(scop);\n\t    scop->nlog_ = 0;\n\t    scop->log_ = 0;\n\t    scop->nevent_ = 0;\n\t    scop->event_ = 0;\n\t    scop->nlpm_ = 0;\n\t    scop->lpm_ = 0;\n\t    scop->def = 0;\n\t    make_scope_parameters(scop, net);\n\t    scop->time_precision = net->time_precision();\n\t    scop->time_units = net->time_unit();\n\t    scop->nattr = net->attr_cnt();\n\t    scop->attr = fill_in_attributes(net);\n\t    scop->is_auto = net->is_auto();\n\t    scop->is_cell = net->is_cell();\n\n\t    switch (net->type()) {\n\t\tcase NetScope::PACKAGE:\n\t\t  cerr << \"?:?\" << \": internal error: \"\n\t\t       << \"Package scopes should not have parents.\" << endl;\n\t\t  // fallthrough\n\t\tcase NetScope::MODULE:\n\t\t  scop->type_ = IVL_SCT_MODULE;\n\t\t  scop->tname_ = net->module_name();\n\t\t  scop->ports = net->module_port_nets();\n\t\t  if (scop->ports > 0) {\n\t\t\tscop->u_.net = new NetNet*[scop->ports];\n\t\t\tfor (unsigned idx = 0; idx < scop->ports; idx += 1) {\n\t\t\t      scop->u_.net[idx] = net->module_port_net(idx);\n\t\t\t}\n\t\t  }\n\t\t  scop->module_ports_info = net->module_port_info();\n\t\t  break;\n\n\t\tcase NetScope::TASK: {\n\t\t      const NetTaskDef*def = net->task_def();\n\t\t      if (def == 0) {\n\t\t\t    cerr <<  \"?:?\" << \": internal error: \"\n\t\t\t\t << \"task \" << scop->name_\n\t\t\t\t << \" has no definition.\" << endl;\n\t\t      }\n\t\t      assert(def);\n\t\t      scop->type_ = IVL_SCT_TASK;\n\t\t      scop->tname_ = def->scope()->basename();\n\t\t      break;\n\t\t}\n\t\tcase NetScope::FUNC:\n\t\t  fill_in_scope_function(scop, net);\n\t\t  break;\n\t\tcase NetScope::BEGIN_END:\n\t\t  scop->type_ = IVL_SCT_BEGIN;\n\t\t  scop->tname_ = scop->name_;\n\t\t  break;\n\t\tcase NetScope::FORK_JOIN:\n\t\t  scop->type_ = IVL_SCT_FORK;\n\t\t  scop->tname_ = scop->name_;\n\t\t  break;\n\t\tcase NetScope::GENBLOCK:\n\t\t  scop->type_ = IVL_SCT_GENERATE;\n\t\t  scop->tname_ = scop->name_;\n\t\t  break;\n\t\tcase NetScope::CLASS:\n\t\t  scop->type_ = IVL_SCT_CLASS;\n\t\t  scop->tname_ = scop->name_;\n\t\t  break;\n\t    }\n      }\n}\n\nvoid dll_target::convert_module_ports(const NetScope*net)\n{\n      ivl_scope_t scop = find_scope(des_, net);\n      if (scop->ports > 0) {\n\t    NetNet**nets = scop->u_.net;\n\t    scop->u_.nex = new ivl_nexus_t[scop->ports];\n\t    for (unsigned idx = 0; idx < scop->ports; idx += 1) {\n\t\t  ivl_signal_t sig = find_signal(des_, nets[idx]);\n\t\t  scop->u_.nex[idx] = nexus_sig_make(sig, 0);\n\t    }\n\t    delete [] nets;\n      }\n}\n\nvoid dll_target::signal(const NetNet*net)\n{\n      ivl_signal_t obj = new struct ivl_signal_s;\n\n      obj->name_ = net->name();\n\n\t/* Attach the signal to the ivl_scope_t object that contains\n\t   it. This involves growing the sigs_ array in the scope\n\t   object, or creating the sigs_ array if this is the first\n\t   signal. */\n      obj->scope_ = find_scope(des_, net->scope());\n      assert(obj->scope_);\n      FILE_NAME(obj, net);\n\n      obj->scope_->sigs_.push_back(obj);\n\n\n\t/* Save the primitive properties of the signal in the\n\t   ivl_signal_t object. */\n\n      { size_t idx = 0;\n\tnetranges_t::const_iterator cur;\n\tobj->packed_dims.resize(net->packed_dims().size());\n\tfor (cur = net->packed_dims().begin(), idx = 0\n\t\t   ; cur != net->packed_dims().end() ; ++cur, idx += 1) {\n\t    obj->packed_dims[idx] = *cur;\n\t}\n      }\n\n      obj->net_type = net->net_type();\n      obj->local_ = net->local_flag()? 1 : 0;\n      obj->forced_net_ = (net->type() != NetNet::REG) &&\n                         (net->peek_lref() > 0) ? 1 : 0;\n      obj->discipline = net->get_discipline();\n\n      obj->array_dimensions_ = net->unpacked_dimensions();\n\n      switch (net->port_type()) {\n\n\t  case NetNet::PINPUT:\n\t    obj->port_ = IVL_SIP_INPUT;\n\t    break;\n\n\t  case NetNet::POUTPUT:\n\t    obj->port_ = IVL_SIP_OUTPUT;\n\t    break;\n\n\t  case NetNet::PINOUT:\n\t    obj->port_ = IVL_SIP_INOUT;\n\t    break;\n\n\t  default:\n\t    obj->port_ = IVL_SIP_NONE;\n\t    break;\n      }\n\n      obj->module_port_index_ = net->get_module_port_index();\n\n      switch (net->type()) {\n\n\t  case NetNet::REG:\n\t    obj->type_ = IVL_SIT_REG;\n\t    break;\n\n\t      /* The SUPPLY0/1 net types are replaced with pulldown/up\n\t\t by elaborate. They should not make it here. */\n\t  case NetNet::SUPPLY0:\n\t    assert(0);\n\t    break;\n\t  case NetNet::SUPPLY1:\n\t    assert(0);\n\t    break;\n\n\t      /* We will convert this to a TRI after we check that there\n\t\t is only one driver. */\n\t  case NetNet::UNRESOLVED_WIRE:\n\t    obj->type_ = IVL_SIT_UWIRE;\n\t    break;\n\n\t  case NetNet::TRI:\n\t  case NetNet::WIRE:\n\t  case NetNet::IMPLICIT:\n\t    obj->type_ = IVL_SIT_TRI;\n\t    break;\n\n\t  case NetNet::TRI0:\n\t    obj->type_ = IVL_SIT_TRI0;\n\t    break;\n\n\t  case NetNet::TRI1:\n\t    obj->type_ = IVL_SIT_TRI1;\n\t    break;\n\n\t  case NetNet::TRIAND:\n\t  case NetNet::WAND:\n\t    obj->type_ = IVL_SIT_TRIAND;\n\t    break;\n\n\t  case NetNet::TRIOR:\n\t  case NetNet::WOR:\n\t    obj->type_ = IVL_SIT_TRIOR;\n\t    break;\n\n\t  default:\n\t    obj->type_ = IVL_SIT_NONE;\n\t    break;\n      }\n\n\t/* Initialize the path fields to be filled in later. */\n      obj->npath = 0;\n      obj->path = 0;\n\n      obj->nattr = net->attr_cnt();\n      obj->attr = fill_in_attributes(net);\n\n      // Special case: IVL_VT_QUEUE objects don't normally show up in the\n      // network,  but can in certain special cases. In these cases, it is the\n      // object itself and not the array elements that is in the network. of\n      // course, only do this if there is at least one link to this signal.\n      if (obj->net_type->base_type()==IVL_VT_QUEUE && net->is_linked()) {\n\t    const Nexus*nex = net->pin(0).nexus();\n\t    ivl_nexus_t tmp = nexus_sig_make(obj, 0);\n\t    tmp->nexus_ = nex;\n\t    tmp->name_ = 0;\n\t    nex->t_cookie(tmp);\n      }\n\n\t/* Get the nexus objects for all the pins of the signal. If\n\t   the signal has only one pin, then write the single\n\t   ivl_nexus_t object into n.pin_. Otherwise, make an array of\n\t   ivl_nexus_t cookies.\n\n\t   When I create an ivl_nexus_t object, store it in the\n\t   t_cookie of the Nexus object so that I find it again when I\n\t   next encounter the nexus. */\n\n      if (obj->array_dimensions_ == 1) {\n\t    const netranges_t& dims = net->unpacked_dims();\n\t    if (dims[0].get_msb() < dims[0].get_lsb()) {\n\t\t  obj->array_base = dims[0].get_msb();\n\t\t  obj->array_addr_swapped = false;\n\t    } else {\n\t\t  obj->array_base = dims[0].get_lsb();\n\t\t  obj->array_addr_swapped = true;\n\t    }\n\t    obj->array_words = net->unpacked_count();\n      } else {\n\t      // The back-end API doesn't yet support multi-dimension\n\t      // unpacked arrays, so just report the canonical dimensions.\n\t    obj->array_base = 0;\n\t      // For a queue we pass the maximum queue size as the array words.\n\t    if (obj->net_type->base_type() == IVL_VT_QUEUE) {\n\t\t  long max_size = net->queue_type()->max_idx()+1;\n\t\t  ivl_assert(*net, max_size >= 0);\n\t\t  obj->array_words = max_size;\n\t    } else\n\t\t  obj->array_words = net->unpacked_count();\n\t    obj->array_addr_swapped = 0;\n      }\n\n      ivl_assert(*net, (obj->array_words == net->pin_count()) ||\n                       (obj->net_type->base_type() == IVL_VT_QUEUE));\n      if (debug_optimizer && obj->array_words > 1000) cerr << \"debug: \"\n\t    \"t-dll creating nexus array \" << obj->array_words << \" long\" << endl;\n      if (obj->array_words > 1 && net->pins_are_virtual()) {\n\t    obj->pins = NULL;\n\t    if (debug_optimizer && obj->array_words > 1000) cerr << \"debug: \"\n\t\t\"t-dll used NULL for big nexus array\" << endl;\n\t    return;\n      }\n      if (obj->array_words > 1)\n\t    obj->pins = new ivl_nexus_t[obj->array_words];\n\n      for (unsigned idx = 0 ;  idx < obj->array_words ;  idx += 1) {\n\n\t    const Nexus*nex = net->pins_are_virtual() ? NULL : net->pin(idx).nexus();\n\t    if (nex == 0) {\n\t\t    // Special case: This pin is connected to\n\t\t    // nothing. This can happen, for example, if the\n\t\t    // variable is only used in behavioral\n\t\t    // code. Create a stub nexus.\n\t\t  ivl_nexus_t tmp = nexus_sig_make(obj, idx);\n\t\t  tmp->nexus_ = nex;\n\t\t  tmp->name_ = 0;\n\t\t  if (obj->array_words > 1)\n\t\t\tobj->pins[idx] = tmp;\n\t\t  else\n\t\t\tobj->pin = tmp;\n\t    } else if (nex->t_cookie()) {\n\t\t  if (obj->array_words > 1) {\n\t\t\tobj->pins[idx] = nex->t_cookie();\n\t\t\tnexus_sig_add(obj->pins[idx], obj, idx);\n\t\t  } else {\n\t\t\tobj->pin = nex->t_cookie();\n\t\t\tnexus_sig_add(obj->pin, obj, idx);\n\t\t  }\n\t    } else {\n\t\t  ivl_nexus_t tmp = nexus_sig_make(obj, idx);\n\t\t  tmp->nexus_ = nex;\n\t\t  tmp->name_ = 0;\n\t\t  nex->t_cookie(tmp);\n\t\t  if (obj->array_words > 1)\n\t\t\tobj->pins[idx] = tmp;\n\t\t  else\n\t\t\tobj->pin = tmp;\n\t    }\n      }\n      if (debug_optimizer && obj->array_words > 1000) cerr << \"debug: t-dll done with big nexus array\" << endl;\n}\n\nbool dll_target::signal_paths(const NetNet*net)\n{\n\t/* Nothing to do if there are no paths for this signal. */\n      if (net->delay_paths() == 0)\n\t    return true;\n\n      ivl_signal_t obj = find_signal(des_, net);\n      assert(obj);\n\n\t/* We cannot have already set up the paths for this signal. */\n      assert(obj->npath == 0);\n      assert(obj->path == 0);\n\n         /* Figure out how many paths there really are. */\n      for (unsigned idx = 0 ;  idx < net->delay_paths() ;  idx += 1) {\n\t    const NetDelaySrc*src = net->delay_path(idx);\n\t    obj->npath += src->src_count();\n      }\n\n      obj->path = new struct ivl_delaypath_s[obj->npath];\n\n      unsigned ptr = 0;\n      for (unsigned idx = 0 ;  idx < net->delay_paths() ;  idx += 1) {\n\t    const NetDelaySrc*src = net->delay_path(idx);\n\n\t      /* If this path has a condition, then hook it up. */\n\t    ivl_nexus_t path_condit = 0;\n\t    if (src->has_condit()) {\n\t\t  const Nexus*nt = src->condit_pin().nexus();\n\t\t  path_condit = nt->t_cookie();\n\t    }\n\n\t    for (unsigned pin = 0; pin < src->src_count(); pin += 1) {\n\t\t  const Nexus*nex = src->src_pin(pin).nexus();\n\t\t  if (! nex->t_cookie()) {\n\t\t\tcerr << src->get_fileline() << \": internal error: \"\n\t\t\t     << \"No signal connected to pin \" << pin\n\t\t\t     << \" of delay path to \" << net->name()\n\t\t\t     << \".\" << endl;\n\t\t  }\n\t\t  assert(nex->t_cookie());\n\t\t  obj->path[ptr].scope = lookup_scope_(src->scope());\n\t\t  obj->path[ptr].src = nex->t_cookie();\n\t\t  obj->path[ptr].condit = path_condit;\n\t\t  obj->path[ptr].conditional = src->is_condit();\n\t\t  obj->path[ptr].parallel = src->is_parallel();\n\t\t  obj->path[ptr].posedge = src->is_posedge();\n\t\t  obj->path[ptr].negedge = src->is_negedge();\n\t\t  for (unsigned pe = 0 ;  pe < 12 ;  pe += 1) {\n\t\t\tobj->path[ptr].delay[pe] = src->get_delay(pe);\n\t\t  }\n\n\t\t  ptr += 1;\n\t    }\n\n      }\n\n      return true;\n}\n\n\nvoid dll_target::test_version(const char*target_name)\n{\n      dll_ = ivl_dlopen(target_name);\n\n      if ((dll_ == 0) && (target_name[0] != '/')) {\n\t    size_t len = strlen(basedir) + 1 + strlen(target_name) + 1;\n\t    char*tmp = new char[len];\n\t    snprintf(tmp, len, \"%s/%s\", basedir, target_name);\n\t    dll_ = ivl_dlopen(tmp);\n\t    delete[]tmp;\n      }\n\n      if (dll_ == 0) {\n\t    cout << \"\\n\\nUnable to load \" << target_name\n\t\t << \" for version details.\" << endl;\n\t    return;\n      }\n\n      target_query_f targ_query = (target_query_f)ivl_dlsym(dll_, LU \"target_query\" TU);\n      if (targ_query == 0) {\n\t    cerr << \"Target \" << target_name\n\t\t << \" has no version hooks.\" << endl;\n\t    return;\n      }\n\n      const char*version_string = (*targ_query) (\"version\");\n      if (version_string == 0) {\n\t    cerr << \"Target \" << target_name\n\t\t << \" has no version string\" << endl;\n\t    return;\n      }\n\n      cout << target_name << \": \" << version_string << endl;\n}\n"
        },
        {
          "name": "t-dll.h",
          "type": "blob",
          "size": 24.0625,
          "content": "#ifndef IVL_t_dll_H\n#define IVL_t_dll_H\n/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"target.h\"\n# include  \"ivl_target.h\"\n# include  \"ivl_target_priv.h\"\n# include  \"StringHeap.h\"\n# include  \"netlist.h\"\n# include  <vector>\n# include  <map>\n\n#if defined(__MINGW32__)\n#include <windows.h>\ntypedef void *ivl_dll_t;\n#elif defined(HAVE_DLFCN_H)\n# include  <dlfcn.h>\ntypedef void* ivl_dll_t;\n#elif defined(HAVE_DL_H)\n# include  <dl.h>\ntypedef shl_t ivl_dll_t;\n#else\n# error No DLL stub support for this target.\n#endif\n\n/*\n * The DLL target type loads a named object file to handle the process\n * of scanning the netlist. When it is time to start the design, I\n * locate and link in the desired DLL, then start calling methods. The\n * DLL will call me back to get information out of the netlist in\n * particular.\n */\nstruct dll_target  : public target_t, public expr_scan_t {\n\n\t// This is a special function for loading and testing the\n\t// version of a loadable target code generator.\n      void test_version(const char*target_name);\n\n      bool start_design(const Design*);\n      int  end_design(const Design*);\n\n      bool bufz(const NetBUFZ*);\n      bool branch(const NetBranch*);\n      bool class_type(const NetScope*, netclass_t*);\n      bool enumeration(const NetScope*, netenum_t*);\n      void event(const NetEvent*);\n      void logic(const NetLogic*);\n      bool tran(const NetTran*);\n      bool ureduce(const NetUReduce*);\n      void net_case_cmp(const NetCaseCmp*);\n      void udp(const NetUDP*);\n      void lpm_abs(const NetAbs*);\n      void lpm_add_sub(const NetAddSub*);\n      bool lpm_array_dq(const NetArrayDq*);\n      bool lpm_cast_int2(const NetCastInt2*);\n      bool lpm_cast_int4(const NetCastInt4*);\n      bool lpm_cast_real(const NetCastReal*);\n      void lpm_clshift(const NetCLShift*);\n      void lpm_compare(const NetCompare*);\n      void lpm_divide(const NetDivide*);\n      void lpm_ff(const NetFF*);\n      void lpm_latch(const NetLatch*);\n      void lpm_modulo(const NetModulo*);\n      void lpm_mult(const NetMult*);\n      void lpm_mux(const NetMux*);\n      void lpm_pow(const NetPow*);\n      bool concat(const NetConcat*);\n      bool part_select(const NetPartSelect*);\n      bool replicate(const NetReplicate*);\n      void net_assign(const NetAssign_*) const;\n      bool net_sysfunction(const NetSysFunc*);\n      bool net_function(const NetUserFunc*);\n      bool net_const(const NetConst*);\n      bool net_literal(const NetLiteral*);\n      void net_probe(const NetEvProbe*);\n      bool sign_extend(const NetSignExtend*);\n      bool substitute(const NetSubstitute*);\n\n      bool process(const NetProcTop*);\n      bool process(const NetAnalogTop*);\n      void scope(const NetScope*);\n      void convert_module_ports(const NetScope*);\n      void signal(const NetNet*);\n      bool signal_paths(const NetNet*);\n      ivl_dll_t dll_;\n\n      ivl_design_s des_;\n\n      target_design_f target_;\n\n\n\t/* These methods and members are used for forming the\n\t   statements of a thread. */\n      struct ivl_statement_s*stmt_cur_;\n      void proc_alloc(const NetAlloc*);\n      bool proc_assign(const NetAssign*);\n      void proc_assign_nb(const NetAssignNB*);\n      bool proc_block(const NetBlock*);\n      bool proc_break(const NetBreak*);\n      void proc_case(const NetCase*);\n      bool proc_cassign(const NetCAssign*);\n      bool proc_condit(const NetCondit*);\n      bool proc_continue(const NetContinue*);\n      bool proc_contribution(const NetContribution*);\n      bool proc_deassign(const NetDeassign*);\n      bool proc_delay(const NetPDelay*);\n      bool proc_disable(const NetDisable*);\n      void proc_do_while(const NetDoWhile*);\n      bool proc_force(const NetForce*);\n      void proc_forever(const NetForever*);\n      bool proc_forloop(const NetForLoop*);\n      void proc_free(const NetFree*);\n      bool proc_release(const NetRelease*);\n      void proc_repeat(const NetRepeat*);\n      void proc_stask(const NetSTask*);\n      bool proc_trigger(const NetEvTrig*);\n      bool proc_nb_trigger(const NetEvNBTrig*);\n      void proc_utask(const NetUTask*);\n      bool proc_wait(const NetEvWait*);\n      void proc_while(const NetWhile*);\n\n      bool func_def(const NetScope*);\n      void task_def(const NetScope*);\n\n      struct ivl_expr_s*expr_;\n      void expr_access_func(const NetEAccess*);\n      void expr_array_pattern(const NetEArrayPattern*);\n      void expr_binary(const NetEBinary*);\n      void expr_concat(const NetEConcat*);\n      void expr_const(const NetEConst*);\n      void expr_creal(const NetECReal*);\n      void expr_last(const NetELast*);\n      void expr_new(const NetENew*);\n      void expr_null(const NetENull*);\n      void expr_param(const NetEConstParam*);\n      void expr_property(const NetEProperty*);\n      void expr_rparam(const NetECRealParam*);\n      void expr_event(const NetEEvent*);\n      void expr_scope(const NetEScope*);\n      void expr_scopy(const NetEShallowCopy*);\n      void expr_netenum(const NetENetenum*);\n      void expr_select(const NetESelect*);\n      void expr_sfunc(const NetESFunc*);\n      void expr_ternary(const NetETernary*);\n      void expr_ufunc(const NetEUFunc*);\n      void expr_unary(const NetEUnary*);\n      void expr_signal(const NetESignal*);\n\n      ivl_scope_t lookup_scope_(const NetScope*scope);\n\n      ivl_attribute_s* fill_in_attributes(const Attrib*net);\n      void switch_attributes(struct ivl_switch_s *obj, const NetNode*net);\n      void logic_attributes(struct ivl_net_logic_s *obj, const NetNode*net);\n\n    private:\n      StringHeap strings_;\n\n      static ivl_scope_t find_scope(ivl_design_s &des, const NetScope*cur);\n      static ivl_signal_t find_signal(ivl_design_s &des, const NetNet*net);\n      static ivl_parameter_t scope_find_param(ivl_scope_t scope,\n\t\t\t\t\t      const char*name);\n\n      void add_root(const NetScope *s);\n\n      bool make_assign_lvals_(const NetAssignBase*net);\n      bool make_single_lval_(const LineInfo*li, struct ivl_lval_s*cur, const NetAssign_*asn);\n      void sub_off_from_expr_(long);\n      void mul_expr_by_const_(long);\n\n      void make_delays_(ivl_expr_t*delay, const NetObj*net);\n      void make_logic_delays_(struct ivl_net_logic_s*obj, const NetObj*net);\n      void make_switch_delays_(struct ivl_switch_s*obj, const NetObj*net);\n      void make_lpm_delays_(struct ivl_lpm_s*obj, const NetObj*net);\n      void make_const_delays_(struct ivl_net_const_s*obj, const NetObj*net);\n      void make_scope_parameters(ivl_scope_t scope, const NetScope*net);\n      void make_scope_param_expr(ivl_parameter_t cur_par, NetExpr*etmp);\n\n      ivl_event_t make_lpm_trigger(const NetEvWait*ev);\n\n      bool lpm_arith1_(ivl_lpm_type_t lpm_type, unsigned wid, bool signed_flag, const NetNode*net);\n\n      static ivl_expr_t expr_from_value_(const verinum&that);\n};\n\nextern struct dll_target dll_target_obj;\n\n/*\n * These are various private declarations used by the t-dll target.\n */\n\nstruct ivl_delaypath_s {\n      ivl_scope_t scope;\n      ivl_nexus_t src;\n      ivl_nexus_t condit;\n      bool conditional;\n      bool parallel;\n      bool posedge;\n      bool negedge;\n      uint64_t delay[12];\n};\n\nstruct ivl_event_s {\n      perm_string name;\n      ivl_scope_t scope;\n      perm_string file;\n      unsigned lineno;\n      unsigned nany, nneg, npos, nedg;\n      ivl_nexus_t*pins;\n};\n\n/*\n * The ivl_expr_t is an opaque reference to one of these\n * structures. This structure holds all the information we need about\n * an expression node, including its type, the expression width, and\n * type specific properties.\n */\nstruct ivl_expr_s {\n      ivl_expr_type_t type_;\n      ivl_variable_type_t value_;\n      ivl_type_t net_type;\n      perm_string file;\n      unsigned lineno;\n\n      unsigned width_;\n      unsigned signed_ : 1;\n      unsigned sized_  : 1;\n\n      union {\n\t    struct {\n\t\t  char op_;\n\t\t  ivl_expr_t lef_;\n\t\t  ivl_expr_t rig_;\n\t    } binary_;\n\n\t    struct {\n\t\t  size_t parms;\n\t\t  ivl_expr_t*parm;\n\t    } array_pattern_;\n\n\t    struct {\n\t\t  ivl_select_type_t  sel_type_;\n\t\t  ivl_expr_t expr_;\n\t\t  ivl_expr_t base_;\n\t    } select_;\n\n\t    struct {\n\t\t  ivl_expr_t dest;\n\t\t  ivl_expr_t src;\n\t    } shallow_;\n\n\t    struct {\n\t\t  ivl_branch_t branch;\n\t\t  ivl_nature_t nature;\n\t    } branch_;\n\n\t    struct {\n\t\t  unsigned   rept;\n\t\t  unsigned   parms;\n\t\t  ivl_expr_t*parm;\n\t    } concat_;\n\n\t    struct {\n\t\t  char*bits_;\n\t\t  ivl_parameter_t parameter;\n\t    } number_;\n\n\t    struct {\n\t\t  ivl_event_t event;\n\t    } event_;\n\n\t    struct {\n\t\t  ivl_scope_t scope;\n\t    } scope_;\n\n\t    struct {\n\t\t  ivl_enumtype_t type;\n\t    } enumtype_;\n\n\t    struct {\n\t\t  ivl_signal_t sig;\n\t\t  ivl_expr_t word;\n\t    } signal_;\n\n\t    struct {\n\t\t  const char *name_;\n\t\t  ivl_expr_t *parm;\n\t\t  unsigned   parms;\n\t    } sfunc_;\n\n\t    struct {\n\t\t  char*value_;\n\t\t  ivl_parameter_t parameter;\n\t    } string_;\n\n\t    struct {\n\t\t  ivl_expr_t cond;\n\t\t  ivl_expr_t true_e;\n\t\t  ivl_expr_t false_e;\n\t    } ternary_;\n\n\t    struct {\n\t\t  ivl_memory_t mem_;\n\t\t  ivl_expr_t idx_;\n\t    } memory_;\n\n\t    struct {\n\t\t  ivl_scope_t def;\n\t\t  ivl_expr_t  *parm;\n\t\t  unsigned    parms;\n\t    } ufunc_;\n\n\t    struct {\n\t\t  unsigned long value;\n\t    } ulong_;\n\n\t    struct {\n\t\t  double value;\n\t\t  ivl_parameter_t parameter;\n\t    } real_;\n\n\t    struct {\n\t\t  char op_;\n\t\t  ivl_expr_t sub_;\n\t    } unary_;\n\n\t    struct {\n\t\t  uint64_t value;\n\t    } delay_;\n\n\t    struct {\n\t\t  ivl_expr_t size;\n\t\t  ivl_expr_t init_val;\n\t    } new_;\n\n\t    struct {\n\t\t  ivl_signal_t sig;\n\t\t  unsigned prop_idx;\n\t\t  ivl_expr_t index;\n\t    } property_;\n      } u_;\n};\n\n/*\n * LPM devices are handled by this suite of types. The ivl_lpm_s\n * structure holds the core, including a type code, the object name\n * and scope. The other properties of the device are held in the type\n * specific member of the union.\n */\n\nstruct ivl_lpm_s {\n      ivl_lpm_type_t type;\n      ivl_scope_t scope;\n      perm_string name;\n      perm_string file;\n      unsigned lineno;\n\t// Value returned by ivl_lpm_width;\n      unsigned width;\n      ivl_expr_t delay[3];\n\n      union {\n\t    struct ivl_lpm_ff_s {\n\t\t  unsigned negedge_flag :1;\n\t\t  ivl_nexus_t clk;\n\t\t  ivl_nexus_t we;\n\t\t  ivl_nexus_t aclr;\n\t\t  ivl_nexus_t aset;\n\t\t  ivl_nexus_t sclr;\n\t\t  ivl_nexus_t sset;\n\t\t  union {\n\t\t\tivl_nexus_t*pins;\n\t\t\tivl_nexus_t pin;\n\t\t  } q;\n\t\t  union {\n\t\t\tivl_nexus_t*pins;\n\t\t\tivl_nexus_t pin;\n\t\t  } d;\n\t\t  ivl_expr_t aset_value;\n\t\t  ivl_expr_t sset_value;\n\t    } ff;\n\t    struct ivl_lpm_latch_s {\n\t\t  ivl_nexus_t e;\n\t\t  union {\n\t\t\tivl_nexus_t*pins;\n\t\t\tivl_nexus_t pin;\n\t\t  } q;\n\t\t  union {\n\t\t\tivl_nexus_t*pins;\n\t\t\tivl_nexus_t pin;\n\t\t  } d;\n\t    } latch;\n\n\t    struct ivl_lpm_mux_s {\n\t\t  unsigned size;\n\t\t  unsigned swid;\n\t\t  ivl_nexus_t*d;\n\t\t  ivl_nexus_t q, s;\n\t    } mux;\n\n\t    struct ivl_lpm_shift_s {\n\t\t  unsigned select;\n\t\t  unsigned signed_flag :1;\n\t\t  ivl_nexus_t q, d, s;\n\t    } shift;\n\n\t    struct ivl_lpm_arith_s {\n\t\t  unsigned signed_flag :1;\n\t\t  ivl_nexus_t q,  a,  b;\n\t    } arith;\n\n\t    struct ivl_lpm_array_s {\n\t\t  ivl_signal_t sig;\n\t\t  unsigned swid;\n\t\t  ivl_nexus_t q,  a;\n\t    } array;\n\n\t    struct ivl_concat_s {\n\t\t  unsigned inputs;\n\t\t  ivl_nexus_t*pins;\n\t    } concat;\n\n\t    struct ivl_part_s {\n\t\t  unsigned base;\n\t\t  unsigned signed_flag :1;\n\t\t  ivl_nexus_t q, a, s;\n\t    } part;\n\n\t      // IVL_LPM_RE_* and IVL_LPM_SIGN_EXT use this.\n\t    struct ivl_lpm_reduce_s {\n\t\t  ivl_nexus_t q,  a;\n\t    } reduce;\n\n\t    struct ivl_lpm_repeat_s {\n\t\t  unsigned count;\n\t\t  ivl_nexus_t q, a;\n\t    } repeat;\n\n\t    struct ivl_lpm_sfunc_s {\n\t\t  const char* fun_name;\n\t\t  unsigned ports;\n\t\t  ivl_nexus_t*pins;\n\t\t  ivl_event_t trigger;\n\t    } sfunc;\n\n\t    struct ivl_lpm_substitute {\n\t\t  unsigned base;\n\t\t  ivl_nexus_t q, a, s;\n\t    } substitute;\n\n\t    struct ivl_lpm_ufunc_s {\n\t\t  ivl_scope_t def;\n\t\t  unsigned ports;\n\t\t  ivl_nexus_t*pins;\n\t\t  ivl_event_t trigger;\n\t    } ufunc;\n      } u_;\n};\n\n/*\n * This object represents l-values to assignments. The l-value can be\n * a register bit or part select, or a memory word select with a part\n * select.\n */\n\nenum ivl_lval_type_t {\n      IVL_LVAL_REG = 0,\n      IVL_LVAL_ARR = 4,\n      IVL_LVAL_LVAL= 5  // Nested l-value\n};\n\nstruct ivl_lval_s {\n      ivl_expr_t loff;\n      ivl_select_type_t sel_type :3;\n      ivl_expr_t idx;\n      unsigned width_;\n      unsigned type_   : 8; /* values from ivl_lval_type_t */\n      int property_idx;\n      union {\n\t    ivl_signal_t sig;\n\t    ivl_lval_t  nest; // type_ == IVL_LVAL_LVAL\n      } n;\n};\n\n/*\n * This object represents a literal constant, possibly signed, in a\n * structural context.\n */\nstruct ivl_net_const_s {\n      ivl_variable_type_t type :  4;\n      unsigned width_          : 24;\n      unsigned signed_         :  1;\n      perm_string file;\n      unsigned lineno;\n      ivl_scope_t scope;\n\n      union {\n\t    double real_value;\n\t    char bit_[sizeof(char*)];\n\t    const char* bits_;\n      } b;\n\n      ivl_nexus_t pin_;\n      ivl_expr_t delay[3];\n\n      void* operator new (size_t s);\n      void  operator delete(void*obj, size_t s); // Not implemented\n};\n\n/*\n * Logic gates (just about everything that has a single output) are\n * represented structurally by instances of this object.\n */\nstruct ivl_net_logic_s {\n      ivl_logic_t type_;\n      unsigned width_;\n      unsigned is_cassign;\n      unsigned is_port_buffer;\n      ivl_udp_t udp;\n\n      perm_string name_;\n      ivl_scope_t scope_;\n      perm_string file;\n      unsigned lineno;\n\n      unsigned npins_;\n      ivl_nexus_t*pins_;\n\n      struct ivl_attribute_s*attr;\n      unsigned nattr;\n\n      ivl_expr_t delay[3];\n};\n\nstruct ivl_switch_s {\n      ivl_switch_type_t type;\n      unsigned width;\n      unsigned part;\n      unsigned offset;\n\n      perm_string name;\n      ivl_scope_t scope;\n      ivl_island_t island;\n\n      struct ivl_attribute_s*attr;\n      unsigned nattr;\n\n      ivl_expr_t delay[3];\n\n      ivl_nexus_t pins[3];\n      perm_string file;\n      unsigned lineno;\n};\n\n/*\n * UDP definition.\n */\nstruct ivl_udp_s {\n      perm_string name;\n      unsigned nin;\n      int sequ; /* boolean */\n      char init;\n      unsigned nrows;\n      typedef const char*ccharp_t;\n      ccharp_t*table; // zero terminated array of pointers\n      perm_string file;\n      unsigned lineno;\n      std::string*ports;\n};\n\n/*\n * The ivl_nexus_t is a single-bit link of some number of pins of\n * devices. the __nexus_ptr structure is a helper that actually does\n * the pointing.\n *\n * The type_ member specifies which of the object pointers in the\n * union are valid.\n *\n * The drive01 members gives the strength of the drive that the device\n * is applying to the nexus, with 0 HiZ and 3 supply. If the pin is an\n * input to the device, then the drives are both HiZ.\n */\nstruct ivl_nexus_ptr_s {\n      unsigned pin_;\n      unsigned type_ : 8;\n      unsigned drive0 : 3;\n      unsigned drive1 : 3;\n      union {\n\t    ivl_signal_t    sig; /* type 0 */\n\t    ivl_net_logic_t log; /* type 1 */\n\t    ivl_net_const_t con; /* type 2 */\n\t    ivl_lpm_t       lpm; /* type 3 */\n\t    ivl_switch_t    swi; /* type 4 */\n\t    ivl_branch_t    bra; /* type 5 */\n      } l;\n};\n# define __NEXUS_PTR_SIG 0\n# define __NEXUS_PTR_LOG 1\n# define __NEXUS_PTR_CON 2\n# define __NEXUS_PTR_LPM 3\n# define __NEXUS_PTR_SWI 4\n# define __NEXUS_PTR_BRA 5\n\n/*\n * NOTE: ONLY allocate ivl_nexus_s objects with the included \"new\" operator.\n */\nstruct ivl_nexus_s {\n      ivl_nexus_s() : ptrs_(1), nexus_(0), name_(0), private_data(0) { }\n      std::vector<ivl_nexus_ptr_s>ptrs_;\n      const Nexus*nexus_;\n      const char*name_;\n      void*private_data;\n\n      void* operator new (size_t s);\n      void  operator delete(void*obj, size_t s); // Not implemented\n};\n\n/*\n * This is the implementation of a parameter. Each scope has a list of\n * these.\n */\nstruct ivl_parameter_s {\n      perm_string basename;\n      ivl_scope_t scope;\n      ivl_expr_t  value;\n      long          msb;\n      long          lsb;\n      bool  signed_flag;\n      bool        local;\n      bool      is_type;\n      perm_string file;\n      unsigned lineno;\n};\n/*\n * All we know about a process is its type (initial or always) and the\n * single statement that is it. A process also has a scope, although\n * that generally only matters for VPI calls.\n */\nstruct ivl_process_s {\n      ivl_process_type_t type_ : 3;\n      unsigned int analog_flag : 1;\n      ivl_scope_t scope_;\n      ivl_statement_t stmt_;\n      perm_string file;\n      unsigned lineno;\n\n      struct ivl_attribute_s*attr;\n      unsigned nattr;\n\n      ivl_process_t next_;\n};\n\n/*\n * Scopes are kept in a tree. Each scope points to its first child,\n * and also to any siblings. Thus a parent can scan all its children\n * by following its child pointer, then following sibling pointers from\n * there.\n */\nstruct ivl_scope_s {\n      ivl_scope_s();\n\n      ivl_scope_t parent;\n      std::map<hname_t,ivl_scope_t> children;\n\t// This is just like the children map above, but in vector\n\t// form for convenient access.\n      std::vector<ivl_scope_t> child;\n\n      perm_string name_;\n      perm_string tname_;\n      perm_string file;\n      perm_string def_file;\n      unsigned lineno;\n      unsigned def_lineno;\n      ivl_scope_type_t type_;\n\n      std::vector<ivl_type_t> classes;\n      std::vector<ivl_enumtype_t> enumerations_;\n\n      std::vector<ivl_signal_t> sigs_;\n\n      unsigned nlog_;\n      ivl_net_logic_t*log_;\n\n      unsigned nevent_;\n      ivl_event_t* event_;\n\n      unsigned nlpm_;\n      ivl_lpm_t* lpm_;\n\n      std::vector<struct ivl_parameter_s> param;\n\n\t/* Scopes that are tasks/functions have a definition. */\n      ivl_statement_t def;\n      unsigned is_auto;\n      ivl_variable_type_t func_type;\n      bool func_signed;\n      unsigned func_width;\n\n      unsigned is_cell;\n\n      // Ports of Module scope (just introspection data for VPI) - actual connections\n      // are nets defined in u_.net (may be > 1 per module port)\n      std::vector<PortInfo>     module_ports_info;\n\n      unsigned ports;\n      union {\n\t    ivl_signal_t*port;\n\t    ivl_nexus_t*nex;\n\t    NetNet**net;\n      } u_;\n\n      std::vector<ivl_switch_t>switches;\n\n      signed int time_precision :8;\n      signed int time_units :8;\n\n      struct ivl_attribute_s*attr;\n      unsigned nattr;\n};\n\n/*\n * A signal is a thing like a wire, a reg, or whatever. It has a type,\n * and if it is a port is also has a direction. Signals are collected\n * into scopes (which also point back to me) and have pins that\n * connect to the rest of the netlist.\n */\nstruct ivl_signal_s {\n      ivl_signal_type_t type_;\n      ivl_signal_port_t port_;\n      int module_port_index_;\n      ivl_discipline_t discipline;\n      perm_string file;\n      unsigned lineno;\n\n\t// This is the type for the signal\n      ivl_type_t net_type;\n      unsigned local_  : 1;\n\n      unsigned forced_net_ : 1;\n\n\t/* For now, support only 0 or 1 array dimensions. */\n      unsigned array_dimensions_ : 8;\n      unsigned array_addr_swapped : 1;\n\n\t/* These encode the declared packed dimensions for the\n\t   signal, in case they are needed by the run-time */\n      netranges_t packed_dims;\n\n      perm_string name_;\n      ivl_scope_t scope_;\n\n      unsigned array_words;\n      int array_base;\n      union {\n\t    ivl_nexus_t pin;\n\t    ivl_nexus_t*pins;\n      };\n\n      ivl_delaypath_s*path;\n      unsigned npath;\n\n      struct ivl_attribute_s*attr;\n      unsigned nattr;\n};\n\n\n/*\n * The ivl_statement_t represents any statement. The type of statement\n * is defined by the ivl_statement_type_t enumeration. Given the type,\n * certain information about the statement may be available.\n */\nstruct ivl_statement_s {\n      enum ivl_statement_type_e type_;\n      perm_string file;\n      unsigned lineno;\n\n      union {\n\t    struct { /* IVL_ST_ALLOC */\n\t\t  ivl_scope_t scope;\n\t    } alloc_;\n\n\t    struct { /* IVL_ST_ASSIGN IVL_ST_ASSIGN_NB\n\t\t\tIVL_ST_CASSIGN, IVL_ST_DEASSIGN */\n\t\t  unsigned lvals_;\n\t\t  struct ivl_lval_s*lval_;\n\t\t  char oper; // Operator if this is a compressed assignment.\n\t\t  ivl_expr_t rval_;\n\t\t  ivl_expr_t delay;\n\t\t    // The following are only for NB event control.\n\t\t  ivl_expr_t count;\n\t\t  unsigned nevent;\n\t\t  union {\n\t\t\tivl_event_t event;\n\t\t\tivl_event_t*events;\n\t\t  };\n\t    } assign_;\n\n\t    struct { /* IVL_ST_BLOCK, IVL_ST_FORK */\n\t\t  struct ivl_statement_s*stmt_;\n\t\t  unsigned nstmt_;\n\t\t  ivl_scope_t scope;\n\t    } block_;\n\n\t    struct { /* IVL_ST_CASE, IVL_ST_CASEX, IVL_ST_CASEZ */\n\t\t  ivl_case_quality_t quality;\n\t\t  ivl_expr_t cond;\n\t\t  unsigned ncase;\n\t\t  ivl_expr_t*case_ex;\n\t\t  struct ivl_statement_s*case_st;\n\t    } case_;\n\n\t    struct { /* IVL_ST_CONDIT */\n\t\t    /* This is the condition expression */\n\t\t  ivl_expr_t cond_;\n\t\t    /* This is two statements, the true and false. */\n\t\t  struct ivl_statement_s*stmt_;\n\t    } condit_;\n\n\t    struct { /* IVL_ST_CONTRIB */\n\t\t  ivl_expr_t lval;\n\t\t  ivl_expr_t rval;\n\t    } contrib_;\n\n\t    struct { /* IVL_ST_DELAY */\n\t\t  uint64_t value;\n\t\t  ivl_statement_t stmt_;\n\t    } delay_;\n\n\t    struct { /* IVL_ST_DELAYX */\n\t\t  ivl_expr_t expr; /* XXXX */\n\t\t  ivl_statement_t stmt_;\n\t    } delayx_;\n\n\t    struct { /* IVL_ST_DISABLE */\n\t\t  ivl_scope_t scope;\n\t\t  bool flow_control;\n\t    } disable_;\n\n\t    struct { /* IVL_ST_FOREVER */\n\t\t  ivl_statement_t stmt_;\n\t    } forever_;\n\n\t    struct { /* IVL_ST_FORLOOP */\n\t\t  ivl_statement_t init_stmt;\n\t\t  ivl_expr_t condition;\n\t\t  ivl_statement_t stmt;\n\t\t  ivl_statement_t step;\n\t    } forloop_;\n\n\t    struct { /* IVL_ST_FREE */\n\t\t  ivl_scope_t scope;\n\t    } free_;\n\n\t    struct { /* IVL_ST_STASK */\n\t\t  const char*name_;\n\t\t  ivl_sfunc_as_task_t sfunc_as_task_;\n\t\t  unsigned   nparm_;\n\t\t  ivl_expr_t*parms_;\n\t    } stask_;\n\n\t    struct { /* IVL_ST_UTASK */\n\t\t  ivl_scope_t def;\n\t    } utask_;\n\n\t    struct { /* IVL_ST_TRIGGER IVL_ST_NB_TRIGGER IVL_ST_WAIT */\n\t\t  unsigned needs_t0_trigger;\n\t\t  unsigned nevent;\n\t\t  union {\n\t\t\tivl_event_t event;\n\t\t\tivl_event_t*events;\n\t\t  };\n\t\t  ivl_expr_t delay;\n\t\t  ivl_statement_t stmt_;\n\t    } wait_;\n\n\t    struct { /* IVL_ST_WHILE IVL_ST_REPEAT */\n\t\t  ivl_expr_t cond_;\n\t\t  ivl_statement_t stmt_;\n\t    } while_;\n      } u_;\n};\n\n/*\n * The FILE_NAME function is a shorthand for attaching file/line\n * information to the statement object.\n */\nstatic inline void FILE_NAME(ivl_expr_t expr, const LineInfo*info)\n{\n      expr->file = info->get_file();\n      expr->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_event_t event, const LineInfo*info)\n{\n      event->file = info->get_file();\n      event->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_lpm_t lpm, const LineInfo*info)\n{\n      lpm->file = info->get_file();\n      lpm->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_net_const_t net, const LineInfo*info)\n{\n      net->file = info->get_file();\n      net->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_net_logic_t net, const LineInfo*info)\n{\n      net->file = info->get_file();\n      net->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_parameter_t net, const LineInfo*info)\n{\n      net->file = info->get_file();\n      net->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_process_t net, const LineInfo*info)\n{\n      net->file = info->get_file();\n      net->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_scope_t scope, const NetScope*info)\n{\n      scope->file = info->get_file();\n      scope->def_file = info->get_def_file();\n      scope->lineno = info->get_lineno();\n      scope->def_lineno = info->get_def_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_statement_t stmt, const LineInfo*info)\n{\n      stmt->file = info->get_file();\n      stmt->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_switch_t net, const LineInfo*info)\n{\n      net->file = info->get_file();\n      net->lineno = info->get_lineno();\n}\n\nstatic inline void FILE_NAME(ivl_signal_t net, const LineInfo*info)\n{\n      net->file = info->get_file();\n      net->lineno = info->get_lineno();\n}\n\n#endif /* IVL_t_dll_H */\n"
        },
        {
          "name": "target.cc",
          "type": "blob",
          "size": 15.3173828125,
          "content": "/*\n * Copyright (c) 1998-2021 Stephen Williams <steve@icarus.com>\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  \"target.h\"\n# include  <typeinfo>\n\nusing namespace std;\n\ntarget_t::~target_t()\n{\n}\n\nvoid target_t::scope(const NetScope*)\n{\n}\n\nvoid target_t::convert_module_ports(const NetScope*)\n{\n}\n\nbool target_t::branch(const NetBranch*obj)\n{\n      cerr << obj->get_fileline() << \": error: target (\" << typeid(*this).name()\n\t   <<  \"): Unhandled branch.\" << endl;\n      return false;\n}\n\nbool target_t::class_type(const NetScope*, netclass_t*obj)\n{\n      cerr << \"<>:0\" << \": error: target (\" << typeid(*this).name()\n\t   <<  \"): Unhandled class_type <\" << obj << \">.\" << endl;\n      return false;\n}\n\nvoid target_t::event(const NetEvent*ev)\n{\n      cerr << ev->get_fileline() << \": error: target (\" << typeid(*this).name()\n\t   <<  \"): Unhandled event <\" << ev->name() << \">.\" << endl;\n}\n\nbool target_t::enumeration(const NetScope*, netenum_t*obj)\n{\n      cerr << \"<>:0\" << \": error: target (\" << typeid(*this).name()\n\t   <<  \"): Unhandled enumeration <\" << obj << \">.\" << endl;\n      return false;\n}\n\nbool target_t::signal_paths(const NetNet*)\n{\n      return true;\n}\nbool target_t::func_def(const NetScope*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled function definition.\" << endl;\n      return false;\n}\n\nvoid target_t::task_def(const NetScope*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled task definition.\" << endl;\n}\n\nvoid target_t::logic(const NetLogic*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled logic gate\" << endl;\n}\n\nbool target_t::tran(const NetTran*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t   << \"TRAN devices not supported.\" << endl;\n      return false;\n}\n\nbool target_t::bufz(const NetBUFZ*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled continuous assign (BUFZ).\" << endl;\n      return false;\n}\n\nvoid target_t::udp(const NetUDP*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled UDP.\" << endl;\n}\n\nbool target_t::ureduce(const NetUReduce*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled unary reduction logic gate.\" << endl;\n      return false;\n}\n\nvoid target_t::lpm_abs(const NetAbs*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetAbs.\" << endl;\n}\n\nvoid target_t::lpm_add_sub(const NetAddSub*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetAddSub.\" << endl;\n}\n\nbool target_t::lpm_array_dq(const NetArrayDq*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetArrayDq.\" << endl;\n      return false;\n}\n\nbool target_t::lpm_cast_int2(const NetCastInt2*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetCastInt2.\" << endl;\n      return false;\n}\n\nbool target_t::lpm_cast_int4(const NetCastInt4*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetCastInt4.\" << endl;\n      return false;\n}\n\nbool target_t::lpm_cast_real(const NetCastReal*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetCastReal.\" << endl;\n      return false;\n}\n\nvoid target_t::lpm_clshift(const NetCLShift*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetCLShift.\" << endl;\n}\n\nvoid target_t::lpm_compare(const NetCompare*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetCompare.\" << endl;\n}\n\nvoid target_t::lpm_divide(const NetDivide*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetDivide.\" << endl;\n}\n\nvoid target_t::lpm_modulo(const NetModulo*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetModulo.\" << endl;\n}\n\nvoid target_t::lpm_ff(const NetFF*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetFF.\" << endl;\n}\n\nvoid target_t::lpm_latch(const NetLatch*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetLatch.\" << endl;\n}\n\nvoid target_t::lpm_mult(const NetMult*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetMult.\" << endl;\n}\n\nvoid target_t::lpm_mux(const NetMux*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetMux.\" << endl;\n}\n\nvoid target_t::lpm_pow(const NetPow*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetPow.\" << endl;\n}\n\nbool target_t::concat(const NetConcat*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetConcat.\" << endl;\n      return false;\n}\n\nbool target_t::part_select(const NetPartSelect*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetPartSelect.\" << endl;\n      return false;\n}\n\nbool target_t::replicate(const NetReplicate*)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled NetReplicate.\" << endl;\n      return false;\n}\n\nvoid target_t::net_case_cmp(const NetCaseCmp*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled case compare node.\" << endl;\n}\n\nbool target_t::net_const(const NetConst*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled CONSTANT node.\" << endl;\n      return false;\n}\n\nbool target_t::net_sysfunction(const NetSysFunc*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled NetSysFunc node.\" << endl;\n      return false;\n}\n\nbool target_t::net_function(const NetUserFunc*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled NetUserFunc node.\" << endl;\n      return false;\n}\n\nbool target_t::net_literal(const NetLiteral*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled LITERAL node.\" << endl;\n      return false;\n}\n\nvoid target_t::net_probe(const NetEvProbe*net)\n{\n      cerr << \"target (\" << typeid(*this).name() << \"): \"\n\t    \"Unhandled probe trigger node\" << endl;\n      net->dump_node(cerr, 4);\n}\n\nbool target_t::sign_extend(const NetSignExtend*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled NetSignExtend node.\" << endl;\n      return false;\n}\n\nbool target_t::substitute(const NetSubstitute*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled NetSubstitute node.\" << endl;\n      return false;\n}\n\nbool target_t::process(const NetProcTop*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled process(NetProcTop).\" << endl;\n      return false;\n}\n\nbool target_t::process(const NetAnalogTop*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled process(NetAnalogTop).\" << endl;\n      return false;\n}\n\nvoid target_t::proc_alloc(const NetAlloc*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_alloc.\" << endl;\n}\n\nbool target_t::proc_assign(const NetAssign*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled procedural assignment.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_assign_nb(const NetAssignNB*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled non-blocking assignment.\" << endl;\n}\n\nbool target_t::proc_block(const NetBlock*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_block.\" << endl;\n      return false;\n}\n\nbool target_t::proc_break(const NetBreak*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_break.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_case(const NetCase*cur)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled case:\" << endl;\n      cur->dump(cerr, 6);\n}\n\nbool target_t::proc_cassign(const NetCAssign*dev)\n{\n\tcerr << \"target (\" << typeid(*this).name() <<  \"): \";\n\tcerr << dev->get_fileline();\n\tcerr << \": Target does not support procedural continuous assignment.\" << endl;\n      return false;\n}\n\nbool target_t::proc_condit(const NetCondit*condit)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled conditional:\" << endl;\n      condit->dump(cerr, 6);\n      return false;\n}\n\nbool target_t::proc_continue(const NetContinue*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_continue.\" << endl;\n      return false;\n}\n\nbool target_t::proc_contribution(const NetContribution*net)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled contribution:\" << endl;\n      net->dump(cerr, 6);\n      return false;\n}\n\nbool target_t::proc_deassign(const NetDeassign*dev)\n{\n      cerr << dev->get_fileline() << \": internal error: \"\n\t   << \"target (\" << typeid(*this).name() <<  \"): \"\n\t   << \"Unhandled proc_deassign.\" << endl;\n      return false;\n}\n\nbool target_t::proc_delay(const NetPDelay*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_delay.\" << endl;\n      return false;\n}\n\nbool target_t::proc_disable(const NetDisable*obj)\n{\n      cerr << obj->get_fileline() << \": internal error: \"\n\t   << \"target (\" << typeid(*this).name() << \"): \"\n\t   << \"does not support disable statements.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_do_while(const NetDoWhile*net)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled do/while:\" << endl;\n      net->dump(cerr, 6);\n}\n\nbool target_t::proc_force(const NetForce*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_force.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_forever(const NetForever*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_forever.\" << endl;\n}\n\nbool target_t::proc_forloop(const NetForLoop*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_forloop.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_free(const NetFree*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_free.\" << endl;\n}\n\nbool target_t::proc_release(const NetRelease*dev)\n{\n      cerr << dev->get_fileline() << \": internal error: \"\n\t   << \"target (\" << typeid(*this).name() <<  \"): \"\n\t   << \"Unhandled proc_release.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_repeat(const NetRepeat*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_repeat.\" << endl;\n}\n\nbool target_t::proc_trigger(const NetEvTrig*tr)\n{\n      cerr << tr->get_fileline() << \": error: target (\" << typeid(*this).name()\n\t   <<  \"): Unhandled event trigger.\" << endl;\n      return false;\n}\n\nbool target_t::proc_nb_trigger(const NetEvNBTrig*tr)\n{\n      cerr << tr->get_fileline() << \": error: target (\" << typeid(*this).name()\n\t   <<  \"): Unhandled non-blocking event trigger.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_stask(const NetSTask*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_stask.\" << endl;\n}\n\nvoid target_t::proc_utask(const NetUTask*)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled proc_utask.\" << endl;\n}\n\nbool target_t::proc_wait(const NetEvWait*tr)\n{\n      cerr << tr->get_fileline() << \": error: target (\" << typeid(*this).name()\n\t   <<  \"): Unhandled event wait.\" << endl;\n      return false;\n}\n\nvoid target_t::proc_while(const NetWhile*net)\n{\n      cerr << \"target (\" << typeid(*this).name() <<  \"): \"\n\t    \"Unhandled while:\" << endl;\n      net->dump(cerr, 6);\n}\n\nint target_t::end_design(const Design*)\n{\n      return 0;\n}\n\nexpr_scan_t::~expr_scan_t()\n{\n}\n\nvoid expr_scan_t::expr_access_func(const NetEAccess*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_access_func.\" << endl;\n}\n\nvoid expr_scan_t::expr_array_pattern(const NetEArrayPattern*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_array_pattern.\" << endl;\n}\n\nvoid expr_scan_t::expr_const(const NetEConst*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_const.\" << endl;\n}\n\nvoid expr_scan_t::expr_last(const NetELast*exp)\n{\n      cerr << exp->get_fileline() << \": expr_scan_t(\" << typeid(*this).name() << \"): \"\n\t   << \"unhandled expr_last.\" << endl;\n}\n\nvoid expr_scan_t::expr_new(const NetENew*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_new.\" << endl;\n}\n\nvoid expr_scan_t::expr_null(const NetENull*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_null.\" << endl;\n}\n\nvoid expr_scan_t::expr_param(const NetEConstParam*that)\n{\n      expr_const(that);\n}\n\nvoid expr_scan_t::expr_property(const NetEProperty*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_property.\" << endl;\n}\n\nvoid expr_scan_t::expr_creal(const NetECReal*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_creal.\" << endl;\n}\n\nvoid expr_scan_t::expr_rparam(const NetECRealParam*that)\n{\n      expr_creal(that);\n}\n\nvoid expr_scan_t::expr_concat(const NetEConcat*that)\n{\n      cerr << that->get_fileline() << \": expr_scan_t (\" <<\n\t    typeid(*this).name() << \"): unhandled expr_concat.\" << endl;\n}\nvoid expr_scan_t::expr_event(const NetEEvent*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_event.\" << endl;\n}\n\nvoid expr_scan_t::expr_netenum(const NetENetenum*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_netenum.\" << endl;\n}\n\nvoid expr_scan_t::expr_scope(const NetEScope*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_scope.\" << endl;\n}\n\nvoid expr_scan_t::expr_scopy(const NetEShallowCopy*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_scopy.\" << endl;\n}\n\nvoid expr_scan_t::expr_select(const NetESelect*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_select.\" << endl;\n}\n\nvoid expr_scan_t::expr_sfunc(const NetESFunc*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_sfunc.\" << endl;\n}\n\nvoid expr_scan_t::expr_signal(const NetESignal*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_signal.\" << endl;\n}\n\nvoid expr_scan_t::expr_ternary(const NetETernary*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_ternary.\" << endl;\n}\n\nvoid expr_scan_t::expr_ufunc(const NetEUFunc*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled function call.\" << endl;\n}\n\nvoid expr_scan_t::expr_unary(const NetEUnary*)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_unary.\" << endl;\n}\n\nvoid expr_scan_t::expr_binary(const NetEBinary*ex)\n{\n      cerr << \"expr_scan_t (\" << typeid(*this).name() << \"): \"\n\t    \"unhandled expr_binary: \" <<*ex  << endl;\n}\n"
        },
        {
          "name": "target.h",
          "type": "blob",
          "size": 7.8310546875,
          "content": "#ifndef IVL_target_H\n#define IVL_target_H\n/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"netlist.h\"\n\n/*\n * This header file describes the types and constants used to describe\n * the possible target output types of the compiler. The backends\n * provide one of these in order to tell the previous steps what the\n * backend is able to do.\n */\n\n/*\n * The backend driver is hooked into the compiler, and given a name,\n * by creating an instance of the target structure. The structure has\n * the name that the compiler will use to locate the driver, and a\n * pointer to a target_t object that is the actual driver.\n */\nstruct target {\n      const char* name;\n      struct target_t* meth;\n};\n\n/*\n * The emit process uses a target_t driver to send the completed\n * design to a file. It is up to the driver object to follow along in\n * the iteration through the design, generating output as it can.\n */\n\nstruct target_t {\n      inline target_t() : errors(0) { }\n      virtual ~target_t();\n\n\t/* Set this to count errors encountered during emit. */\n      int errors;\n\n\t/* Start the design. This sets the main output file stream\n\t   that the target should use. */\n      virtual bool start_design(const Design*) =0;\n\n\t/* This is called once for each scope in the design, before\n\t   anything else is called. */\n      virtual void scope(const NetScope*);\n\n      virtual bool class_type(const NetScope*, netclass_t*);\n\n\t/* This is called to convert module ports from a NetNet* to an\n\t * ivl_signal_t object. */\n      virtual void convert_module_ports(const NetScope*);\n\n\t/* Output an event object. Called for each named event in the scope. */\n      virtual void event(const NetEvent*);\n\n        /* Output an enumeration typespec. */\n      virtual bool enumeration(const NetScope*, netenum_t*);\n\n\t/* Output a signal (called for each signal) */\n      virtual void signal(const NetNet*) =0;\n      virtual bool signal_paths(const NetNet*);\n\n        /* Analog branches */\n      virtual bool branch(const NetBranch*);\n\n\t/* Output a defined task. */\n      virtual void task_def(const NetScope*);\n      virtual bool func_def(const NetScope*);\n\n\t/* LPM style components are handled here. */\n      virtual void lpm_abs(const NetAbs*);\n      virtual void lpm_add_sub(const NetAddSub*);\n      virtual bool lpm_array_dq(const NetArrayDq*);\n      virtual void lpm_clshift(const NetCLShift*);\n      virtual bool lpm_cast_int2(const NetCastInt2*);\n      virtual bool lpm_cast_int4(const NetCastInt4*);\n      virtual bool lpm_cast_real(const NetCastReal*);\n      virtual void lpm_compare(const NetCompare*);\n      virtual void lpm_divide(const NetDivide*);\n      virtual void lpm_modulo(const NetModulo*);\n      virtual void lpm_ff(const NetFF*);\n      virtual void lpm_latch(const NetLatch*);\n      virtual void lpm_mult(const NetMult*);\n      virtual void lpm_mux(const NetMux*);\n      virtual void lpm_pow(const NetPow*);\n\n      virtual bool concat(const NetConcat*);\n      virtual bool part_select(const NetPartSelect*);\n      virtual bool replicate(const NetReplicate*);\n\n\t/* Output a gate (called for each gate) */\n      virtual void logic(const NetLogic*);\n      virtual bool tran(const NetTran*);\n      virtual bool ureduce(const NetUReduce*); /* unary reduction operator */\n      virtual bool bufz(const NetBUFZ*);\n      virtual void udp(const NetUDP*);\n      virtual void net_case_cmp(const NetCaseCmp*);\n      virtual bool net_const(const NetConst*);\n      virtual bool net_sysfunction(const NetSysFunc*);\n      virtual bool net_function(const NetUserFunc*);\n      virtual bool net_literal(const NetLiteral*);\n      virtual void net_probe(const NetEvProbe*);\n      virtual bool sign_extend(const NetSignExtend*);\n      virtual bool substitute(const NetSubstitute*);\n\n\t/* Output a process (called for each process). It is up to the\n\t   target to recurse if desired. */\n      virtual bool process(const NetProcTop*);\n      virtual bool process(const NetAnalogTop*);\n\n\t/* Various kinds of process nodes are dispatched through these. */\n      virtual void proc_alloc(const NetAlloc*);\n      virtual bool proc_assign(const NetAssign*);\n      virtual void proc_assign_nb(const NetAssignNB*);\n      virtual bool proc_block(const NetBlock*);\n      virtual bool proc_break(const NetBreak*);\n      virtual void proc_case(const NetCase*);\n      virtual bool proc_cassign(const NetCAssign*);\n      virtual bool proc_condit(const NetCondit*);\n      virtual bool proc_continue(const NetContinue*);\n      virtual bool proc_contribution(const NetContribution*);\n      virtual bool proc_deassign(const NetDeassign*);\n      virtual bool proc_delay(const NetPDelay*);\n      virtual bool proc_disable(const NetDisable*);\n      virtual void proc_do_while(const NetDoWhile*);\n      virtual bool proc_force(const NetForce*);\n      virtual bool proc_forloop(const NetForLoop*) =0;\n      virtual void proc_forever(const NetForever*);\n      virtual void proc_free(const NetFree*);\n      virtual bool proc_release(const NetRelease*);\n      virtual void proc_repeat(const NetRepeat*);\n      virtual bool proc_trigger(const NetEvTrig*);\n      virtual bool proc_nb_trigger(const NetEvNBTrig*);\n      virtual void proc_stask(const NetSTask*);\n      virtual void proc_utask(const NetUTask*);\n      virtual bool proc_wait(const NetEvWait*);\n      virtual void proc_while(const NetWhile*);\n\n\t/* Done with the design. The target returns !0 if there is\n\t   some error in the code generation. */\n      virtual int end_design(const Design*);\n};\n\n/* This class is used by the NetExpr class to help with the scanning\n   of expressions. */\nstruct expr_scan_t {\n      virtual ~expr_scan_t();\n      virtual void expr_access_func(const NetEAccess*);\n      virtual void expr_array_pattern(const NetEArrayPattern*);\n      virtual void expr_const(const NetEConst*);\n      virtual void expr_last(const NetELast*);\n      virtual void expr_new(const NetENew*);\n      virtual void expr_null(const NetENull*);\n      virtual void expr_param(const NetEConstParam*);\n      virtual void expr_property(const NetEProperty*);\n      virtual void expr_rparam(const NetECRealParam*);\n      virtual void expr_creal(const NetECReal*);\n      virtual void expr_concat(const NetEConcat*);\n      virtual void expr_event(const NetEEvent*);\n      virtual void expr_scope(const NetEScope*);\n      virtual void expr_scopy(const NetEShallowCopy*);\n      virtual void expr_select(const NetESelect*);\n      virtual void expr_sfunc(const NetESFunc*);\n      virtual void expr_signal(const NetESignal*);\n      virtual void expr_ternary(const NetETernary*);\n      virtual void expr_ufunc(const NetEUFunc*);\n      virtual void expr_unary(const NetEUnary*);\n      virtual void expr_binary(const NetEBinary*);\n      virtual void expr_netenum(const NetENetenum*);\n};\n\n\n/* This function takes a fully qualified Verilog name (which may have,\n   for example, dots in it) and produces a mangled version that can be\n   used by most any language. */\nextern std::string mangle(const std::string&str);\n\n/* This function takes a string and produces an escaped version that can be\n   used inside a string constant for a C++ compiler. */\nextern std::string stresc(const std::string&str);\n\n#endif /* IVL_target_H */\n"
        },
        {
          "name": "tgt-blif",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-fpga",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-null",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-pal",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-pcb",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-sizer",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-stub",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-verilog",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-vhdl",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-vlog95",
          "type": "tree",
          "content": null
        },
        {
          "name": "tgt-vvp",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 1.4990234375,
          "content": "#ifndef IVL_util_H\n#define IVL_util_H\n/*\n * Copyright (c) 2000-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <map>\n# include  <vector>\n# include  <list>\n# include  \"StringHeap.h\"\n# include  \"verinum.h\"\n\nclass PExpr;\nclass Design;\nclass NetScope;\n\n/*\n * This file attempts to locate a module in a file. It operates by\n * looking for a plausible Verilog file to hold the module, and\n * invoking the parser to bring in that file's contents.\n */\nextern bool load_module(const char*type, int&parser_errors);\n\n\n\nstruct attrib_list_t {\n      perm_string key;\n      verinum val;\n};\n\nextern attrib_list_t* evaluate_attributes(const std::map<perm_string,PExpr*>&att,\n\t\t\t\t\t  unsigned&natt,\n\t\t\t\t\t  Design*des, NetScope*scope);\n\n#endif /* IVL_util_H */\n"
        },
        {
          "name": "verilog.spec",
          "type": "blob",
          "size": 5.0751953125,
          "content": "#norootforbuild\n#\n%define major 13\n%define minor 0\n%define rev_date 20250103\n# Normally, the suff-ix is %nil, meaning the suffix is to not be used.\n# But if the builder wants to make a suffixed package, he may set this\n# to a value (i.e. -test) to cause suffixes to be put in all the right\n# places.\n%define suff %nil\n#\n#\nSummary: Icarus Verilog\nName: verilog%{suff}\nVersion: %{major}.%{minor}.%{rev_date}\nRelease: 0\nLicense: GPL\nGroup: Productivity/Scientific/Electronics\nSource: verilog%{suff}-%{rev_date}.tar.gz\nURL: http://www.icarus.com/eda/verilog/index.html\nPackager: Stephen Williams <steve@icarus.com>\n\nBuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root\n\nBuildRequires: gcc-c++, zlib-devel, bison, flex, gperf, readline-devel\n\n# This provides tag allows me to use a more specific name for things\n# that actually depend on me, Icarus Verilog.\nProvides: iverilog\n\n%description\nIcarus Verilog is a Verilog compiler that generates a variety of\nengineering formats, including simulation. It strives to be true\nto the IEEE-1364 standard.\n\n%prep\n%setup -n verilog%{suff}-%{rev_date}\n\n%build\nif test X%{suff} != X\nthen\n    %{configure} --enable-suffix=%{suff}\nelse\n    %{configure}\nfi\nmake CXXFLAGS=-O\n\n%install\n%if 0%{?suse_version}\n%{makeinstall}\n%else\nmake DESTDIR=$RPM_BUILD_ROOT install\n%endif\n\n%clean\nrm -rf $RPM_BUILD_ROOT\n\n%files\n\n%attr(-,root,root) %doc COPYING README.txt BUGS.txt QUICK_START.txt ieee1364-notes.txt mingw.txt swift.txt netlist.txt t-dll.txt vpi.txt cadpli/cadpli.txt\n%attr(-,root,root) %doc examples/*\n\n%attr(-,root,root) %{_mandir}/man1/iverilog%{suff}.1.gz\n%attr(-,root,root) %{_mandir}/man1/iverilog-vpi%{suff}.1.gz\n%attr(-,root,root) %{_mandir}/man1/vvp%{suff}.1.gz\n\n%attr(-,root,root) %{_bindir}/iverilog%{suff}\n%attr(-,root,root) %{_bindir}/iverilog-vpi%{suff}\n%attr(-,root,root) %{_bindir}/vvp%{suff}\n%attr(-,root,root) %{_libdir}/ivl%{suff}/ivl\n%attr(-,root,root) %{_libdir}/ivl%{suff}/ivlpp\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdlpp\n%attr(-,root,root) %{_libdir}/ivl%{suff}/blif.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/blif.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/blif-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/null.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/null.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/null-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/sizer.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/sizer.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/sizer-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/stub.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/stub.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/stub-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vvp.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vvp.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vvp-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdl.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdl.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdl-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vlog95.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vlog95.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vlog95-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/pcb.tgt\n%attr(-,root,root) %{_libdir}/ivl%{suff}/pcb.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/pcb-s.conf\n%attr(-,root,root) %{_libdir}/ivl%{suff}/system.sft\n%attr(-,root,root) %{_libdir}/ivl%{suff}/system.vpi\n%attr(-,root,root) %{_libdir}/ivl%{suff}/va_math.sft\n%attr(-,root,root) %{_libdir}/ivl%{suff}/va_math.vpi\n%attr(-,root,root) %{_libdir}/ivl%{suff}/v2005_math.sft\n%attr(-,root,root) %{_libdir}/ivl%{suff}/v2005_math.vpi\n%attr(-,root,root) %{_libdir}/ivl%{suff}/v2009.sft\n%attr(-,root,root) %{_libdir}/ivl%{suff}/v2009.vpi\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdl_sys.sft\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdl_sys.vpi\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdl_textio.sft\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vhdl_textio.vpi\n%attr(-,root,root) %{_libdir}/ivl%{suff}/vpi_debug.vpi\n%attr(-,root,root) %{_libdir}/ivl%{suff}/cadpli.vpl\n%attr(-,root,root) %{_libdir}/libvpi%{suff}.a\n%attr(-,root,root) %{_libdir}/libveriuser%{suff}.a\n%attr(-,root,root) %{_libdir}/ivl%{suff}/include/constants.vams\n%attr(-,root,root) %{_libdir}/ivl%{suff}/include/disciplines.vams\n%attr(-,root,root) /usr/include/iverilog%{suff}/ivl_target.h\n%attr(-,root,root) /usr/include/iverilog%{suff}/vpi_user.h\n%attr(-,root,root) /usr/include/iverilog%{suff}/sv_vpi_user.h\n%attr(-,root,root) /usr/include/iverilog%{suff}/acc_user.h\n%attr(-,root,root) /usr/include/iverilog%{suff}/veriuser.h\n%attr(-,root,root) /usr/include/iverilog%{suff}/_pli_types.h\n\n%changelog -n verilog\n* Thu Jul 25 2013 - steve@icarus.com\n- Add blif code generator files.\n\n* Wed Feb 25 2009 - steve@icarus.com\n- Handle a package suffix if desired.\n\n* Tue Nov 25 2008 - steve@icarus.com\n- Move header files frim /verilog/ to /iverilog/\n\n* Tue Nov 18 2008 - steve@icarus.com\n- New snapshot 20080905\n\n* Fri Sep 03 2008 - steve@icarus.com\n- New snapshot 20080905\n\n* Sat Aug 30 2008 - steve@icarus.com\n- Add vhdl target files\n- Add V/AMS header files.\n\n* Fri Jan 25 2008 - steve@icarus.com\n- Removed vvp32 support for x86_64 build.\n\n* Sun Feb 28 2007 - steve@icarus.com\n- Added formatting suitable for openSUSE packaging.\n"
        },
        {
          "name": "verinum.cc",
          "type": "blob",
          "size": 43.046875,
          "content": "/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  \"verinum.h\"\n# include  <iostream>\n# include  <cassert>\n# include  <climits>\n# include  <cmath> // Needed to get pow for as_double().\n# include  <cstdio> // Needed to get snprintf for as_string().\n# include  <algorithm>\n\nusing namespace std;\n\n#if !defined(HAVE_LROUND)\n/*\n * If the system doesn't provide the lround function, then we provide\n * it ourselves here. It is simply the nearest integer, rounded away\n * from zero.\n */\nextern \"C\" long int lround(double x)\n{\n      if (x >= 0.0)\n\t    return (long)floor(x+0.5);\n      else\n\t    return (long)ceil(x-0.5);\n}\n#endif\n\nstatic verinum::V add_with_carry(verinum::V l, verinum::V r, verinum::V&c);\n\nverinum::verinum()\n: bits_(0), nbits_(0), has_len_(false), has_sign_(false), is_single_(false), string_flag_(false)\n{\n}\n\nverinum::verinum(const V*bits, unsigned nbits, bool has_len__)\n: has_len_(has_len__), has_sign_(false), is_single_(false), string_flag_(false)\n{\n      nbits_ = nbits;\n      bits_ = new V [nbits];\n      for (unsigned idx = 0 ;  idx < nbits ;  idx += 1) {\n\t    bits_[idx] = bits[idx];\n      }\n}\n\nstatic string process_verilog_string_quotes(const string&str)\n{\n      string res;\n\n      int idx = 0;\n      int str_len = str.length();\n\n      while (idx < str_len) {\n\t    if (str[idx] == '\\\\') {\n\t\t  idx += 1;\n\t\t  assert(idx < str_len);\n\t\t  switch (str[idx]) {\n\t\t      case 'n':\n\t\t\tres = res + '\\n';\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t      case 't':\n\t\t\tres = res + '\\t';\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t      case 'v':\n\t\t\tres = res + '\\v';\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t      case 'f':\n\t\t\tres = res + '\\f';\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t      case 'a':\n\t\t\tres = res + '\\a';\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t      case '0':\n\t\t      case '1':\n\t\t      case '2':\n\t\t      case '3':\n\t\t      case '4':\n\t\t      case '5':\n\t\t      case '6':\n\t\t      case '7': {\n\t\t\t    char byte_val = 0;\n\t\t\t    int odx = 0;\n\t\t\t    while (odx < 3 && idx+odx < str_len\n\t\t\t\t   && str[idx+odx] >= '0'\n\t\t\t\t   && str[idx+odx] <= '7') {\n\t\t\t\t  byte_val = 8*byte_val + str[idx+odx]-'0';\n\t\t\t\t  odx += 1;\n\t\t\t    }\n\t\t\t    idx += odx;\n\t\t\t    res = res + byte_val;\n\t\t\t    break;\n\t\t      }\n\t\t      case 'x': {\n\t\t\t    char byte_val = 0;\n\t\t\t    int odx = 1;\n\t\t\t    while (odx < 3 && idx+odx < str_len) {\n\t\t\t\t  if (str[idx+odx] >= '0' && str[idx+odx] <= '9') {\n\t\t\t\t\tbyte_val = 16*byte_val + str[idx+odx]-'0';\n\t\t\t\t\todx += 1;\n\t\t\t\t  } else if  (str[idx+odx] >= 'a' && str[idx+odx] <= 'f') {\n\t\t\t\t\tbyte_val = 16*byte_val + str[idx+odx]-'a'+10;\n\t\t\t\t\todx += 1;\n\t\t\t\t  } else if  (str[idx+odx] >= 'A' && str[idx+odx] <= 'F') {\n\t\t\t\t\tbyte_val = 16*byte_val + str[idx+odx]-'A'+10;\n\t\t\t\t\todx += 1;\n\t\t\t\t  } else {\n\t\t\t\t\tbreak;\n\t\t\t\t  }\n\t\t\t    }\n\t\t\t    idx += odx;\n\t\t\t    res = res + byte_val;\n\t\t\t    break;\n\t\t      }\n\t\t      default:\n\t\t\tres = res + str[idx];\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\t  }\n\t    } else {\n\t\t  res = res + str[idx];\n\t\t  idx += 1;\n\t    }\n      }\n      return res;\n}\n\nverinum::verinum(const string&s)\n: has_len_(true), has_sign_(false), is_single_(false), string_flag_(true)\n{\n      string str = process_verilog_string_quotes(s);\n      nbits_ = str.length() * 8;\n\n\t// Special case: The string \"\" is 8 bits of 0.\n      if (nbits_ == 0) {\n\t    nbits_ = 8;\n\t    bits_ = new V [nbits_];\n\t    bits_[0] = V0;\n\t    bits_[1] = V0;\n\t    bits_[2] = V0;\n\t    bits_[3] = V0;\n\t    bits_[4] = V0;\n\t    bits_[5] = V0;\n\t    bits_[6] = V0;\n\t    bits_[7] = V0;\n\t    return;\n      }\n\n      bits_ = new V [nbits_];\n\n      unsigned idx, cp;\n      V*bp = bits_+nbits_;\n      for (idx = nbits_, cp = 0 ;  idx > 0 ;  idx -= 8, cp += 1) {\n\t    char ch = str[cp];\n\t    *(--bp) = (ch&0x80) ? V1 : V0;\n\t    *(--bp) = (ch&0x40) ? V1 : V0;\n\t    *(--bp) = (ch&0x20) ? V1 : V0;\n\t    *(--bp) = (ch&0x10) ? V1 : V0;\n\t    *(--bp) = (ch&0x08) ? V1 : V0;\n\t    *(--bp) = (ch&0x04) ? V1 : V0;\n\t    *(--bp) = (ch&0x02) ? V1 : V0;\n\t    *(--bp) = (ch&0x01) ? V1 : V0;\n      }\n}\n\nverinum::verinum(verinum::V val, unsigned n, bool h)\n: has_len_(h), has_sign_(false), is_single_(false), string_flag_(false)\n{\n      nbits_ = n;\n      bits_ = new V[nbits_];\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1)\n\t    bits_[idx] = val;\n}\n\nverinum::verinum(uint64_t val, unsigned n)\n: has_len_(true), has_sign_(false), is_single_(false), string_flag_(false)\n{\n      nbits_ = n;\n      bits_ = new V[nbits_];\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1) {\n\t    bits_[idx] = (val&1) ? V1 : V0;\n\t    val >>= (uint64_t)1;\n      }\n}\n\n/* The second argument is not used! It is there to make this\n * constructor unique. */\nverinum::verinum(double val, bool)\n: has_len_(false), has_sign_(true), is_single_(false), string_flag_(false)\n{\n      bool is_neg = false;\n      double fraction;\n      int exponent;\n      const unsigned BITS_IN_LONG = 8*sizeof(long);\n\n\t/* We return `bx for a NaN or +/- infinity. */\n      if (val != val || (val && (val == 0.5*val))) {\n\t    nbits_ = 1;\n\t    bits_ = new V[nbits_];\n\t    bits_[0] = Vx;\n\t    return;\n      }\n\n\t/* Convert to a positive result. */\n      if (val < 0.0) {\n\t    is_neg = true;\n\t    val = -val;\n      }\n\n\t/* Round to the nearest integer now, as this may increase the\n\t   number of bits we need to allocate. */\n      val = round(val);\n\n\t/* Get the exponent and fractional part of the number. */\n      fraction = frexp(val, &exponent);\n      nbits_ = exponent+1;\n      bits_ = new V[nbits_];\n\n\t/* If the value is small enough just use lround(). */\n      if (nbits_ <= BITS_IN_LONG) {\n\t    long sval = lround(val);\n\t    if (is_neg) sval = -sval;\n\t    for (unsigned idx = 0; idx < nbits_; idx += 1) {\n\t\t  bits_[idx] = (sval&1) ? V1 : V0;\n\t\t  sval >>= 1;\n\t    }\n\t      /* Trim the result. */\n\t    signed_trim();\n\t    return;\n      }\n\n      unsigned nwords = (exponent-1)/BITS_IN_LONG;\n\n      fraction = ldexp(fraction, (exponent-1) % BITS_IN_LONG + 1);\n\n      if (nwords == 0) {\n\t    unsigned long bits = (unsigned long) fraction;\n\t    fraction = fraction - (double) bits;\n\t    for (unsigned idx = 0; idx < nbits_; idx += 1) {\n\t\t  bits_[idx] = (bits&1) ? V1 : V0;\n\t\t  bits >>= 1;\n\t    }\n      } else {\n\t    for (int wd = nwords; wd >= 0; wd -= 1) {\n\t\t  unsigned long bits = (unsigned long) fraction;\n\t\t  fraction = fraction - (double) bits;\n\t\t  unsigned max_idx = (wd+1)*BITS_IN_LONG;\n\t\t  if (max_idx > nbits_) max_idx = nbits_;\n\t\t  for (unsigned idx = wd*BITS_IN_LONG; idx < max_idx; idx += 1) {\n\t\t\tbits_[idx] = (bits&1) ? V1 : V0;\n\t\t\tbits >>= 1;\n\t\t  }\n\t\t  fraction = ldexp(fraction, BITS_IN_LONG);\n\t    }\n      }\n\n\t/* Convert a negative number if needed. */\n      if (is_neg) {\n\t    *this = -(*this);\n      }\n\n\t/* Trim the result. */\n      signed_trim();\n}\n\n\n/* This is used by the double constructor above. It is needed to remove\n * extra sign bits that can occur when calculating a negative value. */\nvoid verinum::signed_trim()\n{\n\t/* Do we have any extra digits? */\n      unsigned tlen = nbits_-1;\n      verinum::V sign = bits_[tlen];\n      while ((tlen > 0) && (bits_[tlen] == sign)) tlen -= 1;\n\n\t/* tlen now points to the first digit that is not the sign.\n\t * or bit 0. Set the length to include this bit and one proper\n\t * sign bit if needed. */\n      if (bits_[tlen] != sign) tlen += 1;\n      tlen += 1;\n\n\t/* Trim the bits if needed. */\n      if (tlen < nbits_) {\n\t    V* tbits = new V[tlen];\n\t    for (unsigned idx = 0; idx < tlen; idx += 1)\n\t\t  tbits[idx] = bits_[idx];\n\t    delete[] bits_;\n\t    bits_ = tbits;\n\t    nbits_ = tlen;\n      }\n}\n\nverinum::verinum(const verinum&that)\n{\n      string_flag_ = that.string_flag_;\n      nbits_ = that.nbits_;\n      bits_ = new V[nbits_];\n      has_len_ = that.has_len_;\n      has_sign_ = that.has_sign_;\n      is_single_ = that.is_single_;\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1)\n\t    bits_[idx] = that.bits_[idx];\n}\n\nverinum::verinum(const verinum&that, unsigned nbits)\n{\n      string_flag_ = that.string_flag_ && (that.nbits_ == nbits);\n      nbits_ = nbits;\n      bits_ = new V[nbits_];\n      has_len_ = true;\n      has_sign_ = that.has_sign_;\n      is_single_ = false;\n\n      unsigned copy = nbits;\n      if (copy > that.nbits_)\n\t    copy = that.nbits_;\n      for (unsigned idx = 0 ;  idx < copy ;  idx += 1)\n\t    bits_[idx] = that.bits_[idx];\n\n      if (copy < nbits_) {\n\t    if (has_sign_ || that.is_single_) {\n\t\t  for (unsigned idx = copy ;  idx < nbits_ ;  idx += 1)\n\t\t\tbits_[idx] = bits_[idx-1];\n\t    } else {\n\t\t  for (unsigned idx = copy ;  idx < nbits_ ;  idx += 1)\n\t\t\tbits_[idx] = verinum::V0;\n\t    }\n      }\n}\n\nverinum::verinum(int64_t that)\n: has_len_(false), has_sign_(true), is_single_(false), string_flag_(false)\n{\n      int64_t tmp;\n\n      if (that < 0) tmp = (that+1)/2;\n      else tmp = that/2;\n      nbits_ = 1;\n      while (tmp != 0) {\n\t    nbits_ += 1;\n\t    tmp /= 2;\n      }\n\n      nbits_ += 1;\n\n      bits_ = new V[nbits_];\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1) {\n\t    bits_[idx] = (that & 1)? V1 : V0;\n\t    that >>= 1;\n      }\n}\n\nverinum::~verinum()\n{\n      delete[]bits_;\n}\n\nverinum& verinum::operator= (const verinum&that)\n{\n      if (this == &that) return *this;\n      if (nbits_ != that.nbits_) {\n            delete[]bits_;\n            nbits_ = that.nbits_;\n            bits_ = new V[that.nbits_];\n      }\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1)\n\t    bits_[idx] = that.bits_[idx];\n\n      has_len_ = that.has_len_;\n      has_sign_ = that.has_sign_;\n      is_single_ = that.is_single_;\n      string_flag_ = that.string_flag_;\n      return *this;\n}\n\nverinum::V verinum::get(unsigned idx) const\n{\n      assert(idx < nbits_);\n      return bits_[idx];\n}\n\nverinum::V verinum::set(unsigned idx, verinum::V val)\n{\n      assert(idx < nbits_);\n      return bits_[idx] = val;\n}\n\nvoid verinum::set(unsigned off, const verinum&val)\n{\n      assert(off + val.len() <= nbits_);\n      for (unsigned idx = 0 ; idx < val.len() ; idx += 1)\n\t    bits_[off+idx] = val[idx];\n}\n\nunsigned verinum::as_unsigned() const\n{\n      if (nbits_ == 0)\n\t    return 0;\n\n      if (!is_defined())\n\t    return 0;\n\n      unsigned val = 0;\n      unsigned mask = 1;\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1, mask <<= 1)\n\t    if (bits_[idx] == V1) {\n\t\t  if (mask == 0) return ~mask;\n\t\t  val |= mask;\n\t    }\n\n      return val;\n}\n\nunsigned long verinum::as_ulong() const\n{\n      if (nbits_ == 0)\n\t    return 0;\n\n      if (!is_defined())\n\t    return 0;\n\n      unsigned long val = 0;\n      unsigned long mask = 1;\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1, mask <<= 1)\n\t    if (bits_[idx] == V1) {\n\t\t  if (mask == 0) return ~mask;\n\t\t  val |= mask;\n\t    }\n\n      return val;\n}\n\nuint64_t verinum::as_ulong64() const\n{\n      if (nbits_ == 0)\n\t    return 0;\n\n      if (!is_defined())\n\t    return 0;\n\n      uint64_t val = 0;\n      uint64_t mask = 1;\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1, mask <<= 1)\n\t    if (bits_[idx] == V1) {\n\t\t  if (mask == 0) return ~mask;\n\t\t  val |= mask;\n\t    }\n\n      return val;\n}\n\n/*\n * This function returns the native long integer that represents the\n * value of this object. It accounts for sign extension if the value\n * is signed.\n *\n * If the value is undefined, return 0.\n *\n * This function presumes that the native format is 2s complement\n * (pretty safe these days) and masks/sets bits accordingly. If the\n * value is too large for the native form, it truncates the high bits.\n */\nsigned long verinum::as_long() const\n{\n#define IVLLBITS (8 * sizeof(long) - 1)\n      if (nbits_ == 0)\n\t    return 0;\n\n      if (!is_defined())\n\t    return 0;\n\n      signed long val = 0;\n      unsigned diag_top = 0;\n\n      unsigned top = nbits_;\n      if (top > IVLLBITS) {\n\t    diag_top = top;\n\t    top = IVLLBITS;\n      }\n      int lost_bits=0;\n\n      if (has_sign_ && (bits_[nbits_-1] == V1)) {\n\t    val = -1;\n\t    signed long mask = ~1L;\n\t    for (unsigned idx = 0 ;  idx < top ;  idx += 1) {\n\t\t  if (bits_[idx] == V0) val &= mask;\n\t\t  mask = (mask << 1) | 1L;\n\t    }\n\t    if (diag_top) {\n\t\t  for (unsigned idx = top; idx < diag_top; idx += 1) {\n\t\t\tif (bits_[idx] == V0) lost_bits=1;\n\t\t  }\n\t    }\n      } else {\n\t    signed long mask = 1;\n\t    for (unsigned idx = 0 ;  idx < top ;  idx += 1, mask <<= 1) {\n\t\t  if (bits_[idx] == V1) val |= mask;\n\t    }\n\t    if (diag_top) {\n\t\t  for (unsigned idx = top; idx < diag_top; idx += 1) {\n\t\t\tif (bits_[idx] == V1) lost_bits=1;\n\t\t  }\n\t    }\n      }\n\n      if (lost_bits) cerr << \"warning: verinum::as_long() truncated \" <<\n\t  diag_top << \" bits to \" << IVLLBITS << \", returns \" << val << endl;\n      return val;\n#undef IVLLBITS\n}\n\ndouble verinum::as_double() const\n{\n      if (nbits_ == 0) return 0.0;\n\n      double val = 0.0;\n        /* Do we have/want a signed value? */\n      if (has_sign_ && bits_[nbits_-1] == V1) {\n\t    V carry = V1;\n\t    for (unsigned idx = 0; idx < nbits_; idx += 1) {\n\t\t  V sum = add_with_carry(~bits_[idx], V0, carry);\n\t\t  if (sum == V1)\n\t\t\tval += pow(2.0, (double)idx);\n\t    }\n\t    val *= -1.0;\n      } else {\n\t    for (unsigned idx = 0; idx < nbits_; idx += 1) {\n\t\t  if (bits_[idx] == V1)\n\t\t\tval += pow(2.0, (double)idx);\n\t    }\n      }\n      return val;\n}\n\nstring verinum::as_string() const\n{\n      assert( nbits_%8 == 0 );\n      if (nbits_ == 0)\n\t    return \"\";\n\n      string res;\n      for (unsigned idx = nbits_ ;  idx > 0 ;  idx -= 8) {\n\t    char char_val = 0;\n\t    V*bp = bits_+idx;\n\n\t    if (*(--bp) == V1) char_val |= 0x80;\n\t    if (*(--bp) == V1) char_val |= 0x40;\n\t    if (*(--bp) == V1) char_val |= 0x20;\n\t    if (*(--bp) == V1) char_val |= 0x10;\n\t    if (*(--bp) == V1) char_val |= 0x08;\n\t    if (*(--bp) == V1) char_val |= 0x04;\n\t    if (*(--bp) == V1) char_val |= 0x02;\n\t    if (*(--bp) == V1) char_val |= 0x01;\n\n\t    if (char_val == '\"' || char_val == '\\\\') {\n\t\t  char tmp[5];\n\t\t  snprintf(tmp, sizeof tmp, \"\\\\%03o\", char_val);\n\t\t  res = res + tmp;\n\t    } else if (isprint(char_val)) {\n\t\t  res = res + char_val;\n\t    } else {\n\t\t  char tmp[5];\n\t\t  snprintf(tmp, sizeof tmp, \"\\\\%03o\", (unsigned char)char_val);\n\t\t  res = res + tmp;\n\t    }\n      }\n      return res;\n}\n\nbool verinum::is_before(const verinum&that) const\n{\n      if (that.nbits_ > nbits_) return true;\n      if (that.nbits_ < nbits_) return false;\n\n      for (unsigned idx = nbits_  ;  idx > 0 ;  idx -= 1) {\n\t    if (bits_[idx-1] < that.bits_[idx-1]) return true;\n\t    if (bits_[idx-1] > that.bits_[idx-1]) return false;\n      }\n      return false;\n}\n\nbool verinum::is_defined() const\n{\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1) {\n\t    if (bits_[idx] == Vx) return false;\n\t    if (bits_[idx] == Vz) return false;\n      }\n      return true;\n}\n\nbool verinum::is_zero() const\n{\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1)\n\t    if (bits_[idx] != V0) return false;\n\n      return true;\n}\n\nbool verinum::is_negative() const\n{\n      return (bits_[nbits_-1] == V1) && has_sign();\n}\n\nunsigned verinum::significant_bits() const\n{\n      unsigned sbits = nbits_;\n\n      if (has_sign_) {\n\t    V sgn_bit = bits_[sbits-1];\n\t    while ((sbits > 1) && (bits_[sbits-2] == sgn_bit))\n\t\t  sbits -= 1;\n      } else {\n\t    while ((sbits > 1) && (bits_[sbits-1] == verinum::V0))\n\t\t  sbits -= 1;\n      }\n      return sbits;\n}\n\nvoid verinum::cast_to_int2()\n{\n      for (unsigned idx = 0 ;  idx < nbits_ ;  idx += 1) {\n\t    if (bits_[idx] == Vx || bits_[idx] == Vz)\n\t\t  bits_[idx] = V0;\n      }\n}\n\nverinum pad_to_width(const verinum&that, unsigned width)\n{\n      if (that.len() >= width)\n\t    return that;\n\n      if (that.len() == 0) {\n\t    verinum val (verinum::V0, width, that.has_len());\n\t    val.has_sign(that.has_sign());\n\t    return val;\n      }\n\n      verinum::V pad = that[that.len()-1];\n      if (pad==verinum::V1 && !that.has_sign() && !that.is_single())\n\t    pad = verinum::V0;\n      if (that.has_len() && !that.has_sign() && !that.is_single()) {\n\t    if (pad==verinum::Vx)\n\t\t  pad = verinum::V0;\n\t    if (pad==verinum::Vz)\n\t\t  pad = verinum::V0;\n      }\n\n      verinum val(pad, width, that.has_len());\n\n      for (unsigned idx = 0 ;  idx < that.len() ;  idx += 1)\n\t    val.set(idx, that[idx]);\n\n      val.has_sign(that.has_sign());\n      if (that.is_string() && (width % 8) == 0) {\n\t    val = verinum(val.as_string());\n      }\n      return val;\n}\n\nverinum cast_to_width(const verinum&that, unsigned width)\n{\n      if (that.has_len() && (that.len() == width))\n            return that;\n\n      if (that.len() >= width)\n            return verinum(that, width);\n\n      if (that.len() == 0) {\n\t    verinum val (verinum::V0, width, true);\n\t    val.has_sign(that.has_sign());\n\t    return val;\n      }\n\n      verinum::V pad = that[that.len()-1];\n      if (pad==verinum::V1 && !that.has_sign() && !that.is_single())\n\t    pad = verinum::V0;\n      if (that.has_len() && !that.has_sign() && !that.is_single()) {\n\t    if (pad==verinum::Vx)\n\t\t  pad = verinum::V0;\n\t    if (pad==verinum::Vz)\n\t\t  pad = verinum::V0;\n      }\n\n      verinum val(pad, width, true);\n\n      for (unsigned idx = 0 ;  idx < that.len() ;  idx += 1)\n\t    val.set(idx, that[idx]);\n\n      val.has_sign(that.has_sign());\n      return val;\n}\n\n/*\n * This function returns a version of the verinum that has only as\n * many bits as are needed to accurately represent the value. It takes\n * into account the signedness of the value.\n *\n * If the input value has a definite length, then that value is just\n * returned as is.\n */\nverinum trim_vnum(const verinum&that)\n{\n      unsigned tlen;\n\n      if (that.has_len())\n\t    return that;\n\n      if (that.len() < 2)\n\t    return that;\n\n      if (that.has_sign()) {\n\t    unsigned top = that.len()-1;\n\t    verinum::V sign = that.get(top);\n\n\t    while ((top > 0) && (that.get(top) == sign))\n\t\t  top -= 1;\n\n\t      /* top points to the first digit that is not the\n\t\t sign. Set the length to include this and one proper\n\t\t sign bit. */\n\n\t    if (that.get(top) != sign)\n\t\t  top += 1;\n\n\t    tlen = top+1;\n\n      } else {\n\n\t      /* If the result is unsigned and has an indefinite\n\t\t length, then trim off all but one leading zero. */\n\t    unsigned top = that.len()-1;\n\t    while ((top > 0) && (that.get(top) == verinum::V0))\n\t\t  top -= 1;\n\n\t      /* Now top is the index of the highest non-zero bit. If\n\t\t that turns out to the highest bit in the vector, then\n\t\t there is no trimming possible. */\n\t    if (top+1 == that.len())\n\t\t  return that;\n\n\t      /* Make tlen wide enough to include the highest non-zero\n\t\t bit, plus one extra 0 bit. */\n\t    tlen = top+2;\n\n\t      /* This can only happen when the verinum is all zeros,\n\t\t so make it a single bit wide. */\n\t    if (that.get(top) == verinum::V0) tlen -= 1;\n      }\n\n      verinum tmp (verinum::V0, tlen, false);\n      tmp.has_sign(that.has_sign());\n      for (unsigned idx = 0 ;  idx < tmp.len() ;  idx += 1)\n\t    tmp.set(idx, that.get(idx));\n\n      return tmp;\n}\n\nostream& operator<< (ostream&o, verinum::V v)\n{\n      switch (v) {\n\t  case verinum::V0:\n\t    o << \"0\";\n\t    break;\n\t  case verinum::V1:\n\t    o << \"1\";\n\t    break;\n\t  case verinum::Vx:\n\t    o << \"x\";\n\t    break;\n\t  case verinum::Vz:\n\t    o << \"z\";\n\t    break;\n      }\n      return o;\n}\n\n/*\n * This operator is used by various dumpers to write the Verilog\n * number in a Verilog format.\n */\nostream& operator<< (ostream&o, const verinum&v)\n{\n      if (v.is_string()) {\n\t    o << \"\\\"\" << v.as_string() << \"\\\"\";\n\t    return o;\n      }\n\n\t/* If the verinum number has a fixed length, dump all the bits\n\t   literally. This is how we express the fixed length in the\n\t   output. */\n      if (v.has_len()) {\n\t    o << v.len();\n      }\n\n\t/* If the number is fully defined (no x or z) then print it\n\t   out as a decimal number. */\n      unsigned dec_len = 8*sizeof(int);  /* avoid 32/64 bit differences. */\n      if (! v.has_sign()) dec_len -= 1;  /* an unsigned number. */\n      if (v.is_defined() && v.len() <= dec_len) {\n\t    if (v.has_sign())\n\t\t  o << \"'sd\" << v.as_long();\n\t    else\n\t\t  o << \"'d\" << v.as_ulong();\n\t    return o;\n      }\n\n\t/* Oh, well. Print the minimum to get the value properly\n\t   displayed. */\n      if (v.has_sign())\n\t    o << \"'sb\";\n      else\n\t    o << \"'b\";\n\n      if (v.len() == 0) {\n\t    o << \"0\";\n\t    return o;\n      }\n\n      verinum::V trim_left = v.get(v.len()-1);\n      unsigned idx;\n\n      if (v.has_sign()) {\n\t    for (idx = v.len()-1;  idx > 0;  idx -= 1)\n\t\t  if (trim_left != v.get(idx-1))\n\t\t\tbreak;\n\n\t    o << trim_left;\n      } else {\n\t    idx = v.len();\n      }\n\n      while (idx > 0) {\n\t    o << v.get(idx-1);\n\t    idx -= 1;\n      }\n\n      return o;\n}\n\nverinum::V operator == (const verinum&left, const verinum&right)\n{\n      verinum::V left_pad = verinum::V0;\n      verinum::V right_pad = verinum::V0;\n      if (left.has_sign() && right.has_sign()) {\n\t    left_pad = left.get(left.len()-1);\n\t    right_pad = right.get(right.len()-1);\n\n\t    if (left_pad == verinum::V1 && right_pad == verinum::V0)\n\t\t  return verinum::V0;\n\t    if (left_pad == verinum::V0 && right_pad == verinum::V1)\n\t\t  return verinum::V0;\n      }\n\n      unsigned max_len = left.len();\n      if (right.len() > max_len)\n\t    max_len = right.len();\n\n      for (unsigned idx = 0 ;  idx < max_len ;  idx += 1) {\n\t    verinum::V left_bit  = idx < left.len() ? left[idx]  : left_pad;\n\t    verinum::V right_bit = idx < right.len()? right[idx] : right_pad;\n\t    if (left_bit != right_bit)\n\t\t  return verinum::V0;\n      }\n\n      return verinum::V1;\n}\n\nverinum::V operator <= (const verinum&left, const verinum&right)\n{\n      verinum::V left_pad = verinum::V0;\n      verinum::V right_pad = verinum::V0;\n      bool signed_calc = left.has_sign() && right.has_sign();\n      if (signed_calc) {\n\t    left_pad = left.get(left.len()-1);\n\t    right_pad = right.get(right.len()-1);\n\n\t    if (left_pad == verinum::V1 && right_pad == verinum::V0)\n\t\t  return verinum::V1;\n\t    if (left_pad == verinum::V0 && right_pad == verinum::V1)\n\t\t  return verinum::V0;\n      }\n\n      unsigned idx;\n      for (idx = left.len() ; idx > right.len() ;  idx -= 1) {\n\t    if (left[idx-1] != right_pad) {\n\t\t      // A change of padding for a negative left argument\n\t\t      // denotes the left value is less than the right.\n\t\t   return (signed_calc &&\n\t\t           (left_pad == verinum::V1)) ? verinum::V1 :\n\t\t                                        verinum::V0;\n\t    }\n      }\n\n      for (idx = right.len() ; idx > left.len() ;  idx -= 1) {\n\t    if (right[idx-1] != left_pad) {\n\t\t      // A change of padding for a negative right argument\n\t\t      // denotes the left value is not less than the right.\n\t\t   return (signed_calc &&\n\t\t           (right_pad == verinum::V1)) ? verinum::V0 :\n\t\t                                         verinum::V1;\n\t    }\n      }\n\n      idx = right.len();\n      if (left.len() < idx) idx = left.len();\n\n      while (idx > 0) {\n\t    if (left[idx-1] == verinum::Vx) return verinum::Vx;\n\t    if (left[idx-1] == verinum::Vz) return verinum::Vx;\n\t    if (right[idx-1] == verinum::Vx) return verinum::Vx;\n\t    if (right[idx-1] == verinum::Vz) return verinum::Vx;\n\t    if (left[idx-1] > right[idx-1]) return verinum::V0;\n\t    if (left[idx-1] < right[idx-1]) return verinum::V1;\n\t    idx -= 1;\n      }\n\n      return verinum::V1;\n}\n\nverinum::V operator < (const verinum&left, const verinum&right)\n{\n      verinum::V left_pad = verinum::V0;\n      verinum::V right_pad = verinum::V0;\n      bool signed_calc = left.has_sign() && right.has_sign();\n      if (signed_calc) {\n\t    left_pad = left.get(left.len()-1);\n\t    right_pad = right.get(right.len()-1);\n\n\t    if (left_pad == verinum::V1 && right_pad == verinum::V0)\n\t\t  return verinum::V1;\n\t    if (left_pad == verinum::V0 && right_pad == verinum::V1)\n\t\t  return verinum::V0;\n      }\n\n      unsigned idx;\n      for (idx = left.len() ; idx > right.len() ;  idx -= 1) {\n\t    if (left[idx-1] != right_pad) {\n\t\t      // A change of padding for a negative left argument\n\t\t      // denotes the left value is less than the right.\n\t\t   return (signed_calc &&\n\t\t           (left_pad == verinum::V1)) ? verinum::V1 :\n\t\t                                        verinum::V0;\n\t    }\n      }\n\n      for (idx = right.len() ; idx > left.len() ;  idx -= 1) {\n\t    if (right[idx-1] != left_pad) {\n\t\t      // A change of padding for a negative right argument\n\t\t      // denotes the left value is not less than the right.\n\t\t   return (signed_calc &&\n\t\t           (right_pad == verinum::V1)) ? verinum::V0 :\n\t\t                                         verinum::V1;\n\t    }\n      }\n\n      while (idx > 0) {\n\t    if (left[idx-1] == verinum::Vx) return verinum::Vx;\n\t    if (left[idx-1] == verinum::Vz) return verinum::Vx;\n\t    if (right[idx-1] == verinum::Vx) return verinum::Vx;\n\t    if (right[idx-1] == verinum::Vz) return verinum::Vx;\n\t    if (left[idx-1] > right[idx-1]) return verinum::V0;\n\t    if (left[idx-1] < right[idx-1]) return verinum::V1;\n\t    idx -= 1;\n      }\n\n      return verinum::V0;\n}\n\nstatic verinum::V add_with_carry(verinum::V l, verinum::V r, verinum::V&c)\n{\n      unsigned sum = 0;\n      switch (c) {\n\t  case verinum::Vx:\n\t  case verinum::Vz:\n\t    c = verinum::Vx;\n\t    return verinum::Vx;\n\t  case verinum::V0:\n\t    break;\n\t  case verinum::V1:\n\t    sum += 1;\n      }\n\n      switch (l) {\n\t  case verinum::Vx:\n\t  case verinum::Vz:\n\t    c = verinum::Vx;\n\t    return verinum::Vx;\n\t  case verinum::V0:\n\t    break;\n\t  case verinum::V1:\n\t    sum += 1;\n\t    break;\n      }\n\n      switch (r) {\n\t  case verinum::Vx:\n\t  case verinum::Vz:\n\t    c = verinum::Vx;\n\t    return verinum::Vx;\n\t  case verinum::V0:\n\t    break;\n\t  case verinum::V1:\n\t    sum += 1;\n\t    break;\n      }\n\n      if (sum & 2)\n\t    c = verinum::V1;\n      else\n\t    c = verinum::V0;\n      if (sum & 1)\n\t    return verinum::V1;\n      else\n\t    return verinum::V0;\n}\n\nverinum operator ~ (const verinum&left)\n{\n      verinum val = left;\n      for (unsigned idx = 0 ;  idx < val.len() ;  idx += 1)\n\t    switch (val[idx]) {\n\t\tcase verinum::V0:\n\t\t  val.set(idx, verinum::V1);\n\t\t  break;\n\t\tcase verinum::V1:\n\t\t  val.set(idx, verinum::V0);\n\t\t  break;\n\t\tdefault:\n\t\t  val.set(idx, verinum::Vx);\n\t\t  break;\n\t    }\n\n      return val;\n}\n\n/*\n * Addition and subtraction works a bit at a time, from the least\n * significant up to the most significant. The result is signed only\n * if both of the operands are signed. If either operand is unsized,\n * the result is expanded as needed to prevent overflow.\n */\n\nverinum operator + (const verinum&left, const verinum&right)\n{\n      const bool has_len_flag = left.has_len() && right.has_len();\n      const bool signed_flag = left.has_sign() && right.has_sign();\n\n      unsigned min_len = min(left.len(), right.len());\n      unsigned max_len = max(left.len(), right.len());\n\n\t// If either the left or right values are undefined, the\n\t// entire result is undefined.\n      if (!left.is_defined() || !right.is_defined()) {\n\t    unsigned len = has_len_flag ? max_len : 1;\n\t    verinum result (verinum::Vx, len, has_len_flag);\n\t    result.has_sign(signed_flag);\n\t    return result;\n      }\n\n      verinum::V*val_bits = new verinum::V[max_len+1];\n\n      verinum::V carry = verinum::V0;\n      for (unsigned idx = 0 ;  idx < min_len ;  idx += 1)\n\t    val_bits[idx] = add_with_carry(left[idx], right[idx], carry);\n\n      verinum::V rpad = sign_bit(right);\n      verinum::V lpad = sign_bit(left);\n\n      if (left.len() > right.len()) {\n\n\t    for (unsigned idx = min_len ;  idx < max_len ;  idx += 1)\n\t\t  val_bits[idx] = add_with_carry(left[idx], rpad, carry);\n\n      } else {\n\n\t    for (unsigned idx = min_len ;  idx < max_len ;  idx += 1)\n\t\t  val_bits[idx] = add_with_carry(lpad, right[idx], carry);\n      }\n\n      unsigned len = max_len;\n      if (!has_len_flag) {\n\t    val_bits[max_len] = add_with_carry(lpad, rpad, carry);\n\t    if (signed_flag) {\n\t\t  if (val_bits[max_len] != val_bits[max_len-1]) len += 1;\n\t    } else {\n\t\t  if (val_bits[max_len] != verinum::V0) len += 1;\n\t    }\n      }\n      verinum result (val_bits, len, has_len_flag);\n      result.has_sign(signed_flag);\n\n      delete[]val_bits;\n\n      return result;\n}\n\nverinum operator - (const verinum&left, const verinum&right)\n{\n      const bool has_len_flag = left.has_len() && right.has_len();\n      const bool signed_flag = left.has_sign() && right.has_sign();\n\n      unsigned min_len = min(left.len(), right.len());\n      unsigned max_len = max(left.len(), right.len());\n\n\t// If either the left or right values are undefined, the\n\t// entire result is undefined.\n      if (!left.is_defined() || !right.is_defined()) {\n\t    unsigned len = has_len_flag ? max_len : 1;\n\t    verinum result (verinum::Vx, len, has_len_flag);\n\t    result.has_sign(signed_flag);\n\t    return result;\n      }\n\n      verinum::V*val_bits = new verinum::V[max_len+1];\n\n      verinum::V carry = verinum::V1;\n      for (unsigned idx = 0 ;  idx < min_len ;  idx += 1)\n\t    val_bits[idx] = add_with_carry(left[idx], ~right[idx], carry);\n\n      verinum::V rpad = sign_bit(right);\n      verinum::V lpad = sign_bit(left);\n\n      if (left.len() > right.len()) {\n\n\t    for (unsigned idx = min_len ;  idx < max_len ;  idx += 1)\n\t\t  val_bits[idx] = add_with_carry(left[idx], ~rpad, carry);\n\n      } else {\n\n\t    for (unsigned idx = min_len ;  idx < max_len ;  idx += 1)\n\t\t  val_bits[idx] = add_with_carry(lpad, ~right[idx], carry);\n      }\n\n      unsigned len = max_len;\n      if (signed_flag && !has_len_flag) {\n\t    val_bits[max_len] = add_with_carry(lpad, ~rpad, carry);\n\t    if (val_bits[max_len] != val_bits[max_len-1]) len += 1;\n      }\n      verinum result (val_bits, len, has_len_flag);\n      result.has_sign(signed_flag);\n\n      delete[]val_bits;\n\n      return result;\n}\n\nverinum operator - (const verinum&right)\n{\n      const bool has_len_flag = right.has_len();\n      const bool signed_flag = right.has_sign();\n\n      unsigned len = right.len();\n\n\t// If either the left or right values are undefined, the\n\t// entire result is undefined.\n      if (!right.is_defined()) {\n\t    verinum result (verinum::Vx, has_len_flag ? len : 1, has_len_flag);\n\t    result.has_sign(signed_flag);\n\t    return result;\n      }\n\n      verinum::V*val_bits = new verinum::V[len+1];\n\n      verinum::V carry = verinum::V1;\n      for (unsigned idx = 0 ;  idx < len ;  idx += 1)\n\t    val_bits[idx] = add_with_carry(verinum::V0, ~right[idx], carry);\n\n      if (signed_flag && !has_len_flag) {\n\t    val_bits[len] = add_with_carry(verinum::V0, ~sign_bit(right), carry);\n\t    if (val_bits[len] != val_bits[len-1]) len += 1;\n      }\n      verinum result (val_bits, len, has_len_flag);\n      result.has_sign(signed_flag);\n\n      delete[]val_bits;\n\n      return result;\n}\n\n/*\n * This operator multiplies the left number by the right number. The\n * result is signed only if both of the operands are signed. If either\n * operand is unsized, the resulting number is as large as the sum of\n * the sizes of the operands.\n *\n * The algorithm used is successive shift and add operations,\n * implemented as the nested loops.\n */\nverinum operator * (const verinum&left, const verinum&right)\n{\n      const bool has_len_flag = left.has_len() && right.has_len();\n      const bool signed_flag = left.has_sign() && right.has_sign();\n\n      const unsigned l_len = left.len();\n      const unsigned r_len = right.len();\n\n      unsigned len = has_len_flag ? max(l_len, r_len) : l_len + r_len;\n\n\t// If either the left or right values are undefined, the\n\t// entire result is undefined.\n      if (!left.is_defined() || !right.is_defined()) {\n\t    verinum result (verinum::Vx, has_len_flag ? len : 1, has_len_flag);\n\t    result.has_sign(signed_flag);\n\t    return result;\n      }\n\n      verinum result(verinum::V0, len, has_len_flag);\n      result.has_sign(signed_flag);\n\n      verinum::V r_sign = sign_bit(right);\n      for (unsigned rdx = 0 ;  rdx < len ;  rdx += 1) {\n\n\t    verinum::V r_bit = rdx < r_len ? right.get(rdx) : r_sign;\n\t    if (r_bit == verinum::V0)\n\t\t  continue;\n\n\t    verinum::V l_sign = sign_bit(left);\n\t    verinum::V carry = verinum::V0;\n\t    for (unsigned ldx = 0 ;  ldx < (len - rdx) ;  ldx += 1) {\n\t\t  verinum::V l_bit = ldx < l_len ? left[ldx] : l_sign;\n\t\t  result.set(ldx+rdx, add_with_carry(l_bit,\n\t\t\t\t\t\t     result[rdx+ldx],\n\t\t\t\t\t\t     carry));\n\t    }\n      }\n\n      return trim_vnum(result);\n}\n\nstatic verinum make_p_one(unsigned len, bool has_len, bool has_sign)\n{\n      verinum tmp (verinum::V0, has_len ? len : 2, has_len);\n      tmp.set(0, verinum::V1);\n      tmp.has_sign(has_sign);\n      return tmp;\n}\n\nstatic verinum make_m_one(unsigned len, bool has_len, bool has_sign)\n{\n      verinum tmp (verinum::V1, has_len ? len : 1, has_len);\n      tmp.has_sign(has_sign);\n      return tmp;\n}\n\nstatic verinum recursive_pow(const verinum&left, verinum&right)\n{\n        // If the exponent is zero, return a value of 1\n      if (right.is_zero()) {\n            return make_p_one(left.len(), left.has_len(), left.has_sign());\n      }\n\n      verinum result;\n      if (right.get(0) == 1) {\n              // The exponent is odd, so subtract 1 from it and recurse.\n\t      // We know it's odd, so the subtraction is easy.\n\t    right.set(0, verinum::V0);\n\t    result = pow(left, right);\n\t    result = left * result;\n      } else {\n              // The exponent is even, so divide it by 2 and recurse\n            right = right >> 1;\n            result = pow(left, right);\n            result = result * result;\n      }\n      return result;\n}\n\nverinum pow(const verinum&left, const verinum&right)\n{\n      verinum result;\n\n\t// We need positive and negative one in a few places.\n      verinum p_one = make_p_one(left.len(), left.has_len(), left.has_sign());\n      verinum m_one = make_m_one(left.len(), left.has_len(), left.has_sign());\n\n\t// If either the left or right values are undefined, the\n\t// entire result is undefined.\n      if (!left.is_defined() || !right.is_defined()) {\n\t    result = verinum(verinum::Vx, left.len(), left.has_len());\n            result.has_sign(left.has_sign());\n\n\t// If the right value is zero we need to set the result to 1.\n      } else if (right.is_zero()) {\n\t    result = p_one;\n\n      } else if (right.is_negative()) {\n\n\t      // 0 ** <negative> is 'bx.\n\t    if (left.is_zero()) {\n\t\t  result = verinum(verinum::Vx, left.len(), left.has_len());\n                  result.has_sign(left.has_sign());\n\n\t      // -1 ** <negative> is 1 or -1. Note that this must be done\n              // before testing for +1 in case 'left' has a width of 1.\n\t    } else if (left.has_sign() && left == m_one) {\n\t\t  if (right.get(0) == verinum::V0) {\n\t\t\tresult = p_one;\n\t\t  } else {\n\t\t\tresult = m_one;\n\t\t  }\n\n\t      // 1 ** <negative> is 1.\n\t    } else if (left == p_one) {\n\t\t  result = p_one;\n\n\t      // Everything else is 0.\n\t    } else {\n\t\t  result = verinum(verinum::V0, left.len(), left.has_len());\n                  result.has_sign(left.has_sign());\n\t    }\n\n      } else {\n            verinum exponent = right;\n            result = recursive_pow(left, exponent);\n      }\n\n      return trim_vnum(result);\n}\n\nverinum operator << (const verinum&that, unsigned shift)\n{\n      bool has_len_flag = that.has_len();\n\n      unsigned len = that.len();\n      if (!has_len_flag) len += shift;\n\n      verinum result(verinum::V0, len, has_len_flag);\n      result.has_sign(that.has_sign());\n\n      for (unsigned idx = shift ;  idx < len ;  idx += 1)\n\t    result.set(idx, that.get(idx - shift));\n\n      return trim_vnum(result);\n}\n\nverinum operator >> (const verinum&that, unsigned shift)\n{\n      bool has_len_flag = that.has_len();\n\n      unsigned len = that.len();\n\n      verinum::V sgn_bit = that.has_sign() ? that.get(len-1) : verinum::V0;\n\n      if (shift >= len) {\n\t    if (!has_len_flag) len = 1;\n\t    verinum result(sgn_bit, len, has_len_flag);\n\t    result.has_sign(that.has_sign());\n\t    return result;\n      }\n\n      if (!has_len_flag) len -= shift;\n      verinum result(sgn_bit, len, has_len_flag);\n      result.has_sign(that.has_sign());\n\n      for (unsigned idx = shift ;  idx < that.len() ;  idx += 1)\n\t    result.set(idx-shift, that.get(idx));\n\n      return trim_vnum(result);\n}\n\nstatic verinum unsigned_divide(verinum num, verinum den, bool signed_result)\n{\n\t// We need the following calculations to be lossless. The\n\t// result will be cast to the required width by the caller.\n      num.has_len(false);\n      den.has_len(false);\n\n      unsigned nwid = num.len();\n      while (nwid > 0 && (num.get(nwid-1) == verinum::V0))\n\t    nwid -= 1;\n\n      unsigned dwid = den.len();\n      while (dwid > 0 && (den.get(dwid-1) == verinum::V0))\n\t    dwid -= 1;\n\n      if (dwid > nwid)\n\t    return verinum(verinum::V0, 1);\n\n      den = den << (nwid-dwid);\n\n      unsigned idx = nwid - dwid + 1;\n      verinum result (verinum::V0, signed_result ? idx + 1 : idx);\n      if (signed_result) {\n\t    result.set(idx, verinum::V0);\n\t    result.has_sign(true);\n      }\n      while (idx > 0) {\n\t    if (den <= num) {\n\t\t  verinum dif = num - den;\n\t\t  num = dif;\n\t\t  result.set(idx-1, verinum::V1);\n\t    }\n\t    den = den >> 1;\n\t    idx -= 1;\n      }\n\n      return result;\n}\n\nstatic verinum unsigned_modulus(verinum num, verinum den)\n{\n\t// We need the following calculations to be lossless. The\n\t// result will be cast to the required width by the caller.\n      num.has_len(false);\n      den.has_len(false);\n\n      unsigned nwid = num.len();\n      while (nwid > 0 && (num.get(nwid-1) == verinum::V0))\n\t    nwid -= 1;\n\n      unsigned dwid = den.len();\n      while (dwid > 0 && (den.get(dwid-1) == verinum::V0))\n\t    dwid -= 1;\n\n      if (dwid > nwid)\n\t    return num;\n\n      den = den << (nwid-dwid);\n\n      unsigned idx = nwid - dwid + 1;\n      while (idx > 0) {\n\t    if (den <= num) {\n\t\t  verinum dif = num - den;\n\t\t  num = dif;\n\t    }\n\t    den = den >> 1;\n\t    idx -= 1;\n      }\n\n      return num;\n}\n\n/*\n * This operator divides the left number by the right number. The result\n * is signed only if both of the operands are signed.\n */\nverinum operator / (const verinum&left, const verinum&right)\n{\n      const bool has_len_flag = left.has_len() && right.has_len();\n      const bool signed_flag = left.has_sign() && right.has_sign();\n\n      unsigned use_len = left.len();\n\n\t// If either the left or right values are undefined, or the\n\t// right value is zero, the entire result is undefined.\n      if (!left.is_defined() || !right.is_defined() || right.is_zero()) {\n\t    verinum result (verinum::Vx, use_len, has_len_flag);\n\t    result.has_sign(signed_flag);\n\t    return result;\n      }\n\n      verinum result(verinum::Vz, use_len, has_len_flag);\n\n\t/* do the operation differently, depending on whether the\n\t   result is signed or not. */\n      if (signed_flag) {\n\n\t    if (use_len <= (8*sizeof(long) - 1)) {\n\t\t  long l = left.as_long();\n\t\t  long r = right.as_long();\n\t\t  bool overflow = (l == LONG_MIN) && (r == -1);\n\t\t  long v = overflow ? LONG_MIN : l / r;\n\t\t  for (unsigned idx = 0 ;  idx < use_len ;  idx += 1) {\n\t\t\tresult.set(idx,  (v & 1)? verinum::V1 : verinum::V0);\n\t\t\tv >>= 1;\n\t\t  }\n\n\t    } else {\n\t\t  verinum use_left, use_right;\n\t\t  bool negative = false;\n\t\t  if (left.is_negative()) {\n\t\t\tuse_left = -left;\n\t\t\tnegative = !negative;\n\t\t  } else {\n\t\t\tuse_left = left;\n\t\t  }\n\t\t  use_left.has_sign(false);\n\t\t  if (right.is_negative()) {\n\t\t\tuse_right = -right;\n\t\t\tnegative = !negative;\n\t\t  } else {\n\t\t\tuse_right = right;\n\t\t  }\n\t\t  use_right.has_sign(false);\n\t\t  result = unsigned_divide(use_left, use_right, true);\n\t\t  if (negative) result = -result;\n\t    }\n\n      } else {\n\n\t    if (use_len <= 8 * sizeof(unsigned long)) {\n\t\t    /* Use native unsigned division to do the work. */\n\n\t\t  unsigned long l = left.as_ulong();\n\t\t  unsigned long r = right.as_ulong();\n\t\t  unsigned long v = l / r;\n\t\t  for (unsigned idx = 0 ;  idx < use_len ;  idx += 1) {\n\t\t\tresult.set(idx,  (v & 1)? verinum::V1 : verinum::V0);\n\t\t\tv >>= 1;\n\t\t  }\n\n\t    } else {\n\t\t  result = unsigned_divide(left, right, false);\n\t    }\n      }\n\n      if (has_len_flag)\n\t    result = cast_to_width(result, use_len);\n\n      result.has_sign(signed_flag);\n      return trim_vnum(result);\n}\n\nverinum operator % (const verinum&left, const verinum&right)\n{\n      const bool has_len_flag = left.has_len() && right.has_len();\n      const bool signed_flag = left.has_sign() && right.has_sign();\n\n      unsigned use_len = left.len();\n\n\t// If either the left or right values are undefined, or the\n\t// right value is zero, the entire result is undefined.\n      if (!left.is_defined() || !right.is_defined() || right.is_zero()) {\n\t    verinum result (verinum::Vx, use_len, has_len_flag);\n\t    result.has_sign(signed_flag);\n\t    return result;\n      }\n\n      verinum result(verinum::Vz, use_len, has_len_flag);\n\n      if (signed_flag) {\n\t    if (use_len <= 8*sizeof(long)) {\n\t\t    /* Use native signed modulus to do the work. */\n\t\t  long l = left.as_long();\n\t\t  long r = right.as_long();\n\t\t  bool overflow = (l == LONG_MIN) && (r == -1);\n\t\t  long v = overflow ? 0 : l % r;\n\t\t  for (unsigned idx = 0 ;  idx < use_len ;  idx += 1) {\n\t\t\tresult.set(idx,  (v & 1)? verinum::V1 : verinum::V0);\n\t\t\tv >>= 1;\n\t\t  }\n\t    } else {\n\t\t  verinum use_left, use_right;\n\t\t  bool negative = false;\n\t\t  if (left.is_negative()) {\n\t\t\tuse_left = -left;\n\t\t\tnegative = true;\n\t\t  } else {\n\t\t\tuse_left = left;\n\t\t  }\n\t\t  use_left.has_sign(false);\n\t\t  if (right.is_negative()) {\n\t\t\tuse_right = -right;\n\t\t  } else {\n\t\t\tuse_right = right;\n\t\t  }\n\t\t  use_right.has_sign(false);\n\t\t  result = unsigned_modulus(use_left, use_right);\n\t\t  if (negative) result = -result;\n\t    }\n      } else {\n\t    if (use_len <= 8*sizeof(unsigned long)) {\n\t\t    /* Use native unsigned modulus to do the work. */\n\t\t  unsigned long l = left.as_ulong();\n\t\t  unsigned long r = right.as_ulong();\n\t\t  unsigned long v = l % r;\n\t\t  for (unsigned idx = 0 ;  idx < use_len ;  idx += 1) {\n\t\t\tresult.set(idx,  (v & 1)? verinum::V1 : verinum::V0);\n\t\t\tv >>= 1;\n\t\t  }\n\t    } else {\n\t\t  result = unsigned_modulus(left, right);\n\t    }\n      }\n\n      if (has_len_flag)\n\t    result = cast_to_width(result, use_len);\n\n      result.has_sign(signed_flag);\n      return trim_vnum(result);\n}\n\nverinum concat(const verinum&left, const verinum&right)\n{\n      if (left.is_string() && right.is_string()) {\n\t    std::string tmp = left.as_string() + right.as_string();\n\t    verinum res (tmp);\n\t    return res;\n      }\n\n      verinum res (verinum::V0, left.len() + right.len());\n      for (unsigned idx = 0 ;  idx < right.len() ;  idx += 1)\n\t    res.set(idx, right.get(idx));\n\n      for (unsigned idx = 0 ;  idx < left.len() ;  idx += 1)\n\t    res.set(idx+right.len(), left.get(idx));\n\n      return res;\n}\n\nverinum::V operator ~ (verinum::V l)\n{\n      switch (l) {\n\t  case verinum::V0:\n\t    return verinum::V1;\n\t  case verinum::V1:\n\t    return verinum::V0;\n\t  default:\n\t    return verinum::Vx;\n      }\n}\n\nverinum::V operator | (verinum::V l, verinum::V r)\n{\n      if (l == verinum::V1)\n\t    return verinum::V1;\n      if (r == verinum::V1)\n\t    return verinum::V1;\n      if (l != verinum::V0)\n\t    return verinum::Vx;\n      if (r != verinum::V0)\n\t    return verinum::Vx;\n      return verinum::V0;\n}\n\nverinum::V operator & (verinum::V l, verinum::V r)\n{\n      if (l == verinum::V0)\n\t    return verinum::V0;\n      if (r == verinum::V0)\n\t    return verinum::V0;\n      if (l != verinum::V1)\n\t    return verinum::Vx;\n      if (r != verinum::V1)\n\t    return verinum::Vx;\n      return verinum::V1;\n}\n\nverinum::V operator ^ (verinum::V l, verinum::V r)\n{\n      if (l == verinum::V0)\n\t    return bit4_z2x(r);\n      if (r == verinum::V0)\n\t    return bit4_z2x(l);\n      if ((l == verinum::V1) && (r == verinum::V1))\n\t    return verinum::V0;\n\n      return verinum::Vx;\n}\n"
        },
        {
          "name": "verinum.h",
          "type": "blob",
          "size": 7.1220703125,
          "content": "#ifndef IVL_verinum_H\n#define IVL_verinum_H\n/*\n * Copyright (c) 1998-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <string>\n\n# include  \"config.h\"\n#ifdef HAVE_IOSFWD\n# include  <iosfwd>\n#else\n# include  <iostream>\n#endif\n\n/*\n * Numbers in Verilog are multibit strings, where each bit has 4\n * possible values: 0, 1, x or z. The verinum number is store in\n * little-endian format. This means that if the long value is 2b'10,\n * get(0) is 0 and get(1) is 1.\n */\nclass verinum {\n\n    public:\n      enum V { V0 = 0, V1, Vx, Vz };\n\n      verinum();\n      explicit verinum(const std::string&str);\n      verinum(const V*v, unsigned nbits, bool has_len =true);\n      explicit verinum(V, unsigned nbits =1, bool has_len =true);\n      verinum(uint64_t val, unsigned bits);\n      verinum(double val, bool);\n      verinum(const verinum&);\n\n\t// Create a signed number, with an unspecified number of bits.\n      explicit verinum(int64_t val);\n\n\t// Copy only the specified number of bits from the\n\t// source. Also mark this number as has_len.\n      verinum(const verinum&, unsigned bits);\n\n      ~verinum();\n      verinum& operator= (const verinum&);\n\n\t// Number of stored bits in this number.\n      unsigned len() const { return nbits_; }\n\n\t// A number \"has a length\" if the length was specified fixed\n\t// in some way.\n      bool has_len(bool flag) { has_len_ = flag; return has_len_; }\n      bool has_len() const { return has_len_; }\n\n      bool has_sign(bool flag) { has_sign_ = flag; return has_sign_; }\n      bool has_sign() const { return has_sign_; }\n\n        // A number \"is single\" if it comes from a SystemVerilog 'N bit vector\n      bool is_single(bool flag) { is_single_ = flag; return is_single_; }\n      bool is_single() const { return is_single_; }\n\n\t// A number is \"defined\" if there are no x or z bits in its value.\n      bool is_defined() const;\n      bool is_zero() const;\n      bool is_negative() const;\n\n\t// A number is \"a string\" if its value came directly from\n\t// an ASCII description instead of a number value.\n      bool is_string() const { return string_flag_; }\n\n\t// Comparison for use in sorting algorithms.\n      bool is_before(const verinum&that) const;\n\n\t// Number of significant bits in this number.\n      unsigned significant_bits() const;\n\n\t// Convert 4-state to 2-state\n      void cast_to_int2();\n\n\t// Individual bits can be accessed with the get and set\n\t// methods.\n      V get(unsigned idx) const;\n      V set(unsigned idx, V val);\n      void set(unsigned idx, const verinum&val);\n\n      V operator[] (unsigned idx) const { return get(idx); }\n\n\t// Return the value as a native unsigned integer. If the value is\n\t// larger than can be represented by the returned type, return\n\t// the maximum value of that type. If the value has any x or z\n\t// bits or has zero width, return the value 0.\n      uint64_t as_ulong64() const;\n      unsigned as_unsigned() const;\n      unsigned long as_ulong() const;\n\n      signed long   as_long() const;\n      double as_double() const;\n      std::string as_string() const;\n    private:\n      void signed_trim();\n\n    private:\n      V* bits_;\n      unsigned nbits_;\n      bool has_len_;\n      bool has_sign_;\n      bool is_single_;\n\n\t// These are some convenience flags that help us do a better\n\t// job of pretty-printing values.\n      bool string_flag_;\n};\n\n/*\n * This returns the sign bit of the verinum value. If the value is\n * unsigned, then return an implicit sign bit of 0. Otherwise, return\n * the high bit.\n */\ninline verinum::V sign_bit(const verinum&val)\n{\n      if (val.has_sign())\n\t    return val.get(val.len()-1);\n      else\n\t    return verinum::V0;\n}\n\n/* Return a verinum that has the same value as the input, but is at\n   least as wide as the requested width. This may involve sign\n   extension, if the value is signed. */\nextern verinum pad_to_width(const verinum&, unsigned width);\n\n/* Return a verinum that has the same value as the input, but is\n   exactly the requested width. This may involve sign extension,\n   if the value is signed. The returned verinum will have fixed\n   width. */\nextern verinum cast_to_width(const verinum&, unsigned width);\n\n/* Return a verinum that is minimal. That is, it has only the length\n   needed to accurately represent the contained value, signed or not. */\nextern verinum trim_vnum(const verinum&);\n\nextern std::ostream& operator<< (std::ostream&, const verinum&);\nextern std::ostream& operator<< (std::ostream&, verinum::V);\n\ninline verinum::V bit4_z2x(verinum::V bit)\n{ return bit<2? bit : verinum::Vx; /* Relies on V0 and V1 being <2 */}\n\nextern verinum::V operator ~ (verinum::V l);\nextern verinum::V operator | (verinum::V l, verinum::V r);\nextern verinum::V operator & (verinum::V l, verinum::V r);\nextern verinum::V operator ^ (verinum::V l, verinum::V r);\n\nextern verinum::V operator == (const verinum&left, const verinum&right);\nextern verinum::V operator <= (const verinum&left, const verinum&right);\nextern verinum::V operator <  (const verinum&left, const verinum&right);\n\ninline verinum::V operator > (const verinum&left, const verinum&right)\n{ return right < left; }\n\ninline verinum::V operator >= (const verinum&left, const verinum&right)\n{ return right <= left; }\n\ninline verinum::V operator != (const verinum&left, const verinum&right)\n{ return (left == right)? verinum::V0 : verinum::V1; }\n\n\n/* These are arithmetic operators. If any operand is unsized, they\n   generally work to produce results that do not overflow. That means\n   the result may expand or contract to hold the bits needed to hold\n   the operation results accurately. It is up to the caller to truncate\n   or pad if a specific width is expected. If all operands are sized,\n   the normal Verilog rules for result size are used. */\nextern verinum operator - (const verinum&right);\nextern verinum operator + (const verinum&left, const verinum&right);\nextern verinum operator - (const verinum&left, const verinum&right);\nextern verinum operator * (const verinum&left, const verinum&right);\nextern verinum operator / (const verinum&left, const verinum&right);\nextern verinum operator % (const verinum&left, const verinum&right);\n\nextern verinum pow(const verinum&left, const verinum&right);\n\nextern verinum operator<< (const verinum&left, unsigned shift);\nextern verinum operator>> (const verinum&left, unsigned shift);\n\nextern verinum concat(const verinum&left, const verinum&right);\n\n/* Bitwise not returns the ones complement. */\nextern verinum operator ~ (const verinum&left);\n\n#endif /* IVL_verinum_H */\n"
        },
        {
          "name": "verireal.cc",
          "type": "blob",
          "size": 3.3232421875,
          "content": "/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n# include \"compiler.h\"\n\n# include  \"verireal.h\"\n# include  \"verinum.h\"\n# include  <cstdlib>\n# include  <cctype>\n# include  <iostream>\n# include  <cmath>\n# include  <cassert>\n# include  <cstring>\n\nusing namespace std;\n\nverireal::verireal()\n{\n      value_ = 0.0;\n}\n\nverireal::verireal(const char*txt)\n{\n      char*tmp = new char[strlen(txt)+1];\n      char*cp = tmp;\n      for (unsigned idx = 0 ;  txt[idx] ;  idx += 1) {\n\t    if (txt[idx] == '_')\n\t\t  continue;\n\n\t    *cp++ = txt[idx];\n      }\n      cp[0] = 0;\n\n      value_ = strtod(tmp, 0);\n      delete[]tmp;\n}\n\nverireal::verireal(long val)\n{\n      value_ = (double)val;\n}\n\nverireal::verireal(double val)\n{\n      value_ = val;\n}\n\nverireal::~verireal()\n{\n}\n\nlong verireal::as_long() const\n{\n      double out = value_;\n      double outf;\n\n      if (out >= 0.0) {\n\t    outf = floor(out);\n\t    if (out >= (outf + 0.5))\n\t\t  outf += 1.0;\n      } else {\n\t    outf = ceil(out);\n\t    if (out <= (outf - 0.5))\n\t\t  outf -= 1.0;\n      }\n      return (long) outf;\n}\n\nint64_t verireal::as_long64(int shift) const\n{\n      double out = value_ * pow(10.0,shift);\n      double outf;\n\n      if (out >= 0.0) {\n\t    outf = floor(out);\n\t    if (out >= (outf + 0.5))\n\t\t  outf += 1.0;\n      } else {\n\t    outf = ceil(out);\n\t    if (out <= (outf - 0.5))\n\t\t  outf -= 1.0;\n      }\n      return (int64_t) outf;\n}\n\ndouble verireal::as_double() const\n{\n      return value_;\n}\n\nverireal operator+ (const verireal&l, const verireal&r)\n{\n      verireal res;\n      res.value_ = l.value_ + r.value_;\n      return res;\n}\n\nverireal operator- (const verireal&l, const verireal&r)\n{\n      verireal res;\n      res.value_ = l.value_ - r.value_;\n      return res;\n}\n\nverireal operator* (const verireal&l, const verireal&r)\n{\n      verireal res;\n      res.value_ = l.value_ * r.value_;\n      return res;\n}\n\nverireal operator/ (const verireal&l, const verireal&r)\n{\n      verireal res;\n      res.value_ = l.value_ / r.value_;\n      return res;\n}\n\nverireal operator% (const verireal&l, const verireal&r)\n{\n      verireal res;\n\t// Modulus of a real value is not supported by the standard,\n\t// but we support it as an extension. Assert that we are in\n\t// the correct state before doing the operation.\n      assert(gn_icarus_misc_flag);\n      res.value_ = fmod(l.value_, r.value_);\n      return res;\n}\n\nverireal operator- (const verireal&l)\n{\n      verireal res;\n      res.value_ = - l.value_;\n      return res;\n}\n\nostream& operator<< (ostream&out, const verireal&v)\n{\n      out << showpoint << v.value_;\n      return out;\n}\n"
        },
        {
          "name": "verireal.h",
          "type": "blob",
          "size": 2.6123046875,
          "content": "#ifndef IVL_verireal_H\n#define IVL_verireal_H\n/*\n * Copyright (c) 1999-2021 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n#ifdef HAVE_IOSFWD\n# include  <iosfwd>\n#else\n# include  <iostream>\n#endif\n\nclass verinum;\n\n/*\n * This class holds a floating point decimal number. The number is\n * stored as an integer mantissa and a power of 10. The mantissa is an\n * integer so that decimal numbers in the source (which are decimal)\n * can be stored exactly.\n */\n\nclass verireal {\n\n      friend std::ostream& operator<< (std::ostream&, const verireal&);\n      friend verireal operator+ (const verireal&, const verireal&);\n      friend verireal operator- (const verireal&, const verireal&);\n      friend verireal operator* (const verireal&, const verireal&);\n      friend verireal operator/ (const verireal&, const verireal&);\n      friend verireal operator% (const verireal&, const verireal&);\n\n\t// Unary minus.\n      friend verireal operator- (const verireal&);\n\n    public:\n      explicit verireal();\n      explicit verireal(const char*text);\n      explicit verireal(long val);\n      explicit verireal(double val);\n      ~verireal();\n\n      // Return the value of the floating point number as an\n      // integer, rounded as needed. The shift is the power of 10 to\n      // multiply the value before calculating the result. So for\n      // example if the value is 2.5 and shift == 1, the result\n      // is 25.\n      long as_long() const;\n      int64_t as_long64(int shift =0) const;\n\n      double as_double() const;\n\n    private:\n      double value_;\n};\n\nextern std::ostream& operator<< (std::ostream&, const verireal&);\nextern verireal operator* (const verireal&, const verireal&);\nextern verireal operator/ (const verireal&, const verireal&);\nextern verireal operator% (const verireal&, const verireal&);\nextern verireal operator- (const verireal&);\n\n#endif /* IVL_verireal_H */\n"
        },
        {
          "name": "veriuser.h",
          "type": "blob",
          "size": 11.44921875,
          "content": "#ifndef VERIUSER_H\n#define VERIUSER_H\n/*\n * Copyright (c) 2002-2019 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n/*\n * This header file contains the definitions and declarations needed\n * by an Icarus Verilog user using tf_ routines.\n *\n * NOTE 1: Icarus Verilog does not directly support tf_ routines. This\n * header file defines a tf_ compatibility later. The functions that\n * are implemented here are actually implemented using VPI routines.\n *\n * NOTE 2: The routines and definitions of the tf_ library were\n * clearly not designed to account for C++, or even ANSI-C. This\n * header file attempts to fix these problems in a source code\n * compatible way. In the end, though, it is not completely\n * possible. Instead, users should not use this or the acc_user.h\n * header files or functions in new applications, and instead use the\n * more modern vpi_user.h and VPI functions.\n *\n * This API is provided by Icarus Verilog only to support legacy software.\n */\n\n\n#ifdef __cplusplus\n# define EXTERN_C_START extern \"C\" {\n# define EXTERN_C_END }\n#else\n# define EXTERN_C_START\n# define EXTERN_C_END\n#endif\n\n#ifndef __GNUC__\n# undef  __attribute__\n# define __attribute__(x)\n#endif\n\nEXTERN_C_START\n\n# include  \"_pli_types.h\"\n\n/*\n * defines for tf_message\n */\n#define ERR_MESSAGE 1\n#define ERR_WARNING 2\n#define ERR_ERROR   3\n#define ERR_INTERNAL 4\n#define ERR_SYSTEM   5\n\n/*\n * These are some defines for backwards compatibility. They should not\n * be used in new code.\n */\n#ifndef TRUE\n# define TRUE 1\n#endif\n#ifndef FALSE\n# define FALSE 0\n#endif\n#ifndef __cplusplus\n# ifndef true\n#  define true 1\n# endif\n# ifndef false\n#  define false 0\n# endif\n# ifndef bool\n#  define bool int\n# endif\n#endif\n\n/*\n * structure for veriusertfs array\n */\ntypedef struct t_tfcell\n{\n      short type;               /* usertask|userfunction|userrealfunction */\n      short data;               /* data passed to user routine */\n      int   (*checktf)(int user_data, int reason);\n      int   (*sizetf)(int user_data, int reason);\n      int   (*calltf)(int user_data, int reason);\n      int   (*misctf)(int user_data, int reason, int paramvc);\n      char  *tfname;            /* name of the system task/function */\n      int   forwref;            /* usually set to 1 */\n      char  *tfveritool;        /* usually ignored */\n      char  *tferrmessage;      /* usually ignored */\n      char  reserved[20];            /* reserved */\n} s_tfcell, *p_tfcell;\n\n/*\n * Normal PLI1.0 modules export a veriusertfs array that contains all\n * the function definitions for use by the simulator. The user code is\n * expected to supply that array. The method of export varies amongst\n * Verilog simulators, but at least one vendor gets a pointer to the\n * veriusertfs array by calling a boot function that takes no\n * arguments and returns a pointer to the table.\n *\n * The Icarus Verilog bootstrap process is a little bit different, and\n * is described in the vpi_user.h header file. However, a fairly\n * simple adaptation to your application fixes it so that it\n * automatically boots with Icarus Verilog.\n *\n * The trick is to write a vlog_startup_routine that calls the\n * veriusertfs_register_table function. A simple example:\n *\n *   static struct s_tfcell my_veriusertfs_table[] = {\n *          [... table entries, null terminated ...]\n *   };\n *\n *   // Cadence compatibility\n *   struct s_tfcell* my_bootstrap(void)\n *   { return my_veriusertfs_table; }\n *\n *   // Icarus Verilog compatibility\n *   static void veriusertfs_register(void)\n *   {\n *       veriusertfs_register_table(my_veriusertfs_table);\n *   }\n *   void (*vlog_startup_routines[])() = { &veriusertfs_register, 0 };\n *\n * The veriusertfs_register function and vlog_startup_routines table\n * are specific to Icarus Verilog, and arrange for automatic loading\n * of the PLI1 application. The vvp program will treat this as any\n * other VPI module.\n *\n * By structuring the bootstrap process in this manner, it is\n * plausible to make source code compatibility with a variety of\n * Verilog simulators.\n *\n * NOTE: The cadpli module of Icarus Verilog also makes it possible to\n * be *binary* compatible with other simulators. Create the\n * my_bootstrap function and leave out the vlog_startup_routines, then\n * use the \"-mcadpli\" module to load it in compatibility mode.\n */\nextern s_tfcell veriusertfs[];\nextern void veriusertfs_register_table(p_tfcell vtable);\n#if defined(__MINGW32__) || defined (__CYGWIN__)\nextern __declspec(dllexport) void (*vlog_startup_routines[])(void);\n#endif\n\n#define usertask 1\n#define userfunction 2\n#define userrealfunction 3\n\n/* callback reasons */\n#define reason_checktf 1\n#define reason_sizetf  2\n#define reason_calltf  3\n#define reason_paramvc 7\n#define reason_synch   8\n#define REASON_SYNCH   reason_synch\n#define reason_finish  9\n#define reason_reactivate 10\n#define REASON_REACTIVATE reason_reactivate\n#define reason_rosynch 11\n#define REASON_ROSYNCH reason_rosynch\n#define reason_endofcompile 16\n\n/* These are values returned by tf_typep */\n#define tf_nullparam    0\n#define TF_NULLPARAM    tf_nullparam\n#define tf_string       1\n#define TF_STRING       tf_string\n#define tf_readonly     10\n#define TF_READONLY     tf_readonly\n#define tf_readwrite    11\n#define TF_READWRITE    tf_readwrite\n#define tf_rwbitselect  12\n#define TF_RWBITSELECT  tf_rwbitselect\n#define tf_rwpartselect 13\n#define TF_RWPARTSELECT tf_rwpartselect\n#define tf_rwmemselect  14\n#define TF_RWMEMSELECT  tf_rwmemselect\n#define tf_readonlyreal 15\n#define TF_READONLYREAL tf_readonlyreal\n#define tf_readwritereal 16\n#define TF_READWRITEREAL tf_readwritereal\n\ntypedef struct t_tfnodeinfo {\n      PLI_INT16 node_type;\n      PLI_INT16 padding;\n      union {\n\t    struct t_vecval *vecval_p;\n\t    struct t_strengthval *strengthval_p;\n\t    PLI_BYTE8 *memoryval_p;\n\t    double *read_value_p;\n      } node_value;\n      char* node_symbol;\n      PLI_INT32 node_ngroups;\n      PLI_INT32 node_vec_size;\n      PLI_INT32 node_sign;\n      PLI_INT32 node_ms_index;\n      PLI_INT32 node_ls_index;\n      PLI_INT32 node_mem_size;\n      PLI_INT32 node_lhs_element;\n      PLI_INT32 node_rhs_element;\n      PLI_INT32*node_handle;\n} s_tfnodeinfo, *p_tfnodeinfo;\n\n/* values used in the node_type of the tfnodeinfo structure. */\n#define tf_null_node    100\n#define TF_NULL_NODE    tf_null_node\n#define tf_reg_node     101\n#define TF_REG_NODE     tf_reg_node\n#define tf_integer_node 102\n#define TF_INTEGER_NODE tf_integer_node\n#define tf_time_node    103\n#define TF_TIME_NODE    tf_time_node\n#define tf_netvector_node 104\n#define TF_NETVECTOR_NODE tf_netvector_node\n#define tf_netscalar_node 105\n#define TF_NETSCALAR_NODE tf_netscalar_node\n#define tf_memory_node    106\n#define TF_MEMORY_NODE    tf_memory_node\n#define tf_real_node      107\n#define TF_REAL_NODE      tf_real_node\n\n/* Structure used by the tf_exprinfo function. */\ntypedef struct t_tfexprinfo {\n      PLI_INT16 expr_type;\n      PLI_INT16 padding;\n      struct t_vecval*expr_value_p;\n      double real_value;\n      char*expr_string;\n      PLI_INT32 expr_ngroups;\n      PLI_INT32 expr_vec_size;\n      PLI_INT32 expr_sign;\n      PLI_INT32 expr_lhs_select;\n      PLI_INT32 expr_rhs_select;\n} s_tfexprinfo, *p_tfexprinfo;\n\n\n/* Extern functions from the library. */\nextern void io_printf (const char *, ...)\n      __attribute__((format (printf,1,2)));\nextern char* mc_scan_plusargs(char*plusarg);\n\nextern int tf_asynchoff(void);\nextern int tf_asynchon(void);\n\nextern int tf_dofinish(void);\n\nextern int tf_dostop(void);\n\nextern void tf_error(const char*, ...)\n      __attribute__((format (printf,1,2)));\n\nextern struct t_tfexprinfo* tf_exprinfo(PLI_INT32 a, struct t_tfexprinfo*ip);\n\nextern char* tf_getcstringp(int nparam);\n\nextern PLI_BYTE8* tf_getinstance(void);\n\nextern int tf_getlongp(int*aof_highvalue, int pnum);\n\nextern PLI_INT32 tf_getp(PLI_INT32);\nextern PLI_INT32 tf_igetp(PLI_INT32, void*);\n\nextern double tf_getrealp(PLI_INT32);\nextern double tf_igetrealp(PLI_INT32, void*);\n\nextern char *tf_strgetp(PLI_INT32, PLI_INT32);\nextern char *tf_istrgetp(PLI_INT32, PLI_INT32, void*);\n\nextern char *tf_strgettime(void);\nextern PLI_INT32 tf_gettime(void);\n\nextern PLI_INT32 tf_getlongtime(PLI_INT32*);\nextern PLI_INT32 tf_igetlongtime(PLI_INT32*, void*);\n\nextern void tf_scale_longdelay(void*,PLI_INT32,PLI_INT32,PLI_INT32*,PLI_INT32*);\nextern void tf_unscale_longdelay(void*,PLI_INT32,PLI_INT32,PLI_INT32*,PLI_INT32*);\nextern void tf_scale_realdelay(void*,double,double*);\nextern void tf_unscale_realdelay(void*,double,double*);\n\nextern PLI_INT32 tf_gettimeprecision(void);\nextern PLI_INT32 tf_igettimeprecision(void*);\n\nextern PLI_INT32 tf_gettimeunit(void);\nextern PLI_INT32 tf_igettimeunit(void*);\n\nextern PLI_BYTE8* tf_getworkarea(void);\n\nextern PLI_INT32 tf_message(PLI_INT32 level, char*facility,\n\t\t\t    char*messno, char*fmt, ...)\n      __attribute__((format (printf,4,5)));\n\nextern void tf_multiply_long(PLI_INT32*aof_low1, PLI_INT32*aof_high1,\n\t\t\t     PLI_INT32 aof_low2, PLI_INT32 aof_high2);\nextern void tf_real_to_long(double real, PLI_INT32*low, PLI_INT32*high);\nextern void tf_long_to_real(PLI_INT32 low, PLI_INT32 high, double *real);\n\nextern PLI_INT32 tf_nump(void);\nextern PLI_INT32 tf_inump(void*);\n\n/* IEEE1364 NOTE: tf_putlongp is listed as returning in in the header\n   file shown in the standard, but as returning void in the detailed\n   description of the function. So I call it void. */\nextern void tf_putlongp(int pnum, int lowvalue, int highvalue);\n\nextern PLI_INT32 tf_putp(PLI_INT32, PLI_INT32);\nextern PLI_INT32 tf_iputp(PLI_INT32, PLI_INT32, void*);\n\nextern PLI_INT32 tf_putrealp(PLI_INT32, double);\nextern PLI_INT32 tf_iputrealp(PLI_INT32, double, void*);\n\n/* Activate the misctf function after a delay. The units are of the\n   current scope. The tf_isetdelay variant specifies a particular\n   system task instance to use as the context for the\n   units. tf_getinstance gets that value. */\nextern int tf_setdelay(PLI_INT32 delay);\nextern int tf_isetdelay(PLI_INT32 delay, void* sys);\n\n/* IEEE1364 NOTE: tf_setworkarea is listed as taking a PLI_BYTE8*, but\n   that is silly, it really takes any kind of pointer. Taking void* is\n   compatible with those who pass a PLI_BYTE8*. */\nextern PLI_INT32 tf_setworkarea(void*workarea);\n\n/* Return the complete, hierarchical name of the current scope. The\n   current scope is the scope containing the currently running system\n   task call. */\nextern char* tf_spname(void);\n\nextern char* tf_mipname(void);\nextern char* tf_imipname(void*);\n\nextern PLI_INT32 tf_synchronize(void);\nextern PLI_INT32 tf_isynchronize(void* sys);\n\nextern PLI_INT32 tf_rosynchronize(void);\nextern PLI_INT32 tf_irosynchronize(void* sys);\n\nextern PLI_INT32 tf_setrealdelay(double realdelay);\nextern PLI_INT32 tf_isetrealdelay(double realdelay, void*inst);\n\nextern PLI_INT32 tf_typep(PLI_INT32 narg);\n\nextern void tf_warning(const char*, ...)\n      __attribute__((format (printf,1,2)));\n\nEXTERN_C_END\n\n#endif /* VERIUSER_H */\n"
        },
        {
          "name": "version.c",
          "type": "blob",
          "size": 1.958984375,
          "content": "/*\n * Copyright (c) 2009-2015 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"version_base.h\"\n# include  \"version_tag.h\"\n# include  <stdio.h>\n# include  <string.h>\n\nstatic void run_string(const char*txt)\n{\n      const char*cp = txt;\n      while (*cp) {\n\t    if (cp[0] == '%' && cp[1] != 0) {\n\t\t  switch (cp[1]) {\n\t\t      case 'M':\n\t\t\tfprintf(stdout, \"%d\", VERSION_MAJOR);\n\t\t\tbreak;\n\t\t      case 'n':\n\t\t\tfprintf(stdout, \"%d\", VERSION_MINOR);\n\t\t\tbreak;\n\t\t      case 'E':\n\t\t\tfprintf(stdout, \"%s\", VERSION_EXTRA);\n\t\t\tbreak;\n\t\t      case 'T':\n\t\t\tfprintf(stdout, \"%s\", VERSION_TAG);\n\t\t\tbreak;\n\t\t      case '%':\n\t\t\tputc('%', stdout);\n\t\t\tbreak;\n\t\t      default:\n\t\t\tbreak;\n\t\t  }\n\t\t  cp += 2;\n\n\t    } else if (cp[0] == '\\\\' && cp[1] != 0) {\n\t\t  switch (cp[1]) {\n\t\t      case 'n':\n\t\t\tputc('\\n', stdout);\n\t\t\tbreak;\n\t\t      default:\n\t\t\tputc(cp[1], stdout);\n\t\t\tbreak;\n\t\t  }\n\t\t  cp += 2;\n\n\t    } else {\n\t\t  putc(cp[0], stdout);\n\t\t  cp += 1;\n\t    }\n      }\n}\n\nint main(int argc, char*argv[])\n{\n      int idx;\n\n      if (argc == 1) {\n\t    printf(\"%s\\n\", VERSION);\n\t    return 0;\n      }\n\n      run_string(argv[1]);\n      for (idx = 2 ; idx < argc ; idx += 1) {\n\t    printf(\" \");\n\t    run_string(argv[idx]);\n      }\n\n      return 0;\n}\n"
        },
        {
          "name": "version_base.h",
          "type": "blob",
          "size": 0.484375,
          "content": "#ifndef VERSION\n/*\n * Edit this definition in version_base.in to define the base version\n * number for the compiled result.\n */\n# define VERSION_MAJOR  13\n# define VERSION_MINOR   0\n\n/*\n * This will be appended to the version. Use this to mark development\n * versions and the like.\n */\n# define VERSION_EXTRA   \" (devel)\"\n\n# define VERSION_STRINGIFY(x) #x\n# define VERSION_STR(a,b,extra) VERSION_STRINGIFY(a.b) extra\n\n#define VERSION VERSION_STR(VERSION_MAJOR,VERSION_MINOR,VERSION_EXTRA)\n#endif\n"
        },
        {
          "name": "vhdlpp",
          "type": "tree",
          "content": null
        },
        {
          "name": "vpi",
          "type": "tree",
          "content": null
        },
        {
          "name": "vpi_modules.cc",
          "type": "blob",
          "size": 9.455078125,
          "content": "/*\n * Copyright (c) 2019-2024 Martin Whitaker (icarus@martin-whitaker.me.uk)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#include \"config.h\"\n#include \"compiler.h\"\n#include \"vpi_user.h\"\n#include \"sv_vpi_user.h\"\n#include \"vvp/ivl_dlfcn.h\"\n\nusing namespace std;\n\n/* The only VPI routines that can be legally called when the functions in\n   the vlog_startup_routines[] array are executed are vpi_register_systf()\n   and vpi_register_cb(), so we can simply provide stubs for the rest. We\n   aren't going to execute any callbacks, so we can just provide a stub for\n   vpi_register_cb() too.\n\n   Note that the Icarus system module illegally calls vpi_get_vlog_info()\n   during startup, so take care to fill in the data structure for that.\n*/\n\n// callback related\n\nvpiHandle   vpi_register_cb(p_cb_data) { return 0; }\nPLI_INT32   vpi_remove_cb(vpiHandle) { return 0; }\n\nvoid        vpi_get_systf_info(vpiHandle, p_vpi_systf_data) { }\n\n// for obtaining handles\n\nvpiHandle   vpi_handle_by_name(const char*, vpiHandle) { return 0; }\nvpiHandle   vpi_handle_by_index(vpiHandle, PLI_INT32) { return 0; }\nvpiHandle   vpi_handle_multi(PLI_INT32, vpiHandle, vpiHandle) { return 0; }\n\n// for traversing relationships\n\nvpiHandle   vpi_handle(PLI_INT32, vpiHandle) { return 0; }\nvpiHandle   vpi_iterate(PLI_INT32, vpiHandle) { return 0; }\nvpiHandle   vpi_scan(vpiHandle) { return 0; }\n\n// for processing properties\n\nPLI_INT32   vpi_get(int, vpiHandle) { return 0; }\nchar*       vpi_get_str(PLI_INT32, vpiHandle) { return 0; }\n\n// delay processing\n\nvoid        vpi_get_delays(vpiHandle, p_vpi_delay) { }\nvoid        vpi_put_delays(vpiHandle, p_vpi_delay) { }\n\n// value processing\n\nvoid        vpi_get_value(vpiHandle, p_vpi_value) { }\nvpiHandle   vpi_put_value(vpiHandle, p_vpi_value, p_vpi_time, PLI_INT32) { return 0; }\n\n// time processing\n\nvoid        vpi_get_time(vpiHandle, s_vpi_time*) { }\n\n// data processing\n\nvoid*       vpi_get_userdata(vpiHandle) { return 0; }\nPLI_INT32   vpi_put_userdata(vpiHandle, void*) { return 0; }\n\n// I/O routines\n\nPLI_UINT32  vpi_mcd_open(char *) { return 0; }\nPLI_UINT32  vpi_mcd_close(PLI_UINT32) { return 0; }\nPLI_INT32   vpi_mcd_flush(PLI_UINT32) { return 0; }\nchar*       vpi_mcd_name(PLI_UINT32) { return 0; }\nPLI_INT32   vpi_mcd_printf(PLI_UINT32, const char*, ...) { return 0; }\nPLI_INT32   vpi_mcd_vprintf(PLI_UINT32, const char*, va_list) { return 0; }\n\nPLI_INT32   vpi_flush(void) { return 0; }\nPLI_INT32   vpi_printf(const char*, ...) { return 0; }\nPLI_INT32   vpi_vprintf(const char*, va_list) { return 0; }\n\n// utility routines\n\nPLI_INT32   vpi_chk_error(p_vpi_error_info) { return 0; }\nPLI_INT32   vpi_compare_objects(vpiHandle, vpiHandle) { return 0; }\nPLI_INT32   vpi_free_object(vpiHandle) { return 0; }\nPLI_INT32   vpi_release_handle(vpiHandle) { return 0; }\nPLI_INT32   vpi_get_vlog_info(p_vpi_vlog_info info)\n{\n    info->argc = 0;\n    info->argv = 0;\n    info->product = 0;\n    info->version = 0;\n    return 0;\n}\n\n// control routines\n\nvoid        vpi_control(PLI_INT32, ...) { }\nvoid        vpi_sim_control(PLI_INT32, ...) { }\n\n// proposed standard extensions\n\nPLI_INT32   vpi_fopen(const char*, const char*) { return 0; }\nFILE*       vpi_get_file(PLI_INT32) { return 0; }\n\n// Icarus extensions\n\ns_vpi_vecval vpip_calc_clog2(vpiHandle)\n{\n    s_vpi_vecval val = { 0, 0 };\n    return val;\n}\nvoid        vpip_count_drivers(vpiHandle, unsigned, unsigned [4]) { }\nvoid        vpip_format_strength(char*, s_vpi_value*, unsigned) { }\nvoid        vpip_make_systf_system_defined(vpiHandle) { }\nvoid        vpip_mcd_rawwrite(PLI_UINT32, const char*, size_t) { }\nvoid        vpip_set_return_value(int) { }\nvoid        vpi_vcontrol(PLI_INT32, va_list) { }\n\n\n/* When a module registers a system function, extract and save the return\n   type for use during elaboration. */\nvpiHandle vpi_register_systf(const struct t_vpi_systf_data*ss)\n{\n    if (ss->type != vpiSysFunc)\n        return 0;\n\n    struct sfunc_return_type ret_type;\n    ret_type.name = ss->tfname;\n    switch (ss->sysfunctype) {\n      case vpiIntFunc:\n        ret_type.type = IVL_VT_LOGIC;\n        ret_type.wid  = 32;\n        ret_type.signed_flag = true;\n        break;\n      case vpiRealFunc:\n        ret_type.type = IVL_VT_REAL;\n        ret_type.wid  = 1;\n        ret_type.signed_flag = true;\n        break;\n      case vpiTimeFunc:\n        ret_type.type = IVL_VT_LOGIC;\n        ret_type.wid  = 64;\n        ret_type.signed_flag = false;\n        break;\n      case vpiSizedFunc:\n        ret_type.type = IVL_VT_LOGIC;\n        ret_type.wid  = ss->sizetf ? ss->sizetf(ss->user_data) : 32;\n        ret_type.signed_flag = false;\n        break;\n      case vpiSizedSignedFunc:\n        ret_type.type = IVL_VT_LOGIC;\n        ret_type.wid  = ss->sizetf ? ss->sizetf(ss->user_data) : 32;\n        ret_type.signed_flag = true;\n        break;\n      case vpiStringFunc:\n        ret_type.type = IVL_VT_STRING;\n        ret_type.wid  = 0;\n        ret_type.signed_flag = false;\n        break;\n      case vpiOtherFunc:\n        ret_type.type = IVL_VT_NO_TYPE;\n        ret_type.wid  = 0;\n        ret_type.signed_flag = false;\n        break;\n      default:\n        cerr << \"warning: \" << ss->tfname << \" has an unknown return type. \"\n                \"Assuming 32 bit unsigned.\" << endl;\n        ret_type.type = IVL_VT_LOGIC;\n        ret_type.wid  = 32;\n        ret_type.signed_flag = false;\n        break;\n    }\n    ret_type.override_flag = false;\n    add_sys_func(ret_type);\n    return 0;\n}\n\n#if defined(__MINGW32__) || defined (__CYGWIN__)\nvpip_routines_s vpi_routines = {\n    .register_cb                = vpi_register_cb,\n    .remove_cb                  = vpi_remove_cb,\n    .register_systf             = vpi_register_systf,\n    .get_systf_info             = vpi_get_systf_info,\n    .handle_by_name             = vpi_handle_by_name,\n    .handle_by_index            = vpi_handle_by_index,\n    .handle_multi               = vpi_handle_multi,\n    .handle                     = vpi_handle,\n    .iterate                    = vpi_iterate,\n    .scan                       = vpi_scan,\n    .get                        = vpi_get,\n    .get_str                    = vpi_get_str,\n    .get_delays                 = vpi_get_delays,\n    .put_delays                 = vpi_put_delays,\n    .get_value                  = vpi_get_value,\n    .put_value                  = vpi_put_value,\n    .get_time                   = vpi_get_time,\n    .get_userdata               = vpi_get_userdata,\n    .put_userdata               = vpi_put_userdata,\n    .mcd_open                   = vpi_mcd_open,\n    .mcd_close                  = vpi_mcd_close,\n    .mcd_flush                  = vpi_mcd_flush,\n    .mcd_name                   = vpi_mcd_name,\n    .mcd_vprintf                = vpi_mcd_vprintf,\n    .flush                      = vpi_flush,\n    .vprintf                    = vpi_vprintf,\n    .chk_error                  = vpi_chk_error,\n    .compare_objects            = vpi_compare_objects,\n    .free_object                = vpi_free_object,\n    .release_handle             = vpi_release_handle,\n    .get_vlog_info              = vpi_get_vlog_info,\n    .vcontrol                   = vpi_vcontrol,\n    .fopen                      = vpi_fopen,\n    .get_file                   = vpi_get_file,\n    .calc_clog2                 = vpip_calc_clog2,\n    .count_drivers              = vpip_count_drivers,\n    .format_strength            = vpip_format_strength,\n    .make_systf_system_defined  = vpip_make_systf_system_defined,\n    .mcd_rawwrite               = vpip_mcd_rawwrite,\n    .set_return_value           = vpip_set_return_value,\n};\n\ntypedef PLI_UINT32 (*vpip_set_callback_t)(vpip_routines_s*, PLI_UINT32);\n#endif\ntypedef void (*vlog_startup_routines_t)(void);\n\nbool load_vpi_module(const char*path)\n{\n    ivl_dll_t dll = ivl_dlopen(path, false);\n    if (dll == 0) {\n\tcerr << \"error: Failed to open '\" << path << \"' because:\" << endl;\n        cerr << \"     : \" << dlerror() << endl;\n\treturn false;\n    }\n\n#if defined(__MINGW32__) || defined (__CYGWIN__)\n    void*function = ivl_dlsym(dll, \"vpip_set_callback\");\n    if (function == 0) {\n        cerr << \"warning: '\" << path << \"' has no vpip_set_callback()\" << endl;\n        ivl_dlclose(dll);\n        return true;\n    }\n    vpip_set_callback_t set_callback = (vpip_set_callback_t)function;\n    if (!set_callback(&vpi_routines, vpip_routines_version)) {\n        cerr << \"error: Failed to link '\" << path << \"'. \"\n                \"Try rebuilding it with iverilog-vpi.\" << endl;\n        ivl_dlclose(dll);\n        return true;\n    }\n#endif\n\n    void*table = ivl_dlsym(dll, LU \"vlog_startup_routines\" TU);\n    if (table == 0) {\n        cerr << \"warning: '\" << path << \"' has no vlog_startup_routines\" << endl;\n        ivl_dlclose(dll);\n        return true;\n    }\n\n    vlog_startup_routines_t*routines = (vlog_startup_routines_t*)table;\n    for (unsigned idx = 0; routines[idx]; idx += 1) {\n        (routines[idx])();\n    }\n\n    ivl_dlclose(dll);\n    return true;\n}\n"
        },
        {
          "name": "vpi_user.h",
          "type": "blob",
          "size": 24.619140625,
          "content": "#ifndef VPI_USER_H\n#define VPI_USER_H\n/*\n * Copyright (c) 1999-2020 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n\n#if defined(__MINGW32__) || defined (__CYGWIN__)\n#  define DLLEXPORT __declspec(dllexport)\n#else\n#  define DLLEXPORT\n#endif\n\n#ifdef __cplusplus\n# define EXTERN_C_START extern \"C\" {\n# define EXTERN_C_END }\n#else\n# define EXTERN_C_START\n# define EXTERN_C_END\n#endif\n\n#ifndef __GNUC__\n# undef  __attribute__\n# define __attribute__(x)\n#endif\n\nEXTERN_C_START\n\n# include  <stdarg.h>\n# include  <stdio.h>\n# include  <stdarg.h>\n# include  \"_pli_types.h\"\n\n#ifndef ICARUS_VPI_CONST\n#define ICARUS_VPI_CONST\n#endif\n#ifdef __cplusplus\ntypedef class __vpiHandle *vpiHandle;\n#else\ntypedef struct __vpiHandle *vpiHandle;\n#endif\n\n/*\n * This structure is created by the VPI application to provide hooks\n * into the application that the compiler/simulator can access.\n */\ntypedef struct t_vpi_systf_data {\n      PLI_INT32 type;\n      PLI_INT32 sysfunctype;\n      const char *tfname;\n      PLI_INT32 (*calltf)   (ICARUS_VPI_CONST PLI_BYTE8*);\n      PLI_INT32 (*compiletf)(ICARUS_VPI_CONST PLI_BYTE8*);\n      PLI_INT32 (*sizetf)   (ICARUS_VPI_CONST PLI_BYTE8*);\n      ICARUS_VPI_CONST PLI_BYTE8 *user_data;\n} s_vpi_systf_data, *p_vpi_systf_data;\n\n/* The type in the above structure can have one of the following\n   values: */\n#define vpiSysTask  1\n#define vpiSysFunc  2\n\ntypedef struct t_vpi_vlog_info\n{\n      PLI_INT32 argc;\n      char      **argv;\n      char      *product;\n      char      *version;\n} s_vpi_vlog_info, *p_vpi_vlog_info;\n\n\ntypedef struct t_vpi_time {\n\n      /*\n\tType can be :\n\n\tvpiScaledRealTime == 1\n\tvpiSimTime        == 2\n\tvpiSuppressTime   == 3\n      */\n\n      PLI_INT32 type;\n      PLI_UINT32 high;\n      PLI_UINT32 low;\n      double real;\n} s_vpi_time, *p_vpi_time;\n\n#define vpiScaledRealTime 1\n#define vpiSimTime        2\n#define vpiSuppressTime   3\n\ntypedef struct t_vpi_vecval {\n      PLI_INT32 aval, bval; /* ab encoding: 00=0, 10=1, 11=X, 01=Z */\n} s_vpi_vecval, *p_vpi_vecval;\n\ntypedef struct t_vpi_strengthval {\n      PLI_INT32 logic;\n      PLI_INT32 s0, s1;\n} s_vpi_strengthval, *p_vpi_strengthval;\n\n/*\n * This structure holds values that are passed back and forth between\n * the simulator and the application.\n */\ntypedef struct t_vpi_value {\n      PLI_INT32 format;\n      union {\n\t    char      *str;\n\t    PLI_INT32 scalar;\n\t    PLI_INT32 integer;\n\t    double real;\n\t    struct t_vpi_time *time;\n\t    struct t_vpi_vecval *vector;\n\t    struct t_vpi_strengthval *strength;\n\t    char      *misc;\n      } value;\n} s_vpi_value, *p_vpi_value;\n\n\n/*\n\n  Conform the IEEE 1364, We add the\n  Standard vpi_delay structure to\n  enable the modpath delay values\n\n\n  Conform IEEE 1364, Pg 670 :\n\n  The \"da\" field of the s_vpi_delay\n  structure shall be a user allocated\n  array of \"s_vpi_time\" structure\n\n  The array shall store delay values returned\n  by vpi_get_delay(). The number of elements in\n  the array shall be determined by\n\n  (1) The number of delays to be retrieved\n      ( normally this is used in vpi_get_delays (..) )\n  {\n    (1.1) Set by \"no_of_delays\" field\n\n    (1.2) For the primitive_object, the no_of_delays\n        shall be 2 or 3\n\n    (1.3) For path_delay object the no_of_delays shall\n        be 1,2,3,6, 12\n\n    (1.4) For timing_check_object, the no_of_delays shall\n        be match the number of limits existing in the\n\tTime Check\n\n    (1.5) For intermodule_path object, the no_of_delays shall\n        be 2 or 3\n  }\n\n\n\n\n  (2) The \"mtm_flag\" && \"pulsere_flag\"\n\n\n  Normally, if you set mtm = X, pulsere = Y\n  then, you will need allocate (num * no_of_delay)\n  s_vpi_time elements for 'da' array before calling\n  the vpi_get/put_delays (..)\n\n  ---------------------------------------------------------------------------\n  |                |                         |                              |\n  | mtm_flag       | No of s_vpi_time array  |   order in which delay       |\n  | pulsere_flag   | element required by the |   elements shall be filed    |\n  |                | s_vpi_delay->da         |                              |\n  |                |                         |                              |\n  |----------------|-------------------------|------------------------------|\n  |                |                         | 1o delay  da[0]--> 1o delay  |\n  | mtm = false    | no_of_delay             | 2o delay  da[1]--> 2o delay  |\n  | pulere = false |                         |                              |\n  |                |                         |                              |\n  |----------------|-------------------------|------------------------------|\n  |                |                         | 1o delay  da[0]--> min delay |\n  | mtm = true     |                         |           da[1]--> typ delay |\n  | pulere = false | 3*no_of_delay           |           da[2]--> max delay |\n  |                |                         | 2o delay  da[3]--> min delay |\n  |                |                         |           da[4]--> typ delay |\n  |                |                         |           ....               |\n  |----------------|-------------------------|------------------------------|\n  |                |                         | 1o delay  da[0]--> delay     |\n  | mtm = false    |                         |           da[1]--> rej limit |\n  | pulere = true  | 3*no_of_delay           |           da[2]--> err limit |\n  |                |                         | 2o delay  da[3]--> delay     |\n  |                |                         |           da[4]--> rej limit |\n  |                |                         |           ....               |\n  |----------------|-------------------------|------------------------------|\n  |                |                         | 1o delay da[0]--> min delay  |\n  | mtm = true     |                         |          da[1]--> typ delay  |\n  | pulere = true  | 9*no_of_delay           |          da[2]--> max delay  |\n  |                |                         |          da[3]--> min delay  |\n  |                |                         |          da[4]--> typ delay  |\n  |                |                         |          da[5]--> max delay  |\n  |                |                         |          da[6]--> min delay  |\n  |                |                         |          da[7]--> typ delay  |\n  |                |                         |          da[8]--> max delay  |\n  |                |                         | 2o delay da[9]--> min delay  |\n  |                |                         |          ....                |\n   -------------------------------------------------------------------------\n\n   IMPORTANT :\n\n   The delay Structure has to be allocated before passing a pointer to\n   \"vpi_get_delays ( )\".\n\n*/\n\n\ntypedef struct t_vpi_delay  {\n      struct t_vpi_time  *da; /* Array of delay data */\n      PLI_INT32  no_of_delays ;\n      PLI_INT32  time_type; /* vpiScaledRealTime, vpiSimTime */\n      PLI_INT32  mtm_flag;\n      PLI_INT32  append_flag;\n      PLI_INT32  pulsere_flag;\n} s_vpi_delay, *p_vpi_delay;\n\n\n\n\n\n/* These are valid codes for the format of the t_vpi_value structure. */\n#define vpiBinStrVal    1\n#define vpiOctStrVal    2\n#define vpiDecStrVal    3\n#define vpiHexStrVal    4\n#define vpiScalarVal    5\n#define vpiIntVal       6\n#define vpiRealVal      7\n#define vpiStringVal    8\n#define vpiVectorVal    9\n#define vpiStrengthVal 10\n#define vpiTimeVal     11\n#define vpiObjTypeVal  12\n#define vpiSuppressVal 13\n\n\n/* SCALAR VALUES */\n#define vpi0 0\n#define vpi1 1\n#define vpiZ 2\n#define vpiX 3\n#define vpiH 4\n#define vpiL 5\n#define vpiDontCare 6\n\n/* STRENGTH VALUES */\n#define vpiSupplyDrive  0x80\n#define vpiStrongDrive  0x40\n#define vpiPullDrive    0x20\n#define vpiLargeCharge  0x10\n#define vpiWeakDrive    0x08\n#define vpiMediumCharge 0x04\n#define vpiSmallCharge  0x02\n#define vpiHiZ          0x01\n\n/* OBJECT CODES */\n#define vpiConstant     7\n#define vpiFunction    20\n#define vpiIntegerVar  25\n#define vpiInterModPath 26\n#define vpiIterator    27\n#define vpiMemory      29\n#define vpiMemoryWord  30\n#define vpiModPath     31\n#define vpiModule      32\n#define vpiNamedBegin  33\n#define vpiNamedEvent  34\n#define vpiNamedFork   35\n#define vpiNet         36\n#define vpiNetBit      37\n#define vpiParameter   41\n#define vpiPartSelect  42\n#define vpiPathTerm    43\n#define vpiPort        44\n#define vpiPortBit     45\n#define vpiRealVar     47\n#define vpiReg         48\n#define vpiRegBit      49\n#define vpiSysFuncCall 56\n#define vpiSysTaskCall 57\n#define vpiTask        59\n#define vpiTimeVar     63\n#define vpiUdpDefn     66\n#define vpiUserSystf   67\n#define vpiNetArray   114\n#define vpiIndex       78\n#define vpiLeftRange   79\n#define vpiParent      81\n#define vpiRightRange  83\n#define vpiScope       84\n#define vpiSysTfCall   85\n#define vpiArgument    89\n#define vpiBit         90\n#define vpiInternalScope 92\n#define vpiModPathIn     95\n#define vpiModPathOut    96\n#define vpiVariables   100\n#define vpiExpr        102\n\n/********************** object types added with 1364-2001 *********************/\n\n#define vpiCallback   107\n#define vpiRegArray   116\n\n/********************** object types added with 1364-2005 *********************/\n\n#define vpiGenScope   134\n\n/* PROPERTIES */\n#define vpiUndefined   (-1)\n#define vpiType           1\n#define vpiName           2\n#define vpiFullName       3\n#define vpiSize           4\n#define vpiFile           5\n#define vpiLineNo         6\n#define vpiTopModule      7\n#define vpiCellInstance   8\n#define vpiDefName        9\n#define vpiTimeUnit      11\n#define vpiTimePrecision 12\n#define vpiDefFile       15\n#define vpiDefLineNo     16\n#define vpiScalar        17\n#define vpiVector        18\n\n#define vpiDirection 20 /* direction of port: */\n#   define vpiInput 1\n#   define vpiOutput 2\n#   define vpiInout 3\n#   define vpiMixedIO 4 /* Not currently output */\n#   define vpiNoDirection 5\n\n#define vpiNetType       22\n#   define vpiWire         1\n#   define vpiWand         2\n#   define vpiWor          3\n#   define vpiTri          4\n#   define vpiTri0         5\n#   define vpiTri1         6\n#   define vpiTriReg       7\n#   define vpiTriAnd       8\n#   define vpiTriOr        9\n#   define vpiSupply1     10\n#   define vpiSupply0     11\n#define vpiArray         28\n#define vpiPortIndex     29\n#define vpiEdge          36\n#   define vpiNoEdge       0x00 /* No edge */\n#   define vpiEdge01       0x01 /* 0 --> 1 */\n#   define vpiEdge10       0x02 /* 1 --> 0 */\n#   define vpiEdge0x       0x04 /* 0 --> x */\n#   define vpiEdgex1       0x08 /* x --> 1 */\n#   define vpiEdge1x       0x10 /* 1 --> x */\n#   define vpiEdgex0       0x20 /* x --> 0 */\n#   define vpiPosedge      (vpiEdgex1|vpiEdge01|vpiEdge0x)\n#   define vpiNegedge      (vpiEdgex0|vpiEdge10|vpiEdge1x)\n#   define vpiAnyEdge      (vpiPosedge|vpiNegedge)\n#define vpiConstType 40\n#   define vpiDecConst    1\n#   define vpiRealConst   2\n#   define vpiBinaryConst 3\n#   define vpiOctConst    4\n#   define vpiHexConst    5\n#   define vpiStringConst 6\n#define vpiFuncType  44\n#   define vpiIntFunc     1\n#   define vpiRealFunc    2\n#   define vpiTimeFunc    3\n#   define vpiSizedFunc   4\n#   define vpiSizedSignedFunc 5\n#define vpiSysFuncType     vpiFuncType\n#   define vpiSysFuncInt   vpiIntFunc\n#   define vpiSysFuncReal  vpiRealFunc\n#   define vpiSysFuncTime  vpiTimeFunc\n#   define vpiSysFuncSized vpiSizedFunc\n#define vpiUserDefn       45\n#define vpiAutomatic      50\n#define vpiConstantSelect 53\n#define vpiSigned         65\n#define vpiLocalParam     70\n/* IVL private properties, also see vvp/vpi_priv.h for other properties */\n#define _vpiNexusId        0x1000000\n/* used in vvp/vpi_priv.h  0x1000001 */\n#define _vpiDelaySelection 0x1000002\n#  define _vpiDelaySelMinimum 1\n#  define _vpiDelaySelTypical 2\n#  define _vpiDelaySelMaximum 3\n/* used in vvp/vpi_priv.h  0x1000003 */\n/* used in vvp/vpi_priv.h  0x1000004 */\n\n/* DELAY MODES */\n#define vpiNoDelay            1\n#define vpiInertialDelay      2\n#define vpiTransportDelay     3\n#define vpiPureTransportDelay 4\n\n#define vpiForceFlag   5\n#define vpiReleaseFlag 6\n#define vpiReturnEvent 0x1000\n\n/* VPI FUNCTIONS */\nextern vpiHandle vpi_register_systf(const struct t_vpi_systf_data*ss);\nextern void vpi_get_systf_info(vpiHandle obj, p_vpi_systf_data data);\n\n/* I/O routines */\nextern PLI_UINT32 vpi_mcd_open(char *name);\nextern PLI_UINT32 vpi_mcd_close(PLI_UINT32 mcd);\nextern char      *vpi_mcd_name(PLI_UINT32 mcd);\nextern PLI_INT32  vpi_mcd_printf(PLI_UINT32 mcd, const char*fmt, ...)\n#ifdef __MINGW32__\n      __attribute__((format (gnu_printf,2,3)));\n#else\n      __attribute__((format (printf,2,3)));\n#endif\nextern PLI_INT32  vpi_printf(const char*fmt, ...)\n#ifdef __MINGW32__\n      __attribute__((format (gnu_printf,1,2)));\n#else\n      __attribute__((format (printf,1,2)));\n#endif\n\nextern PLI_INT32  vpi_vprintf(const char*fmt, va_list ap);\nextern PLI_INT32  vpi_mcd_vprintf(PLI_UINT32 mcd, const char*fmt, va_list ap);\n\nextern PLI_INT32  vpi_flush(void);\nextern PLI_INT32  vpi_mcd_flush(PLI_UINT32 mcd);\n\n/* proposed extensions */\n/*\n * These functions are proposed extensions to Verilog, and\n * are described by the Verilog PLI task force as issue#347.\n *\n * The vpi_fopen() function is exactly the same as the $fopen system\n * function. That is, it takes a path string and a mode string, and\n * opens the file. The result is a 32bit value with bit 31 set, the\n * remaining bits made up a small integer to represent the file.\n *\n * The vpi_get_file(fd) function takes as input a descriptor as\n * returned by vpi_fopen or $fopen. Bit 31 must be set. The result\n * is the C FILE* that represents the file.\n */\nextern PLI_INT32 vpi_fopen(const char*name, const char*mode);\nextern FILE *vpi_get_file(PLI_INT32 fd);\n\n/*\n * support for VPI callback functions.\n */\ntypedef struct t_cb_data {\n      PLI_INT32 reason;\n      PLI_INT32 (*cb_rtn)(struct t_cb_data*cb);\n      vpiHandle obj;\n      p_vpi_time time;\n      p_vpi_value value;\n      PLI_INT32 index;\n      ICARUS_VPI_CONST PLI_BYTE8 *user_data;\n} s_cb_data, *p_cb_data;\n\n#define cbValueChange        1\n#define cbStmt               2\n#define cbForce              3\n#define cbRelease            4\n#define cbAtStartOfSimTime   5\n#define cbReadWriteSynch     6\n#define cbReadOnlySynch      7\n#define cbNextSimTime        8\n#define cbAfterDelay         9\n#define cbEndOfCompile      10\n#define cbStartOfSimulation 11\n#define cbEndOfSimulation   12\n#define cbError             13\n#define cbTchkViolation     14\n#define cbStartOfSave       15\n#define cbEndOfSave         16\n#define cbStartOfRestart    17\n#define cbEndOfRestart      18\n#define cbStartOfReset      19\n#define cbEndOfReset        20\n#define cbEnterInteractive  21\n#define cbExitInteractive   22\n#define cbInteractiveScopeChange 23\n#define cbUnresolvedSystf   24\n#define cbAtEndOfSimTime    31\n\nextern vpiHandle vpi_register_cb(p_cb_data data);\nextern PLI_INT32 vpi_remove_cb(vpiHandle ref);\n\n/*\n * This function allows a vpi application to control the simulation\n * engine. The operation parameter specifies the function to\n * perform. The remaining parameters (if any) are interpreted by the\n * operation. The vpi_sim_control definition (now named vpi_control)\n * was added to P1364-2000 14 July 1999. See PLI Task Force ID: PTF-161\n *\n * vpiFinish - perform the $finish operation, as soon as the user\n *             function returns. This operation takes a single\n *             parameter, a diagnostic exit code.\n *\n * vpiStop -\n * vpiReset -\n * vpiSetInteractiveScope -\n */\nextern void vpi_control(PLI_INT32 operation, ...);\n/************* vpi_control() constants (added with 1364-2000) *************/\n#define vpiStop                66  /* execute simulator's $stop */\n#define vpiFinish              67  /* execute simulator's $finish */\n#define vpiReset               68  /* execute simulator's $reset */\n#define vpiSetInteractiveScope 69  /* set simulator's interactive scope */\n#define __ivl_legacy_vpiStop 1\n#define __ivl_legacy_vpiFinish 2\n\n/* vpi_sim_control is the incorrect name for vpi_control. */\nextern void vpi_sim_control(PLI_INT32 operation, ...);\n\nextern vpiHandle  vpi_handle(PLI_INT32 type, vpiHandle ref);\nextern vpiHandle  vpi_iterate(PLI_INT32 type, vpiHandle ref);\nextern vpiHandle  vpi_scan(vpiHandle iter);\nextern vpiHandle  vpi_handle_by_index(vpiHandle ref, PLI_INT32 idx);\nextern vpiHandle  vpi_handle_by_name(const char*name, vpiHandle scope);\nextern vpiHandle  vpi_handle_multi(PLI_INT32 type, vpiHandle ref1, vpiHandle ref2);\n\nextern void  vpi_get_time(vpiHandle obj, s_vpi_time*t);\nextern PLI_INT32 vpi_get(int property, vpiHandle ref);\nextern char      *vpi_get_str(PLI_INT32 property, vpiHandle ref);\nextern void  vpi_get_value(vpiHandle expr, p_vpi_value value);\n\n/*\n * This function puts a value into the object referenced by the\n * handle. This assumes that the value supports having its value\n * written to. The time parameter specifies when the assignment is to\n * take place. This allows you to schedule an assignment to happen in\n * the future.\n *\n * The flags value specifies the delay model to use in assigning the\n * value. This specifies how the time value is to be used.\n *\n *  vpiNoDelay -- Set the value immediately. The p_vpi_time parameter\n *      may be NULL, in this case. This is like a blocking assignment\n *      in behavioral code.\n *\n *  vpiInertialDelay -- Set the value using the transport delay. The\n *      p_vpi_time parameter is required and specifies when the\n *      assignment is to take place. This is like a non-blocking\n *      assignment in behavioral code.\n */\nextern vpiHandle vpi_put_value(vpiHandle obj, p_vpi_value value,\n\t\t\t       p_vpi_time when, PLI_INT32 flags);\n\nextern PLI_INT32 vpi_free_object(vpiHandle ref);\nextern PLI_INT32 vpi_release_handle(vpiHandle ref);\nextern PLI_INT32 vpi_get_vlog_info(p_vpi_vlog_info vlog_info_p);\n\n/*\n  These Routines will enable the modpath vpiHandle\n  to read/write delay values\n*/\nextern void vpi_get_delays(vpiHandle expr, p_vpi_delay delays);\n\nextern void vpi_put_delays(vpiHandle expr, p_vpi_delay delays);\n\n\n/*\n * Check to see if two handles point to the same object.\n */\nextern PLI_INT32 vpi_compare_objects(vpiHandle obj1, vpiHandle obj2);\n\n\n/*\n * These functions support attaching user data to an instance of a\n * system task or function. These functions only apply to\n * vpiSysTaskCall or vpiSysFuncCall handles.\n */\nextern PLI_INT32 vpi_put_userdata(vpiHandle obj, void*data);\nextern void*vpi_get_userdata(vpiHandle obj);\n\n/*\n * Support for handling errors.\n */\ntypedef struct t_vpi_error_info {\n      PLI_INT32 state;\n      PLI_INT32 level;\n      char      *message;\n      char      *product;\n      char      *code;\n      char      *file;\n      PLI_INT32 line;\n} s_vpi_error_info, *p_vpi_error_info;\n\n/* error_info states */\n# define  vpiCompile  1\n# define  vpiPLI      2\n# define  vpiRun      3\n\n/* error_info levels */\n# define  vpiNotice    1\n# define  vpiWarning   2\n# define  vpiError     3\n# define  vpiSystem    4\n# define  vpiInternal  5\n\nextern PLI_INT32 vpi_chk_error(p_vpi_error_info info);\n\n\n/* This is the table of startup routines included in each module. */\nextern DLLEXPORT void (*vlog_startup_routines[])(void);\n\n\n/*\n * ICARUS VERILOG EXTENSIONS\n *\n * The vpip_* functions are Icarus Verilog extensions. They are not\n * standard VPI functions, so use these at your own risk.\n *\n * The vpip_format_* functions format values in string format in the\n * manner of the $display system task.\n */\n\n  /* Format a scalar a la %v. The str points to a 4byte character\n     buffer. The value must be a vpiStrengthVal. */\nextern void vpip_format_strength(char*str, s_vpi_value*value, unsigned bit);\n  /* Set the return value to return from the vvp run time. This is\n     usually 0 or 1. This is the exit code that the vvp process\n     returns, and in distinct from the finish_number that is an\n     argument to $fatal and other severity tasks. The $fatal and\n     $finish system tasks bundled with iverilog use this function to\n     tell vvp to exit SUCCESS or FAILURE. */\nextern void vpip_set_return_value(int value);\n\nextern s_vpi_vecval vpip_calc_clog2(vpiHandle arg);\nextern void vpip_make_systf_system_defined(vpiHandle ref);\n\n  /* Perform fwrite to mcd files. This is used to write raw data,\n     which may include nulls. */\nextern void vpip_mcd_rawwrite(PLI_UINT32 mcd, const char*buf, size_t count);\n\n  /* Return driver information for a net bit. The information is returned\n     in the 'counts' array as follows:\n       counts[0] - number of drivers driving '0' onto the net\n       counts[1] - number of drivers driving '1' onto the net\n       counts[2] - number of drivers driving 'X' onto the net\n       counts[3] - set to 1 if the net is forced, 0 otherwise\n     The 'ref' argument should reference a net. The 'idx' argument selects\n     which bit of the net is examined. */\nextern void vpip_count_drivers(vpiHandle ref, unsigned idx,\n                               unsigned counts[4]);\n\n/*\n * Stopgap fix for br916. We need to reject any attempt to pass a thread\n * variable to $strobe or $monitor. To do this, we use some private VPI\n * properties that are normally only used by the VVP thread cleanup code.\n * Normally the following definitions are provided by vvp/vpi_priv.h, but\n * for the stopgap fix we need to make them more widely available.\n */\n#define BR916_STOPGAP_FIX\n#ifdef BR916_STOPGAP_FIX\n#define _vpiFromThr 0x1000001\n#   define _vpiNoThr   0\n#   define _vpiString  1\n#   define _vpiVThr    2\n#   define _vpiWord    3\n#   define _vpi_at_PV  4\n#   define _vpi_at_A   5\n#   define _vpi_at_APV 6\n#endif\n\n#if defined(__MINGW32__) || defined (__CYGWIN__)\n/*\n * In Linux, when loaded, a shared library can automatically bind to functions\n * provided by its client. In Windows, a DLL can only do this statically at\n * link time, and is then tied to a specific client. So to enable VPI modules\n * to be used by both the compiler and the simulator, we construct a jump table\n * for the VPI routines that we can pass down to the VPI modules.\n */\n\n// Increment the version number any time vpip_routines_s is changed.\nstatic const PLI_UINT32 vpip_routines_version = 1;\n\ntypedef struct {\n    vpiHandle   (*register_cb)(p_cb_data);\n    PLI_INT32   (*remove_cb)(vpiHandle);\n    vpiHandle   (*register_systf)(const struct t_vpi_systf_data*ss);\n    void        (*get_systf_info)(vpiHandle, p_vpi_systf_data);\n    vpiHandle   (*handle_by_name)(const char*, vpiHandle);\n    vpiHandle   (*handle_by_index)(vpiHandle, PLI_INT32);\n    vpiHandle   (*handle_multi)(PLI_INT32, vpiHandle, vpiHandle);\n    vpiHandle   (*handle)(PLI_INT32, vpiHandle);\n    vpiHandle   (*iterate)(PLI_INT32, vpiHandle);\n    vpiHandle   (*scan)(vpiHandle);\n    PLI_INT32   (*get)(int, vpiHandle);\n    char*       (*get_str)(PLI_INT32, vpiHandle);\n    void        (*get_delays)(vpiHandle, p_vpi_delay);\n    void        (*put_delays)(vpiHandle, p_vpi_delay);\n    void        (*get_value)(vpiHandle, p_vpi_value);\n    vpiHandle   (*put_value)(vpiHandle, p_vpi_value, p_vpi_time, PLI_INT32);\n    void        (*get_time)(vpiHandle, s_vpi_time*);\n    void*       (*get_userdata)(vpiHandle);\n    PLI_INT32   (*put_userdata)(vpiHandle, void*);\n    PLI_UINT32  (*mcd_open)(char *);\n    PLI_UINT32  (*mcd_close)(PLI_UINT32);\n    PLI_INT32   (*mcd_flush)(PLI_UINT32);\n    char*       (*mcd_name)(PLI_UINT32);\n    PLI_INT32   (*mcd_vprintf)(PLI_UINT32, const char*, va_list);\n    PLI_INT32   (*flush)(void);\n    PLI_INT32   (*vprintf)(const char*, va_list);\n    PLI_INT32   (*chk_error)(p_vpi_error_info);\n    PLI_INT32   (*compare_objects)(vpiHandle, vpiHandle);\n    PLI_INT32   (*free_object)(vpiHandle);\n    PLI_INT32   (*release_handle)(vpiHandle);\n    PLI_INT32   (*get_vlog_info)(p_vpi_vlog_info info) ;\n    void        (*vcontrol)(PLI_INT32, va_list);\n    PLI_INT32   (*fopen)(const char*, const char*);\n    FILE*       (*get_file)(PLI_INT32);\n    s_vpi_vecval(*calc_clog2)(vpiHandle);\n    void        (*count_drivers)(vpiHandle, unsigned, unsigned [4]);\n    void        (*format_strength)(char*, s_vpi_value*, unsigned);\n    void        (*make_systf_system_defined)(vpiHandle);\n    void        (*mcd_rawwrite)(PLI_UINT32, const char*, size_t);\n    void        (*set_return_value)(int);\n} vpip_routines_s;\n\nextern DLLEXPORT PLI_UINT32 vpip_set_callback(vpip_routines_s*routines, PLI_UINT32 version);\n\n#endif // defined(__MINGW32__) || defined (__CYGWIN__)\n\nEXTERN_C_END\n\n#endif /* VPI_USER_H */\n"
        },
        {
          "name": "vvp",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}