{
  "metadata": {
    "timestamp": 1736566448385,
    "page": 6,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ggerganov/llama.cpp",
      "stars": 70509,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 4.58203125,
          "content": "---\nLanguage:        Cpp\nAlignAfterOpenBracket: Align\nAlignArrayOfStructures: Left\nAlignConsecutiveAssignments: AcrossComments\nAlignConsecutiveBitFields: AcrossComments\nAlignConsecutiveDeclarations: AcrossComments\nAlignConsecutiveMacros: AcrossComments\n# AlignConsecutiveShortCaseStatements: AcrossComments\nAlignEscapedNewlines: Left # LeftWithLastLine\nAlignOperands:   Align\nAlignTrailingComments:\n  Kind: Always\n  OverEmptyLines: 1\nAllowAllArgumentsOnNextLine: true\nAllowAllParametersOfDeclarationOnNextLine: false\n# AllowBreakBeforeNoexceptSpecifier: OnlyWithParen\nAllowShortBlocksOnASingleLine: Never\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: Inline\nAllowShortIfStatementsOnASingleLine: Never\nAllowShortLambdasOnASingleLine: Inline\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakBeforeMultilineStrings: true\nBinPackArguments: true\nBinPackParameters: true # OnePerLine\nBitFieldColonSpacing: Both\nBreakBeforeBraces: Custom # Attach\nBraceWrapping:\n  AfterCaseLabel:  true\n  AfterClass:      false\n  AfterControlStatement: false\n  AfterEnum:       false\n  AfterFunction:   false\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     false\n  AfterUnion:      false\n  AfterExternBlock: false\n  BeforeCatch:     false\n  BeforeElse:      false\n  BeforeLambdaBody: false\n  BeforeWhile: false\n  IndentBraces:    false\n  SplitEmptyFunction: false\n  SplitEmptyRecord: false\n  SplitEmptyNamespace: false\n# BreakAdjacentStringLiterals: true\nBreakAfterAttributes: Never\nBreakBeforeBinaryOperators: None\nBreakBeforeInlineASMColon: OnlyMultiline\nBreakBeforeTernaryOperators: false\n# BreakBinaryOperations: Never\nBreakConstructorInitializers: AfterColon\n# BreakFunctionDefinitionParameters: false\nBreakInheritanceList: AfterComma\nBreakStringLiterals: true\n# BreakTemplateDeclarations: Yes\nColumnLimit:     120\nCommentPragmas:  '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: false\nDerivePointerAlignment: false\nDisableFormat:   false\nEmptyLineBeforeAccessModifier: Leave\nEmptyLineAfterAccessModifier: Never\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: true\nIncludeBlocks:   Regroup\nIncludeCategories:\n  - Regex:           '^<.*\\.h>'\n    Priority:        1\n    SortPriority:    0\n  - Regex:           '^<.*'\n    Priority:        2\n    SortPriority:    0\n  - Regex:           '.*'\n    Priority:        3\n    SortPriority:    0\nIncludeIsMainRegex: '([-_](test|unittest))?$'\nIncludeIsMainSourceRegex: ''\nIndentAccessModifiers: false\nIndentCaseBlocks: true\nIndentCaseLabels: true\nIndentExternBlock: NoIndent\nIndentGotoLabels: false\nIndentPPDirectives: AfterHash\nIndentWidth:     4\nIndentWrappedFunctionNames: false\nInsertBraces:    true # NOTE: may lead to incorrect formatting\nInsertNewlineAtEOF: true\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nLambdaBodyIndentation: Signature\nLineEnding: LF\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBinPackProtocolList: Auto\nObjCBlockIndentWidth: 4\nObjCSpaceAfterProperty: true\nObjCSpaceBeforeProtocolList: true\nPPIndentWidth: -1\nPackConstructorInitializers: CurrentLine\nPenaltyBreakAssignment: 2\nPenaltyBreakBeforeFirstCallParameter: 1\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyBreakTemplateDeclaration: 10\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 200\nPointerAlignment: Middle\nQualifierAlignment: Left\n#QualifierOrder: ['static', 'inline', 'friend', 'constexpr', 'const', 'volatile', 'type', 'restrict']\nRawStringFormats:\n  - Language:        Cpp\n    Delimiters:\n      - cc\n      - CC\n      - cpp\n      - Cpp\n      - CPP\n      - 'c++'\n      - 'C++'\n    CanonicalDelimiter: ''\nReferenceAlignment: Middle\nReflowComments:  false # IndentOnly\nSeparateDefinitionBlocks: Always\nSortIncludes:    CaseInsensitive\nSortUsingDeclarations: LexicographicNumeric\nSpaceAfterCStyleCast: true\nSpaceAfterLogicalNot: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCpp11BracedList: false\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatements\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyBlock: false\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 2\nSpacesInAngles:  Never\nSpacesInContainerLiterals: true\nSpacesInLineCommentPrefix:\n  Minimum: 1\n  Maximum: -1\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nSpaceBeforeSquareBrackets: false\nStandard:        c++17\nTabWidth:        4\nUseTab:          Never\nWhitespaceSensitiveMacros: ['STRINGIZE']\n...\n\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 0.83984375,
          "content": "---\nChecks: >\n    bugprone-*,\n    -bugprone-easily-swappable-parameters,\n    -bugprone-implicit-widening-of-multiplication-result,\n    -bugprone-misplaced-widening-cast,\n    -bugprone-narrowing-conversions,\n    readability-*,\n    -readability-avoid-unconditional-preprocessor-if,\n    -readability-function-cognitive-complexity,\n    -readability-identifier-length,\n    -readability-implicit-bool-conversion,\n    -readability-magic-numbers,\n    -readability-uppercase-literal-suffix,\n    -readability-simplify-boolean-expr,\n    clang-analyzer-*,\n    -clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling,\n    performance-*,\n    portability-*,\n    -portability-simd-intrinsics,\n    misc-*,\n    -misc-const-correctness,\n    -misc-non-private-member-variables-in-classes,\n    -misc-no-recursion,\n    -misc-use-anonymous-namespace,\nFormatStyle: none\n"
        },
        {
          "name": ".devops",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.2314453125,
          "content": "*.o\n*.a\n.cache/\n# Do not ignore .git directory, otherwise the reported build number will always be 0\n.github/\n.gitignore\n.vs/\n.vscode/\n.DS_Store\n\nbuild*/\n\nmodels/*\n\n/llama-cli\n/llama-quantize\n\narm_neon.h\ncompile_commands.json\nDockerfile\n"
        },
        {
          "name": ".ecrc",
          "type": "blob",
          "size": 0.0947265625,
          "content": "{\n  \"Exclude\": [\"^\\\\.gitmodules$\", \"stb_image\\\\.h\"],\n  \"Disable\": {\n    \"IndentSize\": true\n  }\n}\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.787109375,
          "content": "# https://EditorConfig.org\n\n# Top-most EditorConfig file\nroot = true\n\n# Unix-style newlines with a newline ending every file, utf-8 charset\n[*]\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\ncharset = utf-8\nindent_style = space\nindent_size = 4\n\n[Makefile]\nindent_style = tab\n\n[scripts/*.mk]\nindent_style = tab\n\n[prompts/*.txt]\ninsert_final_newline = unset\n\n[examples/server/public/*]\nindent_size = 2\n\n[examples/server/public/deps_*]\ntrim_trailing_whitespace = unset\nindent_style = unset\nindent_size = unset\n\n[examples/server/deps_*]\ntrim_trailing_whitespace = unset\nindent_style = unset\nindent_size = unset\n\n[examples/llama.swiftui/llama.swiftui.xcodeproj/*]\nindent_style = tab\n\n[examples/cvector-generator/*.txt]\ntrim_trailing_whitespace = unset\ninsert_final_newline = unset\n"
        },
        {
          "name": ".flake8",
          "type": "blob",
          "size": 0.53125,
          "content": "[flake8]\nmax-line-length = 125\nignore = E203,E211,E221,E225,E231,E241,E251,E261,E266,E501,E701,E704,W503\nexclude =\n    # Do not traverse examples\n    examples,\n    # Do not include package initializers\n    __init__.py,\n    # No need to traverse our git directory\n    .git,\n    # There's no value in checking cache directories\n    __pycache__,\n    # No need to include the build path\n    build,\n    # This contains builds that we don't want to check\n    dist  # This is generated with `python build .` for package releases\n# max-complexity = 10\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.623046875,
          "content": "# Extensions\n\n*.a\n*.bat\n*.bin\n*.d\n*.dll\n*.dot\n*.etag\n*.exe\n*.gcda\n*.gcno\n*.gcov\n*.gguf\n*.gguf.json\n*.lastModified\n*.log\n*.metallib\n*.o\n*.so\n*.tmp\n\n# IDE / OS\n\n.cache/\n.ccls-cache/\n.direnv/\n.DS_Store\n.envrc\n.idea/\n.swiftpm\n.vs/\n.vscode/\nnppBackup\n\n\n# Coverage\n\ngcovr-report/\nlcov-report/\n\n# Build Artifacts\n\ntags\n.build/\nbuild*\n!build-info.cmake\n!build-info.cpp.in\n!build-info.sh\n!build.zig\n!docs/build.md\n/libllama.so\n/llama-*\n/vulkan-shaders-gen\nandroid-ndk-*\narm_neon.h\ncmake-build-*\nCMakeSettings.json\ncompile_commands.json\nggml-metal-embed.metal\nllama-batched-swift\n/rpc-server\nout/\ntmp/\nautogen-*.md\n\n# Deprecated\n\n/main\n/server\n\n# CI\n\n!.github/workflows/*.yml\n\n# Models\n\nmodels/*\nmodels-mnt\n!models/.editorconfig\n!models/ggml-vocab-*.gguf*\n\n# Zig\nzig-out/\nzig-cache/\n\n# Logs\n\nppl-*.txt\nqnt-*.txt\nperf-*.txt\n\n# Examples\n\nexamples/jeopardy/results.txt\nexamples/server/*.css.hpp\nexamples/server/*.html.hpp\nexamples/server/*.js.hpp\nexamples/server/*.mjs.hpp\n!build_64.sh\n!examples/*.bat\n!examples/*/*.kts\n!examples/*/*/*.kts\n!examples/sycl/*.bat\n!examples/sycl/*.sh\n\n# Server Web UI temporary files\nnode_modules\nexamples/server/webui/dist\n\n# Python\n\n/.venv\n__pycache__/\n*/poetry.lock\npoetry.toml\n\n# Nix\n/result\n\n# Test binaries\n/tests/test-backend-ops\n/tests/test-double-float\n/tests/test-grad0\n/tests/test-grammar-parser\n/tests/test-llama-grammar\n/tests/test-opt\n/tests/test-quantize-fns\n/tests/test-quantize-perf\n/tests/test-rope\n/tests/test-sampling\n/tests/test-tokenizer-0\n/tests/test-tokenizer-1-bpe\n/tests/test-tokenizer-1-spm\n\n# Scripts\n!/scripts/install-oneapi.bat\n\n# Test models for lora adapters\n/lora-tests\n\n# Local scripts\n/run-vim.sh\n/run-chat.sh\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.1044921875,
          "content": "[submodule \"kompute\"]\n\tpath = ggml/src/ggml-kompute/kompute\n\turl = https://github.com/nomic-ai/kompute.git\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.4365234375,
          "content": "# See https://pre-commit.com for more information\n# See https://pre-commit.com/hooks.html for more hooks\nexclude: prompts/.*.txt\nrepos:\n- repo: https://github.com/pre-commit/pre-commit-hooks\n  rev: v4.6.0\n  hooks:\n  - id: trailing-whitespace\n  - id: end-of-file-fixer\n  - id: check-yaml\n  - id: check-added-large-files\n- repo: https://github.com/PyCQA/flake8\n  rev: 7.0.0\n  hooks:\n  -   id: flake8\n      additional_dependencies: [flake8-no-print]\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 40.6650390625,
          "content": "# date: Thu Nov 28 20:46:15 EET 2024\n# this file is auto-generated by scripts/gen-authors.sh\n\n0cc4m <picard12@live.de>\n0xspringtime <110655352+0xspringtime@users.noreply.github.com>\n20kdc <asdd2808@gmail.com>\n2f38b454 <dxf@protonmail.com>\n3ooabkhxtn <31479382+3ooabkhxtn@users.noreply.github.com>\n44670 <44670@users.noreply.github.com>\n65a <10104049+65a@users.noreply.github.com>\nAN Long <aisk@users.noreply.github.com>\nAT <manyoso@users.noreply.github.com>\nAarni Koskela <akx@iki.fi>\nAaron Miller <apage43@ninjawhale.com>\nAaryaman Vasishta <aaryaman.vasishta@amd.com>\nAbheek Gulati <abheekg@hotmail.com>\nAbhilash Majumder <30946547+abhilash1910@users.noreply.github.com>\nAbhishek Gopinath K <31348521+overtunned@users.noreply.github.com>\nAdithya Balaji <adithya.b94@gmail.com>\nAdithyanI <adithyan.i4internet@gmail.com>\nAdrian <smith.adriane@gmail.com>\nAdrian Hesketh <a-h@users.noreply.github.com>\nAhmad Tameem <113388789+Tameem-10xE@users.noreply.github.com>\nAhmet Zeer <ahmed.zeer@std.yildiz.edu.tr>\nAidanBeltonS <87009434+AidanBeltonS@users.noreply.github.com>\nAidanBeltonS <aidan.belton@codeplay.com>\nAisuko <urakiny@gmail.com>\nAkarshan Biswas <akarshan.biswas@gmail.com>\nAkarshan Biswas <akarshanbiswas@fedoraproject.org>\nAl Mochkin <14274697+amochkin@users.noreply.github.com>\nAlbert Jin <albert.jin@gmail.com>\nAlberto <57916483+albbus-stack@users.noreply.github.com>\nAlberto Cabrera Pérez <alberto.cabrera@codeplay.com>\nAlberto Cabrera Pérez <alberto.cabrera@intel.com>\nAlex <awhill19@icloud.com>\nAlex Azarov <alex@azarov.by>\nAlex Azarov <alexander.azarov@mapbox.com>\nAlex Klinkhamer <from.github.com.917@grencez.dev>\nAlex Klinkhamer <git@grencez.dev>\nAlex Nguyen <tiendung@users.noreply.github.com>\nAlex O'Connell <35843486+acon96@users.noreply.github.com>\nAlex Petenchea <alex.petenchea@gmail.com>\nAlex Renda <alexrenda@users.noreply.github.com>\nAlex Tuddenham <61622354+AlexsCode@users.noreply.github.com>\nAlex von Gluck IV <kallisti5@unixzen.com>\nAlexey Parfenov <zxed@alkatrazstudio.net>\nAli Chraghi <63465728+alichraghi@users.noreply.github.com>\nAli Nehzat <ali.nehzat@thanks.dev>\nAli Tariq <ali.tariq@10xengineers.ai>\nAlon <alonfaraj@gmail.com>\nAlpinDale <52078762+AlpinDale@users.noreply.github.com>\nAmir <amir_zia@outlook.com>\nAmirAli Mirian <37371367+amiralimi@users.noreply.github.com>\nAnanta Bastola <anantarajbastola@gmail.com>\nAnas Ahouzi <112881240+aahouzi@users.noreply.github.com>\nAndrás Salamon <ott2@users.noreply.github.com>\nAndreas (Andi) Kunar <andreask@msn.com>\nAndrei <abetlen@gmail.com>\nAndrew Canis <andrew.canis@gmail.com>\nAndrew Downing <andrew2085@gmail.com>\nAndrew Duffy <a10y@users.noreply.github.com>\nAndrew Godfrey <AndrewGodfrey@users.noreply.github.com>\nAndrew Minh Nguyen <40281306+amqdn@users.noreply.github.com>\nAndy Salerno <andysalerno@gmail.com>\nAndy Tai <andy-tai@users.noreply.github.com>\nAnthony Van de Gejuchte <anthonyvdgent@gmail.com>\nAntonis Makropoulos <benuix@gmail.com>\nArik Poznanski <arikpoz@users.noreply.github.com>\nArmen Kaleshian <kriation@users.noreply.github.com>\nArtem <guinmoon@gmail.com>\nArtem Zinnatullin <ceo@abstractny.gay>\nArtyom Lebedev <vagran.ast@gmail.com>\nAsbjørn Olling <asbjornolling@gmail.com>\nÁsgeir Bjarni Ingvarsson <asgeir@fundinn.org>\nAsghar Ghorbani <a-ghorbani@users.noreply.github.com>\nAshish <1856117+ashishdatta@users.noreply.github.com>\nAshok Gelal <401055+ashokgelal@users.noreply.github.com>\nAshraful Islam <ashraful.meche@gmail.com>\nAtsushi Tatsuma <yoshoku@outlook.com>\nAustin <77757836+teleprint-me@users.noreply.github.com>\nAustinMroz <austinmroz@utexas.edu>\nBADR <contact@pythops.com>\nBach Le <bach@bullno1.com>\nBailey Chittle <39804642+bachittle@users.noreply.github.com>\nBarfingLemurs <128182951+BarfingLemurs@users.noreply.github.com>\nBartowski <ckealty1182@gmail.com>\nBehnam M <58621210+ibehnam@users.noreply.github.com>\nBen Ashbaugh <ben.ashbaugh@intel.com>\nBen Garney <bengarney@users.noreply.github.com>\nBen Siraphob <bensiraphob@gmail.com>\nBen Williams <ben@719ben.com>\nBenjamin Findley <39356821+Kartoffelsaft@users.noreply.github.com>\nBenjamin Lecaillon <84293038+blecaillon@users.noreply.github.com>\nBernat Vadell <hounter.caza@gmail.com>\nBert Wagner <github@bertwagner.com>\nBingan <70050083+binganao@users.noreply.github.com>\nBjarke Viksøe <164612031+bviksoe@users.noreply.github.com>\nBodo Graumann <mail@bodograumann.de>\nBono Lv <lvscar@users.noreply.github.com>\nBorislav Stanimirov <b.stanimirov@abv.bg>\nBranden Butler <bwtbutler@hotmail.com>\nBrandon Squizzato <35474886+bsquizz@users.noreply.github.com>\nBrian <mofosyne@gmail.com>\nBrian Cunnie <brian.cunnie@gmail.com>\nBruce MacDonald <brucewmacdonald@gmail.com>\nBryan Honof <bryanhonof@gmail.com>\nCJ Pais <cj@cjpais.com>\nCRD716 <crd716@gmail.com>\nCalvin Laurenson <calvin@laurenson.dev>\nCameron <csteele@steelecameron.com>\nCameron Kaiser <classilla@users.noreply.github.com>\nCarolinabanana <140120812+Carolinabanana@users.noreply.github.com>\nCarryFun <76023481+CarryFun@users.noreply.github.com>\nCarsten Kragelund Jørgensen <carsten@kragelund.me>\nCarterLi999 <664681047@qq.com>\nCasey Primozic <casey@cprimozic.net>\nCasey Primozic <me@ameo.link>\nCausalLM <148736309+CausalLM@users.noreply.github.com>\nCebtenzzre <cebtenzzre@gmail.com>\nChad Brewbaker <crb002@gmail.com>\nChangyeon Kim <cyzero.kim@samsung.com>\nChao Jiang <jc19chaoj@zoho.com>\nCharles Xu <63788048+chaxu01@users.noreply.github.com>\nCharles Xu <charles.xu@arm.com>\nChen Xi <xi2.chen@intel.com>\nChen Xi <xixichen08@foxmail.com>\nCheng Shao <terrorjack@type.dance>\nChenguang Li <87689256+noemotiovon@users.noreply.github.com>\nChris Elrod <elrodc@gmail.com>\nChris Kuehl <ckuehl@ckuehl.me>\nChristian Demsar <christian@github.email.demsar.us>\nChristian Demsar <crasm@git.vczf.us>\nChristian Falch <875252+chrfalch@users.noreply.github.com>\nChristian Kögler <ck3d@gmx.de>\nChristian Köhnenkamp <cvk5@me.com>\nChristian Zhou-Zheng <59622928+christianazinn@users.noreply.github.com>\nClark Saben <76020733+csaben@users.noreply.github.com>\nClint Herron <hanclinto@gmail.com>\nConrad Kramer <conrad@conradkramer.com>\nCrispStrobe <154636388+CrispStrobe@users.noreply.github.com>\nCsaba Kecskemeti <csaba.kecskemeti@gmail.com>\nCuong Trinh Manh <nguoithichkhampha@gmail.com>\nDAN™ <dranger003@gmail.com>\nDamian Stewart <d@damianstewart.com>\nDan Johansson <164997844+eddnjjn@users.noreply.github.com>\nDan Johansson <dan.johansson@arm.com>\nDane Madsen <dane_madsen@hotmail.com>\nDaniAndTheWeb <57776841+DaniAndTheWeb@users.noreply.github.com>\nDaniel Bevenius <daniel.bevenius@gmail.com>\nDaniel Drake <drake@endlessos.org>\nDaniel Hiltgen <dhiltgen@users.noreply.github.com>\nDaniel Illescas Romero <illescas.daniel@protonmail.com>\nDaniel Kleine <53251018+d-kleine@users.noreply.github.com>\nDaniele <57776841+daniandtheweb@users.noreply.github.com>\nDannyDaemonic <DannyDaemonic@gmail.com>\nDat Quoc Nguyen <2412555+datquocnguyen@users.noreply.github.com>\nDave <dave-fl@users.noreply.github.com>\nDave Airlie <airlied@gmail.com>\nDave Airlie <airlied@redhat.com>\nDave Della Costa <ddellacosta+github@gmail.com>\nDavid Friehs <david@friehs.info>\nDavid Kennedy <dakennedyd@gmail.com>\nDavid Pflug <david@pflug.email>\nDavid Renshaw <dwrenshaw@gmail.com>\nDavid Sommers <12738+databyte@users.noreply.github.com>\nDavid Yang <davidyang6us@gmail.com>\nDavidKorczynski <david@adalogics.com>\nDawid Potocki <github@dawidpotocki.com>\nDawid Wysocki <62249621+TortillaZHawaii@users.noreply.github.com>\nDean <Dean.Sinaean@gmail.com>\nDeins <deinsegle@gmail.com>\nDenis Spasyuk <34203011+dspasyuk@users.noreply.github.com>\nDerrick T. Woolworth <dwoolworth@gmail.com>\nDeven Mistry <31466137+deven367@users.noreply.github.com>\nDibakar Gope <dibakar.gope@arm.com>\nDidzis Gosko <didzis@users.noreply.github.com>\nDiego Devesa <slarengh@gmail.com>\nDiogo Teles Sant'Anna <diogoteles@google.com>\nDjip007 <djip.perois@free.fr>\nDon Mahurin <dmahurin@users.noreply.github.com>\nDooWoong Lee (David) <manics99@naver.com>\nDoomsdayrs <38189170+Doomsdayrs@users.noreply.github.com>\nDou Xinpeng <15529241576@163.com>\nDou Xinpeng <81913537+Dou-Git@users.noreply.github.com>\nDouglas Hanley <thesecretaryofwar@gmail.com>\nDr. Tom Murphy VII Ph.D <499244+tom7@users.noreply.github.com>\nEbey Abraham <ebey97@gmail.com>\nEcho Nolan <echo@echonolan.net>\nEd Lee <edilee@mozilla.com>\nEd Lepedus <ed.lepedus@googlemail.com>\nEddie-Wang <wangjinheng1120@163.com>\nEdward Taylor <edeetee@gmail.com>\nElaine <elaine.zosa@gmail.com>\nElbios <141279586+Elbios@users.noreply.github.com>\nElton Kola <eltonkola@gmail.com>\nEngininja2 <139037756+Engininja2@users.noreply.github.com>\nEquim <sayaka@ekyu.moe>\nEric Curtin <ecurtin@redhat.com>\nEric Curtin <ericcurtin17@gmail.com>\nEric Sommerlade <es0m@users.noreply.github.com>\nEric Zhang <34133756+EZForever@users.noreply.github.com>\nErik Garrison <erik.garrison@gmail.com>\nErik Scholz <Green-Sky@users.noreply.github.com>\nEsko Toivonen <eskot98@gmail.com>\nEttore Di Giacinto <mudler@users.noreply.github.com>\nEvan Jones <evan.q.jones@gmail.com>\nEvan Miller <emmiller@gmail.com>\nEve <139727413+netrunnereve@users.noreply.github.com>\nEvgeny Kurnevsky <kurnevsky@gmail.com>\nEwout ter Hoeven <E.M.terHoeven@student.tudelft.nl>\nExtReMLapin <3909752+ExtReMLapin@users.noreply.github.com>\nFK <sozforex@gmail.com>\nFabian <cmdrf@users.noreply.github.com>\nFabio R. Sluzala <Fabio3rs@users.noreply.github.com>\nFaez Shakil <faez.shakil@gmail.com>\nFaisal Zaghloul <faisal.zaghloul@gmail.com>\nFaisal Zaghloul <quic_fzaghlou@quicinc.com>\nFan Shupei <dymarkfan@outlook.com>\nFantasyGmm <16450052+FantasyGmm@users.noreply.github.com>\nFarbod Bijary <110523279+farbodbj@users.noreply.github.com>\nFattire <528174+fat-tire@users.noreply.github.com>\nFelix <stenbackfelix@gmail.com>\nFinn Voorhees <finnvoorhees@gmail.com>\nFirat <firatkiral@gmail.com>\nFirstTimeEZ <179362031+FirstTimeEZ@users.noreply.github.com>\nFolko-Ven <71110216+Folko-Ven@users.noreply.github.com>\nFoul-Tarnished <107711110+Foul-Tarnished@users.noreply.github.com>\nFrancisco Melo <43780565+francis2tm@users.noreply.github.com>\nFrank Mai <thxcode0824@gmail.com>\nFrankHB <frankhb1989@gmail.com>\nFrankie Robertson <frankier@users.noreply.github.com>\nFred Douglas <43351173+fredlas@users.noreply.github.com>\nFrederik Vogel <Schaltfehler@users.noreply.github.com>\nGabe Goodhart <gabe.l.hart@gmail.com>\nGabe Goodhart <ghart@us.ibm.com>\nGainLee <perfecter.gen@gmail.com>\nGalunid <karolek1231456@gmail.com>\nGary Linscott <glinscott@gmail.com>\nGary Mulder <gjmulder@gmail.com>\nGavin Zhao <gavinzhaojw@protonmail.com>\nGenkagaku.GPT <hlhr202@163.com>\nGeorgi Gerganov <ggerganov@gmail.com>\nGilad S <giladgd@users.noreply.github.com>\nGilad S. <7817232+giladgd@users.noreply.github.com>\nGiuseppe Scrivano <giuseppe@scrivano.org>\nGiviMAD <GiviMAD@users.noreply.github.com>\nGovlzkoy <gotope@users.noreply.github.com>\nGuillaume \"Vermeille\" Sanchez <Guillaume.V.Sanchez@gmail.com>\nGuillaume Wenzek <gwenzek@users.noreply.github.com>\nGuoliang Hua <32868157+nbcsm@users.noreply.github.com>\nGuoteng <32697156+SolenoidWGT@users.noreply.github.com>\nGustavo Rocha Dias <91472747+gustrd@users.noreply.github.com>\nHaggai Nuchi <h.nuchi@gmail.com>\nHalalaluyafail3 <55773281+Halalaluyafail3@users.noreply.github.com>\nHamdoud Hakem <90524568+hamdoudhakem@users.noreply.github.com>\nHanishKVC <hanishkvc@gmail.com>\nHaohui Mai <ricetons@gmail.com>\nHaoxiang Fei <tonyfettes@tonyfettes.com>\nHarald Fernengel <harald.fernengel@here.com>\nHatsune Miku <129688334+at8u@users.noreply.github.com>\nHatsuneMikuUwU33 <173229399+HatsuneMikuUwU33@users.noreply.github.com>\nHenk Poley <HenkPoley@gmail.com>\nHenri Vasserman <henv@hot.ee>\nHenrik Forstén <henrik.forsten@gmail.com>\nHerman Semenov <GermanAizek@yandex.ru>\nHesen Peng <hesen.peng@gmail.com>\nHoang Nguyen <hugo53@users.noreply.github.com>\nHong Bo PENG <penghb@cn.ibm.com>\nHongyu Ouyang <96765450+casavaca@users.noreply.github.com>\nHoward Su <howard0su@gmail.com>\nHua Jiang <allenhjiang@outlook.com>\nHuang Qi <huangqi3@xiaomi.com>\nHuawei Lin <huaweilin.cs@gmail.com>\nHugo Roussel <hugo.rous@gmail.com>\nHuifeng Ou <79071290+ho2103@users.noreply.github.com>\nIan Bull <irbull@eclipsesource.com>\nIan Bull <irbull@gmail.com>\nIan Scrivener <github@zilogy.asia>\nIcecream95 <the.real.icecream95@gmail.com>\nIdo S <ido.pluto@gmail.com>\nIgnacioFDM <ignaciofdm@gmail.com>\nIgor Okulist <okigan@gmail.com>\nIkko Eltociear Ashimine <eltociear@gmail.com>\nIlya Kurdyukov <59548320+ilyakurdyukov@users.noreply.github.com>\nIonoclast Laboratories <brigham@ionoclast.com>\nIsaac McFadyen <isaac@imcf.me>\nIsaacDynamo <61521674+IsaacDynamo@users.noreply.github.com>\nIvan <nekotekina@gmail.com>\nIvan Filipov <159561759+vanaka11@users.noreply.github.com>\nIvan Komarov <Ivan.Komarov@dfyz.info>\nIvan Stepanov <ivanstepanovftw@gmail.com>\nJH23X <165871467+JH23X@users.noreply.github.com>\nJack Mousseau <jack@software.inc>\nJack Mousseau <jmousseau@users.noreply.github.com>\nJackJollimore <130917767+JackJollimore@users.noreply.github.com>\nJaeden Amero <jaeden@patater.com>\nJaemin Son <woalsdnd@gmail.com>\nJag Chadha <jagtesh@gmail.com>\nJakub N <jakubniemczyk97@gmail.com>\nJames A Capozzoli <157492257+jac-jim@users.noreply.github.com>\nJames Reynolds <magnusviri@users.noreply.github.com>\nJan Boon <jan.boon@kaetemi.be>\nJan Boon <kaetemi@gmail.com>\nJan Ploski <jpl@plosquare.com>\nJannis Schönleber <joennlae@gmail.com>\nJared Van Bortel <cebtenzzre@gmail.com>\nJared Van Bortel <jared@nomic.ai>\nJason McCartney <jmac@theroot.org>\nJason Stillerman <jason.t.stillerman@gmail.com>\nJean-Christophe Hoelt <hoelt@fovea.cc>\nJean-Michaël Celerier <jeanmichael.celerier+github@gmail.com>\nJed Fox <git@jedfox.com>\nJeff Bolz <jbolz@nvidia.com>\nJeffrey Morgan <jmorganca@gmail.com>\nJeffrey Quesnelle <emozilla@nousresearch.com>\nJeroen Mostert <jeroen.mostert@cm.com>\nJesse Jojo Johnson <williamsaintgeorge@gmail.com>\nJeximo <jeximo@gmail.com>\nJhen-Jie Hong <iainst0409@gmail.com>\nJiahao Li <liplus17@163.com>\nJian Liao <jianliao@users.noreply.github.com>\nJidongZhang-THU <1119708529@qq.com>\nJinwoo Jeong <33892306+williamjeong2@users.noreply.github.com>\nJiří Podivín <66251151+jpodivin@users.noreply.github.com>\nJiří Sejkora <Sejseloid@gmail.com>\nJoan Fontanals <jfontanalsmartinez@gmail.com>\nJoan Fontanals <joan.fontanals.martinez@jina.ai>\nJoão Dinis Ferreira <hello@joaof.eu>\nJoe Eli McIlvain <joe.eli.mac@gmail.com>\nJoe Todd <joe.todd@codeplay.com>\nJohan <JohanAR@users.noreply.github.com>\nJohannes Gäßler <johannesg@5d6.de>\nJohannes Rudolph <johannes.rudolph@gmail.com>\nJohn <78893154+cmp-nct@users.noreply.github.com>\nJohn Balis <phobossystems@gmail.com>\nJohn Smith <67539080+kingsidelee@users.noreply.github.com>\nJohnnyB <jboero@users.noreply.github.com>\nJonas Wunderlich <32615971+jonas-w@users.noreply.github.com>\nJorge A <161275481+jorgealias@users.noreply.github.com>\nJose Maldonado <63384398+yukiteruamano@users.noreply.github.com>\nJoseph Stahl <1269177+josephst@users.noreply.github.com>\nJosh Ramer <josh.ramer@icloud.com>\nJoyce <joycebrum@google.com>\nJuan Calderon-Perez <835733+gaby@users.noreply.github.com>\nJudd <foldl@users.noreply.github.com>\nJulius Arkenberg <arki05@users.noreply.github.com>\nJun Hee Yoo <contact.jhyoo@gmail.com>\nJun Jie <71215065+junnjiee16@users.noreply.github.com>\nJunil Kim <logyourself@gmail.com>\nJunyang Lin <justinlin930319@hotmail.com>\nJuraj Bednar <juraj@bednar.io>\nJustin Parker <jparkerweb@gmail.com>\nJustin Suess <justin.suess@westpoint.edu>\nJustina Cho <justcho5@gmail.com>\nJustine Tunney <jtunney@gmail.com>\nJustine Tunney <jtunney@mozilla.com>\nJuuso Alasuutari <juuso.alasuutari@gmail.com>\nKASR <karim.asrih@gmail.com>\nKamil Tomšík <info@tomsik.cz>\nKarsten Weiss <knweiss@gmail.com>\nKarthick <j.karthic2004@gmail.com>\nKarthik Kumar Viswanathan <195178+guilt@users.noreply.github.com>\nKarthik Sethuraman <k.seth1993@gmail.com>\nKasumi <90275229+kasumi-1@users.noreply.github.com>\nKawrakow <48489457+ikawrakow@users.noreply.github.com>\nKeiichi Tabata <keiichi.tabata@outlook.com>\nKeke Han <hankeke303@163.com>\nKenvix ⭐ <kenvixzure@live.com>\nKerfuffle <44031344+KerfuffleV2@users.noreply.github.com>\nKevin Gibbons <bakkot@gmail.com>\nKevin Ji <1146876+kevinji@users.noreply.github.com>\nKevin Kwok <antimatter15@gmail.com>\nKevin Lo <kevlo@kevlo.org>\nKevin Wang <kevmo314@gmail.com>\nKolen Cheung <ickc@users.noreply.github.com>\nKonstantin Herud <konstantin.herud@denkbares.com>\nKonstantin Zhuravlyov <konstantin.zhuravlyov@amd.com>\nKunshang Ji <kunshang.ji@intel.com>\nKyle Liang <liangmanlai@gmail.com>\nKyle Mistele <kyle@mistele.com>\nKylin <56434533+KyL0N@users.noreply.github.com>\nLars Grammel <lars.grammel@gmail.com>\nLaura <Tijntje_7@msn.com>\nLee <44310445+lx200916@users.noreply.github.com>\nLee Drake <b.lee.drake@gmail.com>\nLeng Yue <lengyue@lengyue.me>\nLeon Knauer <git@leonknauer.com>\nLeonEricsson <70749762+LeonEricsson@users.noreply.github.com>\nLeonardo Neumann <leonardo@neumann.dev.br>\nLi Tan <tanliboy@gmail.com>\nLinwei Wang <wanix1988@gmail.com>\nLiu Jia <109258120+Septa2112@users.noreply.github.com>\nLiu Jia <jia3.liu@intel.com>\nLoganDark <github@logandark.mozmail.com>\nLoïc Carrère <loic.carrere@gmail.com>\nLostRuins <39025047+LostRuins@users.noreply.github.com>\nLuciano <lucianostrika44@gmail.com>\nLuo Tian <lt@basecity.com>\nLyle Dean <dean@lyle.dev>\nM-A <maruel@gmail.com>\nM. Yusuf Sarıgöz <yusufsarigoz@gmail.com>\nMa Mingfei <mingfei.ma@intel.com>\nMaarten ter Huurne <maarten@treewalker.org>\nMack Straight <eiz@users.noreply.github.com>\nMaël Kerbiriou <m431.kerbiriou@gmail.com>\nMaggotHATE <clay1326@gmail.com>\nMahesh Madhav <67384846+heshpdx@users.noreply.github.com>\nManuel <44313466+makuche@users.noreply.github.com>\nMarc Köhlbrugge <subscriptions@marckohlbrugge.com>\nMarco Matthies <71844+marcom@users.noreply.github.com>\nMarcus Dunn <51931484+MarcusDunn@users.noreply.github.com>\nMarian Cepok <marian.cepok@gmail.com>\nMark Fairbairn <thebaron88@gmail.com>\nMark Zhuang <zhuangqiubin@gmail.com>\nMarko Tasic <mtasic85@gmail.com>\nMarkus Tavenrath <mtavenrath@users.noreply.github.com>\nMartin Delille <martin@delille.org>\nMartin Krasser <krasserm@googlemail.com>\nMartin Schwaighofer <mschwaig@users.noreply.github.com>\nMarvin Gießing <marvin.giessing@gmail.com>\nMasaya, Kato <62578291+msy-kato@users.noreply.github.com>\nMasterYi1024 <39848311+MasterYi1024@users.noreply.github.com>\nMateusz Charytoniuk <mateusz.charytoniuk@protonmail.com>\nMatheus C. França <matheus-catarino@hotmail.com>\nMatheus Gabriel Alves Silva <matheusgasource@gmail.com>\nMathieu Geli <mathieu.geli@gmail.com>\nMathieu Nayrolles <MathieuNls@users.noreply.github.com>\nMathijs Henquet <mathijs.henquet@gmail.com>\nMathijs de Bruin <mathijs@mathijsfietst.nl>\nMatt Clayton <156335168+mattjcly@users.noreply.github.com>\nMatt Pulver <matt.pulver@heavy.ai>\nMatt Stephenson <mstephenson6@users.noreply.github.com>\nMatteo Boschini <12133566+mbosc@users.noreply.github.com>\nMatteo Mortari <matteo.mortari@gmail.com>\nMattheus Chediak <shammcity00@gmail.com>\nMatthew Tejo <matthew.tejo@gmail.com>\nMatvey Soloviev <blackhole89@gmail.com>\nMax Krasnyansky <max.krasnyansky@gmail.com>\nMax Krasnyansky <quic_maxk@quicinc.com>\nMaxime <672982+maximegmd@users.noreply.github.com>\nMaximilian Winter <maximilian.winter.91@gmail.com>\nMeng Zhang <meng@tabbyml.com>\nMeng, Hengyu <hengyu.meng@intel.com>\nMengqing Cao <cmq0113@163.com>\nMerrick Christensen <merrick.christensen@gmail.com>\nMichael Coppola <m18coppola@gmail.com>\nMichael Francis <edude03@gmail.com>\nMichael Hueschen <m@mhueschen.dev>\nMichael Kesper <mkesper@schokokeks.org>\nMichael Klimenko <mklimenko29@gmail.com>\nMichael Podvitskiy <podvitskiymichael@gmail.com>\nMichael Potter <NanoTekGuy@Gmail.com>\nMichael de Gans <michael.john.degans@gmail.com>\nMichaël de Vries <vriesdemichael@gmail.com>\nMichał Tuszyński <srgtuszy@gmail.com>\nMihai <mihai.chirculescu@yahoo.com>\nMike <ytianhui2004@gmail.com>\nMikko Juola <mikjuo@gmail.com>\nMinsoo Cheong <54794500+mscheong01@users.noreply.github.com>\nMinsoo Cheong <icycle0409@snu.ac.kr>\nMirko185 <mirkosig@gmail.com>\nMirror Azure <54669636+MirrorAzure@users.noreply.github.com>\nMistApproach <98988043+MistApproach@users.noreply.github.com>\nMiwa / Ensan <63481257+ensan-hcl@users.noreply.github.com>\nMohammadreza Hendiani <hendiani.mohammadreza@gmail.com>\nMohammadreza Hendiani <mohammad.r.hendiani@gmail.com>\nMolly Sophia <mollysophia379@gmail.com>\nMorganRO8 <47795945+MorganRO8@users.noreply.github.com>\nMurilo Santana <mvrilo@gmail.com>\nMusab Gultekin <musabgultekin@users.noreply.github.com>\nNam D. Tran <42194884+namtranase@users.noreply.github.com>\nNathan Epstein <nate2@umbc.edu>\nNatsu <chino@hotococoa.moe>\nNawafAlansari <72708095+NawafAlansari@users.noreply.github.com>\nNebula <infinitewormhole@gmail.com>\nNeo Zhang <14088817+arthw@users.noreply.github.com>\nNeo Zhang <zhang.jianyu@outlook.com>\nNeo Zhang Jianyu <jianyu.zhang@intel.com>\nNeuman Vong <neuman.vong@gmail.com>\nNexes the Old <124105151+Nexesenex@users.noreply.github.com>\nNexesenex <124105151+Nexesenex@users.noreply.github.com>\nNiall Coates <1349685+Niall-@users.noreply.github.com>\nNicholai Tukanov <nicholaitukanov@gmail.com>\nNico Bosshard <nico@bosshome.ch>\nNicolai Weitkemper <kontakt@nicolaiweitkemper.de>\nNicolás Pérez <nicolas_perez@brown.edu>\nNigel Bosch <pnigelb@gmail.com>\nNiklas Korz <niklas@niklaskorz.de>\nNikolaiLyssogor <59844691+NikolaiLyssogor@users.noreply.github.com>\nNikolas <127742645+nneubacher@users.noreply.github.com>\nNindaleth <Nindaleth@users.noreply.github.com>\nOSecret <135510162+OLSecret@users.noreply.github.com>\nOleksandr Nikitin <oleksandr@tvori.info>\nOleksii Maryshchenko <oleksii.maryshchenko@gmail.com>\nOlivier Chafik <ochafik@users.noreply.github.com>\nOndřej Čertík <ondrej@certik.us>\nOuadie EL FAROUKI <ouadie.elfarouki@codeplay.com>\nPAB <pierreantoine.bannier@gmail.com>\nPablo Duboue <pablo.duboue@gmail.com>\nPascal Patry <ppatry@mtacitlabs.com>\nPatrice Ferlet <metal3d@gmail.com>\nPaul Tsochantaris <ptsochantaris@icloud.com>\nPavel Zloi <github.com@drteam.rocks>\nPavol Rusnak <pavol@rusnak.io>\nPaweł Wodnicki <151604+32bitmicro@users.noreply.github.com>\nPedro Cuenca <pedro@huggingface.co>\nPeter Sugihara <peter@campsh.com>\nPhil H <5756783+phiharri@users.noreply.github.com>\nPhilip Taron <philip.taron@gmail.com>\nPhillip Kravtsov <phillip@kravtsov.net>\nPierre Alexandre SCHEMBRI <pa.schembri@gmail.com>\nPierrick Hymbert <pierrick.hymbert@gmail.com>\nPieter Ouwerkerk <pieter.ouwerkerk@gmail.com>\nPlamen Minev <pacominev@gmail.com>\nPrashant Vithule <119530321+Vithulep@users.noreply.github.com>\nPrzemysław Pawełczyk <przemoc@gmail.com>\nQin Yue Chen <71813199+chenqiny@users.noreply.github.com>\nQingyou Meng <meng.qingyou@gmail.com>\nQu Zongfu <43257352+yancaoweidaode@users.noreply.github.com>\nR0CKSTAR <xiaodong.ye@mthreads.com>\nR0CKSTAR <yeahdongcn@gmail.com>\nRJ Adriaansen <adriaansen@eshcc.eur.nl>\nRadoslav Gerganov <rgerganov@gmail.com>\nRadosław Gryta <radek.gryta@gmail.com>\nRahul Vivek Nair <68507071+RahulVivekNair@users.noreply.github.com>\nRaj Hammeer Singh Hada <hammeerraj@gmail.com>\nRalph Soika <ralph.soika@imixs.com>\nRand Xie <randxiexyy29@gmail.com>\nRandall Fitzgerald <randall@dasaku.net>\nRandom Fly <renfei8@live.cn>\nReinforce-II <fate@eastal.com>\nRen Xuancheng <jklj077@users.noreply.github.com>\nRene Leonhardt <65483435+reneleonhardt@users.noreply.github.com>\nRhinoDevel <RhinoDevel@users.noreply.github.com>\nRiceball LEE <snowyu.lee@gmail.com>\nRich Dougherty <rich@rd.nz>\nRichard Kiss <him@richardkiss.com>\nRichard Roberson <richardr1126@gmail.com>\nRick G <26732651+TheFlipbook@users.noreply.github.com>\nRickard Edén <rickardeden@gmail.com>\nRickard Hallerbäck <rickard.hallerback@gmail.com>\nRickey Bowers Jr <bitRAKE@gmail.com>\nRiley Stewart <ristew@users.noreply.github.com>\nRinne <AsakusaRinne@gmail.com>\nRinne <liu_yaohui1998@126.com>\nRobert Brisita <986796+rbrisita@users.noreply.github.com>\nRobert Sung-wook Shin <edp1096@users.noreply.github.com>\nRobey Holderith <robey@flaminglunchbox.net>\nRobyn <robyngraf@users.noreply.github.com>\nRoger Meier <r.meier@siemens.com>\nRoland <14355895+rbur0425@users.noreply.github.com>\nRomain Biessy <romain.biessy@codeplay.com>\nRomain D <90720+Artefact2@users.noreply.github.com>\nRomain Neutron <romain@neutron.io>\nRoman Parykin <donderom@gmail.com>\nRon Evans <ron@hybridgroup.com>\nRon Jailall <rojailal@gmail.com>\nRoni <sulpher@gmx.net>\nRonny Brendel <ronnybrendel@gmail.com>\nRonsor <ronsor@ronsor.pw>\nRowan Hart <rowanbhart@gmail.com>\nRuchira Hasaranga <ruchira66@gmail.com>\nRuixin Huang <18860020911@163.com>\nRune <43761327+Rune-AI@users.noreply.github.com>\nRunningLeon <maningsheng@sensetime.com>\nRunningLeon <mnsheng@yeah.net>\nRyan Landay <rlanday@gmail.com>\nRyder Wishart <ryderwishart@gmail.com>\nRyuei <louixs@users.noreply.github.com>\nRőczey Barnabás <31726601+An0nie@users.noreply.github.com>\nSRHMorris <69468379+SRHMorris@users.noreply.github.com>\nSXX <sxx1136965276@gmail.com>\nSakuraUmi <yukinon244@gmail.com>\nSalvador E. Tropea <stropea@inti.gob.ar>\nSalvatore Mesoraca <s.mesoraca16@gmail.com>\nSam Spilsbury <smspillaz@gmail.com>\nSami Farin <3876865+Safari77@users.noreply.github.com>\nSamuel Maynard <samwmaynard@gmail.com>\nSang-Kil Park <sang.park@42dot.ai>\nSeb C <47074056+Sebby37@users.noreply.github.com>\nSebastián A <sebastian.aedo29@gmail.com>\nSebastianApel <13675545+SebastianApel@users.noreply.github.com>\nSenemu <10880819+Senemu@users.noreply.github.com>\nSergey Alirzaev <zl29ah@gmail.com>\nSergio López <slp@redhat.com>\nSergio López <slp@sinrega.org>\nSertaç Özercan <852750+sozercan@users.noreply.github.com>\nSeungWon Jeong <65549245+redlion0929@users.noreply.github.com>\nShadovvBeast <ShadovvBeast@gmail.com>\nShakhar Dasgupta <shakhardasgupta@gmail.com>\nShane A <shanea@allenai.org>\nShangning Xu <32517059+xushangning@users.noreply.github.com>\nShankar <gshankar.87@gmail.com>\nShanshan Shen <467638484@qq.com>\nShijie <821898965@qq.com>\nShintarou Okada <kokuzen@gmail.com>\nShouzheng Liu <61452103+lshzh-ww@users.noreply.github.com>\nShouzheng Liu <lshzh.hi@gmail.com>\nShuichi Tsutsumi <shuichi0526@gmail.com>\nShupei Fan <dymarkfan@outlook.com>\nSigbjørn Skjæret <sigbjorn.skjaeret@scala.com>\nSimon Willison <swillison@gmail.com>\nSiwen Yu <yusiwen@gmail.com>\nSky Yan <skyan83@gmail.com>\nSlaren <2141330+slaren@users.noreply.github.com>\nSlava Primenko <primenko.s@gmail.com>\nSmall Grass Forest <zixuanxcl@gmail.com>\nSoftwareRenderer <138734813+SoftwareRenderer@users.noreply.github.com>\nSomeone <sergei.kozlukov@aalto.fi>\nSomeone Serge <sergei.kozlukov@aalto.fi>\nSourab Mangrulkar <13534540+pacman100@users.noreply.github.com>\nSpencer Sutton <spencersutton@users.noreply.github.com>\nSrihari-mcw <96763064+Srihari-mcw@users.noreply.github.com>\nSrinivas Billa <nivibilla@gmail.com>\nStefan Sydow <stefan@sydow.email>\nSteffen Röcker <sroecker@gmail.com>\nStephan Walter <stephan@walter.name>\nStephen Nichols <snichols@users.noreply.github.com>\nSteve Bonds <sbonds@gmail.com>\nSteve Grubb <ausearch.1@gmail.com>\nSteven Prichard <spprichard20@gmail.com>\nSteven Roussey <sroussey@gmail.com>\nSteward Garcia <57494570+FSSRepo@users.noreply.github.com>\nStrangeBytesDev <141275258+StrangeBytesDev@users.noreply.github.com>\nSuaj Carrot <72162667+SuajCarrot@users.noreply.github.com>\nSuperUserNameMan <yoann@terminajones.com>\nSutou Kouhei <kou@cozmixng.org>\nTai Duc Nguyen <taiducnguyen.drexel@gmail.com>\nTaikono-Himazin <kazu@po.harenet.ne.jp>\nTameem <113388789+AhmadTameem@users.noreply.github.com>\nTamotsu Takahashi <ttakah+github@gmail.com>\nThái Hoàng Tâm <75922889+RoyalHeart@users.noreply.github.com>\nThatcher Chamberlin <j.thatcher.c@gmail.com>\nTheia Vogel <theia@vgel.me>\nThérence <13496987+Royalphax@users.noreply.github.com>\nThibault Terrasson <thibault.terrasson@gmail.com>\nThomas Klausner <wiz@gatalith.at>\nThorsten Sommer <SommerEngineering@users.noreply.github.com>\nTim Miller <drasticactions@users.noreply.github.com>\nTim Wang <overocean@gmail.com>\nTimmy Knight <r2d2fish@gmail.com>\nTimothy Cronin <40186632+4imothy@users.noreply.github.com>\nTing Lou <ting.lou@gmail.com>\nTing Sun <suntcrick@gmail.com>\nTobias Lütke <tobi@shopify.com>\nTom C <tom.corelis@gmail.com>\nTom Jobbins <784313+TheBloke@users.noreply.github.com>\nTomas <tom.tomas.36478119@gmail.com>\nTomáš Pazdiora <tomas.pazdiora@gmail.com>\nTony Wasserka <4840017+neobrain@users.noreply.github.com>\nTristan Druyen <tristan@vault81.mozmail.com>\nTristan Ross <rosscomputerguy@protonmail.com>\nTrivikram Kamat <16024985+trivikr@users.noreply.github.com>\nTungsten842 <886724vf@anonaddy.me>\nTungsten842 <quantmint@protonmail.com>\nTushar <ditsuke@protonmail.com>\nUEXTM.com <84163508+uextm@users.noreply.github.com>\nUjjawal Panchal <31011628+Ujjawal-K-Panchal@users.noreply.github.com>\nUlrich Drepper <drepper@gmail.com>\nUzo Nweke <uzoechi@gmail.com>\nVaibhav Srivastav <vaibhavs10@gmail.com>\nVal Kharitonov <mail@kharvd.com>\nValentin Konovalov <valle.ketsujin@gmail.com>\nValentyn Bezshapkin <61702053+valentynbez@users.noreply.github.com>\nVali Malinoiu <0x4139@gmail.com>\nVictor Nogueira <felladrin@gmail.com>\nVictor Z. Peng <ziliangdotme@gmail.com>\nViet-Anh NGUYEN (Andrew) <vietanh.dev@gmail.com>\nVinesh Janarthanan <36610342+VJHack@users.noreply.github.com>\nVlad <spitfireage@gmail.com>\nVladimir <bogdad@gmail.com>\nVladimir Malyutin <first-leon@yandex.ru>\nVladimir Zorin <vladimir@deviant.guru>\nVoidIsVoid <343750470@qq.com>\nVolodymyr Vitvitskyi <72226+signalpillar@users.noreply.github.com>\nWangHaoranRobin <56047610+WangHaoranRobin@users.noreply.github.com>\nWeird Constructor <weirdconstructor@gmail.com>\nWelby Seely <welbyseely@gmail.com>\nWentai Zhang <rchardx@gmail.com>\nWillCorticesAI <150854901+WillCorticesAI@users.noreply.github.com>\nWilliam Tambellini <william.tambellini@gmail.com>\nWilly Tarreau <w@1wt.eu>\nWouter <9594229+DifferentialityDevelopment@users.noreply.github.com>\nWu Jian Ping <wujjpp@hotmail.com>\nWu Jian Ping <wujp@greatld.com>\nXiake Sun <xiake.sun@intel.com>\nXiang (Kevin) Li <kevinli020508@gmail.com>\nXiao-Yong Jin <jinxiaoyong@gmail.com>\nXiaotaoChen <chenxiaotao1234@gmail.com>\nXiaoyi Chen <cxychina@gmail.com>\nXie Yanbo <xieyanbo@gmail.com>\nXingchen Song(宋星辰) <xingchensong1996@163.com>\nXinpeng Dou <81913537+Dou-Git@users.noreply.github.com>\nXuan Son Nguyen <thichthat@gmail.com>\nYaiko <elyaiko@hotmail.com>\nYann Follet <131855179+YannFollet@users.noreply.github.com>\nYaroslav <yaroslav.yashin@me.com>\nYazan Agha-Schrader <mountaiin@icloud.com>\nYiming Cui <conandiy@vip.qq.com>\nYishuo Wang <MeouSker77@outlook.com>\nYoshi Suhara <y.suhara@gmail.com>\nYoshi Suhara <ysuhara@nvidia.com>\nYounes Belkada <49240599+younesbelkada@users.noreply.github.com>\nYueh-Po Peng <94939112+y10ab1@users.noreply.github.com>\nYui <dev@sleepyyui.com>\nYuri Khrustalev <ykhrustalev@users.noreply.github.com>\nYusuf Kağan Hanoğlu <hanoglu@yahoo.com>\nYuval Peled <31162840+Yuval-Peled@users.noreply.github.com>\nZHAOKAI WANG <sanxianwei@163.com>\nZane Shannon <z@zcs.me>\nZay <95888118+isaiahbjork@users.noreply.github.com>\nZenix <zenixls2@gmail.com>\nZhang Peiyuan <a1286225768@gmail.com>\nZheng.Deng <32841220+dengzheng-cloud@users.noreply.github.com>\nZhenwei Jin <109658203+kylo5aby@users.noreply.github.com>\nZhiyuan Li <lizhiyuan@uniartisan.com>\nZhouYuChen <zhouyuchen@naver.com>\nZiad Ben Hadj-Alouane <zied.benhadjalouane@gmail.com>\nZiang Wu <97337387+ZiangWu-77@users.noreply.github.com>\nZsapi <martin1.zsapka@gmail.com>\na-n-n-a-l-e-e <150648636+a-n-n-a-l-e-e@users.noreply.github.com>\nadel boussaken <netdur@gmail.com>\nafrideva <95653597+afrideva@users.noreply.github.com>\nagray3 <agray3@users.noreply.github.com>\nakawrykow <142945436+akawrykow@users.noreply.github.com>\nalexpinel <93524949+alexpinel@users.noreply.github.com>\nalonfaraj <alonfaraj@gmail.com>\nalwqx <kenan3015@gmail.com>\namd-lalithnc <lalithnc@amd.com>\namritahs-ibm <amritahs@linux.vnet.ibm.com>\nandrijdavid <david@geek.mg>\nanon998 <131767832+anon998@users.noreply.github.com>\nanzz1 <anzz1@live.com>\napaz <aarpazdera@gmail.com>\napcameron <37645737+apcameron@users.noreply.github.com>\narch-btw <57669023+arch-btw@users.noreply.github.com>\narcrank <arcrank@gmail.com>\nardfork <134447697+ardfork@users.noreply.github.com>\narlo-phoenix <140345165+arlo-phoenix@users.noreply.github.com>\nat8u <129688334+at8u@users.noreply.github.com>\nautomaticcat <daogiatuank54@gmail.com>\nawatuna <23447591+awatuna@users.noreply.github.com>\nb4b4o <zwbao@foxmail.com>\nbandoti <141645996+bandoti@users.noreply.github.com>\nbeiller <beiller@gmail.com>\nbhubbb <79117352+bhubbb@users.noreply.github.com>\nbmwl <brian.marshall@tolko.com>\nbobqianic <129547291+bobqianic@users.noreply.github.com>\nbrucepro <git@brucepro.net>\nbryanSwk <93190252+bryanSwk@users.noreply.github.com>\nbsilvereagle <bsilvereagle@users.noreply.github.com>\nbssrdf <merlintiger@hotmail.com>\nbyte-6174 <88070277+byte-6174@users.noreply.github.com>\ncebtenzzre <cebtenzzre@gmail.com>\nchaihahaha <chai836275709@gmail.com>\nchiranko <96988916+chiranko@users.noreply.github.com>\nclibdev <52199778+clibdev@users.noreply.github.com>\nclyang <clyang@clyang.net>\ncocktailpeanut <121128867+cocktailpeanut@users.noreply.github.com>\ncoezbek <c.oezbek@gmail.com>\ncomex <comexk@gmail.com>\ncompilade <113953597+compilade@users.noreply.github.com>\ncompilade <git@compilade.net>\ncpumaxx <163466046+cpumaxx@users.noreply.github.com>\ncrasm <crasm@git.vczf.net>\ncrasm <crasm@git.vczf.us>\ndaboe01 <daboe01@googlemail.com>\ndaghanerdonmez <44506702+daghanerdonmez@users.noreply.github.com>\ndaminho <37615795+daminho@users.noreply.github.com>\ndavid raistrick <keen99@users.noreply.github.com>\nddh0 <dylanhalladay02@icloud.com>\nddpasa <112642920+ddpasa@users.noreply.github.com>\ndeepdiffuser <112834445+deepdiffuser@users.noreply.github.com>\ndevojony <61173062+devojony@users.noreply.github.com>\nditsuke <ditsuke@protonmail.com>\ndivinity76 <divinity76@gmail.com>\ndm4 <sunrisedm4@gmail.com>\ndotpy314 <33351922+dotpy314@users.noreply.github.com>\ndrbh <david.richard.holtz@gmail.com>\nds5t5 <145942675+ds5t5@users.noreply.github.com>\ndylan <canardleteer@users.noreply.github.com>\neastriver <lee@eastriver.dev>\nebraminio <ebraminio@gmail.com>\neiery <19350831+eiery@users.noreply.github.com>\neric8607242 <e0928021388@gmail.com>\nfairydreaming <166155368+fairydreaming@users.noreply.github.com>\nfengerhu1 <2748250768@qq.com>\nfraxy-v <65565042+fraxy-v@users.noreply.github.com>\ngithub-actions[bot] <github-actions[bot]@users.noreply.github.com>\ngliptic <gliptic@users.noreply.github.com>\ngoerch <jhr.walter@t-online.de>\ngrahameth <96447521+grahameth@users.noreply.github.com>\ngtygo <gtydoit@gmail.com>\ngwjr <502526+gwjr@users.noreply.github.com>\nh-h-h-h <13482553+h-h-h-h@users.noreply.github.com>\nhankcs <cnhankmc@gmail.com>\nhaopeng <657407891@qq.com>\nhipudding <huafengchun@gmail.com>\nhoangmit <hoangmit@users.noreply.github.com>\nhongbo.mo <352280764@qq.com>\nhopkins385 <98618192+hopkins385@users.noreply.github.com>\nhowlger <eclipse@voormann.de>\nhowlger <github@voormann.de>\nhutli <6594598+hutli@users.noreply.github.com>\nhutli <hutli@hutli.hu>\nhutli <jensstaermose@hotmail.com>\nhxer7963 <hxer7963@gmail.com>\nhydai <z54981220@gmail.com>\niSma <ismail.senhaji@gmail.com>\niacore <74560659+iacore@users.noreply.github.com>\nicppWorld <124377669+icppWorld@users.noreply.github.com>\nigarnier <igarnier@protonmail.com>\nintelmatt <61025942+intelmatt@users.noreply.github.com>\niohub <rickyang.pro@gmail.com>\njacobi petrucciani <8117202+jpetrucciani@users.noreply.github.com>\njaime-m-p <167997752+jaime-m-p@users.noreply.github.com>\njameswu2014 <545426914@qq.com>\njdomke <28772296+jdomke@users.noreply.github.com>\njiez <373447296@qq.com>\njneem <joeneeman@gmail.com>\njoecryptotoo <80373433+joecryptotoo@users.noreply.github.com>\njohnson442 <56517414+johnson442@users.noreply.github.com>\njojorne <jojorne@users.noreply.github.com>\njon-chuang <9093549+jon-chuang@users.noreply.github.com>\njp-x-g <jpxg-dev@protonmail.com>\njukofyork <69222624+jukofyork@users.noreply.github.com>\njunchao-loongson <68935141+junchao-loongson@users.noreply.github.com>\njwj7140 <32943891+jwj7140@users.noreply.github.com>\nk.h.lai <adrian.k.h.lai@outlook.com>\nkaizau <kaizau@users.noreply.github.com>\nkalomaze <66376113+kalomaze@users.noreply.github.com>\nkang <tpdns9032100@gmail.com>\nkatsu560 <118887472+katsu560@users.noreply.github.com>\nkchro3 <62481661+kchro3@users.noreply.github.com>\nkhimaros <me@khimaros.com>\nkiltyj <kiltyj@gmail.com>\nklosax <131523366+klosax@users.noreply.github.com>\nkunal-vaishnavi <115581922+kunal-vaishnavi@users.noreply.github.com>\nkunnis <kunnis@users.noreply.github.com>\nkuronekosaiko <EvanChanJ@163.com>\nkustaaya <58045274+kustaaya@users.noreply.github.com>\nkuvaus <22169537+kuvaus@users.noreply.github.com>\nkwin1412 <42286931+kwin1412@users.noreply.github.com>\nl3utterfly <gc.pthzfoldr@gmail.com>\nlaik <laik.lj@me.com>\nldwang <ftgreat@163.com>\nle.chang <cljs118@126.com>\nleejet <leejet714@gmail.com>\nleo-pony <nengjunma@outlook.com>\nlimitedAtonement <limitedAtonement@users.noreply.github.com>\nliuwei-git <14815172+liuwei-git@users.noreply.github.com>\nlon <114724657+longregen@users.noreply.github.com>\nloonerin <132926317+loonerin@users.noreply.github.com>\nltoniazzi <61414566+ltoniazzi@users.noreply.github.com>\nluoyu-intel <yu.luo@intel.com>\nm3ndax <adrian.goessl@outlook.com>\nmaddes8cht <55592906+maddes8cht@users.noreply.github.com>\nmakomk <makosoft@googlemail.com>\nmanikbhandari <mbbhandarimanik2@gmail.com>\nmaor-ps <154728172+maor-ps@users.noreply.github.com>\nmatiaslin <45382001+matiaslin@users.noreply.github.com>\nmatteo <matteogeniaccio@yahoo.it>\nmdrokz <mohammadmunshi@gmail.com>\nmgroeber9110 <45620825+mgroeber9110@users.noreply.github.com>\nminarchist <minarchist@users.noreply.github.com>\nmj-shifu <77107165+mj-shifu@users.noreply.github.com>\nmmyjona <jonathan.gonse@gmail.com>\nmomonga <115213907+mmnga@users.noreply.github.com>\nmomonga <146910567+mmngays@users.noreply.github.com>\nmoritzbrantner <31051084+moritzbrantner@users.noreply.github.com>\nmzcu <milos.cubrilo@gmail.com>\nnanahi <130121847+na-na-hi@users.noreply.github.com>\nngc92 <7938269+ngc92@users.noreply.github.com>\nnhamanasu <45545786+nhamanasu@users.noreply.github.com>\nniansa/tuxifan <anton-sa@web.de>\nniansa/tuxifan <tuxifan@posteo.de>\nnickp27 <nb.porter@gmail.com>\nningshanwutuobang <ningshanwutuobang@gmail.com>\nnold <Nold360@users.noreply.github.com>\nnopperl <54780682+nopperl@users.noreply.github.com>\nnusu-github <29514220+nusu-github@users.noreply.github.com>\nolexiyb <olexiyb@gmail.com>\nomahs <73983677+omahs@users.noreply.github.com>\noobabooga <112222186+oobabooga@users.noreply.github.com>\nopparco <parco.opaai@gmail.com>\nostix360 <55257054+ostix360@users.noreply.github.com>\npculliton <phillipculliton@gmail.com>\npengxin99 <pengxin.yuan@intel.com>\nperserk <perserk@gmail.com>\npiDack <104877312+piDack@users.noreply.github.com>\npmysl <piotr.myslinski@outlook.com>\npostmasters <namnguyen@google.com>\npudepiedj <pudepiedj@gmail.com>\nqingfengfenga <41416092+qingfengfenga@users.noreply.github.com>\nqouoq <qouoq@fastmail.com>\nqunash <anzoria@gmail.com>\nrabidcopy <rabidcopy@yahoo.com>\nrankaiyx <rankaiyx@rankaiyx.com>\nrhjdvsgsgks <26178113+rhjdvsgsgks@users.noreply.github.com>\nrhuddleston <ryan.huddleston@percona.com>\nrimoliga <53384203+rimoliga@users.noreply.github.com>\nrunfuture <runfuture@users.noreply.github.com>\nsandyiscool <sandyiscool@gmail.com>\nsasha0552 <admin@sasha0552.org>\nsemidark <me@semidark.net>\nserhii-nakon <57632032+serhii-nakon@users.noreply.github.com>\nsharpHL <132747147+sharpHL@users.noreply.github.com>\nshibe2 <shibe@tuta.io>\nsingularity <12184989+singularity-s0@users.noreply.github.com>\nsjinzh <sjinzh@gmail.com>\nsjxx <63994076+ylsdamxssjxxdd@users.noreply.github.com>\nslaren <2141330+slaren@users.noreply.github.com>\nslaren <slarengh@gmail.com>\nsnadampal <87143774+snadampal@users.noreply.github.com>\nstandby24x7 <standby24x7@gmail.com>\nstaviq <staviq@gmail.com>\nstduhpf <stephduh@live.fr>\nstrawberrymelonpanda <152940198+strawberrymelonpanda@users.noreply.github.com>\nswittk <switt1995@gmail.com>\ntakov751 <40316768+takov751@users.noreply.github.com>\ntarcey <cey.tarik@gmail.com>\ntc-mb <157115220+tc-mb@users.noreply.github.com>\ntexmex76 <40733439+texmex76@users.noreply.github.com>\nthement <40525767+thement@users.noreply.github.com>\nthewh1teagle <61390950+thewh1teagle@users.noreply.github.com>\ntjohnman <tjohnman@users.noreply.github.com>\ntoyer <2042519524@qq.com>\ntslmy <tslmy@users.noreply.github.com>\nubik2 <ubik2@users.noreply.github.com>\nuint256_t <konndennsa@gmail.com>\nuint256_t <maekawatoshiki1017@gmail.com>\nunbounded <haakon@likedan.net>\nuvos <devnull@uvos.xyz>\nvaliray <133289098+valiray@users.noreply.github.com>\nvb <vaibhavs10@gmail.com>\nvik <vikhyatk@gmail.com>\nviric <viric@viric.name>\nvodkaslime <646329483@qq.com>\nvvhg1 <94630311+vvhg1@users.noreply.github.com>\nvxiiduu <73044267+vxiiduu@users.noreply.github.com>\nwangshuai09 <391746016@qq.com>\nwbpxre150 <100937007+wbpxre150@users.noreply.github.com>\nwhoreson <139810751+whoreson@users.noreply.github.com>\nwoachk <24752637+woachk@users.noreply.github.com>\nwonjun Jang <strutive07@gmail.com>\nwoodx <124784234+woodx9@users.noreply.github.com>\nwwoodsTM <104587230+wwoodsTM@users.noreply.github.com>\nwzy <32936898+Freed-Wu@users.noreply.github.com>\nxaedes <xaedes@gmail.com>\nxaedes <xaedes@googlemail.com>\nxctan <axunlei@gmail.com>\nxloem <0xloem@gmail.com>\nyangli2 <yangli2@gmail.com>\nyuiseki <yuiseki@gmail.com>\nyuri@FreeBSD <yurivict@users.noreply.github.com>\nzakkor <edward.partenie@gmail.com>\nzhangkaihuo <zhangkaihuo@gmail.com>\nzhentaoyu <zhentao.yu@intel.com>\nzhouwg <6889919+zhouwg@users.noreply.github.com>\nzhouwg <zhouwg2000@gmail.com>\nzrm <trustiosity.zrm@gmail.com>\nȘtefan-Gabriel Muscalu <legraphista@users.noreply.github.com>\n杨朱 · Kiki <baofa.fan@daocloud.io>\n源文雨 <41315874+fumiama@users.noreply.github.com>\n蕭澧邦 <45505768+shou692199@users.noreply.github.com>\nНияз Гарифзянов <112617865+garrnizon@users.noreply.github.com>\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 6.9267578125,
          "content": "cmake_minimum_required(VERSION 3.14) # for add_link_options and implicit target directories.\nproject(\"llama.cpp\" C CXX)\ninclude(CheckIncludeFileCXX)\n\n#set(CMAKE_WARN_DEPRECATED YES)\nset(CMAKE_WARN_UNUSED_CLI YES)\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\nif (NOT XCODE AND NOT MSVC AND NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE Release CACHE STRING \"Build type\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\")\nendif()\n\n# Add path to modules\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/\")\n\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n\nif (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)\n    set(LLAMA_STANDALONE ON)\n\n    include(git-vars)\n\n    # configure project version\n    # TODO\nelse()\n    set(LLAMA_STANDALONE OFF)\nendif()\n\nif (EMSCRIPTEN)\n    set(BUILD_SHARED_LIBS_DEFAULT OFF)\n\n    option(LLAMA_WASM_SINGLE_FILE \"llama: embed WASM inside the generated llama.js\" ON)\nelse()\n    if (MINGW)\n        set(BUILD_SHARED_LIBS_DEFAULT OFF)\n    else()\n        set(BUILD_SHARED_LIBS_DEFAULT ON)\n    endif()\nendif()\n\noption(BUILD_SHARED_LIBS \"build shared libraries\" ${BUILD_SHARED_LIBS_DEFAULT})\n\nif (WIN32)\n    add_compile_definitions(_CRT_SECURE_NO_WARNINGS)\nendif()\n\nif (MSVC)\n    add_compile_options(\"$<$<COMPILE_LANGUAGE:C>:/utf-8>\")\n    add_compile_options(\"$<$<COMPILE_LANGUAGE:CXX>:/utf-8>\")\nendif()\n\n#\n# option list\n#\n\n# debug\noption(LLAMA_ALL_WARNINGS           \"llama: enable all compiler warnings\"                   ON)\noption(LLAMA_ALL_WARNINGS_3RD_PARTY \"llama: enable all compiler warnings in 3rd party libs\" OFF)\n\n# build\noption(LLAMA_FATAL_WARNINGS \"llama: enable -Werror flag\" OFF)\n\n# sanitizers\noption(LLAMA_SANITIZE_THREAD    \"llama: enable thread sanitizer\"    OFF)\noption(LLAMA_SANITIZE_ADDRESS   \"llama: enable address sanitizer\"   OFF)\noption(LLAMA_SANITIZE_UNDEFINED \"llama: enable undefined sanitizer\" OFF)\n\n# utils\noption(LLAMA_BUILD_COMMON \"llama: build common utils library\" ${LLAMA_STANDALONE})\n\n# extra artifacts\noption(LLAMA_BUILD_TESTS    \"llama: build tests\"          ${LLAMA_STANDALONE})\noption(LLAMA_BUILD_EXAMPLES \"llama: build examples\"       ${LLAMA_STANDALONE})\noption(LLAMA_BUILD_SERVER   \"llama: build server example\" ${LLAMA_STANDALONE})\n\n# 3rd party libs\noption(LLAMA_CURL \"llama: use libcurl to download model from an URL\" OFF)\n\n# Required for relocatable CMake package\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/cmake/build-info.cmake)\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/cmake/common.cmake)\n\n# override ggml options\nset(GGML_SANITIZE_THREAD    ${LLAMA_SANITIZE_THREAD})\nset(GGML_SANITIZE_ADDRESS   ${LLAMA_SANITIZE_ADDRESS})\nset(GGML_SANITIZE_UNDEFINED ${LLAMA_SANITIZE_UNDEFINED})\nset(GGML_ALL_WARNINGS       ${LLAMA_ALL_WARNINGS})\nset(GGML_FATAL_WARNINGS     ${LLAMA_FATAL_WARNINGS})\n\n# change the default for these ggml options\nif (NOT DEFINED GGML_LLAMAFILE)\n    set(GGML_LLAMAFILE_DEFAULT ON)\nendif()\n\nif (NOT DEFINED GGML_CUDA_GRAPHS)\n    set(GGML_CUDA_GRAPHS_DEFAULT ON)\nendif()\n\n# transition helpers\nfunction (llama_option_depr TYPE OLD NEW)\n    if (${OLD})\n        message(${TYPE} \"${OLD} is deprecated and will be removed in the future.\\nUse ${NEW} instead\\n\")\n        set(${NEW} ON PARENT_SCOPE)\n    endif()\nendfunction()\n\nllama_option_depr(FATAL_ERROR LLAMA_CUBLAS              GGML_CUDA)\nllama_option_depr(WARNING     LLAMA_CUDA                GGML_CUDA)\nllama_option_depr(WARNING     LLAMA_KOMPUTE             GGML_KOMPUTE)\nllama_option_depr(WARNING     LLAMA_METAL               GGML_METAL)\nllama_option_depr(WARNING     LLAMA_METAL_EMBED_LIBRARY GGML_METAL_EMBED_LIBRARY)\nllama_option_depr(WARNING     LLAMA_NATIVE              GGML_NATIVE)\nllama_option_depr(WARNING     LLAMA_RPC                 GGML_RPC)\nllama_option_depr(WARNING     LLAMA_SYCL                GGML_SYCL)\nllama_option_depr(WARNING     LLAMA_SYCL_F16            GGML_SYCL_F16)\nllama_option_depr(WARNING     LLAMA_CANN                GGML_CANN)\n\n#\n# build the library\n#\n\nif (NOT TARGET ggml)\n    add_subdirectory(ggml)\n    # ... otherwise assume ggml is added by a parent CMakeLists.txt\nendif()\nadd_subdirectory(src)\n\n#\n# install\n#\n\ninclude(GNUInstallDirs)\ninclude(CMakePackageConfigHelpers)\n\nset(LLAMA_BUILD_NUMBER        ${BUILD_NUMBER})\nset(LLAMA_BUILD_COMMIT        ${BUILD_COMMIT})\nset(LLAMA_INSTALL_VERSION 0.0.${BUILD_NUMBER})\n\nset(LLAMA_INCLUDE_INSTALL_DIR ${CMAKE_INSTALL_INCLUDEDIR} CACHE PATH \"Location of header  files\")\nset(LLAMA_LIB_INSTALL_DIR     ${CMAKE_INSTALL_LIBDIR}     CACHE PATH \"Location of library files\")\nset(LLAMA_BIN_INSTALL_DIR     ${CMAKE_INSTALL_BINDIR}     CACHE PATH \"Location of binary  files\")\n\n# At the moment some compile definitions are placed within the ggml/src\n# directory but not exported on the `ggml` target. This could be improved by\n# determining _precisely_ which defines are necessary for the llama-config\n# package.\n#\nset(GGML_TRANSIENT_DEFINES)\nget_target_property(GGML_DIRECTORY ggml SOURCE_DIR)\nget_directory_property(GGML_DIR_DEFINES DIRECTORY ${GGML_DIRECTORY} COMPILE_DEFINITIONS)\nif (GGML_DIR_DEFINES)\n    list(APPEND GGML_TRANSIENT_DEFINES ${GGML_DIR_DEFINES})\nendif()\nget_target_property(GGML_TARGET_DEFINES ggml COMPILE_DEFINITIONS)\nif (GGML_TARGET_DEFINES)\n    list(APPEND GGML_TRANSIENT_DEFINES ${GGML_TARGET_DEFINES})\nendif()\nget_target_property(GGML_LINK_LIBRARIES ggml LINK_LIBRARIES)\n# all public headers\nset(LLAMA_PUBLIC_HEADERS\n    ${CMAKE_CURRENT_SOURCE_DIR}/include/llama.h\n    ${CMAKE_CURRENT_SOURCE_DIR}/include/llama-cpp.h)\nset_target_properties(llama PROPERTIES PUBLIC_HEADER \"${LLAMA_PUBLIC_HEADERS}\")\ninstall(TARGETS llama LIBRARY PUBLIC_HEADER)\n\nconfigure_package_config_file(\n        ${CMAKE_CURRENT_SOURCE_DIR}/cmake/llama-config.cmake.in\n        ${CMAKE_CURRENT_BINARY_DIR}/llama-config.cmake\n    INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/llama\n    PATH_VARS LLAMA_INCLUDE_INSTALL_DIR\n              LLAMA_LIB_INSTALL_DIR\n              LLAMA_BIN_INSTALL_DIR )\n\nwrite_basic_package_version_file(\n        ${CMAKE_CURRENT_BINARY_DIR}/llama-version.cmake\n    VERSION ${LLAMA_INSTALL_VERSION}\n    COMPATIBILITY SameMajorVersion)\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/llama-config.cmake\n              ${CMAKE_CURRENT_BINARY_DIR}/llama-version.cmake\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/llama)\n\ninstall(\n    FILES convert_hf_to_gguf.py\n    PERMISSIONS\n        OWNER_READ\n        OWNER_WRITE\n        OWNER_EXECUTE\n        GROUP_READ\n        GROUP_EXECUTE\n        WORLD_READ\n        WORLD_EXECUTE\n    DESTINATION ${CMAKE_INSTALL_BINDIR})\n\nconfigure_file(cmake/llama.pc.in\n        \"${CMAKE_CURRENT_BINARY_DIR}/llama.pc\"\n        @ONLY)\n\ninstall(FILES \"${CMAKE_CURRENT_BINARY_DIR}/llama.pc\"\n        DESTINATION lib/pkgconfig)\n\n#\n# utils, programs, examples and tests\n#\n\nif (LLAMA_BUILD_COMMON)\n    add_subdirectory(common)\nendif()\n\nif (LLAMA_BUILD_COMMON AND LLAMA_BUILD_TESTS AND NOT CMAKE_JS_VERSION)\n    include(CTest)\n    add_subdirectory(tests)\nendif()\n\nif (LLAMA_BUILD_COMMON AND LLAMA_BUILD_EXAMPLES)\n    add_subdirectory(examples)\n    add_subdirectory(pocs)\nendif()\n"
        },
        {
          "name": "CMakePresets.json",
          "type": "blob",
          "size": 4.55859375,
          "content": "{\n  \"version\": 4,\n  \"configurePresets\": [\n    {\n        \"name\":  \"base\",\n        \"hidden\": true,\n        \"generator\":   \"Ninja\",\n        \"binaryDir\":   \"${sourceDir}/build-${presetName}\",\n        \"cacheVariables\": {\n            \"CMAKE_EXPORT_COMPILE_COMMANDS\": \"ON\",\n            \"CMAKE_INSTALL_RPATH\": \"$ORIGIN;$ORIGIN/..\"\n        }\n    },\n    {\n        \"name\": \"sycl-base\",\n        \"hidden\": true,\n        \"generator\": \"Ninja\",\n        \"binaryDir\": \"${sourceDir}/build-${presetName}\",\n        \"cacheVariables\": {\n            \"CMAKE_EXPORT_COMPILE_COMMANDS\": \"ON\",\n            \"CMAKE_CXX_COMPILER\": \"icx\",\n            \"CMAKE_C_COMPILER\": \"cl\",\n            \"GGML_SYCL\": \"ON\",\n            \"CMAKE_INSTALL_RPATH\": \"$ORIGIN;$ORIGIN/..\"\n        }\n    },\n    { \"name\": \"debug\",    \"hidden\": true, \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Debug\" } },\n    { \"name\": \"release\",  \"hidden\": true, \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Release\" } },\n    { \"name\": \"reldbg\",   \"hidden\": true, \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"RelWithDebInfo\" } },\n    { \"name\": \"static\",   \"hidden\": true, \"cacheVariables\": { \"GGML_STATIC\":      \"ON\" } },\n    { \"name\": \"sycl_f16\", \"hidden\": true, \"cacheVariables\": { \"GGML_SYCL_F16\":    \"ON\" } },\n    { \"name\": \"vulkan\",   \"hidden\": true, \"cacheVariables\": { \"GGML_VULKAN\":      \"ON\" } },\n\n    {\n        \"name\": \"x64-windows-llvm\", \"hidden\": true,\n        \"cacheVariables\": {\n            \"CMAKE_TOOLCHAIN_FILE\": \"${sourceDir}/cmake/x64-windows-llvm.cmake\"\n        }\n    },\n\n    {\n        \"name\": \"arm64-windows-msvc\", \"hidden\": true,\n        \"architecture\": { \"value\": \"arm64\",    \"strategy\": \"external\" },\n        \"toolset\":      { \"value\": \"host=x64\", \"strategy\": \"external\" },\n        \"cacheVariables\": {\n            \"CMAKE_TOOLCHAIN_FILE\": \"${sourceDir}/cmake/arm64-windows-msvc.cmake\"\n        }\n    },\n\n    {\n        \"name\": \"arm64-windows-llvm\", \"hidden\": true,\n        \"architecture\": { \"value\": \"arm64\",    \"strategy\": \"external\" },\n        \"toolset\":      { \"value\": \"host=x64\", \"strategy\": \"external\" },\n        \"cacheVariables\": {\n            \"CMAKE_TOOLCHAIN_FILE\": \"${sourceDir}/cmake/arm64-windows-llvm.cmake\"\n        }\n    },\n\n    {\n        \"name\": \"arm64-apple-clang\", \"hidden\": true,\n        \"architecture\": { \"value\": \"arm64\",    \"strategy\": \"external\" },\n        \"toolset\":      { \"value\": \"host=x64\", \"strategy\": \"external\" },\n        \"cacheVariables\": {\n            \"CMAKE_TOOLCHAIN_FILE\": \"${sourceDir}/cmake/arm64-apple-clang.cmake\"\n        }\n    },\n\n    { \"name\": \"arm64-windows-llvm-debug\", \"inherits\": [ \"base\", \"arm64-windows-llvm\", \"debug\" ] },\n    { \"name\": \"arm64-windows-llvm-release\", \"inherits\": [ \"base\", \"arm64-windows-llvm\", \"reldbg\" ] },\n    { \"name\": \"arm64-windows-llvm+static-release\", \"inherits\": [ \"base\", \"arm64-windows-llvm\", \"reldbg\", \"static\" ] },\n\n    { \"name\": \"arm64-apple-clang-debug\", \"inherits\": [ \"base\", \"arm64-apple-clang\", \"debug\" ] },\n    { \"name\": \"arm64-apple-clang-release\", \"inherits\": [ \"base\", \"arm64-apple-clang\", \"reldbg\" ] },\n    { \"name\": \"arm64-apple-clang+static-release\", \"inherits\": [ \"base\", \"arm64-apple-clang\",  \"reldbg\", \"static\" ] },\n\n    { \"name\": \"arm64-windows-msvc-debug\", \"inherits\": [ \"base\", \"arm64-windows-msvc\",  \"debug\"   ] },\n    { \"name\": \"arm64-windows-msvc-release\", \"inherits\": [ \"base\", \"arm64-windows-msvc\",  \"reldbg\" ] },\n    { \"name\": \"arm64-windows-msvc+static-release\", \"inherits\": [ \"base\", \"arm64-windows-msvc\",  \"reldbg\", \"static\" ] },\n\n    { \"name\": \"x64-windows-llvm-debug\", \"inherits\": [ \"base\", \"x64-windows-llvm\", \"debug\" ] },\n    { \"name\": \"x64-windows-llvm-release\", \"inherits\": [ \"base\", \"x64-windows-llvm\", \"release\" ] },\n    { \"name\": \"x64-windows-llvm-reldbg\", \"inherits\": [ \"base\", \"x64-windows-llvm\", \"reldbg\" ] },\n    { \"name\": \"x64-windows-llvm+static-release\", \"inherits\": [ \"base\", \"x64-windows-llvm\", \"reldbg\", \"static\" ] },\n\n    { \"name\": \"x64-windows-msvc-debug\", \"inherits\": [ \"base\", \"debug\" ] },\n    { \"name\": \"x64-windows-msvc-release\", \"inherits\": [ \"base\", \"reldbg\" ] },\n    { \"name\": \"x64-windows-msvc+static-release\", \"inherits\": [ \"base\", \"reldbg\", \"static\" ] },\n\n    { \"name\": \"x64-windows-sycl-debug\", \"inherits\": [ \"sycl-base\", \"debug\" ] },\n    { \"name\": \"x64-windows-sycl-debug-f16\", \"inherits\": [ \"sycl-base\", \"debug\", \"sycl_f16\" ] },\n    { \"name\": \"x64-windows-sycl-release\", \"inherits\": [ \"sycl-base\", \"release\" ] },\n    { \"name\": \"x64-windows-sycl-release-f16\", \"inherits\": [ \"sycl-base\", \"release\", \"sycl_f16\" ] },\n\n    { \"name\": \"x64-windows-vulkan-debug\", \"inherits\": [ \"base\", \"vulkan\", \"debug\" ] },\n    { \"name\": \"x64-windows-vulkan-release\", \"inherits\": [ \"base\", \"vulkan\", \"release\" ] }\n  ]\n}\n"
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 0.4267578125,
          "content": "# collaborators can optionally add themselves here to indicate their availability for reviewing related PRs\n\n/ci/ @ggerganov\n/.devops/*.Dockerfile @ngxson\n/examples/server/ @ngxson\n/ggml/src/ggml-cuda/fattn* @JohannesGaessler\n/ggml/src/ggml-cuda/mmq.* @JohannesGaessler\n/ggml/src/ggml-cuda/mmv.* @JohannesGaessler\n/ggml/src/ggml-cuda/mmvq.* @JohannesGaessler\n/ggml/src/ggml-opt.cpp @JohannesGaessler\n/ggml/src/gguf.cpp @JohannesGaessler\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.4638671875,
          "content": "# Pull requests (for contributors)\n\n- Test your changes:\n  - Execute [the full CI locally on your machine](ci/README.md) before publishing\n  - Verify that the perplexity and the performance are not affected negatively by your changes (use `llama-perplexity` and `llama-bench`)\n  - If you modified the `ggml` source, run the `test-backend-ops` tool to check whether different backend implementations of the `ggml` operators produce consistent results (this requires access to at least two different `ggml` backends)\n  - If you modified a `ggml` operator or added a new one, add the corresponding test cases to `test-backend-ops`\n- Consider allowing write access to your branch for faster reviews, as reviewers can push commits directly\n- If your PR becomes stale, don't hesitate to ping the maintainers in the comments\n\n# Pull requests (for collaborators)\n\n- Squash-merge PRs\n- Use the following format for the squashed commit title: `<module> : <commit title> (#<issue_number>)`. For example: `utils : fix typo in utils.py (#1234)`\n- Optionally pick a `<module>` from here: https://github.com/ggerganov/llama.cpp/wiki/Modules\n- Consider adding yourself to [CODEOWNERS](CODEOWNERS)\n\n# Coding guidelines\n\n- Avoid adding third-party dependencies, extra files, extra headers, etc.\n- Always consider cross-compatibility with other operating systems and architectures\n- Avoid fancy-looking modern STL constructs, use basic `for` loops, avoid templates, keep it simple\n- There are no strict rules for the code style, but try to follow the patterns in the code (indentation, spaces, etc.). Vertical alignment makes things more readable and easier to batch edit\n- Clean-up any trailing whitespaces, use 4 spaces for indentation, brackets on the same line, `void * ptr`, `int & a`\n- Naming usually optimizes for common prefix (see https://github.com/ggerganov/ggml/pull/302#discussion_r1243240963)\n- Tensors store data in row-major order. We refer to dimension 0 as columns, 1 as rows, 2 as matrices\n- Matrix multiplication is unconventional: [`C = ggml_mul_mat(ctx, A, B)`](https://github.com/ggerganov/llama.cpp/blob/880e352277fc017df4d5794f0c21c44e1eae2b84/ggml.h#L1058-L1064) means $C^T = A B^T \\Leftrightarrow C = B A^T.$\n\n![matmul](media/matmul.png)\n\n# Resources\n\nThe Github issues, PRs and discussions contain a lot of information that can be useful to get familiar with the codebase. For convenience, some of the more important information is referenced from Github projects:\n\nhttps://github.com/ggerganov/llama.cpp/projects\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "MIT License\n\nCopyright (c) 2023-2024 The ggml authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 49.1142578125,
          "content": "ifndef LLAMA_MAKEFILE\n$(error The Makefile build is deprecated. Use the CMake build instead. For more details, see https://github.com/ggerganov/llama.cpp/blob/master/docs/build.md)\nendif\n\n# Define the default target now so that it is always the first target\nBUILD_TARGETS = \\\n\tlibllava.a \\\n\tllama-batched \\\n\tllama-batched-bench \\\n\tllama-bench \\\n\tllama-cli \\\n\tllama-convert-llama2c-to-ggml \\\n\tllama-embedding \\\n\tllama-eval-callback \\\n\tllama-export-lora \\\n\tllama-gbnf-validator \\\n\tllama-gguf \\\n\tllama-gguf-hash \\\n\tllama-gguf-split \\\n\tllama-gritlm \\\n\tllama-imatrix \\\n\tllama-infill \\\n\tllama-llava-cli \\\n\tllama-minicpmv-cli\\\n\tllama-qwen2vl-cli\\\n\tllama-lookahead \\\n\tllama-lookup \\\n\tllama-lookup-create \\\n\tllama-lookup-merge \\\n\tllama-lookup-stats \\\n\tllama-parallel \\\n\tllama-passkey \\\n\tllama-perplexity \\\n\tllama-q8dot \\\n\tllama-quantize \\\n\tllama-quantize-stats \\\n\tllama-retrieval \\\n\tllama-save-load-state \\\n\tllama-server \\\n\tllama-simple \\\n\tllama-simple-chat \\\n\tllama-run \\\n\tllama-speculative \\\n\tllama-tokenize \\\n\tllama-vdot \\\n\tllama-cvector-generator \\\n\tllama-gen-docs \\\n\ttests/test-c.o\n\n# Binaries only useful for tests\nTEST_TARGETS = \\\n\ttests/test-arg-parser \\\n\ttests/test-autorelease \\\n\ttests/test-backend-ops \\\n\ttests/test-chat-template \\\n\ttests/test-double-float \\\n\ttests/test-grammar-integration \\\n\ttests/test-grammar-parser \\\n\ttests/test-json-schema-to-grammar \\\n\ttests/test-llama-grammar \\\n\ttests/test-log \\\n\ttests/test-model-load-cancel \\\n\ttests/test-quantize-fns \\\n\ttests/test-quantize-perf \\\n\ttests/test-rope \\\n\ttests/test-sampling \\\n\ttests/test-tokenizer-0 \\\n\ttests/test-tokenizer-1-bpe \\\n\ttests/test-tokenizer-1-spm\n#\ttests/test-opt \\\n\n# Legacy build targets that were renamed in #7809, but should still be removed when the project is cleaned\nLEGACY_TARGETS_CLEAN = main quantize quantize-stats perplexity imatrix embedding vdot q8dot convert-llama2c-to-ggml \\\n\tsimple batched batched-bench save-load-state server gguf gguf-split eval-callback llama-bench libllava.a llava-cli baby-llama \\\n\tretrieval speculative infill tokenize parallel export-lora lookahead lookup passkey gritlm\n\n# Legacy build targets that were renamed in #7809, but we want to build binaries that for them that output a deprecation warning if people try to use them.\n#  We don't want to clutter things too much, so we only build replacements for the most commonly used binaries.\nLEGACY_TARGETS_BUILD = main quantize perplexity embedding server\n\n# Deprecation aliases\nifdef LLAMA_CUBLAS\n$(error LLAMA_CUBLAS is removed. Use GGML_CUDA instead.)\nendif\n\nifdef LLAMA_CUDA\nGGML_CUDA := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_KOMPUTE\nGGML_KOMPUTE := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_METAL\nGGML_METAL := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_RPC\nGGML_RPC := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_SYCL\nGGML_SYCL := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_SYCL_F16\nGGML_SYCL_F16 := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_OPENBLAS\nGGML_OPENBLAS := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_OPENBLAS64\nGGML_OPENBLAS64 := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_BLIS\nGGML_BLIS := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_NO_LLAMAFILE\nGGML_NO_LLAMAFILE := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_NO_ACCELERATE\nGGML_NO_ACCELERATE := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_NO_OPENMP\nGGML_NO_OPENMP := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_NO_METAL\nGGML_NO_METAL := 1\nDEPRECATE_WARNING := 1\nendif\n\nifdef LLAMA_DISABLE_LOGS\nREMOVE_WARNING := 1\nendif\n\nifdef LLAMA_SERVER_VERBOSE\nREMOVE_WARNING := 1\nendif\n\nifndef UNAME_S\nUNAME_S := $(shell uname -s)\nendif\n\nifndef UNAME_P\nUNAME_P := $(shell uname -p)\nendif\n\nifndef UNAME_M\nUNAME_M := $(shell uname -m)\nendif\n\n# In GNU make default CXX is g++ instead of c++.  Let's fix that so that users\n# of non-gcc compilers don't have to provide g++ alias or wrapper.\nDEFCC  := cc\nDEFCXX := c++\nifeq ($(origin CC),default)\nCC  := $(DEFCC)\nendif\nifeq ($(origin CXX),default)\nCXX := $(DEFCXX)\nendif\n\n# Mac OS + Arm can report x86_64\n# ref: https://github.com/ggerganov/whisper.cpp/issues/66#issuecomment-1282546789\nifeq ($(UNAME_S),Darwin)\n\tifndef GGML_NO_METAL\n\t\tGGML_METAL := 1\n\tendif\n\n\tGGML_NO_OPENMP := 1\n\n\tifneq ($(UNAME_P),arm)\n\t\tSYSCTL_M := $(shell sysctl -n hw.optional.arm64 2>/dev/null)\n\t\tifeq ($(SYSCTL_M),1)\n\t\t\t# UNAME_P := arm\n\t\t\t# UNAME_M := arm64\n\t\t\twarn := $(warning Your arch is announced as x86_64, but it seems to actually be ARM64. Not fixing that can lead to bad performance. For more info see: https://github.com/ggerganov/whisper.cpp/issues/66\\#issuecomment-1282546789)\n\t\tendif\n\tendif\nendif\n\nifdef GGML_METAL\n\tGGML_METAL_EMBED_LIBRARY := 1\nendif\n\nifdef GGML_RPC\n\tBUILD_TARGETS += rpc-server\nendif\n\nifdef GGML_VULKAN\n\tBUILD_TARGETS += vulkan-shaders-gen\nendif\n\ndefault: $(BUILD_TARGETS) $(LEGACY_TARGETS_BUILD)\n\ntest: $(TEST_TARGETS)\n\t@failures=0; \\\n\tfor test_target in $(TEST_TARGETS); do \\\n\t\tif [ \"$$test_target\" = \"tests/test-tokenizer-0\" ]; then \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-llama-spm.gguf; \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-llama-bpe.gguf; \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-phi-3.gguf; \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-falcon.gguf; \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-bert-bge.gguf; \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-starcoder.gguf; \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-gpt-2.gguf; \\\n\t\t\t./$$test_target $(CURDIR)/models/ggml-vocab-refact.gguf; \\\n\t\telif [ \"$$test_target\" = \"tests/test-tokenizer-1-spm\" ]; then \\\n\t\t\tcontinue; \\\n\t\telif [ \"$$test_target\" = \"tests/test-tokenizer-1-bpe\" ]; then \\\n\t\t\tcontinue; \\\n\t\telse \\\n\t\t\techo \"Running test $$test_target...\"; \\\n\t\t\t./$$test_target; \\\n\t\tfi; \\\n\t\tif [ $$? -ne 0 ]; then \\\n\t\t\tprintf 'Test %s FAILED!\\n\\n' $$test_target; \\\n\t\t\tfailures=$$(( failures + 1 )); \\\n\t\telse \\\n\t\t\tprintf 'Test %s passed.\\n\\n' $$test_target; \\\n\t\tfi; \\\n\tdone; \\\n\tif [ $$failures -gt 0 ]; then \\\n\t\tprintf '\\n%s tests failed.\\n' $$failures; \\\n\t\texit 1; \\\n\tfi\n\t@echo 'All tests passed.'\n\nall: $(BUILD_TARGETS) $(TEST_TARGETS) $(LEGACY_TARGETS_BUILD)\n\nifdef RISCV_CROSS_COMPILE\nCC\t:= riscv64-unknown-linux-gnu-gcc\nCXX\t:= riscv64-unknown-linux-gnu-g++\nendif\n\n#\n# Compile flags\n#\n\n# keep standard at C11 and C++17\nMK_CPPFLAGS  = -Iggml/include -Iggml/src -Iinclude -Isrc -Icommon -DGGML_USE_CPU\nMK_CFLAGS    = -std=c11   -fPIC\nMK_CXXFLAGS  = -std=c++17 -fPIC\nMK_NVCCFLAGS = -std=c++17\n\nifdef LLAMA_NO_CCACHE\nGGML_NO_CCACHE := 1\nDEPRECATE_WARNING := 1\nendif\n\nifndef GGML_NO_CCACHE\nCCACHE := $(shell which ccache)\nifdef CCACHE\nexport CCACHE_SLOPPINESS = time_macros\n$(info I ccache found, compilation results will be cached. Disable with GGML_NO_CCACHE.)\nCC    := $(CCACHE) $(CC)\nCXX   := $(CCACHE) $(CXX)\nelse\n$(info I ccache not found. Consider installing it for faster compilation.)\nendif # CCACHE\nendif # GGML_NO_CCACHE\n\n# clock_gettime came in POSIX.1b (1993)\n# CLOCK_MONOTONIC came in POSIX.1-2001 / SUSv3 as optional\n# posix_memalign came in POSIX.1-2001 / SUSv3\n# M_PI is an XSI extension since POSIX.1-2001 / SUSv3, came in XPG1 (1985)\nMK_CPPFLAGS += -D_XOPEN_SOURCE=600\n\n# Somehow in OpenBSD whenever POSIX conformance is specified\n# some string functions rely on locale_t availability,\n# which was introduced in POSIX.1-2008, forcing us to go higher\nifeq ($(UNAME_S),OpenBSD)\n\tMK_CPPFLAGS += -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700\nendif\n\n# Data types, macros and functions related to controlling CPU affinity and\n# some memory allocation are available on Linux through GNU extensions in libc\nifeq ($(UNAME_S),Linux)\n\tMK_CPPFLAGS += -D_GNU_SOURCE\n\tMK_LDFLAGS  += -ldl\nendif\n\n# RLIMIT_MEMLOCK came in BSD, is not specified in POSIX.1,\n# and on macOS its availability depends on enabling Darwin extensions\n# similarly on DragonFly, enabling BSD extensions is necessary\nifeq ($(UNAME_S),Darwin)\n\tMK_CPPFLAGS += -D_DARWIN_C_SOURCE\nendif\nifeq ($(UNAME_S),DragonFly)\n\tMK_CPPFLAGS += -D__BSD_VISIBLE\nendif\n\n# alloca is a non-standard interface that is not visible on BSDs when\n# POSIX conformance is specified, but not all of them provide a clean way\n# to enable it in such cases\nifeq ($(UNAME_S),FreeBSD)\n\tMK_CPPFLAGS += -D__BSD_VISIBLE\nendif\nifeq ($(UNAME_S),NetBSD)\n\tMK_CPPFLAGS += -D_NETBSD_SOURCE\nendif\nifeq ($(UNAME_S),OpenBSD)\n\tMK_CPPFLAGS += -D_BSD_SOURCE\nendif\n\nifdef GGML_SCHED_MAX_COPIES\n\tMK_CPPFLAGS += -DGGML_SCHED_MAX_COPIES=$(GGML_SCHED_MAX_COPIES)\nendif\n\nifdef LLAMA_DEBUG\n\tMK_CFLAGS    += -O0 -g\n\tMK_CXXFLAGS  += -O0 -g\n\tMK_LDFLAGS   += -g\n\tMK_NVCCFLAGS += -O0 -g\n\n\tifeq ($(UNAME_S),Linux)\n\t\tMK_CPPFLAGS += -D_GLIBCXX_ASSERTIONS\n\tendif\nelse\n\tMK_CPPFLAGS   += -DNDEBUG\n\tMK_CFLAGS     += -O3 -g\n\tMK_CXXFLAGS   += -O3 -g\n\tMK_NVCCFLAGS  += -O3 -g\nendif\n\nifdef LLAMA_SANITIZE_THREAD\n\tMK_CFLAGS   += -fsanitize=thread -g\n\tMK_CXXFLAGS += -fsanitize=thread -g\n\tMK_LDFLAGS  += -fsanitize=thread -g\nendif\n\nifdef LLAMA_SANITIZE_ADDRESS\n\tMK_CFLAGS   += -fsanitize=address -fno-omit-frame-pointer -g\n\tMK_CXXFLAGS += -fsanitize=address -fno-omit-frame-pointer -g\n\tMK_LDFLAGS  += -fsanitize=address -fno-omit-frame-pointer -g\nendif\n\nifdef LLAMA_SANITIZE_UNDEFINED\n\tMK_CFLAGS   += -fsanitize=undefined -g\n\tMK_CXXFLAGS += -fsanitize=undefined -g\n\tMK_LDFLAGS  += -fsanitize=undefined -g\nendif\n\nifdef LLAMA_SERVER_SSL\n\tMK_CPPFLAGS += -DCPPHTTPLIB_OPENSSL_SUPPORT\n\tMK_LDFLAGS += -lssl -lcrypto\nendif\n\nifndef GGML_NO_CPU_AARCH64\n\tMK_CPPFLAGS += -DGGML_USE_CPU_AARCH64\nendif\n\n# warnings\nWARN_FLAGS = \\\n\t-Wall \\\n\t-Wextra \\\n\t-Wpedantic \\\n\t-Wcast-qual \\\n\t-Wno-unused-function\n\nMK_CFLAGS += \\\n\t$(WARN_FLAGS) \\\n\t-Wshadow \\\n\t-Wstrict-prototypes \\\n\t-Wpointer-arith \\\n\t-Wmissing-prototypes \\\n\t-Werror=implicit-int \\\n\t-Werror=implicit-function-declaration\n\nMK_CXXFLAGS += \\\n\t$(WARN_FLAGS) \\\n\t-Wmissing-declarations \\\n\t-Wmissing-noreturn\n\nifeq ($(LLAMA_FATAL_WARNINGS),1)\n\tMK_CFLAGS   += -Werror\n\tMK_CXXFLAGS += -Werror\nendif\n\n# this version of Apple ld64 is buggy\nifneq '' '$(findstring dyld-1015.7,$(shell $(CC) $(LDFLAGS) -Wl,-v 2>&1))'\n\tMK_CPPFLAGS += -DHAVE_BUGGY_APPLE_LINKER\nendif\n\n# OS specific\n# TODO: support Windows\nifneq '' '$(filter $(UNAME_S),Linux Darwin FreeBSD NetBSD OpenBSD Haiku)'\n\tMK_CFLAGS   += -pthread\n\tMK_CXXFLAGS += -pthread\nendif\n\n# detect Windows\nifneq ($(findstring _NT,$(UNAME_S)),)\n\t_WIN32 := 1\nendif\n\n# library name prefix\nifneq ($(_WIN32),1)\n\tLIB_PRE := lib\nendif\n\n# Dynamic Shared Object extension\nifneq ($(_WIN32),1)\n\tDSO_EXT := .so\nelse\n\tDSO_EXT := .dll\nendif\n\n# Windows Sockets 2 (Winsock) for network-capable apps\nifeq ($(_WIN32),1)\n\tLWINSOCK2 := -lws2_32\nendif\n\nifdef LLAMA_GPROF\n\tMK_CFLAGS   += -pg\n\tMK_CXXFLAGS += -pg\nendif\n\n# Architecture specific\n# TODO: probably these flags need to be tweaked on some architectures\n#       feel free to update the Makefile for your architecture and send a pull request or issue\n\nifndef RISCV_CROSS_COMPILE\n\nifeq ($(UNAME_M),$(filter $(UNAME_M),x86_64 i686 amd64))\n\t# Use all CPU extensions that are available:\n\tMK_CFLAGS     += -march=native -mtune=native\n\tHOST_CXXFLAGS += -march=native -mtune=native\n\n\t# Usage AMX build test\n\t#MK_CFLAGS     += -march=graniterapids -mtune=graniterapids\n\t#HOST_CXXFLAGS += -march=graniterapids -mtune=graniterapids\n\n\t# Usage AVX-only\n\t#MK_CFLAGS   += -mfma -mf16c -mavx\n\t#MK_CXXFLAGS += -mfma -mf16c -mavx\n\n\t# Usage SSSE3-only (Not is SSE3!)\n\t#MK_CFLAGS   += -mssse3\n\t#MK_CXXFLAGS += -mssse3\nendif\n\nifneq '' '$(findstring mingw,$(shell $(CC) -dumpmachine))'\n\t# The stack is only 16-byte aligned on Windows, so don't let gcc emit aligned moves.\n\t# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54412\n\t# https://github.com/ggerganov/llama.cpp/issues/2922\n\tMK_CFLAGS   += -Xassembler -muse-unaligned-vector-move\n\tMK_CXXFLAGS += -Xassembler -muse-unaligned-vector-move\n\n\t# Target Windows 8 for PrefetchVirtualMemory\n\tMK_CPPFLAGS += -D_WIN32_WINNT=0x602\nendif\n\nifneq ($(filter aarch64%,$(UNAME_M)),)\n\t# Apple M1, M2, etc.\n\t# Raspberry Pi 3, 4, Zero 2 (64-bit)\n\t# Nvidia Jetson\n\tMK_CFLAGS   += -mcpu=native\n\tMK_CXXFLAGS += -mcpu=native\n\tJETSON_RELEASE_INFO = $(shell jetson_release)\n\tifdef JETSON_RELEASE_INFO\n\t\tifneq ($(filter TX2%,$(JETSON_RELEASE_INFO)),)\n\t\t\tJETSON_EOL_MODULE_DETECT = 1\n\t\t\tCC = aarch64-unknown-linux-gnu-gcc\n\t\t\tcxx = aarch64-unknown-linux-gnu-g++\n\t\tendif\n\tendif\nendif\n\nifneq ($(filter armv6%,$(UNAME_M)),)\n\t# Raspberry Pi 1, Zero\n\tMK_CFLAGS   += -mfpu=neon-fp-armv8 -mfp16-format=ieee -mno-unaligned-access\n\tMK_CXXFLAGS += -mfpu=neon-fp-armv8 -mfp16-format=ieee -mno-unaligned-access\nendif\n\nifneq ($(filter armv7%,$(UNAME_M)),)\n\t# Raspberry Pi 2\n\tMK_CFLAGS   += -mfpu=neon-fp-armv8 -mfp16-format=ieee -mno-unaligned-access -funsafe-math-optimizations\n\tMK_CXXFLAGS += -mfpu=neon-fp-armv8 -mfp16-format=ieee -mno-unaligned-access -funsafe-math-optimizations\nendif\n\nifneq ($(filter armv8%,$(UNAME_M)),)\n\t# Raspberry Pi 3, 4, Zero 2 (32-bit)\n\tMK_CFLAGS   += -mfp16-format=ieee -mno-unaligned-access\n\tMK_CXXFLAGS += -mfp16-format=ieee -mno-unaligned-access\nendif\n\nifneq ($(filter ppc64%,$(UNAME_M)),)\n\tPOWER9_M := $(shell grep \"POWER9\" /proc/cpuinfo)\n\tifneq (,$(findstring POWER9,$(POWER9_M)))\n\t\tMK_CFLAGS   += -mcpu=power9\n\t\tMK_CXXFLAGS += -mcpu=power9\n\tendif\nendif\n\nifneq ($(filter ppc64le%,$(UNAME_M)),)\n\tMK_CFLAGS   += -mcpu=powerpc64le\n\tMK_CXXFLAGS += -mcpu=powerpc64le\n\tCUDA_POWER_ARCH = 1\nendif\n\nifneq ($(filter loongarch64%,$(UNAME_M)),)\n\tMK_CFLAGS   += -mlasx\n\tMK_CXXFLAGS += -mlasx\nendif\n\nifneq ($(filter riscv64%,$(UNAME_M)),)\n\tMK_CFLAGS   += -march=rv64gcv -mabi=lp64d\n\tMK_CXXFLAGS += -march=rv64gcv -mabi=lp64d\nendif\n\nelse # RISC-V CROSS COMPILATION\n\tMK_CFLAGS   += -march=rv64gcv -mabi=lp64d\n\tMK_CXXFLAGS += -march=rv64gcv -mabi=lp64d\nendif\n\nifndef GGML_NO_ACCELERATE\n\t# Mac OS - include Accelerate framework.\n\t# `-framework Accelerate` works both with Apple Silicon and Mac Intel\n\tifeq ($(UNAME_S),Darwin)\n\t\tMK_CPPFLAGS  += -DGGML_USE_ACCELERATE -DGGML_USE_BLAS -DGGML_BLAS_USE_ACCELERATE\n\t\tMK_CPPFLAGS  += -DACCELERATE_NEW_LAPACK\n\t\tMK_CPPFLAGS  += -DACCELERATE_LAPACK_ILP64\n\t\tMK_LDFLAGS   += -framework Accelerate\n\t\tOBJ_GGML_EXT += ggml/src/ggml-blas/ggml-blas.o\n\tendif\nendif # GGML_NO_ACCELERATE\n\nifndef GGML_NO_OPENMP\n\tMK_CPPFLAGS += -DGGML_USE_OPENMP\n\tMK_CFLAGS   += -fopenmp\n\tMK_CXXFLAGS += -fopenmp\nendif # GGML_NO_OPENMP\n\nifdef GGML_OPENBLAS\n\tMK_CPPFLAGS  += -DGGML_USE_BLAS $(shell pkg-config --cflags-only-I openblas)\n\tMK_CFLAGS    += $(shell pkg-config --cflags-only-other openblas)\n\tMK_LDFLAGS   += $(shell pkg-config --libs openblas)\n\tOBJ_GGML_EXT += ggml/src/ggml-blas/ggml-blas.o\nendif # GGML_OPENBLAS\n\nifdef GGML_OPENBLAS64\n\tMK_CPPFLAGS  += -DGGML_USE_BLAS $(shell pkg-config --cflags-only-I openblas64)\n\tMK_CFLAGS    += $(shell pkg-config --cflags-only-other openblas64)\n\tMK_LDFLAGS   += $(shell pkg-config --libs openblas64)\n\tOBJ_GGML_EXT += ggml/src/ggml-blas/ggml-blas.o\nendif # GGML_OPENBLAS64\n\nifdef GGML_BLIS\n\tMK_CPPFLAGS  += -DGGML_USE_BLAS -DGGML_BLAS_USE_BLIS -I/usr/local/include/blis -I/usr/include/blis\n\tMK_LDFLAGS   += -lblis -L/usr/local/lib\n\tOBJ_GGML_EXT += ggml/src/ggml-blas/ggml-blas.o\nendif # GGML_BLIS\n\nifdef GGML_NVPL\n\tMK_CPPFLAGS  += -DGGML_USE_BLAS -DGGML_BLAS_USE_NVPL -DNVPL_ILP64 -I/usr/local/include/nvpl_blas -I/usr/include/nvpl_blas\n\tMK_LDFLAGS   += -L/usr/local/lib -lnvpl_blas_core -lnvpl_blas_ilp64_gomp\n\tOBJ_GGML_EXT += ggml/src/ggml-blas/ggml-blas.o\nendif # GGML_NVPL\n\nifndef GGML_NO_LLAMAFILE\n\tMK_CPPFLAGS  += -DGGML_USE_LLAMAFILE\n\tOBJ_GGML_EXT += ggml/src/ggml-cpu/llamafile/sgemm.o\nendif\n\nifndef GGML_NO_AMX\n\tMK_CPPFLAGS += -DGGML_USE_AMX\n\tOBJ_GGML_EXT += ggml/src/ggml-cpu/amx/amx.o ggml/src/ggml-cpu/amx/mmq.o\nendif\n\n# only necessary for the CPU backend files\nMK_CPPFLAGS += -Iggml/src/ggml-cpu\n\nifdef GGML_RPC\n\tMK_CPPFLAGS  += -DGGML_USE_RPC\n\tOBJ_GGML_EXT += ggml/src/ggml-rpc.o\nendif # GGML_RPC\n\nOBJ_CUDA_TMPL      = $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/template-instances/fattn-wmma*.cu))\nOBJ_CUDA_TMPL     += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/template-instances/mmq*.cu))\n\nifdef GGML_CUDA_FA_ALL_QUANTS\n\tOBJ_CUDA_TMPL += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/template-instances/fattn-vec*.cu))\nelse\n\tOBJ_CUDA_TMPL += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/template-instances/fattn-vec*q4_0-q4_0.cu))\n\tOBJ_CUDA_TMPL += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/template-instances/fattn-vec*q8_0-q8_0.cu))\n\tOBJ_CUDA_TMPL += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/template-instances/fattn-vec*f16-f16.cu))\nendif # GGML_CUDA_FA_ALL_QUANTS\n\nifdef GGML_CUDA\n\tifneq ('', '$(wildcard /opt/cuda)')\n\t\tCUDA_PATH ?= /opt/cuda\n\telse\n\t\tCUDA_PATH ?= /usr/local/cuda\n\tendif\n\n\tMK_CPPFLAGS  += -DGGML_USE_CUDA -DGGML_CUDA_USE_GRAPHS -I$(CUDA_PATH)/include -I$(CUDA_PATH)/targets/$(UNAME_M)-linux/include\n\tMK_LDFLAGS   += -lcuda -lcublas -lculibos -lcudart -lcublasLt -lpthread -ldl -lrt -L$(CUDA_PATH)/lib64 -L/usr/lib64 -L$(CUDA_PATH)/targets/$(UNAME_M)-linux/lib -L$(CUDA_PATH)/lib64/stubs -L/usr/lib/wsl/lib\n\tMK_NVCCFLAGS += -use_fast_math\n\n\tOBJ_GGML_EXT += ggml/src/ggml-cuda/ggml-cuda.o\n\tOBJ_GGML_EXT += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/*.cu))\n\tOBJ_GGML_EXT += $(OBJ_CUDA_TMPL)\n\nifdef LLAMA_FATAL_WARNINGS\n\tMK_NVCCFLAGS += -Werror all-warnings\nendif # LLAMA_FATAL_WARNINGS\n\nifndef JETSON_EOL_MODULE_DETECT\n\tMK_NVCCFLAGS += --forward-unknown-to-host-compiler\nendif # JETSON_EOL_MODULE_DETECT\n\nifdef LLAMA_DEBUG\n\tMK_NVCCFLAGS += -lineinfo\nendif # LLAMA_DEBUG\n\nifdef GGML_CUDA_DEBUG\n\tMK_NVCCFLAGS += --device-debug\nendif # GGML_CUDA_DEBUG\n\nifdef GGML_CUDA_NVCC\n\tNVCC = $(CCACHE) $(GGML_CUDA_NVCC)\nelse\n\tNVCC = $(CCACHE) nvcc\nendif # GGML_CUDA_NVCC\n\nifdef CUDA_DOCKER_ARCH\n\tMK_NVCCFLAGS += -Wno-deprecated-gpu-targets -arch=$(CUDA_DOCKER_ARCH)\nelse ifndef CUDA_POWER_ARCH\n\tMK_NVCCFLAGS += -arch=native\nendif # CUDA_DOCKER_ARCH\n\nifdef GGML_CUDA_FORCE_MMQ\n\tMK_NVCCFLAGS += -DGGML_CUDA_FORCE_MMQ\nendif # GGML_CUDA_FORCE_MMQ\n\nifdef GGML_CUDA_FORCE_CUBLAS\n\tMK_NVCCFLAGS += -DGGML_CUDA_FORCE_CUBLAS\nendif # GGML_CUDA_FORCE_CUBLAS\n\nifdef GGML_CUDA_F16\n\tMK_NVCCFLAGS += -DGGML_CUDA_F16\nendif # GGML_CUDA_F16\n\nifdef GGML_CUDA_DMMV_F16\n\tMK_NVCCFLAGS += -DGGML_CUDA_F16\nendif # GGML_CUDA_DMMV_F16\n\nifdef GGML_CUDA_PEER_MAX_BATCH_SIZE\n\tMK_NVCCFLAGS += -DGGML_CUDA_PEER_MAX_BATCH_SIZE=$(GGML_CUDA_PEER_MAX_BATCH_SIZE)\nelse\n\tMK_NVCCFLAGS += -DGGML_CUDA_PEER_MAX_BATCH_SIZE=128\nendif # GGML_CUDA_PEER_MAX_BATCH_SIZE\n\nifdef GGML_CUDA_NO_PEER_COPY\n\tMK_NVCCFLAGS += -DGGML_CUDA_NO_PEER_COPY\nendif # GGML_CUDA_NO_PEER_COPY\n\nifdef GGML_CUDA_CCBIN\n\tMK_NVCCFLAGS += -ccbin $(GGML_CUDA_CCBIN)\nendif # GGML_CUDA_CCBIN\n\nifdef GGML_CUDA_FA_ALL_QUANTS\n\tMK_NVCCFLAGS += -DGGML_CUDA_FA_ALL_QUANTS\nendif # GGML_CUDA_FA_ALL_QUANTS\n\nifdef JETSON_EOL_MODULE_DETECT\ndefine NVCC_COMPILE\n\t$(NVCC) -I. -Icommon -D_XOPEN_SOURCE=600 -D_GNU_SOURCE -DNDEBUG -DGGML_USE_CUDA -I/usr/local/cuda/include -I/opt/cuda/include -I/usr/local/cuda/targets/aarch64-linux/include -std=c++11 -O3 $(NVCCFLAGS) $(CPPFLAGS) -Xcompiler \"$(CUDA_CXXFLAGS)\" -c $< -o $@\nendef # NVCC_COMPILE\nelse\ndefine NVCC_COMPILE\n\t$(NVCC) $(NVCCFLAGS) $(CPPFLAGS) -Xcompiler \"$(CUDA_CXXFLAGS)\" -c $< -o $@\nendef # NVCC_COMPILE\nendif # JETSON_EOL_MODULE_DETECT\n\nggml/src/ggml-cuda/%.o: \\\n\tggml/src/ggml-cuda/%.cu \\\n\tggml/include/ggml.h \\\n\tggml/src/ggml-common.h \\\n\tggml/src/ggml-cuda/common.cuh\n\t$(NVCC_COMPILE)\n\nggml/src/ggml-cuda/ggml-cuda.o: \\\n\tggml/src/ggml-cuda/ggml-cuda.cu \\\n\tggml/include/ggml-cuda.h \\\n\tggml/include/ggml.h \\\n\tggml/include/ggml-backend.h \\\n\tggml/src/ggml-backend-impl.h \\\n\tggml/src/ggml-common.h \\\n\t$(wildcard ggml/src/ggml-cuda/*.cuh)\n\t$(NVCC_COMPILE)\nendif # GGML_CUDA\n\nifdef GGML_VULKAN\n\tMK_CPPFLAGS  += -DGGML_USE_VULKAN\n\tMK_LDFLAGS   += $(shell pkg-config --libs vulkan)\n\tOBJ_GGML_EXT += ggml/src/ggml-vulkan.o ggml/src/ggml-vulkan-shaders.o\n\nifdef GGML_VULKAN_CHECK_RESULTS\n\tMK_CPPFLAGS  += -DGGML_VULKAN_CHECK_RESULTS\nendif\n\nifdef GGML_VULKAN_DEBUG\n\tMK_CPPFLAGS  += -DGGML_VULKAN_DEBUG\nendif\n\nifdef GGML_VULKAN_MEMORY_DEBUG\n\tMK_CPPFLAGS  += -DGGML_VULKAN_MEMORY_DEBUG\nendif\n\nifdef GGML_VULKAN_PERF\n\tMK_CPPFLAGS  += -DGGML_VULKAN_PERF\nendif\n\nifdef GGML_VULKAN_VALIDATE\n\tMK_CPPFLAGS  += -DGGML_VULKAN_VALIDATE\nendif\n\nifdef GGML_VULKAN_RUN_TESTS\n\tMK_CPPFLAGS  += -DGGML_VULKAN_RUN_TESTS\nendif\n\nGLSLC_CMD  = glslc\n_ggml_vk_genshaders_cmd = $(shell pwd)/vulkan-shaders-gen\n_ggml_vk_header = ggml/src/ggml-vulkan-shaders.hpp\n_ggml_vk_source = ggml/src/ggml-vulkan-shaders.cpp\n_ggml_vk_input_dir = ggml/src/ggml-vulkan/vulkan-shaders\n_ggml_vk_shader_deps = $(echo $(_ggml_vk_input_dir)/*.comp)\n\nggml/src/ggml-vulkan.o: ggml/src/ggml-vulkan/ggml-vulkan.cpp ggml/include/ggml-vulkan.h $(_ggml_vk_header) $(_ggml_vk_source)\n\t$(CXX) $(CXXFLAGS) $(shell pkg-config --cflags vulkan) -c $< -o $@\n\n$(_ggml_vk_header): $(_ggml_vk_source)\n\n$(_ggml_vk_source): $(_ggml_vk_shader_deps) vulkan-shaders-gen\n\t$(_ggml_vk_genshaders_cmd) \\\n\t\t--glslc      $(GLSLC_CMD) \\\n\t\t--input-dir  $(_ggml_vk_input_dir) \\\n\t\t--target-hpp $(_ggml_vk_header) \\\n\t\t--target-cpp $(_ggml_vk_source)\n\nvulkan-shaders-gen: ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp\n\t$(CXX) $(CXXFLAGS) -o $@ $(LDFLAGS) ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp\n\nendif # GGML_VULKAN\n\nifdef GGML_HIP\n\tifeq ($(wildcard /opt/rocm),)\n\t\tROCM_PATH      ?= /usr\n\t\tAMDGPU_TARGETS ?= $(shell $(shell which amdgpu-arch))\n\telse\n\t\tROCM_PATH\t?= /opt/rocm\n\t\tAMDGPU_TARGETS ?= $(shell $(ROCM_PATH)/llvm/bin/amdgpu-arch)\n\tendif\n\n\tMK_CPPFLAGS += -DGGML_USE_HIP -DGGML_USE_CUDA\n\nifdef GGML_HIP_UMA\n\tMK_CPPFLAGS += -DGGML_HIP_UMA\nendif # GGML_HIP_UMA\n\n\tMK_LDFLAGS += -L$(ROCM_PATH)/lib -Wl,-rpath=$(ROCM_PATH)/lib\n\tMK_LDFLAGS += -L$(ROCM_PATH)/lib64 -Wl,-rpath=$(ROCM_PATH)/lib64\n\tMK_LDFLAGS += -lhipblas -lamdhip64 -lrocblas\n\n\tHIPCC ?= $(CCACHE) $(ROCM_PATH)/bin/hipcc\n\n\tHIPFLAGS += $(addprefix --offload-arch=,$(AMDGPU_TARGETS))\n\nifdef GGML_CUDA_FORCE_MMQ\n\tHIPFLAGS += -DGGML_CUDA_FORCE_MMQ\nendif # GGML_CUDA_FORCE_MMQ\n\nifdef GGML_CUDA_FORCE_CUBLAS\n\tHIPFLAGS += -DGGML_CUDA_FORCE_CUBLAS\nendif # GGML_CUDA_FORCE_CUBLAS\n\nifdef GGML_CUDA_NO_PEER_COPY\n\tHIPFLAGS += -DGGML_CUDA_NO_PEER_COPY\nendif # GGML_CUDA_NO_PEER_COPY\n\n\tOBJ_GGML_EXT += ggml/src/ggml-cuda/ggml-cuda.o\n\tOBJ_GGML_EXT += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/*.cu))\n\tOBJ_GGML_EXT += $(OBJ_CUDA_TMPL)\n\nggml/src/ggml-cuda/ggml-cuda.o: \\\n\tggml/src/ggml-cuda/ggml-cuda.cu \\\n\tggml/include/ggml-cuda.h \\\n\tggml/include/ggml.h \\\n\tggml/include/ggml-backend.h \\\n\tggml/src/ggml-backend-impl.h \\\n\tggml/src/ggml-common.h \\\n\t$(wildcard ggml/src/ggml-cuda/*.cuh)\n\t$(HIPCC) $(CXXFLAGS) $(HIPFLAGS) -x hip -c -o $@ $<\n\nggml/src/ggml-cuda/%.o: \\\n\tggml/src/ggml-cuda/%.cu \\\n\tggml/include/ggml.h \\\n\tggml/src/ggml-common.h \\\n\tggml/src/ggml-cuda/common.cuh\n\t$(HIPCC) $(CXXFLAGS) $(HIPFLAGS) -x hip -c -o $@ $<\nendif # GGML_HIP\n\nifdef GGML_MUSA\n\tifeq ($(wildcard /opt/musa),)\n\t\tMUSA_PATH ?= /usr/local/musa\n\telse\n\t\tMUSA_PATH ?= /opt/musa\n\tendif\n\tMUSA_ARCHITECTURES ?= 21;22\n\n\tMK_CPPFLAGS += -DGGML_USE_MUSA -DGGML_USE_CUDA\n\tMK_LDFLAGS += -L$(MUSA_PATH)/lib -Wl,-rpath=$(MUSA_PATH)/lib\n\tMK_LDFLAGS += -lmusa -lmusart -lmublas\n\n\tifndef GGML_NO_OPENMP\n\t\t# For Ubuntu Focal\n\t\tMK_CPPFLAGS += -I/usr/lib/llvm-10/include/openmp\n\t\tMK_LDFLAGS  += -L/usr/lib/llvm-10/lib\n\t\t# For Ubuntu Jammy\n\t\tMK_CPPFLAGS += -I/usr/lib/llvm-14/lib/clang/14.0.0/include\n\t\tMK_LDFLAGS  += -L/usr/lib/llvm-14/lib\n\tendif # GGML_NO_OPENMP\n\n\tCC  := $(MUSA_PATH)/bin/clang\n\tCXX := $(MUSA_PATH)/bin/clang++\n\tMCC := $(CCACHE) $(MUSA_PATH)/bin/mcc\n\n\tMUSAFLAGS  = -x musa -mtgpu\n\tMUSAFLAGS += $(foreach arch,$(subst ;, ,$(MUSA_ARCHITECTURES)),--cuda-gpu-arch=mp_$(arch))\n\nifdef GGML_CUDA_FORCE_MMQ\n\tMUSAFLAGS += -DGGML_CUDA_FORCE_MMQ\nendif # GGML_CUDA_FORCE_MMQ\n\nifdef GGML_CUDA_FORCE_CUBLAS\n\tMUSAFLAGS += -DGGML_CUDA_FORCE_CUBLAS\nendif # GGML_CUDA_FORCE_CUBLAS\n\nifdef GGML_CUDA_F16\n\tMUSAFLAGS += -DGGML_CUDA_F16\nendif # GGML_CUDA_F16\n\nifdef GGML_CUDA_DMMV_F16\n\tMUSAFLAGS += -DGGML_CUDA_F16\nendif # GGML_CUDA_DMMV_F16\n\nifdef GGML_CUDA_PEER_MAX_BATCH_SIZE\n\tMUSAFLAGS += -DGGML_CUDA_PEER_MAX_BATCH_SIZE=$(GGML_CUDA_PEER_MAX_BATCH_SIZE)\nelse\n\tMUSAFLAGS += -DGGML_CUDA_PEER_MAX_BATCH_SIZE=128\nendif # GGML_CUDA_PEER_MAX_BATCH_SIZE\n\nifdef GGML_CUDA_NO_PEER_COPY\n\tMUSAFLAGS += -DGGML_CUDA_NO_PEER_COPY\nendif # GGML_CUDA_NO_PEER_COPY\n\nifdef GGML_CUDA_FA_ALL_QUANTS\n\tMUSAFLAGS += -DGGML_CUDA_FA_ALL_QUANTS\nendif # GGML_CUDA_FA_ALL_QUANTS\n\n\tOBJ_GGML_EXT += ggml/src/ggml-cuda/ggml-cuda.o\n\tOBJ_GGML_EXT += $(patsubst %.cu,%.o,$(wildcard ggml/src/ggml-cuda/*.cu))\n\tOBJ_GGML_EXT += $(OBJ_CUDA_TMPL)\n\nggml/src/ggml-cuda/ggml-cuda.o: \\\n\tggml/src/ggml-cuda/ggml-cuda.cu \\\n\tggml/include/ggml-cuda.h \\\n\tggml/include/ggml.h \\\n\tggml/include/ggml-backend.h \\\n\tggml/src/ggml-backend-impl.h \\\n\tggml/src/ggml-common.h \\\n\t$(wildcard ggml/src/ggml-cuda/*.cuh)\n\t$(MCC) $(CXXFLAGS) $(MUSAFLAGS) -c -o $@ $<\n\nggml/src/ggml-cuda/%.o: \\\n\tggml/src/ggml-cuda/%.cu \\\n\tggml/include/ggml.h \\\n\tggml/src/ggml-common.h \\\n\tggml/src/ggml-cuda/common.cuh\n\t$(MCC) $(CXXFLAGS) $(MUSAFLAGS) -c -o $@ $<\nendif # GGML_MUSA\n\nifdef GGML_METAL\n\tMK_CPPFLAGS  += -DGGML_USE_METAL\n\tMK_LDFLAGS   += -framework Foundation -framework Metal -framework MetalKit\n\tOBJ_GGML_EXT += ggml/src/ggml-metal/ggml-metal.o\n\nifdef GGML_METAL_USE_BF16\n\tMK_CPPFLAGS += -DGGML_METAL_USE_BF16\nendif # GGML_METAL_USE_BF16\nifdef GGML_METAL_NDEBUG\n\tMK_CPPFLAGS += -DGGML_METAL_NDEBUG\nendif\nifdef GGML_METAL_EMBED_LIBRARY\n\tMK_CPPFLAGS  += -DGGML_METAL_EMBED_LIBRARY\n\tOBJ_GGML_EXT += ggml/src/ggml-metal-embed.o\nendif\nendif # GGML_METAL\n\nifdef GGML_METAL\nggml/src/ggml-metal/ggml-metal.o: \\\n\tggml/src/ggml-metal/ggml-metal.m \\\n\tggml/src/ggml-metal/ggml-metal-impl.h \\\n\tggml/include/ggml-metal.h \\\n\tggml/include/ggml.h\n\t$(CC) $(CFLAGS) -c $< -o $@\n\nifdef GGML_METAL_EMBED_LIBRARY\nggml/src/ggml-metal-embed.o: \\\n\tggml/src/ggml-metal/ggml-metal.metal \\\n\tggml/src/ggml-metal/ggml-metal-impl.h \\\n\tggml/src/ggml-common.h\n\t@echo \"Embedding Metal library\"\n\t@sed -e '/__embed_ggml-common.h__/r      ggml/src/ggml-common.h'                -e '/__embed_ggml-common.h__/d'      < ggml/src/ggml-metal/ggml-metal.metal           > ggml/src/ggml-metal/ggml-metal-embed.metal.tmp\n\t@sed -e '/#include \"ggml-metal-impl.h\"/r ggml/src/ggml-metal/ggml-metal-impl.h' -e '/#include \"ggml-metal-impl.h\"/d' < ggml/src/ggml-metal/ggml-metal-embed.metal.tmp > ggml/src/ggml-metal/ggml-metal-embed.metal\n\t$(eval TEMP_ASSEMBLY=$(shell mktemp -d))\n\t@echo \".section __DATA, __ggml_metallib\"                       >  $(TEMP_ASSEMBLY)/ggml-metal-embed.s\n\t@echo \".globl _ggml_metallib_start\"                            >> $(TEMP_ASSEMBLY)/ggml-metal-embed.s\n\t@echo \"_ggml_metallib_start:\"                                  >> $(TEMP_ASSEMBLY)/ggml-metal-embed.s\n\t@echo \".incbin \\\"ggml/src/ggml-metal/ggml-metal-embed.metal\\\"\" >> $(TEMP_ASSEMBLY)/ggml-metal-embed.s\n\t@echo \".globl _ggml_metallib_end\"                              >> $(TEMP_ASSEMBLY)/ggml-metal-embed.s\n\t@echo \"_ggml_metallib_end:\"                                    >> $(TEMP_ASSEMBLY)/ggml-metal-embed.s\n\t$(CC) $(CFLAGS) -c $(TEMP_ASSEMBLY)/ggml-metal-embed.s -o $@\n\t@rm -f ${TEMP_ASSEMBLY}/ggml-metal-embed.s\n\t@rmdir ${TEMP_ASSEMBLY}\nendif\nendif # GGML_METAL\n\nDIR_GGML = ggml\nDIR_LLAMA = src\nDIR_COMMON = common\n\nOBJ_GGML = \\\n\t$(DIR_GGML)/src/ggml.o \\\n\t$(DIR_GGML)/src/ggml-alloc.o \\\n\t$(DIR_GGML)/src/ggml-backend.o \\\n\t$(DIR_GGML)/src/ggml-backend-reg.o \\\n\t$(DIR_GGML)/src/ggml-opt.o \\\n\t$(DIR_GGML)/src/ggml-quants.o \\\n\t$(DIR_GGML)/src/ggml-threading.o \\\n\t$(DIR_GGML)/src/ggml-cpu/ggml-cpu.o \\\n\t$(DIR_GGML)/src/ggml-cpu/ggml-cpu_cpp.o \\\n\t$(DIR_GGML)/src/ggml-cpu/ggml-cpu-aarch64.o \\\n\t$(DIR_GGML)/src/ggml-cpu/ggml-cpu-hbm.o \\\n\t$(DIR_GGML)/src/ggml-cpu/ggml-cpu-quants.o \\\n\t$(DIR_GGML)/src/ggml-cpu/ggml-cpu-traits.o \\\n\t$(OBJ_GGML_EXT)\n\nOBJ_LLAMA = \\\n\t$(DIR_LLAMA)/llama.o \\\n\t$(DIR_LLAMA)/llama-vocab.o \\\n\t$(DIR_LLAMA)/llama-grammar.o \\\n\t$(DIR_LLAMA)/llama-sampling.o \\\n\t$(DIR_LLAMA)/unicode.o \\\n\t$(DIR_LLAMA)/unicode-data.o\n\nOBJ_COMMON = \\\n\t$(DIR_COMMON)/common.o \\\n\t$(DIR_COMMON)/arg.o \\\n\t$(DIR_COMMON)/log.o \\\n\t$(DIR_COMMON)/console.o \\\n\t$(DIR_COMMON)/ngram-cache.o \\\n\t$(DIR_COMMON)/sampling.o \\\n\t$(DIR_COMMON)/speculative.o \\\n\t$(DIR_COMMON)/build-info.o \\\n\t$(DIR_COMMON)/json-schema-to-grammar.o\n\nOBJ_ALL = $(OBJ_GGML) $(OBJ_LLAMA) $(OBJ_COMMON)\n\nLIB_GGML   = $(LIB_PRE)ggml$(DSO_EXT)\nLIB_GGML_S = $(LIB_PRE)ggml.a\n\nLIB_LLAMA   = $(LIB_PRE)llama$(DSO_EXT)\nLIB_LLAMA_S = $(LIB_PRE)llama.a\n\nLIB_COMMON   = $(LIB_PRE)common$(DSO_EXT)\nLIB_COMMON_S = $(LIB_PRE)common.a\n\nLIB_ALL   = $(LIB_GGML)   $(LIB_LLAMA)   $(LIB_COMMON)\nLIB_ALL_S = $(LIB_GGML_S) $(LIB_LLAMA_S) $(LIB_COMMON_S)\n\nGF_CC := $(CC)\ninclude scripts/get-flags.mk\n\n# combine build flags with cmdline overrides\noverride CPPFLAGS  := $(MK_CPPFLAGS) $(CPPFLAGS)\noverride CFLAGS    := $(CPPFLAGS) $(MK_CFLAGS) $(GF_CFLAGS) $(CFLAGS)\nBASE_CXXFLAGS      := $(MK_CXXFLAGS) $(CXXFLAGS)\noverride CXXFLAGS  := $(BASE_CXXFLAGS) $(HOST_CXXFLAGS) $(GF_CXXFLAGS) $(CPPFLAGS)\noverride NVCCFLAGS := $(MK_NVCCFLAGS) $(NVCCFLAGS)\noverride LDFLAGS   := $(MK_LDFLAGS) $(LDFLAGS)\n\n# identify CUDA host compiler\nifdef GGML_CUDA\nGF_CC := $(NVCC) $(NVCCFLAGS) 2>/dev/null .c -Xcompiler\ninclude scripts/get-flags.mk\nCUDA_CXXFLAGS := $(BASE_CXXFLAGS) $(GF_CXXFLAGS) -Wno-pedantic\nendif\n\nifdef LLAMA_CURL\noverride CXXFLAGS := $(CXXFLAGS) -DLLAMA_USE_CURL\noverride LDFLAGS  := $(LDFLAGS) -lcurl\nendif\n\n#\n# Print build information\n#\n\n$(info I llama.cpp build info: )\n$(info I UNAME_S:   $(UNAME_S))\n$(info I UNAME_P:   $(UNAME_P))\n$(info I UNAME_M:   $(UNAME_M))\n$(info I CFLAGS:    $(CFLAGS))\n$(info I CXXFLAGS:  $(CXXFLAGS))\n$(info I NVCCFLAGS: $(NVCCFLAGS))\n$(info I LDFLAGS:   $(LDFLAGS))\n$(info I CC:        $(shell $(CC)   --version | head -n 1))\n$(info I CXX:       $(shell $(CXX)  --version | head -n 1))\nifdef GGML_CUDA\n$(info I NVCC:      $(shell $(NVCC) --version | tail -n 1))\nCUDA_VERSION := $(shell $(NVCC) --version | grep -oP 'release (\\K[0-9]+\\.[0-9])')\nifeq ($(shell awk -v \"v=$(CUDA_VERSION)\" 'BEGIN { print (v < 11.7) }'),1)\n\nifndef CUDA_DOCKER_ARCH\nifndef CUDA_POWER_ARCH\n$(error I ERROR: For CUDA versions < 11.7 a target CUDA architecture must be explicitly provided via environment variable CUDA_DOCKER_ARCH, e.g. by running \"export CUDA_DOCKER_ARCH=compute_XX\" on Unix-like systems, where XX is the minimum compute capability that the code needs to run on. A list with compute capabilities can be found here: https://developer.nvidia.com/cuda-gpus )\nendif # CUDA_POWER_ARCH\nendif # CUDA_DOCKER_ARCH\n\nendif # eq ($(shell echo \"$(CUDA_VERSION) < 11.7\" | bc),1)\nendif # GGML_CUDA\n$(info )\n\nifdef DEPRECATE_WARNING\n$(info !!! DEPRECATION WARNING !!!)\n$(info The following LLAMA_ options are deprecated and will be removed in the future. Use the GGML_ prefix instead)\n$(info   - LLAMA_CUDA)\n$(info   - LLAMA_METAL)\n$(info   - LLAMA_METAL_EMBED_LIBRARY)\n$(info   - LLAMA_OPENMP)\n$(info   - LLAMA_RPC)\n$(info   - LLAMA_SYCL)\n$(info   - LLAMA_SYCL_F16)\n$(info   - LLAMA_OPENBLAS)\n$(info   - LLAMA_OPENBLAS64)\n$(info   - LLAMA_BLIS)\n$(info   - LLAMA_NO_LLAMAFILE)\n$(info   - LLAMA_NO_ACCELERATE)\n$(info   - LLAMA_NO_OPENMP)\n$(info   - LLAMA_NO_METAL)\n$(info   - LLAMA_NO_CCACHE)\n$(info )\nendif\n\nifdef REMOVE_WARNING\n$(info !!! REMOVAL WARNING !!!)\n$(info The following LLAMA_ options have been removed and are no longer supported)\n$(info   - LLAMA_DISABLE_LOGS   (https://github.com/ggerganov/llama.cpp/pull/9418))\n$(info   - LLAMA_SERVER_VERBOSE (https://github.com/ggerganov/llama.cpp/pull/9418))\n$(info )\nendif\n\n#\n# Build libraries\n#\n\n# Libraries\nLIB_GGML   = libggml.so\nLIB_GGML_S = libggml.a\n\nLIB_LLAMA   = libllama.so\nLIB_LLAMA_S = libllama.a\n\nLIB_COMMON   = libcommon.so\nLIB_COMMON_S = libcommon.a\n\n# Targets\nBUILD_TARGETS += $(LIB_GGML) $(LIB_GGML_S) $(LIB_LLAMA) $(LIB_LLAMA_S) $(LIB_COMMON) $(LIB_COMMON_S)\n\n# Dependency files\nDEP_FILES = $(OBJ_GGML:.o=.d) $(OBJ_LLAMA:.o=.d) $(OBJ_COMMON:.o=.d)\n\n# Default target\nall: $(BUILD_TARGETS)\n\n# force c++ build for source file that have same name as c file\n# Note: need this exception because `ggml-cpu.c` and `ggml-cpu.cpp` both produce the same obj/dep files\n$(DIR_GGML)/%_cpp.o: $(DIR_GGML)/%.cpp\n\t$(CXX) $(CXXFLAGS) -MMD -c $< -o $@\n\n# Rules for building object files\n$(DIR_GGML)/%.o: $(DIR_GGML)/%.c\n\t$(CC) $(CFLAGS) -MMD -c $< -o $@\n\n$(DIR_GGML)/%.o: $(DIR_GGML)/%.cpp\n\t$(CXX) $(CXXFLAGS) -MMD -c $< -o $@\n\n$(DIR_LLAMA)/%.o: $(DIR_LLAMA)/%.cpp\n\t$(CXX) $(CXXFLAGS) -MMD -c $< -o $@\n\n$(DIR_COMMON)/%.o: $(DIR_COMMON)/%.cpp\n\t$(CXX) $(CXXFLAGS) -MMD -c $< -o $@\n\n# Rules for building libraries\n$(LIB_GGML): $(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -shared -fPIC -o $@ $^ $(LDFLAGS)\n\n$(LIB_GGML_S): $(OBJ_GGML)\n\tar rcs $(LIB_GGML_S) $^\n\n$(LIB_LLAMA): $(OBJ_LLAMA) $(LIB_GGML)\n\t$(CXX) $(CXXFLAGS) -shared -fPIC -o $@ $^ $(LDFLAGS)\n\n$(LIB_LLAMA_S): $(OBJ_LLAMA)\n\tar rcs $(LIB_LLAMA_S) $^\n\n$(LIB_COMMON): $(OBJ_COMMON) $(LIB_LLAMA) $(LIB_GGML)\n\t$(CXX) $(CXXFLAGS) -shared -fPIC -o $@ $^ $(LDFLAGS)\n\n$(LIB_COMMON_S): $(OBJ_COMMON)\n\tar rcs $(LIB_COMMON_S) $^\n\n# Include dependency files\n-include $(DEP_FILES)\n\n# Clean generated server assets\nclean-server-assets:\n\tfind examples/server -type f -name \"*.js.hpp\"   -delete\n\tfind examples/server -type f -name \"*.mjs.hpp\"  -delete\n\tfind examples/server -type f -name \"*.css.hpp\"  -delete\n\tfind examples/server -type f -name \"*.html.hpp\" -delete\n\n# Clean rule\nclean: clean-server-assets\n\trm -vrf $(BUILD_TARGETS) $(TEST_TARGETS)\n\trm -rvf *.a *.dll *.so *.dot\n\tfind ggml src common tests examples pocs -type f -name \"*.o\" -delete\n\tfind ggml src common tests examples pocs -type f -name \"*.d\" -delete\n\n#\n# Examples\n#\n\n# $< is the first prerequisite, i.e. the source file.\n# Explicitly compile this to an object file so that it can be cached with ccache.\n# The source file is then filtered out from $^ (the list of all prerequisites) and the object file is added instead.\n\n# Helper function that replaces .c, .cpp, and .cu file endings with .o:\nGET_OBJ_FILE = $(patsubst %.c,%.o,$(patsubst %.cpp,%.o,$(patsubst %.cu,%.o,$(1))))\n\nllama-cli: examples/main/main.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\t@echo\n\t@echo '====  Run ./llama-cli -h for help.  ===='\n\t@echo\n\nllama-infill: examples/infill/infill.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-run: examples/run/run.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-simple: examples/simple/simple.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-simple-chat: examples/simple-chat/simple-chat.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-tokenize: examples/tokenize/tokenize.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-batched: examples/batched/batched.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-batched-bench: examples/batched-bench/batched-bench.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-quantize: examples/quantize/quantize.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-quantize-stats: examples/quantize-stats/quantize-stats.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-perplexity: examples/perplexity/perplexity.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-imatrix: examples/imatrix/imatrix.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-embedding: examples/embedding/embedding.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-gritlm: examples/gritlm/gritlm.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-save-load-state: examples/save-load-state/save-load-state.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-gguf: examples/gguf/gguf.cpp \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nexamples/gguf-hash/deps/sha1/sha1.o: \\\n\texamples/gguf-hash/deps/sha1/sha1.c\n\t$(CC) $(CFLAGS) -Iexamples/gguf-hash/deps -c $< -o $@\n\nexamples/gguf-hash/deps/xxhash/xxhash.o: \\\n\texamples/gguf-hash/deps/xxhash/xxhash.c\n\t$(CC) $(CFLAGS) -Iexamples/gguf-hash/deps -c $< -o $@\n\nexamples/gguf-hash/deps/sha256/sha256.o: \\\n\texamples/gguf-hash/deps/sha256/sha256.c\n\t$(CC) $(CFLAGS) -Iexamples/gguf-hash/deps -c $< -o $@\n\nllama-gguf-hash: examples/gguf-hash/gguf-hash.cpp examples/gguf-hash/deps/sha1/sha1.o examples/gguf-hash/deps/xxhash/xxhash.o examples/gguf-hash/deps/sha256/sha256.o\\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -Iexamples/gguf-hash/deps -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-gguf-split: examples/gguf-split/gguf-split.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-eval-callback: examples/eval-callback/eval-callback.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-cvector-generator: examples/cvector-generator/cvector-generator.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-convert-llama2c-to-ggml: examples/convert-llama2c-to-ggml/convert-llama2c-to-ggml.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-bench: examples/llama-bench/llama-bench.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-export-lora: examples/export-lora/export-lora.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-retrieval: examples/retrieval/retrieval.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-speculative: examples/speculative/speculative.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-parallel: examples/parallel/parallel.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-lookahead: examples/lookahead/lookahead.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-lookup: examples/lookup/lookup.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-lookup-create: examples/lookup/lookup-create.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-lookup-merge: examples/lookup/lookup-merge.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-lookup-stats: examples/lookup/lookup-stats.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-passkey: examples/passkey/passkey.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-gbnf-validator: examples/gbnf-validator/gbnf-validator.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nifdef GGML_RPC\nrpc-server: examples/rpc/rpc-server.cpp \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) $^ -o $@ $(LDFLAGS)\nendif # GGML_RPC\n\nllama-server: \\\n\texamples/server/server.cpp \\\n\texamples/server/utils.hpp \\\n\texamples/server/httplib.h \\\n\texamples/server/index.html.hpp \\\n\texamples/server/loading.html.hpp \\\n\tcommon/json.hpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h %.hpp $<,$^) -Iexamples/server $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS) $(LWINSOCK2)\n\n# Portable equivalent of `cd examples/server/public && xxd -i $(notdir $<) ../$(notdir $<).hpp`:\nexamples/server/%.hpp: examples/server/public/% FORCE Makefile\n\t@( export NAME=$(subst .,_,$(subst -,_,$(notdir $<))) && \\\n\t\techo \"unsigned char $${NAME}[] = {\" && \\\n\t\tcat $< | od -v -t x1 -An | sed -E 's/([0-9a-fA-F]+)/0x\\1, /g' && \\\n\t\techo \"};\" && \\\n\t\techo \"unsigned int $${NAME}_len = $(shell cat $< | wc -c );\" \\\n\t) > $@\n\nllama-gen-docs: examples/gen-docs/gen-docs.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nlibllava.a: examples/llava/llava.cpp \\\n\texamples/llava/llava.h \\\n\texamples/llava/clip.cpp \\\n\texamples/llava/clip.h \\\n\tcommon/stb_image.h \\\n\tcommon/base64.hpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -static -fPIC -c $< -o $@ -Wno-cast-qual\n\nllama-llava-cli: examples/llava/llava-cli.cpp \\\n\texamples/llava/llava.cpp \\\n\texamples/llava/llava.h \\\n\texamples/llava/clip.cpp \\\n\texamples/llava/clip.h \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) $< $(filter-out %.h $<,$^) -o $@ $(LDFLAGS) -Wno-cast-qual\n\nllama-minicpmv-cli: examples/llava/minicpmv-cli.cpp \\\n\texamples/llava/llava.cpp \\\n\texamples/llava/llava.h \\\n\texamples/llava/clip.cpp \\\n\texamples/llava/clip.h \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) $< $(filter-out %.h $<,$^) -o $@ $(LDFLAGS) -Wno-cast-qual\n\nllama-qwen2vl-cli: examples/llava/qwen2vl-cli.cpp \\\n\texamples/llava/llava.cpp \\\n\texamples/llava/llava.h \\\n\texamples/llava/clip.cpp \\\n\texamples/llava/clip.h \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) $< $(filter-out %.h $<,$^) -o $@ $(LDFLAGS) -Wno-cast-qual\n\nifeq ($(UNAME_S),Darwin)\nswift: examples/batched.swift\n\t(cd examples/batched.swift; make build)\nendif\n\ncommon/build-info.cpp: $(wildcard .git/index) scripts/build-info.sh\n\t@sh scripts/build-info.sh \"$(CC)\" > $@.tmp\n\t@if ! cmp -s $@.tmp $@; then \\\n\t\tmv $@.tmp $@; \\\n\telse \\\n\t\trm $@.tmp; \\\n\tfi\n\ncommon/build-info.o: common/build-info.cpp\n\t$(CXX) $(CXXFLAGS) -c $(filter-out %.h,$^) -o $@\n\n#\n# Tests\n#\n\ntests: $(TEST_TARGETS)\n\ntests/test-arg-parser: tests/test-arg-parser.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-llama-grammar: tests/test-llama-grammar.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-log: tests/test-log.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-grammar-parser: tests/test-grammar-parser.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-grammar-integration: tests/test-grammar-integration.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-double-float: tests/test-double-float.cpp\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-json-schema-to-grammar: tests/test-json-schema-to-grammar.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -Iexamples/server -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-opt: tests/test-opt.cpp \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-quantize-fns: tests/test-quantize-fns.cpp \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-quantize-perf: tests/test-quantize-perf.cpp \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-sampling: tests/test-sampling.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-tokenizer-0: tests/test-tokenizer-0.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-tokenizer-1-bpe: tests/test-tokenizer-1-bpe.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-tokenizer-1-spm: tests/test-tokenizer-1-spm.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-rope: tests/test-rope.cpp ggml/src/ggml.o \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-c.o: tests/test-c.c include/llama.h\n\t$(CC) $(CFLAGS) -c $(filter-out %.h,$^) -o $@\n\ntests/test-backend-ops: tests/test-backend-ops.cpp \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-model-load-cancel: tests/test-model-load-cancel.cpp tests/get-model.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-autorelease: tests/test-autorelease.cpp tests/get-model.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\ntests/test-chat-template: tests/test-chat-template.cpp \\\n\t$(OBJ_ALL)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out %.h $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\n#\n# PoCs\n#\n\nllama-vdot: pocs/vdot/vdot.cpp ggml/src/ggml.o \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\nllama-q8dot: pocs/vdot/q8dot.cpp ggml/src/ggml.o \\\n\t$(OBJ_GGML)\n\t$(CXX) $(CXXFLAGS) -c $< -o $(call GET_OBJ_FILE, $<)\n\t$(CXX) $(CXXFLAGS) $(filter-out $<,$^) $(call GET_OBJ_FILE, $<) -o $@ $(LDFLAGS)\n\n#\n# Deprecated binaries that we want to keep around long enough for people to migrate to the new filenames, then these can be removed.\n#\n# Mark legacy binary targets as .PHONY so that they are always checked.\n.PHONY: FORCE main quantize perplexity embedding server\n\n# Define the object file target\nexamples/deprecation-warning/deprecation-warning.o: examples/deprecation-warning/deprecation-warning.cpp\n\t$(CXX) $(CXXFLAGS) -c $< -o $@\n\n# NOTE: We currently will always build the deprecation-warning `main` and `server` binaries to help users migrate.\n#  Eventually we will want to remove these target from building all the time.\nmain: examples/deprecation-warning/deprecation-warning.o\n\t$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)\n\t@echo \"NOTICE: The 'main' binary is deprecated. Please use 'llama-cli' instead.\"\n\nserver: examples/deprecation-warning/deprecation-warning.o\n\t$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)\n\t@echo \"NOTICE: The 'server' binary is deprecated. Please use 'llama-server' instead.\"\n\nquantize: examples/deprecation-warning/deprecation-warning.o\nifneq (,$(wildcard quantize))\n\t$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)\n\t@echo \"#########\"\n\t@echo \"WARNING: The 'quantize' binary is deprecated. Please use 'llama-quantize' instead.\"\n\t@echo \"  Remove the 'quantize' binary to remove this warning.\"\n\t@echo \"#########\"\nendif\n\nperplexity: examples/deprecation-warning/deprecation-warning.o\nifneq (,$(wildcard perplexity))\n\t$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)\n\t@echo \"#########\"\n\t@echo \"WARNING: The 'perplexity' binary is deprecated. Please use 'llama-perplexity' instead.\"\n\t@echo \"  Remove the 'perplexity' binary to remove this warning.\"\n\t@echo \"#########\"\nendif\n\nembedding: examples/deprecation-warning/deprecation-warning.o\nifneq (,$(wildcard embedding))\n\t$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)\n\t@echo \"#########\"\n\t@echo \"WARNING: The 'embedding' binary is deprecated. Please use 'llama-embedding' instead.\"\n\t@echo \"  Remove the 'embedding' binary to remove this warning.\"\n\t@echo \"#########\"\nendif\n"
        },
        {
          "name": "Package.swift",
          "type": "blob",
          "size": 0.35546875,
          "content": "// swift-tools-version:5.5\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"llama\",\n    platforms: [\n        .macOS(.v12),\n        .iOS(.v14),\n        .watchOS(.v4),\n        .tvOS(.v14)\n    ],\n    products: [\n        .library(name: \"llama\", targets: [\"llama\"]),\n    ],\n    targets: [\n        .systemLibrary(name: \"llama\", pkgConfig: \"llama\"),\n    ]\n)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.9921875,
          "content": "# llama.cpp\n\n![llama](https://user-images.githubusercontent.com/1991296/230134379-7181e485-c521-4d23-a0d6-f7b3b61ba524.png)\n\n[![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT)\n[![Server](https://github.com/ggerganov/llama.cpp/actions/workflows/server.yml/badge.svg)](https://github.com/ggerganov/llama.cpp/actions/workflows/server.yml)\n\n[Roadmap](https://github.com/users/ggerganov/projects/7) / [Project status](https://github.com/ggerganov/llama.cpp/discussions/3471) / [Manifesto](https://github.com/ggerganov/llama.cpp/discussions/205) / [ggml](https://github.com/ggerganov/ggml)\n\nInference of Meta's [LLaMA](https://arxiv.org/abs/2302.13971) model (and others) in pure C/C++\n\n## Recent API changes\n\n- [Changelog for `libllama` API](https://github.com/ggerganov/llama.cpp/issues/9289)\n- [Changelog for `llama-server` REST API](https://github.com/ggerganov/llama.cpp/issues/9291)\n\n## Hot topics\n\n- **Introducing GGUF-my-LoRA** https://github.com/ggerganov/llama.cpp/discussions/10123\n- Hugging Face Inference Endpoints now support GGUF out of the box! https://github.com/ggerganov/llama.cpp/discussions/9669\n- Hugging Face GGUF editor: [discussion](https://github.com/ggerganov/llama.cpp/discussions/9268) | [tool](https://huggingface.co/spaces/CISCai/gguf-editor)\n\n----\n\n## Description\n\nThe main goal of `llama.cpp` is to enable LLM inference with minimal setup and state-of-the-art performance on a wide\nrange of hardware - locally and in the cloud.\n\n- Plain C/C++ implementation without any dependencies\n- Apple silicon is a first-class citizen - optimized via ARM NEON, Accelerate and Metal frameworks\n- AVX, AVX2, AVX512 and AMX support for x86 architectures\n- 1.5-bit, 2-bit, 3-bit, 4-bit, 5-bit, 6-bit, and 8-bit integer quantization for faster inference and reduced memory use\n- Custom CUDA kernels for running LLMs on NVIDIA GPUs (support for AMD GPUs via HIP and Moore Threads MTT GPUs via MUSA)\n- Vulkan and SYCL backend support\n- CPU+GPU hybrid inference to partially accelerate models larger than the total VRAM capacity\n\nThe `llama.cpp` project is the main playground for developing new features for the [ggml](https://github.com/ggerganov/ggml) library.\n\n<details>\n<summary>Models</summary>\n\nTypically finetunes of the base models below are supported as well.\n\nInstructions for adding support for new models: [HOWTO-add-model.md](docs/development/HOWTO-add-model.md)\n\n#### Text-only\n\n- [X] LLaMA 🦙\n- [x] LLaMA 2 🦙🦙\n- [x] LLaMA 3 🦙🦙🦙\n- [X] [Mistral 7B](https://huggingface.co/mistralai/Mistral-7B-v0.1)\n- [x] [Mixtral MoE](https://huggingface.co/models?search=mistral-ai/Mixtral)\n- [x] [DBRX](https://huggingface.co/databricks/dbrx-instruct)\n- [X] [Falcon](https://huggingface.co/models?search=tiiuae/falcon)\n- [X] [Chinese LLaMA / Alpaca](https://github.com/ymcui/Chinese-LLaMA-Alpaca) and [Chinese LLaMA-2 / Alpaca-2](https://github.com/ymcui/Chinese-LLaMA-Alpaca-2)\n- [X] [Vigogne (French)](https://github.com/bofenghuang/vigogne)\n- [X] [BERT](https://github.com/ggerganov/llama.cpp/pull/5423)\n- [X] [Koala](https://bair.berkeley.edu/blog/2023/04/03/koala/)\n- [X] [Baichuan 1 & 2](https://huggingface.co/models?search=baichuan-inc/Baichuan) + [derivations](https://huggingface.co/hiyouga/baichuan-7b-sft)\n- [X] [Aquila 1 & 2](https://huggingface.co/models?search=BAAI/Aquila)\n- [X] [Starcoder models](https://github.com/ggerganov/llama.cpp/pull/3187)\n- [X] [Refact](https://huggingface.co/smallcloudai/Refact-1_6B-fim)\n- [X] [MPT](https://github.com/ggerganov/llama.cpp/pull/3417)\n- [X] [Bloom](https://github.com/ggerganov/llama.cpp/pull/3553)\n- [x] [Yi models](https://huggingface.co/models?search=01-ai/Yi)\n- [X] [StableLM models](https://huggingface.co/stabilityai)\n- [x] [Deepseek models](https://huggingface.co/models?search=deepseek-ai/deepseek)\n- [x] [Qwen models](https://huggingface.co/models?search=Qwen/Qwen)\n- [x] [PLaMo-13B](https://github.com/ggerganov/llama.cpp/pull/3557)\n- [x] [Phi models](https://huggingface.co/models?search=microsoft/phi)\n- [x] [PhiMoE](https://github.com/ggerganov/llama.cpp/pull/11003)\n- [x] [GPT-2](https://huggingface.co/gpt2)\n- [x] [Orion 14B](https://github.com/ggerganov/llama.cpp/pull/5118)\n- [x] [InternLM2](https://huggingface.co/models?search=internlm2)\n- [x] [CodeShell](https://github.com/WisdomShell/codeshell)\n- [x] [Gemma](https://ai.google.dev/gemma)\n- [x] [Mamba](https://github.com/state-spaces/mamba)\n- [x] [Grok-1](https://huggingface.co/keyfan/grok-1-hf)\n- [x] [Xverse](https://huggingface.co/models?search=xverse)\n- [x] [Command-R models](https://huggingface.co/models?search=CohereForAI/c4ai-command-r)\n- [x] [SEA-LION](https://huggingface.co/models?search=sea-lion)\n- [x] [GritLM-7B](https://huggingface.co/GritLM/GritLM-7B) + [GritLM-8x7B](https://huggingface.co/GritLM/GritLM-8x7B)\n- [x] [OLMo](https://allenai.org/olmo)\n- [x] [OLMo 2](https://allenai.org/olmo)\n- [x] [OLMoE](https://huggingface.co/allenai/OLMoE-1B-7B-0924)\n- [x] [Granite models](https://huggingface.co/collections/ibm-granite/granite-code-models-6624c5cec322e4c148c8b330)\n- [x] [GPT-NeoX](https://github.com/EleutherAI/gpt-neox) + [Pythia](https://github.com/EleutherAI/pythia)\n- [x] [Snowflake-Arctic MoE](https://huggingface.co/collections/Snowflake/arctic-66290090abe542894a5ac520)\n- [x] [Smaug](https://huggingface.co/models?search=Smaug)\n- [x] [Poro 34B](https://huggingface.co/LumiOpen/Poro-34B)\n- [x] [Bitnet b1.58 models](https://huggingface.co/1bitLLM)\n- [x] [Flan T5](https://huggingface.co/models?search=flan-t5)\n- [x] [Open Elm models](https://huggingface.co/collections/apple/openelm-instruct-models-6619ad295d7ae9f868b759ca)\n- [x] [ChatGLM3-6b](https://huggingface.co/THUDM/chatglm3-6b) + [ChatGLM4-9b](https://huggingface.co/THUDM/glm-4-9b)\n- [x] [SmolLM](https://huggingface.co/collections/HuggingFaceTB/smollm-6695016cad7167254ce15966)\n- [x] [EXAONE-3.0-7.8B-Instruct](https://huggingface.co/LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct)\n- [x] [FalconMamba Models](https://huggingface.co/collections/tiiuae/falconmamba-7b-66b9a580324dd1598b0f6d4a)\n- [x] [Jais](https://huggingface.co/inceptionai/jais-13b-chat)\n- [x] [Bielik-11B-v2.3](https://huggingface.co/collections/speakleash/bielik-11b-v23-66ee813238d9b526a072408a)\n- [x] [RWKV-6](https://github.com/BlinkDL/RWKV-LM)\n- [x] [QRWKV-6](https://huggingface.co/recursal/QRWKV6-32B-Instruct-Preview-v0.1)\n- [x] [GigaChat-20B-A3B](https://huggingface.co/ai-sage/GigaChat-20B-A3B-instruct)\n\n#### Multimodal\n\n- [x] [LLaVA 1.5 models](https://huggingface.co/collections/liuhaotian/llava-15-653aac15d994e992e2677a7e), [LLaVA 1.6 models](https://huggingface.co/collections/liuhaotian/llava-16-65b9e40155f60fd046a5ccf2)\n- [x] [BakLLaVA](https://huggingface.co/models?search=SkunkworksAI/Bakllava)\n- [x] [Obsidian](https://huggingface.co/NousResearch/Obsidian-3B-V0.5)\n- [x] [ShareGPT4V](https://huggingface.co/models?search=Lin-Chen/ShareGPT4V)\n- [x] [MobileVLM 1.7B/3B models](https://huggingface.co/models?search=mobileVLM)\n- [x] [Yi-VL](https://huggingface.co/models?search=Yi-VL)\n- [x] [Mini CPM](https://huggingface.co/models?search=MiniCPM)\n- [x] [Moondream](https://huggingface.co/vikhyatk/moondream2)\n- [x] [Bunny](https://github.com/BAAI-DCAI/Bunny)\n- [x] [Qwen2-VL](https://huggingface.co/collections/Qwen/qwen2-vl-66cee7455501d7126940800d)\n\n</details>\n\n<details>\n<summary>Bindings</summary>\n\n- Python: [abetlen/llama-cpp-python](https://github.com/abetlen/llama-cpp-python)\n- Go: [go-skynet/go-llama.cpp](https://github.com/go-skynet/go-llama.cpp)\n- Node.js: [withcatai/node-llama-cpp](https://github.com/withcatai/node-llama-cpp)\n- JS/TS (llama.cpp server client): [lgrammel/modelfusion](https://modelfusion.dev/integration/model-provider/llamacpp)\n- JS/TS (Programmable Prompt Engine CLI): [offline-ai/cli](https://github.com/offline-ai/cli)\n- JavaScript/Wasm (works in browser): [tangledgroup/llama-cpp-wasm](https://github.com/tangledgroup/llama-cpp-wasm)\n- Typescript/Wasm (nicer API, available on npm): [ngxson/wllama](https://github.com/ngxson/wllama)\n- Ruby: [yoshoku/llama_cpp.rb](https://github.com/yoshoku/llama_cpp.rb)\n- Rust (more features): [edgenai/llama_cpp-rs](https://github.com/edgenai/llama_cpp-rs)\n- Rust (nicer API): [mdrokz/rust-llama.cpp](https://github.com/mdrokz/rust-llama.cpp)\n- Rust (more direct bindings): [utilityai/llama-cpp-rs](https://github.com/utilityai/llama-cpp-rs)\n- C#/.NET: [SciSharp/LLamaSharp](https://github.com/SciSharp/LLamaSharp)\n- C#/VB.NET (more features - community license): [LM-Kit.NET](https://docs.lm-kit.com/lm-kit-net/index.html)\n- Scala 3: [donderom/llm4s](https://github.com/donderom/llm4s)\n- Clojure: [phronmophobic/llama.clj](https://github.com/phronmophobic/llama.clj)\n- React Native: [mybigday/llama.rn](https://github.com/mybigday/llama.rn)\n- Java: [kherud/java-llama.cpp](https://github.com/kherud/java-llama.cpp)\n- Zig: [deins/llama.cpp.zig](https://github.com/Deins/llama.cpp.zig)\n- Flutter/Dart: [netdur/llama_cpp_dart](https://github.com/netdur/llama_cpp_dart)\n- Flutter: [xuegao-tzx/Fllama](https://github.com/xuegao-tzx/Fllama)\n- PHP (API bindings and features built on top of llama.cpp): [distantmagic/resonance](https://github.com/distantmagic/resonance) [(more info)](https://github.com/ggerganov/llama.cpp/pull/6326)\n- Guile Scheme: [guile_llama_cpp](https://savannah.nongnu.org/projects/guile-llama-cpp)\n- Swift [srgtuszy/llama-cpp-swift](https://github.com/srgtuszy/llama-cpp-swift)\n- Swift [ShenghaiWang/SwiftLlama](https://github.com/ShenghaiWang/SwiftLlama)\n\n</details>\n\n<details>\n<summary>UIs</summary>\n\n*(to have a project listed here, it should clearly state that it depends on `llama.cpp`)*\n\n- [AI Sublime Text plugin](https://github.com/yaroslavyaroslav/OpenAI-sublime-text) (MIT)\n- [cztomsik/ava](https://github.com/cztomsik/ava) (MIT)\n- [Dot](https://github.com/alexpinel/Dot) (GPL)\n- [eva](https://github.com/ylsdamxssjxxdd/eva) (MIT)\n- [iohub/collama](https://github.com/iohub/coLLaMA) (Apache-2.0)\n- [janhq/jan](https://github.com/janhq/jan) (AGPL)\n- [KanTV](https://github.com/zhouwg/kantv?tab=readme-ov-file) (Apache-2.0)\n- [KodiBot](https://github.com/firatkiral/kodibot) (GPL)\n- [llama.vim](https://github.com/ggml-org/llama.vim) (MIT)\n- [LARS](https://github.com/abgulati/LARS) (AGPL)\n- [Llama Assistant](https://github.com/vietanhdev/llama-assistant) (GPL)\n- [LLMFarm](https://github.com/guinmoon/LLMFarm?tab=readme-ov-file) (MIT)\n- [LLMUnity](https://github.com/undreamai/LLMUnity) (MIT)\n- [LMStudio](https://lmstudio.ai/) (proprietary)\n- [LocalAI](https://github.com/mudler/LocalAI) (MIT)\n- [LostRuins/koboldcpp](https://github.com/LostRuins/koboldcpp) (AGPL)\n- [MindMac](https://mindmac.app) (proprietary)\n- [MindWorkAI/AI-Studio](https://github.com/MindWorkAI/AI-Studio) (FSL-1.1-MIT)\n- [Mobile-Artificial-Intelligence/maid](https://github.com/Mobile-Artificial-Intelligence/maid) (MIT)\n- [Mozilla-Ocho/llamafile](https://github.com/Mozilla-Ocho/llamafile) (Apache-2.0)\n- [nat/openplayground](https://github.com/nat/openplayground) (MIT)\n- [nomic-ai/gpt4all](https://github.com/nomic-ai/gpt4all) (MIT)\n- [ollama/ollama](https://github.com/ollama/ollama) (MIT)\n- [oobabooga/text-generation-webui](https://github.com/oobabooga/text-generation-webui) (AGPL)\n- [PocketPal AI](https://github.com/a-ghorbani/pocketpal-ai) (MIT)\n- [psugihara/FreeChat](https://github.com/psugihara/FreeChat) (MIT)\n- [ptsochantaris/emeltal](https://github.com/ptsochantaris/emeltal) (MIT)\n- [pythops/tenere](https://github.com/pythops/tenere) (AGPL)\n- [ramalama](https://github.com/containers/ramalama) (MIT)\n- [semperai/amica](https://github.com/semperai/amica) (MIT)\n- [withcatai/catai](https://github.com/withcatai/catai) (MIT)\n\n</details>\n\n<details>\n<summary>Tools</summary>\n\n- [akx/ggify](https://github.com/akx/ggify) – download PyTorch models from HuggingFace Hub and convert them to GGML\n- [akx/ollama-dl](https://github.com/akx/ollama-dl) – download models from the Ollama library to be used directly with llama.cpp\n- [crashr/gppm](https://github.com/crashr/gppm) – launch llama.cpp instances utilizing NVIDIA Tesla P40 or P100 GPUs with reduced idle power consumption\n- [gpustack/gguf-parser](https://github.com/gpustack/gguf-parser-go/tree/main/cmd/gguf-parser) - review/check the GGUF file and estimate the memory usage\n- [Styled Lines](https://marketplace.unity.com/packages/tools/generative-ai/styled-lines-llama-cpp-model-292902) (proprietary licensed, async wrapper of inference part for game development in Unity3d with pre-built Mobile and Web platform wrappers and a model example)\n\n</details>\n\n<details>\n<summary>Infrastructure</summary>\n\n- [Paddler](https://github.com/distantmagic/paddler) - Stateful load balancer custom-tailored for llama.cpp\n- [GPUStack](https://github.com/gpustack/gpustack) - Manage GPU clusters for running LLMs\n- [llama_cpp_canister](https://github.com/onicai/llama_cpp_canister) - llama.cpp as a smart contract on the Internet Computer, using WebAssembly\n- [llama-swap](https://github.com/mostlygeek/llama-swap) - transparent proxy that adds automatic model switching with llama-server\n\n</details>\n\n<details>\n<summary>Games</summary>\n\n- [Lucy's Labyrinth](https://github.com/MorganRO8/Lucys_Labyrinth) - A simple maze game where agents controlled by an AI model will try to trick you.\n\n</details>\n\n## Supported backends\n\n| Backend | Target devices |\n| --- | --- |\n| [Metal](docs/build.md#metal-build) | Apple Silicon |\n| [BLAS](docs/build.md#blas-build) | All |\n| [BLIS](docs/backend/BLIS.md) | All |\n| [SYCL](docs/backend/SYCL.md) | Intel and Nvidia GPU |\n| [MUSA](docs/build.md#musa) | Moore Threads MTT GPU |\n| [CUDA](docs/build.md#cuda) | Nvidia GPU |\n| [HIP](docs/build.md#hip) | AMD GPU |\n| [Vulkan](docs/build.md#vulkan) | GPU |\n| [CANN](docs/build.md#cann) | Ascend NPU |\n\n## Building the project\n\nThe main product of this project is the `llama` library. Its C-style interface can be found in [include/llama.h](include/llama.h).\nThe project also includes many example programs and tools using the `llama` library. The examples range from simple, minimal code snippets to sophisticated sub-projects such as an OpenAI-compatible HTTP server. Possible methods for obtaining the binaries:\n\n- Clone this repository and build locally, see [how to build](docs/build.md)\n- On MacOS or Linux, install `llama.cpp` via [brew, flox or nix](docs/install.md)\n- Use a Docker image, see [documentation for Docker](docs/docker.md)\n- Download pre-built binaries from [releases](https://github.com/ggerganov/llama.cpp/releases)\n\n## Obtaining and quantizing models\n\nThe [Hugging Face](https://huggingface.co) platform hosts a [number of LLMs](https://huggingface.co/models?library=gguf&sort=trending) compatible with `llama.cpp`:\n\n- [Trending](https://huggingface.co/models?library=gguf&sort=trending)\n- [LLaMA](https://huggingface.co/models?sort=trending&search=llama+gguf)\n\nAfter downloading a model, use the CLI tools to run it locally - see below.\n\n`llama.cpp` requires the model to be stored in the [GGUF](https://github.com/ggerganov/ggml/blob/master/docs/gguf.md) file format. Models in other data formats can be converted to GGUF using the `convert_*.py` Python scripts in this repo.\n\nThe Hugging Face platform provides a variety of online tools for converting, quantizing and hosting models with `llama.cpp`:\n\n- Use the [GGUF-my-repo space](https://huggingface.co/spaces/ggml-org/gguf-my-repo) to convert to GGUF format and quantize model weights to smaller sizes\n- Use the [GGUF-my-LoRA space](https://huggingface.co/spaces/ggml-org/gguf-my-lora) to convert LoRA adapters to GGUF format (more info: https://github.com/ggerganov/llama.cpp/discussions/10123)\n- Use the [GGUF-editor space](https://huggingface.co/spaces/CISCai/gguf-editor) to edit GGUF meta data in the browser (more info: https://github.com/ggerganov/llama.cpp/discussions/9268)\n- Use the [Inference Endpoints](https://ui.endpoints.huggingface.co/) to directly host `llama.cpp` in the cloud (more info: https://github.com/ggerganov/llama.cpp/discussions/9669)\n\nTo learn more about model quantization, [read this documentation](examples/quantize/README.md)\n\n## [`llama-cli`](examples/main)\n\n#### A CLI tool for accessing and experimenting with most of `llama.cpp`'s functionality.\n\n- <details open>\n    <summary>Run simple text completion</summary>\n\n    ```bash\n    llama-cli -m model.gguf -p \"I believe the meaning of life is\" -n 128\n\n    # I believe the meaning of life is to find your own truth and to live in accordance with it. For me, this means being true to myself and following my passions, even if they don't align with societal expectations. I think that's what I love about yoga – it's not just a physical practice, but a spiritual one too. It's about connecting with yourself, listening to your inner voice, and honoring your own unique journey.\n    ```\n\n    </details>\n\n- <details>\n    <summary>Run in conversation mode</summary>\n\n    ```bash\n    llama-cli -m model.gguf -p \"You are a helpful assistant\" -cnv\n\n    # > hi, who are you?\n    # Hi there! I'm your helpful assistant! I'm an AI-powered chatbot designed to assist and provide information to users like you. I'm here to help answer your questions, provide guidance, and offer support on a wide range of topics. I'm a friendly and knowledgeable AI, and I'm always happy to help with anything you need. What's on your mind, and how can I assist you today?\n    #\n    # > what is 1+1?\n    # Easy peasy! The answer to 1+1 is... 2!\n    ```\n\n    </details>\n\n- <details>\n    <summary>Run with custom chat template</summary>\n\n    ```bash\n    # use the \"chatml\" template\n    llama-cli -m model.gguf -p \"You are a helpful assistant\" -cnv --chat-template chatml\n\n    # use a custom template\n    llama-cli -m model.gguf -p \"You are a helpful assistant\" -cnv --in-prefix 'User: ' --reverse-prompt 'User:'\n    ```\n\n    [Supported templates](https://github.com/ggerganov/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template)\n\n    </details>\n\n- <details>\n    <summary>Constrain the output with a custom grammar</summary>\n\n    ```bash\n    llama-cli -m model.gguf -n 256 --grammar-file grammars/json.gbnf -p 'Request: schedule a call at 8pm; Command:'\n\n    # {\"appointmentTime\": \"8pm\", \"appointmentDetails\": \"schedule a a call\"}\n    ```\n\n    The [grammars/](grammars/) folder contains a handful of sample grammars. To write your own, check out the [GBNF Guide](grammars/README.md).\n\n    For authoring more complex JSON grammars, check out https://grammar.intrinsiclabs.ai/\n\n    </details>\n\n\n## [`llama-server`](examples/server)\n\n#### A lightweight, [OpenAI API](https://github.com/openai/openai-openapi) compatible, HTTP server for serving LLMs.\n\n- <details open>\n    <summary>Start a local HTTP server with default configuration on port 8080</summary>\n\n    ```bash\n    llama-server -m model.gguf --port 8080\n\n    # Basic web UI can be accessed via browser: http://localhost:8080\n    # Chat completion endpoint: http://localhost:8080/v1/chat/completions\n    ```\n\n    </details>\n\n- <details>\n    <summary>Support multiple-users and parallel decoding</summary>\n\n    ```bash\n    # up to 4 concurrent requests, each with 4096 max context\n    llama-server -m model.gguf -c 16384 -np 4\n    ```\n\n    </details>\n\n- <details>\n    <summary>Enable speculative decoding</summary>\n\n    ```bash\n    # the draft.gguf model should be a small variant of the target model.gguf\n    llama-server -m model.gguf -md draft.gguf\n    ```\n\n    </details>\n\n- <details>\n    <summary>Serve an embedding model</summary>\n\n    ```bash\n    # use the /embedding endpoint\n    llama-server -m model.gguf --embedding --pooling cls -ub 8192\n    ```\n\n    </details>\n\n- <details>\n    <summary>Serve a reranking model</summary>\n\n    ```bash\n    # use the /reranking endpoint\n    llama-server -m model.gguf --reranking\n    ```\n\n    </details>\n\n- <details>\n    <summary>Constrain all outputs with a grammar</summary>\n\n    ```bash\n    # custom grammar\n    llama-server -m model.gguf --grammar-file grammar.gbnf\n\n    # JSON\n    llama-server -m model.gguf --grammar-file grammars/json.gbnf\n    ```\n\n    </details>\n\n\n## [`llama-perplexity`](examples/perplexity)\n\n#### A tool for measuring the perplexity [^1][^2] (and other quality metrics) of a model over a given text.\n\n- <details open>\n    <summary>Measure the perplexity over a text file</summary>\n\n    ```bash\n    llama-perplexity -m model.gguf -f file.txt\n\n    # [1]15.2701,[2]5.4007,[3]5.3073,[4]6.2965,[5]5.8940,[6]5.6096,[7]5.7942,[8]4.9297, ...\n    # Final estimate: PPL = 5.4007 +/- 0.67339\n    ```\n\n    </details>\n\n- <details>\n    <summary>Measure KL divergence</summary>\n\n    ```bash\n    # TODO\n    ```\n\n    </details>\n\n[^1]: [examples/perplexity/README.md](examples/perplexity/README.md)\n[^2]: [https://huggingface.co/docs/transformers/perplexity](https://huggingface.co/docs/transformers/perplexity)\n\n## [`llama-bench`](examples/llama-bench)\n\n#### Benchmark the performance of the inference for various parameters.\n\n- <details open>\n    <summary>Run default benchmark</summary>\n\n    ```bash\n    llama-bench -m model.gguf\n\n    # Output:\n    # | model               |       size |     params | backend    | threads |          test |                  t/s |\n    # | ------------------- | ---------: | ---------: | ---------- | ------: | ------------: | -------------------: |\n    # | qwen2 1.5B Q4_0     | 885.97 MiB |     1.54 B | Metal,BLAS |      16 |         pp512 |      5765.41 ± 20.55 |\n    # | qwen2 1.5B Q4_0     | 885.97 MiB |     1.54 B | Metal,BLAS |      16 |         tg128 |        197.71 ± 0.81 |\n    #\n    # build: 3e0ba0e60 (4229)\n    ```\n\n    </details>\n\n## [`llama-run`](examples/run)\n\n#### A comprehensive example for running `llama.cpp` models. Useful for inferencing. Used with RamaLama [^3].\n\n- <details>\n    <summary>Run a model with a specific prompt (by default it's pulled from Ollama registry)</summary>\n\n    ```bash\n    llama-run granite-code\n    ```\n\n    </details>\n\n[^3]: [RamaLama](https://github.com/containers/ramalama)\n\n## [`llama-simple`](examples/simple)\n\n#### A minimal example for implementing apps with `llama.cpp`. Useful for developers.\n\n- <details>\n    <summary>Basic text completion</summary>\n\n    ```bash\n    llama-simple -m model.gguf\n\n    # Hello my name is Kaitlyn and I am a 16 year old girl. I am a junior in high school and I am currently taking a class called \"The Art of\n    ```\n\n    </details>\n\n\n## Contributing\n\n- Contributors can open PRs\n- Collaborators can push to branches in the `llama.cpp` repo and merge PRs into the `master` branch\n- Collaborators will be invited based on contributions\n- Any help with managing issues, PRs and projects is very appreciated!\n- See [good first issues](https://github.com/ggerganov/llama.cpp/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) for tasks suitable for first contributions\n- Read the [CONTRIBUTING.md](CONTRIBUTING.md) for more information\n- Make sure to read this: [Inference at the edge](https://github.com/ggerganov/llama.cpp/discussions/205)\n- A bit of backstory for those who are interested: [Changelog podcast](https://changelog.com/podcast/532)\n\n## Other documentation\n\n- [main (cli)](examples/main/README.md)\n- [server](examples/server/README.md)\n- [GBNF grammars](grammars/README.md)\n\n#### Development documentation\n\n- [How to build](docs/build.md)\n- [Running on Docker](docs/docker.md)\n- [Build on Android](docs/android.md)\n- [Performance troubleshooting](docs/development/token_generation_performance_tips.md)\n- [GGML tips & tricks](https://github.com/ggerganov/llama.cpp/wiki/GGML-Tips-&-Tricks)\n\n#### Seminal papers and background on the models\n\nIf your issue is with model generation quality, then please at least scan the following links and papers to understand the limitations of LLaMA models. This is especially important when choosing an appropriate model size and appreciating both the significant and subtle differences between LLaMA models and ChatGPT:\n- LLaMA:\n    - [Introducing LLaMA: A foundational, 65-billion-parameter large language model](https://ai.facebook.com/blog/large-language-model-llama-meta-ai/)\n    - [LLaMA: Open and Efficient Foundation Language Models](https://arxiv.org/abs/2302.13971)\n- GPT-3\n    - [Language Models are Few-Shot Learners](https://arxiv.org/abs/2005.14165)\n- GPT-3.5 / InstructGPT / ChatGPT:\n    - [Aligning language models to follow instructions](https://openai.com/research/instruction-following)\n    - [Training language models to follow instructions with human feedback](https://arxiv.org/abs/2203.02155)\n\n#### References\n\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 4.970703125,
          "content": "# Security Policy\n\n - [**Using llama.cpp securely**](#using-llamacpp-securely)\n   - [Untrusted models](#untrusted-models)\n   - [Untrusted inputs](#untrusted-inputs)\n   - [Data privacy](#data-privacy)\n   - [Untrusted environments or networks](#untrusted-environments-or-networks)\n   - [Multi-Tenant environments](#multi-tenant-environments)\n - [**Reporting a vulnerability**](#reporting-a-vulnerability)\n\n## Using llama.cpp securely\n\n### Untrusted models\nBe careful when running untrusted models. This classification includes models created by unknown developers or utilizing data obtained from unknown sources.\n\n*Always execute untrusted models within a secure, isolated environment such as a sandbox* (e.g., containers, virtual machines). This helps protect your system from potentially malicious code.\n\n> [!NOTE]\n> The trustworthiness of a model is not binary. You must always determine the proper level of caution depending on the specific model and how it matches your use case and risk tolerance.\n\n### Untrusted inputs\n\nSome models accept various input formats (text, images, audio, etc.). The libraries converting these inputs have varying security levels, so it's crucial to isolate the model and carefully pre-process inputs to mitigate script injection risks.\n\nFor maximum security when handling untrusted inputs, you may need to employ the following:\n\n* Sandboxing: Isolate the environment where the inference happens.\n* Pre-analysis: Check how the model performs by default when exposed to prompt injection (e.g. using [fuzzing for prompt injection](https://github.com/FonduAI/awesome-prompt-injection?tab=readme-ov-file#tools)). This will give you leads on how hard you will have to work on the next topics.\n* Updates: Keep both LLaMA C++ and your libraries updated with the latest security patches.\n* Input Sanitation: Before feeding data to the model, sanitize inputs rigorously. This involves techniques such as:\n    * Validation: Enforce strict rules on allowed characters and data types.\n    * Filtering: Remove potentially malicious scripts or code fragments.\n    * Encoding: Convert special characters into safe representations.\n    * Verification: Run tooling that identifies potential script injections (e.g. [models that detect prompt injection attempts](https://python.langchain.com/docs/guides/safety/hugging_face_prompt_injection)).\n\n### Data privacy\n\nTo protect sensitive data from potential leaks or unauthorized access, it is crucial to sandbox the model execution. This means running the model in a secure, isolated environment, which helps mitigate many attack vectors.\n\n### Untrusted environments or networks\n\nIf you can't run your models in a secure and isolated environment or if it must be exposed to an untrusted network, make sure to take the following security precautions:\n* Confirm the hash of any downloaded artifact (e.g. pre-trained model weights) matches a known-good value\n* Encrypt your data if sending it over the network.\n\n### Multi-Tenant environments\n\nIf you intend to run multiple models in parallel with shared memory, it is your responsibility to ensure the models do not interact or access each other's data. The primary areas of concern are tenant isolation, resource allocation, model sharing and hardware attacks.\n\n1. Tenant Isolation: Models should run separately with strong isolation methods to prevent unwanted data access. Separating networks is crucial for isolation, as it prevents unauthorized access to data or models and malicious users from sending graphs to execute under another tenant's identity.\n\n2. Resource Allocation: A denial of service caused by one model can impact the overall system health. Implement safeguards like rate limits, access controls, and health monitoring.\n\n3. Model Sharing: In a multitenant model sharing design, tenants and users must understand the security risks of running code provided by others. Since there are no reliable methods to detect malicious models, sandboxing the model execution is the recommended approach to mitigate the risk.\n\n4. Hardware Attacks: GPUs or TPUs can also be attacked. [Researches](https://scholar.google.com/scholar?q=gpu+side+channel) has shown that side channel attacks on GPUs are possible, which can make data leak from other models or processes running on the same system at the same time.\n\n## Reporting a vulnerability\n\nBeware that none of the topics under [Using llama.cpp securely](#using-llamacpp-securely) are considered vulnerabilities of LLaMA C++.\n\n<!-- normal version -->\nHowever, If you have discovered a security vulnerability in this project, please report it privately. **Do not disclose it as a public issue.** This gives us time to work with you to fix the issue before public exposure, reducing the chance that the exploit will be used before a patch is released.\n\nPlease disclose it as a private [security advisory](https://github.com/ggerganov/llama.cpp/security/advisories/new).\n\nA team of volunteers on a reasonable-effort basis maintains this project. As such, please give us at least 90 days to work on a fix before public exposure.\n"
        },
        {
          "name": "Sources",
          "type": "tree",
          "content": null
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "common",
          "type": "tree",
          "content": null
        },
        {
          "name": "convert_hf_to_gguf.py",
          "type": "blob",
          "size": 227.5576171875,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom __future__ import annotations\n\nimport ast\nimport logging\nimport argparse\nimport contextlib\nimport json\nimport os\nimport re\nimport sys\nfrom enum import IntEnum\nfrom pathlib import Path\nfrom hashlib import sha256\nfrom typing import TYPE_CHECKING, Any, Callable, ContextManager, Iterable, Iterator, Literal, Sequence, TypeVar, cast\nfrom itertools import chain\n\nimport math\nimport numpy as np\nimport torch\n\nif TYPE_CHECKING:\n    from torch import Tensor\n\nif 'NO_LOCAL_GGUF' not in os.environ:\n    sys.path.insert(1, str(Path(__file__).parent / 'gguf-py'))\nimport gguf\n\nlogger = logging.getLogger(\"hf-to-gguf\")\n\n\n###### MODEL DEFINITIONS ######\n\nclass SentencePieceTokenTypes(IntEnum):\n    NORMAL = 1\n    UNKNOWN = 2\n    CONTROL = 3\n    USER_DEFINED = 4\n    UNUSED = 5\n    BYTE = 6\n\n\nAnyModel = TypeVar(\"AnyModel\", bound=\"type[Model]\")\n\n\nclass Model:\n    _model_classes: dict[str, type[Model]] = {}\n\n    dir_model: Path\n    ftype: gguf.LlamaFileType\n    fname_out: Path\n    is_big_endian: bool\n    endianess: gguf.GGUFEndian\n    use_temp_file: bool\n    lazy: bool\n    part_names: list[str]\n    is_safetensors: bool\n    hparams: dict[str, Any]\n    block_count: int\n    tensor_map: gguf.TensorNameMap\n    tensor_names: set[str] | None\n    gguf_writer: gguf.GGUFWriter\n    model_name: str | None\n    metadata_override: Path | None\n    dir_model_card: Path\n\n    # subclasses should define this!\n    model_arch: gguf.MODEL_ARCH\n\n    def __init__(self, dir_model: Path, ftype: gguf.LlamaFileType, fname_out: Path, is_big_endian: bool = False,\n                 use_temp_file: bool = False, eager: bool = False,\n                 metadata_override: Path | None = None, model_name: str | None = None,\n                 split_max_tensors: int = 0, split_max_size: int = 0, dry_run: bool = False,\n                 small_first_shard: bool = False, hparams: dict[str, Any] | None = None):\n        if type(self) is Model:\n            raise TypeError(f\"{type(self).__name__!r} should not be directly instantiated\")\n\n        self.dir_model = dir_model\n        self.ftype = ftype\n        self.fname_out = fname_out\n        self.is_big_endian = is_big_endian\n        self.endianess = gguf.GGUFEndian.BIG if is_big_endian else gguf.GGUFEndian.LITTLE\n        self.use_temp_file = use_temp_file\n        self.lazy = not eager\n        self.part_names = Model.get_model_part_names(self.dir_model, \"model\", \".safetensors\")\n        self.is_safetensors = len(self.part_names) > 0\n        if not self.is_safetensors:\n            self.part_names = Model.get_model_part_names(self.dir_model, \"pytorch_model\", \".bin\")\n        self.hparams = Model.load_hparams(self.dir_model) if hparams is None else hparams\n        self.block_count = self.find_hparam([\"n_layers\", \"num_hidden_layers\", \"n_layer\", \"num_layers\"])\n        self.tensor_map = gguf.get_tensor_name_map(self.model_arch, self.block_count)\n        self.tensor_names = None\n        self.metadata_override = metadata_override\n        self.model_name = model_name\n        self.dir_model_card = dir_model  # overridden in convert_lora_to_gguf.py\n\n        # Apply heuristics to figure out typical tensor encoding based on first layer tensor encoding type\n        if self.ftype == gguf.LlamaFileType.GUESSED:\n            # NOTE: can't use field \"torch_dtype\" in config.json, because some finetunes lie.\n            _, first_tensor = next(self.get_tensors())\n            if first_tensor.dtype == torch.float16:\n                logger.info(f\"choosing --outtype f16 from first tensor type ({first_tensor.dtype})\")\n                self.ftype = gguf.LlamaFileType.MOSTLY_F16\n            else:\n                logger.info(f\"choosing --outtype bf16 from first tensor type ({first_tensor.dtype})\")\n                self.ftype = gguf.LlamaFileType.MOSTLY_BF16\n\n        # Configure GGUF Writer\n        self.gguf_writer = gguf.GGUFWriter(path=None, arch=gguf.MODEL_ARCH_NAMES[self.model_arch], endianess=self.endianess, use_temp_file=self.use_temp_file,\n                                           split_max_tensors=split_max_tensors, split_max_size=split_max_size, dry_run=dry_run, small_first_shard=small_first_shard)\n\n    @classmethod\n    def __init_subclass__(cls):\n        # can't use an abstract property, because overriding it without type errors\n        # would require using decorated functions instead of simply defining the property\n        if \"model_arch\" not in cls.__dict__:\n            raise TypeError(f\"Missing property 'model_arch' for {cls.__name__!r}\")\n\n    def find_hparam(self, keys: Iterable[str], optional: bool = False) -> Any:\n        key = next((k for k in keys if k in self.hparams), None)\n        if key is not None:\n            return self.hparams[key]\n        if optional:\n            return None\n        raise KeyError(f\"could not find any of: {keys}\")\n\n    def set_vocab(self):\n        self._set_vocab_gpt2()\n\n    def get_tensors(self) -> Iterator[tuple[str, Tensor]]:\n        tensor_names_from_parts: set[str] = set()\n\n        index_name = \"model.safetensors\" if self.is_safetensors else \"pytorch_model.bin\"\n        index_name += \".index.json\"\n        index_file = self.dir_model / index_name\n\n        if index_file.is_file():\n            self.tensor_names = set()\n            logger.info(f\"gguf: loading model weight map from '{index_name}'\")\n            with open(index_file, \"r\", encoding=\"utf-8\") as f:\n                index: dict[str, Any] = json.load(f)\n                weight_map = index.get(\"weight_map\")\n                if weight_map is None or not isinstance(weight_map, dict):\n                    raise ValueError(f\"Can't load 'weight_map' from {index_name!r}\")\n                self.tensor_names.update(weight_map.keys())\n        else:\n            self.tensor_names = tensor_names_from_parts\n            weight_map = {}\n\n        for part_name in self.part_names:\n            logger.info(f\"gguf: loading model part '{part_name}'\")\n            ctx: ContextManager[Any]\n            if self.is_safetensors:\n                from safetensors import safe_open\n                ctx = cast(ContextManager[Any], safe_open(self.dir_model / part_name, framework=\"pt\", device=\"cpu\"))\n            else:\n                ctx = contextlib.nullcontext(torch.load(str(self.dir_model / part_name), map_location=\"cpu\", mmap=True, weights_only=True))\n\n            with ctx as model_part:\n                tensor_names_from_parts.update(model_part.keys())\n\n                for name in model_part.keys():\n                    if self.is_safetensors:\n                        if self.lazy:\n                            data = model_part.get_slice(name)\n                            data = LazyTorchTensor.from_safetensors_slice(data)\n                        else:\n                            data = model_part.get_tensor(name)\n                    else:\n                        data = model_part[name]\n                        if self.lazy:\n                            data = LazyTorchTensor.from_eager(data)\n                    yield name, data\n\n        # verify tensor name presence and identify potentially missing files\n        if len(tensor_names_from_parts.symmetric_difference(self.tensor_names)) > 0:\n            missing = sorted(self.tensor_names.difference(tensor_names_from_parts))\n            extra = sorted(tensor_names_from_parts.difference(self.tensor_names))\n            missing_files = sorted(set(weight_map[n] for n in missing if n in weight_map))\n            if len(extra) == 0 and len(missing_files) > 0:\n                raise ValueError(f\"Missing or incomplete model files: {missing_files}\")\n            else:\n                raise ValueError(\"Mismatch between weight map and model parts for tensor names:\\n\"\n                                 f\"Missing tensors: {missing}\\n\"\n                                 f\"Extra tensors: {extra}\")\n\n    def format_tensor_name(self, key: gguf.MODEL_TENSOR, bid: int | None = None, suffix: str = \".weight\") -> str:\n        if key not in gguf.MODEL_TENSORS[self.model_arch]:\n            raise ValueError(f\"Missing {key!r} for MODEL_TENSORS of {self.model_arch!r}\")\n        name: str = gguf.TENSOR_NAMES[key]\n        if \"{bid}\" in name:\n            assert bid is not None\n            name = name.format(bid=bid)\n        return name + suffix\n\n    def match_model_tensor_name(self, name: str, key: gguf.MODEL_TENSOR, bid: int | None, suffix: str = \".weight\") -> bool:\n        if key not in gguf.MODEL_TENSORS[self.model_arch]:\n            return False\n        key_name: str = gguf.TENSOR_NAMES[key]\n        if \"{bid}\" in key_name:\n            if bid is None:\n                return False\n            key_name = key_name.format(bid=bid)\n        else:\n            if bid is not None:\n                return False\n        return name == (key_name + suffix)\n\n    def map_tensor_name(self, name: str, try_suffixes: Sequence[str] = (\".weight\", \".bias\")) -> str:\n        new_name = self.tensor_map.get_name(key=name, try_suffixes=try_suffixes)\n        if new_name is None:\n            raise ValueError(f\"Can not map tensor {name!r}\")\n        return new_name\n\n    def set_gguf_parameters(self):\n        self.gguf_writer.add_block_count(self.block_count)\n\n        if (n_ctx := self.find_hparam([\"max_position_embeddings\", \"n_ctx\"], optional=True)) is not None:\n            self.gguf_writer.add_context_length(n_ctx)\n            logger.info(f\"gguf: context length = {n_ctx}\")\n\n        if (n_embd := self.find_hparam([\"hidden_size\", \"n_embd\"], optional=True)) is not None:\n            self.gguf_writer.add_embedding_length(n_embd)\n            logger.info(f\"gguf: embedding length = {n_embd}\")\n\n        if (n_ff := self.find_hparam([\"intermediate_size\", \"n_inner\"], optional=True)) is not None:\n            self.gguf_writer.add_feed_forward_length(n_ff)\n            logger.info(f\"gguf: feed forward length = {n_ff}\")\n\n        if (n_head := self.find_hparam([\"num_attention_heads\", \"n_head\"], optional=True)) is not None:\n            self.gguf_writer.add_head_count(n_head)\n            logger.info(f\"gguf: head count = {n_head}\")\n\n        if (n_head_kv := self.hparams.get(\"num_key_value_heads\")) is not None:\n            self.gguf_writer.add_head_count_kv(n_head_kv)\n            logger.info(f\"gguf: key-value head count = {n_head_kv}\")\n\n        if (rope_theta := self.hparams.get(\"rope_theta\")) is not None:\n            self.gguf_writer.add_rope_freq_base(rope_theta)\n            logger.info(f\"gguf: rope theta = {rope_theta}\")\n        if (f_rms_eps := self.hparams.get(\"rms_norm_eps\")) is not None:\n            self.gguf_writer.add_layer_norm_rms_eps(f_rms_eps)\n            logger.info(f\"gguf: rms norm epsilon = {f_rms_eps}\")\n        if (f_norm_eps := self.find_hparam([\"layer_norm_eps\", \"layer_norm_epsilon\", \"norm_epsilon\"], optional=True)) is not None:\n            self.gguf_writer.add_layer_norm_eps(f_norm_eps)\n            logger.info(f\"gguf: layer norm epsilon = {f_norm_eps}\")\n        if (n_experts := self.hparams.get(\"num_local_experts\")) is not None:\n            self.gguf_writer.add_expert_count(n_experts)\n            logger.info(f\"gguf: expert count = {n_experts}\")\n        if (n_experts_used := self.hparams.get(\"num_experts_per_tok\")) is not None:\n            self.gguf_writer.add_expert_used_count(n_experts_used)\n            logger.info(f\"gguf: experts used count = {n_experts_used}\")\n\n        if (head_dim := self.hparams.get(\"head_dim\")) is not None:\n            self.gguf_writer.add_key_length(head_dim)\n            self.gguf_writer.add_value_length(head_dim)\n\n        self.gguf_writer.add_file_type(self.ftype)\n        logger.info(f\"gguf: file type = {self.ftype}\")\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def tensor_force_quant(self, name: str, new_name: str, bid: int | None, n_dims: int) -> gguf.GGMLQuantizationType | bool:\n        del name, new_name, bid, n_dims  # unused\n\n        return False\n\n    # some models need extra generated tensors (like rope_freqs)\n    def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n        return ()\n\n    def prepare_tensors(self):\n        max_name_len = max(len(s) for _, s in self.tensor_map.mapping.values()) + len(\".weight,\")\n\n        for name, data_torch in chain(self.generate_extra_tensors(), self.get_tensors()):\n            # we don't need these\n            if name.endswith((\".attention.masked_bias\", \".attention.bias\", \".rotary_emb.inv_freq\")):\n                continue\n\n            old_dtype = data_torch.dtype\n\n            # convert any unsupported data types to float32\n            if data_torch.dtype not in (torch.float16, torch.float32):\n                data_torch = data_torch.to(torch.float32)\n\n            # use the first number-like part of the tensor name as the block id\n            bid = None\n            for part in name.split(\".\"):\n                if part.isdecimal():\n                    bid = int(part)\n                    break\n\n            for new_name, data_torch in (self.modify_tensors(data_torch, name, bid)):\n                # TODO: why do we squeeze here?\n                # data = data_torch.squeeze().numpy()\n                data = data_torch.numpy()\n\n                # if data ends up empty, it means data_torch was a scalar tensor -> restore\n                if len(data.shape) == 0:\n                    data = data_torch.numpy()\n\n                n_dims = len(data.shape)\n                data_qtype: gguf.GGMLQuantizationType | bool = self.tensor_force_quant(name, new_name, bid, n_dims)\n\n                # Most of the codebase that takes in 1D tensors or norms only handles F32 tensors\n                if n_dims <= 1 or new_name.endswith(\"_norm.weight\"):\n                    data_qtype = gguf.GGMLQuantizationType.F32\n\n                # Conditions should closely match those in llama_model_quantize_internal in llama.cpp\n                # Some tensor types are always in float32\n                if data_qtype is False and (\n                    any(\n                        self.match_model_tensor_name(new_name, key, bid)\n                        for key in (\n                            gguf.MODEL_TENSOR.FFN_GATE_INP,\n                            gguf.MODEL_TENSOR.POS_EMBD,\n                            gguf.MODEL_TENSOR.TOKEN_TYPES,\n                            gguf.MODEL_TENSOR.SSM_CONV1D,\n                            gguf.MODEL_TENSOR.TIME_MIX_FIRST,\n                            gguf.MODEL_TENSOR.TIME_MIX_W1,\n                            gguf.MODEL_TENSOR.TIME_MIX_W2,\n                            gguf.MODEL_TENSOR.TIME_MIX_DECAY_W1,\n                            gguf.MODEL_TENSOR.TIME_MIX_DECAY_W2,\n                            gguf.MODEL_TENSOR.TIME_MIX_LERP_FUSED,\n                            gguf.MODEL_TENSOR.POSNET_NORM1,\n                            gguf.MODEL_TENSOR.POSNET_NORM2,\n                        )\n                    )\n                    or not new_name.endswith(\".weight\")\n                ):\n                    data_qtype = gguf.GGMLQuantizationType.F32\n\n                if data_qtype is False and any(\n                    self.match_model_tensor_name(new_name, key, bid)\n                    for key in (\n                        gguf.MODEL_TENSOR.TOKEN_EMBD,\n                        gguf.MODEL_TENSOR.OUTPUT,\n                    )\n                ):\n                    if self.ftype in (\n                        gguf.LlamaFileType.MOSTLY_TQ1_0,\n                        gguf.LlamaFileType.MOSTLY_TQ2_0,\n                    ):\n                        # TODO: use Q4_K and Q6_K\n                        data_qtype = gguf.GGMLQuantizationType.F16\n\n                # No override (data_qtype is False), or wants to be quantized (data_qtype is True)\n                if isinstance(data_qtype, bool):\n                    if self.ftype == gguf.LlamaFileType.ALL_F32:\n                        data_qtype = gguf.GGMLQuantizationType.F32\n                    elif self.ftype == gguf.LlamaFileType.MOSTLY_F16:\n                        data_qtype = gguf.GGMLQuantizationType.F16\n                    elif self.ftype == gguf.LlamaFileType.MOSTLY_BF16:\n                        data_qtype = gguf.GGMLQuantizationType.BF16\n                    elif self.ftype == gguf.LlamaFileType.MOSTLY_Q8_0:\n                        data_qtype = gguf.GGMLQuantizationType.Q8_0\n                    elif self.ftype == gguf.LlamaFileType.MOSTLY_TQ1_0:\n                        data_qtype = gguf.GGMLQuantizationType.TQ1_0\n                    elif self.ftype == gguf.LlamaFileType.MOSTLY_TQ2_0:\n                        data_qtype = gguf.GGMLQuantizationType.TQ2_0\n                    else:\n                        raise ValueError(f\"Unknown file type: {self.ftype.name}\")\n\n                try:\n                    data = gguf.quants.quantize(data, data_qtype)\n                except gguf.QuantError as e:\n                    logger.warning(\"%s, %s\", e, \"falling back to F16\")\n                    data_qtype = gguf.GGMLQuantizationType.F16\n                    data = gguf.quants.quantize(data, data_qtype)\n\n                shape = gguf.quant_shape_from_byte_shape(data.shape, data_qtype) if data.dtype == np.uint8 else data.shape\n\n                # reverse shape to make it similar to the internal ggml dimension order\n                shape_str = f\"{{{', '.join(str(n) for n in reversed(shape))}}}\"\n\n                # n_dims is implicit in the shape\n                logger.info(f\"{f'%-{max_name_len}s' % f'{new_name},'} {old_dtype} --> {data_qtype.name}, shape = {shape_str}\")\n\n                self.gguf_writer.add_tensor(new_name, data, raw_dtype=data_qtype)\n\n    def set_type(self):\n        self.gguf_writer.add_type(gguf.GGUFType.MODEL)\n\n    def prepare_metadata(self, vocab_only: bool):\n\n        total_params, shared_params, expert_params, expert_count = self.gguf_writer.get_total_parameter_count()\n\n        self.metadata = gguf.Metadata.load(self.metadata_override, self.dir_model_card, self.model_name, total_params)\n\n        # Fallback to model directory name if metadata name is still missing\n        if self.metadata.name is None:\n            self.metadata.name = self.dir_model.name\n\n        # Generate parameter weight class (useful for leader boards) if not yet determined\n        if self.metadata.size_label is None and total_params > 0:\n            self.metadata.size_label = gguf.size_label(total_params, shared_params, expert_params, expert_count)\n\n        # Extract the encoding scheme from the file type name. e.g. 'gguf.LlamaFileType.MOSTLY_Q8_0' --> 'Q8_0'\n        output_type: str = self.ftype.name.partition(\"_\")[2]\n\n        # Filename Output\n        if self.fname_out.is_dir():\n            # Generate default filename based on model specification and available metadata\n            if not vocab_only:\n                fname_default: str = gguf.naming_convention(self.metadata.name, self.metadata.basename, self.metadata.finetune, self.metadata.version, self.metadata.size_label, output_type, model_type=\"LoRA\" if total_params < 0 else None)\n            else:\n                fname_default: str = gguf.naming_convention(self.metadata.name, self.metadata.basename, self.metadata.finetune, self.metadata.version, size_label=None, output_type=None, model_type=\"vocab\")\n\n            # Use the default filename\n            self.fname_out = self.fname_out / f\"{fname_default}.gguf\"\n        else:\n            # Output path is a custom defined templated filename\n            # Note: `not is_dir()` is used because `.is_file()` will not detect\n            #       file template strings as it doesn't actually exist as a file\n\n            # Process templated file name with the output ftype, useful with the \"auto\" ftype\n            self.fname_out = self.fname_out.parent / gguf.fill_templated_filename(self.fname_out.name, output_type)\n\n        self.set_type()\n\n        logger.info(\"Set meta model\")\n        self.metadata.set_gguf_meta_model(self.gguf_writer)\n\n        logger.info(\"Set model parameters\")\n        self.set_gguf_parameters()\n\n        logger.info(\"Set model tokenizer\")\n        self.set_vocab()\n\n        logger.info(\"Set model quantization version\")\n        self.gguf_writer.add_quantization_version(gguf.GGML_QUANT_VERSION)\n\n    def write(self):\n        self.prepare_tensors()\n        self.prepare_metadata(vocab_only=False)\n        self.gguf_writer.write_header_to_file(path=self.fname_out)\n        self.gguf_writer.write_kv_data_to_file()\n        self.gguf_writer.write_tensors_to_file(progress=True)\n        self.gguf_writer.close()\n\n    def write_vocab(self):\n        if len(self.gguf_writer.tensors) != 1:\n            raise ValueError('Splitting the vocabulary is not supported')\n\n        self.prepare_metadata(vocab_only=True)\n        self.gguf_writer.write_header_to_file(path=self.fname_out)\n        self.gguf_writer.write_kv_data_to_file()\n        self.gguf_writer.close()\n\n    @staticmethod\n    def get_model_part_names(dir_model: Path, prefix: str, suffix: str) -> list[str]:\n        part_names: list[str] = []\n        for filename in os.listdir(dir_model):\n            if filename.startswith(prefix) and filename.endswith(suffix):\n                part_names.append(filename)\n\n        part_names.sort()\n\n        return part_names\n\n    @staticmethod\n    def load_hparams(dir_model: Path):\n        with open(dir_model / \"config.json\", \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n\n    @classmethod\n    def register(cls, *names: str) -> Callable[[AnyModel], AnyModel]:\n        assert names\n\n        def func(modelcls: AnyModel) -> AnyModel:\n            for name in names:\n                cls._model_classes[name] = modelcls\n            return modelcls\n        return func\n\n    @classmethod\n    def print_registered_models(cls):\n        for name in cls._model_classes.keys():\n            logger.error(f\"- {name}\")\n\n    @classmethod\n    def from_model_architecture(cls, arch: str) -> type[Model]:\n        try:\n            return cls._model_classes[arch]\n        except KeyError:\n            raise NotImplementedError(f'Architecture {arch!r} not supported!') from None\n\n    def does_token_look_special(self, token: str | bytes) -> bool:\n        if isinstance(token, (bytes, bytearray)):\n            token_text = token.decode(encoding=\"utf-8\")\n        elif isinstance(token, memoryview):\n            token_text = token.tobytes().decode(encoding=\"utf-8\")\n        else:\n            token_text = token\n\n        # Some models mark some added tokens which ought to be control tokens as not special.\n        # (e.g. command-r, command-r-plus, deepseek-coder, gemma{,-2})\n        seems_special = token_text in (\n            \"<pad>\",  # deepseek-coder\n            \"<mask>\", \"<2mass>\", \"[@BOS@]\",  # gemma{,-2}\n        )\n\n        seems_special = seems_special or (token_text.startswith(\"<|\") and token_text.endswith(\"|>\"))\n        seems_special = seems_special or (token_text.startswith(\"<｜\") and token_text.endswith(\"｜>\"))  # deepseek-coder\n\n        # TODO: should these be marked as UNUSED instead? (maybe not)\n        seems_special = seems_special or (token_text.startswith(\"<unused\") and token_text.endswith(\">\"))  # gemma{,-2}\n\n        return seems_special\n\n    # used for GPT-2 BPE and WordPiece vocabs\n    def get_vocab_base(self) -> tuple[list[str], list[int], str]:\n        tokens: list[str] = []\n        toktypes: list[int] = []\n\n        from transformers import AutoTokenizer\n        tokenizer = AutoTokenizer.from_pretrained(self.dir_model)\n        vocab_size = self.hparams.get(\"vocab_size\", len(tokenizer.vocab))\n        assert max(tokenizer.vocab.values()) < vocab_size\n\n        tokpre = self.get_vocab_base_pre(tokenizer)\n\n        reverse_vocab = {id_: encoded_tok for encoded_tok, id_ in tokenizer.vocab.items()}\n        added_vocab = tokenizer.get_added_vocab()\n\n        for i in range(vocab_size):\n            if i not in reverse_vocab:\n                tokens.append(f\"[PAD{i}]\")\n                toktypes.append(gguf.TokenType.UNUSED)\n            else:\n                token: str = reverse_vocab[i]\n                if token in added_vocab:\n                    # The tokenizer in llama.cpp assumes the CONTROL and USER_DEFINED tokens are pre-normalized.\n                    # To avoid unexpected issues - we make sure to normalize non-normalized tokens\n                    if not tokenizer.added_tokens_decoder[i].normalized:\n                        previous_token = token\n                        token = tokenizer.decode(tokenizer.encode(token, add_special_tokens=False))\n                        if previous_token != token:\n                            logger.info(f\"{repr(previous_token)} is encoded and decoded back to {repr(token)} using AutoTokenizer\")\n\n                    if tokenizer.added_tokens_decoder[i].special or self.does_token_look_special(token):\n                        toktypes.append(gguf.TokenType.CONTROL)\n                    else:\n                        # NOTE: this was added for Gemma.\n                        # Encoding and decoding the tokens above isn't sufficient for this case.\n                        token = token.replace(b\"\\xe2\\x96\\x81\".decode(\"utf-8\"), \" \")  # pre-normalize user-defined spaces\n                        toktypes.append(gguf.TokenType.USER_DEFINED)\n                else:\n                    toktypes.append(gguf.TokenType.NORMAL)\n                tokens.append(token)\n\n        return tokens, toktypes, tokpre\n\n    # NOTE: this function is generated by convert_hf_to_gguf_update.py\n    #       do not modify it manually!\n    # ref:  https://github.com/ggerganov/llama.cpp/pull/6920\n    # Marker: Start get_vocab_base_pre\n    def get_vocab_base_pre(self, tokenizer) -> str:\n        # encoding this string and hashing the resulting tokens would (hopefully) give us a unique identifier that\n        # is specific for the BPE pre-tokenizer used by the model\n        # we will use this unique identifier to write a \"tokenizer.ggml.pre\" entry in the GGUF file which we can\n        # use in llama.cpp to implement the same pre-tokenizer\n\n        chktxt = '\\n \\n\\n \\n\\n\\n \\t \\t\\t \\t\\n  \\n   \\n    \\n     \\n🚀 (normal) 😶\\u200d🌫️ (multiple emojis concatenated) ✅ 🦙🦙 3 33 333 3333 33333 333333 3333333 33333333 3.3 3..3 3...3 កាន់តែពិសេសអាច😁 ?我想在apple工作1314151天～ ------======= нещо на Български \\'\\'\\'\\'\\'\\'```````\"\"\"\"......!!!!!!?????? I\\'ve been \\'told he\\'s there, \\'RE you sure? \\'M not sure I\\'ll make it, \\'D you like some tea? We\\'Ve a\\'lL'\n\n        chktok = tokenizer.encode(chktxt)\n        chkhsh = sha256(str(chktok).encode()).hexdigest()\n\n        logger.debug(f\"chktok: {chktok}\")\n        logger.debug(f\"chkhsh: {chkhsh}\")\n\n        res = None\n\n        # NOTE: if you get an error here, you need to update the convert_hf_to_gguf_update.py script\n        #       or pull the latest version of the model from Huggingface\n        #       don't edit the hashes manually!\n        if chkhsh == \"0ef9807a4087ebef797fc749390439009c3b9eda9ad1a097abbe738f486c01e5\":\n            # ref: https://huggingface.co/meta-llama/Meta-Llama-3-8B\n            res = \"llama-bpe\"\n        if chkhsh == \"049ecf7629871e3041641907f3de7c733e4dbfdc736f57d882ba0b0845599754\":\n            # ref: https://huggingface.co/deepseek-ai/deepseek-llm-7b-base\n            res = \"deepseek-llm\"\n        if chkhsh == \"347715f544604f9118bb75ed199f68779f423cabb20db6de6f31b908d04d7821\":\n            # ref: https://huggingface.co/deepseek-ai/deepseek-coder-6.7b-base\n            res = \"deepseek-coder\"\n        if chkhsh == \"8aeee3860c56296a157a1fe2fad249ec40aa59b1bb5709f4ade11c4e6fe652ed\":\n            # ref: https://huggingface.co/tiiuae/falcon-7b\n            res = \"falcon\"\n        if chkhsh == \"9d032fcbd5501f4a38150912590928bfb36091efb5df11b8e2124b0390e3fb1e\":\n            # ref: https://huggingface.co/tiiuae/Falcon3-7B-Base\n            res = \"falcon3\"\n        if chkhsh == \"0876d13b50744004aa9aeae05e7b0647eac9d801b5ba4668afc01e709c15e19f\":\n            # ref: https://huggingface.co/BAAI/bge-small-en-v1.5\n            res = \"bert-bge\"\n        if chkhsh == \"8e62295832751ca1e8f92f2226f403dea30dc5165e448b5bfa05af5340c64ec7\":\n            # ref: https://huggingface.co/BAAI/bge-large-zh-v1.5\n            res = \"bert-bge-large\"\n        if chkhsh == \"b6dc8df998e1cfbdc4eac8243701a65afe638679230920b50d6f17d81c098166\":\n            # ref: https://huggingface.co/mosaicml/mpt-7b\n            res = \"mpt\"\n        if chkhsh == \"35d91631860c815f952d711435f48d356ebac988362536bed955d43bfa436e34\":\n            # ref: https://huggingface.co/bigcode/starcoder2-3b\n            res = \"starcoder\"\n        if chkhsh == \"3ce83efda5659b07b1ad37ca97ca5797ea4285d9b9ab0dc679e4a720c9da7454\":\n            # ref: https://huggingface.co/openai-community/gpt2\n            res = \"gpt-2\"\n        if chkhsh == \"32d85c31273f8019248f2559fed492d929ea28b17e51d81d3bb36fff23ca72b3\":\n            # ref: https://huggingface.co/stabilityai/stablelm-2-zephyr-1_6b\n            res = \"stablelm2\"\n        if chkhsh == \"6221ad2852e85ce96f791f476e0b390cf9b474c9e3d1362f53a24a06dc8220ff\":\n            # ref: https://huggingface.co/smallcloudai/Refact-1_6-base\n            res = \"refact\"\n        if chkhsh == \"9c2227e4dd922002fb81bde4fc02b0483ca4f12911410dee2255e4987644e3f8\":\n            # ref: https://huggingface.co/CohereForAI/c4ai-command-r-v01\n            res = \"command-r\"\n        if chkhsh == \"e636dc30a262dcc0d8c323492e32ae2b70728f4df7dfe9737d9f920a282b8aea\":\n            # ref: https://huggingface.co/Qwen/Qwen1.5-7B\n            res = \"qwen2\"\n        if chkhsh == \"b6dc8df998e1cfbdc4eac8243701a65afe638679230920b50d6f17d81c098166\":\n            # ref: https://huggingface.co/allenai/OLMo-1.7-7B-hf\n            res = \"olmo\"\n        if chkhsh == \"a8594e3edff7c29c003940395316294b2c623e09894deebbc65f33f1515df79e\":\n            # ref: https://huggingface.co/databricks/dbrx-base\n            res = \"dbrx\"\n        if chkhsh == \"c7699093ba4255a91e702aa38a596aa81669f3525dae06c2953267dde580f448\":\n            # ref: https://huggingface.co/jinaai/jina-reranker-v1-tiny-en\n            res = \"jina-v1-en\"\n        if chkhsh == \"0876d13b50744004aa9aeae05e7b0647eac9d801b5ba4668afc01e709c15e19f\":\n            # ref: https://huggingface.co/jinaai/jina-embeddings-v2-base-en\n            res = \"jina-v2-en\"\n        if chkhsh == \"171aeeedd6fb548d418a7461d053f11b6f1f1fc9b387bd66640d28a4b9f5c643\":\n            # ref: https://huggingface.co/jinaai/jina-embeddings-v2-base-es\n            res = \"jina-v2-es\"\n        if chkhsh == \"27949a2493fc4a9f53f5b9b029c82689cfbe5d3a1929bb25e043089e28466de6\":\n            # ref: https://huggingface.co/jinaai/jina-embeddings-v2-base-de\n            res = \"jina-v2-de\"\n        if chkhsh == \"c136ed14d01c2745d4f60a9596ae66800e2b61fa45643e72436041855ad4089d\":\n            # ref: https://huggingface.co/abacusai/Smaug-Llama-3-70B-Instruct\n            res = \"smaug-bpe\"\n        if chkhsh == \"c7ea5862a53e4272c035c8238367063e2b270d51faa48c0f09e9d5b54746c360\":\n            # ref: https://huggingface.co/LumiOpen/Poro-34B-chat\n            res = \"poro-chat\"\n        if chkhsh == \"7967bfa498ade6b757b064f31e964dddbb80f8f9a4d68d4ba7998fcf281c531a\":\n            # ref: https://huggingface.co/jinaai/jina-embeddings-v2-base-code\n            res = \"jina-v2-code\"\n        if chkhsh == \"b6e8e1518dc4305be2fe39c313ed643381c4da5db34a98f6a04c093f8afbe99b\":\n            # ref: https://huggingface.co/THUDM/glm-4-9b-chat\n            res = \"chatglm-bpe\"\n        if chkhsh == \"7fc505bd3104ca1083b150b17d088b59534ede9bde81f0dd2090967d7fe52cee\":\n            # ref: https://huggingface.co/LumiOpen/Viking-7B\n            res = \"viking\"\n        if chkhsh == \"b53802fb28e26d645c3a310b34bfe07da813026ec7c7716883404d5e0f8b1901\":\n            # ref: https://huggingface.co/core42/jais-13b\n            res = \"jais\"\n        if chkhsh == \"7b3e7548e4308f52a76e8229e4e6cc831195d0d1df43aed21ac6c93da05fec5f\":\n            # ref: https://huggingface.co/WisdomShell/CodeShell-7B\n            res = \"codeshell\"\n        if chkhsh == \"63b97e4253352e6f357cc59ea5b583e3a680eaeaf2632188c2b952de2588485e\":\n            # ref: https://huggingface.co/mistralai/Mistral-Nemo-Base-2407\n            res = \"tekken\"\n        if chkhsh == \"855059429035d75a914d1eda9f10a876752e281a054a7a3d421ef0533e5b6249\":\n            # ref: https://huggingface.co/HuggingFaceTB/SmolLM-135M\n            res = \"smollm\"\n        if chkhsh == \"3c30d3ad1d6b64202cd222813e7736c2db6e1bd6d67197090fc1211fbc612ae7\":\n            # ref: https://huggingface.co/bigscience/bloom\n            res = \"bloom\"\n        if chkhsh == \"bc01ce58980e1db43859146dc51b1758b3b88729b217a74792e9f8d43e479d21\":\n            # ref: https://huggingface.co/TurkuNLP/gpt3-finnish-small\n            res = \"gpt3-finnish\"\n        if chkhsh == \"4e2b24cc4770243d65a2c9ec19770a72f08cffc161adbb73fcbb6b7dd45a0aae\":\n            # ref: https://huggingface.co/LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct\n            res = \"exaone\"\n        if chkhsh == \"fcace8b9cac38ce847670c970cd5892031a753a1ef381abd1d9af00f713da085\":\n            # ref: https://huggingface.co/microsoft/phi-2\n            res = \"phi-2\"\n        if chkhsh == \"60824e3c0d9401f89943cbb2fff727f0e2d4c545ba4df2d6e4f09a6db0f5b450\":\n            # ref: https://huggingface.co/facebook/chameleon-7b\n            res = \"chameleon\"\n        if chkhsh == \"1431a23e583c97432bc230bff598d103ddb5a1f89960c8f1d1051aaa944d0b35\":\n            # ref: https://huggingface.co/sapienzanlp/Minerva-7B-base-v1.0\n            res = \"minerva-7b\"\n        if chkhsh == \"8b5a93ed704057481f240da0be7e7dca721d7f8f4755263b6807227a2cbeae65\":\n            # ref: https://huggingface.co/sentence-transformers/stsb-roberta-base\n            res = \"roberta-bpe\"\n        if chkhsh == \"ad851be1dba641f2e3711822f816db2c265f788b37c63b4e1aeacb9ee92de8eb\":\n            # ref: https://huggingface.co/ai-sage/GigaChat-20B-A3B-instruct\n            res = \"gigachat\"\n        if chkhsh == \"d4c8f286ea6b520b3d495c4455483cfa2302c0cfcd4be05d781b6a8a0a7cdaf1\":\n            # ref: https://huggingface.co/Infinigence/Megrez-3B-Instruct\n            res = \"megrez\"\n        if chkhsh == \"877081d19cf6996e2c4ff0e1236341e9b7bde288f5311a56a937f0afbbb3aeb5\":\n            # ref: https://huggingface.co/deepseek-ai/DeepSeek-V3\n            res = \"deepseek-v3\"\n\n        if res is None:\n            logger.warning(\"\\n\")\n            logger.warning(\"**************************************************************************************\")\n            logger.warning(\"** WARNING: The BPE pre-tokenizer was not recognized!\")\n            logger.warning(\"**          There are 2 possible reasons for this:\")\n            logger.warning(\"**          - the model has not been added to convert_hf_to_gguf_update.py yet\")\n            logger.warning(\"**          - the pre-tokenization config has changed upstream\")\n            logger.warning(\"**          Check your model files and convert_hf_to_gguf_update.py and update them accordingly.\")\n            logger.warning(\"** ref:     https://github.com/ggerganov/llama.cpp/pull/6920\")\n            logger.warning(\"**\")\n            logger.warning(f\"** chkhsh:  {chkhsh}\")\n            logger.warning(\"**************************************************************************************\")\n            logger.warning(\"\\n\")\n            raise NotImplementedError(\"BPE pre-tokenizer was not recognized - update get_vocab_base_pre()\")\n\n        logger.debug(f\"tokenizer.ggml.pre: {repr(res)}\")\n        logger.debug(f\"chkhsh: {chkhsh}\")\n\n        return res\n        # Marker: End get_vocab_base_pre\n\n    def _set_vocab_none(self) -> None:\n        self.gguf_writer.add_tokenizer_model(\"none\")\n\n    def _set_vocab_gpt2(self) -> None:\n        tokens, toktypes, tokpre = self.get_vocab_base()\n        self.gguf_writer.add_tokenizer_model(\"gpt2\")\n        self.gguf_writer.add_tokenizer_pre(tokpre)\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, load_merges=True)\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def _set_vocab_qwen(self):\n        dir_model = self.dir_model\n        hparams = self.hparams\n        tokens: list[str] = []\n        toktypes: list[int] = []\n\n        from transformers import AutoTokenizer\n        tokenizer = AutoTokenizer.from_pretrained(dir_model, trust_remote_code=True)\n        vocab_size = hparams[\"vocab_size\"]\n        assert max(tokenizer.get_vocab().values()) < vocab_size\n\n        tokpre = self.get_vocab_base_pre(tokenizer)\n\n        merges = []\n        vocab = {}\n        mergeable_ranks = tokenizer.mergeable_ranks\n        for token, rank in mergeable_ranks.items():\n            vocab[QwenModel.token_bytes_to_string(token)] = rank\n            if len(token) == 1:\n                continue\n            merged = QwenModel.bpe(mergeable_ranks, token, max_rank=rank)\n            assert len(merged) == 2\n            merges.append(' '.join(map(QwenModel.token_bytes_to_string, merged)))\n\n        # for this kind of tokenizer, added_vocab is not a subset of vocab, so they need to be combined\n        added_vocab = tokenizer.special_tokens\n        reverse_vocab = {id_ : encoded_tok for encoded_tok, id_ in {**vocab, **added_vocab}.items()}\n\n        for i in range(vocab_size):\n            if i not in reverse_vocab:\n                tokens.append(f\"[PAD{i}]\")\n                toktypes.append(gguf.TokenType.UNUSED)\n            elif reverse_vocab[i] in added_vocab:\n                tokens.append(reverse_vocab[i])\n                toktypes.append(gguf.TokenType.CONTROL)\n            else:\n                tokens.append(reverse_vocab[i])\n                toktypes.append(gguf.TokenType.NORMAL)\n\n        self.gguf_writer.add_tokenizer_model(\"gpt2\")\n        self.gguf_writer.add_tokenizer_pre(tokpre)\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(dir_model, load_merges=False)\n        special_vocab.merges = merges\n        # only add special tokens when they were not already loaded from config.json\n        if len(special_vocab.special_token_ids) == 0:\n            special_vocab._set_special_token(\"bos\", tokenizer.special_tokens[\"<|endoftext|>\"])\n            special_vocab._set_special_token(\"eos\", tokenizer.special_tokens[\"<|endoftext|>\"])\n        # this one is usually not in config.json anyway\n        special_vocab._set_special_token(\"unk\", tokenizer.special_tokens[\"<|endoftext|>\"])\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def _set_vocab_sentencepiece(self, add_to_gguf=True):\n        tokens, scores, toktypes = self._create_vocab_sentencepiece()\n\n        self.gguf_writer.add_tokenizer_model(\"llama\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def _create_vocab_sentencepiece(self):\n        from sentencepiece import SentencePieceProcessor\n\n        tokenizer_path = self.dir_model / 'tokenizer.model'\n\n        if not tokenizer_path.is_file():\n            raise FileNotFoundError(f\"File not found: {tokenizer_path}\")\n\n        tokenizer = SentencePieceProcessor()\n        tokenizer.LoadFromFile(str(tokenizer_path))\n\n        vocab_size = self.hparams.get('vocab_size', tokenizer.vocab_size())\n\n        tokens: list[bytes] = [f\"[PAD{i}]\".encode(\"utf-8\") for i in range(vocab_size)]\n        scores: list[float] = [-10000.0] * vocab_size\n        toktypes: list[int] = [SentencePieceTokenTypes.UNUSED] * vocab_size\n\n        for token_id in range(tokenizer.vocab_size()):\n            piece = tokenizer.IdToPiece(token_id)\n            text = piece.encode(\"utf-8\")\n            score = tokenizer.GetScore(token_id)\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.IsUnknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.IsControl(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.IsUnused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.IsByte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n\n            tokens[token_id] = text\n            scores[token_id] = score\n            toktypes[token_id] = toktype\n\n        added_tokens_file = self.dir_model / 'added_tokens.json'\n        if added_tokens_file.is_file():\n            with open(added_tokens_file, \"r\", encoding=\"utf-8\") as f:\n                added_tokens_json = json.load(f)\n                for key in added_tokens_json:\n                    token_id = added_tokens_json[key]\n                    if token_id >= vocab_size:\n                        logger.warning(f'ignore token {token_id}: id is out of range, max={vocab_size - 1}')\n                        continue\n\n                    tokens[token_id] = key.encode(\"utf-8\")\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n\n        tokenizer_config_file = self.dir_model / 'tokenizer_config.json'\n        if tokenizer_config_file.is_file():\n            with open(tokenizer_config_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_config_json = json.load(f)\n                added_tokens_decoder = tokenizer_config_json.get(\"added_tokens_decoder\", {})\n                for token_id, token_data in added_tokens_decoder.items():\n                    token_id = int(token_id)\n                    token: str = token_data[\"content\"]\n                    if toktypes[token_id] != SentencePieceTokenTypes.UNUSED:\n                        if tokens[token_id] != token.encode(\"utf-8\"):\n                            logger.warning(f'replacing token {token_id}: {tokens[token_id].decode(\"utf-8\")!r} -> {token!r}')\n                    if token_data.get(\"special\") or self.does_token_look_special(token):\n                        toktypes[token_id] = SentencePieceTokenTypes.CONTROL\n                    else:\n                        token = token.replace(b\"\\xe2\\x96\\x81\".decode(\"utf-8\"), \" \")  # pre-normalize user-defined spaces\n                        toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n\n                    scores[token_id] = -1000.0\n                    tokens[token_id] = token.encode(\"utf-8\")\n\n        if vocab_size > len(tokens):\n            pad_count = vocab_size - len(tokens)\n            logger.debug(f\"Padding vocab with {pad_count} token(s) - [PAD1] through [PAD{pad_count}]\")\n            for i in range(1, pad_count + 1):\n                tokens.append(bytes(f\"[PAD{i}]\", encoding=\"utf-8\"))\n                scores.append(-1000.0)\n                toktypes.append(SentencePieceTokenTypes.UNUSED)\n\n        return tokens, scores, toktypes\n\n    def _set_vocab_llama_hf(self):\n        vocab = gguf.LlamaHfVocab(self.dir_model)\n        tokens = []\n        scores = []\n        toktypes = []\n\n        for text, score, toktype in vocab.all_tokens():\n            tokens.append(text)\n            scores.append(score)\n            toktypes.append(toktype)\n\n        assert len(tokens) == vocab.vocab_size\n\n        self.gguf_writer.add_tokenizer_model(\"llama\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def _set_vocab_builtin(self, model_name: Literal[\"gpt-neox\", \"llama-spm\"], vocab_size: int):\n        tokenizer_path = Path(sys.path[0]) / \"models\" / f\"ggml-vocab-{model_name}.gguf\"\n        logger.warning(f\"Using tokenizer from '{os.path.relpath(tokenizer_path, os.getcwd())}'\")\n        vocab_reader = gguf.GGUFReader(tokenizer_path, \"r\")\n\n        default_pre = \"mpt\" if model_name == \"gpt-neox\" else \"default\"\n\n        field = vocab_reader.get_field(gguf.Keys.Tokenizer.MODEL)\n        assert field  # tokenizer model\n        self.gguf_writer.add_tokenizer_model(bytes(field.parts[-1]).decode(\"utf-8\"))\n\n        field = vocab_reader.get_field(gguf.Keys.Tokenizer.PRE)\n        self.gguf_writer.add_tokenizer_pre(bytes(field.parts[-1]).decode(\"utf-8\") if field else default_pre)\n\n        field = vocab_reader.get_field(gguf.Keys.Tokenizer.LIST)\n        assert field  # token list\n        self.gguf_writer.add_token_list([bytes(field.parts[i]) for i in field.data][:vocab_size])\n\n        if model_name == \"llama-spm\":\n            field = vocab_reader.get_field(gguf.Keys.Tokenizer.SCORES)\n            assert field  # token scores\n            self.gguf_writer.add_token_scores([field.parts[i].tolist()[0] for i in field.data][:vocab_size])\n\n        field = vocab_reader.get_field(gguf.Keys.Tokenizer.TOKEN_TYPE)\n        assert field  # token types\n        self.gguf_writer.add_token_types([field.parts[i].tolist()[0] for i in field.data][:vocab_size])\n\n        if model_name != \"llama-spm\":\n            field = vocab_reader.get_field(gguf.Keys.Tokenizer.MERGES)\n            assert field  # token merges\n            self.gguf_writer.add_token_merges([bytes(field.parts[i]) for i in field.data])\n\n        if (field := vocab_reader.get_field(gguf.Keys.Tokenizer.BOS_ID)) is not None:\n            self.gguf_writer.add_bos_token_id(field.parts[-1].tolist()[0])\n        if (field := vocab_reader.get_field(gguf.Keys.Tokenizer.EOS_ID)) is not None:\n            self.gguf_writer.add_eos_token_id(field.parts[-1].tolist()[0])\n        if (field := vocab_reader.get_field(gguf.Keys.Tokenizer.UNK_ID)) is not None:\n            self.gguf_writer.add_unk_token_id(field.parts[-1].tolist()[0])\n        if (field := vocab_reader.get_field(gguf.Keys.Tokenizer.PAD_ID)) is not None:\n            self.gguf_writer.add_pad_token_id(field.parts[-1].tolist()[0])\n        if (field := vocab_reader.get_field(gguf.Keys.Tokenizer.ADD_BOS)) is not None:\n            self.gguf_writer.add_add_bos_token(field.parts[-1].tolist()[0])\n        if (field := vocab_reader.get_field(gguf.Keys.Tokenizer.ADD_EOS)) is not None:\n            self.gguf_writer.add_add_eos_token(field.parts[-1].tolist()[0])\n\n\n@Model.register(\"GPTNeoXForCausalLM\")\nclass GPTNeoXModel(Model):\n    model_arch = gguf.MODEL_ARCH.GPTNEOX\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"num_hidden_layers\"]\n\n        self.gguf_writer.add_context_length(self.hparams[\"max_position_embeddings\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"intermediate_size\"])\n        self.gguf_writer.add_rope_dimension_count(\n            int(self.hparams[\"rotary_pct\"] * (self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])),\n        )\n        self.gguf_writer.add_head_count(self.hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_parallel_residual(self.hparams.get(\"use_parallel_residual\", True))\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_eps\"])\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        n_head = self.hparams.get(\"n_head\", self.hparams.get(\"num_attention_heads\"))\n        n_embed = self.hparams.get(\"hidden_size\", self.hparams.get(\"n_embed\"))\n\n        tensors: list[tuple[str, Tensor]] = []\n\n        if re.match(r\"gpt_neox\\.layers\\.\\d+\\.attention\\.query_key_value\\.weight\", name):\n            # Map bloom-style qkv_linear to gpt-style qkv_linear\n            # bloom: https://github.com/huggingface/transformers/blob/main/src/transformers/models/bloom/modeling_bloom.py#L238-L252  # noqa\n            # gpt-2: https://github.com/huggingface/transformers/blob/main/src/transformers/models/gpt2/modeling_gpt2.py#L312  # noqa\n            qkv_weights = data_torch.reshape((n_head, 3, n_embed // n_head, n_embed))\n            data_torch = torch.cat(\n                (\n                    qkv_weights[:, 0, :, :].reshape((-1, n_embed)),\n                    qkv_weights[:, 1, :, :].reshape((-1, n_embed)),\n                    qkv_weights[:, 2, :, :].reshape((-1, n_embed)),\n                ),\n                dim=0,\n            )\n            logger.info(\"re-format attention.linear_qkv.weight\")\n        elif re.match(r\"gpt_neox\\.layers\\.\\d+\\.attention\\.query_key_value\\.bias\", name):\n            qkv_bias = data_torch.reshape((n_head, 3, n_embed // n_head))\n            data_torch = torch.cat(\n                (\n                    qkv_bias[:, 0, :].reshape((n_embed,)),\n                    qkv_bias[:, 1, :].reshape((n_embed,)),\n                    qkv_bias[:, 2, :].reshape((n_embed,)),\n                ),\n                dim=0,\n            )\n            logger.info(\"re-format attention.linear_qkv.bias\")\n\n        tensors.append((self.map_tensor_name(name), data_torch))\n\n        return tensors\n\n\n@Model.register(\"BloomForCausalLM\", \"BloomModel\")\nclass BloomModel(Model):\n    model_arch = gguf.MODEL_ARCH.BLOOM\n\n    def set_gguf_parameters(self):\n        n_embed = self.hparams.get(\"hidden_size\", self.hparams.get(\"n_embed\"))\n        n_head = self.hparams.get(\"n_head\", self.hparams.get(\"num_attention_heads\"))\n        self.gguf_writer.add_context_length(self.hparams.get(\"seq_length\", n_embed))\n        self.gguf_writer.add_embedding_length(n_embed)\n        self.gguf_writer.add_feed_forward_length(4 * n_embed)\n        self.gguf_writer.add_block_count(self.hparams[\"n_layer\"])\n        self.gguf_writer.add_head_count(n_head)\n        self.gguf_writer.add_head_count_kv(n_head)\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        n_head = self.hparams.get(\"n_head\", self.hparams.get(\"num_attention_heads\"))\n        n_embed = self.hparams.get(\"hidden_size\", self.hparams.get(\"n_embed\"))\n\n        name = re.sub(r'transformer\\.', '', name)\n\n        tensors: list[tuple[str, Tensor]] = []\n\n        if re.match(r\"h\\.\\d+\\.self_attention\\.query_key_value\\.weight\", name):\n            # Map bloom-style qkv_linear to gpt-style qkv_linear\n            # bloom: https://github.com/huggingface/transformers/blob/main/src/transformers/models/bloom/modeling_bloom.py#L238-L252  # noqa\n            # gpt-2: https://github.com/huggingface/transformers/blob/main/src/transformers/models/gpt2/modeling_gpt2.py#L312  # noqa\n            qkv_weights = data_torch.reshape((n_head, 3, n_embed // n_head, n_embed))\n            data_torch = torch.cat(\n                (\n                    qkv_weights[:, 0, :, :].reshape((-1, n_embed)),\n                    qkv_weights[:, 1, :, :].reshape((-1, n_embed)),\n                    qkv_weights[:, 2, :, :].reshape((-1, n_embed)),\n                ),\n                dim=0,\n            )\n            logger.info(\"re-format attention.linear_qkv.weight\")\n        elif re.match(r\"h\\.\\d+\\.self_attention\\.query_key_value\\.bias\", name):\n            qkv_bias = data_torch.reshape((n_head, 3, n_embed // n_head))\n            data_torch = torch.cat(\n                (\n                    qkv_bias[:, 0, :].reshape((n_embed,)),\n                    qkv_bias[:, 1, :].reshape((n_embed,)),\n                    qkv_bias[:, 2, :].reshape((n_embed,)),\n                ),\n                dim=0,\n            )\n            logger.info(\"re-format attention.linear_qkv.bias\")\n\n        tensors.append((self.map_tensor_name(name), data_torch))\n\n        if name == \"word_embeddings.weight\":\n            assert self.tensor_names is not None\n\n            # TODO: tie them at runtime, don't duplicate in the model file\n            if all(s not in self.tensor_names for s in (\"lm_head.weight\", \"output.weight\")):\n                tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.OUTPUT), data_torch))\n\n        return tensors\n\n\n@Model.register(\"MPTForCausalLM\")\nclass MPTModel(Model):\n    model_arch = gguf.MODEL_ARCH.MPT\n\n    def set_vocab(self):\n        try:\n            self._set_vocab_gpt2()\n        except Exception:\n            # Fallback for SEA-LION model\n            self._set_vocab_sentencepiece()\n            self.gguf_writer.add_add_bos_token(False)\n            self.gguf_writer.add_pad_token_id(3)\n            self.gguf_writer.add_eos_token_id(1)\n            self.gguf_writer.add_unk_token_id(0)\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"n_layers\"]\n        self.gguf_writer.add_context_length(self.hparams[\"max_seq_len\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"d_model\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(4 * self.hparams[\"d_model\"])\n        self.gguf_writer.add_head_count(self.hparams[\"n_heads\"])\n        if kv_n_heads := self.hparams[\"attn_config\"].get(\"kv_n_heads\"):\n            self.gguf_writer.add_head_count_kv(kv_n_heads)\n        self.gguf_writer.add_layer_norm_eps(1e-5)\n        if self.hparams[\"attn_config\"][\"clip_qkv\"] is not None:\n            self.gguf_writer.add_clamp_kqv(self.hparams[\"attn_config\"][\"clip_qkv\"])\n        if self.hparams[\"attn_config\"][\"alibi\"]:\n            self.gguf_writer.add_max_alibi_bias(self.hparams[\"attn_config\"][\"alibi_bias_max\"])\n        else:\n            self.gguf_writer.add_max_alibi_bias(0.0)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        if \"scales\" in name:\n            new_name = self.map_tensor_name(name, try_suffixes=(\".weight\", \".bias\", \".scales\"))\n            new_name = new_name.replace(\"scales\", \"act.scales\")\n        else:\n            new_name = self.map_tensor_name(name, try_suffixes=(\".weight\", \".bias\"))\n\n        return [(new_name, data_torch)]\n\n\n@Model.register(\"OrionForCausalLM\")\nclass OrionModel(Model):\n    model_arch = gguf.MODEL_ARCH.ORION\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"num_hidden_layers\"]\n        head_count = self.hparams[\"num_attention_heads\"]\n        head_count_kv = self.hparams.get(\"num_key_value_heads\", head_count)\n\n        ctx_length = 0\n        if \"max_sequence_length\" in self.hparams:\n            ctx_length = self.hparams[\"max_sequence_length\"]\n        elif \"max_position_embeddings\" in self.hparams:\n            ctx_length = self.hparams[\"max_position_embeddings\"]\n        elif \"model_max_length\" in self.hparams:\n            ctx_length = self.hparams[\"model_max_length\"]\n        else:\n            raise ValueError(\"gguf: can not find ctx length parameter.\")\n\n        self.gguf_writer.add_file_type(self.ftype)\n        self.gguf_writer.add_tensor_data_layout(\"Meta AI original pth\")\n        self.gguf_writer.add_context_length(ctx_length)\n        self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"intermediate_size\"])\n        self.gguf_writer.add_head_count(head_count)\n        self.gguf_writer.add_head_count_kv(head_count_kv)\n        # note: config provides rms norm but it is actually layer norm\n        # ref:  https://huggingface.co/OrionStarAI/Orion-14B-Chat/blob/276a17221ce42beb45f66fac657a41540e71f4f5/modeling_orion.py#L570-L571\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"rms_norm_eps\"])\n\n\n@Model.register(\"BaichuanForCausalLM\", \"BaiChuanForCausalLM\")\nclass BaichuanModel(Model):\n    model_arch = gguf.MODEL_ARCH.BAICHUAN\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"num_hidden_layers\"]\n        head_count = self.hparams[\"num_attention_heads\"]\n        head_count_kv = self.hparams.get(\"num_key_value_heads\", head_count)\n\n        ctx_length = 0\n        if \"max_sequence_length\" in self.hparams:\n            ctx_length = self.hparams[\"max_sequence_length\"]\n        elif \"max_position_embeddings\" in self.hparams:\n            ctx_length = self.hparams[\"max_position_embeddings\"]\n        elif \"model_max_length\" in self.hparams:\n            ctx_length = self.hparams[\"model_max_length\"]\n        else:\n            raise ValueError(\"gguf: can not find ctx length parameter.\")\n\n        self.gguf_writer.add_tensor_data_layout(\"Meta AI original pth\")\n        self.gguf_writer.add_context_length(ctx_length)\n        self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"intermediate_size\"])\n        self.gguf_writer.add_rope_dimension_count(self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count(head_count)\n        self.gguf_writer.add_head_count_kv(head_count_kv)\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"rms_norm_eps\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n        if self.hparams.get(\"rope_scaling\") is not None and \"factor\" in self.hparams[\"rope_scaling\"]:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"linear\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n                self.gguf_writer.add_rope_scaling_factor(self.hparams[\"rope_scaling\"][\"factor\"])\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        head_count = self.hparams[\"num_attention_heads\"]\n        head_count_kv = self.hparams.get(\"num_key_value_heads\", head_count)\n\n        tensors: list[tuple[str, Tensor]] = []\n\n        if bid is not None and name == f\"model.layers.{bid}.self_attn.W_pack.weight\":\n            logger.info(f\"Unpacking and permuting layer {bid}\")\n            tensors = [\n                (self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_Q, bid),\n                    self._reverse_hf_permute_part(data_torch, 0, head_count, head_count)),\n                (self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_K, bid),\n                    self._reverse_hf_permute_part(data_torch, 1, head_count, head_count_kv)),\n                (self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_V, bid),\n                    self._reverse_hf_part(data_torch, 2)),\n            ]\n        else:\n            tensors = [(self.map_tensor_name(name), data_torch)]\n\n        return tensors\n\n    def _reverse_hf_permute(self, weights: Tensor, n_head: int, n_kv_head: int | None = None) -> Tensor:\n        if n_kv_head is not None and n_head != n_kv_head:\n            n_head //= n_kv_head\n\n        return (\n            weights.reshape(n_head, 2, weights.shape[0] // n_head // 2, *weights.shape[1:])\n            .swapaxes(1, 2)\n            .reshape(weights.shape)\n        )\n\n    def _reverse_hf_permute_part(\n        self, weights: Tensor, n_part: int, n_head: int, n_head_kv: int | None = None,\n    ) -> Tensor:\n        r = weights.shape[0] // 3\n        return self._reverse_hf_permute(weights[r * n_part:r * n_part + r, ...], n_head, n_head_kv)\n\n    def _reverse_hf_part(self, weights: Tensor, n_part: int) -> Tensor:\n        r = weights.shape[0] // 3\n        return weights[r * n_part:r * n_part + r, ...]\n\n\n@Model.register(\"XverseForCausalLM\")\nclass XverseModel(Model):\n    model_arch = gguf.MODEL_ARCH.XVERSE\n\n    def set_vocab(self):\n        assert (self.dir_model / \"tokenizer.json\").is_file()\n        dir_model = self.dir_model\n        hparams = self.hparams\n\n        tokens: list[bytes] = []\n        toktypes: list[int] = []\n\n        from transformers import AutoTokenizer\n        tokenizer = AutoTokenizer.from_pretrained(dir_model)\n        vocab_size = hparams.get(\"vocab_size\", len(tokenizer.vocab))\n        # Since we are checking the maximum index, we need to ensure it's strictly less than vocab_size,\n        # because vocab_size is the count of items, and indexes start at 0.\n        max_vocab_index = max(tokenizer.get_vocab().values())\n        if max_vocab_index >= vocab_size:\n            raise ValueError(\"Vocabulary size exceeds expected maximum size.\")\n\n        reverse_vocab: dict[int, str] = {id_: encoded_tok for encoded_tok, id_ in tokenizer.vocab.items()}\n        added_vocab = tokenizer.get_added_vocab()\n\n        for token_id in range(vocab_size):\n            token_text = reverse_vocab[token_id].encode('utf-8')\n            # replace \"\\x00\" to string with length > 0\n            if token_text == b\"\\x00\":\n                toktype = gguf.TokenType.BYTE  # special\n                token_text = f\"<{token_text}>\".encode('utf-8')\n            elif re.fullmatch(br\"<0x[0-9A-Fa-f]{2}>\", token_text):\n                toktype = gguf.TokenType.BYTE  # special\n            elif reverse_vocab[token_id] in added_vocab:\n                if tokenizer.added_tokens_decoder[token_id].special:\n                    toktype = gguf.TokenType.CONTROL\n                else:\n                    toktype = gguf.TokenType.USER_DEFINED\n            else:\n                toktype = gguf.TokenType.NORMAL\n\n            tokens.append(token_text)\n            toktypes.append(toktype)\n\n        self.gguf_writer.add_tokenizer_model(\"llama\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"num_hidden_layers\"]\n        head_count = self.hparams[\"num_attention_heads\"]\n        head_count_kv = self.hparams.get(\"num_key_value_heads\", head_count)\n\n        ctx_length = 0\n        if \"max_sequence_length\" in self.hparams:\n            ctx_length = self.hparams[\"max_sequence_length\"]\n        elif \"max_position_embeddings\" in self.hparams:\n            ctx_length = self.hparams[\"max_position_embeddings\"]\n        elif \"model_max_length\" in self.hparams:\n            ctx_length = self.hparams[\"model_max_length\"]\n        else:\n            raise ValueError(\"gguf: can not find ctx length parameter.\")\n\n        self.gguf_writer.add_tensor_data_layout(\"Meta AI original pth\")\n        self.gguf_writer.add_context_length(ctx_length)\n        self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"intermediate_size\"])\n        self.gguf_writer.add_rope_dimension_count(self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count(head_count)\n        self.gguf_writer.add_head_count_kv(head_count_kv)\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"rms_norm_eps\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n        if self.hparams.get(\"rope_scaling\") is not None and \"factor\" in self.hparams[\"rope_scaling\"]:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"linear\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n                self.gguf_writer.add_rope_scaling_factor(self.hparams[\"rope_scaling\"][\"factor\"])\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        head_count = self.hparams[\"num_attention_heads\"]\n        head_count_kv = self.hparams.get(\"num_key_value_heads\", head_count)\n\n        # HF models permute some of the tensors, so we need to undo that\n        if name.endswith(\"q_proj.weight\"):\n            data_torch = self._reverse_hf_permute(data_torch, head_count, head_count)\n        if name.endswith(\"k_proj.weight\"):\n            data_torch = self._reverse_hf_permute(data_torch, head_count, head_count_kv)\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def _reverse_hf_permute(self, weights: Tensor, n_head: int, n_kv_head: int | None = None) -> Tensor:\n        if n_kv_head is not None and n_head != n_kv_head:\n            n_head //= n_kv_head\n\n        return (\n            weights.reshape(n_head, 2, weights.shape[0] // n_head // 2, *weights.shape[1:])\n            .swapaxes(1, 2)\n            .reshape(weights.shape)\n        )\n\n\n@Model.register(\"FalconForCausalLM\", \"RWForCausalLM\")\nclass FalconModel(Model):\n    model_arch = gguf.MODEL_ARCH.FALCON\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams.get(\"num_hidden_layers\")\n        if block_count is None:\n            block_count = self.hparams[\"n_layer\"]  # old name\n\n        n_head = self.hparams.get(\"num_attention_heads\")\n        if n_head is None:\n            n_head = self.hparams[\"n_head\"]  # old name\n\n        n_head_kv = self.hparams.get(\"num_kv_heads\")\n        if n_head_kv is None:\n            n_head_kv = self.hparams.get(\"n_head_kv\", 1)  # old name\n\n        self.gguf_writer.add_context_length(2048)  # not in config.json\n        self.gguf_writer.add_tensor_data_layout(\"jploski\")  # qkv tensor transform\n        self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_feed_forward_length(4 * self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_head_count(n_head)\n        self.gguf_writer.add_head_count_kv(n_head_kv)\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        # QKV tensor transform\n        # The original query_key_value tensor contains n_head_kv \"kv groups\",\n        # each consisting of n_head/n_head_kv query weights followed by one key\n        # and one value weight (shared by all query heads in the kv group).\n        # This layout makes it a big pain to work with in GGML.\n        # So we rearrange them here,, so that we have n_head query weights\n        # followed by n_head_kv key weights followed by n_head_kv value weights,\n        # in contiguous fashion.\n        # ref: https://github.com/jploski/ggml/blob/falcon40b/examples/falcon/convert-hf-to-ggml.py\n\n        if \"query_key_value\" in name:\n            n_head = self.find_hparam([\"num_attention_heads\", \"n_head\"])\n            n_head_kv = self.find_hparam([\"num_kv_heads\", \"n_head_kv\"], optional=True) or 1\n            head_dim = self.hparams[\"hidden_size\"] // n_head\n\n            qkv = data_torch.view(n_head_kv, n_head // n_head_kv + 2, head_dim, head_dim * n_head)\n            q = qkv[:, :-2].reshape(n_head * head_dim, head_dim * n_head)\n            k = qkv[:, [-2]].reshape(n_head_kv * head_dim, head_dim * n_head)\n            v = qkv[:, [-1]].reshape(n_head_kv * head_dim, head_dim * n_head)\n            data_torch = torch.cat((q, k, v)).reshape_as(data_torch)\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"GPTBigCodeForCausalLM\")\nclass StarCoderModel(Model):\n    model_arch = gguf.MODEL_ARCH.STARCODER\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"n_layer\"]\n\n        self.gguf_writer.add_context_length(self.hparams[\"n_positions\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"n_embd\"])\n        self.gguf_writer.add_feed_forward_length(4 * self.hparams[\"n_embd\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_head_count(self.hparams[\"n_head\"])\n        self.gguf_writer.add_head_count_kv(1)\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n\n@Model.register(\"GPTRefactForCausalLM\")\nclass RefactModel(Model):\n    model_arch = gguf.MODEL_ARCH.REFACT\n\n    def set_vocab(self):\n        super().set_vocab()\n\n        # TODO: how to determine special FIM tokens automatically?\n        special_vocab = gguf.SpecialVocab(self.dir_model, load_merges=False,\n                                          special_token_types = ['prefix', 'suffix', 'middle', 'eot'])\n        special_vocab._set_special_token(\"prefix\", 1)\n        special_vocab._set_special_token(\"suffix\", 3)\n        special_vocab._set_special_token(\"middle\", 2)\n        special_vocab.chat_template = None  # do not add it twice\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def set_gguf_parameters(self):\n        hidden_dim = self.hparams[\"n_embd\"]\n        inner_dim = 4 * hidden_dim\n        hidden_dim = int(2 * inner_dim / 3)\n        multiple_of = 256\n        ff_dim = multiple_of * ((hidden_dim + multiple_of - 1) // multiple_of)\n\n        block_count = self.hparams[\"n_layer\"]\n\n        # refact uses Alibi. So this is from config.json which might be used by training.\n        self.gguf_writer.add_context_length(self.hparams[\"n_positions\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"n_embd\"])\n\n        self.gguf_writer.add_feed_forward_length(ff_dim)\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_head_count(self.hparams[\"n_head\"])\n        self.gguf_writer.add_head_count_kv(1)\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        hidden_dim = self.hparams[\"n_embd\"]\n        inner_dim = 4 * hidden_dim\n        hidden_dim = int(2 * inner_dim / 3)\n        multiple_of = 256\n        ff_dim = multiple_of * ((hidden_dim + multiple_of - 1) // multiple_of)\n        n_head = self.hparams[\"n_head\"]\n        n_head_kv = 1\n        head_dim = self.hparams[\"n_embd\"] // n_head\n\n        tensors: list[tuple[str, Tensor]] = []\n\n        if bid is not None:\n            if name == f\"transformer.h.{bid}.attn.kv.weight\":\n                tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_K, bid), data_torch[:n_head_kv * head_dim]))\n                tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_V, bid), data_torch[n_head_kv * head_dim:]))\n            elif name == f\"transformer.h.{bid}.attn.q.weight\":\n                tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_Q, bid), data_torch))\n            elif name == f\"transformer.h.{bid}.mlp.gate_up_proj.weight\":\n                tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.FFN_GATE, bid), data_torch[:ff_dim]))\n                tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.FFN_UP, bid), data_torch[ff_dim:]))\n\n        if len(tensors) == 0:\n            tensors.append((self.map_tensor_name(name), data_torch))\n\n        return tensors\n\n\n@Model.register(\"StableLmForCausalLM\", \"StableLMEpochForCausalLM\", \"LlavaStableLMEpochForCausalLM\")\nclass StableLMModel(Model):\n    model_arch = gguf.MODEL_ARCH.STABLELM\n\n    def set_vocab(self):\n        if (self.dir_model / \"tokenizer.json\").is_file():\n            self._set_vocab_gpt2()\n        else:\n            # StableLM 2 1.6B used to have a vocab in a similar format to Qwen's vocab\n            self._set_vocab_qwen()\n\n    def set_gguf_parameters(self):\n        hparams = self.hparams\n        block_count = hparams[\"num_hidden_layers\"]\n\n        self.gguf_writer.add_context_length(hparams[\"max_position_embeddings\"])\n        self.gguf_writer.add_embedding_length(hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(hparams[\"intermediate_size\"])\n        rotary_factor = self.find_hparam([\"partial_rotary_factor\", \"rope_pct\"])\n        self.gguf_writer.add_rope_dimension_count(int(rotary_factor * (hparams[\"hidden_size\"] // hparams[\"num_attention_heads\"])))\n        self.gguf_writer.add_head_count(hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count_kv(hparams[\"num_key_value_heads\"])\n        self.gguf_writer.add_parallel_residual(hparams[\"use_parallel_residual\"] if \"use_parallel_residual\" in hparams else True)\n        self.gguf_writer.add_layer_norm_eps(self.find_hparam([\"layer_norm_eps\", \"norm_eps\"]))\n        self.gguf_writer.add_file_type(self.ftype)\n\n    _q_norms: list[dict[str, Tensor]] | None = None\n    _k_norms: list[dict[str, Tensor]] | None = None\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        n_head = self.hparams[\"num_attention_heads\"]\n        n_kv_head = self.hparams[\"num_key_value_heads\"]\n\n        if name.find(\"q_layernorm.norms\") != -1:\n            assert bid is not None\n\n            if self._q_norms is None:\n                self._q_norms = [{} for _ in range(self.block_count)]\n\n            self._q_norms[bid][name] = data_torch\n\n            if len(self._q_norms[bid]) >= n_head:\n                return self._stack_qk_norm(bid, n_head, self._q_norms[bid], \"q_layernorm\")\n            else:\n                return []\n\n        if name.find(\"k_layernorm.norms\") != -1:\n            assert bid is not None\n\n            if self._k_norms is None:\n                self._k_norms = [{} for _ in range(self.block_count)]\n\n            self._k_norms[bid][name] = data_torch\n\n            if len(self._k_norms[bid]) >= n_kv_head:\n                return self._stack_qk_norm(bid, n_kv_head, self._k_norms[bid], \"k_layernorm\")\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def _stack_qk_norm(self, bid: int, n_head: int, norms: dict[str, Tensor], layer_name: str = \"q_layernorm\"):\n        datas: list[Tensor] = []\n        # extract the norms in order\n        for xid in range(n_head):\n            ename = f\"model.layers.{bid}.self_attn.{layer_name}.norms.{xid}.weight\"\n            datas.append(norms[ename])\n            del norms[ename]\n        data_torch = torch.stack(datas, dim=0)\n\n        merged_name = f\"model.layers.{bid}.self_attn.{layer_name}.weight\"\n        new_name = self.map_tensor_name(merged_name)\n\n        return [(new_name, data_torch)]\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._q_norms is not None or self._k_norms is not None:\n            # flatten two `list[dict[str, Tensor]]` into a single `list[str]`\n            norms = (\n                [k for d in self._q_norms for k in d.keys()] if self._q_norms is not None else []\n            ) + (\n                [k for d in self._k_norms for k in d.keys()] if self._k_norms is not None else []\n            )\n            if len(norms) > 0:\n                raise ValueError(f\"Unprocessed norms: {norms}\")\n\n\n@Model.register(\"LLaMAForCausalLM\", \"LlamaForCausalLM\", \"MistralForCausalLM\", \"MixtralForCausalLM\")\nclass LlamaModel(Model):\n    model_arch = gguf.MODEL_ARCH.LLAMA\n\n    def set_vocab(self):\n        try:\n            self._set_vocab_sentencepiece()\n        except FileNotFoundError:\n            try:\n                self._set_vocab_llama_hf()\n            except (FileNotFoundError, TypeError):\n                # Llama 3\n                self._set_vocab_gpt2()\n\n        # Apply to CodeLlama only (and ignore for Llama 3 with a vocab size of 128256)\n        if self.hparams.get(\"vocab_size\", 32000) == 32016:\n            special_vocab = gguf.SpecialVocab(\n                self.dir_model, load_merges=False,\n                special_token_types = ['prefix', 'suffix', 'middle', 'eot']\n            )\n            special_vocab._set_special_token(\"prefix\", 32007)\n            special_vocab._set_special_token(\"suffix\", 32008)\n            special_vocab._set_special_token(\"middle\", 32009)\n            special_vocab._set_special_token(\"eot\",    32010)\n            special_vocab.add_to_gguf(self.gguf_writer)\n\n        tokenizer_config_file = self.dir_model / 'tokenizer_config.json'\n        if tokenizer_config_file.is_file():\n            with open(tokenizer_config_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_config_json = json.load(f)\n                if \"add_prefix_space\" in tokenizer_config_json:\n                    self.gguf_writer.add_add_space_prefix(tokenizer_config_json[\"add_prefix_space\"])\n\n        # Apply to granite small models only\n        if self.hparams.get(\"vocab_size\", 32000) == 49152:\n            self.gguf_writer.add_add_bos_token(False)\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        hparams = self.hparams\n        self.gguf_writer.add_vocab_size(hparams[\"vocab_size\"])\n\n        if \"head_dim\" in hparams:\n            rope_dim = hparams[\"head_dim\"]\n        else:\n            rope_dim = hparams[\"hidden_size\"] // hparams[\"num_attention_heads\"]\n        self.gguf_writer.add_rope_dimension_count(rope_dim)\n\n        if self.hparams.get(\"rope_scaling\") is not None and \"factor\" in self.hparams[\"rope_scaling\"]:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"linear\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n                self.gguf_writer.add_rope_scaling_factor(self.hparams[\"rope_scaling\"][\"factor\"])\n\n    @staticmethod\n    def permute(weights: Tensor, n_head: int, n_head_kv: int | None):\n        if n_head_kv is not None and n_head != n_head_kv:\n            n_head = n_head_kv\n        return (weights.reshape(n_head, 2, weights.shape[0] // n_head // 2, *weights.shape[1:])\n                .swapaxes(1, 2)\n                .reshape(weights.shape))\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        n_head = self.hparams[\"num_attention_heads\"]\n        n_kv_head = self.hparams.get(\"num_key_value_heads\")\n\n        if name.endswith((\"q_proj.weight\", \"q_proj.bias\")):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_head)\n        if name.endswith((\"k_proj.weight\", \"k_proj.bias\")):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_kv_head)\n\n        # process the experts separately\n        if name.find(\"block_sparse_moe.experts\") != -1:\n            n_experts = self.hparams[\"num_local_experts\"]\n\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for wid in [\"w1\", \"w2\", \"w3\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"model.layers.{bid}.block_sparse_moe.experts.{xid}.{wid}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"layers.{bid}.feed_forward.experts.{wid}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n        if rope_scaling := self.find_hparam([\"rope_scaling\"], optional=True):\n            if rope_scaling.get(\"rope_type\", '').lower() == \"llama3\":\n                base = self.hparams.get(\"rope_theta\", 10000.0)\n                dim = self.hparams.get(\"head_dim\", self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n                freqs = 1.0 / (base ** (torch.arange(0, dim, 2, dtype=torch.float32) / dim))\n\n                factor = rope_scaling.get(\"factor\", 8.0)\n                low_freq_factor = rope_scaling.get(\"low_freq_factor\", 1.0)\n                high_freq_factor = rope_scaling.get(\"high_freq_factor\", 4.0)\n                old_context_len = self.hparams.get(\"original_max_position_embeddings\", 8192)\n\n                low_freq_wavelen = old_context_len / low_freq_factor\n                high_freq_wavelen = old_context_len / high_freq_factor\n                assert low_freq_wavelen != high_freq_wavelen\n\n                rope_factors = []\n                for freq in freqs:\n                    wavelen = 2 * math.pi / freq\n                    if wavelen < high_freq_wavelen:\n                        rope_factors.append(1)\n                    elif wavelen > low_freq_wavelen:\n                        rope_factors.append(factor)\n                    else:\n                        smooth = (old_context_len / wavelen - low_freq_factor) / (high_freq_factor - low_freq_factor)\n                        rope_factors.append(1 / ((1 - smooth) / factor + smooth))\n\n                yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FREQS), torch.tensor(rope_factors, dtype=torch.float32))\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._experts is not None:\n            # flatten `list[dict[str, Tensor]]` into `list[str]`\n            experts = [k for d in self._experts for k in d.keys()]\n            if len(experts) > 0:\n                raise ValueError(f\"Unprocessed experts: {experts}\")\n\n\n@Model.register(\"DeciLMForCausalLM\")\nclass DeciModel(Model):\n    model_arch = gguf.MODEL_ARCH.DECI\n\n    @staticmethod\n    def _ffn_mult_to_intermediate_size(ffn_mult: float, n_embd: int) -> int:\n        # DeciLM-specific code\n        intermediate_size = int(2 * ffn_mult * n_embd / 3)\n        return DeciModel._find_multiple(intermediate_size, 256)\n\n    @staticmethod\n    def _find_multiple(n: int, k: int) -> int:\n        # DeciLM-specific code\n        if n % k == 0:\n            return n\n        return n + k - (n % k)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if \"block_configs\" in self.hparams: # Llama-3_1-Nemotron-51B\n            _block_configs: list[dict[str,Any]] = self.hparams[\"block_configs\"]\n            assert self.block_count == len(_block_configs)\n            self._num_kv_heads = list()\n            self._num_heads = list()\n            _ffn_multipliers = list()\n            # ***linear attention layer***\n            # if n_heads_in_group is None and replace_with_linear is True\n            # then _num_kv_heads[il] is 0 and _num_heads[il] is num_attention_heads\n            # ***attention-free layer***\n            # if n_heads_in_group is None and replace_with_linear is False\n            # then _num_kv_heads[il] is 0 and _num_heads[il] is 0\n            # ***normal attention-layer***\n            # if n_heads_in_group is not None, then\n            # _num_kv_heads[il] is num_attention_head // n_heads_in_group and\n            # _num_heads[il] is num_attention_head\n            for il in range(len(_block_configs)):\n                if _block_configs[il][\"attention\"][\"n_heads_in_group\"] is None:\n                    if _block_configs[il][\"attention\"][\"replace_with_linear\"] is True:\n                        self._num_kv_heads.append(0)\n                        self._num_heads.append(self.hparams[\"num_attention_heads\"])\n                    else:\n                        self._num_kv_heads.append(0)\n                        self._num_heads.append(0)\n                else:\n                    self._num_kv_heads.append(self.hparams[\"num_attention_heads\"] // _block_configs[il][\"attention\"][\"n_heads_in_group\"])\n                    self._num_heads.append(self.hparams[\"num_attention_heads\"])\n                _ffn_multipliers.append(_block_configs[il][\"ffn\"][\"ffn_mult\"])\n            assert self.block_count == len(self._num_kv_heads)\n            assert self.block_count == len(self._num_heads)\n            assert self.block_count == len(_ffn_multipliers)\n            assert isinstance(self._num_kv_heads, list) and isinstance(self._num_kv_heads[0], int)\n            assert isinstance(self._num_heads, list) and isinstance(self._num_heads[0], int)\n            assert isinstance(_ffn_multipliers, list) and isinstance(_ffn_multipliers[0], float)\n            self._ffn_dims: list[int] = [\n                DeciModel._ffn_mult_to_intermediate_size(multiplier, self.hparams[\"hidden_size\"])\n                for multiplier in _ffn_multipliers\n            ]\n\n    def set_vocab(self):\n        # Please change tokenizer_config.json of Llama-3_1-Nemotron-51B's\n        # eos_token from '|eot_id|' to '|end_of_text|'\n        if self.hparams.get(\"vocab_size\", 128256) == 128256:\n            tokens, toktypes, tokpre = self.get_vocab_base()\n            self.gguf_writer.add_tokenizer_model(\"gpt2\")\n            self.gguf_writer.add_tokenizer_pre(tokpre)\n            self.gguf_writer.add_token_list(tokens)\n            self.gguf_writer.add_token_types(toktypes)\n\n            special_vocab = gguf.SpecialVocab(self.dir_model, load_merges=True)\n            special_vocab.add_to_gguf(self.gguf_writer)\n        else:\n            # DeciLM-7B\n            self._set_vocab_llama_hf()\n\n    def set_gguf_parameters(self):\n        if \"block_configs\" in self.hparams: # Llama-3_1-Nemotron-51B\n            assert self.block_count == len(self._num_kv_heads)\n            assert self.block_count == len(self._num_heads)\n            assert self.block_count == len(self._ffn_dims)\n            if (rope_theta := self.hparams.get(\"rope_theta\")) is not None:\n                self.gguf_writer.add_rope_freq_base(rope_theta)\n            self.gguf_writer.add_head_count_kv(self._num_kv_heads)\n            self.gguf_writer.add_head_count(self._num_heads)\n            self.gguf_writer.add_feed_forward_length(self._ffn_dims)\n            self.gguf_writer.add_block_count(self.block_count)\n            self.gguf_writer.add_context_length(self.hparams[\"max_position_embeddings\"])\n            self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n            self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"rms_norm_eps\"])\n            self.gguf_writer.add_key_length(self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n            self.gguf_writer.add_value_length(self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n            self.gguf_writer.add_file_type(self.ftype)\n        else: # DeciLM-7B\n            super().set_gguf_parameters()\n            if \"num_key_value_heads_per_layer\" in self.hparams: # DeciLM-7B\n                self._num_kv_heads: list[int] = self.hparams[\"num_key_value_heads_per_layer\"]\n                assert self.block_count == len(self._num_kv_heads)\n                self.gguf_writer.add_head_count_kv(self._num_kv_heads)\n        hparams = self.hparams\n        self.gguf_writer.add_vocab_size(hparams[\"vocab_size\"])\n\n        if \"head_dim\" in hparams:\n            rope_dim = hparams[\"head_dim\"]\n        else:\n            rope_dim = hparams[\"hidden_size\"] // hparams[\"num_attention_heads\"]\n        self.gguf_writer.add_rope_dimension_count(rope_dim)\n\n        if self.hparams.get(\"rope_scaling\") is not None and \"factor\" in self.hparams[\"rope_scaling\"]:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"linear\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n                self.gguf_writer.add_rope_scaling_factor(self.hparams[\"rope_scaling\"][\"factor\"])\n\n    @staticmethod\n    def permute(weights: Tensor, n_head: int, n_head_kv: int | None):\n        if n_head_kv is not None and n_head != n_head_kv:\n            n_head = n_head_kv\n        return (weights.reshape(n_head, 2, weights.shape[0] // n_head // 2, *weights.shape[1:])\n                .swapaxes(1, 2)\n                .reshape(weights.shape))\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        n_head = self.hparams[\"num_attention_heads\"]\n        if bid is not None:\n            if \"num_key_value_heads_per_layer\" in self.hparams:\n                n_kv_head = self.hparams[\"num_key_value_heads_per_layer\"][bid]\n            elif \"block_configs\" in self.hparams:\n                n_kv_head = self._num_kv_heads[bid]\n                n_head = self._num_heads[bid]\n            else:\n                n_kv_head = self.hparams.get(\"num_key_value_heads\")\n        else:\n            n_kv_head = self.hparams.get(\"num_key_value_heads\")\n\n        if name.endswith((\"q_proj.weight\", \"q_proj.bias\")):\n            data_torch = DeciModel.permute(data_torch, n_head, n_head)\n        if name.endswith((\"k_proj.weight\", \"k_proj.bias\")):\n            data_torch = DeciModel.permute(data_torch, n_head, n_kv_head)\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n        if rope_scaling := self.find_hparam([\"rope_scaling\"], optional=True):\n            if rope_scaling.get(\"rope_type\", '').lower() == \"llama3\":\n                base = self.hparams.get(\"rope_theta\", 10000.0)\n                dim = self.hparams.get(\"head_dim\", self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n                freqs = 1.0 / (base ** (torch.arange(0, dim, 2, dtype=torch.float32) / dim))\n\n                factor = rope_scaling.get(\"factor\", 8.0)\n                low_freq_factor = rope_scaling.get(\"low_freq_factor\", 1.0)\n                high_freq_factor = rope_scaling.get(\"high_freq_factor\", 4.0)\n                old_context_len = self.hparams.get(\"original_max_position_embeddings\", 8192)\n\n                low_freq_wavelen = old_context_len / low_freq_factor\n                high_freq_wavelen = old_context_len / high_freq_factor\n                assert low_freq_wavelen != high_freq_wavelen\n\n                rope_factors = []\n                for freq in freqs:\n                    wavelen = 2 * math.pi / freq\n                    if wavelen < high_freq_wavelen:\n                        rope_factors.append(1)\n                    elif wavelen > low_freq_wavelen:\n                        rope_factors.append(factor)\n                    else:\n                        smooth = (old_context_len / wavelen - low_freq_factor) / (high_freq_factor - low_freq_factor)\n                        rope_factors.append(1 / ((1 - smooth) / factor + smooth))\n\n                yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FREQS), torch.tensor(rope_factors, dtype=torch.float32))\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n\n@Model.register(\"BitnetForCausalLM\")\nclass BitnetModel(Model):\n    model_arch = gguf.MODEL_ARCH.BITNET\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n        self.gguf_writer.add_rope_scaling_factor(1.0)\n\n    def weight_quant(self, weight: Tensor) -> Tensor:\n        dtype = weight.dtype\n        weight = weight.float()\n        scale = weight.abs().mean().clamp(min=1e-5)\n        iscale = 1 / scale\n        # TODO: multiply by the scale directly instead of inverting it twice\n        # (this is also unnecessarily doubly inverted upstream)\n        # ref: https://huggingface.co/1bitLLM/bitnet_b1_58-3B/blob/af89e318d78a70802061246bf037199d2fb97020/utils_quant.py#L10\n        result = (weight * iscale).round().clamp(-1, 1) / iscale\n        return result.type(dtype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        new_name = self.map_tensor_name(name)\n\n        if any(self.match_model_tensor_name(new_name, key, bid) for key in [\n            gguf.MODEL_TENSOR.ATTN_Q,\n            gguf.MODEL_TENSOR.ATTN_K,\n            gguf.MODEL_TENSOR.ATTN_V,\n            gguf.MODEL_TENSOR.ATTN_OUT,\n            gguf.MODEL_TENSOR.FFN_UP,\n            gguf.MODEL_TENSOR.FFN_DOWN,\n            gguf.MODEL_TENSOR.FFN_GATE,\n        ]):\n            # transform weight into 1/0/-1 (in fp32)\n            data_torch = self.weight_quant(data_torch)\n\n        yield (new_name, data_torch)\n\n\n@Model.register(\"GrokForCausalLM\")\nclass GrokModel(Model):\n    model_arch = gguf.MODEL_ARCH.GROK\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # process the experts separately\n        if name.find(\".moe.\") != -1:\n            n_experts = self.hparams[\"num_local_experts\"]\n\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for wid in [\"linear\", \"linear_1\", \"linear_v\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"transformer.decoder_layer.{bid}.moe.{xid}.{wid}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"transformer.decoder_layer.{bid}.moe.{wid}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"DbrxForCausalLM\")\nclass DbrxModel(Model):\n    model_arch = gguf.MODEL_ARCH.DBRX\n\n    def set_gguf_parameters(self):\n        ffn_config = self.hparams[\"ffn_config\"]\n        attn_config = self.hparams[\"attn_config\"]\n        self.gguf_writer.add_block_count(self.hparams[\"n_layers\"])\n\n        self.gguf_writer.add_context_length(self.hparams[\"max_seq_len\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"d_model\"])\n        self.gguf_writer.add_feed_forward_length(ffn_config[\"ffn_hidden_size\"])\n\n        self.gguf_writer.add_head_count(self.hparams[\"n_heads\"])\n        self.gguf_writer.add_head_count_kv(attn_config[\"kv_n_heads\"])\n\n        self.gguf_writer.add_rope_freq_base(attn_config[\"rope_theta\"])\n\n        self.gguf_writer.add_clamp_kqv(attn_config[\"clip_qkv\"])\n\n        self.gguf_writer.add_expert_count(ffn_config[\"moe_num_experts\"])\n        self.gguf_writer.add_expert_used_count(ffn_config[\"moe_top_k\"])\n\n        self.gguf_writer.add_layer_norm_eps(1e-5)\n\n        self.gguf_writer.add_file_type(self.ftype)\n        logger.info(f\"gguf: file type = {self.ftype}\")\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        n_expert = self.hparams[\"ffn_config\"][\"moe_num_experts\"]\n        n_ff = self.hparams[\"ffn_config\"][\"ffn_hidden_size\"]\n        n_embd = self.hparams[\"d_model\"]\n\n        # Specific behavior for experts tensors: suffix .weight, view as 3D and transpose\n        # original implementation expects (n_expert, n_ff, n_embd) for all experts weights\n        # But llama.cpp moe graph works differently\n        # AND the dimensions in ggml are typically in the reverse order of the pytorch dimensions\n        # so (n_expert, n_ff, n_embd) in pytorch is {n_embd, n_ff, n_expert} in ggml_tensor\n        exp_tensor_names = {\"ffn.experts.mlp.w1\": None,       # LLM_TENSOR_FFN_GATE_EXPS ggml_tensor->ne{n_embd, n_ff,   n_expert}\n                            \"ffn.experts.mlp.w2\": (0, 2, 1),  # LLM_TENSOR_FFN_DOWN_EXPS ggml_tensor->ne{n_ff,   n_embd, n_expert}\n                            \"ffn.experts.mlp.v1\": None}       # LLM_TENSOR_FFN_UP_EXPS   ggml_tensor->ne{n_embd, n_ff,   n_expert}\n        experts = False\n\n        for exp_tensor_name in exp_tensor_names.keys():\n            if name.find(exp_tensor_name) != -1 and name.find(\".weight\") == -1:\n                experts = True\n                data_torch = data_torch.view(n_expert, n_ff, n_embd)\n                if (permute_tensor := exp_tensor_names[exp_tensor_name]) is not None:\n                    data_torch = data_torch.permute(*permute_tensor)\n                break\n\n        # map tensor names\n        # In MoE models the ffn tensors are typically most of the model weights,\n        # and need to be quantizable. Quantize expects tensor names to be suffixed by .weight.\n        # Every other model has the weight names ending in .weight,\n        # let's assume that is the convention which is not the case for dbrx:\n        # https://huggingface.co/databricks/dbrx-instruct/blob/main/model.safetensors.index.json#L15\n        new_name = self.map_tensor_name(name if not experts else name + \".weight\", try_suffixes=(\".weight\",))\n\n        return [(new_name, data_torch)]\n\n    def tensor_force_quant(self, name: str, new_name: str, bid: int | None, n_dims: int) -> gguf.GGMLQuantizationType | bool:\n        del name, new_name, bid  # unused\n\n        return n_dims > 1\n\n\n@Model.register(\"MiniCPMForCausalLM\")\nclass MiniCPMModel(Model):\n    model_arch = gguf.MODEL_ARCH.MINICPM\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        embedding_scale = float(self.hparams[\"scale_emb\"])\n        self.gguf_writer.add_embedding_scale(embedding_scale)\n        logger.info(f\"gguf: (minicpm) embedding_scale = {embedding_scale}\")\n        residual_scale = self.hparams[\"scale_depth\"] / self.hparams[\"num_hidden_layers\"] ** 0.5\n        self.gguf_writer.add_residual_scale(residual_scale)\n        logger.info(f\"gguf: (minicpm) residual_scale = {residual_scale}\")\n        logit_scale = self.hparams[\"hidden_size\"] / self.hparams[\"dim_model_base\"]\n        self.gguf_writer.add_logit_scale(logit_scale)\n        logger.info(f\"gguf: (minicpm) logit_scale = {logit_scale}\")\n        if self.hparams.get(\"rope_scaling\") is not None:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"longrope\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LONGROPE)\n                logger.info(f\"gguf: (minicpm) rope_scaling_type = {gguf.RopeScalingType.LONGROPE}\")\n\n    def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n        rope_dims = self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"]\n\n        rope_scaling = self.find_hparam(['rope_scaling'], True)\n        if rope_scaling is not None:\n            long_factors = rope_scaling.get('long_factor', None)\n            short_factors = rope_scaling.get('short_factor', None)\n\n            if long_factors is None or short_factors is None:\n                raise KeyError('Missing the required key rope_scaling.long_factor or rope_scaling_short_factor')\n\n            if len(long_factors) != len(short_factors) or len(long_factors) != rope_dims / 2:\n                raise ValueError(f'The length of rope long and short factors must be {rope_dims / 2}')\n\n            yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FACTORS_LONG), torch.tensor(long_factors, dtype=torch.float32))\n            yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FACTORS_SHORT), torch.tensor(short_factors, dtype=torch.float32))\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        n_head = self.hparams[\"num_attention_heads\"]\n        n_kv_head = self.hparams.get(\"num_key_value_heads\")\n\n        # HF models permute some of the tensors, so we need to undo that\n        if name.endswith((\"q_proj.weight\")):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_head)\n        if name.endswith((\"k_proj.weight\")):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_kv_head)\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"MiniCPM3ForCausalLM\")\nclass MiniCPM3Model(Model):\n    model_arch = gguf.MODEL_ARCH.MINICPM3\n\n    def set_gguf_parameters(self):\n        hparams = self.hparams\n\n        self.gguf_writer.add_file_type(self.ftype)\n        self.gguf_writer.add_context_length(hparams[\"max_position_embeddings\"])\n        self.gguf_writer.add_embedding_length(hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(self.block_count)\n        self.gguf_writer.add_feed_forward_length(hparams[\"intermediate_size\"])\n        self.gguf_writer.add_head_count(hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count_kv(hparams[\"num_key_value_heads\"])\n        self.gguf_writer.add_layer_norm_rms_eps(hparams[\"rms_norm_eps\"])\n        self.gguf_writer.add_vocab_size(hparams[\"vocab_size\"])\n        if \"q_lora_rank\" in hparams and hparams[\"q_lora_rank\"] is not None:\n            self.gguf_writer.add_q_lora_rank(hparams[\"q_lora_rank\"])\n        self.gguf_writer.add_kv_lora_rank(hparams[\"kv_lora_rank\"])\n        self.gguf_writer.add_key_length(hparams[\"qk_nope_head_dim\"] + hparams[\"qk_rope_head_dim\"])\n        self.gguf_writer.add_rope_dimension_count(hparams[\"qk_rope_head_dim\"])\n\n    def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n        rope_scaling = self.find_hparam(['rope_scaling'], True)\n        if rope_scaling is not None:\n            rope_dims = self.hparams[\"qk_rope_head_dim\"]\n\n            long_factors = rope_scaling.get('long_factor', None)\n            short_factors = rope_scaling.get('short_factor', None)\n\n            if long_factors is None or short_factors is None:\n                raise KeyError('Missing the required key rope_scaling.long_factor or rope_scaling_short_factor')\n\n            if len(long_factors) != len(short_factors) or len(long_factors) != rope_dims / 2:\n                raise ValueError(f'The length of rope long and short factors must be {rope_dims / 2}')\n\n            yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FACTORS_LONG), torch.tensor(long_factors, dtype=torch.float32))\n            yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FACTORS_SHORT), torch.tensor(short_factors, dtype=torch.float32))\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n    def _reverse_hf_permute(self, weights: Tensor, n_head: int, n_kv_head: int | None = None) -> Tensor:\n        if n_kv_head is not None and n_head != n_kv_head:\n            n_head //= n_kv_head\n\n        return (\n            weights.reshape(n_head, 2, weights.shape[0] // n_head // 2, *weights.shape[1:])\n            .swapaxes(1, 2)\n            .reshape(weights.shape)\n        )\n\n\n@Model.register(\"QWenLMHeadModel\")\nclass QwenModel(Model):\n    model_arch = gguf.MODEL_ARCH.QWEN\n\n    @staticmethod\n    def token_bytes_to_string(b):\n        from transformers.models.gpt2.tokenization_gpt2 import bytes_to_unicode\n        byte_encoder = bytes_to_unicode()\n        return ''.join([byte_encoder[ord(char)] for char in b.decode('latin-1')])\n\n    @staticmethod\n    def bpe(mergeable_ranks: dict[bytes, int], token: bytes, max_rank: int | None = None) -> list[bytes]:\n        parts = [bytes([b]) for b in token]\n        while True:\n            min_idx = None\n            min_rank = None\n            for i, pair in enumerate(zip(parts[:-1], parts[1:])):\n                rank = mergeable_ranks.get(pair[0] + pair[1])\n                if rank is not None and (min_rank is None or rank < min_rank):\n                    min_idx = i\n                    min_rank = rank\n            if min_rank is None or (max_rank is not None and min_rank >= max_rank):\n                break\n            assert min_idx is not None\n            parts = parts[:min_idx] + [parts[min_idx] + parts[min_idx + 1]] + parts[min_idx + 2:]\n        return parts\n\n    def set_vocab(self):\n        self._set_vocab_qwen()\n\n    def set_gguf_parameters(self):\n        self.gguf_writer.add_context_length(self.hparams[\"max_position_embeddings\"])\n        self.gguf_writer.add_block_count(self.hparams[\"num_hidden_layers\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"intermediate_size\"])\n        self.gguf_writer.add_rope_freq_base(self.hparams[\"rotary_emb_base\"])\n        self.gguf_writer.add_rope_dimension_count(self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count(self.hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n\n@Model.register(\"Qwen2ForCausalLM\")\nclass Qwen2Model(Model):\n    model_arch = gguf.MODEL_ARCH.QWEN2\n\n    def set_vocab(self):\n        try:\n            self._set_vocab_sentencepiece()\n        except FileNotFoundError:\n            self._set_vocab_gpt2()\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        if self.hparams.get(\"rope_scaling\") is not None and \"factor\" in self.hparams[\"rope_scaling\"]:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"yarn\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.YARN)\n                self.gguf_writer.add_rope_scaling_factor(self.hparams[\"rope_scaling\"][\"factor\"])\n                self.gguf_writer.add_rope_scaling_orig_ctx_len(self.hparams[\"rope_scaling\"][\"original_max_position_embeddings\"])\n\n\n@Model.register(\"Qwen2VLForConditionalGeneration\")\nclass Qwen2VLModel(Model):\n    model_arch = gguf.MODEL_ARCH.QWEN2VL\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        mrope_section = self.hparams[\"rope_scaling\"][\"mrope_section\"]\n        mrope_section += [0] * max(0, 4 - len(mrope_section))\n        self.gguf_writer.add_rope_dimension_sections(mrope_section)\n\n    def set_vocab(self):\n        try:\n            self._set_vocab_sentencepiece()\n        except FileNotFoundError:\n            self._set_vocab_gpt2()\n\n    def get_tensors(self) -> Iterator[tuple[str, Tensor]]:\n        for name, data in super().get_tensors():\n            if name.startswith(\"visual.\"):\n                continue\n            yield name, data\n\n\n@Model.register(\"WavTokenizerDec\")\nclass WavTokenizerDecModel(Model):\n    model_arch = gguf.MODEL_ARCH.WAVTOKENIZER_DEC\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        if \\\n                name.endswith(\"codebook.cluster_size\") or \\\n                name.endswith(\"codebook.embed_avg\") or \\\n                name.endswith(\"codebook.inited\"):\n            logger.debug(f\"Skipping {name!r}\")\n            return []\n\n        logger.info(f\"{self.map_tensor_name(name)} -> {data_torch.shape}\")\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def set_vocab(self):\n        self._set_vocab_none()\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_vocab_size         (self.hparams[\"vocab_size\"])\n        self.gguf_writer.add_features_length    (self.hparams[\"n_embd_features\"])\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"n_ff\"])\n        self.gguf_writer.add_group_norm_eps     (self.hparams[\"group_norm_epsilon\"])\n        self.gguf_writer.add_group_norm_groups  (self.hparams[\"group_norm_groups\"])\n\n        self.gguf_writer.add_posnet_embedding_length(self.hparams[\"posnet\"][\"n_embd\"])\n        self.gguf_writer.add_posnet_block_count     (self.hparams[\"posnet\"][\"n_layer\"])\n\n        self.gguf_writer.add_convnext_embedding_length(self.hparams[\"convnext\"][\"n_embd\"])\n        self.gguf_writer.add_convnext_block_count     (self.hparams[\"convnext\"][\"n_layer\"])\n\n        self.gguf_writer.add_causal_attention(False)\n\n\n@Model.register(\"Qwen2MoeForCausalLM\")\nclass Qwen2MoeModel(Model):\n    model_arch = gguf.MODEL_ARCH.QWEN2MOE\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        if (n_experts := self.hparams.get(\"num_experts\")) is not None:\n            self.gguf_writer.add_expert_count(n_experts)\n        if (moe_intermediate_size := self.hparams.get(\"moe_intermediate_size\")) is not None:\n            self.gguf_writer.add_expert_feed_forward_length(moe_intermediate_size)\n            logger.info(f\"gguf: expert feed forward length = {moe_intermediate_size}\")\n        if (shared_expert_intermediate_size := self.hparams.get('shared_expert_intermediate_size')) is not None:\n            self.gguf_writer.add_expert_shared_feed_forward_length(shared_expert_intermediate_size)\n            logger.info(f\"gguf: expert shared feed forward length = {shared_expert_intermediate_size}\")\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # process the experts separately\n        if name.find(\"experts\") != -1:\n            n_experts = self.hparams[\"num_experts\"]\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for w_name in [\"down_proj\", \"gate_proj\", \"up_proj\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"model.layers.{bid}.mlp.experts.{xid}.{w_name}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"model.layers.{bid}.mlp.experts.{w_name}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._experts is not None:\n            # flatten `list[dict[str, Tensor]]` into `list[str]`\n            experts = [k for d in self._experts for k in d.keys()]\n            if len(experts) > 0:\n                raise ValueError(f\"Unprocessed experts: {experts}\")\n\n\n@Model.register(\"GPT2LMHeadModel\")\nclass GPT2Model(Model):\n    model_arch = gguf.MODEL_ARCH.GPT2\n\n    def set_gguf_parameters(self):\n        self.gguf_writer.add_block_count(self.hparams[\"n_layer\"])\n        self.gguf_writer.add_context_length(self.hparams[\"n_ctx\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"n_embd\"])\n        self.gguf_writer.add_feed_forward_length(4 * self.hparams[\"n_embd\"])\n        self.gguf_writer.add_head_count(self.hparams[\"n_head\"])\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        tensors: list[tuple[str, Tensor]] = []\n\n        # we don't need these\n        if name.endswith((\".attn.bias\", \".attn.masked_bias\")):\n            return tensors\n\n        if name.endswith((\".c_attn.weight\", \".c_proj.weight\", \".c_fc.weight\", \".c_proj.weight\")):\n            data_torch = data_torch.transpose(1, 0)\n\n        new_name = self.map_tensor_name(name)\n\n        tensors.append((new_name, data_torch))\n\n        # note: GPT2 output is tied to (same as) wte in original model\n        if new_name == self.format_tensor_name(gguf.MODEL_TENSOR.TOKEN_EMBD):\n            tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.OUTPUT), data_torch))\n\n        return tensors\n\n\n@Model.register(\"PhiForCausalLM\")\nclass Phi2Model(Model):\n    model_arch = gguf.MODEL_ARCH.PHI2\n\n    def set_gguf_parameters(self):\n        block_count = self.find_hparam([\"num_hidden_layers\", \"n_layer\"])\n\n        rot_pct = self.find_hparam([\"partial_rotary_factor\"])\n        n_embd = self.find_hparam([\"hidden_size\", \"n_embd\"])\n        n_head = self.find_hparam([\"num_attention_heads\", \"n_head\"])\n\n        self.gguf_writer.add_context_length(self.find_hparam([\"n_positions\", \"max_position_embeddings\"]))\n\n        self.gguf_writer.add_embedding_length(n_embd)\n        self.gguf_writer.add_feed_forward_length(4 * n_embd)\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_head_count(n_head)\n        self.gguf_writer.add_head_count_kv(n_head)\n        self.gguf_writer.add_layer_norm_eps(self.find_hparam([\"layer_norm_epsilon\", \"layer_norm_eps\"]))\n        self.gguf_writer.add_rope_dimension_count(int(rot_pct * n_embd) // n_head)\n        self.gguf_writer.add_file_type(self.ftype)\n        self.gguf_writer.add_add_bos_token(False)\n\n\n@Model.register(\"Phi3ForCausalLM\")\nclass Phi3MiniModel(Model):\n    model_arch = gguf.MODEL_ARCH.PHI3\n\n    def set_vocab(self):\n        # Phi-4 model uses GPT2Tokenizer\n        tokenizer_config_file = self.dir_model / 'tokenizer_config.json'\n        if tokenizer_config_file.is_file():\n            with open(tokenizer_config_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_config_json = json.load(f)\n                tokenizer_class = tokenizer_config_json['tokenizer_class']\n                if tokenizer_class == 'GPT2Tokenizer':\n                    return self._set_vocab_gpt2()\n\n        from sentencepiece import SentencePieceProcessor\n\n        tokenizer_path = self.dir_model / 'tokenizer.model'\n\n        if not tokenizer_path.is_file():\n            raise ValueError(f'Error: Missing {tokenizer_path}')\n\n        tokenizer = SentencePieceProcessor()\n        tokenizer.LoadFromFile(str(tokenizer_path))\n\n        vocab_size = self.hparams.get('vocab_size', tokenizer.vocab_size())\n\n        tokens: list[bytes] = [f\"[PAD{i}]\".encode(\"utf-8\") for i in range(vocab_size)]\n        scores: list[float] = [-10000.0] * vocab_size\n        toktypes: list[int] = [SentencePieceTokenTypes.UNUSED] * vocab_size\n\n        for token_id in range(tokenizer.vocab_size()):\n\n            piece = tokenizer.IdToPiece(token_id)\n            text = piece.encode(\"utf-8\")\n            score = tokenizer.GetScore(token_id)\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.IsUnknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.IsControl(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.IsUnused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.IsByte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n\n            tokens[token_id] = text\n            scores[token_id] = score\n            toktypes[token_id] = toktype\n\n        added_tokens_file = self.dir_model / 'added_tokens.json'\n        if added_tokens_file.is_file():\n            with open(added_tokens_file, \"r\", encoding=\"utf-8\") as f:\n                added_tokens_json = json.load(f)\n\n                for key in added_tokens_json:\n                    token_id = added_tokens_json[key]\n                    if token_id >= vocab_size:\n                        logger.debug(f'ignore token {token_id}: id is out of range, max={vocab_size - 1}')\n                        continue\n\n                    tokens[token_id] = key.encode(\"utf-8\")\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n\n        tokenizer_config_file = self.dir_model / 'tokenizer_config.json'\n        if tokenizer_config_file.is_file():\n            with open(tokenizer_config_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_config_json = json.load(f)\n                added_tokens_decoder = tokenizer_config_json.get(\"added_tokens_decoder\", {})\n                for token_id, foken_data in added_tokens_decoder.items():\n                    token_id = int(token_id)\n                    token = foken_data[\"content\"].encode(\"utf-8\")\n                    if toktypes[token_id] != SentencePieceTokenTypes.UNUSED:\n                        if tokens[token_id] != token:\n                            logger.warning(f'replacing token {token_id}: {tokens[token_id].decode(\"utf-8\")!r} -> {token.decode(\"utf-8\")!r}')\n                    tokens[token_id] = token\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n                    if foken_data.get(\"special\"):\n                        toktypes[token_id] = SentencePieceTokenTypes.CONTROL\n\n        tokenizer_file = self.dir_model / 'tokenizer.json'\n        if tokenizer_file.is_file():\n            with open(tokenizer_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_json = json.load(f)\n                added_tokens = tokenizer_json.get(\"added_tokens\", [])\n                for foken_data in added_tokens:\n                    token_id = int(foken_data[\"id\"])\n                    token = foken_data[\"content\"].encode(\"utf-8\")\n                    if toktypes[token_id] != SentencePieceTokenTypes.UNUSED:\n                        if tokens[token_id] != token:\n                            logger.warning(f'replacing token {token_id}: {tokens[token_id].decode(\"utf-8\")!r} -> {token.decode(\"utf-8\")!r}')\n                    tokens[token_id] = token\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n                    if foken_data.get(\"special\"):\n                        toktypes[token_id] = SentencePieceTokenTypes.CONTROL\n\n        self.gguf_writer.add_tokenizer_model(\"llama\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def set_gguf_parameters(self):\n        block_count = self.find_hparam([\"num_hidden_layers\", \"n_layer\"])\n\n        n_embd = self.find_hparam([\"hidden_size\", \"n_embd\"])\n        n_head = self.find_hparam([\"num_attention_heads\", \"n_head\"])\n        n_head_kv = self.find_hparam([\"num_key_value_heads\", \"n_head_kv\"])\n        rms_eps = self.find_hparam([\"rms_norm_eps\"])\n        max_pos_embds = self.find_hparam([\"n_positions\", \"max_position_embeddings\"])\n        orig_max_pos_embds = self.find_hparam([\"original_max_position_embeddings\"])\n        rope_dims = n_embd // n_head\n\n        self.gguf_writer.add_context_length(max_pos_embds)\n        self.gguf_writer.add_rope_scaling_orig_ctx_len(orig_max_pos_embds)\n        self.gguf_writer.add_embedding_length(n_embd)\n        self.gguf_writer.add_feed_forward_length(self.find_hparam([\"intermediate_size\"]))\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_head_count(n_head)\n        self.gguf_writer.add_head_count_kv(n_head_kv)\n        self.gguf_writer.add_layer_norm_rms_eps(rms_eps)\n        self.gguf_writer.add_rope_dimension_count(rope_dims)\n        self.gguf_writer.add_rope_freq_base(self.find_hparam([\"rope_theta\"]))\n        self.gguf_writer.add_file_type(self.ftype)\n        sliding_window = self.hparams.get(\"sliding_window\")\n        # use zero value of sliding_window to distinguish Phi-4 from other PHI3 models\n        if sliding_window is None:\n            sliding_window = 0\n        self.gguf_writer.add_sliding_window(sliding_window)\n\n    def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n        n_embd = self.find_hparam([\"hidden_size\", \"n_embd\"])\n        n_head = self.find_hparam([\"num_attention_heads\", \"n_head\"])\n        max_pos_embds = self.find_hparam([\"n_positions\", \"max_position_embeddings\"])\n        orig_max_pos_embds = self.find_hparam([\"original_max_position_embeddings\"])\n        rope_dims = n_embd // n_head\n\n        # write rope scaling for long context (128k) model\n        rope_scaling = self.find_hparam(['rope_scaling'], True)\n        if rope_scaling is None:\n            return\n\n        scale = max_pos_embds / orig_max_pos_embds\n\n        rope_scaling_type = rope_scaling.get('type', '').lower()\n        if len(rope_scaling_type) == 0:\n            raise KeyError('Missing the required key rope_scaling.type')\n\n        if rope_scaling_type == 'su' or rope_scaling_type == 'longrope':\n            attn_factor = math.sqrt(1 + math.log(scale) / math.log(orig_max_pos_embds)) if scale > 1.0 else 1.0\n        elif rope_scaling_type == 'yarn':\n            attn_factor = 0.1 * math.log(scale) + 1.0 if scale > 1.0 else 1.0\n        else:\n            raise NotImplementedError(f'The rope scaling type {rope_scaling_type} is not supported yet')\n\n        self.gguf_writer.add_rope_scaling_attn_factors(attn_factor)\n\n        long_factors = rope_scaling.get('long_factor', None)\n        short_factors = rope_scaling.get('short_factor', None)\n\n        if long_factors is None or short_factors is None:\n            raise KeyError('Missing the required key rope_scaling.long_factor or rope_scaling_short_factor')\n\n        if len(long_factors) != len(short_factors) or len(long_factors) != rope_dims / 2:\n            raise ValueError(f'The length of rope long and short factors must be {rope_dims / 2}')\n\n        yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FACTORS_LONG), torch.tensor(long_factors, dtype=torch.float32))\n        yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FACTORS_SHORT), torch.tensor(short_factors, dtype=torch.float32))\n\n\n@Model.register(\"PhiMoEForCausalLM\")\nclass PhiMoeModel(Phi3MiniModel):\n    model_arch = gguf.MODEL_ARCH.PHIMOE\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_expert_used_count(self.hparams[\"num_experts_per_tok\"])\n        self.gguf_writer.add_expert_count(self.hparams[\"num_local_experts\"])\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # process the experts separately\n        if name.find(\"block_sparse_moe.experts\") != -1:\n            n_experts = self.hparams[\"num_local_experts\"]\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for w_name in [\"w1\", \"w2\", \"w3\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"model.layers.{bid}.block_sparse_moe.experts.{xid}.{w_name}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"model.layers.{bid}.block_sparse_moe.experts.{w_name}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._experts is not None:\n            # flatten `list[dict[str, Tensor]]` into `list[str]`\n            experts = [k for d in self._experts for k in d.keys()]\n            if len(experts) > 0:\n                raise ValueError(f\"Unprocessed experts: {experts}\")\n\n\n@Model.register(\"PlamoForCausalLM\")\nclass PlamoModel(Model):\n    model_arch = gguf.MODEL_ARCH.PLAMO\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n    def set_gguf_parameters(self):\n        hparams = self.hparams\n        block_count = hparams[\"num_hidden_layers\"]\n\n        self.gguf_writer.add_context_length(4096)  # not in config.json\n        self.gguf_writer.add_embedding_length(hparams[\"hidden_size\"])\n        self.gguf_writer.add_feed_forward_length(hparams[\"intermediate_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_head_count(hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count_kv(5)  # hparams[\"num_key_value_heads\"]) is wrong\n        self.gguf_writer.add_layer_norm_rms_eps(hparams[\"rms_norm_eps\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def shuffle_attn_q_weight(self, data_torch):\n        assert data_torch.size() == (5120, 5120)\n        data_torch = data_torch.reshape(8, 5, 128, 5120)\n        data_torch = torch.permute(data_torch, (1, 0, 2, 3))\n        data_torch = torch.reshape(data_torch, (5120, 5120))\n        return data_torch\n\n    def shuffle_attn_output_weight(self, data_torch):\n        assert data_torch.size() == (5120, 5120)\n        data_torch = data_torch.reshape(5120, 8, 5, 128)\n        data_torch = torch.permute(data_torch, (0, 2, 1, 3))\n        data_torch = torch.reshape(data_torch, (5120, 5120))\n        return data_torch\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        new_name = self.map_tensor_name(name)\n\n        # shuffle for broadcasting of gqa in ggml_mul_mat\n        if new_name.endswith(\"attn_q.weight\"):\n            data_torch = self.shuffle_attn_q_weight(data_torch)\n        elif new_name.endswith(\"attn_output.weight\"):\n            data_torch = self.shuffle_attn_output_weight(data_torch)\n\n        return [(new_name, data_torch)]\n\n\n@Model.register(\"CodeShellForCausalLM\")\nclass CodeShellModel(Model):\n    model_arch = gguf.MODEL_ARCH.CODESHELL\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"n_layer\"]\n\n        self.gguf_writer.add_context_length(self.hparams[\"n_positions\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"n_embd\"])\n        self.gguf_writer.add_feed_forward_length(4 * self.hparams[\"n_embd\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_head_count(self.hparams[\"n_head\"])\n        self.gguf_writer.add_head_count_kv(self.hparams[\"num_query_groups\"])\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n        self.gguf_writer.add_rope_freq_base(10000.0)\n        self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n        self.gguf_writer.add_rope_scaling_factor(1.0)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        new_name = self.map_tensor_name(name)\n\n        tensors: list[tuple[str, Tensor]] = [(new_name, data_torch)]\n\n        if new_name == self.format_tensor_name(gguf.MODEL_TENSOR.TOKEN_EMBD):\n            assert self.tensor_names is not None\n\n            if all(s not in self.tensor_names for s in (\"lm_head.weight\", \"output.weight\")):\n                # copy tok_embd.weight to output.weight\n                tensors.append((self.format_tensor_name(gguf.MODEL_TENSOR.OUTPUT), data_torch))\n\n        return tensors\n\n\n@Model.register(\"InternLM2ForCausalLM\")\nclass InternLM2Model(Model):\n    model_arch = gguf.MODEL_ARCH.INTERNLM2\n\n    def set_vocab(self):\n        # (TODO): Is there a better way?\n        # Copy from _set_vocab_sentencepiece, The only difference is that we will treat the character\n        # \\x00 specially and convert it into an emoji character to prevent it from being mistakenly\n        # recognized as an empty string in C++.\n        from sentencepiece import SentencePieceProcessor\n        from sentencepiece import sentencepiece_model_pb2 as model\n\n        tokenizer_path = self.dir_model / 'tokenizer.model'\n\n        tokens: list[bytes] = []\n        scores: list[float] = []\n        toktypes: list[int] = []\n\n        if not tokenizer_path.is_file():\n            logger.error(f'Error: Missing {tokenizer_path}')\n            sys.exit(1)\n\n        sentencepiece_model = model.ModelProto()  # pyright: ignore[reportAttributeAccessIssue]\n        sentencepiece_model.ParseFromString(open(tokenizer_path, \"rb\").read())\n        add_prefix = sentencepiece_model.normalizer_spec.add_dummy_prefix\n\n        tokenizer = SentencePieceProcessor()\n        tokenizer.LoadFromFile(str(tokenizer_path))\n\n        vocab_size = self.hparams.get('vocab_size', tokenizer.vocab_size())\n\n        for token_id in range(vocab_size):\n            piece = tokenizer.IdToPiece(token_id)\n            text = piece.encode(\"utf-8\")\n            score = tokenizer.GetScore(token_id)\n            if text == b\"\\x00\":\n                # (TODO): fixme\n                # Hack here and replace the \\x00 characters.\n                logger.warning(f\"InternLM2 convert token '{text}' to '🐉'!\")\n                text = \"🐉\".encode(\"utf-8\")\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.IsUnknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.IsControl(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.IsUnused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.IsByte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n            # take care of ununsed raw token\n            if piece.startswith('[UNUSED'):\n                toktype = SentencePieceTokenTypes.UNUSED\n\n            tokens.append(text)\n            scores.append(score)\n            toktypes.append(toktype)\n\n        added_tokens_file = self.dir_model / 'added_tokens.json'\n        if added_tokens_file.is_file():\n            with open(added_tokens_file, \"r\", encoding=\"utf-8\") as f:\n                added_tokens_json = json.load(f)\n\n                for key in added_tokens_json:\n                    tokens.append(key.encode(\"utf-8\"))\n                    scores.append(-1000.0)\n                    toktypes.append(SentencePieceTokenTypes.USER_DEFINED)\n\n        chat_eos_token = '<|im_end|>'\n        chat_eos_token_id = None\n\n        tokenizer_config_file = self.dir_model / 'tokenizer_config.json'\n        if tokenizer_config_file.is_file():\n            with open(tokenizer_config_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_config_json = json.load(f)\n                added_tokens_decoder = tokenizer_config_json.get(\"added_tokens_decoder\", {})\n                for token_id, foken_data in added_tokens_decoder.items():\n                    token_id = int(token_id)\n                    token = foken_data[\"content\"]\n                    if token == chat_eos_token:\n                        chat_eos_token_id = token_id\n                    token = token.encode(\"utf-8\")\n                    if toktypes[token_id] != SentencePieceTokenTypes.UNUSED:\n                        if tokens[token_id] != token:\n                            logger.warning(f'replacing token {token_id}: {tokens[token_id].decode(\"utf-8\")!r} -> {token.decode(\"utf-8\")!r}')\n                    tokens[token_id] = token\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n                    if foken_data.get(\"special\"):\n                        toktypes[token_id] = SentencePieceTokenTypes.CONTROL\n\n        tokenizer_file = self.dir_model / 'tokenizer.json'\n        if tokenizer_file.is_file():\n            with open(tokenizer_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_json = json.load(f)\n                added_tokens = tokenizer_json.get(\"added_tokens\", [])\n                for foken_data in added_tokens:\n                    token_id = int(foken_data[\"id\"])\n                    token = foken_data[\"content\"]\n                    if token == chat_eos_token:\n                        chat_eos_token_id = token_id\n                    token = token.encode(\"utf-8\")\n                    if toktypes[token_id] != SentencePieceTokenTypes.UNUSED:\n                        if tokens[token_id] != token:\n                            logger.warning(f'replacing token {token_id}: {tokens[token_id].decode(\"utf-8\")!r} -> {token.decode(\"utf-8\")!r}')\n                    tokens[token_id] = token\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n                    if foken_data.get(\"special\"):\n                        toktypes[token_id] = SentencePieceTokenTypes.CONTROL\n\n        self.gguf_writer.add_tokenizer_model(\"llama\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n        self.gguf_writer.add_add_space_prefix(add_prefix)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        old_eos = special_vocab.special_token_ids[\"eos\"]\n        if chat_eos_token_id is not None:\n            # For the chat model, we replace the eos with '<|im_end|>'.\n            # TODO: this is a hack, should be fixed\n            #       https://github.com/ggerganov/llama.cpp/pull/6745#issuecomment-2067687048\n            special_vocab.special_token_ids[\"eos\"] = chat_eos_token_id\n            logger.warning(f\"Replace eos:{old_eos} with a special token:{chat_eos_token_id}\"\n                           \" in chat mode so that the conversation can end normally.\")\n\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def set_gguf_parameters(self):\n        self.gguf_writer.add_context_length(self.hparams[\"max_position_embeddings\"])\n        self.gguf_writer.add_block_count(self.hparams[\"num_hidden_layers\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"hidden_size\"])\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"intermediate_size\"])\n        self.gguf_writer.add_rope_freq_base(self.hparams[\"rope_theta\"])\n        self.gguf_writer.add_head_count(self.hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"rms_norm_eps\"])\n        self.gguf_writer.add_head_count_kv(self.hparams[\"num_key_value_heads\"])\n        self.gguf_writer.add_file_type(self.ftype)\n        if self.hparams.get(\"rope_scaling\") is not None and \"factor\" in self.hparams[\"rope_scaling\"]:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"linear\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n                self.gguf_writer.add_rope_scaling_factor(self.hparams[\"rope_scaling\"][\"factor\"])\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        num_heads = self.hparams[\"num_attention_heads\"]\n        num_kv_heads = self.hparams[\"num_key_value_heads\"]\n        n_embd = self.hparams[\"hidden_size\"]\n        q_per_kv = num_heads // num_kv_heads\n        head_dim = n_embd // num_heads\n        num_groups = num_heads // q_per_kv\n\n        if bid is not None and f\"model.layers.{bid}.attention.wqkv\" in name:\n            qkv = data_torch\n\n            qkv = qkv.reshape((num_groups, q_per_kv + 2, head_dim, n_embd))\n            q, k, v = qkv[:, : q_per_kv], qkv[:, -2], qkv[:, -1]\n\n            # The model weights of q and k equire additional reshape.\n            q = LlamaModel.permute(q.reshape((-1, q.shape[-1])), num_heads, num_heads)\n            k = LlamaModel.permute(k.reshape((-1, k.shape[-1])), num_heads, num_kv_heads)\n            v = v.reshape((-1, v.shape[-1]))\n\n            return [\n                (self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_Q, bid), q),\n                (self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_K, bid), k),\n                (self.format_tensor_name(gguf.MODEL_TENSOR.ATTN_V, bid), v),\n            ]\n        else:\n            return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"BertModel\", \"BertForMaskedLM\", \"CamembertModel\")\nclass BertModel(Model):\n    model_arch = gguf.MODEL_ARCH.BERT\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.vocab_size = None\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_causal_attention(False)\n\n        # get pooling path\n        pooling_path = None\n        module_path = self.dir_model / \"modules.json\"\n        if module_path.is_file():\n            with open(module_path, encoding=\"utf-8\") as f:\n                modules = json.load(f)\n            for mod in modules:\n                if mod[\"type\"] == \"sentence_transformers.models.Pooling\":\n                    pooling_path = mod[\"path\"]\n                    break\n\n        # get pooling type\n        if pooling_path is not None:\n            with open(self.dir_model / pooling_path / \"config.json\", encoding=\"utf-8\") as f:\n                pooling = json.load(f)\n            if pooling[\"pooling_mode_mean_tokens\"]:\n                pooling_type = gguf.PoolingType.MEAN\n            elif pooling[\"pooling_mode_cls_token\"]:\n                pooling_type = gguf.PoolingType.CLS\n            else:\n                raise NotImplementedError(\"Only MEAN and CLS pooling types supported\")\n            self.gguf_writer.add_pooling_type(pooling_type)\n\n    def set_vocab(self):\n        tokens, toktypes, tokpre = self.get_vocab_base()\n        self.vocab_size = len(tokens)\n\n        # we need this to validate the size of the token_type embeddings\n        # though currently we are passing all zeros to the token_type embeddings\n        # \"Sequence A\" or \"Sequence B\"\n        self.gguf_writer.add_token_type_count(self.hparams.get(\"type_vocab_size\", 1))\n\n        # convert to phantom space vocab\n        def phantom(tok):\n            if tok.startswith(\"[\") and tok.endswith(\"]\"):\n                return tok\n            if tok.startswith(\"##\"):\n                return tok[2:]\n            return \"\\u2581\" + tok\n        tokens = list(map(phantom, tokens))\n\n        # add vocab to gguf\n        self.gguf_writer.add_tokenizer_model(\"bert\")\n        self.gguf_writer.add_tokenizer_pre(tokpre)\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_types(toktypes)\n\n        # handle special tokens\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        if name.startswith(\"bert.\"):\n            name = name[5:]\n\n        if name.endswith(\".gamma\"):\n            name = name[:-6] + \".weight\"\n\n        if name.endswith(\".beta\"):\n            name = name[:-5] + \".bias\"\n\n        # we are only using BERT for embeddings so we don't need the pooling layer\n        if name in (\"embeddings.position_ids\", \"pooler.dense.weight\", \"pooler.dense.bias\"):\n            return [] # we don't need these\n\n        if name.startswith(\"cls.predictions\"):\n            return []\n\n        if name.startswith(\"cls.seq_relationship\"):\n            return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"RobertaModel\")\nclass RobertaModel(BertModel):\n    model_arch = gguf.MODEL_ARCH.BERT\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # we need the pad_token_id to know how to chop down position_embd matrix\n        if (pad_token_id := self.hparams.get(\"pad_token_id\")) is not None:\n            self._position_offset = 1 + pad_token_id\n            if \"max_position_embeddings\" in self.hparams:\n                self.hparams[\"max_position_embeddings\"] -= self._position_offset\n        else:\n            self._position_offset = None\n\n    def set_vocab(self):\n        \"\"\"Support BPE tokenizers for roberta models\"\"\"\n        bpe_tok_path = self.dir_model / \"tokenizer.json\"\n        if bpe_tok_path.exists():\n            self._set_vocab_gpt2()\n            self.gguf_writer.add_add_bos_token(True)\n            self.gguf_writer.add_add_eos_token(True)\n\n            # we need this to validate the size of the token_type embeddings\n            # though currently we are passing all zeros to the token_type embeddings\n            # \"Sequence A\" or \"Sequence B\"\n            self.gguf_writer.add_token_type_count(self.hparams.get(\"type_vocab_size\", 1))\n\n        else:\n            return super().set_vocab()\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # if name starts with \"roberta.\", remove the prefix\n        # e.g. https://huggingface.co/BAAI/bge-reranker-v2-m3/tree/main\n        if name.startswith(\"roberta.\"):\n            name = name[8:]\n\n        # position embeddings start at pad_token_id + 1, so just chop down the weight tensor\n        if name == \"embeddings.position_embeddings.weight\":\n            if self._position_offset is not None:\n                data_torch = data_torch[self._position_offset:,:]\n\n        return super().modify_tensors(data_torch, name, bid)\n\n\n@Model.register(\"NomicBertModel\")\nclass NomicBertModel(BertModel):\n    model_arch = gguf.MODEL_ARCH.NOMIC_BERT\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # the HF config claims n_ctx=8192, but it uses RoPE scaling\n        self.hparams[\"n_ctx\"] = 2048\n\n        # SwigLU activation\n        assert self.hparams[\"activation_function\"] == \"swiglu\"\n        # this doesn't do anything in the HF version\n        assert self.hparams[\"causal\"] is False\n        # no bias tensors\n        assert self.hparams[\"qkv_proj_bias\"] is False\n        assert self.hparams[\"mlp_fc1_bias\"] is False\n        assert self.hparams[\"mlp_fc2_bias\"] is False\n        # norm at end of layer\n        assert self.hparams[\"prenorm\"] is False\n        # standard RoPE\n        assert self.hparams[\"rotary_emb_fraction\"] == 1.0\n        assert self.hparams[\"rotary_emb_interleaved\"] is False\n        assert self.hparams[\"rotary_emb_scale_base\"] is None\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_rope_freq_base(self.hparams[\"rotary_emb_base\"])\n\n\n@Model.register(\"XLMRobertaModel\", \"XLMRobertaForSequenceClassification\")\nclass XLMRobertaModel(BertModel):\n    model_arch = gguf.MODEL_ARCH.BERT\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # we need the pad_token_id to know how to chop down position_embd matrix\n        if (pad_token_id := self.hparams.get(\"pad_token_id\")) is not None:\n            self._position_offset = 1 + pad_token_id\n            if \"max_position_embeddings\" in self.hparams:\n                self.hparams[\"max_position_embeddings\"] -= self._position_offset\n        else:\n            self._position_offset = None\n\n    def set_vocab(self):\n        # to avoid TypeError: Descriptors cannot be created directly\n        # exception when importing sentencepiece_model_pb2\n        os.environ[\"PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION\"] = \"python\"\n        from sentencepiece import SentencePieceProcessor\n        from sentencepiece import sentencepiece_model_pb2 as model\n\n        tokenizer_path = self.dir_model / 'sentencepiece.bpe.model'\n        if not tokenizer_path.is_file():\n            raise FileNotFoundError(f\"File not found: {tokenizer_path}\")\n\n        sentencepiece_model = model.ModelProto()  # pyright: ignore[reportAttributeAccessIssue]\n        sentencepiece_model.ParseFromString(open(tokenizer_path, \"rb\").read())\n        assert sentencepiece_model.trainer_spec.model_type == 1  # UNIGRAM\n\n        add_prefix = sentencepiece_model.normalizer_spec.add_dummy_prefix\n        remove_whitespaces = sentencepiece_model.normalizer_spec.remove_extra_whitespaces\n        precompiled_charsmap = sentencepiece_model.normalizer_spec.precompiled_charsmap\n\n        tokenizer = SentencePieceProcessor()\n        tokenizer.LoadFromFile(str(tokenizer_path))\n\n        vocab_size = self.hparams.get('vocab_size', tokenizer.vocab_size())\n\n        tokens: list[bytes] = [f\"[PAD{i}]\".encode(\"utf-8\") for i in range(vocab_size)]\n        scores: list[float] = [-10000.0] * vocab_size\n        toktypes: list[int] = [SentencePieceTokenTypes.UNUSED] * vocab_size\n\n        for token_id in range(tokenizer.vocab_size()):\n            piece = tokenizer.IdToPiece(token_id)\n            text = piece.encode(\"utf-8\")\n            score = tokenizer.GetScore(token_id)\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.IsUnknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.IsControl(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.IsUnused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.IsByte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n\n            tokens[token_id] = text\n            scores[token_id] = score\n            toktypes[token_id] = toktype\n\n        if vocab_size > len(tokens):\n            pad_count = vocab_size - len(tokens)\n            logger.debug(f\"Padding vocab with {pad_count} token(s) - [PAD1] through [PAD{pad_count}]\")\n            for i in range(1, pad_count + 1):\n                tokens.append(bytes(f\"[PAD{i}]\", encoding=\"utf-8\"))\n                scores.append(-1000.0)\n                toktypes.append(SentencePieceTokenTypes.UNUSED)\n\n        # realign tokens (see HF tokenizer code)\n        tokens = [b'<s>', b'<pad>', b'</s>', b'<unk>'] + tokens[3:-1]\n        scores = [0.0, 0.0, 0.0, 0.0] + scores[3:-1]\n        toktypes = [\n            SentencePieceTokenTypes.CONTROL,\n            SentencePieceTokenTypes.CONTROL,\n            SentencePieceTokenTypes.CONTROL,\n            SentencePieceTokenTypes.UNKNOWN,\n        ] + toktypes[3:-1]\n\n        self.gguf_writer.add_tokenizer_model(\"t5\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n        self.gguf_writer.add_add_space_prefix(add_prefix)\n        self.gguf_writer.add_token_type_count(self.hparams.get(\"type_vocab_size\", 1))\n        self.gguf_writer.add_remove_extra_whitespaces(remove_whitespaces)\n        if precompiled_charsmap:\n            self.gguf_writer.add_precompiled_charsmap(precompiled_charsmap)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n        self.gguf_writer.add_add_bos_token(True)\n        self.gguf_writer.add_add_eos_token(True)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # if name starts with \"roberta.\", remove the prefix\n        # e.g. https://huggingface.co/BAAI/bge-reranker-v2-m3/tree/main\n        if name.startswith(\"roberta.\"):\n            name = name[8:]\n\n        # position embeddings start at pad_token_id + 1, so just chop down the weight tensor\n        if name == \"embeddings.position_embeddings.weight\":\n            if self._position_offset is not None:\n                data_torch = data_torch[self._position_offset:,:]\n\n        return super().modify_tensors(data_torch, name, bid)\n\n\n@Model.register(\"GemmaForCausalLM\")\nclass GemmaModel(Model):\n    model_arch = gguf.MODEL_ARCH.GEMMA\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n        # TODO: these special tokens should be exported only for the CodeGemma family\n        special_vocab = gguf.SpecialVocab(self.dir_model, load_merges=False,\n                                          special_token_types = ['prefix', 'suffix', 'middle', 'fsep', 'eot'])\n        special_vocab._set_special_token(\"prefix\", 67)\n        special_vocab._set_special_token(\"suffix\", 69)\n        special_vocab._set_special_token(\"middle\", 68)\n        special_vocab._set_special_token(\"fsep\",   70)\n        special_vocab._set_special_token(\"eot\",    107)\n        special_vocab.chat_template = None  # do not add it twice\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n        self.gguf_writer.add_add_space_prefix(False)\n\n    def set_gguf_parameters(self):\n        hparams = self.hparams\n        block_count = hparams[\"num_hidden_layers\"]\n\n        self.gguf_writer.add_context_length(hparams[\"max_position_embeddings\"])\n        self.gguf_writer.add_embedding_length(hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(hparams[\"intermediate_size\"])\n        self.gguf_writer.add_head_count(hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count_kv(self.hparams[\"num_key_value_heads\"] if \"num_key_value_heads\" in hparams else hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"rms_norm_eps\"])\n        self.gguf_writer.add_key_length(hparams[\"head_dim\"])\n        self.gguf_writer.add_value_length(hparams[\"head_dim\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        # lm_head is not used in llama.cpp, while autoawq will include this tensor in model\n        # To prevent errors, skip loading lm_head.weight.\n        if name == \"lm_head.weight\":\n            logger.debug(f\"Skipping get tensor {name!r} in safetensors so that convert can end normally.\")\n            return []\n\n        # ref: https://github.com/huggingface/transformers/blob/fc37f38915372c15992b540dfcbbe00a916d4fc6/src/transformers/models/gemma/modeling_gemma.py#L89\n        if name.endswith(\"norm.weight\"):\n            data_torch = data_torch + 1\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"Gemma2ForCausalLM\")\nclass Gemma2Model(Model):\n    model_arch = gguf.MODEL_ARCH.GEMMA2\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n\n        self.gguf_writer.add_add_space_prefix(False)\n\n    def set_gguf_parameters(self):\n        hparams = self.hparams\n        block_count = hparams[\"num_hidden_layers\"]\n\n        self.gguf_writer.add_context_length(hparams[\"max_position_embeddings\"])\n        self.gguf_writer.add_embedding_length(hparams[\"hidden_size\"])\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_feed_forward_length(hparams[\"intermediate_size\"])\n        self.gguf_writer.add_head_count(hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_head_count_kv(self.hparams[\"num_key_value_heads\"] if \"num_key_value_heads\" in hparams else hparams[\"num_attention_heads\"])\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"rms_norm_eps\"])\n        self.gguf_writer.add_key_length(hparams[\"head_dim\"])\n        self.gguf_writer.add_value_length(hparams[\"head_dim\"])\n        self.gguf_writer.add_file_type(self.ftype)\n        self.gguf_writer.add_attn_logit_softcapping(\n            self.hparams[\"attn_logit_softcapping\"]\n        )\n        self.gguf_writer.add_final_logit_softcapping(\n            self.hparams[\"final_logit_softcapping\"]\n        )\n        self.gguf_writer.add_sliding_window(self.hparams[\"sliding_window\"])\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        # lm_head is not used in llama.cpp, while autoawq will include this tensor in model\n        # To prevent errors, skip loading lm_head.weight.\n        if name == \"lm_head.weight\":\n            logger.debug(f\"Skipping get tensor {name!r} in safetensors so that convert can end normally.\")\n            return []\n\n        # ref: https://github.com/huggingface/transformers/blob/fc37f38915372c15992b540dfcbbe00a916d4fc6/src/transformers/models/gemma/modeling_gemma.py#L89\n        if name.endswith(\"norm.weight\"):\n            data_torch = data_torch + 1\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"Starcoder2ForCausalLM\")\nclass StarCoder2Model(Model):\n    model_arch = gguf.MODEL_ARCH.STARCODER2\n\n\n@Model.register(\"Rwkv6ForCausalLM\")\nclass Rwkv6Model(Model):\n    model_arch = gguf.MODEL_ARCH.RWKV6\n\n    def set_vocab(self):\n        assert (self.dir_model / \"rwkv_vocab_v20230424.txt\").is_file()\n        vocab_size = self.hparams.get(\"vocab_size\", 65536)\n\n        tokens: list[bytes] = ['<s>'.encode(\"utf-8\")]\n        toktypes: list[int] = [gguf.TokenType.CONTROL]\n\n        with open(self.dir_model / \"rwkv_vocab_v20230424.txt\", \"r\", encoding=\"utf-8\") as f:\n            lines = f.readlines()\n            for line in lines:\n                parts = line.split(' ')\n                assert len(parts) >= 3\n                token, token_len = ast.literal_eval(' '.join(parts[1:-1])), int(parts[-1])\n                token = token.encode(\"utf-8\") if isinstance(token, str) else token\n                assert isinstance(token, bytes)\n                assert len(token) == token_len\n                token_text: str = repr(token)[2:-1]  # \"b'\\xff'\" -> \"\\xff\"\n                tokens.append(token_text.encode(\"utf-8\"))\n                toktypes.append(gguf.TokenType.NORMAL)\n        remainder = vocab_size - len(tokens)\n        assert remainder >= 0\n        for i in range(len(tokens), vocab_size):\n            tokens.append(f\"[PAD{i}]\".encode(\"utf-8\"))\n            toktypes.append(gguf.TokenType.UNUSED)\n\n        self.gguf_writer.add_tokenizer_model(\"rwkv\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_types(toktypes)\n        special_vocab = gguf.SpecialVocab(self.dir_model, load_merges=False)\n        special_vocab.chat_template = \"rwkv-world\"\n        # hack: Add '\\n\\n' as the EOT token to make it chat normally\n        special_vocab._set_special_token(\"eot\", 261)\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"num_hidden_layers\"]\n        head_size = self.hparams[\"head_size\"]\n        hidden_size = self.hparams[\"hidden_size\"]\n        layer_norm_eps = self.hparams[\"layer_norm_epsilon\"]\n        rescale_every_n_layers = self.hparams[\"rescale_every\"]\n        intermediate_size = self.hparams[\"intermediate_size\"] if self.hparams[\"intermediate_size\"] is not None else int((hidden_size * 3.5) // 32 * 32)\n        time_mix_extra_dim = 64 if hidden_size == 4096 else 32\n        time_decay_extra_dim = 128 if hidden_size == 4096 else 64\n\n        # RWKV isn't context limited\n        self.gguf_writer.add_context_length(1048576)\n        self.gguf_writer.add_embedding_length(hidden_size)\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_layer_norm_eps(layer_norm_eps)\n        self.gguf_writer.add_rescale_every_n_layers(rescale_every_n_layers)\n        self.gguf_writer.add_wkv_head_size(head_size)\n        self.gguf_writer.add_time_mix_extra_dim(time_mix_extra_dim)\n        self.gguf_writer.add_time_decay_extra_dim(time_decay_extra_dim)\n        self.gguf_writer.add_feed_forward_length(intermediate_size)\n        self.gguf_writer.add_file_type(self.ftype)\n\n        # required by llama.cpp, unused\n        self.gguf_writer.add_head_count(0)\n\n    lerp_weights: dict[int, dict[str, Tensor]] = {}\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        new_name = self.map_tensor_name(name)\n\n        if not (new_name.endswith(\".weight\") or new_name.endswith(\".bias\")):\n            new_name += \".weight\"\n\n        if new_name.endswith(\"time_mix_w1.weight\") or new_name.endswith(\"time_mix_decay_w1.weight\") or new_name.endswith(\"time_mix_decay_w2.weight\"):\n            data_torch = data_torch.transpose(0, 1)\n\n        if new_name.endswith(\"time_mix_w2.weight\"):\n            data_torch = data_torch.permute(0, 2, 1)\n\n        if new_name.endswith(\"time_mix_decay.weight\") or \"lerp\" in new_name:\n            data_torch = data_torch.squeeze()\n\n        try:\n            rescale_every_n_layers = self.hparams[\"rescale_every\"]\n            if rescale_every_n_layers > 0:\n                if new_name.endswith(\"time_mix_output.weight\") or new_name.endswith(\"channel_mix_value.weight\"):\n                    data_torch = data_torch.div_(2 ** int(bid // rescale_every_n_layers))\n        except KeyError:\n            pass\n\n        # concat time_mix_lerp weights to reduce some cpu overhead\n        # also reduces the number of tensors in the model\n        if bid is not None and \"time_mix_lerp\" in new_name and \"time_mix_lerp_x\" not in new_name:\n            try:\n                self.lerp_weights[bid][new_name] = data_torch\n            except KeyError:\n                self.lerp_weights[bid] = {new_name: data_torch}\n            if all(f\"blk.{bid}.time_mix_lerp_{i}.weight\" in self.lerp_weights[bid].keys() for i in [\"w\", \"k\", \"v\", \"r\", \"g\"]):\n                new_name = f\"blk.{bid}.time_mix_lerp_fused.weight\"\n                data = torch.stack([self.lerp_weights[bid][f\"blk.{bid}.time_mix_lerp_{i}.weight\"].unsqueeze(0) for i in [\"w\", \"k\", \"v\", \"r\", \"g\"]], dim=0).unsqueeze(1)\n                yield (new_name, data)\n            return\n\n        yield (new_name, data_torch)\n\n\n@Model.register(\"RWKV6Qwen2ForCausalLM\")\nclass RWKV6Qwen2Model(Rwkv6Model):\n    model_arch = gguf.MODEL_ARCH.RWKV6QWEN2\n\n    def set_vocab(self):\n        try:\n            self._set_vocab_sentencepiece()\n        except FileNotFoundError:\n            self._set_vocab_gpt2()\n\n    def set_gguf_parameters(self):\n        block_count = self.hparams[\"num_hidden_layers\"]\n        num_attention_heads = self.hparams[\"num_attention_heads\"]\n        num_key_value_heads = self.hparams[\"num_key_value_heads\"]\n        hidden_size = self.hparams[\"hidden_size\"]\n        head_size = hidden_size // num_attention_heads\n        rms_norm_eps = self.hparams[\"rms_norm_eps\"]\n        intermediate_size = self.hparams[\"intermediate_size\"]\n        time_mix_extra_dim = 64 if hidden_size >= 4096 else 32\n        time_decay_extra_dim = 128 if hidden_size >= 4096 else 64\n\n        # RWKV isn't context limited\n        self.gguf_writer.add_context_length(1048576)\n        self.gguf_writer.add_embedding_length(hidden_size)\n        self.gguf_writer.add_block_count(block_count)\n        self.gguf_writer.add_wkv_head_size(head_size)\n        self.gguf_writer.add_time_mix_extra_dim(time_mix_extra_dim)\n        self.gguf_writer.add_time_decay_extra_dim(time_decay_extra_dim)\n        self.gguf_writer.add_feed_forward_length(intermediate_size)\n        self.gguf_writer.add_file_type(self.ftype)\n\n        # special parameters for time_mixing in RWKV6QWEN2\n        self.gguf_writer.add_layer_norm_rms_eps(rms_norm_eps)\n        self.gguf_writer.add_token_shift_count(1)\n        # RWKV6QWEN2 use grouped key/value like GQA\n        self.gguf_writer.add_head_count_kv(num_key_value_heads)\n\n        # required by llama.cpp, unused\n        self.gguf_writer.add_head_count(0)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        for new_name, data in super().modify_tensors(data_torch, name, bid):\n            if \"time_mix_w1\" in new_name or \"time_mix_w2\" in new_name:\n                data = data.view(5, -1, data.shape[-1])\n                # rwkv6qwen2 has a different order of rkvwg instead of the original wkvrg\n                # permute them here to avoid code changes\n                data = torch.stack([data[3], data[1], data[2], data[0], data[4]], dim=0).view(-1, data.shape[-1])\n                if \"w2\" in new_name:\n                    data = data.view(5, -1, data.shape[-1])\n                yield (new_name, data)\n                continue\n            yield (new_name, data)\n\n\n@Model.register(\"MambaForCausalLM\", \"MambaLMHeadModel\", \"FalconMambaForCausalLM\")\nclass MambaModel(Model):\n    model_arch = gguf.MODEL_ARCH.MAMBA\n\n    def set_vocab(self):\n        vocab_size = self.hparams[\"vocab_size\"]\n        # Round vocab size to next multiple of 8\n        pad_vocab = self.hparams.get(\"pad_vocab_size_multiple\", 8)\n        # pad using ceiling division\n        # ref: https://stackoverflow.com/a/17511341/22827863\n        vocab_size = -(vocab_size // -pad_vocab) * pad_vocab\n        self.hparams[\"vocab_size\"] = vocab_size\n\n        if (self.dir_model / \"tokenizer.json\").is_file():\n            self._set_vocab_gpt2()\n        elif (self.dir_model / \"tokenizer.model\").is_file():\n            self._set_vocab_sentencepiece()\n        else:\n            # Use the GPT-NeoX tokenizer when no tokenizer files are present\n            self._set_vocab_builtin(\"gpt-neox\", vocab_size)\n\n    def set_gguf_parameters(self):\n        d_model = self.find_hparam([\"hidden_size\",       \"d_model\"])\n        d_conv  = self.find_hparam([\"conv_kernel\",       \"d_conv\"],  optional=True) or 4\n        d_inner = self.find_hparam([\"intermediate_size\", \"d_inner\"], optional=True) or 2 * d_model\n        d_state = self.find_hparam([\"state_size\",        \"d_state\"], optional=True) or 16\n        # ceiling division\n        # ref: https://stackoverflow.com/a/17511341/22827863\n        # ref: https://github.com/state-spaces/mamba/blob/ce59daea3a090d011d6476c6e5b97f6d58ddad8b/mamba_ssm/modules/mamba_simple.py#L58\n        dt_rank      = self.find_hparam([\"time_step_rank\",     \"dt_rank\"],      optional=True) or -(d_model // -16)\n        rms_norm_eps = self.find_hparam([\"layer_norm_epsilon\", \"rms_norm_eps\"], optional=True) or 1e-5\n        use_dt_b_c_norm = False\n        # For falconmamba we do apply RMS norm on B / DT and C layers\n        if self.find_hparam([\"model_type\"], optional=True) in (\"falcon_mamba\",):\n            use_dt_b_c_norm = True\n        # Fail early for models which don't have a block expansion factor of 2\n        assert d_inner == 2 * d_model\n\n        self.gguf_writer.add_context_length(2**20) # arbitrary value; for those who use the default\n        self.gguf_writer.add_embedding_length(d_model)\n        self.gguf_writer.add_feed_forward_length(0) # unused, but seemingly required when loading\n        self.gguf_writer.add_head_count(0) # unused, but seemingly required when loading\n        self.gguf_writer.add_block_count(self.block_count)\n        self.gguf_writer.add_ssm_conv_kernel(d_conv)\n        self.gguf_writer.add_ssm_inner_size(d_inner)\n        self.gguf_writer.add_ssm_state_size(d_state)\n        self.gguf_writer.add_ssm_time_step_rank(dt_rank)\n        self.gguf_writer.add_layer_norm_rms_eps(rms_norm_eps)\n        self.gguf_writer.add_ssm_dt_b_c_rms(use_dt_b_c_norm) # For classic Mamba we don't apply rms norm on B / DT layers\n        self.gguf_writer.add_file_type(self.ftype)\n\n    _tok_embd = None\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        output_name = self.format_tensor_name(gguf.MODEL_TENSOR.OUTPUT)\n        tok_embd_name = self.format_tensor_name(gguf.MODEL_TENSOR.TOKEN_EMBD)\n\n        new_name = self.map_tensor_name(name)\n\n        if name.endswith(\".A_log\"):\n            logger.debug(\"A_log --> A ==> \" + new_name)\n            data_torch = -torch.exp(data_torch)\n\n        # assuming token_embd.weight is seen before output.weight\n        if self._tok_embd is not None and new_name == output_name:\n            if torch.equal(self._tok_embd, data_torch):\n                logger.debug(f\"{output_name} is equivalent to {tok_embd_name}, omitting\")\n                return []\n        elif new_name == tok_embd_name:\n            self._tok_embd = data_torch\n\n        return [(new_name, data_torch)]\n\n\n@Model.register(\"CohereForCausalLM\")\nclass CommandR2Model(Model):\n    model_arch = gguf.MODEL_ARCH.COMMAND_R\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # max_position_embeddings = 8192 in config.json but model was actually\n        # trained on 128k context length\n        # aya-23 models don't have model_max_length specified\n        self.hparams[\"max_position_embeddings\"] = self.find_hparam([\"model_max_length\", \"max_position_embeddings\"])\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_logit_scale(self.hparams[\"logit_scale\"])\n        self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.NONE)\n\n\n@Model.register(\"Cohere2ForCausalLM\")\nclass Cohere2Model(Model):\n    model_arch = gguf.MODEL_ARCH.COHERE2\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n\n        self.gguf_writer.add_logit_scale(self.hparams[\"logit_scale\"])\n        self.gguf_writer.add_sliding_window(self.hparams[\"sliding_window\"])\n        self.gguf_writer.add_vocab_size(self.hparams[\"vocab_size\"])\n\n        rotary_pct = self.hparams[\"rotary_pct\"]\n        hidden_size = self.hparams[\"hidden_size\"]\n        num_attention_heads = self.hparams[\"num_attention_heads\"]\n        self.gguf_writer.add_rope_dimension_count(int(rotary_pct * (hidden_size // num_attention_heads)))\n        self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.NONE)\n\n\n@Model.register(\"OlmoForCausalLM\")\n@Model.register(\"OLMoForCausalLM\")\nclass OlmoModel(Model):\n    model_arch = gguf.MODEL_ARCH.OLMO\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_layer_norm_eps(1e-5)\n        clip_qkv = self.hparams.get(\"clip_qkv\")\n        if clip_qkv is not None:\n            self.gguf_writer.add_clamp_kqv(clip_qkv)\n\n    # Same as super class, but permuting q_proj, k_proj\n    # Copied from: LlamaModel\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        n_head = self.hparams[\"num_attention_heads\"]\n        n_kv_head = self.hparams.get(\"num_key_value_heads\")\n\n        if name.endswith(\"q_proj.weight\"):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_head)\n        if name.endswith(\"k_proj.weight\"):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_kv_head)\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"Olmo2ForCausalLM\")\nclass Olmo2Model(Model):\n    model_arch = gguf.MODEL_ARCH.OLMO2\n\n\n@Model.register(\"OlmoeForCausalLM\")\nclass OlmoeModel(Model):\n    model_arch = gguf.MODEL_ARCH.OLMOE\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_layer_norm_rms_eps(1e-5)\n        if (n_experts := self.hparams.get(\"num_experts\")) is not None:\n            self.gguf_writer.add_expert_count(n_experts)\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    # Copied from: Qwen2MoeModel\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # process the experts separately\n        if name.find(\"experts\") != -1:\n            n_experts = self.hparams[\"num_experts\"]\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for w_name in [\"down_proj\", \"gate_proj\", \"up_proj\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"model.layers.{bid}.mlp.experts.{xid}.{w_name}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"model.layers.{bid}.mlp.experts.{w_name}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    # Copied from: Qwen2MoeModel\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._experts is not None:\n            # flatten `list[dict[str, Tensor]]` into `list[str]`\n            experts = [k for d in self._experts for k in d.keys()]\n            if len(experts) > 0:\n                raise ValueError(f\"Unprocessed experts: {experts}\")\n\n\n@Model.register(\"JinaBertModel\", \"JinaBertForMaskedLM\")\nclass JinaBertV2Model(BertModel):\n    model_arch = gguf.MODEL_ARCH.JINA_BERT_V2\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.intermediate_size = self.hparams[\"intermediate_size\"]\n\n    def get_tensors(self):\n        for name, data in super().get_tensors():\n            if 'gated_layer' in name:\n                d1 = data[:self.intermediate_size, :]\n                name1 = name.replace('gated_layers', 'gated_layers_w')\n                name1 = name1.replace('up_gated_layer', 'gated_layers_v')\n                d2 = data[self.intermediate_size:, :]\n                name2 = name.replace('gated_layers', 'gated_layers_v')\n                name2 = name2.replace('up_gated_layer', 'gated_layers_w')\n                yield name1, d1\n                yield name2, d2\n                continue\n\n            yield name, data\n\n    def set_vocab(self):\n        tokenizer_class = 'BertTokenizer'\n        with open(self.dir_model / \"tokenizer_config.json\", \"r\", encoding=\"utf-8\") as f:\n            tokenizer_class = json.load(f)['tokenizer_class']\n\n        if tokenizer_class == 'BertTokenizer':\n            super().set_vocab()\n        elif tokenizer_class == 'RobertaTokenizer':\n            self._set_vocab_gpt2()\n            self.gguf_writer.add_token_type_count(2)\n        else:\n            raise NotImplementedError(f'Tokenizer {tokenizer_class} is not supported for JinaBertModel')\n        self.gguf_writer.add_add_bos_token(True)\n        self.gguf_writer.add_add_eos_token(True)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # if name starts with \"bert.\", remove the prefix\n        # e.g. https://huggingface.co/jinaai/jina-reranker-v1-tiny-en\n        if name.startswith(\"bert.\"):\n            name = name[5:]\n\n        return super().modify_tensors(data_torch, name, bid)\n\n\n@Model.register(\"OpenELMForCausalLM\")\nclass OpenELMModel(Model):\n    model_arch = gguf.MODEL_ARCH.OPENELM\n\n    @staticmethod\n    def _make_divisible(v: float | int, divisor: int) -> int:\n        # ref: https://huggingface.co/apple/OpenELM-270M-Instruct/blob/eb111ff2e6724348e5b905984063d4064d4bc579/configuration_openelm.py#L34-L38\n        new_v = max(divisor, int(v + divisor / 2) // divisor * divisor)\n        # Make sure that round down does not go down by more than 10%.\n        if new_v < 0.9 * v:\n            new_v += divisor\n        return new_v\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        ffn_multipliers: list[float] = self.hparams[\"ffn_multipliers\"]\n        ffn_dim_divisor: int = self.hparams[\"ffn_dim_divisor\"]\n        self._n_embd: int = self.hparams[\"model_dim\"]\n        self._num_kv_heads: list[int] = self.hparams[\"num_kv_heads\"]\n        self._num_query_heads: list[int] = self.hparams[\"num_query_heads\"]\n        self._ffn_dims: list[int] = [\n            OpenELMModel._make_divisible(multiplier * self._n_embd, ffn_dim_divisor)\n            for multiplier in ffn_multipliers\n        ]\n        assert isinstance(self._num_kv_heads, list) and isinstance(self._num_kv_heads[0], int)\n        assert isinstance(self._num_query_heads, list) and isinstance(self._num_query_heads[0], int)\n\n    # Uses the tokenizer from meta-llama/Llama-2-7b-hf\n    def set_vocab(self):\n        try:\n            self._set_vocab_sentencepiece()\n        except FileNotFoundError:\n            self._set_vocab_builtin(\"llama-spm\", self.hparams[\"vocab_size\"])\n\n    def set_gguf_parameters(self):\n        n_embd = self._n_embd\n        head_dim = self.hparams[\"head_dim\"]\n        rot_pct = 1.0\n        assert self.block_count == len(self._num_kv_heads)\n        assert self.block_count == len(self._num_query_heads)\n        assert self.block_count == len(self._ffn_dims)\n\n        self.gguf_writer.add_block_count(self.block_count)\n        self.gguf_writer.add_context_length(self.hparams[\"max_context_length\"])\n        self.gguf_writer.add_embedding_length(n_embd)\n        self.gguf_writer.add_feed_forward_length(self._ffn_dims)\n        self.gguf_writer.add_head_count(self._num_query_heads)\n        self.gguf_writer.add_head_count_kv(self._num_kv_heads)\n        self.gguf_writer.add_rope_freq_base(self.hparams[\"rope_freq_constant\"])\n        # https://huggingface.co/apple/OpenELM-270M-Instruct/blob/c401df2/modeling_openelm.py#L30\n        self.gguf_writer.add_layer_norm_rms_eps(1e-6)\n        self.gguf_writer.add_rope_dimension_count(int(rot_pct * head_dim))\n        self.gguf_writer.add_key_length(head_dim)\n        self.gguf_writer.add_value_length(head_dim)\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def find_hparam(self, keys: Iterable[str], optional: bool = False) -> Any:\n        if \"n_layers\" in keys:\n            return self.hparams[\"num_transformer_layers\"]\n\n        return super().find_hparam(keys, optional)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n\n        # split ff\n        if bid is not None and name == f\"transformer.layers.{bid}.ffn.proj_1.weight\":\n            ff_dim = self._ffn_dims[bid]\n            yield (self.format_tensor_name(gguf.MODEL_TENSOR.FFN_GATE, bid), data_torch[:ff_dim])\n            yield (self.format_tensor_name(gguf.MODEL_TENSOR.FFN_UP, bid), data_torch[ff_dim:])\n            return\n\n        yield (self.map_tensor_name(name), data_torch)\n\n\n@Model.register(\"ArcticForCausalLM\")\nclass ArcticModel(Model):\n    model_arch = gguf.MODEL_ARCH.ARCTIC\n\n    def set_vocab(self):\n        # The reason for using a custom implementation here is that the\n        # snowflake-arctic-instruct model redefined tokens 31998 and 31999 from\n        # tokenizer.model and used them as BOS and EOS instead of adding new tokens.\n        from sentencepiece import SentencePieceProcessor\n\n        tokenizer_path = self.dir_model / 'tokenizer.model'\n\n        if not tokenizer_path.is_file():\n            logger.error(f'Error: Missing {tokenizer_path}')\n            sys.exit(1)\n\n        # Read the whole vocabulary from the tokenizer.model file\n        tokenizer = SentencePieceProcessor()\n        tokenizer.LoadFromFile(str(tokenizer_path))\n\n        vocab_size = self.hparams.get('vocab_size', tokenizer.vocab_size())\n\n        tokens: list[bytes] = [f\"[PAD{i}]\".encode(\"utf-8\") for i in range(vocab_size)]\n        scores: list[float] = [-10000.0] * vocab_size\n        toktypes: list[int] = [SentencePieceTokenTypes.UNUSED] * vocab_size\n\n        for token_id in range(tokenizer.vocab_size()):\n\n            piece = tokenizer.IdToPiece(token_id)\n            text = piece.encode(\"utf-8\")\n            score = tokenizer.GetScore(token_id)\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.IsUnknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.IsControl(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.IsUnused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.IsByte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n\n            tokens[token_id] = text\n            scores[token_id] = score\n            toktypes[token_id] = toktype\n\n        # Use the added_tokens_decoder field from tokeniser_config.json as the source\n        # of information about added/redefined tokens and modify them accordingly.\n        tokenizer_config_file = self.dir_model / 'tokenizer_config.json'\n        if tokenizer_config_file.is_file():\n            with open(tokenizer_config_file, \"r\", encoding=\"utf-8\") as f:\n                tokenizer_config_json = json.load(f)\n\n                if \"added_tokens_decoder\" in tokenizer_config_json:\n                    added_tokens_decoder = tokenizer_config_json[\"added_tokens_decoder\"]\n                    for token_id, token_json in added_tokens_decoder.items():\n                        token_id = int(token_id)\n                        if token_id >= vocab_size:\n                            logger.debug(f'ignore token {token_id}: id is out of range, max={vocab_size - 1}')\n                            continue\n\n                        token_content = token_json[\"content\"]\n                        token_type = SentencePieceTokenTypes.USER_DEFINED\n                        token_score = -10000.0\n\n                        # Map unk_token to UNKNOWN, other special tokens to CONTROL\n                        # Set the score to 0.0 as in the original tokenizer.model\n                        if (\"special\" in token_json) and token_json[\"special\"]:\n                            if token_content == tokenizer_config_json[\"unk_token\"]:\n                                token_type = SentencePieceTokenTypes.UNKNOWN\n                            else:\n                                token_type = SentencePieceTokenTypes.CONTROL\n                            token_score = 0.0\n\n                        logger.info(f\"Setting added token {token_id} to '{token_content}' (type: {token_type}, score: {token_score:.2f})\")\n                        tokens[token_id] = token_content.encode(\"utf-8\")\n                        toktypes[token_id] = token_type\n                        scores[token_id] = token_score\n\n        self.gguf_writer.add_tokenizer_model(\"llama\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        hparams = self.hparams\n        self.gguf_writer.add_vocab_size(hparams[\"vocab_size\"])\n        self.gguf_writer.add_rope_dimension_count(hparams[\"hidden_size\"] // hparams[\"num_attention_heads\"])\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        n_head = self.hparams[\"num_attention_heads\"]\n        n_kv_head = self.hparams.get(\"num_key_value_heads\")\n\n        if name.endswith(\"q_proj.weight\"):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_head)\n        if name.endswith(\"k_proj.weight\"):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_kv_head)\n\n        # process the experts separately\n        if name.find(\"block_sparse_moe.experts\") != -1:\n            n_experts = self.hparams[\"num_local_experts\"]\n\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for wid in [\"w1\", \"w2\", \"w3\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"model.layers.{bid}.block_sparse_moe.experts.{xid}.{wid}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"layers.{bid}.feed_forward.experts.{wid}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._experts is not None:\n            # flatten `list[dict[str, Tensor]]` into `list[str]`\n            experts = [k for d in self._experts for k in d.keys()]\n            if len(experts) > 0:\n                raise ValueError(f\"Unprocessed experts: {experts}\")\n\n\n@Model.register(\"DeepseekForCausalLM\")\nclass DeepseekModel(Model):\n    model_arch = gguf.MODEL_ARCH.DEEPSEEK\n\n    def set_vocab(self):\n        try:\n            self._set_vocab_sentencepiece()\n        except FileNotFoundError:\n            self._set_vocab_gpt2()\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        hparams = self.hparams\n        if \"head_dim\" in hparams:\n            rope_dim = hparams[\"head_dim\"]\n        else:\n            rope_dim = hparams[\"hidden_size\"] // hparams[\"num_attention_heads\"]\n\n        self.gguf_writer.add_rope_dimension_count(rope_dim)\n        self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.NONE)\n        self.gguf_writer.add_leading_dense_block_count(hparams[\"first_k_dense_replace\"])\n        self.gguf_writer.add_vocab_size(hparams[\"vocab_size\"])\n        self.gguf_writer.add_expert_feed_forward_length(hparams[\"moe_intermediate_size\"])\n        self.gguf_writer.add_expert_weights_scale(1.0)\n        self.gguf_writer.add_expert_count(hparams[\"n_routed_experts\"])\n        self.gguf_writer.add_expert_shared_count(hparams[\"n_shared_experts\"])\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    @staticmethod\n    def permute(weights: Tensor, n_head: int, n_head_kv: int | None):\n        if n_head_kv is not None and n_head != n_head_kv:\n            n_head = n_head_kv\n        return (weights.reshape(n_head, 2, weights.shape[0] // n_head // 2, *weights.shape[1:])\n                .swapaxes(1, 2)\n                .reshape(weights.shape))\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        n_head = self.hparams[\"num_attention_heads\"]\n        n_kv_head = self.hparams.get(\"num_key_value_heads\")\n\n        if name.endswith((\"q_proj.weight\", \"q_proj.bias\")):\n            data_torch = DeepseekModel.permute(data_torch, n_head, n_head)\n        if name.endswith((\"k_proj.weight\", \"k_proj.bias\")):\n            data_torch = DeepseekModel.permute(data_torch, n_head, n_kv_head)\n\n        # process the experts separately\n        if name.find(\"mlp.experts\") != -1:\n            n_experts = self.hparams[\"n_routed_experts\"]\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for w_name in [\"down_proj\", \"gate_proj\", \"up_proj\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"model.layers.{bid}.mlp.experts.{xid}.{w_name}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"model.layers.{bid}.mlp.experts.{w_name}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._experts is not None:\n            # flatten `list[dict[str, Tensor]]` into `list[str]`\n            experts = [k for d in self._experts for k in d.keys()]\n            if len(experts) > 0:\n                raise ValueError(f\"Unprocessed experts: {experts}\")\n\n\n@Model.register(\"DeepseekV2ForCausalLM\")\n@Model.register(\"DeepseekV3ForCausalLM\")\nclass DeepseekV2Model(Model):\n    model_arch = gguf.MODEL_ARCH.DEEPSEEK2\n\n    def set_vocab(self):\n        self._set_vocab_gpt2()\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        hparams = self.hparams\n\n        self.gguf_writer.add_leading_dense_block_count(hparams[\"first_k_dense_replace\"])\n        self.gguf_writer.add_vocab_size(hparams[\"vocab_size\"])\n        if \"q_lora_rank\" in hparams and hparams[\"q_lora_rank\"] is not None:\n            self.gguf_writer.add_q_lora_rank(hparams[\"q_lora_rank\"])\n        self.gguf_writer.add_kv_lora_rank(hparams[\"kv_lora_rank\"])\n        self.gguf_writer.add_key_length(hparams[\"qk_nope_head_dim\"] + hparams[\"qk_rope_head_dim\"])\n        self.gguf_writer.add_value_length(hparams[\"v_head_dim\"])\n        self.gguf_writer.add_expert_feed_forward_length(hparams[\"moe_intermediate_size\"])\n        self.gguf_writer.add_expert_count(hparams[\"n_routed_experts\"])\n        self.gguf_writer.add_expert_shared_count(hparams[\"n_shared_experts\"])\n        self.gguf_writer.add_expert_weights_scale(hparams[\"routed_scaling_factor\"])\n        self.gguf_writer.add_expert_weights_norm(hparams[\"norm_topk_prob\"])\n\n        if hparams[\"scoring_func\"] == \"sigmoid\":\n            self.gguf_writer.add_expert_gating_func(gguf.ExpertGatingFuncType.SIGMOID)\n        elif hparams[\"scoring_func\"] == \"softmax\":\n            self.gguf_writer.add_expert_gating_func(gguf.ExpertGatingFuncType.SOFTMAX)\n        else:\n            raise ValueError(f\"Unsupported scoring_func value: {hparams['scoring_func']}\")\n\n        self.gguf_writer.add_rope_dimension_count(hparams[\"qk_rope_head_dim\"])\n\n        if self.hparams.get(\"rope_scaling\") is not None and \"factor\" in self.hparams[\"rope_scaling\"]:\n            if self.hparams[\"rope_scaling\"].get(\"type\") == \"yarn\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.YARN)\n                self.gguf_writer.add_rope_scaling_factor(self.hparams[\"rope_scaling\"][\"factor\"])\n                self.gguf_writer.add_rope_scaling_orig_ctx_len(self.hparams[\"rope_scaling\"][\"original_max_position_embeddings\"])\n                self.gguf_writer.add_rope_scaling_yarn_log_mul(0.1 * hparams[\"rope_scaling\"][\"mscale_all_dim\"])\n\n    _experts: list[dict[str, Tensor]] | None = None\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # rename e_score_correction_bias tensors\n        if name.endswith(\"e_score_correction_bias\"):\n            name = name.replace(\"e_score_correction_bias\", \"e_score_correction.bias\")\n\n        # skip Multi-Token Prediction (MTP) layers\n        block_count = self.hparams[\"num_hidden_layers\"]\n        match = re.match(r\"model.layers.(\\d+)\", name)\n        if match and int(match.group(1)) >= block_count:\n            return []\n\n        # process the experts separately\n        if name.find(\"mlp.experts\") != -1:\n            n_experts = self.hparams[\"n_routed_experts\"]\n            assert bid is not None\n\n            if self._experts is None:\n                self._experts = [{} for _ in range(self.block_count)]\n\n            self._experts[bid][name] = data_torch\n\n            if len(self._experts[bid]) >= n_experts * 3:\n                tensors: list[tuple[str, Tensor]] = []\n\n                # merge the experts into a single 3d tensor\n                for w_name in [\"down_proj\", \"gate_proj\", \"up_proj\"]:\n                    datas: list[Tensor] = []\n\n                    for xid in range(n_experts):\n                        ename = f\"model.layers.{bid}.mlp.experts.{xid}.{w_name}.weight\"\n                        datas.append(self._experts[bid][ename])\n                        del self._experts[bid][ename]\n\n                    data_torch = torch.stack(datas, dim=0)\n\n                    merged_name = f\"model.layers.{bid}.mlp.experts.{w_name}.weight\"\n\n                    new_name = self.map_tensor_name(merged_name)\n\n                    tensors.append((new_name, data_torch))\n                return tensors\n            else:\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n\n        if self._experts is not None:\n            # flatten `list[dict[str, Tensor]]` into `list[str]`\n            experts = [k for d in self._experts for k in d.keys()]\n            if len(experts) > 0:\n                raise ValueError(f\"Unprocessed experts: {experts}\")\n\n\n@Model.register(\"T5WithLMHeadModel\")\n@Model.register(\"T5ForConditionalGeneration\")\n@Model.register(\"MT5ForConditionalGeneration\")\n@Model.register(\"UMT5ForConditionalGeneration\")\nclass T5Model(Model):\n    model_arch = gguf.MODEL_ARCH.T5\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.shared_token_embeddings_found = False\n\n    def set_vocab(self):\n        # to avoid TypeError: Descriptors cannot be created directly\n        # exception when importing sentencepiece_model_pb2\n        os.environ[\"PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION\"] = \"python\"\n        from sentencepiece import SentencePieceProcessor\n        from sentencepiece import sentencepiece_model_pb2 as model\n\n        tokenizer_path = self.dir_model / 'tokenizer.model'\n\n        # many older models use spiece.model tokenizer model filename\n        if not tokenizer_path.is_file():\n            tokenizer_path = self.dir_model / 'spiece.model'\n\n        if not tokenizer_path.is_file():\n            raise FileNotFoundError(f\"File not found: {tokenizer_path}\")\n\n        sentencepiece_model = model.ModelProto()  # pyright: ignore[reportAttributeAccessIssue]\n        sentencepiece_model.ParseFromString(open(tokenizer_path, \"rb\").read())\n\n        # some models like Pile-T5 family use BPE tokenizer instead of Unigram\n        if sentencepiece_model.trainer_spec.model_type == 2:  # BPE\n            # assure the tokenizer model file name is correct\n            assert tokenizer_path.name == 'tokenizer.model'\n            return self._set_vocab_sentencepiece()\n        else:\n            assert sentencepiece_model.trainer_spec.model_type == 1  # UNIGRAM\n\n        add_prefix = sentencepiece_model.normalizer_spec.add_dummy_prefix\n        remove_whitespaces = sentencepiece_model.normalizer_spec.remove_extra_whitespaces\n        precompiled_charsmap = sentencepiece_model.normalizer_spec.precompiled_charsmap\n\n        tokenizer = SentencePieceProcessor()\n        tokenizer.LoadFromFile(str(tokenizer_path))\n\n        vocab_size = self.hparams.get('vocab_size', tokenizer.vocab_size())\n\n        tokens: list[bytes] = [f\"[PAD{i}]\".encode(\"utf-8\") for i in range(vocab_size)]\n        scores: list[float] = [-10000.0] * vocab_size\n        toktypes: list[int] = [SentencePieceTokenTypes.UNUSED] * vocab_size\n\n        for token_id in range(tokenizer.vocab_size()):\n            piece = tokenizer.IdToPiece(token_id)\n            text = piece.encode(\"utf-8\")\n            score = tokenizer.GetScore(token_id)\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.IsUnknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.IsControl(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.IsUnused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.IsByte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n\n            tokens[token_id] = text\n            scores[token_id] = score\n            toktypes[token_id] = toktype\n\n        added_tokens_file = self.dir_model / 'added_tokens.json'\n        if added_tokens_file.is_file():\n            with open(added_tokens_file, \"r\", encoding=\"utf-8\") as f:\n                added_tokens_json = json.load(f)\n                for key in added_tokens_json:\n                    token_id = added_tokens_json[key]\n                    if token_id >= vocab_size:\n                        logger.warning(f'ignore token {token_id}: id is out of range, max={vocab_size - 1}')\n                        continue\n\n                    tokens[token_id] = key.encode(\"utf-8\")\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n\n        if vocab_size > len(tokens):\n            pad_count = vocab_size - len(tokens)\n            logger.debug(f\"Padding vocab with {pad_count} token(s) - [PAD1] through [PAD{pad_count}]\")\n            for i in range(1, pad_count + 1):\n                tokens.append(bytes(f\"[PAD{i}]\", encoding=\"utf-8\"))\n                scores.append(-1000.0)\n                toktypes.append(SentencePieceTokenTypes.UNUSED)\n\n        self.gguf_writer.add_tokenizer_model(\"t5\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n        self.gguf_writer.add_add_space_prefix(add_prefix)\n        self.gguf_writer.add_remove_extra_whitespaces(remove_whitespaces)\n        if precompiled_charsmap:\n            self.gguf_writer.add_precompiled_charsmap(precompiled_charsmap)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n        self.gguf_writer.add_add_bos_token(False)\n        self.gguf_writer.add_add_eos_token(True)\n\n    def set_gguf_parameters(self):\n        if (n_ctx := self.find_hparam([\"n_positions\"], optional=True)) is None:\n            logger.warning(\"Couldn't find context length in config.json, assuming default value of 512\")\n            n_ctx = 512\n        self.gguf_writer.add_context_length(n_ctx)\n        self.gguf_writer.add_embedding_length(self.hparams[\"d_model\"])\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"d_ff\"])\n        self.gguf_writer.add_block_count(self.hparams[\"num_layers\"])\n        self.gguf_writer.add_head_count(self.hparams[\"num_heads\"])\n        self.gguf_writer.add_key_length(self.hparams[\"d_kv\"])\n        self.gguf_writer.add_value_length(self.hparams[\"d_kv\"])\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_relative_attn_buckets_count(self.hparams[\"relative_attention_num_buckets\"])\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_decoder_start_token_id(self.hparams[\"decoder_start_token_id\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        # T5 based models contain shared token embeddings tensors saved randomly as either \"encoder.embed_tokens.weight\",\n        # \"decoder.embed_tokens.weight\" or \"shared.weight\" tensor. In some models there are even multiple of them stored\n        # in the safetensors files. We use the first tensor from these three as the token embeddings for both encoder\n        # and decoder and ignore the remaining ones.\n        if name in [\"decoder.embed_tokens.weight\", \"encoder.embed_tokens.weight\", \"shared.weight\"]:\n            if not self.shared_token_embeddings_found:\n                name = \"shared.weight\"\n                self.shared_token_embeddings_found = True\n            else:\n                logger.debug(f\"Skipping shared tensor {name!r} in safetensors so that convert can end normally.\")\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"T5EncoderModel\")\nclass T5EncoderModel(Model):\n    model_arch = gguf.MODEL_ARCH.T5ENCODER\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.shared_token_embeddings_found = False\n\n    def set_vocab(self):\n        # to avoid TypeError: Descriptors cannot be created directly\n        # exception when importing sentencepiece_model_pb2\n        os.environ[\"PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION\"] = \"python\"\n        from sentencepiece import SentencePieceProcessor\n        from sentencepiece import sentencepiece_model_pb2 as model\n\n        tokenizer_path = self.dir_model / 'tokenizer.model'\n\n        # many older models use spiece.model tokenizer model filename\n        if not tokenizer_path.is_file():\n            tokenizer_path = self.dir_model / 'spiece.model'\n\n        if not tokenizer_path.is_file():\n            raise FileNotFoundError(f\"File not found: {tokenizer_path}\")\n\n        sentencepiece_model = model.ModelProto()  # pyright: ignore[reportAttributeAccessIssue]\n        sentencepiece_model.ParseFromString(open(tokenizer_path, \"rb\").read())\n\n        # some models like Pile-T5 family use BPE tokenizer instead of Unigram\n        if sentencepiece_model.trainer_spec.model_type == 2:  # BPE\n            # assure the tokenizer model file name is correct\n            assert tokenizer_path.name == 'tokenizer.model'\n            return self._set_vocab_sentencepiece()\n        else:\n            assert sentencepiece_model.trainer_spec.model_type == 1  # UNIGRAM\n\n        add_prefix = sentencepiece_model.normalizer_spec.add_dummy_prefix\n        remove_whitespaces = sentencepiece_model.normalizer_spec.remove_extra_whitespaces\n        precompiled_charsmap = sentencepiece_model.normalizer_spec.precompiled_charsmap\n\n        tokenizer = SentencePieceProcessor()\n        tokenizer.LoadFromFile(str(tokenizer_path))\n\n        vocab_size = self.hparams.get('vocab_size', tokenizer.vocab_size())\n\n        tokens: list[bytes] = [f\"[PAD{i}]\".encode(\"utf-8\") for i in range(vocab_size)]\n        scores: list[float] = [-10000.0] * vocab_size\n        toktypes: list[int] = [SentencePieceTokenTypes.UNUSED] * vocab_size\n\n        for token_id in range(tokenizer.vocab_size()):\n            piece = tokenizer.IdToPiece(token_id)\n            text = piece.encode(\"utf-8\")\n            score = tokenizer.GetScore(token_id)\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.IsUnknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.IsControl(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.IsUnused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.IsByte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n\n            tokens[token_id] = text\n            scores[token_id] = score\n            toktypes[token_id] = toktype\n\n        added_tokens_file = self.dir_model / 'added_tokens.json'\n        if added_tokens_file.is_file():\n            with open(added_tokens_file, \"r\", encoding=\"utf-8\") as f:\n                added_tokens_json = json.load(f)\n                for key in added_tokens_json:\n                    token_id = added_tokens_json[key]\n                    if token_id >= vocab_size:\n                        logger.warning(f'ignore token {token_id}: id is out of range, max={vocab_size - 1}')\n                        continue\n\n                    tokens[token_id] = key.encode(\"utf-8\")\n                    scores[token_id] = -1000.0\n                    toktypes[token_id] = SentencePieceTokenTypes.USER_DEFINED\n\n        if vocab_size > len(tokens):\n            pad_count = vocab_size - len(tokens)\n            logger.debug(f\"Padding vocab with {pad_count} token(s) - [PAD1] through [PAD{pad_count}]\")\n            for i in range(1, pad_count + 1):\n                tokens.append(bytes(f\"[PAD{i}]\", encoding=\"utf-8\"))\n                scores.append(-1000.0)\n                toktypes.append(SentencePieceTokenTypes.UNUSED)\n\n        self.gguf_writer.add_tokenizer_model(\"t5\")\n        self.gguf_writer.add_tokenizer_pre(\"default\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n        self.gguf_writer.add_add_space_prefix(add_prefix)\n        self.gguf_writer.add_remove_extra_whitespaces(remove_whitespaces)\n        if precompiled_charsmap:\n            self.gguf_writer.add_precompiled_charsmap(precompiled_charsmap)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n        self.gguf_writer.add_add_bos_token(False)\n        self.gguf_writer.add_add_eos_token(True)\n\n    def set_gguf_parameters(self):\n        if (n_ctx := self.find_hparam([\"n_positions\"], optional=True)) is None:\n            logger.warning(\"Couldn't find context length in config.json, assuming default value of 512\")\n            n_ctx = 512\n        self.gguf_writer.add_context_length(n_ctx)\n        self.gguf_writer.add_embedding_length(self.hparams[\"d_model\"])\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"d_ff\"])\n        self.gguf_writer.add_block_count(self.hparams[\"num_layers\"])\n        self.gguf_writer.add_head_count(self.hparams[\"num_heads\"])\n        self.gguf_writer.add_key_length(self.hparams[\"d_kv\"])\n        self.gguf_writer.add_value_length(self.hparams[\"d_kv\"])\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_relative_attn_buckets_count(self.hparams[\"relative_attention_num_buckets\"])\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        # T5 based models contain shared token embeddings tensors saved randomly as either \"encoder.embed_tokens.weight\",\n        # \"decoder.embed_tokens.weight\" or \"shared.weight\" tensor. In some models there are even multiple of them stored\n        # in the safetensors files. We use the first tensor from these three as the token embeddings for both encoder\n        # and decoder and ignore the remaining ones.\n        if name in [\"decoder.embed_tokens.weight\", \"encoder.embed_tokens.weight\", \"shared.weight\"]:\n            if not self.shared_token_embeddings_found:\n                name = \"shared.weight\"\n                self.shared_token_embeddings_found = True\n            else:\n                logger.debug(f\"Skipping shared tensor {name!r} in safetensors so that convert can end normally.\")\n                return []\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"JAISLMHeadModel\")\nclass JaisModel(Model):\n    model_arch = gguf.MODEL_ARCH.JAIS\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # SwigLU activation\n        assert self.hparams[\"activation_function\"] == \"swiglu\"\n        # ALiBi position embedding\n        assert self.hparams[\"position_embedding_type\"] == \"alibi\"\n\n        # Embeddings scale\n        self.embeddings_scale = 1.0\n        if 'mup_embeddings_scale' in self.hparams:\n            self.embeddings_scale = self.hparams['mup_embeddings_scale']\n        elif 'embeddings_scale' in self.hparams:\n            self.embeddings_scale = self.hparams['embeddings_scale']\n        else:\n            assert False\n\n        self.width_scale = 1.0\n        if 'mup_output_alpha' in self.hparams:\n            assert 'mup_width_scale' in self.hparams\n            self.width_scale = self.hparams['mup_output_alpha'] * self.hparams['mup_width_scale']\n        elif 'width_scale' in self.hparams:\n            self.width_scale = self.hparams['width_scale']\n        else:\n            assert False\n\n        self.max_alibi_bias = 8.0\n\n    def set_vocab(self):\n        self._set_vocab_gpt2()\n\n    def set_gguf_parameters(self):\n        self.gguf_writer.add_block_count(self.hparams[\"n_layer\"])\n        self.gguf_writer.add_context_length(self.hparams[\"n_positions\"])\n        self.gguf_writer.add_embedding_length(self.hparams[\"n_embd\"])\n        self.gguf_writer.add_feed_forward_length(self.hparams[\"n_inner\"])\n        self.gguf_writer.add_head_count(self.hparams[\"n_head\"])\n        self.gguf_writer.add_layer_norm_eps(self.hparams[\"layer_norm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        tensors: list[tuple[str, Tensor]] = []\n\n        # we don't need these\n        if name.endswith((\".attn.bias\")):\n            return tensors\n\n        if name.endswith((\"relative_pe.slopes\")):\n            # Calculate max ALiBi bias (this is the inverse of the ALiBi calculation)\n            # Some other models has max_alibi_bias spelled out explicitly in the hyperparams,\n            # but Jais's PyTorch model simply precalculates the slope values and places them\n            # in relative_pes.slopes\n            n_head_closest_log2 = 2 ** math.floor(math.log2(self.hparams[\"n_head\"]))\n            first_val = float(data_torch[0].item())\n            self.max_alibi_bias = -round(math.log2(first_val) * n_head_closest_log2)\n\n            return tensors\n\n        if name.endswith((\".c_attn.weight\", \".c_proj.weight\", \".c_fc.weight\", \".c_fc2.weight\")):\n            data_torch = data_torch.transpose(1, 0)\n\n        new_name = self.map_tensor_name(name)\n\n        if new_name == self.format_tensor_name(gguf.MODEL_TENSOR.TOKEN_EMBD):\n            tensors.append((new_name, data_torch * self.embeddings_scale))\n        elif new_name == self.format_tensor_name(gguf.MODEL_TENSOR.OUTPUT):\n            tensors.append((new_name, data_torch * self.width_scale))\n        else:\n            tensors.append((new_name, data_torch))\n\n        return tensors\n\n    def prepare_tensors(self):\n        super().prepare_tensors()\n        self.gguf_writer.add_max_alibi_bias(self.max_alibi_bias)\n\n\n@Model.register(\"ChatGLMModel\", \"ChatGLMForConditionalGeneration\")\nclass ChatGLMModel(Model):\n    model_arch = gguf.MODEL_ARCH.CHATGLM\n\n    def set_vocab_chatglm3(self):\n        dir_model = self.dir_model\n        hparams = self.hparams\n        tokens: list[bytes] = []\n        toktypes: list[int] = []\n        scores: list[float] = []\n\n        from transformers import AutoTokenizer\n        tokenizer = AutoTokenizer.from_pretrained(dir_model, trust_remote_code=True)\n        vocab_size = hparams.get(\"padded_vocab_size\", len(tokenizer.get_vocab()))\n        assert max(tokenizer.get_vocab().values()) < vocab_size\n        role_special_tokens = [\"<|system|>\", \"<|user|>\", \"<|assistant|>\", \"<|observation|>\"]\n        special_tokens = [\"[MASK]\", \"[gMASK]\", \"[sMASK]\", \"sop\", \"eop\"] + role_special_tokens\n        for token_id in range(vocab_size):\n            piece = tokenizer._convert_id_to_token(token_id)\n            if token_id == 0:\n                piece = \"<unk>\"\n            elif token_id == 1:\n                piece = \"<bos>\"\n            elif token_id == 2:\n                piece = \"<eos>\"\n\n            text = piece.encode(\"utf-8\")\n            score = 0.0\n            # Referencing the tokenizer Python implementation(https://huggingface.co/THUDM/chatglm3-6b/blob/main/tokenization_chatglm.py),\n            # it is only valid if it is less than tokenizer.tokenizer.sp_model.vocab_size()\n            if len(piece) != 0 and token_id < tokenizer.tokenizer.sp_model.vocab_size():\n                score = tokenizer.tokenizer.sp_model.get_score(token_id)\n\n            if token_id >= tokenizer.tokenizer.sp_model.vocab_size():\n                if piece in special_tokens:\n                    toktype = SentencePieceTokenTypes.CONTROL\n                elif len(piece) == 0:\n                    text = f\"[PAD{token_id}]\".encode(\"utf-8\")\n                    toktype = SentencePieceTokenTypes.UNUSED\n                else:\n                    toktype = SentencePieceTokenTypes.USER_DEFINED\n                tokens.append(text)\n                scores.append(score)\n                toktypes.append(toktype)\n                continue\n\n            toktype = SentencePieceTokenTypes.NORMAL\n            if tokenizer.tokenizer.sp_model.is_unknown(token_id):\n                toktype = SentencePieceTokenTypes.UNKNOWN\n            elif tokenizer.tokenizer.sp_model.is_control(token_id):\n                toktype = SentencePieceTokenTypes.CONTROL\n            elif tokenizer.tokenizer.sp_model.is_unused(token_id):\n                toktype = SentencePieceTokenTypes.UNUSED\n            elif tokenizer.tokenizer.sp_model.is_byte(token_id):\n                toktype = SentencePieceTokenTypes.BYTE\n\n            tokens.append(text)\n            scores.append(score)\n            toktypes.append(toktype)\n\n        self.gguf_writer.add_tokenizer_model(\"llama\")\n        # glm3 needs prefix and suffix formatted as:\n        # prompt = \"[gMASK]sop<|user|>\\n\" + prompt + \"<|assistant|>\"\n        self.gguf_writer.add_tokenizer_pre(\"chatglm-spm\")\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_scores(scores)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(self.dir_model, n_vocab=len(tokens))\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    @staticmethod\n    def token_bytes_to_string(b):\n        from transformers.models.gpt2.tokenization_gpt2 import bytes_to_unicode\n        byte_encoder = bytes_to_unicode()\n        return ''.join([byte_encoder[ord(char)] for char in b.decode('latin-1')])\n\n    @staticmethod\n    def bpe(mergeable_ranks: dict[bytes, int], token: bytes, max_rank: int | None = None) -> list[bytes]:\n        parts = [bytes([b]) for b in token]\n        while True:\n            min_idx = None\n            min_rank = None\n            for i, pair in enumerate(zip(parts[:-1], parts[1:])):\n                rank = mergeable_ranks.get(pair[0] + pair[1])\n                if rank is not None and (min_rank is None or rank < min_rank):\n                    min_idx = i\n                    min_rank = rank\n            if min_rank is None or (max_rank is not None and min_rank >= max_rank):\n                break\n            assert min_idx is not None\n            parts = parts[:min_idx] + [parts[min_idx] + parts[min_idx + 1]] + parts[min_idx + 2:]\n        return parts\n\n    def set_vocab(self):\n        if \"THUDM/chatglm3-6b\" in self.hparams.get(\"_name_or_path\", \"\"):\n            self.set_vocab_chatglm3()\n            return\n\n        dir_model = self.dir_model\n        hparams = self.hparams\n        tokens: list[str] = []\n        toktypes: list[int] = []\n\n        from transformers import AutoTokenizer\n        tokenizer = AutoTokenizer.from_pretrained(dir_model, trust_remote_code=True)\n        vocab_size = hparams[\"padded_vocab_size\"]\n        assert max(tokenizer.get_vocab().values()) < vocab_size\n\n        tokpre = self.get_vocab_base_pre(tokenizer)\n\n        merges = []\n        vocab = {}\n        mergeable_ranks = tokenizer.mergeable_ranks\n        for token, rank in mergeable_ranks.items():\n            vocab[ChatGLMModel.token_bytes_to_string(token)] = rank\n            if len(token) == 1:\n                continue\n            merged = ChatGLMModel.bpe(mergeable_ranks, token, max_rank=rank)\n            assert len(merged) >= 2 and len(merged) <= 7\n            merges.append(' '.join(map(ChatGLMModel.token_bytes_to_string, merged)))\n\n        # for this kind of tokenizer, added_vocab is not a subset of vocab, so they need to be combined\n        added_vocab = tokenizer.get_added_vocab()\n        reverse_vocab = {id_ : encoded_tok for encoded_tok, id_ in {**vocab, **added_vocab}.items()}\n\n        for i in range(vocab_size):\n            if i not in reverse_vocab:\n                tokens.append(f\"[PAD{i}]\")\n                toktypes.append(gguf.TokenType.UNUSED)\n            elif reverse_vocab[i] in added_vocab:\n                tokens.append(reverse_vocab[i])\n                if tokenizer.added_tokens_decoder[i].special:\n                    toktypes.append(gguf.TokenType.CONTROL)\n                else:\n                    toktypes.append(gguf.TokenType.USER_DEFINED)\n            else:\n                tokens.append(reverse_vocab[i])\n                toktypes.append(gguf.TokenType.NORMAL)\n\n        self.gguf_writer.add_tokenizer_model(\"gpt2\")\n        self.gguf_writer.add_tokenizer_pre(tokpre)\n        self.gguf_writer.add_token_list(tokens)\n        self.gguf_writer.add_token_types(toktypes)\n\n        special_vocab = gguf.SpecialVocab(dir_model, load_merges=False)\n        special_vocab.merges = merges\n        # only add special tokens when they were not already loaded from config.json\n        special_vocab._set_special_token(\"eos\", tokenizer.get_added_vocab()[\"<|endoftext|>\"])\n        special_vocab._set_special_token(\"eot\", tokenizer.get_added_vocab()[\"<|user|>\"])\n        # this one is usually not in config.json anyway\n        special_vocab._set_special_token(\"unk\", tokenizer.get_added_vocab()[\"<|endoftext|>\"])\n        special_vocab.add_to_gguf(self.gguf_writer)\n\n    def set_gguf_parameters(self):\n        n_embed = self.hparams.get(\"hidden_size\", self.hparams.get(\"n_embed\"))\n        n_head = self.hparams.get(\"n_head\", self.hparams.get(\"num_attention_heads\"))\n        n_head_kv = self.hparams.get(\"multi_query_group_num\", n_head)\n        self.gguf_writer.add_context_length(self.hparams.get(\"seq_length\", n_embed))\n        self.gguf_writer.add_embedding_length(n_embed)\n        self.gguf_writer.add_feed_forward_length(self.hparams.get(\"ffn_hidden_size\", 4 * n_embed))\n        self.gguf_writer.add_block_count(self.hparams[\"num_layers\"])\n        self.gguf_writer.add_head_count(n_head)\n        self.gguf_writer.add_head_count_kv(n_head_kv)\n        self.gguf_writer.add_layer_norm_rms_eps(self.hparams[\"layernorm_epsilon\"])\n        self.gguf_writer.add_file_type(self.ftype)\n        self.gguf_writer.add_rope_dimension_count(64)\n        self.gguf_writer.add_add_bos_token(False)\n        rope_freq = 10000\n        if \"rope_ratio\" in self.hparams:\n            rope_freq = rope_freq * self.hparams[\"rope_ratio\"]\n        self.gguf_writer.add_rope_freq_base(rope_freq)\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        del bid  # unused\n\n        if name.endswith(\".rotary_pos_emb.inv_freq\"):\n            return []\n\n        name = name.removeprefix(\"transformer.\")\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"NemotronForCausalLM\")\nclass NemotronModel(Model):\n    model_arch = gguf.MODEL_ARCH.NEMOTRON\n\n    def set_vocab(self):\n        self._set_vocab_sentencepiece()\n        self.gguf_writer.add_pad_token_id(0)\n        self.gguf_writer.add_unk_token_id(1)\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        hparams = self.hparams\n        self.gguf_writer.add_vocab_size(hparams[\"vocab_size\"])\n\n        f_norm_eps = self.find_hparam([\"layer_norm_eps\", \"layer_norm_epsilon\", \"norm_epsilon\", \"norm_eps\"])\n        self.gguf_writer.add_layer_norm_eps(f_norm_eps)\n\n        # * Partial RoPE\n        rot_pct = self.find_hparam([\"partial_rotary_factor\", \"rope_pct\", \"rope_percent\"])\n        n_embd = self.find_hparam([\"hidden_size\", \"n_embd\"])\n        n_head = self.find_hparam([\"num_attention_heads\", \"n_head\"])\n        self.gguf_writer.add_rope_dimension_count(int(rot_pct * n_embd) // n_head)\n\n        # * RopeScaling for Nemotron\n        if \"rope_scaling\" not in self.hparams or self.hparams[\"rope_scaling\"] is None:\n            self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.NONE)\n        else:\n            self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n            self.gguf_writer.add_rope_scaling_factor(self.hparams[\"factor\"])\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # * Adding +1 to LayerNorm's weights here to implement layernorm1p w/o changing anything on the GGML engine side\n        #   model.layers.{l}.input_layernorm.weight\n        #   model.layers.{l}.post_attention_layernorm.weight\n        #   model.norm.weight\n        if name.endswith(\"norm.weight\"):\n            data_torch = data_torch + 1\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n\n@Model.register(\"ExaoneForCausalLM\")\nclass ExaoneModel(Model):\n    model_arch = gguf.MODEL_ARCH.EXAONE\n\n    def set_gguf_parameters(self):\n        hparams = self.hparams\n\n        assert (hparams[\"activation_function\"] == \"silu\")\n\n        max_position_embeddings = hparams[\"max_position_embeddings\"]\n        embed_dim = hparams[\"hidden_size\"]\n        num_heads = hparams[\"num_attention_heads\"]\n        num_kv_heads = hparams.get(\"num_key_value_heads\", num_heads)\n        layer_norm_eps = hparams[\"layer_norm_epsilon\"]\n        intermediate_size = hparams[\"intermediate_size\"] if \"intermediate_size\" in hparams else 4 * embed_dim\n        num_layers = hparams[\"num_layers\"]\n        # ignore for now as EXAONE-3.0-7.8B-Instruct attentino_dropout is 0.0\n        # attention_dropout_rate = hparams[\"attention_dropout\"]\n        # ignore for now as EXAONE-3.0-7.8B-Instruct embed_dropout is 0.0\n        # embed_dropout_rate = hparams[\"embed_dropout\"]\n        self.gguf_writer.add_embedding_length(embed_dim)\n        self.gguf_writer.add_head_count(num_heads)\n        self.gguf_writer.add_head_count_kv(num_kv_heads)\n        self.gguf_writer.add_context_length(max_position_embeddings)\n        self.gguf_writer.add_layer_norm_rms_eps(layer_norm_eps)\n        self.gguf_writer.add_feed_forward_length(intermediate_size)\n        self.gguf_writer.add_block_count(num_layers)\n        self.gguf_writer.add_file_type(self.ftype)\n\n        if (rope_theta := self.hparams.get(\"rope_theta\")) is not None:\n            self.gguf_writer.add_rope_freq_base(rope_theta)\n        rotary_factor = self.find_hparam([\"partial_rotary_factor\", \"rope_pct\"], optional=True)\n        rotary_factor = rotary_factor if rotary_factor is not None else 1.0\n        self.gguf_writer.add_rope_dimension_count(int(rotary_factor * (hparams[\"hidden_size\"] // hparams[\"num_attention_heads\"])))\n        if hparams.get(\"rope_scaling\") is not None and \"factor\" in hparams[\"rope_scaling\"]:\n            if hparams[\"rope_scaling\"].get(\"type\") == \"linear\":\n                self.gguf_writer.add_rope_scaling_type(gguf.RopeScalingType.LINEAR)\n                self.gguf_writer.add_rope_scaling_factor(hparams[\"rope_scaling\"][\"factor\"])\n\n    def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n        if rope_scaling := self.find_hparam([\"rope_scaling\"], optional=True):\n            if rope_scaling.get(\"rope_type\", '').lower() == \"llama3\":\n                base = self.hparams.get(\"rope_theta\", 10000.0)\n                dim = self.hparams.get(\"head_dim\", self.hparams[\"hidden_size\"] // self.hparams[\"num_attention_heads\"])\n                freqs = 1.0 / (base ** (torch.arange(0, dim, 2, dtype=torch.float32) / dim))\n\n                factor = rope_scaling.get(\"factor\", 8.0)\n                low_freq_factor = rope_scaling.get(\"low_freq_factor\", 1.0)\n                high_freq_factor = rope_scaling.get(\"high_freq_factor\", 4.0)\n                old_context_len = self.hparams.get(\"original_max_position_embeddings\", 8192)\n\n                low_freq_wavelen = old_context_len / low_freq_factor\n                high_freq_wavelen = old_context_len / high_freq_factor\n                assert low_freq_wavelen != high_freq_wavelen\n\n                rope_factors = []\n                for freq in freqs:\n                    wavelen = 2 * math.pi / freq\n                    if wavelen < high_freq_wavelen:\n                        rope_factors.append(1)\n                    elif wavelen > low_freq_wavelen:\n                        rope_factors.append(factor)\n                    else:\n                        smooth = (old_context_len / wavelen - low_freq_factor) / (high_freq_factor - low_freq_factor)\n                        rope_factors.append(1 / ((1 - smooth) / factor + smooth))\n\n                yield (self.format_tensor_name(gguf.MODEL_TENSOR.ROPE_FREQS), torch.tensor(rope_factors, dtype=torch.float32))\n\n\n@Model.register(\"GraniteForCausalLM\")\nclass GraniteModel(LlamaModel):\n    \"\"\"Conversion for IBM's GraniteForCausalLM\"\"\"\n    model_arch = gguf.MODEL_ARCH.GRANITE\n\n    def set_gguf_parameters(self):\n        \"\"\"Granite uses standard llama parameters with the following differences:\n\n        - No head_dim support\n        - New multiplier params:\n            - attention_scale\n            - embedding_scale\n            - residual_scale\n        - logits_scaling\n        \"\"\"\n        if head_dim := self.hparams.pop(\"head_dim\", None):\n            logger.warning(\"Ignoring head_dim (%s) from config for Granite\", head_dim)\n        super().set_gguf_parameters()\n        # NOTE: Convert _multiplier params to _scale params for naming\n        #   consistency\n        if attention_scale := self.hparams.get(\"attention_multiplier\"):\n            self.gguf_writer.add_attention_scale(attention_scale)\n            logger.info(\"gguf: (granite) attention_scale = %s\", attention_scale)\n        if embedding_scale := self.hparams.get(\"embedding_multiplier\"):\n            self.gguf_writer.add_embedding_scale(embedding_scale)\n            logger.info(\"gguf: (granite) embedding_scale = %s\", embedding_scale)\n        if residual_scale := self.hparams.get(\"residual_multiplier\"):\n            self.gguf_writer.add_residual_scale(residual_scale)\n            logger.info(\"gguf: (granite) residual_scale = %s\", residual_scale)\n        if logits_scale := self.hparams.get(\"logits_scaling\"):\n            self.gguf_writer.add_logit_scale(logits_scale)\n            logger.info(\"gguf: (granite) logits_scale = %s\", logits_scale)\n\n\n@Model.register(\"GraniteMoeForCausalLM\")\nclass GraniteMoeModel(GraniteModel):\n    \"\"\"Conversion for IBM's GraniteMoeForCausalLM\"\"\"\n    model_arch = gguf.MODEL_ARCH.GRANITE_MOE\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        \"\"\"In modeling_granitemoe, the JetMoe implementation of parallel experts\n        is used. This essentially merges w1 and w3 into a single tensor with 2x\n        the hidden size that is then split during forward. To keep compatibility\n        with existing mixtral support, we pull them apart here.\n        \"\"\"\n\n        if name.endswith(\"block_sparse_moe.input_linear.weight\"):\n            ffn_dim = self.hparams[\"intermediate_size\"]\n            assert data_torch.shape[-2] == 2 * ffn_dim, \"Merged FFN tensor size must be 2 * intermediate_size\"\n            gate, up = data_torch[..., :ffn_dim, :], data_torch[..., ffn_dim:, :]\n            return [\n                (self.format_tensor_name(gguf.MODEL_TENSOR.FFN_GATE_EXP, bid), gate),\n                (self.format_tensor_name(gguf.MODEL_TENSOR.FFN_UP_EXP, bid), up),\n            ]\n\n        return super().modify_tensors(data_torch, name, bid)\n\n\n@Model.register(\"ChameleonForConditionalGeneration\")\n@Model.register(\"ChameleonForCausalLM\")  # obsolete\nclass ChameleonModel(Model):\n    model_arch = gguf.MODEL_ARCH.CHAMELEON\n\n    def set_gguf_parameters(self):\n        super().set_gguf_parameters()\n        self.gguf_writer.add_swin_norm(self.hparams.get(\"swin_norm\", False))\n\n    def set_vocab(self):\n        self._set_vocab_gpt2()\n\n    def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n        # ignore image tokenizer for now\n        # TODO: remove this once image support is implemented for Chameleon\n        if name.startswith(\"model.vqmodel\"):\n            return []\n\n        n_head = self.hparams[\"num_attention_heads\"]\n        n_kv_head = self.hparams.get(\"num_key_value_heads\")\n        hidden_dim = self.hparams.get(\"hidden_size\")\n\n        if name.endswith((\"q_proj.weight\", \"q_proj.bias\")):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_head)\n        if name.endswith((\"k_proj.weight\", \"k_proj.bias\")):\n            data_torch = LlamaModel.permute(data_torch, n_head, n_kv_head)\n        if name.endswith((\"q_norm.weight\", \"q_norm.bias\")):\n            data_torch = ChameleonModel._reverse_hf_permute(data_torch, n_head, hidden_dim)\n        if name.endswith((\"k_norm.weight\", \"k_norm.bias\")):\n            data_torch = ChameleonModel._reverse_hf_permute(data_torch, n_kv_head, hidden_dim)\n\n        return [(self.map_tensor_name(name), data_torch)]\n\n    # see: https://github.com/huggingface/transformers/blob/72fb02c47dbbe1999ae105319f24631cad6e2e00/src/transformers/models/chameleon/convert_chameleon_weights_to_hf.py#L176-L203\n    @staticmethod\n    def _reverse_hf_permute(data_torch, n_heads, hidden_dim):\n        head_dim = hidden_dim // n_heads\n        data_torch = data_torch[0].view(2, head_dim // 2).t().reshape(1, -1)\n        data_torch = data_torch.repeat_interleave(n_heads, 0)\n        return data_torch\n\n\n###### CONVERSION LOGIC ######\n\n\n# tree of lazy tensors\nclass LazyTorchTensor(gguf.LazyBase):\n    _tensor_type = torch.Tensor\n    # to keep the type-checker happy\n    dtype: torch.dtype\n    shape: torch.Size\n\n    # only used when converting a torch.Tensor to a np.ndarray\n    _dtype_map: dict[torch.dtype, type] = {\n        torch.float16: np.float16,\n        torch.float32: np.float32,\n    }\n\n    # used for safetensors slices\n    # ref: https://github.com/huggingface/safetensors/blob/079781fd0dc455ba0fe851e2b4507c33d0c0d407/bindings/python/src/lib.rs#L1046\n    # TODO: uncomment U64, U32, and U16, ref: https://github.com/pytorch/pytorch/issues/58734\n    _dtype_str_map: dict[str, torch.dtype] = {\n        \"F64\": torch.float64,\n        \"F32\": torch.float32,\n        \"BF16\": torch.bfloat16,\n        \"F16\": torch.float16,\n        # \"U64\": torch.uint64,\n        \"I64\": torch.int64,\n        # \"U32\": torch.uint32,\n        \"I32\": torch.int32,\n        # \"U16\": torch.uint16,\n        \"I16\": torch.int16,\n        \"U8\": torch.uint8,\n        \"I8\": torch.int8,\n        \"BOOL\": torch.bool,\n        \"F8_E4M3\": torch.float8_e4m3fn,\n        \"F8_E5M2\": torch.float8_e5m2,\n    }\n\n    def numpy(self) -> gguf.LazyNumpyTensor:\n        dtype = self._dtype_map[self.dtype]\n        return gguf.LazyNumpyTensor(\n            meta=gguf.LazyNumpyTensor.meta_with_dtype_and_shape(dtype, self.shape),\n            args=(self,),\n            func=(lambda s: s.numpy())\n        )\n\n    @classmethod\n    def meta_with_dtype_and_shape(cls, dtype: torch.dtype, shape: tuple[int, ...]) -> Tensor:\n        return torch.empty(size=shape, dtype=dtype, device=\"meta\")\n\n    @classmethod\n    def from_safetensors_slice(cls, st_slice: Any) -> Tensor:\n        dtype = cls._dtype_str_map[st_slice.get_dtype()]\n        shape: tuple[int, ...] = tuple(st_slice.get_shape())\n        lazy = cls(meta=cls.meta_with_dtype_and_shape(dtype, shape), args=(st_slice,), func=lambda s: s[:])\n        return cast(torch.Tensor, lazy)\n\n    @classmethod\n    def __torch_function__(cls, func, types, args=(), kwargs=None):\n        del types  # unused\n\n        if kwargs is None:\n            kwargs = {}\n\n        if func is torch.Tensor.numpy:\n            return args[0].numpy()\n\n        return cls._wrap_fn(func)(*args, **kwargs)\n\n\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(\n        description=\"Convert a huggingface model to a GGML compatible file\")\n    parser.add_argument(\n        \"--vocab-only\", action=\"store_true\",\n        help=\"extract only the vocab\",\n    )\n    parser.add_argument(\n        \"--outfile\", type=Path,\n        help=\"path to write to; default: based on input. {ftype} will be replaced by the outtype.\",\n    )\n    parser.add_argument(\n        \"--outtype\", type=str, choices=[\"f32\", \"f16\", \"bf16\", \"q8_0\", \"tq1_0\", \"tq2_0\", \"auto\"], default=\"f16\",\n        help=\"output format - use f32 for float32, f16 for float16, bf16 for bfloat16, q8_0 for Q8_0, tq1_0 or tq2_0 for ternary, and auto for the highest-fidelity 16-bit float type depending on the first loaded tensor type\",\n    )\n    parser.add_argument(\n        \"--bigendian\", action=\"store_true\",\n        help=\"model is executed on big endian machine\",\n    )\n    parser.add_argument(\n        \"model\", type=Path,\n        help=\"directory containing model file\",\n        nargs=\"?\",\n    )\n    parser.add_argument(\n        \"--use-temp-file\", action=\"store_true\",\n        help=\"use the tempfile library while processing (helpful when running out of memory, process killed)\",\n    )\n    parser.add_argument(\n        \"--no-lazy\", action=\"store_true\",\n        help=\"use more RAM by computing all outputs before writing (use in case lazy evaluation is broken)\",\n    )\n    parser.add_argument(\n        \"--model-name\", type=str, default=None,\n        help=\"name of the model\",\n    )\n    parser.add_argument(\n        \"--verbose\", action=\"store_true\",\n        help=\"increase output verbosity\",\n    )\n    parser.add_argument(\n        \"--split-max-tensors\", type=int, default=0,\n        help=\"max tensors in each split\",\n    )\n    parser.add_argument(\n        \"--split-max-size\", type=str, default=\"0\",\n        help=\"max size per split N(M|G)\",\n    )\n    parser.add_argument(\n        \"--dry-run\", action=\"store_true\",\n        help=\"only print out a split plan and exit, without writing any new files\",\n    )\n    parser.add_argument(\n        \"--no-tensor-first-split\", action=\"store_true\",\n        help=\"do not add tensors to the first split (disabled by default)\"\n    )\n    parser.add_argument(\n        \"--metadata\", type=Path,\n        help=\"Specify the path for an authorship metadata override file\"\n    )\n    parser.add_argument(\n        \"--print-supported-models\", action=\"store_true\",\n        help=\"Print the supported models\"\n    )\n\n    args = parser.parse_args()\n    if not args.print_supported_models and args.model is None:\n        parser.error(\"the following arguments are required: model\")\n    return args\n\n\ndef split_str_to_n_bytes(split_str: str) -> int:\n    if split_str.endswith(\"K\"):\n        n = int(split_str[:-1]) * 1000\n    elif split_str.endswith(\"M\"):\n        n = int(split_str[:-1]) * 1000 * 1000\n    elif split_str.endswith(\"G\"):\n        n = int(split_str[:-1]) * 1000 * 1000 * 1000\n    elif split_str.isnumeric():\n        n = int(split_str)\n    else:\n        raise ValueError(f\"Invalid split size: {split_str}, must be a number, optionally followed by K, M, or G\")\n\n    if n < 0:\n        raise ValueError(f\"Invalid split size: {split_str}, must be positive\")\n\n    return n\n\n\ndef main() -> None:\n    args = parse_args()\n\n    if args.print_supported_models:\n        logger.error(\"Supported models:\")\n        Model.print_registered_models()\n        sys.exit(0)\n\n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        logging.basicConfig(level=logging.INFO)\n\n    dir_model = args.model\n\n    if not dir_model.is_dir():\n        logger.error(f'Error: {args.model} is not a directory')\n        sys.exit(1)\n\n    ftype_map: dict[str, gguf.LlamaFileType] = {\n        \"f32\": gguf.LlamaFileType.ALL_F32,\n        \"f16\": gguf.LlamaFileType.MOSTLY_F16,\n        \"bf16\": gguf.LlamaFileType.MOSTLY_BF16,\n        \"q8_0\": gguf.LlamaFileType.MOSTLY_Q8_0,\n        \"tq1_0\": gguf.LlamaFileType.MOSTLY_TQ1_0,\n        \"tq2_0\": gguf.LlamaFileType.MOSTLY_TQ2_0,\n        \"auto\": gguf.LlamaFileType.GUESSED,\n    }\n\n    is_split = args.split_max_tensors > 0 or args.split_max_size != \"0\"\n    if args.use_temp_file and is_split:\n        logger.error(\"Error: Cannot use temp file when splitting\")\n        sys.exit(1)\n\n    if args.outfile is not None:\n        fname_out = args.outfile\n    else:\n        fname_out = dir_model\n\n    logger.info(f\"Loading model: {dir_model.name}\")\n\n    hparams = Model.load_hparams(dir_model)\n\n    with torch.inference_mode():\n        output_type = ftype_map[args.outtype]\n        model_architecture = hparams[\"architectures\"][0]\n\n        try:\n            model_class = Model.from_model_architecture(model_architecture)\n        except NotImplementedError:\n            logger.error(f\"Model {model_architecture} is not supported\")\n            sys.exit(1)\n\n        model_instance = model_class(dir_model=dir_model, ftype=output_type, fname_out=fname_out,\n                                     is_big_endian=args.bigendian, use_temp_file=args.use_temp_file,\n                                     eager=args.no_lazy,\n                                     metadata_override=args.metadata, model_name=args.model_name,\n                                     split_max_tensors=args.split_max_tensors,\n                                     split_max_size=split_str_to_n_bytes(args.split_max_size), dry_run=args.dry_run,\n                                     small_first_shard=args.no_tensor_first_split)\n\n        if args.vocab_only:\n            logger.info(\"Exporting model vocab...\")\n            model_instance.write_vocab()\n            logger.info(f\"Model vocab successfully exported to {model_instance.fname_out}\")\n        else:\n            logger.info(\"Exporting model...\")\n            model_instance.write()\n            out_path = f\"{model_instance.fname_out.parent}{os.sep}\" if is_split else model_instance.fname_out\n            logger.info(f\"Model successfully exported to {out_path}\")\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "convert_hf_to_gguf_update.py",
          "type": "blob",
          "size": 16.716796875,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# This script downloads the tokenizer models of the specified models from Huggingface and\n# generates the get_vocab_base_pre() function for convert_hf_to_gguf.py\n#\n# This is necessary in order to analyze the type of pre-tokenizer used by the model and\n# provide the necessary information to llama.cpp via the GGUF header in order to implement\n# the same pre-tokenizer.\n#\n# ref: https://github.com/ggerganov/llama.cpp/pull/6920\n#\n# Instructions:\n#\n# - Add a new model to the \"models\" list\n# - Run the script with your huggingface token:\n#\n#   python3 convert_hf_to_gguf_update.py <huggingface_token>\n#\n# - The convert_hf_to_gguf.py script will have had its get_vocab_base_pre() function updated\n# - Update llama.cpp with the new pre-tokenizer if necessary\n#\n# TODO: generate tokenizer tests for llama.cpp\n#\n\nimport logging\nimport os\nimport pathlib\nimport re\n\nimport requests\nimport sys\nimport json\nimport shutil\n\nfrom hashlib import sha256\nfrom enum import IntEnum, auto\nfrom transformers import AutoTokenizer\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"convert_hf_to_gguf_update\")\nsess = requests.Session()\n\n\nclass TOKENIZER_TYPE(IntEnum):\n    SPM = auto()\n    BPE = auto()\n    WPM = auto()\n    UGM = auto()\n\n\n# TODO: this string has to exercise as much pre-tokenizer functionality as possible\n#       will be updated with time - contributions welcome\nCHK_TXT = '\\n \\n\\n \\n\\n\\n \\t \\t\\t \\t\\n  \\n   \\n    \\n     \\n🚀 (normal) 😶‍🌫️ (multiple emojis concatenated) ✅ 🦙🦙 3 33 333 3333 33333 333333 3333333 33333333 3.3 3..3 3...3 កាន់តែពិសេសអាច😁 ?我想在apple工作1314151天～ ------======= нещо на Български \\'\\'\\'\\'\\'\\'```````\\\"\\\"\\\"\\\"......!!!!!!?????? I\\'ve been \\'told he\\'s there, \\'RE you sure? \\'M not sure I\\'ll make it, \\'D you like some tea? We\\'Ve a\\'lL'\n\nif len(sys.argv) == 2:\n    token = sys.argv[1]\n    if not token.startswith(\"hf_\"):\n        logger.info(\"Huggingface token seems invalid\")\n        logger.info(\"Usage: python convert_hf_to_gguf_update.py <huggingface_token>\")\n        sys.exit(1)\nelse:\n    logger.info(\"Usage: python convert_hf_to_gguf_update.py <huggingface_token>\")\n    sys.exit(1)\n\n# TODO: add models here, base models preferred\nmodels = [\n    {\"name\": \"llama-spm\",      \"tokt\": TOKENIZER_TYPE.SPM, \"repo\": \"https://huggingface.co/meta-llama/Llama-2-7b-hf\", },\n    {\"name\": \"llama-bpe\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/meta-llama/Meta-Llama-3-8B\", },\n    {\"name\": \"phi-3\",          \"tokt\": TOKENIZER_TYPE.SPM, \"repo\": \"https://huggingface.co/microsoft/Phi-3-mini-4k-instruct\", },\n    {\"name\": \"deepseek-llm\",   \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/deepseek-ai/deepseek-llm-7b-base\", },\n    {\"name\": \"deepseek-coder\", \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/deepseek-ai/deepseek-coder-6.7b-base\", },\n    {\"name\": \"falcon\",         \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/tiiuae/falcon-7b\", },\n    {\"name\": \"bert-bge\",       \"tokt\": TOKENIZER_TYPE.WPM, \"repo\": \"https://huggingface.co/BAAI/bge-small-en-v1.5\", },\n    {\"name\": \"falcon3\",        \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/tiiuae/Falcon3-7B-Base\", },\n    {\"name\": \"bert-bge-large\", \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/BAAI/bge-large-zh-v1.5\", },\n    {\"name\": \"mpt\",            \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/mosaicml/mpt-7b\", },\n    {\"name\": \"starcoder\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/bigcode/starcoder2-3b\", },\n    {\"name\": \"gpt-2\",          \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/openai-community/gpt2\", },\n    {\"name\": \"stablelm2\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/stabilityai/stablelm-2-zephyr-1_6b\", },\n    {\"name\": \"refact\",         \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/smallcloudai/Refact-1_6-base\", },\n    {\"name\": \"command-r\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/CohereForAI/c4ai-command-r-v01\", },\n    {\"name\": \"qwen2\",          \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/Qwen/Qwen1.5-7B\", },\n    {\"name\": \"olmo\",           \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/allenai/OLMo-1.7-7B-hf\", },\n    {\"name\": \"dbrx\",           \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/databricks/dbrx-base\", },\n    {\"name\": \"jina-v1-en\",     \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/jinaai/jina-reranker-v1-tiny-en\", },\n    {\"name\": \"jina-v2-en\",     \"tokt\": TOKENIZER_TYPE.WPM, \"repo\": \"https://huggingface.co/jinaai/jina-embeddings-v2-base-en\", }, # WPM!\n    {\"name\": \"jina-v2-es\",     \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/jinaai/jina-embeddings-v2-base-es\", },\n    {\"name\": \"jina-v2-de\",     \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/jinaai/jina-embeddings-v2-base-de\", },\n    {\"name\": \"smaug-bpe\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/abacusai/Smaug-Llama-3-70B-Instruct\", },\n    {\"name\": \"poro-chat\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/LumiOpen/Poro-34B-chat\", },\n    {\"name\": \"jina-v2-code\",   \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/jinaai/jina-embeddings-v2-base-code\", },\n    {\"name\": \"viking\",         \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/LumiOpen/Viking-7B\", }, # Also used for Viking 13B and 33B\n    {\"name\": \"gemma\",          \"tokt\": TOKENIZER_TYPE.SPM, \"repo\": \"https://huggingface.co/google/gemma-2b\", },\n    {\"name\": \"gemma-2\",        \"tokt\": TOKENIZER_TYPE.SPM, \"repo\": \"https://huggingface.co/google/gemma-2-9b\", },\n    {\"name\": \"jais\",           \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/core42/jais-13b\", },\n    {\"name\": \"t5\",             \"tokt\": TOKENIZER_TYPE.UGM, \"repo\": \"https://huggingface.co/google-t5/t5-small\", },\n    {\"name\": \"codeshell\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/WisdomShell/CodeShell-7B\", },\n    {\"name\": \"tekken\",         \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/mistralai/Mistral-Nemo-Base-2407\", },\n    {\"name\": \"smollm\",         \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/HuggingFaceTB/SmolLM-135M\", },\n    {'name': \"bloom\",          \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/bigscience/bloom\", },\n    {'name': \"gpt3-finnish\",   \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/TurkuNLP/gpt3-finnish-small\", },\n    {\"name\": \"exaone\",         \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct\", },\n    {\"name\": \"phi-2\",          \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/microsoft/phi-2\", },\n    {\"name\": \"chameleon\",      \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/facebook/chameleon-7b\", },\n    {\"name\": \"minerva-7b\",     \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/sapienzanlp/Minerva-7B-base-v1.0\", },\n    {\"name\": \"roberta-bpe\",    \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/sentence-transformers/stsb-roberta-base\"},\n    {\"name\": \"gigachat\",       \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/ai-sage/GigaChat-20B-A3B-instruct\"},\n    {\"name\": \"megrez\",         \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/Infinigence/Megrez-3B-Instruct\"},\n    {\"name\": \"deepseek-v3\",    \"tokt\": TOKENIZER_TYPE.BPE, \"repo\": \"https://huggingface.co/deepseek-ai/DeepSeek-V3\"},\n]\n\n\ndef download_file_with_auth(url, token, save_path):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = sess.get(url, headers=headers)\n    response.raise_for_status()\n    os.makedirs(os.path.dirname(save_path), exist_ok=True)\n    with open(save_path, 'wb') as downloaded_file:\n        downloaded_file.write(response.content)\n    logger.info(f\"File {save_path} downloaded successfully\")\n\n\ndef download_model(model):\n    name = model[\"name\"]\n    repo = model[\"repo\"]\n    tokt = model[\"tokt\"]\n\n    os.makedirs(f\"models/tokenizers/{name}\", exist_ok=True)\n\n    files = [\"config.json\", \"tokenizer.json\", \"tokenizer_config.json\"]\n\n    if tokt == TOKENIZER_TYPE.SPM:\n        files.append(\"tokenizer.model\")\n\n    if tokt == TOKENIZER_TYPE.UGM:\n        files.append(\"spiece.model\")\n\n    if os.path.isdir(repo):\n        # If repo is a path on the file system, copy the directory\n        for file in files:\n            src_path = os.path.join(repo, file)\n            dst_path = f\"models/tokenizers/{name}/{file}\"\n            if os.path.isfile(dst_path):\n                logger.info(f\"{name}: File {dst_path} already exists - skipping\")\n                continue\n            if os.path.isfile(src_path):\n                shutil.copy2(src_path, dst_path)\n                logger.info(f\"{name}: Copied {src_path} to {dst_path}\")\n            else:\n                logger.warning(f\"{name}: Source file {src_path} does not exist\")\n    else:\n        # If repo is a URL, download the files\n        for file in files:\n            save_path = f\"models/tokenizers/{name}/{file}\"\n            if os.path.isfile(save_path):\n                logger.info(f\"{name}: File {save_path} already exists - skipping\")\n                continue\n            download_file_with_auth(f\"{repo}/resolve/main/{file}\", token, save_path)\n\n\nfor model in models:\n    try:\n        download_model(model)\n    except Exception as e:\n        logger.error(f\"Failed to download model {model['name']}. Error: {e}\")\n\n\n# generate the source code for the convert_hf_to_gguf.py:get_vocab_base_pre() function:\n\nsrc_ifs = \"\"\nfor model in models:\n    name = model[\"name\"]\n    tokt = model[\"tokt\"]\n\n    if tokt == TOKENIZER_TYPE.SPM or tokt == TOKENIZER_TYPE.UGM:\n        continue\n\n    # Skip if the tokenizer folder does not exist or there are other download issues previously\n    if not os.path.exists(f\"models/tokenizers/{name}\"):\n        logger.warning(f\"Directory for tokenizer {name} not found. Skipping...\")\n        continue\n\n    # create the tokenizer\n    try:\n        if name == \"t5\":\n            tokenizer = AutoTokenizer.from_pretrained(f\"models/tokenizers/{name}\", use_fast=False)\n        else:\n            tokenizer = AutoTokenizer.from_pretrained(f\"models/tokenizers/{name}\")\n    except OSError as e:\n        logger.error(f\"Error loading tokenizer for model {name}. The model may not exist or is not accessible with the provided token. Error: {e}\")\n        continue  # Skip to the next model if the tokenizer can't be loaded\n\n    chktok = tokenizer.encode(CHK_TXT)\n    chkhsh = sha256(str(chktok).encode()).hexdigest()\n\n    logger.info(f\"model: {name}\")\n    logger.info(f\"tokt: {tokt}\")\n    logger.info(f\"repo: {model['repo']}\")\n    logger.info(f\"chktok: {chktok}\")\n    logger.info(f\"chkhsh: {chkhsh}\")\n\n    # print the \"pre_tokenizer\" content from the tokenizer.json\n    with open(f\"models/tokenizers/{name}/tokenizer.json\", \"r\", encoding=\"utf-8\") as f:\n        cfg = json.load(f)\n        normalizer = cfg[\"normalizer\"]\n        logger.info(\"normalizer: \" + json.dumps(normalizer, indent=4))\n        pre_tokenizer = cfg[\"pre_tokenizer\"]\n        logger.info(\"pre_tokenizer: \" + json.dumps(pre_tokenizer, indent=4))\n        if \"ignore_merges\" in cfg[\"model\"]:\n            logger.info(\"ignore_merges: \" + json.dumps(cfg[\"model\"][\"ignore_merges\"], indent=4))\n\n    logger.info(\"\")\n\n    src_ifs += f\"        if chkhsh == \\\"{chkhsh}\\\":\\n\"\n    src_ifs += f\"            # ref: {model['repo']}\\n\"\n    src_ifs += f\"            res = \\\"{name}\\\"\\n\"\n\nsrc_func = f\"\"\"\n    def get_vocab_base_pre(self, tokenizer) -> str:\n        # encoding this string and hashing the resulting tokens would (hopefully) give us a unique identifier that\n        # is specific for the BPE pre-tokenizer used by the model\n        # we will use this unique identifier to write a \"tokenizer.ggml.pre\" entry in the GGUF file which we can\n        # use in llama.cpp to implement the same pre-tokenizer\n\n        chktxt = {repr(CHK_TXT)}\n\n        chktok = tokenizer.encode(chktxt)\n        chkhsh = sha256(str(chktok).encode()).hexdigest()\n\n        logger.debug(f\"chktok: {{chktok}}\")\n        logger.debug(f\"chkhsh: {{chkhsh}}\")\n\n        res = None\n\n        # NOTE: if you get an error here, you need to update the convert_hf_to_gguf_update.py script\n        #       or pull the latest version of the model from Huggingface\n        #       don't edit the hashes manually!\n{src_ifs}\n        if res is None:\n            logger.warning(\"\\\\n\")\n            logger.warning(\"**************************************************************************************\")\n            logger.warning(\"** WARNING: The BPE pre-tokenizer was not recognized!\")\n            logger.warning(\"**          There are 2 possible reasons for this:\")\n            logger.warning(\"**          - the model has not been added to convert_hf_to_gguf_update.py yet\")\n            logger.warning(\"**          - the pre-tokenization config has changed upstream\")\n            logger.warning(\"**          Check your model files and convert_hf_to_gguf_update.py and update them accordingly.\")\n            logger.warning(\"** ref:     https://github.com/ggerganov/llama.cpp/pull/6920\")\n            logger.warning(\"**\")\n            logger.warning(f\"** chkhsh:  {{chkhsh}}\")\n            logger.warning(\"**************************************************************************************\")\n            logger.warning(\"\\\\n\")\n            raise NotImplementedError(\"BPE pre-tokenizer was not recognized - update get_vocab_base_pre()\")\n\n        logger.debug(f\"tokenizer.ggml.pre: {{repr(res)}}\")\n        logger.debug(f\"chkhsh: {{chkhsh}}\")\n\n        return res\n\"\"\"\n\nconvert_py_pth = pathlib.Path(\"convert_hf_to_gguf.py\")\nconvert_py = convert_py_pth.read_text(encoding=\"utf-8\")\nconvert_py = re.sub(\n    r\"(# Marker: Start get_vocab_base_pre)(.+?)( +# Marker: End get_vocab_base_pre)\",\n    lambda m: m.group(1) + src_func + m.group(3),\n    convert_py,\n    flags=re.DOTALL | re.MULTILINE,\n)\n\nconvert_py_pth.write_text(convert_py, encoding=\"utf-8\")\n\nlogger.info(\"+++ convert_hf_to_gguf.py was updated\")\n\n# generate tests for each tokenizer model\n\ntests = [\n    \"ied 4 ½ months\",\n    \"Führer\",\n    \"\",\n    \" \",\n    \"  \",\n    \"   \",\n    \"\\t\",\n    \"\\n\",\n    \"\\n\\n\",\n    \"\\n\\n\\n\",\n    \"\\t\\n\",\n    \"Hello world\",\n    \" Hello world\",\n    \"Hello World\",\n    \" Hello World\",\n    \" Hello World!\",\n    \"Hello, world!\",\n    \" Hello, world!\",\n    \" this is 🦙.cpp\",\n    \"w048 7tuijk dsdfhu\",\n    \"нещо на Български\",\n    \"កាន់តែពិសេសអាចខលចេញ\",\n    \"🚀 (normal) 😶‍🌫️ (multiple emojis concatenated) ✅ (only emoji that has its own token)\",\n    \"Hello\",\n    \" Hello\",\n    \"  Hello\",\n    \"   Hello\",\n    \"    Hello\",\n    \"    Hello\\n    Hello\",\n    \" (\",\n    \"\\n =\",\n    \"' era\",\n    \"Hello, y'all! How are you 😁 ?我想在apple工作1314151天～\",\n    \"!!!!!!\",\n    \"3\",\n    \"33\",\n    \"333\",\n    \"3333\",\n    \"33333\",\n    \"333333\",\n    \"3333333\",\n    \"33333333\",\n    \"333333333\",\n    \"Cửa Việt\", # llama-bpe fails on this\n    \" discards\",\n    CHK_TXT,\n]\n\n# write the tests to ./models/ggml-vocab-{name}.gguf.inp\n# the format is:\n#\n# test0\n# __ggml_vocab_test__\n# test1\n# __ggml_vocab_test__\n# ...\n#\n\n# with each model, encode all tests and write the results in ./models/ggml-vocab-{name}.gguf.out\n# for each test, write the resulting tokens on a separate line\n\nfor model in models:\n    name = model[\"name\"]\n    tokt = model[\"tokt\"]\n\n    # Skip if the tokenizer folder does not exist or there are other download issues previously\n    if not os.path.exists(f\"models/tokenizers/{name}\"):\n        logger.warning(f\"Directory for tokenizer {name} not found. Skipping...\")\n        continue\n\n    # create the tokenizer\n    try:\n        if name == \"t5\":\n            tokenizer = AutoTokenizer.from_pretrained(f\"models/tokenizers/{name}\", use_fast=False)\n        else:\n            tokenizer = AutoTokenizer.from_pretrained(f\"models/tokenizers/{name}\")\n    except OSError as e:\n        logger.error(f\"Failed to load tokenizer for model {name}. Error: {e}\")\n        continue  # Skip this model and continue with the next one in the loop\n\n    with open(f\"models/ggml-vocab-{name}.gguf.inp\", \"w\", encoding=\"utf-8\") as f:\n        for text in tests:\n            f.write(f\"{text}\")\n            f.write(\"\\n__ggml_vocab_test__\\n\")\n\n    with open(f\"models/ggml-vocab-{name}.gguf.out\", \"w\") as f:\n        for text in tests:\n            res = tokenizer.encode(text, add_special_tokens=False)\n            for r in res:\n                f.write(f\" {r}\")\n            f.write(\"\\n\")\n\n    logger.info(f\"Tests for {name} written in ./models/ggml-vocab-{name}.gguf.*\")\n\n# generate commands for creating vocab files\n\nlogger.info(\"\\nRun the following commands to generate the vocab files for testing:\\n\")\n\nfor model in models:\n    name = model[\"name\"]\n\n    print(f\"python3 convert_hf_to_gguf.py models/tokenizers/{name}/ --outfile models/ggml-vocab-{name}.gguf --vocab-only\") # noqa: NP100\n\nlogger.info(\"\\n\")\n"
        },
        {
          "name": "convert_llama_ggml_to_gguf.py",
          "type": "blob",
          "size": 18.658203125,
          "content": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport logging\nimport argparse\nimport os\nimport struct\nimport sys\nfrom enum import IntEnum\nfrom pathlib import Path\n\nimport numpy as np\n\nif 'NO_LOCAL_GGUF' not in os.environ:\n    sys.path.insert(1, str(Path(__file__).parent / 'gguf-py'))\nimport gguf\n\nlogger = logging.getLogger(\"ggml-to-gguf\")\n\n\nclass GGMLFormat(IntEnum):\n    GGML = 0\n    GGMF = 1\n    GGJT = 2\n\n\nclass GGMLFType(IntEnum):\n    ALL_F32              = 0\n    MOSTLY_F16           = 1\n    MOSTLY_Q4_0          = 2\n    MOSTLY_Q4_1          = 3\n    MOSTLY_Q4_1_SOME_F16 = 4\n    MOSTLY_Q8_0          = 7\n    MOSTLY_Q5_0          = 8\n    MOSTLY_Q5_1          = 9\n    MOSTLY_Q2_K          = 10\n    MOSTLY_Q3_K_S        = 11\n    MOSTLY_Q3_K_M        = 12\n    MOSTLY_Q3_K_L        = 13\n    MOSTLY_Q4_K_S        = 14\n    MOSTLY_Q4_K_M        = 15\n    MOSTLY_Q5_K_S        = 16\n    MOSTLY_Q5_K_M        = 17\n    MOSTLY_Q6_K          = 18\n\n\nclass Hyperparameters:\n    def __init__(self):\n        self.n_vocab = self.n_embd = self.n_mult = self.n_head = 0\n        self.n_layer = self.n_rot = self.n_ff = 0\n        self.ftype = GGMLFType.ALL_F32\n\n    def set_n_ff(self, model):\n        ff_tensor_idx = model.tensor_map.get(b'layers.0.feed_forward.w1.weight')\n        assert ff_tensor_idx is not None, 'Missing layer 0 FF tensor'\n        ff_tensor = model.tensors[ff_tensor_idx]\n        self.n_ff = ff_tensor.dims[1]\n\n    def load(self, data, offset):\n        (\n            self.n_vocab,\n            self.n_embd,\n            self.n_mult,\n            self.n_head,\n            self.n_layer,\n            self.n_rot,\n            ftype,\n        ) = struct.unpack('<7I', data[offset:offset + (4 * 7)])\n        try:\n            self.ftype = GGMLFType(ftype)\n        except ValueError:\n            raise ValueError(f'Invalid ftype {ftype}')\n        return 4 * 7\n\n    def __str__(self):\n        return f'<Hyperparameters: n_vocab={self.n_vocab}, n_embd={self.n_embd}, n_mult={self.n_mult}, n_head={self.n_head}, n_layer={self.n_layer}, n_rot={self.n_rot}, n_ff={self.n_ff}, ftype={self.ftype.name}>'\n\n\nclass Vocab:\n    def __init__(self, load_scores = True):\n        self.items = []\n        self.load_scores = load_scores\n\n    def load(self, data, offset, n_vocab):\n        orig_offset = offset\n        for _ in range(n_vocab):\n            itemlen = struct.unpack('<I', data[offset:offset + 4])[0]\n            assert itemlen < 4096, 'Absurd vocab item length'\n            offset += 4\n            item_text = bytes(data[offset:offset + itemlen])\n            offset += itemlen\n            if self.load_scores:\n                item_score = struct.unpack('<f', data[offset:offset + 4])[0]\n                offset += 4\n            else:\n                item_score = 0.0\n            self.items.append((item_text, item_score))\n        return offset - orig_offset\n\n\nclass Tensor:\n    def __init__(self, use_padding = True):\n        self.name = None\n        self.dims: tuple[int, ...] = ()\n        self.dtype = None\n        self.start_offset = 0\n        self.len_bytes = np.int64(0)\n        self.use_padding = use_padding\n\n    def load(self, data, offset):\n        orig_offset = offset\n        (n_dims, name_len, dtype) = struct.unpack('<3I', data[offset:offset + 12])\n        assert n_dims >= 0 and n_dims <= 4, f'Invalid tensor dimensions {n_dims}'\n        assert name_len < 4096, 'Absurd tensor name length'\n        quant = gguf.GGML_QUANT_SIZES.get(dtype)\n        assert quant is not None, 'Unknown tensor type'\n        (blksize, tysize) = quant\n        offset += 12\n        self.dtype= gguf.GGMLQuantizationType(dtype)\n        self.dims = struct.unpack(f'<{n_dims}I', data[offset:offset + (4 * n_dims)])\n        offset += 4 * n_dims\n        self.name = bytes(data[offset:offset + name_len])\n        offset += name_len\n        pad = ((offset + 31) & ~31) - offset if self.use_padding else 0\n        offset += pad\n        n_elems = np.prod(self.dims)\n        n_bytes = np.int64(np.int64(n_elems) * np.int64(tysize)) // np.int64(blksize)\n        self.start_offset = offset\n        self.len_bytes = n_bytes\n        offset += n_bytes\n        return offset - orig_offset\n\n\nclass GGMLModel:\n\n    file_format: GGMLFormat\n    format_version: int\n\n    def __init__(self):\n        self.hyperparameters = None\n        self.vocab = None\n        self.tensor_map = {}\n        self.tensors = []\n\n    def validate_header(self, data, offset):\n        magic = bytes(data[offset:offset + 4])\n        if magic == b'GGUF':\n            raise ValueError('File is already in GGUF format.')\n        if magic == b'lmgg':\n            self.file_format = GGMLFormat.GGML\n            self.format_version = 1\n            return 4\n        version = struct.unpack('<I', data[offset + 4:offset + 8])[0]\n        if magic == b'fmgg':\n            if version != 1:\n                raise ValueError(f'Cannot handle unexpected GGMF file version {version}')\n            self.file_format = GGMLFormat.GGMF\n            self.format_version = version\n            return 8\n        if magic == b'tjgg':\n            if version < 1 or version > 3:\n                raise ValueError(f'Cannot handle unexpected GGJT file version {version}')\n            self.file_format = GGMLFormat.GGJT\n            self.format_version = version\n            return 8\n        raise ValueError(f\"Unexpected file magic {magic!r}! This doesn't look like a GGML format file.\")\n\n    def validate_conversion(self, ftype):\n        err = ''\n        if (self.file_format < GGMLFormat.GGJT or self.format_version < 2):\n            if ftype not in (GGMLFType.ALL_F32, GGMLFType.MOSTLY_F16):\n                err = 'Quantizations changed in GGJTv2. Can only convert unquantized GGML files older than GGJTv2.'\n        elif (self.file_format == GGMLFormat.GGJT and self.format_version == 2):\n            if ftype in (GGMLFType.MOSTLY_Q4_0, GGMLFType.MOSTLY_Q4_1,\n                         GGMLFType.MOSTLY_Q4_1_SOME_F16, GGMLFType.MOSTLY_Q8_0):\n                err = 'Q4 and Q8 quantizations changed in GGJTv3.'\n        if len(err) > 0:\n            raise ValueError(f'{err} Sorry, your {self.file_format.name}v{self.format_version} file of type {ftype.name} is not eligible for conversion.')\n\n    def load(self, data, offset):\n        offset += self.validate_header(data, offset)\n        hp = Hyperparameters()\n        offset += hp.load(data, offset)\n        logger.info(f'* File format: {self.file_format.name}v{self.format_version} with ftype {hp.ftype.name}')\n        self.validate_conversion(hp.ftype)\n        vocab = Vocab(load_scores = self.file_format > GGMLFormat.GGML)\n        offset += vocab.load(data, offset, hp.n_vocab)\n        tensors: list[Tensor] = []\n        tensor_map = {}\n        while offset < len(data):\n            tensor = Tensor(use_padding = self.file_format > GGMLFormat.GGMF)\n            offset += tensor.load(data, offset)\n            tensor_map[tensor.name] = len(tensors)\n            tensors.append(tensor)\n        self.hyperparameters = hp\n        self.vocab = vocab\n        self.tensors = tensors\n        self.tensor_map = tensor_map\n        hp.set_n_ff(self)\n        return offset\n\n\nclass GGMLToGGUF:\n    def __init__(self, ggml_model, data, cfg, params_override = None, vocab_override = None, special_vocab = None):\n        hp = ggml_model.hyperparameters\n        self.model = ggml_model\n        self.data = data\n        self.cfg = cfg\n        self.params_override = params_override\n        self.vocab_override = vocab_override\n        self.special_vocab = special_vocab\n        if params_override is not None:\n            n_kv_head = params_override.n_head_kv\n        else:\n            if cfg.gqa == 1:\n                n_kv_head = hp.n_head\n            else:\n                gqa = float(cfg.gqa)\n                n_kv_head = None\n                for x in range(1, 256):\n                    if float(hp.n_head) / float(x) == gqa:\n                        n_kv_head = x\n                assert n_kv_head is not None, \"Couldn't determine n_kv_head from GQA param\"\n                logger.info(f'- Guessed n_kv_head = {n_kv_head} based on GQA {cfg.gqa}')\n        self.n_kv_head = n_kv_head\n        self.name_map = gguf.get_tensor_name_map(gguf.MODEL_ARCH.LLAMA, ggml_model.hyperparameters.n_layer)\n\n    def save(self):\n        logger.info('* Preparing to save GGUF file')\n        gguf_writer = gguf.GGUFWriter(\n            self.cfg.output,\n            gguf.MODEL_ARCH_NAMES[gguf.MODEL_ARCH.LLAMA],\n            use_temp_file = False)\n        self.add_params(gguf_writer)\n        self.add_vocab(gguf_writer)\n        if self.special_vocab is not None:\n            self.special_vocab.add_to_gguf(gguf_writer)\n        self.add_tensors(gguf_writer)\n        logger.info(\"    gguf: write header\")\n        gguf_writer.write_header_to_file()\n        logger.info(\"    gguf: write metadata\")\n        gguf_writer.write_kv_data_to_file()\n        logger.info(\"    gguf: write tensors\")\n        gguf_writer.write_tensors_to_file()\n        gguf_writer.close()\n\n    def add_params(self, gguf_writer):\n        hp = self.model.hyperparameters\n        cfg = self.cfg\n        if cfg.desc is not None:\n            desc = cfg.desc\n        else:\n            desc = f'converted from legacy {self.model.file_format.name}v{self.model.format_version} {hp.ftype.name} format'\n        try:\n            # Filenames aren't necessarily valid UTF8.\n            name = cfg.name if cfg.name is not None else cfg.input.name\n        except UnicodeDecodeError:\n            name = None\n        logger.info('* Adding model parameters and KV items')\n        if name is not None:\n            gguf_writer.add_name(name)\n        gguf_writer.add_description(desc)\n        gguf_writer.add_file_type(int(hp.ftype))\n        if self.params_override is not None:\n            po = self.params_override\n            assert po.n_embd == hp.n_embd, 'Model hyperparams mismatch'\n            assert po.n_layer == hp.n_layer, 'Model hyperparams mismatch'\n            assert po.n_head == hp.n_head, 'Model hyperparams mismatch'\n            gguf_writer.add_context_length      (po.n_ctx)\n            gguf_writer.add_embedding_length    (po.n_embd)\n            gguf_writer.add_block_count         (po.n_layer)\n            gguf_writer.add_feed_forward_length (po.n_ff)\n            gguf_writer.add_rope_dimension_count(po.n_embd // po.n_head)\n            gguf_writer.add_head_count          (po.n_head)\n            gguf_writer.add_head_count_kv       (po.n_head_kv)\n            gguf_writer.add_layer_norm_rms_eps  (po.f_norm_eps)\n            return\n        gguf_writer.add_context_length(cfg.context_length)\n        gguf_writer.add_embedding_length(hp.n_embd)\n        gguf_writer.add_block_count(hp.n_layer)\n        gguf_writer.add_feed_forward_length(hp.n_ff)\n        gguf_writer.add_rope_dimension_count(hp.n_embd // hp.n_head)\n        gguf_writer.add_head_count(hp.n_head)\n        gguf_writer.add_head_count_kv(self.n_kv_head)\n        gguf_writer.add_layer_norm_rms_eps(float(cfg.eps))\n\n    def add_vocab(self, gguf_writer):\n        hp = self.model.hyperparameters\n        gguf_writer.add_tokenizer_model('llama')\n        gguf_writer.add_tokenizer_pre('default')\n        tokens = []\n        scores = []\n        toktypes = []\n        if self.vocab_override is not None:\n            vo = self.vocab_override\n            logger.info('* Adding vocab item(s)')\n            for (_, (vbytes, score, ttype)) in enumerate(vo.all_tokens()):\n                tokens.append(vbytes)\n                scores.append(score)\n                toktypes.append(ttype)\n            assert len(tokens) == hp.n_vocab, \\\n                f'Override vocab has a different number of items than hyperparameters - override = {len(tokens)} but n_vocab={hp.n_vocab}'\n            gguf_writer.add_token_list(tokens)\n            gguf_writer.add_token_scores(scores)\n            if len(toktypes) > 0:\n                gguf_writer.add_token_types(toktypes)\n            return\n        logger.info(f'* Adding {hp.n_vocab} vocab item(s)')\n        assert len(self.model.vocab.items) >= 3, 'Cannot handle unexpectedly short model vocab'\n        for (tokid, (vbytes, vscore)) in enumerate(self.model.vocab.items):\n            tt = 1 # Normal\n            # Special handling for UNK, BOS, EOS tokens.\n            if tokid <= 2:\n                if tokid == 0:\n                    vbytes = b'<unk>'\n                    tt = 2\n                elif tokid == 1:\n                    vbytes = b'<s>'\n                    tt = 3\n                else:\n                    vbytes = b'</s>'\n                    tt = 3\n            elif len(vbytes) == 0:\n                tt = 3 # Control\n            elif tokid >= 3 and tokid <= 258 and len(vbytes) == 1:\n                vbytes = bytes(f'<0x{vbytes[0]:02X}>', encoding = 'UTF-8')\n                tt = 6 # Byte\n            else:\n                vbytes = vbytes.replace(b' ', b'\\xe2\\x96\\x81')\n            toktypes.append(tt)\n            tokens.append(vbytes)\n            scores.append(vscore)\n        gguf_writer.add_token_list(tokens)\n        gguf_writer.add_token_scores(scores)\n        gguf_writer.add_token_types(toktypes)\n        gguf_writer.add_unk_token_id(0)\n        gguf_writer.add_bos_token_id(1)\n        gguf_writer.add_eos_token_id(2)\n\n    def add_tensors(self, gguf_writer):\n        tensor_map = self.name_map\n        data = self.data\n        logger.info(f'* Adding {len(self.model.tensors)} tensor(s)')\n        for tensor in self.model.tensors:\n            name = str(tensor.name, 'UTF-8')\n            mapped_name = tensor_map.get_name(name, try_suffixes = (\".weight\", \".bias\"))\n            assert mapped_name is not None, f'Bad name {name}'\n            tempdims = list(tensor.dims[:])\n            if len(tempdims) > 1:\n                temp = tempdims[1]\n                tempdims[1] = tempdims[0]\n                tempdims[0] = temp\n            gguf_writer.add_tensor(\n                mapped_name,\n                data[tensor.start_offset:tensor.start_offset + tensor.len_bytes],\n                raw_shape = tempdims,\n                raw_dtype = tensor.dtype)\n\n\ndef handle_metadata(cfg, hp):\n    import examples.convert_legacy_llama as convert\n\n    assert cfg.model_metadata_dir.is_dir(), 'Metadata dir is not a directory'\n    hf_config_path   = cfg.model_metadata_dir / \"config.json\"\n    orig_config_path = cfg.model_metadata_dir / \"params.json\"\n    # We pass a fake model here. \"original\" mode will check the shapes of some\n    # tensors if information is missing in the .json file: other than that, the\n    # model data isn't used so this should be safe (at least for now).\n    fakemodel = {\n        'tok_embeddings.weight': convert.LazyTensor.__new__(convert.LazyTensor),\n        'layers.0.feed_forward.w1.weight': convert.LazyTensor.__new__(convert.LazyTensor),\n    }\n    fakemodel['tok_embeddings.weight'].shape = [hp.n_vocab]\n    fakemodel['layers.0.feed_forward.w1.weight'].shape = [hp.n_ff]\n    if hf_config_path.exists():\n        params = convert.Params.loadHFTransformerJson(fakemodel, hf_config_path)\n    elif orig_config_path.exists():\n        params = convert.Params.loadOriginalParamsJson(fakemodel, orig_config_path)\n    else:\n        raise ValueError('Unable to load metadata')\n    vocab_path = Path(cfg.vocab_dir if cfg.vocab_dir is not None else cfg.model_metadata_dir)\n    vocab_factory = convert.VocabFactory(vocab_path)\n    vocab, special_vocab = vocab_factory.load_vocab(cfg.vocabtype.split(\",\"), cfg.model_metadata_dir)\n    convert.check_vocab_size(params, vocab)\n    return params, vocab, special_vocab\n\n\ndef handle_args():\n    parser = argparse.ArgumentParser(description = 'Convert GGML models to GGUF')\n    parser.add_argument('--input', '-i', type = Path, required = True,\n                        help = 'Input GGMLv3 filename')\n    parser.add_argument('--output', '-o', type = Path, required = True,\n                        help ='Output GGUF filename')\n    parser.add_argument('--name',\n                        help = 'Set model name')\n    parser.add_argument('--desc',\n                        help = 'Set model description')\n    parser.add_argument('--gqa', type = int, default = 1,\n                        help = 'grouped-query attention factor (use 8 for LLaMA2 70B)')\n    parser.add_argument('--eps', default = '5.0e-06',\n                        help = 'RMS norm eps: Use 1e-6 for LLaMA1 and OpenLLaMA, use 1e-5 for LLaMA2')\n    parser.add_argument('--context-length', '-c', type=int, default = 2048,\n                        help = 'Default max context length: LLaMA1 is typically 2048, LLaMA2 is typically 4096')\n    parser.add_argument('--model-metadata-dir', '-m', type = Path,\n                        help ='Load HuggingFace/.pth vocab and metadata from the specified directory')\n    parser.add_argument(\"--vocab-dir\", type=Path,\n                        help=\"directory containing tokenizer.model, if separate from model file - only meaningful with --model-metadata-dir\")\n    parser.add_argument(\"--vocabtype\", default=\"spm,hfft\",\n                        help=\"vocab format - only meaningful with --model-metadata-dir and/or --vocab-dir (default: spm,hfft)\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"increase output verbosity\")\n    return parser.parse_args()\n\n\ndef main():\n    cfg = handle_args()\n    logging.basicConfig(level=logging.DEBUG if cfg.verbose else logging.INFO)\n    logger.info(f'* Using config: {cfg}')\n    logger.warning('=== WARNING === Be aware that this conversion script is best-effort. Use a native GGUF model if possible. === WARNING ===')\n    if cfg.model_metadata_dir is None and (cfg.gqa == 1 or cfg.eps == '5.0e-06'):\n        logger.info('- Note: If converting LLaMA2, specifying \"--eps 1e-5\" is required. 70B models also need \"--gqa 8\".')\n    data = np.memmap(cfg.input, mode = 'r')\n    model = GGMLModel()\n    logger.info('* Scanning GGML input file')\n    offset = model.load(data, 0)  # noqa\n    logger.info(f'* GGML model hyperparameters: {model.hyperparameters}')\n    vocab_override = None\n    params_override = None\n    special_vocab = None\n    if cfg.model_metadata_dir is not None:\n        (params_override, vocab_override, special_vocab) = handle_metadata(cfg, model.hyperparameters)\n        logger.info('!! Note: When overriding params the --gqa, --eps and --context-length options are ignored.')\n        logger.info(f'* Overriding params: {params_override}')\n        logger.info(f'* Overriding vocab: {vocab_override}')\n        logger.info(f'* Special vocab: {special_vocab}')\n    else:\n        logger.warning('\\n=== WARNING === Special tokens may not be converted correctly. Use --model-metadata-dir if possible === WARNING ===\\n')\n        if model.file_format == GGMLFormat.GGML:\n            logger.info('! This is a very old GGML file that does not contain vocab scores. Strongly recommend using model metadata!')\n    converter = GGMLToGGUF(\n        model, data, cfg,\n        params_override = params_override,\n        vocab_override = vocab_override,\n        special_vocab = special_vocab\n    )\n    converter.save()\n    logger.info(f'* Successful completion. Output saved to: {cfg.output}')\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "convert_lora_to_gguf.py",
          "type": "blob",
          "size": 18.177734375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nimport logging\nimport argparse\nimport os\nimport sys\nimport json\nfrom math import prod\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Iterable, Iterator, Sequence, SupportsIndex, cast\nfrom transformers import AutoConfig\n\nimport torch\n\nif TYPE_CHECKING:\n    from torch import Tensor\n\nif 'NO_LOCAL_GGUF' not in os.environ:\n    sys.path.insert(1, str(Path(__file__).parent / 'gguf-py'))\nimport gguf\n\n# reuse model definitions from convert_hf_to_gguf.py\nfrom convert_hf_to_gguf import LazyTorchTensor, Model\n\nlogger = logging.getLogger(\"lora-to-gguf\")\n\n\n@dataclass\nclass PartialLoraTensor:\n    A: Tensor | None = None\n    B: Tensor | None = None\n\n\n# magic to support tensor shape modifications and splitting\nclass LoraTorchTensor:\n    _lora_A: Tensor  # (n_rank, row_size)\n    _lora_B: Tensor  # (col_size, n_rank)\n    _rank: int\n\n    def __init__(self, A: Tensor, B: Tensor):\n        assert len(A.shape) == len(B.shape)\n        assert A.shape[-2] == B.shape[-1]\n        if A.dtype != B.dtype:\n            A = A.to(torch.float32)\n            B = B.to(torch.float32)\n        self._lora_A = A\n        self._lora_B = B\n        self._rank = B.shape[-1]\n\n    def get_lora_A_B(self) -> tuple[Tensor, Tensor]:\n        return (self._lora_A, self._lora_B)\n\n    def __getitem__(\n        self,\n        indices: (\n            SupportsIndex\n            | slice\n            | tuple[SupportsIndex | slice | Tensor, ...]  # TODO: add ellipsis in the type signature\n        ),\n    ) -> LoraTorchTensor:\n        shape = self.shape\n        if isinstance(indices, SupportsIndex):\n            if len(shape) > 2:\n                return LoraTorchTensor(self._lora_A[indices], self._lora_B[indices])\n            else:\n                raise NotImplementedError  # can't return a vector\n        elif isinstance(indices, slice):\n            if len(shape) > 2:\n                return LoraTorchTensor(self._lora_A[indices], self._lora_B[indices])\n            else:\n                return LoraTorchTensor(self._lora_A, self._lora_B[indices])\n        elif isinstance(indices, tuple):\n            assert len(indices) > 0\n            if indices[-1] is Ellipsis:\n                return self[indices[:-1]]\n            # expand ellipsis\n            indices = tuple(\n                u\n                for v in (\n                    (\n                        (slice(None, None) for _ in range(len(indices) - 1))\n                        if i is Ellipsis\n                        else (i,)\n                    )\n                    for i in indices\n                )\n                for u in v\n            )\n\n            if len(indices) < len(shape):\n                indices = (*indices, *(slice(None, None) for _ in range(len(indices), len(shape))))\n\n            # TODO: make sure this is correct\n            indices_A = (\n                *(\n                    (\n                        j.__index__() % self._lora_A.shape[i]\n                        if isinstance(j, SupportsIndex)\n                        else slice(None, None)\n                    )\n                    for i, j in enumerate(indices[:-2])\n                ),\n                slice(None, None),\n                indices[-1],\n            )\n            indices_B = indices[:-1]\n            return LoraTorchTensor(self._lora_A[indices_A], self._lora_B[indices_B])\n        else:\n            raise NotImplementedError  # unknown indice type\n\n    @property\n    def dtype(self) -> torch.dtype:\n        assert self._lora_A.dtype == self._lora_B.dtype\n        return self._lora_A.dtype\n\n    @property\n    def shape(self) -> tuple[int, ...]:\n        assert len(self._lora_A.shape) == len(self._lora_B.shape)\n        return (*self._lora_B.shape[:-1], self._lora_A.shape[-1])\n\n    def size(self, dim=None):\n        assert dim is None\n        return self.shape\n\n    def reshape(self, *shape: int | tuple[int, ...]) -> LoraTorchTensor:\n        if isinstance(shape[0], tuple):\n            new_shape: tuple[int, ...] = shape[0]\n        else:\n            new_shape = cast(tuple[int, ...], shape)\n        orig_shape = self.shape\n        if len(new_shape) < 2:\n            raise NotImplementedError  # can't become a vector\n\n        # expand -1 in the shape\n        if any(dim == -1 for dim in new_shape):\n            n_elems = prod(orig_shape)\n            n_new_elems = prod(dim if dim != -1 else 1 for dim in new_shape)\n            assert n_elems % n_new_elems == 0\n            new_shape = (*(dim if dim != -1 else n_elems // n_new_elems for dim in new_shape),)\n\n        if new_shape[-1] != orig_shape[-1]:\n            raise NotImplementedError  # can't reshape the row size trivially\n\n        shape_A = (*(1 for _ in new_shape[:-2]), self._rank, orig_shape[-1])\n        shape_B = (*new_shape[:-1], self._rank)\n        return LoraTorchTensor(\n            self._lora_A.reshape(shape_A),\n            self._lora_B.reshape(shape_B),\n        )\n\n    def reshape_as(self, other: Tensor) -> LoraTorchTensor:\n        return self.reshape(*other.shape)\n\n    def view(self, *size: int) -> LoraTorchTensor:\n        return self.reshape(*size)\n\n    def permute(self, *dims: int) -> LoraTorchTensor:\n        shape = self.shape\n        dims = tuple(dim - len(shape) if dim >= 0 else dim for dim in dims)\n        if dims[-1] == -1:\n            # TODO: support higher dimensional A shapes bigger than 1\n            assert all(dim == 1 for dim in self._lora_A.shape[:-2])\n            return LoraTorchTensor(self._lora_A, self._lora_B.permute(*dims))\n        if len(shape) == 2 and dims[-1] == -2 and dims[-2] == -1:\n            return LoraTorchTensor(self._lora_B.permute(*dims), self._lora_A.permute(*dims))\n        else:\n            # TODO: compose the above two\n            raise NotImplementedError\n\n    def transpose(self, dim0: int, dim1: int) -> LoraTorchTensor:\n        shape = self.shape\n        dims = [i for i in range(len(shape))]\n        dims[dim0], dims[dim1] = dims[dim1], dims[dim0]\n        return self.permute(*dims)\n\n    def swapaxes(self, axis0: int, axis1: int) -> LoraTorchTensor:\n        return self.transpose(axis0, axis1)\n\n    def to(self, *args, **kwargs):\n        return LoraTorchTensor(self._lora_A.to(*args, **kwargs), self._lora_B.to(*args, **kwargs))\n\n    @classmethod\n    def __torch_function__(cls, func: Callable, types, args=(), kwargs=None):\n        del types  # unused\n\n        if kwargs is None:\n            kwargs = {}\n\n        if func is torch.permute:\n            return type(args[0]).permute(*args, **kwargs)\n        elif func is torch.reshape:\n            return type(args[0]).reshape(*args, **kwargs)\n        elif func is torch.stack:\n            assert isinstance(args[0], Sequence)\n            dim = kwargs.get(\"dim\", 0)\n            assert dim == 0\n            return LoraTorchTensor(\n                torch.stack([a._lora_A for a in args[0]], dim),\n                torch.stack([b._lora_B for b in args[0]], dim),\n            )\n        elif func is torch.cat:\n            assert isinstance(args[0], Sequence)\n            dim = kwargs.get(\"dim\", 0)\n            assert dim == 0\n            if len(args[0][0].shape) > 2:\n                return LoraTorchTensor(\n                    torch.cat([a._lora_A for a in args[0]], dim),\n                    torch.cat([b._lora_B for b in args[0]], dim),\n                )\n            elif all(torch.equal(args[0][0]._lora_A, t._lora_A) for t in args[0][1:]):\n                return LoraTorchTensor(\n                    args[0][0]._lora_A,\n                    torch.cat([b._lora_B for b in args[0]], dim),\n                )\n            else:\n                raise NotImplementedError\n        else:\n            raise NotImplementedError\n\n\ndef get_base_tensor_name(lora_tensor_name: str) -> str:\n    base_name = lora_tensor_name.replace(\"base_model.model.\", \"\")\n    base_name = base_name.replace(\".lora_A.weight\", \".weight\")\n    base_name = base_name.replace(\".lora_B.weight\", \".weight\")\n    # models produced by mergekit-extract-lora have token embeddings in the adapter\n    base_name = base_name.replace(\".lora_embedding_A\", \".weight\")\n    base_name = base_name.replace(\".lora_embedding_B\", \".weight\")\n    return base_name\n\n\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(\n        description=\"Convert a Hugging Face PEFT LoRA adapter to a GGUF file\")\n    parser.add_argument(\n        \"--outfile\", type=Path,\n        help=\"path to write to; default: based on input. {ftype} will be replaced by the outtype.\",\n    )\n    parser.add_argument(\n        \"--outtype\", type=str, choices=[\"f32\", \"f16\", \"bf16\", \"q8_0\", \"auto\"], default=\"f16\",\n        help=\"output format - use f32 for float32, f16 for float16, bf16 for bfloat16, q8_0 for Q8_0, auto for the highest-fidelity 16-bit float type depending on the first loaded tensor type\",\n    )\n    parser.add_argument(\n        \"--bigendian\", action=\"store_true\",\n        help=\"model is executed on big endian machine\",\n    )\n    parser.add_argument(\n        \"--no-lazy\", action=\"store_true\",\n        help=\"use more RAM by computing all outputs before writing (use in case lazy evaluation is broken)\",\n    )\n    parser.add_argument(\n        \"--verbose\", action=\"store_true\",\n        help=\"increase output verbosity\",\n    )\n    parser.add_argument(\n        \"--dry-run\", action=\"store_true\",\n        help=\"only print out what will be done, without writing any new files\",\n    )\n    parser.add_argument(\n        \"--base\", type=Path,\n        help=\"directory containing Hugging Face model config files (config.json, tokenizer.json) for the base model that the adapter is based on - only config is needed, actual model weights are not required. If base model is unspecified, it will be loaded from Hugging Face hub based on the adapter config\",\n    )\n    parser.add_argument(\n        \"--base-model-id\", type=str,\n        help=\"the model ID of the base model, if it is not available locally or in the adapter config. If specified, it will ignore --base and load the base model config from the Hugging Face hub (Example: 'meta-llama/Llama-3.2-1B-Instruct')\",\n    )\n    parser.add_argument(\n        \"lora_path\", type=Path,\n        help=\"directory containing Hugging Face PEFT LoRA config (adapter_model.json) and weights (adapter_model.safetensors or adapter_model.bin)\",\n    )\n\n    return parser.parse_args()\n\n\ndef load_hparams_from_hf(hf_model_id: str) -> dict[str, Any]:\n    # normally, adapter does not come with base model config, we need to load it from AutoConfig\n    config = AutoConfig.from_pretrained(hf_model_id)\n    return config.to_dict()\n\n\nif __name__ == '__main__':\n    args = parse_args()\n    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)\n\n    ftype_map: dict[str, gguf.LlamaFileType] = {\n        \"f32\": gguf.LlamaFileType.ALL_F32,\n        \"f16\": gguf.LlamaFileType.MOSTLY_F16,\n        \"bf16\": gguf.LlamaFileType.MOSTLY_BF16,\n        \"q8_0\": gguf.LlamaFileType.MOSTLY_Q8_0,\n        \"auto\": gguf.LlamaFileType.GUESSED,\n    }\n\n    ftype = ftype_map[args.outtype]\n\n    dir_base_model: Path | None = args.base\n    dir_lora: Path = args.lora_path\n    base_model_id: str | None = args.base_model_id\n    lora_config = dir_lora / \"adapter_config.json\"\n    input_model = dir_lora / \"adapter_model.safetensors\"\n\n    if args.outfile is not None:\n        fname_out = args.outfile\n    else:\n        # output in the same directory as the model by default\n        fname_out = dir_lora\n\n    if os.path.exists(input_model):\n        # lazy import load_file only if lora is in safetensors format.\n        from safetensors.torch import load_file\n\n        lora_model = load_file(input_model, device=\"cpu\")\n    else:\n        input_model = os.path.join(dir_lora, \"adapter_model.bin\")\n        lora_model = torch.load(input_model, map_location=\"cpu\", weights_only=True)\n\n    # load LoRA config\n    with open(lora_config, \"r\") as f:\n        lparams: dict[str, Any] = json.load(f)\n\n    # load base model\n    if base_model_id is not None:\n        logger.info(f\"Loading base model from Hugging Face: {base_model_id}\")\n        hparams = load_hparams_from_hf(base_model_id)\n    elif dir_base_model is None:\n        if \"base_model_name_or_path\" in lparams:\n            model_id = lparams[\"base_model_name_or_path\"]\n            logger.info(f\"Loading base model from Hugging Face: {model_id}\")\n            try:\n                hparams = load_hparams_from_hf(model_id)\n            except OSError as e:\n                logger.error(f\"Failed to load base model config: {e}\")\n                logger.error(\"Please try downloading the base model and add its path to --base\")\n                sys.exit(1)\n        else:\n            logger.error(\"'base_model_name_or_path' is not found in adapter_config.json\")\n            logger.error(\"Base model config is required. Please download the base model and add its path to --base\")\n            sys.exit(1)\n    else:\n        logger.info(f\"Loading base model: {dir_base_model.name}\")\n        hparams = Model.load_hparams(dir_base_model)\n\n    with torch.inference_mode():\n        try:\n            model_class = Model.from_model_architecture(hparams[\"architectures\"][0])\n        except NotImplementedError:\n            logger.error(f\"Model {hparams['architectures'][0]} is not supported\")\n            sys.exit(1)\n\n        class LoraModel(model_class):\n            model_arch = model_class.model_arch\n\n            lora_alpha: float\n\n            def __init__(self, *args, dir_lora_model: Path, lora_alpha: float, **kwargs):\n\n                super().__init__(*args, **kwargs)\n\n                self.dir_model_card = dir_lora_model\n                self.lora_alpha = float(lora_alpha)\n\n            def set_vocab(self):\n                pass\n\n            def set_type(self):\n                self.gguf_writer.add_type(gguf.GGUFType.ADAPTER)\n                self.gguf_writer.add_string(gguf.Keys.Adapter.TYPE, \"lora\")\n\n            def set_gguf_parameters(self):\n                self.gguf_writer.add_float32(gguf.Keys.Adapter.LORA_ALPHA, self.lora_alpha)\n\n            def generate_extra_tensors(self) -> Iterable[tuple[str, Tensor]]:\n                # Never add extra tensors (e.g. rope_freqs) for LoRA adapters\n                return ()\n\n            def get_tensors(self) -> Iterator[tuple[str, Tensor]]:\n                tensor_map: dict[str, PartialLoraTensor] = {}\n\n                for name, tensor in lora_model.items():\n                    if self.lazy:\n                        tensor = LazyTorchTensor.from_eager(tensor)\n                    base_name = get_base_tensor_name(name)\n                    # note: mergekit-extract-lora also adds token embeddings to the adapter\n                    is_lora_a = \".lora_A.weight\" in name or \".lora_embedding_A\" in name\n                    is_lora_b = \".lora_B.weight\" in name or \".lora_embedding_B\" in name\n                    if not is_lora_a and not is_lora_b:\n                        if \".base_layer.weight\" in name:\n                            continue\n                        # mergekit-extract-lora add these layernorm to the adapter, we need to keep them\n                        if \"_layernorm\" in name or \".norm\" in name:\n                            yield (base_name, tensor)\n                            continue\n                        logger.error(f\"Unexpected name '{name}': Not a lora_A or lora_B tensor\")\n                        if \".embed_tokens.weight\" in name or \".lm_head.weight\" in name:\n                            logger.error(\"Embeddings is present in the adapter. This can be due to new tokens added during fine tuning\")\n                            logger.error(\"Please refer to https://github.com/ggerganov/llama.cpp/pull/9948\")\n                        sys.exit(1)\n\n                    if base_name in tensor_map:\n                        if is_lora_a:\n                            tensor_map[base_name].A = tensor\n                        else:\n                            tensor_map[base_name].B = tensor\n                    else:\n                        if is_lora_a:\n                            tensor_map[base_name] = PartialLoraTensor(A=tensor)\n                        else:\n                            tensor_map[base_name] = PartialLoraTensor(B=tensor)\n\n                for name, tensor in tensor_map.items():\n                    assert tensor.A is not None\n                    assert tensor.B is not None\n                    yield (name, cast(torch.Tensor, LoraTorchTensor(tensor.A, tensor.B)))\n\n            def modify_tensors(self, data_torch: Tensor, name: str, bid: int | None) -> Iterable[tuple[str, Tensor]]:\n                dest = list(super().modify_tensors(data_torch, name, bid))\n                # some archs may have the same tensor for lm_head and output (tie word embeddings)\n                # in this case, adapters targeting lm_head will fail when using llama-export-lora\n                # therefore, we ignore them for now\n                # see: https://github.com/ggerganov/llama.cpp/issues/9065\n                if name == \"lm_head.weight\" and len(dest) == 0:\n                    raise ValueError(\"lm_head is present in adapter, but is ignored in base model\")\n                for dest_name, dest_data in dest:\n                    # mergekit-extract-lora add these layernorm to the adapter\n                    if \"_norm\" in dest_name:\n                        assert dest_data.dim() == 1\n                        yield (dest_name, dest_data)\n                        continue\n\n                    # otherwise, we must get the lora_A and lora_B tensors\n                    assert isinstance(dest_data, LoraTorchTensor)\n                    lora_a, lora_b = dest_data.get_lora_A_B()\n\n                    # note: mergekit-extract-lora flip and transpose A and B\n                    # here we only need to transpose token_embd.lora_a, see llm_build_inp_embd()\n                    if \"token_embd.weight\" in dest_name:\n                        lora_a = lora_a.T\n\n                    yield (dest_name + \".lora_a\", lora_a)\n                    yield (dest_name + \".lora_b\", lora_b)\n\n        alpha: float = lparams[\"lora_alpha\"]\n\n        model_instance = LoraModel(\n            dir_base_model,\n            ftype,\n            fname_out,\n            is_big_endian=args.bigendian,\n            use_temp_file=False,\n            eager=args.no_lazy,\n            dry_run=args.dry_run,\n            dir_lora_model=dir_lora,\n            lora_alpha=alpha,\n            hparams=hparams,\n        )\n\n        logger.info(\"Exporting model...\")\n        model_instance.write()\n        logger.info(f\"Model successfully exported to {model_instance.fname_out}\")\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 1.51953125,
          "content": "{\n  \"nodes\": {\n    \"flake-parts\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib\"\n      },\n      \"locked\": {\n        \"lastModified\": 1730504689,\n        \"narHash\": \"sha256-hgmguH29K2fvs9szpq2r3pz2/8cJd2LPS+b4tfNFCwE=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"506278e768c2a08bec68eb62932193e341f55c90\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1732014248,\n        \"narHash\": \"sha256-y/MEyuJ5oBWrWAic/14LaIr/u5E0wRVzyYsouYY3W6w=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"23e89b7da85c3640bbc2173fe04f4bd114342367\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib\": {\n      \"locked\": {\n        \"lastModified\": 1730504152,\n        \"narHash\": \"sha256-lXvH/vOfb4aGYyvFmZK/HlsNsr/0CVWlwYvo2rxJk3s=\",\n        \"type\": \"tarball\",\n        \"url\": \"https://github.com/NixOS/nixpkgs/archive/cc2f28000298e1269cea6612cd06ec9979dd5d7f.tar.gz\"\n      },\n      \"original\": {\n        \"type\": \"tarball\",\n        \"url\": \"https://github.com/NixOS/nixpkgs/archive/cc2f28000298e1269cea6612cd06ec9979dd5d7f.tar.gz\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts\",\n        \"nixpkgs\": \"nixpkgs\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 7.2939453125,
          "content": "# The flake interface to llama.cpp's Nix expressions. The flake is used as a\n# more discoverable entry-point, as well as a way to pin the dependencies and\n# expose default outputs, including the outputs built by the CI.\n\n# For more serious applications involving some kind of customization  you may\n# want to consider consuming the overlay, or instantiating `llamaPackages`\n# directly:\n#\n# ```nix\n# pkgs.callPackage ${llama-cpp-root}/.devops/nix/scope.nix { }`\n# ```\n\n# Cf. https://jade.fyi/blog/flakes-arent-real/ for a more detailed exposition\n# of the relation between Nix and the Nix Flakes.\n{\n  description = \"Port of Facebook's LLaMA model in C/C++\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    flake-parts.url = \"github:hercules-ci/flake-parts\";\n  };\n\n  # There's an optional binary cache available. The details are below, but they're commented out.\n  #\n  # Why? The terrible experience of being prompted to accept them on every single Nix command run.\n  # Plus, there are warnings shown about not being a trusted user on a default Nix install\n  # if you *do* say yes to the prompts.\n  #\n  # This experience makes having `nixConfig` in a flake a persistent UX problem.\n  #\n  # To make use of the binary cache, please add the relevant settings to your `nix.conf`.\n  # It's located at `/etc/nix/nix.conf` on non-NixOS systems. On NixOS, adjust the `nix.settings`\n  # option in your NixOS configuration to add `extra-substituters` and `extra-trusted-public-keys`,\n  # as shown below.\n  #\n  # ```\n  # nixConfig = {\n  #   extra-substituters = [\n  #     # Populated by the CI in ggerganov/llama.cpp\n  #     \"https://llama-cpp.cachix.org\"\n  #\n  #     # A development cache for nixpkgs imported with `config.cudaSupport = true`.\n  #     # Populated by https://hercules-ci.com/github/SomeoneSerge/nixpkgs-cuda-ci.\n  #     # This lets one skip building e.g. the CUDA-enabled openmpi.\n  #     # TODO: Replace once nix-community obtains an official one.\n  #     \"https://cuda-maintainers.cachix.org\"\n  #   ];\n  #\n  #   # Verify these are the same keys as published on\n  #   # - https://app.cachix.org/cache/llama-cpp\n  #   # - https://app.cachix.org/cache/cuda-maintainers\n  #   extra-trusted-public-keys = [\n  #     \"llama-cpp.cachix.org-1:H75X+w83wUKTIPSO1KWy9ADUrzThyGs8P5tmAbkWhQc=\"\n  #     \"cuda-maintainers.cachix.org-1:0dq3bujKpuEPMCX6U4WylrUDZ9JyUG0VpVZa7CNfq5E=\"\n  #   ];\n  # };\n  # ```\n\n  # For inspection, use `nix flake show github:ggerganov/llama.cpp` or the nix repl:\n  #\n  # ```bash\n  # ❯ nix repl\n  # nix-repl> :lf github:ggerganov/llama.cpp\n  # Added 13 variables.\n  # nix-repl> outputs.apps.x86_64-linux.quantize\n  # { program = \"/nix/store/00000000000000000000000000000000-llama.cpp/bin/llama-quantize\"; type = \"app\"; }\n  # ```\n  outputs =\n    { self, flake-parts, ... }@inputs:\n    let\n      # We could include the git revisions in the package names but those would\n      # needlessly trigger rebuilds:\n      # llamaVersion = self.dirtyShortRev or self.shortRev;\n\n      # Nix already uses cryptographic hashes for versioning, so we'll just fix\n      # the fake semver for now:\n      llamaVersion = \"0.0.0\";\n    in\n    flake-parts.lib.mkFlake { inherit inputs; }\n\n      {\n\n        imports = [\n          .devops/nix/nixpkgs-instances.nix\n          .devops/nix/apps.nix\n          .devops/nix/devshells.nix\n          .devops/nix/jetson-support.nix\n        ];\n\n        # An overlay can be used to have a more granular control over llama-cpp's\n        # dependencies and configuration, than that offered by the `.override`\n        # mechanism. Cf. https://nixos.org/manual/nixpkgs/stable/#chap-overlays.\n        #\n        # E.g. in a flake:\n        # ```\n        # { nixpkgs, llama-cpp, ... }:\n        # let pkgs = import nixpkgs {\n        #     overlays = [ (llama-cpp.overlays.default) ];\n        #     system = \"aarch64-linux\";\n        #     config.allowUnfree = true;\n        #     config.cudaSupport = true;\n        #     config.cudaCapabilities = [ \"7.2\" ];\n        #     config.cudaEnableForwardCompat = false;\n        # }; in {\n        #     packages.aarch64-linux.llamaJetsonXavier = pkgs.llamaPackages.llama-cpp;\n        # }\n        # ```\n        #\n        # Cf. https://nixos.org/manual/nix/unstable/command-ref/new-cli/nix3-flake.html?highlight=flake#flake-format\n        flake.overlays.default = (\n          final: prev: {\n            llamaPackages = final.callPackage .devops/nix/scope.nix { inherit llamaVersion; };\n            inherit (final.llamaPackages) llama-cpp;\n          }\n        );\n\n        systems = [\n          \"aarch64-darwin\"\n          \"aarch64-linux\"\n          \"x86_64-darwin\" # x86_64-darwin isn't tested (and likely isn't relevant)\n          \"x86_64-linux\"\n        ];\n\n        perSystem =\n          {\n            config,\n            lib,\n            system,\n            pkgs,\n            pkgsCuda,\n            pkgsRocm,\n            ...\n          }:\n          {\n            # For standardised reproducible formatting with `nix fmt`\n            formatter = pkgs.nixfmt-rfc-style;\n\n            # Unlike `.#packages`, legacyPackages may contain values of\n            # arbitrary types (including nested attrsets) and may even throw\n            # exceptions. This attribute isn't recursed into by `nix flake\n            # show` either.\n            #\n            # You can add arbitrary scripts to `.devops/nix/scope.nix` and\n            # access them as `nix build .#llamaPackages.${scriptName}` using\n            # the same path you would with an overlay.\n            legacyPackages = {\n              llamaPackages = pkgs.callPackage .devops/nix/scope.nix { inherit llamaVersion; };\n              llamaPackagesWindows = pkgs.pkgsCross.mingwW64.callPackage .devops/nix/scope.nix {\n                inherit llamaVersion;\n              };\n              llamaPackagesCuda = pkgsCuda.callPackage .devops/nix/scope.nix { inherit llamaVersion; };\n              llamaPackagesRocm = pkgsRocm.callPackage .devops/nix/scope.nix { inherit llamaVersion; };\n            };\n\n            # We don't use the overlay here so as to avoid making too many instances of nixpkgs,\n            # cf. https://zimbatm.com/notes/1000-instances-of-nixpkgs\n            packages =\n              {\n                default = config.legacyPackages.llamaPackages.llama-cpp;\n                vulkan = config.packages.default.override { useVulkan = true; };\n                windows = config.legacyPackages.llamaPackagesWindows.llama-cpp;\n                python-scripts = config.legacyPackages.llamaPackages.python-scripts;\n              }\n              // lib.optionalAttrs pkgs.stdenv.isLinux {\n                cuda = config.legacyPackages.llamaPackagesCuda.llama-cpp;\n\n                mpi-cpu = config.packages.default.override { useMpi = true; };\n                mpi-cuda = config.packages.default.override { useMpi = true; };\n              }\n              // lib.optionalAttrs (system == \"x86_64-linux\") {\n                rocm = config.legacyPackages.llamaPackagesRocm.llama-cpp;\n              };\n\n            # Packages exposed in `.#checks` will be built by the CI and by\n            # `nix flake check`.\n            #\n            # We could test all outputs e.g. as `checks = confg.packages`.\n            #\n            # TODO: Build more once https://github.com/ggerganov/llama.cpp/issues/6346 has been addressed\n            checks = {\n              inherit (config.packages) default vulkan;\n            };\n          };\n      };\n}\n"
        },
        {
          "name": "ggml",
          "type": "tree",
          "content": null
        },
        {
          "name": "gguf-py",
          "type": "tree",
          "content": null
        },
        {
          "name": "grammars",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "models",
          "type": "tree",
          "content": null
        },
        {
          "name": "mypy.ini",
          "type": "blob",
          "size": 0.1591796875,
          "content": "[mypy]\nstrict = true\nallow_untyped_calls = true\nallow_untyped_defs = true\nallow_incomplete_defs = true\ndisable_error_code = import-untyped\nwarn_return_any = false\n"
        },
        {
          "name": "pocs",
          "type": "tree",
          "content": null
        },
        {
          "name": "poetry.lock",
          "type": "blob",
          "size": 121.861328125,
          "content": "# This file is automatically @generated by Poetry 1.7.1 and should not be changed by hand.\n\n[[package]]\nname = \"atomicwrites\"\nversion = \"1.4.1\"\ndescription = \"Atomic file writes.\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*\"\nfiles = [\n    {file = \"atomicwrites-1.4.1.tar.gz\", hash = \"sha256:81b2c9071a49367a7f770170e5eec8cb66567cfbbc8c73d20ce5ca4a8d71cf11\"},\n]\n\n[[package]]\nname = \"attrs\"\nversion = \"23.2.0\"\ndescription = \"Classes Without Boilerplate\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"attrs-23.2.0-py3-none-any.whl\", hash = \"sha256:99b87a485a5820b23b879f04c2305b44b951b502fd64be915879d77a7e8fc6f1\"},\n    {file = \"attrs-23.2.0.tar.gz\", hash = \"sha256:935dc3b529c262f6cf76e50877d35a4bd3c1de194fd41f47a2b7ae8f19971f30\"},\n]\n\n[package.extras]\ncov = [\"attrs[tests]\", \"coverage[toml] (>=5.3)\"]\ndev = [\"attrs[tests]\", \"pre-commit\"]\ndocs = [\"furo\", \"myst-parser\", \"sphinx\", \"sphinx-notfound-page\", \"sphinxcontrib-towncrier\", \"towncrier\", \"zope-interface\"]\ntests = [\"attrs[tests-no-zope]\", \"zope-interface\"]\ntests-mypy = [\"mypy (>=1.6)\", \"pytest-mypy-plugins\"]\ntests-no-zope = [\"attrs[tests-mypy]\", \"cloudpickle\", \"hypothesis\", \"pympler\", \"pytest (>=4.3.0)\", \"pytest-xdist[psutil]\"]\n\n[[package]]\nname = \"certifi\"\nversion = \"2024.2.2\"\ndescription = \"Python package for providing Mozilla's CA Bundle.\"\noptional = false\npython-versions = \">=3.6\"\nfiles = [\n    {file = \"certifi-2024.2.2-py3-none-any.whl\", hash = \"sha256:dc383c07b76109f368f6106eee2b593b04a011ea4d55f652c6ca24a754d1cdd1\"},\n    {file = \"certifi-2024.2.2.tar.gz\", hash = \"sha256:0569859f95fc761b18b45ef421b1290a0f65f147e92a1e5eb3e635f9a5e4e66f\"},\n]\n\n[[package]]\nname = \"charset-normalizer\"\nversion = \"3.3.2\"\ndescription = \"The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet.\"\noptional = false\npython-versions = \">=3.7.0\"\nfiles = [\n    {file = \"charset-normalizer-3.3.2.tar.gz\", hash = \"sha256:f30c3cb33b24454a82faecaf01b19c18562b1e89558fb6c56de4d9118a032fd5\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:25baf083bf6f6b341f4121c2f3c548875ee6f5339300e08be3f2b2ba1721cdd3\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:06435b539f889b1f6f4ac1758871aae42dc3a8c0e24ac9e60c2384973ad73027\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:9063e24fdb1e498ab71cb7419e24622516c4a04476b17a2dab57e8baa30d6e03\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:6897af51655e3691ff853668779c7bad41579facacf5fd7253b0133308cf000d\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:1d3193f4a680c64b4b6a9115943538edb896edc190f0b222e73761716519268e\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:cd70574b12bb8a4d2aaa0094515df2463cb429d8536cfb6c7ce983246983e5a6\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:8465322196c8b4d7ab6d1e049e4c5cb460d0394da4a27d23cc242fbf0034b6b5\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:a9a8e9031d613fd2009c182b69c7b2c1ef8239a0efb1df3f7c8da66d5dd3d537\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:beb58fe5cdb101e3a055192ac291b7a21e3b7ef4f67fa1d74e331a7f2124341c\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:e06ed3eb3218bc64786f7db41917d4e686cc4856944f53d5bdf83a6884432e12\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-musllinux_1_1_ppc64le.whl\", hash = \"sha256:2e81c7b9c8979ce92ed306c249d46894776a909505d8f5a4ba55b14206e3222f\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-musllinux_1_1_s390x.whl\", hash = \"sha256:572c3763a264ba47b3cf708a44ce965d98555f618ca42c926a9c1616d8f34269\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:fd1abc0d89e30cc4e02e4064dc67fcc51bd941eb395c502aac3ec19fab46b519\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-win32.whl\", hash = \"sha256:3d47fa203a7bd9c5b6cee4736ee84ca03b8ef23193c0d1ca99b5089f72645c73\"},\n    {file = \"charset_normalizer-3.3.2-cp310-cp310-win_amd64.whl\", hash = \"sha256:10955842570876604d404661fbccbc9c7e684caf432c09c715ec38fbae45ae09\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:802fe99cca7457642125a8a88a084cef28ff0cf9407060f7b93dca5aa25480db\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:573f6eac48f4769d667c4442081b1794f52919e7edada77495aaed9236d13a96\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:549a3a73da901d5bc3ce8d24e0600d1fa85524c10287f6004fbab87672bf3e1e\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:f27273b60488abe721a075bcca6d7f3964f9f6f067c8c4c605743023d7d3944f\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:1ceae2f17a9c33cb48e3263960dc5fc8005351ee19db217e9b1bb15d28c02574\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:65f6f63034100ead094b8744b3b97965785388f308a64cf8d7c34f2f2e5be0c4\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:753f10e867343b4511128c6ed8c82f7bec3bd026875576dfd88483c5c73b2fd8\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:4a78b2b446bd7c934f5dcedc588903fb2f5eec172f3d29e52a9096a43722adfc\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:e537484df0d8f426ce2afb2d0f8e1c3d0b114b83f8850e5f2fbea0e797bd82ae\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-musllinux_1_1_i686.whl\", hash = \"sha256:eb6904c354526e758fda7167b33005998fb68c46fbc10e013ca97f21ca5c8887\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-musllinux_1_1_ppc64le.whl\", hash = \"sha256:deb6be0ac38ece9ba87dea880e438f25ca3eddfac8b002a2ec3d9183a454e8ae\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-musllinux_1_1_s390x.whl\", hash = \"sha256:4ab2fe47fae9e0f9dee8c04187ce5d09f48eabe611be8259444906793ab7cbce\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:80402cd6ee291dcb72644d6eac93785fe2c8b9cb30893c1af5b8fdd753b9d40f\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-win32.whl\", hash = \"sha256:7cd13a2e3ddeed6913a65e66e94b51d80a041145a026c27e6bb76c31a853c6ab\"},\n    {file = \"charset_normalizer-3.3.2-cp311-cp311-win_amd64.whl\", hash = \"sha256:663946639d296df6a2bb2aa51b60a2454ca1cb29835324c640dafb5ff2131a77\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-macosx_10_9_universal2.whl\", hash = \"sha256:0b2b64d2bb6d3fb9112bafa732def486049e63de9618b5843bcdd081d8144cd8\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:ddbb2551d7e0102e7252db79ba445cdab71b26640817ab1e3e3648dad515003b\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:55086ee1064215781fff39a1af09518bc9255b50d6333f2e4c74ca09fac6a8f6\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:8f4a014bc36d3c57402e2977dada34f9c12300af536839dc38c0beab8878f38a\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:a10af20b82360ab00827f916a6058451b723b4e65030c5a18577c8b2de5b3389\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:8d756e44e94489e49571086ef83b2bb8ce311e730092d2c34ca8f7d925cb20aa\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:90d558489962fd4918143277a773316e56c72da56ec7aa3dc3dbbe20fdfed15b\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:6ac7ffc7ad6d040517be39eb591cac5ff87416c2537df6ba3cba3bae290c0fed\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:7ed9e526742851e8d5cc9e6cf41427dfc6068d4f5a3bb03659444b4cabf6bc26\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-musllinux_1_1_i686.whl\", hash = \"sha256:8bdb58ff7ba23002a4c5808d608e4e6c687175724f54a5dade5fa8c67b604e4d\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-musllinux_1_1_ppc64le.whl\", hash = \"sha256:6b3251890fff30ee142c44144871185dbe13b11bab478a88887a639655be1068\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-musllinux_1_1_s390x.whl\", hash = \"sha256:b4a23f61ce87adf89be746c8a8974fe1c823c891d8f86eb218bb957c924bb143\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:efcb3f6676480691518c177e3b465bcddf57cea040302f9f4e6e191af91174d4\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-win32.whl\", hash = \"sha256:d965bba47ddeec8cd560687584e88cf699fd28f192ceb452d1d7ee807c5597b7\"},\n    {file = \"charset_normalizer-3.3.2-cp312-cp312-win_amd64.whl\", hash = \"sha256:96b02a3dc4381e5494fad39be677abcb5e6634bf7b4fa83a6dd3112607547001\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:95f2a5796329323b8f0512e09dbb7a1860c46a39da62ecb2324f116fa8fdc85c\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:c002b4ffc0be611f0d9da932eb0f704fe2602a9a949d1f738e4c34c75b0863d5\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:a981a536974bbc7a512cf44ed14938cf01030a99e9b3a06dd59578882f06f985\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:3287761bc4ee9e33561a7e058c72ac0938c4f57fe49a09eae428fd88aafe7bb6\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:42cb296636fcc8b0644486d15c12376cb9fa75443e00fb25de0b8602e64c1714\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:0a55554a2fa0d408816b3b5cedf0045f4b8e1a6065aec45849de2d6f3f8e9786\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:c083af607d2515612056a31f0a8d9e0fcb5876b7bfc0abad3ecd275bc4ebc2d5\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:87d1351268731db79e0f8e745d92493ee2841c974128ef629dc518b937d9194c\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-musllinux_1_1_ppc64le.whl\", hash = \"sha256:bd8f7df7d12c2db9fab40bdd87a7c09b1530128315d047a086fa3ae3435cb3a8\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-musllinux_1_1_s390x.whl\", hash = \"sha256:c180f51afb394e165eafe4ac2936a14bee3eb10debc9d9e4db8958fe36afe711\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:8c622a5fe39a48f78944a87d4fb8a53ee07344641b0562c540d840748571b811\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-win32.whl\", hash = \"sha256:db364eca23f876da6f9e16c9da0df51aa4f104a972735574842618b8c6d999d4\"},\n    {file = \"charset_normalizer-3.3.2-cp37-cp37m-win_amd64.whl\", hash = \"sha256:86216b5cee4b06df986d214f664305142d9c76df9b6512be2738aa72a2048f99\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:6463effa3186ea09411d50efc7d85360b38d5f09b870c48e4600f63af490e56a\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:6c4caeef8fa63d06bd437cd4bdcf3ffefe6738fb1b25951440d80dc7df8c03ac\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:37e55c8e51c236f95b033f6fb391d7d7970ba5fe7ff453dad675e88cf303377a\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:fb69256e180cb6c8a894fee62b3afebae785babc1ee98b81cdf68bbca1987f33\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:ae5f4161f18c61806f411a13b0310bea87f987c7d2ecdbdaad0e94eb2e404238\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:b2b0a0c0517616b6869869f8c581d4eb2dd83a4d79e0ebcb7d373ef9956aeb0a\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:45485e01ff4d3630ec0d9617310448a8702f70e9c01906b0d0118bdf9d124cf2\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:eb00ed941194665c332bf8e078baf037d6c35d7c4f3102ea2d4f16ca94a26dc8\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:2127566c664442652f024c837091890cb1942c30937add288223dc895793f898\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:a50aebfa173e157099939b17f18600f72f84eed3049e743b68ad15bd69b6bf99\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-musllinux_1_1_ppc64le.whl\", hash = \"sha256:4d0d1650369165a14e14e1e47b372cfcb31d6ab44e6e33cb2d4e57265290044d\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-musllinux_1_1_s390x.whl\", hash = \"sha256:923c0c831b7cfcb071580d3f46c4baf50f174be571576556269530f4bbd79d04\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:06a81e93cd441c56a9b65d8e1d043daeb97a3d0856d177d5c90ba85acb3db087\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-win32.whl\", hash = \"sha256:6ef1d82a3af9d3eecdba2321dc1b3c238245d890843e040e41e470ffa64c3e25\"},\n    {file = \"charset_normalizer-3.3.2-cp38-cp38-win_amd64.whl\", hash = \"sha256:eb8821e09e916165e160797a6c17edda0679379a4be5c716c260e836e122f54b\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:c235ebd9baae02f1b77bcea61bce332cb4331dc3617d254df3323aa01ab47bd4\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:5b4c145409bef602a690e7cfad0a15a55c13320ff7a3ad7ca59c13bb8ba4d45d\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:68d1f8a9e9e37c1223b656399be5d6b448dea850bed7d0f87a8311f1ff3dabb0\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:22afcb9f253dac0696b5a4be4a1c0f8762f8239e21b99680099abd9b2b1b2269\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:e27ad930a842b4c5eb8ac0016b0a54f5aebbe679340c26101df33424142c143c\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:1f79682fbe303db92bc2b1136016a38a42e835d932bab5b3b1bfcfbf0640e519\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b261ccdec7821281dade748d088bb6e9b69e6d15b30652b74cbbac25e280b796\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:122c7fa62b130ed55f8f285bfd56d5f4b4a5b503609d181f9ad85e55c89f4185\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:d0eccceffcb53201b5bfebb52600a5fb483a20b61da9dbc885f8b103cbe7598c\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:9f96df6923e21816da7e0ad3fd47dd8f94b2a5ce594e00677c0013018b813458\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-musllinux_1_1_ppc64le.whl\", hash = \"sha256:7f04c839ed0b6b98b1a7501a002144b76c18fb1c1850c8b98d458ac269e26ed2\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-musllinux_1_1_s390x.whl\", hash = \"sha256:34d1c8da1e78d2e001f363791c98a272bb734000fcef47a491c1e3b0505657a8\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:ff8fa367d09b717b2a17a052544193ad76cd49979c805768879cb63d9ca50561\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-win32.whl\", hash = \"sha256:aed38f6e4fb3f5d6bf81bfa990a07806be9d83cf7bacef998ab1a9bd660a581f\"},\n    {file = \"charset_normalizer-3.3.2-cp39-cp39-win_amd64.whl\", hash = \"sha256:b01b88d45a6fcb69667cd6d2f7a9aeb4bf53760d7fc536bf679ec94fe9f3ff3d\"},\n    {file = \"charset_normalizer-3.3.2-py3-none-any.whl\", hash = \"sha256:3e4d1f6587322d2788836a99c69062fbb091331ec940e02d12d179c1d53e25fc\"},\n]\n\n[[package]]\nname = \"colorama\"\nversion = \"0.4.6\"\ndescription = \"Cross-platform colored terminal text.\"\noptional = false\npython-versions = \"!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*,!=3.6.*,>=2.7\"\nfiles = [\n    {file = \"colorama-0.4.6-py2.py3-none-any.whl\", hash = \"sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6\"},\n    {file = \"colorama-0.4.6.tar.gz\", hash = \"sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44\"},\n]\n\n[[package]]\nname = \"filelock\"\nversion = \"3.13.1\"\ndescription = \"A platform independent file lock.\"\noptional = false\npython-versions = \">=3.8\"\nfiles = [\n    {file = \"filelock-3.13.1-py3-none-any.whl\", hash = \"sha256:57dbda9b35157b05fb3e58ee91448612eb674172fab98ee235ccb0b5bee19a1c\"},\n    {file = \"filelock-3.13.1.tar.gz\", hash = \"sha256:521f5f56c50f8426f5e03ad3b281b490a87ef15bc6c526f168290f0c7148d44e\"},\n]\n\n[package.extras]\ndocs = [\"furo (>=2023.9.10)\", \"sphinx (>=7.2.6)\", \"sphinx-autodoc-typehints (>=1.24)\"]\ntesting = [\"covdefaults (>=2.3)\", \"coverage (>=7.3.2)\", \"diff-cover (>=8)\", \"pytest (>=7.4.3)\", \"pytest-cov (>=4.1)\", \"pytest-mock (>=3.12)\", \"pytest-timeout (>=2.2)\"]\ntyping = [\"typing-extensions (>=4.8)\"]\n\n[[package]]\nname = \"fsspec\"\nversion = \"2024.2.0\"\ndescription = \"File-system specification\"\noptional = false\npython-versions = \">=3.8\"\nfiles = [\n    {file = \"fsspec-2024.2.0-py3-none-any.whl\", hash = \"sha256:817f969556fa5916bc682e02ca2045f96ff7f586d45110fcb76022063ad2c7d8\"},\n    {file = \"fsspec-2024.2.0.tar.gz\", hash = \"sha256:b6ad1a679f760dda52b1168c859d01b7b80648ea6f7f7c7f5a8a91dc3f3ecb84\"},\n]\n\n[package.extras]\nabfs = [\"adlfs\"]\nadl = [\"adlfs\"]\narrow = [\"pyarrow (>=1)\"]\ndask = [\"dask\", \"distributed\"]\ndevel = [\"pytest\", \"pytest-cov\"]\ndropbox = [\"dropbox\", \"dropboxdrivefs\", \"requests\"]\nfull = [\"adlfs\", \"aiohttp (!=4.0.0a0,!=4.0.0a1)\", \"dask\", \"distributed\", \"dropbox\", \"dropboxdrivefs\", \"fusepy\", \"gcsfs\", \"libarchive-c\", \"ocifs\", \"panel\", \"paramiko\", \"pyarrow (>=1)\", \"pygit2\", \"requests\", \"s3fs\", \"smbprotocol\", \"tqdm\"]\nfuse = [\"fusepy\"]\ngcs = [\"gcsfs\"]\ngit = [\"pygit2\"]\ngithub = [\"requests\"]\ngs = [\"gcsfs\"]\ngui = [\"panel\"]\nhdfs = [\"pyarrow (>=1)\"]\nhttp = [\"aiohttp (!=4.0.0a0,!=4.0.0a1)\"]\nlibarchive = [\"libarchive-c\"]\noci = [\"ocifs\"]\ns3 = [\"s3fs\"]\nsftp = [\"paramiko\"]\nsmb = [\"smbprotocol\"]\nssh = [\"paramiko\"]\ntqdm = [\"tqdm\"]\n\n[[package]]\nname = \"gguf\"\nversion = \"0.7.0\"\ndescription = \"Read and write ML models in GGUF for GGML\"\noptional = false\npython-versions = \">=3.8\"\nfiles = []\ndevelop = false\n\n[package.dependencies]\nnumpy = \">=1.17\"\n\n[package.source]\ntype = \"directory\"\nurl = \"gguf-py\"\n\n[[package]]\nname = \"huggingface-hub\"\nversion = \"0.20.3\"\ndescription = \"Client library to download and publish models, datasets and other repos on the huggingface.co hub\"\noptional = false\npython-versions = \">=3.8.0\"\nfiles = [\n    {file = \"huggingface_hub-0.20.3-py3-none-any.whl\", hash = \"sha256:d988ae4f00d3e307b0c80c6a05ca6dbb7edba8bba3079f74cda7d9c2e562a7b6\"},\n    {file = \"huggingface_hub-0.20.3.tar.gz\", hash = \"sha256:94e7f8e074475fbc67d6a71957b678e1b4a74ff1b64a644fd6cbb83da962d05d\"},\n]\n\n[package.dependencies]\nfilelock = \"*\"\nfsspec = \">=2023.5.0\"\npackaging = \">=20.9\"\npyyaml = \">=5.1\"\nrequests = \"*\"\ntqdm = \">=4.42.1\"\ntyping-extensions = \">=3.7.4.3\"\n\n[package.extras]\nall = [\"InquirerPy (==0.3.4)\", \"Jinja2\", \"Pillow\", \"aiohttp\", \"gradio\", \"jedi\", \"mypy (==1.5.1)\", \"numpy\", \"pydantic (>1.1,<2.0)\", \"pydantic (>1.1,<3.0)\", \"pytest\", \"pytest-asyncio\", \"pytest-cov\", \"pytest-env\", \"pytest-rerunfailures\", \"pytest-vcr\", \"pytest-xdist\", \"ruff (>=0.1.3)\", \"soundfile\", \"types-PyYAML\", \"types-requests\", \"types-simplejson\", \"types-toml\", \"types-tqdm\", \"types-urllib3\", \"typing-extensions (>=4.8.0)\", \"urllib3 (<2.0)\"]\ncli = [\"InquirerPy (==0.3.4)\"]\ndev = [\"InquirerPy (==0.3.4)\", \"Jinja2\", \"Pillow\", \"aiohttp\", \"gradio\", \"jedi\", \"mypy (==1.5.1)\", \"numpy\", \"pydantic (>1.1,<2.0)\", \"pydantic (>1.1,<3.0)\", \"pytest\", \"pytest-asyncio\", \"pytest-cov\", \"pytest-env\", \"pytest-rerunfailures\", \"pytest-vcr\", \"pytest-xdist\", \"ruff (>=0.1.3)\", \"soundfile\", \"types-PyYAML\", \"types-requests\", \"types-simplejson\", \"types-toml\", \"types-tqdm\", \"types-urllib3\", \"typing-extensions (>=4.8.0)\", \"urllib3 (<2.0)\"]\nfastai = [\"fastai (>=2.4)\", \"fastcore (>=1.3.27)\", \"toml\"]\ninference = [\"aiohttp\", \"pydantic (>1.1,<2.0)\", \"pydantic (>1.1,<3.0)\"]\nquality = [\"mypy (==1.5.1)\", \"ruff (>=0.1.3)\"]\ntensorflow = [\"graphviz\", \"pydot\", \"tensorflow\"]\ntesting = [\"InquirerPy (==0.3.4)\", \"Jinja2\", \"Pillow\", \"aiohttp\", \"gradio\", \"jedi\", \"numpy\", \"pydantic (>1.1,<2.0)\", \"pydantic (>1.1,<3.0)\", \"pytest\", \"pytest-asyncio\", \"pytest-cov\", \"pytest-env\", \"pytest-rerunfailures\", \"pytest-vcr\", \"pytest-xdist\", \"soundfile\", \"urllib3 (<2.0)\"]\ntorch = [\"torch\"]\ntyping = [\"types-PyYAML\", \"types-requests\", \"types-simplejson\", \"types-toml\", \"types-tqdm\", \"types-urllib3\", \"typing-extensions (>=4.8.0)\"]\n\n[[package]]\nname = \"idna\"\nversion = \"3.6\"\ndescription = \"Internationalized Domain Names in Applications (IDNA)\"\noptional = false\npython-versions = \">=3.5\"\nfiles = [\n    {file = \"idna-3.6-py3-none-any.whl\", hash = \"sha256:c05567e9c24a6b9faaa835c4821bad0590fbb9d5779e7caa6e1cc4978e7eb24f\"},\n    {file = \"idna-3.6.tar.gz\", hash = \"sha256:9ecdbbd083b06798ae1e86adcbfe8ab1479cf864e4ee30fe4e46a003d12491ca\"},\n]\n\n[[package]]\nname = \"jinja2\"\nversion = \"3.1.3\"\ndescription = \"A very fast and expressive template engine.\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"Jinja2-3.1.3-py3-none-any.whl\", hash = \"sha256:7d6d50dd97d52cbc355597bd845fabfbac3f551e1f99619e39a35ce8c370b5fa\"},\n    {file = \"Jinja2-3.1.3.tar.gz\", hash = \"sha256:ac8bd6544d4bb2c9792bf3a159e80bba8fda7f07e81bc3aed565432d5925ba90\"},\n]\n\n[package.dependencies]\nMarkupSafe = \">=2.0\"\n\n[package.extras]\ni18n = [\"Babel (>=2.7)\"]\n\n[[package]]\nname = \"markupsafe\"\nversion = \"2.1.5\"\ndescription = \"Safely add untrusted strings to HTML/XML markup.\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:a17a92de5231666cfbe003f0e4b9b3a7ae3afb1ec2845aadc2bacc93ff85febc\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:72b6be590cc35924b02c78ef34b467da4ba07e4e0f0454a2c5907f473fc50ce5\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:e61659ba32cf2cf1481e575d0462554625196a1f2fc06a1c777d3f48e8865d46\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:2174c595a0d73a3080ca3257b40096db99799265e1c27cc5a610743acd86d62f\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:ae2ad8ae6ebee9d2d94b17fb62763125f3f374c25618198f40cbb8b525411900\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:075202fa5b72c86ad32dc7d0b56024ebdbcf2048c0ba09f1cde31bfdd57bcfff\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:598e3276b64aff0e7b3451b72e94fa3c238d452e7ddcd893c3ab324717456bad\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:fce659a462a1be54d2ffcacea5e3ba2d74daa74f30f5f143fe0c58636e355fdd\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-win32.whl\", hash = \"sha256:d9fad5155d72433c921b782e58892377c44bd6252b5af2f67f16b194987338a4\"},\n    {file = \"MarkupSafe-2.1.5-cp310-cp310-win_amd64.whl\", hash = \"sha256:bf50cd79a75d181c9181df03572cdce0fbb75cc353bc350712073108cba98de5\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:629ddd2ca402ae6dbedfceeba9c46d5f7b2a61d9749597d4307f943ef198fc1f\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:5b7b716f97b52c5a14bffdf688f971b2d5ef4029127f1ad7a513973cfd818df2\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:6ec585f69cec0aa07d945b20805be741395e28ac1627333b1c5b0105962ffced\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b91c037585eba9095565a3556f611e3cbfaa42ca1e865f7b8015fe5c7336d5a5\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:7502934a33b54030eaf1194c21c692a534196063db72176b0c4028e140f8f32c\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:0e397ac966fdf721b2c528cf028494e86172b4feba51d65f81ffd65c63798f3f\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-musllinux_1_1_i686.whl\", hash = \"sha256:c061bb86a71b42465156a3ee7bd58c8c2ceacdbeb95d05a99893e08b8467359a\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:3a57fdd7ce31c7ff06cdfbf31dafa96cc533c21e443d57f5b1ecc6cdc668ec7f\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-win32.whl\", hash = \"sha256:397081c1a0bfb5124355710fe79478cdbeb39626492b15d399526ae53422b906\"},\n    {file = \"MarkupSafe-2.1.5-cp311-cp311-win_amd64.whl\", hash = \"sha256:2b7c57a4dfc4f16f7142221afe5ba4e093e09e728ca65c51f5620c9aaeb9a617\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-macosx_10_9_universal2.whl\", hash = \"sha256:8dec4936e9c3100156f8a2dc89c4b88d5c435175ff03413b443469c7c8c5f4d1\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:3c6b973f22eb18a789b1460b4b91bf04ae3f0c4234a0a6aa6b0a92f6f7b951d4\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:ac07bad82163452a6884fe8fa0963fb98c2346ba78d779ec06bd7a6262132aee\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f5dfb42c4604dddc8e4305050aa6deb084540643ed5804d7455b5df8fe16f5e5\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:ea3d8a3d18833cf4304cd2fc9cbb1efe188ca9b5efef2bdac7adc20594a0e46b\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:d050b3361367a06d752db6ead6e7edeb0009be66bc3bae0ee9d97fb326badc2a\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-musllinux_1_1_i686.whl\", hash = \"sha256:bec0a414d016ac1a18862a519e54b2fd0fc8bbfd6890376898a6c0891dd82e9f\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:58c98fee265677f63a4385256a6d7683ab1832f3ddd1e66fe948d5880c21a169\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-win32.whl\", hash = \"sha256:8590b4ae07a35970728874632fed7bd57b26b0102df2d2b233b6d9d82f6c62ad\"},\n    {file = \"MarkupSafe-2.1.5-cp312-cp312-win_amd64.whl\", hash = \"sha256:823b65d8706e32ad2df51ed89496147a42a2a6e01c13cfb6ffb8b1e92bc910bb\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:c8b29db45f8fe46ad280a7294f5c3ec36dbac9491f2d1c17345be8e69cc5928f\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:ec6a563cff360b50eed26f13adc43e61bc0c04d94b8be985e6fb24b81f6dcfdf\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:a549b9c31bec33820e885335b451286e2969a2d9e24879f83fe904a5ce59d70a\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:4f11aa001c540f62c6166c7726f71f7573b52c68c31f014c25cc7901deea0b52\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:7b2e5a267c855eea6b4283940daa6e88a285f5f2a67f2220203786dfa59b37e9\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:2d2d793e36e230fd32babe143b04cec8a8b3eb8a3122d2aceb4a371e6b09b8df\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:ce409136744f6521e39fd8e2a24c53fa18ad67aa5bc7c2cf83645cce5b5c4e50\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-win32.whl\", hash = \"sha256:4096e9de5c6fdf43fb4f04c26fb114f61ef0bf2e5604b6ee3019d51b69e8c371\"},\n    {file = \"MarkupSafe-2.1.5-cp37-cp37m-win_amd64.whl\", hash = \"sha256:4275d846e41ecefa46e2015117a9f491e57a71ddd59bbead77e904dc02b1bed2\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:656f7526c69fac7f600bd1f400991cc282b417d17539a1b228617081106feb4a\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:97cafb1f3cbcd3fd2b6fbfb99ae11cdb14deea0736fc2b0952ee177f2b813a46\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:1f3fbcb7ef1f16e48246f704ab79d79da8a46891e2da03f8783a5b6fa41a9532\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:fa9db3f79de01457b03d4f01b34cf91bc0048eb2c3846ff26f66687c2f6d16ab\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:ffee1f21e5ef0d712f9033568f8344d5da8cc2869dbd08d87c84656e6a2d2f68\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:5dedb4db619ba5a2787a94d877bc8ffc0566f92a01c0ef214865e54ecc9ee5e0\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:30b600cf0a7ac9234b2638fbc0fb6158ba5bdcdf46aeb631ead21248b9affbc4\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:8dd717634f5a044f860435c1d8c16a270ddf0ef8588d4887037c5028b859b0c3\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-win32.whl\", hash = \"sha256:daa4ee5a243f0f20d528d939d06670a298dd39b1ad5f8a72a4275124a7819eff\"},\n    {file = \"MarkupSafe-2.1.5-cp38-cp38-win_amd64.whl\", hash = \"sha256:619bc166c4f2de5caa5a633b8b7326fbe98e0ccbfacabd87268a2b15ff73a029\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:7a68b554d356a91cce1236aa7682dc01df0edba8d043fd1ce607c49dd3c1edcf\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:db0b55e0f3cc0be60c1f19efdde9a637c32740486004f20d1cff53c3c0ece4d2\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:3e53af139f8579a6d5f7b76549125f0d94d7e630761a2111bc431fd820e163b8\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:17b950fccb810b3293638215058e432159d2b71005c74371d784862b7e4683f3\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:4c31f53cdae6ecfa91a77820e8b151dba54ab528ba65dfd235c80b086d68a465\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:bff1b4290a66b490a2f4719358c0cdcd9bafb6b8f061e45c7a2460866bf50c2e\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:bc1667f8b83f48511b94671e0e441401371dfd0f0a795c7daa4a3cd1dde55bea\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:5049256f536511ee3f7e1b3f87d1d1209d327e818e6ae1365e8653d7e3abb6a6\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-win32.whl\", hash = \"sha256:00e046b6dd71aa03a41079792f8473dc494d564611a8f89bbbd7cb93295ebdcf\"},\n    {file = \"MarkupSafe-2.1.5-cp39-cp39-win_amd64.whl\", hash = \"sha256:fa173ec60341d6bb97a89f5ea19c85c5643c1e7dedebc22f5181eb73573142c5\"},\n    {file = \"MarkupSafe-2.1.5.tar.gz\", hash = \"sha256:d283d37a890ba4c1ae73ffadf8046435c76e7bc2247bbb63c00bd1a709c6544b\"},\n]\n\n[[package]]\nname = \"more-itertools\"\nversion = \"10.2.0\"\ndescription = \"More routines for operating on iterables, beyond itertools\"\noptional = false\npython-versions = \">=3.8\"\nfiles = [\n    {file = \"more-itertools-10.2.0.tar.gz\", hash = \"sha256:8fccb480c43d3e99a00087634c06dd02b0d50fbf088b380de5a41a015ec239e1\"},\n    {file = \"more_itertools-10.2.0-py3-none-any.whl\", hash = \"sha256:686b06abe565edfab151cb8fd385a05651e1fdf8f0a14191e4439283421f8684\"},\n]\n\n[[package]]\nname = \"mpmath\"\nversion = \"1.3.0\"\ndescription = \"Python library for arbitrary-precision floating-point arithmetic\"\noptional = false\npython-versions = \"*\"\nfiles = [\n    {file = \"mpmath-1.3.0-py3-none-any.whl\", hash = \"sha256:a0b2b9fe80bbcd81a6647ff13108738cfb482d481d826cc0e02f5b35e5c88d2c\"},\n    {file = \"mpmath-1.3.0.tar.gz\", hash = \"sha256:7a28eb2a9774d00c7bc92411c19a89209d5da7c4c9a9e227be8330a23a25b91f\"},\n]\n\n[package.extras]\ndevelop = [\"codecov\", \"pycodestyle\", \"pytest (>=4.6)\", \"pytest-cov\", \"wheel\"]\ndocs = [\"sphinx\"]\ngmpy = [\"gmpy2 (>=2.1.0a4)\"]\ntests = [\"pytest (>=4.6)\"]\n\n[[package]]\nname = \"networkx\"\nversion = \"3.2.1\"\ndescription = \"Python package for creating and manipulating graphs and networks\"\noptional = false\npython-versions = \">=3.9\"\nfiles = [\n    {file = \"networkx-3.2.1-py3-none-any.whl\", hash = \"sha256:f18c69adc97877c42332c170849c96cefa91881c99a7cb3e95b7c659ebdc1ec2\"},\n    {file = \"networkx-3.2.1.tar.gz\", hash = \"sha256:9f1bb5cf3409bf324e0a722c20bdb4c20ee39bf1c30ce8ae499c8502b0b5e0c6\"},\n]\n\n[package.extras]\ndefault = [\"matplotlib (>=3.5)\", \"numpy (>=1.22)\", \"pandas (>=1.4)\", \"scipy (>=1.9,!=1.11.0,!=1.11.1)\"]\ndeveloper = [\"changelist (==0.4)\", \"mypy (>=1.1)\", \"pre-commit (>=3.2)\", \"rtoml\"]\ndoc = [\"nb2plots (>=0.7)\", \"nbconvert (<7.9)\", \"numpydoc (>=1.6)\", \"pillow (>=9.4)\", \"pydata-sphinx-theme (>=0.14)\", \"sphinx (>=7)\", \"sphinx-gallery (>=0.14)\", \"texext (>=0.6.7)\"]\nextra = [\"lxml (>=4.6)\", \"pydot (>=1.4.2)\", \"pygraphviz (>=1.11)\", \"sympy (>=1.10)\"]\ntest = [\"pytest (>=7.2)\", \"pytest-cov (>=4.0)\"]\n\n[[package]]\nname = \"numpy\"\nversion = \"1.26.4\"\ndescription = \"Fundamental package for array computing in Python\"\noptional = false\npython-versions = \">=3.9\"\nfiles = [\n    {file = \"numpy-1.26.4-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:9ff0f4f29c51e2803569d7a51c2304de5554655a60c5d776e35b4a41413830d0\"},\n    {file = \"numpy-1.26.4-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:2e4ee3380d6de9c9ec04745830fd9e2eccb3e6cf790d39d7b98ffd19b0dd754a\"},\n    {file = \"numpy-1.26.4-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d209d8969599b27ad20994c8e41936ee0964e6da07478d6c35016bc386b66ad4\"},\n    {file = \"numpy-1.26.4-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:ffa75af20b44f8dba823498024771d5ac50620e6915abac414251bd971b4529f\"},\n    {file = \"numpy-1.26.4-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:62b8e4b1e28009ef2846b4c7852046736bab361f7aeadeb6a5b89ebec3c7055a\"},\n    {file = \"numpy-1.26.4-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:a4abb4f9001ad2858e7ac189089c42178fcce737e4169dc61321660f1a96c7d2\"},\n    {file = \"numpy-1.26.4-cp310-cp310-win32.whl\", hash = \"sha256:bfe25acf8b437eb2a8b2d49d443800a5f18508cd811fea3181723922a8a82b07\"},\n    {file = \"numpy-1.26.4-cp310-cp310-win_amd64.whl\", hash = \"sha256:b97fe8060236edf3662adfc2c633f56a08ae30560c56310562cb4f95500022d5\"},\n    {file = \"numpy-1.26.4-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:4c66707fabe114439db9068ee468c26bbdf909cac0fb58686a42a24de1760c71\"},\n    {file = \"numpy-1.26.4-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:edd8b5fe47dab091176d21bb6de568acdd906d1887a4584a15a9a96a1dca06ef\"},\n    {file = \"numpy-1.26.4-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:7ab55401287bfec946ced39700c053796e7cc0e3acbef09993a9ad2adba6ca6e\"},\n    {file = \"numpy-1.26.4-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:666dbfb6ec68962c033a450943ded891bed2d54e6755e35e5835d63f4f6931d5\"},\n    {file = \"numpy-1.26.4-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:96ff0b2ad353d8f990b63294c8986f1ec3cb19d749234014f4e7eb0112ceba5a\"},\n    {file = \"numpy-1.26.4-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:60dedbb91afcbfdc9bc0b1f3f402804070deed7392c23eb7a7f07fa857868e8a\"},\n    {file = \"numpy-1.26.4-cp311-cp311-win32.whl\", hash = \"sha256:1af303d6b2210eb850fcf03064d364652b7120803a0b872f5211f5234b399f20\"},\n    {file = \"numpy-1.26.4-cp311-cp311-win_amd64.whl\", hash = \"sha256:cd25bcecc4974d09257ffcd1f098ee778f7834c3ad767fe5db785be9a4aa9cb2\"},\n    {file = \"numpy-1.26.4-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:b3ce300f3644fb06443ee2222c2201dd3a89ea6040541412b8fa189341847218\"},\n    {file = \"numpy-1.26.4-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:03a8c78d01d9781b28a6989f6fa1bb2c4f2d51201cf99d3dd875df6fbd96b23b\"},\n    {file = \"numpy-1.26.4-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:9fad7dcb1aac3c7f0584a5a8133e3a43eeb2fe127f47e3632d43d677c66c102b\"},\n    {file = \"numpy-1.26.4-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:675d61ffbfa78604709862923189bad94014bef562cc35cf61d3a07bba02a7ed\"},\n    {file = \"numpy-1.26.4-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:ab47dbe5cc8210f55aa58e4805fe224dac469cde56b9f731a4c098b91917159a\"},\n    {file = \"numpy-1.26.4-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:1dda2e7b4ec9dd512f84935c5f126c8bd8b9f2fc001e9f54af255e8c5f16b0e0\"},\n    {file = \"numpy-1.26.4-cp312-cp312-win32.whl\", hash = \"sha256:50193e430acfc1346175fcbdaa28ffec49947a06918b7b92130744e81e640110\"},\n    {file = \"numpy-1.26.4-cp312-cp312-win_amd64.whl\", hash = \"sha256:08beddf13648eb95f8d867350f6a018a4be2e5ad54c8d8caed89ebca558b2818\"},\n    {file = \"numpy-1.26.4-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:7349ab0fa0c429c82442a27a9673fc802ffdb7c7775fad780226cb234965e53c\"},\n    {file = \"numpy-1.26.4-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:52b8b60467cd7dd1e9ed082188b4e6bb35aa5cdd01777621a1658910745b90be\"},\n    {file = \"numpy-1.26.4-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d5241e0a80d808d70546c697135da2c613f30e28251ff8307eb72ba696945764\"},\n    {file = \"numpy-1.26.4-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f870204a840a60da0b12273ef34f7051e98c3b5961b61b0c2c1be6dfd64fbcd3\"},\n    {file = \"numpy-1.26.4-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:679b0076f67ecc0138fd2ede3a8fd196dddc2ad3254069bcb9faf9a79b1cebcd\"},\n    {file = \"numpy-1.26.4-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:47711010ad8555514b434df65f7d7b076bb8261df1ca9bb78f53d3b2db02e95c\"},\n    {file = \"numpy-1.26.4-cp39-cp39-win32.whl\", hash = \"sha256:a354325ee03388678242a4d7ebcd08b5c727033fcff3b2f536aea978e15ee9e6\"},\n    {file = \"numpy-1.26.4-cp39-cp39-win_amd64.whl\", hash = \"sha256:3373d5d70a5fe74a2c1bb6d2cfd9609ecf686d47a2d7b1d37a8f3b6bf6003aea\"},\n    {file = \"numpy-1.26.4-pp39-pypy39_pp73-macosx_10_9_x86_64.whl\", hash = \"sha256:afedb719a9dcfc7eaf2287b839d8198e06dcd4cb5d276a3df279231138e83d30\"},\n    {file = \"numpy-1.26.4-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:95a7476c59002f2f6c590b9b7b998306fba6a5aa646b1e22ddfeaf8f78c3a29c\"},\n    {file = \"numpy-1.26.4-pp39-pypy39_pp73-win_amd64.whl\", hash = \"sha256:7e50d0a0cc3189f9cb0aeb3a6a6af18c16f59f004b866cd2be1c14b36134a4a0\"},\n    {file = \"numpy-1.26.4.tar.gz\", hash = \"sha256:2a02aba9ed12e4ac4eb3ea9421c420301a0c6460d9830d74a9df87efa4912010\"},\n]\n\n[[package]]\nname = \"packaging\"\nversion = \"23.2\"\ndescription = \"Core utilities for Python packages\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"packaging-23.2-py3-none-any.whl\", hash = \"sha256:8c491190033a9af7e1d931d0b5dacc2ef47509b34dd0de67ed209b5203fc88c7\"},\n    {file = \"packaging-23.2.tar.gz\", hash = \"sha256:048fb0e9405036518eaaf48a55953c750c11e1a1b68e0dd1a9d62ed0c092cfc5\"},\n]\n\n[[package]]\nname = \"pluggy\"\nversion = \"0.13.1\"\ndescription = \"plugin and hook calling mechanisms for python\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*\"\nfiles = [\n    {file = \"pluggy-0.13.1-py2.py3-none-any.whl\", hash = \"sha256:966c145cd83c96502c3c3868f50408687b38434af77734af1e9ca461a4081d2d\"},\n    {file = \"pluggy-0.13.1.tar.gz\", hash = \"sha256:15b2acde666561e1298d71b523007ed7364de07029219b604cf808bfa1c765b0\"},\n]\n\n[package.extras]\ndev = [\"pre-commit\", \"tox\"]\n\n[[package]]\nname = \"protobuf\"\nversion = \"4.25.3\"\ndescription = \"\"\noptional = false\npython-versions = \">=3.8\"\nfiles = [\n    {file = \"protobuf-4.25.3-cp310-abi3-win32.whl\", hash = \"sha256:d4198877797a83cbfe9bffa3803602bbe1625dc30d8a097365dbc762e5790faa\"},\n    {file = \"protobuf-4.25.3-cp310-abi3-win_amd64.whl\", hash = \"sha256:209ba4cc916bab46f64e56b85b090607a676f66b473e6b762e6f1d9d591eb2e8\"},\n    {file = \"protobuf-4.25.3-cp37-abi3-macosx_10_9_universal2.whl\", hash = \"sha256:f1279ab38ecbfae7e456a108c5c0681e4956d5b1090027c1de0f934dfdb4b35c\"},\n    {file = \"protobuf-4.25.3-cp37-abi3-manylinux2014_aarch64.whl\", hash = \"sha256:e7cb0ae90dd83727f0c0718634ed56837bfeeee29a5f82a7514c03ee1364c019\"},\n    {file = \"protobuf-4.25.3-cp37-abi3-manylinux2014_x86_64.whl\", hash = \"sha256:7c8daa26095f82482307bc717364e7c13f4f1c99659be82890dcfc215194554d\"},\n    {file = \"protobuf-4.25.3-cp38-cp38-win32.whl\", hash = \"sha256:f4f118245c4a087776e0a8408be33cf09f6c547442c00395fbfb116fac2f8ac2\"},\n    {file = \"protobuf-4.25.3-cp38-cp38-win_amd64.whl\", hash = \"sha256:c053062984e61144385022e53678fbded7aea14ebb3e0305ae3592fb219ccfa4\"},\n    {file = \"protobuf-4.25.3-cp39-cp39-win32.whl\", hash = \"sha256:19b270aeaa0099f16d3ca02628546b8baefe2955bbe23224aaf856134eccf1e4\"},\n    {file = \"protobuf-4.25.3-cp39-cp39-win_amd64.whl\", hash = \"sha256:e3c97a1555fd6388f857770ff8b9703083de6bf1f9274a002a332d65fbb56c8c\"},\n    {file = \"protobuf-4.25.3-py3-none-any.whl\", hash = \"sha256:f0700d54bcf45424477e46a9f0944155b46fb0639d69728739c0e47bab83f2b9\"},\n    {file = \"protobuf-4.25.3.tar.gz\", hash = \"sha256:25b5d0b42fd000320bd7830b349e3b696435f3b329810427a6bcce6a5492cc5c\"},\n]\n\n[[package]]\nname = \"py\"\nversion = \"1.11.0\"\ndescription = \"library with cross-python path, ini-parsing, io, code, log facilities\"\noptional = false\npython-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*\"\nfiles = [\n    {file = \"py-1.11.0-py2.py3-none-any.whl\", hash = \"sha256:607c53218732647dff4acdfcd50cb62615cedf612e72d1724fb1a0cc6405b378\"},\n    {file = \"py-1.11.0.tar.gz\", hash = \"sha256:51c75c4126074b472f746a24399ad32f6053d1b34b68d2fa41e558e6f4a98719\"},\n]\n\n[[package]]\nname = \"pytest\"\nversion = \"5.4.3\"\ndescription = \"pytest: simple powerful testing with Python\"\noptional = false\npython-versions = \">=3.5\"\nfiles = [\n    {file = \"pytest-5.4.3-py3-none-any.whl\", hash = \"sha256:5c0db86b698e8f170ba4582a492248919255fcd4c79b1ee64ace34301fb589a1\"},\n    {file = \"pytest-5.4.3.tar.gz\", hash = \"sha256:7979331bfcba207414f5e1263b5a0f8f521d0f457318836a7355531ed1a4c7d8\"},\n]\n\n[package.dependencies]\natomicwrites = {version = \">=1.0\", markers = \"sys_platform == \\\"win32\\\"\"}\nattrs = \">=17.4.0\"\ncolorama = {version = \"*\", markers = \"sys_platform == \\\"win32\\\"\"}\nmore-itertools = \">=4.0.0\"\npackaging = \"*\"\npluggy = \">=0.12,<1.0\"\npy = \">=1.5.0\"\nwcwidth = \"*\"\n\n[package.extras]\ncheckqa-mypy = [\"mypy (==v0.761)\"]\ntesting = [\"argcomplete\", \"hypothesis (>=3.56)\", \"mock\", \"nose\", \"requests\", \"xmlschema\"]\n\n[[package]]\nname = \"pyyaml\"\nversion = \"6.0.1\"\ndescription = \"YAML parser and emitter for Python\"\noptional = false\npython-versions = \">=3.6\"\nfiles = [\n    {file = \"PyYAML-6.0.1-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:d858aa552c999bc8a8d57426ed01e40bef403cd8ccdd0fc5f6f04a00414cac2a\"},\n    {file = \"PyYAML-6.0.1-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:fd66fc5d0da6d9815ba2cebeb4205f95818ff4b79c3ebe268e75d961704af52f\"},\n    {file = \"PyYAML-6.0.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:69b023b2b4daa7548bcfbd4aa3da05b3a74b772db9e23b982788168117739938\"},\n    {file = \"PyYAML-6.0.1-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:81e0b275a9ecc9c0c0c07b4b90ba548307583c125f54d5b6946cfee6360c733d\"},\n    {file = \"PyYAML-6.0.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:ba336e390cd8e4d1739f42dfe9bb83a3cc2e80f567d8805e11b46f4a943f5515\"},\n    {file = \"PyYAML-6.0.1-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:326c013efe8048858a6d312ddd31d56e468118ad4cdeda36c719bf5bb6192290\"},\n    {file = \"PyYAML-6.0.1-cp310-cp310-win32.whl\", hash = \"sha256:bd4af7373a854424dabd882decdc5579653d7868b8fb26dc7d0e99f823aa5924\"},\n    {file = \"PyYAML-6.0.1-cp310-cp310-win_amd64.whl\", hash = \"sha256:fd1592b3fdf65fff2ad0004b5e363300ef59ced41c2e6b3a99d4089fa8c5435d\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:6965a7bc3cf88e5a1c3bd2e0b5c22f8d677dc88a455344035f03399034eb3007\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:f003ed9ad21d6a4713f0a9b5a7a0a79e08dd0f221aff4525a2be4c346ee60aab\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:42f8152b8dbc4fe7d96729ec2b99c7097d656dc1213a3229ca5383f973a5ed6d\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:062582fca9fabdd2c8b54a3ef1c978d786e0f6b3a1510e0ac93ef59e0ddae2bc\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:d2b04aac4d386b172d5b9692e2d2da8de7bfb6c387fa4f801fbf6fb2e6ba4673\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:e7d73685e87afe9f3b36c799222440d6cf362062f78be1013661b00c5c6f678b\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-win32.whl\", hash = \"sha256:1635fd110e8d85d55237ab316b5b011de701ea0f29d07611174a1b42f1444741\"},\n    {file = \"PyYAML-6.0.1-cp311-cp311-win_amd64.whl\", hash = \"sha256:bf07ee2fef7014951eeb99f56f39c9bb4af143d8aa3c21b1677805985307da34\"},\n    {file = \"PyYAML-6.0.1-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:855fb52b0dc35af121542a76b9a84f8d1cd886ea97c84703eaa6d88e37a2ad28\"},\n    {file = \"PyYAML-6.0.1-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:40df9b996c2b73138957fe23a16a4f0ba614f4c0efce1e9406a184b6d07fa3a9\"},\n    {file = \"PyYAML-6.0.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:a08c6f0fe150303c1c6b71ebcd7213c2858041a7e01975da3a99aed1e7a378ef\"},\n    {file = \"PyYAML-6.0.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6c22bec3fbe2524cde73d7ada88f6566758a8f7227bfbf93a408a9d86bcc12a0\"},\n    {file = \"PyYAML-6.0.1-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:8d4e9c88387b0f5c7d5f281e55304de64cf7f9c0021a3525bd3b1c542da3b0e4\"},\n    {file = \"PyYAML-6.0.1-cp312-cp312-win32.whl\", hash = \"sha256:d483d2cdf104e7c9fa60c544d92981f12ad66a457afae824d146093b8c294c54\"},\n    {file = \"PyYAML-6.0.1-cp312-cp312-win_amd64.whl\", hash = \"sha256:0d3304d8c0adc42be59c5f8a4d9e3d7379e6955ad754aa9d6ab7a398b59dd1df\"},\n    {file = \"PyYAML-6.0.1-cp36-cp36m-macosx_10_9_x86_64.whl\", hash = \"sha256:50550eb667afee136e9a77d6dc71ae76a44df8b3e51e41b77f6de2932bfe0f47\"},\n    {file = \"PyYAML-6.0.1-cp36-cp36m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:1fe35611261b29bd1de0070f0b2f47cb6ff71fa6595c077e42bd0c419fa27b98\"},\n    {file = \"PyYAML-6.0.1-cp36-cp36m-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:704219a11b772aea0d8ecd7058d0082713c3562b4e271b849ad7dc4a5c90c13c\"},\n    {file = \"PyYAML-6.0.1-cp36-cp36m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:afd7e57eddb1a54f0f1a974bc4391af8bcce0b444685d936840f125cf046d5bd\"},\n    {file = \"PyYAML-6.0.1-cp36-cp36m-win32.whl\", hash = \"sha256:fca0e3a251908a499833aa292323f32437106001d436eca0e6e7833256674585\"},\n    {file = \"PyYAML-6.0.1-cp36-cp36m-win_amd64.whl\", hash = \"sha256:f22ac1c3cac4dbc50079e965eba2c1058622631e526bd9afd45fedd49ba781fa\"},\n    {file = \"PyYAML-6.0.1-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:b1275ad35a5d18c62a7220633c913e1b42d44b46ee12554e5fd39c70a243d6a3\"},\n    {file = \"PyYAML-6.0.1-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:18aeb1bf9a78867dc38b259769503436b7c72f7a1f1f4c93ff9a17de54319b27\"},\n    {file = \"PyYAML-6.0.1-cp37-cp37m-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:596106435fa6ad000c2991a98fa58eeb8656ef2325d7e158344fb33864ed87e3\"},\n    {file = \"PyYAML-6.0.1-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:baa90d3f661d43131ca170712d903e6295d1f7a0f595074f151c0aed377c9b9c\"},\n    {file = \"PyYAML-6.0.1-cp37-cp37m-win32.whl\", hash = \"sha256:9046c58c4395dff28dd494285c82ba00b546adfc7ef001486fbf0324bc174fba\"},\n    {file = \"PyYAML-6.0.1-cp37-cp37m-win_amd64.whl\", hash = \"sha256:4fb147e7a67ef577a588a0e2c17b6db51dda102c71de36f8549b6816a96e1867\"},\n    {file = \"PyYAML-6.0.1-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:1d4c7e777c441b20e32f52bd377e0c409713e8bb1386e1099c2415f26e479595\"},\n    {file = \"PyYAML-6.0.1-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:a0cd17c15d3bb3fa06978b4e8958dcdc6e0174ccea823003a106c7d4d7899ac5\"},\n    {file = \"PyYAML-6.0.1-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:28c119d996beec18c05208a8bd78cbe4007878c6dd15091efb73a30e90539696\"},\n    {file = \"PyYAML-6.0.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:7e07cbde391ba96ab58e532ff4803f79c4129397514e1413a7dc761ccd755735\"},\n    {file = \"PyYAML-6.0.1-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:49a183be227561de579b4a36efbb21b3eab9651dd81b1858589f796549873dd6\"},\n    {file = \"PyYAML-6.0.1-cp38-cp38-win32.whl\", hash = \"sha256:184c5108a2aca3c5b3d3bf9395d50893a7ab82a38004c8f61c258d4428e80206\"},\n    {file = \"PyYAML-6.0.1-cp38-cp38-win_amd64.whl\", hash = \"sha256:1e2722cc9fbb45d9b87631ac70924c11d3a401b2d7f410cc0e3bbf249f2dca62\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:9eb6caa9a297fc2c2fb8862bc5370d0303ddba53ba97e71f08023b6cd73d16a8\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:c8098ddcc2a85b61647b2590f825f3db38891662cfc2fc776415143f599bb859\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:5773183b6446b2c99bb77e77595dd486303b4faab2b086e7b17bc6bef28865f6\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:b786eecbdf8499b9ca1d697215862083bd6d2a99965554781d0d8d1ad31e13a0\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:bc1bf2925a1ecd43da378f4db9e4f799775d6367bdb94671027b73b393a7c42c\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:04ac92ad1925b2cff1db0cfebffb6ffc43457495c9b3c39d3fcae417d7125dc5\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-win32.whl\", hash = \"sha256:faca3bdcf85b2fc05d06ff3fbc1f83e1391b3e724afa3feba7d13eeab355484c\"},\n    {file = \"PyYAML-6.0.1-cp39-cp39-win_amd64.whl\", hash = \"sha256:510c9deebc5c0225e8c96813043e62b680ba2f9c50a08d3724c7f28a747d1486\"},\n    {file = \"PyYAML-6.0.1.tar.gz\", hash = \"sha256:bfdf460b1736c775f2ba9f6a92bca30bc2095067b8a9d77876d1fad6cc3b4a43\"},\n]\n\n[[package]]\nname = \"regex\"\nversion = \"2023.12.25\"\ndescription = \"Alternative regular expression module, to replace re.\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"regex-2023.12.25-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:0694219a1d54336fd0445ea382d49d36882415c0134ee1e8332afd1529f0baa5\"},\n    {file = \"regex-2023.12.25-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:b014333bd0217ad3d54c143de9d4b9a3ca1c5a29a6d0d554952ea071cff0f1f8\"},\n    {file = \"regex-2023.12.25-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:d865984b3f71f6d0af64d0d88f5733521698f6c16f445bb09ce746c92c97c586\"},\n    {file = \"regex-2023.12.25-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:1e0eabac536b4cc7f57a5f3d095bfa557860ab912f25965e08fe1545e2ed8b4c\"},\n    {file = \"regex-2023.12.25-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:c25a8ad70e716f96e13a637802813f65d8a6760ef48672aa3502f4c24ea8b400\"},\n    {file = \"regex-2023.12.25-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:a9b6d73353f777630626f403b0652055ebfe8ff142a44ec2cf18ae470395766e\"},\n    {file = \"regex-2023.12.25-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:a9cc99d6946d750eb75827cb53c4371b8b0fe89c733a94b1573c9dd16ea6c9e4\"},\n    {file = \"regex-2023.12.25-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:88d1f7bef20c721359d8675f7d9f8e414ec5003d8f642fdfd8087777ff7f94b5\"},\n    {file = \"regex-2023.12.25-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:cb3fe77aec8f1995611f966d0c656fdce398317f850d0e6e7aebdfe61f40e1cd\"},\n    {file = \"regex-2023.12.25-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:7aa47c2e9ea33a4a2a05f40fcd3ea36d73853a2aae7b4feab6fc85f8bf2c9704\"},\n    {file = \"regex-2023.12.25-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:df26481f0c7a3f8739fecb3e81bc9da3fcfae34d6c094563b9d4670b047312e1\"},\n    {file = \"regex-2023.12.25-cp310-cp310-musllinux_1_1_ppc64le.whl\", hash = \"sha256:c40281f7d70baf6e0db0c2f7472b31609f5bc2748fe7275ea65a0b4601d9b392\"},\n    {file = \"regex-2023.12.25-cp310-cp310-musllinux_1_1_s390x.whl\", hash = \"sha256:d94a1db462d5690ebf6ae86d11c5e420042b9898af5dcf278bd97d6bda065423\"},\n    {file = \"regex-2023.12.25-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:ba1b30765a55acf15dce3f364e4928b80858fa8f979ad41f862358939bdd1f2f\"},\n    {file = \"regex-2023.12.25-cp310-cp310-win32.whl\", hash = \"sha256:150c39f5b964e4d7dba46a7962a088fbc91f06e606f023ce57bb347a3b2d4630\"},\n    {file = \"regex-2023.12.25-cp310-cp310-win_amd64.whl\", hash = \"sha256:09da66917262d9481c719599116c7dc0c321ffcec4b1f510c4f8a066f8768105\"},\n    {file = \"regex-2023.12.25-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:1b9d811f72210fa9306aeb88385b8f8bcef0dfbf3873410413c00aa94c56c2b6\"},\n    {file = \"regex-2023.12.25-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:d902a43085a308cef32c0d3aea962524b725403fd9373dea18110904003bac97\"},\n    {file = \"regex-2023.12.25-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:d166eafc19f4718df38887b2bbe1467a4f74a9830e8605089ea7a30dd4da8887\"},\n    {file = \"regex-2023.12.25-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:c7ad32824b7f02bb3c9f80306d405a1d9b7bb89362d68b3c5a9be53836caebdb\"},\n    {file = \"regex-2023.12.25-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:636ba0a77de609d6510235b7f0e77ec494d2657108f777e8765efc060094c98c\"},\n    {file = \"regex-2023.12.25-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:0fda75704357805eb953a3ee15a2b240694a9a514548cd49b3c5124b4e2ad01b\"},\n    {file = \"regex-2023.12.25-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f72cbae7f6b01591f90814250e636065850c5926751af02bb48da94dfced7baa\"},\n    {file = \"regex-2023.12.25-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:db2a0b1857f18b11e3b0e54ddfefc96af46b0896fb678c85f63fb8c37518b3e7\"},\n    {file = \"regex-2023.12.25-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:7502534e55c7c36c0978c91ba6f61703faf7ce733715ca48f499d3dbbd7657e0\"},\n    {file = \"regex-2023.12.25-cp311-cp311-musllinux_1_1_i686.whl\", hash = \"sha256:e8c7e08bb566de4faaf11984af13f6bcf6a08f327b13631d41d62592681d24fe\"},\n    {file = \"regex-2023.12.25-cp311-cp311-musllinux_1_1_ppc64le.whl\", hash = \"sha256:283fc8eed679758de38fe493b7d7d84a198b558942b03f017b1f94dda8efae80\"},\n    {file = \"regex-2023.12.25-cp311-cp311-musllinux_1_1_s390x.whl\", hash = \"sha256:f44dd4d68697559d007462b0a3a1d9acd61d97072b71f6d1968daef26bc744bd\"},\n    {file = \"regex-2023.12.25-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:67d3ccfc590e5e7197750fcb3a2915b416a53e2de847a728cfa60141054123d4\"},\n    {file = \"regex-2023.12.25-cp311-cp311-win32.whl\", hash = \"sha256:68191f80a9bad283432385961d9efe09d783bcd36ed35a60fb1ff3f1ec2efe87\"},\n    {file = \"regex-2023.12.25-cp311-cp311-win_amd64.whl\", hash = \"sha256:7d2af3f6b8419661a0c421584cfe8aaec1c0e435ce7e47ee2a97e344b98f794f\"},\n    {file = \"regex-2023.12.25-cp312-cp312-macosx_10_9_universal2.whl\", hash = \"sha256:8a0ccf52bb37d1a700375a6b395bff5dd15c50acb745f7db30415bae3c2b0715\"},\n    {file = \"regex-2023.12.25-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:c3c4a78615b7762740531c27cf46e2f388d8d727d0c0c739e72048beb26c8a9d\"},\n    {file = \"regex-2023.12.25-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:ad83e7545b4ab69216cef4cc47e344d19622e28aabec61574b20257c65466d6a\"},\n    {file = \"regex-2023.12.25-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:b7a635871143661feccce3979e1727c4e094f2bdfd3ec4b90dfd4f16f571a87a\"},\n    {file = \"regex-2023.12.25-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:d498eea3f581fbe1b34b59c697512a8baef88212f92e4c7830fcc1499f5b45a5\"},\n    {file = \"regex-2023.12.25-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:43f7cd5754d02a56ae4ebb91b33461dc67be8e3e0153f593c509e21d219c5060\"},\n    {file = \"regex-2023.12.25-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:51f4b32f793812714fd5307222a7f77e739b9bc566dc94a18126aba3b92b98a3\"},\n    {file = \"regex-2023.12.25-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:ba99d8077424501b9616b43a2d208095746fb1284fc5ba490139651f971d39d9\"},\n    {file = \"regex-2023.12.25-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:4bfc2b16e3ba8850e0e262467275dd4d62f0d045e0e9eda2bc65078c0110a11f\"},\n    {file = \"regex-2023.12.25-cp312-cp312-musllinux_1_1_i686.whl\", hash = \"sha256:8c2c19dae8a3eb0ea45a8448356ed561be843b13cbc34b840922ddf565498c1c\"},\n    {file = \"regex-2023.12.25-cp312-cp312-musllinux_1_1_ppc64le.whl\", hash = \"sha256:60080bb3d8617d96f0fb7e19796384cc2467447ef1c491694850ebd3670bc457\"},\n    {file = \"regex-2023.12.25-cp312-cp312-musllinux_1_1_s390x.whl\", hash = \"sha256:b77e27b79448e34c2c51c09836033056a0547aa360c45eeeb67803da7b0eedaf\"},\n    {file = \"regex-2023.12.25-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:518440c991f514331f4850a63560321f833979d145d7d81186dbe2f19e27ae3d\"},\n    {file = \"regex-2023.12.25-cp312-cp312-win32.whl\", hash = \"sha256:e2610e9406d3b0073636a3a2e80db05a02f0c3169b5632022b4e81c0364bcda5\"},\n    {file = \"regex-2023.12.25-cp312-cp312-win_amd64.whl\", hash = \"sha256:cc37b9aeebab425f11f27e5e9e6cf580be7206c6582a64467a14dda211abc232\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:da695d75ac97cb1cd725adac136d25ca687da4536154cdc2815f576e4da11c69\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d126361607b33c4eb7b36debc173bf25d7805847346dd4d99b5499e1fef52bc7\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:4719bb05094d7d8563a450cf8738d2e1061420f79cfcc1fa7f0a44744c4d8f73\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:5dd58946bce44b53b06d94aa95560d0b243eb2fe64227cba50017a8d8b3cd3e2\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:22a86d9fff2009302c440b9d799ef2fe322416d2d58fc124b926aa89365ec482\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:2aae8101919e8aa05ecfe6322b278f41ce2994c4a430303c4cd163fef746e04f\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:e692296c4cc2873967771345a876bcfc1c547e8dd695c6b89342488b0ea55cd8\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:263ef5cc10979837f243950637fffb06e8daed7f1ac1e39d5910fd29929e489a\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:d6f7e255e5fa94642a0724e35406e6cb7001c09d476ab5fce002f652b36d0c39\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-musllinux_1_1_ppc64le.whl\", hash = \"sha256:88ad44e220e22b63b0f8f81f007e8abbb92874d8ced66f32571ef8beb0643b2b\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-musllinux_1_1_s390x.whl\", hash = \"sha256:3a17d3ede18f9cedcbe23d2daa8a2cd6f59fe2bf082c567e43083bba3fb00347\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:d15b274f9e15b1a0b7a45d2ac86d1f634d983ca40d6b886721626c47a400bf39\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-win32.whl\", hash = \"sha256:ed19b3a05ae0c97dd8f75a5d8f21f7723a8c33bbc555da6bbe1f96c470139d3c\"},\n    {file = \"regex-2023.12.25-cp37-cp37m-win_amd64.whl\", hash = \"sha256:a6d1047952c0b8104a1d371f88f4ab62e6275567d4458c1e26e9627ad489b445\"},\n    {file = \"regex-2023.12.25-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:b43523d7bc2abd757119dbfb38af91b5735eea45537ec6ec3a5ec3f9562a1c53\"},\n    {file = \"regex-2023.12.25-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:efb2d82f33b2212898f1659fb1c2e9ac30493ac41e4d53123da374c3b5541e64\"},\n    {file = \"regex-2023.12.25-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:b7fca9205b59c1a3d5031f7e64ed627a1074730a51c2a80e97653e3e9fa0d415\"},\n    {file = \"regex-2023.12.25-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:086dd15e9435b393ae06f96ab69ab2d333f5d65cbe65ca5a3ef0ec9564dfe770\"},\n    {file = \"regex-2023.12.25-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:e81469f7d01efed9b53740aedd26085f20d49da65f9c1f41e822a33992cb1590\"},\n    {file = \"regex-2023.12.25-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:34e4af5b27232f68042aa40a91c3b9bb4da0eeb31b7632e0091afc4310afe6cb\"},\n    {file = \"regex-2023.12.25-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:9852b76ab558e45b20bf1893b59af64a28bd3820b0c2efc80e0a70a4a3ea51c1\"},\n    {file = \"regex-2023.12.25-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:ff100b203092af77d1a5a7abe085b3506b7eaaf9abf65b73b7d6905b6cb76988\"},\n    {file = \"regex-2023.12.25-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:cc038b2d8b1470364b1888a98fd22d616fba2b6309c5b5f181ad4483e0017861\"},\n    {file = \"regex-2023.12.25-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:094ba386bb5c01e54e14434d4caabf6583334090865b23ef58e0424a6286d3dc\"},\n    {file = \"regex-2023.12.25-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:5cd05d0f57846d8ba4b71d9c00f6f37d6b97d5e5ef8b3c3840426a475c8f70f4\"},\n    {file = \"regex-2023.12.25-cp38-cp38-musllinux_1_1_ppc64le.whl\", hash = \"sha256:9aa1a67bbf0f957bbe096375887b2505f5d8ae16bf04488e8b0f334c36e31360\"},\n    {file = \"regex-2023.12.25-cp38-cp38-musllinux_1_1_s390x.whl\", hash = \"sha256:98a2636994f943b871786c9e82bfe7883ecdaba2ef5df54e1450fa9869d1f756\"},\n    {file = \"regex-2023.12.25-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:37f8e93a81fc5e5bd8db7e10e62dc64261bcd88f8d7e6640aaebe9bc180d9ce2\"},\n    {file = \"regex-2023.12.25-cp38-cp38-win32.whl\", hash = \"sha256:d78bd484930c1da2b9679290a41cdb25cc127d783768a0369d6b449e72f88beb\"},\n    {file = \"regex-2023.12.25-cp38-cp38-win_amd64.whl\", hash = \"sha256:b521dcecebc5b978b447f0f69b5b7f3840eac454862270406a39837ffae4e697\"},\n    {file = \"regex-2023.12.25-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:f7bc09bc9c29ebead055bcba136a67378f03d66bf359e87d0f7c759d6d4ffa31\"},\n    {file = \"regex-2023.12.25-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:e14b73607d6231f3cc4622809c196b540a6a44e903bcfad940779c80dffa7be7\"},\n    {file = \"regex-2023.12.25-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:9eda5f7a50141291beda3edd00abc2d4a5b16c29c92daf8d5bd76934150f3edc\"},\n    {file = \"regex-2023.12.25-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:cc6bb9aa69aacf0f6032c307da718f61a40cf970849e471254e0e91c56ffca95\"},\n    {file = \"regex-2023.12.25-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:298dc6354d414bc921581be85695d18912bea163a8b23cac9a2562bbcd5088b1\"},\n    {file = \"regex-2023.12.25-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:2f4e475a80ecbd15896a976aa0b386c5525d0ed34d5c600b6d3ebac0a67c7ddf\"},\n    {file = \"regex-2023.12.25-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:531ac6cf22b53e0696f8e1d56ce2396311254eb806111ddd3922c9d937151dae\"},\n    {file = \"regex-2023.12.25-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:22f3470f7524b6da61e2020672df2f3063676aff444db1daa283c2ea4ed259d6\"},\n    {file = \"regex-2023.12.25-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl\", hash = \"sha256:89723d2112697feaa320c9d351e5f5e7b841e83f8b143dba8e2d2b5f04e10923\"},\n    {file = \"regex-2023.12.25-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:0ecf44ddf9171cd7566ef1768047f6e66975788258b1c6c6ca78098b95cf9a3d\"},\n    {file = \"regex-2023.12.25-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:905466ad1702ed4acfd67a902af50b8db1feeb9781436372261808df7a2a7bca\"},\n    {file = \"regex-2023.12.25-cp39-cp39-musllinux_1_1_ppc64le.whl\", hash = \"sha256:4558410b7a5607a645e9804a3e9dd509af12fb72b9825b13791a37cd417d73a5\"},\n    {file = \"regex-2023.12.25-cp39-cp39-musllinux_1_1_s390x.whl\", hash = \"sha256:7e316026cc1095f2a3e8cc012822c99f413b702eaa2ca5408a513609488cb62f\"},\n    {file = \"regex-2023.12.25-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:3b1de218d5375cd6ac4b5493e0b9f3df2be331e86520f23382f216c137913d20\"},\n    {file = \"regex-2023.12.25-cp39-cp39-win32.whl\", hash = \"sha256:11a963f8e25ab5c61348d090bf1b07f1953929c13bd2309a0662e9ff680763c9\"},\n    {file = \"regex-2023.12.25-cp39-cp39-win_amd64.whl\", hash = \"sha256:e693e233ac92ba83a87024e1d32b5f9ab15ca55ddd916d878146f4e3406b5c91\"},\n    {file = \"regex-2023.12.25.tar.gz\", hash = \"sha256:29171aa128da69afdf4bde412d5bedc335f2ca8fcfe4489038577d05f16181e5\"},\n]\n\n[[package]]\nname = \"requests\"\nversion = \"2.31.0\"\ndescription = \"Python HTTP for Humans.\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"requests-2.31.0-py3-none-any.whl\", hash = \"sha256:58cd2187c01e70e6e26505bca751777aa9f2ee0b7f4300988b709f44e013003f\"},\n    {file = \"requests-2.31.0.tar.gz\", hash = \"sha256:942c5a758f98d790eaed1a29cb6eefc7ffb0d1cf7af05c3d2791656dbd6ad1e1\"},\n]\n\n[package.dependencies]\ncertifi = \">=2017.4.17\"\ncharset-normalizer = \">=2,<4\"\nidna = \">=2.5,<4\"\nurllib3 = \">=1.21.1,<3\"\n\n[package.extras]\nsocks = [\"PySocks (>=1.5.6,!=1.5.7)\"]\nuse-chardet-on-py3 = [\"chardet (>=3.0.2,<6)\"]\n\n[[package]]\nname = \"safetensors\"\nversion = \"0.4.2\"\ndescription = \"\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"safetensors-0.4.2-cp310-cp310-macosx_10_12_x86_64.whl\", hash = \"sha256:69d8bb8384dc2cb5b72c36c4d6980771b293d1a1377b378763f5e37b6bb8d133\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:3d420e19fcef96d0067f4de4699682b4bbd85fc8fea0bd45fcd961fdf3e8c82c\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:9ca54742122fa3c4821754adb67318e1cd25c3a22bbf0c5520d5176e77a099ac\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:8b47aa643afdfd66cf7ce4c184092ae734e15d10aba2c2948f24270211801c3c\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:d88a16bbc330f27e7f2d4caaf6fb061ad0b8a756ecc4033260b0378e128ce8a2\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:e9223b8ac21085db614a510eb3445e7083cae915a9202357555fa939695d4f57\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:ce6cb86133dc8930a7ab5e7438545a7f205f7a1cdd5aaf108c1d0da6bdcfbc2b\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:b8a628e0ae2bbc334b62952c384aa5f41621d01850f8d67b04a96b9c39dd7326\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:88d6beb7f811a081e0e5f1d9669fdac816c45340c04b1eaf7ebfda0ce93ea403\"},\n    {file = \"safetensors-0.4.2-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:b57fc5b1b54cb12d8690a58a4cf4b7144730d4bde9d98aa0e1dab6295a1cd579\"},\n    {file = \"safetensors-0.4.2-cp310-none-win32.whl\", hash = \"sha256:9d87a1c98803c16cf113b9ba03f07b2dce5e8eabfd1811a7f7323fcaa2a1bf47\"},\n    {file = \"safetensors-0.4.2-cp310-none-win_amd64.whl\", hash = \"sha256:18930ec1d1ecb526d3d9835abc2489b8f1530877518f0c541e77ef0b7abcbd99\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-macosx_10_12_x86_64.whl\", hash = \"sha256:c5dd2ed788730ed56b415d1a11c62026b8cc8c573f55a2092afb3ab383e94fff\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:cc41791b33efb9c83a59b731619f3d15f543dfe71f3a793cb8fbf9bd5d0d5d71\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:4c888bf71d5ca12a720f1ed87d407c4918afa022fb247a6546d8fac15b1f112b\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:e6b2feb4b47226a16a792e6fac3f49442714884a3d4c1008569d5068a3941be9\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:f41cc0ee4b838ae8f4d8364a1b162067693d11a3893f0863be8c228d40e4d0ee\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:51b7228e46c0a483c40ba4b9470dea00fb1ff8685026bb4766799000f6328ac2\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:02697f8f2be8ca3c37a4958702dbdb1864447ef765e18b5328a1617022dcf164\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:27fd8f65cf7c80e4280cae1ee6bcd85c483882f6580821abe71ee1a0d3dcfca7\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:c487b5f113b0924c9534a07dc034830fb4ef05ce9bb6d78cfe016a7dedfe281f\"},\n    {file = \"safetensors-0.4.2-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:da7f6483f3fe67ff39b3a55552552c67930ea10a36e9f2539d36fc205273d767\"},\n    {file = \"safetensors-0.4.2-cp311-none-win32.whl\", hash = \"sha256:52a7012f6cb9cb4a132760b6308daede18a9f5f8952ce08adc7c67a7d865c2d8\"},\n    {file = \"safetensors-0.4.2-cp311-none-win_amd64.whl\", hash = \"sha256:4d1361a097ac430b310ce9eed8ed4746edee33ddafdfbb965debc8966fc34dc2\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-macosx_10_12_x86_64.whl\", hash = \"sha256:77af8aa0edcc2863760fd6febbfdb82e88fd75d0e60c1ce4ba57208ba5e4a89b\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:846666c1c5a8c8888d2dfda8d3921cb9cb8e2c5f78365be756c11021e75a0a2a\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:4f4bfc7ea19b446bfad41510d4b4c76101698c00caaa8a332c8edd8090a412ef\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:233436fd30f27ffeb3c3780d0b84f496518868445c7a8db003639a649cc98453\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:7a09237a795d11cd11f9dae505d170a29b5616151db1e10c14f892b11caadc7d\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:de01c9a3a3b7b69627d624ff69d9f11d28ce9908eea2fb6245adafa4b1d43df6\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:8c1f25c5069ee42a5bcffdc66c300a407941edd73f3239e9fdefd26216407391\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:7a73b3649456d09ca8506140d44484b63154a7378434cc1e8719f8056550b224\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:e1625a8d07d046e968bd5c4961810aba1225984e4fb9243626f9d04a06ed3fee\"},\n    {file = \"safetensors-0.4.2-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:8f74c86b25615cb24ad4cff765a2eefc09d71bf0fed97588cf585aad9c38fbb4\"},\n    {file = \"safetensors-0.4.2-cp312-none-win32.whl\", hash = \"sha256:8523b9c5777d771bcde5c2389c03f1cdf7ebe8797432a1bd5e345efe25c55987\"},\n    {file = \"safetensors-0.4.2-cp312-none-win_amd64.whl\", hash = \"sha256:dcff0243e1737a21f83d664c63fed89d1f532c23fc6830d0427279fabd789ccb\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-macosx_10_12_x86_64.whl\", hash = \"sha256:96ad3d7d472612e26cbe413922b4fb13933310f0511d346ea5cc9a1e856e52eb\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-macosx_11_0_arm64.whl\", hash = \"sha256:88250922401b5ae4e37de929178caf46be47ed16c817b2237b81679bec07c120\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d40443554142fc0ab30652d5cc8554c4b7a613513bde00373e18afd5de8cbe4b\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:27f53f70106224d32d874aacecbeb4a6e4c5b16a1d2006d0e876d97229086d71\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:cc068afe23734dfb26ce19db0a7877499ddf73b1d55ceb762417e8da4a1b05fb\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:9be1918eb8d43a11a6f8806759fccfa0eeb0542b12924caba66af8a7800ad01a\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:41911087d20a7bbd78cb4ad4f98aab0c431533107584df6635d8b54b99945573\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:50771c662aab909f31e94d048e76861fd027d66076ea773eef2e66c717766e24\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-musllinux_1_1_aarch64.whl\", hash = \"sha256:13f2e57be007b7ea9329133d2399e6bdfcf1910f655440a4da17df3a45afcd30\"},\n    {file = \"safetensors-0.4.2-cp313-cp313-musllinux_1_1_x86_64.whl\", hash = \"sha256:c772147e6395bc829842e0a98e1b30c67fe25d816299c28196488511d5a5e951\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-macosx_10_12_x86_64.whl\", hash = \"sha256:36239a0060b537a3e8c473df78cffee14c3ec4f51d5f1a853af99371a2fb2a35\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-macosx_11_0_arm64.whl\", hash = \"sha256:d0cbb7664fad2c307f95195f951b7059e95dc23e0e1822e5978c8b500098543c\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:2b3e55adb6bd9dc1c2a341e72f48f075953fa35d173dd8e29a95b3b02d0d1462\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:42f743b3cca863fba53ca57a193f510e5ec359b97f38c282437716b6768e4a25\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:04e6af4a6dbeb06c4e6e7d46cf9c716cbc4cc5ef62584fd8a7c0fe558562df45\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:a492ba21b5c8f14ee5ec9b20f42ba969e53ca1f909a4d04aad736b66a341dcc2\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b25b8233a1a85dc67e39838951cfb01595d792f3b7b644add63edb652992e030\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:fd27e063fbdafe776f7b1714da59110e88f270e86db00788a8fd65f4eacfeba7\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:1b6fa399f251bbeb52029bf5a0ac2878d7705dd3612a2f8895b48e9c11f0367d\"},\n    {file = \"safetensors-0.4.2-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:de642d46b459e4afd5c2020b26c0d6d869a171ea00411897d5776c127cac74f0\"},\n    {file = \"safetensors-0.4.2-cp37-none-win32.whl\", hash = \"sha256:77b72d17754c93bb68f3598182f14d78776e0b9b31682ca5bb2c7c5bd9a75267\"},\n    {file = \"safetensors-0.4.2-cp37-none-win_amd64.whl\", hash = \"sha256:d36ee3244d461cd655aeef493792c3bccf4875282f8407fd9af99e9a41cf2530\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-macosx_10_12_x86_64.whl\", hash = \"sha256:16b6b3884f7876c6b3b23a742428223a7170a5a9dac819d8c12a1569422c4b5a\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:ee25d311493fbbe0be9d395faee46e9d79e8948f461e388ff39e59875ed9a350\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:eed8097968585cd752a1171f86fce9aa1d89a29033e5cd8bec5a502e29f6b7af\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:880e6865cf72cb67f9ab8d04a3c4b49dd95ae92fb1583929ce65aed94e1f685f\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:91290f83daf80ce6d1a7f629b244443c200060a80f908b29d879021409e5ea94\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:3517d568486ab3508a7acc360b82d7a4a3e26b86efdf210a9ecd9d233c40708a\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:e1f43a77eb38540f782999e5dc5645164fe9027d3f0194f6c9a5126168017efa\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:b684d9818aa5d63fddc65f7d0151968037d255d91adf74eba82125b41c680aaa\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:ab1f5d84185f9fefaf21413efb764e4908057b8a9a0b987ede890c353490fd70\"},\n    {file = \"safetensors-0.4.2-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:2bd979642e6c3a517ef4b84ff36c2fee4015664fea05a61154fc565978347553\"},\n    {file = \"safetensors-0.4.2-cp38-none-win32.whl\", hash = \"sha256:11be6e7afed29e5a5628f0aa6214e34bc194da73f558dc69fc7d56e07037422a\"},\n    {file = \"safetensors-0.4.2-cp38-none-win_amd64.whl\", hash = \"sha256:2f7a6e5d29bd2cc340cffaa391fa437b1be9d21a2bd8b8724d2875d13a6ef2a9\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-macosx_10_12_x86_64.whl\", hash = \"sha256:a5a921b4fe6925f9942adff3ebae8c16e0487908c54586a5a42f35b59fd69794\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:b691727228c28f2d82d8a92b2bc26e7a1f129ee40b2f2a3185b5974e038ed47c\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:91ca1056decc4e981248786e87b2a202d4841ee5f99d433f1adf3d44d4bcfa0e\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:55969fd2e6fdb38dc221b0ab380668c21b0efa12a7562db9924759faa3c51757\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:6ae429bfaecc10ab5fe78c93009b3d1656c1581da560041e700eadb497dbe7a4\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:4ff88f194fe4ac50b463a4a6f0c03af9ad72eb5d24ec6d6730af59522e37fedb\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:a80cb48d0a447f8dd18e61813efa7d3f8f8d52edf0f05806abc0c59b83431f57\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:b286fb7adfee70a4189898ac2342b8a67d5f493e6b21b0af89ca8eac1b967cbf\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:0ceeff9ddbab4f78738489eb6682867ae946178776f33699737b2129b5394dc1\"},\n    {file = \"safetensors-0.4.2-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:a26fae748a7488cb3aac381eddfa818c42052c87b5e689fb4c6e82ed58cec209\"},\n    {file = \"safetensors-0.4.2-cp39-none-win32.whl\", hash = \"sha256:039a42ab33c9d68b39706fd38f1922ace26866eff246bf20271edb619f5f848b\"},\n    {file = \"safetensors-0.4.2-cp39-none-win_amd64.whl\", hash = \"sha256:b3a3e1f5b85859e398773f064943b62a4059f225008a2a8ee6add1edcf77cacf\"},\n    {file = \"safetensors-0.4.2-pp310-pypy310_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:4e70d442ad17e8b153ef9095bf48ea64f15a66bf26dc2b6ca94660c154edbc24\"},\n    {file = \"safetensors-0.4.2-pp310-pypy310_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:b90f1d9809caf4ff395951b4703295a68d12907f6945bbc3129e934ff8ae46f6\"},\n    {file = \"safetensors-0.4.2-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:8c7ac9ad3728838006598e296b3ae9f27d80b489effd4685b92d97b3fc4c98f6\"},\n    {file = \"safetensors-0.4.2-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:de5730d77e6ff7f4c7039e20913661ad0ea2f86c09e71c039e73dfdd1f394f08\"},\n    {file = \"safetensors-0.4.2-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:44feb8cb156d6803dcd19fc6b81b27235f29b877660605a6ac35e1da7d64f0e4\"},\n    {file = \"safetensors-0.4.2-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:523a241c33e7c827ab9a3a23760d75c7d062f43dfe55b6b019409f89b0fb52d1\"},\n    {file = \"safetensors-0.4.2-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:fb18300e8eb74291225214f26c9a8ae2110fd61a6c9b5a2ff4c4e0eb1bb9a998\"},\n    {file = \"safetensors-0.4.2-pp37-pypy37_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:fe5437ff9fb116e44f2ab558981249ae63f978392b4576e62fcfe167d353edbc\"},\n    {file = \"safetensors-0.4.2-pp37-pypy37_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d9304a0934ced5a5d272f39de36291dc141dfc152d277f03fb4d65f2fb2ffa7c\"},\n    {file = \"safetensors-0.4.2-pp37-pypy37_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:160ba1b1e11cf874602c233ab80a14f588571d09556cbc3586900121d622b5ed\"},\n    {file = \"safetensors-0.4.2-pp37-pypy37_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:04fcd6fcf7d9c13c7e5dc7e08de5e492ee4daa8f4ad74b4d8299d3eb0224292f\"},\n    {file = \"safetensors-0.4.2-pp37-pypy37_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:906d14c4a677d35834fb0f3a5455ef8305e1bba10a5e0f2e0f357b3d1ad989f2\"},\n    {file = \"safetensors-0.4.2-pp37-pypy37_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:df3fcdec0cd543084610d1f09c65cdb10fb3079f79bceddc092b0d187c6a265b\"},\n    {file = \"safetensors-0.4.2-pp38-pypy38_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:5ca76f13fb1cef242ea3ad2cb37388e7d005994f42af8b44bee56ba48b2d45ce\"},\n    {file = \"safetensors-0.4.2-pp38-pypy38_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:278a1a3414c020785decdcd741c578725721274d2f9f787fcc930882e83b89cc\"},\n    {file = \"safetensors-0.4.2-pp38-pypy38_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:05b5a461cc68ecd42d9d546e5e1268a39d8ede7934a68d1ce17c3c659cb829d6\"},\n    {file = \"safetensors-0.4.2-pp38-pypy38_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:c2341411412a41671d25e26bed59ec121e46bf4fadb8132895e610411c4b9681\"},\n    {file = \"safetensors-0.4.2-pp38-pypy38_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:3497ac3895acf17c5f98197f1fa4769f09c5e7ede07fcb102f1c201e663e052c\"},\n    {file = \"safetensors-0.4.2-pp38-pypy38_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:01b5e71d3754d2201294f1eb7a6d59cce3a5702ff96d83d226571b2ca2183837\"},\n    {file = \"safetensors-0.4.2-pp38-pypy38_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:3627dbd1ea488dd8046a0491de5087f3c0d641e7acc80c0189a33c69398f1cd1\"},\n    {file = \"safetensors-0.4.2-pp39-pypy39_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:9d56f0ef53afad26ec54ceede78a43e9a23a076dadbbda7b44d304c591abf4c1\"},\n    {file = \"safetensors-0.4.2-pp39-pypy39_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:b259ca73d42daf658a1bda463f1f83885ae4d93a60869be80d7f7dfcc9d8bbb5\"},\n    {file = \"safetensors-0.4.2-pp39-pypy39_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:1ebc3cd401e4eb54e7c0a70346be565e81942d9a41fafd5f4bf7ab3a55d10378\"},\n    {file = \"safetensors-0.4.2-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:5bc384a0309b706aa0425c93abb0390508a61bf029ce99c7d9df4220f25871a5\"},\n    {file = \"safetensors-0.4.2-pp39-pypy39_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:af2d8f7235d8a08fbccfb8394387890e7fa38942b349a94e6eff13c52ac98087\"},\n    {file = \"safetensors-0.4.2-pp39-pypy39_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:0911315bbcc5289087d063c2c2c7ccd711ea97a7e557a7bce005ac2cf80146aa\"},\n    {file = \"safetensors-0.4.2-pp39-pypy39_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:1efe31673be91832d73439a2af426743e1395fc9ef7b081914e9e1d567bd7b5f\"},\n    {file = \"safetensors-0.4.2.tar.gz\", hash = \"sha256:acc85dcb09ec5e8aa787f588d7ad4d55c103f31e4ff060e17d92cc0e8b8cac73\"},\n]\n\n[package.extras]\nall = [\"safetensors[jax]\", \"safetensors[numpy]\", \"safetensors[paddlepaddle]\", \"safetensors[pinned-tf]\", \"safetensors[quality]\", \"safetensors[testing]\", \"safetensors[torch]\"]\ndev = [\"safetensors[all]\"]\njax = [\"flax (>=0.6.3)\", \"jax (>=0.3.25)\", \"jaxlib (>=0.3.25)\", \"safetensors[numpy]\"]\nmlx = [\"mlx (>=0.0.9)\"]\nnumpy = [\"numpy (>=1.21.6)\"]\npaddlepaddle = [\"paddlepaddle (>=2.4.1)\", \"safetensors[numpy]\"]\npinned-tf = [\"safetensors[numpy]\", \"tensorflow (==2.11.0)\"]\nquality = [\"black (==22.3)\", \"click (==8.0.4)\", \"flake8 (>=3.8.3)\", \"isort (>=5.5.4)\"]\ntensorflow = [\"safetensors[numpy]\", \"tensorflow (>=2.11.0)\"]\ntesting = [\"h5py (>=3.7.0)\", \"huggingface_hub (>=0.12.1)\", \"hypothesis (>=6.70.2)\", \"pytest (>=7.2.0)\", \"pytest-benchmark (>=4.0.0)\", \"safetensors[numpy]\", \"setuptools_rust (>=1.5.2)\"]\ntorch = [\"safetensors[numpy]\", \"torch (>=1.10)\"]\n\n[[package]]\nname = \"sentencepiece\"\nversion = \"0.1.99\"\ndescription = \"SentencePiece python wrapper\"\noptional = false\npython-versions = \"*\"\nfiles = [\n    {file = \"sentencepiece-0.1.99-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:0eb528e70571b7c02723e5804322469b82fe7ea418c96051d0286c0fa028db73\"},\n    {file = \"sentencepiece-0.1.99-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:77d7fafb2c4e4659cbdf303929503f37a26eabc4ff31d3a79bf1c5a1b338caa7\"},\n    {file = \"sentencepiece-0.1.99-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:be9cf5b9e404c245aeb3d3723c737ba7a8f5d4ba262ef233a431fa6c45f732a0\"},\n    {file = \"sentencepiece-0.1.99-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:baed1a26464998f9710d20e52607c29ffd4293e7c71c6a1f83f51ad0911ec12c\"},\n    {file = \"sentencepiece-0.1.99-cp310-cp310-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:9832f08bb372d4c8b567612f8eab9e36e268dff645f1c28f9f8e851be705f6d1\"},\n    {file = \"sentencepiece-0.1.99-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:019e7535108e309dae2b253a75834fc3128240aa87c00eb80732078cdc182588\"},\n    {file = \"sentencepiece-0.1.99-cp310-cp310-win32.whl\", hash = \"sha256:fa16a830416bb823fa2a52cbdd474d1f7f3bba527fd2304fb4b140dad31bb9bc\"},\n    {file = \"sentencepiece-0.1.99-cp310-cp310-win_amd64.whl\", hash = \"sha256:14b0eccb7b641d4591c3e12ae44cab537d68352e4d3b6424944f0c447d2348d5\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:6d3c56f24183a1e8bd61043ff2c58dfecdc68a5dd8955dc13bab83afd5f76b81\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:ed6ea1819fd612c989999e44a51bf556d0ef6abfb553080b9be3d347e18bcfb7\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:a2a0260cd1fb7bd8b4d4f39dc2444a8d5fd4e0a0c4d5c899810ef1abf99b2d45\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:8a1abff4d1ff81c77cac3cc6fefa34fa4b8b371e5ee51cb7e8d1ebc996d05983\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:004e6a621d4bc88978eecb6ea7959264239a17b70f2cbc348033d8195c9808ec\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:db361e03342c41680afae5807590bc88aa0e17cfd1a42696a160e4005fcda03b\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-win32.whl\", hash = \"sha256:2d95e19168875b70df62916eb55428a0cbcb834ac51d5a7e664eda74def9e1e0\"},\n    {file = \"sentencepiece-0.1.99-cp311-cp311-win_amd64.whl\", hash = \"sha256:f90d73a6f81248a909f55d8e6ef56fec32d559e1e9af045f0b0322637cb8e5c7\"},\n    {file = \"sentencepiece-0.1.99-cp36-cp36m-macosx_10_9_x86_64.whl\", hash = \"sha256:62e24c81e74bd87a6e0d63c51beb6527e4c0add67e1a17bac18bcd2076afcfeb\"},\n    {file = \"sentencepiece-0.1.99-cp36-cp36m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:57efcc2d51caff20d9573567d9fd3f854d9efe613ed58a439c78c9f93101384a\"},\n    {file = \"sentencepiece-0.1.99-cp36-cp36m-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:6a904c46197993bd1e95b93a6e373dca2f170379d64441041e2e628ad4afb16f\"},\n    {file = \"sentencepiece-0.1.99-cp36-cp36m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:d89adf59854741c0d465f0e1525b388c0d174f611cc04af54153c5c4f36088c4\"},\n    {file = \"sentencepiece-0.1.99-cp36-cp36m-win32.whl\", hash = \"sha256:47c378146928690d1bc106fdf0da768cebd03b65dd8405aa3dd88f9c81e35dba\"},\n    {file = \"sentencepiece-0.1.99-cp36-cp36m-win_amd64.whl\", hash = \"sha256:9ba142e7a90dd6d823c44f9870abdad45e6c63958eb60fe44cca6828d3b69da2\"},\n    {file = \"sentencepiece-0.1.99-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:b7b1a9ae4d7c6f1f867e63370cca25cc17b6f4886729595b885ee07a58d3cec3\"},\n    {file = \"sentencepiece-0.1.99-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d0f644c9d4d35c096a538507b2163e6191512460035bf51358794a78515b74f7\"},\n    {file = \"sentencepiece-0.1.99-cp37-cp37m-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:c8843d23a0f686d85e569bd6dcd0dd0e0cbc03731e63497ca6d5bacd18df8b85\"},\n    {file = \"sentencepiece-0.1.99-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:33e6f690a1caebb4867a2e367afa1918ad35be257ecdb3455d2bbd787936f155\"},\n    {file = \"sentencepiece-0.1.99-cp37-cp37m-win32.whl\", hash = \"sha256:8a321866c2f85da7beac74a824b4ad6ddc2a4c9bccd9382529506d48f744a12c\"},\n    {file = \"sentencepiece-0.1.99-cp37-cp37m-win_amd64.whl\", hash = \"sha256:c42f753bcfb7661c122a15b20be7f684b61fc8592c89c870adf52382ea72262d\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:85b476406da69c70586f0bb682fcca4c9b40e5059814f2db92303ea4585c650c\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:cfbcfe13c69d3f87b7fcd5da168df7290a6d006329be71f90ba4f56bc77f8561\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:445b0ec381af1cd4eef95243e7180c63d9c384443c16c4c47a28196bd1cda937\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:c6890ea0f2b4703f62d0bf27932e35808b1f679bdb05c7eeb3812b935ba02001\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:fb71af492b0eefbf9f2501bec97bcd043b6812ab000d119eaf4bd33f9e283d03\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:27b866b5bd3ddd54166bbcbf5c8d7dd2e0b397fac8537991c7f544220b1f67bc\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-win32.whl\", hash = \"sha256:b133e8a499eac49c581c3c76e9bdd08c338cc1939e441fee6f92c0ccb5f1f8be\"},\n    {file = \"sentencepiece-0.1.99-cp38-cp38-win_amd64.whl\", hash = \"sha256:0eaf3591dd0690a87f44f4df129cf8d05d8a4029b5b6709b489b8e27f9a9bcff\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:38efeda9bbfb55052d482a009c6a37e52f42ebffcea9d3a98a61de7aee356a28\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:6c030b081dc1e1bcc9fadc314b19b740715d3d566ad73a482da20d7d46fd444c\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:84dbe53e02e4f8a2e45d2ac3e430d5c83182142658e25edd76539b7648928727\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:0b0f55d0a0ee1719b4b04221fe0c9f0c3461dc3dabd77a035fa2f4788eb3ef9a\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:18e800f206cd235dc27dc749299e05853a4e4332e8d3dfd81bf13d0e5b9007d9\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:2ae1c40cda8f9d5b0423cfa98542735c0235e7597d79caf318855cdf971b2280\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-win32.whl\", hash = \"sha256:c84ce33af12ca222d14a1cdd37bd76a69401e32bc68fe61c67ef6b59402f4ab8\"},\n    {file = \"sentencepiece-0.1.99-cp39-cp39-win_amd64.whl\", hash = \"sha256:350e5c74d739973f1c9643edb80f7cc904dc948578bcb1d43c6f2b173e5d18dd\"},\n    {file = \"sentencepiece-0.1.99.tar.gz\", hash = \"sha256:189c48f5cb2949288f97ccdb97f0473098d9c3dcf5a3d99d4eabe719ec27297f\"},\n]\n\n[[package]]\nname = \"sympy\"\nversion = \"1.12\"\ndescription = \"Computer algebra system (CAS) in Python\"\noptional = false\npython-versions = \">=3.8\"\nfiles = [\n    {file = \"sympy-1.12-py3-none-any.whl\", hash = \"sha256:c3588cd4295d0c0f603d0f2ae780587e64e2efeedb3521e46b9bb1d08d184fa5\"},\n    {file = \"sympy-1.12.tar.gz\", hash = \"sha256:ebf595c8dac3e0fdc4152c51878b498396ec7f30e7a914d6071e674d49420fb8\"},\n]\n\n[package.dependencies]\nmpmath = \">=0.19\"\n\n[[package]]\nname = \"tokenizers\"\nversion = \"0.15.2\"\ndescription = \"\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"tokenizers-0.15.2-cp310-cp310-macosx_10_12_x86_64.whl\", hash = \"sha256:52f6130c9cbf70544287575a985bf44ae1bda2da7e8c24e97716080593638012\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:054c1cc9c6d68f7ffa4e810b3d5131e0ba511b6e4be34157aa08ee54c2f8d9ee\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:a9b9b070fdad06e347563b88c278995735292ded1132f8657084989a4c84a6d5\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:ea621a7eef4b70e1f7a4e84dd989ae3f0eeb50fc8690254eacc08acb623e82f1\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:cf7fd9a5141634fa3aa8d6b7be362e6ae1b4cda60da81388fa533e0b552c98fd\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:44f2a832cd0825295f7179eaf173381dc45230f9227ec4b44378322d900447c9\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:8b9ec69247a23747669ec4b0ca10f8e3dfb3545d550258129bd62291aabe8605\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:40b6a4c78da863ff26dbd5ad9a8ecc33d8a8d97b535172601cf00aee9d7ce9ce\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:5ab2a4d21dcf76af60e05af8063138849eb1d6553a0d059f6534357bce8ba364\"},\n    {file = \"tokenizers-0.15.2-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:a47acfac7e511f6bbfcf2d3fb8c26979c780a91e06fb5b9a43831b2c0153d024\"},\n    {file = \"tokenizers-0.15.2-cp310-none-win32.whl\", hash = \"sha256:064ff87bb6acdbd693666de9a4b692add41308a2c0ec0770d6385737117215f2\"},\n    {file = \"tokenizers-0.15.2-cp310-none-win_amd64.whl\", hash = \"sha256:3b919afe4df7eb6ac7cafd2bd14fb507d3f408db7a68c43117f579c984a73843\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-macosx_10_12_x86_64.whl\", hash = \"sha256:89cd1cb93e4b12ff39bb2d626ad77e35209de9309a71e4d3d4672667b4b256e7\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:cfed5c64e5be23d7ee0f0e98081a25c2a46b0b77ce99a4f0605b1ec43dd481fa\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:a907d76dcfda37023ba203ab4ceeb21bc5683436ebefbd895a0841fd52f6f6f2\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:20ea60479de6fc7b8ae756b4b097572372d7e4032e2521c1bbf3d90c90a99ff0\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:48e2b9335be2bc0171df9281385c2ed06a15f5cf121c44094338306ab7b33f2c\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:112a1dd436d2cc06e6ffdc0b06d55ac019a35a63afd26475205cb4b1bf0bfbff\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:4620cca5c2817177ee8706f860364cc3a8845bc1e291aaf661fb899e5d1c45b0\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:ccd73a82751c523b3fc31ff8194702e4af4db21dc20e55b30ecc2079c5d43cb7\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:107089f135b4ae7817affe6264f8c7a5c5b4fd9a90f9439ed495f54fcea56fb4\"},\n    {file = \"tokenizers-0.15.2-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:0ff110ecc57b7aa4a594396525a3451ad70988e517237fe91c540997c4e50e29\"},\n    {file = \"tokenizers-0.15.2-cp311-none-win32.whl\", hash = \"sha256:6d76f00f5c32da36c61f41c58346a4fa7f0a61be02f4301fd30ad59834977cc3\"},\n    {file = \"tokenizers-0.15.2-cp311-none-win_amd64.whl\", hash = \"sha256:cc90102ed17271cf0a1262babe5939e0134b3890345d11a19c3145184b706055\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-macosx_10_12_x86_64.whl\", hash = \"sha256:f86593c18d2e6248e72fb91c77d413a815153b8ea4e31f7cd443bdf28e467670\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:0774bccc6608eca23eb9d620196687c8b2360624619623cf4ba9dc9bd53e8b51\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:d0222c5b7c9b26c0b4822a82f6a7011de0a9d3060e1da176f66274b70f846b98\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:3835738be1de66624fff2f4f6f6684775da4e9c00bde053be7564cbf3545cc66\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:0143e7d9dcd811855c1ce1ab9bf5d96d29bf5e528fd6c7824d0465741e8c10fd\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:db35825f6d54215f6b6009a7ff3eedee0848c99a6271c870d2826fbbedf31a38\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:3f5e64b0389a2be47091d8cc53c87859783b837ea1a06edd9d8e04004df55a5c\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:9e0480c452217edd35eca56fafe2029fb4d368b7c0475f8dfa3c5c9c400a7456\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:a33ab881c8fe70474980577e033d0bc9a27b7ab8272896e500708b212995d834\"},\n    {file = \"tokenizers-0.15.2-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:a308a607ca9de2c64c1b9ba79ec9a403969715a1b8ba5f998a676826f1a7039d\"},\n    {file = \"tokenizers-0.15.2-cp312-none-win32.whl\", hash = \"sha256:b8fcfa81bcb9447df582c5bc96a031e6df4da2a774b8080d4f02c0c16b42be0b\"},\n    {file = \"tokenizers-0.15.2-cp312-none-win_amd64.whl\", hash = \"sha256:38d7ab43c6825abfc0b661d95f39c7f8af2449364f01d331f3b51c94dcff7221\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-macosx_10_12_x86_64.whl\", hash = \"sha256:38bfb0204ff3246ca4d5e726e8cc8403bfc931090151e6eede54d0e0cf162ef0\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-macosx_11_0_arm64.whl\", hash = \"sha256:9c861d35e8286a53e06e9e28d030b5a05bcbf5ac9d7229e561e53c352a85b1fc\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:936bf3842db5b2048eaa53dade907b1160f318e7c90c74bfab86f1e47720bdd6\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:620beacc3373277700d0e27718aa8b25f7b383eb8001fba94ee00aeea1459d89\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:2735ecbbf37e52db4ea970e539fd2d450d213517b77745114f92867f3fc246eb\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:473c83c5e2359bb81b0b6fde870b41b2764fcdd36d997485e07e72cc3a62264a\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:968fa1fb3c27398b28a4eca1cbd1e19355c4d3a6007f7398d48826bbe3a0f728\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:865c60ae6eaebdde7da66191ee9b7db52e542ed8ee9d2c653b6d190a9351b980\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-musllinux_1_1_aarch64.whl\", hash = \"sha256:7c0d8b52664ab2d4a8d6686eb5effc68b78608a9008f086a122a7b2996befbab\"},\n    {file = \"tokenizers-0.15.2-cp313-cp313-musllinux_1_1_x86_64.whl\", hash = \"sha256:f33dfbdec3784093a9aebb3680d1f91336c56d86cc70ddf88708251da1fe9064\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-macosx_10_12_x86_64.whl\", hash = \"sha256:d44ba80988ff9424e33e0a49445072ac7029d8c0e1601ad25a0ca5f41ed0c1d6\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-macosx_11_0_arm64.whl\", hash = \"sha256:dce74266919b892f82b1b86025a613956ea0ea62a4843d4c4237be2c5498ed3a\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:0ef06b9707baeb98b316577acb04f4852239d856b93e9ec3a299622f6084e4be\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:c73e2e74bbb07910da0d37c326869f34113137b23eadad3fc00856e6b3d9930c\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:4eeb12daf02a59e29f578a865f55d87cd103ce62bd8a3a5874f8fdeaa82e336b\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:9ba9f6895af58487ca4f54e8a664a322f16c26bbb442effd01087eba391a719e\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:ccec77aa7150e38eec6878a493bf8c263ff1fa8a62404e16c6203c64c1f16a26\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f3f40604f5042ff210ba82743dda2b6aa3e55aa12df4e9f2378ee01a17e2855e\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:5645938a42d78c4885086767c70923abad047163d809c16da75d6b290cb30bbe\"},\n    {file = \"tokenizers-0.15.2-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:05a77cbfebe28a61ab5c3891f9939cc24798b63fa236d84e5f29f3a85a200c00\"},\n    {file = \"tokenizers-0.15.2-cp37-none-win32.whl\", hash = \"sha256:361abdc068e8afe9c5b818769a48624687fb6aaed49636ee39bec4e95e1a215b\"},\n    {file = \"tokenizers-0.15.2-cp37-none-win_amd64.whl\", hash = \"sha256:7ef789f83eb0f9baeb4d09a86cd639c0a5518528f9992f38b28e819df397eb06\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-macosx_10_12_x86_64.whl\", hash = \"sha256:4fe1f74a902bee74a3b25aff180fbfbf4f8b444ab37c4d496af7afd13a784ed2\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:4c4b89038a684f40a6b15d6b09f49650ac64d951ad0f2a3ea9169687bbf2a8ba\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:d05a1b06f986d41aed5f2de464c003004b2df8aaf66f2b7628254bcbfb72a438\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:508711a108684111ec8af89d3a9e9e08755247eda27d0ba5e3c50e9da1600f6d\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:daa348f02d15160cb35439098ac96e3a53bacf35885072611cd9e5be7d333daa\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:494fdbe5932d3416de2a85fc2470b797e6f3226c12845cadf054dd906afd0442\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:c2d60f5246f4da9373f75ff18d64c69cbf60c3bca597290cea01059c336d2470\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:93268e788825f52de4c7bdcb6ebc1fcd4a5442c02e730faa9b6b08f23ead0e24\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:6fc7083ab404019fc9acafe78662c192673c1e696bd598d16dc005bd663a5cf9\"},\n    {file = \"tokenizers-0.15.2-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:41e39b41e5531d6b2122a77532dbea60e171ef87a3820b5a3888daa847df4153\"},\n    {file = \"tokenizers-0.15.2-cp38-none-win32.whl\", hash = \"sha256:06cd0487b1cbfabefb2cc52fbd6b1f8d4c37799bd6c6e1641281adaa6b2504a7\"},\n    {file = \"tokenizers-0.15.2-cp38-none-win_amd64.whl\", hash = \"sha256:5179c271aa5de9c71712e31cb5a79e436ecd0d7532a408fa42a8dbfa4bc23fd9\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-macosx_10_12_x86_64.whl\", hash = \"sha256:82f8652a74cc107052328b87ea8b34291c0f55b96d8fb261b3880216a9f9e48e\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:02458bee6f5f3139f1ebbb6d042b283af712c0981f5bc50edf771d6b762d5e4f\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:c9a09cd26cca2e1c349f91aa665309ddb48d71636370749414fbf67bc83c5343\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:158be8ea8554e5ed69acc1ce3fbb23a06060bd4bbb09029431ad6b9a466a7121\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:1ddba9a2b0c8c81633eca0bb2e1aa5b3a15362b1277f1ae64176d0f6eba78ab1\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:3ef5dd1d39797044642dbe53eb2bc56435308432e9c7907728da74c69ee2adca\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:454c203164e07a860dbeb3b1f4a733be52b0edbb4dd2e5bd75023ffa8b49403a\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:0cf6b7f1d4dc59af960e6ffdc4faffe6460bbfa8dce27a58bf75755ffdb2526d\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:2ef09bbc16519f6c25d0c7fc0c6a33a6f62923e263c9d7cca4e58b8c61572afb\"},\n    {file = \"tokenizers-0.15.2-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:c9a2ebdd2ad4ec7a68e7615086e633857c85e2f18025bd05d2a4399e6c5f7169\"},\n    {file = \"tokenizers-0.15.2-cp39-none-win32.whl\", hash = \"sha256:918fbb0eab96fe08e72a8c2b5461e9cce95585d82a58688e7f01c2bd546c79d0\"},\n    {file = \"tokenizers-0.15.2-cp39-none-win_amd64.whl\", hash = \"sha256:524e60da0135e106b254bd71f0659be9f89d83f006ea9093ce4d1fab498c6d0d\"},\n    {file = \"tokenizers-0.15.2-pp310-pypy310_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:6a9b648a58281c4672212fab04e60648fde574877d0139cd4b4f93fe28ca8944\"},\n    {file = \"tokenizers-0.15.2-pp310-pypy310_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:7c7d18b733be6bbca8a55084027f7be428c947ddf871c500ee603e375013ffba\"},\n    {file = \"tokenizers-0.15.2-pp310-pypy310_pp73-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:13ca3611de8d9ddfbc4dc39ef54ab1d2d4aaa114ac8727dfdc6a6ec4be017378\"},\n    {file = \"tokenizers-0.15.2-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:237d1bf3361cf2e6463e6c140628e6406766e8b27274f5fcc62c747ae3c6f094\"},\n    {file = \"tokenizers-0.15.2-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:67a0fe1e49e60c664915e9fb6b0cb19bac082ab1f309188230e4b2920230edb3\"},\n    {file = \"tokenizers-0.15.2-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:4e022fe65e99230b8fd89ebdfea138c24421f91c1a4f4781a8f5016fd5cdfb4d\"},\n    {file = \"tokenizers-0.15.2-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:d857be2df69763362ac699f8b251a8cd3fac9d21893de129bc788f8baaef2693\"},\n    {file = \"tokenizers-0.15.2-pp37-pypy37_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:708bb3e4283177236309e698da5fcd0879ce8fd37457d7c266d16b550bcbbd18\"},\n    {file = \"tokenizers-0.15.2-pp37-pypy37_pp73-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:64c35e09e9899b72a76e762f9854e8750213f67567787d45f37ce06daf57ca78\"},\n    {file = \"tokenizers-0.15.2-pp37-pypy37_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:c1257f4394be0d3b00de8c9e840ca5601d0a4a8438361ce9c2b05c7d25f6057b\"},\n    {file = \"tokenizers-0.15.2-pp37-pypy37_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:02272fe48280e0293a04245ca5d919b2c94a48b408b55e858feae9618138aeda\"},\n    {file = \"tokenizers-0.15.2-pp37-pypy37_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:dc3ad9ebc76eabe8b1d7c04d38be884b8f9d60c0cdc09b0aa4e3bcf746de0388\"},\n    {file = \"tokenizers-0.15.2-pp37-pypy37_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:32e16bdeffa7c4f46bf2152172ca511808b952701d13e7c18833c0b73cb5c23f\"},\n    {file = \"tokenizers-0.15.2-pp38-pypy38_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:fb16ba563d59003028b678d2361a27f7e4ae0ab29c7a80690efa20d829c81fdb\"},\n    {file = \"tokenizers-0.15.2-pp38-pypy38_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:2277c36d2d6cdb7876c274547921a42425b6810d38354327dd65a8009acf870c\"},\n    {file = \"tokenizers-0.15.2-pp38-pypy38_pp73-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:1cf75d32e8d250781940d07f7eece253f2fe9ecdb1dc7ba6e3833fa17b82fcbc\"},\n    {file = \"tokenizers-0.15.2-pp38-pypy38_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:f1b3b31884dc8e9b21508bb76da80ebf7308fdb947a17affce815665d5c4d028\"},\n    {file = \"tokenizers-0.15.2-pp38-pypy38_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b10122d8d8e30afb43bb1fe21a3619f62c3e2574bff2699cf8af8b0b6c5dc4a3\"},\n    {file = \"tokenizers-0.15.2-pp38-pypy38_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:d88b96ff0fe8e91f6ef01ba50b0d71db5017fa4e3b1d99681cec89a85faf7bf7\"},\n    {file = \"tokenizers-0.15.2-pp38-pypy38_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:37aaec5a52e959892870a7c47cef80c53797c0db9149d458460f4f31e2fb250e\"},\n    {file = \"tokenizers-0.15.2-pp39-pypy39_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:e2ea752f2b0fe96eb6e2f3adbbf4d72aaa1272079b0dfa1145507bd6a5d537e6\"},\n    {file = \"tokenizers-0.15.2-pp39-pypy39_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:4b19a808d8799fda23504a5cd31d2f58e6f52f140380082b352f877017d6342b\"},\n    {file = \"tokenizers-0.15.2-pp39-pypy39_pp73-manylinux_2_12_i686.manylinux2010_i686.whl\", hash = \"sha256:64c86e5e068ac8b19204419ed8ca90f9d25db20578f5881e337d203b314f4104\"},\n    {file = \"tokenizers-0.15.2-pp39-pypy39_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:de19c4dc503c612847edf833c82e9f73cd79926a384af9d801dcf93f110cea4e\"},\n    {file = \"tokenizers-0.15.2-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:ea09acd2fe3324174063d61ad620dec3bcf042b495515f27f638270a7d466e8b\"},\n    {file = \"tokenizers-0.15.2-pp39-pypy39_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:cf27fd43472e07b57cf420eee1e814549203d56de00b5af8659cb99885472f1f\"},\n    {file = \"tokenizers-0.15.2-pp39-pypy39_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:7ca22bd897537a0080521445d91a58886c8c04084a6a19e6c78c586e0cfa92a5\"},\n    {file = \"tokenizers-0.15.2.tar.gz\", hash = \"sha256:e6e9c6e019dd5484be5beafc775ae6c925f4c69a3487040ed09b45e13df2cb91\"},\n]\n\n[package.dependencies]\nhuggingface_hub = \">=0.16.4,<1.0\"\n\n[package.extras]\ndev = [\"tokenizers[testing]\"]\ndocs = [\"setuptools_rust\", \"sphinx\", \"sphinx_rtd_theme\"]\ntesting = [\"black (==22.3)\", \"datasets\", \"numpy\", \"pytest\", \"requests\"]\n\n[[package]]\nname = \"torch\"\nversion = \"2.2.1+cpu\"\ndescription = \"Tensors and Dynamic neural networks in Python with strong GPU acceleration\"\noptional = false\npython-versions = \">=3.8.0\"\nfiles = [\n    {file = \"torch-2.2.1+cpu-cp310-cp310-linux_x86_64.whl\", hash = \"sha256:5d82422cf04797f1b2a8574b64a916070ec83eef58ad4900615ee0218d7b8b8e\"},\n    {file = \"torch-2.2.1+cpu-cp310-cp310-win_amd64.whl\", hash = \"sha256:f8914dd0f5f0e5c66fdecd9559403eea9feac82d1ea639b672fde0073c6addbd\"},\n    {file = \"torch-2.2.1+cpu-cp311-cp311-linux_x86_64.whl\", hash = \"sha256:6bc973d5632374b92b4b293817b4d2ff8c8ce1c784c748b471dba1fffcd9c333\"},\n    {file = \"torch-2.2.1+cpu-cp311-cp311-win_amd64.whl\", hash = \"sha256:abdec34b0ade8fca0520055e72c3094425ae0ef210718e9c0278121cd3608c32\"},\n    {file = \"torch-2.2.1+cpu-cp312-cp312-linux_x86_64.whl\", hash = \"sha256:d7339580135da4105c1244a8621faa076990409afeab5a7b642c3c1ee70a5622\"},\n    {file = \"torch-2.2.1+cpu-cp312-cp312-win_amd64.whl\", hash = \"sha256:039128fcb5548122465b15f679b8831c47d14f0d6c28c1f1b631f8019c104720\"},\n    {file = \"torch-2.2.1+cpu-cp38-cp38-linux_x86_64.whl\", hash = \"sha256:2b447f7bb50b393b4544b4036d587e39ab524d4353e77c197f6a2727f22b0d47\"},\n    {file = \"torch-2.2.1+cpu-cp38-cp38-win_amd64.whl\", hash = \"sha256:2ccdf3e5f71e6426ea9e34d21c3cc333b29d4f48299b981d28aeb5112b5495e1\"},\n    {file = \"torch-2.2.1+cpu-cp39-cp39-linux_x86_64.whl\", hash = \"sha256:2fb340b289760040a16a77a6d70b8a48961abba1822e6f58705c97c80befa03e\"},\n    {file = \"torch-2.2.1+cpu-cp39-cp39-win_amd64.whl\", hash = \"sha256:e03dc4654ecceeb5b03f0a6f60b342c0e0d267b3ebc61e4f672cace1df8cd930\"},\n]\n\n[package.dependencies]\nfilelock = \"*\"\nfsspec = \"*\"\njinja2 = \"*\"\nnetworkx = \"*\"\nsympy = \"*\"\ntyping-extensions = \">=4.8.0\"\n\n[package.extras]\nopt-einsum = [\"opt-einsum (>=3.3)\"]\noptree = [\"optree (>=0.9.1)\"]\n\n[package.source]\ntype = \"legacy\"\nurl = \"https://download.pytorch.org/whl/cpu\"\nreference = \"pytorch\"\n\n[[package]]\nname = \"tqdm\"\nversion = \"4.66.2\"\ndescription = \"Fast, Extensible Progress Meter\"\noptional = false\npython-versions = \">=3.7\"\nfiles = [\n    {file = \"tqdm-4.66.2-py3-none-any.whl\", hash = \"sha256:1ee4f8a893eb9bef51c6e35730cebf234d5d0b6bd112b0271e10ed7c24a02bd9\"},\n    {file = \"tqdm-4.66.2.tar.gz\", hash = \"sha256:6cd52cdf0fef0e0f543299cfc96fec90d7b8a7e88745f411ec33eb44d5ed3531\"},\n]\n\n[package.dependencies]\ncolorama = {version = \"*\", markers = \"platform_system == \\\"Windows\\\"\"}\n\n[package.extras]\ndev = [\"pytest (>=6)\", \"pytest-cov\", \"pytest-timeout\", \"pytest-xdist\"]\nnotebook = [\"ipywidgets (>=6)\"]\nslack = [\"slack-sdk\"]\ntelegram = [\"requests\"]\n\n[[package]]\nname = \"transformers\"\nversion = \"4.38.1\"\ndescription = \"State-of-the-art Machine Learning for JAX, PyTorch and TensorFlow\"\noptional = false\npython-versions = \">=3.8.0\"\nfiles = [\n    {file = \"transformers-4.38.1-py3-none-any.whl\", hash = \"sha256:a7a9265fb060183e9d975cbbadc4d531b10281589c43f6d07563f86322728973\"},\n    {file = \"transformers-4.38.1.tar.gz\", hash = \"sha256:86dc84ccbe36123647e84cbd50fc31618c109a41e6be92514b064ab55bf1304c\"},\n]\n\n[package.dependencies]\nfilelock = \"*\"\nhuggingface-hub = \">=0.19.3,<1.0\"\nnumpy = \">=1.17\"\npackaging = \">=20.0\"\npyyaml = \">=5.1\"\nregex = \"!=2019.12.17\"\nrequests = \"*\"\nsafetensors = \">=0.4.1\"\ntokenizers = \">=0.14,<0.19\"\ntqdm = \">=4.27\"\n\n[package.extras]\naccelerate = [\"accelerate (>=0.21.0)\"]\nagents = [\"Pillow (>=10.0.1,<=15.0)\", \"accelerate (>=0.21.0)\", \"datasets (!=2.5.0)\", \"diffusers\", \"opencv-python\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"torch\"]\nall = [\"Pillow (>=10.0.1,<=15.0)\", \"accelerate (>=0.21.0)\", \"av (==9.2.0)\", \"codecarbon (==1.2.0)\", \"decord (==0.6.0)\", \"flax (>=0.4.1,<=0.7.0)\", \"jax (>=0.4.1,<=0.4.13)\", \"jaxlib (>=0.4.1,<=0.4.13)\", \"kenlm\", \"keras-nlp (>=0.3.1)\", \"librosa\", \"onnxconverter-common\", \"optax (>=0.0.8,<=0.1.4)\", \"optuna\", \"phonemizer\", \"protobuf\", \"pyctcdecode (>=0.4.0)\", \"ray[tune] (>=2.7.0)\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"sigopt\", \"tensorflow (>=2.6,<2.16)\", \"tensorflow-text (<2.16)\", \"tf2onnx\", \"timm\", \"tokenizers (>=0.14,<0.19)\", \"torch\", \"torchaudio\", \"torchvision\"]\naudio = [\"kenlm\", \"librosa\", \"phonemizer\", \"pyctcdecode (>=0.4.0)\"]\ncodecarbon = [\"codecarbon (==1.2.0)\"]\ndeepspeed = [\"accelerate (>=0.21.0)\", \"deepspeed (>=0.9.3)\"]\ndeepspeed-testing = [\"GitPython (<3.1.19)\", \"accelerate (>=0.21.0)\", \"beautifulsoup4\", \"cookiecutter (==1.7.3)\", \"datasets (!=2.5.0)\", \"deepspeed (>=0.9.3)\", \"dill (<0.3.5)\", \"evaluate (>=0.2.0)\", \"faiss-cpu\", \"hf-doc-builder (>=0.3.0)\", \"nltk\", \"optuna\", \"parameterized\", \"protobuf\", \"psutil\", \"pydantic\", \"pytest (>=7.2.0,<8.0.0)\", \"pytest-timeout\", \"pytest-xdist\", \"rjieba\", \"rouge-score (!=0.0.7,!=0.0.8,!=0.1,!=0.1.1)\", \"ruff (==0.1.5)\", \"sacrebleu (>=1.4.12,<2.0.0)\", \"sacremoses\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"tensorboard\", \"timeout-decorator\"]\ndev = [\"GitPython (<3.1.19)\", \"Pillow (>=10.0.1,<=15.0)\", \"accelerate (>=0.21.0)\", \"av (==9.2.0)\", \"beautifulsoup4\", \"codecarbon (==1.2.0)\", \"cookiecutter (==1.7.3)\", \"datasets (!=2.5.0)\", \"decord (==0.6.0)\", \"dill (<0.3.5)\", \"evaluate (>=0.2.0)\", \"faiss-cpu\", \"flax (>=0.4.1,<=0.7.0)\", \"fugashi (>=1.0)\", \"hf-doc-builder\", \"hf-doc-builder (>=0.3.0)\", \"ipadic (>=1.0.0,<2.0)\", \"isort (>=5.5.4)\", \"jax (>=0.4.1,<=0.4.13)\", \"jaxlib (>=0.4.1,<=0.4.13)\", \"kenlm\", \"keras-nlp (>=0.3.1)\", \"librosa\", \"nltk\", \"onnxconverter-common\", \"optax (>=0.0.8,<=0.1.4)\", \"optuna\", \"parameterized\", \"phonemizer\", \"protobuf\", \"psutil\", \"pyctcdecode (>=0.4.0)\", \"pydantic\", \"pytest (>=7.2.0,<8.0.0)\", \"pytest-timeout\", \"pytest-xdist\", \"ray[tune] (>=2.7.0)\", \"rhoknp (>=1.1.0,<1.3.1)\", \"rjieba\", \"rouge-score (!=0.0.7,!=0.0.8,!=0.1,!=0.1.1)\", \"ruff (==0.1.5)\", \"sacrebleu (>=1.4.12,<2.0.0)\", \"sacremoses\", \"scikit-learn\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"sigopt\", \"sudachidict-core (>=20220729)\", \"sudachipy (>=0.6.6)\", \"tensorboard\", \"tensorflow (>=2.6,<2.16)\", \"tensorflow-text (<2.16)\", \"tf2onnx\", \"timeout-decorator\", \"timm\", \"tokenizers (>=0.14,<0.19)\", \"torch\", \"torchaudio\", \"torchvision\", \"unidic (>=1.0.2)\", \"unidic-lite (>=1.0.7)\", \"urllib3 (<2.0.0)\"]\ndev-tensorflow = [\"GitPython (<3.1.19)\", \"Pillow (>=10.0.1,<=15.0)\", \"beautifulsoup4\", \"cookiecutter (==1.7.3)\", \"datasets (!=2.5.0)\", \"dill (<0.3.5)\", \"evaluate (>=0.2.0)\", \"faiss-cpu\", \"hf-doc-builder\", \"hf-doc-builder (>=0.3.0)\", \"isort (>=5.5.4)\", \"kenlm\", \"keras-nlp (>=0.3.1)\", \"librosa\", \"nltk\", \"onnxconverter-common\", \"onnxruntime (>=1.4.0)\", \"onnxruntime-tools (>=1.4.2)\", \"parameterized\", \"phonemizer\", \"protobuf\", \"psutil\", \"pyctcdecode (>=0.4.0)\", \"pydantic\", \"pytest (>=7.2.0,<8.0.0)\", \"pytest-timeout\", \"pytest-xdist\", \"rjieba\", \"rouge-score (!=0.0.7,!=0.0.8,!=0.1,!=0.1.1)\", \"ruff (==0.1.5)\", \"sacrebleu (>=1.4.12,<2.0.0)\", \"sacremoses\", \"scikit-learn\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"tensorboard\", \"tensorflow (>=2.6,<2.16)\", \"tensorflow-text (<2.16)\", \"tf2onnx\", \"timeout-decorator\", \"tokenizers (>=0.14,<0.19)\", \"urllib3 (<2.0.0)\"]\ndev-torch = [\"GitPython (<3.1.19)\", \"Pillow (>=10.0.1,<=15.0)\", \"accelerate (>=0.21.0)\", \"beautifulsoup4\", \"codecarbon (==1.2.0)\", \"cookiecutter (==1.7.3)\", \"datasets (!=2.5.0)\", \"dill (<0.3.5)\", \"evaluate (>=0.2.0)\", \"faiss-cpu\", \"fugashi (>=1.0)\", \"hf-doc-builder\", \"hf-doc-builder (>=0.3.0)\", \"ipadic (>=1.0.0,<2.0)\", \"isort (>=5.5.4)\", \"kenlm\", \"librosa\", \"nltk\", \"onnxruntime (>=1.4.0)\", \"onnxruntime-tools (>=1.4.2)\", \"optuna\", \"parameterized\", \"phonemizer\", \"protobuf\", \"psutil\", \"pyctcdecode (>=0.4.0)\", \"pydantic\", \"pytest (>=7.2.0,<8.0.0)\", \"pytest-timeout\", \"pytest-xdist\", \"ray[tune] (>=2.7.0)\", \"rhoknp (>=1.1.0,<1.3.1)\", \"rjieba\", \"rouge-score (!=0.0.7,!=0.0.8,!=0.1,!=0.1.1)\", \"ruff (==0.1.5)\", \"sacrebleu (>=1.4.12,<2.0.0)\", \"sacremoses\", \"scikit-learn\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"sigopt\", \"sudachidict-core (>=20220729)\", \"sudachipy (>=0.6.6)\", \"tensorboard\", \"timeout-decorator\", \"timm\", \"tokenizers (>=0.14,<0.19)\", \"torch\", \"torchaudio\", \"torchvision\", \"unidic (>=1.0.2)\", \"unidic-lite (>=1.0.7)\", \"urllib3 (<2.0.0)\"]\ndocs = [\"Pillow (>=10.0.1,<=15.0)\", \"accelerate (>=0.21.0)\", \"av (==9.2.0)\", \"codecarbon (==1.2.0)\", \"decord (==0.6.0)\", \"flax (>=0.4.1,<=0.7.0)\", \"hf-doc-builder\", \"jax (>=0.4.1,<=0.4.13)\", \"jaxlib (>=0.4.1,<=0.4.13)\", \"kenlm\", \"keras-nlp (>=0.3.1)\", \"librosa\", \"onnxconverter-common\", \"optax (>=0.0.8,<=0.1.4)\", \"optuna\", \"phonemizer\", \"protobuf\", \"pyctcdecode (>=0.4.0)\", \"ray[tune] (>=2.7.0)\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"sigopt\", \"tensorflow (>=2.6,<2.16)\", \"tensorflow-text (<2.16)\", \"tf2onnx\", \"timm\", \"tokenizers (>=0.14,<0.19)\", \"torch\", \"torchaudio\", \"torchvision\"]\ndocs-specific = [\"hf-doc-builder\"]\nflax = [\"flax (>=0.4.1,<=0.7.0)\", \"jax (>=0.4.1,<=0.4.13)\", \"jaxlib (>=0.4.1,<=0.4.13)\", \"optax (>=0.0.8,<=0.1.4)\"]\nflax-speech = [\"kenlm\", \"librosa\", \"phonemizer\", \"pyctcdecode (>=0.4.0)\"]\nftfy = [\"ftfy\"]\nintegrations = [\"optuna\", \"ray[tune] (>=2.7.0)\", \"sigopt\"]\nja = [\"fugashi (>=1.0)\", \"ipadic (>=1.0.0,<2.0)\", \"rhoknp (>=1.1.0,<1.3.1)\", \"sudachidict-core (>=20220729)\", \"sudachipy (>=0.6.6)\", \"unidic (>=1.0.2)\", \"unidic-lite (>=1.0.7)\"]\nmodelcreation = [\"cookiecutter (==1.7.3)\"]\nnatten = [\"natten (>=0.14.6,<0.15.0)\"]\nonnx = [\"onnxconverter-common\", \"onnxruntime (>=1.4.0)\", \"onnxruntime-tools (>=1.4.2)\", \"tf2onnx\"]\nonnxruntime = [\"onnxruntime (>=1.4.0)\", \"onnxruntime-tools (>=1.4.2)\"]\noptuna = [\"optuna\"]\nquality = [\"GitPython (<3.1.19)\", \"datasets (!=2.5.0)\", \"hf-doc-builder (>=0.3.0)\", \"isort (>=5.5.4)\", \"ruff (==0.1.5)\", \"urllib3 (<2.0.0)\"]\nray = [\"ray[tune] (>=2.7.0)\"]\nretrieval = [\"datasets (!=2.5.0)\", \"faiss-cpu\"]\nsagemaker = [\"sagemaker (>=2.31.0)\"]\nsentencepiece = [\"protobuf\", \"sentencepiece (>=0.1.91,!=0.1.92)\"]\nserving = [\"fastapi\", \"pydantic\", \"starlette\", \"uvicorn\"]\nsigopt = [\"sigopt\"]\nsklearn = [\"scikit-learn\"]\nspeech = [\"kenlm\", \"librosa\", \"phonemizer\", \"pyctcdecode (>=0.4.0)\", \"torchaudio\"]\ntesting = [\"GitPython (<3.1.19)\", \"beautifulsoup4\", \"cookiecutter (==1.7.3)\", \"datasets (!=2.5.0)\", \"dill (<0.3.5)\", \"evaluate (>=0.2.0)\", \"faiss-cpu\", \"hf-doc-builder (>=0.3.0)\", \"nltk\", \"parameterized\", \"protobuf\", \"psutil\", \"pydantic\", \"pytest (>=7.2.0,<8.0.0)\", \"pytest-timeout\", \"pytest-xdist\", \"rjieba\", \"rouge-score (!=0.0.7,!=0.0.8,!=0.1,!=0.1.1)\", \"ruff (==0.1.5)\", \"sacrebleu (>=1.4.12,<2.0.0)\", \"sacremoses\", \"tensorboard\", \"timeout-decorator\"]\ntf = [\"keras-nlp (>=0.3.1)\", \"onnxconverter-common\", \"tensorflow (>=2.6,<2.16)\", \"tensorflow-text (<2.16)\", \"tf2onnx\"]\ntf-cpu = [\"keras-nlp (>=0.3.1)\", \"onnxconverter-common\", \"tensorflow-cpu (>=2.6,<2.16)\", \"tensorflow-text (<2.16)\", \"tf2onnx\"]\ntf-speech = [\"kenlm\", \"librosa\", \"phonemizer\", \"pyctcdecode (>=0.4.0)\"]\ntimm = [\"timm\"]\ntokenizers = [\"tokenizers (>=0.14,<0.19)\"]\ntorch = [\"accelerate (>=0.21.0)\", \"torch\"]\ntorch-speech = [\"kenlm\", \"librosa\", \"phonemizer\", \"pyctcdecode (>=0.4.0)\", \"torchaudio\"]\ntorch-vision = [\"Pillow (>=10.0.1,<=15.0)\", \"torchvision\"]\ntorchhub = [\"filelock\", \"huggingface-hub (>=0.19.3,<1.0)\", \"importlib-metadata\", \"numpy (>=1.17)\", \"packaging (>=20.0)\", \"protobuf\", \"regex (!=2019.12.17)\", \"requests\", \"sentencepiece (>=0.1.91,!=0.1.92)\", \"tokenizers (>=0.14,<0.19)\", \"torch\", \"tqdm (>=4.27)\"]\nvideo = [\"av (==9.2.0)\", \"decord (==0.6.0)\"]\nvision = [\"Pillow (>=10.0.1,<=15.0)\"]\n\n[[package]]\nname = \"typing-extensions\"\nversion = \"4.9.0\"\ndescription = \"Backported and Experimental Type Hints for Python 3.8+\"\noptional = false\npython-versions = \">=3.8\"\nfiles = [\n    {file = \"typing_extensions-4.9.0-py3-none-any.whl\", hash = \"sha256:af72aea155e91adfc61c3ae9e0e342dbc0cba726d6cba4b6c72c1f34e47291cd\"},\n    {file = \"typing_extensions-4.9.0.tar.gz\", hash = \"sha256:23478f88c37f27d76ac8aee6c905017a143b0b1b886c3c9f66bc2fd94f9f5783\"},\n]\n\n[[package]]\nname = \"urllib3\"\nversion = \"2.2.1\"\ndescription = \"HTTP library with thread-safe connection pooling, file post, and more.\"\noptional = false\npython-versions = \">=3.8\"\nfiles = [\n    {file = \"urllib3-2.2.1-py3-none-any.whl\", hash = \"sha256:450b20ec296a467077128bff42b73080516e71b56ff59a60a02bef2232c4fa9d\"},\n    {file = \"urllib3-2.2.1.tar.gz\", hash = \"sha256:d0570876c61ab9e520d776c38acbbb5b05a776d3f9ff98a5c8fd5162a444cf19\"},\n]\n\n[package.extras]\nbrotli = [\"brotli (>=1.0.9)\", \"brotlicffi (>=0.8.0)\"]\nh2 = [\"h2 (>=4,<5)\"]\nsocks = [\"pysocks (>=1.5.6,!=1.5.7,<2.0)\"]\nzstd = [\"zstandard (>=0.18.0)\"]\n\n[[package]]\nname = \"wcwidth\"\nversion = \"0.2.13\"\ndescription = \"Measures the displayed width of unicode strings in a terminal\"\noptional = false\npython-versions = \"*\"\nfiles = [\n    {file = \"wcwidth-0.2.13-py2.py3-none-any.whl\", hash = \"sha256:3da69048e4540d84af32131829ff948f1e022c1c6bdb8d6102117aac784f6859\"},\n    {file = \"wcwidth-0.2.13.tar.gz\", hash = \"sha256:72ea0c06399eb286d978fdedb6923a9eb47e1c486ce63e9b4e64fc18303972b5\"},\n]\n\n[metadata]\nlock-version = \"2.0\"\npython-versions = \">=3.9\"\ncontent-hash = \"c8c4cc87637266a7b85debcbafa8887c5ad81cc8ef40e98a3f52c7c50af05c03\"\n"
        },
        {
          "name": "prompts",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 1.25,
          "content": "[tool.poetry]\nname = \"llama-cpp-scripts\"\nversion = \"0.0.0\"\ndescription = \"Scripts that ship with llama.cpp\"\nauthors = [\"GGML <ggml@ggml.ai>\"]\nreadme = \"README.md\"\nhomepage = \"https://ggml.ai\"\nrepository = \"https://github.com/ggerganov/llama.cpp\"\nkeywords = [\"ggml\", \"gguf\", \"llama.cpp\"]\npackages = [{ include = \"*.py\", from = \".\" }]\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\n[tool.poetry.dependencies]\npython = \">=3.9\"\nnumpy = \"^1.25.0\"\nsentencepiece = \">=0.1.98,<=0.2.0\"\ntransformers = \">=4.35.2,<5.0.0\"\nprotobuf = \">=4.21.0,<5.0.0\"\ngguf = { path = \"./gguf-py\" }\ntorch = { version = \"^2.2.0\", source = \"pytorch\" }\n\n[tool.poetry.dev-dependencies]\npytest = \"^5.2\"\n\n\n# Force wheel + cpu\n# For discussion and context see https://github.com/python-poetry/poetry#6409\n[[tool.poetry.source]]\nname = \"pytorch\"\nurl = \"https://download.pytorch.org/whl/cpu\"\npriority = \"explicit\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n[tool.poetry.scripts]\nllama-convert-hf-to-gguf = \"convert_hf_to_gguf:main\"\nllama-convert-llama-ggml-to-gguf = \"convert_llama_ggml_to_gguf:main\"\nllama-ggml-vk-generate-shaders = \"ggml_vk_generate_shaders:main\"\n"
        },
        {
          "name": "pyrightconfig.json",
          "type": "blob",
          "size": 0.6044921875,
          "content": "{\n  \"extraPaths\": [\"gguf-py\"],\n  \"pythonVersion\": \"3.9\",\n  \"pythonPlatform\": \"All\",\n  \"reportUnusedImport\": \"warning\",\n  \"reportDuplicateImport\": \"error\",\n  \"reportDeprecated\": \"warning\",\n  \"reportUnnecessaryTypeIgnoreComment\": \"information\",\n  \"disableBytesTypePromotions\": false, // TODO: change once Python 3.12 is the minimum\n  \"executionEnvironments\": [\n    {\n      // TODO: make this version override work correctly\n      \"root\": \"gguf-py\",\n      \"pythonVersion\": \"3.8\",\n    },\n    {\n      // uses match expressions in steps.py\n      \"root\": \"examples/server/tests\",\n      \"pythonVersion\": \"3.10\",\n    },\n  ],\n }\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.4931640625,
          "content": "# These requirements include all dependencies for all top-level python scripts\n# for llama.cpp. Avoid adding packages here directly.\n#\n# Package versions must stay compatible across all top-level python scripts.\n#\n\n-r ./requirements/requirements-convert_legacy_llama.txt\n\n-r ./requirements/requirements-convert_hf_to_gguf.txt\n-r ./requirements/requirements-convert_hf_to_gguf_update.txt\n-r ./requirements/requirements-convert_llama_ggml_to_gguf.txt\n-r ./requirements/requirements-convert_lora_to_gguf.txt\n"
        },
        {
          "name": "requirements",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "spm-headers",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}