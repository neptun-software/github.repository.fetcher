{
  "metadata": {
    "timestamp": 1736566071359,
    "page": 59,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "open-source-parsers/jsoncpp",
      "stars": 8256,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.1025390625,
          "content": "BasedOnStyle:  LLVM\nDerivePointerAlignment: false\nPointerAlignment: Left\nSpacesBeforeTrailingComments: 1\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 0.4541015625,
          "content": "---\nChecks:          'google-readability-casting,modernize-deprecated-headers,modernize-loop-convert,modernize-use-auto,modernize-use-default-member-init,modernize-use-using,readability-else-after-return,readability-redundant-member-init,readability-redundant-string-cstr'\nWarningsAsErrors: ''\nHeaderFilterRegex: ''\nAnalyzeTemporaryDtors: false\nFormatStyle:     none\nCheckOptions:\n  - key:             modernize-use-using.IgnoreMacros\n    value:           '0'\n...\n\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.2158203125,
          "content": "*           text=auto\n*.h         text\n*.cpp       text\n*.json      text\n*.in        text\n*.sh        eol=lf\n*.bat       eol=crlf\n*.vcproj    eol=crlf\n*.vcxproj   eol=crlf\n*.sln       eol=crlf\ndevtools/agent_vm* eol=crlf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.697265625,
          "content": "/build/\n/build-*/\n*.pyc\n*.swp\n*.actual\n*.actual-rewrite\n*.process-output\n*.rewrite\n/bin/\n/libs/\n/doc/doxyfile\n/dist/\n/.cache/\n\n# MSVC project files:\n*.sln\n*.vcxproj\n*.filters\n*.user\n*.sdf\n*.opensdf\n*.suo\n\n# MSVC build files:\n*.lib\n*.obj\n*.tlog/\n*.pdb\n\n# CMake-generated files:\nCMakeFiles/\n/pkg-config/jsoncpp.pc\njsoncpp_lib_static.dir/\ncompile_commands.json\n\n# In case someone runs cmake in the root-dir:\n/CMakeCache.txt\n/Makefile\n/include/Makefile\n/src/Makefile\n/src/jsontestrunner/Makefile\n/src/jsontestrunner/jsontestrunner_exe\n/src/lib_json/Makefile\n/src/test_lib_json/Makefile\n/src/test_lib_json/jsoncpp_test\n*.a\n\n# eclipse project files\n.project\n.cproject\n/.settings/\n\n# DS_Store\n.DS_Store\n\n# temps\n/version\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 4.1015625,
          "content": "Baptiste Lepilleur <blep@users.sourceforge.net>\n\nAaron Jacobs <aaronjjacobs@gmail.com>\nAaron Jacobs <jacobsa@google.com>\nAdam Boseley <ABoseley@agjunction.com>\nAdam Boseley <adam.boseley@gmail.com>\nAleksandr Derbenev <13alexac@gmail.com>\nAlexander Gazarov <DrMetallius@users.noreply.github.com>\nAlexander V. Brezgin <abrezgin@appliedtech.ru>\nAlexandr Brezgin <albrezgin@mail.ru>\nAlexey Kruchinin <alexey@mopals.com>\nAnton Indrawan <anton.indrawan@gmail.com>\nBaptiste Jonglez <git@bitsofnetworks.org>\nBaptiste Lepilleur <baptiste.lepilleur@gmail.com>\nBaruch Siach <baruch@tkos.co.il>\nBen Boeckel <mathstuf@gmail.com>\nBenjamin Knecht <bknecht@logitech.com>\nBernd Kuhls <bernd.kuhls@t-online.de>\nBilly Donahue <billy.donahue@gmail.com>\nBraden McDorman <bmcdorman@gmail.com>\nBrandon Myers <bmyers1788@gmail.com>\nBrendan Drew <brendan.drew@daqri.com>\nchason <cxchao802@gmail.com>\nchenguoping <chenguopingdota@163.com>\nChris Gilling <cgilling@iparadigms.com>\nChristopher Dawes <christopher.dawes.1981@googlemail.com>\nChristopher Dunn <cdunn2001@gmail.com>\nChuck Atkins <chuck.atkins@kitware.com>\nCody P Schafer <dev@codyps.com>\nConnor Manning <connor@hobu.co>\nCory Quammen <cory.quammen@kitware.com>\nCristóvão B da Cruz e Silva <CrisXed@gmail.com>\nDaniel Krügler <daniel.kruegler@gmail.com>\nDani-Hub <daniel.kruegler@googlemail.com>\nDan Liu <gzliudan>\ndatadiode <datadiode@users.noreply.github.com>\ndatadiode <jochen.neubeck@vodafone.de>\nDavid Seifert <soap@gentoo.org>\nDavid West <david-west@idexx.com>\ndawesc <chris.dawes@eftlab.co.uk>\nDevin Jeanpierre <jeanpierreda@google.com>\nDmitry Marakasov <amdmi3@amdmi3.ru>\ndominicpezzuto <dom@dompezzuto.com>\nDon Milham <dmilham@gmail.com>\ndrgler <daniel.kruegler@gmail.com>\nds283 <D.Seery@sussex.ac.uk>\nEgor Tensin <Egor.Tensin@gmail.com>\neightnoteight <mr.eightnoteight@gmail.com>\nEvince <baneyue@gmail.com>\nfilipjs <filipjs@users.noreply.github.com>\nfindblar <ft@finbarr.ca>\nFlorian Meier <florian.meier@koalo.de>\nGaëtan Lehmann <gaetan.lehmann@gmail.com>\nGaurav <g.gupta@samsung.com>\nGergely Nagy <ngg@ngg.hu>\nGida Pataki <gida.pataki@prezi.com>\nI3ck <buckmartin@buckmartin.de>\nIñaki Baz Castillo <ibc@aliax.net>\nJacco <jacco@geul.net>\nJean-Christophe Fillion-Robin <jchris.fillionr@kitware.com>\nJonas Platte <mail@jonasplatte.de>\nJordan Bayles <bayles.jordan@gmail.com>\nJörg Krause <joerg.krause@embedded.rocks>\nKeith Lea <keith@whamcitylights.com>\nKevin Grant <kbradleygrant@gmail.com>\nKirill V. Lyadvinsky <jia3ep@gmail.com>\nKirill V. Lyadvinsky <mail@codeatcpp.com>\nKobi Gurkan <kobigurk@gmail.com>\nMagnus Bjerke Vik <mbvett@gmail.com>\nMalay Shah <malays@users.sourceforge.net>\nMara Kim <hacker.root@gmail.com>\nMarek Kotewicz <marek.kotewicz@gmail.com>\nMark Lakata <mark@lakata.org>\nMark Zeren <mzeren@vmware.com>\nMartin Buck <buckmartin@buckmartin.de>\nMartyn Gigg <martyn.gigg@gmail.com>\nMattes D <github@xoft.cz>\nMatthias Loy <matthias.loy@hbm.com>\nMerlyn Morgan-Graham <kavika@gmail.com>\nMichael Shields <mshields@google.com>\nMichał Górny <mgorny@gentoo.org>\nMike Naberezny <mike@naberezny.com>\nmloy <matthias.loy@googlemail.com>\nMotti <lanzkron@gmail.com>\nnnkur <nnkur@mail.ru>\nOmkar Wagh <owagh@owaghlinux.ny.tower-research.com>\npaulo <paulobrizolara@users.noreply.github.com>\npavel.pimenov <pavel.pimenov@gmail.com>\nPaweł Bylica <chfast@gmail.com>\nPéricles Lopes Machado <pericles.raskolnikoff@gmail.com>\nPeter Spiess-Knafl <psk@autistici.org>\npffang <pffang@vip.qq.com>\nRémi Verschelde <remi@verschelde.fr>\nrenu555 <renu.tyagi@samsung.com>\nRobert Dailey <rcdailey@gmail.com>\nSam Clegg <sbc@chromium.org>\nselaselah <selah@outlook.com>\nSergiy80 <sil2004@gmail.com>\nsergzub <sergzub@gmail.com>\nStefan Schweter <stefan@schweter.it>\nStefano Fiorentino <stefano.fiore84@gmail.com>\nSteffen Kieß <Steffen.Kiess@ipvs.uni-stuttgart.de>\nSteven Hahn <hahnse@ornl.gov>\nStuart Eichert <stuart@fivemicro.com>\nSuperManitu <supermanitu@gmail.com>\nTechwolf <dring@g33kworld.net>\nTengiz Sharafiev <btolfa+github@gmail.com>\nTomasz Maciejewski <tmaciejewsk@gmail.com>\nVicente Olivert Riera <Vincent.Riera@imgtec.com>\nxiaoyur347 <xiaoyur347@gmail.com>\nycqiu <429148848@qq.com>\nyiqiju <fred_ju@selinc.com>\nYu Xiaolei <dreifachstein@gmail.com>\n\nGoogle Inc.\n"
        },
        {
          "name": "BUILD.bazel",
          "type": "blob",
          "size": 0.908203125,
          "content": "licenses([\"unencumbered\"])  # Public Domain or MIT\n\nexports_files([\"LICENSE\"])\n\ncc_library(\n    name = \"jsoncpp\",\n    srcs = [\n        \"src/lib_json/json_reader.cpp\",\n        \"src/lib_json/json_tool.h\",\n        \"src/lib_json/json_value.cpp\",\n        \"src/lib_json/json_writer.cpp\",\n    ],\n    hdrs = [\n        \"include/json/allocator.h\",\n        \"include/json/assertions.h\",\n        \"include/json/config.h\",\n        \"include/json/json_features.h\",\n        \"include/json/forwards.h\",\n        \"include/json/json.h\",\n        \"include/json/reader.h\",\n        \"include/json/value.h\",\n        \"include/json/version.h\",\n        \"include/json/writer.h\",\n    ],\n    copts = [\n        \"-DJSON_USE_EXCEPTION=0\",\n        \"-DJSON_HAS_INT64\",\n    ],\n    includes = [\"include\"],\n    visibility = [\"//visibility:public\"],\n    deps = [\":private\"],\n)\n\ncc_library(\n    name = \"private\",\n    textual_hdrs = [\"src/lib_json/json_valueiterator.inl\"],\n)\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 8.2001953125,
          "content": "# vim: et ts=4 sts=4 sw=4 tw=0\n\n# ==== Define cmake build policies that affect compilation and linkage default behaviors\n#\n# Set the JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION string to the newest cmake version\n# policies that provide successful builds. By setting JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION\n# to a value greater than the oldest policies, all policies between\n# JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION and CMAKE_VERSION (used for this build)\n# are set to their NEW behavior, thereby suppressing policy warnings related to policies\n# between the JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION and CMAKE_VERSION.\n#\n# CMake versions greater than the JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION policies will\n# continue to generate policy warnings \"CMake Warning (dev)...Policy CMP0XXX is not set:\"\n#\nset(JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION \"3.8.0\")\nset(JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION \"3.13.2\")\ncmake_minimum_required(VERSION ${JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION})\nif(\"${CMAKE_VERSION}\" VERSION_LESS \"${JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION}\")\n    #Set and use the newest available cmake policies that are validated to work\n    set(JSONCPP_CMAKE_POLICY_VERSION \"${CMAKE_VERSION}\")\nelse()\n    set(JSONCPP_CMAKE_POLICY_VERSION \"${JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION}\")\nendif()\ncmake_policy(VERSION ${JSONCPP_CMAKE_POLICY_VERSION})\nif(POLICY CMP0091)\n    cmake_policy(SET CMP0091 NEW)\nendif()\n#\n# Now enumerate specific policies newer than JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION\n# that may need to be individually set to NEW/OLD\n#\nforeach(pnew \"\") # Currently Empty\n    if(POLICY ${pnew})\n        cmake_policy(SET ${pnew} NEW)\n    endif()\nendforeach()\nforeach(pold \"\") # Currently Empty\n    if(POLICY ${pold})\n        cmake_policy(SET ${pold} OLD)\n    endif()\nendforeach()\n\n# Build the library with C++11 standard support, independent from other including\n# software which may use a different CXX_STANDARD or CMAKE_CXX_STANDARD.\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Ensure that CMAKE_BUILD_TYPE has a value specified for single configuration generators.\nif(NOT DEFINED CMAKE_BUILD_TYPE AND NOT DEFINED CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE Release CACHE STRING\n        \"Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel Coverage.\")\nendif()\n\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n\nproject(jsoncpp\n        # Note: version must be updated in three places when doing a release. This\n        # annoying process ensures that amalgamate, CMake, and meson all report the\n        # correct version.\n        # 1. ./meson.build\n        # 2. ./include/json/version.h\n        # 3. ./CMakeLists.txt\n        # IMPORTANT: also update the PROJECT_SOVERSION!!\n        VERSION 1.9.7 # <major>[.<minor>[.<patch>[.<tweak>]]]\n        LANGUAGES CXX)\n\nmessage(STATUS \"JsonCpp Version: ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}\")\nset(PROJECT_SOVERSION 27)\n\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/include/PreventInSourceBuilds.cmake)\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/include/PreventInBuildInstalls.cmake)\n\noption(JSONCPP_WITH_TESTS \"Compile and (for jsoncpp_check) run JsonCpp test executables\" ON)\noption(JSONCPP_WITH_POST_BUILD_UNITTEST \"Automatically run unit-tests as a post build step\" ON)\noption(JSONCPP_WITH_WARNING_AS_ERROR \"Force compilation to fail if a warning occurs\" OFF)\noption(JSONCPP_WITH_STRICT_ISO \"Issue all the warnings demanded by strict ISO C and ISO C++\" ON)\noption(JSONCPP_WITH_PKGCONFIG_SUPPORT \"Generate and install .pc files\" ON)\noption(JSONCPP_WITH_CMAKE_PACKAGE \"Generate and install cmake package files\" ON)\noption(JSONCPP_WITH_EXAMPLE \"Compile JsonCpp example\" OFF)\noption(JSONCPP_STATIC_WINDOWS_RUNTIME \"Use static (MT/MTd) Windows runtime\" OFF)\noption(BUILD_SHARED_LIBS \"Build jsoncpp_lib as a shared library.\" ON)\noption(BUILD_STATIC_LIBS \"Build jsoncpp_lib as a static library.\" ON)\noption(BUILD_OBJECT_LIBS \"Build jsoncpp_lib as a object library.\" ON)\n\n# Adhere to GNU filesystem layout conventions\ninclude(GNUInstallDirs)\n\nif(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/lib\" CACHE PATH \"Archive output dir.\")\n    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/lib\" CACHE PATH \"Library output dir.\")\n    set(CMAKE_PDB_OUTPUT_DIRECTORY     \"${CMAKE_BINARY_DIR}/bin\" CACHE PATH \"PDB (MSVC debug symbol)output dir.\")\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\" CACHE PATH \"Executable/dll output dir.\")\nendif()\n\ninclude(CheckFunctionExists)\ncheck_function_exists(memset_s HAVE_MEMSET_S)\nif(HAVE_MEMSET_S)\n    add_definitions(\"-DHAVE_MEMSET_S=1\")\nendif()\n\nif(JSONCPP_USE_SECURE_MEMORY)\n    add_definitions(\"-DJSONCPP_USE_SECURE_MEMORY=1\")\nendif()\n\nconfigure_file(\"${PROJECT_SOURCE_DIR}/version.in\"\n    \"${PROJECT_BINARY_DIR}/version\"\n    NEWLINE_STYLE UNIX)\n\nmacro(use_compilation_warning_as_error)\n    if(MSVC)\n        # Only enabled in debug because some old versions of VS STL generate\n        # warnings when compiled in release configuration.\n        add_compile_options($<$<CONFIG:Debug>:/WX>)\n    elseif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        add_compile_options(-Werror)\n        if(JSONCPP_WITH_STRICT_ISO)\n            add_compile_options(-pedantic-errors)\n        endif()\n    endif()\nendmacro()\n\n# Include our configuration header\ninclude_directories(${jsoncpp_SOURCE_DIR}/include)\n\nif(MSVC)\n    # Only enabled in debug because some old versions of VS STL generate\n    # unreachable code warning when compiled in release configuration.\n    add_compile_options($<$<CONFIG:Debug>:/W4>)\n    if (JSONCPP_STATIC_WINDOWS_RUNTIME)\n        set(CMAKE_MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\n    endif()\nendif()\n\nif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n    # using regular Clang or AppleClang\n    add_compile_options(-Wall -Wconversion -Wshadow)\n\n    if(JSONCPP_WITH_WARNING_AS_ERROR)\n        add_compile_options(-Werror=conversion -Werror=sign-compare)\n    endif()\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n    # using GCC\n    add_compile_options(-Wall -Wconversion -Wshadow -Wextra)\n    # not yet ready for -Wsign-conversion\n\n    if(JSONCPP_WITH_STRICT_ISO)\n        add_compile_options(-Wpedantic)\n    endif()\n    if(JSONCPP_WITH_WARNING_AS_ERROR)\n        add_compile_options(-Werror=conversion)\n    endif()\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"Intel\")\n    # using Intel compiler\n    add_compile_options(-Wall -Wconversion -Wshadow -Wextra)\n\n    if(JSONCPP_WITH_WARNING_AS_ERROR)\n        add_compile_options(-Werror=conversion)\n    elseif(JSONCPP_WITH_STRICT_ISO)\n        add_compile_options(-Wpedantic)\n    endif()\nendif()\n\nif(JSONCPP_WITH_WARNING_AS_ERROR)\n    use_compilation_warning_as_error()\nendif()\n\nif(JSONCPP_WITH_PKGCONFIG_SUPPORT)\n    include(JoinPaths)\n\n    join_paths(libdir_for_pc_file \"\\${exec_prefix}\" \"${CMAKE_INSTALL_LIBDIR}\")\n    join_paths(includedir_for_pc_file \"\\${prefix}\" \"${CMAKE_INSTALL_INCLUDEDIR}\")\n\n    configure_file(\n        \"pkg-config/jsoncpp.pc.in\"\n        \"pkg-config/jsoncpp.pc\"\n        @ONLY)\n    install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/pkg-config/jsoncpp.pc\"\n        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/pkgconfig\")\nendif()\n\nif(JSONCPP_WITH_CMAKE_PACKAGE)\n    include(CMakePackageConfigHelpers)\n    install(EXPORT jsoncpp\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/jsoncpp\n        FILE        jsoncpp-targets.cmake)\n    configure_package_config_file(jsoncppConfig.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/jsoncppConfig.cmake\n        INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/jsoncpp)\n\n    write_basic_package_version_file(\"${CMAKE_CURRENT_BINARY_DIR}/jsoncppConfigVersion.cmake\"\n        VERSION ${PROJECT_VERSION}\n        COMPATIBILITY SameMajorVersion)\n    install(FILES\n        ${CMAKE_CURRENT_BINARY_DIR}/jsoncppConfigVersion.cmake ${CMAKE_CURRENT_BINARY_DIR}/jsoncppConfig.cmake\n        ${CMAKE_CURRENT_SOURCE_DIR}/jsoncpp-namespaced-targets.cmake\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/jsoncpp)\nendif()\n\nif(JSONCPP_WITH_TESTS)\n    enable_testing()\n    include(CTest)\nendif()\n\n# Build the different applications\nadd_subdirectory(src)\n\n#install the includes\nadd_subdirectory(include)\n\n#install the example\nif(JSONCPP_WITH_EXAMPLE)\n    add_subdirectory(example)\nendif()\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.775390625,
          "content": "# Contributing to JsonCpp\n\n## Building\n\nBoth CMake and Meson tools are capable of generating a variety of build environments for you preferred development environment.\nUsing cmake or meson you can generate an XCode, Visual Studio, Unix Makefile, Ninja, or other environment that fits your needs.\n\nAn example of a common Meson/Ninja environment is described next.\n\n## Building and testing with Meson/Ninja\nThanks to David Seifert (@SoapGentoo), we (the maintainers) now use\n[meson](http://mesonbuild.com/) and [ninja](https://ninja-build.org/) to build\nfor debugging, as well as for continuous integration (see\n[`./.travis_scripts/meson_builder.sh`](./.travis_scripts/meson_builder.sh) ). Other systems may work, but minor\nthings like version strings might break.\n\nFirst, install both meson (which requires Python3) and ninja.\nIf you wish to install to a directory other than /usr/local, set an environment variable called DESTDIR with the desired path:\n    DESTDIR=/path/to/install/dir\n\nThen,\n```sh\n    cd jsoncpp/\n    BUILD_TYPE=debug\n    #BUILD_TYPE=release\n    LIB_TYPE=shared\n    #LIB_TYPE=static\n    meson --buildtype ${BUILD_TYPE} --default-library ${LIB_TYPE} . build-${LIB_TYPE}\n    ninja -v -C build-${LIB_TYPE}\n\n    ninja -C build-static/ test\n\n    # Or\n    #cd build-${LIB_TYPE}\n    #meson test --no-rebuild --print-errorlogs\n\n    sudo ninja install\n```\n\n## Building and testing with other build systems\nSee https://github.com/open-source-parsers/jsoncpp/wiki/Building\n\n## Running the tests manually\n\nYou need to run tests manually only if you are troubleshooting an issue.\n\nIn the instructions below, replace `path/to/jsontest` with the path of the\n`jsontest` executable that was compiled on your platform.\n\n    cd test\n    # This will run the Reader/Writer tests\n    python runjsontests.py path/to/jsontest\n\n    # This will run the Reader/Writer tests, using JSONChecker test suite\n    # (http://www.json.org/JSON_checker/).\n    # Notes: not all tests pass: JsonCpp is too lenient (for example,\n    # it allows an integer to start with '0'). The goal is to improve\n    # strict mode parsing to get all tests to pass.\n    python runjsontests.py --with-json-checker path/to/jsontest\n\n    # This will run the unit tests (mostly Value)\n    python rununittests.py path/to/test_lib_json\n\n    # You can run the tests using valgrind:\n    python rununittests.py --valgrind path/to/test_lib_json\n\n## Building the documentation\n\nRun the Python script `doxybuild.py` from the top directory:\n\n    python doxybuild.py --doxygen=$(which doxygen) --open --with-dot\n\nSee `doxybuild.py --help` for options.\n\n## Adding a reader/writer test\n\nTo add a test, you need to create two files in test/data:\n\n* a `TESTNAME.json` file, that contains the input document in JSON format.\n* a `TESTNAME.expected` file, that contains a flattened representation of the\n  input document.\n\nThe `TESTNAME.expected` file format is as follows:\n\n* Each line represents a JSON element of the element tree represented by the\n  input document.\n* Each line has two parts: the path to access the element separated from the\n  element value by `=`. Array and object values are always empty (i.e.\n  represented by either `[]` or `{}`).\n* Element path `.` represents the root element, and is used to separate object\n  members. `[N]` is used to specify the value of an array element at index `N`.\n\nSee the examples `test_complex_01.json` and `test_complex_01.expected` to better understand element paths.\n\n## Understanding reader/writer test output\n\nWhen a test is run, output files are generated beside the input test files. Below is a short description of the content of each file:\n\n* `test_complex_01.json`: input JSON document.\n* `test_complex_01.expected`: flattened JSON element tree used to check if\n  parsing was corrected.\n* `test_complex_01.actual`: flattened JSON element tree produced by `jsontest`\n  from reading `test_complex_01.json`.\n* `test_complex_01.rewrite`: JSON document written by `jsontest` using the\n  `Json::Value` parsed from `test_complex_01.json` and serialized using\n  `Json::StyledWritter`.\n* `test_complex_01.actual-rewrite`: flattened JSON element tree produced by\n  `jsontest` from reading `test_complex_01.rewrite`.\n* `test_complex_01.process-output`: `jsontest` output, typically useful for\n  understanding parsing errors.\n\n## Versioning rules\n\nConsumers of this library require a strict approach to incrementing versioning of the JsonCpp library. Currently, we follow the below set of rules:\n\n* Any new public symbols require a minor version bump.\n* Any alteration or removal of public symbols requires a major version bump, including changing the size of a class. This is necessary for\nconsumers to do dependency injection properly.\n\n## Preparing code for submission\n\nGenerally, JsonCpp's style guide has been pretty relaxed, with the following common themes:\n\n* Variables and function names use lower camel case (E.g. parseValue or collectComments).\n* Class use camel case (e.g. OurReader)\n* Member variables have a trailing underscore\n* Prefer `nullptr` over `NULL`.\n* Passing by non-const reference is allowed.\n* Single statement if blocks may omit brackets.\n* Generally prefer less space over more space.\n\nFor an example:\n\n```c++\nbool Reader::decodeNumber(Token& token) {\n  Value decoded;\n  if (!decodeNumber(token, decoded))\n    return false;\n  currentValue().swapPayload(decoded);\n  currentValue().setOffsetStart(token.start_ - begin_);\n  currentValue().setOffsetLimit(token.end_ - begin_);\n  return true;\n}\n```\n\nBefore submitting your code, ensure that you meet the versioning requirements above, follow the style guide of the file you are modifying (or the above rules for new files), and run clang format. Meson exposes clang format with the following command:\n```\nninja -v -C build-${LIB_TYPE}/ clang-format\n```\n\nFor convenience, you can also run the `reformat.sh` script located in the root directory.\n\n"
        },
        {
          "name": "CTestConfig.cmake",
          "type": "blob",
          "size": 0.5205078125,
          "content": "## This file should be placed in the root directory of your project.\n## Then modify the CMakeLists.txt file in the root directory of your\n## project to incorporate the testing dashboard.\n##\n## # The following are required to submit to the CDash dashboard:\n##   ENABLE_TESTING()\n##   INCLUDE(CTest)\n\nset(CTEST_PROJECT_NAME \"jsoncpp\")\nset(CTEST_NIGHTLY_START_TIME \"01:23:45 UTC\")\n\nset(CTEST_DROP_METHOD \"https\")\nset(CTEST_DROP_SITE \"my.cdash.org\")\nset(CTEST_DROP_LOCATION \"/submit.php?project=jsoncpp\")\nset(CTEST_DROP_SITE_CDASH TRUE)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.650390625,
          "content": "The JsonCpp library's source code, including accompanying documentation,\ntests and demonstration applications, are licensed under the following\nconditions...\n\nBaptiste Lepilleur and The JsonCpp Authors explicitly disclaim copyright in all\njurisdictions which recognize such a disclaimer. In such jurisdictions,\nthis software is released into the Public Domain.\n\nIn jurisdictions which do not recognize Public Domain property (e.g. Germany as of\n2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur and\nThe JsonCpp Authors, and is released under the terms of the MIT License (see below).\n\nIn jurisdictions which recognize Public Domain property, the user of this\nsoftware may choose to accept it either as 1) Public Domain, 2) under the\nconditions of the MIT License (see below), or 3) under the terms of dual\nPublic Domain/MIT License conditions described here, as they choose.\n\nThe MIT License is about as close to Public Domain as a license can get, and is\ndescribed in clear, concise terms at:\n\n   http://en.wikipedia.org/wiki/MIT_License\n\nThe full text of the MIT License follows:\n\n========================================================================\nCopyright (c) 2007-2010 Baptiste Lepilleur and The JsonCpp Authors\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use, copy,\nmodify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n========================================================================\n(END LICENSE TEXT)\n\nThe MIT license is compatible with both the GPL and commercial\nsoftware, affording one all of the rights of Public Domain with the\nminor nuisance of being required to keep the above copyright notice\nand license text in the source code. Note also that by accepting the\nPublic Domain \"license\" you can re-license your copy using whatever\nlicense you like.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.66796875,
          "content": "# JsonCpp\n\n[![badge](https://img.shields.io/badge/conan.io-jsoncpp%2F1.8.0-green.svg?logo=data:image/png;base64%2CiVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAMAAAAolt3jAAAA1VBMVEUAAABhlctjlstkl8tlmMtlmMxlmcxmmcxnmsxpnMxpnM1qnc1sn85voM91oM11oc1xotB2oc56pNF6pNJ2ptJ8ptJ8ptN9ptN8p9N5qNJ9p9N9p9R8qtOBqdSAqtOAqtR%2BrNSCrNJ/rdWDrNWCsNWCsNaJs9eLs9iRvNuVvdyVv9yXwd2Zwt6axN6dxt%2Bfx%2BChyeGiyuGjyuCjyuGly%2BGlzOKmzOGozuKoz%2BKqz%2BOq0OOv1OWw1OWw1eWx1eWy1uay1%2Baz1%2Baz1%2Bez2Oe02Oe12ee22ujUGwH3AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgBQkREyOxFIh/AAAAiklEQVQI12NgAAMbOwY4sLZ2NtQ1coVKWNvoc/Eq8XDr2wB5Ig62ekza9vaOqpK2TpoMzOxaFtwqZua2Bm4makIM7OzMAjoaCqYuxooSUqJALjs7o4yVpbowvzSUy87KqSwmxQfnsrPISyFzWeWAXCkpMaBVIC4bmCsOdgiUKwh3JojLgAQ4ZCE0AMm2D29tZwe6AAAAAElFTkSuQmCC)](https://bintray.com/theirix/conan-repo/jsoncpp%3Atheirix)\n[![badge](https://img.shields.io/badge/license-MIT-blue)](https://github.com/open-source-parsers/jsoncpp/blob/master/LICENSE)\n[![badge](https://img.shields.io/badge/document-doxygen-brightgreen)](http://open-source-parsers.github.io/jsoncpp-docs/doxygen/index.html)\n[![Coverage Status](https://coveralls.io/repos/github/open-source-parsers/jsoncpp/badge.svg?branch=master)](https://coveralls.io/github/open-source-parsers/jsoncpp?branch=master)\n\n\n[JSON][json-org] is a lightweight data-interchange format. It can represent\nnumbers, strings, ordered sequences of values, and collections of name/value\npairs.\n\n[json-org]: http://json.org/\n\nJsonCpp is a C++ library that allows manipulating JSON values, including\nserialization and deserialization to and from strings. It can also preserve\nexisting comment in unserialization/serialization steps, making it a convenient\nformat to store user input files.\n\n\n## Documentation\n\n[JsonCpp documentation][JsonCpp-documentation] is generated using [Doxygen][].\n\n[JsonCpp-documentation]: http://open-source-parsers.github.io/jsoncpp-docs/doxygen/index.html\n[Doxygen]: http://www.doxygen.org\n\n\n## A note on backward-compatibility\n\n* `1.y.z` is built with C++11.\n* `0.y.z` can be used with older compilers.\n* `00.11.z` can be used both in old and new compilers.\n* Major versions maintain binary-compatibility.\n\n### Special note\nThe branch `00.11.z`is a new branch, its major version number `00` is to show that it is\ndifferent from `0.y.z` and `1.y.z`, the main purpose of this branch is to make a balance\nbetween the other two branches. Thus, users can use some new features in this new branch\nthat introduced in 1.y.z, but can hardly applied into 0.y.z.\n\n## Using JsonCpp in your project\n\n### The vcpkg dependency manager\nYou can download and install JsonCpp using the [vcpkg](https://github.com/Microsoft/vcpkg/) dependency manager:\n\n    git clone https://github.com/Microsoft/vcpkg.git\n    cd vcpkg\n    ./bootstrap-vcpkg.sh\n    ./vcpkg integrate install\n    ./vcpkg install jsoncpp\n\nThe JsonCpp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n### Amalgamated source\nhttps://github.com/open-source-parsers/jsoncpp/wiki/Amalgamated-(Possibly-outdated)\n\n### The Meson Build System\nIf you are using the [Meson Build System](http://mesonbuild.com), then you can get a wrap file by downloading it from [Meson WrapDB](https://wrapdb.mesonbuild.com/jsoncpp), or simply use `meson wrap install jsoncpp`.\n\n### Other ways\nIf you have trouble, see the [Wiki](https://github.com/open-source-parsers/jsoncpp/wiki), or post a question as an Issue.\n\n## License\n\nSee the `LICENSE` file for details. In summary, JsonCpp is licensed under the\nMIT license, or public domain if desired and recognized in your jurisdiction.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.7119140625,
          "content": "# Security Policy\n\nIf you have discovered a security vulnerability in this project, please report it\nprivately. **Do not disclose it as a public issue.** This gives us time to work with you\nto fix the issue before public exposure, reducing the chance that the exploit will be\nused before a patch is released.\n\nPlease submit the report by filling out\n[this form](https://github.com/open-source-parsers/jsoncpp/security/advisories/new).\n\nPlease provide the following information in your report:\n\n- A description of the vulnerability and its impact\n- How to reproduce the issue\n\nThis project is maintained by volunteers on a reasonable-effort basis. As such,\nwe ask that you give us 90 days to work on a fix before public exposure.\n"
        },
        {
          "name": "amalgamate.py",
          "type": "blob",
          "size": 7.0546875,
          "content": "#!/usr/bin/env python\n\n\"\"\"Amalgamate json-cpp library sources into a single source and header file.\n\nWorks with python2.6+ and python3.4+.\n\nExample of invocation (must be invoked from json-cpp top directory):\npython amalgamate.py\n\"\"\"\nimport os\nimport os.path\nimport sys\n\nINCLUDE_PATH = \"include/json\"\nSRC_PATH = \"src/lib_json\"\n\nclass AmalgamationFile:\n    def __init__(self, top_dir):\n        self.top_dir = top_dir\n        self.blocks = []\n\n    def add_text(self, text):\n        if not text.endswith(\"\\n\"):\n            text += \"\\n\"\n        self.blocks.append(text)\n\n    def add_file(self, relative_input_path, wrap_in_comment=False):\n        def add_marker(prefix):\n            self.add_text(\"\")\n            self.add_text(\"// \" + \"/\"*70)\n            self.add_text(\"// %s of content of file: %s\" % (prefix, relative_input_path.replace(\"\\\\\",\"/\")))\n            self.add_text(\"// \" + \"/\"*70)\n            self.add_text(\"\")\n        add_marker(\"Beginning\")\n        f = open(os.path.join(self.top_dir, relative_input_path), \"rt\")\n        content = f.read()\n        if wrap_in_comment:\n            content = \"/*\\n\" + content + \"\\n*/\"\n        self.add_text(content)\n        f.close()\n        add_marker(\"End\")\n        self.add_text(\"\\n\\n\\n\\n\")\n\n    def get_value(self):\n        return \"\".join(self.blocks).replace(\"\\r\\n\",\"\\n\")\n\n    def write_to(self, output_path):\n        output_dir = os.path.dirname(output_path)\n        if output_dir and not os.path.isdir(output_dir):\n            os.makedirs(output_dir)\n        f = open(output_path, \"wb\")\n        f.write(str.encode(self.get_value(), 'UTF-8'))\n        f.close()\n\ndef amalgamate_source(source_top_dir=None,\n                       target_source_path=None,\n                       header_include_path=None):\n    \"\"\"Produces amalgamated source.\n       Parameters:\n           source_top_dir: top-directory\n           target_source_path: output .cpp path\n           header_include_path: generated header path relative to target_source_path.\n    \"\"\"\n    print(\"Amalgamating header...\")\n    header = AmalgamationFile(source_top_dir)\n    header.add_text(\"/// Json-cpp amalgamated header (https://github.com/open-source-parsers/jsoncpp/).\")\n    header.add_text('/// It is intended to be used with #include \"%s\"' % header_include_path)\n    header.add_file(\"LICENSE\", wrap_in_comment=True)\n    header.add_text(\"#ifndef JSON_AMALGAMATED_H_INCLUDED\")\n    header.add_text(\"# define JSON_AMALGAMATED_H_INCLUDED\")\n    header.add_text(\"/// If defined, indicates that the source file is amalgamated\")\n    header.add_text(\"/// to prevent private header inclusion.\")\n    header.add_text(\"#define JSON_IS_AMALGAMATION\")\n    header.add_file(os.path.join(INCLUDE_PATH, \"version.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"allocator.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"config.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"forwards.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"json_features.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"value.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"reader.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"writer.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"assertions.h\"))\n    header.add_text(\"#endif //ifndef JSON_AMALGAMATED_H_INCLUDED\")\n\n    target_header_path = os.path.join(os.path.dirname(target_source_path), header_include_path)\n    print(\"Writing amalgamated header to %r\" % target_header_path)\n    header.write_to(target_header_path)\n\n    base, ext = os.path.splitext(header_include_path)\n    forward_header_include_path = base + \"-forwards\" + ext\n    print(\"Amalgamating forward header...\")\n    header = AmalgamationFile(source_top_dir)\n    header.add_text(\"/// Json-cpp amalgamated forward header (https://github.com/open-source-parsers/jsoncpp/).\")\n    header.add_text('/// It is intended to be used with #include \"%s\"' % forward_header_include_path)\n    header.add_text(\"/// This header provides forward declaration for all JsonCpp types.\")\n    header.add_file(\"LICENSE\", wrap_in_comment=True)\n    header.add_text(\"#ifndef JSON_FORWARD_AMALGAMATED_H_INCLUDED\")\n    header.add_text(\"# define JSON_FORWARD_AMALGAMATED_H_INCLUDED\")\n    header.add_text(\"/// If defined, indicates that the source file is amalgamated\")\n    header.add_text(\"/// to prevent private header inclusion.\")\n    header.add_text(\"#define JSON_IS_AMALGAMATION\")\n    header.add_file(os.path.join(INCLUDE_PATH, \"version.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"allocator.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"config.h\"))\n    header.add_file(os.path.join(INCLUDE_PATH, \"forwards.h\"))\n    header.add_text(\"#endif //ifndef JSON_FORWARD_AMALGAMATED_H_INCLUDED\")\n\n    target_forward_header_path = os.path.join(os.path.dirname(target_source_path),\n                                               forward_header_include_path)\n    print(\"Writing amalgamated forward header to %r\" % target_forward_header_path)\n    header.write_to(target_forward_header_path)\n\n    print(\"Amalgamating source...\")\n    source = AmalgamationFile(source_top_dir)\n    source.add_text(\"/// Json-cpp amalgamated source (https://github.com/open-source-parsers/jsoncpp/).\")\n    source.add_text('/// It is intended to be used with #include \"%s\"' % header_include_path)\n    source.add_file(\"LICENSE\", wrap_in_comment=True)\n    source.add_text(\"\")\n    source.add_text('#include \"%s\"' % header_include_path)\n    source.add_text(\"\"\"\n#ifndef JSON_IS_AMALGAMATION\n#error \"Compile with -I PATH_TO_JSON_DIRECTORY\"\n#endif\n\"\"\")\n    source.add_text(\"\")\n    source.add_file(os.path.join(SRC_PATH, \"json_tool.h\"))\n    source.add_file(os.path.join(SRC_PATH, \"json_reader.cpp\"))\n    source.add_file(os.path.join(SRC_PATH, \"json_valueiterator.inl\"))\n    source.add_file(os.path.join(SRC_PATH, \"json_value.cpp\"))\n    source.add_file(os.path.join(SRC_PATH, \"json_writer.cpp\"))\n\n    print(\"Writing amalgamated source to %r\" % target_source_path)\n    source.write_to(target_source_path)\n\ndef main():\n    usage = \"\"\"%prog [options]\nGenerate a single amalgamated source and header file from the sources.\n\"\"\"\n    from optparse import OptionParser\n    parser = OptionParser(usage=usage)\n    parser.allow_interspersed_args = False\n    parser.add_option(\"-s\", \"--source\", dest=\"target_source_path\", action=\"store\", default=\"dist/jsoncpp.cpp\",\n        help=\"\"\"Output .cpp source path. [Default: %default]\"\"\")\n    parser.add_option(\"-i\", \"--include\", dest=\"header_include_path\", action=\"store\", default=\"json/json.h\",\n        help=\"\"\"Header include path. Used to include the header from the amalgamated source file. [Default: %default]\"\"\")\n    parser.add_option(\"-t\", \"--top-dir\", dest=\"top_dir\", action=\"store\", default=os.getcwd(),\n        help=\"\"\"Source top-directory. [Default: %default]\"\"\")\n    parser.enable_interspersed_args()\n    options, args = parser.parse_args()\n\n    msg = amalgamate_source(source_top_dir=options.top_dir,\n                             target_source_path=options.target_source_path,\n                             header_include_path=options.header_include_path)\n    if msg:\n        sys.stderr.write(msg + \"\\n\")\n        sys.exit(1)\n    else:\n        print(\"Source successfully amalgamated\")\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 1.5,
          "content": "clone_folder: c:\\projects\\jsoncpp\n\nenvironment:\n\n  matrix:\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015\n      CMAKE_GENERATOR: Visual Studio 14 2015\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015\n      CMAKE_GENERATOR: Visual Studio 14 2015 Win64\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      CMAKE_GENERATOR: Visual Studio 15 2017\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      CMAKE_GENERATOR: Visual Studio 15 2017 Win64\n\nbuild_script:\n  - cmake --version\n  # The build script starts in root.\n  - set JSONCPP_FOLDER=%cd%\n  - set JSONCPP_BUILD_FOLDER=%JSONCPP_FOLDER%\\build\\release\n  - mkdir -p %JSONCPP_BUILD_FOLDER%\n  - cd %JSONCPP_BUILD_FOLDER%\n  - cmake -G \"%CMAKE_GENERATOR%\" -DCMAKE_INSTALL_PREFIX:PATH=%CD:\\=/%/install -DBUILD_SHARED_LIBS:BOOL=ON %JSONCPP_FOLDER%\n  # Use ctest to make a dashboard build:\n  # - ctest -D Experimental(Start|Update|Configure|Build|Test|Coverage|MemCheck|Submit)\n  # NOTE: Testing on windows is not yet finished:\n  # - ctest -C Release -D ExperimentalStart -D ExperimentalConfigure -D ExperimentalBuild -D ExperimentalTest -D ExperimentalSubmit\n  - ctest -C Release -D ExperimentalStart -D ExperimentalConfigure -D ExperimentalBuild -D ExperimentalSubmit\n  # Final step is to verify that installation succeeds\n  - cmake --build . --config Release --target install\n\ndeploy:\n    provider: GitHub\n    auth_token:\n        secure: K2Tp1q8pIZ7rs0Ot24ZMWuwr12Ev6Tc6QkhMjGQxoQG3ng1pXtgPasiJ45IDXGdg\n    on:\n        branch: master\n        appveyor_repo_tag: true\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "dev.makefile",
          "type": "blob",
          "size": 1.10546875,
          "content": "# This is only for jsoncpp developers/contributors.\n# We use this to sign releases, generate documentation, etc.\nVER?=$(shell cat version)\n\ndefault:\n\t@echo \"VER=${VER}\"\nupdate-version:\n\tperl get_version.pl meson.build >| version\nsign: jsoncpp-${VER}.tar.gz\n\tgpg --armor --detach-sign $<\n\tgpg --verify $<.asc\n\t# Then upload .asc to the release.\njsoncpp-%.tar.gz:\n\tcurl https://github.com/open-source-parsers/jsoncpp/archive/$*.tar.gz -o $@\ndox:\n\tpython doxybuild.py --doxygen=$$(which doxygen) --in doc/web_doxyfile.in\n\trsync -va -c --delete dist/doxygen/jsoncpp-api-html-${VER}/ ../jsoncpp-docs/doxygen/\n\t# Then 'git add -A' and 'git push' in jsoncpp-docs.\nbuild:\n\tmkdir -p build/debug\n\tcd build/debug; cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_SHARED_LIBS=ON -G \"Unix Makefiles\" ../..\n\tmake -C build/debug\n\n# Currently, this depends on include/json/version.h generated\n# by cmake.\ntest-amalgamate:\n\tpython2.7 amalgamate.py\n\tpython3.4 amalgamate.py\n\tcd dist; gcc -I. -c jsoncpp.cpp\n\nvalgrind:\n\tvalgrind --error-exitcode=42 --leak-check=full ./build/debug/src/test_lib_json/jsoncpp_test\n\nclean:\n\t\\rm -rf *.gz *.asc dist/\n\n.PHONY: build\n"
        },
        {
          "name": "devtools",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "doxybuild.py",
          "type": "blob",
          "size": 7.2373046875,
          "content": "\"\"\"Script to generate doxygen documentation.\n\"\"\"\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\nfrom devtools import tarball\nfrom contextlib import contextmanager\nimport subprocess\nimport traceback\nimport re\nimport os\nimport sys\nimport shutil\n\n@contextmanager\ndef cd(newdir):\n    \"\"\"\n    http://stackoverflow.com/questions/431684/how-do-i-cd-in-python\n    \"\"\"\n    prevdir = os.getcwd()\n    os.chdir(newdir)\n    try:\n        yield\n    finally:\n        os.chdir(prevdir)\n\ndef find_program(*filenames):\n    \"\"\"find a program in folders path_lst, and sets env[var]\n    @param filenames: a list of possible names of the program to search for\n    @return: the full path of the filename if found, or '' if filename could not be found\n\"\"\"\n    paths = os.environ.get('PATH', '').split(os.pathsep)\n    suffixes = ('win32' in sys.platform) and '.exe .com .bat .cmd' or ''\n    for filename in filenames:\n        for name in [filename+ext for ext in suffixes.split(' ')]:\n            for directory in paths:\n                full_path = os.path.join(directory, name)\n                if os.path.isfile(full_path):\n                    return full_path\n    return ''\n\ndef do_subst_in_file(targetfile, sourcefile, dict):\n    \"\"\"Replace all instances of the keys of dict with their values.\n    For example, if dict is {'%VERSION%': '1.2345', '%BASE%': 'MyProg'},\n    then all instances of %VERSION% in the file will be replaced with 1.2345 etc.\n    \"\"\"\n    with open(sourcefile, 'r') as f:\n        contents = f.read()\n    for (k,v) in list(dict.items()):\n        v = v.replace('\\\\','\\\\\\\\')\n        contents = re.sub(k, v, contents)\n    with open(targetfile, 'w') as f:\n        f.write(contents)\n\ndef getstatusoutput(cmd):\n    \"\"\"cmd is a list.\n    \"\"\"\n    try:\n        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        output, _ = process.communicate()\n        status = process.returncode\n    except:\n        status = -1\n        output = traceback.format_exc()\n    return status, output\n\ndef run_cmd(cmd, silent=False):\n    \"\"\"Raise exception on failure.\n    \"\"\"\n    info = 'Running: %r in %r' %(' '.join(cmd), os.getcwd())\n    print(info)\n    sys.stdout.flush()\n    if silent:\n        status, output = getstatusoutput(cmd)\n    else:\n        status, output = subprocess.call(cmd), ''\n    if status:\n        msg = 'Error while %s ...\\n\\terror=%d, output=\"\"\"%s\"\"\"' %(info, status, output)\n        raise Exception(msg)\n\ndef assert_is_exe(path):\n    if not path:\n        raise Exception('path is empty.')\n    if not os.path.isfile(path):\n        raise Exception('%r is not a file.' %path)\n    if not os.access(path, os.X_OK):\n        raise Exception('%r is not executable by this user.' %path)\n\ndef run_doxygen(doxygen_path, config_file, working_dir, is_silent):\n    assert_is_exe(doxygen_path)\n    config_file = os.path.abspath(config_file)\n    with cd(working_dir):\n        cmd = [doxygen_path, config_file]\n        run_cmd(cmd, is_silent)\n\ndef build_doc(options,  make_release=False):\n    if make_release:\n        options.make_tarball = True\n        options.with_dot = True\n        options.with_html_help = True\n        options.with_uml_look = True\n        options.open = False\n        options.silent = True\n\n    version = open('version', 'rt').read().strip()\n    output_dir = 'dist/doxygen' # relative to doc/doxyfile location.\n    if not os.path.isdir(output_dir):\n        os.makedirs(output_dir)\n    top_dir = os.path.abspath('.')\n    html_output_dirname = 'jsoncpp-api-html-' + version\n    tarball_path = os.path.join('dist', html_output_dirname + '.tar.gz')\n    warning_log_path = os.path.join(output_dir, '../jsoncpp-doxygen-warning.log')\n    html_output_path = os.path.join(output_dir, html_output_dirname)\n    def yesno(bool):\n        return bool and 'YES' or 'NO'\n    subst_keys = {\n        '%JSONCPP_VERSION%': version,\n        '%DOC_TOPDIR%': '',\n        '%TOPDIR%': top_dir,\n        '%HTML_OUTPUT%': os.path.join('..', output_dir, html_output_dirname),\n        '%HAVE_DOT%': yesno(options.with_dot),\n        '%DOT_PATH%': os.path.split(options.dot_path)[0],\n        '%HTML_HELP%': yesno(options.with_html_help),\n        '%UML_LOOK%': yesno(options.with_uml_look),\n        '%WARNING_LOG_PATH%': os.path.join('..', warning_log_path)\n        }\n\n    if os.path.isdir(output_dir):\n        print('Deleting directory:', output_dir)\n        shutil.rmtree(output_dir)\n    if not os.path.isdir(output_dir):\n        os.makedirs(output_dir)\n\n    do_subst_in_file('doc/doxyfile', options.doxyfile_input_path, subst_keys)\n    run_doxygen(options.doxygen_path, 'doc/doxyfile', 'doc', is_silent=options.silent)\n    if not options.silent:\n        print(open(warning_log_path, 'r').read())\n    index_path = os.path.abspath(os.path.join('doc', subst_keys['%HTML_OUTPUT%'], 'index.html'))\n    print('Generated documentation can be found in:')\n    print(index_path)\n    if options.open:\n        import webbrowser\n        webbrowser.open('file://' + index_path)\n    if options.make_tarball:\n        print('Generating doc tarball to', tarball_path)\n        tarball_sources = [\n            output_dir,\n            'README.md',\n            'LICENSE',\n            'NEWS.txt',\n            'version'\n            ]\n        tarball_basedir = os.path.join(output_dir, html_output_dirname)\n        tarball.make_tarball(tarball_path, tarball_sources, tarball_basedir, html_output_dirname)\n    return tarball_path, html_output_dirname\n\ndef main():\n    usage = \"\"\"%prog\n    Generates doxygen documentation in build/doxygen.\n    Optionally makes a tarball of the documentation to dist/.\n\n    Must be started in the project top directory.\n    \"\"\"\n    from optparse import OptionParser\n    parser = OptionParser(usage=usage)\n    parser.allow_interspersed_args = False\n    parser.add_option('--with-dot', dest=\"with_dot\", action='store_true', default=False,\n        help=\"\"\"Enable usage of DOT to generate collaboration diagram\"\"\")\n    parser.add_option('--dot', dest=\"dot_path\", action='store', default=find_program('dot'),\n        help=\"\"\"Path to GraphViz dot tool. Must be full qualified path. [Default: %default]\"\"\")\n    parser.add_option('--doxygen', dest=\"doxygen_path\", action='store', default=find_program('doxygen'),\n        help=\"\"\"Path to Doxygen tool. [Default: %default]\"\"\")\n    parser.add_option('--in', dest=\"doxyfile_input_path\", action='store', default='doc/doxyfile.in',\n        help=\"\"\"Path to doxygen inputs. [Default: %default]\"\"\")\n    parser.add_option('--with-html-help', dest=\"with_html_help\", action='store_true', default=False,\n        help=\"\"\"Enable generation of Microsoft HTML HELP\"\"\")\n    parser.add_option('--no-uml-look', dest=\"with_uml_look\", action='store_false', default=True,\n        help=\"\"\"Generates DOT graph without UML look [Default: False]\"\"\")\n    parser.add_option('--open', dest=\"open\", action='store_true', default=False,\n        help=\"\"\"Open the HTML index in the web browser after generation\"\"\")\n    parser.add_option('--tarball', dest=\"make_tarball\", action='store_true', default=False,\n        help=\"\"\"Generates a tarball of the documentation in dist/ directory\"\"\")\n    parser.add_option('-s', '--silent', dest=\"silent\", action='store_true', default=False,\n        help=\"\"\"Hides doxygen output\"\"\")\n    parser.enable_interspersed_args()\n    options, args = parser.parse_args()\n    build_doc(options)\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "get_version.pl",
          "type": "blob",
          "size": 0.05859375,
          "content": "while (<>) {\n\tif (/version : '(.+)',/) {\n\t\tprint \"$1\";\n\t}\n}\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "jsoncpp-namespaced-targets.cmake",
          "type": "blob",
          "size": 0.4208984375,
          "content": "if (NOT TARGET JsonCpp::JsonCpp)\n    if (TARGET jsoncpp_static)\n        add_library(JsonCpp::JsonCpp INTERFACE IMPORTED)\n        set_target_properties(JsonCpp::JsonCpp PROPERTIES INTERFACE_LINK_LIBRARIES \"jsoncpp_static\")\n    elseif (TARGET jsoncpp_lib)\n        add_library(JsonCpp::JsonCpp INTERFACE IMPORTED)\n        set_target_properties(JsonCpp::JsonCpp PROPERTIES INTERFACE_LINK_LIBRARIES \"jsoncpp_lib\")\n    endif ()\nendif ()\n"
        },
        {
          "name": "jsoncppConfig.cmake.in",
          "type": "blob",
          "size": 0.2529296875,
          "content": "cmake_policy(PUSH)\ncmake_policy(VERSION 3.0...3.26)\n\n@PACKAGE_INIT@\n\ninclude ( \"${CMAKE_CURRENT_LIST_DIR}/jsoncpp-targets.cmake\" )\ninclude ( \"${CMAKE_CURRENT_LIST_DIR}/jsoncpp-namespaced-targets.cmake\" )\n\ncheck_required_components(JsonCpp)\n\ncmake_policy(POP)\n"
        },
        {
          "name": "jsoncppConfig.cmake.meson.in",
          "type": "blob",
          "size": 0.130859375,
          "content": "@PACKAGE_INIT@\n\n@MESON_SHARED_TARGET@\n@MESON_STATIC_TARGET@\n\ninclude ( \"${CMAKE_CURRENT_LIST_DIR}/jsoncpp-namespaced-targets.cmake\" )\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 4.6181640625,
          "content": "project(\n  'jsoncpp',\n  'cpp',\n\n  # Note: version must be updated in three places when doing a release. This\n  # annoying process ensures that amalgamate, CMake, and meson all report the\n  # correct version.\n  # 1. /meson.build\n  # 2. /include/json/version.h\n  # 3. /CMakeLists.txt\n  # IMPORTANT: also update the SOVERSION!!\n  version : '1.9.7',\n  default_options : [\n    'buildtype=release',\n    'cpp_std=c++11',\n    'warning_level=1'],\n  license : 'Public Domain',\n  meson_version : '>= 0.54.0')\n\n\njsoncpp_headers = files([\n  'include/json/allocator.h',\n  'include/json/assertions.h',\n  'include/json/config.h',\n  'include/json/json_features.h',\n  'include/json/forwards.h',\n  'include/json/json.h',\n  'include/json/reader.h',\n  'include/json/value.h',\n  'include/json/version.h',\n  'include/json/writer.h',\n])\njsoncpp_include_directories = include_directories('include')\n\ninstall_headers(\n  jsoncpp_headers,\n  subdir : 'json')\n\nif get_option('default_library') == 'shared' and meson.get_compiler('cpp').get_id() == 'msvc'\n  dll_export_flag = '-DJSON_DLL_BUILD'\n  dll_import_flag = '-DJSON_DLL'\nelse\n  dll_export_flag = []\n  dll_import_flag = []\nendif\n\njsoncpp_lib = library(\n  'jsoncpp', files([\n    'src/lib_json/json_reader.cpp',\n    'src/lib_json/json_value.cpp',\n    'src/lib_json/json_writer.cpp',\n  ]),\n  soversion : 27,\n  install : true,\n  include_directories : jsoncpp_include_directories,\n  cpp_args: dll_export_flag)\n\nimport('pkgconfig').generate(\n  libraries : jsoncpp_lib,\n  version : meson.project_version(),\n  name : 'jsoncpp',\n  filebase : 'jsoncpp',\n  description : 'A C++ library for interacting with JSON')\n\ncmakeconf = configuration_data()\ncmakeconf.set('MESON_LIB_DIR', get_option('libdir'))\ncmakeconf.set('MESON_INCLUDE_DIR', get_option('includedir'))\n\nfs = import('fs')\nif get_option('default_library') == 'shared'\n  shared_name = fs.name(jsoncpp_lib.full_path())\nendif\nif get_option('default_library') == 'static'\n  static_name = fs.name(jsoncpp_lib.full_path())\nendif\nif get_option('default_library') == 'both'\n  shared_name = fs.name(jsoncpp_lib.get_shared_lib().full_path())\n  static_name = fs.name(jsoncpp_lib.get_static_lib().full_path())\nendif\n\nif get_option('default_library') == 'shared' or get_option('default_library') == 'both'\n   cmakeconf.set('MESON_SHARED_TARGET', '''\nadd_library(jsoncpp_lib IMPORTED SHARED)\nset_target_properties(jsoncpp_lib PROPERTIES\n  IMPORTED_LOCATION \"''' + join_paths('${PACKAGE_PREFIX_DIR}', get_option('libdir'), shared_name) + '''\"\n  INTERFACE_INCLUDE_DIRECTORIES \"''' + join_paths('${PACKAGE_PREFIX_DIR}', get_option('includedir')) + '\")')\nendif\nif get_option('default_library') == 'static' or get_option('default_library') == 'both'\n   cmakeconf.set('MESON_STATIC_TARGET', '''\nadd_library(jsoncpp_static IMPORTED STATIC)\nset_target_properties(jsoncpp_static PROPERTIES\n  IMPORTED_LOCATION \"''' + join_paths('${PACKAGE_PREFIX_DIR}', get_option('libdir'), static_name) + '''\"\n  INTERFACE_INCLUDE_DIRECTORIES \"''' + join_paths('${PACKAGE_PREFIX_DIR}', get_option('includedir')) + '\")')\nendif\n\nimport('cmake').configure_package_config_file(\n  name: 'jsoncpp',\n  input: 'jsoncppConfig.cmake.meson.in',\n  configuration: cmakeconf)\ninstall_data('jsoncpp-namespaced-targets.cmake', install_dir : join_paths(get_option('libdir'), 'cmake', jsoncpp_lib.name()))\n\n# for libraries bundling jsoncpp\njsoncpp_dep = declare_dependency(\n  include_directories : jsoncpp_include_directories,\n  link_with : jsoncpp_lib,\n  version : meson.project_version())\n\n# tests\nif meson.is_subproject() or not get_option('tests')\n  subdir_done()\nendif\n\npython = find_program('python3')\n\njsoncpp_test = executable(\n  'jsoncpp_test', files([\n    'src/test_lib_json/jsontest.cpp',\n    'src/test_lib_json/main.cpp',\n    'src/test_lib_json/fuzz.cpp',\n  ]),\n  include_directories : jsoncpp_include_directories,\n  link_with : jsoncpp_lib,\n  install : false,\n  cpp_args: dll_import_flag)\ntest(\n  'unittest_jsoncpp_test',\n  jsoncpp_test)\n\njsontestrunner = executable(\n  'jsontestrunner',\n  'src/jsontestrunner/main.cpp',\n  include_directories : jsoncpp_include_directories,\n  link_with : jsoncpp_lib,\n  install : false,\n  cpp_args: dll_import_flag)\ntest(\n  'unittest_jsontestrunner',\n  python,\n  args : [\n    '-B',\n    join_paths(meson.current_source_dir(), 'test/runjsontests.py'),\n    jsontestrunner,\n    join_paths(meson.current_source_dir(), 'test/data')],\n  )\ntest(\n  'jsonchecker_jsontestrunner',\n  python,\n  is_parallel : false,\n  args : [\n    '-B',\n    join_paths(meson.current_source_dir(), 'test/runjsontests.py'),\n    '--with-json-checker',\n    jsontestrunner,\n    join_paths(meson.current_source_dir(), 'test/data')],\n    workdir : join_paths(meson.current_source_dir(), 'test/data'),\n  )\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 0.09375,
          "content": "option(\n  'tests',\n  type : 'boolean',\n  value : true,\n  description : 'Enable building tests')\n"
        },
        {
          "name": "pkg-config",
          "type": "tree",
          "content": null
        },
        {
          "name": "reformat.sh",
          "type": "blob",
          "size": 0.0615234375,
          "content": "find src -name '*.cpp' -or -name '*.h' | xargs clang-format -i\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.in",
          "type": "blob",
          "size": 0.017578125,
          "content": "@JSONCPP_VERSION@\n"
        }
      ]
    }
  ]
}