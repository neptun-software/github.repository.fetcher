{
  "metadata": {
    "timestamp": 1736566107975,
    "page": 105,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wangyu-/udp2raw",
      "stars": 7452,
      "defaultBranch": "unified",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0693359375,
          "content": "SortIncludes: false\nBasedOnStyle: Google\nColumnLimit: 0\nIndentWidth: 4\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.03515625,
          "content": "lib/aes_acc/asm/* linguist-vendored\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.96875,
          "content": "#note: experimental\n#      currently only used for generating `compile_commands.json` for clangd.\n#      to build this project, it's suggested to use `makefile` instead\n\ncmake_minimum_required(VERSION 3.7)\nproject(udp2raw)\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\nset(CMAKE_CXX_STANDARD 11)\n\nset(SOURCE_FILES\n        main.cpp \n        lib/md5.cpp\n        lib/pbkdf2-sha1.cpp\n        lib/pbkdf2-sha256.cpp\n        encrypt.cpp\n        log.cpp\n        network.cpp\n        common.cpp\n        connection.cpp\n        misc.cpp\n        fd_manager.cpp\n        client.cpp\n        server.cpp\n        lib/aes_faster_c/aes.cpp\n        lib/aes_faster_c/wrapper.cpp\n        my_ev.cpp\n)\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -Wno-unused-variable -Wno-unused-parameter -Wno-missing-field-initializers -O2 -g -fsanitize=address,undefined\")\n\nadd_executable(udp2raw ${SOURCE_FILES})\ntarget_link_libraries(udp2raw rt)\ntarget_link_libraries(udp2raw pthread)\ninclude_directories(SYSTEM \"libev\")\ninclude_directories(\".\")\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 0.013671875,
          "content": "English Only.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0625,
          "content": "MIT License\n\nCopyright (c) 2017 Yu Wang (wangyucn at gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.55859375,
          "content": "# Udp2raw-tunnel\n\n\nA Tunnel which turns UDP Traffic into Encrypted FakeTCP/UDP/ICMP Traffic by using Raw Socket, helps you Bypass UDP FireWalls(or Unstable UDP Environment).\n\nWhen used alone,udp2raw tunnels only UDP traffic. Nevertheless,if you used udp2raw + any UDP-based VPN together,you can tunnel any traffic(include TCP/UDP/ICMP),currently OpenVPN/L2TP/ShadowVPN and [tinyfecVPN](https://github.com/wangyu-/tinyfecVPN) are confirmed to be supported.\n\n\n![image0](images/image0.PNG)\n\nor\n\n![image_vpn](images/udp2rawopenvpn.PNG)\n\n[udp2raw wiki](https://github.com/wangyu-/udp2raw-tunnel/wiki)\n\n[简体中文](/doc/README.zh-cn.md)\n\n\n# Support Platforms\nLinux host (including desktop Linux,Android phone/tablet,OpenWRT router,or Raspberry PI) with root account or cap_net_raw capability.\n\nFor Windows and MacOS users, use the udp2raw in [this repo](https://github.com/wangyu-/udp2raw-multiplatform).\n\n# Features\n### Send/Receive UDP Packets with ICMP/FakeTCP/UDP headers\nICMP/FakeTCP headers help you bypass UDP blocking, UDP QOS or improper UDP NAT behavior on some ISPs. In ICMP header mode,udp2raw works like an ICMP tunnel.\n\nUDP headers are also supported. In UDP header mode, it behaves just like a normal UDP tunnel, and you can just make use of the other features (such as encryption, anti-replay, or connection stabilization).\n\n### Simulated TCP with Real-time/Out-of-Order Delivery\nIn FakeTCP header mode,udp2raw simulates 3-way handshake while establishing a connection,simulates seq and ack_seq while data transferring. It also simulates a few TCP options such as: `MSS`, `sackOk`, `TS`, `TS_ack`, `wscale`. Firewalls will regard FakeTCP as a TCP connection, but its essentially UDP: it supports real-time/out-of-order delivery(just as normal UDP does), no congestion control or re-transmission. So there wont be any TCP over TCP problem when using OpenVPN.\n\n### Encryption, Anti-Replay\n* Encrypt your traffic with AES-128-CBC.\n* Protect data integrity by HMAC-SHA1 (or weaker MD5/CRC32).\n* Defense replay attack with anti-replay window.\n\n[Notes on encryption](https://github.com/wangyu-/udp2raw-tunnel/wiki/Notes-on-encryption)\n\n### Failure Dectection & Stabilization (Connection Recovery)\nConection failures are detected by heartbeats. If timed-out, client will automatically change port number and reconnect. If reconnection is successful, the previous connection will be recovered, and all existing UDP conversations will stay vaild.\n\nFor example, if you use udp2raw + OpenVPN, OpenVPN won't lose connection after any reconnect, **even if network cable is re-plugged or WiFi access point is changed**.\n\n### Other Features\n* **Multiplexing** One client can handle multiple UDP connections, all of which share the same raw connection.\n\n* **Multiple Clients** One server can have multiple clients.\n\n* **NAT Support** All of the 3 modes work in NAT environments.\n\n* **OpenVZ Support** Tested on BandwagonHost VPS.\n\n* **Easy to Build** No dependencies.To cross-compile udp2raw,all you need to do is just to download a toolchain,modify makefile to point at the toolchain,run `make cross` then everything is done.(Note:Pre-compiled binaries for Desktop,RaspberryPi,Android,some Openwrt Routers are already included in [Releases](https://github.com/wangyu-/udp2raw-tunnel/releases))\n\n### Keywords\n`Bypass UDP QoS` `Bypass UDP Blocking` `Bypass OpenVPN TCP over TCP problem` `OpenVPN over ICMP` `UDP to ICMP tunnel` `UDP to TCP tunnel` `UDP over ICMP` `UDP over TCP`\n\n# Getting Started\n### Installing\nDownload binary release from https://github.com/wangyu-/udp2raw-tunnel/releases\n\n### Running\nAssume your UDP is blocked or being QOS-ed or just poorly supported. Assume your server ip is 44.55.66.77, you have a service listening on udp port 7777.\n\n```bash\n# Run at server side:\n./udp2raw_amd64 -s -l0.0.0.0:4096 -r 127.0.0.1:7777    -k \"passwd\" --raw-mode faketcp -a\n\n# Run at client side\n./udp2raw_amd64 -c -l0.0.0.0:3333  -r44.55.66.77:4096  -k \"passwd\" --raw-mode faketcp -a\n```\n(The above commands need to be run as root. For better security, with some extra steps, you can run udp2raw as non-root. Check [this link](https://github.com/wangyu-/udp2raw-tunnel/wiki/run-udp2raw-as-non-root) for more info  )\n\n###### Server Output:\n![](images/output_server.PNG)\n###### Client Output:\n![](images/output_client.PNG)\n\nNow,an encrypted raw tunnel has been established between client and server through TCP port 4096. Connecting to UDP port 3333 at the client side is equivalent to connecting to port 7777 at the server side. No UDP traffic will be exposed.\n\n### Note\nTo run on Android, check [Android_Guide](https://github.com/wangyu-/udp2raw/wiki/Android-Guide)\n\n`-a` option automatically adds an iptables rule (or a few iptables rules) for you, udp2raw relies on this iptables rule to work stably. Be aware you dont forget `-a` (its a common mistake). If you dont want udp2raw to add iptables rule automatically, you can add it manually(take a look at `-g` option) and omit `-a`.\n\n\n# Advanced Topic\n### Usage\n```\nudp2raw-tunnel\ngit version:6e1df4b39f    build date:Oct 24 2017 09:21:15\nrepository: https://github.com/wangyu-/udp2raw-tunnel\n\nusage:\n    run as client : ./this_program -c -l local_listen_ip:local_port -r server_address:server_port  [options]\n    run as server : ./this_program -s -l server_listen_ip:server_port -r remote_address:remote_port  [options]\n\ncommon options,these options must be same on both side:\n    --raw-mode            <string>        avaliable values:faketcp(default),udp,icmp\n    -k,--key              <string>        password to gen symetric key,default:\"secret key\"\n    --cipher-mode         <string>        avaliable values:aes128cbc(default),xor,none\n    --auth-mode           <string>        avaliable values:hmac_sha1,md5(default),crc32,simple,none\n    -a,--auto-rule                        auto add (and delete) iptables rule\n    -g,--gen-rule                         generate iptables rule then exit,so that you can copy and\n                                          add it manually.overrides -a\n    --disable-anti-replay                 disable anti-replay,not suggested\nclient options:\n    --source-ip           <ip>            force source-ip for raw socket\n    --source-port         <port>          force source-port for raw socket,tcp/udp only\n                                          this option disables port changing while re-connecting\nother options:\n    --conf-file           <string>        read options from a configuration file instead of command line.\n                                          check example.conf in repo for format\n    --fifo                <string>        use a fifo(named pipe) for sending commands to the running program,\n                                          check readme.md in repository for supported commands.\n    --log-level           <number>        0:never    1:fatal   2:error   3:warn\n                                          4:info (default)     5:debug   6:trace\n    --log-position                        enable file name,function name,line number in log\n    --disable-color                       disable log color\n    --disable-bpf                         disable the kernel space filter,most time its not necessary\n                                          unless you suspect there is a bug\n    --sock-buf            <number>        buf size for socket,>=10 and <=10240,unit:kbyte,default:1024\n    --force-sock-buf                      bypass system limitation while setting sock-buf\n    --seq-mode            <number>        seq increase mode for faketcp:\n                                          0:static header,do not increase seq and ack_seq\n                                          1:increase seq for every packet,simply ack last seq\n                                          2:increase seq randomly, about every 3 packets,simply ack last seq\n                                          3:simulate an almost real seq/ack procedure(default)\n                                          4:similiar to 3,but do not consider TCP Option Window_Scale,\n                                          maybe useful when firewall doesnt support TCP Option\n    --lower-level         <string>        send packets at OSI level 2, format:'if_name#dest_mac_adress'\n                                          ie:'eth0#00:23:45:67:89:b9'.or try '--lower-level auto' to obtain\n                                          the parameter automatically,specify it manually if 'auto' failed\n    --gen-add                             generate iptables rule and add it permanently,then exit.overrides -g\n    --keep-rule                           monitor iptables and auto re-add if necessary.implys -a\n    --clear                               clear any iptables rules added by this program.overrides everything\n    -h,--help                             print this help message\n\n```\n\n### Iptables rules,`-a` and `-g`\nThis program sends packets via raw socket. In FakeTCP mode, Linux kernel TCP packet processing has to be blocked by a iptables rule on both sides, otherwise the kernel will automatically send RST for an unrecongized TCP packet and you will sustain from stability / peformance problems. You can use `-a` option to let the program automatically add / delete iptables rule on start / exit. You can also use the `-g` option to generate iptables rule and add it manually.\n\n### `--cipher-mode` and `--auth-mode`\nIt is suggested to use `aes128cbc` + `hmac_sha1` to obtain maximum security. If you want to run the program on a router, you can try `xor` + `simple`, which can fool packet inspection by firewalls the most of time, but it cannot protect you from serious attacks. Mode none is only for debugging purpose. It is not recommended to set the cipher-mode or auth-mode to none.\n\n### `--seq-mode`\nThe FakeTCP mode does not behave 100% like a real tcp connection. ISPs may be able to distinguish the simulated tcp traffic from the real TCP traffic (though it's costly). seq-mode can help you change the seq increase behavior slightly. If you experience connection problems, try to change the value.\n\n### `--lower-level`\n`--lower-level` allows you to send packet at OSI level 2(link level),so that you can bypass any local iptables rules. If you have a complicated iptables rules which conflicts with udp2raw and you cant(or too lazy to) edit the iptables rules,`--lower-level` can be very useful. Try `--lower-level auto` to auto detect the parameters,you can specify it manually if `auto` fails.\n\nManual format `if_name#dest_mac_adress`,ie:`eth0#00:23:45:67:89:b9`.\n\n### `--keep-rule`\nMonitor iptables and auto re-add iptables rules(for blocking kernel tcp processing) if necessary.Especially useful when iptables rules may be cleared by other programs(for example,if you are using openwrt,everytime you changed and commited a setting,iptables rule may be cleared and re-constructed).\n\n### `--conf-file`\n\nYou can also load options from a configuration file in order to keep secrets away from `ps` command.\n\nFor example, rewrite the options for the above `server` example (in Getting Started section) into configuration file:\n\n`server.conf`\n\n```\n-s\n# You can add comments like this\n# Comments MUST occupy an entire line\n# Or they will not work as expected\n# Listen address\n-l 0.0.0.0:4096\n# Remote address\n-r 127.0.0.1:7777\n-a\n-k passwd\n--raw-mode faketcp\n```\n\nPay attention to the `-k` parameter: In command line mode the quotes around the password will be removed by shell. In configuration files we do not remove quotes.\n\nThen start the server with\n\n```bash\n./udp2raw_amd64 --conf-file server.conf\n```\n\n### `--fifo`\nUse a fifo(named pipe) for sending commands to the running program. For example `--fifo fifo.file`.\n\nAt client side,you can use `echo reconnect >fifo.file` to force client to reconnect.Currently no command has been implemented for server.\n\n# Peformance Test\n#### Test method:\niperf3 TCP via OpenVPN + udp2raw\n(iperf3 UDP mode is not used because of a bug mentioned in this issue: https://github.com/esnet/iperf/issues/296 . Instead, we package the TCP traffic into UDP by OpenVPN to test the performance. Read [Application](https://github.com/wangyu-/udp2raw-tunnel#application) for details.\n\n#### iperf3 command:\n```\niperf3 -c 10.222.2.1 -P40\niperf3 -c 10.222.2.1 -P40 -R\n```\n#### Environments\n* **Client** Vultr $2.5/monthly plan (single core 2.4GHz cpu, 512MB RAM, Tokyo, Japan)\n* **Server** BandwagonHost $3.99/annually plan (single core 2.0GHz cpu, 128MB RAM, Los Angeles, USA)\n\n### Test1\nraw_mode: faketcp  cipher_mode: xor  auth_mode: simple\n\n![image4](images/image4.PNG)\n\n(reverse speed was simliar and not uploaded)\n\n### Test2\nraw_mode: faketcp  cipher_mode: aes128cbc  auth_mode: md5\n\n![image5](images/image5.PNG)\n\n(reverse speed was simliar and not uploaded)\n\n# wiki\n\nCheck wiki for more info:\n\nhttps://github.com/wangyu-/udp2raw-tunnel/wiki\n"
        },
        {
          "name": "client.cpp",
          "type": "blob",
          "size": 33.9697265625,
          "content": "#include \"common.h\"\n#include \"network.h\"\n#include \"connection.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"lib/md5.h\"\n#include \"encrypt.h\"\n#include \"fd_manager.h\"\n\n#ifdef UDP2RAW_MP\nu32_t detect_interval = 1500;\nu64_t laste_detect_time = 0;\n\nint use_udp_for_detection = 0;\nint use_tcp_for_detection = 1;\n\nextern pcap_t *pcap_handle;\n\nextern int pcap_captured_full_len;\n#endif\n\nint client_on_timer(conn_info_t &conn_info)  // for client. called when a timer is ready in epoll\n{\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n    raw_info_t &raw_info = conn_info.raw_info;\n    conn_info.blob->conv_manager.c.clear_inactive();\n    mylog(log_trace, \"timer!\\n\");\n\n    mylog(log_trace, \"roller my %d,oppsite %d,%lld\\n\", int(conn_info.my_roller), int(conn_info.oppsite_roller), conn_info.last_oppsite_roller_time);\n\n    mylog(log_trace, \"<client_on_timer,send_info.ts_ack= %u>\\n\", send_info.ts_ack);\n\n#ifdef UDP2RAW_MP\n    // mylog(log_debug,\"pcap cnt :%d\\n\",pcap_cnt);\n    if (send_with_pcap && !pcap_header_captured) {\n        if (get_current_time() - laste_detect_time > detect_interval) {\n            laste_detect_time = get_current_time();\n        } else {\n            return 0;\n        }\n        /*\n                        struct sockaddr_in remote_addr_in={0};\n\n                        socklen_t slen = sizeof(sockaddr_in);\n                        int port=get_true_random_number()%65534+1;\n                        remote_addr_in.sin_family = AF_INET;\n                        remote_addr_in.sin_port = htons(port);\n                        remote_addr_in.sin_addr.s_addr = remote_ip_uint32;*/\n        int port = get_true_random_number() % 65534 + 1;\n        address_t tmp_addr = remote_addr;\n        tmp_addr.set_port(port);\n\n        if (use_udp_for_detection) {\n            int new_udp_fd = socket(tmp_addr.get_type(), SOCK_DGRAM, IPPROTO_UDP);\n            if (new_udp_fd < 0) {\n                mylog(log_warn, \"create new_udp_fd error\\n\");\n                return -1;\n            }\n            setnonblocking(new_udp_fd);\n            u64_t tmp = get_true_random_number();\n\n            int ret = sendto(new_udp_fd, (char *)(&tmp), sizeof(tmp), 0, (struct sockaddr *)&tmp_addr.inner, tmp_addr.get_len());\n            if (ret == -1) {\n                mylog(log_warn, \"sendto() failed\\n\");\n            }\n            sock_close(new_udp_fd);\n        }\n\n        if (use_tcp_for_detection) {\n            static int last_tcp_fd = -1;\n\n            int new_tcp_fd = socket(tmp_addr.get_type(), SOCK_STREAM, IPPROTO_TCP);\n            if (new_tcp_fd < 0) {\n                mylog(log_warn, \"create new_tcp_fd error\\n\");\n                return -1;\n            }\n            setnonblocking(new_tcp_fd);\n            connect(new_tcp_fd, (struct sockaddr *)&tmp_addr.inner, tmp_addr.get_len());\n            if (last_tcp_fd != -1)\n                sock_close(last_tcp_fd);\n            last_tcp_fd = new_tcp_fd;\n            // close(new_tcp_fd);\n        }\n\n        mylog(log_info, \"waiting for a use-able packet to be captured\\n\");\n\n        return 0;\n    }\n#endif\n    if (raw_info.disabled) {\n        conn_info.state.client_current_state = client_idle;\n        conn_info.my_id = get_true_random_number_nz();\n\n        mylog(log_info, \"state back to client_idle\\n\");\n    }\n\n    if (conn_info.state.client_current_state == client_idle) {\n        raw_info.rst_received = 0;\n        raw_info.disabled = 0;\n\n        fail_time_counter++;\n        if (max_fail_time > 0 && fail_time_counter > max_fail_time) {\n            mylog(log_fatal, \"max_fail_time exceed\\n\");\n            myexit(-1);\n        }\n\n        conn_info.blob->anti_replay.re_init();\n        conn_info.my_id = get_true_random_number_nz();  /// todo no need to do this everytime\n\n        address_t tmp_addr;\n        // u32_t new_ip=0;\n        if (!force_source_ip) {\n            if (get_src_adress2(tmp_addr, remote_addr) != 0) {\n                mylog(log_warn, \"get_src_adress() failed\\n\");\n                return -1;\n            }\n            // source_addr=new_addr;\n            // source_addr.set_port(0);\n\n            mylog(log_info, \"source_addr is now %s\\n\", tmp_addr.get_ip());\n\n            /*\n            if(new_ip!=source_ip_uint32)\n            {\n                    mylog(log_info,\"source ip changed from %s to \",my_ntoa(source_ip_uint32));\n                    log_bare(log_info,\"%s\\n\",my_ntoa(new_ip));\n                    source_ip_uint32=new_ip;\n                    send_info.src_ip=new_ip;\n            }*/\n\n        } else {\n            tmp_addr = source_addr;\n        }\n\n        send_info.new_src_ip.from_address_t(tmp_addr);\n\n        if (force_source_port == 0) {\n            send_info.src_port = client_bind_to_a_new_port2(bind_fd, tmp_addr);\n        } else {\n            send_info.src_port = source_port;\n        }\n\n        if (raw_mode == mode_icmp) {\n            send_info.dst_port = send_info.src_port;\n        }\n\n        mylog(log_info, \"using port %d\\n\", send_info.src_port);\n        init_filter(send_info.src_port);\n\n        if (raw_mode == mode_icmp || raw_mode == mode_udp) {\n            conn_info.state.client_current_state = client_handshake1;\n\n            mylog(log_info, \"state changed from client_idle to client_pre_handshake\\n\");\n        }\n        if (raw_mode == mode_faketcp) {\n            if (use_tcp_dummy_socket) {\n                setnonblocking(bind_fd);\n                int ret = connect(bind_fd, (struct sockaddr *)&remote_addr.inner, remote_addr.get_len());\n                mylog(log_debug, \"ret=%d,errno=%s, %d %s\\n\", ret, get_sock_error(), bind_fd, remote_addr.get_str());\n                // mylog(log_info,\"ret=%d,errno=,%d %s\\n\",ret,bind_fd,remote_addr.get_str());\n                conn_info.state.client_current_state = client_tcp_handshake_dummy;\n                mylog(log_info, \"state changed from client_idle to client_tcp_handshake_dummy\\n\");\n            } else {\n                conn_info.state.client_current_state = client_tcp_handshake;\n                mylog(log_info, \"state changed from client_idle to client_tcp_handshake\\n\");\n            }\n        }\n        conn_info.last_state_time = get_current_time();\n        conn_info.last_hb_sent_time = 0;\n        // dont return;\n    }\n    if (conn_info.state.client_current_state == client_tcp_handshake)  // send and resend syn\n    {\n        assert(raw_mode == mode_faketcp);\n        if (get_current_time() - conn_info.last_state_time > client_handshake_timeout) {\n            conn_info.state.client_current_state = client_idle;\n            mylog(log_info, \"state back to client_idle from client_tcp_handshake\\n\");\n            return 0;\n\n        } else if (get_current_time() - conn_info.last_hb_sent_time > client_retry_interval) {\n            if (raw_mode == mode_faketcp) {\n                if (conn_info.last_hb_sent_time == 0) {\n                    send_info.psh = 0;\n                    send_info.syn = 1;\n                    send_info.ack = 0;\n                    send_info.ts_ack = 0;\n                    send_info.seq = get_true_random_number();\n                    send_info.ack_seq = get_true_random_number();\n                }\n            }\n\n            send_raw0(raw_info, 0, 0);\n\n            conn_info.last_hb_sent_time = get_current_time();\n            mylog(log_info, \"(re)sent tcp syn\\n\");\n            return 0;\n        } else {\n            return 0;\n        }\n        return 0;\n    } else if (conn_info.state.client_current_state == client_tcp_handshake_dummy) {\n        assert(raw_mode == mode_faketcp);\n        if (get_current_time() - conn_info.last_state_time > client_handshake_timeout) {\n            conn_info.state.client_current_state = client_idle;\n            mylog(log_info, \"state back to client_idle from client_tcp_handshake_dummy\\n\");\n            return 0;\n        }\n    } else if (conn_info.state.client_current_state == client_handshake1)  // send and resend handshake1\n    {\n        if (get_current_time() - conn_info.last_state_time > client_handshake_timeout) {\n            conn_info.state.client_current_state = client_idle;\n            mylog(log_info, \"state back to client_idle from client_handshake1\\n\");\n            return 0;\n\n        } else if (get_current_time() - conn_info.last_hb_sent_time > client_retry_interval) {\n            if (raw_mode == mode_faketcp) {\n                if (conn_info.last_hb_sent_time == 0) {\n                    send_info.seq++;\n                    send_info.ack_seq = recv_info.seq + 1;\n                    send_info.ts_ack = recv_info.ts;\n                    raw_info.reserved_send_seq = send_info.seq;\n                }\n                send_info.seq = raw_info.reserved_send_seq;\n                send_info.psh = 0;\n                send_info.syn = 0;\n                send_info.ack = 1;\n\n                if (!use_tcp_dummy_socket)\n                    send_raw0(raw_info, 0, 0);\n\n                send_handshake(raw_info, conn_info.my_id, 0, const_id);\n\n                send_info.seq += raw_info.send_info.data_len;\n            } else {\n                send_handshake(raw_info, conn_info.my_id, 0, const_id);\n                if (raw_mode == mode_icmp)\n                    send_info.my_icmp_seq++;\n            }\n\n            conn_info.last_hb_sent_time = get_current_time();\n            mylog(log_info, \"(re)sent handshake1\\n\");\n            return 0;\n        } else {\n            return 0;\n        }\n        return 0;\n    } else if (conn_info.state.client_current_state == client_handshake2) {\n        if (get_current_time() - conn_info.last_state_time > client_handshake_timeout) {\n            conn_info.state.client_current_state = client_idle;\n            mylog(log_info, \"state back to client_idle from client_handshake2\\n\");\n            return 0;\n        } else if (get_current_time() - conn_info.last_hb_sent_time > client_retry_interval) {\n            if (raw_mode == mode_faketcp) {\n                if (conn_info.last_hb_sent_time == 0) {\n                    send_info.ack_seq = recv_info.seq + raw_info.recv_info.data_len;\n                    send_info.ts_ack = recv_info.ts;\n                    raw_info.reserved_send_seq = send_info.seq;\n                }\n                send_info.seq = raw_info.reserved_send_seq;\n                send_handshake(raw_info, conn_info.my_id, conn_info.oppsite_id, const_id);\n                send_info.seq += raw_info.send_info.data_len;\n\n            } else {\n                send_handshake(raw_info, conn_info.my_id, conn_info.oppsite_id, const_id);\n                if (raw_mode == mode_icmp)\n                    send_info.my_icmp_seq++;\n            }\n            conn_info.last_hb_sent_time = get_current_time();\n            mylog(log_info, \"(re)sent handshake2\\n\");\n            return 0;\n\n        } else {\n            return 0;\n        }\n        return 0;\n    } else if (conn_info.state.client_current_state == client_ready) {\n        fail_time_counter = 0;\n        mylog(log_trace, \"time %llu,%llu\\n\", get_current_time(), conn_info.last_state_time);\n\n        if (get_current_time() - conn_info.last_hb_recv_time > client_conn_timeout) {\n            conn_info.state.client_current_state = client_idle;\n            conn_info.my_id = get_true_random_number_nz();\n            mylog(log_info, \"state back to client_idle from  client_ready bc of server-->client direction timeout\\n\");\n            return 0;\n        }\n\n        if (get_current_time() - conn_info.last_oppsite_roller_time > client_conn_uplink_timeout) {\n            conn_info.state.client_current_state = client_idle;\n            conn_info.my_id = get_true_random_number_nz();\n            mylog(log_info, \"state back to client_idle from  client_ready bc of client-->server direction timeout\\n\");\n        }\n\n        if (get_current_time() - conn_info.last_hb_sent_time < heartbeat_interval) {\n            return 0;\n        }\n\n        mylog(log_debug, \"heartbeat sent <%x,%x>\\n\", conn_info.oppsite_id, conn_info.my_id);\n\n        if (hb_mode == 0)\n            send_safer(conn_info, 'h', hb_buf, 0);  /////////////send\n        else\n            send_safer(conn_info, 'h', hb_buf, hb_len);\n        conn_info.last_hb_sent_time = get_current_time();\n        return 0;\n    } else {\n        mylog(log_fatal, \"unknown state,this shouldnt happen.\\n\");\n        myexit(-1);\n    }\n    return 0;\n}\nint client_on_raw_recv_hs2_or_ready(conn_info_t &conn_info, char type, char *data, int data_len) {\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n    if (!recv_info.new_src_ip.equal(send_info.new_dst_ip) || recv_info.src_port != send_info.dst_port) {\n        mylog(log_warn, \"unexpected adress %s %s %d %d,this shouldnt happen.\\n\", recv_info.new_src_ip.get_str1(), send_info.new_dst_ip.get_str2(), recv_info.src_port, send_info.dst_port);\n        return -1;\n    }\n\n    if (conn_info.state.client_current_state == client_handshake2) {\n        mylog(log_info, \"changed state from to client_handshake2 to client_ready\\n\");\n        conn_info.state.client_current_state = client_ready;\n        conn_info.last_hb_sent_time = 0;\n        conn_info.last_hb_recv_time = get_current_time();\n        conn_info.last_oppsite_roller_time = conn_info.last_hb_recv_time;\n        client_on_timer(conn_info);\n    }\n    if (data_len >= 0 && type == 'h') {\n        mylog(log_debug, \"[hb]heart beat received,oppsite_roller=%d\\n\", int(conn_info.oppsite_roller));\n        conn_info.last_hb_recv_time = get_current_time();\n        return 0;\n    } else if (data_len >= int(sizeof(u32_t)) && type == 'd') {\n        mylog(log_trace, \"received a data from fake tcp,len:%d\\n\", data_len);\n\n        if (hb_mode == 0)\n            conn_info.last_hb_recv_time = get_current_time();\n\n        u32_t tmp_conv_id;\n        memcpy(&tmp_conv_id, &data[0], sizeof(tmp_conv_id));\n        tmp_conv_id = ntohl(tmp_conv_id);\n\n        if (!conn_info.blob->conv_manager.c.is_conv_used(tmp_conv_id)) {\n            mylog(log_info, \"unknow conv %d,ignore\\n\", tmp_conv_id);\n            return 0;\n        }\n\n        conn_info.blob->conv_manager.c.update_active_time(tmp_conv_id);\n\n        // u64_t u64=conn_info.blob->conv_manager.c.find_data_by_conv(tmp_conv_id);\n        address_t tmp_addr = conn_info.blob->conv_manager.c.find_data_by_conv(tmp_conv_id);\n\n        // sockaddr_in tmp_sockaddr={0};\n\n        // tmp_sockaddr.sin_family = AF_INET;\n        // tmp_sockaddr.sin_addr.s_addr=(u64>>32u);\n\n        // tmp_sockaddr.sin_port= htons(uint16_t((u64<<32u)>>32u));\n\n        int ret = sendto(udp_fd, data + sizeof(u32_t), data_len - (sizeof(u32_t)), 0, (struct sockaddr *)&tmp_addr.inner, tmp_addr.get_len());\n\n        if (ret < 0) {\n            mylog(log_warn, \"sento returned %d,%s,%02x,%s\\n\", ret, get_sock_error(), int(tmp_addr.get_type()), tmp_addr.get_str());\n            // perror(\"ret<0\");\n        }\n    } else {\n        mylog(log_warn, \"unknown packet,this shouldnt happen.\\n\");\n        return -1;\n    }\n    return 0;\n}\nint client_on_raw_recv(conn_info_t &conn_info)  // called when raw fd received a packet.\n{\n    char *data;\n    int data_len;\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n    raw_info_t &raw_info = conn_info.raw_info;\n\n    mylog(log_trace, \"<client_on_raw_recv,send_info.ts_ack= %u>\\n\", send_info.ts_ack);\n\n#ifdef UDP2RAW_LINUX\n    if (pre_recv_raw_packet() < 0) return -1;\n#endif\n\n    if (conn_info.state.client_current_state == client_idle) {\n        discard_raw_packet();\n        // recv(raw_recv_fd, 0,0, 0  );\n    } else if (conn_info.state.client_current_state == client_tcp_handshake || conn_info.state.client_current_state == client_tcp_handshake_dummy)  // received syn ack\n    {\n        assert(raw_mode == mode_faketcp);\n        if (recv_raw0(raw_info, data, data_len) < 0) {\n            return -1;\n        }\n        if (data_len >= max_data_len + 1) {\n            mylog(log_debug, \"data_len=%d >= max_data_len+1,ignored\", data_len);\n            return -1;\n        }\n        if (!recv_info.new_src_ip.equal(send_info.new_dst_ip) || recv_info.src_port != send_info.dst_port) {\n            mylog(log_debug, \"unexpected adress %s %s %d %d\\n\", recv_info.new_src_ip.get_str1(), send_info.new_dst_ip.get_str2(), recv_info.src_port, send_info.dst_port);\n            return -1;\n        }\n        if (data_len == 0 && raw_info.recv_info.syn == 1 && raw_info.recv_info.ack == 1) {\n            if (conn_info.state.client_current_state == client_tcp_handshake) {\n                if (recv_info.ack_seq != send_info.seq + 1) {\n                    mylog(log_debug, \"seq ack_seq mis match\\n\");\n                    return -1;\n                }\n                mylog(log_info, \"state changed from client_tcp_handshake to client_handshake1\\n\");\n            } else {\n                send_info.seq = recv_info.ack_seq - 1;\n                mylog(log_info, \"state changed from client_tcp_dummy to client_handshake1\\n\");\n                // send_info.ack_seq=recv_info.seq+1;\n            }\n            conn_info.state.client_current_state = client_handshake1;\n\n            conn_info.last_state_time = get_current_time();\n            conn_info.last_hb_sent_time = 0;\n            client_on_timer(conn_info);\n            return 0;\n        } else {\n            mylog(log_debug, \"unexpected packet type,expected:syn ack\\n\");\n            return -1;\n        }\n    } else if (conn_info.state.client_current_state == client_handshake1)  // recevied respond of handshake1\n    {\n        if (recv_bare(raw_info, data, data_len) != 0) {\n            mylog(log_debug, \"recv_bare failed!\\n\");\n            return -1;\n        }\n        if (!recv_info.new_src_ip.equal(send_info.new_dst_ip) || recv_info.src_port != send_info.dst_port) {\n            mylog(log_debug, \"unexpected adress %s %s %d %d\\n\", recv_info.new_src_ip.get_str1(), send_info.new_dst_ip.get_str2(), recv_info.src_port, send_info.dst_port);\n            return -1;\n        }\n        if (data_len < int(3 * sizeof(my_id_t))) {\n            mylog(log_debug, \"too short to be a handshake\\n\");\n            return -1;\n        }\n        my_id_t tmp_oppsite_id;\n        memcpy(&tmp_oppsite_id, &data[0], sizeof(tmp_oppsite_id));\n        tmp_oppsite_id = ntohl(tmp_oppsite_id);\n\n        my_id_t tmp_my_id;\n        memcpy(&tmp_my_id, &data[sizeof(my_id_t)], sizeof(tmp_my_id));\n        tmp_my_id = ntohl(tmp_my_id);\n\n        my_id_t tmp_oppsite_const_id;\n        memcpy(&tmp_oppsite_const_id, &data[sizeof(my_id_t) * 2], sizeof(tmp_oppsite_const_id));\n        tmp_oppsite_const_id = ntohl(tmp_oppsite_const_id);\n\n        if (tmp_my_id != conn_info.my_id) {\n            mylog(log_debug, \"tmp_my_id doesnt match\\n\");\n            return -1;\n        }\n\n        if (raw_mode == mode_faketcp) {\n            if (recv_info.ack_seq != send_info.seq) {\n                mylog(log_debug, \"seq ack_seq mis match\\n\");\n                return -1;\n            }\n            if (recv_info.seq != send_info.ack_seq) {\n                mylog(log_debug, \"seq ack_seq mis match\\n\");\n                return -1;\n            }\n        }\n        conn_info.oppsite_id = tmp_oppsite_id;\n\n        mylog(log_info, \"changed state from to client_handshake1 to client_handshake2,my_id is %x,oppsite id is %x\\n\", conn_info.my_id, conn_info.oppsite_id);\n\n        conn_info.state.client_current_state = client_handshake2;\n        conn_info.last_state_time = get_current_time();\n        conn_info.last_hb_sent_time = 0;\n        client_on_timer(conn_info);\n\n        return 0;\n    } else if (conn_info.state.client_current_state == client_handshake2 || conn_info.state.client_current_state == client_ready)  // received heartbeat or data\n    {\n        vector<char> type_vec;\n        vector<string> data_vec;\n        recv_safer_multi(conn_info, type_vec, data_vec);\n        if (data_vec.empty()) {\n            mylog(log_debug, \"recv_safer failed!\\n\");\n            return -1;\n        }\n\n        for (int i = 0; i < (int)type_vec.size(); i++) {\n            char type = type_vec[i];\n            char *data = (char *)data_vec[i].c_str();  // be careful, do not append data to it\n            int data_len = data_vec[i].length();\n            client_on_raw_recv_hs2_or_ready(conn_info, type, data, data_len);\n        }\n\n        return 0;\n    } else {\n        mylog(log_fatal, \"unknown state,this shouldnt happen.\\n\");\n        myexit(-1);\n    }\n    return 0;\n}\nint client_on_udp_recv(conn_info_t &conn_info) {\n    int recv_len;\n    char buf[buf_len];\n    address_t::storage_t udp_new_addr_in = {{0}};\n    socklen_t udp_new_addr_len = sizeof(address_t::storage_t);\n    if ((recv_len = recvfrom(udp_fd, buf, max_data_len + 1, 0,\n                             (struct sockaddr *)&udp_new_addr_in, &udp_new_addr_len)) == -1) {\n        mylog(log_debug, \"recv_from error,%s\\n\", get_sock_error());\n        return -1;\n        // myexit(1);\n    };\n\n    if (recv_len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d,dropped\\n\", max_data_len);\n        return -1;\n    }\n\n    if (recv_len >= mtu_warn) {\n        mylog(log_warn, \"huge packet,data len=%d (>=%d).strongly suggested to set a smaller mtu at upper level,to get rid of this warn\\n \", recv_len, mtu_warn);\n    }\n\n    address_t tmp_addr;\n    tmp_addr.from_sockaddr((sockaddr *)&udp_new_addr_in, udp_new_addr_len);\n    u32_t conv;\n\n    if (!conn_info.blob->conv_manager.c.is_data_used(tmp_addr)) {\n        if (conn_info.blob->conv_manager.c.get_size() >= max_conv_num) {\n            mylog(log_warn, \"ignored new udp connect bc max_conv_num exceed\\n\");\n            return -1;\n        }\n        conv = conn_info.blob->conv_manager.c.get_new_conv();\n        conn_info.blob->conv_manager.c.insert_conv(conv, tmp_addr);\n        mylog(log_info, \"new packet from %s,conv_id=%x\\n\", tmp_addr.get_str(), conv);\n    } else {\n        conv = conn_info.blob->conv_manager.c.find_conv_by_data(tmp_addr);\n    }\n\n    conn_info.blob->conv_manager.c.update_active_time(conv);\n\n    if (conn_info.state.client_current_state == client_ready) {\n        send_data_safer(conn_info, buf, recv_len, conv);\n    }\n    return 0;\n}\nvoid udp_accept_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n    client_on_udp_recv(conn_info);\n}\nvoid raw_recv_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    if (is_udp2raw_mp) assert(0 == 1);\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n    client_on_raw_recv(conn_info);\n}\n#ifdef UDP2RAW_MP\nvoid async_cb(struct ev_loop *loop, struct ev_async *watcher, int revents) {\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    if (send_with_pcap && !pcap_header_captured) {\n        int empty = 0;\n        char *p;\n        int len;\n        pthread_mutex_lock(&queue_mutex);\n        empty = my_queue.empty();\n        if (!empty) {\n            my_queue.peek_front(p, len);\n            my_queue.pop_front();\n        }\n        pthread_mutex_unlock(&queue_mutex);\n        if (empty) return;\n\n        pcap_header_captured = 1;\n        assert(pcap_link_header_len != -1);\n        memcpy(pcap_header_buf, p, max_data_len);\n\n        log_bare(log_info, \"link level header captured:\\n\");\n        unsigned char *tmp = (unsigned char *)pcap_header_buf;\n        pcap_captured_full_len = len;\n        for (int i = 0; i < pcap_link_header_len; i++)\n            log_bare(log_info, \"<%x>\", (u32_t)tmp[i]);\n\n        log_bare(log_info, \"\\n\");\n        return;\n    }\n\n    // mylog(log_info,\"async_cb called\\n\");\n    while (1) {\n        int empty = 0;\n        char *p;\n        int len;\n        pthread_mutex_lock(&queue_mutex);\n        empty = my_queue.empty();\n        if (!empty) {\n            my_queue.peek_front(p, len);\n            my_queue.pop_front();\n        }\n        pthread_mutex_unlock(&queue_mutex);\n\n        if (empty) break;\n        if (g_fix_gro == 0 && len > max_data_len) {\n            mylog(log_warn, \"huge packet %d > %d, dropped. maybe you need to turn down mtu at upper level, or maybe you need the --fix-gro option\\n\", len, max_data_len);\n            break;\n        }\n\n        int new_len = len - pcap_link_header_len;\n        memcpy(g_packet_buf, p + pcap_link_header_len, new_len);\n        g_packet_buf_len = new_len;\n        assert(g_packet_buf_cnt == 0);\n        g_packet_buf_cnt++;\n        client_on_raw_recv(conn_info);\n    }\n}\n#endif\nvoid clear_timer_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n    client_on_timer(conn_info);\n}\nvoid fifo_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    char buf[buf_len];\n    int fifo_fd = watcher->fd;\n\n    int len = read(fifo_fd, buf, sizeof(buf));\n    if (len < 0) {\n        mylog(log_warn, \"fifo read failed len=%d,errno=%s\\n\", len, get_sock_error());\n        return;\n    }\n    buf[len] = 0;\n    while (len >= 1 && buf[len - 1] == '\\n')\n        buf[len - 1] = 0;\n    mylog(log_info, \"got data from fifo,len=%d,s=[%s]\\n\", len, buf);\n    if (strcmp(buf, \"reconnect\") == 0) {\n        mylog(log_info, \"received command: reconnect\\n\");\n        conn_info.state.client_current_state = client_idle;\n        conn_info.my_id = get_true_random_number_nz();\n    } else {\n        mylog(log_info, \"unknown command\\n\");\n    }\n}\nint client_event_loop() {\n    char buf[buf_len];\n\n    conn_info_t conn_info;\n    conn_info.my_id = get_true_random_number_nz();\n\n    conn_info.prepare();\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n#ifdef UDP2RAW_LINUX\n    if (lower_level) {\n        if (lower_level_manual) {\n            int index;\n            init_ifindex(if_name, raw_send_fd, index);\n            // init_ifindex(if_name);\n            memset(&send_info.addr_ll, 0, sizeof(send_info.addr_ll));\n            send_info.addr_ll.sll_family = AF_PACKET;\n            send_info.addr_ll.sll_ifindex = index;\n            send_info.addr_ll.sll_halen = ETHER_ADDR_LEN;\n            send_info.addr_ll.sll_protocol = htons(ETH_P_IP);\n            memcpy(&send_info.addr_ll.sll_addr, dest_hw_addr, ETHER_ADDR_LEN);\n            mylog(log_info, \"we are running at lower-level (manual) mode\\n\");\n        } else {\n            u32_t dest_ip;\n            string if_name_string;\n            string hw_string;\n            assert(remote_addr.get_type() == AF_INET);\n\n            if (retry_on_error == 0) {\n                if (find_lower_level_info(remote_addr.inner.ipv4.sin_addr.s_addr, dest_ip, if_name_string, hw_string) != 0) {\n                    mylog(log_fatal, \"auto detect lower-level info failed for %s,specific it manually\\n\", remote_addr.get_ip());\n                    myexit(-1);\n                }\n            } else {\n                int ok = 0;\n                while (!ok) {\n                    if (find_lower_level_info(remote_addr.inner.ipv4.sin_addr.s_addr, dest_ip, if_name_string, hw_string) != 0) {\n                        mylog(log_warn, \"auto detect lower-level info failed for %s,retry in %d seconds\\n\", remote_addr.get_ip(), retry_on_error_interval);\n                        sleep(retry_on_error_interval);\n                    } else {\n                        ok = 1;\n                    }\n                }\n            }\n            mylog(log_info, \"we are running at lower-level (auto) mode,%s %s %s\\n\", my_ntoa(dest_ip), if_name_string.c_str(), hw_string.c_str());\n\n            u32_t hw[6];\n            memset(hw, 0, sizeof(hw));\n            sscanf(hw_string.c_str(), \"%x:%x:%x:%x:%x:%x\", &hw[0], &hw[1], &hw[2],\n                   &hw[3], &hw[4], &hw[5]);\n\n            mylog(log_warn,\n                  \"make sure this is correct:   if_name=<%s>  dest_mac_adress=<%02x:%02x:%02x:%02x:%02x:%02x>  \\n\",\n                  if_name_string.c_str(), hw[0], hw[1], hw[2], hw[3], hw[4], hw[5]);\n            for (int i = 0; i < 6; i++) {\n                dest_hw_addr[i] = uint8_t(hw[i]);\n            }\n\n            // mylog(log_fatal,\"--lower-level auto for client hasnt been implemented\\n\");\n            int index;\n            init_ifindex(if_name_string.c_str(), raw_send_fd, index);\n\n            memset(&send_info.addr_ll, 0, sizeof(send_info.addr_ll));\n            send_info.addr_ll.sll_family = AF_PACKET;\n            send_info.addr_ll.sll_ifindex = index;\n            send_info.addr_ll.sll_halen = ETHER_ADDR_LEN;\n            send_info.addr_ll.sll_protocol = htons(ETH_P_IP);\n            memcpy(&send_info.addr_ll.sll_addr, dest_hw_addr, ETHER_ADDR_LEN);\n            // mylog(log_info,\"we are running at lower-level (manual) mode\\n\");\n        }\n    }\n#endif\n\n#ifdef UDP2RAW_MP\n\n    address_t tmp_addr;\n    if (get_src_adress2(tmp_addr, remote_addr) != 0) {\n        mylog(log_error, \"get_src_adress() failed\\n\");\n        myexit(-1);\n    }\n    if (strcmp(dev, \"\") == 0) {\n        mylog(log_info, \"--dev have not been set, trying to detect automatically, available devices:\\n\");\n\n        mylog(log_info, \"available device(device name: ip address ; description):\\n\");\n\n        char errbuf[PCAP_ERRBUF_SIZE];\n\n        int found = 0;\n\n        pcap_if_t *interfaces, *d;\n        if (pcap_findalldevs(&interfaces, errbuf) == -1) {\n            mylog(log_fatal, \"error in pcap_findalldevs(),%s\\n\", errbuf);\n            myexit(-1);\n        }\n\n        for (pcap_if_t *d = interfaces; d != NULL; d = d->next) {\n            log_bare(log_warn, \"%s:\", d->name);\n            int cnt = 0;\n            for (pcap_addr_t *a = d->addresses; a != NULL; a = a->next) {\n                if (a->addr == NULL) {\n                    log_bare(log_debug, \" [a->addr==NULL]\");\n                    continue;\n                }\n                if (a->addr->sa_family == AF_INET || a->addr->sa_family == AF_INET6) {\n                    cnt++;\n\n                    if (a->addr->sa_family == AF_INET) {\n                        char s[max_addr_len];\n                        inet_ntop(AF_INET, &((struct sockaddr_in *)a->addr)->sin_addr, s, max_addr_len);\n                        log_bare(log_warn, \" [%s]\", s);\n\n                        if (a->addr->sa_family == raw_ip_version) {\n                            if (((struct sockaddr_in *)a->addr)->sin_addr.s_addr == tmp_addr.inner.ipv4.sin_addr.s_addr) {\n                                found++;\n                                strcpy(dev, d->name);\n                            }\n                        }\n                    } else {\n                        assert(a->addr->sa_family == AF_INET6);\n\n                        char s[max_addr_len];\n                        inet_ntop(AF_INET6, &((struct sockaddr_in6 *)a->addr)->sin6_addr, s, max_addr_len);\n                        log_bare(log_warn, \" [%s]\", s);\n\n                        if (a->addr->sa_family == raw_ip_version) {\n                            if (memcmp(&((struct sockaddr_in6 *)a->addr)->sin6_addr, &tmp_addr.inner.ipv6.sin6_addr, sizeof(struct in6_addr)) == 0) {\n                                found++;\n                                strcpy(dev, d->name);\n                            }\n                        }\n                    }\n                } else {\n                    log_bare(log_debug, \" [unknow:%d]\", int(a->addr->sa_family));\n                }\n            }\n            if (cnt == 0) log_bare(log_warn, \" [no ip found]\");\n            if (d->description == 0) {\n                log_bare(log_warn, \"; (no description available)\");\n            } else {\n                log_bare(log_warn, \"; %s\", d->description);\n            }\n            log_bare(log_warn, \"\\n\");\n        }\n\n        if (found == 0) {\n            mylog(log_fatal, \"no matched device found for ip: [%s]\\n\", tmp_addr.get_ip());\n            myexit(-1);\n        } else if (found == 1) {\n            mylog(log_info, \"using device:[%s], ip: [%s]\\n\", dev, tmp_addr.get_ip());\n        } else {\n            mylog(log_fatal, \"more than one devices found for ip: [%s] , you need to use --dev manually\\n\", tmp_addr.get_ip());\n            myexit(-1);\n        }\n    } else {\n        mylog(log_info, \"--dev has been manually set, using device:[%s]\\n\", dev);\n    }\n#endif\n\n    send_info.src_port = 0;\n    memset(&send_info.new_src_ip, 0, sizeof(send_info.new_src_ip));\n\n    int i, j, k;\n    int ret;\n\n    send_info.new_dst_ip.from_address_t(remote_addr);\n    send_info.dst_port = remote_addr.get_port();\n\n    udp_fd = socket(local_addr.get_type(), SOCK_DGRAM, IPPROTO_UDP);\n    set_buf_size(udp_fd, socket_buf_size);\n\n    if (::bind(udp_fd, (struct sockaddr *)&local_addr.inner, local_addr.get_len()) == -1) {\n        mylog(log_fatal, \"socket bind error\\n\");\n        // perror(\"socket bind error\");\n        myexit(1);\n    }\n    setnonblocking(udp_fd);\n\n    // epollfd = epoll_create1(0);\n\n    // const int max_events = 4096;\n    // struct epoll_event ev, events[max_events];\n    // if (epollfd < 0) {\n    //\tmylog(log_fatal,\"epoll return %d\\n\", epollfd);\n    //\tmyexit(-1);\n    // }\n\n    struct ev_loop *loop = ev_default_loop(0);\n    assert(loop != NULL);\n\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = udp_fd;\n    // ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, udp_fd, &ev);\n    // if (ret!=0) {\n    //\tmylog(log_fatal,\"add  udp_listen_fd error\\n\");\n    //\tmyexit(-1);\n    // }\n\n    struct ev_io udp_accept_watcher;\n\n    udp_accept_watcher.data = &conn_info;\n    ev_io_init(&udp_accept_watcher, udp_accept_cb, udp_fd, EV_READ);\n    ev_io_start(loop, &udp_accept_watcher);\n\n    // ev.events = EPOLLIN;\n    // ev.data.u64 = raw_recv_fd;\n\n    // ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, raw_recv_fd, &ev);\n    // if (ret!= 0) {\n    //\tmylog(log_fatal,\"add raw_fd error\\n\");\n    //\tmyexit(-1);\n    // }\n\n#ifdef UDP2RAW_LINUX\n    struct ev_io raw_recv_watcher;\n\n    raw_recv_watcher.data = &conn_info;\n    ev_io_init(&raw_recv_watcher, raw_recv_cb, raw_recv_fd, EV_READ);\n    ev_io_start(loop, &raw_recv_watcher);\n#endif\n\n#ifdef UDP2RAW_MP\n    g_default_loop = loop;\n    async_watcher.data = &conn_info;\n    ev_async_init(&async_watcher, async_cb);\n    ev_async_start(loop, &async_watcher);\n\n    init_raw_socket();  // must be put after dev detection\n#endif\n\n    // set_timer(epollfd,timer_fd);\n    struct ev_timer clear_timer;\n\n    clear_timer.data = &conn_info;\n    ev_timer_init(&clear_timer, clear_timer_cb, 0, timer_interval / 1000.0);\n    ev_timer_start(loop, &clear_timer);\n\n    mylog(log_debug, \"send_raw : from %s %d  to %s %d\\n\", send_info.new_src_ip.get_str1(), send_info.src_port, send_info.new_dst_ip.get_str2(), send_info.dst_port);\n\n    int fifo_fd = -1;\n\n    struct ev_io fifo_watcher;\n    fifo_watcher.data = &conn_info;\n\n    if (fifo_file[0] != 0) {\n        fifo_fd = create_fifo(fifo_file);\n\n        ev_io_init(&fifo_watcher, fifo_cb, fifo_fd, EV_READ);\n        ev_io_start(loop, &fifo_watcher);\n\n        mylog(log_info, \"fifo_file=%s\\n\", fifo_file);\n    }\n\n    ev_run(loop, 0);\n    return 0;\n}\n"
        },
        {
          "name": "common.cpp",
          "type": "blob",
          "size": 29.4873046875,
          "content": "/*\n * comm.cpp\n *\n *  Created on: Jul 29, 2017\n *      Author: wangyu\n */\n\n#include \"common.h\"\n#include \"log.h\"\n#include \"misc.h\"\n\n#include <random>\n#include <cmath>\n\n// static int random_number_fd=-1;\nint force_socket_buf = 0;\n\nint address_t::from_str(char *str) {\n    clear();\n\n    char ip_addr_str[100];\n    u32_t port;\n    mylog(log_info, \"parsing address: %s\\n\", str);\n    int is_ipv6 = 0;\n    if (sscanf(str, \"[%[^]]]:%u\", ip_addr_str, &port) == 2) {\n        mylog(log_info, \"its an ipv6 adress\\n\");\n        inner.ipv6.sin6_family = AF_INET6;\n        is_ipv6 = 1;\n    } else if (sscanf(str, \"%[^:]:%u\", ip_addr_str, &port) == 2) {\n        mylog(log_info, \"its an ipv4 adress\\n\");\n        inner.ipv4.sin_family = AF_INET;\n    } else {\n        mylog(log_error, \"failed to parse\\n\");\n        myexit(-1);\n    }\n\n    mylog(log_info, \"ip_address is {%s}, port is {%u}\\n\", ip_addr_str, port);\n\n    if (port > 65535) {\n        mylog(log_error, \"invalid port: %d\\n\", port);\n        myexit(-1);\n    }\n\n    int ret = -100;\n    if (is_ipv6) {\n        ret = inet_pton(AF_INET6, ip_addr_str, &(inner.ipv6.sin6_addr));\n        inner.ipv6.sin6_port = htons(port);\n        if (ret == 0)  // 0 if address type doesnt match\n        {\n            mylog(log_error, \"ip_addr %s is not an ipv6 address, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        } else if (ret == 1)  // inet_pton returns 1 on success\n        {\n            // okay\n        } else {\n            mylog(log_error, \"ip_addr %s is invalid, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        }\n    } else {\n        ret = inet_pton(AF_INET, ip_addr_str, &(inner.ipv4.sin_addr));\n        inner.ipv4.sin_port = htons(port);\n\n        if (ret == 0) {\n            mylog(log_error, \"ip_addr %s is not an ipv4 address, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        } else if (ret == 1) {\n            // okay\n        } else {\n            mylog(log_error, \"ip_addr %s is invalid, %d\\n\", ip_addr_str, ret);\n            myexit(-1);\n        }\n    }\n\n    return 0;\n}\n\nint address_t::from_str_ip_only(char *str) {\n    clear();\n\n    u32_t type;\n\n    if (strchr(str, ':') == NULL)\n        type = AF_INET;\n    else\n        type = AF_INET6;\n\n    ((sockaddr *)&inner)->sa_family = type;\n\n    int ret;\n    if (type == AF_INET) {\n        ret = inet_pton(type, str, &inner.ipv4.sin_addr);\n    } else {\n        ret = inet_pton(type, str, &inner.ipv6.sin6_addr);\n    }\n\n    if (ret == 0)  // 0 if address type doesnt match\n    {\n        mylog(log_error, \"confusion in parsing %s, %d\\n\", str, ret);\n        myexit(-1);\n    } else if (ret == 1)  // inet_pton returns 1 on success\n    {\n        // okay\n    } else {\n        mylog(log_error, \"ip_addr %s is invalid, %d\\n\", str, ret);\n        myexit(-1);\n    }\n    return 0;\n}\n\nchar *address_t::get_str() {\n    static char res[max_addr_len];\n    to_str(res);\n    return res;\n}\nvoid address_t::to_str(char *s) {\n    // static char res[max_addr_len];\n    char ip_addr[max_addr_len];\n    u32_t port;\n    const char *ret = 0;\n    if (get_type() == AF_INET6) {\n        ret = inet_ntop(AF_INET6, &inner.ipv6.sin6_addr, ip_addr, max_addr_len);\n        port = inner.ipv6.sin6_port;\n    } else if (get_type() == AF_INET) {\n        ret = inet_ntop(AF_INET, &inner.ipv4.sin_addr, ip_addr, max_addr_len);\n        port = inner.ipv4.sin_port;\n    } else {\n        assert(0 == 1);\n    }\n\n    if (ret == 0)  // NULL on failure\n    {\n        mylog(log_error, \"inet_ntop failed\\n\");\n        myexit(-1);\n    }\n\n    port = ntohs(port);\n\n    ip_addr[max_addr_len - 1] = 0;\n    if (get_type() == AF_INET6) {\n        sprintf(s, \"[%s]:%u\", ip_addr, (u32_t)port);\n    } else {\n        sprintf(s, \"%s:%u\", ip_addr, (u32_t)port);\n    }\n\n    // return res;\n}\n\nchar *address_t::get_ip() {\n    char ip_addr[max_addr_len];\n    static char s[max_addr_len];\n    const char *ret = 0;\n    if (get_type() == AF_INET6) {\n        ret = inet_ntop(AF_INET6, &inner.ipv6.sin6_addr, ip_addr, max_addr_len);\n    } else if (get_type() == AF_INET) {\n        ret = inet_ntop(AF_INET, &inner.ipv4.sin_addr, ip_addr, max_addr_len);\n    } else {\n        assert(0 == 1);\n    }\n\n    if (ret == 0)  // NULL on failure\n    {\n        mylog(log_error, \"inet_ntop failed\\n\");\n        myexit(-1);\n    }\n\n    ip_addr[max_addr_len - 1] = 0;\n    if (get_type() == AF_INET6) {\n        sprintf(s, \"%s\", ip_addr);\n    } else {\n        sprintf(s, \"%s\", ip_addr);\n    }\n\n    return s;\n}\n\nint address_t::from_sockaddr(sockaddr *addr, socklen_t slen) {\n    clear();\n    // memset(&inner,0,sizeof(inner));\n    if (addr->sa_family == AF_INET6) {\n        assert(slen == sizeof(sockaddr_in6));\n        // inner.ipv6= *( (sockaddr_in6*) addr );\n        memcpy(&inner, addr, slen);\n    } else if (addr->sa_family == AF_INET) {\n        assert(slen == sizeof(sockaddr_in));\n        // inner.ipv4= *( (sockaddr_in*) addr );\n        memcpy(&inner, addr, slen);\n    } else {\n        assert(0 == 1);\n    }\n    return 0;\n}\n\nint address_t::new_connected_udp_fd() {\n    int new_udp_fd;\n    new_udp_fd = socket(get_type(), SOCK_DGRAM, IPPROTO_UDP);\n    if (new_udp_fd < 0) {\n        mylog(log_warn, \"create udp_fd error\\n\");\n        return -1;\n    }\n    setnonblocking(new_udp_fd);\n    set_buf_size(new_udp_fd, socket_buf_size);\n\n    mylog(log_debug, \"created new udp_fd %d\\n\", new_udp_fd);\n    int ret = connect(new_udp_fd, (struct sockaddr *)&inner, get_len());\n    if (ret != 0) {\n        mylog(log_warn, \"udp fd connect fail %d %s\\n\", ret, strerror(errno));\n        // sock_close(new_udp_fd);\n        close(new_udp_fd);\n        return -1;\n    }\n\n    return new_udp_fd;\n}\n\nbool my_ip_t::equal(const my_ip_t &b) const {\n    // extern int raw_ip_version;\n    if (raw_ip_version == AF_INET) {\n        return v4 == b.v4;\n    } else if (raw_ip_version == AF_INET6) {\n        return memcmp(&v6, &b.v6, sizeof(v6)) == 0;\n    }\n    assert(0 == 1);\n    return 0;\n}\nchar *my_ip_t::get_str1() const {\n    static char res[max_addr_len];\n    if (raw_ip_version == AF_INET6) {\n        assert(inet_ntop(AF_INET6, &v6, res, max_addr_len) != 0);\n    } else {\n        assert(raw_ip_version == AF_INET);\n        assert(inet_ntop(AF_INET, &v4, res, max_addr_len) != 0);\n    }\n    return res;\n}\nchar *my_ip_t::get_str2() const {\n    static char res[max_addr_len];\n    if (raw_ip_version == AF_INET6) {\n        assert(inet_ntop(AF_INET6, &v6, res, max_addr_len) != 0);\n    } else {\n        assert(raw_ip_version == AF_INET);\n        assert(inet_ntop(AF_INET, &v4, res, max_addr_len) != 0);\n    }\n    return res;\n}\n\nint my_ip_t::from_address_t(address_t tmp_addr) {\n    if (tmp_addr.get_type() == raw_ip_version && raw_ip_version == AF_INET) {\n        v4 = tmp_addr.inner.ipv4.sin_addr.s_addr;\n    } else if (tmp_addr.get_type() == raw_ip_version && raw_ip_version == AF_INET6) {\n        v6 = tmp_addr.inner.ipv6.sin6_addr;\n    } else {\n        assert(0 == 1);\n    }\n    return 0;\n}\n/*\nint my_ip_t::from_str(char * str)\n{\n        u32_t type;\n        if(strchr(str,':')==NULL)\n                type=AF_INET;\n        else\n                type=AF_INET6;\n        int ret;\n        ret=inet_pton(type, str,this);\n        if(ret==0)  // 0 if address type doesnt match\n        {\n                mylog(log_error,\"confusion in parsing %s, %d\\n\",str,ret);\n                myexit(-1);\n        }\n        else if(ret==1) // inet_pton returns 1 on success\n        {\n                //okay\n        }\n        else\n        {\n                mylog(log_error,\"ip_addr %s is invalid, %d\\n\",str,ret);\n                myexit(-1);\n        }\n        return 0;\n}*/\n#ifdef UDP2RAW_MP\n\nint init_ws() {\n#if defined(__MINGW32__)\n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n\n    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0) {\n        /* Tell the user that we could not find a usable */\n        /* Winsock DLL.                                  */\n        printf(\"WSAStartup failed with error: %d\\n\", err);\n        exit(-1);\n    }\n\n    /* Confirm that the WinSock DLL supports 2.2.*/\n    /* Note that if the DLL supports versions greater    */\n    /* than 2.2 in addition to 2.2, it will still return */\n    /* 2.2 in wVersion since that is the version we      */\n    /* requested.                                        */\n\n    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {\n        /* Tell the user that we could not find a usable */\n        /* WinSock DLL.                                  */\n        printf(\"Could not find a usable version of Winsock.dll\\n\");\n        WSACleanup();\n        exit(-1);\n    } else {\n        printf(\"The Winsock 2.2 dll was found okay\");\n    }\n\n    int tmp[] = {0, 100, 200, 300, 500, 800, 1000, 2000, 3000, 4000, -1};\n    int succ = 0;\n    for (int i = 1; tmp[i] != -1; i++) {\n        if (_setmaxstdio(100) == -1)\n            break;\n        else\n            succ = i;\n    }\n    printf(\", _setmaxstdio() was set to %d\\n\", tmp[succ]);\n#endif\n    return 0;\n}\n\n#endif\n\n#if defined(__MINGW32__)\nint inet_pton(int af, const char *src, void *dst) {\n    struct sockaddr_storage ss;\n    int size = sizeof(ss);\n    char src_copy[max_addr_len + 1];\n\n    ZeroMemory(&ss, sizeof(ss));\n    /* stupid non-const API */\n    strncpy(src_copy, src, max_addr_len + 1);\n    src_copy[max_addr_len] = 0;\n\n    if (WSAStringToAddress(src_copy, af, NULL, (struct sockaddr *)&ss, &size) == 0) {\n        switch (af) {\n            case AF_INET:\n                *(struct in_addr *)dst = ((struct sockaddr_in *)&ss)->sin_addr;\n                return 1;\n            case AF_INET6:\n                *(struct in6_addr *)dst = ((struct sockaddr_in6 *)&ss)->sin6_addr;\n                return 1;\n        }\n    }\n    return 0;\n}\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size) {\n    struct sockaddr_storage ss;\n    unsigned long s = size;\n\n    ZeroMemory(&ss, sizeof(ss));\n    ss.ss_family = af;\n\n    switch (af) {\n        case AF_INET:\n            ((struct sockaddr_in *)&ss)->sin_addr = *(struct in_addr *)src;\n            break;\n        case AF_INET6:\n            ((struct sockaddr_in6 *)&ss)->sin6_addr = *(struct in6_addr *)src;\n            break;\n        default:\n            return NULL;\n    }\n    /* cannot direclty use &size because of strict aliasing rules */\n    return (WSAAddressToString((struct sockaddr *)&ss, sizeof(ss), NULL, dst, &s) == 0) ? dst : NULL;\n}\nchar *get_sock_error() {\n    static char buf[1000];\n    int e = WSAGetLastError();\n    wchar_t *s = NULL;\n    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                   NULL, e,\n                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                   (LPWSTR)&s, 0, NULL);\n    sprintf(buf, \"%d:%S\", e, s);\n    int len = strlen(buf);\n    while (len > 0 && (buf[len - 1] == '\\r' || buf[len - 1] == '\\n')) {\n        len--;\n        buf[len] = 0;\n    }\n    LocalFree(s);\n    return buf;\n}\nint get_sock_errno() {\n    return WSAGetLastError();\n}\n#else\nchar *get_sock_error() {\n    static char buf[1000];\n    sprintf(buf, \"%d:%s\", errno, strerror(errno));\n    return buf;\n}\nint get_sock_errno() {\n    return errno;\n}\n#endif\n\nu64_t get_current_time_us() {\n    static u64_t value_fix = 0;\n    static u64_t largest_value = 0;\n\n    u64_t raw_value = (u64_t)(ev_time() * 1000 * 1000);\n\n    u64_t fixed_value = raw_value + value_fix;\n\n    if (fixed_value < largest_value) {\n        value_fix += largest_value - fixed_value;\n    } else {\n        largest_value = fixed_value;\n    }\n\n    // printf(\"<%lld,%lld,%lld>\\n\",raw_value,value_fix,raw_value + value_fix);\n    return raw_value + value_fix;  // new fixed value\n}\n\nu64_t get_current_time() {\n    return get_current_time_us() / 1000;\n}\n\nu64_t pack_u64(u32_t a, u32_t b) {\n    u64_t ret = a;\n    ret <<= 32u;\n    ret += b;\n    return ret;\n}\nu32_t get_u64_h(u64_t a) {\n    return a >> 32u;\n}\nu32_t get_u64_l(u64_t a) {\n    return (a << 32u) >> 32u;\n}\n\nchar *my_ntoa(u32_t ip) {\n    in_addr a;\n    a.s_addr = ip;\n    return inet_ntoa(a);\n}\n/*\nvoid init_random_number_fd()\n{\n\n        random_number_fd=open(\"/dev/urandom\",O_RDONLY);\n\n        if(random_number_fd==-1)\n        {\n                mylog(log_fatal,\"error open /dev/urandom\\n\");\n                myexit(-1);\n        }\n        setnonblocking(random_number_fd);\n}*/\n\n#if !defined(__MINGW32__)\nstruct random_fd_t {\n    int random_number_fd;\n    random_fd_t() {\n        random_number_fd = open(\"/dev/urandom\", O_RDONLY);\n\n        if (random_number_fd == -1) {\n            mylog(log_fatal, \"error open /dev/urandom\\n\");\n            myexit(-1);\n        }\n        setnonblocking(random_number_fd);\n    }\n    int get_fd() {\n        return random_number_fd;\n    }\n} random_fd;\n#else\nstruct my_random_t {\n    std::random_device rd;\n    std::mt19937 gen;\n    std::uniform_int_distribution<u64_t> dis64;\n    std::uniform_int_distribution<u32_t> dis32;\n\n    std::uniform_int_distribution<unsigned char> dis8;\n\n    my_random_t() {\n        // std::mt19937 gen_tmp(rd());  //random device is broken on mingw\n        timespec tmp_time;\n        clock_gettime(CLOCK_MONOTONIC, &tmp_time);\n        long long a = ((u64_t)tmp_time.tv_sec) * 1000000000llu + ((u64_t)tmp_time.tv_nsec);\n        std::mt19937 gen_tmp(a);\n        gen = gen_tmp;\n        gen.discard(700000);  // magic\n    }\n    u64_t gen64() {\n        return dis64(gen);\n    }\n    u32_t gen32() {\n        return dis32(gen);\n    }\n\n    unsigned char gen8() {\n        return dis8(gen);\n    }\n    /*int random_number_fd;\n    random_fd_t()\n    {\n                    random_number_fd=open(\"/dev/urandom\",O_RDONLY);\n                    if(random_number_fd==-1)\n                    {\n                            mylog(log_fatal,\"error open /dev/urandom\\n\");\n                            myexit(-1);\n                    }\n                    setnonblocking(random_number_fd);\n    }\n    int get_fd()\n    {\n            return random_number_fd;\n    }*/\n} my_random;\n#endif\n\nu64_t get_true_random_number_64() {\n#if !defined(__MINGW32__)\n    u64_t ret;\n    int size = read(random_fd.get_fd(), &ret, sizeof(ret));\n    if (size != sizeof(ret)) {\n        mylog(log_fatal, \"get random number failed %d\\n\", size);\n        myexit(-1);\n    }\n    return ret;\n#else\n    return my_random.gen64();  // fake random number\n#endif\n}\nu32_t get_true_random_number() {\n#if !defined(__MINGW32__)\n    u32_t ret;\n    int size = read(random_fd.get_fd(), &ret, sizeof(ret));\n    if (size != sizeof(ret)) {\n        mylog(log_fatal, \"get random number failed %d\\n\", size);\n        myexit(-1);\n    }\n    return ret;\n#else\n    return my_random.gen32();  // fake random number\n#endif\n}\nu32_t get_true_random_number_nz()  // nz for non-zero\n{\n    u32_t ret = 0;\n    while (ret == 0) {\n        ret = get_true_random_number();\n    }\n    return ret;\n}\n\ninline int is_big_endian() {\n    int i = 1;\n    return !*((char *)&i);\n}\nu64_t ntoh64(u64_t a) {\n#ifdef UDP2RAW_LITTLE_ENDIAN\n    u32_t h = get_u64_h(a);\n    u32_t l = get_u64_l(a);\n    return pack_u64(ntohl(l), ntohl(h));\n    // return bswap_64( a);\n#else\n    return a;\n#endif\n}\nu64_t hton64(u64_t a) {\n    return ntoh64(a);\n}\n\nvoid write_u16(char *p, u16_t w) {\n    *(unsigned char *)(p + 1) = (w & 0xff);\n    *(unsigned char *)(p + 0) = (w >> 8);\n}\nu16_t read_u16(char *p) {\n    u16_t res;\n    res = *(const unsigned char *)(p + 0);\n    res = *(const unsigned char *)(p + 1) + (res << 8);\n    return res;\n}\n\nvoid write_u32(char *p, u32_t l) {\n    *(unsigned char *)(p + 3) = (unsigned char)((l >> 0) & 0xff);\n    *(unsigned char *)(p + 2) = (unsigned char)((l >> 8) & 0xff);\n    *(unsigned char *)(p + 1) = (unsigned char)((l >> 16) & 0xff);\n    *(unsigned char *)(p + 0) = (unsigned char)((l >> 24) & 0xff);\n}\nu32_t read_u32(char *p) {\n    u32_t res;\n    res = *(const unsigned char *)(p + 0);\n    res = *(const unsigned char *)(p + 1) + (res << 8);\n    res = *(const unsigned char *)(p + 2) + (res << 8);\n    res = *(const unsigned char *)(p + 3) + (res << 8);\n    return res;\n}\n\nvoid write_u64(char *s, u64_t a) {\n    assert(0 == 1);\n}\nu64_t read_u64(char *s) {\n    assert(0 == 1);\n    return 0;\n}\n\nvoid setnonblocking(int sock) {\n#if !defined(__MINGW32__)\n    int opts;\n    opts = fcntl(sock, F_GETFL);\n\n    if (opts < 0) {\n        mylog(log_fatal, \"fcntl(sock,GETFL)\\n\");\n        // perror(\"fcntl(sock,GETFL)\");\n        myexit(1);\n    }\n    opts = opts | O_NONBLOCK;\n    if (fcntl(sock, F_SETFL, opts) < 0) {\n        mylog(log_fatal, \"fcntl(sock,SETFL,opts)\\n\");\n        // perror(\"fcntl(sock,SETFL,opts)\");\n        myexit(1);\n    }\n#else\n    int iResult;\n    u_long iMode = 1;\n    iResult = ioctlsocket(sock, FIONBIO, &iMode);\n    if (iResult != NO_ERROR)\n        printf(\"ioctlsocket failed with error: %d\\n\", iResult);\n\n#endif\n}\n\n/*\n    Generic checksum calculation function\n*/\nunsigned short csum(const unsigned short *ptr, int nbytes) {  // works both for big and little endian\n    long sum;\n    unsigned short oddbyte;\n    short answer;\n\n    sum = 0;\n    while (nbytes > 1) {\n        sum += *ptr++;\n        nbytes -= 2;\n    }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n\n    sum = (sum >> 16) + (sum & 0xffff);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n\n    return (answer);\n}\n\nunsigned short csum_with_header(char *header, int hlen, const unsigned short *ptr, int nbytes) {  // works both for big and little endian\n\n    long sum;\n    unsigned short oddbyte;\n    short answer;\n\n    assert(hlen % 2 == 0);\n\n    sum = 0;\n    unsigned short *tmp = (unsigned short *)header;\n    for (int i = 0; i < hlen / 2; i++) {\n        sum += *tmp++;\n    }\n\n    while (nbytes > 1) {\n        sum += *ptr++;\n        nbytes -= 2;\n    }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n\n    sum = (sum >> 16) + (sum & 0xffff);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n\n    return (answer);\n}\n\nint set_buf_size(int fd, int socket_buf_size) {\n    if (force_socket_buf) {\n        if (is_udp2raw_mp) {\n            mylog(log_fatal, \"force_socket_buf not supported in this verion\\n\");\n            myexit(-1);\n        }\n        // assert(0==1);\n#ifdef UDP2RAW_LINUX\n        if (setsockopt(fd, SOL_SOCKET, SO_SNDBUFFORCE, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_SNDBUFFORCE fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, strerror(errno));\n            myexit(1);\n        }\n        if (setsockopt(fd, SOL_SOCKET, SO_RCVBUFFORCE, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_RCVBUFFORCE fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, strerror(errno));\n            myexit(1);\n        }\n#endif\n\n    } else {\n        if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_SNDBUF fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, get_sock_error());\n            myexit(1);\n        }\n        if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_RCVBUF fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, get_sock_error());\n            myexit(1);\n        }\n    }\n    return 0;\n}\n\nint numbers_to_char(my_id_t id1, my_id_t id2, my_id_t id3, char *&data, int &len) {\n    static char buf[buf_len];\n    data = buf;\n    my_id_t tmp = htonl(id1);\n    memcpy(buf, &tmp, sizeof(tmp));\n\n    tmp = htonl(id2);\n    memcpy(buf + sizeof(tmp), &tmp, sizeof(tmp));\n\n    tmp = htonl(id3);\n    memcpy(buf + sizeof(tmp) * 2, &tmp, sizeof(tmp));\n\n    len = sizeof(my_id_t) * 3;\n    return 0;\n}\n\nint char_to_numbers(const char *data, int len, my_id_t &id1, my_id_t &id2, my_id_t &id3) {\n    if (len < int(sizeof(my_id_t) * 3)) return -1;\n    // id1=ntohl(  *((id_t*)(data+0)) );\n    memcpy(&id1, data + 0, sizeof(id1));\n    id1 = ntohl(id1);\n    // id2=ntohl(  *((id_t*)(data+sizeof(id_t))) );\n    memcpy(&id2, data + sizeof(my_id_t), sizeof(id2));\n    id2 = ntohl(id2);\n    // id3=ntohl(  *((id_t*)(data+sizeof(id_t)*2)) );\n    memcpy(&id3, data + sizeof(my_id_t) * 2, sizeof(id3));\n    id3 = ntohl(id3);\n    return 0;\n}\nint hex_to_u32(const string &a, u32_t &output) {\n    // string b=\"0x\";\n    // b+=a;\n    if (sscanf(a.c_str(), \"%x\", &output) == 1) {\n        // printf(\"%s %x\\n\",a.c_str(),output);\n        return 0;\n    }\n    mylog(log_error, \"<%s> doesnt contain a hex\\n\", a.c_str());\n    return -1;\n}\nint hex_to_u32_with_endian(const string &a, u32_t &output) {\n    // string b=\"0x\";\n    // b+=a;\n    if (sscanf(a.c_str(), \"%x\", &output) == 1) {\n        output = htonl(output);\n        // printf(\"%s %x\\n\",a.c_str(),output);\n        return 0;\n    }\n    mylog(log_error, \"<%s> doesnt contain a hex\\n\", a.c_str());\n    return -1;\n}\nbool larger_than_u32(u32_t a, u32_t b) {\n    return ((i32_t(a - b)) > 0);\n    /*\n            u32_t smaller,bigger;\n            smaller=min(a,b);//smaller in normal sense\n            bigger=max(a,b);\n            u32_t distance=min(bigger-smaller,smaller+(0xffffffff-bigger+1));\n            if(distance==bigger-smaller)\n            {\n                    if(bigger==a)\n                    {\n                            return 1;\n                    }\n                    else\n                    {\n                            return 0;\n                    }\n            }\n            else\n            {\n                    if(smaller==b)\n                    {\n                            return 0;\n                    }\n                    else\n                    {\n                            return 1;\n                    }\n            }\n    */\n}\n\nbool larger_than_u16(uint16_t a, uint16_t b) {\n    return ((i16_t(a - b)) > 0);\n    /*\n            uint16_t smaller,bigger;\n            smaller=min(a,b);//smaller in normal sense\n            bigger=max(a,b);\n            uint16_t distance=min(bigger-smaller,smaller+(0xffff-bigger+1));\n            if(distance==bigger-smaller)\n            {\n                    if(bigger==a)\n                    {\n                            return 1;\n                    }\n                    else\n                    {\n                            return 0;\n                    }\n            }\n            else\n            {\n                    if(smaller==b)\n                    {\n                            return 0;\n                    }\n                    else\n                    {\n                            return 1;\n                    }\n            }*/\n}\n\nvoid myexit(int a) {\n    if (enable_log_color)\n        printf(\"%s\\n\", RESET);\n#ifdef UDP2RAW_LINUX\n    if (keep_thread_running) {\n        if (pthread_cancel(keep_thread)) {\n            mylog(log_warn, \"pthread_cancel failed\\n\");\n        } else {\n            mylog(log_info, \"pthread_cancel success\\n\");\n        }\n    }\n    clear_iptables_rule();\n#endif\n    exit(a);\n}\n\nvector<string> string_to_vec(const char *s, const char *sp) {\n    vector<string> res;\n    string str = s;\n    char *p = strtok((char *)str.c_str(), sp);\n    while (p != NULL) {\n        res.push_back(p);\n        // printf (\"%s\\n\",p);\n        p = strtok(NULL, sp);\n    }\n\n    /* for(int i=0;i<(int)res.size();i++)\n     {\n             printf(\"<<%s>>\\n\",res[i].c_str());\n     }*/\n    return res;\n}\n\nvector<vector<string> > string_to_vec2(const char *s) {\n    vector<vector<string> > res;\n    vector<string> lines = string_to_vec(s, \"\\n\");\n    for (int i = 0; i < int(lines.size()); i++) {\n        vector<string> tmp;\n        tmp = string_to_vec(lines[i].c_str(), \"\\t \");\n        res.push_back(tmp);\n    }\n    return res;\n}\nint read_file(const char *file, string &output) {\n    const int max_len = 3 * 1024 * 1024;\n    // static char buf[max_len+100];\n    string buf0;\n    buf0.reserve(max_len + 200);\n    char *buf = (char *)buf0.c_str();\n    buf[max_len] = 0;\n    // buf[sizeof(buf)-1]=0;\n    int fd = open(file, O_RDONLY);\n    if (fd == -1) {\n        mylog(log_error, \"read_file %s fail\\n\", file);\n        return -1;\n    }\n    int len = read(fd, buf, max_len);\n    if (len == max_len) {\n        buf[0] = 0;\n        mylog(log_error, \"%s too long,buf not large enough\\n\", file);\n        return -2;\n    } else if (len < 0) {\n        buf[0] = 0;\n        mylog(log_error, \"%s read fail %d\\n\", file, len);\n        return -3;\n    } else {\n        buf[len] = 0;\n        output = buf;\n    }\n    return 0;\n}\nint run_command(string command0, char *&output, int flag) {\n    if (is_udp2raw_mp) {\n        mylog(log_fatal, \"run_command not supported in this version\\n\");\n        myexit(-1);\n    }\n#ifdef UDP2RAW_LINUX\n    FILE *in;\n\n    if ((flag & show_log) == 0) command0 += \" 2>&1 \";\n\n    const char *command = command0.c_str();\n\n    int level = (flag & show_log) ? log_warn : log_debug;\n\n    if (flag & show_command) {\n        mylog(log_info, \"run_command %s\\n\", command);\n    } else {\n        mylog(log_debug, \"run_command %s\\n\", command);\n    }\n    static __thread char buf[1024 * 1024 + 100];\n    buf[sizeof(buf) - 1] = 0;\n    if (!(in = popen(command, \"r\"))) {\n        mylog(level, \"command %s popen failed,errno %s\\n\", command, strerror(errno));\n        return -1;\n    }\n\n    int len = fread(buf, 1024 * 1024, 1, in);\n    if (len == 1024 * 1024) {\n        buf[0] = 0;\n        mylog(level, \"too long,buf not larger enough\\n\");\n        return -2;\n    } else {\n        buf[len] = 0;\n    }\n    int ret;\n    if ((ret = ferror(in))) {\n        mylog(level, \"command %s fread failed,ferror return value %d \\n\", command, ret);\n        return -3;\n    }\n    // if(output!=0)\n    output = buf;\n    ret = pclose(in);\n\n    int ret2 = WEXITSTATUS(ret);\n\n    if (ret != 0 || ret2 != 0) {\n        mylog(level, \"commnad %s ,pclose returned %d ,WEXITSTATUS %d,errnor :%s \\n\", command, ret, ret2, strerror(errno));\n        return -4;\n    }\n\n#endif\n    return 0;\n}\n/*\nint run_command_no_log(string command0,char * &output) {\n    FILE *in;\n    command0+=\" 2>&1 \";\n    const char * command=command0.c_str();\n    mylog(log_debug,\"run_command_no_log %s\\n\",command);\n    static char buf[1024*1024+100];\n    buf[sizeof(buf)-1]=0;\n    if(!(in = popen(command, \"r\"))){\n        mylog(log_debug,\"command %s popen failed,errno %s\\n\",command,strerror(errno));\n        return -1;\n    }\n\n    int len =fread(buf, 1024*1024, 1, in);\n    if(len==1024*1024)\n    {\n        buf[0]=0;\n        mylog(log_debug,\"too long,buf not larger enough\\n\");\n        return -2;\n    }\n    else\n    {\n        buf[len]=0;\n    }\n    int ret;\n    if(( ret=ferror(in) ))\n    {\n        mylog(log_debug,\"command %s fread failed,ferror return value %d \\n\",command,ret);\n        return -3;\n    }\n    //if(output!=0)\n    output=buf;\n    ret= pclose(in);\n\n    int ret2=WEXITSTATUS(ret);\n\n    if(ret!=0||ret2!=0)\n    {\n        mylog(log_debug,\"commnad %s ,pclose returned %d ,WEXITSTATUS %d,errnor :%s \\n\",command,ret,ret2,strerror(errno));\n        return -4;\n    }\n\n    return 0;\n\n}*/\n\n// Remove preceding and trailing characters\nstring trim(const string &str, char c) {\n    size_t first = str.find_first_not_of(c);\n    if (string::npos == first) {\n        return \"\";\n    }\n    size_t last = str.find_last_not_of(c);\n    return str.substr(first, (last - first + 1));\n}\n\nvector<string> parse_conf_line(const string &s0) {\n    string s = s0;\n    s.reserve(s.length() + 200);\n    char *buf = (char *)s.c_str();\n    // char buf[s.length()+200];\n    char *p = buf;\n    int i = int(s.length()) - 1;\n    int j;\n    vector<string> res;\n    // strcpy(buf,(char *)s.c_str());\n    while (i >= 0) {\n        if (buf[i] == ' ' || buf[i] == '\\t')\n            buf[i] = 0;\n        else\n            break;\n        i--;\n    }\n    while (*p != 0) {\n        if (*p == ' ' || *p == '\\t') {\n            p++;\n        } else\n            break;\n    }\n    int new_len = strlen(p);\n    if (new_len == 0) return res;\n    if (p[0] == '#') return res;\n    if (p[0] != '-') {\n        mylog(log_fatal, \"line :<%s> not begin with '-' \", s.c_str());\n        myexit(-1);\n    }\n\n    for (i = 0; i < new_len; i++) {\n        if (p[i] == ' ' || p[i] == '\\t') {\n            break;\n        }\n    }\n    if (i == new_len) {\n        res.push_back(p);\n        return res;\n    }\n\n    j = i;\n    while (p[j] == ' ' || p[j] == '\\t')\n        j++;\n    p[i] = 0;\n    res.push_back(p);\n    res.push_back(p + j);\n    return res;\n}\n\nint create_fifo(char *file) {\n#if !defined(__MINGW32__)\n    if (mkfifo(file, 0666) != 0) {\n        if (errno == EEXIST) {\n            mylog(log_warn, \"warning fifo file %s exist\\n\", file);\n        } else {\n            mylog(log_fatal, \"create fifo file %s failed\\n\", file);\n            myexit(-1);\n        }\n    }\n    int fifo_fd = open(file, O_RDWR);\n    if (fifo_fd < 0) {\n        mylog(log_fatal, \"create fifo file %s failed\\n\", file);\n        myexit(-1);\n    }\n    struct stat st;\n    if (fstat(fifo_fd, &st) != 0) {\n        mylog(log_fatal, \"fstat failed for fifo file %s\\n\", file);\n        myexit(-1);\n    }\n\n    if (!S_ISFIFO(st.st_mode)) {\n        mylog(log_fatal, \"%s is not a fifo\\n\", file);\n        myexit(-1);\n    }\n\n    setnonblocking(fifo_fd);\n    return fifo_fd;\n#else\n    mylog(log_fatal, \"--fifo not supported in this version\\n\");\n    myexit(-1);\n    return 0;\n#endif\n}\n\n/*\nvoid ip_port_t::from_u64(u64_t u64)\n{\n        ip=get_u64_h(u64);\n        port=get_u64_l(u64);\n}\nu64_t ip_port_t::to_u64()\n{\n        return pack_u64(ip,port);\n}\nchar * ip_port_t::to_s()\n{\n        static char res[40];\n        sprintf(res,\"%s:%d\",my_ntoa(ip),port);\n        return res;\n}*/\n\nvoid print_binary_chars(const char *a, int len) {\n    for (int i = 0; i < len; i++) {\n        unsigned char b = a[i];\n        log_bare(log_debug, \"<%02x>\", (int)b);\n    }\n    log_bare(log_debug, \"\\n\");\n}\n\nu32_t djb2(unsigned char *str, int len) {\n    u32_t hash = 5381;\n    int c;\n    for (int i=0; i<len ;i++) {\n        c = *(str++);\n        hash = ((hash << 5) + hash) ^ c; /* (hash * 33) ^ c */\n    }\n\n    hash = htonl(hash);\n    return hash;\n}\n\nu32_t sdbm(unsigned char *str, int len) {\n    u32_t hash = 0;\n    int c;\n    for (int i=0; i<len ;i++) {\n        c = *(str++);\n        hash = c + (hash << 6) + (hash << 16) - hash;\n    }\n    // hash=htonl(hash);\n    return hash;\n}\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 12.1279296875,
          "content": "/*\n * common.h\n *\n *  Created on: Jul 29, 2017\n *      Author: wangyu\n */\n\n#ifndef UDP2RAW_COMMON_H_\n#define UDP2RAW_COMMON_H_\n#define __STDC_FORMAT_MACROS 1\n#include <inttypes.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <getopt.h>\n\n#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <stdlib.h>  //for exit(0);\n#include <errno.h>   //For errno - the error number\n#include <fcntl.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <pthread.h>\n\n#ifndef USE_LIBNET\n#define NO_LIBNET\n#endif\n\n#if defined(UDP2RAW_MP)\nconst int is_udp2raw_mp = 1;\n#if !defined(__CYGWIN__) && !defined(__MINGW32__)\n#include <pcap.h>\n#else\n#include <pcap_wrapper.h>\n#define NO_LIBNET\n#endif\n\n#ifndef NO_LIBNET\n#include <libnet.h>\n#endif\n\n#else\n#define UDP2RAW_LINUX\nconst int is_udp2raw_mp = 0;\n//#include <linux/if_ether.h>\n#include <linux/filter.h>\n#include <linux/if_packet.h>\n#include <sys/epoll.h>\n//#include <sys/wait.h> //signal\n#include <netinet/if_ether.h>\n#include <net/if.h>\n#include <sys/timerfd.h>\n\n#endif\n\n#if !defined(NO_LIBEV_EMBED)\n#include <my_ev.h>\n#else\n#include \"ev.h\"\n#endif\n\n#if defined(__MINGW32__)\n#include <winsock2.h>\n#include <ws2ipdef.h>\ntypedef unsigned char u_int8_t;\ntypedef unsigned short u_int16_t;\ntypedef unsigned int u_int32_t;\ntypedef int socklen_t;\n#else\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#endif\n\n#include <unordered_map>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\nusing namespace std;\n\n#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN ||             \\\n    defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || \\\n    defined(__BIG_ENDIAN__) ||                                           \\\n    defined(__ARMEB__) ||                                                \\\n    defined(__THUMBEB__) ||                                              \\\n    defined(__AARCH64EB__) ||                                            \\\n    defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)\n#define UDP2RAW_BIG_ENDIAN 1\n#endif\n\n#if defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN ||             \\\n    defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || \\\n    defined(__LITTLE_ENDIAN__) ||                                           \\\n    defined(__ARMEL__) ||                                                   \\\n    defined(__THUMBEL__) ||                                                 \\\n    defined(__AARCH64EL__) ||                                               \\\n    defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__)\n#define UDP2RAW_LITTLE_ENDIAN 1\n#endif\n\n#if defined(UDP2RAW_BIG_ENDIAN) && defined(UDP2RAW_LITTLE_ENDIAN)\n#error \"endian detection conflicts\"\n#endif\n\n#if !defined(UDP2RAW_BIG_ENDIAN) && !defined(UDP2RAW_LITTLE_ENDIAN)\n#error \"endian detection failed\"\n#endif\n\n#if defined(__MINGW32__)\nint inet_pton(int af, const char *src, void *dst);\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n#define setsockopt(a, b, c, d, e) setsockopt(a, b, c, (const char *)(d), e)\n#endif\n\nchar *get_sock_error();\nint get_sock_errno();\n\n#if defined(__MINGW32__)\ntypedef SOCKET my_fd_t;\ninline int sock_close(my_fd_t fd) {\n    return closesocket(fd);\n}\n#else\ntypedef int my_fd_t;\ninline int sock_close(my_fd_t fd) {\n    return close(fd);\n}\n\n#endif\n\ntypedef unsigned long long u64_t;  // this works on most platform,avoid using the PRId64\ntypedef long long i64_t;\n\ntypedef unsigned int u32_t;\ntypedef int i32_t;\n\ntypedef unsigned short u16_t;\ntypedef short i16_t;\n\ntypedef u32_t my_id_t;\n\ntypedef u64_t iv_t;\n\ntypedef u64_t padding_t;\n\ntypedef u64_t anti_replay_seq_t;\n\ntypedef u64_t my_time_t;\n\nconst int max_addr_len = 100;\n\nextern int force_socket_buf;\n\nextern int g_fix_gro;\n\n/*\nstruct ip_port_t\n{\n        u32_t ip;\n        int port;\n        void from_u64(u64_t u64);\n        u64_t to_u64();\n        char * to_s();\n};*/\n\ntypedef u64_t fd64_t;\n\nu32_t djb2(unsigned char *str, int len);\nu32_t sdbm(unsigned char *str, int len);\n\nstruct address_t  // TODO scope id\n{\n    struct hash_function {\n        u32_t operator()(const address_t &key) const {\n            return sdbm((unsigned char *)&key.inner, sizeof(key.inner));\n        }\n    };\n\n    union storage_t  // sockaddr_storage is too huge, we dont use it.\n    {\n        sockaddr_in ipv4;\n        sockaddr_in6 ipv6;\n    };\n    storage_t inner;\n\n    address_t() {\n        clear();\n    }\n    void clear() {\n        memset(&inner, 0, sizeof(inner));\n    }\n    int from_ip_port(u32_t ip, int port) {\n        clear();\n        inner.ipv4.sin_family = AF_INET;\n        inner.ipv4.sin_port = htons(port);\n        inner.ipv4.sin_addr.s_addr = ip;\n        return 0;\n    }\n\n    int from_ip_port_new(int type, void *ip, int port) {\n        clear();\n        if (type == AF_INET) {\n            inner.ipv4.sin_family = AF_INET;\n            inner.ipv4.sin_port = htons(port);\n            inner.ipv4.sin_addr.s_addr = *((u32_t *)ip);\n        } else if (type == AF_INET6) {\n            inner.ipv6.sin6_family = AF_INET6;\n            inner.ipv6.sin6_port = htons(port);\n            inner.ipv6.sin6_addr = *((in6_addr *)ip);\n        }\n        return 0;\n    }\n\n    int from_str(char *str);\n\n    int from_str_ip_only(char *str);\n\n    int from_sockaddr(sockaddr *, socklen_t);\n\n    char *get_str();\n    void to_str(char *);\n\n    inline u32_t get_type() {\n        u32_t ret = ((sockaddr *)&inner)->sa_family;\n        assert(ret == AF_INET || ret == AF_INET6);\n        return ret;\n    }\n\n    inline u32_t get_len() {\n        u32_t type = get_type();\n        switch (type) {\n            case AF_INET:\n                return sizeof(sockaddr_in);\n            case AF_INET6:\n                return sizeof(sockaddr_in6);\n            default:\n                assert(0 == 1);\n        }\n        return -1;\n    }\n\n    inline u32_t get_port() {\n        u32_t type = get_type();\n        switch (type) {\n            case AF_INET:\n                return ntohs(inner.ipv4.sin_port);\n            case AF_INET6:\n                return ntohs(inner.ipv6.sin6_port);\n            default:\n                assert(0 == 1);\n        }\n        return -1;\n    }\n\n    inline void set_port(int port) {\n        u32_t type = get_type();\n        switch (type) {\n            case AF_INET:\n                inner.ipv4.sin_port = htons(port);\n                break;\n            case AF_INET6:\n                inner.ipv6.sin6_port = htons(port);\n                break;\n            default:\n                assert(0 == 1);\n        }\n        return;\n    }\n\n    bool operator==(const address_t &b) const {\n        // return this->data==b.data;\n        return memcmp(&this->inner, &b.inner, sizeof(this->inner)) == 0;\n    }\n\n    int new_connected_udp_fd();\n\n    char *get_ip();\n};\n\nnamespace std {\ntemplate <>\nstruct hash<address_t> {\n    std::size_t operator()(const address_t &key) const {\n        // return address_t::hash_function(k);\n        return sdbm((unsigned char *)&key.inner, sizeof(key.inner));\n    }\n};\n}  // namespace std\n\nunion my_ip_t  // just a simple version of address_t,stores ip only\n{\n    u32_t v4;\n    in6_addr v6;\n\n    bool equal(const my_ip_t &b) const;\n\n    // int from_str(char * str);\n    char *get_str1() const;\n    char *get_str2() const;\n\n    int from_address_t(address_t a);\n};\n\nstruct not_copy_able_t {\n    not_copy_able_t() {\n    }\n    not_copy_able_t(const not_copy_able_t &other) {\n        assert(0 == 1);\n    }\n    const not_copy_able_t &operator=(const not_copy_able_t &other) {\n        assert(0 == 1);\n        return other;\n    }\n};\n\nconst int huge_data_len = 65535 + 100;  // a packet with link level header might be larger than 65535\nconst int huge_buf_len = huge_data_len + 100;\n\nconst int max_data_len = 1800;\nconst int buf_len = max_data_len + 400;\n\n// const int max_address_len=512;\n\n#ifdef UDP2RAW_MP\nconst int queue_len = 200;\n\nstruct queue_t {\n    char data[queue_len][huge_buf_len];\n    int data_len[queue_len];\n\n    int head = 0;\n    int tail = 0;\n    void clear() {\n        head = tail = 0;\n    }\n    int empty() {\n        if (head == tail)\n            return 1;\n        else\n            return 0;\n    }\n    int full() {\n        if ((tail + 1) % queue_len == head)\n            return 1;\n        else\n            return 0;\n    }\n    void peek_front(char *&p, int &len) {\n        assert(!empty());\n        p = data[head];\n        len = data_len[head];\n    }\n    void pop_front() {\n        assert(!empty());\n        head++;\n        head %= queue_len;\n    }\n    void push_back(char *p, int len) {\n        assert(!full());\n        memcpy(data[tail], p, len);\n        data_len[tail] = len;\n        tail++;\n        tail %= queue_len;\n    }\n};\n\nint init_ws();\n#endif\nu64_t get_current_time();\nu64_t pack_u64(u32_t a, u32_t b);\n\nu32_t get_u64_h(u64_t a);\n\nu32_t get_u64_l(u64_t a);\n\nchar *my_ntoa(u32_t ip);\n\nvoid init_random_number_fd();\nu64_t get_true_random_number_64();\nu32_t get_true_random_number();\nu32_t get_true_random_number_nz();\nu64_t ntoh64(u64_t a);\nu64_t hton64(u64_t a);\n\nvoid write_u16(char *, u16_t a);  // network order\nu16_t read_u16(char *);\nvoid write_u32(char *, u32_t a);  // network order\nu32_t read_u32(char *);\nvoid write_u64(char *, u64_t a);\nu64_t read_u64(char *);\n\nbool larger_than_u16(uint16_t a, uint16_t b);\nbool larger_than_u32(u32_t a, u32_t b);\nvoid setnonblocking(int sock);\nint set_buf_size(int fd, int socket_buf_size);\n\nvoid myexit(int a);\n\nunsigned short csum(const unsigned short *ptr, int nbytes);\nunsigned short csum_with_header(char *header, int hlen, const unsigned short *ptr, int nbytes);\n\nint numbers_to_char(my_id_t id1, my_id_t id2, my_id_t id3, char *&data, int &len);\nint char_to_numbers(const char *data, int len, my_id_t &id1, my_id_t &id2, my_id_t &id3);\n\nconst int show_none = 0;\nconst int show_command = 0x1;\nconst int show_log = 0x2;\nconst int show_all = show_command | show_log;\n\nint run_command(string command, char *&output, int flag = show_all);\n// int run_command_no_log(string command,char * &output);\nint read_file(const char *file, string &output);\n\nvector<string> string_to_vec(const char *s, const char *sp);\nvector<vector<string> > string_to_vec2(const char *s);\n\nstring trim(const string &str, char c);\n\nstring trim_conf_line(const string &str);\n\nvector<string> parse_conf_line(const string &s);\n\nint hex_to_u32_with_endian(const string &a, u32_t &output);\nint hex_to_u32(const string &a, u32_t &output);\n// extern string iptables_pattern;\n\nint create_fifo(char *file);\n\nvoid print_binary_chars(const char *a, int len);\n\ntemplate <class key_t>\nstruct lru_collector_t : not_copy_able_t {\n    // typedef void* key_t;\n    //#define key_t void*\n    struct lru_pair_t {\n        key_t key;\n        my_time_t ts;\n    };\n\n    unordered_map<key_t, typename list<lru_pair_t>::iterator> mp;\n\n    list<lru_pair_t> q;\n    int update(key_t key) {\n        assert(mp.find(key) != mp.end());\n        auto it = mp[key];\n        q.erase(it);\n\n        my_time_t value = get_current_time();\n        if (!q.empty()) {\n            assert(value >= q.front().ts);\n        }\n        lru_pair_t tmp;\n        tmp.key = key;\n        tmp.ts = value;\n        q.push_front(tmp);\n        mp[key] = q.begin();\n\n        return 0;\n    }\n    int new_key(key_t key) {\n        assert(mp.find(key) == mp.end());\n\n        my_time_t value = get_current_time();\n        if (!q.empty()) {\n            assert(value >= q.front().ts);\n        }\n        lru_pair_t tmp;\n        tmp.key = key;\n        tmp.ts = value;\n        q.push_front(tmp);\n        mp[key] = q.begin();\n\n        return 0;\n    }\n    int size() {\n        return q.size();\n    }\n    int empty() {\n        return q.empty();\n    }\n    void clear() {\n        mp.clear();\n        q.clear();\n    }\n    my_time_t ts_of(key_t key) {\n        assert(mp.find(key) != mp.end());\n        return mp[key]->ts;\n    }\n\n    my_time_t peek_back(key_t &key) {\n        assert(!q.empty());\n        auto it = q.end();\n        it--;\n        key = it->key;\n        return it->ts;\n    }\n    void erase(key_t key) {\n        assert(mp.find(key) != mp.end());\n        q.erase(mp[key]);\n        mp.erase(key);\n    }\n    /*\n    void erase_back()\n    {\n            assert(!q.empty());\n            auto it=q.end(); it--;\n            key_t key=it->key;\n            erase(key);\n    }*/\n};\n\n#endif /* COMMON_H_ */\n"
        },
        {
          "name": "connection.cpp",
          "type": "blob",
          "size": 21.12109375,
          "content": "/*\n * connection.cpp\n *\n *  Created on: Sep 23, 2017\n *      Author: root\n */\n\n#include \"connection.h\"\n#include \"encrypt.h\"\n#include \"fd_manager.h\"\n\nint disable_anti_replay = 0;  // if anti_replay windows is diabled\n\nconst int disable_conn_clear = 0;  // a raw connection is called conn.\n\nconn_manager_t conn_manager;\n\nanti_replay_seq_t anti_replay_t::get_new_seq_for_send() {\n    return anti_replay_seq++;\n}\nanti_replay_t::anti_replay_t() {\n    max_packet_received = 0;\n    anti_replay_seq = get_true_random_number_64() / 10;  // random first seq\n    // memset(window,0,sizeof(window)); //not necessary\n}\nvoid anti_replay_t::re_init() {\n    max_packet_received = 0;\n    // memset(window,0,sizeof(window));\n}\n\nint anti_replay_t::is_vaild(u64_t seq) {\n    if (disable_anti_replay) return 1;\n    // if(disabled) return 0;\n\n    if (seq == max_packet_received)\n        return 0;\n    else if (seq > max_packet_received) {\n        if (seq - max_packet_received >= anti_replay_window_size) {\n            memset(window, 0, sizeof(window));\n            window[seq % anti_replay_window_size] = 1;\n        } else {\n            for (u64_t i = max_packet_received + 1; i < seq; i++)\n                window[i % anti_replay_window_size] = 0;\n            window[seq % anti_replay_window_size] = 1;\n        }\n        max_packet_received = seq;\n        return 1;\n    } else if (seq < max_packet_received) {\n        if (max_packet_received - seq >= anti_replay_window_size)\n            return 0;\n        else {\n            if (window[seq % anti_replay_window_size] == 1)\n                return 0;\n            else {\n                window[seq % anti_replay_window_size] = 1;\n                return 1;\n            }\n        }\n    }\n\n    return 0;  // for complier check\n}\n\nvoid conn_info_t::recover(const conn_info_t &conn_info) {\n    raw_info = conn_info.raw_info;\n\n    raw_info.rst_received = 0;\n    raw_info.disabled = 0;\n\n    last_state_time = conn_info.last_state_time;\n    last_hb_recv_time = conn_info.last_hb_recv_time;\n    last_hb_sent_time = conn_info.last_hb_sent_time;\n    my_id = conn_info.my_id;\n    oppsite_id = conn_info.oppsite_id;\n    blob->anti_replay.re_init();\n\n    my_roller = 0;       // no need to set,but for easier debug,set it to zero\n    oppsite_roller = 0;  // same as above\n    last_oppsite_roller_time = 0;\n}\n\nvoid conn_info_t::re_init() {\n    // send_packet_info.protocol=g_packet_info_send.protocol;\n    if (program_mode == server_mode)\n        state.server_current_state = server_idle;\n    else\n        state.client_current_state = client_idle;\n    last_state_time = 0;\n    oppsite_const_id = 0;\n\n    timer_fd64 = 0;\n\n    my_roller = 0;\n    oppsite_roller = 0;\n    last_oppsite_roller_time = 0;\n}\nconn_info_t::conn_info_t() {\n    blob = 0;\n    re_init();\n}\nvoid conn_info_t::prepare() {\n    assert(blob == 0);\n    blob = new blob_t;\n    if (program_mode == server_mode) {\n        blob->conv_manager.s.additional_clear_function = server_clear_function;\n    } else {\n        assert(program_mode == client_mode);\n    }\n}\n\nconn_info_t::conn_info_t(const conn_info_t &b) {\n    assert(0 == 1);\n    // mylog(log_error,\"called!!!!!!!!!!!!!\\n\");\n}\n\nconn_info_t &conn_info_t::operator=(const conn_info_t &b) {\n    mylog(log_fatal, \"not allowed\\n\");\n    myexit(-1);\n    return *this;\n}\nconn_info_t::~conn_info_t() {\n    if (program_mode == server_mode) {\n        if (state.server_current_state == server_ready) {\n            assert(blob != 0);\n            assert(oppsite_const_id != 0);\n            // assert(conn_manager.const_id_mp.find(oppsite_const_id)!=conn_manager.const_id_mp.end()); // conn_manager 's deconstuction function  erases it\n        } else {\n            assert(blob == 0);\n            assert(oppsite_const_id == 0);\n        }\n    }\n    assert(timer_fd64 == 0);\n    // if(oppsite_const_id!=0)     //do this at conn_manager 's deconstuction function\n    // conn_manager.const_id_mp.erase(oppsite_const_id);\n    if (blob != 0)\n        delete blob;\n\n    // send_packet_info.protocol=g_packet_info_send.protocol;\n}\n\nconn_manager_t::conn_manager_t() {\n    ready_num = 0;\n    mp.reserve(10007);\n    // clear_it=mp.begin();\n    // timer_fd_mp.reserve(10007);\n    const_id_mp.reserve(10007);\n    // udp_fd_mp.reserve(100007);\n    last_clear_time = 0;\n    // current_ready_ip=0;\n    // current_ready_port=0;\n}\nint conn_manager_t::exist(address_t addr) {\n    // u64_t u64=0;\n    // u64=ip;\n    // u64<<=32u;\n    // u64|=port;\n    if (mp.find(addr) != mp.end()) {\n        return 1;\n    }\n    return 0;\n}\n/*\nint insert(uint32_t ip,uint16_t port)\n{\n        uint64_t u64=0;\n        u64=ip;\n        u64<<=32u;\n        u64|=port;\n        mp[u64];\n        return 0;\n}*/\nconn_info_t *&conn_manager_t::find_insert_p(address_t addr)  // be aware,the adress may change after rehash\n{\n    // u64_t u64=0;\n    // u64=ip;\n    // u64<<=32u;\n    // u64|=port;\n    unordered_map<address_t, conn_info_t *>::iterator it = mp.find(addr);\n    if (it == mp.end()) {\n        mp[addr] = new conn_info_t;\n        // lru.new_key(addr);\n    } else {\n        // lru.update(addr);\n    }\n    return mp[addr];\n}\nconn_info_t &conn_manager_t::find_insert(address_t addr)  // be aware,the adress may change after rehash\n{\n    // u64_t u64=0;\n    // u64=ip;\n    // u64<<=32u;\n    // u64|=port;\n    unordered_map<address_t, conn_info_t *>::iterator it = mp.find(addr);\n    if (it == mp.end()) {\n        mp[addr] = new conn_info_t;\n        // lru.new_key(addr);\n    } else {\n        // lru.update(addr);\n    }\n    return *mp[addr];\n}\nint conn_manager_t::erase(unordered_map<address_t, conn_info_t *>::iterator erase_it) {\n    if (erase_it->second->state.server_current_state == server_ready) {\n        ready_num--;\n        assert(i32_t(ready_num) != -1);\n        assert(erase_it->second != 0);\n\n        assert(erase_it->second->timer_fd64 != 0);\n\n        assert(fd_manager.exist(erase_it->second->timer_fd64));\n\n        assert(erase_it->second->oppsite_const_id != 0);\n        assert(const_id_mp.find(erase_it->second->oppsite_const_id) != const_id_mp.end());\n\n        // assert(timer_fd_mp.find(erase_it->second->timer_fd)!=timer_fd_mp.end());\n\n        const_id_mp.erase(erase_it->second->oppsite_const_id);\n\n        fd_manager.fd64_close(erase_it->second->timer_fd64);\n\n        erase_it->second->timer_fd64 = 0;\n        // timer_fd_mp.erase(erase_it->second->timer_fd);\n        // close(erase_it->second->timer_fd);// close will auto delte it from epoll\n        delete (erase_it->second);\n        mp.erase(erase_it->first);\n    } else {\n        assert(erase_it->second->blob == 0);\n        assert(erase_it->second->timer_fd64 == 0);\n\n        assert(erase_it->second->oppsite_const_id == 0);\n        delete (erase_it->second);\n        mp.erase(erase_it->first);\n    }\n    return 0;\n}\nint conn_manager_t::clear_inactive() {\n    if (get_current_time() - last_clear_time > conn_clear_interval) {\n        last_clear_time = get_current_time();\n        return clear_inactive0();\n    }\n    return 0;\n}\nint conn_manager_t::clear_inactive0() {\n    unordered_map<address_t, conn_info_t *>::iterator it;\n    unordered_map<address_t, conn_info_t *>::iterator old_it;\n\n    if (disable_conn_clear) return 0;\n\n    // map<uint32_t,uint64_t>::iterator it;\n    int cnt = 0;\n    it = clear_it;\n    int size = mp.size();\n    int num_to_clean = size / conn_clear_ratio + conn_clear_min;  // clear 1/10 each time,to avoid latency glitch\n\n    mylog(log_trace, \"mp.size() %d\\n\", size);\n\n    num_to_clean = min(num_to_clean, (int)mp.size());\n    u64_t current_time = get_current_time();\n\n    for (;;) {\n        if (cnt >= num_to_clean) break;\n        if (mp.begin() == mp.end()) break;\n\n        if (it == mp.end()) {\n            it = mp.begin();\n        }\n\n        if (it->second->state.server_current_state == server_ready && current_time - it->second->last_hb_recv_time <= server_conn_timeout) {\n            it++;\n        } else if (it->second->state.server_current_state != server_ready && current_time - it->second->last_state_time <= server_handshake_timeout) {\n            it++;\n        } else if (it->second->blob != 0 && it->second->blob->conv_manager.s.get_size() > 0) {\n            assert(it->second->state.server_current_state == server_ready);\n            it++;\n        } else {\n            mylog(log_info, \"[%s:%d]inactive conn cleared \\n\", it->second->raw_info.recv_info.new_src_ip.get_str1(), it->second->raw_info.recv_info.src_port);\n            old_it = it;\n            it++;\n            erase(old_it);\n        }\n        cnt++;\n    }\n    clear_it = it;\n\n    return 0;\n}\n\nint send_bare(raw_info_t &raw_info, const char *data, int len)  // send function with encryption but no anti replay,this is used when client and server verifys each other\n// you have to design the protocol carefully, so that you wont be affect by relay attack\n{\n    if (len < 0) {\n        mylog(log_debug, \"input_len <0\\n\");\n        return -1;\n    }\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    char send_data_buf[buf_len];  // buf for send data and send hb\n    char send_data_buf2[buf_len];\n\n    // static send_bare[buf_len];\n    iv_t iv = get_true_random_number_64();\n    padding_t padding = get_true_random_number_64();\n\n    memcpy(send_data_buf, &iv, sizeof(iv));\n    memcpy(send_data_buf + sizeof(iv), &padding, sizeof(padding));\n\n    send_data_buf[sizeof(iv) + sizeof(padding)] = 'b';\n    memcpy(send_data_buf + sizeof(iv) + sizeof(padding) + 1, data, len);\n    int new_len = len + sizeof(iv) + sizeof(padding) + 1;\n\n    if (my_encrypt(send_data_buf, send_data_buf2, new_len) != 0) {\n        return -1;\n    }\n    send_raw0(raw_info, send_data_buf2, new_len);\n    return 0;\n}\nint reserved_parse_bare(const char *input, int input_len, char *&data, int &len)  // a sub function used in recv_bare\n{\n    static char recv_data_buf[buf_len];\n\n    if (input_len < 0) {\n        mylog(log_debug, \"input_len <0\\n\");\n        return -1;\n    }\n    if (my_decrypt(input, recv_data_buf, input_len) != 0) {\n        mylog(log_debug, \"decrypt_fail in recv bare\\n\");\n        return -1;\n    }\n    if (recv_data_buf[sizeof(iv_t) + sizeof(padding_t)] != 'b') {\n        mylog(log_debug, \"not a bare packet\\n\");\n        return -1;\n    }\n    len = input_len;\n    data = recv_data_buf + sizeof(iv_t) + sizeof(padding_t) + 1;\n    len -= sizeof(iv_t) + sizeof(padding_t) + 1;\n    if (len < 0) {\n        mylog(log_debug, \"len <0\\n\");\n        return -1;\n    }\n    return 0;\n}\nint recv_bare(raw_info_t &raw_info, char *&data, int &len)  // recv function with encryption but no anti replay,this is used when client and server verifys each other\n// you have to design the protocol carefully, so that you wont be affect by relay attack\n{\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    if (recv_raw0(raw_info, data, len) < 0) {\n        // printf(\"recv_raw_fail in recv bare\\n\");\n        return -1;\n    }\n\n    if (len >= max_data_len + 1) {\n        mylog(log_debug, \"data_len=%d >= max_data_len+1,ignored\", len);\n        return -1;\n    }\n\n    mylog(log_trace, \"data len=%d\\n\", len);\n    if ((raw_mode == mode_faketcp && (recv_info.syn == 1 || recv_info.ack != 1))) {\n        mylog(log_debug, \"unexpect packet type recv_info.syn=%d recv_info.ack=%d \\n\", recv_info.syn, recv_info.ack);\n        return -1;\n    }\n    return reserved_parse_bare(data, len, data, len);\n}\n\nint send_handshake(raw_info_t &raw_info, my_id_t id1, my_id_t id2, my_id_t id3)  // a warp for send_bare for sending handshake(this is not tcp handshake) easily\n{\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    char *data;\n    int len;\n    // len=sizeof(id_t)*3;\n    if (numbers_to_char(id1, id2, id3, data, len) != 0) return -1;\n    if (send_bare(raw_info, data, len) != 0) {\n        mylog(log_warn, \"send bare fail\\n\");\n        return -1;\n    }\n    return 0;\n}\n/*\nint recv_handshake(packet_info_t &info,id_t &id1,id_t &id2,id_t &id3)\n{\n        char * data;int len;\n        if(recv_bare(info,data,len)!=0) return -1;\n\n        if(char_to_numbers(data,len,id1,id2,id3)!=0) return -1;\n\n        return 0;\n}*/\n\nint send_safer(conn_info_t &conn_info, char type, const char *data, int len)  // safer transfer function with anti-replay,when mutually verification is done.\n{\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n    if (type != 'h' && type != 'd') {\n        mylog(log_warn, \"first byte is not h or d  ,%x\\n\", type);\n        return -1;\n    }\n\n    char send_data_buf[buf_len];  // buf for send data and send hb\n    char send_data_buf2[buf_len];\n\n    my_id_t n_tmp_id = htonl(conn_info.my_id);\n\n    memcpy(send_data_buf, &n_tmp_id, sizeof(n_tmp_id));\n\n    n_tmp_id = htonl(conn_info.oppsite_id);\n\n    memcpy(send_data_buf + sizeof(n_tmp_id), &n_tmp_id, sizeof(n_tmp_id));\n\n    anti_replay_seq_t n_seq = hton64(conn_info.blob->anti_replay.get_new_seq_for_send());\n\n    memcpy(send_data_buf + sizeof(n_tmp_id) * 2, &n_seq, sizeof(n_seq));\n\n    send_data_buf[sizeof(n_tmp_id) * 2 + sizeof(n_seq)] = type;\n    send_data_buf[sizeof(n_tmp_id) * 2 + sizeof(n_seq) + 1] = conn_info.my_roller;\n\n    memcpy(send_data_buf + 2 + sizeof(n_tmp_id) * 2 + sizeof(n_seq), data, len);  // data;\n\n    int new_len = len + sizeof(n_seq) + sizeof(n_tmp_id) * 2 + 2;\n\n    if (g_fix_gro == 0) {\n        if (my_encrypt(send_data_buf, send_data_buf2, new_len) != 0) {\n            return -1;\n        }\n    } else {\n        if (my_encrypt(send_data_buf, send_data_buf2 + 2, new_len) != 0) {\n            return -1;\n        }\n        write_u16(send_data_buf2, new_len);\n        new_len += 2;\n        if (cipher_mode == cipher_xor) {\n            send_data_buf2[0] ^= gro_xor[0];\n            send_data_buf2[1] ^= gro_xor[1];\n        } else if (cipher_mode == cipher_aes128cbc || cipher_mode == cipher_aes128cfb) {\n            aes_ecb_encrypt1(send_data_buf2);\n        }\n    }\n\n    if (send_raw0(conn_info.raw_info, send_data_buf2, new_len) != 0) return -1;\n\n    if (after_send_raw0(conn_info.raw_info) != 0) return -1;\n\n    return 0;\n}\nint send_data_safer(conn_info_t &conn_info, const char *data, int len, u32_t conv_num)  // a wrap for  send_safer for transfer data.\n{\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n    char send_data_buf[buf_len];\n    // send_data_buf[0]='d';\n    u32_t n_conv_num = htonl(conv_num);\n    memcpy(send_data_buf, &n_conv_num, sizeof(n_conv_num));\n\n    memcpy(send_data_buf + sizeof(n_conv_num), data, len);\n    int new_len = len + sizeof(n_conv_num);\n    send_safer(conn_info, 'd', send_data_buf, new_len);\n    return 0;\n}\nint reserved_parse_safer(conn_info_t &conn_info, const char *input, int input_len, char &type, char *&data, int &len)  // subfunction for recv_safer,allow overlap\n{\n    static char recv_data_buf[buf_len];\n\n    // char *recv_data_buf=recv_data_buf0; //fix strict alias warning\n    if (my_decrypt(input, recv_data_buf, input_len) != 0) {\n        // printf(\"decrypt fail\\n\");\n        return -1;\n    }\n\n    // char *a=recv_data_buf;\n    // id_t h_oppiste_id= ntohl (  *((id_t * )(recv_data_buf)) );\n    my_id_t h_oppsite_id;\n    memcpy(&h_oppsite_id, recv_data_buf, sizeof(h_oppsite_id));\n    h_oppsite_id = ntohl(h_oppsite_id);\n\n    // id_t h_my_id= ntohl (  *((id_t * )(recv_data_buf+sizeof(id_t)))    );\n    my_id_t h_my_id;\n    memcpy(&h_my_id, recv_data_buf + sizeof(my_id_t), sizeof(h_my_id));\n    h_my_id = ntohl(h_my_id);\n\n    // anti_replay_seq_t h_seq= ntoh64 (  *((anti_replay_seq_t * )(recv_data_buf  +sizeof(id_t) *2 ))   );\n    anti_replay_seq_t h_seq;\n    memcpy(&h_seq, recv_data_buf + sizeof(my_id_t) * 2, sizeof(h_seq));\n    h_seq = ntoh64(h_seq);\n\n    if (h_oppsite_id != conn_info.oppsite_id || h_my_id != conn_info.my_id) {\n        mylog(log_debug, \"id and oppsite_id verification failed %x %x %x %x \\n\", h_oppsite_id, conn_info.oppsite_id, h_my_id, conn_info.my_id);\n        return -1;\n    }\n\n    if (conn_info.blob->anti_replay.is_vaild(h_seq) != 1) {\n        mylog(log_debug, \"dropped replay packet\\n\");\n        return -1;\n    }\n\n    // printf(\"recv _len %d\\n \",recv_len);\n    data = recv_data_buf + sizeof(anti_replay_seq_t) + sizeof(my_id_t) * 2;\n    len = input_len - (sizeof(anti_replay_seq_t) + sizeof(my_id_t) * 2);\n\n    if (data[0] != 'h' && data[0] != 'd') {\n        mylog(log_debug, \"first byte is not h or d  ,%x\\n\", data[0]);\n        return -1;\n    }\n\n    uint8_t roller = data[1];\n\n    type = data[0];\n    data += 2;\n    len -= 2;\n\n    if (len < 0) {\n        mylog(log_debug, \"len <0 ,%d\\n\", len);\n        return -1;\n    }\n\n    if (roller != conn_info.oppsite_roller) {\n        conn_info.oppsite_roller = roller;\n        conn_info.last_oppsite_roller_time = get_current_time();\n    }\n    if (hb_mode == 0)\n        conn_info.my_roller++;  // increase on a successful recv\n    else if (hb_mode == 1) {\n        if (type == 'h')\n            conn_info.my_roller++;\n    } else {\n        mylog(log_fatal, \"unknow hb_mode\\n\");\n        myexit(-1);\n    }\n\n    if (after_recv_raw0(conn_info.raw_info) != 0) return -1;  // TODO might need to move this function to somewhere else after --fix-gro is introduced\n\n    return 0;\n}\nint recv_safer_notused(conn_info_t &conn_info, char &type, char *&data, int &len)  /// safer transfer function with anti-replay,when mutually verification is done.\n{\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n    char *recv_data;\n    int recv_len;\n    // static char recv_data_buf[buf_len];\n\n    if (recv_raw0(conn_info.raw_info, recv_data, recv_len) != 0) return -1;\n\n    return reserved_parse_safer(conn_info, recv_data, recv_len, type, data, len);\n}\n\nint recv_safer_multi(conn_info_t &conn_info, vector<char> &type_arr, vector<string> &data_arr)  /// safer transfer function with anti-replay,when mutually verification is done.\n{\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n    char *recv_data;\n    int recv_len;\n    assert(type_arr.empty());\n    assert(data_arr.empty());\n\n    if (recv_raw0(conn_info.raw_info, recv_data, recv_len) != 0) return -1;\n\n    char type;\n    char *data;\n    int len;\n\n    if (g_fix_gro == 0) {\n        int ret = reserved_parse_safer(conn_info, recv_data, recv_len, type, data, len);\n        if (ret == 0) {\n            type_arr.push_back(type);\n            data_arr.emplace_back(data, data + len);\n            // std::copy(data,data+len,data_arr[0]);\n        }\n        return 0;\n    } else {\n        char *ori_recv_data = recv_data;\n        int ori_recv_len = recv_len;\n        // mylog(log_debug,\"recv_len:%d\\n\",recv_len);\n        int cnt = 0;\n        while (recv_len >= 16) {\n            cnt++;\n            int single_len_no_xor;\n            single_len_no_xor = read_u16(recv_data);\n            int single_len;\n            if (cipher_mode == cipher_xor) {\n                recv_data[0] ^= gro_xor[0];\n                recv_data[1] ^= gro_xor[1];\n            } else if (cipher_mode == cipher_aes128cbc || cipher_mode == cipher_aes128cfb) {\n                aes_ecb_decrypt1(recv_data);\n            }\n            single_len = read_u16(recv_data);\n            recv_len -= 2;\n            recv_data += 2;\n            if (single_len > recv_len) {\n                mylog(log_debug, \"illegal single_len %d(%d), recv_len %d left,dropped\\n\", single_len, single_len_no_xor, recv_len);\n                break;\n            }\n            if (single_len > max_data_len) {\n                mylog(log_warn, \"single_len %d(%d) > %d, maybe you need to turn down mtu at upper level\\n\", single_len, single_len_no_xor, max_data_len);\n                break;\n            }\n\n            int ret = reserved_parse_safer(conn_info, recv_data, single_len, type, data, len);\n\n            if (ret != 0) {\n                mylog(log_debug, \"parse failed, offset= %d,single_len=%d(%d)\\n\", (int)(recv_data - ori_recv_data), single_len, single_len_no_xor);\n            } else {\n                type_arr.push_back(type);\n                data_arr.emplace_back(data, data + len);\n                // std::copy(data,data+len,data_arr[data_arr.size()-1]);\n            }\n            recv_data += single_len;\n            recv_len -= single_len;\n        }\n        if (cnt > 1) {\n            mylog(log_debug, \"got a suspected gro packet, %d packets recovered, recv_len=%d, loop_cnt=%d\\n\", (int)data_arr.size(), ori_recv_len, cnt);\n        }\n        return 0;\n    }\n}\n\nvoid server_clear_function(u64_t u64)  // used in conv_manager in server mode.for server we have to use one udp fd for one conv(udp connection),\n// so we have to close the fd when conv expires\n{\n    // int fd=int(u64);\n    //\tint ret;\n    // assert(fd!=0);\n    /*\n    epoll_event ev;\n\n    ev.events = EPOLLIN;\n    ev.data.u64 = u64;\n\n    ret = epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &ev);\n    if (ret!=0)\n    {\n            mylog(log_fatal,\"fd:%d epoll delete failed!!!!\\n\",fd);\n            myexit(-1);   //this shouldnt happen\n    }*/\n    // no need\n\n    /*ret= close(fd);  //closed fd should be auto removed from epoll\n\n    if (ret!=0)\n    {\n            mylog(log_fatal,\"close fd %d failed !!!!\\n\",fd);\n            myexit(-1);  //this shouldnt happen\n    }*/\n    // mylog(log_fatal,\"size:%d !!!!\\n\",conn_manager.udp_fd_mp.size());\n    fd64_t fd64 = u64;\n    assert(fd_manager.exist(fd64));\n    fd_manager.fd64_close(fd64);\n\n    // assert(conn_manager.udp_fd_mp.find(fd)!=conn_manager.udp_fd_mp.end());\n    // conn_manager.udp_fd_mp.erase(fd);\n}\n"
        },
        {
          "name": "connection.h",
          "type": "blob",
          "size": 10.0791015625,
          "content": "/*\n * connection.h\n *\n *  Created on: Sep 23, 2017\n *      Author: root\n */\n\n#ifndef CONNECTION_H_\n#define CONNECTION_H_\n\nextern int disable_anti_replay;\n\n#include \"connection.h\"\n#include \"common.h\"\n#include \"log.h\"\n#include \"network.h\"\n#include \"misc.h\"\n\nconst int disable_conv_clear = 0;  // a udp connection in the multiplexer is called conversation in this program,conv for short.\n\nstruct anti_replay_t  // its for anti replay attack,similar to openvpn/ipsec 's anti replay window\n{\n    u64_t max_packet_received;\n    char window[anti_replay_window_size];\n    anti_replay_seq_t anti_replay_seq;\n    anti_replay_seq_t get_new_seq_for_send();\n    anti_replay_t();\n    void re_init();\n\n    int is_vaild(u64_t seq);\n};  // anti_replay;\n\nvoid server_clear_function(u64_t u64);\n\n#include <type_traits>\n\ntemplate <class T>\nstruct conv_manager_t  // manage the udp connections\n{\n    // typedef hash_map map;\n    unordered_map<T, u32_t> data_to_conv;  // conv and u64 are both supposed to be uniq\n    unordered_map<u32_t, T> conv_to_data;\n\n    lru_collector_t<u32_t> lru;\n    // unordered_map<u32_t,u64_t> conv_last_active_time;\n\n    // unordered_map<u32_t,u64_t>::iterator clear_it;\n\n    void (*additional_clear_function)(T data) = 0;\n\n    long long last_clear_time;\n\n    conv_manager_t() {\n        // clear_it=conv_last_active_time.begin();\n        long long last_clear_time = 0;\n        additional_clear_function = 0;\n    }\n    ~conv_manager_t() {\n        clear();\n    }\n    int get_size() {\n        return conv_to_data.size();\n    }\n    void reserve() {\n        data_to_conv.reserve(10007);\n        conv_to_data.reserve(10007);\n        // conv_last_active_time.reserve(10007);\n\n        lru.mp.reserve(10007);\n    }\n    void clear() {\n        if (disable_conv_clear) return;\n\n        if (additional_clear_function != 0) {\n            for (auto it = conv_to_data.begin(); it != conv_to_data.end(); it++) {\n                // int fd=int((it->second<<32u)>>32u);\n                additional_clear_function(it->second);\n            }\n        }\n        data_to_conv.clear();\n        conv_to_data.clear();\n\n        lru.clear();\n        // conv_last_active_time.clear();\n\n        // clear_it=conv_last_active_time.begin();\n    }\n    u32_t get_new_conv() {\n        u32_t conv = get_true_random_number_nz();\n        while (conv_to_data.find(conv) != conv_to_data.end()) {\n            conv = get_true_random_number_nz();\n        }\n        return conv;\n    }\n    int is_conv_used(u32_t conv) {\n        return conv_to_data.find(conv) != conv_to_data.end();\n    }\n    int is_data_used(T data) {\n        return data_to_conv.find(data) != data_to_conv.end();\n    }\n    u32_t find_conv_by_data(T data) {\n        return data_to_conv[data];\n    }\n    T find_data_by_conv(u32_t conv) {\n        return conv_to_data[conv];\n    }\n    int update_active_time(u32_t conv) {\n        // return conv_last_active_time[conv]=get_current_time();\n        lru.update(conv);\n        return 0;\n    }\n    int insert_conv(u32_t conv, T data) {\n        data_to_conv[data] = conv;\n        conv_to_data[conv] = data;\n        // conv_last_active_time[conv]=get_current_time();\n        lru.new_key(conv);\n        return 0;\n    }\n    int erase_conv(u32_t conv) {\n        if (disable_conv_clear) return 0;\n        T data = conv_to_data[conv];\n        if (additional_clear_function != 0) {\n            additional_clear_function(data);\n        }\n        conv_to_data.erase(conv);\n        data_to_conv.erase(data);\n        // conv_last_active_time.erase(conv);\n        lru.erase(conv);\n        return 0;\n    }\n    int clear_inactive(char *info = 0) {\n        if (get_current_time() - last_clear_time > conv_clear_interval) {\n            last_clear_time = get_current_time();\n            return clear_inactive0(info);\n        }\n        return 0;\n    }\n    int clear_inactive0(char *info) {\n        if (disable_conv_clear) return 0;\n\n        unordered_map<u32_t, u64_t>::iterator it;\n        unordered_map<u32_t, u64_t>::iterator old_it;\n\n        // map<uint32_t,uint64_t>::iterator it;\n        int cnt = 0;\n        // it=clear_it;\n        int size = lru.size();\n        int num_to_clean = size / conv_clear_ratio + conv_clear_min;  // clear 1/10 each time,to avoid latency glitch\n\n        num_to_clean = min(num_to_clean, size);\n\n        my_time_t current_time = get_current_time();\n        for (;;) {\n            if (cnt >= num_to_clean) break;\n            if (lru.empty()) break;\n\n            u32_t conv;\n            my_time_t ts = lru.peek_back(conv);\n\n            if (current_time - ts < conv_timeout) break;\n\n            erase_conv(conv);\n            if (info == 0) {\n                mylog(log_info, \"conv %x cleared\\n\", conv);\n            } else {\n                mylog(log_info, \"[%s]conv %x cleared\\n\", info, conv);\n            }\n            cnt++;\n        }\n        return 0;\n    }\n\n    /*\nconv_manager_t();\n~conv_manager_t();\nint get_size();\nvoid reserve();\nvoid clear();\nu32_t get_new_conv();\nint is_conv_used(u32_t conv);\nint is_u64_used(T u64);\nu32_t find_conv_by_u64(T u64);\nT find_u64_by_conv(u32_t conv);\nint update_active_time(u32_t conv);\nint insert_conv(u32_t conv,T u64);\nint erase_conv(u32_t conv);\nint clear_inactive(char * ip_port=0);\nint clear_inactive0(char * ip_port);*/\n};  // g_conv_manager;\n\nstruct blob_t : not_copy_able_t  // used in conn_info_t.\n{\n    union tmp_union_t  // conv_manager_t is here to avoid copying when a connection is recovered\n    {\n        conv_manager_t<address_t> c;\n        conv_manager_t<u64_t> s;\n        // avoid templates here and there, avoid pointer and type cast\n        tmp_union_t() {\n            if (program_mode == client_mode) {\n                new (&c) conv_manager_t<address_t>();\n            } else {\n                assert(program_mode == server_mode);\n                new (&s) conv_manager_t<u64_t>();\n            }\n        }\n        ~tmp_union_t() {\n            if (program_mode == client_mode) {\n                c.~conv_manager_t<address_t>();\n            } else {\n                assert(program_mode == server_mode);\n                s.~conv_manager_t<u64_t>();\n            }\n        }\n    } conv_manager;\n\n    anti_replay_t anti_replay;  // anti_replay_t is here bc its huge,its allocation is delayed.\n};\nstruct conn_info_t  // stores info for a raw connection.for client ,there is only one connection,for server there can be thousand of connection since server can\n// handle multiple clients\n{\n    current_state_t state;\n\n    raw_info_t raw_info;\n    u64_t last_state_time;\n    u64_t last_hb_sent_time;  // client re-use this for retry\n    u64_t last_hb_recv_time;\n    // long long last_resent_time;\n\n    my_id_t my_id;\n    my_id_t oppsite_id;\n\n    fd64_t timer_fd64;\n    fd64_t udp_fd64;\n\n    my_id_t oppsite_const_id;\n\n    blob_t *blob;\n\n    uint8_t my_roller;\n    uint8_t oppsite_roller;\n    u64_t last_oppsite_roller_time;\n\n    //\tip_port_t ip_port;\n\n    /*\n            const uint32_t &ip=raw_info.recv_info.src_ip;\n            const uint16_t &port=raw_info.recv_info.src_port;\n\n    */\n    void recover(const conn_info_t &conn_info);\n    void re_init();\n    conn_info_t();\n    void prepare();\n    conn_info_t(const conn_info_t &b);\n    conn_info_t &operator=(const conn_info_t &b);\n    ~conn_info_t();\n};  // g_conn_info;\n\nstruct conn_manager_t  // manager for connections. for client,we dont need conn_manager since there is only one connection.for server we use one conn_manager for all connections\n{\n    u32_t ready_num;\n\n    // unordered_map<int,conn_info_t *> udp_fd_mp;  //a bit dirty to used pointer,but can void unordered_map search\n    // unordered_map<int,conn_info_t *> timer_fd_mp;//we can use pointer here since unordered_map.rehash() uses shallow copy\n\n    unordered_map<my_id_t, conn_info_t *> const_id_mp;\n\n    unordered_map<address_t, conn_info_t *> mp;  // put it at end so that it de-consturcts first\n\n    // lru_collector_t<address_t> lru;\n\n    unordered_map<address_t, conn_info_t *>::iterator clear_it;\n\n    long long last_clear_time;\n\n    conn_manager_t();\n    int exist(address_t addr);\n    /*\n    int insert(uint32_t ip,uint16_t port)\n    {\n            uint64_t u64=0;\n            u64=ip;\n            u64<<=32u;\n            u64|=port;\n            mp[u64];\n            return 0;\n    }*/\n    conn_info_t *&find_insert_p(address_t addr);  // be aware,the adress may change after rehash //not true?\n    conn_info_t &find_insert(address_t addr);     // be aware,the adress may change after rehash\n\n    int erase(unordered_map<address_t, conn_info_t *>::iterator erase_it);\n    int clear_inactive();\n    int clear_inactive0();\n};\n\nextern conn_manager_t conn_manager;\n\nvoid server_clear_function(u64_t u64);\n\nint send_bare(raw_info_t &raw_info, const char *data, int len);  // send function with encryption but no anti replay,this is used when client and server verifys each other\n// you have to design the protocol carefully, so that you wont be affect by relay attack\n// int reserved_parse_bare(const char *input,int input_len,char* & data,int & len); // a sub function used in recv_bare\nint recv_bare(raw_info_t &raw_info, char *&data, int &len);  // recv function with encryption but no anti replay,this is used when client and server verifys each other\n// you have to design the protocol carefully, so that you wont be affect by relay attack\nint send_handshake(raw_info_t &raw_info, my_id_t id1, my_id_t id2, my_id_t id3);         // a warp for send_bare for sending handshake(this is not tcp handshake) easily\nint send_safer(conn_info_t &conn_info, char type, const char *data, int len);            // safer transfer function with anti-replay,when mutually verification is done.\nint send_data_safer(conn_info_t &conn_info, const char *data, int len, u32_t conv_num);  // a wrap for  send_safer for transfer data.\n// int reserved_parse_safer(conn_info_t &conn_info,const char * input,int input_len,char &type,char* &data,int &len);//subfunction for recv_safer,allow overlap\n\n// int recv_safer(conn_info_t &conn_info,char &type,char* &data,int &len);///safer transfer function with anti-replay,when mutually verification is done.\n\nint recv_safer_multi(conn_info_t &conn_info, vector<char> &type_arr, vector<string> &data_arr);  // new api for handle gro\n#endif                                                                                           /* CONNECTION_H_ */\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "encrypt.cpp",
          "type": "blob",
          "size": 18.560546875,
          "content": "#include \"lib/aes-common.h\"\n#include \"lib/md5.h\"\n#include \"lib/pbkdf2-sha1.h\"\n#include \"lib/pbkdf2-sha256.h\"\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"encrypt.h\"\n#include \"common.h\"\n#include \"log.h\"\n\n// static uint64_t seq=1;\n\nstatic int8_t zero_iv[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};  // this prog use zero iv,you should make sure first block of data contains a random/nonce data\n/****\n * security of zero_iv + nonce first data block\n * https://crypto.stackexchange.com/questions/5421/using-cbc-with-a-fixed-iv-and-a-random-first-plaintext-block\n ****/\n\nchar normal_key[16 + 100];    // generated from key_string by md5. reserved for compatiblity\nconst int hmac_key_len = 64;  // generate 512bit long keys, use first n chars when needed\nconst int cipher_key_len = 64;\nunsigned char hmac_key_encrypt[hmac_key_len + 100];      // key for hmac\nunsigned char hmac_key_decrypt[hmac_key_len + 100];      // key for hmac\nunsigned char cipher_key_encrypt[cipher_key_len + 100];  // key for aes etc.\nunsigned char cipher_key_decrypt[cipher_key_len + 100];  // key for aes etc.\n\nchar gro_xor[256 + 100];  // dirty fix for gro\n\nunordered_map<int, const char *> auth_mode_tostring = {\n    {auth_none, \"none\"},\n    {auth_md5, \"md5\"},\n    {auth_crc32, \"crc32\"},\n    {auth_simple, \"simple\"},\n    {auth_hmac_sha1, \"hmac_sha1\"},\n};\n\nunordered_map<int, const char *> cipher_mode_tostring = {\n    {cipher_none, \"none\"},\n    {cipher_aes128cfb, \"aes128cfb\"},\n    {cipher_aes128cbc, \"aes128cbc\"},\n    {cipher_xor, \"xor\"},\n};\n// TODO aes-gcm\n\nauth_mode_t auth_mode = auth_md5;\ncipher_mode_t cipher_mode = cipher_aes128cbc;\nint is_hmac_used = 0;\n\nint aes128cfb_old = 0;\n\n// TODO key negotiation and forward secrecy\n\nint my_init_keys(const char *user_passwd, int is_client) {\n    char tmp[1000] = \"\";\n    int len = strlen(user_passwd);\n\n    strcat(tmp, user_passwd);\n\n    strcat(tmp, \"key1\");\n\n    md5((uint8_t *)tmp, strlen(tmp), (uint8_t *)normal_key);\n\n    if (auth_mode == auth_hmac_sha1)\n        is_hmac_used = 1;\n    if (is_hmac_used || g_fix_gro || 1) {\n        unsigned char salt[400] = \"\";\n        char salt_text[400] = \"udp2raw_salt1\";\n        md5((uint8_t *)(salt_text), strlen(salt_text), salt);  // TODO different salt per session\n\n        unsigned char pbkdf2_output1[400] = \"\";\n        PKCS5_PBKDF2_HMAC_SHA256((uint8_t *)user_passwd, len, salt, 16, 10000, 32, pbkdf2_output1);  // TODO argon2 ?\n\n        // unsigned char pbkdf2_output2[400]=\"\";\n        // PKCS5_PBKDF2_HMAC_SHA256(pbkdf2_output1,32,0,0,1, hmac_key_len*2+cipher_key_len*2,pbkdf2_output2);  //stretch it\n\n        const char *info_hmac_encrypt = \"hmac_key server-->client\";\n        const char *info_hmac_decrypt = \"hmac_key client-->server\";\n        const char *info_cipher_encrypt = \"cipher_key server-->client\";\n        const char *info_cipher_decrypt = \"cipher_key client-->server\";\n\n        if (is_client) {\n            const char *tmp;\n            tmp = info_hmac_encrypt;\n            info_hmac_encrypt = info_hmac_decrypt;\n            info_hmac_decrypt = tmp;\n            tmp = info_cipher_encrypt;\n            info_cipher_encrypt = info_cipher_decrypt;\n            info_cipher_decrypt = tmp;\n        } else {\n            // nop\n        }\n\n        assert(hkdf_sha256_expand(pbkdf2_output1, 32, (unsigned char *)info_cipher_encrypt, strlen(info_cipher_encrypt), cipher_key_encrypt, cipher_key_len) == 0);\n        assert(hkdf_sha256_expand(pbkdf2_output1, 32, (unsigned char *)info_cipher_decrypt, strlen(info_cipher_decrypt), cipher_key_decrypt, cipher_key_len) == 0);\n        assert(hkdf_sha256_expand(pbkdf2_output1, 32, (unsigned char *)info_hmac_encrypt, strlen(info_hmac_encrypt), hmac_key_encrypt, hmac_key_len) == 0);\n        assert(hkdf_sha256_expand(pbkdf2_output1, 32, (unsigned char *)info_hmac_decrypt, strlen(info_hmac_decrypt), hmac_key_decrypt, hmac_key_len) == 0);\n\n        const char *gro_info = \"gro\";\n        assert(hkdf_sha256_expand(pbkdf2_output1, 32, (unsigned char *)gro_info, strlen(gro_info), (unsigned char *)gro_xor, 256) == 0);\n    }\n\n    print_binary_chars(normal_key, 16);\n    print_binary_chars((char *)hmac_key_encrypt, hmac_key_len);\n    print_binary_chars((char *)hmac_key_decrypt, hmac_key_len);\n    print_binary_chars((char *)cipher_key_encrypt, cipher_key_len);\n    print_binary_chars((char *)cipher_key_decrypt, cipher_key_len);\n\n    return 0;\n}\n/*\n *  this function comes from  http://www.hackersdelight.org/hdcodetxt/crc.c.txt\n */\nunsigned int crc32h(unsigned char *message, int len) {\n    int i, crc;\n    unsigned int byte, c;\n    const unsigned int g0 = 0xEDB88320, g1 = g0 >> 1,\n                       g2 = g0 >> 2, g3 = g0 >> 3, g4 = g0 >> 4, g5 = g0 >> 5,\n                       g6 = (g0 >> 6) ^ g0, g7 = ((g0 >> 6) ^ g0) >> 1;\n\n    i = 0;\n    crc = 0xFFFFFFFF;\n    while (i != len) {  // Get next byte.\n        byte = message[i];\n        crc = crc ^ byte;\n        c = ((crc << 31 >> 31) & g7) ^ ((crc << 30 >> 31) & g6) ^\n            ((crc << 29 >> 31) & g5) ^ ((crc << 28 >> 31) & g4) ^\n            ((crc << 27 >> 31) & g3) ^ ((crc << 26 >> 31) & g2) ^\n            ((crc << 25 >> 31) & g1) ^ ((crc << 24 >> 31) & g0);\n        crc = ((unsigned)crc >> 8) ^ c;\n        i = i + 1;\n    }\n    return ~crc;\n}\n\n/*\n void sum(const unsigned  char *data,int len,unsigned char*  res) {\n   memset(res,0,sizeof(int));\n   for(int i=0,j=0;i<len;i++,j++)\n   {\n           if(j==4) j=0;\n           res[j]+=data[i];\n   }\n\n   return ;\n}*/\n\nvoid simple_hash(unsigned char *str, int len, unsigned char res[8])  // djb2+ sdbm\n{\n    u32_t hash = 5381;\n    u32_t hash2 = 0;\n    int c;\n    int i = 0;\n    while (c = *str++, i++ != len) {\n        // hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n        hash = ((hash << 5) + hash) ^ c; /* (hash * 33) ^ c */\n        hash2 = c + (hash2 << 6) + (hash2 << 16) - hash2;\n    }\n\n    hash = htonl(hash);\n    hash2 = htonl(hash2);\n    memcpy(res, &hash, sizeof(hash));\n    memcpy(res + sizeof(hash), &hash2, sizeof(hash2));\n}\n\nint auth_md5_cal(const char *data, char *output, int &len) {\n    memcpy(output, data, len);  // TODO inefficient code\n    md5((unsigned char *)output, len, (unsigned char *)(output + len));\n    len += 16;\n    return 0;\n}\n\nint auth_hmac_sha1_cal(const char *data, char *output, int &len) {\n    mylog(log_trace, \"auth_hmac_sha1_cal() is called\\n\");\n    memcpy(output, data, len);  // TODO inefficient code\n    sha1_hmac(hmac_key_encrypt, 20, (const unsigned char *)data, len, (unsigned char *)(output + len));\n    // use key len of 20 instead of hmac_key_len, \"extra length would not significantly increase the function strength\" (rfc2104)\n    len += 20;\n    return 0;\n}\n\nint auth_hmac_sha1_verify(const char *data, int &len) {\n    mylog(log_trace, \"auth_hmac_sha1_verify() is called\\n\");\n    if (len < 20) {\n        mylog(log_trace, \"auth_hmac_sha1_verify len<20\\n\");\n        return -1;\n    }\n    char res[20];\n\n    sha1_hmac(hmac_key_decrypt, 20, (const unsigned char *)data, len - 20, (unsigned char *)(res));\n\n    if (memcmp(res, data + len - 20, 20) != 0) {\n        mylog(log_trace, \"auth_hmac_sha1 check failed\\n\");\n        return -2;\n    }\n    len -= 20;\n    return 0;\n}\n\nint auth_crc32_cal(const char *data, char *output, int &len) {\n    memcpy(output, data, len);  // TODO inefficient code\n    unsigned int ret = crc32h((unsigned char *)output, len);\n    unsigned int ret_n = htonl(ret);\n    memcpy(output + len, &ret_n, sizeof(unsigned int));\n    len += sizeof(unsigned int);\n    return 0;\n}\n\nint auth_simple_cal(const char *data, char *output, int &len) {\n    // char res[4];\n    memcpy(output, data, len);  // TODO inefficient code\n    simple_hash((unsigned char *)output, len, (unsigned char *)(output + len));\n    len += 8;\n    return 0;\n}\nint auth_simple_verify(const char *data, int &len) {\n    if (len < 8) return -1;\n    unsigned char res[8];\n    len -= 8;\n    simple_hash((unsigned char *)data, len, res);\n    if (memcmp(res, data + len, 8) != 0)\n        return -1;\n    return 0;\n}\n\nint auth_none_cal(const char *data, char *output, int &len) {\n    memcpy(output, data, len);\n    return 0;\n}\nint auth_md5_verify(const char *data, int &len) {\n    if (len < 16) {\n        mylog(log_trace, \"auth_md5_verify len<16\\n\");\n        return -1;\n    }\n    char md5_res[16];\n\n    md5((unsigned char *)data, len - 16, (unsigned char *)md5_res);\n\n    if (memcmp(md5_res, data + len - 16, 16) != 0) {\n        mylog(log_trace, \"auth_md5_verify md5 check failed\\n\");\n        return -2;\n    }\n    len -= 16;\n    return 0;\n}\nint auth_none_verify(const char *data, int &len) {\n    return 0;\n}\n\nint cipher_xor_encrypt(const char *data, char *output, int &len, char *key) {\n    int i, j;\n    for (i = 0, j = 0; i < len; i++, j++) {\n        if (j == 16) j = 0;\n        output[i] = data[i] ^ key[j];\n    }\n    return 0;\n}\nint cipher_xor_decrypt(const char *data, char *output, int &len, char *key) {\n    int i, j;\n    // char tmp[buf_len];\n    // len=len/16*16+1;\n    // AES128_CBC_decrypt_buffer((uint8_t *)tmp, (uint8_t *)input, len, (uint8_t *)key, (uint8_t *)iv);\n    // for(i=0;i<len;i++)\n    // input[i]=tmp[i];\n    for (i = 0, j = 0; i < len; i++, j++) {\n        if (j == 16) j = 0;\n        output[i] = data[i] ^ key[j];\n    }\n    return 0;\n}\n\nint padding(char *data, int &data_len, int padding_num) {\n    int old_len = data_len;\n    data_len += 1;\n    if (data_len % padding_num != 0) {\n        data_len = (data_len / padding_num) * padding_num + padding_num;\n    }\n    unsigned char *p = (unsigned char *)&data[data_len - 1];\n    *p = (data_len - old_len);\n    return 0;\n}\n\nint de_padding(const char *data, int &data_len, int padding_num) {\n    if (data_len == 0) return -1;\n    if ((uint8_t)data[data_len - 1] > padding_num) return -1;\n    data_len -= (uint8_t)data[data_len - 1];\n    if (data_len < 0) {\n        return -1;\n    }\n    return 0;\n}\nvoid aes_ecb_encrypt(const char *data, char *output) {\n    static int first_time = 1;\n    char *key = (char *)cipher_key_encrypt;\n    if (aes_key_optimize) {\n        if (first_time == 0)\n            key = 0;\n        else\n            first_time = 0;\n    }\n    AES_ECB_encrypt_buffer((uint8_t *)data, (uint8_t *)key, (uint8_t *)output);\n}\nvoid aes_ecb_encrypt1(char *data) {\n    char buf[16];\n    memcpy(buf, data, 16);\n    aes_ecb_encrypt(buf, data);\n}\nvoid aes_ecb_decrypt(const char *data, char *output) {\n    static int first_time = 1;\n    char *key = (char *)cipher_key_decrypt;\n    if (aes_key_optimize) {\n        if (first_time == 0)\n            key = 0;\n        else\n            first_time = 0;\n    }\n    AES_ECB_decrypt_buffer((uint8_t *)data, (uint8_t *)key, (uint8_t *)output);\n}\nvoid aes_ecb_decrypt1(char *data) {\n    char buf[16];\n    memcpy(buf, data, 16);\n    aes_ecb_decrypt(buf, data);\n}\nint cipher_aes128cbc_encrypt(const char *data, char *output, int &len, char *key) {\n    static int first_time = 1;\n\n    char buf[buf_len];\n    memcpy(buf, data, len);  // TODO inefficient code\n\n    if (padding(buf, len, 16) < 0) return -1;\n\n    if (aes_key_optimize) {\n        if (first_time == 0)\n            key = 0;\n        else\n            first_time = 0;\n    }\n\n    AES_CBC_encrypt_buffer((unsigned char *)output, (unsigned char *)buf, len, (unsigned char *)key, (unsigned char *)zero_iv);\n    return 0;\n}\nint cipher_aes128cfb_encrypt(const char *data, char *output, int &len, char *key) {\n    static int first_time = 1;\n    assert(len >= 16);\n\n    char buf[buf_len];\n    memcpy(buf, data, len);  // TODO inefficient code\n    if (aes_key_optimize) {\n        if (first_time == 0)\n            key = 0;\n        else\n            first_time = 0;\n    }\n    if (!aes128cfb_old) {\n        aes_ecb_encrypt(data, buf);  // encrypt the first block\n    }\n\n    AES_CFB_encrypt_buffer((unsigned char *)output, (unsigned char *)buf, len, (unsigned char *)key, (unsigned char *)zero_iv);\n    return 0;\n}\nint auth_crc32_verify(const char *data, int &len) {\n    if (len < int(sizeof(unsigned int))) {\n        mylog(log_debug, \"auth_crc32_verify len<%d\\n\", int(sizeof(unsigned int)));\n        return -1;\n    }\n    unsigned int ret = crc32h((unsigned char *)data, len - sizeof(unsigned int));\n    unsigned int ret_n = htonl(ret);\n\n    if (memcmp(data + len - sizeof(unsigned int), &ret_n, sizeof(unsigned int)) != 0) {\n        mylog(log_debug, \"auth_crc32_verify memcmp fail\\n\");\n        return -1;\n    }\n    len -= sizeof(unsigned int);\n    return 0;\n}\nint cipher_none_encrypt(const char *data, char *output, int &len, char *key) {\n    memcpy(output, data, len);\n    return 0;\n}\nint cipher_aes128cbc_decrypt(const char *data, char *output, int &len, char *key) {\n    static int first_time = 1;\n    if (len % 16 != 0) {\n        mylog(log_debug, \"len%%16!=0\\n\");\n        return -1;\n    }\n    if (aes_key_optimize) {\n        if (first_time == 0)\n            key = 0;\n        else\n            first_time = 0;\n    }\n    AES_CBC_decrypt_buffer((unsigned char *)output, (unsigned char *)data, len, (unsigned char *)key, (unsigned char *)zero_iv);\n    if (de_padding(output, len, 16) < 0) return -1;\n    return 0;\n}\nint cipher_aes128cfb_decrypt(const char *data, char *output, int &len, char *key) {\n    static int first_time = 1;\n    if (len < 16) return -1;\n\n    if (aes_key_optimize) {\n        if (first_time == 0)\n            key = 0;\n        else\n            first_time = 0;\n    }\n\n    AES_CFB_decrypt_buffer((unsigned char *)output, (unsigned char *)data, len, (unsigned char *)key, (unsigned char *)zero_iv);\n\n    if (!aes128cfb_old)\n        aes_ecb_decrypt1(output);  // decrypt the first block\n    // if(de_padding(output,len,16)<0) return -1;\n    return 0;\n}\n\nint cipher_none_decrypt(const char *data, char *output, int &len, char *key) {\n    memcpy(output, data, len);\n    return 0;\n}\n\nint auth_cal(const char *data, char *output, int &len) {\n    mylog(log_trace, \"auth:%d\\n\", auth_mode);\n    switch (auth_mode) {\n        case auth_crc32:\n            return auth_crc32_cal(data, output, len);\n        case auth_md5:\n            return auth_md5_cal(data, output, len);\n        case auth_simple:\n            return auth_simple_cal(data, output, len);\n        case auth_none:\n            return auth_none_cal(data, output, len);\n        case auth_hmac_sha1:\n            return auth_hmac_sha1_cal(data, output, len);\n        // default:\treturn auth_md5_cal(data,output,len);//default;\n        default:\n            assert(0 == 1);\n    }\n    return -1;\n}\nint auth_verify(const char *data, int &len) {\n    mylog(log_trace, \"auth:%d\\n\", auth_mode);\n    switch (auth_mode) {\n        case auth_crc32:\n            return auth_crc32_verify(data, len);\n        case auth_md5:\n            return auth_md5_verify(data, len);\n        case auth_simple:\n            return auth_simple_verify(data, len);\n        case auth_none:\n            return auth_none_verify(data, len);\n        case auth_hmac_sha1:\n            return auth_hmac_sha1_verify(data, len);\n        // default:\treturn auth_md5_verify(data,len);//default\n        default:\n            assert(0 == 1);\n    }\n    return -1;\n}\nint cipher_encrypt(const char *data, char *output, int &len, char *key) {\n    mylog(log_trace, \"cipher:%d\\n\", cipher_mode);\n    switch (cipher_mode) {\n        case cipher_aes128cbc:\n            return cipher_aes128cbc_encrypt(data, output, len, key);\n        case cipher_aes128cfb:\n            return cipher_aes128cfb_encrypt(data, output, len, key);\n        case cipher_xor:\n            return cipher_xor_encrypt(data, output, len, key);\n        case cipher_none:\n            return cipher_none_encrypt(data, output, len, key);\n        // default:return cipher_aes128cbc_encrypt(data,output,len, key);\n        default:\n            assert(0 == 1);\n    }\n    return -1;\n}\nint cipher_decrypt(const char *data, char *output, int &len, char *key) {\n    mylog(log_trace, \"cipher:%d\\n\", cipher_mode);\n    switch (cipher_mode) {\n        case cipher_aes128cbc:\n            return cipher_aes128cbc_decrypt(data, output, len, key);\n        case cipher_aes128cfb:\n            return cipher_aes128cfb_decrypt(data, output, len, key);\n        case cipher_xor:\n            return cipher_xor_decrypt(data, output, len, key);\n        case cipher_none:\n            return cipher_none_decrypt(data, output, len, key);\n        //\tdefault:\treturn cipher_aes128cbc_decrypt(data,output,len,key);\n        default:\n            assert(0 == 1);\n    }\n    return -1;\n}\n\nint encrypt_AE(const char *data, char *output, int &len /*,char * key*/) {\n    mylog(log_trace, \"encrypt_AE is called\\n\");\n    char buf[buf_len];\n    char buf2[buf_len];\n    memcpy(buf, data, len);\n    if (cipher_encrypt(buf, buf2, len, (char *)cipher_key_encrypt) != 0) {\n        mylog(log_debug, \"cipher_encrypt failed \");\n        return -1;\n    }\n    if (auth_cal(buf2, output, len) != 0) {\n        mylog(log_debug, \"auth_cal failed \");\n        return -1;\n    }\n\n    // printf(\"%d %x %x\\n\",len,(int)(output[0]),(int)(output[1]));\n    // print_binary_chars(output,len);\n\n    // use encrypt-then-MAC scheme\n    return 0;\n}\n\nint decrypt_AE(const char *data, char *output, int &len /*,char * key*/) {\n    mylog(log_trace, \"decrypt_AE is called\\n\");\n    // printf(\"%d %x %x\\n\",len,(int)(data[0]),(int)(data[1]));\n    // print_binary_chars(data,len);\n\n    if (auth_verify(data, len) != 0) {\n        mylog(log_debug, \"auth_verify failed\\n\");\n        return -1;\n    }\n    if (cipher_decrypt(data, output, len, (char *)cipher_key_decrypt) != 0) {\n        mylog(log_debug, \"cipher_decrypt failed \\n\");\n        return -1;\n    }\n    return 0;\n}\n\nint my_encrypt(const char *data, char *output, int &len /*,char * key*/) {\n    if (len < 0) {\n        mylog(log_trace, \"len<0\");\n        return -1;\n    }\n    if (len > max_data_len) {\n        mylog(log_warn, \"len>max_data_len\");\n        return -1;\n    }\n\n    if (is_hmac_used)\n        return encrypt_AE(data, output, len);\n\n    char buf[buf_len];\n    char buf2[buf_len];\n    memcpy(buf, data, len);\n    if (auth_cal(buf, buf2, len) != 0) {\n        mylog(log_debug, \"auth_cal failed \");\n        return -1;\n    }\n    if (cipher_encrypt(buf2, output, len, normal_key) != 0) {\n        mylog(log_debug, \"cipher_encrypt failed \");\n        return -1;\n    }\n    return 0;\n}\n\nint my_decrypt(const char *data, char *output, int &len /*,char * key*/) {\n    if (len < 0) return -1;\n    if (len > max_data_len) {\n        mylog(log_warn, \"len>max_data_len\");\n        return -1;\n    }\n\n    if (is_hmac_used)\n        return decrypt_AE(data, output, len);\n\n    if (cipher_decrypt(data, output, len, normal_key) != 0) {\n        mylog(log_debug, \"cipher_decrypt failed \\n\");\n        return -1;\n    }\n    if (auth_verify(output, len) != 0) {\n        mylog(log_debug, \"auth_verify failed\\n\");\n        return -1;\n    }\n\n    return 0;\n}\n\nint encrypt_AEAD(uint8_t *data, uint8_t *output, int &len, uint8_t *key, uint8_t *header, int hlen) {\n    // TODO\n    return -1;\n}\n\nint decrypt_AEAD(uint8_t *data, uint8_t *output, int &len, uint8_t *key, uint8_t *header, int hlen) {\n    // TODO\n    return -1;\n}\n"
        },
        {
          "name": "encrypt.h",
          "type": "blob",
          "size": 1.5029296875,
          "content": "#ifndef UDP2RAW_ENCRYPTION_H_\n#define UDP2RAW_ENCRYPTION_H_\n\n//#include \"aes.h\"\n//#include \"md5.h\"\n#include \"common.h\"\n\n// using namespace std;\n// extern char key[16];\n\nconst int aes_key_optimize = 1;  // if enabled,once you used a key for aes,you cant change it anymore\nextern int aes128cfb_old;\n\nint my_init_keys(const char *, int);\n\nint my_encrypt(const char *data, char *output, int &len);\nint my_decrypt(const char *data, char *output, int &len);\n\nunsigned short csum(const unsigned short *ptr, int nbytes);\n\nenum auth_mode_t { auth_none = 0,\n                   auth_md5,\n                   auth_crc32,\n                   auth_simple,\n                   auth_hmac_sha1,\n                   auth_end };\n\nenum cipher_mode_t { cipher_none = 0,\n                     cipher_aes128cbc,\n                     cipher_xor,\n                     cipher_aes128cfb,\n                     cipher_end };\n\nextern auth_mode_t auth_mode;\nextern cipher_mode_t cipher_mode;\n\nextern unordered_map<int, const char *> auth_mode_tostring;\nextern unordered_map<int, const char *> cipher_mode_tostring;\n\nextern char gro_xor[256 + 100];\n\nint cipher_decrypt(const char *data, char *output, int &len, char *key);  // internal interface ,exposed for test only\nint cipher_encrypt(const char *data, char *output, int &len, char *key);  // internal interface ,exposed for test only\n\nvoid aes_ecb_encrypt(const char *data, char *output);\nvoid aes_ecb_decrypt(const char *data, char *output);\n\nvoid aes_ecb_encrypt1(char *data);\nvoid aes_ecb_decrypt1(char *data);\n\n#endif\n"
        },
        {
          "name": "example.conf",
          "type": "blob",
          "size": 0.361328125,
          "content": "# Basically this file is the equivalent to splitting the command line options into multiple lines\n# Each line should contain an option\n\n# This is client\n-c\n# Or use -s if you use it on server side\n# Define local address\n-l 127.0.0.1:56789\n# Define remote address\n-r 45.66.77.88:45678\n# Password\n-k my_awesome_password\n# Mode\n--raw-mode faketcp\n# Log Level\n--log-level 4\n"
        },
        {
          "name": "fd_manager.cpp",
          "type": "blob",
          "size": 1.25,
          "content": "/*\n * fd_manager.cpp\n *\n *  Created on: Sep 25, 2017\n *      Author: root\n */\n\n#include \"fd_manager.h\"\nint fd_manager_t::fd_exist(int fd) {\n    return fd_to_fd64_mp.find(fd) != fd_to_fd64_mp.end();\n}\nint fd_manager_t::exist(fd64_t fd64) {\n    return fd64_to_fd_mp.find(fd64) != fd64_to_fd_mp.end();\n}\nint fd_manager_t::to_fd(fd64_t fd64) {\n    assert(exist(fd64));\n    return fd64_to_fd_mp[fd64];\n}\nvoid fd_manager_t::fd64_close(fd64_t fd64) {\n    assert(exist(fd64));\n    int fd = fd64_to_fd_mp[fd64];\n    fd64_to_fd_mp.erase(fd64);\n    fd_to_fd64_mp.erase(fd);\n    if (exist_info(fd64)) {\n        fd_info_mp.erase(fd64);\n    }\n    // assert(close(fd)==0);\n    sock_close(fd);\n}\nvoid fd_manager_t::reserve(int n) {\n    fd_to_fd64_mp.reserve(n);\n    fd64_to_fd_mp.reserve(n);\n    fd_info_mp.reserve(n);\n}\nu64_t fd_manager_t::create(int fd) {\n    assert(!fd_exist(fd));\n    fd64_t fd64 = counter++;\n    fd_to_fd64_mp[fd] = fd64;\n    fd64_to_fd_mp[fd64] = fd;\n    return fd64;\n}\nfd_manager_t::fd_manager_t() {\n    counter = u32_t(-1);\n    counter += 100;\n    reserve(10007);\n}\nfd_info_t& fd_manager_t::get_info(fd64_t fd64) {\n    assert(exist(fd64));\n    return fd_info_mp[fd64];\n}\nint fd_manager_t::exist_info(fd64_t fd64) {\n    return fd_info_mp.find(fd64) != fd_info_mp.end();\n}\n"
        },
        {
          "name": "fd_manager.h",
          "type": "blob",
          "size": 0.9853515625,
          "content": "/*\n * fd_manager.h\n *\n *  Created on: Sep 25, 2017\n *      Author: root\n */\n\n#ifndef FD_MANAGER_H_\n#define FD_MANAGER_H_\n\n#include \"common.h\"\n//#include \"packet.h\"\n#include \"connection.h\"\n\nstruct fd_info_t {\n    // ip_port_t ip_port;\n    conn_info_t *p_conn_info;\n};\n\nstruct fd_manager_t  // conver fd to a uniq 64bit number,avoid fd value conflict caused by close and re-create\n// this class is not strictly necessary,it just makes epoll fd handling easier\n{\n    fd_info_t &get_info(fd64_t fd64);\n    int exist_info(fd64_t);\n    int exist(fd64_t fd64);\n    int to_fd(fd64_t);\n    void fd64_close(fd64_t fd64);\n    void reserve(int n);\n    u64_t create(int fd);\n    fd_manager_t();\n\n   private:\n    u64_t counter;\n    unordered_map<int, fd64_t> fd_to_fd64_mp;\n    unordered_map<fd64_t, int> fd64_to_fd_mp;\n    unordered_map<fd64_t, fd_info_t> fd_info_mp;\n    int fd_exist(int fd);\n    // void remove_fd(int fd);\n    // fd64_t fd_to_fd64(int fd);\n};\n\nextern fd_manager_t fd_manager;\n#endif /* FD_MANAGER_H_ */\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "libev",
          "type": "tree",
          "content": null
        },
        {
          "name": "log.cpp",
          "type": "blob",
          "size": 1.3408203125,
          "content": "#include \"log.h\"\n#include \"misc.h\"\n\nint log_level = log_info;\n\nint enable_log_position = 0;\nint enable_log_color = 1;\n\nvoid log0(const char* file, const char* function, int line, int level, const char* str, ...) {\n    if (level > log_level) return;\n    if (level > log_trace || level < 0) return;\n\n    time_t timer;\n    char buffer[100];\n    struct tm* tm_info;\n\n    time(&timer);\n    tm_info = localtime(&timer);\n\n    if (enable_log_color)\n        printf(\"%s\", log_color[level]);\n\n    strftime(buffer, 100, \"%Y-%m-%d %H:%M:%S\", tm_info);\n    printf(\"[%s][%s]\", buffer, log_text[level]);\n\n    if (enable_log_position) printf(\"[%s,func:%s,line:%d]\", file, function, line);\n\n    va_list vlist;\n    va_start(vlist, str);\n    vfprintf(stdout, str, vlist);\n    va_end(vlist);\n    if (enable_log_color)\n        printf(\"%s\", RESET);\n\n    // printf(\"\\n\");\n    // if(enable_log_color)\n    // printf(log_color[level]);\n    fflush(stdout);\n\n    if (log_level == log_fatal) {\n        about_to_exit = 1;\n    }\n}\n\nvoid log_bare(int level, const char* str, ...) {\n    if (level > log_level) return;\n    if (level > log_trace || level < 0) return;\n    if (enable_log_color)\n        printf(\"%s\", log_color[level]);\n    va_list vlist;\n    va_start(vlist, str);\n    vfprintf(stdout, str, vlist);\n    va_end(vlist);\n    if (enable_log_color)\n        printf(\"%s\", RESET);\n    fflush(stdout);\n}\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 1.080078125,
          "content": "\n#ifndef UDP2RAW_LOG_MYLOG_H_\n#define UDP2RAW_LOG_MYLOG_H_\n\n#include \"common.h\"\n\nusing namespace std;\n\n#define RED \"\\x1B[31m\"\n#define GRN \"\\x1B[32m\"\n#define YEL \"\\x1B[33m\"\n#define BLU \"\\x1B[34m\"\n#define MAG \"\\x1B[35m\"\n#define CYN \"\\x1B[36m\"\n#define WHT \"\\x1B[37m\"\n#define RESET \"\\x1B[0m\"\n\nconst int log_never = 0;\nconst int log_fatal = 1;\nconst int log_error = 2;\nconst int log_warn = 3;\nconst int log_info = 4;\nconst int log_debug = 5;\nconst int log_trace = 6;\nconst int log_end = 7;\n\nconst char log_text[][20] = {\"NEVER\", \"FATAL\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\", \"TRACE\", \"\"};\nconst char log_color[][20] = {RED, RED, RED, YEL, GRN, MAG, \"\"};\n\nextern int log_level;\nextern int enable_log_position;\nextern int enable_log_color;\n\n#ifdef MY_DEBUG\n#define mylog(__first_argu__dummy_abcde__, ...) printf(__VA_ARGS__)\n\n#else\n#define mylog(...) log0(__FILE__, __FUNCTION__, __LINE__, __VA_ARGS__)\n#endif\n\n//#define mylog(__first_argu__dummy_abcde__,...) {;}\n\nvoid log0(const char* file, const char* function, int line, int level, const char* str, ...);\n\nvoid log_bare(int level, const char* str, ...);\n\n#endif\n"
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 3.005859375,
          "content": "#include \"common.h\"\n#include \"network.h\"\n#include \"connection.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"lib/md5.h\"\n#include \"encrypt.h\"\n#include \"fd_manager.h\"\n\nvoid sigpipe_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigpipe, ignored\");\n}\n\nvoid sigterm_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigterm, exit\");\n    myexit(0);\n}\n\nvoid sigint_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigint, exit\");\n    myexit(0);\n}\n\nint client_event_loop();\nint server_event_loop();\n\nint main(int argc, char *argv[]) {\n    assert(sizeof(unsigned short) == 2);\n    assert(sizeof(unsigned int) == 4);\n    assert(sizeof(unsigned long long) == 8);\n\n#ifdef UDP2RAW_MP\n    init_ws();\n#endif\n\n    dup2(1, 2);  // redirect stderr to stdout\n#if defined(__MINGW32__)\n    enable_log_color = 0;\n#endif\n\n    pre_process_arg(argc, argv);\n\n    ev_signal signal_watcher_sigpipe;\n    ev_signal signal_watcher_sigterm;\n    ev_signal signal_watcher_sigint;\n\n    if (program_mode == client_mode) {\n        struct ev_loop *loop = ev_default_loop(0);\n#if !defined(__MINGW32__)\n        ev_signal_init(&signal_watcher_sigpipe, sigpipe_cb, SIGPIPE);\n        ev_signal_start(loop, &signal_watcher_sigpipe);\n#endif\n        ev_signal_init(&signal_watcher_sigterm, sigterm_cb, SIGTERM);\n        ev_signal_start(loop, &signal_watcher_sigterm);\n\n        ev_signal_init(&signal_watcher_sigint, sigint_cb, SIGINT);\n        ev_signal_start(loop, &signal_watcher_sigint);\n    } else {\n#ifdef UDP2RAW_LINUX\n        signal(SIGINT, signal_handler);\n        signal(SIGHUP, signal_handler);\n        signal(SIGKILL, signal_handler);\n        signal(SIGTERM, signal_handler);\n        signal(SIGQUIT, signal_handler);\n#else\n        mylog(log_fatal, \"server mode not supported in multi-platform version\\n\");\n        myexit(-1);\n#endif\n    }\n#if !defined(__MINGW32__)\n    if (geteuid() != 0) {\n        mylog(log_warn, \"root check failed, it seems like you are using a non-root account. we can try to continue, but it may fail. If you want to run udp2raw as non-root, you have to add iptables rule manually, and grant udp2raw CAP_NET_RAW capability, check README.md in repo for more info.\\n\");\n    } else {\n        mylog(log_warn, \"you can run udp2raw with non-root account for better security. check README.md in repo for more info.\\n\");\n    }\n#endif\n\n    mylog(log_info, \"remote_ip=[%s], make sure this is a vaild IP address\\n\", remote_addr.get_ip());\n\n    // init_random_number_fd();\n    srand(get_true_random_number_nz());\n    const_id = get_true_random_number_nz();\n\n    mylog(log_info, \"const_id:%x\\n\", const_id);\n\n    my_init_keys(key_string, program_mode == client_mode ? 1 : 0);\n\n    iptables_rule();\n\n#ifdef UDP2RAW_LINUX\n    init_raw_socket();\n#endif\n\n    if (program_mode == client_mode) {\n        client_event_loop();\n    } else {\n#ifdef UDP2RAW_LINUX\n        server_event_loop();\n#else\n        mylog(log_fatal, \"server mode not supported in multi-platform version\\n\");\n        myexit(-1);\n#endif\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 6.0771484375,
          "content": "cc_cross=/home/wangyu/Desktop/arm-2014.05/bin/arm-none-linux-gnueabi-g++\ncc_local=g++\ncc_mips24kc_be=/toolchains/lede-sdk-17.01.2-ar71xx-generic_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-mips_24kc_gcc-5.4.0_musl-1.1.16/bin/mips-openwrt-linux-musl-g++\ncc_mips24kc_le=/toolchains/lede-sdk-17.01.2-ramips-mt7621_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-mipsel_24kc_gcc-5.4.0_musl-1.1.16/bin/mipsel-openwrt-linux-musl-g++\ncc_arm= /toolchains/lede-sdk-17.01.2-bcm53xx_gcc-5.4.0_musl-1.1.16_eabi.Linux-x86_64/staging_dir/toolchain-arm_cortex-a9_gcc-5.4.0_musl-1.1.16_eabi/bin/arm-openwrt-linux-c++\ncc_mingw_cross=i686-w64-mingw32-g++-posix\ncc_mac_cross=o64-clang++ -stdlib=libc++\ncc_x86=/toolchains/lede-sdk-17.01.2-x86-generic_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-i386_pentium4_gcc-5.4.0_musl-1.1.16/bin/i486-openwrt-linux-c++\ncc_amd64=/toolchains/lede-sdk-17.01.2-x86-64_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-x86_64_gcc-5.4.0_musl-1.1.16/bin/x86_64-openwrt-linux-c++\n#cc_bcm2708=/home/wangyu/raspberry/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++ \n\n\nFLAGS= -std=c++11   -Wall -Wextra -Wno-unused-variable -Wno-unused-parameter -Wno-missing-field-initializers ${OPT}\n\nCOMMON=main.cpp lib/md5.cpp lib/pbkdf2-sha1.cpp lib/pbkdf2-sha256.cpp encrypt.cpp log.cpp network.cpp common.cpp  connection.cpp misc.cpp fd_manager.cpp client.cpp server.cpp -lpthread\n\nSOURCES0= $(COMMON) lib/aes_faster_c/aes.cpp lib/aes_faster_c/wrapper.cpp\nSOURCES= ${SOURCES0} my_ev.cpp -isystem libev\nSOURCES_AES_ACC= $(COMMON) $(wildcard lib/aes_acc/aes*.c) my_ev.cpp -isystem libev\nPCAP=\"-lpcap\"\nMP=\"-DUDP2RAW_MP\"\n\n\nNAME=udp2raw\n\nTARGETS=amd64 arm amd64_hw_aes arm_asm_aes mips24kc_be mips24kc_be_asm_aes x86 x86_asm_aes mips24kc_le mips24kc_le_asm_aes\n\nTAR=${NAME}_binaries.tar.gz `echo ${TARGETS}|sed -r 's/([^ ]+)/${NAME}_\\1/g'` version.txt\n\nTARGETS_MP= mingw_cross mingw_cross_wepoll mac_cross\n\nexport STAGING_DIR=/tmp/    #just for supress warning of staging_dir not define\n\n# targets for nativei (non-cross) compile \nall:git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -ggdb -static -O2\n\n#dynamic link\ndynamic: git_version\n\t${cc_local}   -o ${NAME}_$@          -I. ${SOURCES} ${FLAGS} -lrt -O2\n\n#targes for general cross compile\n\ncross:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -O2\n\ncross2:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -static -lgcc_eh -O2\n\ncross3:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -static -O2\n\n#targets only for debug purpose\nfast: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -ggdb\ndebug: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -Wformat-nonliteral -D MY_DEBUG  -ggdb\ndebug2: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -Wformat-nonliteral -ggdb -fsanitize=address\n\n#targets only for 'make release'\n\nmips24kc_be: git_version\n\t${cc_mips24kc_be}  -o ${NAME}_$@   -I. ${SOURCES} ${FLAGS} -lrt -lgcc_eh -static -O2\nmips24kc_be_asm_aes: git_version\n\t${cc_mips24kc_be}  -o ${NAME}_$@   -I. ${SOURCES_AES_ACC} ${FLAGS} -lrt -lgcc_eh -static -O2 lib/aes_acc/asm/mips_be.S\nmips24kc_le: git_version\n\t${cc_mips24kc_le}  -o ${NAME}_$@   -I. ${SOURCES} ${FLAGS} -lrt -lgcc_eh -static -O2\nmips24kc_le_asm_aes: git_version\n\t${cc_mips24kc_le}  -o ${NAME}_$@   -I. ${SOURCES_AES_ACC} ${FLAGS} -lrt -lgcc_eh -static -O2 lib/aes_acc/asm/mips.S\namd64:git_version\n\t${cc_amd64}   -o ${NAME}_$@    -I. ${SOURCES} ${FLAGS} -lrt -static -O2 -lgcc_eh -ggdb\namd64_hw_aes:git_version\n\t${cc_amd64}   -o ${NAME}_$@   -I. ${SOURCES_AES_ACC} ${FLAGS} -lrt -static -O2 lib/aes_acc/asm/x64.S -lgcc_eh -ggdb\nx86:git_version\n\t${cc_x86}   -o ${NAME}_$@      -I. ${SOURCES} ${FLAGS} -lrt -static -O2 -lgcc_eh -ggdb\nx86_asm_aes:git_version\n\t${cc_x86}   -o ${NAME}_$@    -I. ${SOURCES_AES_ACC} ${FLAGS} -lrt -static -O2 lib/aes_acc/asm/x86.S -lgcc_eh -ggdb\narm:git_version\n\t${cc_arm}   -o ${NAME}_$@      -I. ${SOURCES} ${FLAGS} -lrt -static -O2 -lgcc_eh\narm_asm_aes:git_version\n\t${cc_arm}   -o ${NAME}_$@    -I. ${SOURCES_AES_ACC} ${FLAGS} -lrt -static -O2 lib/aes_acc/asm/arm.S -lgcc_eh\n\nrelease: ${TARGETS}\n\tcp git_version.h version.txt\n\ttar -zcvf ${TAR}\n\n#targets for multi-platform version (native compile)\ncygwin:git_version\n\t${cc_local}   -o ${NAME}_$@          -I. ${SOURCES} pcap_wrapper.cpp ${FLAGS} -lrt -ggdb -static -O2 -D_GNU_SOURCE ${MP}\n\nmingw:git_version\n\t${cc_local}   -o ${NAME}_$@         -I. ${SOURCES} pcap_wrapper.cpp ${FLAGS} -ggdb -static -O2 -lws2_32 ${MP}\n\nmingw_wepoll:git_version\n\t${cc_local}   -o ${NAME}_$@        -I. ${SOURCES0} pcap_wrapper.cpp ${FLAGS} -ggdb -static -O2 -DNO_LIBEV_EMBED -D_WIN32 -lev -lws2_32 ${MP}\n\nlinux:git_version\n\t${cc_local}   -o ${NAME}_$@          -I. ${SOURCES} ${PCAP} ${FLAGS} -lrt -ggdb -static -O2 ${MP}\n\nfreebsd:git_version\n\t${cc_local}   -o ${NAME}_$@        -I. ${SOURCES} ${PCAP} ${FLAGS} -lrt -ggdb -static -libverbs -O2 ${MP}\n\nmac:git_version\n\t${cc_local}   -o ${NAME}_$@        -I. ${SOURCES} ${PCAP} ${FLAGS} -ggdb -O2 ${MP}\n\n#targets for multi-platform version (cross compile)\n\nmingw_cross:git_version\n\t${cc_mingw_cross}   -o ${NAME}_mp.exe          -I. ${SOURCES} pcap_wrapper.cpp ${FLAGS} -ggdb -static -O2 -lws2_32 ${MP}\n\nmingw_cross_wepoll:git_version\n\t${cc_mingw_cross}   -o ${NAME}_mp_wepoll.exe   -I. ${SOURCES0} pcap_wrapper.cpp ${FLAGS} -ggdb -static -O2 -DNO_LIBEV_EMBED -D_WIN32 -lev -lws2_32 ${MP}\n\nmac_cross:git_version\n\t${cc_mac_cross}   -o ${NAME}_mp_mac            -I. ${SOURCES} ${PCAP} ${FLAGS} -ggdb -O2 ${MP}\n\nrelease_mp:${TARGETS_MP}\n\tcp git_version.h version.txt\n\ttar -zcvf ${NAME}_mp_binaries.tar.gz ${NAME}_mp.exe ${NAME}_mp_wepoll.exe ${NAME}_mp_mac version.txt\n\n\nclean:\t\n\trm -f ${TAR}\n\trm -f ${NAME} ${NAME}_cross ${NAME}.exe ${NAME}_wepoll.exe ${NAME}_mac\n\trm -f ${NAME}_mp_binaries.tar.gz ${NAME}_mp.exe ${NAME}_mp_wepoll.exe ${NAME}_mp_mac\n\trm -f git_version.h\n\ngit_version:\n\t    echo \"const char *gitversion = \\\"$(shell git rev-parse HEAD)\\\";\" > git_version.h\n"
        },
        {
          "name": "misc.cpp",
          "type": "blob",
          "size": 53.85546875,
          "content": "/*\n * misc.cpp\n *\n *  Created on: Sep 23, 2017\n *      Author: root\n */\n#include \"git_version.h\"\n#include \"common.h\"\n#include \"encrypt.h\"\n#include \"misc.h\"\n#include \"network.h\"\n#include \"connection.h\"\n#include \"fd_manager.h\"\n\nint hb_mode = 1;\nint hb_len = 1200;\nchar hb_buf[buf_len];\n\nint mtu_warn = 1375;  // if a packet larger than mtu warn is receviced,there will be a warning\n\nint max_rst_to_show = 15;\n\nint max_rst_allowed = -1;\n\nint enable_dns_resolve = 0;\n\nint ttl_value = 64;\n\nfd_manager_t fd_manager;\n\n// char remote_address[max_address_len]=\"\";\n// char local_ip[100]=\"0.0.0.0\", remote_ip[100]=\"255.255.255.255\",source_ip[100]=\"0.0.0.0\";//local_ip is for -l option,remote_ip for -r option,source for --source-ip\n// u32_t local_ip_uint32,remote_ip_uint32,source_ip_uint32;//convert from last line.\n// int local_port = -1, remote_port=-1,source_port=0;//similiar to local_ip  remote_ip,buf for port.source_port=0 indicates --source-port is not enabled\naddress_t local_addr, remote_addr, source_addr;\n\nmy_ip_t bind_addr;\n\nint source_port = -1;\n\nint bind_addr_used = 0;\nint force_source_ip = 0;  // if --source-ip is enabled\nint force_source_port = 0;\n\nmy_id_t const_id = 0;  // an id used for connection recovery,its generated randomly,it never change since its generated\n\nint udp_fd = -1;   // for client only. client use this fd to listen and handle udp connection\nint bind_fd = -1;  // bind only,never send or recv.  its just a dummy fd for bind,so that other program wont occupy the same port\n#ifdef UDP2RAW_LINUX\nint epollfd = -1;   // fd for epoll\nint timer_fd = -1;  // the general timer fd for client and server.for server this is not the only timer find,every connection has a timer fd.\n#endif\nint fail_time_counter = 0;      // determine if the max_fail_time is reached\nint epoll_trigger_counter = 0;  // for debug only\nint debug_flag = 0;             // for debug only\n\nint simple_rule = 0;                 // deprecated.\nint keep_rule = 0;                   // whether to monitor the iptables rule periodly,re-add if losted\nint auto_add_iptables_rule = 0;      // if -a is set\nint generate_iptables_rule = 0;      // if -g is set\nint generate_iptables_rule_add = 0;  // if --gen-add is set\n\nint retry_on_error = 0;\n\nint debug_resend = 0;  // debug only\n\nchar key_string[1000] = \"secret key\";  // -k option\n\nchar fifo_file[1000] = \"\";\n\nint clear_iptables = 0;\nint wait_xtables_lock = 0;\n#ifdef UDP2RAW_LINUX\nstring iptables_command0 = \"iptables/ip6tables \";\nstring iptables_command = \"\";\nstring iptables_pattern = \"\";\nint iptables_rule_added = 0;\nint iptables_rule_keeped = 0;\nint iptables_rule_keep_index = 0;\n#endif\n\nprogram_mode_t program_mode = unset_mode;  // 0 unset; 1client 2server\nraw_mode_t raw_mode = mode_faketcp;\nu32_t raw_ip_version = (u32_t)-1;\nunordered_map<int, const char *> raw_mode_tostring = {{mode_faketcp, \"faketcp\"}, {mode_udp, \"udp\"}, {mode_icmp, \"icmp\"}};\n\nint about_to_exit = 0;\n\nint socket_buf_size = 1024 * 1024;\n// int force_socket_buf=0;\n\n// char lower_level_arg[1000];\n#ifdef UDP2RAW_LINUX\nint process_lower_level_arg()  // handle --lower-level option\n{\n    lower_level = 1;\n    if (strcmp(optarg, \"auto\") == 0) {\n        return 0;\n    }\n\n    lower_level_manual = 1;\n    if (strchr(optarg, '#') == 0) {\n        mylog(log_fatal,\n              \"lower-level parameter invaild,check help page for format\\n\");\n        myexit(-1);\n    }\n    lower_level = 1;\n    u32_t hw[6];\n    memset(hw, 0, sizeof(hw));\n    sscanf(optarg, \"%[^#]#%x:%x:%x:%x:%x:%x\", if_name, &hw[0], &hw[1], &hw[2],\n           &hw[3], &hw[4], &hw[5]);\n\n    mylog(log_warn,\n          \"make sure this is correct:   if_name=<%s>  dest_mac_adress=<%02x:%02x:%02x:%02x:%02x:%02x>  \\n\",\n          if_name, hw[0], hw[1], hw[2], hw[3], hw[4], hw[5]);\n    for (int i = 0; i < 6; i++) {\n        dest_hw_addr[i] = uint8_t(hw[i]);\n    }\n    return 0;\n}\n#endif\nvoid print_help() {\n    char git_version_buf[100] = {0};\n    strncpy(git_version_buf, gitversion, 10);\n    printf(\"udp2raw-tunnel\\n\");\n    printf(\"git version:%s    \", git_version_buf);\n    printf(\"build date:%s %s\\n\", __DATE__, __TIME__);\n    printf(\"repository: https://github.com/wangyu-/udp2raw-tunnel\\n\");\n    printf(\"\\n\");\n#ifdef UDP2RAW_MP\n#ifdef NO_LIBNET\n    printf(\"libnet is disabled at compile time\\n\");\n    printf(\"\\n\");\n#endif\n#endif\n    printf(\"usage:\\n\");\n    printf(\"    run as client : ./this_program -c -l local_listen_ip:local_port -r server_address:server_port  [options]\\n\");\n    printf(\"    run as server : ./this_program -s -l server_listen_ip:server_port -r remote_address:remote_port  [options]\\n\");\n    printf(\"\\n\");\n    printf(\"common options,these options must be same on both side:\\n\");\n    printf(\"    --raw-mode            <string>        available values:faketcp(default),udp,icmp and easy-faketcp\\n\");\n    printf(\"    -k,--key              <string>        password to gen symetric key,default:\\\"secret key\\\"\\n\");\n    printf(\"    --cipher-mode         <string>        available values:aes128cfb,aes128cbc(default),xor,none\\n\");\n    printf(\"    --auth-mode           <string>        available values:hmac_sha1,md5(default),crc32,simple,none\\n\");\n    printf(\"    -a,--auto-rule                        auto add (and delete) iptables rule\\n\");\n    printf(\"    -g,--gen-rule                         generate iptables rule then exit,so that you can copy and\\n\");\n    printf(\"                                          add it manually.overrides -a\\n\");\n    printf(\"    --disable-anti-replay                 disable anti-replay,not suggested\\n\");\n    printf(\"    --fix-gro                             try to fix huge packet caused by GRO. this option is at an early stage.\\n\");\n    printf(\"                                          make sure client and server are at same version.\\n\");\n\n    // printf(\"\\n\");\n    printf(\"client options:\\n\");\n    printf(\"    --source-ip           <ip>            force source-ip for raw socket\\n\");\n    printf(\"    --source-port         <port>          force source-port for raw socket,tcp/udp only\\n\");\n    printf(\"                                          this option disables port changing while re-connecting\\n\");\n    //\tprintf(\"                                          \\n\");\n    printf(\"other options:\\n\");\n    printf(\"    --conf-file           <string>        read options from a configuration file instead of command line.\\n\");\n    printf(\"                                          check example.conf in repo for format\\n\");\n    printf(\"    --fifo                <string>        use a fifo(named pipe) for sending commands to the running program,\\n\");\n    printf(\"                                          check readme.md in repository for supported commands.\\n\");\n    printf(\"    --log-level           <number>        0:never    1:fatal   2:error   3:warn \\n\");\n    printf(\"                                          4:info (default)     5:debug   6:trace\\n\");\n    //\tprintf(\"\\n\");\n    printf(\"    --log-position                        enable file name,function name,line number in log\\n\");\n    printf(\"    --disable-color                       disable log color\\n\");\n    printf(\"    --disable-bpf                         disable the kernel space filter,most time its not necessary\\n\");\n    printf(\"                                          unless you suspect there is a bug\\n\");\n//\tprintf(\"\\n\");\n#ifdef UDP2RAW_LINUX\n    printf(\"    --dev                 <string>        bind raw socket to a device, not necessary but improves performance\\n\");\n#endif\n    printf(\"    --sock-buf            <number>        buf size for socket,>=10 and <=10240,unit:kbyte,default:1024\\n\");\n    printf(\"    --force-sock-buf                      bypass system limitation while setting sock-buf\\n\");\n    printf(\"    --seq-mode            <number>        seq increase mode for faketcp:\\n\");\n    printf(\"                                          0:static header,do not increase seq and ack_seq\\n\");\n    printf(\"                                          1:increase seq for every packet,simply ack last seq\\n\");\n    printf(\"                                          2:increase seq randomly, about every 3 packets,simply ack last seq\\n\");\n    printf(\"                                          3:simulate an almost real seq/ack procedure(default)\\n\");\n    printf(\"                                          4:similiar to 3,but do not consider TCP Option Window_Scale,\\n\");\n    printf(\"                                          maybe useful when firewall doesnt support TCP Option \\n\");\n    //\tprintf(\"\\n\");\n    printf(\"    --lower-level         <string>        send packets at OSI level 2, format:'if_name#dest_mac_adress'\\n\");\n    printf(\"                                          ie:'eth0#00:23:45:67:89:b9'.or try '--lower-level auto' to obtain\\n\");\n    printf(\"                                          the parameter automatically,specify it manually if 'auto' failed\\n\");\n    printf(\"    --wait-lock                           wait for xtables lock while invoking iptables, need iptables v1.4.20+\\n\");\n    printf(\"    --gen-add                             generate iptables rule and add it permanently,then exit.overrides -g\\n\");\n    printf(\"    --keep-rule                           monitor iptables and auto re-add if necessary.implys -a\\n\");\n    printf(\"    --hb-len              <number>        length of heart-beat packet, >=0 and <=1500\\n\");\n    printf(\"    --mtu-warn            <number>        mtu warning threshold, unit:byte, default:1375\\n\");\n    printf(\"    --clear                               clear any iptables rules added by this program.overrides everything\\n\");\n    printf(\"    --retry-on-error                      retry on error, allow to start udp2raw before network is initialized\\n\");\n    printf(\"    -h,--help                             print this help message\\n\");\n    // printf(\"common options,these options must be same on both side\\n\");\n}\n\nint load_config(char *file_name, int &argc, vector<string> &argv)  // load conf file and append to argv\n{\n    // Load configurations from config_file instead of the command line.\n    // See config.example for example configurations\n    std::ifstream conf_file(file_name);\n    std::string line;\n    if (conf_file.fail()) {\n        mylog(log_fatal, \"conf_file %s open failed,reason :%s\\n\", file_name, get_sock_error());\n        myexit(-1);\n    }\n    while (std::getline(conf_file, line)) {\n        auto res = parse_conf_line(line);\n\n        argc += res.size();\n        for (int i = 0; i < (int)res.size(); i++) {\n            argv.push_back(res[i]);\n        }\n    }\n    conf_file.close();\n\n    return 0;\n}\n\nint process_log_level(int argc, char *argv[])  // process  --log-level and --disable-cloer --log-postion options\n{\n    int i, j, k;\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"--log-level\") == 0) {\n            if (i < argc - 1) {\n                sscanf(argv[i + 1], \"%d\", &log_level);\n                if (0 <= log_level && log_level < log_end) {\n                } else {\n                    log_bare(log_fatal, \"invalid log_level\\n\");\n                    myexit(-1);\n                }\n            }\n        }\n        if (strcmp(argv[i], \"--enable-color\") == 0) {\n            enable_log_color = 1;\n        }\n        if (strcmp(argv[i], \"--disable-color\") == 0) {\n            enable_log_color = 0;\n        }\n        if (strcmp(argv[i], \"--log-position\") == 0) {\n            enable_log_position = 1;\n        }\n    }\n    return 0;\n}\nvoid process_arg(int argc, char *argv[])  // process all options\n{\n    int i, j, k, opt;\n\n    int option_index = 0;\n\n    char options[] = \"l:r:schk:ag\";\n    static struct option long_options[] =\n        {\n            /* These options set a flag. */\n            {\"source-ip\", required_argument, 0, 1},\n            {\"source-port\", required_argument, 0, 1},\n            {\"log-level\", required_argument, 0, 1},\n            {\"key\", required_argument, 0, 'k'},\n            {\"auth-mode\", required_argument, 0, 1},\n            {\"cipher-mode\", required_argument, 0, 1},\n            {\"raw-mode\", required_argument, 0, 1},\n            {\"disable-color\", no_argument, 0, 1},\n            {\"enable-color\", no_argument, 0, 1},\n            {\"log-position\", no_argument, 0, 1},\n            {\"disable-bpf\", no_argument, 0, 1},\n            {\"disable-anti-replay\", no_argument, 0, 1},\n            {\"auto-rule\", no_argument, 0, 'a'},\n            {\"gen-rule\", no_argument, 0, 'g'},\n            {\"gen-add\", no_argument, 0, 1},\n            {\"debug\", no_argument, 0, 1},\n            {\"retry-on-error\", no_argument, 0, 1},\n            {\"clear\", no_argument, 0, 1},\n            {\"simple-rule\", no_argument, 0, 1},\n            {\"keep-rule\", no_argument, 0, 1},\n            {\"lower-level\", required_argument, 0, 1},\n            {\"sock-buf\", required_argument, 0, 1},\n            {\"seq-mode\", required_argument, 0, 1},\n            {\"conf-file\", required_argument, 0, 1},\n            {\"force-sock-buf\", no_argument, 0, 1},\n            {\"wait-lock\", no_argument, 0, 1},\n            {\"random-drop\", required_argument, 0, 1},\n            {\"fifo\", required_argument, 0, 1},\n            {\"hb-mode\", required_argument, 0, 1},\n            {\"hb-len\", required_argument, 0, 1},\n            {\"mtu-warn\", required_argument, 0, 1},\n            {\"max-rst-to-show\", required_argument, 0, 1},\n            {\"max-rst-allowed\", required_argument, 0, 1},\n            {\"set-ttl\", required_argument, 0, 1},\n            {\"dev\", required_argument, 0, 1},\n            {\"dns-resolve\", no_argument, 0, 1},\n            {\"easy-tcp\", no_argument, 0, 1},\n#ifdef UDP2RAW_MP\n            {\"pcap-send\", no_argument, 0, 1},\n            {\"no-pcap-mutex\", no_argument, 0, 1},\n#endif\n            {\"fix-gro\", no_argument, 0, 1},\n            {NULL, 0, 0, 0}};\n\n    process_log_level(argc, argv);\n\n    set<string> all_options;\n    map<string, string> shortcut_map;\n\n    all_options.insert(\"--help\");\n    all_options.insert(\"-h\");\n    string dummy = \"\";\n    for (i = 0; i < (int)strlen(options); i++) {\n        char val = options[i];\n        if ((val >= '0' && val <= '9') || (val >= 'a' && val <= 'z') || (val >= 'A' && val <= 'Z')) {\n            all_options.insert(dummy + '-' + val);\n        }\n    }\n    for (i = 0; i < int(sizeof(long_options) / sizeof(long_options[0])); i++) {\n        if (long_options[i].name == NULL) break;\n        int val = long_options[i].val;\n        if ((val >= '0' && val <= '9') || (val >= 'a' && val <= 'z') || (val >= 'A' && val <= 'Z')) {\n            shortcut_map[dummy + \"--\" + long_options[i].name] = dummy + \"-\" + char(val);\n        }\n        all_options.insert(dummy + \"--\" + long_options[i].name);\n    }\n\n    for (i = 0; i < argc; i++) {\n        int len = strlen(argv[i]);\n        if (len == 0) {\n            mylog(log_fatal, \"found an empty string in options\\n\");\n            myexit(-1);\n        }\n        if (len == 1 && argv[i][0] == '-') {\n            mylog(log_fatal, \"invaild option '-' in argv\\n\");\n            myexit(-1);\n        }\n        if (len == 2 && argv[i][0] == '-' && argv[i][1] == '-') {\n            mylog(log_fatal, \"invaild option '--' in argv\\n\");\n            myexit(-1);\n        }\n    }\n\n    mylog(log_info, \"argc=%d \", argc);\n\n    for (i = 0; i < argc; i++) {\n        log_bare(log_info, \"%s \", argv[i]);\n    }\n    log_bare(log_info, \"\\n\");\n\n    // string dummy=\"\";\n    for (i = +1; i < argc; i++) {\n        if (argv[i][0] != '-') continue;\n        string a = argv[i];\n        if (a[0] == '-' && a[1] != '-')\n            a = dummy + a[0] + a[1];\n\n        if (all_options.find(a.c_str()) == all_options.end()) {\n            mylog(log_fatal, \"invaild option %s\\n\", a.c_str());\n            myexit(-1);\n        }\n        for (j = i + 1; j < argc; j++) {\n            if (argv[j][0] != '-') continue;\n\n            string b = argv[j];\n\n            if (b[0] == '-' && b[1] != '-')\n                b = dummy + b[0] + b[1];\n\n            if (shortcut_map.find(a) != shortcut_map.end())\n                a = shortcut_map[a];\n            if (shortcut_map.find(b) != shortcut_map.end())\n                b = shortcut_map[b];\n            if (a == b) {\n                mylog(log_fatal, \"%s duplicates with %s\\n\", argv[i], argv[j]);\n                myexit(-1);\n            }\n        }\n    }\n\n    int no_l = 1, no_r = 1;\n    while ((opt = getopt_long(argc, argv, options, long_options, &option_index)) != -1) {\n        // string opt_key;\n        // opt_key+=opt;\n        switch (opt) {\n            case 'l':\n                no_l = 0;\n                local_addr.from_str(optarg);\n                if (local_addr.get_port() == 22) {\n                    mylog(log_fatal, \"port 22 not allowed\\n\");\n                    myexit(-1);\n                }\n                /*\n                if (strchr(optarg, ':') != 0) {\n                        sscanf(optarg, \"%[^:]:%d\", local_ip, &local_port);\n                        if(local_port==22)\n                        {\n                                mylog(log_fatal,\"port 22 not allowed\\n\");\n                                myexit(-1);\n                        }\n                } else {\n                        mylog(log_fatal,\"invalid parameter for -l ,%s,should be ip:port\\n\",optarg);\n                        myexit(-1);\n                }*/\n                break;\n            case 'r':\n                no_r = 0;\n                remote_addr.from_str(optarg);\n                if (remote_addr.get_port() == 22) {\n                    mylog(log_fatal, \"port 22 not allowed\\n\");\n                    myexit(-1);\n                }\n                /*\n                if (strchr(optarg, ':') != 0) {\n                        sscanf(optarg, \"%[^:]:%d\", remote_address, &remote_port);\n                        if(remote_port==22)\n                        {\n                                mylog(log_fatal,\"port 22 not allowed\\n\");\n                                myexit(-1);\n                        }\n                } else {\n                        mylog(log_fatal,\"invalid parameter for -r ,%s,should be ip:port\\n\",optarg);\n                        myexit(-1);\n                }*/\n                break;\n            case 's':\n                if (program_mode == 0) {\n                    program_mode = server_mode;\n                } else {\n                    mylog(log_fatal, \"-s /-c has already been set,conflict\\n\");\n                    myexit(-1);\n                }\n                break;\n            case 'c':\n                if (program_mode == 0) {\n                    program_mode = client_mode;\n                } else {\n                    mylog(log_fatal, \"-s /-c has already been set,conflict\\n\");\n                    myexit(-1);\n                }\n                break;\n            case 'h':\n                break;\n            case 'a':\n                if (is_udp2raw_mp) {\n                    mylog(log_fatal, \"-a not supported in this version, check -g or --raw-mode easyfaketcp\\n\");\n                    myexit(-1);\n                }\n                auto_add_iptables_rule = 1;\n                break;\n            case 'g':\n                generate_iptables_rule = 1;\n                break;\n            case 'k':\n                mylog(log_debug, \"parsing key option\\n\");\n                sscanf(optarg, \"%s\", key_string);\n                break;\n            case 1:\n                mylog(log_debug, \"option_index: %d\\n\", option_index);\n                if (strcmp(long_options[option_index].name, \"clear\") == 0) {\n                    if (is_udp2raw_mp) {\n                        mylog(log_fatal, \"--clear not supported in this version\\n\");\n                        myexit(-1);\n                    }\n\n                    clear_iptables = 1;\n                } else if (strcmp(long_options[option_index].name, \"source-ip\") == 0) {\n                    mylog(log_debug, \"parsing long option :source-ip\\n\");\n                    // sscanf(optarg, \"%s\", source_ip);\n                    source_addr.from_str_ip_only(optarg);\n                    mylog(log_debug, \"source: %s\\n\", source_addr.get_ip());\n                    force_source_ip = 1;\n                } else if (strcmp(long_options[option_index].name, \"source-port\") == 0) {\n                    mylog(log_debug, \"parsing long option :source-port\\n\");\n                    sscanf(optarg, \"%d\", &source_port);\n                    mylog(log_info, \"source: %d\\n\", source_port);\n                    force_source_port = 1;\n                } else if (strcmp(long_options[option_index].name, \"raw-mode\") == 0) {\n                    /*\n                    for(i=0;i<mode_end;i++)\n                    {\n                            if(strcmp(optarg,raw_mode_tostring[i])==0)\n                            {\n                                    //printf(\"%d i\\n\",i);\n                                    //printf(\"%s\",raw_mode_tostring[i]);\n                                    raw_mode=(raw_mode_t)i;\n                                    break;\n                            }\n                    }\n                    if(i==mode_end)\n                    {\n                            mylog(log_fatal,\"no such raw_mode %s\\n\",optarg);\n                            myexit(-1);\n                    }\n                     */\n                    if (strcmp(optarg, \"easyfaketcp\") == 0 || strcmp(optarg, \"easy_faketcp\") == 0 || strcmp(optarg, \"easy-faketcp\") == 0) {\n                        raw_mode = mode_faketcp;\n                        use_tcp_dummy_socket = 1;\n                    } else {\n                        for (i = 0; i < mode_end; i++) {\n                            if (strcmp(optarg, raw_mode_tostring[i]) == 0) {\n                                // printf(\"%d i\\n\",i);\n                                // printf(\"%s\",raw_mode_tostring[i]);\n                                raw_mode = (raw_mode_t)i;\n                                break;\n                            }\n                        }\n                        if (i == mode_end) {\n                            mylog(log_fatal, \"no such raw_mode %s\\n\", optarg);\n                            myexit(-1);\n                        }\n                    }\n                } else if (strcmp(long_options[option_index].name, \"auth-mode\") == 0) {\n                    for (i = 0; i < auth_end; i++) {\n                        if (strcmp(optarg, auth_mode_tostring[i]) == 0) {\n                            auth_mode = (auth_mode_t)i;\n                            if (auth_mode == auth_none) {\n                                disable_anti_replay = 1;\n                            }\n                            break;\n                        }\n                    }\n                    if (i == auth_end) {\n                        mylog(log_fatal, \"no such auth_mode %s\\n\", optarg);\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"cipher-mode\") == 0) {\n                    string s = optarg;\n                    if (s == \"aes128cfb_0\") {\n                        s = \"aes128cfb\";\n                        aes128cfb_old = 1;\n                        mylog(log_warn, \"aes128cfb_0 is used\\n\");\n                    }\n                    for (i = 0; i < cipher_end; i++) {\n                        if (strcmp(s.c_str(), cipher_mode_tostring[i]) == 0) {\n                            cipher_mode = (cipher_mode_t)i;\n                            break;\n                        }\n                    }\n                    if (i == cipher_end) {\n                        mylog(log_fatal, \"no such cipher_mode %s\\n\", optarg);\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"log-level\") == 0) {\n                } else if (strcmp(long_options[option_index].name, \"lower-level\") == 0) {\n                    if (is_udp2raw_mp) {\n                        mylog(log_fatal, \"--lower-level not supported in this version\\n\");\n                        myexit(-1);\n                    }\n\n#ifdef UDP2RAW_LINUX\n                    process_lower_level_arg();\n#endif\n                    // process_lower_level_arg();\n                    // lower_level=1;\n                    // strcpy(lower_level_arg,optarg);\n                } else if (strcmp(long_options[option_index].name, \"simple-rule\") == 0) {\n                    if (is_udp2raw_mp) {\n                        mylog(log_fatal, \"--simple-rule not supported in this version\\n\");\n                        myexit(-1);\n                    }\n                    simple_rule = 1;\n                } else if (strcmp(long_options[option_index].name, \"keep-rule\") == 0) {\n                    if (is_udp2raw_mp) {\n                        mylog(log_fatal, \"--keep-rule not supported in this version\\n\");\n                        myexit(-1);\n                    }\n                    keep_rule = 1;\n                } else if (strcmp(long_options[option_index].name, \"gen-add\") == 0) {\n                    if (is_udp2raw_mp) {\n                        mylog(log_fatal, \"--gen-add not supported in this version\\n\");\n                        myexit(-1);\n                    }\n                    generate_iptables_rule_add = 1;\n                } else if (strcmp(long_options[option_index].name, \"disable-color\") == 0) {\n                    // enable_log_color=0;\n                } else if (strcmp(long_options[option_index].name, \"enable-color\") == 0) {\n                    // enable_log_color=0;\n                } else if (strcmp(long_options[option_index].name, \"debug\") == 0) {\n                    debug_flag = 1;\n                    // enable_log_color=0;\n                } else if (strcmp(long_options[option_index].name, \"dev\") == 0) {\n                    sscanf(optarg, \"%s\", dev);\n                    // enable_log_color=0;\n                    mylog(log_info, \"dev=[%s]\\n\", dev);\n                } else if (strcmp(long_options[option_index].name, \"debug-resend\") == 0) {\n                    // debug_resend=1;\n                    // enable_log_color=0;\n                } else if (strcmp(long_options[option_index].name, \"log-position\") == 0) {\n                    // enable_log_position=1;\n                } else if (strcmp(long_options[option_index].name, \"force-sock-buf\") == 0) {\n                    if (is_udp2raw_mp) {\n                        mylog(log_fatal, \"--force-sock-buf not supported in this version\\n\");\n                        myexit(-1);\n                    }\n                    force_socket_buf = 1;\n                } else if (strcmp(long_options[option_index].name, \"retry-on-error\") == 0) {\n                    retry_on_error = 1;\n                } else if (strcmp(long_options[option_index].name, \"wait-lock\") == 0) {\n                    wait_xtables_lock = 1;\n                } else if (strcmp(long_options[option_index].name, \"disable-bpf\") == 0) {\n                    disable_bpf_filter = 1;\n                } else if (strcmp(long_options[option_index].name, \"disable-anti-replay\") == 0) {\n                    disable_anti_replay = 1;\n                } else if (strcmp(long_options[option_index].name, \"sock-buf\") == 0) {\n                    int tmp = -1;\n                    sscanf(optarg, \"%d\", &tmp);\n                    if (10 <= tmp && tmp <= 10 * 1024) {\n                        socket_buf_size = tmp * 1024;\n                    } else {\n                        mylog(log_fatal, \"sock-buf value must be between 1 and 10240 (kbyte) \\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"seq-mode\") == 0) {\n                    sscanf(optarg, \"%d\", &seq_mode);\n                    if (0 <= seq_mode && seq_mode <= max_seq_mode) {\n                    } else {\n                        mylog(log_fatal, \"seq_mode value must be  0,1,or 2 \\n\");\n                        myexit(-1);\n                    }\n                } else if (strcmp(long_options[option_index].name, \"random-drop\") == 0) {\n                    sscanf(optarg, \"%d\", &random_drop);\n                    if (random_drop < 0 || random_drop > 10000) {\n                        mylog(log_fatal, \"random_drop must be between 0 10000 \\n\");\n                        myexit(-1);\n                    }\n                    mylog(log_info, \"random_drop =%d \\n\", random_drop);\n                } else if (strcmp(long_options[option_index].name, \"fifo\") == 0) {\n                    if (is_udp2raw_mp) {\n                        mylog(log_fatal, \"--fifo not supported in this version\\n\");\n                        myexit(-1);\n                    }\n                    sscanf(optarg, \"%s\", fifo_file);\n\n                    mylog(log_info, \"fifo_file =%s \\n\", fifo_file);\n                } else if (strcmp(long_options[option_index].name, \"conf-file\") == 0) {\n                    mylog(log_info, \"configuration loaded from %s\\n\", optarg);\n                } else if (strcmp(long_options[option_index].name, \"hb-mode\") == 0) {\n                    sscanf(optarg, \"%d\", &hb_mode);\n                    assert(hb_mode == 0 || hb_mode == 1);\n                    mylog(log_info, \"hb_mode =%d \\n\", hb_mode);\n                } else if (strcmp(long_options[option_index].name, \"hb-len\") == 0) {\n                    sscanf(optarg, \"%d\", &hb_len);\n                    assert(hb_len >= 0 && hb_len <= 1500);\n                    mylog(log_info, \"hb_len =%d \\n\", hb_len);\n                } else if (strcmp(long_options[option_index].name, \"mtu-warn\") == 0) {\n                    sscanf(optarg, \"%d\", &mtu_warn);\n                    assert(mtu_warn > 0);\n                    mylog(log_info, \"mtu_warn=%d \\n\", mtu_warn);\n                } else if (strcmp(long_options[option_index].name, \"max-rst-to-show\") == 0) {\n                    sscanf(optarg, \"%d\", &max_rst_to_show);\n                    assert(max_rst_to_show >= -1);\n                    mylog(log_info, \"max_rst_to_show=%d \\n\", max_rst_to_show);\n                } else if (strcmp(long_options[option_index].name, \"max-rst-allowed\") == 0) {\n                    sscanf(optarg, \"%d\", &max_rst_allowed);\n                    assert(max_rst_allowed >= -1);\n                    mylog(log_info, \"max_rst_allowed=%d \\n\", max_rst_allowed);\n                } else if (strcmp(long_options[option_index].name, \"set-ttl\") == 0) {\n                    sscanf(optarg, \"%d\", &ttl_value);\n                    assert(ttl_value >= 0 && ttl_value <= 255);\n                    mylog(log_info, \"ttl_value=%d\\n\", ttl_value);\n                }\n\n                else if (strcmp(long_options[option_index].name, \"dns-resolve\") == 0)  // currently not used\n                {\n                    enable_dns_resolve = 1;\n                    mylog(log_info, \"dns-resolve enabled\\n\");\n                }\n#ifdef UDP2RAW_MP\n                else if (strcmp(long_options[option_index].name, \"pcap-send\") == 0) {\n                    send_with_pcap = 1;\n                    mylog(log_info, \"--pcap-send enabled, now pcap will be used for sending packet instead of libnet\\n\");\n                } else if (strcmp(long_options[option_index].name, \"no-pcap-mutex\") == 0) {\n                    use_pcap_mutex = 0;\n                    mylog(log_warn, \"--no-pcap-mutex enabled, we will assume the underlying pcap calls are threadsafe\\n\");\n                }\n#endif\n                else if (strcmp(long_options[option_index].name, \"easy-tcp\") == 0) {\n                    use_tcp_dummy_socket = 1;\n                    mylog(log_info, \"--easy-tcp enabled, now a dummy tcp socket will be created for handshake and block rst\\n\");\n                } else if (strcmp(long_options[option_index].name, \"fix-gro\") == 0) {\n                    mylog(log_info, \"--fix-gro enabled\\n\");\n                    g_fix_gro = 1;\n                } else {\n                    mylog(log_warn, \"ignored unknown long option ,option_index:%d code:<%x>\\n\", option_index, optopt);\n                }\n                break;\n            default:\n                mylog(log_fatal, \"unknown option ,code:<%c>,<%x>\\n\", optopt, optopt);\n                myexit(-1);\n        }\n    }\n\n    if (no_l)\n        mylog(log_fatal, \"error: -l not found\\n\");\n    if (no_r)\n        mylog(log_fatal, \"error: -r not found\\n\");\n    if (program_mode == 0)\n        mylog(log_fatal, \"error: -c /-s  hasnt been set\\n\");\n    if (no_l || no_r || program_mode == 0) {\n        print_help();\n        myexit(-1);\n    }\n    if (program_mode == client_mode) {\n        raw_ip_version = remote_addr.get_type();\n    } else {\n        raw_ip_version = local_addr.get_type();\n    }\n\n    if (auto_add_iptables_rule && use_tcp_dummy_socket) {\n        mylog(log_error, \"-a,--auto-rule is not supposed to be used with easyfaketcp mode, you are likely making a mistake, but we can try to continue\\n\");\n    }\n\n    if (keep_rule && use_tcp_dummy_socket) {\n        mylog(log_error, \"--keep-rule is not supposed to be used with easyfaketcp mode, you are likely making a mistake, but we can try to continue\\n\");\n    }\n\n    mylog(log_info, \"important variables: \");\n\n    log_bare(log_info, \"log_level=%d:%s \", log_level, log_text[log_level]);\n    log_bare(log_info, \"raw_mode=%s \", raw_mode_tostring[raw_mode]);\n    log_bare(log_info, \"cipher_mode=%s \", cipher_mode_tostring[cipher_mode]);\n    log_bare(log_info, \"auth_mode=%s \", auth_mode_tostring[auth_mode]);\n\n    log_bare(log_info, \"key=%s \", key_string);\n\n    log_bare(log_info, \"local_addr=%s \", local_addr.get_str());\n    log_bare(log_info, \"remote_addr=%s \", remote_addr.get_str());\n\n    if (force_source_ip)\n        log_bare(log_info, \"source_addr=%s \", source_addr.get_ip());\n\n    if (force_source_port)\n        log_bare(log_info, \"source_port=%d \", source_port);\n\n    log_bare(log_info, \"socket_buf_size=%d \", socket_buf_size);\n\n    log_bare(log_info, \"\\n\");\n}\n\nvoid pre_process_arg(int argc, char *argv[])  // mainly for load conf file\n{\n    int i, j, k;\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"--unit-test\") == 0) {\n            unit_test();\n            myexit(0);\n        }\n    }\n\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0) {\n            print_help();\n            myexit(0);\n        }\n    }\n\n    if (argc == 1) {\n        print_help();\n        myexit(-1);\n    }\n\n    process_log_level(argc, argv);\n\n    int new_argc = 0;\n    vector<string> new_argv;\n\n    int count = 0;\n    int pos = -1;\n\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"--conf-file\") == 0) {\n            count++;\n            pos = i;\n            if (i == argc) {\n                mylog(log_fatal, \"--conf-file need a parameter\\n\");\n                myexit(-1);\n            }\n            if (argv[i + 1][0] == '-') {\n                mylog(log_fatal, \"--conf-file need a parameter\\n\");\n                myexit(-1);\n            }\n            i++;\n        } else {\n            // printf(\"<%s>\",argv[i]);\n            new_argc++;\n            new_argv.push_back(argv[i]);\n        }\n    }\n    if (count > 1) {\n        mylog(log_fatal, \"duplicated --conf-file option\\n\");\n        myexit(-1);\n    }\n\n    if (count > 0) {\n        load_config(argv[pos + 1], new_argc, new_argv);\n    }\n    char *new_argv_char[new_argv.size()];\n\n    new_argc = 0;\n    for (i = 0; i < (int)new_argv.size(); i++) {\n        if (strcmp(new_argv[i].c_str(), \"--conf-file\") == 0) {\n            mylog(log_fatal, \"cant have --conf-file in a config file\\n\");\n            myexit(-1);\n        }\n        new_argv_char[new_argc++] = (char *)new_argv[i].c_str();\n    }\n    process_arg(new_argc, new_argv_char);\n}\n#ifdef UDP2RAW_LINUX\nvoid *run_keep(void *none)  // called in a new thread for --keep-rule option\n{\n    while (1) {\n        sleep(iptables_rule_keep_interval);\n        keep_iptables_rule();\n        if (about_to_exit)  // just incase it runs forever if there is some bug,not necessary\n        {\n            sleep(10);\n            keep_thread_running = 0;  // not thread safe ,but wont cause problem\n            break;\n        }\n    }\n    return NULL;\n}\nvoid iptables_rule()  // handles -a -g --gen-add  --keep-rule --clear --wait-lock\n{\n    assert(raw_ip_version == AF_INET || raw_ip_version == AF_INET6);\n\n    if (raw_ip_version == AF_INET) {\n        iptables_command0 = \"iptables \";\n    } else\n        iptables_command0 = \"ip6tables \";\n    if (!wait_xtables_lock) {\n        iptables_command = iptables_command0;\n    } else {\n        iptables_command = iptables_command0 + \"-w \";\n    }\n\n    if (clear_iptables) {\n        char *output;\n        // int ret =system(\"iptables-save |grep udp2raw_dWRwMnJhdw|sed -n 's/^-A/iptables -D/p'|sh\");\n        int ret = run_command(iptables_command + \"-S|sed -n '/udp2rawDwrW/p'|sed -n 's/^-A/\" + iptables_command + \"-D/p'|sh\", output);\n\n        int ret2 = run_command(iptables_command + \"-S|sed -n '/udp2rawDwrW/p'|sed -n 's/^-N/\" + iptables_command + \"-X/p'|sh\", output);\n        // system(\"iptables-save |grep udp2raw_dWRwMnJhdw|sed 's/^-A/iptables -D/'|sh\");\n        // system(\"iptables-save|grep -v udp2raw_dWRwMnJhdw|iptables-restore\");\n        mylog(log_info, \"tried to clear all iptables rule created previously,return value %d %d\\n\", ret, ret2);\n        myexit(-1);\n    }\n\n    if (auto_add_iptables_rule && generate_iptables_rule) {\n        mylog(log_warn, \" -g overrides -a\\n\");\n        auto_add_iptables_rule = 0;\n        // myexit(-1);\n    }\n    if (generate_iptables_rule_add && generate_iptables_rule) {\n        mylog(log_warn, \" --gen-add overrides -g\\n\");\n        generate_iptables_rule = 0;\n        // myexit(-1);\n    }\n\n    if (keep_rule && auto_add_iptables_rule == 0) {\n        auto_add_iptables_rule = 1;\n        mylog(log_warn, \" --keep_rule implys -a\\n\");\n        generate_iptables_rule = 0;\n        // myexit(-1);\n    }\n    char tmp_pattern[200];\n    string pattern = \"\";\n\n    if (program_mode == client_mode) {\n        tmp_pattern[0] = 0;\n        if (raw_mode == mode_faketcp) {\n            sprintf(tmp_pattern, \"-s %s -p tcp -m tcp --sport %d\", remote_addr.get_ip(), remote_addr.get_port());\n        }\n        if (raw_mode == mode_udp) {\n            sprintf(tmp_pattern, \"-s %s -p udp -m udp --sport %d\", remote_addr.get_ip(), remote_addr.get_port());\n        }\n        if (raw_mode == mode_icmp) {\n            if (raw_ip_version == AF_INET)\n                sprintf(tmp_pattern, \"-s %s -p icmp --icmp-type 0\", remote_addr.get_ip());\n            else\n                sprintf(tmp_pattern, \"-s %s -p icmpv6 --icmpv6-type 129\", remote_addr.get_ip());\n        }\n        pattern += tmp_pattern;\n    }\n    if (program_mode == server_mode) {\n        tmp_pattern[0] = 0;\n        if (raw_ip_version == AF_INET) {\n            if (local_addr.inner.ipv4.sin_addr.s_addr != 0) {\n                sprintf(tmp_pattern, \"-d %s \", local_addr.get_ip());\n            }\n        } else {\n            char zero_arr[16] = {0};\n            if (memcmp(&local_addr.inner.ipv6.sin6_addr, zero_arr, 16) != 0) {\n                sprintf(tmp_pattern, \"-d %s \", local_addr.get_ip());\n            }\n        }\n        pattern += tmp_pattern;\n\n        tmp_pattern[0] = 0;\n        if (raw_mode == mode_faketcp) {\n            sprintf(tmp_pattern, \"-p tcp -m tcp --dport %d\", local_addr.get_port());\n        }\n        if (raw_mode == mode_udp) {\n            sprintf(tmp_pattern, \"-p udp -m udp --dport %d\", local_addr.get_port());\n        }\n        if (raw_mode == mode_icmp) {\n            if (raw_ip_version == AF_INET)\n                sprintf(tmp_pattern, \"-p icmp --icmp-type 8\");\n            else\n                sprintf(tmp_pattern, \"-p icmpv6 --icmpv6-type 128\");\n        }\n        pattern += tmp_pattern;\n    }\n    /*\n            if(!simple_rule)\n            {\n                    pattern += \" -m comment --comment udp2rawDwrW_\";\n\n                    char const_id_str[100];\n                    sprintf(const_id_str, \"%x_\", const_id);\n\n                    pattern += const_id_str;\n\n                    time_t timer;\n                    char buffer[26];\n                    struct tm* tm_info;\n\n                    time(&timer);\n                    tm_info = localtime(&timer);\n\n                    strftime(buffer, 26, \"%Y-%m-%d-%H:%M:%S\", tm_info);\n\n                    pattern += buffer;\n\n\n            }*/\n\n    if (generate_iptables_rule) {\n        string rule = iptables_command + \"-I INPUT \";\n        rule += pattern;\n        rule += \" -j DROP\";\n\n        printf(\"generated iptables rule:\\n\");\n        printf(\"%s\\n\", rule.c_str());\n        myexit(0);\n    }\n    if (generate_iptables_rule_add) {\n        iptables_gen_add(pattern.c_str(), const_id);\n        myexit(0);\n    }\n\n    if (auto_add_iptables_rule) {\n        iptables_rule_init(pattern.c_str(), const_id, keep_rule);\n        if (keep_rule) {\n            if (pthread_create(&keep_thread, NULL, run_keep, 0)) {\n                mylog(log_fatal, \"Error creating thread\\n\");\n                myexit(-1);\n            }\n            keep_thread_running = 1;\n        }\n    } else {\n        mylog(log_warn, \" -a has not been set, make sure you have added the needed iptables rules manually\\n\");\n    }\n}\n#endif\n\nint unit_test() {\n    printf(\"running unit test\\n\");\n    vector<string> conf_lines = {\"---aaa\", \"--aaa bbb\", \"-a bbb\", \" \\t \\t \\t-a\\t \\t \\t bbbbb\\t \\t \\t \"};\n    for (int i = 0; i < int(conf_lines.size()); i++) {\n        printf(\"orign:%s\\n\", conf_lines[i].c_str());\n        auto res = parse_conf_line(conf_lines[i]);\n        printf(\"pasrse_result: size %d\", int(res.size()));\n        for (int j = 0; j < int(res.size()); j++) {\n            printf(\"<%s>\", res[j].c_str());\n        }\n        printf(\"\\n\");\n    }\n\n    char s1[] = {1, 2, 3, 4, 5};\n\n    char s2[] = {1};\n\n    short c1 = csum((unsigned short *)s1, 5);\n    short c2 = csum((unsigned short *)s2, 1);\n    // c2=0;\n\n    printf(\"%x %x\\n\", (int)c1, (int)c2);\n\n    const char buf[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 2, 13, 14, 15, 16};\n    char key[100] = {0};\n    char buf2[100] = {0};\n    char buf3[100] = {0};\n    char buf4[100] = {0};\n    int len = 16;\n    for (int i = 0; i < len; i++) {\n        printf(\"<%d>\", buf[i]);\n    }\n    printf(\"\\n\");\n    cipher_encrypt(buf, buf2, len, key);\n    for (int i = 0; i < len; i++) {\n        printf(\"<%d>\", buf2[i]);\n    }\n    printf(\"\\n\");\n    int temp_len = len;\n    cipher_decrypt(buf2, buf3, len, key);\n    for (int i = 0; i < len; i++) {\n        printf(\"<%d>\", buf3[i]);\n    }\n    printf(\"\\n\");\n    cipher_encrypt(buf2, buf4, temp_len, key);\n    for (int i = 0; i < temp_len; i++) {\n        printf(\"<%d>\", buf4[i]);\n    }\n    return 0;\n}\n\n#ifdef UDP2RAW_LINUX\nint set_timer(int epollfd, int &timer_fd)  // put a timer_fd into epoll,general function,used both in client and server\n{\n    int ret;\n    epoll_event ev;\n\n    itimerspec its;\n    memset(&its, 0, sizeof(its));\n\n    if ((timer_fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK)) < 0) {\n        mylog(log_fatal, \"timer_fd create error\\n\");\n        myexit(1);\n    }\n    its.it_interval.tv_sec = (timer_interval / 1000);\n    its.it_interval.tv_nsec = (timer_interval % 1000) * 1000ll * 1000ll;\n    its.it_value.tv_nsec = 1;  // imidiately\n    timerfd_settime(timer_fd, 0, &its, 0);\n\n    ev.events = EPOLLIN;\n    ev.data.u64 = timer_fd;\n\n    ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, timer_fd, &ev);\n    if (ret < 0) {\n        mylog(log_fatal, \"epoll_ctl return %d\\n\", ret);\n        myexit(-1);\n    }\n    return 0;\n}\n\nint set_timer_server(int epollfd, int &timer_fd, fd64_t &fd64)  // only for server\n{\n    int ret;\n    epoll_event ev;\n\n    itimerspec its;\n    memset(&its, 0, sizeof(its));\n\n    if ((timer_fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK)) < 0) {\n        mylog(log_fatal, \"timer_fd create error\\n\");\n        myexit(1);\n    }\n    its.it_interval.tv_sec = (timer_interval / 1000);\n    its.it_interval.tv_nsec = (timer_interval % 1000) * 1000ll * 1000ll;\n    its.it_value.tv_nsec = 1;  // imidiately\n    timerfd_settime(timer_fd, 0, &its, 0);\n\n    fd64 = fd_manager.create(timer_fd);\n\n    ev.events = EPOLLIN;\n    ev.data.u64 = fd64;  ////difference\n\n    ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, timer_fd, &ev);\n    if (ret < 0) {\n        mylog(log_fatal, \"epoll_ctl return %d\\n\", ret);\n        myexit(-1);\n    }\n    return 0;\n}\n\nint handle_lower_level(raw_info_t &raw_info)  // fill lower_level info,when --lower-level is enabled,only for server\n{\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    if (lower_level_manual) {\n        memset(&send_info.addr_ll, 0, sizeof(send_info.addr_ll));\n        send_info.addr_ll.sll_family = AF_PACKET;\n        send_info.addr_ll.sll_ifindex = ifindex;\n        send_info.addr_ll.sll_halen = ETHER_ADDR_LEN;\n        send_info.addr_ll.sll_protocol = htons(ETH_P_IP);\n        memcpy(&send_info.addr_ll.sll_addr, dest_hw_addr, ETHER_ADDR_LEN);\n        mylog(log_debug, \"[manual]lower level info %x %x\\n \", send_info.addr_ll.sll_halen, send_info.addr_ll.sll_protocol);\n    } else {\n        memset(&send_info.addr_ll, 0, sizeof(send_info.addr_ll));\n        send_info.addr_ll.sll_family = recv_info.addr_ll.sll_family;\n        send_info.addr_ll.sll_ifindex = recv_info.addr_ll.sll_ifindex;\n        send_info.addr_ll.sll_protocol = recv_info.addr_ll.sll_protocol;\n        send_info.addr_ll.sll_halen = recv_info.addr_ll.sll_halen;\n        memcpy(send_info.addr_ll.sll_addr, recv_info.addr_ll.sll_addr, sizeof(send_info.addr_ll.sll_addr));\n        // other bytes should be kept zero.\n\n        mylog(log_debug, \"[auto]lower level info %x %x\\n \", send_info.addr_ll.sll_halen, send_info.addr_ll.sll_protocol);\n    }\n    return 0;\n}\n\nstring chain[2];\nstring rule_keep[2];\nstring rule_keep_add[2];\nstring rule_keep_del[2];\nu64_t keep_rule_last_time = 0;\n\npthread_t keep_thread;\nint keep_thread_running = 0;\nint iptables_gen_add(const char *s, u32_t const_id) {\n    string dummy = \"\";\n    iptables_pattern = s;\n    chain[0] = dummy + \"udp2rawDwrW_C\";\n    rule_keep[0] = dummy + iptables_pattern + \" -j \" + chain[0];\n    rule_keep_add[0] = iptables_command + \"-I INPUT \" + rule_keep[0];\n\n    char *output;\n    run_command(iptables_command + \"-N \" + chain[0], output, show_none);\n    run_command(iptables_command + \"-F \" + chain[0], output);\n    run_command(iptables_command + \"-I \" + chain[0] + \" -j DROP\", output);\n\n    rule_keep_del[0] = iptables_command + \"-D INPUT \" + rule_keep[0];\n\n    run_command(rule_keep_del[0], output, show_none);\n    run_command(rule_keep_del[0], output, show_none);\n\n    if (run_command(rule_keep_add[0], output) != 0) {\n        mylog(log_fatal, \"auto added iptables failed by: %s\\n\", rule_keep_add[0].c_str());\n        myexit(-1);\n    }\n    return 0;\n}\nint iptables_rule_init(const char *s, u32_t const_id, int keep) {\n    iptables_pattern = s;\n    iptables_rule_added = 1;\n    iptables_rule_keeped = keep;\n\n    string dummy = \"\";\n    char const_id_str[100];\n    sprintf(const_id_str, \"%x\", const_id);\n\n    chain[0] = dummy + \"udp2rawDwrW_\" + const_id_str + \"_C0\";\n    chain[1] = dummy + \"udp2rawDwrW_\" + const_id_str + \"_C1\";\n\n    rule_keep[0] = dummy + iptables_pattern + \" -j \" + chain[0];\n    rule_keep[1] = dummy + iptables_pattern + \" -j \" + chain[1];\n\n    rule_keep_add[0] = iptables_command + \"-I INPUT \" + rule_keep[0];\n    rule_keep_add[1] = iptables_command + \"-I INPUT \" + rule_keep[1];\n\n    rule_keep_del[0] = iptables_command + \"-D INPUT \" + rule_keep[0];\n    rule_keep_del[1] = iptables_command + \"-D INPUT \" + rule_keep[1];\n\n    keep_rule_last_time = get_current_time();\n\n    char *output;\n\n    for (int i = 0; i <= iptables_rule_keeped; i++) {\n        run_command(iptables_command + \"-N \" + chain[i], output);\n        run_command(iptables_command + \"-F \" + chain[i], output);\n        run_command(iptables_command + \"-I \" + chain[i] + \" -j DROP\", output);\n\n        if (run_command(rule_keep_add[i], output) != 0) {\n            mylog(log_fatal, \"auto added iptables failed by: %s\\n\", rule_keep_add[i].c_str());\n            myexit(-1);\n        }\n    }\n    mylog(log_warn, \"auto added iptables rules\\n\");\n    return 0;\n}\n\nint keep_iptables_rule()  // magic to work on a machine without grep/iptables --check/-m commment\n{\n    /*\n    if(iptables_rule_keeped==0) return  0;\n\n\n    uint64_t tmp_current_time=get_current_time();\n    if(tmp_current_time-keep_rule_last_time<=iptables_rule_keep_interval)\n    {\n            return 0;\n    }\n    else\n    {\n            keep_rule_last_time=tmp_current_time;\n    }*/\n\n    mylog(log_debug, \"keep_iptables_rule begin %llu\\n\", get_current_time());\n    iptables_rule_keep_index += 1;\n    iptables_rule_keep_index %= 2;\n\n    string dummy = \"\";\n    char *output;\n\n    int i = iptables_rule_keep_index;\n\n    run_command(iptables_command + \"-N \" + chain[i], output, show_none);\n\n    if (run_command(iptables_command + \"-F \" + chain[i], output, show_none) != 0)\n        mylog(log_warn, \"iptables -F failed %d\\n\", i);\n\n    if (run_command(iptables_command + \"-I \" + chain[i] + \" -j DROP\", output, show_none) != 0)\n        mylog(log_warn, \"iptables -I failed %d\\n\", i);\n\n    if (run_command(rule_keep_del[i], output, show_none) != 0)\n        mylog(log_warn, \"rule_keep_del failed %d\\n\", i);\n\n    run_command(rule_keep_del[i], output, show_none);  // do it twice,incase it fails for unknown random reason\n\n    if (run_command(rule_keep_add[i], output, show_log) != 0)\n        mylog(log_warn, \"rule_keep_del failed %d\\n\", i);\n\n    mylog(log_debug, \"keep_iptables_rule end %llu\\n\", get_current_time());\n    return 0;\n}\n\nint clear_iptables_rule() {\n    char *output;\n    string dummy = \"\";\n    if (!iptables_rule_added) return 0;\n\n    for (int i = 0; i <= iptables_rule_keeped; i++) {\n        run_command(rule_keep_del[i], output);\n        run_command(iptables_command + \"-F \" + chain[i], output);\n        run_command(iptables_command + \"-X \" + chain[i], output);\n    }\n    return 0;\n}\n#endif\n\n#ifdef UDP2RAW_MP\nvoid iptables_rule()  // handles -a -g --gen-add  --keep-rule --clear --wait-lock\n{\n    if (generate_iptables_rule) {\n        if (raw_mode == mode_faketcp && use_tcp_dummy_socket == 1) {\n            mylog(log_fatal, \"failed,-g doesnt work with easy-faketcp mode\\n\");\n            myexit(-1);\n        }\n        if (raw_mode == mode_udp) {\n            mylog(log_warn, \"It not necessary to use iptables/firewall rule in udp mode\\n\");\n        }\n        log_bare(log_warn, \"for linux, use:\\n\");\n        if (raw_ip_version == AF_INET) {\n            if (raw_mode == mode_faketcp)\n                printf(\"iptables -I INPUT -s %s -p tcp -m tcp --sport %d -j DROP\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_udp)\n                printf(\"iptables -I INPUT -s %s -p udp -m udp --sport %d -j DROP\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_icmp)\n                printf(\"iptables -I INPUT -s %s -p icmp --icmp-type 0 -j DROP\\n\", remote_addr.get_ip());\n            printf(\"\\n\");\n        } else {\n            assert(raw_ip_version == AF_INET6);\n            if (raw_mode == mode_faketcp)\n                printf(\"ip6tables -I INPUT -s %s -p tcp -m tcp --sport %d -j DROP\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_udp)\n                printf(\"ip6tables -I INPUT -s %s -p udp -m udp --sport %d -j DROP\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_icmp)\n                printf(\"ip6tables -I INPUT -s %s -p -p icmpv6 --icmpv6-type 129 -j DROP\\n\", remote_addr.get_ip());\n            printf(\"\\n\");\n        }\n\n        log_bare(log_warn, \"for mac/bsd use:\\n\");\n        if (raw_ip_version == AF_INET) {\n            if (raw_mode == mode_faketcp)\n                printf(\"echo 'block drop inet proto tcp from %s port %d to any' > ./1.conf\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_udp)\n                printf(\"echo 'block drop inet proto udp from %s port %d to any' > ./1.conf\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_icmp)\n                printf(\"echo 'block drop inet proto icmp from %s to any' > ./1.conf\\n\", remote_addr.get_ip());\n        } else {\n            assert(raw_ip_version == AF_INET6);\n            if (raw_mode == mode_faketcp)\n                printf(\"echo 'block drop inet6 proto tcp from %s port %d to any' > ./1.conf\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_udp)\n                printf(\"echo 'block drop inet6 proto udp from %s port %d to any' > ./1.conf\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            if (raw_mode == mode_icmp)\n                printf(\"echo 'block drop inet6 proto icmp6 from %s to any' > ./1.conf\\n\", remote_addr.get_ip());\n        }\n        printf(\"pfctl -f ./1.conf\\n\");\n        printf(\"pfctl -e\\n\");\n        printf(\"\\n\");\n\n        log_bare(log_warn, \"for windows vista and above use:\\n\");\n        if (raw_ip_version == AF_INET) {\n            if (raw_mode == mode_faketcp) {\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=TCP dir=in remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=TCP dir=out remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            }\n            if (raw_mode == mode_udp) {\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=UDP dir=in remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=UDP dir=out remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            }\n\n            if (raw_mode == mode_icmp) {\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=ICMPV4 dir=in remoteip=%s action=block\\n\", remote_addr.get_ip());\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=ICMPV4 dir=out remoteip=%s action=block\\n\", remote_addr.get_ip());\n            }\n        } else {\n            assert(raw_ip_version == AF_INET6);\n            if (raw_mode == mode_faketcp) {\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=TCP dir=in remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=TCP dir=out remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            }\n            if (raw_mode == mode_udp) {\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=UDP dir=in remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=UDP dir=out remoteip=%s remoteport=%d action=block\\n\", remote_addr.get_ip(), remote_addr.get_port());\n            }\n\n            if (raw_mode == mode_icmp) {\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=ICMPV6 dir=in remoteip=%s action=block\\n\", remote_addr.get_ip());\n                printf(\"netsh advfirewall firewall add rule name=udp2raw protocol=ICMPV6 dir=out remoteip=%s action=block\\n\", remote_addr.get_ip());\n            }\n        }\n\n        myexit(0);\n    }\n}\n#endif\n\nvoid signal_handler(int sig) {\n    about_to_exit = 1;\n    // myexit(0);\n}\n"
        },
        {
          "name": "misc.h",
          "type": "blob",
          "size": 5.3779296875,
          "content": "/*\n * misc.h\n *\n *  Created on: Sep 23, 2017\n *      Author: root\n */\n\n#ifndef MISC_H_\n#define MISC_H_\n\n#include \"common.h\"\n#include \"log.h\"\n#include \"network.h\"\n\nextern int hb_mode;\nextern int hb_len;\nextern char hb_buf[buf_len];\n\nextern int mtu_warn;\n\nextern int max_rst_allowed;\nextern int max_rst_to_show;\n\nextern int enable_dns_resolve;\n\nextern int ttl_value;\n\nconst u32_t max_handshake_conn_num = 10000;\nconst u32_t max_ready_conn_num = 1000;\nconst u32_t anti_replay_window_size = 4000;\nconst int max_conv_num = 10000;\n\nconst u32_t client_handshake_timeout = 5000;  // unit ms\nconst u32_t client_retry_interval = 1000;     // ms\n\nconst u32_t server_handshake_timeout = client_handshake_timeout + 5000;  // this should be longer than clients. client retry initially ,server retry passtively\n\nconst int conv_clear_ratio = 30;  // conv grabage collecter check 1/30 of all conv one time\nconst int conn_clear_ratio = 50;\nconst int conv_clear_min = 1;\nconst int conn_clear_min = 1;\n\nconst u32_t conv_clear_interval = 1000;  // ms\nconst u32_t conn_clear_interval = 1000;  // ms\n\nconst i32_t max_fail_time = 0;  // disable\n\nconst u32_t heartbeat_interval = 600;  // ms\n\nconst u32_t timer_interval = 400;  // ms. this should be smaller than heartbeat_interval and retry interval;\n\nconst uint32_t conv_timeout = 180000;  // ms. 120 second\n// const u32_t conv_timeout=30000; //for test\n\nconst u32_t client_conn_timeout = 10000;                              // ms.\nconst u32_t client_conn_uplink_timeout = client_conn_timeout + 2000;  // ms\n\nconst uint32_t server_conn_timeout = conv_timeout + 60000;  // ms. this should be 60s+ longer than conv_timeout,so that conv_manager can destruct convs gradually,to avoid latency glicth\n// const u32_t server_conn_timeout=conv_timeout+10000;//for test\n\nconst u32_t iptables_rule_keep_interval = 20;  // unit: second;\n\nenum server_current_state_t { server_idle = 0,\n                              server_handshake1,\n                              server_ready };  // server state machine\nenum client_current_state_t { client_idle = 0,\n                              client_tcp_handshake,\n                              client_handshake1,\n                              client_handshake2,\n                              client_ready,\n                              client_tcp_handshake_dummy };  // client state machine\n\nenum raw_mode_t { mode_faketcp = 0,\n                  mode_udp,\n                  mode_icmp,\n                  mode_end };\nenum program_mode_t { unset_mode = 0,\n                      client_mode,\n                      server_mode };\n\nunion current_state_t {\n    server_current_state_t server_current_state;\n    client_current_state_t client_current_state;\n};\n\n// extern char remote_address[max_address_len];\n// extern char local_ip[100], remote_ip[100],source_ip[100];//local_ip is for -l option,remote_ip for -r option,source for --source-ip\n// extern u32_t local_ip_uint32,remote_ip_uint32,source_ip_uint32;//convert from last line.\n// extern int local_port , remote_port,source_port;//similiar to local_ip  remote_ip,buf for port.source_port=0 indicates --source-port is not enabled\n\nextern address_t local_addr, remote_addr, source_addr;\n\nextern my_ip_t bind_addr;\n\nextern int bind_addr_used;\nextern int force_source_ip;  // if --source-ip is enabled\nextern int force_source_port;\nextern int source_port;\n\nextern my_id_t const_id;  // an id used for connection recovery,its generated randomly,it never change since its generated\n\nextern int udp_fd;                 // for client only. client use this fd to listen and handle udp connection\nextern int bind_fd;                // bind only,never send or recv.  its just a dummy fd for bind,so that other program wont occupy the same port\nextern int epollfd;                // fd for epoll\nextern int timer_fd;               // the general timer fd for client and server.for server this is not the only timer find,every connection has a timer fd.\nextern int fail_time_counter;      // determine if the max_fail_time is reached\nextern int epoll_trigger_counter;  // for debug only\nextern int debug_flag;             // for debug only\n\nextern int simple_rule;                 // deprecated.\nextern int keep_rule;                   // whether to monitor the iptables rule periodly,re-add if losted\nextern int auto_add_iptables_rule;      // if -a is set\nextern int generate_iptables_rule;      // if -g is set\nextern int generate_iptables_rule_add;  // if --gen-add is set\nextern int retry_on_error;\nconst int retry_on_error_interval = 10;\n\nextern int debug_resend;  // debug only\n\nextern char key_string[1000];  // -k option\nextern char fifo_file[1000];\n\nextern raw_mode_t raw_mode;\nextern u32_t raw_ip_version;\n\nextern program_mode_t program_mode;\nextern unordered_map<int, const char *> raw_mode_tostring;\n\nextern int about_to_exit;\n\nextern int socket_buf_size;\n\nextern pthread_t keep_thread;\nextern int keep_thread_running;\n\nint process_lower_level_arg();\nvoid print_help();\nvoid iptables_rule();\nvoid pre_process_arg(int argc, char *argv[]);  // mainly for load conf file;\nint unit_test();\nint set_timer(int epollfd, int &timer_fd);\nint set_timer_server(int epollfd, int &timer_fd, fd64_t &fd64);\nint handle_lower_level(raw_info_t &raw_info);\n\nint add_iptables_rule(const char *);\n\nint clear_iptables_rule();\n\nint iptables_gen_add(const char *s, u32_t const_id);\nint iptables_rule_init(const char *s, u32_t const_id, int keep);\nint keep_iptables_rule();\n\nvoid signal_handler(int sig);\n\n#endif /* MISC_H_ */\n"
        },
        {
          "name": "my_ev.cpp",
          "type": "blob",
          "size": 0.443359375,
          "content": "#pragma GCC diagnostic push\n\n#pragma GCC diagnostic ignored \"-Wextra\"\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wcomment\"\n#pragma GCC diagnostic ignored \"-Wparentheses\"\n#pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n#pragma GCC diagnostic ignored \"-Wunused-value\"\n\n#pragma GCC diagnostic ignored \"-Wall\"\n#pragma GCC diagnostic ignored \"-W\"\n\n#include \"my_ev_common.h\"\n#include \"ev.c\"\n\n#pragma GCC diagnostic pop\n"
        },
        {
          "name": "my_ev.h",
          "type": "blob",
          "size": 0.0546875,
          "content": "#pragma once\n\n#include \"my_ev_common.h\"\n#include \"ev.h\"\n"
        },
        {
          "name": "my_ev_common.h",
          "type": "blob",
          "size": 0.400390625,
          "content": "\n#define EV_STANDALONE 1\n#define EV_COMMON \\\n    void *data;   \\\n    unsigned long long u64;\n#define EV_COMPAT3 0\n\n//#include <wepoll.h>\n#if defined(__MINGW32__)\n//#define EV_USE_SELECT 1\n//#define EV_SELECT_IS_WINSOCKET 1\n\n#define EV_FD_TO_WIN32_HANDLE(fd) (fd)\n#define EV_WIN32_HANDLE_TO_FD(handle) (handle)\n#define EV_WIN32_CLOSE_FD(fd) closesocket(fd)\n#define FD_SETSIZE 4096\n\n#endif\n//#define EV_VERIFY 2\n"
        },
        {
          "name": "network.cpp",
          "type": "blob",
          "size": 88.24609375,
          "content": "/*\n * network.cpp\n *\n *  Created on: Jul 29, 2017\n *      Author: wangyu\n */\n#include \"common.h\"\n#include \"network.h\"\n#include \"log.h\"\n#include \"misc.h\"\n\nint g_fix_gro = 0;\n\nint raw_recv_fd = -1;\nint raw_send_fd = -1;\nu32_t link_level_header_len = 0;  // set it to 14 if SOCK_RAW is used in socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));\nint use_tcp_dummy_socket = 0;\n\nint seq_mode = 3;\nint max_seq_mode = 4;\nint random_drop = 0;\n\nint filter_port = -1;\n\nint disable_bpf_filter = 0;  // for test only,most time no need to disable this\n\n// u32_t bind_address_uint32=0;\n\nint lower_level = 0;\nint lower_level_manual = 0;\nint ifindex = -1;\nchar if_name[100] = \"\";\n\nchar dev[100] = \"\";\n\nunsigned short g_ip_id_counter = 0;\n#ifdef UDP2RAW_LINUX\nunsigned char dest_hw_addr[sizeof(sockaddr_ll::sll_addr)] =\n    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0};\n#endif\n\n//{0x00,0x23,0x45,0x67,0x89,0xb9};\n\nconst u32_t receive_window_lower_bound = 40960;\nconst u32_t receive_window_random_range = 512;\nconst unsigned char wscale = 0x05;\n\nchar g_packet_buf[huge_buf_len];  // looks dirty but works well\nint g_packet_buf_len = -1;\nint g_packet_buf_cnt = 0;\n\n#ifdef UDP2RAW_LINUX\nunion {\n    sockaddr_ll ll;\n    sockaddr_in ipv4;\n    sockaddr_in6 ipv6;\n} g_sockaddr;\nsocklen_t g_sockaddr_len = -1;\n#endif\n\n#ifdef UDP2RAW_MP\n\n#ifndef NO_LIBNET\nlibnet_t *libnet_handle;\nlibnet_ptag_t g_ptag = 0;\nint send_with_pcap = 0;\n#else\nint send_with_pcap = 1;\n#endif\n\nint pcap_header_captured = 0;\nint pcap_header_buf[buf_len];\nint pcap_captured_full_len = -1;\n\npcap_t *pcap_handle;\nint pcap_link_header_len = -1;\n// int pcap_cnt=0;\nqueue_t my_queue;\n\npthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t pcap_mutex = PTHREAD_MUTEX_INITIALIZER;\nint use_pcap_mutex = 1;\n\nev_async async_watcher;\n\nstruct ev_loop *g_default_loop;\n\npthread_t pcap_recv_thread;\n\nstruct bpf_program g_filter;\nlong long g_filter_compile_cnt = 0;\n\n#endif\n\n#ifdef UDP2RAW_LINUX\n\nstruct sock_filter code_tcp_old[] = {\n    {0x28, 0, 0, 0x0000000c},   // 0\n    {0x15, 0, 10, 0x00000800},  // 1\n    {0x30, 0, 0, 0x00000017},   // 2\n    {0x15, 0, 8, 0x00000006},   // 3\n    {0x28, 0, 0, 0x00000014},   // 4\n    {0x45, 6, 0, 0x00001fff},   // 5\n    {0xb1, 0, 0, 0x0000000e},   // 6\n    {0x48, 0, 0, 0x0000000e},   // 7\n    {0x15, 2, 0, 0x0000ef32},   // 8\n    {0x48, 0, 0, 0x00000010},   // 9\n    {0x15, 0, 1, 0x0000ef32},   // 10\n    {0x6, 0, 0, 0x0000ffff},    // 11\n    {0x6, 0, 0, 0x00000000},    // 12\n};\nstruct sock_filter code_tcp[] = {\n    //{ 0x5, 0, 0, 0x00000001 },//0    //jump to 2,dirty hack from tcpdump -d's output\n    //{ 0x5, 0, 0, 0x00000000 },//1\n    {0x30, 0, 0, 0x00000009},  // 2\n    {0x15, 0, 6, 0x00000006},  // 3\n    {0x28, 0, 0, 0x00000006},  // 4\n    {0x45, 4, 0, 0x00001fff},  // 5\n    {0xb1, 0, 0, 0x00000000},  // 6\n    {0x48, 0, 0, 0x00000002},  // 7\n    {0x15, 0, 1, 0x0000fffe},  // 8   //modify this fffe to the port you listen on\n    {0x6, 0, 0, 0x0000ffff},   // 9\n    {0x6, 0, 0, 0x00000000},   // 10\n};\n/*\n{ 0x28, 0, 0, 0x0000000c },\n{ 0x15, 0, 8, 0x00000800 },\n{ 0x30, 0, 0, 0x00000017 },\n{ 0x15, 0, 6, 0x00000006 },\n{ 0x28, 0, 0, 0x00000014 },\n{ 0x45, 4, 0, 0x00001fff },\n{ 0xb1, 0, 0, 0x0000000e },\n{ 0x48, 0, 0, 0x00000010 },\n{ 0x15, 0, 1, 0x0000fffe },\n{ 0x6, 0, 0, 0x0000ffff },\n{ 0x6, 0, 0, 0x00000000 },\n*/\n\nint code_tcp_port_index = 6;\n\n// tcpdump -i ens33 ip6 and tcp and dst port 65534 -dd\nstruct sock_filter code_tcp6[] = {\n    //{ 0x28, 0, 0, 0x0000000c },//0\n    //{ 0x15, 0, 5, 0x000086dd },//1\n    {0x30, 0, 0, 0x00000006},  // 2\n    {0x15, 0, 3, 0x00000006},  // 3\n    {0x28, 0, 0, 0x0000002a},  // 4\n    {0x15, 0, 1, 0x0000fffe},  // 5\n    {0x6, 0, 0, 0x00040000},   // 6\n    {0x6, 0, 0, 0x00000000},   // 7\n};                             // note: this filter doesnt support extension headers\n/*\n { 0x30, 0, 0, 0x00000014 },//2\n{ 0x15, 0, 3, 0x00000006 },//3\n{ 0x28, 0, 0, 0x00000038 },//4\n{ 0x15, 0, 1, 0x0000fffe },//5\n{ 0x6, 0, 0, 0x00040000 },//6\n{ 0x6, 0, 0, 0x00000000 },//7\n*/\n\nint code_tcp6_port_index = 3;\n\nstruct sock_filter code_udp[] = {\n    //{ 0x5, 0, 0, 0x00000001 },\n    //{ 0x5, 0, 0, 0x00000000 },\n    {0x30, 0, 0, 0x00000009},\n    {0x15, 0, 6, 0x00000011},\n    {0x28, 0, 0, 0x00000006},\n    {0x45, 4, 0, 0x00001fff},\n    {0xb1, 0, 0, 0x00000000},\n    {0x48, 0, 0, 0x00000002},\n    {0x15, 0, 1, 0x0000fffe},  // modify this fffe to the port you listen on\n    {0x6, 0, 0, 0x0000ffff},\n    {0x6, 0, 0, 0x00000000},\n};\nint code_udp_port_index = 6;\n\nstruct sock_filter code_udp6[] = {\n    //\t\t{ 0x28, 0, 0, 0x0000000c },\n    //\t\t{ 0x15, 0, 5, 0x000086dd },\n    {0x30, 0, 0, 0x00000006},\n    {0x15, 0, 3, 0x00000011},\n    {0x28, 0, 0, 0x0000002a},\n    {0x15, 0, 1, 0x0000fffe},\n    {0x6, 0, 0, 0x00040000},\n    {0x6, 0, 0, 0x00000000},\n\n};\nint code_udp6_port_index = 3;\n\nstruct sock_filter code_icmp[] = {\n    //{ 0x5, 0, 0, 0x00000001 },\n    //{ 0x5, 0, 0, 0x00000000 },\n    {0x30, 0, 0, 0x00000009},\n    {0x15, 0, 1, 0x00000001},\n    {0x6, 0, 0, 0x0000ffff},\n    {0x6, 0, 0, 0x00000000},\n};\n\nstruct sock_filter code_icmp6[] = {\n    //\t\t{ 0x28, 0, 0, 0x0000000c },\n    //\t\t{ 0x15, 0, 6, 0x000086dd },\n    {0x30, 0, 0, 0x00000006},\n    {0x15, 3, 0, 0x0000003a},\n    {0x15, 0, 3, 0x0000002c},\n    {0x30, 0, 0, 0x00000028},\n    {0x15, 0, 1, 0x0000003a},\n    {0x6, 0, 0, 0x00040000},\n    {0x6, 0, 0, 0x00000000},\n\n};\n/*\n\ntcpdump -i eth1  ip and icmp -d\n(000) ldh      [12]\n(001) jeq      #0x800           jt 2    jf 5\n(002) ldb      [23]\n(003) jeq      #0x1             jt 4    jf 5\n(004) ret      #65535\n(005) ret      #0\n\ntcpdump -i eth1  ip and icmp -dd\n{ 0x28, 0, 0, 0x0000000c },\n{ 0x15, 0, 3, 0x00000800 },\n{ 0x30, 0, 0, 0x00000017 },\n{ 0x15, 0, 1, 0x00000001 },\n{ 0x6, 0, 0, 0x0000ffff },\n{ 0x6, 0, 0, 0x00000000 },\n\n\n */\n/*\n  tcpdump -i eth1 ip and tcp and dst port 65534 -dd\n\n{ 0x28, 0, 0, 0x0000000c },\n{ 0x15, 0, 8, 0x00000800 },\n{ 0x30, 0, 0, 0x00000017 },\n{ 0x15, 0, 6, 0x00000006 },\n{ 0x28, 0, 0, 0x00000014 },\n{ 0x45, 4, 0, 0x00001fff },\n{ 0xb1, 0, 0, 0x0000000e },\n{ 0x48, 0, 0, 0x00000010 },\n{ 0x15, 0, 1, 0x0000fffe },\n{ 0x6, 0, 0, 0x0000ffff },\n{ 0x6, 0, 0, 0x00000000 },\n\n (000) ldh      [12]\n(001) jeq      #0x800           jt 2    jf 10\n(002) ldb      [23]\n(003) jeq      #0x6             jt 4    jf 10\n(004) ldh      [20]\n(005) jset     #0x1fff          jt 10   jf 6\n(006) ldxb     4*([14]&0xf)\n(007) ldh      [x + 16]\n(008) jeq      #0xfffe          jt 9    jf 10\n(009) ret      #65535\n(010) ret      #0\n\n */\n#endif\n\npacket_info_t::packet_info_t() {\n    src_port = 0;\n    dst_port = 0;\n    if (raw_mode == mode_faketcp) {\n        protocol = IPPROTO_TCP;\n        ack_seq = get_true_random_number();\n        seq = get_true_random_number();\n        has_ts = 0;\n        ts_ack = 0;\n        syn = 0;\n        ack = 1;\n        ack_seq_counter = 0;\n\n        // mylog(log_info,\"<cons ,ts_ack= %u>\\n\",ts_ack);\n    } else if (raw_mode == mode_udp) {\n        protocol = IPPROTO_UDP;\n    } else if (raw_mode == mode_icmp) {\n        if (raw_ip_version == AF_INET) {\n            protocol = IPPROTO_ICMP;\n        } else {\n            assert(raw_ip_version == AF_INET6);\n            protocol = IPPROTO_ICMPV6;\n        }\n        my_icmp_seq = 0;\n    }\n}\n#ifdef UDP2RAW_MP\nvoid my_packet_handler(\n    u_char *args,\n    const struct pcap_pkthdr *packet_header,\n    const u_char *pkt_data) {\n    /*printf(\"<%d %d>\\n\",(int)packet_header->caplen,(int)packet_header->len );\n    for(int i=0;i<sizeof(pcap_pkthdr);i++)\n    {\n            char *p=(char *) packet_header;\n            printf(\"<%x>\",int( p[i] ));\n    }\n    printf(\"\\n\");*/\n    // mylog(log_debug,\"received a packet!\\n\");\n    assert(packet_header->caplen <= packet_header->len);\n    assert(packet_header->caplen <= huge_data_len);\n    // if(packet_header->caplen > max_data_len) return ;\n    if (g_fix_gro == 0 && packet_header->caplen < packet_header->len) return;\n\n    if ((int)packet_header->caplen < pcap_link_header_len) return;\n    // mylog(log_debug,\"and its vaild!\\n\");\n\n    pthread_mutex_lock(&queue_mutex);\n    if (!my_queue.full())\n        my_queue.push_back((char *)pkt_data, (int)(packet_header->caplen));\n    pthread_mutex_unlock(&queue_mutex);\n\n    // pcap_cnt++;\n\n    ev_async_send(g_default_loop, &async_watcher);\n    return;\n}\n\nvoid *pcap_recv_thread_entry(void *none) {\n    struct pcap_pkthdr *packet_header;\n    const u_char *pkt_data;\n\n    while (1) {\n        if (use_pcap_mutex) pthread_mutex_lock(&pcap_mutex);\n        int ret = pcap_loop(pcap_handle, -1, my_packet_handler, NULL);  // use -1 instead of 0 as cnt, since 0 is undefined in old versions\n        if (use_pcap_mutex) pthread_mutex_unlock(&pcap_mutex);\n        if (ret == -1)\n            mylog(log_warn, \"pcap_loop exited with value %d\\n\", ret);\n        else {\n            mylog(log_debug, \"pcap_loop exited with value %d\\n\", ret);\n        }\n        ev_sleep(1.0);\n        // myexit(-1);\n    }\n    /*\n    while(1)\n    {\n            //printf(\"!!!\\n\");\n            pthread_mutex_lock(&pcap_mutex);\n            int ret=pcap_next_ex(pcap_handle,&packet_header,&pkt_data);\n            pthread_mutex_unlock(&pcap_mutex);\n\n            switch (ret)\n            {\n                    case 0:\n                            continue;\n                    case 1:\n\n                            break;\n\n                    case -1:\n                            mylog(log_fatal,\"pcap_next_ex error [%s]\\n\",pcap_geterr(pcap_handle));\n                            myexit(-1);\n                            break;\n                    case -2:\n                            assert(0==1);//\n                            break;\n                    default:\n                            assert(0==1);//\n            }\n    }\n    myexit(-1);*/\n    return 0;\n}\n\nextern void async_cb(struct ev_loop *loop, struct ev_async *watcher, int revents);\n#endif\n\n#ifdef UDP2RAW_LINUX\nint init_raw_socket() {\n    assert(raw_ip_version == AF_INET || raw_ip_version == AF_INET6);\n\n    g_ip_id_counter = get_true_random_number() % 65535;\n    if (lower_level == 0) {\n        raw_send_fd = socket(raw_ip_version, SOCK_RAW, IPPROTO_RAW);  // IPPROTO_TCP??\n\n        if (raw_send_fd == -1) {\n            mylog(log_fatal, \"Failed to create raw_send_fd\\n\");\n            // perror(\"Failed to create raw_send_fd\");\n            myexit(1);\n        }\n\n        /*ETH_P_IP\n        int one = 1;\n        const int *val = &one;\n        if (setsockopt (raw_send_fd, IPPROTO_IP, IP_HDRINCL, val, sizeof (one)) < 0) {\n            mylog(log_fatal,\"Error setting IP_HDRINCL %d\\n\",errno);\n            //perror(\"Error setting IP_HDRINCL\");\n            myexit(2);\n        }*/\n\n    } else {\n        raw_send_fd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));  // todo  how to create a recv only raw socket?\n\n        if (raw_send_fd == -1) {\n            mylog(log_fatal, \"Failed to create raw_send_fd\\n\");\n            // perror(\"Failed to create raw_send_fd\");\n            myexit(1);\n        }\n        // init_ifindex(if_name);\n    }\n\n    int opt = 0;\n    assert(setsockopt(raw_send_fd, SOL_SOCKET, SO_RCVBUF, &opt, sizeof(opt)) == 0);  // raw_send_fd is for send only, set its recv buffer to zero\n\n    if (force_socket_buf) {\n        if (setsockopt(raw_send_fd, SOL_SOCKET, SO_SNDBUFFORCE, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_SNDBUFFORCE fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, strerror(errno));\n            myexit(1);\n        }\n    } else {\n        if (setsockopt(raw_send_fd, SOL_SOCKET, SO_SNDBUF, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_SNDBUF fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, strerror(errno));\n            myexit(1);\n        }\n    }\n\n    // raw_fd = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ALL));\n\n    if (raw_ip_version == AF_INET)\n        raw_recv_fd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));\n    else\n        raw_recv_fd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IPV6));\n    // ETH_P_IP doesnt read outgoing packets\n    //    https://stackoverflow.com/questions/20264895/eth-p-ip-is-not-working-as-expected-i-can-only-receive-incoming-packets\n    //    to capture both incoming and outgoing packets use ETH_P_ALL\n\n    if (raw_recv_fd == -1) {\n        mylog(log_fatal, \"Failed to create raw_recv_fd\\n\");\n        // perror(\"\");\n        myexit(1);\n    }\n    if (strlen(dev) != 0) {\n        struct sockaddr_ll bind_address;\n        memset(&bind_address, 0, sizeof(bind_address));\n\n        int index = -1;\n        assert(init_ifindex(dev, raw_recv_fd, index) == 0);\n\n        bind_address.sll_family = AF_PACKET;\n        if (raw_ip_version == AF_INET)\n            bind_address.sll_protocol = htons(ETH_P_IP);\n        else\n            bind_address.sll_protocol = htons(ETH_P_IPV6);\n        bind_address.sll_ifindex = index;\n\n        if (bind(raw_recv_fd, (struct sockaddr *)&bind_address, sizeof(bind_address)) == -1) {\n            mylog(log_fatal, \"bind to dev [%s] failed\\n\", dev);\n            myexit(1);\n        }\n    }\n\n    if (force_socket_buf) {\n        if (setsockopt(raw_recv_fd, SOL_SOCKET, SO_RCVBUFFORCE, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_RCVBUFFORCE fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, strerror(errno));\n            myexit(1);\n        }\n    } else {\n        if (setsockopt(raw_recv_fd, SOL_SOCKET, SO_RCVBUF, &socket_buf_size, sizeof(socket_buf_size)) < 0) {\n            mylog(log_fatal, \"SO_RCVBUF fail  socket_buf_size=%d  errno=%s\\n\", socket_buf_size, strerror(errno));\n            myexit(1);\n        }\n    }\n\n    // IP_HDRINCL to tell the kernel that headers are included in the packet\n\n    setnonblocking(raw_send_fd);  // not really necessary\n    setnonblocking(raw_recv_fd);\n\n    return 0;\n}\n#endif\n#ifdef UDP2RAW_MP\nint init_raw_socket() {\n#ifndef NO_LIBNET\n    char libnet_errbuf[LIBNET_ERRBUF_SIZE];\n\n    if (raw_ip_version == AF_INET) {\n        libnet_handle = libnet_init(LIBNET_RAW4, dev, libnet_errbuf);\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        libnet_handle = libnet_init(LIBNET_RAW6, dev, libnet_errbuf);\n    }\n\n    if (libnet_handle == 0) {\n        mylog(log_fatal, \"libnet_init failed bc of [%s]\\n\", libnet_errbuf);\n        myexit(-1);\n    }\n    g_ptag = 0;\n    libnet_clear_packet(libnet_handle);\n#endif\n\n    char pcap_errbuf[PCAP_ERRBUF_SIZE];\n\n    // pcap_handle=pcap_open_live(dev,max_data_len,0,1000,pcap_errbuf);\n\n    pcap_handle = pcap_create(dev, pcap_errbuf);\n\n    if (pcap_handle == 0) {\n        mylog(log_fatal, \"pcap_create failed bc of [%s]\\n\", pcap_errbuf);\n        myexit(-1);\n    }\n\n    assert(pcap_set_snaplen(pcap_handle, huge_data_len) == 0);\n    assert(pcap_set_promisc(pcap_handle, 0) == 0);\n    assert(pcap_set_timeout(pcap_handle, 1) == 0);\n    assert(pcap_set_immediate_mode(pcap_handle, 1) == 0);\n\n    int ret = pcap_activate(pcap_handle);\n    if (ret < 0) {\n        printf(\"pcap_activate failed  %s\\n\", pcap_geterr(pcap_handle));\n        myexit(-1);\n    }\n\n    if (send_with_pcap) {\n        ret = pcap_setdirection(pcap_handle, PCAP_D_INOUT);  // must be used after being actived\n        if (ret != 0) mylog(log_debug, \"pcap_setdirection(pcap_handle,PCAP_D_INOUT) failed with value %d, %s\\n\", ret, pcap_geterr(pcap_handle));\n    } else {\n        ret = pcap_setdirection(pcap_handle, PCAP_D_IN);\n        if (ret != 0) mylog(log_debug, \"pcap_setdirection(pcap_handle,PCAP_D_IN) failed with value %d, %s\\n\", ret, pcap_geterr(pcap_handle));\n    }\n\n    ret = pcap_datalink(pcap_handle);\n\n    if (ret == DLT_EN10MB) {\n        pcap_link_header_len = 14;\n    } else if (ret == DLT_NULL) {\n        pcap_link_header_len = 4;\n    } else if (ret == DLT_LINUX_SLL) {\n        pcap_link_header_len = 16;\n    } else {\n        mylog(log_fatal, \"unknown pcap link type : %d\\n\", ret);\n        myexit(-1);\n    }\n\n    char filter_exp[1000];\n\n    address_t tmp_addr;\n    if (get_src_adress2(tmp_addr, remote_addr) != 0) {\n        mylog(log_error, \"get_src_adress() failed, maybe you dont have internet\\n\");\n        myexit(-1);\n    }\n\n    string src = tmp_addr.get_ip();\n    string dst = remote_addr.get_ip();\n    if (raw_ip_version == AF_INET) {\n        // sprintf(filter_exp,\"ip and src %s and dst %s and (tcp or udp or icmp)\",my_ntoa(source_ip_uint32),dst.c_str());\n        sprintf(filter_exp, \"ip and src %s and dst %s and (tcp or udp or icmp)\", src.c_str(), dst.c_str());\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        sprintf(filter_exp, \"ip6 and src %s and dst %s and (tcp or udp or icmp6)\", src.c_str(), dst.c_str());\n    }\n\n    if (pcap_compile(pcap_handle, &g_filter, filter_exp, 0, PCAP_NETMASK_UNKNOWN) == -1) {\n        printf(\"Bad filter - %s\\n\", pcap_geterr(pcap_handle));\n        myexit(-1);\n    }\n    g_filter_compile_cnt++;\n\n    if (pcap_setfilter(pcap_handle, &g_filter) == -1) {\n        printf(\"Error setting filter - %s\\n\", pcap_geterr(pcap_handle));\n        myexit(-1);\n    }\n\n    ///////////////////////////////////////////////////////////////new thread created here\n    if (pthread_create(&pcap_recv_thread, NULL, pcap_recv_thread_entry, 0)) {\n        mylog(log_fatal, \"Error creating thread\\n\");\n        myexit(-1);\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n\n    g_ip_id_counter = get_true_random_number() % 65535;\n\n    /*\n    if(lower_level==0)\n    {\n            raw_send_fd = socket(AF_INET , SOCK_RAW , IPPROTO_TCP);\n\n        if(raw_send_fd == -1) {\n            mylog(log_fatal,\"Failed to create raw_send_fd\\n\");\n            //perror(\"Failed to create raw_send_fd\");\n            myexit(1);\n        }\n\n        int one = 1;\n        const int *val = &one;\n        if (setsockopt (raw_send_fd, IPPROTO_IP, IP_HDRINCL, val, sizeof (one)) < 0) {\n            mylog(log_fatal,\"Error setting IP_HDRINCL %d\\n\",errno);\n            //perror(\"Error setting IP_HDRINCL\");\n            myexit(2);\n        }\n\n\n    }\n    else\n    {\n            raw_send_fd = socket(PF_PACKET , SOCK_DGRAM , htons(ETH_P_IP));\n\n        if(raw_send_fd == -1) {\n            mylog(log_fatal,\"Failed to create raw_send_fd\\n\");\n            //perror(\"Failed to create raw_send_fd\");\n            myexit(1);\n        }\n            //init_ifindex(if_name);\n\n    }\n\n    if(force_socket_buf)\n    {\n            if(setsockopt(raw_send_fd, SOL_SOCKET, SO_SNDBUFFORCE, &socket_buf_size, sizeof(socket_buf_size))<0)\n            {\n                    mylog(log_fatal,\"SO_SNDBUFFORCE fail  socket_buf_size=%d  errno=%s\\n\",socket_buf_size,strerror(errno));\n                    myexit(1);\n            }\n    }\n    else\n    {\n            if(setsockopt(raw_send_fd, SOL_SOCKET, SO_SNDBUF, &socket_buf_size, sizeof(socket_buf_size))<0)\n            {\n                    mylog(log_fatal,\"SO_SNDBUF fail  socket_buf_size=%d  errno=%s\\n\",socket_buf_size,strerror(errno));\n                    myexit(1);\n            }\n    }\n\n\n\n    //raw_fd = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ALL));\n\n    raw_recv_fd= socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));\n\nif(raw_recv_fd == -1) {\n    mylog(log_fatal,\"Failed to create raw_recv_fd\\n\");\n    //perror(\"\");\n    myexit(1);\n}\n\n    if(force_socket_buf)\n    {\n            if(setsockopt(raw_recv_fd, SOL_SOCKET, SO_RCVBUFFORCE, &socket_buf_size, sizeof(socket_buf_size))<0)\n            {\n                    mylog(log_fatal,\"SO_RCVBUFFORCE fail  socket_buf_size=%d  errno=%s\\n\",socket_buf_size,strerror(errno));\n                    myexit(1);\n            }\n    }\n    else\n    {\n            if(setsockopt(raw_recv_fd, SOL_SOCKET, SO_RCVBUF, &socket_buf_size, sizeof(socket_buf_size))<0)\n            {\n                    mylog(log_fatal,\"SO_RCVBUF fail  socket_buf_size=%d  errno=%s\\n\",socket_buf_size,strerror(errno));\n                    myexit(1);\n            }\n    }\n\n//IP_HDRINCL to tell the kernel that headers are included in the packet\n\n\n\nsetnonblocking(raw_send_fd); //not really necessary\nsetnonblocking(raw_recv_fd);*/\n\n    return 0;\n}\n#endif\n#ifdef UDP2RAW_LINUX\nvoid init_filter(int port) {\n    sock_fprog bpf;\n    assert(raw_ip_version == AF_INET || raw_ip_version == AF_INET6);\n    if (raw_mode == mode_faketcp || raw_mode == mode_udp) {\n        filter_port = port;\n    }\n    if (disable_bpf_filter) return;\n    // if(raw_mode==mode_icmp) return ;\n    // code_tcp[8].k=code_tcp[10].k=port;\n    if (raw_mode == mode_faketcp) {\n        if (raw_ip_version == AF_INET) {\n            bpf.len = sizeof(code_tcp) / sizeof(code_tcp[0]);\n            code_tcp[code_tcp_port_index].k = port;\n            bpf.filter = code_tcp;\n        } else {\n            bpf.len = sizeof(code_tcp6) / sizeof(code_tcp6[0]);\n            code_tcp6[code_tcp6_port_index].k = port;\n            bpf.filter = code_tcp6;\n        }\n    } else if (raw_mode == mode_udp) {\n        if (raw_ip_version == AF_INET) {\n            bpf.len = sizeof(code_udp) / sizeof(code_udp[0]);\n            code_udp[code_udp_port_index].k = port;\n            bpf.filter = code_udp;\n        } else {\n            bpf.len = sizeof(code_udp6) / sizeof(code_udp6[0]);\n            code_udp6[code_udp6_port_index].k = port;\n            bpf.filter = code_udp6;\n        }\n    } else if (raw_mode == mode_icmp) {\n        if (raw_ip_version == AF_INET) {\n            bpf.len = sizeof(code_icmp) / sizeof(code_icmp[0]);\n            bpf.filter = code_icmp;\n        } else {\n            bpf.len = sizeof(code_icmp6) / sizeof(code_icmp6[0]);\n            bpf.filter = code_icmp6;\n        }\n    }\n\n    int dummy=0;\n\n    int ret = setsockopt(raw_recv_fd, SOL_SOCKET, SO_DETACH_FILTER, &dummy, sizeof(dummy));  // in case i forgot to remove\n    if (ret != 0) {\n        mylog(log_debug, \"error remove fiter\\n\");\n        // perror(\"filter\");\n        // exit(-1);\n    }\n    ret = setsockopt(raw_recv_fd, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf));\n    if (ret != 0) {\n        mylog(log_fatal, \"error set fiter\\n\");\n        // perror(\"filter\");\n        myexit(-1);\n    }\n}\n#endif\n\n#ifdef UDP2RAW_MP\nvoid init_filter(int port) {\n    /*\n    sock_fprog bpf;*/\n    if (raw_mode == mode_faketcp || raw_mode == mode_udp) {\n        filter_port = port;\n    }\n\n    char filter_exp[1000];\n\n    if (raw_ip_version == AF_INET) {\n        if (raw_mode == mode_faketcp) {\n            sprintf(filter_exp, \"ip and tcp and src %s and src port %d and dst port %d\", remote_addr.get_ip(), remote_addr.get_port(), port);\n        } else if (raw_mode == mode_udp) {\n            sprintf(filter_exp, \"ip and udp and src %s and src port %d and dst port %d\", remote_addr.get_ip(), remote_addr.get_port(), port);\n        } else if (raw_mode == mode_icmp) {\n            sprintf(filter_exp, \"ip and icmp and src %s\", remote_addr.get_ip());\n        } else {\n            mylog(log_fatal, \"unknow raw mode\\n\");\n            myexit(-1);\n        }\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        if (raw_mode == mode_faketcp) {\n            sprintf(filter_exp, \"ip6 and tcp and src %s and src port %d and dst port %d\", remote_addr.get_ip(), remote_addr.get_port(), port);\n        } else if (raw_mode == mode_udp) {\n            sprintf(filter_exp, \"ip6 and udp and src %s and src port %d and dst port %d\", remote_addr.get_ip(), remote_addr.get_port(), port);\n        } else if (raw_mode == mode_icmp) {\n            sprintf(filter_exp, \"ip6 and icmp6 and src %s\", remote_addr.get_ip());\n        } else {\n            mylog(log_fatal, \"unknow raw mode\\n\");\n            myexit(-1);\n        }\n    }\n\n    mylog(log_info, \"filter expression is [%s]\\n\", filter_exp);\n\n    // pthread_mutex_lock(&pcap_mutex);//not sure if mutex is needed here\n\n    long long tmp_cnt = 0;\n    if (use_pcap_mutex) {\n        while (pthread_mutex_trylock(&pcap_mutex) != 0) {\n            tmp_cnt++;\n            pcap_breakloop(pcap_handle);\n            if (tmp_cnt == 100) {\n                mylog(log_warn, \"%lld attempts of pcap_breakloop()\\n\", tmp_cnt);\n            }\n            if (tmp_cnt % 1000 == 0) {\n                mylog(log_warn, \"%lld attempts of pcap_breakloop()\\n\", tmp_cnt);\n                if (tmp_cnt > 5000) {\n                    mylog(log_fatal, \"we might have already run into a deadlock\\n\");\n                }\n            }\n            ev_sleep(0.001);\n        }\n        mylog(log_info, \"breakloop() succeed after %lld attempt(s)\\n\", tmp_cnt);\n    }\n\n    if (1) {\n        int ret = pcap_setdirection(pcap_handle, PCAP_D_IN);\n        if (ret != 0) mylog(log_debug, \"pcap_setdirection(pcap_handle,PCAP_D_IN) failed with value %d, %s\\n\", ret, pcap_geterr(pcap_handle));\n    }\n\n    assert(g_filter_compile_cnt != 0);\n    pcap_freecode(&g_filter);\n\n    if (pcap_compile(pcap_handle, &g_filter, filter_exp, 0, PCAP_NETMASK_UNKNOWN) == -1) {\n        mylog(log_fatal, \"Bad filter - %s\\n\", pcap_geterr(pcap_handle));\n        myexit(-1);\n    }\n    g_filter_compile_cnt++;\n\n    if (pcap_setfilter(pcap_handle, &g_filter) == -1) {\n        mylog(log_fatal, \"Error setting filter - %s\\n\", pcap_geterr(pcap_handle));\n        myexit(-1);\n    }\n\n    if (use_pcap_mutex) pthread_mutex_unlock(&pcap_mutex);\n    /*\n    if(disable_bpf_filter) return;\n    //if(raw_mode==mode_icmp) return ;\n    //code_tcp[8].k=code_tcp[10].k=port;\n    if(raw_mode==mode_faketcp)\n    {\n            bpf.len = sizeof(code_tcp)/sizeof(code_tcp[0]);\n            code_tcp[code_tcp_port_index].k=port;\n            bpf.filter = code_tcp;\n    }\n    else if(raw_mode==mode_udp)\n    {\n            bpf.len = sizeof(code_udp)/sizeof(code_udp[0]);\n            code_udp[code_udp_port_index].k=port;\n            bpf.filter = code_udp;\n    }\n    else if(raw_mode==mode_icmp)\n    {\n            bpf.len = sizeof(code_icmp)/sizeof(code_icmp[0]);\n            bpf.filter = code_icmp;\n    }\n\n    int dummy;\n\n    int ret=setsockopt(raw_recv_fd, SOL_SOCKET, SO_DETACH_FILTER, &dummy, sizeof(dummy)); //in case i forgot to remove\n    if (ret != 0)\n    {\n            mylog(log_debug,\"error remove fiter\\n\");\n            //perror(\"filter\");\n            //exit(-1);\n    }\n    ret = setsockopt(raw_recv_fd, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf));\n    if (ret != 0)\n    {\n            mylog(log_fatal,\"error set fiter\\n\");\n            //perror(\"filter\");\n            myexit(-1);\n    }*/\n}\n#endif\n\nvoid remove_filter() {\n    filter_port = 0;\n#ifdef UDP2RAW_LINUX\n    int dummy=0;\n    int ret = setsockopt(raw_recv_fd, SOL_SOCKET, SO_DETACH_FILTER, &dummy, sizeof(dummy));\n    if (ret != 0) {\n        mylog(log_debug, \"error remove fiter\\n\");\n        // perror(\"filter\");\n        // exit(-1);\n    }\n#endif\n}\n\nint init_ifindex(const char *if_name, int fd, int &index) {\n#ifdef UDP2RAW_LINUX\n    struct ifreq ifr;\n    size_t if_name_len = strlen(if_name);\n    if (if_name_len < sizeof(ifr.ifr_name)) {\n        memcpy(ifr.ifr_name, if_name, if_name_len);\n        ifr.ifr_name[if_name_len] = 0;\n    } else {\n        mylog(log_fatal, \"interface name is too long\\n\");\n        myexit(-1);\n    }\n    if (ioctl(fd, SIOCGIFINDEX, &ifr) == -1) {\n        mylog(log_fatal, \"SIOCGIFINDEX fail ,%s\\n\", strerror(errno));\n        myexit(-1);\n    }\n    index = ifr.ifr_ifindex;\n    mylog(log_info, \"ifname:%s  ifindex:%d\\n\", if_name, index);\n#endif\n    return 0;\n}\n\n#ifdef UDP2RAW_LINUX\nbool interface_has_arp(const char *interface) {\n    struct ifreq ifr;\n    // int sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n    int sock = raw_send_fd;\n    memset(&ifr, 0, sizeof(ifr));\n    strcpy(ifr.ifr_name, interface);\n    if (ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {\n        // perror(\"SIOCGIFFLAGS\");\n        mylog(log_fatal, \"ioctl(sock, SIOCGIFFLAGS, &ifr) failed for interface %s,errno %s\\n\", interface, strerror(errno));\n        myexit(-1);\n    }\n    // close(sock);\n    return !(ifr.ifr_flags & IFF_NOARP);\n}\nstruct route_info_t {\n    string if_name;\n    u32_t dest;\n    u32_t mask;\n    u32_t gw;\n    u32_t flag;\n};\nint dest_idx = 1;\nint gw_idx = 2;\nint if_idx = 0;\nint mask_idx = 7;\nint flag_idx = 3;\nvector<int> find_route_entry(const vector<route_info_t> &route_info_vec, u32_t ip) {\n    vector<int> res;\n    for (u32_t i = 0; i <= 32; i++) {\n        u32_t mask = 0xffffffff;\n        // mask >>=i;\n        // if(i==32) mask=0;  //why 0xffffffff>>32  equals 0xffffffff??\n\n        mask <<= i;\n        if (i == 32) mask = 0;\n        log_bare(log_debug, \"(mask:%x)\", mask);\n        for (u32_t j = 0; j < route_info_vec.size(); j++) {\n            const route_info_t &info = route_info_vec[j];\n            if (info.mask != mask)\n                continue;\n            log_bare(log_debug, \"<<%d,%d>>\", i, j);\n            if ((info.dest & mask) == (ip & mask)) {\n                log_bare(log_debug, \"found!\");\n                res.push_back(j);\n            }\n        }\n        if (res.size() != 0) {\n            return res;\n        }\n    }\n    return res;\n}\nint find_direct_dest(const vector<route_info_t> &route_info_vec, u32_t ip, u32_t &dest_ip, string &if_name) {\n    vector<int> res;\n    for (int i = 0; i < 1000; i++) {\n        res = find_route_entry(route_info_vec, ip);\n        log_bare(log_debug, \"<entry:%u>\", (u32_t)res.size());\n        if (res.size() == 0) {\n            mylog(log_error, \"cant find route entry\\n\");\n            return -1;\n        }\n        if (res.size() > 1) {\n            mylog(log_error, \"found duplicated entries\\n\");\n            return -1;\n        }\n        if ((route_info_vec[res[0]].flag & 2) == 0) {\n            dest_ip = ip;\n            if_name = route_info_vec[res[0]].if_name;\n            return 0;\n        } else {\n            ip = route_info_vec[res[0]].gw;\n        }\n    }\n    mylog(log_error, \"dead loop in find_direct_dest\\n\");\n    return -1;\n}\nstruct arp_info_t {\n    u32_t ip;\n    string hw;\n    string if_name;\n};\nint arp_ip_idx = 0;\nint arp_hw_idx = 3;\nint arp_if_idx = 5;\n\nint find_arp(const vector<arp_info_t> &arp_info_vec, u32_t ip, string if_name, string &hw) {\n    int pos = -1;\n    int count = 0;\n    for (u32_t i = 0; i < arp_info_vec.size(); i++) {\n        const arp_info_t &info = arp_info_vec[i];\n        if (info.if_name != if_name) continue;\n        if (info.ip == ip) {\n            count++;\n            pos = i;\n        }\n    }\n    if (count == 0) {\n        // mylog(log_warn,\"cant find arp entry for %s %s,using 00:00:00:00:00:00\\n\",my_ntoa(ip),if_name.c_str());\n        // hw=\"00:00:00:00:00:00\";\n        mylog(log_error, \"cant find arp entry for %s %s\\n\", my_ntoa(ip), if_name.c_str());\n        return -1;\n    }\n    if (count > 1) {\n        mylog(log_error, \"find multiple arp entry for %s %s\\n\", my_ntoa(ip), if_name.c_str());\n        return -1;\n    }\n    hw = arp_info_vec[pos].hw;\n    return 0;\n}\nint find_lower_level_info(u32_t ip, u32_t &dest_ip, string &if_name, string &hw) {\n    ip = htonl(ip);\n    if (ip == htonl(inet_addr(\"127.0.0.1\"))) {\n        dest_ip = ntohl(ip);\n        if_name = \"lo\";\n        hw = \"00:00:00:00:00:00\";\n        return 0;\n    }\n\n    string route_file;\n    if (read_file(\"/proc/net/route\", route_file) != 0) return -1;\n    string arp_file;\n    if (read_file(\"/proc/net/arp\", arp_file) != 0) return -1;\n\n    log_bare(log_debug, \"/proc/net/route:<<%s>>\\n\", route_file.c_str());\n    log_bare(log_debug, \"/proc/net/arp:<<%s>>\\n\", route_file.c_str());\n\n    auto route_vec2 = string_to_vec2(route_file.c_str());\n    vector<route_info_t> route_info_vec;\n    for (u32_t i = 1; i < route_vec2.size(); i++) {\n        log_bare(log_debug, \"<size:%u>\", (u32_t)route_vec2[i].size());\n        if (route_vec2[i].size() != 11) {\n            mylog(log_error, \"route coloum %d !=11 \\n\", int(route_vec2[i].size()));\n            return -1;\n        }\n        route_info_t tmp;\n        tmp.if_name = route_vec2[i][if_idx];\n        if (hex_to_u32_with_endian(route_vec2[i][dest_idx], tmp.dest) != 0) return -1;\n        if (hex_to_u32_with_endian(route_vec2[i][gw_idx], tmp.gw) != 0) return -1;\n        if (hex_to_u32_with_endian(route_vec2[i][mask_idx], tmp.mask) != 0) return -1;\n        if (hex_to_u32(route_vec2[i][flag_idx], tmp.flag) != 0) return -1;\n        route_info_vec.push_back(tmp);\n        for (u32_t j = 0; j < route_vec2[i].size(); j++) {\n            log_bare(log_debug, \"<%s>\", route_vec2[i][j].c_str());\n        }\n        log_bare(log_debug, \"%s dest:%x mask:%x gw:%x flag:%x\", tmp.if_name.c_str(), tmp.dest, tmp.mask, tmp.gw, tmp.flag);\n        log_bare(log_debug, \"\\n\");\n    }\n\n    if (find_direct_dest(route_info_vec, ip, dest_ip, if_name) != 0) {\n        mylog(log_error, \"find_direct_dest failed for ip %s\\n\", my_ntoa(ntohl(ip)));\n        return -1;\n    }\n\n    log_bare(log_debug, \"========\\n\");\n    auto arp_vec2 = string_to_vec2(arp_file.c_str());\n    vector<arp_info_t> arp_info_vec;\n    for (u32_t i = 1; i < arp_vec2.size(); i++) {\n        log_bare(log_debug, \"<<arp_vec2[i].size(): %d>>\", (int)arp_vec2[i].size());\n\n        for (u32_t j = 0; j < arp_vec2[i].size(); j++) {\n            log_bare(log_debug, \"<%s>\", arp_vec2[i][j].c_str());\n        }\n        if (arp_vec2[i].size() != 6) {\n            mylog(log_error, \"arp coloum %d !=11 \\n\", int(arp_vec2[i].size()));\n            return -1;\n        }\n        arp_info_t tmp;\n        tmp.if_name = arp_vec2[i][arp_if_idx];\n        tmp.hw = arp_vec2[i][arp_hw_idx];\n        tmp.ip = htonl(inet_addr(arp_vec2[i][arp_ip_idx].c_str()));\n        arp_info_vec.push_back(tmp);\n        log_bare(log_debug, \"\\n\");\n    }\n    if (!interface_has_arp(if_name.c_str())) {\n        mylog(log_info, \"%s is a noarp interface,using 00:00:00:00:00:00\\n\", if_name.c_str());\n        hw = \"00:00:00:00:00:00\";\n    } else if (find_arp(arp_info_vec, dest_ip, if_name, hw) != 0) {\n        mylog(log_error, \"find_arp failed for dest_ip %s ,if_name %s\\n\", my_ntoa(ntohl(ip)), if_name.c_str());\n        return -1;\n    }\n    // printf(\"%s\\n\",hw.c_str());\n\n    dest_ip = ntohl(dest_ip);\n    return 0;\n}\n#endif\n\n#ifdef UDP2RAW_LINUX\nint send_raw_packet(raw_info_t &raw_info, const char *packet, int len) {\n    const packet_info_t &send_info = raw_info.send_info;\n    const packet_info_t &recv_info = raw_info.recv_info;\n\n    int ret;\n    if (lower_level == 0) {\n        if (raw_ip_version == AF_INET) {\n            struct sockaddr_in sin = {0};\n            sin.sin_family = raw_ip_version;\n            // sin.sin_port = htons(info.dst_port); //dont need this\n            sin.sin_addr.s_addr = send_info.new_dst_ip.v4;\n            ret = sendto(raw_send_fd, packet, len, 0, (struct sockaddr *)&sin, sizeof(sin));\n        } else if (raw_ip_version == AF_INET6) {\n            struct sockaddr_in6 sin = {0};\n            sin.sin6_family = raw_ip_version;\n            // sin.sin_port = htons(info.dst_port); //dont need this\n            sin.sin6_addr = send_info.new_dst_ip.v6;\n            ret = sendto(raw_send_fd, packet, len, 0, (struct sockaddr *)&sin, sizeof(sin));\n        } else {\n            assert(0 == 1);\n        }\n\n    } else {\n        struct sockaddr_ll addr = {0};  //={0} not necessary\n        memcpy(&addr, &send_info.addr_ll, sizeof(addr));\n\n        ret = sendto(raw_send_fd, packet, len, 0, (struct sockaddr *)&addr, sizeof(addr));\n    }\n    if (ret == -1) {\n        mylog(log_trace, \"sendto failed\\n\");\n        // perror(\"why?\");\n        return -1;\n    } else {\n        // mylog(log_info,\"sendto succ\\n\");\n    }\n    return 0;\n}\n#endif\n\n#ifdef UDP2RAW_MP\n\nint send_raw_packet(raw_info_t &raw_info, const char *packet, int len) {\n    const packet_info_t &send_info = raw_info.send_info;\n    const packet_info_t &recv_info = raw_info.recv_info;\n\n    if (!send_with_pcap) {\n#ifndef NO_LIBNET\n\n        // g_ptag=libnet_build_ipv4(ip_tot_len, iph->tos, ntohs(iph->id), ntohs(iph->frag_off),\n        //\tiph->ttl , iph->protocol , iph->check , iph->saddr, iph->daddr,\n        //\t(const unsigned char *)payload, payloadlen, libnet_handle, g_ptag);\n\n        // assert(g_ptag!=-1 &&g_ptag!=0);\n\n        // int ret;\n        // ret= libnet_write(libnet_handle);\n\n        // assert(ret!=-1);\n\n        // iph->tot_len=htons(ip_tot_len);\n        // iph->check =csum ((unsigned short *) send_raw_ip_buf, iph->ihl*4);\n        if (raw_ip_version == AF_INET) {\n            libnet_write_raw_ipv4(libnet_handle, (const unsigned char *)packet, len);  // todo, this api is marked as internal, maybe we should avoid using it.\n        } else {\n            assert(raw_ip_version == AF_INET6);\n            libnet_write_raw_ipv6(libnet_handle, (const unsigned char *)packet, len);\n        }\n#endif\n    } else {\n        char buf[buf_len];\n        assert(pcap_header_captured == 1);\n        assert(pcap_link_header_len != -1);\n        memcpy(buf, pcap_header_buf, pcap_link_header_len);\n        memcpy(buf + pcap_link_header_len, packet, len);\n        // pthread_mutex_lock(&pcap_mutex); looks like this is not necessary, and it harms performance\n        int ret = pcap_sendpacket(pcap_handle, (const unsigned char *)buf, len + pcap_link_header_len);\n        if (ret != 0) {\n            mylog(log_warn, \"pcap_sendpcaket failed with vaule %d,%s, data_len=%d\\n\", ret, pcap_geterr(pcap_handle), len);\n            // pthread_mutex_unlock(&pcap_mutex);\n            // myexit(-1);\n        }\n        // pthread_mutex_unlock(&pcap_mutex);\n        /*\nunsigned char *p=(unsigned char *)send_raw_ip_buf0;\nfor(int i=0;i<ip_tot_len+pcap_link_header_len;i++)\n        printf(\"<%02x>\",int(p[i]));\nprintf(\"\\n\");\nassert(pcap_sendpacket(pcap_handle,(const unsigned char *)pcap_header_buf,cap_len)==0);\np=(unsigned char *)pcap_header_buf;\nfor(int i=0;i<cap_len;i++)\n        printf(\"<%02x>\",int(p[i]));\nprintf(\"\\n\");\nprintf(\"pcap send!\\n\");*/\n    }\n    return 0;\n}\n#endif\n\nint send_raw_ip(raw_info_t &raw_info, const char *payload, int payloadlen) {\n    const packet_info_t &send_info = raw_info.send_info;\n    const packet_info_t &recv_info = raw_info.recv_info;\n    char send_raw_ip_buf[buf_len];\n\n    if (raw_info.disabled) {\n        mylog(log_debug, \"[%s,%d]connection disabled, no packet will be sent\\n\", recv_info.new_src_ip.get_str1(), recv_info.src_port);\n        assert(max_rst_allowed >= 0);\n        return 0;\n    }\n\n    uint16_t ip_tot_len;\n    if (raw_ip_version == AF_INET) {\n        struct my_iphdr *iph = (struct my_iphdr *)send_raw_ip_buf;\n        memset(iph, 0, sizeof(my_iphdr));\n\n        iph->ihl = sizeof(my_iphdr) / 4;  // we dont use ip options,so the length is just sizeof(iphdr)\n        iph->version = 4;\n        iph->tos = 0;\n\n        if (lower_level) {\n            // iph->id=0;\n            iph->id = htons(g_ip_id_counter++);  // Id of this packet\n        } else                                   // no need to else?\n        {\n            iph->id = htons(g_ip_id_counter++);  // Id of this packet\n            // iph->id = 0; //Id of this packet  ,kernel will auto fill this if id is zero  ,or really?????// todo //seems like there is a problem\n        }\n\n        iph->frag_off = htons(0x4000);  // DF set,others are zero\n        // iph->frag_off = htons(0x0000); //DF set,others are zero\n        iph->ttl = (unsigned char)ttl_value;\n        iph->protocol = send_info.protocol;\n        iph->check = 0;                        // Set to 0 before calculating checksum\n        iph->saddr = send_info.new_src_ip.v4;  // Spoof the source ip address\n        iph->daddr = send_info.new_dst_ip.v4;\n\n        ip_tot_len = sizeof(struct my_iphdr) + payloadlen;\n#ifdef UDP2RAW_LINUX\n        if (lower_level)\n            iph->tot_len = htons(ip_tot_len);  // this is not necessary ,kernel will always auto fill this  //http://man7.org/linux/man-pages/man7/raw.7.html\n        else\n            iph->tot_len = 0;\n#endif\n\n#ifdef UDP2RAW_MP\n        iph->tot_len = htons(ip_tot_len);  // always fill for mp version\n#endif\n\n        memcpy(send_raw_ip_buf + sizeof(my_iphdr), payload, payloadlen);\n\n#ifdef UDP2RAW_LINUX\n        if (lower_level)\n            iph->check =\n                csum((unsigned short *)send_raw_ip_buf, iph->ihl * 4);  // this is not necessary ,kernel will always auto fill this\n        else\n            iph->check = 0;\n#endif\n\n#ifdef UDP2RAW_MP\n        iph->check = csum((unsigned short *)send_raw_ip_buf, iph->ihl * 4);  // always cal checksum for mp version\n#endif\n    } else {\n        assert(raw_ip_version == AF_INET6);\n\n        struct my_ip6hdr *ip6h = (struct my_ip6hdr *)send_raw_ip_buf;\n        memset(ip6h, 0, sizeof(my_ip6hdr));\n\n        ip6h->version = 6;\n        ip6h->payload_len = htons(payloadlen);\n        ip6h->next_header = send_info.protocol;\n        ip6h->hop_limit = (unsigned char)ttl_value;\n        ip6h->src = send_info.new_src_ip.v6;\n        ip6h->dst = send_info.new_dst_ip.v6;\n\n        ip_tot_len = sizeof(struct my_ip6hdr) + payloadlen;\n        memcpy(send_raw_ip_buf + sizeof(my_ip6hdr), payload, payloadlen);\n    }\n\n    return send_raw_packet(raw_info, send_raw_ip_buf, ip_tot_len);\n}\n\nint pre_recv_raw_packet() {\n#ifdef UDP2RAW_LINUX\n    assert(g_packet_buf_cnt == 0);\n\n    g_sockaddr_len = sizeof(g_sockaddr.ll);\n    g_packet_buf_len = recvfrom(raw_recv_fd, g_packet_buf, huge_data_len + 1, 0, (sockaddr *)&g_sockaddr, &g_sockaddr_len);\n    // assert(g_sockaddr_len==sizeof(g_sockaddr.ll)); //g_sockaddr_len=18, sizeof(g_sockaddr.ll)=20, why its not equal? maybe its bc sll_halen is 6?\n\n    // assert(g_addr_ll_size==sizeof(g_addr_ll));\n\n    if (g_packet_buf_len == huge_data_len + 1) {\n        if (g_fix_gro == 0) {\n            mylog(log_warn, \"huge packet, data_len %d > %d,dropped\\n\", g_packet_buf_len, huge_data_len);\n            return -1;\n        } else {\n            mylog(log_debug, \"huge packet, data_len %d > %d,not dropped\\n\", g_packet_buf_len, huge_data_len);\n            g_packet_buf_len = huge_data_len;\n        }\n    }\n\n    if (g_packet_buf_len >= max_data_len + 1) {\n        if (g_fix_gro == 0) {\n            mylog(log_warn, \"huge packet, data_len %d > %d(max_data_len) dropped, maybe you need to turn down mtu at upper level, or you may take a look at --fix-gro\\n\", g_packet_buf_len,\n                  max_data_len);\n            return -1;\n        } else {\n            mylog(log_debug, \"huge packet, data_len %d > %d(max_data_len) not dropped\\n\", g_packet_buf_len,\n                  max_data_len);\n            // return -1;\n        }\n    }\n\n    if (g_packet_buf_len < 0) {\n        mylog(log_trace, \"recv_len %d\\n\", g_packet_buf_len);\n        return -1;\n    }\n    g_packet_buf_cnt++;\n#endif\n    return 0;\n}\nint discard_raw_packet() {\n    assert(g_packet_buf_cnt == 1);\n    g_packet_buf_cnt--;\n    return 0;\n}\n#ifdef UDP2RAW_LINUX\nint recv_raw_packet(char *&packet, int &len, int peek) {\n    assert(g_packet_buf_cnt == 1);\n    if (!peek)\n        g_packet_buf_cnt--;\n\n    if (g_packet_buf_len < int(link_level_header_len)) {\n        mylog(log_trace, \"packet len %d shorter than link_level_header_len %d\\n\", g_packet_buf_len, int(link_level_header_len));\n        return -1;\n    }\n\n    if (link_level_header_len == 14) {\n        unsigned char a = g_packet_buf[12];\n        unsigned char b = g_packet_buf[13];\n\n        if (!((a == 0x08 && b == 0x00) || (a == 0x86 && b == 0xdd))) {\n            mylog(log_trace, \"not an ipv4 or ipv6 packet!\\n\");\n            return -1;\n        }\n    }\n    packet = g_packet_buf + int(link_level_header_len);\n    len = g_packet_buf_len - int(link_level_header_len);\n    return 0;\n}\n#endif\n#ifdef UDP2RAW_MP\nint recv_raw_packet(char *&packet, int &len, int peek) {\n    assert(g_packet_buf_cnt == 1);\n    if (!peek)\n        g_packet_buf_cnt--;\n\n    packet = g_packet_buf;\n    len = g_packet_buf_len;\n    return 0;\n}\n#endif\nint recv_raw_ip(raw_info_t &raw_info, char *&payload, int &payloadlen) {\n    char *raw_packet_buf;\n    // static char recv_raw_ip_buf[buf_len];\n    int raw_packet_len;\n\n    if (recv_raw_packet(raw_packet_buf, raw_packet_len, raw_info.peek) != 0) return -1;\n\n    // const packet_info_t &send_info=raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    my_iphdr *iph;\n    my_ip6hdr *ip6h;\n    int flag = 0;\n    // int recv_len = recvfrom(raw_recv_fd, recv_raw_ip_buf, max_data_len+1, flag ,(sockaddr*)&saddr , &saddr_size);\n\n    char *ip_begin = raw_packet_buf;  // 14 is eth net header\n\n    if (raw_packet_len < 1) {\n        mylog(log_trace, \"raw_packet_len <1, dropped\\n\");\n        return -1;\n    }\n    iph = (struct my_iphdr *)(ip_begin);\n    ip6h = (struct my_ip6hdr *)(ip_begin);\n    if (raw_ip_version == AF_INET) {\n        if (iph->version != 4) {\n            mylog(log_trace, \"expect ipv4 packet, but got something else: %02x\\n\", iph->version);\n            return -1;\n        }\n        if (raw_packet_len < (int)sizeof(my_iphdr)) {\n            mylog(log_trace, \"raw_packet_len<sizeof(iphdr)\\n\");\n            return -1;\n        }\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        if (ip6h->version != 6) {\n            mylog(log_trace, \"expect ipv6 packet, but got something else: %02x\\n\", ip6h->version);\n            return -1;\n        }\n        if (raw_packet_len < (int)sizeof(my_ip6hdr)) {\n            mylog(log_trace, \"raw_packet_len<sizeof(ip6_hdr)\\n\");\n            return -1;\n        }\n    }\n#ifdef UDP2RAW_LINUX\n    if (lower_level) {\n        memcpy(&recv_info.addr_ll, &g_sockaddr.ll, sizeof(recv_info.addr_ll));\n    }\n#endif\n\n    unsigned short iphdrlen;\n    int ip_len;\n    if (raw_ip_version == AF_INET) {\n        recv_info.new_src_ip.v4 = iph->saddr;\n        recv_info.new_dst_ip.v4 = iph->daddr;\n        recv_info.protocol = iph->protocol;\n        iphdrlen = iph->ihl * 4;\n        ip_len = ntohs(iph->tot_len);\n    } else {\n        // todo flow id\n        assert(raw_ip_version == AF_INET6);\n        recv_info.new_src_ip.v6 = ip6h->src;\n        recv_info.new_dst_ip.v6 = ip6h->dst;\n        iphdrlen = 40;\n        recv_info.protocol = ip6h->next_header;  // todo handle extension headers;\n        ip_len = ntohs(ip6h->payload_len) + iphdrlen;\n    }\n\n    if (bind_addr_used && !recv_info.new_dst_ip.equal(bind_addr)) {\n        mylog(log_trace, \"bind adress doenst match %s %s, dropped\\n\", recv_info.new_dst_ip.get_str1(), bind_addr.get_str2());\n        // printf(\" bind adress doenst match, dropped\\n\");\n        return -1;\n    }\n\n    // if (!(iph->ihl > 0 && iph->ihl <=60)) {\n    //\tmylog(log_trace,\"iph ihl error\\n\");\n    //    return -1;\n    //  }\n\n    if (raw_packet_len < ip_len) {\n        mylog(log_debug, \"incomplete packet\\n\");\n        return -1;\n    }\n\n    if (raw_ip_version == AF_INET) {\n        if (raw_info.peek == 0)  // avoid cal it twice\n        {\n            u32_t ip_chk = csum((unsigned short *)ip_begin, iphdrlen);\n\n            if (ip_chk != 0) {\n                mylog(log_debug, \"ip header error %x\\n\", ip_chk);\n                return -1;\n            }\n        }\n    } else {\n        // do nothing\n    }\n\n    payload = ip_begin + iphdrlen;\n\n    payloadlen = ip_len - iphdrlen;\n\n    if (payloadlen < 0) {\n        mylog(log_warn, \"error payload len\\n\");\n        return -1;\n    }\n\n    return 0;\n}\n\nint peek_raw(raw_info_t &raw_info) {\n    // static char peek_raw_buf[buf_len];\n    // assert(g_packet_buf_cnt==1);\n    // g_packet_buf_cnt--;\n    // char * peek_raw_buf=g_packet_buf;\n    // int recv_len=g_packet_buf_len;\n\n    // char *ip_begin=peek_raw_buf+link_level_header_len;\n    // struct sockaddr saddr={0};\n    // socklen_t saddr_size=sizeof(saddr);\n    // int recv_len = recvfrom(raw_recv_fd, peek_raw_buf,max_data_len, MSG_PEEK ,&saddr , &saddr_size);//change max_data_len to something smaller,we only need header here\n    // iphdr * iph = (struct iphdr *) (ip_begin);\n    // mylog(log_info,\"recv_len %d\\n\",recv_len);\n    // if(recv_len<int(sizeof(iphdr)))\n    //{\n    //\tmylog(log_trace,\"failed here %d %d\\n\",recv_len,int(sizeof(iphdr)));\n    //\tmylog(log_trace,\"%s\\n \",strerror(errno));\n    //\treturn -1;\n    // }\n    // peek_info.new_src_ip.v4=iph->saddr;\n    // unsigned short iphdrlen =iph->ihl*4;\n    // char *payload=ip_begin+iphdrlen;\n\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    char *payload;\n    int payload_len;\n    if (recv_raw_ip(raw_info, payload, payload_len) != 0)\n        return -1;\n    // mylog(log_info,\"protocol %d\\n\",iph->protocol);\n    switch (raw_mode) {\n        case mode_faketcp: {\n            if (recv_info.protocol != IPPROTO_TCP) {\n                mylog(log_trace, \"failed here\");\n                return -1;\n            }\n            struct my_tcphdr *tcph = (my_tcphdr *)payload;\n            if (payload_len < int(sizeof(my_tcphdr))) {\n                mylog(log_trace, \"failed here\");\n                return -1;\n            }\n            recv_info.src_port = ntohs(tcph->source);\n            recv_info.syn = tcph->syn;\n            break;\n        }\n        case mode_udp: {\n            if (recv_info.protocol != IPPROTO_UDP) return -1;\n            struct my_udphdr *udph = (my_udphdr *)payload;\n            if (payload_len < int(sizeof(my_udphdr)))\n                return -1;\n            recv_info.src_port = ntohs(udph->source);\n            break;\n        }\n        case mode_icmp: {\n            if (raw_ip_version == AF_INET) {\n                if (recv_info.protocol != IPPROTO_ICMP) return -1;\n            } else {\n                assert(raw_ip_version == AF_INET6);\n                if (recv_info.protocol != IPPROTO_ICMPV6) return -1;\n            }\n            struct my_icmphdr *icmph = (my_icmphdr *)payload;\n            if (payload_len < int(sizeof(my_udphdr)))\n                return -1;\n            recv_info.src_port = ntohs(icmph->id);\n            break;\n        }\n        default:\n            return -1;\n    }\n    return 0;\n}\nint send_raw_icmp(raw_info_t &raw_info, const char *payload, int payloadlen) {\n    const packet_info_t &send_info = raw_info.send_info;\n    const packet_info_t &recv_info = raw_info.recv_info;\n\n    char send_raw_icmp_buf[buf_len];\n    my_icmphdr *icmph = (struct my_icmphdr *)(send_raw_icmp_buf);\n    memset(icmph, 0, sizeof(my_icmphdr));\n    if (raw_ip_version == AF_INET) {\n        if (program_mode == client_mode) {\n            icmph->type = 8;\n        } else {\n            icmph->type = 0;\n        }\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        if (program_mode == client_mode) {\n            icmph->type = 128;\n        } else {\n            icmph->type = 129;\n        }\n    }\n    icmph->code = 0;\n    icmph->id = htons(send_info.src_port);\n\n    icmph->seq = htons(send_info.my_icmp_seq);  /////////////modify\n\n    memcpy(send_raw_icmp_buf + sizeof(my_icmphdr), payload, payloadlen);\n\n    if (raw_ip_version == AF_INET) {\n        icmph->check_sum = csum((unsigned short *)send_raw_icmp_buf, sizeof(my_icmphdr) + payloadlen);\n    } else {\n        assert(raw_ip_version == AF_INET6);\n\n        pseudo_header6 v6;\n        struct pseudo_header6 *psh = &v6;\n\n        psh->src = send_info.new_src_ip.v6;\n        psh->dst = send_info.new_dst_ip.v6;\n        psh->next_header = IPPROTO_ICMPV6;\n        psh->tcp_length = htons(sizeof(my_icmphdr) + payloadlen);\n        psh->placeholder1 = 0;\n        psh->placeholder2 = 0;\n\n        icmph->check_sum = csum_with_header((char *)psh, sizeof(pseudo_header6), (unsigned short *)send_raw_icmp_buf, sizeof(my_icmphdr) + payloadlen);\n    }\n    if (send_raw_ip(raw_info, send_raw_icmp_buf, sizeof(my_icmphdr) + payloadlen) != 0) {\n        return -1;\n    }\n\n    /*if(program_mode==client_mode)\n    {\n            send_info.icmp_seq++;\n    }*/\n\n    return 0;\n}\n\nint send_raw_udp(raw_info_t &raw_info, const char *payload, int payloadlen) {\n    const packet_info_t &send_info = raw_info.send_info;\n    const packet_info_t &recv_info = raw_info.recv_info;\n\n    char send_raw_udp_buf[buf_len];\n\n    my_udphdr *udph = (struct my_udphdr *)(send_raw_udp_buf);\n\n    memset(udph, 0, sizeof(my_udphdr));\n\n    udph->source = htons(send_info.src_port);\n    udph->dest = htons(send_info.dst_port);\n\n    int udp_tot_len = payloadlen + sizeof(my_udphdr);\n\n    if (udp_tot_len > 65535) {\n        mylog(log_debug, \"invalid len\\n\");\n        return -1;\n    }\n    mylog(log_trace, \"udp_len:%d %d\\n\", udp_tot_len, udph->len);\n    udph->len = htons(uint16_t(udp_tot_len));\n\n    memcpy(send_raw_udp_buf + sizeof(my_udphdr), payload, payloadlen);\n\n    if (raw_ip_version == AF_INET) {\n        pseudo_header v4;\n        struct pseudo_header *psh = &v4;\n\n        psh->source_address = send_info.new_src_ip.v4;\n        psh->dest_address = send_info.new_dst_ip.v4;\n        psh->placeholder = 0;\n        psh->protocol = IPPROTO_UDP;\n        psh->tcp_length = htons(udp_tot_len);\n\n        udph->check = csum_with_header((char *)psh, sizeof(pseudo_header), (unsigned short *)send_raw_udp_buf, udp_tot_len);\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        pseudo_header6 v6;\n        struct pseudo_header6 *psh = &v6;\n\n        psh->src = send_info.new_src_ip.v6;\n        psh->dst = send_info.new_dst_ip.v6;\n        psh->next_header = IPPROTO_UDP;\n        psh->tcp_length = htons(udp_tot_len);\n\n        psh->placeholder1 = 0;\n        psh->placeholder2 = 0;\n\n        udph->check = csum_with_header((char *)psh, sizeof(pseudo_header6), (unsigned short *)send_raw_udp_buf, udp_tot_len);\n    }\n\n    if (send_raw_ip(raw_info, send_raw_udp_buf, udp_tot_len) != 0) {\n        return -1;\n    }\n    return 0;\n}\n\nint send_raw_tcp(raw_info_t &raw_info, const char *payload, int payloadlen) {  // TODO seq increase\n\n    const packet_info_t &send_info = raw_info.send_info;\n    const packet_info_t &recv_info = raw_info.recv_info;\n\n    // mylog(log_debug,\"syn %d\\n\",send_info.syn);\n\n    char send_raw_tcp_buf[buf_len];\n    // char *send_raw_tcp_buf=send_raw_tcp_buf0;\n\n    struct my_tcphdr *tcph = (struct my_tcphdr *)(send_raw_tcp_buf);\n\n    memset(tcph, 0, sizeof(my_tcphdr));\n\n    // TCP Header\n    tcph->source = htons(send_info.src_port);\n    tcph->dest = htons(send_info.dst_port);\n\n    tcph->seq = htonl(send_info.seq);\n    tcph->ack_seq = htonl(send_info.ack_seq);\n\n    tcph->fin = 0;\n    tcph->syn = send_info.syn;\n    tcph->rst = 0;\n    tcph->psh = send_info.psh;\n    tcph->ack = send_info.ack;\n\n    if (tcph->syn == 1) {\n        tcph->doff = 10;  // tcp header size\n        int i = sizeof(my_tcphdr);\n        send_raw_tcp_buf[i++] = 0x02;  // mss\n        send_raw_tcp_buf[i++] = 0x04;\n        send_raw_tcp_buf[i++] = 0x05;\n        send_raw_tcp_buf[i++] = (char)0xb4;\n\n        // raw_send_buf[i++]=0x01;\n        // raw_send_buf[i++]=0x01;\n        send_raw_tcp_buf[i++] = 0x04;  // sack ok\n        send_raw_tcp_buf[i++] = 0x02;  // sack ok\n\n        send_raw_tcp_buf[i++] = 0x08;  // ts   i=6\n        send_raw_tcp_buf[i++] = 0x0a;  // i=7\n\n        //*(u32_t*) (&send_raw_tcp_buf[i]) = htonl(\n        //\t(u32_t) get_current_time());\n\n        u32_t ts = htonl((u32_t)get_current_time());\n        memcpy(&send_raw_tcp_buf[i], &ts, sizeof(ts));\n\n        i += 4;\n\n        // mylog(log_info,\"[syn]<send_info.ts_ack= %u>\\n\",send_info.ts_ack);\n\n        //*(u32_t*) (&send_raw_tcp_buf[i]) = htonl(send_info.ts_ack);\n        u32_t ts_ack = htonl(send_info.ts_ack);\n        memcpy(&send_raw_tcp_buf[i], &ts_ack, sizeof(ts_ack));\n\n        i += 4;\n\n        send_raw_tcp_buf[i++] = 0x01;\n        send_raw_tcp_buf[i++] = 0x03;\n        send_raw_tcp_buf[i++] = 0x03;\n        send_raw_tcp_buf[i++] = wscale;\n    } else {\n        tcph->doff = 8;\n        int i = sizeof(my_tcphdr);\n\n        send_raw_tcp_buf[i++] = 0x01;\n        send_raw_tcp_buf[i++] = 0x01;\n\n        send_raw_tcp_buf[i++] = 0x08;  // ts   //i=2\n        send_raw_tcp_buf[i++] = 0x0a;  // i=3;\n\n        //*(u32_t*) (&send_raw_tcp_buf[i]) = htonl(\n        //\t(u32_t) get_current_time());\n\n        u32_t ts = htonl((u32_t)get_current_time());\n        memcpy(&send_raw_tcp_buf[i], &ts, sizeof(ts));\n\n        i += 4;\n\n        // mylog(log_info,\"<send_info.ts_ack= %u>\\n\",send_info.ts_ack);\n\n        //*(u32_t*) (&send_raw_tcp_buf[i]) = htonl(send_info.ts_ack);\n        u32_t ts_ack = htonl(send_info.ts_ack);\n        memcpy(&send_raw_tcp_buf[i], &ts_ack, sizeof(ts_ack));\n        i += 4;\n    }\n\n    tcph->urg = 0;\n    // tcph->window = htons((uint16_t)(1024));\n    tcph->window = htons((uint16_t)(receive_window_lower_bound + get_true_random_number() % receive_window_random_range));\n\n    tcph->check = 0;  // leave checksum 0 now, filled later by pseudo header\n    tcph->urg_ptr = 0;\n\n    char *tcp_data = send_raw_tcp_buf + +tcph->doff * 4;\n\n    memcpy(tcp_data, payload, payloadlen);\n    int tcp_totlen = tcph->doff * 4 + payloadlen;\n\n    if (raw_ip_version == AF_INET) {\n        pseudo_header v4;\n        struct pseudo_header *psh = &v4;\n\n        psh->source_address = send_info.new_src_ip.v4;\n        psh->dest_address = send_info.new_dst_ip.v4;\n        psh->placeholder = 0;\n        psh->protocol = IPPROTO_TCP;\n        psh->tcp_length = htons(tcp_totlen);\n\n        tcph->check = csum_with_header((char *)psh, sizeof(pseudo_header), (unsigned short *)send_raw_tcp_buf, tcp_totlen);\n    } else {\n        assert(raw_ip_version == AF_INET6);\n\n        pseudo_header6 v6;\n        struct pseudo_header6 *psh = &v6;\n\n        psh->src = send_info.new_src_ip.v6;\n        psh->dst = send_info.new_dst_ip.v6;\n        psh->next_header = IPPROTO_TCP;\n        psh->tcp_length = htons(tcp_totlen);\n        psh->placeholder1 = 0;\n        psh->placeholder2 = 0;\n\n        tcph->check = csum_with_header((char *)psh, sizeof(pseudo_header6), (unsigned short *)send_raw_tcp_buf, tcp_totlen);\n    }\n\n    if (send_raw_ip(raw_info, send_raw_tcp_buf, tcp_totlen) != 0) {\n        return -1;\n    }\n\n    raw_info.send_info.data_len = payloadlen;\n    return 0;\n}\n/*\nint send_raw_tcp_deprecated(const packet_info_t &info,const char * payload,int payloadlen)\n{\n        static uint16_t ip_id=1;\n        char raw_send_buf[buf_len];\n        char raw_send_buf2[buf_len];\n\n        //if((prog_mode==client_mode&& payloadlen!=9)  ||(prog_mode==server_mode&& payloadlen!=5 )  )\n        mylog(log_trace,\"send raw from to %d %d %d %d\\n\",info.src_ip,info.src_port,info.dst_ip,info.dst_port);\n\n        char *data;\n\n    memset(raw_send_buf,0,payloadlen+100);\n\n    struct iphdr *iph = (struct iphdr *) raw_send_buf;\n\n    //TCP header\n    struct tcphdr *tcph = (struct tcphdr *) (raw_send_buf + sizeof (struct ip));\n\n    struct sockaddr_in sin;\n    struct pseudo_header psh;\n\n    //some address resolution\n    sin.sin_family = AF_INET;\n    sin.sin_port = htons(info.dst_port);\n    sin.sin_addr.s_addr = info.dst_ip;\n\n    //Fill in the IP Header\n    iph->ihl = 5;\n    iph->version = 4;\n    iph->tos = 0;\n\n    iph->id = htonl (ip_id++); //Id of this packet\n    iph->frag_off = htons(0x4000); //DF set,others are zero\n    iph->ttl = (unsigned char)ttl_value;\n    iph->protocol = IPPROTO_TCP;\n    iph->check = 0; //Set to 0 before calculating checksum\n    iph->saddr = info.src_ip;    //Spoof the source ip address\n    iph->daddr = info.dst_ip;\n\n    //TCP Header\n    tcph->source = htons(info.src_port);\n    tcph->dest = htons(info.dst_port);\n\n    tcph->seq =htonl(info.seq);\n    tcph->ack_seq = htonl(info.ack_seq);\n\n    tcph->fin=0;\n    tcph->syn=info.syn;\n    tcph->rst=0;\n    tcph->psh=info.psh;\n    tcph->ack=info.ack;\n\n    if(tcph->syn==1)\n    {\n        tcph->doff = 10;  //tcp header size\n        int i=sizeof (struct iphdr)+20;\n        raw_send_buf[i++]=0x02;//mss\n        raw_send_buf[i++]=0x04;\n        raw_send_buf[i++]=0x05;\n        raw_send_buf[i++]=0xb4;\n\n        //raw_send_buf[i++]=0x01;\n        //raw_send_buf[i++]=0x01;\n        raw_send_buf[i++]=0x04; //sack ok\n        raw_send_buf[i++]=0x02; //sack ok\n\n\n        raw_send_buf[i++]=0x08;   //i=6;\n        raw_send_buf[i++]=0x0a;\n\n        *(uint32_t*)(& raw_send_buf[i])=htonl((uint32_t)get_current_time());\n\n        i+=4;\n\n        *(uint32_t*)(& raw_send_buf[i])=htonl(info.ts_ack);\n        i+=4;\n\n        raw_send_buf[i++]=0x01;\n        raw_send_buf[i++]=0x03;\n        raw_send_buf[i++]=0x03;\n        raw_send_buf[i++]=0x05;\n    }\n    else\n    {\n        tcph->doff=8;\n        int i=sizeof (struct iphdr)+20;\n\n        raw_send_buf[i++]=0x01;\n        raw_send_buf[i++]=0x01;\n\n        raw_send_buf[i++]=0x08;   //i=0;\n        raw_send_buf[i++]=0x0a;\n\n        *(uint32_t*)(& raw_send_buf[i])=htonl((uint32_t)get_current_time());\n\n        i+=4;\n\n        *(uint32_t*)(& raw_send_buf[i])=htonl(info.ts_ack);\n        i+=4;\n\n\n    }\n\n\n\n    tcph->urg=0;\n    //tcph->window = htons((uint16_t)(1024));\n    tcph->window = htons((uint16_t)(10240+random()%100));\n\n\n    tcph->check = 0; //leave checksum 0 now, filled later by pseudo header\n    tcph->urg_ptr = 0;\n\n\n    //Data part\n    data = raw_send_buf + sizeof(struct iphdr) + tcph->doff*4;\n\n    iph->tot_len = sizeof (struct iphdr) + tcph->doff*4 + payloadlen;\n\n    memcpy(data , payload, payloadlen);\n\n    psh.source_address = info.src_ip;\n    psh.dest_address = sin.sin_addr.s_addr;\n    psh.placeholder = 0;\n    psh.protocol = IPPROTO_TCP;\n    psh.tcp_length = htons(tcph->doff*4 + payloadlen );\n\n    int psize = sizeof(struct pseudo_header) + tcph->doff*4 + payloadlen;\n\n     memcpy(raw_send_buf2 , (char*) &psh , sizeof (struct pseudo_header));\n     memcpy(raw_send_buf2 + sizeof(struct pseudo_header) , tcph , tcph->doff*4 + payloadlen);\n\n     tcph->check = csum( (unsigned short*) raw_send_buf2, psize);\n\n     //Ip checksum\n     iph->check = csum ((unsigned short *) raw_send_buf, iph->tot_len);\n\n     mylog(log_trace,\"sent seq  ack_seq len<%u %u %d>\\n\",g_packet_info_send.seq,g_packet_info_send.ack_seq,payloadlen);\n\n     int ret = sendto(raw_send_fd, raw_send_buf, iph->tot_len ,  0, (struct sockaddr *) &sin, sizeof (sin));\n\n     if(g_packet_info_send.syn==0&&g_packet_info_send.ack==1&&payloadlen!=0)\n     {\n         if(seq_mode==0)\n         {\n\n\n         }\n         else if(seq_mode==1)\n         {\n                 g_packet_info_send.seq+=payloadlen;\n         }\n         else if(seq_mode==2)\n         {\n                 if(random()% 5==3 )\n                         g_packet_info_send.seq+=payloadlen;\n         }\n     }\n     mylog(log_trace,\"<ret:%d>\\n\",ret);\n         if(ret<0)\n     {\n                mylog(log_fatal,\"\");\n         perror(\"raw send error\\n\");\n         //printf(\"send error\\n\");\n     }\n     return 0;\n}\n*/\n\nint recv_raw_icmp(raw_info_t &raw_info, char *&payload, int &payloadlen) {\n    const packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n    static char recv_raw_icmp_buf[buf_len];\n\n    char *ip_payload;\n    int ip_payloadlen;\n\n    if (recv_raw_ip(raw_info, ip_payload, ip_payloadlen) != 0) {\n        mylog(log_debug, \"recv_raw_ip error\\n\");\n        return -1;\n    }\n    mylog(log_trace, \"ip_payloadlen=%d\\n\", ip_payloadlen);\n    if (raw_ip_version == AF_INET) {\n        if (recv_info.protocol != IPPROTO_ICMP) {\n            // printf(\"not udp protocol\\n\");\n            return -1;\n        }\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        if (recv_info.protocol != IPPROTO_ICMPV6) {\n            // printf(\"not udp protocol\\n\");\n            return -1;\n        }\n    }\n\n    if (ip_payloadlen < int(sizeof(my_icmphdr))) {\n        mylog(log_debug, \"too short to hold icmp header\\n\");\n        return -1;\n    }\n\n    my_icmphdr *icmph = (struct my_icmphdr *)(ip_payload);\n\n    if (ntohs(icmph->id) != send_info.src_port) {\n        mylog(log_debug, \"icmp id mis-match,ignored\\n\");\n        return -1;\n    }\n\n    recv_info.src_port = recv_info.dst_port = ntohs(icmph->id);\n    recv_info.my_icmp_seq = ntohs(icmph->seq);\n\n    if (icmph->code != 0)\n        return -1;\n\n    unsigned short check;\n    if (raw_ip_version == AF_INET) {\n        if (program_mode == client_mode) {\n            if (icmph->type != 0)\n                return -1;\n        } else {\n            if (icmph->type != 8)\n                return -1;\n        }\n        check = csum((unsigned short *)ip_payload, ip_payloadlen);\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        if (program_mode == client_mode) {\n            if (icmph->type != 129)\n                return -1;\n        } else {\n            if (icmph->type != 128)\n                return -1;\n        }\n\n        pseudo_header6 tmp_header;\n        struct pseudo_header6 *psh = &tmp_header;\n\n        psh->src = recv_info.new_src_ip.v6;\n        psh->dst = recv_info.new_dst_ip.v6;\n        psh->placeholder1 = 0;\n        psh->placeholder2 = 0;\n        psh->next_header = IPPROTO_ICMPV6;\n        psh->tcp_length = htons(ip_payloadlen);\n\n        check = csum_with_header((char *)psh, sizeof(pseudo_header6), (unsigned short *)ip_payload, ip_payloadlen);\n    }\n\n    if (check != 0) {\n        mylog(log_debug, \"icmp checksum fail %x\\n\", check);\n        return -1;\n    }\n    // mylog(log_info,\"program_mode=%d\\n\",program_mode);\n    /*\n            if(program_mode==server_mode)\n            {\n                    send_info.icmp_seq=ntohs(icmph->seq);\n                    //mylog(log_info,\"send_info.seq=%d\\n\",send_info.seq);\n            }*/\n\n    payload = ip_payload + sizeof(my_icmphdr);\n    payloadlen = ip_payloadlen - sizeof(my_icmphdr);\n    mylog(log_trace, \"get a packet len=%d\\n\", payloadlen);\n\n    return 0;\n}\n\nint recv_raw_udp(raw_info_t &raw_info, char *&payload, int &payloadlen) {\n    const packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n    // static char recv_raw_udp_buf[buf_len];\n    char *ip_payload;\n    int ip_payloadlen;\n\n    if (recv_raw_ip(raw_info, ip_payload, ip_payloadlen) != 0) {\n        mylog(log_debug, \"recv_raw_ip error\\n\");\n        return -1;\n    }\n    if (recv_info.protocol != IPPROTO_UDP) {\n        // printf(\"not udp protocol\\n\");\n        return -1;\n    }\n    if (ip_payloadlen < int(sizeof(my_udphdr))) {\n        mylog(log_debug, \"too short to hold udpheader\\n\");\n        return -1;\n    }\n    my_udphdr *udph = (struct my_udphdr *)ip_payload;\n\n    if (int(ntohs(udph->len)) != ip_payloadlen) {\n        mylog(log_debug, \"udp length error %d %d \\n\", ntohs(udph->len), ip_payloadlen);\n        return -1;\n    }\n\n    if (udph->dest != ntohs(uint16_t(filter_port))) {\n        // printf(\"%x %x\",tcph->dest,);\n        return -1;\n    }\n\n    // memcpy(recv_raw_udp_buf+ sizeof(struct pseudo_header) , ip_payload , ip_payloadlen);\n\n    /*\n    pseudo_header tmp_header={0};\n    struct pseudo_header *psh=&tmp_header ;\n\n    psh->source_address = recv_info.new_src_ip.v4;\n    psh->dest_address = recv_info.new_dst_ip.v4;\n    psh->placeholder = 0;\n    psh->protocol = IPPROTO_UDP;\n    psh->tcp_length = htons(ip_payloadlen);\n\n    int csum_len=ip_payloadlen;\n    uint16_t udp_chk = csum_with_header((char *)psh,sizeof(pseudo_header), (unsigned short*) ip_payload, csum_len);\n    */\n    uint16_t udp_chk;\n    int csum_len = ip_payloadlen;\n    if (raw_ip_version == AF_INET) {\n        pseudo_header tmp_header;\n        struct pseudo_header *psh = &tmp_header;\n\n        psh->source_address = recv_info.new_src_ip.v4;\n        psh->dest_address = recv_info.new_dst_ip.v4;\n        psh->placeholder = 0;\n        psh->protocol = IPPROTO_UDP;\n        psh->tcp_length = htons(ip_payloadlen);\n\n        udp_chk = csum_with_header((char *)psh, sizeof(pseudo_header), (unsigned short *)ip_payload, csum_len);\n    } else {\n        assert(raw_ip_version == AF_INET6);\n\n        pseudo_header6 tmp_header;\n        struct pseudo_header6 *psh = &tmp_header;\n\n        psh->src = recv_info.new_src_ip.v6;\n        psh->dst = recv_info.new_dst_ip.v6;\n        psh->placeholder1 = 0;\n        psh->placeholder2 = 0;\n        psh->next_header = IPPROTO_UDP;\n        psh->tcp_length = htons(ip_payloadlen);\n\n        udp_chk = csum_with_header((char *)psh, sizeof(pseudo_header6), (unsigned short *)ip_payload, csum_len);\n    }\n\n    if (udp_chk != 0) {\n        mylog(log_debug, \"udp_chk:%x\\n\", udp_chk);\n        mylog(log_debug, \"udp header error\\n\");\n        return -1;\n    }\n\n    char *udp_begin = ip_payload;\n\n    recv_info.src_port = ntohs(udph->source);\n    recv_info.dst_port = ntohs(udph->dest);\n\n    payloadlen = ip_payloadlen - sizeof(my_udphdr);\n\n    payload = udp_begin + sizeof(my_udphdr);\n\n    return 0;\n}\nint parse_tcp_option(char *option_begin, char *option_end, packet_info_t &recv_info) {\n    recv_info.has_ts = 0;\n    recv_info.ts = 0;\n\n    char *ptr = option_begin;\n    // char *option_end=tcp_begin+tcp_hdr_len;\n    while (ptr < option_end) {\n        if (*ptr == 0) {\n            return 0;\n        } else if (*ptr == 1) {\n            ptr++;\n        } else if (*ptr == 8) {\n            if (ptr + 1 >= option_end) {\n                mylog(log_trace, \"invaild option ptr+1==option_end,for ts\\n\");\n                return -1;\n            }\n            if (*(ptr + 1) != 10) {\n                mylog(log_trace, \"invaild ts len\\n\");\n                return -1;\n            }\n            if (ptr + 10 > option_end) {\n                mylog(log_trace, \"ptr+10>option_end for ts\\n\");\n                return -1;\n            }\n\n            recv_info.has_ts = 1;\n\n            recv_info.ts = read_u32(ptr + 2);\n            recv_info.ts_ack = read_u32(ptr + 6);\n\n            // printf(\"<%d %d>!\\n\",recv_info.ts,recv_info.ts_ack);\n\n            // return 0;//we currently only parse ts, so just return after its found\n            ptr += 10;\n        } else {\n            if (ptr + 1 >= option_end) {\n                mylog(log_trace, \"invaild option ptr+1==option_end\\n\");\n                return -1;\n            } else {\n                int len = (unsigned char)*(ptr + 1);\n                if (len <= 1) {\n                    mylog(log_trace, \"invaild option len %d\\n\", len);\n                    return -1;\n                }\n                // omit check\n                ptr += len;\n            }\n        }\n        // printf(\"!\");\n    }\n    // printf(\"\\n\");\n\n    return 0;\n}\nint recv_raw_tcp(raw_info_t &raw_info, char *&payload, int &payloadlen) {\n    const packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    // static char recv_raw_tcp_buf[buf_len];\n\n    char *ip_payload;\n    int ip_payloadlen;\n\n    if (recv_raw_ip(raw_info, ip_payload, ip_payloadlen) != 0) {\n        mylog(log_debug, \"recv_raw_ip error\\n\");\n        return -1;\n    }\n\n    if (recv_info.protocol != IPPROTO_TCP) {\n        // printf(\"not tcp protocol\\n\");\n        return -1;\n    }\n\n    my_tcphdr *tcph = (struct my_tcphdr *)ip_payload;\n\n    unsigned short tcphdrlen = tcph->doff * 4;\n\n    if (!(tcphdrlen > 0 && tcphdrlen <= 60)) {\n        mylog(log_debug, \"tcph error\\n\");\n        return 0;\n    }\n\n    if (tcphdrlen > ip_payloadlen) {\n        mylog(log_debug, \"error,tcphdrlen >ip_payloadlen\\n\");\n        return 0;\n    }\n\n    if (tcph->dest != ntohs(uint16_t(filter_port))) {\n        // printf(\"%x %x\",tcph->dest,);\n        return -1;\n    }\n\n    // memcpy(recv_raw_tcp_buf+ sizeof(struct pseudo_header) , ip_payload , ip_payloadlen);\n    uint16_t tcp_chk;\n    int csum_len = ip_payloadlen;\n    if (raw_ip_version == AF_INET) {\n        pseudo_header tmp_header;\n        struct pseudo_header *psh = &tmp_header;\n\n        psh->source_address = recv_info.new_src_ip.v4;\n        psh->dest_address = recv_info.new_dst_ip.v4;\n        psh->placeholder = 0;\n        psh->protocol = IPPROTO_TCP;\n        psh->tcp_length = htons(ip_payloadlen);\n\n        tcp_chk = csum_with_header((char *)psh, sizeof(pseudo_header), (unsigned short *)ip_payload, csum_len);\n    } else {\n        assert(raw_ip_version == AF_INET6);\n\n        pseudo_header6 tmp_header;\n        struct pseudo_header6 *psh = &tmp_header;\n\n        psh->src = recv_info.new_src_ip.v6;\n        psh->dst = recv_info.new_dst_ip.v6;\n        psh->placeholder1 = 0;\n        psh->placeholder2 = 0;\n        psh->next_header = IPPROTO_TCP;\n        psh->tcp_length = htons(ip_payloadlen);\n\n        tcp_chk = csum_with_header((char *)psh, sizeof(pseudo_header6), (unsigned short *)ip_payload, csum_len);\n    }\n    /*for(int i=0;i<csum_len;i++)\n    {\n        printf(\"<%d>\",int(ip_payload[i]));\n    }\n    printf(\"\\n\");*/\n\n    if (tcp_chk != 0) {\n        mylog(log_debug, \"tcp_chk:%x, tcp checksum failed, ignored\\n\", tcp_chk);\n        // return -1;\n    }\n\n    char *tcp_begin = ip_payload;  // ip packet's data part\n\n    char *tcp_option = ip_payload + sizeof(my_tcphdr);\n    char *option_end = ip_payload + tcphdrlen;\n\n    /*\n    //old ts parse code\n    recv_info.has_ts=0;\n    recv_info.ts=0;\n    if(tcph->doff==10)\n    {\n        if(tcp_option[6]==0x08 &&tcp_option[7]==0x0a)\n        {\n                recv_info.has_ts=1;\n                //recv_info.ts=ntohl(*(u32_t*)(&tcp_option[8]));\n                memcpy(&recv_info.ts,&tcp_option[8],sizeof(recv_info.ts));\n                recv_info.ts=ntohl(recv_info.ts);\n\n                //recv_info.ts_ack=ntohl(*(u32_t*)(&tcp_option[12]));\n                memcpy(&recv_info.ts_ack,&tcp_option[12],sizeof(recv_info.ts_ack));\n                recv_info.ts_ack=ntohl(recv_info.ts_ack);\n\n                //g_packet_info_send.ts_ack= ntohl(*(uint32_t*)(&tcp_option[8]));\n        }\n        else\n        {\n        //\tmylog(log_info,\"\\n\");\n        }\n    }\n    else if(tcph->doff==8)\n    {\n        if(tcp_option[2]==0x08 &&tcp_option[3]==0x0a)\n        {\n                recv_info.has_ts=1;\n                //recv_info.ts=ntohl(*(u32_t*)(&tcp_option[4]));\n                memcpy(&recv_info.ts,&tcp_option[4],sizeof(recv_info.ts));\n                recv_info.ts=ntohl(recv_info.ts);\n                //recv_info.ts_ack=ntohl(*(u32_t*)(&tcp_option[8]));\n                memcpy(&recv_info.ts_ack,&tcp_option[8],sizeof(recv_info.ts_ack));\n                recv_info.ts_ack=ntohl(recv_info.ts_ack);\n                //g_packet_info_send.ts_ack= ntohl(*(uint32_t*)(&tcp_option[0]));\n        }\n        else\n        {\n                //mylog(log_info,\"!!!\\n\");\n        }\n    }\n    else\n    {\n        //mylog(log_info,\"tcph->doff= %u\\n\",tcph->doff);\n    }\n    printf(\"<%d %d>\\n\",recv_info.ts,recv_info.ts_ack);\n    */\n    parse_tcp_option(tcp_option, option_end, recv_info);\n\n    recv_info.ack = tcph->ack;\n    recv_info.syn = tcph->syn;\n    recv_info.rst = tcph->rst;\n    recv_info.src_port = ntohs(tcph->source);\n    recv_info.dst_port = ntohs(tcph->dest);\n\n    recv_info.seq = ntohl(tcph->seq);\n\n    // recv_info.last_last_ack_seq=recv_info.last_ack_seq;\n    // recv_info.last_ack_seq=recv_info.ack_seq;\n    u32_t last_ack_seq = recv_info.ack_seq;\n    recv_info.ack_seq = ntohl(tcph->ack_seq);\n    if (recv_info.ack_seq == last_ack_seq) {\n        recv_info.ack_seq_counter++;\n    } else {\n        recv_info.ack_seq_counter = 0;\n    }\n\n    recv_info.psh = tcph->psh;\n\n    if (tcph->rst == 1) {\n        raw_info.rst_received++;\n\n        if (max_rst_to_show > 0) {\n            if (raw_info.rst_received < max_rst_to_show) {\n                mylog(log_warn, \"[%s,%d]rst==1,cnt=%d\\n\", recv_info.new_src_ip.get_str1(), recv_info.src_port, (int)raw_info.rst_received);\n            } else if (raw_info.rst_received == max_rst_to_show) {\n                mylog(log_warn, \"[%s,%d]rst==1,cnt=%d >=max_rst_to_show, this log will be muted for current connection\\n\", recv_info.new_src_ip.get_str1(), recv_info.src_port, (int)raw_info.rst_received);\n            } else {\n                mylog(log_debug, \"[%s,%d]rst==1,cnt=%d\\n\", recv_info.new_src_ip.get_str1(), recv_info.src_port, (int)raw_info.rst_received);\n            }\n        } else if (max_rst_to_show == 0) {\n            mylog(log_debug, \"[%s,%d]rst==1,cnt=%d\\n\", recv_info.new_src_ip.get_str1(), recv_info.src_port, (int)raw_info.rst_received);\n        } else {\n            mylog(log_warn, \"[%s,%d]rst==1,cnt=%d\\n\", recv_info.new_src_ip.get_str1(), recv_info.src_port, (int)raw_info.rst_received);\n        }\n\n        if (max_rst_allowed >= 0 && raw_info.rst_received == max_rst_allowed + 1) {\n            mylog(log_warn, \"[%s,%d]connection disabled because of rst_received=%d > max_rst_allow=%d\\n\", recv_info.new_src_ip.get_str1(), recv_info.src_port, (int)raw_info.rst_received, (int)max_rst_allowed);\n            raw_info.disabled = 1;\n        }\n    }\n\n    /* if(recv_info.has_ts)\n     {\n         send_info.ts_ack=recv_info.ts;   //////////////////////////////////////////////modify\n     }*/\n\n    payloadlen = ip_payloadlen - tcphdrlen;\n\n    payload = tcp_begin + tcphdrlen;\n\n    /*if (recv_info.syn == 0 && recv_info.ack == 1&& payloadlen != 0)   //only modify   send_info when the packet is not part of handshake\n    {\n            send_info.ack_seq=recv_info.seq;\n    }*/\n    raw_info.recv_info.data_len = payloadlen;\n    return 0;\n}\n/*\nint recv_raw_tcp_deprecated(packet_info_t &info,char * &payload,int &payloadlen)\n{\n        static char buf[buf_len];\n\n        char raw_recv_buf[buf_len];\n        char raw_recv_buf2[buf_len];\n        char raw_recv_buf3[buf_len];\n\n        iphdr *  iph;\n        tcphdr * tcph;\n        int size;\n        struct sockaddr saddr;\n        socklen_t saddr_size;\n        saddr_size = sizeof(saddr);\n\n        mylog(log_trace,\"raw!\\n\");\n\n        size = recvfrom(raw_recv_fd, buf, max_data_len, 0 ,&saddr , &saddr_size);\n\n        if(buf[12]!=8||buf[13]!=0)\n        {\n                mylog(log_debug,\"not an ipv4 packet!\\n\");\n                return -1;\n        }\n\n        char *ip_begin=buf+14;\n\n        iph = (struct iphdr *) (ip_begin);\n\n\n    if (!(iph->ihl > 0 && iph->ihl <=60)) {\n        mylog(log_debug,\"iph ihl error\");\n        return -1;\n    }\n\n    if (iph->protocol != IPPROTO_TCP) {\n        mylog(log_debug,\"iph protocal != tcp\\n\");\n        return -1;\n    }\n\n\n        int ip_len=ntohs(iph->tot_len);\n\n    unsigned short iphdrlen =iph->ihl*4;\n    tcph=(struct tcphdr*)(ip_begin+ iphdrlen);\n    unsigned short tcphdrlen = tcph->doff*4;\n\n    if (!(tcph->doff > 0 && tcph->doff <=60)) {\n        mylog(log_debug,\"tcph error\");\n        return 0;\n    }\n\n\n    if(tcph->dest!=ntohs(uint16_t(filter_port)))\n    {\n        //printf(\"%x %x\",tcph->dest,);\n        return -1;\n    }\n    /////ip\n    uint32_t ip_chk=csum ((unsigned short *) ip_begin, iphdrlen);\n\n    int psize = sizeof(struct pseudo_header) + ip_len-iphdrlen;\n    /////ip end\n\n\n    ///tcp\n    struct pseudo_header psh;\n\n    psh.source_address = iph->saddr;\n    psh.dest_address = iph->daddr;\n    psh.placeholder = 0;\n    psh.protocol = IPPROTO_TCP;\n    psh.tcp_length = htons(ip_len-iphdrlen);\n\n    memcpy(raw_recv_buf2 , (char*) &psh , sizeof (struct pseudo_header));\n    memcpy(raw_recv_buf2 + sizeof(struct pseudo_header) , ip_begin+ iphdrlen , ip_len-iphdrlen);\n\n    uint16_t tcp_chk = csum( (unsigned short*) raw_recv_buf2, psize);\n\n\n   if(ip_chk!=0)\n    {\n           mylog(log_debug,\"ip header error %d\\n\",ip_chk);\n        return -1;\n    }\n    if(tcp_chk!=0)\n    {\n        mylog(log_debug,\"tcp_chk:%x\\n\",tcp_chk);\n        mylog(log_debug,\"tcp header error\\n\");\n        return -1;\n\n    }\n    char *tcp_begin=raw_recv_buf2+sizeof(struct pseudo_header);  //ip packet's data part\n\n    char *tcp_option=raw_recv_buf2+sizeof(struct pseudo_header)+sizeof(tcphdr);\n\n    info.has_ts=0;\n\n    if(tcph->doff==10)\n    {\n        if(tcp_option[6]==0x08 &&tcp_option[7]==0x0a)\n        {\n                info.has_ts=1;\n                info.ts=ntohl(*(uint32_t*)(&tcp_option[8]));\n                info.ts_ack=ntohl(*(uint32_t*)(&tcp_option[12]));\n                //g_packet_info_send.ts_ack= ntohl(*(uint32_t*)(&tcp_option[8]));\n        }\n    }\n    else if(tcph->doff==8)\n    {\n        if(tcp_option[3]==0x08 &&tcp_option[4]==0x0a)\n        {\n                info.has_ts=1;\n                info.ts=ntohl(*(uint32_t*)(&tcp_option[0]));\n                info.ts_ack=ntohl(*(uint32_t*)(&tcp_option[4]));\n                //g_packet_info_send.ts_ack= ntohl(*(uint32_t*)(&tcp_option[0]));\n        }\n    }\n\n    if(tcph->rst==1)\n    {\n        mylog(log_warn,\"%%%%%%%%%%rst==1%%%%%%%%%%%%%\\n\");\n    }\n\n\n    info.ack=tcph->ack;\n    info.syn=tcph->syn;\n    info.rst=tcph->rst;\n    info.src_port=ntohs(tcph->source);\n    info.src_ip=iph->saddr;\n    info.seq=ntohl(tcph->seq);\n    info.ack_seq=ntohl(tcph->ack_seq);\n    info.psh=tcph->psh;\n    if(info.has_ts)\n    {\n        g_packet_info_send.ts_ack=info.ts;\n    }\n    ////tcp end\n\n\n    payloadlen = ip_len-tcphdrlen-iphdrlen;\n\n    payload=ip_begin+tcphdrlen+iphdrlen;\n\n    if(payloadlen>0&&payload[0]=='h')\n    {\n        mylog(log_debug,\"recvd <%u %u %d>\\n\",ntohl(tcph->seq ),ntohl(tcph->ack_seq), payloadlen);\n    }\n\n    if(payloadlen>0&&tcph->syn==0&&tcph->ack==1)\n    {\n        //if(seq_increse)\n                g_packet_info_send.ack_seq=ntohl(tcph->seq)+(uint32_t)payloadlen;\n    }\n\n\n    //printf(\"%d\\n\",ip_len);\n\n    mylog(log_trace,\"<%u,%u,%u,%u,%d>\\n\",(unsigned int)iphdrlen,(unsigned int)tcphdrlen,(unsigned int)tcph->syn,(unsigned int)tcph->ack,payloadlen);\n\n\n        return 0;\n}*/\nint send_raw0(raw_info_t &raw_info, const char *payload, int payloadlen) {\n    if (random_drop != 0) {\n        if (get_true_random_number() % 10000 < (u32_t)random_drop) {\n            return 0;\n        }\n    }\n\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n    mylog(log_trace, \"send_raw : from %s %d  to %s %d\\n\", send_info.new_src_ip.get_str1(), send_info.src_port, send_info.new_dst_ip.get_str2(), send_info.dst_port);\n    switch (raw_mode) {\n        case mode_faketcp:\n            return send_raw_tcp(raw_info, payload, payloadlen);\n        case mode_udp:\n            return send_raw_udp(raw_info, payload, payloadlen);\n        case mode_icmp:\n            return send_raw_icmp(raw_info, payload, payloadlen);\n        default:\n            return -1;\n    }\n}\nint recv_raw0(raw_info_t &raw_info, char *&payload, int &payloadlen) {\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n    switch (raw_mode) {\n        case mode_faketcp:\n            return recv_raw_tcp(raw_info, payload, payloadlen);\n        case mode_udp:\n            return recv_raw_udp(raw_info, payload, payloadlen);\n        case mode_icmp:\n            return recv_raw_icmp(raw_info, payload, payloadlen);\n        default:\n            return -1;\n    }\n}\n\nint after_send_raw0(raw_info_t &raw_info) {\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    if (raw_mode == mode_faketcp) {\n        if (send_info.syn == 0 && send_info.ack == 1 && raw_info.send_info.data_len != 0)  // only modify   send_info when the packet is not part of handshake\n        {\n            if (seq_mode == 0) {\n            } else if (seq_mode == 1) {\n                send_info.seq += raw_info.send_info.data_len;  //////////////////modify\n            } else if (seq_mode == 2) {\n                if (get_true_random_number() % 5 == 3)\n                    send_info.seq += raw_info.send_info.data_len;  //////////////////modify\n            } else if (seq_mode == 3 || seq_mode == 4) {\n                send_info.seq += raw_info.send_info.data_len;\n\n                u32_t window_size;\n\n                if (seq_mode == 3) {\n                    window_size = (u32_t)((u32_t)receive_window_lower_bound << (u32_t)wscale);\n                } else  // seq_mode==4\n                {\n                    window_size = (u32_t)((u32_t)receive_window_lower_bound);\n                }\n\n                if (larger_than_u32(send_info.seq + max_data_len, recv_info.ack_seq + window_size)) {\n                    send_info.seq = raw_info.recv_info.ack_seq;\n                }\n                if (recv_info.ack_seq_counter >= 3)  // simulate tcp fast re-transmit\n                {\n                    recv_info.ack_seq_counter = 0;\n                    send_info.seq = raw_info.recv_info.ack_seq;\n                }\n                if (larger_than_u32(raw_info.recv_info.ack_seq, send_info.seq))  // for further use,currently no effect.\n                {\n                    send_info.seq = raw_info.recv_info.ack_seq;\n                }\n            }\n        }\n    }\n    if (raw_mode == mode_icmp) {\n        if (program_mode == client_mode) {\n            send_info.my_icmp_seq++;\n        }\n    }\n    return 0;\n}\nint after_recv_raw0(raw_info_t &raw_info) {\n    packet_info_t &send_info = raw_info.send_info;\n    packet_info_t &recv_info = raw_info.recv_info;\n\n    if (raw_mode == mode_faketcp) {\n        if (recv_info.has_ts)\n            send_info.ts_ack = recv_info.ts;\n        if (recv_info.syn == 0 && recv_info.ack == 1 && raw_info.recv_info.data_len != 0)  // only modify   send_info when the packet is not part of handshake\n        {\n            if (seq_mode == 0 || seq_mode == 1 || seq_mode == 2) {\n                if (larger_than_u32(recv_info.seq + raw_info.recv_info.data_len, send_info.ack_seq))\n                    send_info.ack_seq = recv_info.seq + raw_info.recv_info.data_len;  // TODO only update if its larger\n            } else if (seq_mode == 3 || seq_mode == 4) {\n                if (recv_info.seq == send_info.ack_seq) {\n                    send_info.ack_seq = recv_info.seq + raw_info.recv_info.data_len;  // currently we dont remembr tcp segments,this is the simplest way\n                    // TODO implement tcp segment remembering and SACK.\n                }\n            }\n        }\n    }\n    if (raw_mode == mode_icmp) {\n        if (program_mode == server_mode) {\n            if (larger_than_u16(recv_info.my_icmp_seq, send_info.my_icmp_seq))\n                send_info.my_icmp_seq = recv_info.my_icmp_seq;  // TODO only update if its larger\n        }\n    }\n    return 0;\n}\n\n/*\nint send_raw(raw_info_t &raw_info,const char * payload,int payloadlen)\n{\n        packet_info_t &send_info=raw_info.send_info;\n        packet_info_t &recv_info=raw_info.recv_info;\n        int ret=send_raw0(raw_info,payload,payloadlen);\n        if(ret<0) return ret;\n        else\n        {\n                after_send_raw0(raw_info);\n                return ret;\n        }\n}\n\nint recv_raw(raw_info_t &raw_info,char *& payload,int & payloadlen)\n{\n        packet_info_t &send_info=raw_info.send_info;\n        packet_info_t &recv_info=raw_info.recv_info;\n        int ret=recv_raw0(raw_info,payload,payloadlen);\n        if(ret<0) return ret;\n        else\n        {\n                after_recv_raw0(raw_info);\n                return ret;\n        }\n}*/\n\n/*\nint get_src_adress(u32_t &ip,u32_t remote_ip_uint32,int remote_port)  //a trick to get src adress for a dest adress,so that we can use the src address in raw socket as source ip\n{\n        struct sockaddr_in remote_addr_in={0};\n\n        socklen_t slen = sizeof(sockaddr_in);\n        //memset(&remote_addr_in, 0, sizeof(remote_addr_in));\n        remote_addr_in.sin_family = AF_INET;\n        remote_addr_in.sin_port = htons(remote_port);\n        remote_addr_in.sin_addr.s_addr = remote_ip_uint32;\n\n\n        int new_udp_fd=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n        if(new_udp_fd<0)\n        {\n                mylog(log_warn,\"create udp_fd error\\n\");\n                return -1;\n        }\n        //set_buf_size(new_udp_fd);\n\n        mylog(log_debug,\"created new udp_fd %d\\n\",new_udp_fd);\n        int ret = connect(new_udp_fd, (struct sockaddr *) &remote_addr_in, slen);\n        if(ret!=0)\n        {\n                mylog(log_warn,\"udp fd connect fail\\n\");\n                close(new_udp_fd);\n                return -1;\n        }\n\n        struct sockaddr_in my_addr={0};\n        socklen_t len=sizeof(my_addr);\n\n    if(getsockname(new_udp_fd, (struct sockaddr *) &my_addr, &len)!=0){close(new_udp_fd); return -1;}\n\n    ip=my_addr.sin_addr.s_addr;\n\n    close(new_udp_fd);\n\n    return 0;\n}*/\n\nint get_src_adress2(address_t &output_addr, address_t remote_addr) {\n    int new_udp_fd = remote_addr.new_connected_udp_fd();\n    if (new_udp_fd < 0) {\n        mylog(log_warn, \"create udp_fd error\\n\");\n        return -1;\n    }\n\n    socklen_t len = sizeof(output_addr.inner);\n\n    if (getsockname(new_udp_fd, (struct sockaddr *)&output_addr.inner, &len) != 0) {\n        close(new_udp_fd);\n        return -1;\n    }\n\n    assert(output_addr.get_type() == remote_addr.get_type());\n\n    close(new_udp_fd);\n\n    return 0;\n}\n/*\nint try_to_list_and_bind(int &fd,u32_t local_ip_uint32,int port)  //try to bind to a port,may fail.\n{\n         int old_bind_fd=fd;\n\n         if(raw_mode==mode_faketcp)\n         {\n                 fd=socket(AF_INET,SOCK_STREAM,0);\n         }\n         else  if(raw_mode==mode_udp||raw_mode==mode_icmp)\n         {\n                 fd=socket(AF_INET,SOCK_DGRAM,0);\n         }\n     if(old_bind_fd!=-1)\n     {\n         close(old_bind_fd);\n     }\n\n         struct sockaddr_in temp_bind_addr={0};\n     //bzero(&temp_bind_addr, sizeof(temp_bind_addr));\n\n     temp_bind_addr.sin_family = AF_INET;\n     temp_bind_addr.sin_port = htons(port);\n     temp_bind_addr.sin_addr.s_addr = local_ip_uint32;\n\n     if (bind(fd, (struct sockaddr*)&temp_bind_addr, sizeof(temp_bind_addr)) !=0)\n     {\n         mylog(log_debug,\"bind fail\\n\");\n         return -1;\n     }\n         if(raw_mode==mode_faketcp)\n         {\n\n                if (listen(fd, SOMAXCONN) != 0) {\n                        mylog(log_warn,\"listen fail\\n\");\n                        return -1;\n                }\n         }\n     return 0;\n}*/\nint try_to_list_and_bind2(int &fd, address_t address)  // try to bind to a port,may fail.\n{\n    if (fd != -1) {\n        close(fd);\n    }\n    if (raw_mode == mode_faketcp) {\n        fd = socket(address.get_type(), SOCK_STREAM, 0);\n    } else if (raw_mode == mode_udp || raw_mode == mode_icmp) {\n        fd = socket(address.get_type(), SOCK_DGRAM, 0);\n    }\n\n    if (fd == -1) {\n        mylog(log_debug, \"create fd fail\\n\");\n        return -1;\n    }\n    /*struct sockaddr_in temp_bind_addr={0};\n    //bzero(&temp_bind_addr, sizeof(temp_bind_addr));\n\n    temp_bind_addr.sin_family = AF_INET;\n    temp_bind_addr.sin_port = htons(port);\n    temp_bind_addr.sin_addr.s_addr = local_ip_uint32;*/\n\n    if (::bind(fd, (struct sockaddr *)&address.inner, address.get_len()) != 0) {\n        mylog(log_debug, \"bind fail\\n\");\n        return -1;\n    }\n    if (raw_mode == mode_faketcp && !use_tcp_dummy_socket) {\n        if (listen(fd, SOMAXCONN) != 0) {\n            mylog(log_warn, \"listen fail\\n\");\n            return -1;\n        }\n    }\n    return 0;\n}\n/*\nint client_bind_to_a_new_port(int &fd,u32_t local_ip_uint32)//find a free port and bind to it.\n{\n        int raw_send_port=10000+get_true_random_number()%(65535-10000);\n        for(int i=0;i<1000;i++)//try 1000 times at max,this should be enough\n        {\n                if (try_to_list_and_bind(fd,local_ip_uint32,raw_send_port)==0)\n                {\n                        return raw_send_port;\n                }\n        }\n        mylog(log_fatal,\"bind port fail\\n\");\n        myexit(-1);\n        return -1;////for compiler check\n}*/\n\nint client_bind_to_a_new_port2(int &fd, const address_t &address)  // find a free port and bind to it.\n{\n    address_t tmp = address;\n    for (int i = 0; i < 1000; i++)  // try 1000 times at max,this should be enough\n    {\n        int raw_send_port = 10000 + get_true_random_number() % (65535 - 10000);\n        tmp.set_port(raw_send_port);\n        if (try_to_list_and_bind2(fd, tmp) == 0) {\n            return raw_send_port;\n        }\n    }\n    mylog(log_fatal, \"bind port fail\\n\");\n    myexit(-1);\n    return -1;  ////for compiler check\n}\n"
        },
        {
          "name": "network.h",
          "type": "blob",
          "size": 7.2177734375,
          "content": "/*\n * network.h\n *\n *  Created on: Jul 29, 2017\n *      Author: wangyu\n */\n\n#ifndef UDP2RAW_NETWORK_H_\n#define UDP2RAW_NETWORK_H_\n\nextern int raw_recv_fd;\nextern int raw_send_fd;\nextern int use_tcp_dummy_socket;\nextern int seq_mode;\nextern int max_seq_mode;\nextern int filter_port;\n// extern u32_t bind_address_uint32;\nextern int disable_bpf_filter;\n\nextern int lower_level;\nextern int lower_level_manual;\nextern char if_name[100];\nextern char dev[100];\nextern unsigned char dest_hw_addr[];\n\nextern int random_drop;\n\nextern int ifindex;\n\nextern char g_packet_buf[huge_buf_len];\nextern int g_packet_buf_len;\nextern int g_packet_buf_cnt;\n#ifdef UDP2RAW_MP\nextern queue_t my_queue;\n\nextern ev_async async_watcher;\nextern struct ev_loop *g_default_loop;\n\nextern pthread_mutex_t queue_mutex;\nextern int use_pcap_mutex;\n\nextern int pcap_cnt;\n\nextern int pcap_link_header_len;\n\nextern int send_with_pcap;\nextern int pcap_header_captured;\nextern int pcap_header_buf[buf_len];\n\nstruct icmphdr {\n    uint8_t type;\n    uint8_t code;\n    uint16_t check_sum;\n    uint16_t id;\n    uint16_t seq;\n};\n#endif\n\nstruct my_iphdr {\n#ifdef UDP2RAW_LITTLE_ENDIAN\n    unsigned char ihl : 4;\n    unsigned char version : 4;\n#else\n    unsigned char version : 4;\n    unsigned char ihl : 4;\n#endif\n    u_int8_t tos;\n    u_int16_t tot_len;\n    u_int16_t id;\n    u_int16_t frag_off;\n    u_int8_t ttl;\n    u_int8_t protocol;\n    u_int16_t check;\n    u_int32_t saddr;\n    u_int32_t daddr;\n    /*The options start here. */\n};\n\nstruct my_udphdr {\n    /*__extension__*/ union {\n        struct\n        {\n            u_int16_t uh_sport; /* source port */\n            u_int16_t uh_dport; /* destination port */\n            u_int16_t uh_ulen;  /* udp length */\n            u_int16_t uh_sum;   /* udp checksum */\n        };\n        struct\n        {\n            u_int16_t source;\n            u_int16_t dest;\n            u_int16_t len;\n            u_int16_t check;\n        };\n    };\n};\n\nstruct my_tcphdr {\n    /*__extension__*/ union {\n        struct\n        {\n            u_int16_t th_sport; /* source port */\n            u_int16_t th_dport; /* destination port */\n            u_int32_t th_seq;   /* sequence number */\n            u_int32_t th_ack;   /* acknowledgement number */\n#ifdef UDP2RAW_LITTLE_ENDIAN\n            u_int8_t th_x2 : 4;  /* (unused) */\n            u_int8_t tc_off : 4; /* data offset */\n#else\n            u_int8_t th_off : 4; /* data offset */\n            u_int8_t th_x2 : 4;  /* (unused) */\n#endif\n            u_int8_t th_flags;\n#define TH_FIN 0x01\n#define TH_SYN 0x02\n#define TH_RST 0x04\n#define TH_PUSH 0x08\n#define TH_ACK 0x10\n#define TH_URG 0x20\n            u_int16_t th_win; /* window */\n            u_int16_t th_sum; /* checksum */\n            u_int16_t th_urp; /* urgent pointer */\n        };\n        struct\n        {\n            u_int16_t source;\n            u_int16_t dest;\n            u_int32_t seq;\n            u_int32_t ack_seq;\n#ifdef UDP2RAW_LITTLE_ENDIAN\n            u_int16_t res1 : 4;\n            u_int16_t doff : 4;\n            u_int16_t fin : 1;\n            u_int16_t syn : 1;\n            u_int16_t rst : 1;\n            u_int16_t psh : 1;\n            u_int16_t ack : 1;\n            u_int16_t urg : 1;\n            u_int16_t res2 : 2;\n#else\n            u_int16_t doff : 4;\n            u_int16_t res1 : 4;\n            u_int16_t res2 : 2;\n            u_int16_t urg : 1;\n            u_int16_t ack : 1;\n            u_int16_t psh : 1;\n            u_int16_t rst : 1;\n            u_int16_t syn : 1;\n            u_int16_t fin : 1;\n#endif\n            u_int16_t window;\n            u_int16_t check;\n            u_int16_t urg_ptr;\n        };\n    };\n};\n\nstruct my_ip6hdr {\n#ifdef UDP2RAW_LITTLE_ENDIAN\n    uint8_t traffic_class_high : 4;\n    uint8_t version : 4;\n    uint8_t flow_label_high : 4;\n    uint8_t traffic_class_low : 4;\n#else\n    uint8_t version : 4;\n    uint8_t traffic_class_high : 4;\n    uint8_t traffic_class_low : 4;\n    uint8_t flow_label_high : 4;\n#endif\n    u_int16_t flow_label_low;\n    u_int16_t payload_len;\n    uint8_t next_header;\n    uint8_t hop_limit;\n\n    struct in6_addr src;\n    struct in6_addr dst;\n};\n\nstruct my_icmphdr {\n    uint8_t type;\n    uint8_t code;\n    uint16_t check_sum;\n    uint16_t id;\n    uint16_t seq;\n};\n\nstruct pseudo_header {\n    u_int32_t source_address;\n    u_int32_t dest_address;\n    u_int8_t placeholder;\n    u_int8_t protocol;\n    u_int16_t tcp_length;\n};\n\nstruct pseudo_header6 {\n    struct in6_addr src;\n    struct in6_addr dst;\n    u_int32_t tcp_length;\n    u_int16_t placeholder1;\n    u_int8_t placeholder2;\n    u_int8_t next_header;\n};\n\nstruct packet_info_t  // todo change this to union\n{\n    uint8_t protocol;\n\n    // u32_t src_ip;\n    // u32_t dst_ip;\n    my_ip_t new_src_ip;\n    my_ip_t new_dst_ip;\n\n    uint16_t src_port;\n    uint16_t dst_port;\n\n    // tcp_part:\n    bool syn, ack, psh, rst;\n\n    u32_t seq, ack_seq;\n\n    u32_t ack_seq_counter;\n\n    u32_t ts, ts_ack;\n\n    uint16_t my_icmp_seq;\n\n    bool has_ts;\n\n    i32_t data_len;\n\n#ifdef UDP2RAW_LINUX\n    sockaddr_ll addr_ll;\n#endif\n\n    packet_info_t();\n};\n\nstruct raw_info_t {\n    packet_info_t send_info;\n    packet_info_t recv_info;\n    // int last_send_len;\n    // int last_recv_len;\n    bool peek = 0;\n    // bool csum=1;\n    u32_t reserved_send_seq;\n    // uint32_t first_seq,first_ack_seq;\n    int rst_received = 0;\n    bool disabled = 0;\n\n};  // g_raw_info;\n\nint init_raw_socket();\n\nvoid init_filter(int port);\n\nvoid remove_filter();\n\n#ifdef UDP2RAW_LINUX\nint init_ifindex(const char *if_name, int fd, int &index);\n#endif\n\n#ifdef UDP2RAW_MP\nint init_ifindex(const char *if_name, int &index);\n#endif\n\nint find_lower_level_info(u32_t ip, u32_t &dest_ip, string &if_name, string &hw);\n\nint get_src_adress(u32_t &ip, u32_t remote_ip_uint32, int remote_port);  // a trick to get src adress for a dest adress,so that we can use the src address in raw socket as source ip\nint get_src_adress2(address_t &output_addr, address_t remote_addr);\n\nint try_to_list_and_bind(int &bind_fd, u32_t local_ip_uint32, int port);  // try to bind to a port,may fail.\nint try_to_list_and_bind2(int &fd, address_t address);\n\nint client_bind_to_a_new_port(int &bind_fd, u32_t local_ip_uint32);  // find a free port and bind to it.\nint client_bind_to_a_new_port2(int &fd, const address_t &address);\n\nint discard_raw_packet();\nint pre_recv_raw_packet();\n\nint send_raw_ip(raw_info_t &raw_info, const char *payload, int payloadlen);\n\nint peek_raw(raw_info_t &peek_info);\n\nint recv_raw_ip(raw_info_t &raw_info, char *&payload, int &payloadlen);\n\nint send_raw_icmp(raw_info_t &raw_info, const char *payload, int payloadlen);\n\nint send_raw_udp(raw_info_t &raw_info, const char *payload, int payloadlen);\n\nint send_raw_tcp(raw_info_t &raw_info, const char *payload, int payloadlen);\n\nint recv_raw_icmp(raw_info_t &raw_info, char *&payload, int &payloadlen);\n\nint recv_raw_udp(raw_info_t &raw_info, char *&payload, int &payloadlen);\n\nint recv_raw_tcp(raw_info_t &raw_info, char *&payload, int &payloadlen);\n\n// int send_raw(raw_info_t &raw_info,const char * payload,int payloadlen);\n\n// int recv_raw(raw_info_t &raw_info,char * &payload,int &payloadlen);\n\nint send_raw0(raw_info_t &raw_info, const char *payload, int payloadlen);\n\nint recv_raw0(raw_info_t &raw_info, char *&payload, int &payloadlen);\n\nint after_send_raw0(raw_info_t &raw_info);\n\nint after_recv_raw0(raw_info_t &raw_info);\n\n#endif /* NETWORK_H_ */\n"
        },
        {
          "name": "pcap_wrapper.cpp",
          "type": "blob",
          "size": 4.490234375,
          "content": "#include <windows.h>\n#include <pcap_wrapper.h>\n#include <assert.h>\n#include <stdio.h>\nint (*pcap_loop)(pcap_t *, int, pcap_handler, u_char *);\nint (*pcap_breakloop)(pcap_t *);\n\npcap_t *(*pcap_create)(const char *, char *);\n\nint (*pcap_set_snaplen)(pcap_t *, int) = 0;\nint (*pcap_set_promisc)(pcap_t *, int) = 0;\nint (*pcap_can_set_rfmon)(pcap_t *) = 0;\nint (*pcap_set_rfmon)(pcap_t *, int) = 0;\nint (*pcap_set_timeout)(pcap_t *, int) = 0;\nint (*pcap_set_buffer_size)(pcap_t *, int) = 0;\nint (*pcap_activate)(pcap_t *) = 0;\n\nint (*pcap_setfilter)(pcap_t *, struct bpf_program *) = 0;\nint (*pcap_setdirection)(pcap_t *, pcap_direction_t) = 0;\n\nint (*pcap_datalink)(pcap_t *) = 0;\n\nvoid (*pcap_freecode)(struct bpf_program *) = 0;\n\nint (*pcap_compile)(pcap_t *, struct bpf_program *, const char *, int,\n                    bpf_u_int32) = 0;\n\nchar *(*pcap_geterr)(pcap_t *) = 0;\nint (*pcap_sendpacket)(pcap_t *, const u_char *, int) = 0;\n\nchar *(*pcap_lookupdev)(char *) = 0;\n\nint (*pcap_findalldevs)(pcap_if_t **, char *) = 0;\n\nstruct init_pcap_t {\n    init_pcap_t() {\n        init_pcap();\n    }\n\n} do_it;\n\nstatic void init_npcap_dll_path() {\n    BOOL(WINAPI * SetDllDirectory)\n    (LPCTSTR);\n    char sysdir_name[512];\n    int len;\n\n    SetDllDirectory = (BOOL(WINAPI *)(LPCTSTR))GetProcAddress(GetModuleHandle(\"kernel32.dll\"), \"SetDllDirectoryA\");\n    if (SetDllDirectory == NULL) {\n        printf(\"Error in SetDllDirectory\\n\");\n    } else {\n        len = GetSystemDirectory(sysdir_name, 480);  //\tbe safe\n        if (!len)\n            printf(\"Error in GetSystemDirectory (%d)\\n\", (int)GetLastError());\n        strcat(sysdir_name, \"\\\\Npcap\");\n        if (SetDllDirectory(sysdir_name) == 0)\n            printf(\"Error in SetDllDirectory(\\\"System32\\\\Npcap\\\")\\n\");\n    }\n}\n\n#define EXPORT_FUN(XXX)                                     \\\n    do {                                                    \\\n        XXX = (__typeof__(XXX))GetProcAddress(wpcap, #XXX); \\\n    } while (0)\nint init_pcap() {\n    HMODULE wpcap = LoadLibrary(\"wpcap.dll\");\n    if (wpcap != 0) {\n        printf(\"using system32/wpcap.dll\\n\");\n    } else {\n        init_npcap_dll_path();\n        // SetDllDirectory(\"C:\\\\Windows\\\\System32\\\\Npcap\\\\\");\n        wpcap = LoadLibrary(\"wpcap.dll\");\n        if (wpcap != 0)\n            printf(\"using system32/npcap/wpcap.dll\\n\");\n    }\n    if (wpcap == 0) {\n        printf(\"cant not open wpcap.dll, make sure winpcap/npcap is installed\\n\");\n        exit(-1);\n    }\n    assert(wpcap != 0);\n\n    EXPORT_FUN(pcap_loop);\n    EXPORT_FUN(pcap_breakloop);\n    EXPORT_FUN(pcap_create);\n    EXPORT_FUN(pcap_set_snaplen);\n    EXPORT_FUN(pcap_set_promisc);\n    EXPORT_FUN(pcap_set_timeout);\n    EXPORT_FUN(pcap_activate);\n    EXPORT_FUN(pcap_setfilter);\n    EXPORT_FUN(pcap_setdirection);\n    EXPORT_FUN(pcap_datalink);\n    EXPORT_FUN(pcap_freecode);\n    EXPORT_FUN(pcap_compile);\n    EXPORT_FUN(pcap_geterr);\n    EXPORT_FUN(pcap_sendpacket);\n    EXPORT_FUN(pcap_lookupdev);\n    EXPORT_FUN(pcap_findalldevs);\n    /*\n    pcap_loop = (__typeof__(pcap_loop))GetProcAddress(wpcap, \"pcap_loop\");\n    pcap_create = (__typeof__(pcap_create))GetProcAddress(wpcap, \"pcap_create\");\n    pcap_set_snaplen = (__typeof__(pcap_set_snaplen))GetProcAddress(wpcap, \"pcap_set_snaplen\");\n    pcap_set_promisc = (__typeof__(pcap_set_promisc))GetProcAddress(wpcap, \"pcap_set_promisc\");\n    pcap_set_timeout = (__typeof__(pcap_set_timeout))GetProcAddress(wpcap, \"pcap_set_timeout\");\n    pcap_activate = (__typeof__(pcap_activate))GetProcAddress(wpcap, \"pcap_activate\");\n    pcap_setfilter = (__typeof__(pcap_setfilter))GetProcAddress(wpcap, \"pcap_setfilter\");\n    pcap_setdirection = (__typeof__(pcap_setdirection))GetProcAddress(wpcap, \"pcap_setdirection\");\n    pcap_datalink = (__typeof__(pcap_datalink))GetProcAddress(wpcap, \"pcap_datalink\");\n    pcap_freecode = (__typeof__(pcap_freecode))GetProcAddress(wpcap, \"pcap_freecode\");\n    pcap_compile = (__typeof__(pcap_compile))GetProcAddress(wpcap, \"pcap_compile\");\n    pcap_geterr = (__typeof__(pcap_geterr))GetProcAddress(wpcap, \"pcap_geterr\");\n    pcap_sendpacket = (__typeof__(pcap_sendpacket))GetProcAddress(wpcap, \"pcap_sendpacket\");\n    pcap_lookupdev = (__typeof__(pcap_lookupdev))GetProcAddress(wpcap, \"pcap_lookupdev\");\n    pcap_findalldevs = (__typeof__(pcap_findalldevs))GetProcAddress(wpcap, \"pcap_findalldevs\");\n    //pcap_loop = (__typeof__(pcap_loop))GetProcAddress(wpcap, \"pcap_loop\");\n    //pcap_loop = (__typeof__(pcap_loop))GetProcAddress(wpcap, \"pcap_loop\");\n    //pcap_loop = (__typeof__(pcap_loop))GetProcAddress(wpcap, \"pcap_loop\");\n    */\n    return 0;\n}\n"
        },
        {
          "name": "pcap_wrapper.h",
          "type": "blob",
          "size": 3.05859375,
          "content": "#pragma once\n\n//#ifdef __cplusplus\n// extern \"C\" {\n//#endif\n\n//#include <sys/time.h>\n//#include <stdint.h>\n\nstruct bpf_program {\n    char a[4096];\n};\n\nstruct pcap_t {\n    char a[4096];\n};\n\ntypedef unsigned int bpf_u_int32;\n\ntypedef struct my_timeval {\n    int tv_sec;\n    int tv_usec;\n} my_timeval;\n\nstruct pcap_pkthdr {\n    struct my_timeval ts; /* time stamp */\n    bpf_u_int32 caplen;   /* length of portion present */\n    bpf_u_int32 len;      /* length this packet (off wire) */\n};\n\ntypedef enum {\n    PCAP_D_INOUT = 0,\n    PCAP_D_IN,\n    PCAP_D_OUT\n} pcap_direction_t;\n\nstruct pcap_addr {\n    struct pcap_addr *next;\n    struct sockaddr *addr;      /* address */\n    struct sockaddr *netmask;   /* netmask for that address */\n    struct sockaddr *broadaddr; /* broadcast address for that address */\n    struct sockaddr *dstaddr;   /* P2P destination address for that address */\n};\n\nstruct pcap_if {\n    struct pcap_if *next;\n    char *name;        /* name to hand to \"pcap_open_live()\" */\n    char *description; /* textual description of interface, or NULL */\n    struct pcap_addr *addresses;\n    bpf_u_int32 flags; /* PCAP_IF_ interface flags */\n};\n\ntypedef struct pcap_if pcap_if_t;\ntypedef struct pcap_addr pcap_addr_t;\n\ntypedef unsigned char u_char;\n\n#define PCAP_ERRBUF_SIZE 256\n\n#define DLT_NULL 0    /* BSD loopback encapsulation */\n#define DLT_EN10MB 1  /* Ethernet (10Mb) */\n#define DLT_EN3MB 2   /* Experimental Ethernet (3Mb) */\n#define DLT_AX25 3    /* Amateur Radio AX.25 */\n#define DLT_PRONET 4  /* Proteon ProNET Token Ring */\n#define DLT_CHAOS 5   /* Chaos */\n#define DLT_IEEE802 6 /* 802.5 Token Ring */\n#define DLT_ARCNET 7  /* ARCNET, with BSD-style header */\n#define DLT_SLIP 8    /* Serial Line IP */\n#define DLT_PPP 9     /* Point-to-point Protocol */\n#define DLT_FDDI 10   /* FDDI */\n#define DLT_LINUX_SLL 113\n\n#define PCAP_NETMASK_UNKNOWN 0xffffffff\n\ntypedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *,\n                             const u_char *);\n\nextern int (*pcap_loop)(pcap_t *, int, pcap_handler, u_char *);\n\nextern int (*pcap_breakloop)(pcap_t *);\n\nextern pcap_t *(*pcap_create)(const char *, char *);\n\nextern int (*pcap_set_snaplen)(pcap_t *, int);\nextern int (*pcap_set_promisc)(pcap_t *, int);\nextern int (*pcap_can_set_rfmon)(pcap_t *);\nextern int (*pcap_set_rfmon)(pcap_t *, int);\nextern int (*pcap_set_timeout)(pcap_t *, int);\nextern int (*pcap_set_buffer_size)(pcap_t *, int);\nextern int (*pcap_activate)(pcap_t *);\n\nextern int (*pcap_setfilter)(pcap_t *, struct bpf_program *);\nextern int (*pcap_setdirection)(pcap_t *, pcap_direction_t);\n\nextern int (*pcap_datalink)(pcap_t *);\n\nextern void (*pcap_freecode)(struct bpf_program *);\n\nextern int (*pcap_compile)(pcap_t *, struct bpf_program *, const char *, int,\n                           bpf_u_int32);\n\nextern char *(*pcap_geterr)(pcap_t *);\nextern int (*pcap_sendpacket)(pcap_t *, const u_char *, int);\n\nextern char *(*pcap_lookupdev)(char *);\n\nextern int (*pcap_findalldevs)(pcap_if_t **, char *);\n\ninline int pcap_set_immediate_mode(pcap_t *, int) {\n    return 0;\n}\n\n//#ifdef __cplusplus\n//}\n//#endif\n\nint init_pcap();\n"
        },
        {
          "name": "server.cpp",
          "type": "blob",
          "size": 29.2451171875,
          "content": "/*\n * server.cpp\n *\n *  Created on: Aug 29, 2018\n *      Author: root\n */\n\n#ifndef UDP2RAW_MP\n\n#include \"common.h\"\n#include \"network.h\"\n#include \"connection.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"lib/md5.h\"\n#include \"encrypt.h\"\n#include \"fd_manager.h\"\n\nint server_on_timer_multi(conn_info_t &conn_info)  // for server. called when a timer is ready in epoll.for server,there will be one timer for every connection\n// there is also a global timer for server,but its not handled here\n{\n    char ip_port[max_addr_len];\n    // u32_t ip=conn_info.raw_info.send_info.dst_ip;\n    // u32_t port=conn_info.raw_info.send_info.dst_port;\n\n    address_t tmp_addr;\n    tmp_addr.from_ip_port_new(raw_ip_version, &conn_info.raw_info.send_info.new_dst_ip, conn_info.raw_info.send_info.dst_port);\n    // sprintf(ip_port,\"%s:%d\",my_ntoa(ip),port);\n    tmp_addr.to_str(ip_port);\n\n    // keep_iptables_rule();\n    mylog(log_trace, \"server timer!\\n\");\n    raw_info_t &raw_info = conn_info.raw_info;\n\n    assert(conn_info.state.server_current_state == server_ready);\n\n    if (conn_info.state.server_current_state == server_ready) {\n        conn_info.blob->conv_manager.s.clear_inactive(ip_port);\n        /*\n        if( get_current_time()-conn_info.last_hb_recv_time>heartbeat_timeout )\n        {\n                mylog(log_trace,\"%lld %lld\\n\",get_current_time(),conn_info.last_state_time);\n                conn_info.server_current_state=server_nothing;\n\n                //conn_manager.current_ready_ip=0;\n                //conn_manager.current_ready_port=0;\n\n                mylog(log_info,\"changed state to server_nothing\\n\");\n                return 0;\n        }*/\n        // dont need to do this at server,conn_manger will clear expired connections\n\n        if (get_current_time() - conn_info.last_hb_sent_time < heartbeat_interval) {\n            return 0;\n        }\n\n        if (hb_mode == 0)\n            send_safer(conn_info, 'h', hb_buf, 0);  /////////////send\n        else\n            send_safer(conn_info, 'h', hb_buf, hb_len);\n        conn_info.last_hb_sent_time = get_current_time();\n\n        mylog(log_debug, \"heart beat sent<%x,%x>\\n\", conn_info.my_id, conn_info.oppsite_id);\n    } else {\n        mylog(log_fatal, \"this shouldnt happen!\\n\");\n        myexit(-1);\n    }\n    return 0;\n}\nint server_on_raw_recv_ready(conn_info_t &conn_info, char *ip_port, char type, char *data, int data_len)  // called while the state for a connection is server_ready\n// receives data and heart beat by recv_safer.\n{\n    raw_info_t &raw_info = conn_info.raw_info;\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n    // char ip_port[40];\n\n    // sprintf(ip_port,\"%s:%d\",my_ntoa(recv_info.src_ip),recv_info.src_port);\n\n    /*\n            if (recv_info.src_ip != send_info.dst_ip\n                            || recv_info.src_port != send_info.dst_port) {\n                    mylog(log_debug, \"unexpected adress\\n\");\n                    return 0;\n            }*/\n\n    if (type == 'h' && data_len >= 0) {\n        // u32_t tmp = ntohl(*((u32_t *) &data[sizeof(u32_t)]));\n        mylog(log_debug, \"[%s][hb]received hb \\n\", ip_port);\n        conn_info.last_hb_recv_time = get_current_time();\n        return 0;\n    } else if (type == 'd' && data_len >= int(sizeof(u32_t))) {\n        // u32_t tmp_conv_id = ntohl(*((u32_t *) &data[0]));\n        my_id_t tmp_conv_id;\n        memcpy(&tmp_conv_id, &data[0], sizeof(tmp_conv_id));\n        tmp_conv_id = ntohl(tmp_conv_id);\n\n        if (hb_mode == 0)\n            conn_info.last_hb_recv_time = get_current_time();\n\n        mylog(log_trace, \"conv:%u\\n\", tmp_conv_id);\n        if (!conn_info.blob->conv_manager.s.is_conv_used(tmp_conv_id)) {\n            if (conn_info.blob->conv_manager.s.get_size() >= max_conv_num) {\n                mylog(log_warn,\n                      \"[%s]ignored new conv %x connect bc max_conv_num exceed\\n\", ip_port,\n                      tmp_conv_id);\n                return 0;\n            }\n\n            /*\n            struct sockaddr_in remote_addr_in={0};\n\n            socklen_t slen = sizeof(sockaddr_in);\n            //memset(&remote_addr_in, 0, sizeof(remote_addr_in));\n            remote_addr_in.sin_family = AF_INET;\n            remote_addr_in.sin_port = htons(remote_port);\n            remote_addr_in.sin_addr.s_addr = remote_ip_uint32;\n\n\n\n            int new_udp_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\n\n            if (new_udp_fd < 0) {\n                    mylog(log_warn, \"[%s]create udp_fd error\\n\",ip_port);\n                    return -1;\n            }\n            setnonblocking(new_udp_fd);\n            set_buf_size(new_udp_fd,socket_buf_size);\n\n            mylog(log_debug, \"[%s]created new udp_fd %d\\n\",ip_port, new_udp_fd);\n            int ret = connect(new_udp_fd, (struct sockaddr *) &remote_addr_in,\n                            slen);\n            if (ret != 0) {\n                    mylog(log_warn, \"udp fd connect fail\\n\");\n                    close(new_udp_fd);\n                    return -1;\n            }*/\n\n            int new_udp_fd = remote_addr.new_connected_udp_fd();\n            if (new_udp_fd < 0) {\n                mylog(log_warn, \"[%s]new_connected_udp_fd() failed\\n\", ip_port);\n                return -1;\n            }\n\n            struct epoll_event ev;\n\n            fd64_t new_udp_fd64 = fd_manager.create(new_udp_fd);\n            fd_manager.get_info(new_udp_fd64).p_conn_info = &conn_info;\n\n            mylog(log_trace, \"[%s]u64: %lld\\n\", ip_port, new_udp_fd64);\n            ev.events = EPOLLIN;\n\n            ev.data.u64 = new_udp_fd64;\n\n            int ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, new_udp_fd, &ev);\n\n            if (ret != 0) {\n                mylog(log_warn, \"[%s]add udp_fd error\\n\", ip_port);\n                close(new_udp_fd);\n                return -1;\n            }\n\n            conn_info.blob->conv_manager.s.insert_conv(tmp_conv_id, new_udp_fd64);\n\n            // assert(conn_manager.udp_fd_mp.find(new_udp_fd)==conn_manager.udp_fd_mp.end());\n\n            // conn_manager.udp_fd_mp[new_udp_fd] = &conn_info;\n\n            // pack_u64(conn_info.raw_info.recv_info.src_ip,conn_info.raw_info.recv_info.src_port);\n\n            mylog(log_info, \"[%s]new conv conv_id=%x, assigned fd=%d\\n\", ip_port,\n                  tmp_conv_id, new_udp_fd);\n        }\n\n        fd64_t fd64 = conn_info.blob->conv_manager.s.find_data_by_conv(tmp_conv_id);\n\n        conn_info.blob->conv_manager.s.update_active_time(tmp_conv_id);\n\n        int fd = fd_manager.to_fd(fd64);\n\n        mylog(log_trace, \"[%s]received a data from fake tcp,len:%d\\n\", ip_port, data_len);\n        int ret = send(fd, data + sizeof(u32_t),\n                       data_len - (sizeof(u32_t)), 0);\n\n        mylog(log_trace, \"[%s]%d byte sent  ,fd :%d\\n \", ip_port, ret, fd);\n        if (ret < 0) {\n            mylog(log_warn, \"send returned %d\\n\", ret);\n            // perror(\"what happened????\");\n        }\n        return 0;\n    }\n    return 0;\n}\n\nint server_on_raw_recv_pre_ready(conn_info_t &conn_info, char *ip_port, u32_t tmp_oppsite_const_id)  // do prepare work before state change to server ready for a specifc connection\n// connection recovery is also handle here\n{\n    // u32_t ip;uint16_t port;\n    // ip=conn_info.raw_info.recv_info.src_ip;\n    // port=conn_info.raw_info.recv_info.src_port;\n    // char ip_port[40];\n    // sprintf(ip_port,\"%s:%d\",my_ntoa(ip),port);\n\n    mylog(log_info, \"[%s]received handshake oppsite_id:%x  my_id:%x\\n\", ip_port, conn_info.oppsite_id, conn_info.my_id);\n\n    mylog(log_info, \"[%s]oppsite const_id:%x \\n\", ip_port, tmp_oppsite_const_id);\n    if (conn_manager.const_id_mp.find(tmp_oppsite_const_id) == conn_manager.const_id_mp.end()) {\n        // conn_manager.const_id_mp=\n\n        if (conn_manager.ready_num >= max_ready_conn_num) {\n            mylog(log_info, \"[%s]max_ready_conn_num,cant turn to ready\\n\", ip_port);\n            conn_info.state.server_current_state = server_idle;\n            return 0;\n        }\n\n        conn_info.prepare();\n        conn_info.state.server_current_state = server_ready;\n        conn_info.oppsite_const_id = tmp_oppsite_const_id;\n        conn_manager.ready_num++;\n        conn_manager.const_id_mp[tmp_oppsite_const_id] = &conn_info;\n\n        // conn_info.last_state_time=get_current_time(); //dont change this!!!!!!!!!!!!!!!!!!!!!!!!!\n\n        // conn_manager.current_ready_ip=ip;\n        // conn_manager.current_ready_port=port;\n\n        // my_id=conn_info.my_id;\n        // oppsite_id=conn_info.oppsite_id;\n        conn_info.last_hb_recv_time = get_current_time();\n\n        conn_info.last_hb_sent_time = conn_info.last_hb_recv_time;  //=get_current_time()\n\n        if (hb_mode == 0)\n            send_safer(conn_info, 'h', hb_buf, 0);  /////////////send\n        else\n            send_safer(conn_info, 'h', hb_buf, hb_len);\n\n        mylog(log_info, \"[%s]changed state to server_ready\\n\", ip_port);\n        conn_info.blob->anti_replay.re_init();\n\n        // g_conn_info=conn_info;\n        int new_timer_fd;\n        set_timer_server(epollfd, new_timer_fd, conn_info.timer_fd64);\n\n        fd_manager.get_info(conn_info.timer_fd64).p_conn_info = &conn_info;\n        // assert(conn_manager.timer_fd_mp.find(new_timer_fd)==conn_manager.timer_fd_mp.end());\n        // conn_manager.timer_fd_mp[new_timer_fd] = &conn_info;//pack_u64(ip,port);\n\n        // timer_fd_mp[new_timer_fd]\n        /*\n         if(oppsite_const_id!=0&&tmp_oppsite_const_id!=oppsite_const_id)  //TODO MOVE TO READY\n         {\n         mylog(log_info,\"cleared all conv bc of const id doesnt match\\n\");\n         conv_manager.clear();\n         }*/\n        // oppsite_const_id=tmp_oppsite_const_id;\n    } else {\n        conn_info_t &ori_conn_info = *conn_manager.const_id_mp[tmp_oppsite_const_id];\n\n        if (ori_conn_info.state.server_current_state == server_ready) {\n            if (conn_info.last_state_time < ori_conn_info.last_state_time) {\n                mylog(log_info, \"[%s]conn_info.last_state_time<ori_conn_info.last_state_time. ignored new handshake\\n\", ip_port);\n                conn_info.state.server_current_state = server_idle;\n                conn_info.oppsite_const_id = 0;\n                return 0;\n            }\n            address_t addr1;\n            addr1.from_ip_port_new(raw_ip_version, &ori_conn_info.raw_info.recv_info.new_src_ip, ori_conn_info.raw_info.recv_info.src_port);\n            if (!conn_manager.exist(addr1))  // TODO remove this\n            {\n                mylog(log_fatal, \"[%s]this shouldnt happen\\n\", ip_port);\n                myexit(-1);\n            }\n            address_t addr2;\n            addr2.from_ip_port_new(raw_ip_version, &conn_info.raw_info.recv_info.new_src_ip, conn_info.raw_info.recv_info.src_port);\n            if (!conn_manager.exist(addr2))  // TODO remove this\n            {\n                mylog(log_fatal, \"[%s]this shouldnt happen2\\n\", ip_port);\n                myexit(-1);\n            }\n            conn_info_t *&p_ori = conn_manager.find_insert_p(addr1);\n            conn_info_t *&p = conn_manager.find_insert_p(addr2);\n            conn_info_t *tmp = p;\n            p = p_ori;\n            p_ori = tmp;\n\n            mylog(log_info, \"[%s]grabbed a connection\\n\", ip_port);\n\n            // ori_conn_info.state.server_current_state=server_ready;\n            ori_conn_info.recover(conn_info);\n\n            // send_safer(ori_conn_info, 'h',hb_buf, hb_len);\n            // ori_conn_info.blob->anti_replay.re_init();\n            if (hb_mode == 0)\n                send_safer(ori_conn_info, 'h', hb_buf, 0);  /////////////send\n            else\n                send_safer(ori_conn_info, 'h', hb_buf, hb_len);\n\n            ori_conn_info.last_hb_recv_time = get_current_time();\n\n            conn_info.state.server_current_state = server_idle;\n            conn_info.oppsite_const_id = 0;\n\n        } else {\n            mylog(log_fatal, \"[%s]this should never happen\\n\", ip_port);\n            myexit(-1);\n        }\n        return 0;\n    }\n    return 0;\n}\nint server_on_raw_recv_handshake1(conn_info_t &conn_info, char *ip_port, char *data, int data_len)  // called when server received a handshake1 packet from client\n{\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n    raw_info_t &raw_info = conn_info.raw_info;\n\n    // u32_t ip=conn_info.raw_info.recv_info.src_ip;\n    // uint16_t port=conn_info.raw_info.recv_info.src_port;\n\n    // char ip_port[40];\n    // sprintf(ip_port,\"%s:%d\",my_ntoa(ip),port);\n\n    if (data_len < int(3 * sizeof(my_id_t))) {\n        mylog(log_debug, \"[%s] data_len=%d too short to be a handshake\\n\", ip_port, data_len);\n        return -1;\n    }\n    // id_t tmp_oppsite_id=  ntohl(* ((u32_t *)&data[0]));\n    my_id_t tmp_oppsite_id;\n    memcpy(&tmp_oppsite_id, (u32_t *)&data[0], sizeof(tmp_oppsite_id));\n    tmp_oppsite_id = ntohl(tmp_oppsite_id);\n\n    // id_t tmp_my_id=ntohl(* ((u32_t *)&data[sizeof(id_t)]));\n    my_id_t tmp_my_id;\n    memcpy(&tmp_my_id, &data[sizeof(my_id_t)], sizeof(tmp_my_id));\n    tmp_my_id = ntohl(tmp_my_id);\n\n    if (tmp_my_id == 0)  // received  init handshake again\n    {\n        if (raw_mode == mode_faketcp) {\n            send_info.seq = recv_info.ack_seq;\n            send_info.ack_seq = recv_info.seq + raw_info.recv_info.data_len;\n            send_info.ts_ack = recv_info.ts;\n        }\n        if (raw_mode == mode_icmp) {\n            send_info.my_icmp_seq = recv_info.my_icmp_seq;\n        }\n        send_handshake(raw_info, conn_info.my_id, tmp_oppsite_id, const_id);  //////////////send\n\n        mylog(log_info, \"[%s]changed state to server_handshake1,my_id is %x\\n\", ip_port, conn_info.my_id);\n    } else if (tmp_my_id == conn_info.my_id) {\n        conn_info.oppsite_id = tmp_oppsite_id;\n        // id_t tmp_oppsite_const_id=ntohl(* ((u32_t *)&data[sizeof(id_t)*2]));\n\n        my_id_t tmp_oppsite_const_id;\n        memcpy(&tmp_oppsite_const_id, &data[sizeof(my_id_t) * 2], sizeof(tmp_oppsite_const_id));\n        tmp_oppsite_const_id = ntohl(tmp_oppsite_const_id);\n\n        if (raw_mode == mode_faketcp) {\n            send_info.seq = recv_info.ack_seq;\n            send_info.ack_seq = recv_info.seq + raw_info.recv_info.data_len;\n            send_info.ts_ack = recv_info.ts;\n        }\n\n        if (raw_mode == mode_icmp) {\n            send_info.my_icmp_seq = recv_info.my_icmp_seq;\n        }\n\n        server_on_raw_recv_pre_ready(conn_info, ip_port, tmp_oppsite_const_id);\n\n    } else {\n        mylog(log_debug, \"[%s]invalid my_id %x,my_id is %x\\n\", ip_port, tmp_my_id, conn_info.my_id);\n    }\n    return 0;\n}\nint server_on_recv_safer_multi(conn_info_t &conn_info, char type, char *data, int data_len) {\n    return 0;\n}\nint server_on_raw_recv_multi()  // called when server received an raw packet\n{\n    char dummy_buf[buf_len];\n    raw_info_t peek_raw_info;\n    peek_raw_info.peek = 1;\n    packet_info_t &peek_info = peek_raw_info.recv_info;\n    mylog(log_trace, \"got a packet\\n\");\n    if (pre_recv_raw_packet() < 0) return -1;\n    if (peek_raw(peek_raw_info) < 0) {\n        discard_raw_packet();\n        // recv(raw_recv_fd, 0,0, 0  );//\n        // struct sockaddr saddr;\n        // socklen_t saddr_size=sizeof(saddr);\n        /// recvfrom(raw_recv_fd, 0,0, 0 ,&saddr , &saddr_size);//\n        mylog(log_trace, \"peek_raw failed\\n\");\n        return -1;\n    } else {\n        mylog(log_trace, \"peek_raw success\\n\");\n    }\n    // u32_t ip=peek_info.src_ip;uint16_t port=peek_info.src_port;\n\n    int data_len;\n    char *data;\n\n    address_t addr;\n    addr.from_ip_port_new(raw_ip_version, &peek_info.new_src_ip, peek_info.src_port);\n\n    char ip_port[max_addr_len];\n    addr.to_str(ip_port);\n    // sprintf(ip_port,\"%s:%d\",my_ntoa(ip),port);\n    mylog(log_trace, \"[%s]peek_raw\\n\", ip_port);\n\n    if (raw_mode == mode_faketcp && peek_info.syn == 1) {\n        if (!conn_manager.exist(addr) || conn_manager.find_insert(addr).state.server_current_state != server_ready) {  // reply any syn ,before state become ready\n\n            raw_info_t tmp_raw_info;\n            if (recv_raw0(tmp_raw_info, data, data_len) < 0) {\n                return 0;\n            }\n            if (data_len >= max_data_len + 1) {\n                mylog(log_debug, \"data_len=%d >= max_data_len+1,ignored\", data_len);\n                return -1;\n            }\n            if (use_tcp_dummy_socket != 0)\n                return 0;\n            raw_info_t &raw_info = tmp_raw_info;\n            packet_info_t &send_info = raw_info.send_info;\n            packet_info_t &recv_info = raw_info.recv_info;\n\n            send_info.new_src_ip = recv_info.new_dst_ip;\n            send_info.src_port = recv_info.dst_port;\n\n            send_info.dst_port = recv_info.src_port;\n            send_info.new_dst_ip = recv_info.new_src_ip;\n\n            if (lower_level) {\n                handle_lower_level(raw_info);\n            }\n\n            if (data_len == 0 && raw_info.recv_info.syn == 1 && raw_info.recv_info.ack == 0) {\n                send_info.ack_seq = recv_info.seq + 1;\n\n                send_info.psh = 0;\n                send_info.syn = 1;\n                send_info.ack = 1;\n                send_info.ts_ack = recv_info.ts;\n\n                mylog(log_info, \"[%s]received syn,sent syn ack back\\n\", ip_port);\n                send_raw0(raw_info, 0, 0);\n                return 0;\n            }\n        } else {\n            discard_raw_packet();\n            // recv(raw_recv_fd, 0,0,0);\n        }\n        return 0;\n    }\n    if (!conn_manager.exist(addr)) {\n        if (conn_manager.mp.size() >= max_handshake_conn_num) {\n            mylog(log_info, \"[%s]reached max_handshake_conn_num,ignored new handshake\\n\", ip_port);\n            discard_raw_packet();\n            // recv(raw_recv_fd, 0,0, 0  );//\n            return 0;\n        }\n\n        raw_info_t tmp_raw_info;\n\n        if (raw_mode == mode_icmp) {\n            tmp_raw_info.send_info.dst_port = tmp_raw_info.send_info.src_port = addr.get_port();\n        }\n        if (recv_bare(tmp_raw_info, data, data_len) < 0) {\n            return 0;\n        }\n        if (data_len < int(3 * sizeof(my_id_t))) {\n            mylog(log_debug, \"[%s]too short to be a handshake\\n\", ip_port);\n            return -1;\n        }\n\n        // id_t zero=ntohl(* ((u32_t *)&data[sizeof(id_t)]));\n        my_id_t zero;\n        memcpy(&zero, &data[sizeof(my_id_t)], sizeof(zero));\n        zero = ntohl(zero);\n\n        if (zero != 0) {\n            mylog(log_debug, \"[%s]not a invalid initial handshake\\n\", ip_port);\n            return -1;\n        }\n\n        mylog(log_info, \"[%s]got packet from a new ip\\n\", ip_port);\n\n        conn_info_t &conn_info = conn_manager.find_insert(addr);\n        conn_info.raw_info = tmp_raw_info;\n        raw_info_t &raw_info = conn_info.raw_info;\n\n        packet_info_t &send_info = conn_info.raw_info.send_info;\n        packet_info_t &recv_info = conn_info.raw_info.recv_info;\n\n        // conn_info.ip_port.ip=ip;\n        // conn_info.ip_port.port=port;\n\n        send_info.new_src_ip = recv_info.new_dst_ip;\n        send_info.src_port = recv_info.dst_port;\n\n        send_info.dst_port = recv_info.src_port;\n        send_info.new_dst_ip = recv_info.new_src_ip;\n\n        if (lower_level) {\n            handle_lower_level(raw_info);\n        }\n\n        // id_t tmp_oppsite_id=  ntohl(* ((u32_t *)&data[0]));\n        // mylog(log_info,\"[%s]handshake1 received %x\\n\",ip_port,tmp_oppsite_id);\n\n        conn_info.my_id = get_true_random_number_nz();\n\n        mylog(log_info, \"[%s]created new conn,state: server_handshake1,my_id is %x\\n\", ip_port, conn_info.my_id);\n\n        conn_info.state.server_current_state = server_handshake1;\n        conn_info.last_state_time = get_current_time();\n\n        server_on_raw_recv_handshake1(conn_info, ip_port, data, data_len);\n        return 0;\n    }\n\n    conn_info_t &conn_info = conn_manager.find_insert(addr);  // insert if not exist\n    packet_info_t &send_info = conn_info.raw_info.send_info;\n    packet_info_t &recv_info = conn_info.raw_info.recv_info;\n    raw_info_t &raw_info = conn_info.raw_info;\n\n    if (conn_info.state.server_current_state == server_handshake1) {\n        if (recv_bare(raw_info, data, data_len) != 0) {\n            return -1;\n        }\n        return server_on_raw_recv_handshake1(conn_info, ip_port, data, data_len);\n    }\n    if (conn_info.state.server_current_state == server_ready) {\n        vector<char> type_vec;\n        vector<string> data_vec;\n        recv_safer_multi(conn_info, type_vec, data_vec);\n        if (data_vec.empty()) {\n            mylog(log_debug, \"recv_safer failed!\\n\");\n            return -1;\n        }\n\n        for (int i = 0; i < (int)type_vec.size(); i++) {\n            char type = type_vec[i];\n            char *data = (char *)data_vec[i].c_str();  // be careful, do not append data to it\n            int data_len = data_vec[i].length();\n            server_on_raw_recv_ready(conn_info, ip_port, type, data, data_len);\n        }\n        return 0;\n    }\n\n    if (conn_info.state.server_current_state == server_idle) {\n        discard_raw_packet();\n        // recv(raw_recv_fd, 0,0, 0  );//\n        return 0;\n    }\n    mylog(log_fatal, \"we should never run to here\\n\");\n    myexit(-1);\n    return -1;\n}\n\nint server_on_udp_recv(conn_info_t &conn_info, fd64_t fd64) {\n    char buf[buf_len];\n\n    if (conn_info.state.server_current_state != server_ready)  // TODO remove this for peformance\n    {\n        mylog(log_fatal, \"p_conn_info->state.server_current_state!=server_ready!!!this shouldnt happen\\n\");\n        myexit(-1);\n    }\n\n    // conn_info_t &conn_info=*p_conn_info;\n\n    assert(conn_info.blob->conv_manager.s.is_data_used(fd64));\n\n    u32_t conv_id = conn_info.blob->conv_manager.s.find_conv_by_data(fd64);\n\n    int fd = fd_manager.to_fd(fd64);\n\n    int recv_len = recv(fd, buf, max_data_len + 1, 0);\n\n    mylog(log_trace, \"received a packet from udp_fd,len:%d\\n\", recv_len);\n\n    if (recv_len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d,dropped\\n\", max_data_len);\n        return -1;\n    }\n\n    if (recv_len < 0) {\n        mylog(log_debug, \"udp fd,recv_len<0 continue,%s\\n\", strerror(errno));\n        return -1;\n    }\n\n    if (recv_len >= mtu_warn) {\n        mylog(log_warn, \"huge packet,data len=%d (>=%d).strongly suggested to set a smaller mtu at upper level,to get rid of this warn\\n \", recv_len, mtu_warn);\n    }\n\n    // conn_info.conv_manager->update_active_time(conv_id);  server dosnt update from upd side,only update from raw side.  (client updates at both side)\n\n    if (conn_info.state.server_current_state == server_ready) {\n        send_data_safer(conn_info, buf, recv_len, conv_id);\n        // send_data(g_packet_info_send,buf,recv_len,my_id,oppsite_id,conv_id);\n        mylog(log_trace, \"send_data_safer ,sent !!\\n\");\n    }\n\n    return 0;\n}\n\nint server_event_loop() {\n    char buf[buf_len];\n\n    int i, j, k;\n    int ret;\n\n    if (raw_ip_version == AF_INET) {\n        if (local_addr.inner.ipv4.sin_addr.s_addr != 0) {\n            bind_addr_used = 1;\n            bind_addr.v4 = local_addr.inner.ipv4.sin_addr.s_addr;\n        }\n    } else {\n        assert(raw_ip_version == AF_INET6);\n        char zero_arr[16] = {0};\n        if (memcmp(&local_addr.inner.ipv6.sin6_addr, zero_arr, 16) != 0) {\n            bind_addr_used = 1;\n            bind_addr.v6 = local_addr.inner.ipv6.sin6_addr;\n        }\n    }\n    // bind_address_uint32=local_ip_uint32;//only server has bind adress,client sets it to zero\n\n    if (lower_level) {\n        if (lower_level_manual) {\n            init_ifindex(if_name, raw_send_fd, ifindex);\n            mylog(log_info, \"we are running at lower-level (manual) mode\\n\");\n        } else {\n            mylog(log_info, \"we are running at lower-level (auto) mode\\n\");\n        }\n    }\n\n    if (raw_mode == mode_faketcp) {\n        bind_fd = socket(local_addr.get_type(), SOCK_STREAM, 0);\n    } else if (raw_mode == mode_udp || raw_mode == mode_icmp)  // bind an adress to avoid collision,for icmp,there is no port,just bind a udp port\n    {\n        bind_fd = socket(local_addr.get_type(), SOCK_DGRAM, 0);\n    }\n\n    // struct sockaddr_in temp_bind_addr={0};\n    // bzero(&temp_bind_addr, sizeof(temp_bind_addr));\n\n    // temp_bind_addr.sin_family = AF_INET;\n    // temp_bind_addr.sin_port = local_addr.get_port();\n    // temp_bind_addr.sin_addr.s_addr = local_addr.inner.ipv4.sin_addr.s_addr;\n\n    if (bind(bind_fd, (struct sockaddr *)&local_addr.inner, local_addr.get_len()) != 0) {\n        mylog(log_fatal, \"bind fail\\n\");\n        myexit(-1);\n    }\n\n    if (raw_mode == mode_faketcp) {\n        if (listen(bind_fd, SOMAXCONN) != 0) {\n            mylog(log_fatal, \"listen fail\\n\");\n            myexit(-1);\n        }\n    }\n\n    // init_raw_socket();\n    init_filter(local_addr.get_port());  // bpf filter\n\n    epollfd = epoll_create1(0);\n    const int max_events = 4096;\n\n    struct epoll_event ev, events[max_events];\n    if (epollfd < 0) {\n        mylog(log_fatal, \"epoll return %d\\n\", epollfd);\n        myexit(-1);\n    }\n\n    ev.events = EPOLLIN;\n    ev.data.u64 = raw_recv_fd;\n\n    ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, raw_recv_fd, &ev);\n    if (ret != 0) {\n        mylog(log_fatal, \"add raw_fd error\\n\");\n        myexit(-1);\n    }\n    int timer_fd;\n\n    set_timer(epollfd, timer_fd);\n\n    u64_t begin_time = 0;\n    u64_t end_time = 0;\n\n    mylog(log_info, \"now listening at %s\\n\", local_addr.get_str());\n\n    int fifo_fd = -1;\n\n    if (fifo_file[0] != 0) {\n        fifo_fd = create_fifo(fifo_file);\n        ev.events = EPOLLIN;\n        ev.data.u64 = fifo_fd;\n\n        ret = epoll_ctl(epollfd, EPOLL_CTL_ADD, fifo_fd, &ev);\n        if (ret != 0) {\n            mylog(log_fatal, \"add fifo_fd to epoll error %s\\n\", strerror(errno));\n            myexit(-1);\n        }\n        mylog(log_info, \"fifo_file=%s\\n\", fifo_file);\n    }\n\n    while (1)  ////////////////////////\n    {\n        if (about_to_exit) myexit(0);\n\n        int nfds = epoll_wait(epollfd, events, max_events, 180 * 1000);\n        if (nfds < 0) {  // allow zero\n            if (errno == EINTR) {\n                mylog(log_info, \"epoll interrupted by signal,continue\\n\");\n                // myexit(0);\n            } else {\n                mylog(log_fatal, \"epoll_wait return %d,%s\\n\", nfds, strerror(errno));\n                myexit(-1);\n            }\n        }\n        int idx;\n        for (idx = 0; idx < nfds; ++idx) {\n            // mylog(log_debug,\"ndfs:  %d \\n\",nfds);\n            epoll_trigger_counter++;\n            // printf(\"%d %d %d %d\\n\",timer_fd,raw_recv_fd,raw_send_fd,n);\n            if ((events[idx].data.u64) == (u64_t)timer_fd) {\n                if (debug_flag) begin_time = get_current_time();\n                conn_manager.clear_inactive();\n                u64_t dummy;\n                int unused = read(timer_fd, &dummy, 8);\n                // current_time_rough=get_current_time();\n                if (debug_flag) {\n                    end_time = get_current_time();\n                    mylog(log_debug, \"timer_fd,%llu,%llu,%llu\\n\", begin_time, end_time, end_time - begin_time);\n                }\n\n                mylog(log_trace, \"epoll_trigger_counter:  %d \\n\", epoll_trigger_counter);\n                epoll_trigger_counter = 0;\n\n            } else if (events[idx].data.u64 == (u64_t)raw_recv_fd) {\n                if (debug_flag) begin_time = get_current_time();\n                server_on_raw_recv_multi();\n                if (debug_flag) {\n                    end_time = get_current_time();\n                    mylog(log_debug, \"raw_recv_fd,%llu,%llu,%llu  \\n\", begin_time, end_time, end_time - begin_time);\n                }\n            } else if (events[idx].data.u64 == (u64_t)fifo_fd) {\n                int len = read(fifo_fd, buf, sizeof(buf));\n                if (len < 0) {\n                    mylog(log_warn, \"fifo read failed len=%d,errno=%s\\n\", len, strerror(errno));\n                    continue;\n                }\n                // assert(len>=0);\n                buf[len] = 0;\n                while (len >= 1 && buf[len - 1] == '\\n')\n                    buf[len - 1] = 0;\n                mylog(log_info, \"got data from fifo,len=%d,s=[%s]\\n\", len, buf);\n                mylog(log_info, \"unknown command\\n\");\n            } else if (events[idx].data.u64 > u32_t(-1)) {\n                fd64_t fd64 = events[idx].data.u64;\n                if (!fd_manager.exist(fd64)) {\n                    mylog(log_trace, \"fd64 no longer exist\\n\");\n                    return -1;\n                }\n                assert(fd_manager.exist_info(fd64));\n                conn_info_t *p_conn_info = fd_manager.get_info(fd64).p_conn_info;\n                conn_info_t &conn_info = *p_conn_info;\n                if (fd64 == conn_info.timer_fd64)  //////////timer_fd64\n                {\n                    if (debug_flag) begin_time = get_current_time();\n                    int fd = fd_manager.to_fd(fd64);\n                    u64_t dummy;\n                    int unused = read(fd, &dummy, 8);\n                    assert(conn_info.state.server_current_state == server_ready);  // TODO remove this for peformance\n                    server_on_timer_multi(conn_info);\n                    if (debug_flag) {\n                        end_time = get_current_time();\n                        mylog(log_debug, \"(events[idx].data.u64 >>32u) == 2u ,%llu,%llu,%llu  \\n\", begin_time, end_time, end_time - begin_time);\n                    }\n                } else  // udp_fd64\n                {\n                    if (debug_flag) begin_time = get_current_time();\n                    server_on_udp_recv(conn_info, fd64);\n                    if (debug_flag) {\n                        end_time = get_current_time();\n                        mylog(log_debug, \"(events[idx].data.u64 >>32u) == 1u,%lld,%lld,%lld  \\n\", begin_time, end_time, end_time - begin_time);\n                    }\n                }\n            } else {\n                mylog(log_fatal, \"unknown fd,this should never happen\\n\");\n                myexit(-1);\n            }\n        }\n    }\n    return 0;\n}\n\n#endif\n"
        },
        {
          "name": "third-party",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}