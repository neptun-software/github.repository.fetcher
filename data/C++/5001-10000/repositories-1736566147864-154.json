{
  "metadata": {
    "timestamp": 1736566147864,
    "page": 154,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "N64Recomp/N64Recomp",
      "stars": 6445,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.55078125,
          "content": "# VSCode file settings\n.vscode/settings.json\n.vscode/c_cpp_properties.json\n\n# Input elf and rom files\n*.elf\n*.z64\n\n# Local working data\ntests\n\n# Linux build output\nbuild/\n*.o\n\n# Windows build output\n*.exe\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Ww][Ii][Nn]32/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n[Ll]ogs/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n\n# Runtime files\nimgui.ini\nrt64.log\n.idea\ncmake-build*\n.DS_Store\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.4365234375,
          "content": "[submodule \"lib/rabbitizer\"]\n\tpath = lib/rabbitizer\n\turl = https://github.com/Decompollaborate/rabbitizer\n[submodule \"lib/ELFIO\"]\n\tpath = lib/ELFIO\n\turl = https://github.com/serge1/ELFIO\n[submodule \"lib/fmt\"]\n\tpath = lib/fmt\n\turl = https://github.com/fmtlib/fmt\n[submodule \"lib/tomlplusplus\"]\n\tpath = lib/tomlplusplus\n\turl = https://github.com/marzer/tomlplusplus\n[submodule \"lib/sljit\"]\n\tpath = lib/sljit\n\turl = https://github.com/zherczeg/sljit\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 7.9765625,
          "content": "cmake_minimum_required(VERSION 3.20)\nset(CMAKE_C_STANDARD 17)\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n# set(CMAKE_CXX_VISIBILITY_PRESET hidden)\n\n# Rabbitizer\nproject(rabbitizer)\nadd_library(rabbitizer STATIC)\n\ntarget_sources(rabbitizer PRIVATE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/analysis/LoPairingInfo.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/analysis/RegistersTracker.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/instructions/InstrId.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/instructions/InstrIdType.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/instructions/InstructionBase.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/instructions/InstructionCpu.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/instructions/InstructionR3000GTE.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/instructions/InstructionR5900.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/src/instructions/InstructionRsp.cpp\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/analysis/RabbitizerLoPairingInfo.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/analysis/RabbitizerRegistersTracker.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/analysis/RabbitizerTrackedRegisterState.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/common/RabbitizerConfig.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/common/RabbitizerVersion.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/common/Utils.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstrCategory.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstrDescriptor.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstrId.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstrIdType.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstrSuffix.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionCpu/RabbitizerInstructionCpu_OperandType.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionR3000GTE/RabbitizerInstructionR3000GTE.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionR3000GTE/RabbitizerInstructionR3000GTE_OperandType.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionR3000GTE/RabbitizerInstructionR3000GTE_ProcessUniqueId.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionR5900/RabbitizerInstructionR5900.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionR5900/RabbitizerInstructionR5900_OperandType.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionR5900/RabbitizerInstructionR5900_ProcessUniqueId.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionRsp/RabbitizerInstructionRsp.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionRsp/RabbitizerInstructionRsp_OperandType.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstructionRsp/RabbitizerInstructionRsp_ProcessUniqueId.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstruction/RabbitizerInstruction.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstruction/RabbitizerInstruction_Disassemble.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstruction/RabbitizerInstruction_Examination.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstruction/RabbitizerInstruction_Operand.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerInstruction/RabbitizerInstruction_ProcessUniqueId.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerRegister.c\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/src/instructions/RabbitizerRegisterDescriptor.c\")\n\ntarget_include_directories(rabbitizer PUBLIC\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/include\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/cplusplus/include\")\n\ntarget_include_directories(rabbitizer PRIVATE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/rabbitizer/tables\")\n\n# fmtlib\nadd_subdirectory(lib/fmt)\n\n# tomlplusplus\nset(TOML_ENABLE_FORMATTERS OFF)\nadd_subdirectory(lib/tomlplusplus)\n\n# Hardcoded symbol lists (separate library to not force a dependency on N64Recomp)\nproject(SymbolLists)\nadd_library(SymbolLists)\n\ntarget_sources(SymbolLists PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/symbol_lists.cpp\n)\n\ntarget_include_directories(SymbolLists PUBLIC\n    \"${CMAKE_CURRENT_SOURCE_DIR}/include\"\n)\n\n# N64 recompiler core library\nproject(N64Recomp)\nadd_library(N64Recomp)\n\ntarget_sources(N64Recomp PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/analysis.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/operations.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/cgenerator.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/recompilation.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/mod_symbols.cpp\n)\n\ntarget_include_directories(N64Recomp PUBLIC\n    \"${CMAKE_CURRENT_SOURCE_DIR}/include\"\n)\n\ntarget_link_libraries(N64Recomp SymbolLists fmt rabbitizer tomlplusplus::tomlplusplus)\n\n# N64 recompiler elf parsing\nproject(N64RecompElf)\nadd_library(N64RecompElf)\n\ntarget_sources(N64RecompElf PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/elf.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/symbol_lists.cpp\n)\n\ntarget_include_directories(N64RecompElf PUBLIC\n    \"${CMAKE_CURRENT_SOURCE_DIR}/include\"\n)\n\ntarget_include_directories(N64RecompElf PRIVATE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/lib/ELFIO\"\n)\n\ntarget_link_libraries(N64RecompElf fmt)\n\n# N64 recompiler executable\nproject(N64RecompCLI)\nadd_executable(N64RecompCLI)\n\ntarget_sources(N64RecompCLI PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/config.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/main.cpp\n)\n\ntarget_include_directories(N64RecompCLI PRIVATE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/include\"\n)\n\ntarget_link_libraries(N64RecompCLI fmt rabbitizer tomlplusplus::tomlplusplus N64Recomp N64RecompElf)\nset_target_properties(N64RecompCLI PROPERTIES OUTPUT_NAME N64Recomp)\n\n# RSP recompiler\nproject(RSPRecomp)\nadd_executable(RSPRecomp)\n\ntarget_include_directories(RSPRecomp PRIVATE \"${CMAKE_CURRENT_SOURCE_DIR}/include\")\n\ntarget_link_libraries(RSPRecomp fmt rabbitizer tomlplusplus::tomlplusplus)\n\ntarget_sources(RSPRecomp PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/RSPRecomp/src/rsp_recomp.cpp)\n\n# Mod tool\nproject(RecompModTool)\nadd_executable(RecompModTool)\n\ntarget_sources(RecompModTool PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/config.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/mod_symbols.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/RecompModTool/main.cpp\n)\n\ntarget_include_directories(RecompModTool PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/lib/ELFIO\n)\n\ntarget_link_libraries(RecompModTool fmt tomlplusplus::tomlplusplus N64RecompElf)\n\n# Offline mod recompiler\nproject(OfflineModRecomp)\nadd_executable(OfflineModRecomp)\n\ntarget_sources(OfflineModRecomp PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/src/config.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/OfflineModRecomp/main.cpp\n)\n\ntarget_link_libraries(OfflineModRecomp fmt rabbitizer tomlplusplus::tomlplusplus N64Recomp)\n\n# Live recompiler\nproject(LiveRecomp)\nadd_library(LiveRecomp)\n\ntarget_sources(LiveRecomp PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/LiveRecomp/live_generator.cpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/lib/sljit/sljit_src/sljitLir.c\n)\n\ntarget_include_directories(LiveRecomp PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/lib/sljit/sljit_src\n)\n\ntarget_link_libraries(LiveRecomp N64Recomp)\n\n# Live recompiler test\nproject(LiveRecompTest)\nadd_executable(LiveRecompTest)\n\ntarget_sources(LiveRecompTest PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/LiveRecomp/live_recompiler_test.cpp\n)\n\ntarget_include_directories(LiveRecompTest PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/lib/sljit/sljit_src\n)\n\ntarget_link_libraries(LiveRecompTest LiveRecomp)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2024 Wiseguy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "LiveRecomp",
          "type": "tree",
          "content": null
        },
        {
          "name": "OfflineModRecomp",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.9306640625,
          "content": "# N64: Recompiled\nN64: Recompiled is a tool to statically recompile N64 binaries into C code that can be compiled for any platform. This can be used for ports or tools as well as for simulating behaviors significantly faster than interpreters or dynamic recompilation can. More widely, it can be used in any context where you want to run some part of an N64 binary in a standalone environment.\n\nThis is not the first project that uses static recompilation on game console binaries. A well known example is [jamulator](https://github.com/andrewrk/jamulator), which targets NES binaries. Additionally, this is not even the first project to apply static recompilation to N64-related projects: the [IDO static recompilation](https://github.com/decompals/ido-static-recomp) recompiles the SGI IRIX IDO compiler on modern systems to faciliate matching decompilation of N64 games. This project works similarly to the IDO static recomp project in some ways, and that project was my main inspiration for making this.\n\n## Table of Contents\n* [How it Works](#how-it-works)\n* [Overlays](#overlays)\n* [How to Use](#how-to-use)\n* [Single File Output Mode](#single-file-output-mode-for-patches)\n* [RSP Microcode Support](#rsp-microcode-support)\n* [Planned Features](#planned-features)\n* [Building](#building)\n\n## How it Works\nThe recompiler works by accepting a list of symbols and metadata alongside the binary with the goal of splitting the input binary into functions that are each individually recompiled into a C function, named according to the metadata.\n\nInstructions are processed one-by-one and corresponding C code is emitted as each one gets processed. This translation is very literal in order to keep complexity low. For example, the instruction `addiu $r4, $r4, 0x20`, which adds `0x20` to the 32-bit value in the low bytes of register `$r4` and stores the sign extended 64-bit result in `$r4`, gets recompiled into `ctx->r4 = ADD32(ctx->r4, 0X20);` The `jal` (jump-and-link) instruction is recompiled directly into a function call, and `j` or `b` instructions (unconditional jumps and branches) that can be identified as tail-call optimizations are also recompiled into function calls as well. Branch delay slots are handled by duplicating instructions as necessary. There are other specific behaviors for certain instructions, such as the recompiler attempting to turn a `jr` instruction into a switch-case statement if it can tell that it's being used with a jump table. The recompiler has mostly been tested on binaries built with old MIPS compilers (e.g. mips gcc 2.7.2 and IDO) as well as modern clang targeting mips. Modern mips gcc may trip up the recompiler due to certain optimizations it can do, but those cases can probably be avoided by setting specific compilation flags.\n\nEvery output function created by the recompiler is currently emitted into its own file. An option may be provided in the future to group functions together into output files, which should help improve build times of the recompiler output by reducing file I/O in the build process.\n\nRecompiler output can be compiled with any C compiler (tested with msvc, gcc and clang). The output is expected to be used with a runtime that can provide the necessary functionality and macro implementations to run it. A runtime is provided in [N64ModernRuntime](https://github.com/N64Recomp/N64ModernRuntime) which can be seen in action in the [Zelda 64: Recompiled](https://github.com/Zelda64Recomp/Zelda64Recomp) project.\n\n## Overlays\nStatically linked and relocatable overlays can both be handled by this tool. In both cases, the tool emits function lookups for jump-and-link-register (i.e. function pointers or virtual functions) which the provided runtime can implement using any sort of lookup table. For example, the instruction `jalr $25` would get recompiled as `LOOKUP_FUNC(ctx->r25)(rdram, ctx);` The runtime can then maintain a list of which program sections are loaded and at what address they are at in order to determine which function to run whenever a lookup is triggered during runtime.\n\nFor relocatable overlays, the tool will modify supported instructions possessing relocation data (`lui`, `addiu`, load and store instructions) by emitting an extra macro that enables the runtime to relocate the instruction's immediate value field. For example, the instruction `lui $24, 0x80C0` in a section beginning at address `0x80BFA100` with a relocation against a symbol with an address of `0x80BFA730` will get recompiled as `ctx->r24 = S32(RELOC_HI16(1754, 0X630) << 16);`, where 1754 is the index of this section. The runtime can then implement the RELOC_HI16 and RELOC_LO16 macros in order to handle modifying the immediate based on the current loaded address of the section.\n\nSupport for relocations for TLB mapping is coming in the future, which will add the ability to provide a list of MIPS32 relocations so that the runtime can relocate them on load. Combining this with the functionality used for relocatable overlays should allow running most TLB mapped code without incurring a performance penalty on every RAM access.\n\n## How to Use\nThe recompiler is configured by providing a toml file in order to configure the recompiler behavior, which is the first argument provided to the recompiler. The toml is where you specify input and output file paths, as well as optionally stub out specific functions, skip recompilation of specific functions, and patch single instructions in the target binary. There is also planned functionality to be able to emit hooks in the recompiler output by adding them to the toml (the `[[patches.func]]` and `[[patches.hook]]` sections of the linked toml below), but this is currently unimplemented. Documentation on every option that the recompiler provides is not currently available, but an example toml can be found in the Zelda 64: Recompiled project [here](https://github.com/Mr-Wiseguy/Zelda64Recomp/blob/dev/us.rev1.toml).\n\nCurrently, the only way to provide the required metadata is by passing an elf file to this tool. The easiest way to get such an elf is to set up a disassembly or decompilation of the target binary, but there will be support for providing the metadata via a custom format to bypass the need to do so in the future.\n\n## Single File Output Mode (for Patches)\nThis tool can also be configured to recompile in \"single file output\" mode via an option in the configuration toml. This will emit all of the functions in the provided elf into a single output file. The purpose of this mode is to be able to compile patched versions of functions from the target binary.\n\nThis mode can be combined with the functionality provided by almost all linkers (ld, lld, MSVC's link.exe, etc.) to replace functions from the original recompiler output with modified versions. Those linkers only look for symbols in a static library if they weren't already found in a previous input file, so providing the recompiled patches to the linker before providing the original recompiler output will result in the patches taking priority over functions with the same names from the original recompiler output.\n\nThis saves a tremendous amount of time while iterating on patches for the target binary, as you can bypass rerunning the recompiler on the target binary as well as compiling the original recompiler output. An example of using this single file output mode for that purpose can be found in the Zelda 64: Recompiled project [here](https://github.com/Mr-Wiseguy/Zelda64Recomp/blob/dev/patches.toml), with the corresponding Makefile that gets used to build the elf for those patches [here](https://github.com/Mr-Wiseguy/Zelda64Recomp/blob/dev/patches/Makefile).\n\n## RSP Microcode Support\nRSP microcode can also be recompiled with this tool. Currently there is no support for recompiling RSP overlays, but it may be added in the future if desired. Documentation on how to use this functionality will be coming soon.\n\n## Planned Features\n* Custom metadata format to provide symbol names, relocations, and any other necessary data in order to operate without an elf\n* Emitting multiple functions per output file to speed up compilation\n* Support for recording MIPS32 relocations to allow runtimes to relocate them for TLB mapping\n* Ability to recompile into a dynamic language (such as Lua) to be able to load code at runtime for mod support\n\n## Building\nThis project can be built with CMake 3.20 or above and a C++ compiler that supports C++20. This repo uses git submodules, so be sure to clone recursively (`git clone --recurse-submodules`) or initialize submodules recursively after cloning (`git submodule update --init --recursive`). From there, building is identical to any other cmake project, e.g. run `cmake` in the target build folder and point it at the root of this repo, then run `cmake --build .` from that target folder.\n\n## Libraries Used\n* [rabbitizer](https://github.com/Decompollaborate/rabbitizer) for instruction decoding/analysis\n* [ELFIO](https://github.com/serge1/ELFIO) for elf parsing\n* [toml11](https://github.com/ToruNiina/toml11) for toml parsing\n* [fmtlib](https://github.com/fmtlib/fmt)\n"
        },
        {
          "name": "RSPRecomp",
          "type": "tree",
          "content": null
        },
        {
          "name": "RecompModTool",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}