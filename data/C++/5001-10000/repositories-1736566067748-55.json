{
  "metadata": {
    "timestamp": 1736566067748,
    "page": 55,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ValveSoftware/GameNetworkingSockets",
      "stars": 8384,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.166015625,
          "content": "root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\n\n[*.py]\nindent_style = space\nindent_size = 4\n\n[CMakeLists.txt,*.{cpp,h}]\nindent_style = tab\nindent_size = 4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.0693359375,
          "content": "# Prerequisites\n*.d\n\n# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\nobj\n\n# Precompiled Headers\n*.gch\n*.pch\n\n/bin\n\n# Ignore CMake outputs\ncompile_commands.json\nCMakeCache.txt\nCMakeFiles\nMakefile\ncmake_install.cmake\n\n# Ignore outputs from \"perf record\"\nperf.data\nperf.data.old\n\n# Default/recommended install directory for vcpkg\n**/vcpkg\n\n# Other misc stuff\n*.VC.*\n**/.vscode\n**/build\n**/build-*\n**/build.bat\n**/log.txt\n**/.vs\n/src/steamnetworkingsockets/Messageswin64Debug/*\n/src/steamnetworkingsockets/certtool/win64/*\n/src/steamnetworkingsockets/clientlib/win64/*\n*.swp\n/.github/build-ci-ccache\n*.log\n*build-ci-ccache*\nvcpkg_installed\n.p4config\nP4CONFIG\n\n# We use cmake, so no Visual studio project files should be in git\n*.sln\n*.vcxproj\n*.vcxproj.filters\n*.vcxproj.user\n*.vpc_crc\n*.vpc.sentinel\n*_from_partner.bat\nsrc/mp.bat\n*_changes.html\n\n# Unfortunately, in the partner branch we compile our generated protobufs\n# directly into the common folder\nsrc/common/*.pb.cc\nsrc/common/*.pb.h\n\n# Protobuf has some test scripts and we get warnings about line endings\nsrc/external/protobuf-3.15.3/**/*.sh\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.33984375,
          "content": "[submodule \"src/external/abseil\"]\n\tpath = src/external/abseil\n\turl = https://github.com/abseil/abseil-cpp\n\tbranch = lts_2020_02_25\n[submodule \"src/external/webrtc\"]\n\tpath = src/external/webrtc\n\turl = https://webrtc.googlesource.com/src\n[submodule \"src/external/picojson\"]\n\tpath = src/external/picojson\n\turl = https://github.com/kazuho/picojson.git\n"
        },
        {
          "name": ".travis-run-local.py",
          "type": "blob",
          "size": 5.44921875,
          "content": "#!/usr/bin/python\n\"\"\"\nUsage:\n    .travis-run-local.py [--arch=<arch>] [--image=<image> --image-tag=<tag>]\n\nOptions:\n    -h --help          Print this help message.\n    --arch=<arch>      Only build in containers with this CPU architecture. [default: any]\n    --image=<image>    Only build for this image name. [default: any]\n    --image-tag=<tag>  Only build for this image tag. [default: any]\n\"\"\"\n\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nimport yaml\nfrom docopt import docopt\n\ndef read_travis_yml():\n    return yaml.load(open('.travis.yml', 'r'), Loader=yaml.SafeLoader)\n\ndef docker_arch(travis_arch):\n    if travis_arch == 'arm64':\n        return 'arm64v8'\n    return travis_arch\n\ndef image_name(image, tag, arch):\n    # e.g. ubuntu:latest\n    image = '%s:%s' % (image, tag)\n\n    if arch != 'amd64':\n        image_prefix = docker_arch(arch) + '/'\n        os.environ['IMAGE_PREFIX'] = image_prefix\n        return image_prefix + image\n\n    return image\n\ndef env_parse(env, arch):\n    kv_str = env.split()\n    kv = { k: v for k, v in [ s.split('=') for s in kv_str ] }\n\n    # Ugly trick to prepare for running commands for this image\n    try:\n        del os.environ['IMAGE_PREFIX']\n    except KeyError:\n        pass\n    os.environ.update(kv)\n\n    if 'IMAGE' not in kv or 'IMAGE_TAG' not in kv:\n        return None\n\n    if options['--arch'] != 'any' and arch != options['--arch']:\n        return None\n\n    if options['--image'] != 'any' and kv['IMAGE'] != options['--image']:\n        return None\n\n    if options['--image-tag'] != 'any' and kv['IMAGE_TAG'] != options['--image-tag']:\n        return None\n\n    return image_name(kv['IMAGE'], kv['IMAGE_TAG'], arch)\n\ndef get_images(travis):\n    match_found = False\n\n    for env in travis['env']['global']:\n        env_parse(env, travis['arch'])\n\n    for env in travis['env']['jobs']:\n        image = env_parse(env, travis['arch'])\n        if image is not None:\n            match_found = True\n            yield image\n\n    for job in travis['jobs']['include']:\n        image = env_parse(job['env'], job['arch'])\n        if image is not None:\n            match_found = True\n            yield image\n\n    # If we didn't find a match with our constraints, maybe the user wanted to\n    # test a specific image not listed in .travis.yml.\n    if not match_found:\n        if 'any' not in [options['--image'], options['--image-tag'], options['--arch']]:\n            image = env_parse(\n                'IMAGE=%s IMAGE_TAG=%s' % (options['--image'], options['--image-tag']),\n                options['--arch']\n            )\n            if image is not None:\n                yield image\n\ndef docker_pull(image):\n    subprocess.run(['docker', 'pull', image], check=True)\n\ndef pull_images(travis):\n    for image in get_images(travis):\n        docker_pull(image)\n\ndef init_logging(level=logging.INFO):\n    root_logger = logging.getLogger('')\n    root_logger.setLevel(level)\n\n    # Log to stdout\n    console_log_format = logging.Formatter(\n        '%(asctime)s %(levelname)7s: %(message)s',\n        '%Y-%m-%d %H:%M:%S')\n    console_logger = logging.StreamHandler(sys.stdout)\n    console_logger.setFormatter(console_log_format)\n    console_logger.setLevel(level)\n    root_logger.addHandler(console_logger)\n\n    return root_logger\n\ndef kill_and_wait():\n    log.info(\"Terminating build container\")\n    subprocess.run('docker kill $CONTAINER_NAME', shell=True, stdout=subprocess.DEVNULL)\n    subprocess.run('docker container rm $CONTAINER_NAME', shell=True, stdout=subprocess.DEVNULL)\n\n    # The container removal process is asynchronous and there's no\n    # convenient way to wait for it, so we'll just poll and see if the\n    # container still exists.\n    log.info(\"Waiting for container to exit...\")\n    attempts = 0\n    while True:\n        proc = subprocess.run('docker container inspect $CONTAINER_NAME', shell=True, stdout=subprocess.DEVNULL)\n        if proc.returncode != 0:\n            break\n        log.info(\"Container is still alive, waiting a few seconds\")\n        attempts += 1\n        if attempts > 5:\n            raise RuntimeError\n        time.sleep(3)\n    log.info(\"Container has exited.\")\n\ndef main():\n    global options\n    global log\n    log = init_logging()\n\n    options = docopt(__doc__)\n\n    # We do a shallow \"git submodule update --init\" in a real travis build, but\n    # that's not useful for local development purposes. We should do a real\n    # update before a container can make shallow clones.\n    log.info(\"Updating submodules\")\n    subprocess.run(['git', 'submodule', 'update', '--init'])\n\n    log.info(\"Parsing Travis configuration file\")\n    travis = read_travis_yml()\n\n    # Pull the images down first\n    log.info(\"Pulling Docker images\")\n    docker_pull('aptman/qus')\n    pull_images(travis)\n\n    # Initialize system environment\n    log.info(\"Preparing system to run foreign architecture containers\")\n    subprocess.run(['docker', 'run', '--rm', '--privileged', 'aptman/qus', '-s', '--', '-r'], check=True)\n    subprocess.run(['docker', 'run', '--rm', '--privileged', 'aptman/qus', '-s', '--', '-p'], check=True)\n\n    # Run native tests first\n    kill_and_wait()\n    for image in get_images(travis):\n        log.info(\"Running build and test process for image %s\", image)\n        stages = ['before_install', 'install', 'script', 'after_script']\n        for stage in stages:\n            for command in travis.get(stage, []):\n                subprocess.run(command, shell=True, check=True)\n        kill_and_wait()\n\n    log.info(\"Build and test run complete!\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.1640625,
          "content": "language: minimal\n\ndist: bionic\n\nos: linux\n\nservices:\n  - docker\n\narch: amd64\n\nenv:\n  global:\n    - CONTAINER_NAME=github-docker-builder\n  jobs:\n    - IMAGE=alpine IMAGE_TAG=latest\n    - IMAGE=archlinux IMAGE_TAG=latest\n    # 18.04 (Bionic) is the oldest one we want to attempt builds with.\n    - IMAGE=ubuntu IMAGE_TAG=bionic\n    - IMAGE=ubuntu IMAGE_TAG=latest\n    - IMAGE=ubuntu IMAGE_TAG=rolling\n    # Something broke here.  Commenting it out to see if it's just broken at the head.\n    #- IMAGE=ubuntu IMAGE_TAG=devel\n    - IMAGE=fedora IMAGE_TAG=latest\n    - IMAGE=fedora IMAGE_TAG=rawhide\n\njobs:\n  include:\n    - arch: i386\n      env: IMAGE=debian IMAGE_TAG=stable\n    - arch: arm64\n      env: IMAGE=ubuntu IMAGE_TAG=rolling\n    # Disabled - the docker is failing to boot ver early with this output:\n    # Unpacking locales (2.31-0ubuntu9) ...\n    # dpkg: error processing archive /var/cache/apt/archives/locales_2.31-0ubuntu9_all.deb (--unpack):\n    #   unable to install new version of './usr/share/doc/locales': Invalid cross-device link\n    # dpkg-deb: error: paste subprocess was killed by signal (Broken pipe)\n    # Errors were encountered while processing:\n    #  /var/cache/apt/archives/locales_2.31-0ubuntu9_all.deb\n    #- arch: ppc64le\n    #  env: IMAGE=ubuntu IMAGE_TAG=rolling\n    - arch: s390x\n      env: IMAGE=ubuntu IMAGE_TAG=rolling\n\nbefore_install:\n  - docker run -d --rm --cap-add SYS_PTRACE --name $CONTAINER_NAME -e LC_ALL=\"C\" -e LANG=\"C\" -v $(pwd):/build -w /build $IMAGE_PREFIX$IMAGE:$IMAGE_TAG tail -f /dev/null\n  - docker ps\n  - docker exec -e CI_BUILD=1 -e IMAGE=$IMAGE -e IMAGE_TAG=$IMAGE_TAG -t $CONTAINER_NAME sh .github/preinstall.sh\n  - docker exec -e CI_BUILD=1 -e IMAGE=$IMAGE -e IMAGE_TAG=$IMAGE_TAG -t $CONTAINER_NAME bash .github/update-packages.sh\n\ninstall:\n  - docker exec -e CI_BUILD=1 -e IMAGE=$IMAGE -e IMAGE_TAG=$IMAGE_TAG -t $CONTAINER_NAME bash .github/install.sh\n  - docker exec -e CI_BUILD=1 -e IMAGE=$IMAGE -e IMAGE_TAG=$IMAGE_TAG -t $CONTAINER_NAME bash .github/install-post.sh\n\nscript:\n  - docker exec -e CI_BUILD=1 -e IMAGE=$IMAGE -e IMAGE_TAG=$IMAGE_TAG -t $CONTAINER_NAME bash .github/build.sh\n  - docker kill $CONTAINER_NAME\n\n# vim: set ts=2 sts=2 sw=2 et:\n"
        },
        {
          "name": "BUILDING.md",
          "type": "blob",
          "size": 6.04296875,
          "content": "Building\n---\n\n## Dependencies\n\n* CMake 3.10 or later\n* A build tool like Ninja, GNU Make or Visual Studio\n* A C++11-compliant compiler, such as:\n  * GCC 7.3 or later\n  * Clang 3.3 or later\n  * Visual Studio 2017 or later\n* One of the following crypto solutions:\n  * OpenSSL 1.1.1 or later\n  * libsodium (can cause issues on Intel machines with AES-NI disabled see [here](https://github.com/ValveSoftware/GameNetworkingSockets/issues/243))\n  * [bcrypt](https://docs.microsoft.com/en-us/windows/desktop/api/bcrypt/)\n    (Windows only.  Note the primary reason this is supported is to satisfy\n    an Xbox requirement.)\n* Google protobuf 2.6.1+\n* Google [webrtc](https://opensource.google/projects/webrtc) is used for\n  NAT piercing (ICE) for P2P connections.  The relevant code is linked in as a\n  git submodule.  You'll need to initialize that submodule to compile.\n\n## Known Issues\n* The build may have link errors when building with LLVM 10+:\n  [LLVM bug #46313](https://bugs.llvm.org/show_bug.cgi?id=46313). As\n  a workaround, consider building the library with GCC instead.\n\n## Linux\n\n### OpenSSL and protobuf\n\nJust use the appropriate package manager.\n\nUbuntu/debian:\n\n```\n# apt install libssl-dev\n# apt install libprotobuf-dev protobuf-compiler\n```\n\nArch Linux:\n\n```\n# pacman -S openssl\n# pacman -S protobuf\n```\n\n### Building\n\nUsing CMake (preferred):\n\n```\n$ mkdir build\n$ cd build\n$ cmake -G Ninja ..\n$ ninja\n```\n\n## Using vcpkg to build the gamenetworkingsockets package\n\nIf you are using [vcpkg](https://github.com/microsoft/vcpkg/) and are OK with the latest release and default configuration (OpenSSL for the crypto backend, P2P disabled), then you do not need to sync any of this code or build gamenetworkingsockets explicitly.  You can just install the package using vcpkg.  See [this example](examples/vcpkg_example_chat/README.md)\nfor more.\n\n## Windows / Visual Studio\n\nTo build gamenetworkingsockets on Windows, it's recommended to obtain thge dependencies by using vcpkg in [\"manifest mode\"](https://learn.microsoft.com/en-us/vcpkg/concepts/manifest-mode).  The following instructions assume that you will follow the vcpkg recommendations and install vcpkg as a subfolder.  If you want to use \"classic mode\" or install vcpkg somewhere else, you're on your own.\n\nIf you don't want to use vcpkg, try the [manual instructions](BUILDING_WINDOWS_MANUAL.md).\n\nFirst, bootstrap vcpkg.  From the root folder of your GameNetworkingSockets workspace:\n\n```\n> git clone https://github.com/microsoft/vcpkg\n> .\\vcpkg\\bootstrap-vcpkg.bat\n```\n\nFor the following commands, it's important to run them from a Visual Studio command prompt so that the compiler can be located.\n\nYou can obtain the dependent packages into your local `vcpkg` folder as an explicit step.  This is optional because the `cmake` command line below will also do it for you, but doing it as a separate step can help isolate any problems.\n\n```\n> .\\vcpkg\\vcpkg install --triplet=x64-windows\n```\n\nIf you want to use the libsodium backend, install the libsodium dependencies by adding `--x-feature=libsodium`.\n\nNow run cmake to create the project files.  Assuming you have vcpkg in the recommended location as shown above, the vcpkg toolchain will automatically be used, so you do not need to explicitly set `CMAKE_TOOLCHAIN_FILE`.  A minimal command line might look like this:\n\n```\n> cmake -S . -B build -G Ninja\n```\n\nTo build all the examples and tests and add P2P/ICE support via the WebRTC submodule, use something like this:\n\n```\n> cmake -S . -B build -G Ninja -DBUILD_EXAMPLES=ON -DBUILD_TESTS=ON -DUSE_STEAMWEBRTC=ON\n```\n\nFinally, build the projects:\n\n```\n> cd build\n> ninja\n```\n\n## Mac OS X\n\nUsing [Homebrew](https://brew.sh)\n\n### OpenSSL\n\n```\n$ brew install openssl\n$ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/opt/openssl/lib/pkgconfig\n```\nGameNetworkingSockets requries openssl version 1.1+, so if you install and link openssl but at compile you see the error ```Dependency libcrypto found: NO (tried cmake and framework)``` you'll need to force Brew to install openssl 1.1. You can do that like this:\n```\n$ brew install openssl@1.1\n$ export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/opt/openssl@1.1/lib/pkgconfig\n```\n\n### protobuf\n\n```\n$ brew install protobuf\n```\n\n## MSYS2\n\nYou can also build this project on [MSYS2](https://www.msys2.org). First,\nfollow the [instructions](https://www.msys2.org/wiki/MSYS2-installation) on the\nMSYS2 website for updating your MSYS2 install.\n\n**Be sure to follow the instructions at the site above to update MSYS2 before\nyou continue. A fresh install is *not* up to date by default.**\n\nNext install the dependencies for building GameNetworkingSockets (if you want\na 32-bit build, install the i686 versions of these packages):\n\n```\n$ pacman -S \\\n    git \\\n    mingw-w64-x86_64-gcc \\\n    mingw-w64-x86_64-openssl \\\n    mingw-w64-x86_64-pkg-config \\\n    mingw-w64-x86_64-protobuf\n```\n\nAnd finally, clone the repository and build it:\n\n```\n$ git clone https://github.com/ValveSoftware/GameNetworkingSockets.git\n$ cd GameNetworkingSockets\n$ mkdir build\n$ cd build\n$ cmake -G Ninja ..\n$ ninja\n```\n\n**NOTE:** When building with MSYS2, be sure you launch the correct version of\nthe MSYS2 terminal, as the three different Start menu entries will give you\ndifferent environment variables that will affect the build.  You should run the\nStart menu item named `MSYS2 MinGW 64-bit` or `MSYS2 MinGW 32-bit`, depending\non the packages you've installed and what architecture you want to build\nGameNetworkingSockets for.\n\n\n## Visual Studio Code\nIf you're using Visual Studio Code, we have a few extensions to recommend\ninstalling, which will help build the project. Once you have these extensions\ninstalled, open up the .code-workspace file in Visual Studio Code.\n\n### C/C++ by Microsoft\nThis extension provides IntelliSense support for C/C++.\n\nVS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\n\n### CMake Tools by vector-of-bool\nThis extension allows for configuring the CMake project and building it from\nwithin the Visual Studio Code IDE.\n\nVS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=vector-of-bool.cmake-tools\n"
        },
        {
          "name": "BUILDING_WINDOWS_MANUAL.md",
          "type": "blob",
          "size": 5.23046875,
          "content": "Building Windows w/out Using vcpkg\n---\n\nWe recommend using vcpkg to get the dependencies installed.  But if that\ndoesn't work for you for some reason, you might try these instructions.\nThis is a bit of an arduous gauntlet, and this method is no longer supported,\nbut since these instructions were written, and at the present time still work,\nwe didn't delete them in case somebody finds them useful.  However, this is\nnot a supported method of building the library so please don't file any issues.\n\n#### Checking prerequisites\n\nStart a Visual Studio Command Prompt (2017+), and double-check\nthat you have everything you need.  Note that Visual Studio comes with these tools,\nbut you might not have selected to install them.  Or just install them from somewhere\nelse and put them in your `PATH`.\n\n*IMPORTANT*: Make sure you start the command prompt for the desired target\narchitecture (x64 or x64)!  In the examples here we are building 64-bit.\n\n```\n**********************************************************************\n** Visual Studio 2019 Developer Command Prompt v16.5.4\n** Copyright (c) 2019 Microsoft Corporation\n**********************************************************************\n[vcvarsall.bat] Environment initialized for: 'x64'\n\nC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise> cd \\dev\n\nC:\\dev> git --version\ngit version 2.17.1.windows.2\n\nC:\\dev> cmake --version       # 3.5 or higher is required\ncmake version 3.16.19112601-MSVC_2\n\nC:\\dev> ninja --version\n1.8.2\n```\n\n#### OpenSSL\n\nYou can install the [OpenSSL binaries](https://slproweb.com/products/Win32OpenSSL.html)\nprovided by Shining Light Productions. The Windows CMake distribution understands\nhow to find the OpenSSL binaries from these installers, which makes building a lot\neasier. Be sure to pick the installers **without** the \"Light\"suffix. In this instance,\n\"Light\" means no development libraries or headers.\n\nFor CMake to find the libraries, you may need to set the environment variable\n`OPENSSL_ROOT_DIR`.\n\nIf you are linking statically with OpenSSL you will need to set `OPENSSL_USE_STATIC_LIBS` to `ON`.\n`OPENSSL_MSVC_STATIC_RT` is automatically matched to the value of `MSVC_CRT_STATIC`.\n\nBoth need to be set before any calls to `find_package(OpenSSL REQUIRED)` because CMake caches the paths to libraries.\nWhen building GameNetworkingSockets by itself it is sufficient to set these variables on the command line or in the GUI before first configuration.\n\nSee the documentation for [FindOpenSSL](https://cmake.org/cmake/help/latest/module/FindOpenSSL.html) for more information about CMake variables involing OpenSSL.\n\n#### Protobuf\n\nInstructions for getting a working installation of google protobuf on Windows can\nbe found [here](https://github.com/protocolbuffers/protobuf/blob/master/cmake/README.md).\n\nHere is an example.  First, start a Visual Studio Command Prompt as above.  Then download\na particular release of the source.  Here we are using `git`, but\nyou can also just download a [release .zip](https://github.com/protocolbuffers/protobuf/releases).\n\n```\nC:\\dev> git clone -b 3.5.x https://github.com/google/protobuf\nC:\\dev> cd protobuf\n```\n\nCompile the protobuf source.  You need to make sure that all of the following match\nthe settings you will use for compiling GameNetworkingSockets:\n\n* The target architecture must match (controlled by the MSVC environment variables).\n* ```CMAKE_BUILD_TYPE```, which controls debug or release for both projects,\n  and must match.\n* ```protobuf_BUILD_SHARED_LIBS=ON``` in the example indicates that\n  GameNetworkingSockets will link dynamically with protobuf .dlls, which is the\n  default for GameNetworkingSockets.  For static linkage, remove this and set\n  ``Protobuf_USE_STATIC_LIBS=ON`` when building GameNetworkingSockets.\n* If you link statically with protobuf, then you will also need to make sure that\n  the linkage with the MSVC CRT is the same.  The default for both protobuf and\n  GameNetworkingSockets is multithreaded dll.\n\nAlso, note the value for ```CMAKE_INSTALL_PREFIX```.  This specifies where to\n\"install\" the library (headers, link libraries, and the protoc compiler tool).\n\n```\nC:\\dev\\protobuf> mkdir cmake_build\nC:\\dev\\protobuf> cd cmake_build\nC:\\dev\\protobuf\\cmake_build> cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=c:\\sdk\\protobuf-amd64 ..\\cmake\nC:\\dev\\protobuf\\cmake_build> ninja\nC:\\dev\\protobuf\\cmake_build> ninja install\n```\n\n#### Building\n\nStart a Visual Studio Command Prompt, and create a directory to hold the build output.\n\n```\nC:\\dev\\GameNetworkingSockets> mkdir build\nC:\\dev\\GameNetworkingSockets> cd build\n```\n\nYou'll need to add the path to the protobuf `bin` folder to your path, so\nCMake can find the protobuf compiler.  If you followed the example above, that would\nbe something like this:\n\n```\nC:\\dev\\GameNetworkingSockets\\build> set PATH=%PATH%;C:\\sdk\\protobuf-amd64\\bin\n```\n\nNow invoke cmake to generate the type or project you want to build.  Here we are creating\nninja files, for a 100% command line build.  It's also possible to get cmake to output\nVisual studio project (`.vcxproj`) and solution (`.sln`) files.\n```\nC:\\dev\\GameNetworkingSockets\\build> cmake -G Ninja -DCMAKE_BUILD_TYPE=Release ..\n```\n\nFinally, perform the build\n```\nC:\\dev\\GameNetworkingSockets\\build> ninja\n```\n\n\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 9.05859375,
          "content": "cmake_minimum_required(VERSION 3.9)\n\n# If vcpkg present as submodule, bring in the toolchain\nif( EXISTS ${CMAKE_SOURCE_DIR}/vcpkg/scripts/buildsystems/vcpkg.cmake )\n\tmessage(STATUS \"Found ${CMAKE_SOURCE_DIR}/vcpkg/scripts/buildsystems/vcpkg.cmake; using it!\")\n\tset(CMAKE_TOOLCHAIN_FILE ${CMAKE_SOURCE_DIR}/vcpkg/scripts/buildsystems/vcpkg.cmake\n\t\tCACHE STRING \"Vcpkg toolchain file\")\nendif()\n\ninclude(CheckIPOSupported)\ninclude(CMakeDependentOption)\ninclude(CMakePushCheckState)\ninclude(CheckSymbolExists)\n\n# CMP0069: INTERPROCEDURAL_OPTIMIZATION is enforced when enabled.\n# This variable is needed for abseil, which has a different\n# cmake_minimum_required version set (3.5).\nset(CMAKE_POLICY_DEFAULT_CMP0069 NEW)\n\n# Put all the output from all projects into the same folder\n#set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n\nproject(GameNetworkingSockets C CXX)\n\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/cmake)\n\ninclude(DefaultBuildType)\nfind_package(Sanitizers)\n\nif(SANITIZE_ADDRESS OR SANITIZE_THREAD OR SANITIZE_MEMORY OR SANITIZE_UNDEFINED)\n\tset(SANITIZE ON)\nendif()\n\ninclude(FlagsMSVC)\nadd_definitions( -DVALVE_CRYPTO_ENABLE_25519 )\nif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n\tadd_definitions(\n\t\t-D_CRT_SECURE_NO_WARNINGS\n\t\t-D_CRT_NONSTDC_NO_WARNINGS\n\t\t)\nendif()\n\noption(BUILD_STATIC_LIB \"Build the static link version of the client library\" ON)\noption(BUILD_SHARED_LIB \"Build the shared library version of the client library\" ON)\noption(BUILD_EXAMPLES \"Build the included examples\" OFF)\noption(BUILD_TESTS \"Build crypto, pki and network connection tests\" OFF)\noption(BUILD_TOOLS \"Build cert management tool\" OFF)\noption(LTO \"Enable Link-Time Optimization\" OFF)\noption(ENABLE_ICE \"Enable support for NAT-punched P2P connections using ICE protocol.  Build native ICE client\" ON)\noption(USE_STEAMWEBRTC \"Build Google's WebRTC library to get ICE support for P2P\" OFF)\noption(Protobuf_USE_STATIC_LIBS \"Link with protobuf statically\" OFF)\nif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n\toption(MSVC_CRT_STATIC \"Link the MSVC CRT statically\" OFF)\n\tconfigure_msvc_runtime()\n\tprint_default_msvc_flags()\nendif()\n\n#\n# Primary crypto library (for AES, SHA256, etc)\n#\nset(useCryptoOptions OpenSSL libsodium BCrypt)\nset(USE_CRYPTO \"OpenSSL\" CACHE STRING \"Crypto library to use for AES/SHA256\")\nset_property(CACHE USE_CRYPTO PROPERTY STRINGS ${useCryptoOptions})\n\nlist(FIND useCryptoOptions \"${USE_CRYPTO}\" useCryptoIndex)\nif(useCryptoIndex EQUAL -1)\n\tmessage(FATAL_ERROR \"USE_CRYPTO must be one of: ${useCryptoOptions}\")\nendif()\nif(USE_CRYPTO STREQUAL \"BCrypt\" AND NOT WIN32)\n\tmessage(FATAL_ERROR \"USE_CRYPTO=\\\"BCrypt\\\" is only valid on Windows\")\nendif()\n\nif(LTO)\n\tcheck_ipo_supported()\nendif()\n\nif (WIN32)\n\t#\n\t# Strip compiler flags which conflict with ones we explicitly set. If we don't\n\t# do this, then we get a warning on every file we compile for the library.\n\t#\n\tstring(REPLACE \"/EHsc\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n\tstring(REPLACE \"/GR\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n\n\tif (USE_CRYPTO STREQUAL \"BCrypt\")\n\t\t#\n\t\t# Check whether BCrypt can be used with this SDK version\n\t\t#\n\t\ttry_compile(BCRYPT_AVAILABLE \"${CMAKE_CURRENT_BINARY_DIR}/tryCompile\" SOURCES \"${CMAKE_CURRENT_LIST_DIR}/cmake/tryCompileTestBCrypt.cpp\" LINK_LIBRARIES bcrypt OUTPUT_VARIABLE BCRYPT_AVAILABILITY_TEST_MESSAGES)\n\t\tif (NOT BCRYPT_AVAILABLE)\n\t\t\tmessage(STATUS ${BCRYPT_AVAILABILITY_TEST_MESSAGES})\n\t\t\tmessage(FATAL_ERROR \"You're on Windows but BCrypt seems to be unavailable, you will need OpenSSL\")\n\t\tendif()\n\tendif()\nendif()\n\nif (USE_CRYPTO STREQUAL \"OpenSSL\")\n\t# Match the OpenSSL runtime to our setting.\n\t# Note that once found the library paths are cached and will not change if the option is changed.\n\tif (MSVC)\n\t\tset(OPENSSL_MSVC_STATIC_RT ${MSVC_CRT_STATIC})\n\tendif()\n\n\tfind_package(OpenSSL REQUIRED)\n\tmessage( STATUS \"OPENSSL_INCLUDE_DIR = ${OPENSSL_INCLUDE_DIR}\" )\n\n\t# Ensure the OpenSSL version is recent enough. We need a bunch of EVP\n\t# functionality.\n\tcmake_push_check_state()\n\t\tset(CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})\n\t\tset(CMAKE_REQUIRED_LIBRARIES OpenSSL::Crypto)\n\t\tif(WIN32 AND OPENSSL_USE_STATIC_LIBS)\n\t\t\tlist(APPEND CMAKE_REQUIRED_LIBRARIES ws2_32 crypt32)\n\t\tendif()\n\t\tcheck_symbol_exists(EVP_MD_CTX_free openssl/evp.h OPENSSL_NEW_ENOUGH)\n\t\tif (NOT OPENSSL_NEW_ENOUGH)\n\t\t\tmessage(FATAL_ERROR \"Cannot find EVP_MD_CTX_free in OpenSSL headers/libs for the target architecture.  Check that you're using OpenSSL 1.1.0 or later.\")\n\t\tendif()\n\tcmake_pop_check_state()\n\tcmake_push_check_state()\n\t\tset(CMAKE_REQUIRED_LIBRARIES OpenSSL::Crypto)\n\t\tif(WIN32 AND OPENSSL_USE_STATIC_LIBS)\n\t\t\tlist(APPEND CMAKE_REQUIRED_LIBRARIES ws2_32 crypt32)\n\t\tendif()\n\t\tif(USE_CRYPTO25519 STREQUAL \"OpenSSL\")\n\t\t\tcheck_symbol_exists(EVP_PKEY_get_raw_public_key openssl/evp.h OPENSSL_HAS_25519_RAW)\n\t\tendif()\n\tcmake_pop_check_state()\nendif()\n\nif(USE_CRYPTO25519 STREQUAL \"OpenSSL\" AND NOT OPENSSL_HAS_25519_RAW)\n\tmessage(FATAL_ERROR \"Cannot find (EVP_PKEY_get_raw_public_key in OpenSSL headers/libs for the target architecture.  Please use -DUSE_CRYPTO25519=Reference or upgrade OpenSSL to 1.1.1 or later\")\nendif()\n\nif(USE_CRYPTO STREQUAL \"libsodium\" OR USE_CRYPTO25519 STREQUAL \"libsodium\")\n\tfind_package(sodium REQUIRED)\nendif()\n\nif(USE_CRYPTO STREQUAL \"libsodium\")\n\tif(NOT CMAKE_SYSTEM_PROCESSOR MATCHES \"amd64.*|x86_64.*|AMD64.*|i686.*|i386.*|x86.*\")\n\t\tmessage(FATAL_ERROR \"-DUSE_CRYPTO=libsodium invalid, libsodium AES implementation only works on x86/x86_64 CPUs\")\n\tendif()\nendif()\n\n# We always need at least sse2 on x86\nif(CMAKE_SYSTEM_PROCESSOR MATCHES \"amd64.*|x86_64.*|AMD64.*|i686.*|i386.*|x86.*\")\n       set(TARGET_ARCH_FLAGS \"-msse2\")\nendif()\n\nfunction(set_target_common_gns_properties TGT)\n\ttarget_compile_definitions( ${TGT} PRIVATE GOOGLE_PROTOBUF_NO_RTTI )\n\n\tif(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n\t\t# Reduce binary size by allowing for a pseudo-\"function-level linking\" analog\n\t\ttarget_compile_options(${TGT} PRIVATE -ffunction-sections -fdata-sections ${TARGET_ARCH_FLAGS})\n\tendif()\n\n\tif(CMAKE_SYSTEM_NAME MATCHES Linux)\n\t\ttarget_compile_definitions(${TGT} PUBLIC LINUX)\n\telseif(CMAKE_SYSTEM_NAME MATCHES Darwin)\n\t\ttarget_compile_definitions(${TGT} PUBLIC OSX)\n\telseif(CMAKE_SYSTEM_NAME MATCHES FreeBSD)\n\t\ttarget_compile_definitions(${TGT} PUBLIC FREEBSD)\n\telseif(CMAKE_SYSTEM_NAME MATCHES Windows)\n\t\ttarget_compile_definitions(${TGT} PUBLIC _WINDOWS)\n\t\tif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n\t\t\tif(NOT Protobuf_USE_STATIC_LIBS)\n\t\t\t\ttarget_compile_definitions(${TGT} PRIVATE PROTOBUF_USE_DLLS)\n\t\t\tendif()\n\t\t\ttarget_compile_options(${TGT} PRIVATE\n\t\t\t\t/EHs-c-   # Disable C++ exceptions\n\n\t\t\t\t# Below are warnings we can't fix and don't want to see (mostly from protobuf, some from MSVC standard library)\n\t\t\t\t/wd4146   # include/google/protobuf/wire_format_lite.h(863): warning C4146: unary minus operator applied to unsigned type, result still unsigned\n\t\t\t\t/wd4530   # .../xlocale(319): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc\n\t\t\t\t/wd4244   # google/protobuf/wire_format_lite.h(935): warning C4244: 'argument': conversion from 'google::protobuf::uint64' to 'google::protobuf::uint32', possible loss of data\n\t\t\t\t/wd4251   # 'google::protobuf::io::CodedOutputStream::default_serialization_deterministic_': struct 'std::atomic<bool>' needs to have dll-interface to be used by clients of class \n\t\t\t\t/wd4267   # google/protobuf/has_bits.h(73): warning C4267: 'argument': conversion from 'size_t' to 'int', possible loss of data\n\t\t\t\t)\n\n\t\t\t# Disable RTTI except in Debug, because we use dynamic_cast in assert_cast\n\t\t\ttarget_compile_options(${TGT} PRIVATE $<IF:$<CONFIG:Debug>,/GR,/GR->)\n\t\telse()\n\t\t\ttarget_compile_definitions(${TGT} PRIVATE\n\t\t\t\t__STDC_FORMAT_MACROS=1\n\t\t\t\t__USE_MINGW_ANSI_STDIO=0\n\t\t\t\t)\n\t\t\ttarget_compile_options(${TGT} PRIVATE -fno-stack-protector)\n\t\tendif()\n\telse()\n\t\tmessage(FATAL_ERROR \"Could not identify your target operating system\")\n\tendif()\n\n\tif(NOT CMAKE_SYSTEM_NAME MATCHES Windows)\n\t\ttarget_compile_options(${TGT} PRIVATE -fstack-protector-strong)\n\tendif()\n\n\tif(LTO)\n\t\tset_target_properties(${TGT} PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE)\n\tendif()\n\n\tset_target_properties(${TGT} PROPERTIES\n\t\tCXX_STANDARD 11\n\t)\nendfunction()\n\nif(BUILD_EXAMPLES)\n\tif ( NOT BUILD_SHARED_LIB )\n\t\t# See also portfile.cmake\n\t\tmessage(FATAL_ERROR \"Must build shared lib (-DBUILD_SHARED_LIB=ON) to build examples\")\n\tendif()\nendif()\nadd_subdirectory(examples) # examples/CMakeLists will check what's defined and only add appropriate targets\n\nif(BUILD_TESTS)\n\tif ( NOT BUILD_STATIC_LIB )\n\t\t# See also portfile.cmake\n\t\tmessage(FATAL_ERROR \"Must build static lib (-DBUILD_STATIC_LIB=ON) to build tests\")\n\tendif()\n\tadd_subdirectory(tests)\nendif()\n\nadd_subdirectory(src)\n\n#message(STATUS \"---------------------------------------------------------\")\nmessage(STATUS \"Crypto library for AES/SHA256: ${USE_CRYPTO}\")\nmessage(STATUS \"Crypto library for ed25519/curve25519: ${USE_CRYPTO25519}\")\nmessage(STATUS \"Link-time optimization: ${LTO}\")\n#message(STATUS \"---------------------------------------------------------\")\n"
        },
        {
          "name": "GameNetworkingSockets.code-workspace",
          "type": "blob",
          "size": 0.2607421875,
          "content": "{\n\t\"folders\": [\n\t\t{\n\t\t\t\"path\": \".\"\n\t\t}\n\t],\n\t\"settings\": {\n\t\t\"cmake.buildDirectory\": \"${workspaceFolder}/build\",\n\t\t\"C_Cpp.default.compileCommands\": \"${workspaceFolder}/build/compile_commands.json\",\n\t\t\"C_Cpp.default.configurationProvider\": \"ms-vscode.cmake-tools\"\n\t}\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.453125,
          "content": "Copyright (c) 2018, Valve Corporation\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.0654296875,
          "content": "# GameNetworkingSockets\n[![Windows, Ubuntu](https://github.com/ValveSoftware/GameNetworkingSockets/actions/workflows/build.yml/badge.svg)](https://github.com/ValveSoftware/GameNetworkingSockets/actions)  [![MacOS](https://github.com/ValveSoftware/GameNetworkingSockets/actions/workflows/macos.yml/badge.svg)](https://github.com/ValveSoftware/GameNetworkingSockets/actions) [![Linux flavors](https://github.com/ValveSoftware/GameNetworkingSockets/actions/workflows/linux-flavors.yml/badge.svg)](https://github.com/ValveSoftware/GameNetworkingSockets/actions)\n\nGameNetworkingSockets is a basic transport layer for games.  The features are:\n\n* Connection-oriented API (like TCP)\n* ... but message-oriented (like UDP), not stream-oriented.\n* Supports both reliable and unreliable message types\n* Messages can be larger than underlying MTU.  The protocol performs\n  fragmentation, reassembly, and retransmission for reliable messages.\n* A [reliability layer](src/steamnetworkingsockets/clientlib/SNP_WIRE_FORMAT.md)\n  significantly more sophisticated than a basic TCP-style sliding window.\n  It is based on the \"ack vector\" model from DCCP (RFC 4340, section 11.4)\n  and Google QUIC and discussed in the context of games by\n  [Glenn Fiedler](https://gafferongames.com/post/reliable_ordered_messages/).\n  The basic idea is for the receiver to efficiently communicate to the sender\n  the status of every packet number (whether or not a packet was received\n  with that number).  By remembering which segments were sent in each packet,\n  the sender can deduce which segments need to be retransmitted.\n* Encryption. AES-GCM-256 per packet, [Curve25519](https://cr.yp.to/ecdh.html) for\n  key exchange and cert signatures. The details for shared key derivation and\n  per-packet IV are based on the [design](https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit?usp=sharing)\n  used by Google's QUIC protocol.\n* Tools for simulating packet latency/loss, and detailed stats measurement\n* Head-of-line blocking control and bandwidth sharing of multiple message\n  streams (\"lanes\") on the same connection.  You can use strict priority\n  values, softer [weight values](https://en.wikipedia.org/wiki/Weighted_fair_queueing)\n  that control how bandwidth is shared, or some combination of the two methods.\n  See [``ISteamNetworkingSockets::ConfigureConnectionLanes``](include/steam/isteamnetworkingsockets.h).\n* IPv6 support\n* Peer-to-peer networking:\n  * NAT traversal through google WebRTC's ICE implementation.\n  * Plug in your own signaling service.\n  * Unique \"symmetric connect\" mode.\n  * [``ISteamNetworkingMessages``](include/steam/isteamnetworkingmessages.h) is an\n    interface designed to make it easy to port UDP-based code to P2P use cases.  (By\n    UDP-based, we mean non-connection-oriented code, where each time you send a\n    packet, you specify the recipient's address.)\n  * See [README_P2P.md](README_P2P.md) for more info\n* Cross platform.  This library has shipped on consoles, mobile platforms, and non-Steam\n  stores, and has been used to facilitate cross-platform connectivity.  Contact us to get\n  access to the code.  (We are not allowed to distribute it here.)\n\nWhat it does *not* do:\n\n* Higher level serialization of entities, delta encoding of changed state\n  variables, etc\n* Compression\n\n## Quick API overview\n\nTo get an idea of what the API is like, here are a few things to check out:\n\n* The [include/steam](include/steam) folder has the public API headers.\n  * [``ISteamNetworkingSockets``](include/steam/isteamnetworkingsockets.h) is the\n    most important interface.\n  * [``steamnetworkingtypes.h``](include/steam/steamnetworkingtypes.h) has misc\n    types and declarations.\n* The\n  [Steamworks SDK documentation](https://partner.steamgames.com/doc/api/ISteamNetworkingSockets)\n  offers web-based documentation for these APIs.  Note that some features\n  are only available on Steam, such as Steam's authentication service,\n  signaling service, and the SDR relay service.\n* Look at these examples:\n  * [example_chat.cpp](examples/example_chat.cpp).  Very simple client/server\n    program using all reliable messages over ordinary IPv4.\n  * [test_p2p.cpp](tests/test_p2p.cpp).  Shows how to get two hosts to connect\n    to each other using P2P connectivity.  Also an example of how to write a\n    signaling service plugin.\n\n## Building\n\nSee [BUILDING](BUILDING.md) for more information.\n\n## Language bindings\n\nThe library was written in C++, but there is also a plain C interface\nto facilitate binding to other languages.\n\nThird party language bindings:\n\n* C#:\n  * <https://github.com/nxrighthere/ValveSockets-CSharp>\n  * <https://github.com/Facepunch/Facepunch.Steamworks>\n* Go:\n  * <https://github.com/nielsAD/gns/>\n* Rust:\n  * <https://github.com/hussein-aitlahcen/gns-rs>\n\n## Why do I see \"Steam\" everywhere?\n\nThe main interface class is named SteamNetworkingSockets, and many files have\n\"steam\" in their name.  But *Steam is not needed*.  If you don't make games or\naren't on Steam, feel free to use this code for whatever purpose you want.\n\nThe reason for \"Steam\" in the names is that this provides a subset of the\nfunctionality of the [API](https://partner.steamgames.com/doc/api/ISteamNetworkingSockets)\nwith the same name in the Steamworks SDK.  Our main\nreason for releasing this code is so that developers won't have any hesitation\ncoding to the API in the Steamworks SDK.  On Steam, you will link against the\nSteamworks version, and you can access the additional services provided by\nthe [Steam Datagram Relay](https://partner.steamgames.com/doc/features/multiplayer/steamdatagramrelay)\nnetwork.  On other platforms and stores, as long as you ship a version of your\ngame on Steam, you might be able to take advantage of these services.  See\nthe Steamworks documentation for more information.  Because this is a live\nservice, and we need to control our security and backward compatibility burden,\nat this time we are not able to offer access to SDR on other platforms to all\npartners.\n\nIf you aren't a Steam partner, or don't have a version of your game on Steam,\nthen use this opensource version of the API and take advantage of the permissive\nlicense to do whatever you want.  We want you to take maximum advantage of the\nfeatures in the Steamworks version.  That won't happen if this API is a weird\n\"wart\" that's hidden behind `#ifdef STEAM`, which is why we're making this\nopensource version available.\n\nThe desire to match the Steamworks SDK also explains a somewhat anachronistic\ncoding style and weird directory layout.  This project is kept in sync with the\nSteam code here at Valve.  When we extracted the code from the much larger\ncodebase, we had to do some relatively gross hackery.  The files in folders\nnamed  `tier0`, `tier1`, `vstdlib`, `common`, etc have especially suffered\ntrauma.  Also if you see code that appears to have unnecessary layers of\nabstraction, it's probably because those layers are needed to support relayed\nconnection types or some part of the Steamworks SDK.\n\n## Security\n\nDid you find a security vulnerability?  Please inform us responsibly; you may\nbe eligible for a bug bounty.  See the [security policy](SECURITY.md) for more\ninformation.\n"
        },
        {
          "name": "README_P2P.md",
          "type": "blob",
          "size": 8.0078125,
          "content": "# About that P2P support....\n\nSteamNetworkingSockets supports peer-to-peer connections.  A \"peer-to-peer\"\nconnection in this context means that the hosts do not (initially) know\neach other's IP address.  Furthermore, they may be behind NAT, and so they\nmay not know their *own* public IP address.  They may not even *have* a public\nIP that other hosts can use to send them inbound traffic.  [Here](https://tailscale.com/blog/how-nat-traversal-works/)\nis a good article about the problem of NAT traversal.\n\n[ICE](https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment)\nis an internet standard protocol for discovering and sharing IP addresses,\nnegotiating NAT, and establishing a direct connection or fallback to relaying\nthe connection if necessary.\n\nThe opensource version of the code can compile with [google webrtc](https://webrtc.googlesource.com/src)'s ICE\nimplementation.  We interface with the WebRTC code at a reletaively low level\nand only use it for datagram transport.  We don't use DTLS or WebRTC data\nchannels.  (In the future, we may offer alternate NAT traversal\nimplementations.  In particular, we'd like to have an implementation that\nuses [PCP](https://tools.ietf.org/html/rfc6887), which is not used by\nthe current google WebRTC code.)\n\n## Symmetric connect mode\n\nSteamNetworkingSockets offers a unique feature known as *symmetric\nconnect mode*, which really puts the \"peer\" in \"peer-to-peer connection\".\nThis feature is useful in the following common use case:\n\n* Two hosts wish to establish a *single* connection between them.\n* Either host may initiate the connection.\n* The hosts may initiate the connection at the same time.\n\nThis situation involves race conditions that can be tricky to get\nright, especially when authentication, encryption, ICE roles, etc\nare involved.  With symmetric connect mode, sorting out these race\nconditions and producing a single connection is handled by the API.\n\nSee the ``k_ESteamNetworkingConfig_SymmetricConnect``\nconnection flag in [steamnetworkingtypes.h](include/steam/steamnetworkingtypes.h)\nfor more info.\n\n## ISteamNetworkingMessages\n\nMost P2P libraries, such as google WebRTC, and indeed our own\n[ISteamNetworkingSockets](include/steam/isteamnetworkingsockets.h), are *connection\noriented*.  To talk to a peer, you first establish a connection to the peer, and\nwhen you send and receive messages, the peer is identified by the connection handle.\n\nMuch existing network code is based on UDP with a single socket, where\n connection handles are not used.  Instead, packets are sent with the IP address\n of the recipeient specified for each packet.   (E.g. ``sentto()`` and ``recvfrom()``).\n[ISteamNetworkingMessages](include/steam/isteamnetworkingmessages.h) was created\nto provide a more \"ad-hoc\" interface like UDP.  It can be useful when adding P2P\nsupport to existing code, depending on the abstraction you are working with.  If\nthe code you are modifing already has the concept of a connection, then you might\nfind it easier to use ISteamNetworkinSockets directly.  But if you are modifying code\nat a lower level, you may find that you need to maintain a table of active connections,\nand each time you send a packet, use the existing connection if one exists, or\ncreate a new connection if one does not exist.  This is exactly what\nISteamNetworkingMessages does for you.  It creates symmetric-mode connections on\ndemand the first time you communicate with a given peer, and idle connections are\nautomatically closed when they are no longer needed.\n\n## Requirements\n\nPeer-to-peer connections require more than just working code.  In addition\nto the code in this library, there are several other prerequisites.\n(Note that the Steamworks API provides all of these services for Steam games.)\n\n### Signaling service\n\nA side channel, capable of relaying small rendezvous\nmessages from one host to another.  This means hosts must have a constant\nconnection to your service, once that enables you to *push* messages to them.\n\nSteamNetworkingSockets supports a pluggable signaling service.  The requirements\nplaced on your signaling service are relatively minimal:\n\n* Individual rendezvous messages are small.  (Perhaps bigger than IP MTU,\n  but never more than a few KB.)\n* Only datagram \"best-effort\" delivery is required.  The signaling protocol\n  is tolerant of dropped, duplicated, or reordered messages.\n  These anomalies may cause negotiation to take longer, but not fail.\n  This means, for example that there doesn't need to be a mechanism to\n  inform the system when your connection to the signaling service is\n  disrupted.\n* The channel can be relatively low bandwidth and high latency.  Usually\n  there is a burst of a handful of exchanges when a connection is created,\n  followed by silence, unless something changes with the connection.\n\n\n### STUN server(s)\n\nA [STUN](https://en.wikipedia.org/wiki/STUN) server is used to help peers\ndiscover their own public IP address and open up firewalls.  STUN\nservers are relatively low bandwidth, and there are publicly-available ones.\n\n### Relay fallback\n\nUnfortunatley, for some pairs of hosts, NAT piercing is not successful.\nIn this situation, the traffic must be relayed.  In the ICE protocol, this is\ndone using [TURN](https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT)\nservers.  (NOTE: Any TURN server also doubles as a STUN server.)  Because the TURN\nserver is relaying every packet, is is a relatively costly service, so you probably\nwill need to run your own, or just fail connections that cannot pierce NAT.\n\nOn Steam we use a custom relay service known as [Steam Datgaram Relay](https://partner.steamgames.com/doc/features/multiplayer/steamdatagramrelay)\n-- SDR for short -- carrying packets through our network of relays and\non our backbone.   (You may see this mentioned in the opensource code here,\nbut the SDR support code is not opensource.)  Also, on Steam we always\nrelay traffic and do not share IP addresses between untrusted peers, so\nthat malicious players cannot DoS attack.\n\n### Naming hosts and matchmaking\n\nThe above requirements are just what is needed to make a connection between two\nhosts, once you know who to connect to.  But before that, you need a way to assign an\nidentity to a host, authenticate them, matchmaking them, etc.  Those services are\nalso included with Steam, but outside the scope of a transport library like this.\n\n## Using P2P\n\nAssuming you have all of those requirements, you can use SteamNetworkingSockets\nto make P2P connections!\n\nTo compile with ICE support, set USE_STEAMWEBRTC when building the project files:\n```\ncmake -DUSE_STEAMWEBRTC=ON (etc...)\n```\n\nYou'll also need to activate two git submodules to pull down the google WebRTC code.\n(Just run ``cmake`` and follow the instructions.)\n\nTake a look at these files for more information:\n\n* [steamnetworkingcustomsignaling.h](include/steam/steamnetworkingcustomsignaling.h)\n  contains the interfaces you'll need to implement for your signaling service.\n* An example of a really trivial signaling protocol:\n  * [trivial_signaling_server.go](examples/trivial_signaling_server.go) server\n  * [trivial_signaling_client.cpp](examples/trivial_signaling_client.cpp) client\n* A test case that puts everything together.  It starts up an example trivial\n  signaling protocol server and two peers, and has them connect to each other\n  and exchange a few messages.  We use the publicly-available google STUN servers.\n  (No TURN servers for relay fallback in this example.)\n  * [test_p2p.py](tests/test_p2p.py) Executive test script that starts all the processes.\n  * [test_p2p.cpp](tests/test_p2p.cpp) Code for the process each peer runs.\n\n## Roadmap\n\nHere are some things we have in mind to make P2P support better:\n\n* Get plugins written for standard, opensource protocols that could be used for\nsignaling, such as [XMPP](https://xmpp.org/).  This would be a great project for\n  somebody else to do!  We would welcome contributions to this repository, or\n  happily link to your own project.  (See issue #136)\n* LAN beacon support, so that P2P connections can be made even when signaling\n  is down or the hosts do not have Internet connectivity.  (See issue #82)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.4482421875,
          "content": "# Security Policy\n\nIf you believe you have found a security vulnerability, please do not file a\npublic issue or pull request.  Instead, disclose it responsibly through\n[hacker one](https://hackerone.com/valve).\n\nBecause most of the code in this library is used in the Steamworks SDK and our\ngames, it is in scope for hackerone reports.  Note that to be eligible\nfor a bounty, the vulnerability needs to be in a part of the code that is used\nby Steam players.\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "vcpkg.json",
          "type": "blob",
          "size": 0.8994140625,
          "content": "{\n\t\"$schema\": \"https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json\",\n\t\"name\": \"gamenetworkingsockets\",\n\t\"version-string\": \"1.4.0\",\n\t\"description\": \"A basic transport layer for games.\",\n\t\"homepage\": \"https://github.com/ValveSoftware/GameNetworkingSockets\",\n\t\"dependencies\": [ \"protobuf\", \"openssl\" ],\n\t\"default-features\": [ \"openssl\" ],\n\t\"features\": {\n\t\t\"openssl\": {\n\t\t\t\"description\": \"Use OpenSSL as the crypto provider.  This is the default.\",\n\t\t\t\"dependencies\": [ \"openssl\" ]\n\t\t},\n\t\t\"libsodium\": {\n\t\t\t\"description\": \"Use libsodium as the crypto provider.\",\n\t\t\t\"dependencies\": [ \"libsodium\" ]\n\t\t},\n\t\t\"webrtc\": {\n\t\t\t\"description\": \"Compiles WebRTC support for P2P.\",\n\t\t\t\"dependencies\": [ \"abseil\" ]\n\t\t},\n\t\t\"examples\": {\n\t\t\t\"description\": \"Build the examples.\"\n\t\t},\n\t\t\"tests\": {\n\t\t\t\"description\": \"Build the tests.\"\n\t\t},\n\t\t\"tools\": {\n\t\t\t\"description\": \"Build cert management tool.\"\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "vcpkg_ports",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}