{
  "metadata": {
    "timestamp": 1736566234148,
    "page": 249,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "leethomason/tinyxml2",
      "stars": 5165,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2568359375,
          "content": "# intermediate files\nWin32/\nx64/\nipch/\nresources/out/\ntinyxml2/tinyxml2-cbp/bin/\ntinyxml2/tinyxml2-cbp/obj/\ntinyxml2/bin/\ntinyxml2/temp/\n.artifacts/\n.projects/\n*.sdf\n*.suo\n*.opensdf\n*.user\n*.depend\n*.layout\n*.o\n*.vc.db\n*.vc.opendb\nlibtinyxml2.a\nxmltest\nvs/debug\n\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 3.462890625,
          "content": "cmake_minimum_required(VERSION 3.15)\r\nproject(tinyxml2 VERSION 10.0.0)\r\n\r\ninclude(CTest)\r\noption(tinyxml2_BUILD_TESTING \"Build tests for tinyxml2\" \"${BUILD_TESTING}\")\r\n\r\n##\r\n## Honor tinyxml2_SHARED_LIBS to match install interface\r\n##\r\n\r\nif (DEFINED tinyxml2_SHARED_LIBS)\r\n    set(BUILD_SHARED_LIBS \"${tinyxml2_SHARED_LIBS}\")\r\nendif ()\r\n\r\n##\r\n## Main library build\r\n##\r\n\r\nset(CMAKE_CXX_VISIBILITY_PRESET hidden)\r\nset(CMAKE_VISIBILITY_INLINES_HIDDEN YES)\r\n\r\nadd_library(tinyxml2 tinyxml2.cpp tinyxml2.h)\r\nadd_library(tinyxml2::tinyxml2 ALIAS tinyxml2)\r\n\r\n# Uncomment the following line to require C++11 (or greater) to use tinyxml2\r\n# target_compile_features(tinyxml2 PUBLIC cxx_std_11)\r\ntarget_include_directories(tinyxml2 PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\")\r\n\r\ntarget_compile_definitions(\r\n    tinyxml2\r\n    PUBLIC $<$<CONFIG:Debug>:TINYXML2_DEBUG>\r\n    INTERFACE $<$<BOOL:${BUILD_SHARED_LIBS}>:TINYXML2_IMPORT>\r\n    PRIVATE $<$<CXX_COMPILER_ID:MSVC>:_CRT_SECURE_NO_WARNINGS>\r\n    PUBLIC _FILE_OFFSET_BITS=64\r\n)\r\n\r\nset_target_properties(\r\n    tinyxml2\r\n    PROPERTIES\r\n    DEFINE_SYMBOL \"TINYXML2_EXPORT\"\r\n    VERSION \"${tinyxml2_VERSION}\"\r\n    SOVERSION \"${tinyxml2_VERSION_MAJOR}\"\r\n)\r\n\r\nif (tinyxml2_BUILD_TESTING)\r\n    add_executable(xmltest xmltest.cpp)\r\n    target_link_libraries(xmltest PRIVATE tinyxml2::tinyxml2)\r\n\r\n    add_test(\r\n        NAME xmltest\r\n        COMMAND xmltest\r\n        WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\"\r\n    )\r\n\r\n    set_tests_properties(xmltest PROPERTIES PASS_REGULAR_EXPRESSION \", Fail 0\")\r\nendif ()\r\n\r\n##\r\n## Installation\r\n##\r\n\r\n## Standard modules\r\ninclude(GNUInstallDirs)\r\ninclude(CMakePackageConfigHelpers)\r\n\r\n## Custom settings\r\noption(tinyxml2_INSTALL_PKGCONFIG \"Create and install pkgconfig files\" ON)\r\n\r\nset(tinyxml2_INSTALL_PKGCONFIGDIR \"${CMAKE_INSTALL_LIBDIR}/pkgconfig\"\r\n    CACHE PATH \"Directory for pkgconfig files\")\r\n\r\nset(tinyxml2_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/tinyxml2\"\r\n    CACHE STRING \"Path to tinyxml2 CMake files\")\r\n\r\n## CMake targets and export scripts\r\n\r\ninstall(\r\n    TARGETS tinyxml2 EXPORT tinyxml2-targets\r\n    RUNTIME COMPONENT tinyxml2_runtime\r\n    LIBRARY COMPONENT tinyxml2_runtime\r\n    NAMELINK_COMPONENT tinyxml2_development\r\n    ARCHIVE COMPONENT tinyxml2_development\r\n    INCLUDES DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\"\r\n)\r\n\r\n# Type-specific targets\r\n\r\nif (BUILD_SHARED_LIBS)\r\n    set(type shared)\r\nelse ()\r\n    set(type static)\r\nendif ()\r\n\r\ninstall(\r\n    EXPORT tinyxml2-targets\r\n    DESTINATION \"${tinyxml2_INSTALL_CMAKEDIR}\"\r\n    NAMESPACE tinyxml2::\r\n    FILE tinyxml2-${type}-targets.cmake\r\n    COMPONENT tinyxml2_development\r\n)\r\n\r\n# Auto-generated version compatibility file\r\nwrite_basic_package_version_file(\r\n    tinyxml2-config-version.cmake\r\n    COMPATIBILITY SameMajorVersion\r\n)\r\n\r\ninstall(\r\n    FILES\r\n    \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/tinyxml2-config.cmake\"\r\n    \"${CMAKE_CURRENT_BINARY_DIR}/tinyxml2-config-version.cmake\"\r\n    DESTINATION \"${tinyxml2_INSTALL_CMAKEDIR}\"\r\n    COMPONENT tinyxml2_development\r\n)\r\n\r\n## Headers\r\n\r\ninstall(\r\n    FILES tinyxml2.h\r\n    TYPE INCLUDE\r\n    COMPONENT tinyxml2_development\r\n)\r\n\r\n## pkg-config\r\n\r\nif (tinyxml2_INSTALL_PKGCONFIG)\r\n    configure_file(cmake/tinyxml2.pc.in tinyxml2.pc.gen @ONLY)\r\n    file(GENERATE OUTPUT tinyxml2.pc INPUT \"${CMAKE_CURRENT_BINARY_DIR}/tinyxml2.pc.gen\")\r\n    install(\r\n        FILES \"${CMAKE_CURRENT_BINARY_DIR}/tinyxml2.pc\"\r\n        DESTINATION \"${tinyxml2_INSTALL_PKGCONFIGDIR}\"\r\n        COMPONENT tinyxml2_development\r\n    )\r\nendif ()\r\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 0.7890625,
          "content": "This software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.9248046875,
          "content": "# For GNU conventions and targets see https://www.gnu.org/prep/standards/standards.html\n# Using GNU standards makes it easier for some users to keep doing what they are used to.\n\n# 'mkdir -p' is non-portable, but it is widely supported. A portable solution\n# is elusive due to race conditions on testing the directory and creating it.\n# Anemic toolchain users can sidestep the problem using MKDIR=\"mkdir\".\n\nAR = ar\nARFLAGS = cr\nRM = rm -f\nRANLIB = ranlib\nMKDIR = mkdir -p\nCXXFLAGS = -D_FILE_OFFSET_BITS=64 -fPIC\n\nINSTALL = install\nINSTALL_PROGRAM = $(INSTALL)\nINSTALL_DATA = $(INSTALL) -m 644\n\nprefix = /usr/local\nbindir = $(prefix)/bin\nlibdir = $(prefix)/lib\nincludedir = $(prefix)/include\n\nall: xmltest staticlib\n\nrebuild: clean all\n\nxmltest: xmltest.cpp libtinyxml2.a\n\neffc:\n\tgcc -Werror -Wall -Wextra -Wshadow -Wpedantic -Wformat-nonliteral \\\n        -Wformat-security -Wswitch-default -Wuninitialized -Wundef \\\n        -Wpointer-arith -Woverloaded-virtual -Wctor-dtor-privacy \\\n        -Wnon-virtual-dtor -Woverloaded-virtual -Wsign-promo \\\n        -Wno-unused-parameter -Weffc++ xmltest.cpp tinyxml2.cpp -o xmltest\n\nclean:\n\t-$(RM) *.o xmltest libtinyxml2.a\n\n# Standard GNU target\ndistclean:\n\t-$(RM) *.o xmltest libtinyxml2.a\n\ntest: xmltest\n\t./xmltest\n\n# Standard GNU target\ncheck: xmltest\n\t./xmltest\n\nstaticlib: libtinyxml2.a\n\nlibtinyxml2.a: tinyxml2.o\n\t$(AR) $(ARFLAGS) $@ $^\n\t$(RANLIB) $@\n\ntinyxml2.o: tinyxml2.cpp tinyxml2.h\n\ndirectories:\n\t$(MKDIR) $(DESTDIR)$(prefix)\n\t$(MKDIR) $(DESTDIR)$(bindir)\n\t$(MKDIR) $(DESTDIR)$(libdir)\n\t$(MKDIR) $(DESTDIR)$(includedir)\n\n# Standard GNU target.\ninstall: xmltest staticlib directories\n\t$(INSTALL_PROGRAM) xmltest $(DESTDIR)$(bindir)/xmltest\n\t$(INSTALL_DATA) tinyxml2.h $(DESTDIR)$(includedir)/tinyxml2.h\n\t$(INSTALL_DATA) libtinyxml2.a $(DESTDIR)$(libdir)/libtinyxml2.a\n\n# Standard GNU target\nuninstall:\n\t$(RM) $(DESTDIR)$(bindir)/xmltest\n\t$(RM) $(DESTDIR)$(includedir)/tinyxml2.h\n\t$(RM) $(DESTDIR)$(libdir)/libtinyxml2.a\n"
        },
        {
          "name": "TinyXML2_small.png",
          "type": "blob",
          "size": 209.9384765625,
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "dox",
          "type": "blob",
          "size": 106.5458984375,
          "content": "# Doxyfile 1.8.13\r\n\r\n# This file describes the settings to be used by the documentation system\r\n# doxygen (www.doxygen.org) for a project.\r\n#\r\n# All text after a double hash (##) is considered a comment and is placed in\r\n# front of the TAG it is preceding.\r\n#\r\n# All text after a single hash (#) is considered a comment and will be ignored.\r\n# The format is:\r\n# TAG = value [value, ...]\r\n# For lists, items can also be appended using:\r\n# TAG += value [value, ...]\r\n# Values that contain spaces should be placed between quotes (\\\" \\\").\r\n\r\n#---------------------------------------------------------------------------\r\n# Project related configuration options\r\n#---------------------------------------------------------------------------\r\n\r\n# This tag specifies the encoding used for all characters in the config file\r\n# that follow. The default is UTF-8 which is also the encoding used for all text\r\n# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv\r\n# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv\r\n# for the list of possible encodings.\r\n# The default value is: UTF-8.\r\n\r\nDOXYFILE_ENCODING      = UTF-8\r\n\r\n# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by\r\n# double-quotes, unless you are using Doxywizard) that should identify the\r\n# project for which the documentation is generated. This name is used in the\r\n# title of most generated pages and in a few other places.\r\n# The default value is: My Project.\r\n\r\nPROJECT_NAME           = \"TinyXML-2\"\r\n\r\n# The PROJECT_NUMBER tag can be used to enter a project or revision number. This\r\n# could be handy for archiving the generated documentation or if some version\r\n# control system is used.\r\n\r\nPROJECT_NUMBER = 10.0.0\r\n\r\n# Using the PROJECT_BRIEF tag one can provide an optional one line description\r\n# for a project that appears at the top of each page and should give viewer a\r\n# quick idea about the purpose of the project. Keep the description short.\r\n\r\nPROJECT_BRIEF          =\r\n\r\n# With the PROJECT_LOGO tag one can specify a logo or an icon that is included\r\n# in the documentation. The maximum height of the logo should not exceed 55\r\n# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy\r\n# the logo to the output directory.\r\n\r\nPROJECT_LOGO           =\r\n\r\n# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path\r\n# into which the generated documentation will be written. If a relative path is\r\n# entered, it will be relative to the location where doxygen was started. If\r\n# left blank the current directory will be used.\r\n\r\nOUTPUT_DIRECTORY       = .\r\n\r\n# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-\r\n# directories (in 2 levels) under the output directory of each output format and\r\n# will distribute the generated files over these directories. Enabling this\r\n# option can be useful when feeding doxygen a huge amount of source files, where\r\n# putting all generated files in the same directory would otherwise causes\r\n# performance problems for the file system.\r\n# The default value is: NO.\r\n\r\nCREATE_SUBDIRS         = NO\r\n\r\n# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII\r\n# characters to appear in the names of generated files. If set to NO, non-ASCII\r\n# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode\r\n# U+3044.\r\n# The default value is: NO.\r\n\r\nALLOW_UNICODE_NAMES    = NO\r\n\r\n# The OUTPUT_LANGUAGE tag is used to specify the language in which all\r\n# documentation generated by doxygen is written. Doxygen will use this\r\n# information to generate all constant output in the proper language.\r\n# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,\r\n# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),\r\n# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,\r\n# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),\r\n# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,\r\n# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,\r\n# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,\r\n# Ukrainian and Vietnamese.\r\n# The default value is: English.\r\n\r\nOUTPUT_LANGUAGE        = English\r\n\r\n# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member\r\n# descriptions after the members that are listed in the file and class\r\n# documentation (similar to Javadoc). Set to NO to disable this.\r\n# The default value is: YES.\r\n\r\nBRIEF_MEMBER_DESC      = YES\r\n\r\n# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief\r\n# description of a member or function before the detailed description\r\n#\r\n# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the\r\n# brief descriptions will be completely suppressed.\r\n# The default value is: YES.\r\n\r\nREPEAT_BRIEF           = YES\r\n\r\n# This tag implements a quasi-intelligent brief description abbreviator that is\r\n# used to form the text in various listings. Each string in this list, if found\r\n# as the leading text of the brief description, will be stripped from the text\r\n# and the result, after processing the whole list, is used as the annotated\r\n# text. Otherwise, the brief description is used as-is. If left blank, the\r\n# following values are used ($name is automatically replaced with the name of\r\n# the entity):The $name class, The $name widget, The $name file, is, provides,\r\n# specifies, contains, represents, a, an and the.\r\n\r\nABBREVIATE_BRIEF       =\r\n\r\n# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then\r\n# doxygen will generate a detailed section even if there is only a brief\r\n# description.\r\n# The default value is: NO.\r\n\r\nALWAYS_DETAILED_SEC    = NO\r\n\r\n# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all\r\n# inherited members of a class in the documentation of that class as if those\r\n# members were ordinary class members. Constructors, destructors and assignment\r\n# operators of the base classes will not be shown.\r\n# The default value is: NO.\r\n\r\nINLINE_INHERITED_MEMB  = NO\r\n\r\n# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path\r\n# before files name in the file list and in the header files. If set to NO the\r\n# shortest path that makes the file name unique will be used\r\n# The default value is: YES.\r\n\r\nFULL_PATH_NAMES        = YES\r\n\r\n# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.\r\n# Stripping is only done if one of the specified strings matches the left-hand\r\n# part of the path. The tag can be used to show relative paths in the file list.\r\n# If left blank the directory from which doxygen is run is used as the path to\r\n# strip.\r\n#\r\n# Note that you can specify absolute paths here, but also relative paths, which\r\n# will be relative from the directory where doxygen is started.\r\n# This tag requires that the tag FULL_PATH_NAMES is set to YES.\r\n\r\nSTRIP_FROM_PATH        =\r\n\r\n# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the\r\n# path mentioned in the documentation of a class, which tells the reader which\r\n# header file to include in order to use a class. If left blank only the name of\r\n# the header file containing the class definition is used. Otherwise one should\r\n# specify the list of include paths that are normally passed to the compiler\r\n# using the -I flag.\r\n\r\nSTRIP_FROM_INC_PATH    =\r\n\r\n# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but\r\n# less readable) file names. This can be useful is your file systems doesn't\r\n# support long names like on DOS, Mac, or CD-ROM.\r\n# The default value is: NO.\r\n\r\nSHORT_NAMES            = NO\r\n\r\n# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the\r\n# first line (until the first dot) of a Javadoc-style comment as the brief\r\n# description. If set to NO, the Javadoc-style will behave just like regular Qt-\r\n# style comments (thus requiring an explicit @brief command for a brief\r\n# description.)\r\n# The default value is: NO.\r\n\r\nJAVADOC_AUTOBRIEF      = NO\r\n\r\n# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first\r\n# line (until the first dot) of a Qt-style comment as the brief description. If\r\n# set to NO, the Qt-style will behave just like regular Qt-style comments (thus\r\n# requiring an explicit \\brief command for a brief description.)\r\n# The default value is: NO.\r\n\r\nQT_AUTOBRIEF           = NO\r\n\r\n# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a\r\n# multi-line C++ special comment block (i.e. a block of //! or /// comments) as\r\n# a brief description. This used to be the default behavior. The new default is\r\n# to treat a multi-line C++ comment block as a detailed description. Set this\r\n# tag to YES if you prefer the old behavior instead.\r\n#\r\n# Note that setting this tag to YES also means that rational rose comments are\r\n# not recognized any more.\r\n# The default value is: NO.\r\n\r\nMULTILINE_CPP_IS_BRIEF = NO\r\n\r\n# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the\r\n# documentation from any documented member that it re-implements.\r\n# The default value is: YES.\r\n\r\nINHERIT_DOCS           = YES\r\n\r\n# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new\r\n# page for each member. If set to NO, the documentation of a member will be part\r\n# of the file/class/namespace that contains it.\r\n# The default value is: NO.\r\n\r\nSEPARATE_MEMBER_PAGES  = NO\r\n\r\n# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen\r\n# uses this value to replace tabs by spaces in code fragments.\r\n# Minimum value: 1, maximum value: 16, default value: 4.\r\n\r\nTAB_SIZE               = 4\r\n\r\n# This tag can be used to specify a number of aliases that act as commands in\r\n# the documentation. An alias has the form:\r\n# name=value\r\n# For example adding\r\n# \"sideeffect=@par Side Effects:\\n\"\r\n# will allow you to put the command \\sideeffect (or @sideeffect) in the\r\n# documentation, which will result in a user-defined paragraph with heading\r\n# \"Side Effects:\". You can put \\n's in the value part of an alias to insert\r\n# newlines.\r\n\r\nALIASES                =\r\n\r\n# This tag can be used to specify a number of word-keyword mappings (TCL only).\r\n# A mapping has the form \"name=value\". For example adding \"class=itcl::class\"\r\n# will allow you to use the command class in the itcl::class meaning.\r\n\r\nTCL_SUBST              =\r\n\r\n# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources\r\n# only. Doxygen will then generate output that is more tailored for C. For\r\n# instance, some of the names that are used will be different. The list of all\r\n# members will be omitted, etc.\r\n# The default value is: NO.\r\n\r\nOPTIMIZE_OUTPUT_FOR_C  = NO\r\n\r\n# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or\r\n# Python sources only. Doxygen will then generate output that is more tailored\r\n# for that language. For instance, namespaces will be presented as packages,\r\n# qualified scopes will look different, etc.\r\n# The default value is: NO.\r\n\r\nOPTIMIZE_OUTPUT_JAVA   = NO\r\n\r\n# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran\r\n# sources. Doxygen will then generate output that is tailored for Fortran.\r\n# The default value is: NO.\r\n\r\nOPTIMIZE_FOR_FORTRAN   = NO\r\n\r\n# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL\r\n# sources. Doxygen will then generate output that is tailored for VHDL.\r\n# The default value is: NO.\r\n\r\nOPTIMIZE_OUTPUT_VHDL   = NO\r\n\r\n# Doxygen selects the parser to use depending on the extension of the files it\r\n# parses. With this tag you can assign which parser to use for a given\r\n# extension. Doxygen has a built-in mapping, but you can override or extend it\r\n# using this tag. The format is ext=language, where ext is a file extension, and\r\n# language is one of the parsers supported by doxygen: IDL, Java, Javascript,\r\n# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:\r\n# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:\r\n# Fortran. In the later case the parser tries to guess whether the code is fixed\r\n# or free formatted code, this is the default for Fortran type files), VHDL. For\r\n# instance to make doxygen treat .inc files as Fortran files (default is PHP),\r\n# and .f files as C (default is Fortran), use: inc=Fortran f=C.\r\n#\r\n# Note: For files without extension you can use no_extension as a placeholder.\r\n#\r\n# Note that for custom extensions you also need to set FILE_PATTERNS otherwise\r\n# the files are not read by doxygen.\r\n\r\nEXTENSION_MAPPING      =\r\n\r\n# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments\r\n# according to the Markdown format, which allows for more readable\r\n# documentation. See http://daringfireball.net/projects/markdown/ for details.\r\n# The output of markdown processing is further processed by doxygen, so you can\r\n# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in\r\n# case of backward compatibilities issues.\r\n# The default value is: YES.\r\n\r\nMARKDOWN_SUPPORT       = YES\r\n\r\n# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up\r\n# to that level are automatically included in the table of contents, even if\r\n# they do not have an id attribute.\r\n# Note: This feature currently applies only to Markdown headings.\r\n# Minimum value: 0, maximum value: 99, default value: 0.\r\n# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.\r\n\r\nTOC_INCLUDE_HEADINGS   = 0\r\n\r\n# When enabled doxygen tries to link words that correspond to documented\r\n# classes, or namespaces to their corresponding documentation. Such a link can\r\n# be prevented in individual cases by putting a % sign in front of the word or\r\n# globally by setting AUTOLINK_SUPPORT to NO.\r\n# The default value is: YES.\r\n\r\nAUTOLINK_SUPPORT       = YES\r\n\r\n# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want\r\n# to include (a tag file for) the STL sources as input, then you should set this\r\n# tag to YES in order to let doxygen match functions declarations and\r\n# definitions whose arguments contain STL classes (e.g. func(std::string);\r\n# versus func(std::string) {}). This also make the inheritance and collaboration\r\n# diagrams that involve STL classes more complete and accurate.\r\n# The default value is: NO.\r\n\r\nBUILTIN_STL_SUPPORT    = NO\r\n\r\n# If you use Microsoft's C++/CLI language, you should set this option to YES to\r\n# enable parsing support.\r\n# The default value is: NO.\r\n\r\nCPP_CLI_SUPPORT        = NO\r\n\r\n# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:\r\n# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen\r\n# will parse them like normal C++ but will assume all classes use public instead\r\n# of private inheritance when no explicit protection keyword is present.\r\n# The default value is: NO.\r\n\r\nSIP_SUPPORT            = NO\r\n\r\n# For Microsoft's IDL there are propget and propput attributes to indicate\r\n# getter and setter methods for a property. Setting this option to YES will make\r\n# doxygen to replace the get and set methods by a property in the documentation.\r\n# This will only work if the methods are indeed getting or setting a simple\r\n# type. If this is not the case, or you want to show the methods anyway, you\r\n# should set this option to NO.\r\n# The default value is: YES.\r\n\r\nIDL_PROPERTY_SUPPORT   = YES\r\n\r\n# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC\r\n# tag is set to YES then doxygen will reuse the documentation of the first\r\n# member in the group (if any) for the other members of the group. By default\r\n# all members of a group must be documented explicitly.\r\n# The default value is: NO.\r\n\r\nDISTRIBUTE_GROUP_DOC   = NO\r\n\r\n# If one adds a struct or class to a group and this option is enabled, then also\r\n# any nested class or struct is added to the same group. By default this option\r\n# is disabled and one has to add nested compounds explicitly via \\ingroup.\r\n# The default value is: NO.\r\n\r\nGROUP_NESTED_COMPOUNDS = NO\r\n\r\n# Set the SUBGROUPING tag to YES to allow class member groups of the same type\r\n# (for instance a group of public functions) to be put as a subgroup of that\r\n# type (e.g. under the Public Functions section). Set it to NO to prevent\r\n# subgrouping. Alternatively, this can be done per class using the\r\n# \\nosubgrouping command.\r\n# The default value is: YES.\r\n\r\nSUBGROUPING            = YES\r\n\r\n# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions\r\n# are shown inside the group in which they are included (e.g. using \\ingroup)\r\n# instead of on a separate page (for HTML and Man pages) or section (for LaTeX\r\n# and RTF).\r\n#\r\n# Note that this feature does not work in combination with\r\n# SEPARATE_MEMBER_PAGES.\r\n# The default value is: NO.\r\n\r\nINLINE_GROUPED_CLASSES = NO\r\n\r\n# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions\r\n# with only public data fields or simple typedef fields will be shown inline in\r\n# the documentation of the scope in which they are defined (i.e. file,\r\n# namespace, or group documentation), provided this scope is documented. If set\r\n# to NO, structs, classes, and unions are shown on a separate page (for HTML and\r\n# Man pages) or section (for LaTeX and RTF).\r\n# The default value is: NO.\r\n\r\nINLINE_SIMPLE_STRUCTS  = NO\r\n\r\n# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or\r\n# enum is documented as struct, union, or enum with the name of the typedef. So\r\n# typedef struct TypeS {} TypeT, will appear in the documentation as a struct\r\n# with name TypeT. When disabled the typedef will appear as a member of a file,\r\n# namespace, or class. And the struct will be named TypeS. This can typically be\r\n# useful for C code in case the coding convention dictates that all compound\r\n# types are typedef'ed and only the typedef is referenced, never the tag name.\r\n# The default value is: NO.\r\n\r\nTYPEDEF_HIDES_STRUCT   = NO\r\n\r\n# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This\r\n# cache is used to resolve symbols given their name and scope. Since this can be\r\n# an expensive process and often the same symbol appears multiple times in the\r\n# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small\r\n# doxygen will become slower. If the cache is too large, memory is wasted. The\r\n# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range\r\n# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536\r\n# symbols. At the end of a run doxygen will report the cache usage and suggest\r\n# the optimal cache size from a speed point of view.\r\n# Minimum value: 0, maximum value: 9, default value: 0.\r\n\r\nLOOKUP_CACHE_SIZE      = 0\r\n\r\n#---------------------------------------------------------------------------\r\n# Build related configuration options\r\n#---------------------------------------------------------------------------\r\n\r\n# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in\r\n# documentation are documented, even if no documentation was available. Private\r\n# class members and static file members will be hidden unless the\r\n# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.\r\n# Note: This will also disable the warnings about undocumented members that are\r\n# normally produced when WARNINGS is set to YES.\r\n# The default value is: NO.\r\n\r\nEXTRACT_ALL            = NO\r\n\r\n# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will\r\n# be included in the documentation.\r\n# The default value is: NO.\r\n\r\nEXTRACT_PRIVATE        = NO\r\n\r\n# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal\r\n# scope will be included in the documentation.\r\n# The default value is: NO.\r\n\r\nEXTRACT_PACKAGE        = NO\r\n\r\n# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be\r\n# included in the documentation.\r\n# The default value is: NO.\r\n\r\nEXTRACT_STATIC         = NO\r\n\r\n# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined\r\n# locally in source files will be included in the documentation. If set to NO,\r\n# only classes defined in header files are included. Does not have any effect\r\n# for Java sources.\r\n# The default value is: YES.\r\n\r\nEXTRACT_LOCAL_CLASSES  = YES\r\n\r\n# This flag is only useful for Objective-C code. If set to YES, local methods,\r\n# which are defined in the implementation section but not in the interface are\r\n# included in the documentation. If set to NO, only methods in the interface are\r\n# included.\r\n# The default value is: NO.\r\n\r\nEXTRACT_LOCAL_METHODS  = NO\r\n\r\n# If this flag is set to YES, the members of anonymous namespaces will be\r\n# extracted and appear in the documentation as a namespace called\r\n# 'anonymous_namespace{file}', where file will be replaced with the base name of\r\n# the file that contains the anonymous namespace. By default anonymous namespace\r\n# are hidden.\r\n# The default value is: NO.\r\n\r\nEXTRACT_ANON_NSPACES   = NO\r\n\r\n# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all\r\n# undocumented members inside documented classes or files. If set to NO these\r\n# members will be included in the various overviews, but no documentation\r\n# section is generated. This option has no effect if EXTRACT_ALL is enabled.\r\n# The default value is: NO.\r\n\r\nHIDE_UNDOC_MEMBERS     = YES\r\n\r\n# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all\r\n# undocumented classes that are normally visible in the class hierarchy. If set\r\n# to NO, these classes will be included in the various overviews. This option\r\n# has no effect if EXTRACT_ALL is enabled.\r\n# The default value is: NO.\r\n\r\nHIDE_UNDOC_CLASSES     = YES\r\n\r\n# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend\r\n# (class|struct|union) declarations. If set to NO, these declarations will be\r\n# included in the documentation.\r\n# The default value is: NO.\r\n\r\nHIDE_FRIEND_COMPOUNDS  = NO\r\n\r\n# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any\r\n# documentation blocks found inside the body of a function. If set to NO, these\r\n# blocks will be appended to the function's detailed documentation block.\r\n# The default value is: NO.\r\n\r\nHIDE_IN_BODY_DOCS      = NO\r\n\r\n# The INTERNAL_DOCS tag determines if documentation that is typed after a\r\n# \\internal command is included. If the tag is set to NO then the documentation\r\n# will be excluded. Set it to YES to include the internal documentation.\r\n# The default value is: NO.\r\n\r\nINTERNAL_DOCS          = NO\r\n\r\n# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file\r\n# names in lower-case letters. If set to YES, upper-case letters are also\r\n# allowed. This is useful if you have classes or files whose names only differ\r\n# in case and if your file system supports case sensitive file names. Windows\r\n# and Mac users are advised to set this option to NO.\r\n# The default value is: system dependent.\r\n\r\nCASE_SENSE_NAMES       = NO\r\n\r\n# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with\r\n# their full class and namespace scopes in the documentation. If set to YES, the\r\n# scope will be hidden.\r\n# The default value is: NO.\r\n\r\nHIDE_SCOPE_NAMES       = NO\r\n\r\n# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will\r\n# append additional text to a page's title, such as Class Reference. If set to\r\n# YES the compound reference will be hidden.\r\n# The default value is: NO.\r\n\r\nHIDE_COMPOUND_REFERENCE= NO\r\n\r\n# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of\r\n# the files that are included by a file in the documentation of that file.\r\n# The default value is: YES.\r\n\r\nSHOW_INCLUDE_FILES     = YES\r\n\r\n# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each\r\n# grouped member an include statement to the documentation, telling the reader\r\n# which file to include in order to use the member.\r\n# The default value is: NO.\r\n\r\nSHOW_GROUPED_MEMB_INC  = NO\r\n\r\n# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include\r\n# files with double quotes in the documentation rather than with sharp brackets.\r\n# The default value is: NO.\r\n\r\nFORCE_LOCAL_INCLUDES   = NO\r\n\r\n# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the\r\n# documentation for inline members.\r\n# The default value is: YES.\r\n\r\nINLINE_INFO            = YES\r\n\r\n# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the\r\n# (detailed) documentation of file and class members alphabetically by member\r\n# name. If set to NO, the members will appear in declaration order.\r\n# The default value is: YES.\r\n\r\nSORT_MEMBER_DOCS       = YES\r\n\r\n# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief\r\n# descriptions of file, namespace and class members alphabetically by member\r\n# name. If set to NO, the members will appear in declaration order. Note that\r\n# this will also influence the order of the classes in the class list.\r\n# The default value is: NO.\r\n\r\nSORT_BRIEF_DOCS        = NO\r\n\r\n# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the\r\n# (brief and detailed) documentation of class members so that constructors and\r\n# destructors are listed first. If set to NO the constructors will appear in the\r\n# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.\r\n# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief\r\n# member documentation.\r\n# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting\r\n# detailed member documentation.\r\n# The default value is: NO.\r\n\r\nSORT_MEMBERS_CTORS_1ST = NO\r\n\r\n# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy\r\n# of group names into alphabetical order. If set to NO the group names will\r\n# appear in their defined order.\r\n# The default value is: NO.\r\n\r\nSORT_GROUP_NAMES       = NO\r\n\r\n# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by\r\n# fully-qualified names, including namespaces. If set to NO, the class list will\r\n# be sorted only by class name, not including the namespace part.\r\n# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.\r\n# Note: This option applies only to the class list, not to the alphabetical\r\n# list.\r\n# The default value is: NO.\r\n\r\nSORT_BY_SCOPE_NAME     = NO\r\n\r\n# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper\r\n# type resolution of all parameters of a function it will reject a match between\r\n# the prototype and the implementation of a member function even if there is\r\n# only one candidate or it is obvious which candidate to choose by doing a\r\n# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still\r\n# accept a match between prototype and implementation in such cases.\r\n# The default value is: NO.\r\n\r\nSTRICT_PROTO_MATCHING  = NO\r\n\r\n# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo\r\n# list. This list is created by putting \\todo commands in the documentation.\r\n# The default value is: YES.\r\n\r\nGENERATE_TODOLIST      = NO\r\n\r\n# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test\r\n# list. This list is created by putting \\test commands in the documentation.\r\n# The default value is: YES.\r\n\r\nGENERATE_TESTLIST      = NO\r\n\r\n# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug\r\n# list. This list is created by putting \\bug commands in the documentation.\r\n# The default value is: YES.\r\n\r\nGENERATE_BUGLIST       = NO\r\n\r\n# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)\r\n# the deprecated list. This list is created by putting \\deprecated commands in\r\n# the documentation.\r\n# The default value is: YES.\r\n\r\nGENERATE_DEPRECATEDLIST= YES\r\n\r\n# The ENABLED_SECTIONS tag can be used to enable conditional documentation\r\n# sections, marked by \\if <section_label> ... \\endif and \\cond <section_label>\r\n# ... \\endcond blocks.\r\n\r\nENABLED_SECTIONS       =\r\n\r\n# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the\r\n# initial value of a variable or macro / define can have for it to appear in the\r\n# documentation. If the initializer consists of more lines than specified here\r\n# it will be hidden. Use a value of 0 to hide initializers completely. The\r\n# appearance of the value of individual variables and macros / defines can be\r\n# controlled using \\showinitializer or \\hideinitializer command in the\r\n# documentation regardless of this setting.\r\n# Minimum value: 0, maximum value: 10000, default value: 30.\r\n\r\nMAX_INITIALIZER_LINES  = 30\r\n\r\n# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at\r\n# the bottom of the documentation of classes and structs. If set to YES, the\r\n# list will mention the files that were used to generate the documentation.\r\n# The default value is: YES.\r\n\r\nSHOW_USED_FILES        = YES\r\n\r\n# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This\r\n# will remove the Files entry from the Quick Index and from the Folder Tree View\r\n# (if specified).\r\n# The default value is: YES.\r\n\r\nSHOW_FILES             = YES\r\n\r\n# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces\r\n# page. This will remove the Namespaces entry from the Quick Index and from the\r\n# Folder Tree View (if specified).\r\n# The default value is: YES.\r\n\r\nSHOW_NAMESPACES        = YES\r\n\r\n# The FILE_VERSION_FILTER tag can be used to specify a program or script that\r\n# doxygen should invoke to get the current version for each file (typically from\r\n# the version control system). Doxygen will invoke the program by executing (via\r\n# popen()) the command command input-file, where command is the value of the\r\n# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided\r\n# by doxygen. Whatever the program writes to standard output is used as the file\r\n# version. For an example see the documentation.\r\n\r\nFILE_VERSION_FILTER    =\r\n\r\n# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed\r\n# by doxygen. The layout file controls the global structure of the generated\r\n# output files in an output format independent way. To create the layout file\r\n# that represents doxygen's defaults, run doxygen with the -l option. You can\r\n# optionally specify a file name after the option, if omitted DoxygenLayout.xml\r\n# will be used as the name of the layout file.\r\n#\r\n# Note that if you run doxygen from a directory containing a file called\r\n# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE\r\n# tag is left empty.\r\n\r\nLAYOUT_FILE            =\r\n\r\n# The CITE_BIB_FILES tag can be used to specify one or more bib files containing\r\n# the reference definitions. This must be a list of .bib files. The .bib\r\n# extension is automatically appended if omitted. This requires the bibtex tool\r\n# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.\r\n# For LaTeX the style of the bibliography can be controlled using\r\n# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the\r\n# search path. See also \\cite for info how to create references.\r\n\r\nCITE_BIB_FILES         =\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to warning and progress messages\r\n#---------------------------------------------------------------------------\r\n\r\n# The QUIET tag can be used to turn on/off the messages that are generated to\r\n# standard output by doxygen. If QUIET is set to YES this implies that the\r\n# messages are off.\r\n# The default value is: NO.\r\n\r\nQUIET                  = NO\r\n\r\n# The WARNINGS tag can be used to turn on/off the warning messages that are\r\n# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES\r\n# this implies that the warnings are on.\r\n#\r\n# Tip: Turn warnings on while writing the documentation.\r\n# The default value is: YES.\r\n\r\nWARNINGS               = YES\r\n\r\n# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate\r\n# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag\r\n# will automatically be disabled.\r\n# The default value is: YES.\r\n\r\nWARN_IF_UNDOCUMENTED   = NO\r\n\r\n# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for\r\n# potential errors in the documentation, such as not documenting some parameters\r\n# in a documented function, or documenting parameters that don't exist or using\r\n# markup commands wrongly.\r\n# The default value is: YES.\r\n\r\nWARN_IF_DOC_ERROR      = YES\r\n\r\n# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that\r\n# are documented, but have no documentation for their parameters or return\r\n# value. If set to NO, doxygen will only warn about wrong or incomplete\r\n# parameter documentation, but not about the absence of documentation.\r\n# The default value is: NO.\r\n\r\nWARN_NO_PARAMDOC       = NO\r\n\r\n# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when\r\n# a warning is encountered.\r\n# The default value is: NO.\r\n\r\nWARN_AS_ERROR          = NO\r\n\r\n# The WARN_FORMAT tag determines the format of the warning messages that doxygen\r\n# can produce. The string should contain the $file, $line, and $text tags, which\r\n# will be replaced by the file and line number from which the warning originated\r\n# and the warning text. Optionally the format may contain $version, which will\r\n# be replaced by the version of the file (if it could be obtained via\r\n# FILE_VERSION_FILTER)\r\n# The default value is: $file:$line: $text.\r\n\r\nWARN_FORMAT            = \"$file:$line: $text\"\r\n\r\n# The WARN_LOGFILE tag can be used to specify a file to which warning and error\r\n# messages should be written. If left blank the output is written to standard\r\n# error (stderr).\r\n\r\nWARN_LOGFILE           =\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the input files\r\n#---------------------------------------------------------------------------\r\n\r\n# The INPUT tag is used to specify the files and/or directories that contain\r\n# documented source files. You may enter file names like myfile.cpp or\r\n# directories like /usr/src/myproject. Separate the files or directories with\r\n# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING\r\n# Note: If this tag is empty the current directory is searched.\r\n\r\nINPUT                  = tinyxml2.h \\\r\n                         xmltest.cpp \\\r\n                         readme.md\r\n\r\n# This tag can be used to specify the character encoding of the source files\r\n# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses\r\n# libiconv (or the iconv built into libc) for the transcoding. See the libiconv\r\n# documentation (see: http://www.gnu.org/software/libiconv) for the list of\r\n# possible encodings.\r\n# The default value is: UTF-8.\r\n\r\nINPUT_ENCODING         = UTF-8\r\n\r\n# If the value of the INPUT tag contains directories, you can use the\r\n# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and\r\n# *.h) to filter out the source-files in the directories.\r\n#\r\n# Note that for custom extensions or not directly supported extensions you also\r\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\r\n# read by doxygen.\r\n#\r\n# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,\r\n# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,\r\n# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,\r\n# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,\r\n# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf and *.qsf.\r\n\r\nFILE_PATTERNS          =\r\n\r\n# The RECURSIVE tag can be used to specify whether or not subdirectories should\r\n# be searched for input files as well.\r\n# The default value is: NO.\r\n\r\nRECURSIVE              = NO\r\n\r\n# The EXCLUDE tag can be used to specify files and/or directories that should be\r\n# excluded from the INPUT source files. This way you can easily exclude a\r\n# subdirectory from a directory tree whose root is specified with the INPUT tag.\r\n#\r\n# Note that relative paths are relative to the directory from which doxygen is\r\n# run.\r\n\r\nEXCLUDE                =\r\n\r\n# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or\r\n# directories that are symbolic links (a Unix file system feature) are excluded\r\n# from the input.\r\n# The default value is: NO.\r\n\r\nEXCLUDE_SYMLINKS       = NO\r\n\r\n# If the value of the INPUT tag contains directories, you can use the\r\n# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude\r\n# certain files from those directories.\r\n#\r\n# Note that the wildcards are matched against the file with absolute path, so to\r\n# exclude all test directories for example use the pattern */test/*\r\n\r\nEXCLUDE_PATTERNS       =\r\n\r\n# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names\r\n# (namespaces, classes, functions, etc.) that should be excluded from the\r\n# output. The symbol name can be a fully qualified name, a word, or if the\r\n# wildcard * is used, a substring. Examples: ANamespace, AClass,\r\n# AClass::ANamespace, ANamespace::*Test\r\n#\r\n# Note that the wildcards are matched against the file with absolute path, so to\r\n# exclude all test directories use the pattern */test/*\r\n\r\nEXCLUDE_SYMBOLS        =\r\n\r\n# The EXAMPLE_PATH tag can be used to specify one or more files or directories\r\n# that contain example code fragments that are included (see the \\include\r\n# command).\r\n\r\nEXAMPLE_PATH           = .\r\n\r\n# If the value of the EXAMPLE_PATH tag contains directories, you can use the\r\n# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and\r\n# *.h) to filter out the source-files in the directories. If left blank all\r\n# files are included.\r\n\r\nEXAMPLE_PATTERNS       =\r\n\r\n# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be\r\n# searched for input files to be used with the \\include or \\dontinclude commands\r\n# irrespective of the value of the RECURSIVE tag.\r\n# The default value is: NO.\r\n\r\nEXAMPLE_RECURSIVE      = NO\r\n\r\n# The IMAGE_PATH tag can be used to specify one or more files or directories\r\n# that contain images that are to be included in the documentation (see the\r\n# \\image command).\r\n\r\nIMAGE_PATH             =\r\n\r\n# The INPUT_FILTER tag can be used to specify a program that doxygen should\r\n# invoke to filter for each input file. Doxygen will invoke the filter program\r\n# by executing (via popen()) the command:\r\n#\r\n# <filter> <input-file>\r\n#\r\n# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the\r\n# name of an input file. Doxygen will then use the output that the filter\r\n# program writes to standard output. If FILTER_PATTERNS is specified, this tag\r\n# will be ignored.\r\n#\r\n# Note that the filter must not add or remove lines; it is applied before the\r\n# code is scanned, but not when the output code is generated. If lines are added\r\n# or removed, the anchors will not be placed correctly.\r\n#\r\n# Note that for custom extensions or not directly supported extensions you also\r\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\r\n# properly processed by doxygen.\r\n\r\nINPUT_FILTER           =\r\n\r\n# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern\r\n# basis. Doxygen will compare the file name with each pattern and apply the\r\n# filter if there is a match. The filters are a list of the form: pattern=filter\r\n# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how\r\n# filters are used. If the FILTER_PATTERNS tag is empty or if none of the\r\n# patterns match the file name, INPUT_FILTER is applied.\r\n#\r\n# Note that for custom extensions or not directly supported extensions you also\r\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\r\n# properly processed by doxygen.\r\n\r\nFILTER_PATTERNS        =\r\n\r\n# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using\r\n# INPUT_FILTER) will also be used to filter the input files that are used for\r\n# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).\r\n# The default value is: NO.\r\n\r\nFILTER_SOURCE_FILES    = NO\r\n\r\n# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file\r\n# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and\r\n# it is also possible to disable source filtering for a specific pattern using\r\n# *.ext= (so without naming a filter).\r\n# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.\r\n\r\nFILTER_SOURCE_PATTERNS =\r\n\r\n# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that\r\n# is part of the input, its contents will be placed on the main page\r\n# (index.html). This can be useful if you have a project on for instance GitHub\r\n# and want to reuse the introduction page also for the doxygen output.\r\n\r\nUSE_MDFILE_AS_MAINPAGE = readme.md\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to source browsing\r\n#---------------------------------------------------------------------------\r\n\r\n# If the SOURCE_BROWSER tag is set to YES then a list of source files will be\r\n# generated. Documented entities will be cross-referenced with these sources.\r\n#\r\n# Note: To get rid of all source code in the generated output, make sure that\r\n# also VERBATIM_HEADERS is set to NO.\r\n# The default value is: NO.\r\n\r\nSOURCE_BROWSER         = NO\r\n\r\n# Setting the INLINE_SOURCES tag to YES will include the body of functions,\r\n# classes and enums directly into the documentation.\r\n# The default value is: NO.\r\n\r\nINLINE_SOURCES         = NO\r\n\r\n# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any\r\n# special comment blocks from generated source code fragments. Normal C, C++ and\r\n# Fortran comments will always remain visible.\r\n# The default value is: YES.\r\n\r\nSTRIP_CODE_COMMENTS    = YES\r\n\r\n# If the REFERENCED_BY_RELATION tag is set to YES then for each documented\r\n# function all documented functions referencing it will be listed.\r\n# The default value is: NO.\r\n\r\nREFERENCED_BY_RELATION = NO\r\n\r\n# If the REFERENCES_RELATION tag is set to YES then for each documented function\r\n# all documented entities called/used by that function will be listed.\r\n# The default value is: NO.\r\n\r\nREFERENCES_RELATION    = NO\r\n\r\n# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set\r\n# to YES then the hyperlinks from functions in REFERENCES_RELATION and\r\n# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will\r\n# link to the documentation.\r\n# The default value is: YES.\r\n\r\nREFERENCES_LINK_SOURCE = YES\r\n\r\n# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the\r\n# source code will show a tooltip with additional information such as prototype,\r\n# brief description and links to the definition and documentation. Since this\r\n# will make the HTML file larger and loading of large files a bit slower, you\r\n# can opt to disable this feature.\r\n# The default value is: YES.\r\n# This tag requires that the tag SOURCE_BROWSER is set to YES.\r\n\r\nSOURCE_TOOLTIPS        = YES\r\n\r\n# If the USE_HTAGS tag is set to YES then the references to source code will\r\n# point to the HTML generated by the htags(1) tool instead of doxygen built-in\r\n# source browser. The htags tool is part of GNU's global source tagging system\r\n# (see http://www.gnu.org/software/global/global.html). You will need version\r\n# 4.8.6 or higher.\r\n#\r\n# To use it do the following:\r\n# - Install the latest version of global\r\n# - Enable SOURCE_BROWSER and USE_HTAGS in the config file\r\n# - Make sure the INPUT points to the root of the source tree\r\n# - Run doxygen as normal\r\n#\r\n# Doxygen will invoke htags (and that will in turn invoke gtags), so these\r\n# tools must be available from the command line (i.e. in the search path).\r\n#\r\n# The result: instead of the source browser generated by doxygen, the links to\r\n# source code will now point to the output of htags.\r\n# The default value is: NO.\r\n# This tag requires that the tag SOURCE_BROWSER is set to YES.\r\n\r\nUSE_HTAGS              = NO\r\n\r\n# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a\r\n# verbatim copy of the header file for each class for which an include is\r\n# specified. Set to NO to disable this.\r\n# See also: Section \\class.\r\n# The default value is: YES.\r\n\r\nVERBATIM_HEADERS       = YES\r\n\r\n# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the\r\n# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the\r\n# cost of reduced performance. This can be particularly helpful with template\r\n# rich C++ code for which doxygen's built-in parser lacks the necessary type\r\n# information.\r\n# Note: The availability of this option depends on whether or not doxygen was\r\n# generated with the -Duse-libclang=ON option for CMake.\r\n# The default value is: NO.\r\n\r\nCLANG_ASSISTED_PARSING = NO\r\n\r\n# If clang assisted parsing is enabled you can provide the compiler with command\r\n# line options that you would normally use when invoking the compiler. Note that\r\n# the include paths will already be set by doxygen for the files and directories\r\n# specified with INPUT and INCLUDE_PATH.\r\n# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.\r\n\r\nCLANG_OPTIONS          =\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the alphabetical class index\r\n#---------------------------------------------------------------------------\r\n\r\n# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all\r\n# compounds will be generated. Enable this if the project contains a lot of\r\n# classes, structs, unions or interfaces.\r\n# The default value is: YES.\r\n\r\nALPHABETICAL_INDEX     = YES\r\n\r\n# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in\r\n# which the alphabetical index list will be split.\r\n# Minimum value: 1, maximum value: 20, default value: 5.\r\n# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.\r\n\r\nCOLS_IN_ALPHA_INDEX    = 5\r\n\r\n# In case all classes in a project start with a common prefix, all classes will\r\n# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag\r\n# can be used to specify a prefix (or a list of prefixes) that should be ignored\r\n# while generating the index headers.\r\n# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.\r\n\r\nIGNORE_PREFIX          =\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the HTML output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output\r\n# The default value is: YES.\r\n\r\nGENERATE_HTML          = YES\r\n\r\n# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a\r\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\r\n# it.\r\n# The default directory is: html.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_OUTPUT            = docs\r\n\r\n# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each\r\n# generated HTML page (for example: .htm, .php, .asp).\r\n# The default value is: .html.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_FILE_EXTENSION    = .html\r\n\r\n# The HTML_HEADER tag can be used to specify a user-defined HTML header file for\r\n# each generated HTML page. If the tag is left blank doxygen will generate a\r\n# standard header.\r\n#\r\n# To get valid HTML the header file that includes any scripts and style sheets\r\n# that doxygen needs, which is dependent on the configuration options used (e.g.\r\n# the setting GENERATE_TREEVIEW). It is highly recommended to start with a\r\n# default header using\r\n# doxygen -w html new_header.html new_footer.html new_stylesheet.css\r\n# YourConfigFile\r\n# and then modify the file new_header.html. See also section \"Doxygen usage\"\r\n# for information on how to generate the default header that doxygen normally\r\n# uses.\r\n# Note: The header is subject to change so you typically have to regenerate the\r\n# default header when upgrading to a newer version of doxygen. For a description\r\n# of the possible markers and block names see the documentation.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_HEADER            =\r\n\r\n# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each\r\n# generated HTML page. If the tag is left blank doxygen will generate a standard\r\n# footer. See HTML_HEADER for more information on how to generate a default\r\n# footer and what special commands can be used inside the footer. See also\r\n# section \"Doxygen usage\" for information on how to generate the default footer\r\n# that doxygen normally uses.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_FOOTER            =\r\n\r\n# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style\r\n# sheet that is used by each HTML page. It can be used to fine-tune the look of\r\n# the HTML output. If left blank doxygen will generate a default style sheet.\r\n# See also section \"Doxygen usage\" for information on how to generate the style\r\n# sheet that doxygen normally uses.\r\n# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as\r\n# it is more robust and this tag (HTML_STYLESHEET) will in the future become\r\n# obsolete.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_STYLESHEET        =\r\n\r\n# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined\r\n# cascading style sheets that are included after the standard style sheets\r\n# created by doxygen. Using this option one can overrule certain style aspects.\r\n# This is preferred over using HTML_STYLESHEET since it does not replace the\r\n# standard style sheet and is therefore more robust against future updates.\r\n# Doxygen will copy the style sheet files to the output directory.\r\n# Note: The order of the extra style sheet files is of importance (e.g. the last\r\n# style sheet in the list overrules the setting of the previous ones in the\r\n# list). For an example see the documentation.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_EXTRA_STYLESHEET  =\r\n\r\n# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or\r\n# other source files which should be copied to the HTML output directory. Note\r\n# that these files will be copied to the base HTML output directory. Use the\r\n# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these\r\n# files. In the HTML_STYLESHEET file, use the file name only. Also note that the\r\n# files will be copied as-is; there are no commands or markers available.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_EXTRA_FILES       =\r\n\r\n# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen\r\n# will adjust the colors in the style sheet and background images according to\r\n# this color. Hue is specified as an angle on a colorwheel, see\r\n# http://en.wikipedia.org/wiki/Hue for more information. For instance the value\r\n# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300\r\n# purple, and 360 is red again.\r\n# Minimum value: 0, maximum value: 359, default value: 220.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_COLORSTYLE_HUE    = 220\r\n\r\n# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors\r\n# in the HTML output. For a value of 0 the output will use grayscales only. A\r\n# value of 255 will produce the most vivid colors.\r\n# Minimum value: 0, maximum value: 255, default value: 100.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_COLORSTYLE_SAT    = 100\r\n\r\n# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the\r\n# luminance component of the colors in the HTML output. Values below 100\r\n# gradually make the output lighter, whereas values above 100 make the output\r\n# darker. The value divided by 100 is the actual gamma applied, so 80 represents\r\n# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not\r\n# change the gamma.\r\n# Minimum value: 40, maximum value: 240, default value: 80.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_COLORSTYLE_GAMMA  = 80\r\n\r\n# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML\r\n# page will contain the date and time when the page was generated. Setting this\r\n# to YES can help to show when doxygen was last run and thus if the\r\n# documentation is up to date.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_TIMESTAMP         = YES\r\n\r\n# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML\r\n# documentation will contain sections that can be hidden and shown after the\r\n# page has loaded.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_DYNAMIC_SECTIONS  = NO\r\n\r\n# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries\r\n# shown in the various tree structured indices initially; the user can expand\r\n# and collapse entries dynamically later on. Doxygen will expand the tree to\r\n# such a level that at most the specified number of entries are visible (unless\r\n# a fully collapsed tree already exceeds this amount). So setting the number of\r\n# entries 1 will produce a full collapsed tree by default. 0 is a special value\r\n# representing an infinite number of entries and will result in a full expanded\r\n# tree by default.\r\n# Minimum value: 0, maximum value: 9999, default value: 100.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nHTML_INDEX_NUM_ENTRIES = 100\r\n\r\n# If the GENERATE_DOCSET tag is set to YES, additional index files will be\r\n# generated that can be used as input for Apple's Xcode 3 integrated development\r\n# environment (see: http://developer.apple.com/tools/xcode/), introduced with\r\n# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a\r\n# Makefile in the HTML output directory. Running make will produce the docset in\r\n# that directory and running make install will install the docset in\r\n# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at\r\n# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html\r\n# for more information.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nGENERATE_DOCSET        = NO\r\n\r\n# This tag determines the name of the docset feed. A documentation feed provides\r\n# an umbrella under which multiple documentation sets from a single provider\r\n# (such as a company or product suite) can be grouped.\r\n# The default value is: Doxygen generated docs.\r\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\r\n\r\nDOCSET_FEEDNAME        = \"Doxygen generated docs\"\r\n\r\n# This tag specifies a string that should uniquely identify the documentation\r\n# set bundle. This should be a reverse domain-name style string, e.g.\r\n# com.mycompany.MyDocSet. Doxygen will append .docset to the name.\r\n# The default value is: org.doxygen.Project.\r\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\r\n\r\nDOCSET_BUNDLE_ID       = org.doxygen.Project\r\n\r\n# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify\r\n# the documentation publisher. This should be a reverse domain-name style\r\n# string, e.g. com.mycompany.MyDocSet.documentation.\r\n# The default value is: org.doxygen.Publisher.\r\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\r\n\r\nDOCSET_PUBLISHER_ID    = org.doxygen.Publisher\r\n\r\n# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.\r\n# The default value is: Publisher.\r\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\r\n\r\nDOCSET_PUBLISHER_NAME  = Publisher\r\n\r\n# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three\r\n# additional HTML index files: index.hhp, index.hhc, and index.hhk. The\r\n# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop\r\n# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on\r\n# Windows.\r\n#\r\n# The HTML Help Workshop contains a compiler that can convert all HTML output\r\n# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML\r\n# files are now used as the Windows 98 help format, and will replace the old\r\n# Windows help format (.hlp) on all Windows platforms in the future. Compressed\r\n# HTML files also contain an index, a table of contents, and you can search for\r\n# words in the documentation. The HTML workshop also contains a viewer for\r\n# compressed HTML files.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nGENERATE_HTMLHELP      = NO\r\n\r\n# The CHM_FILE tag can be used to specify the file name of the resulting .chm\r\n# file. You can add a path in front of the file if the result should not be\r\n# written to the html output directory.\r\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\r\n\r\nCHM_FILE               =\r\n\r\n# The HHC_LOCATION tag can be used to specify the location (absolute path\r\n# including file name) of the HTML help compiler (hhc.exe). If non-empty,\r\n# doxygen will try to run the HTML help compiler on the generated index.hhp.\r\n# The file has to be specified with full path.\r\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\r\n\r\nHHC_LOCATION           =\r\n\r\n# The GENERATE_CHI flag controls if a separate .chi index file is generated\r\n# (YES) or that it should be included in the master .chm file (NO).\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\r\n\r\nGENERATE_CHI           = NO\r\n\r\n# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)\r\n# and project file content.\r\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\r\n\r\nCHM_INDEX_ENCODING     =\r\n\r\n# The BINARY_TOC flag controls whether a binary table of contents is generated\r\n# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it\r\n# enables the Previous and Next buttons.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\r\n\r\nBINARY_TOC             = NO\r\n\r\n# The TOC_EXPAND flag can be set to YES to add extra items for group members to\r\n# the table of contents of the HTML help documentation and to the tree view.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\r\n\r\nTOC_EXPAND             = YES\r\n\r\n# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and\r\n# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that\r\n# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help\r\n# (.qch) of the generated HTML documentation.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nGENERATE_QHP           = NO\r\n\r\n# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify\r\n# the file name of the resulting .qch file. The path specified is relative to\r\n# the HTML output folder.\r\n# This tag requires that the tag GENERATE_QHP is set to YES.\r\n\r\nQCH_FILE               =\r\n\r\n# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help\r\n# Project output. For more information please see Qt Help Project / Namespace\r\n# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).\r\n# The default value is: org.doxygen.Project.\r\n# This tag requires that the tag GENERATE_QHP is set to YES.\r\n\r\nQHP_NAMESPACE          = org.doxygen.Project\r\n\r\n# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt\r\n# Help Project output. For more information please see Qt Help Project / Virtual\r\n# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-\r\n# folders).\r\n# The default value is: doc.\r\n# This tag requires that the tag GENERATE_QHP is set to YES.\r\n\r\nQHP_VIRTUAL_FOLDER     = doc\r\n\r\n# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom\r\n# filter to add. For more information please see Qt Help Project / Custom\r\n# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-\r\n# filters).\r\n# This tag requires that the tag GENERATE_QHP is set to YES.\r\n\r\nQHP_CUST_FILTER_NAME   =\r\n\r\n# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the\r\n# custom filter to add. For more information please see Qt Help Project / Custom\r\n# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-\r\n# filters).\r\n# This tag requires that the tag GENERATE_QHP is set to YES.\r\n\r\nQHP_CUST_FILTER_ATTRS  =\r\n\r\n# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this\r\n# project's filter section matches. Qt Help Project / Filter Attributes (see:\r\n# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).\r\n# This tag requires that the tag GENERATE_QHP is set to YES.\r\n\r\nQHP_SECT_FILTER_ATTRS  =\r\n\r\n# The QHG_LOCATION tag can be used to specify the location of Qt's\r\n# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the\r\n# generated .qhp file.\r\n# This tag requires that the tag GENERATE_QHP is set to YES.\r\n\r\nQHG_LOCATION           =\r\n\r\n# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be\r\n# generated, together with the HTML files, they form an Eclipse help plugin. To\r\n# install this plugin and make it available under the help contents menu in\r\n# Eclipse, the contents of the directory containing the HTML and XML files needs\r\n# to be copied into the plugins directory of eclipse. The name of the directory\r\n# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.\r\n# After copying Eclipse needs to be restarted before the help appears.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nGENERATE_ECLIPSEHELP   = NO\r\n\r\n# A unique identifier for the Eclipse help plugin. When installing the plugin\r\n# the directory name containing the HTML and XML files should also have this\r\n# name. Each documentation set should have its own identifier.\r\n# The default value is: org.doxygen.Project.\r\n# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.\r\n\r\nECLIPSE_DOC_ID         = org.doxygen.Project\r\n\r\n# If you want full control over the layout of the generated HTML pages it might\r\n# be necessary to disable the index and replace it with your own. The\r\n# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top\r\n# of each HTML page. A value of NO enables the index and the value YES disables\r\n# it. Since the tabs in the index contain the same information as the navigation\r\n# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nDISABLE_INDEX          = NO\r\n\r\n# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index\r\n# structure should be generated to display hierarchical information. If the tag\r\n# value is set to YES, a side panel will be generated containing a tree-like\r\n# index structure (just like the one that is generated for HTML Help). For this\r\n# to work a browser that supports JavaScript, DHTML, CSS and frames is required\r\n# (i.e. any modern browser). Windows users are probably better off using the\r\n# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can\r\n# further fine-tune the look of the index. As an example, the default style\r\n# sheet generated by doxygen has an example that shows how to put an image at\r\n# the root of the tree instead of the PROJECT_NAME. Since the tree basically has\r\n# the same information as the tab index, you could consider setting\r\n# DISABLE_INDEX to YES when enabling this option.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nGENERATE_TREEVIEW      = NO\r\n\r\n# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that\r\n# doxygen will group on one line in the generated HTML documentation.\r\n#\r\n# Note that a value of 0 will completely suppress the enum values from appearing\r\n# in the overview section.\r\n# Minimum value: 0, maximum value: 20, default value: 4.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nENUM_VALUES_PER_LINE   = 4\r\n\r\n# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used\r\n# to set the initial width (in pixels) of the frame in which the tree is shown.\r\n# Minimum value: 0, maximum value: 1500, default value: 250.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nTREEVIEW_WIDTH         = 250\r\n\r\n# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to\r\n# external symbols imported via tag files in a separate window.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nEXT_LINKS_IN_WINDOW    = NO\r\n\r\n# Use this tag to change the font size of LaTeX formulas included as images in\r\n# the HTML documentation. When you change the font size after a successful\r\n# doxygen run you need to manually remove any form_*.png images from the HTML\r\n# output directory to force them to be regenerated.\r\n# Minimum value: 8, maximum value: 50, default value: 10.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nFORMULA_FONTSIZE       = 10\r\n\r\n# Use the FORMULA_TRANPARENT tag to determine whether or not the images\r\n# generated for formulas are transparent PNGs. Transparent PNGs are not\r\n# supported properly for IE 6.0, but are supported on all modern browsers.\r\n#\r\n# Note that when changing this option you need to delete any form_*.png files in\r\n# the HTML output directory before the changes have effect.\r\n# The default value is: YES.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nFORMULA_TRANSPARENT    = YES\r\n\r\n# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see\r\n# http://www.mathjax.org) which uses client side Javascript for the rendering\r\n# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX\r\n# installed or if you want to formulas look prettier in the HTML output. When\r\n# enabled you may also need to install MathJax separately and configure the path\r\n# to it using the MATHJAX_RELPATH option.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nUSE_MATHJAX            = NO\r\n\r\n# When MathJax is enabled you can set the default output format to be used for\r\n# the MathJax output. See the MathJax site (see:\r\n# http://docs.mathjax.org/en/latest/output.html) for more details.\r\n# Possible values are: HTML-CSS (which is slower, but has the best\r\n# compatibility), NativeMML (i.e. MathML) and SVG.\r\n# The default value is: HTML-CSS.\r\n# This tag requires that the tag USE_MATHJAX is set to YES.\r\n\r\nMATHJAX_FORMAT         = HTML-CSS\r\n\r\n# When MathJax is enabled you need to specify the location relative to the HTML\r\n# output directory using the MATHJAX_RELPATH option. The destination directory\r\n# should contain the MathJax.js script. For instance, if the mathjax directory\r\n# is located at the same level as the HTML output directory, then\r\n# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax\r\n# Content Delivery Network so you can quickly see the result without installing\r\n# MathJax. However, it is strongly recommended to install a local copy of\r\n# MathJax from http://www.mathjax.org before deployment.\r\n# The default value is: http://cdn.mathjax.org/mathjax/latest.\r\n# This tag requires that the tag USE_MATHJAX is set to YES.\r\n\r\nMATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest\r\n\r\n# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax\r\n# extension names that should be enabled during MathJax rendering. For example\r\n# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols\r\n# This tag requires that the tag USE_MATHJAX is set to YES.\r\n\r\nMATHJAX_EXTENSIONS     =\r\n\r\n# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces\r\n# of code that will be used on startup of the MathJax code. See the MathJax site\r\n# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an\r\n# example see the documentation.\r\n# This tag requires that the tag USE_MATHJAX is set to YES.\r\n\r\nMATHJAX_CODEFILE       =\r\n\r\n# When the SEARCHENGINE tag is enabled doxygen will generate a search box for\r\n# the HTML output. The underlying search engine uses javascript and DHTML and\r\n# should work on any modern browser. Note that when using HTML help\r\n# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)\r\n# there is already a search function so this one should typically be disabled.\r\n# For large projects the javascript based search engine can be slow, then\r\n# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to\r\n# search using the keyboard; to jump to the search box use <access key> + S\r\n# (what the <access key> is depends on the OS and browser, but it is typically\r\n# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down\r\n# key> to jump into the search results window, the results can be navigated\r\n# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel\r\n# the search. The filter options can be selected when the cursor is inside the\r\n# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>\r\n# to select a filter and <Enter> or <escape> to activate or cancel the filter\r\n# option.\r\n# The default value is: YES.\r\n# This tag requires that the tag GENERATE_HTML is set to YES.\r\n\r\nSEARCHENGINE           = YES\r\n\r\n# When the SERVER_BASED_SEARCH tag is enabled the search engine will be\r\n# implemented using a web server instead of a web client using Javascript. There\r\n# are two flavors of web server based searching depending on the EXTERNAL_SEARCH\r\n# setting. When disabled, doxygen will generate a PHP script for searching and\r\n# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing\r\n# and searching needs to be provided by external tools. See the section\r\n# \"External Indexing and Searching\" for details.\r\n# The default value is: NO.\r\n# This tag requires that the tag SEARCHENGINE is set to YES.\r\n\r\nSERVER_BASED_SEARCH    = NO\r\n\r\n# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP\r\n# script for searching. Instead the search results are written to an XML file\r\n# which needs to be processed by an external indexer. Doxygen will invoke an\r\n# external search engine pointed to by the SEARCHENGINE_URL option to obtain the\r\n# search results.\r\n#\r\n# Doxygen ships with an example indexer (doxyindexer) and search engine\r\n# (doxysearch.cgi) which are based on the open source search engine library\r\n# Xapian (see: http://xapian.org/).\r\n#\r\n# See the section \"External Indexing and Searching\" for details.\r\n# The default value is: NO.\r\n# This tag requires that the tag SEARCHENGINE is set to YES.\r\n\r\nEXTERNAL_SEARCH        = NO\r\n\r\n# The SEARCHENGINE_URL should point to a search engine hosted by a web server\r\n# which will return the search results when EXTERNAL_SEARCH is enabled.\r\n#\r\n# Doxygen ships with an example indexer (doxyindexer) and search engine\r\n# (doxysearch.cgi) which are based on the open source search engine library\r\n# Xapian (see: http://xapian.org/). See the section \"External Indexing and\r\n# Searching\" for details.\r\n# This tag requires that the tag SEARCHENGINE is set to YES.\r\n\r\nSEARCHENGINE_URL       =\r\n\r\n# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed\r\n# search data is written to a file for indexing by an external tool. With the\r\n# SEARCHDATA_FILE tag the name of this file can be specified.\r\n# The default file is: searchdata.xml.\r\n# This tag requires that the tag SEARCHENGINE is set to YES.\r\n\r\nSEARCHDATA_FILE        = searchdata.xml\r\n\r\n# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the\r\n# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is\r\n# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple\r\n# projects and redirect the results back to the right project.\r\n# This tag requires that the tag SEARCHENGINE is set to YES.\r\n\r\nEXTERNAL_SEARCH_ID     =\r\n\r\n# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen\r\n# projects other than the one defined by this configuration file, but that are\r\n# all added to the same external search index. Each project needs to have a\r\n# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of\r\n# to a relative location where the documentation can be found. The format is:\r\n# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...\r\n# This tag requires that the tag SEARCHENGINE is set to YES.\r\n\r\nEXTRA_SEARCH_MAPPINGS  =\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the LaTeX output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.\r\n# The default value is: YES.\r\n\r\nGENERATE_LATEX         = NO\r\n\r\n# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a\r\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\r\n# it.\r\n# The default directory is: latex.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_OUTPUT           = latex\r\n\r\n# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be\r\n# invoked.\r\n#\r\n# Note that when enabling USE_PDFLATEX this option is only used for generating\r\n# bitmaps for formulas in the HTML output, but not in the Makefile that is\r\n# written to the output directory.\r\n# The default file is: latex.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_CMD_NAME         = latex\r\n\r\n# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate\r\n# index for LaTeX.\r\n# The default file is: makeindex.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nMAKEINDEX_CMD_NAME     = makeindex\r\n\r\n# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX\r\n# documents. This may be useful for small projects and may help to save some\r\n# trees in general.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nCOMPACT_LATEX          = NO\r\n\r\n# The PAPER_TYPE tag can be used to set the paper type that is used by the\r\n# printer.\r\n# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x\r\n# 14 inches) and executive (7.25 x 10.5 inches).\r\n# The default value is: a4.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nPAPER_TYPE             = a4\r\n\r\n# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names\r\n# that should be included in the LaTeX output. The package can be specified just\r\n# by its name or with the correct syntax as to be used with the LaTeX\r\n# \\usepackage command. To get the times font for instance you can specify :\r\n# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}\r\n# To use the option intlimits with the amsmath package you can specify:\r\n# EXTRA_PACKAGES=[intlimits]{amsmath}\r\n# If left blank no extra packages will be included.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nEXTRA_PACKAGES         =\r\n\r\n# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the\r\n# generated LaTeX document. The header should contain everything until the first\r\n# chapter. If it is left blank doxygen will generate a standard header. See\r\n# section \"Doxygen usage\" for information on how to let doxygen write the\r\n# default header to a separate file.\r\n#\r\n# Note: Only use a user-defined header if you know what you are doing! The\r\n# following commands have a special meaning inside the header: $title,\r\n# $datetime, $date, $doxygenversion, $projectname, $projectnumber,\r\n# $projectbrief, $projectlogo. Doxygen will replace $title with the empty\r\n# string, for the replacement values of the other commands the user is referred\r\n# to HTML_HEADER.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_HEADER           =\r\n\r\n# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the\r\n# generated LaTeX document. The footer should contain everything after the last\r\n# chapter. If it is left blank doxygen will generate a standard footer. See\r\n# LATEX_HEADER for more information on how to generate a default footer and what\r\n# special commands can be used inside the footer.\r\n#\r\n# Note: Only use a user-defined footer if you know what you are doing!\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_FOOTER           =\r\n\r\n# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined\r\n# LaTeX style sheets that are included after the standard style sheets created\r\n# by doxygen. Using this option one can overrule certain style aspects. Doxygen\r\n# will copy the style sheet files to the output directory.\r\n# Note: The order of the extra style sheet files is of importance (e.g. the last\r\n# style sheet in the list overrules the setting of the previous ones in the\r\n# list).\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_EXTRA_STYLESHEET =\r\n\r\n# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or\r\n# other source files which should be copied to the LATEX_OUTPUT output\r\n# directory. Note that the files will be copied as-is; there are no commands or\r\n# markers available.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_EXTRA_FILES      =\r\n\r\n# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is\r\n# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will\r\n# contain links (just like the HTML output) instead of page references. This\r\n# makes the output suitable for online browsing using a PDF viewer.\r\n# The default value is: YES.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nPDF_HYPERLINKS         = YES\r\n\r\n# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate\r\n# the PDF file directly from the LaTeX files. Set this option to YES, to get a\r\n# higher quality PDF documentation.\r\n# The default value is: YES.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nUSE_PDFLATEX           = YES\r\n\r\n# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode\r\n# command to the generated LaTeX files. This will instruct LaTeX to keep running\r\n# if errors occur, instead of asking the user for help. This option is also used\r\n# when generating formulas in HTML.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_BATCHMODE        = NO\r\n\r\n# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the\r\n# index chapters (such as File Index, Compound Index, etc.) in the output.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_HIDE_INDICES     = NO\r\n\r\n# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source\r\n# code with syntax highlighting in the LaTeX output.\r\n#\r\n# Note that which sources are shown also depends on other settings such as\r\n# SOURCE_BROWSER.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_SOURCE_CODE      = NO\r\n\r\n# The LATEX_BIB_STYLE tag can be used to specify the style to use for the\r\n# bibliography, e.g. plainnat, or ieeetr. See\r\n# http://en.wikipedia.org/wiki/BibTeX and \\cite for more info.\r\n# The default value is: plain.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_BIB_STYLE        = plain\r\n\r\n# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated\r\n# page will contain the date and time when the page was generated. Setting this\r\n# to NO can help when comparing the output of multiple runs.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_LATEX is set to YES.\r\n\r\nLATEX_TIMESTAMP        = NO\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the RTF output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The\r\n# RTF output is optimized for Word 97 and may not look too pretty with other RTF\r\n# readers/editors.\r\n# The default value is: NO.\r\n\r\nGENERATE_RTF           = NO\r\n\r\n# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a\r\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\r\n# it.\r\n# The default directory is: rtf.\r\n# This tag requires that the tag GENERATE_RTF is set to YES.\r\n\r\nRTF_OUTPUT             = rtf\r\n\r\n# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF\r\n# documents. This may be useful for small projects and may help to save some\r\n# trees in general.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_RTF is set to YES.\r\n\r\nCOMPACT_RTF            = NO\r\n\r\n# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will\r\n# contain hyperlink fields. The RTF file will contain links (just like the HTML\r\n# output) instead of page references. This makes the output suitable for online\r\n# browsing using Word or some other Word compatible readers that support those\r\n# fields.\r\n#\r\n# Note: WordPad (write) and others do not support links.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_RTF is set to YES.\r\n\r\nRTF_HYPERLINKS         = NO\r\n\r\n# Load stylesheet definitions from file. Syntax is similar to doxygen's config\r\n# file, i.e. a series of assignments. You only have to provide replacements,\r\n# missing definitions are set to their default value.\r\n#\r\n# See also section \"Doxygen usage\" for information on how to generate the\r\n# default style sheet that doxygen normally uses.\r\n# This tag requires that the tag GENERATE_RTF is set to YES.\r\n\r\nRTF_STYLESHEET_FILE    =\r\n\r\n# Set optional variables used in the generation of an RTF document. Syntax is\r\n# similar to doxygen's config file. A template extensions file can be generated\r\n# using doxygen -e rtf extensionFile.\r\n# This tag requires that the tag GENERATE_RTF is set to YES.\r\n\r\nRTF_EXTENSIONS_FILE    =\r\n\r\n# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code\r\n# with syntax highlighting in the RTF output.\r\n#\r\n# Note that which sources are shown also depends on other settings such as\r\n# SOURCE_BROWSER.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_RTF is set to YES.\r\n\r\nRTF_SOURCE_CODE        = NO\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the man page output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for\r\n# classes and files.\r\n# The default value is: NO.\r\n\r\nGENERATE_MAN           = NO\r\n\r\n# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a\r\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\r\n# it. A directory man3 will be created inside the directory specified by\r\n# MAN_OUTPUT.\r\n# The default directory is: man.\r\n# This tag requires that the tag GENERATE_MAN is set to YES.\r\n\r\nMAN_OUTPUT             = man\r\n\r\n# The MAN_EXTENSION tag determines the extension that is added to the generated\r\n# man pages. In case the manual section does not start with a number, the number\r\n# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is\r\n# optional.\r\n# The default value is: .3.\r\n# This tag requires that the tag GENERATE_MAN is set to YES.\r\n\r\nMAN_EXTENSION          = .3\r\n\r\n# The MAN_SUBDIR tag determines the name of the directory created within\r\n# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by\r\n# MAN_EXTENSION with the initial . removed.\r\n# This tag requires that the tag GENERATE_MAN is set to YES.\r\n\r\nMAN_SUBDIR             =\r\n\r\n# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it\r\n# will generate one additional man file for each entity documented in the real\r\n# man page(s). These additional files only source the real man page, but without\r\n# them the man command would be unable to find the correct page.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_MAN is set to YES.\r\n\r\nMAN_LINKS              = NO\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the XML output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that\r\n# captures the structure of the code including all documentation.\r\n# The default value is: NO.\r\n\r\nGENERATE_XML           = NO\r\n\r\n# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a\r\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\r\n# it.\r\n# The default directory is: xml.\r\n# This tag requires that the tag GENERATE_XML is set to YES.\r\n\r\nXML_OUTPUT             = xml\r\n\r\n# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program\r\n# listings (including syntax highlighting and cross-referencing information) to\r\n# the XML output. Note that enabling this will significantly increase the size\r\n# of the XML output.\r\n# The default value is: YES.\r\n# This tag requires that the tag GENERATE_XML is set to YES.\r\n\r\nXML_PROGRAMLISTING     = YES\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the DOCBOOK output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files\r\n# that can be used to generate PDF.\r\n# The default value is: NO.\r\n\r\nGENERATE_DOCBOOK       = NO\r\n\r\n# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.\r\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in\r\n# front of it.\r\n# The default directory is: docbook.\r\n# This tag requires that the tag GENERATE_DOCBOOK is set to YES.\r\n\r\nDOCBOOK_OUTPUT         = docbook\r\n\r\n# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the\r\n# program listings (including syntax highlighting and cross-referencing\r\n# information) to the DOCBOOK output. Note that enabling this will significantly\r\n# increase the size of the DOCBOOK output.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_DOCBOOK is set to YES.\r\n\r\nDOCBOOK_PROGRAMLISTING = NO\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options for the AutoGen Definitions output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an\r\n# AutoGen Definitions (see http://autogen.sf.net) file that captures the\r\n# structure of the code including all documentation. Note that this feature is\r\n# still experimental and incomplete at the moment.\r\n# The default value is: NO.\r\n\r\nGENERATE_AUTOGEN_DEF   = NO\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the Perl module output\r\n#---------------------------------------------------------------------------\r\n\r\n# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module\r\n# file that captures the structure of the code including all documentation.\r\n#\r\n# Note that this feature is still experimental and incomplete at the moment.\r\n# The default value is: NO.\r\n\r\nGENERATE_PERLMOD       = NO\r\n\r\n# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary\r\n# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI\r\n# output from the Perl module output.\r\n# The default value is: NO.\r\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\r\n\r\nPERLMOD_LATEX          = NO\r\n\r\n# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely\r\n# formatted so it can be parsed by a human reader. This is useful if you want to\r\n# understand what is going on. On the other hand, if this tag is set to NO, the\r\n# size of the Perl module output will be much smaller and Perl will parse it\r\n# just the same.\r\n# The default value is: YES.\r\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\r\n\r\nPERLMOD_PRETTY         = YES\r\n\r\n# The names of the make variables in the generated doxyrules.make file are\r\n# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful\r\n# so different doxyrules.make files included by the same Makefile don't\r\n# overwrite each other's variables.\r\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\r\n\r\nPERLMOD_MAKEVAR_PREFIX =\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the preprocessor\r\n#---------------------------------------------------------------------------\r\n\r\n# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all\r\n# C-preprocessor directives found in the sources and include files.\r\n# The default value is: YES.\r\n\r\nENABLE_PREPROCESSING   = YES\r\n\r\n# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names\r\n# in the source code. If set to NO, only conditional compilation will be\r\n# performed. Macro expansion can be done in a controlled way by setting\r\n# EXPAND_ONLY_PREDEF to YES.\r\n# The default value is: NO.\r\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\r\n\r\nMACRO_EXPANSION        = NO\r\n\r\n# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then\r\n# the macro expansion is limited to the macros specified with the PREDEFINED and\r\n# EXPAND_AS_DEFINED tags.\r\n# The default value is: NO.\r\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\r\n\r\nEXPAND_ONLY_PREDEF     = NO\r\n\r\n# If the SEARCH_INCLUDES tag is set to YES, the include files in the\r\n# INCLUDE_PATH will be searched if a #include is found.\r\n# The default value is: YES.\r\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\r\n\r\nSEARCH_INCLUDES        = YES\r\n\r\n# The INCLUDE_PATH tag can be used to specify one or more directories that\r\n# contain include files that are not input files but should be processed by the\r\n# preprocessor.\r\n# This tag requires that the tag SEARCH_INCLUDES is set to YES.\r\n\r\nINCLUDE_PATH           =\r\n\r\n# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard\r\n# patterns (like *.h and *.hpp) to filter out the header-files in the\r\n# directories. If left blank, the patterns specified with FILE_PATTERNS will be\r\n# used.\r\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\r\n\r\nINCLUDE_FILE_PATTERNS  =\r\n\r\n# The PREDEFINED tag can be used to specify one or more macro names that are\r\n# defined before the preprocessor is started (similar to the -D option of e.g.\r\n# gcc). The argument of the tag is a list of macros of the form: name or\r\n# name=definition (no spaces). If the definition and the \"=\" are omitted, \"=1\"\r\n# is assumed. To prevent a macro definition from being undefined via #undef or\r\n# recursively expanded use the := operator instead of the = operator.\r\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\r\n\r\nPREDEFINED             =\r\n\r\n# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this\r\n# tag can be used to specify a list of macro names that should be expanded. The\r\n# macro definition that is found in the sources will be used. Use the PREDEFINED\r\n# tag if you want to use a different macro definition that overrules the\r\n# definition found in the source code.\r\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\r\n\r\nEXPAND_AS_DEFINED      =\r\n\r\n# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will\r\n# remove all references to function-like macros that are alone on a line, have\r\n# an all uppercase name, and do not end with a semicolon. Such function macros\r\n# are typically used for boiler-plate code, and will confuse the parser if not\r\n# removed.\r\n# The default value is: YES.\r\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\r\n\r\nSKIP_FUNCTION_MACROS   = YES\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to external references\r\n#---------------------------------------------------------------------------\r\n\r\n# The TAGFILES tag can be used to specify one or more tag files. For each tag\r\n# file the location of the external documentation should be added. The format of\r\n# a tag file without this location is as follows:\r\n# TAGFILES = file1 file2 ...\r\n# Adding location for the tag files is done as follows:\r\n# TAGFILES = file1=loc1 \"file2 = loc2\" ...\r\n# where loc1 and loc2 can be relative or absolute paths or URLs. See the\r\n# section \"Linking to external documentation\" for more information about the use\r\n# of tag files.\r\n# Note: Each tag file must have a unique name (where the name does NOT include\r\n# the path). If a tag file is not located in the directory in which doxygen is\r\n# run, you must also specify the path to the tagfile here.\r\n\r\nTAGFILES               =\r\n\r\n# When a file name is specified after GENERATE_TAGFILE, doxygen will create a\r\n# tag file that is based on the input files it reads. See section \"Linking to\r\n# external documentation\" for more information about the usage of tag files.\r\n\r\nGENERATE_TAGFILE       =\r\n\r\n# If the ALLEXTERNALS tag is set to YES, all external class will be listed in\r\n# the class index. If set to NO, only the inherited external classes will be\r\n# listed.\r\n# The default value is: NO.\r\n\r\nALLEXTERNALS           = NO\r\n\r\n# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed\r\n# in the modules index. If set to NO, only the current project's groups will be\r\n# listed.\r\n# The default value is: YES.\r\n\r\nEXTERNAL_GROUPS        = YES\r\n\r\n# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in\r\n# the related pages index. If set to NO, only the current project's pages will\r\n# be listed.\r\n# The default value is: YES.\r\n\r\nEXTERNAL_PAGES         = YES\r\n\r\n# The PERL_PATH should be the absolute path and name of the perl script\r\n# interpreter (i.e. the result of 'which perl').\r\n# The default file (with absolute path) is: /usr/bin/perl.\r\n\r\nPERL_PATH              = /usr/bin/perl\r\n\r\n#---------------------------------------------------------------------------\r\n# Configuration options related to the dot tool\r\n#---------------------------------------------------------------------------\r\n\r\n# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram\r\n# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to\r\n# NO turns the diagrams off. Note that this option also works with HAVE_DOT\r\n# disabled, but it is recommended to install and use dot, since it yields more\r\n# powerful graphs.\r\n# The default value is: YES.\r\n\r\nCLASS_DIAGRAMS         = YES\r\n\r\n# You can define message sequence charts within doxygen comments using the \\msc\r\n# command. Doxygen will then run the mscgen tool (see:\r\n# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the\r\n# documentation. The MSCGEN_PATH tag allows you to specify the directory where\r\n# the mscgen tool resides. If left empty the tool is assumed to be found in the\r\n# default search path.\r\n\r\nMSCGEN_PATH            =\r\n\r\n# You can include diagrams made with dia in doxygen documentation. Doxygen will\r\n# then run dia to produce the diagram and insert it in the documentation. The\r\n# DIA_PATH tag allows you to specify the directory where the dia binary resides.\r\n# If left empty dia is assumed to be found in the default search path.\r\n\r\nDIA_PATH               =\r\n\r\n# If set to YES the inheritance and collaboration graphs will hide inheritance\r\n# and usage relations if the target is undocumented or is not a class.\r\n# The default value is: YES.\r\n\r\nHIDE_UNDOC_RELATIONS   = YES\r\n\r\n# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is\r\n# available from the path. This tool is part of Graphviz (see:\r\n# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent\r\n# Bell Labs. The other options in this section have no effect if this option is\r\n# set to NO\r\n# The default value is: NO.\r\n\r\nHAVE_DOT               = NO\r\n\r\n# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed\r\n# to run in parallel. When set to 0 doxygen will base this on the number of\r\n# processors available in the system. You can set it explicitly to a value\r\n# larger than 0 to get control over the balance between CPU load and processing\r\n# speed.\r\n# Minimum value: 0, maximum value: 32, default value: 0.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_NUM_THREADS        = 0\r\n\r\n# When you want a differently looking font in the dot files that doxygen\r\n# generates you can specify the font name using DOT_FONTNAME. You need to make\r\n# sure dot is able to find the font, which can be done by putting it in a\r\n# standard location or by setting the DOTFONTPATH environment variable or by\r\n# setting DOT_FONTPATH to the directory containing the font.\r\n# The default value is: Helvetica.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_FONTNAME           = Helvetica\r\n\r\n# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of\r\n# dot graphs.\r\n# Minimum value: 4, maximum value: 24, default value: 10.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_FONTSIZE           = 10\r\n\r\n# By default doxygen will tell dot to use the default font as specified with\r\n# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set\r\n# the path where dot can find it using this tag.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_FONTPATH           =\r\n\r\n# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for\r\n# each documented class showing the direct and indirect inheritance relations.\r\n# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nCLASS_GRAPH            = YES\r\n\r\n# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a\r\n# graph for each documented class showing the direct and indirect implementation\r\n# dependencies (inheritance, containment, and class references variables) of the\r\n# class with other documented classes.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nCOLLABORATION_GRAPH    = YES\r\n\r\n# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for\r\n# groups, showing the direct groups dependencies.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nGROUP_GRAPHS           = YES\r\n\r\n# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and\r\n# collaboration diagrams in a style similar to the OMG's Unified Modeling\r\n# Language.\r\n# The default value is: NO.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nUML_LOOK               = NO\r\n\r\n# If the UML_LOOK tag is enabled, the fields and methods are shown inside the\r\n# class node. If there are many fields or methods and many nodes the graph may\r\n# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the\r\n# number of items for each type to make the size more manageable. Set this to 0\r\n# for no limit. Note that the threshold may be exceeded by 50% before the limit\r\n# is enforced. So when you set the threshold to 10, up to 15 fields may appear,\r\n# but if the number exceeds 15, the total amount of fields shown is limited to\r\n# 10.\r\n# Minimum value: 0, maximum value: 100, default value: 10.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nUML_LIMIT_NUM_FIELDS   = 10\r\n\r\n# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and\r\n# collaboration graphs will show the relations between templates and their\r\n# instances.\r\n# The default value is: NO.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nTEMPLATE_RELATIONS     = NO\r\n\r\n# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to\r\n# YES then doxygen will generate a graph for each documented file showing the\r\n# direct and indirect include dependencies of the file with other documented\r\n# files.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nINCLUDE_GRAPH          = YES\r\n\r\n# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are\r\n# set to YES then doxygen will generate a graph for each documented file showing\r\n# the direct and indirect include dependencies of the file with other documented\r\n# files.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nINCLUDED_BY_GRAPH      = YES\r\n\r\n# If the CALL_GRAPH tag is set to YES then doxygen will generate a call\r\n# dependency graph for every global function or class method.\r\n#\r\n# Note that enabling this option will significantly increase the time of a run.\r\n# So in most cases it will be better to enable call graphs for selected\r\n# functions only using the \\callgraph command. Disabling a call graph can be\r\n# accomplished by means of the command \\hidecallgraph.\r\n# The default value is: NO.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nCALL_GRAPH             = NO\r\n\r\n# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller\r\n# dependency graph for every global function or class method.\r\n#\r\n# Note that enabling this option will significantly increase the time of a run.\r\n# So in most cases it will be better to enable caller graphs for selected\r\n# functions only using the \\callergraph command. Disabling a caller graph can be\r\n# accomplished by means of the command \\hidecallergraph.\r\n# The default value is: NO.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nCALLER_GRAPH           = NO\r\n\r\n# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical\r\n# hierarchy of all classes instead of a textual one.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nGRAPHICAL_HIERARCHY    = YES\r\n\r\n# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the\r\n# dependencies a directory has on other directories in a graphical way. The\r\n# dependency relations are determined by the #include relations between the\r\n# files in the directories.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDIRECTORY_GRAPH        = YES\r\n\r\n# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images\r\n# generated by dot. For an explanation of the image formats see the section\r\n# output formats in the documentation of the dot tool (Graphviz (see:\r\n# http://www.graphviz.org/)).\r\n# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order\r\n# to make the SVG files visible in IE 9+ (other browsers do not have this\r\n# requirement).\r\n# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,\r\n# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and\r\n# png:gdiplus:gdiplus.\r\n# The default value is: png.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_IMAGE_FORMAT       = png\r\n\r\n# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to\r\n# enable generation of interactive SVG images that allow zooming and panning.\r\n#\r\n# Note that this requires a modern browser other than Internet Explorer. Tested\r\n# and working are Firefox, Chrome, Safari, and Opera.\r\n# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make\r\n# the SVG files visible. Older versions of IE do not have SVG support.\r\n# The default value is: NO.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nINTERACTIVE_SVG        = NO\r\n\r\n# The DOT_PATH tag can be used to specify the path where the dot tool can be\r\n# found. If left blank, it is assumed the dot tool can be found in the path.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_PATH               =\r\n\r\n# The DOTFILE_DIRS tag can be used to specify one or more directories that\r\n# contain dot files that are included in the documentation (see the \\dotfile\r\n# command).\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOTFILE_DIRS           =\r\n\r\n# The MSCFILE_DIRS tag can be used to specify one or more directories that\r\n# contain msc files that are included in the documentation (see the \\mscfile\r\n# command).\r\n\r\nMSCFILE_DIRS           =\r\n\r\n# The DIAFILE_DIRS tag can be used to specify one or more directories that\r\n# contain dia files that are included in the documentation (see the \\diafile\r\n# command).\r\n\r\nDIAFILE_DIRS           =\r\n\r\n# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the\r\n# path where java can find the plantuml.jar file. If left blank, it is assumed\r\n# PlantUML is not used or called during a preprocessing step. Doxygen will\r\n# generate a warning when it encounters a \\startuml command in this case and\r\n# will not generate output for the diagram.\r\n\r\nPLANTUML_JAR_PATH      =\r\n\r\n# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a\r\n# configuration file for plantuml.\r\n\r\nPLANTUML_CFG_FILE      =\r\n\r\n# When using plantuml, the specified paths are searched for files specified by\r\n# the !include statement in a plantuml block.\r\n\r\nPLANTUML_INCLUDE_PATH  =\r\n\r\n# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes\r\n# that will be shown in the graph. If the number of nodes in a graph becomes\r\n# larger than this value, doxygen will truncate the graph, which is visualized\r\n# by representing a node as a red box. Note that doxygen if the number of direct\r\n# children of the root node in a graph is already larger than\r\n# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that\r\n# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.\r\n# Minimum value: 0, maximum value: 10000, default value: 50.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_GRAPH_MAX_NODES    = 50\r\n\r\n# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs\r\n# generated by dot. A depth value of 3 means that only nodes reachable from the\r\n# root by following a path via at most 3 edges will be shown. Nodes that lay\r\n# further from the root node will be omitted. Note that setting this option to 1\r\n# or 2 may greatly reduce the computation time needed for large code bases. Also\r\n# note that the size of a graph can be further restricted by\r\n# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.\r\n# Minimum value: 0, maximum value: 1000, default value: 0.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nMAX_DOT_GRAPH_DEPTH    = 0\r\n\r\n# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent\r\n# background. This is disabled by default, because dot on Windows does not seem\r\n# to support this out of the box.\r\n#\r\n# Warning: Depending on the platform used, enabling this option may lead to\r\n# badly anti-aliased labels on the edges of a graph (i.e. they become hard to\r\n# read).\r\n# The default value is: NO.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_TRANSPARENT        = NO\r\n\r\n# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output\r\n# files in one run (i.e. multiple -o and -T options on the command line). This\r\n# makes dot run faster, but since only newer versions of dot (>1.8.10) support\r\n# this, this feature is disabled by default.\r\n# The default value is: NO.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_MULTI_TARGETS      = NO\r\n\r\n# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page\r\n# explaining the meaning of the various boxes and arrows in the dot generated\r\n# graphs.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nGENERATE_LEGEND        = YES\r\n\r\n# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot\r\n# files that are used to generate the various graphs.\r\n# The default value is: YES.\r\n# This tag requires that the tag HAVE_DOT is set to YES.\r\n\r\nDOT_CLEANUP            = YES\r\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 2.27734375,
          "content": "# Copyright © 2020 Dylan Baker\n\n# This software is provided 'as-is', without any express or implied\n# warranty. In no event will the authors be held liable for any\n# damages arising from the use of this software.\n\n# Permission is granted to anyone to use this software for any\n# purpose, including commercial applications, and to alter it and\n# redistribute it freely, subject to the following restrictions:\n\n# 1. The origin of this software must not be misrepresented; you must\n# not claim that you wrote the original software. If you use this\n# software in a product, an acknowledgment in the product documentation\n# would be appreciated but is not required.\n\n# 2. Altered source versions must be plainly marked as such, and\n# must not be misrepresented as being the original software.\n\n# 3. This notice may not be removed or altered from any source\n# distribution.\n\nproject(\n    'tinyxml2',\n    ['cpp'],\n    version : '10.0.0',\n    meson_version : '>= 0.49.0',\n)\n\ncpp = meson.get_compiler('cpp')\n\ntinyxml_extra_args = []\nif cpp.get_argument_syntax() == 'msvc'\n    tinyxml_extra_args += '-D_CRT_SECURE_NO_WARNINGS'\nendif\n\nif get_option('default_library') == 'shared'\n    tinyxml_extra_args += '-DTINYXML2_EXPORT'\nendif\n\nif get_option('debug')\n    tinyxml_extra_args += '-DTINYXML2_DEBUG'\nendif\n\nlib_tinyxml2 = library(\n    'tinyxml2',\n    ['tinyxml2.cpp'],\n    cpp_args : tinyxml_extra_args,\n    gnu_symbol_visibility : 'hidden',\n    version : meson.project_version(),\n    install : true,\n)\n\ndep_tinyxml2 = declare_dependency(\n    link_with : lib_tinyxml2,\n    include_directories : include_directories('.'),\n)\n\n# This is the new way to set dependencies, but let's not break users of older\n# versions of meson\nif meson.version().version_compare('>= 0.54.0')\n  meson.override_dependency('tinyxml2', dep_tinyxml2)\nendif\n\nif get_option('tests')\n    test(\n        'xmltest',\n        executable(\n            'xmltest',\n            ['xmltest.cpp'],\n            link_with : [lib_tinyxml2],\n        ),\n        workdir : meson.current_source_dir(),\n    )\nendif\n\ninstall_headers('tinyxml2.h')\n\n# This is better than using the .in because meson tracks dependencies\n# internally, and will generate a more accurate pkg-config file\npkg = import('pkgconfig')\npkg.generate(\n    lib_tinyxml2,\n    description : 'simple, small, C++ XML parser',\n)\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 0.9658203125,
          "content": "# Copyright © 2020 Dylan Baker\n\n# This software is provided 'as-is', without any express or implied\n# warranty. In no event will the authors be held liable for any\n# damages arising from the use of this software.\n\n# Permission is granted to anyone to use this software for any\n# purpose, including commercial applications, and to alter it and\n# redistribute it freely, subject to the following restrictions:\n\n# 1. The origin of this software must not be misrepresented; you must\n# not claim that you wrote the original software. If you use this\n# software in a product, an acknowledgment in the product documentation\n# would be appreciated but is not required.\n\n# 2. Altered source versions must be plainly marked as such, and\n# must not be misrepresented as being the original software.\n\n# 3. This notice may not be removed or altered from any source\n# distribution.\n\noption(\n    'tests',\n    type : 'boolean',\n    description : 'Enable unit tests',\n    value : true,\n    yield : true,\n)"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 11.3935546875,
          "content": "TinyXML-2\n=========\n\n[![Test](https://github.com/leethomason/tinyxml2/actions/workflows/test.yml/badge.svg)](https://github.com/leethomason/tinyxml2/actions/workflows/test.yml)\n\nTinyXML-2 is a simple, small, efficient, C++ XML parser that can be\neasily integrated into other programs.\n\nThe master is hosted on github:\nhttps://github.com/leethomason/tinyxml2\n\nThe online HTML version of these docs:\nhttp://leethomason.github.io/tinyxml2/\n\nExamples are in the \"related pages\" tab of the HTML docs.\n\nWhat it does.\n-------------\n\nIn brief, TinyXML-2 parses an XML document, and builds from that a\nDocument Object Model (DOM) that can be read, modified, and saved.\n\nXML stands for \"eXtensible Markup Language.\" It is a general purpose\nhuman and machine readable markup language to describe arbitrary data.\nAll those random file formats created to store application data can\nall be replaced with XML. One parser for everything.\n\nhttp://en.wikipedia.org/wiki/XML\n\nThere are different ways to access and interact with XML data.\nTinyXML-2 uses a Document Object Model (DOM), meaning the XML data is parsed\ninto a C++ objects that can be browsed and manipulated, and then\nwritten to disk or another output stream. You can also construct an XML document\nfrom scratch with C++ objects and write this to disk or another output\nstream. You can even use TinyXML-2 to stream XML programmatically from\ncode without creating a document first.\n\nTinyXML-2 is designed to be easy and fast to learn. It is one header and\none cpp file. Simply add these to your project and off you go.\nThere is an example file - xmltest.cpp - to get you started.\n\nTinyXML-2 is released under the ZLib license,\nso you can use it in open source or commercial code. The details\nof the license are at the top of every source file.\n\nTinyXML-2 attempts to be a flexible parser, but with truly correct and\ncompliant XML output. TinyXML-2 should compile on any reasonably C++\ncompliant system. It does not rely on exceptions, RTTI, or the STL.\n\nWhat it doesn't do.\n-------------------\n\nTinyXML-2 doesn't parse or use DTDs (Document Type Definitions) or XSLs\n(eXtensible Stylesheet Language.) There are other parsers out there\nthat are much more fully featured. But they are generally bigger and\nmore difficult to use. If you are working with\nbrowsers or have more complete XML needs, TinyXML-2 is not the parser for you.\n\nTinyXML-1 vs. TinyXML-2\n-----------------------\n\nTinyXML-2 long been the focus of all development. It is well tested \nand should be used instead of TinyXML-1.\n\nTinyXML-2 uses a similar API to TinyXML-1 and the same\nrich test cases. But the implementation of the parser is completely re-written\nto make it more appropriate for use in a game. It uses less memory, is faster,\nand uses far fewer memory allocations.\n\nTinyXML-2 has no requirement or support for STL.\n\nFeatures\n--------\n\n### Code Page\n\nTinyXML-2 uses UTF-8 exclusively when interpreting XML. All XML is assumed to\nbe UTF-8.\n\nFilenames for loading / saving are passed unchanged to the underlying OS.\n\n### Memory Model\n\nAn XMLDocument is a C++ object like any other, that can be on the stack, or\nnew'd and deleted on the heap.\n\nHowever, any sub-node of the Document, XMLElement, XMLText, etc, can only\nbe created by calling the appropriate XMLDocument::NewElement, NewText, etc.\nmethod. Although you have pointers to these objects, they are still owned\nby the Document. When the Document is deleted, so are all the nodes it contains.\n\n### White Space\n\n#### Whitespace Preservation (default, PRESERVE_WHITESPACE)\n\nMicrosoft has an excellent article on white space: http://msdn.microsoft.com/en-us/library/ms256097.aspx\n\nBy default, TinyXML-2 preserves white space in a (hopefully) sane way that is almost compliant with the\nspec. (TinyXML-1 used a completely different model, much more similar to 'collapse', below.)\n\nAs a first step, all newlines / carriage-returns / line-feeds are normalized to a\nline-feed character, as required by the XML spec.\n\nWhite space in text is preserved. For example:\n\n\t<element> Hello,  World</element>\n\nThe leading space before the \"Hello\" and the double space after the comma are\npreserved. Line-feeds are preserved, as in this example:\n\n\t<element> Hello again,\n\t          World</element>\n\nHowever, white space between elements is **not** preserved. Although not strictly\ncompliant, tracking and reporting inter-element space is awkward, and not normally\nvaluable. TinyXML-2 sees these as the same XML:\n\n\t<document>\n\t\t<data>1</data>\n\t\t<data>2</data>\n\t\t<data>3</data>\n\t</document>\n\n\t<document><data>1</data><data>2</data><data>3</data></document>\n\n#### Whitespace Collapse (COLLAPSE_WHITESPACE)\n\nFor some applications, it is preferable to collapse whitespace. Collapsing\nwhitespace gives you \"HTML-like\" behavior, which is sometimes more suitable\nfor hand typed documents.\n\nTinyXML-2 supports this with the 'whitespace' parameter to the XMLDocument constructor.\n(The default is to preserve whitespace, as described above.)\n\nHowever, you may also use COLLAPSE_WHITESPACE, which will:\n\n* Remove leading and trailing whitespace\n* Convert newlines and line-feeds into a space character\n* Collapse a run of any number of space characters into a single space character\n\nNote that (currently) there is a performance impact for using COLLAPSE_WHITESPACE.\nIt essentially causes the XML to be parsed twice.\n\n#### Pedantic Whitespace (PEDANTIC_WHITESPACE)\n\nFor applications that need to know about text nodes that are composed entirely of \nwhitespace, PEDANTIC_WHITESPACE is available. PEDANTIC_WHITESPACE maintains all the\nwhilespace between elements. \n\nPEDANTIC_WHITESPACE is a new mode and not as tested as the other whitespace modes.\n\n### Error Reporting\n\nTinyXML-2 reports the line number of any errors in an XML document that\ncannot be parsed correctly. In addition, all nodes (elements, declarations,\ntext, comments etc.) and attributes have a line number recorded as they are parsed.\nThis allows an application that performs additional validation of the parsed\nXML document (e.g. application-implemented DTD validation) to report\nline number information for error messages.\n\n### Entities\n\nTinyXML-2 recognizes the pre-defined \"character entities\", meaning special\ncharacters. Namely:\n\n\t&amp;\t&\n\t&lt;\t<\n\t&gt;\t>\n\t&quot;\t\"\n\t&apos;\t'\n\nThese are recognized when the XML document is read, and translated to their\nUTF-8 equivalents. For instance, text with the XML of:\n\n\tFar &amp; Away\n\nwill have the Value() of \"Far & Away\" when queried from the XMLText object,\nand will be written back to the XML stream/file as an ampersand.\n\nAdditionally, any character can be specified by its Unicode code point:\nThe syntax `&#xA0;` or `&#160;` are both to the non-breaking space character.\nThis is called a 'numeric character reference'. Any numeric character reference\nthat isn't one of the special entities above, will be read, but written as a\nregular code point. The output is correct, but the entity syntax isn't preserved.\n\n### Printing\n\n#### Print to file\nYou can directly use the convenience function:\n\n\tXMLDocument doc;\n\t...\n\tdoc.SaveFile( \"foo.xml\" );\n\nOr the XMLPrinter class:\n\n\tXMLPrinter printer( fp );\n\tdoc.Print( &printer );\n\n#### Print to memory\nPrinting to memory is supported by the XMLPrinter.\n\n\tXMLPrinter printer;\n\tdoc.Print( &printer );\n\t// printer.CStr() has a const char* to the XML\n\n#### Print without an XMLDocument\n\nWhen loading, an XML parser is very useful. However, sometimes\nwhen saving, it just gets in the way. The code is often set up\nfor streaming, and constructing the DOM is just overhead.\n\nThe Printer supports the streaming case. The following code\nprints out a trivially simple XML file without ever creating\nan XML document.\n\n\tXMLPrinter printer( fp );\n\tprinter.OpenElement( \"foo\" );\n\tprinter.PushAttribute( \"foo\", \"bar\" );\n\tprinter.CloseElement();\n\nExamples\n--------\n\n#### Load and parse an XML file.\n\n\t/* ------ Example 1: Load and parse an XML file. ---- */\n\t{\n\t\tXMLDocument doc;\n\t\tdoc.LoadFile( \"dream.xml\" );\n\t}\n\n#### Lookup information.\n\n\t/* ------ Example 2: Lookup information. ---- */\n\t{\n\t\tXMLDocument doc;\n\t\tdoc.LoadFile( \"dream.xml\" );\n\n\t\t// Structure of the XML file:\n\t\t// - Element \"PLAY\"      the root Element, which is the\n\t\t//                       FirstChildElement of the Document\n\t\t// - - Element \"TITLE\"   child of the root PLAY Element\n\t\t// - - - Text            child of the TITLE Element\n\n\t\t// Navigate to the title, using the convenience function,\n\t\t// with a dangerous lack of error checking.\n\t\tconst char* title = doc.FirstChildElement( \"PLAY\" )->FirstChildElement( \"TITLE\" )->GetText();\n\t\tprintf( \"Name of play (1): %s\\n\", title );\n\n\t\t// Text is just another Node to TinyXML-2. The more\n\t\t// general way to get to the XMLText:\n\t\tXMLText* textNode = doc.FirstChildElement( \"PLAY\" )->FirstChildElement( \"TITLE\" )->FirstChild()->ToText();\n\t\ttitle = textNode->Value();\n\t\tprintf( \"Name of play (2): %s\\n\", title );\n\t}\n\nUsing and Installing\n--------------------\n\nThere are 2 files in TinyXML-2:\n* tinyxml2.cpp\n* tinyxml2.h\n\nAnd additionally a test file:\n* xmltest.cpp\n\nGenerally speaking, the intent is that you simply include the tinyxml2.cpp and \ntinyxml2.h files in your project and build with your other source code.\n\nThere is also a CMake build included. CMake is the general build for TinyXML-2.\n\n(Additional build systems are costly to maintain, and tend to bit-rot. They are\nbeing removed over time.)\n\nBuilding TinyXML-2 - Using vcpkg\n--------------------------------\n\nYou can download and install TinyXML-2 using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n\n    git clone https://github.com/Microsoft/vcpkg.git\n    cd vcpkg\n    ./bootstrap-vcpkg.sh\n    ./vcpkg integrate install\n    ./vcpkg install tinyxml2\n\nThe TinyXML-2 port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\nVersioning\n----------\n\nTinyXML-2 uses semantic versioning. http://semver.org/ Releases are now tagged in github.\n\nNote that the major version will (probably) change fairly rapidly. API changes are fairly\ncommon.\n\nLicense\n-------\n\nTinyXML-2 is released under the zlib license:\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n3. This notice may not be removed or altered from any source\ndistribution.\n\nContributors\n------------\n\nThanks very much to everyone who sends suggestions, bugs, ideas, and\nencouragement. It all helps, and makes this project fun.\n\nThe original TinyXML-1 has many contributors, who all deserve thanks\nin shaping what is a very successful library. Extra thanks to Yves\nBerquin and Andrew Ellerton who were key contributors.\n\nTinyXML-2 grew from that effort. Lee Thomason is the original author\nof TinyXML-2 (and TinyXML-1) but TinyXML-2 has been and is being improved\nby many contributors.\n\nThanks to John Mackay at http://john.mackay.rosalilastudio.com for the TinyXML-2 logo!\n\n\n"
        },
        {
          "name": "resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "setversion.py",
          "type": "blob",
          "size": 3.625,
          "content": "#!/usr/bin/env python3\r\n# Python program to set the version.\r\n##############################################\r\n\r\nimport re\r\nimport sys\r\nimport optparse\r\n\r\ndef fileProcess( name, lineFunction ):\r\n\tfilestream = open( name, 'r' )\r\n\tif filestream.closed:\r\n\t\tprint( \"file \" + name + \" not open.\" )\r\n\t\treturn\r\n\r\n\toutput = \"\"\r\n\tprint( \"--- Processing \" + name + \" ---------\" )\r\n\twhile 1:\r\n\t\tline = filestream.readline()\r\n\t\tif not line: break\r\n\t\toutput += lineFunction( line )\r\n\tfilestream.close()\r\n\r\n\tif not output: return\t\t\t# basic error checking\r\n\r\n\tprint( \"Writing file \" + name )\r\n\tfilestream = open( name, \"w\" );\r\n\tfilestream.write( output );\r\n\tfilestream.close()\r\n\r\ndef echoInput( line ):\r\n\treturn line\r\n\r\nparser = optparse.OptionParser( \"usage: %prog major minor build\" )\r\n(options, args) = parser.parse_args()\r\nif len(args) != 3:\r\n\tparser.error( \"incorrect number of arguments\" );\r\n\r\nmajor = args[0]\r\nminor = args[1]\r\nbuild = args[2]\r\nversionStr = major + \".\" + minor + \".\" + build\r\n\r\nprint (\"Setting dox,tinyxml2.h\")\r\nprint (\"Version: \" + major + \".\" + minor + \".\" + build)\r\n\r\n#### Write the tinyxml.h ####\r\n\r\ndef engineRule( line ):\r\n\r\n\tmatchMajor = \"static const int TIXML2_MAJOR_VERSION\"\r\n\tmatchMinor = \"static const int TIXML2_MINOR_VERSION\"\r\n\tmatchBuild = \"static const int TIXML2_PATCH_VERSION\"\r\n\r\n\tif line[0:len(matchMajor)] == matchMajor:\r\n\t\tprint( \"1)tinyxml2.h Major found\" )\r\n\t\treturn matchMajor + \" = \" + major + \";\\n\"\r\n\r\n\telif line[0:len(matchMinor)] == matchMinor:\r\n\t\tprint( \"2)tinyxml2.h Minor found\" )\r\n\t\treturn matchMinor + \" = \" + minor + \";\\n\"\r\n\r\n\telif line[0:len(matchBuild)] == matchBuild:\r\n\t\tprint( \"3)tinyxml2.h Build found\" )\r\n\t\treturn matchBuild + \" = \" + build + \";\\n\"\r\n\r\n\telse:\r\n\t\treturn line;\r\n\r\nfileProcess( \"tinyxml2.h\", engineRule )\r\n\r\ndef macroVersionRule( line ):\r\n\r\n\tmatchMajor = \"#define TINYXML2_MAJOR_VERSION\"\r\n\tmatchMinor = \"#define TINYXML2_MINOR_VERSION\"\r\n\tmatchBuild = \"#define TINYXML2_PATCH_VERSION\"\r\n\r\n\tif line[0:len(matchMajor)] == matchMajor:\r\n\t\tprint( \"1)macro Major found\" )\r\n\t\treturn matchMajor + \" \" + major + \"\\n\"\r\n\r\n\telif line[0:len(matchMinor)] == matchMinor:\r\n\t\tprint( \"2)macro Minor found\" )\r\n\t\treturn matchMinor + \" \" + minor + \"\\n\"\r\n\r\n\telif line[0:len(matchBuild)] == matchBuild:\r\n\t\tprint( \"3)macro Build found\" )\r\n\t\treturn matchBuild + \" \" + build + \"\\n\"\r\n\r\n\telse:\r\n\t\treturn line;\r\n\r\nfileProcess(\"tinyxml2.h\", macroVersionRule)\r\n\r\n#### Write the dox ####\r\n\r\ndef doxRule( line ):\r\n\r\n\tmatch = \"PROJECT_NUMBER\"\r\n\r\n\tif line[0:len( match )] == match:\r\n\t\tprint( \"dox project found\" )\r\n\t\treturn \"PROJECT_NUMBER = \" + major + \".\" + minor + \".\" + build + \"\\n\"\r\n\r\n\telse:\r\n\t\treturn line;\r\n\r\nfileProcess( \"dox\", doxRule )\r\n\r\n\r\n#### Write the CMakeLists.txt ####\r\n\r\ndef cmakeRule( line ):\r\n\r\n\tmatchVersion = \"project(tinyxml2 VERSION\"\r\n\r\n\tif line[0:len(matchVersion)] == matchVersion:\r\n\t\tprint( \"1)tinyxml2.h Major found\" )\r\n\t\treturn matchVersion + \" \" + major + \".\" + minor + \".\" + build + \")\\n\"\r\n\r\n\telse:\r\n\t\treturn line;\r\n\r\nfileProcess( \"CMakeLists.txt\", cmakeRule )\r\n\r\n\r\ndef mesonRule(line):\r\n\tmatch = re.search(r\"(\\s*version) : '(\\d+.\\d+.\\d+)',\", line)\r\n\tif match:\r\n\t\tprint(\"1)meson.build version found.\")\r\n\t\treturn \"{} : '{}.{}.{}',\\n\".format(match.group(1), major, minor, build)\r\n\treturn line\r\n\r\nfileProcess(\"meson.build\", mesonRule)\r\n\r\nprint( \"Release note:\" )\r\nprint( '1. Build.   g++ -Wall -DTINYXML2_DEBUG tinyxml2.cpp xmltest.cpp -o gccxmltest.exe' )\r\nprint( '2. Commit.  git commit -am\"setting the version to ' + versionStr + '\"' )\r\nprint( '3. Tag.     git tag ' + versionStr )\r\nprint( '   OR       git tag -a ' + versionStr + ' -m [tag message]' )\r\nprint( 'Remember to \"git push\" both code and tag. For the tag:' )\r\nprint( 'git push origin [tagname]')\r\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tinyxml2.cpp",
          "type": "blob",
          "size": 76.69140625,
          "content": "/*\r\nOriginal code by Lee Thomason (www.grinninglizard.com)\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any\r\ndamages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you must\r\nnot claim that you wrote the original software. If you use this\r\nsoftware in a product, an acknowledgment in the product documentation\r\nwould be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"tinyxml2.h\"\r\n\r\n#include <new>\t\t// yes, this one new style header, is in the Android SDK.\r\n#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)\r\n#   include <stddef.h>\r\n#   include <stdarg.h>\r\n#else\r\n#   include <cstddef>\r\n#   include <cstdarg>\r\n#endif\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)\r\n\t// Microsoft Visual Studio, version 2005 and higher. Not WinCE.\r\n\t/*int _snprintf_s(\r\n\t   char *buffer,\r\n\t   size_t sizeOfBuffer,\r\n\t   size_t count,\r\n\t   const char *format [,\r\n\t\t  argument] ...\r\n\t);*/\r\n\tstatic inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )\r\n\t{\r\n\t\tva_list va;\r\n\t\tva_start( va, format );\r\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\r\n\t\tva_end( va );\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )\r\n\t{\r\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\r\n\t\treturn result;\r\n\t}\r\n\r\n\t#define TIXML_VSCPRINTF\t_vscprintf\r\n\t#define TIXML_SSCANF\tsscanf_s\r\n#elif defined _MSC_VER\r\n\t// Microsoft Visual Studio 2003 and earlier or WinCE\r\n\t#define TIXML_SNPRINTF\t_snprintf\r\n\t#define TIXML_VSNPRINTF _vsnprintf\r\n\t#define TIXML_SSCANF\tsscanf\r\n\t#if (_MSC_VER < 1400 ) && (!defined WINCE)\r\n\t\t// Microsoft Visual Studio 2003 and not WinCE.\r\n\t\t#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.\r\n\t#else\r\n\t\t// Microsoft Visual Studio 2003 and earlier or WinCE.\r\n\t\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\r\n\t\t{\r\n\t\t\tint len = 512;\r\n\t\t\tfor (;;) {\r\n\t\t\t\tlen = len*2;\r\n\t\t\t\tchar* str = new char[len]();\r\n\t\t\t\tconst int required = _vsnprintf(str, len, format, va);\r\n\t\t\t\tdelete[] str;\r\n\t\t\t\tif ( required != -1 ) {\r\n\t\t\t\t\tTIXMLASSERT( required >= 0 );\r\n\t\t\t\t\tlen = required;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tTIXMLASSERT( len >= 0 );\r\n\t\t\treturn len;\r\n\t\t}\r\n\t#endif\r\n#else\r\n\t// GCC version 3 and higher\r\n\t//#warning( \"Using sn* functions.\" )\r\n\t#define TIXML_SNPRINTF\tsnprintf\r\n\t#define TIXML_VSNPRINTF\tvsnprintf\r\n\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\r\n\t{\r\n\t\tint len = vsnprintf( 0, 0, format, va );\r\n\t\tTIXMLASSERT( len >= 0 );\r\n\t\treturn len;\r\n\t}\r\n\t#define TIXML_SSCANF   sscanf\r\n#endif\r\n\r\n#if defined(_WIN64)\r\n\t#define TIXML_FSEEK _fseeki64\r\n\t#define TIXML_FTELL _ftelli64\r\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)\r\n\t#define TIXML_FSEEK fseeko\r\n\t#define TIXML_FTELL ftello\r\n#elif defined(__ANDROID__) && __ANDROID_API__ > 24\r\n\t#define TIXML_FSEEK fseeko64\r\n\t#define TIXML_FTELL ftello64\r\n#else\r\n\t#define TIXML_FSEEK fseek\r\n\t#define TIXML_FTELL ftell\r\n#endif\r\n\r\n\r\nstatic const char LINE_FEED\t\t\t\t= static_cast<char>(0x0a);\t\t\t// all line endings are normalized to LF\r\nstatic const char LF = LINE_FEED;\r\nstatic const char CARRIAGE_RETURN\t\t= static_cast<char>(0x0d);\t\t\t// CR gets filtered out\r\nstatic const char CR = CARRIAGE_RETURN;\r\nstatic const char SINGLE_QUOTE\t\t\t= '\\'';\r\nstatic const char DOUBLE_QUOTE\t\t\t= '\\\"';\r\n\r\n// Bunch of unicode info at:\r\n//\t\thttp://www.unicode.org/faq/utf_bom.html\r\n//\tef bb bf (Microsoft \"lead bytes\") - designates UTF-8\r\n\r\nstatic const unsigned char TIXML_UTF_LEAD_0 = 0xefU;\r\nstatic const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\r\nstatic const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\r\n\r\nnamespace tinyxml2\r\n{\r\n\r\nstruct Entity {\r\n    const char* pattern;\r\n    int length;\r\n    char value;\r\n};\r\n\r\nstatic const int NUM_ENTITIES = 5;\r\nstatic const Entity entities[NUM_ENTITIES] = {\r\n    { \"quot\", 4,\tDOUBLE_QUOTE },\r\n    { \"amp\", 3,\t\t'&'  },\r\n    { \"apos\", 4,\tSINGLE_QUOTE },\r\n    { \"lt\",\t2, \t\t'<'\t },\r\n    { \"gt\",\t2,\t\t'>'\t }\r\n};\r\n\r\n\r\nStrPair::~StrPair()\r\n{\r\n    Reset();\r\n}\r\n\r\n\r\nvoid StrPair::TransferTo( StrPair* other )\r\n{\r\n    if ( this == other ) {\r\n        return;\r\n    }\r\n    // This in effect implements the assignment operator by \"moving\"\r\n    // ownership (as in auto_ptr).\r\n\r\n    TIXMLASSERT( other != 0 );\r\n    TIXMLASSERT( other->_flags == 0 );\r\n    TIXMLASSERT( other->_start == 0 );\r\n    TIXMLASSERT( other->_end == 0 );\r\n\r\n    other->Reset();\r\n\r\n    other->_flags = _flags;\r\n    other->_start = _start;\r\n    other->_end = _end;\r\n\r\n    _flags = 0;\r\n    _start = 0;\r\n    _end = 0;\r\n}\r\n\r\n\r\nvoid StrPair::Reset()\r\n{\r\n    if ( _flags & NEEDS_DELETE ) {\r\n        delete [] _start;\r\n    }\r\n    _flags = 0;\r\n    _start = 0;\r\n    _end = 0;\r\n}\r\n\r\n\r\nvoid StrPair::SetStr( const char* str, int flags )\r\n{\r\n    TIXMLASSERT( str );\r\n    Reset();\r\n    size_t len = strlen( str );\r\n    TIXMLASSERT( _start == 0 );\r\n    _start = new char[ len+1 ];\r\n    memcpy( _start, str, len+1 );\r\n    _end = _start + len;\r\n    _flags = flags | NEEDS_DELETE;\r\n}\r\n\r\n\r\nchar* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )\r\n{\r\n    TIXMLASSERT( p );\r\n    TIXMLASSERT( endTag && *endTag );\r\n\tTIXMLASSERT(curLineNumPtr);\r\n\r\n    char* start = p;\r\n    const char  endChar = *endTag;\r\n    size_t length = strlen( endTag );\r\n\r\n    // Inner loop of text parsing.\r\n    while ( *p ) {\r\n        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {\r\n            Set( start, p, strFlags );\r\n            return p + length;\r\n        } else if (*p == '\\n') {\r\n            ++(*curLineNumPtr);\r\n        }\r\n        ++p;\r\n        TIXMLASSERT( p );\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nchar* StrPair::ParseName( char* p )\r\n{\r\n    if ( !p || !(*p) ) {\r\n        return 0;\r\n    }\r\n    if ( !XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {\r\n        return 0;\r\n    }\r\n\r\n    char* const start = p;\r\n    ++p;\r\n    while ( *p && XMLUtil::IsNameChar( static_cast<unsigned char>(*p) ) ) {\r\n        ++p;\r\n    }\r\n\r\n    Set( start, p, 0 );\r\n    return p;\r\n}\r\n\r\n\r\nvoid StrPair::CollapseWhitespace()\r\n{\r\n    // Adjusting _start would cause undefined behavior on delete[]\r\n    TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );\r\n    // Trim leading space.\r\n    _start = XMLUtil::SkipWhiteSpace( _start, 0 );\r\n\r\n    if ( *_start ) {\r\n        const char* p = _start;\t// the read pointer\r\n        char* q = _start;\t// the write pointer\r\n\r\n        while( *p ) {\r\n            if ( XMLUtil::IsWhiteSpace( *p )) {\r\n                p = XMLUtil::SkipWhiteSpace( p, 0 );\r\n                if ( *p == 0 ) {\r\n                    break;    // don't write to q; this trims the trailing space.\r\n                }\r\n                *q = ' ';\r\n                ++q;\r\n            }\r\n            *q = *p;\r\n            ++q;\r\n            ++p;\r\n        }\r\n        *q = 0;\r\n    }\r\n}\r\n\r\n\r\nconst char* StrPair::GetStr()\r\n{\r\n    TIXMLASSERT( _start );\r\n    TIXMLASSERT( _end );\r\n    if ( _flags & NEEDS_FLUSH ) {\r\n        *_end = 0;\r\n        _flags ^= NEEDS_FLUSH;\r\n\r\n        if ( _flags ) {\r\n            const char* p = _start;\t// the read pointer\r\n            char* q = _start;\t// the write pointer\r\n\r\n            while( p < _end ) {\r\n                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {\r\n                    // CR-LF pair becomes LF\r\n                    // CR alone becomes LF\r\n                    // LF-CR becomes LF\r\n                    if ( *(p+1) == LF ) {\r\n                        p += 2;\r\n                    }\r\n                    else {\r\n                        ++p;\r\n                    }\r\n                    *q = LF;\r\n                    ++q;\r\n                }\r\n                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {\r\n                    if ( *(p+1) == CR ) {\r\n                        p += 2;\r\n                    }\r\n                    else {\r\n                        ++p;\r\n                    }\r\n                    *q = LF;\r\n                    ++q;\r\n                }\r\n                else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {\r\n                    // Entities handled by tinyXML2:\r\n                    // - special entities in the entity table [in/out]\r\n                    // - numeric character reference [in]\r\n                    //   &#20013; or &#x4e2d;\r\n\r\n                    if ( *(p+1) == '#' ) {\r\n                        const int buflen = 10;\r\n                        char buf[buflen] = { 0 };\r\n                        int len = 0;\r\n                        const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );\r\n                        if ( adjusted == 0 ) {\r\n                            *q = *p;\r\n                            ++p;\r\n                            ++q;\r\n                        }\r\n                        else {\r\n                            TIXMLASSERT( 0 <= len && len <= buflen );\r\n                            TIXMLASSERT( q + len <= adjusted );\r\n                            p = adjusted;\r\n                            memcpy( q, buf, len );\r\n                            q += len;\r\n                        }\r\n                    }\r\n                    else {\r\n                        bool entityFound = false;\r\n                        for( int i = 0; i < NUM_ENTITIES; ++i ) {\r\n                            const Entity& entity = entities[i];\r\n                            if ( strncmp( p + 1, entity.pattern, entity.length ) == 0\r\n                                    && *( p + entity.length + 1 ) == ';' ) {\r\n                                // Found an entity - convert.\r\n                                *q = entity.value;\r\n                                ++q;\r\n                                p += entity.length + 2;\r\n                                entityFound = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if ( !entityFound ) {\r\n                            // fixme: treat as error?\r\n                            ++p;\r\n                            ++q;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    *q = *p;\r\n                    ++p;\r\n                    ++q;\r\n                }\r\n            }\r\n            *q = 0;\r\n        }\r\n        // The loop below has plenty going on, and this\r\n        // is a less useful mode. Break it out.\r\n        if ( _flags & NEEDS_WHITESPACE_COLLAPSING ) {\r\n            CollapseWhitespace();\r\n        }\r\n        _flags = (_flags & NEEDS_DELETE);\r\n    }\r\n    TIXMLASSERT( _start );\r\n    return _start;\r\n}\r\n\r\n\r\n\r\n\r\n// --------- XMLUtil ----------- //\r\n\r\nconst char* XMLUtil::writeBoolTrue  = \"true\";\r\nconst char* XMLUtil::writeBoolFalse = \"false\";\r\n\r\nvoid XMLUtil::SetBoolSerialization(const char* writeTrue, const char* writeFalse)\r\n{\r\n\tstatic const char* defTrue  = \"true\";\r\n\tstatic const char* defFalse = \"false\";\r\n\r\n\twriteBoolTrue = (writeTrue) ? writeTrue : defTrue;\r\n\twriteBoolFalse = (writeFalse) ? writeFalse : defFalse;\r\n}\r\n\r\n\r\nconst char* XMLUtil::ReadBOM( const char* p, bool* bom )\r\n{\r\n    TIXMLASSERT( p );\r\n    TIXMLASSERT( bom );\r\n    *bom = false;\r\n    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);\r\n    // Check for BOM:\r\n    if (    *(pu+0) == TIXML_UTF_LEAD_0\r\n            && *(pu+1) == TIXML_UTF_LEAD_1\r\n            && *(pu+2) == TIXML_UTF_LEAD_2 ) {\r\n        *bom = true;\r\n        p += 3;\r\n    }\r\n    TIXMLASSERT( p );\r\n    return p;\r\n}\r\n\r\n\r\nvoid XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )\r\n{\r\n    const unsigned long BYTE_MASK = 0xBF;\r\n    const unsigned long BYTE_MARK = 0x80;\r\n    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\r\n\r\n    if (input < 0x80) {\r\n        *length = 1;\r\n    }\r\n    else if ( input < 0x800 ) {\r\n        *length = 2;\r\n    }\r\n    else if ( input < 0x10000 ) {\r\n        *length = 3;\r\n    }\r\n    else if ( input < 0x200000 ) {\r\n        *length = 4;\r\n    }\r\n    else {\r\n        *length = 0;    // This code won't convert this correctly anyway.\r\n        return;\r\n    }\r\n\r\n    output += *length;\r\n\r\n    // Scary scary fall throughs are annotated with carefully designed comments\r\n    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc\r\n    switch (*length) {\r\n        case 4:\r\n            --output;\r\n            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);\r\n            input >>= 6;\r\n            //fall through\r\n        case 3:\r\n            --output;\r\n            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);\r\n            input >>= 6;\r\n            //fall through\r\n        case 2:\r\n            --output;\r\n            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);\r\n            input >>= 6;\r\n            //fall through\r\n        case 1:\r\n            --output;\r\n            *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);\r\n            break;\r\n        default:\r\n            TIXMLASSERT( false );\r\n    }\r\n}\r\n\r\n\r\nconst char* XMLUtil::GetCharacterRef(const char* p, char* value, int* length)\r\n{\r\n    // Assume an entity, and pull it out.\r\n    *length = 0;\r\n\r\n    static const uint32_t MAX_CODE_POINT = 0x10FFFF;\r\n\r\n    if (*(p + 1) == '#' && *(p + 2)) {\r\n        uint32_t ucs = 0;\r\n        ptrdiff_t delta = 0;\r\n        uint32_t mult = 1;\r\n        static const char SEMICOLON = ';';\r\n\r\n        bool hex = false;\r\n        uint32_t radix = 10;\r\n        const char* q = 0;\r\n        char terminator = '#';\r\n\r\n        if (*(p + 2) == 'x') {\r\n            // Hexadecimal.\r\n            hex = true;\r\n            radix = 16;\r\n            terminator = 'x';\r\n\r\n            q = p + 3;\r\n        }\r\n        else {\r\n            // Decimal.\r\n            q = p + 2;\r\n        }\r\n        if (!(*q)) {\r\n            return 0;\r\n        }\r\n\r\n        q = strchr(q, SEMICOLON);\r\n        if (!q) {\r\n            return 0;\r\n        }\r\n        TIXMLASSERT(*q == SEMICOLON);\r\n\r\n        delta = q - p;\r\n        --q;\r\n\r\n        while (*q != terminator) {\r\n            uint32_t digit = 0;\r\n\r\n            if (*q >= '0' && *q <= '9') {\r\n                digit = *q - '0';\r\n            }\r\n            else if (hex && (*q >= 'a' && *q <= 'f')) {\r\n                digit = *q - 'a' + 10;\r\n            }\r\n            else if (hex && (*q >= 'A' && *q <= 'F')) {\r\n                digit = *q - 'A' + 10;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n            TIXMLASSERT(digit < radix);\r\n\r\n            const unsigned int digitScaled = mult * digit;\r\n            ucs += digitScaled;\r\n            mult *= radix;       \r\n            \r\n            // Security check: could a value exist that is out of range?\r\n            // Easily; limit to the MAX_CODE_POINT, which also allows for a\r\n            // bunch of leading zeroes.\r\n            if (mult > MAX_CODE_POINT) {\r\n                mult = MAX_CODE_POINT;\r\n            }\r\n            --q;\r\n        }\r\n        // Out of range:\r\n        if (ucs > MAX_CODE_POINT) {\r\n            return 0;\r\n        }\r\n        // convert the UCS to UTF-8\r\n        ConvertUTF32ToUTF8(ucs, value, length);\r\n\t\tif (length == 0) {\r\n            // If length is 0, there was an error. (Security? Bad input?)\r\n            // Fail safely.\r\n\t\t\treturn 0;\r\n\t\t}\r\n        return p + delta + 1;\r\n    }\r\n    return p + 1;\r\n}\r\n\r\nvoid XMLUtil::ToStr( int v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%d\", v );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%u\", v );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( bool v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%s\", v ? writeBoolTrue : writeBoolFalse);\r\n}\r\n\r\n/*\r\n\tToStr() of a number is a very tricky topic.\r\n\thttps://github.com/leethomason/tinyxml2/issues/106\r\n*/\r\nvoid XMLUtil::ToStr( float v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%.8g\", v );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( double v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%.17g\", v );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )\r\n{\r\n\t// horrible syntax trick to make the compiler happy about %lld\r\n\tTIXML_SNPRINTF(buffer, bufferSize, \"%lld\", static_cast<long long>(v));\r\n}\r\n\r\nvoid XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )\r\n{\r\n    // horrible syntax trick to make the compiler happy about %llu\r\n    TIXML_SNPRINTF(buffer, bufferSize, \"%llu\", static_cast<unsigned long long>(v));\r\n}\r\n\r\nbool XMLUtil::ToInt(const char* str, int* value)\r\n{\r\n    if (IsPrefixHex(str)) {\r\n        unsigned v;\r\n        if (TIXML_SSCANF(str, \"%x\", &v) == 1) {\r\n            *value = static_cast<int>(v);\r\n            return true;\r\n        }\r\n    }\r\n    else {\r\n        if (TIXML_SSCANF(str, \"%d\", value) == 1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nbool XMLUtil::ToUnsigned(const char* str, unsigned* value)\r\n{\r\n    if (TIXML_SSCANF(str, IsPrefixHex(str) ? \"%x\" : \"%u\", value) == 1) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool XMLUtil::ToBool( const char* str, bool* value )\r\n{\r\n    int ival = 0;\r\n    if ( ToInt( str, &ival )) {\r\n        *value = (ival==0) ? false : true;\r\n        return true;\r\n    }\r\n    static const char* TRUE_VALS[] = { \"true\", \"True\", \"TRUE\", 0 };\r\n    static const char* FALSE_VALS[] = { \"false\", \"False\", \"FALSE\", 0 };\r\n\r\n    for (int i = 0; TRUE_VALS[i]; ++i) {\r\n        if (StringEqual(str, TRUE_VALS[i])) {\r\n            *value = true;\r\n            return true;\r\n        }\r\n    }\r\n    for (int i = 0; FALSE_VALS[i]; ++i) {\r\n        if (StringEqual(str, FALSE_VALS[i])) {\r\n            *value = false;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool XMLUtil::ToFloat( const char* str, float* value )\r\n{\r\n    if ( TIXML_SSCANF( str, \"%f\", value ) == 1 ) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool XMLUtil::ToDouble( const char* str, double* value )\r\n{\r\n    if ( TIXML_SSCANF( str, \"%lf\", value ) == 1 ) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool XMLUtil::ToInt64(const char* str, int64_t* value)\r\n{\r\n    if (IsPrefixHex(str)) {\r\n        unsigned long long v = 0;\t// horrible syntax trick to make the compiler happy about %llx\r\n        if (TIXML_SSCANF(str, \"%llx\", &v) == 1) {\r\n            *value = static_cast<int64_t>(v);\r\n            return true;\r\n        }\r\n    }\r\n    else {\r\n        long long v = 0;\t// horrible syntax trick to make the compiler happy about %lld\r\n        if (TIXML_SSCANF(str, \"%lld\", &v) == 1) {\r\n            *value = static_cast<int64_t>(v);\r\n            return true;\r\n        }\r\n    }\r\n\treturn false;\r\n}\r\n\r\n\r\nbool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {\r\n    unsigned long long v = 0;\t// horrible syntax trick to make the compiler happy about %llu\r\n    if(TIXML_SSCANF(str, IsPrefixHex(str) ? \"%llx\" : \"%llu\", &v) == 1) {\r\n        *value = static_cast<uint64_t>(v);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nchar* XMLDocument::Identify( char* p, XMLNode** node, bool first )\r\n{\r\n    TIXMLASSERT( node );\r\n    TIXMLASSERT( p );\r\n    char* const start = p;\r\n    int const startLine = _parseCurLineNum;\r\n    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );\r\n    if( !*p ) {\r\n        *node = 0;\r\n        TIXMLASSERT( p );\r\n        return p;\r\n    }\r\n\r\n    // These strings define the matching patterns:\r\n    static const char* xmlHeader\t\t= { \"<?\" };\r\n    static const char* commentHeader\t= { \"<!--\" };\r\n    static const char* cdataHeader\t\t= { \"<![CDATA[\" };\r\n    static const char* dtdHeader\t\t= { \"<!\" };\r\n    static const char* elementHeader\t= { \"<\" };\t// and a header for everything else; check last.\r\n\r\n    static const int xmlHeaderLen\t\t= 2;\r\n    static const int commentHeaderLen\t= 4;\r\n    static const int cdataHeaderLen\t\t= 9;\r\n    static const int dtdHeaderLen\t\t= 2;\r\n    static const int elementHeaderLen\t= 1;\r\n\r\n    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );\t\t// use same memory pool\r\n    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );\t// use same memory pool\r\n    XMLNode* returnNode = 0;\r\n    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {\r\n        returnNode = CreateUnlinkedNode<XMLDeclaration>( _commentPool );\r\n        returnNode->_parseLineNum = _parseCurLineNum;\r\n        p += xmlHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {\r\n        returnNode = CreateUnlinkedNode<XMLComment>( _commentPool );\r\n        returnNode->_parseLineNum = _parseCurLineNum;\r\n        p += commentHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {\r\n        XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );\r\n        returnNode = text;\r\n        returnNode->_parseLineNum = _parseCurLineNum;\r\n        p += cdataHeaderLen;\r\n        text->SetCData( true );\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {\r\n        returnNode = CreateUnlinkedNode<XMLUnknown>( _commentPool );\r\n        returnNode->_parseLineNum = _parseCurLineNum;\r\n        p += dtdHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {\r\n\r\n        // Preserve whitespace pedantically before closing tag, when it's immediately after opening tag\r\n        if (WhitespaceMode() == PEDANTIC_WHITESPACE && first && p != start && *(p + elementHeaderLen) == '/') {\r\n            returnNode = CreateUnlinkedNode<XMLText>(_textPool);\r\n            returnNode->_parseLineNum = startLine;\r\n            p = start;\t// Back it up, all the text counts.\r\n            _parseCurLineNum = startLine;\r\n        }\r\n        else {\r\n            returnNode = CreateUnlinkedNode<XMLElement>(_elementPool);\r\n            returnNode->_parseLineNum = _parseCurLineNum;\r\n            p += elementHeaderLen;\r\n        }\r\n    }\r\n    else {\r\n        returnNode = CreateUnlinkedNode<XMLText>( _textPool );\r\n        returnNode->_parseLineNum = _parseCurLineNum; // Report line of first non-whitespace character\r\n        p = start;\t// Back it up, all the text counts.\r\n        _parseCurLineNum = startLine;\r\n    }\r\n\r\n    TIXMLASSERT( returnNode );\r\n    TIXMLASSERT( p );\r\n    *node = returnNode;\r\n    return p;\r\n}\r\n\r\n\r\nbool XMLDocument::Accept( XMLVisitor* visitor ) const\r\n{\r\n    TIXMLASSERT( visitor );\r\n    if ( visitor->VisitEnter( *this ) ) {\r\n        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {\r\n            if ( !node->Accept( visitor ) ) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return visitor->VisitExit( *this );\r\n}\r\n\r\n\r\n// --------- XMLNode ----------- //\r\n\r\nXMLNode::XMLNode( XMLDocument* doc ) :\r\n    _document( doc ),\r\n    _parent( 0 ),\r\n    _value(),\r\n    _parseLineNum( 0 ),\r\n    _firstChild( 0 ), _lastChild( 0 ),\r\n    _prev( 0 ), _next( 0 ),\r\n\t_userData( 0 ),\r\n    _memPool( 0 )\r\n{\r\n}\r\n\r\n\r\nXMLNode::~XMLNode()\r\n{\r\n    DeleteChildren();\r\n    if ( _parent ) {\r\n        _parent->Unlink( this );\r\n    }\r\n}\r\n\r\n// ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.\r\n\r\nint XMLNode::ChildElementCount(const char *value) const {\r\n\tint count = 0;\r\n\r\n\tconst XMLElement *e = FirstChildElement(value);\r\n\r\n\twhile (e) {\r\n\t\te = e->NextSiblingElement(value);\r\n\t\tcount++;\r\n\t}\r\n\r\n\treturn count;\r\n}\r\n\r\nint XMLNode::ChildElementCount() const {\r\n\tint count = 0;\r\n\r\n\tconst XMLElement *e = FirstChildElement();\r\n\r\n\twhile (e) {\r\n\t\te = e->NextSiblingElement();\r\n\t\tcount++;\r\n\t}\r\n\r\n\treturn count;\r\n}\r\n\r\nconst char* XMLNode::Value() const\r\n{\r\n    // Edge case: XMLDocuments don't have a Value. Return null.\r\n    if ( this->ToDocument() )\r\n        return 0;\r\n    return _value.GetStr();\r\n}\r\n\r\nvoid XMLNode::SetValue( const char* str, bool staticMem )\r\n{\r\n    if ( staticMem ) {\r\n        _value.SetInternedStr( str );\r\n    }\r\n    else {\r\n        _value.SetStr( str );\r\n    }\r\n}\r\n\r\nXMLNode* XMLNode::DeepClone(XMLDocument* target) const\r\n{\r\n\tXMLNode* clone = this->ShallowClone(target);\r\n\tif (!clone) return 0;\r\n\r\n\tfor (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {\r\n\t\tXMLNode* childClone = child->DeepClone(target);\r\n\t\tTIXMLASSERT(childClone);\r\n\t\tclone->InsertEndChild(childClone);\r\n\t}\r\n\treturn clone;\r\n}\r\n\r\nvoid XMLNode::DeleteChildren()\r\n{\r\n    while( _firstChild ) {\r\n        TIXMLASSERT( _lastChild );\r\n        DeleteChild( _firstChild );\r\n    }\r\n    _firstChild = _lastChild = 0;\r\n}\r\n\r\n\r\nvoid XMLNode::Unlink( XMLNode* child )\r\n{\r\n    TIXMLASSERT( child );\r\n    TIXMLASSERT( child->_document == _document );\r\n    TIXMLASSERT( child->_parent == this );\r\n    if ( child == _firstChild ) {\r\n        _firstChild = _firstChild->_next;\r\n    }\r\n    if ( child == _lastChild ) {\r\n        _lastChild = _lastChild->_prev;\r\n    }\r\n\r\n    if ( child->_prev ) {\r\n        child->_prev->_next = child->_next;\r\n    }\r\n    if ( child->_next ) {\r\n        child->_next->_prev = child->_prev;\r\n    }\r\n\tchild->_next = 0;\r\n\tchild->_prev = 0;\r\n\tchild->_parent = 0;\r\n}\r\n\r\n\r\nvoid XMLNode::DeleteChild( XMLNode* node )\r\n{\r\n    TIXMLASSERT( node );\r\n    TIXMLASSERT( node->_document == _document );\r\n    TIXMLASSERT( node->_parent == this );\r\n    Unlink( node );\r\n\tTIXMLASSERT(node->_prev == 0);\r\n\tTIXMLASSERT(node->_next == 0);\r\n\tTIXMLASSERT(node->_parent == 0);\r\n    DeleteNode( node );\r\n}\r\n\r\n\r\nXMLNode* XMLNode::InsertEndChild( XMLNode* addThis )\r\n{\r\n    TIXMLASSERT( addThis );\r\n    if ( addThis->_document != _document ) {\r\n        TIXMLASSERT( false );\r\n        return 0;\r\n    }\r\n    InsertChildPreamble( addThis );\r\n\r\n    if ( _lastChild ) {\r\n        TIXMLASSERT( _firstChild );\r\n        TIXMLASSERT( _lastChild->_next == 0 );\r\n        _lastChild->_next = addThis;\r\n        addThis->_prev = _lastChild;\r\n        _lastChild = addThis;\r\n\r\n        addThis->_next = 0;\r\n    }\r\n    else {\r\n        TIXMLASSERT( _firstChild == 0 );\r\n        _firstChild = _lastChild = addThis;\r\n\r\n        addThis->_prev = 0;\r\n        addThis->_next = 0;\r\n    }\r\n    addThis->_parent = this;\r\n    return addThis;\r\n}\r\n\r\n\r\nXMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )\r\n{\r\n    TIXMLASSERT( addThis );\r\n    if ( addThis->_document != _document ) {\r\n        TIXMLASSERT( false );\r\n        return 0;\r\n    }\r\n    InsertChildPreamble( addThis );\r\n\r\n    if ( _firstChild ) {\r\n        TIXMLASSERT( _lastChild );\r\n        TIXMLASSERT( _firstChild->_prev == 0 );\r\n\r\n        _firstChild->_prev = addThis;\r\n        addThis->_next = _firstChild;\r\n        _firstChild = addThis;\r\n\r\n        addThis->_prev = 0;\r\n    }\r\n    else {\r\n        TIXMLASSERT( _lastChild == 0 );\r\n        _firstChild = _lastChild = addThis;\r\n\r\n        addThis->_prev = 0;\r\n        addThis->_next = 0;\r\n    }\r\n    addThis->_parent = this;\r\n    return addThis;\r\n}\r\n\r\n\r\nXMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )\r\n{\r\n    TIXMLASSERT( addThis );\r\n    if ( addThis->_document != _document ) {\r\n        TIXMLASSERT( false );\r\n        return 0;\r\n    }\r\n\r\n    TIXMLASSERT( afterThis );\r\n\r\n    if ( afterThis->_parent != this ) {\r\n        TIXMLASSERT( false );\r\n        return 0;\r\n    }\r\n    if ( afterThis == addThis ) {\r\n        // Current state: BeforeThis -> AddThis -> OneAfterAddThis\r\n        // Now AddThis must disappear from it's location and then\r\n        // reappear between BeforeThis and OneAfterAddThis.\r\n        // So just leave it where it is.\r\n        return addThis;\r\n    }\r\n\r\n    if ( afterThis->_next == 0 ) {\r\n        // The last node or the only node.\r\n        return InsertEndChild( addThis );\r\n    }\r\n    InsertChildPreamble( addThis );\r\n    addThis->_prev = afterThis;\r\n    addThis->_next = afterThis->_next;\r\n    afterThis->_next->_prev = addThis;\r\n    afterThis->_next = addThis;\r\n    addThis->_parent = this;\r\n    return addThis;\r\n}\r\n\r\n\r\n\r\n\r\nconst XMLElement* XMLNode::FirstChildElement( const char* name ) const\r\n{\r\n    for( const XMLNode* node = _firstChild; node; node = node->_next ) {\r\n        const XMLElement* element = node->ToElementWithName( name );\r\n        if ( element ) {\r\n            return element;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst XMLElement* XMLNode::LastChildElement( const char* name ) const\r\n{\r\n    for( const XMLNode* node = _lastChild; node; node = node->_prev ) {\r\n        const XMLElement* element = node->ToElementWithName( name );\r\n        if ( element ) {\r\n            return element;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst XMLElement* XMLNode::NextSiblingElement( const char* name ) const\r\n{\r\n    for( const XMLNode* node = _next; node; node = node->_next ) {\r\n        const XMLElement* element = node->ToElementWithName( name );\r\n        if ( element ) {\r\n            return element;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const\r\n{\r\n    for( const XMLNode* node = _prev; node; node = node->_prev ) {\r\n        const XMLElement* element = node->ToElementWithName( name );\r\n        if ( element ) {\r\n            return element;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nchar* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )\r\n{\r\n    // This is a recursive method, but thinking about it \"at the current level\"\r\n    // it is a pretty simple flat list:\r\n    //\t\t<foo/>\r\n    //\t\t<!-- comment -->\r\n    //\r\n    // With a special case:\r\n    //\t\t<foo>\r\n    //\t\t</foo>\r\n    //\t\t<!-- comment -->\r\n    //\r\n    // Where the closing element (/foo) *must* be the next thing after the opening\r\n    // element, and the names must match. BUT the tricky bit is that the closing\r\n    // element will be read by the child.\r\n    //\r\n    // 'endTag' is the end tag for this node, it is returned by a call to a child.\r\n    // 'parentEnd' is the end tag for the parent, which is filled in and returned.\r\n\r\n\tXMLDocument::DepthTracker tracker(_document);\r\n\tif (_document->Error())\r\n\t\treturn 0;\r\n\r\n\tbool first = true;\r\n\twhile( p && *p ) {\r\n        XMLNode* node = 0;\r\n\r\n        p = _document->Identify( p, &node, first );\r\n        TIXMLASSERT( p );\r\n        if ( node == 0 ) {\r\n            break;\r\n        }\r\n        first = false;\r\n\r\n       const int initialLineNum = node->_parseLineNum;\r\n\r\n        StrPair endTag;\r\n        p = node->ParseDeep( p, &endTag, curLineNumPtr );\r\n        if ( !p ) {\r\n            _document->DeleteNode( node );\r\n            if ( !_document->Error() ) {\r\n                _document->SetError( XML_ERROR_PARSING, initialLineNum, 0);\r\n            }\r\n            break;\r\n        }\r\n\r\n        const XMLDeclaration* const decl = node->ToDeclaration();\r\n        if ( decl ) {\r\n            // Declarations are only allowed at document level\r\n            //\r\n            // Multiple declarations are allowed but all declarations\r\n            // must occur before anything else. \r\n            //\r\n            // Optimized due to a security test case. If the first node is \r\n            // a declaration, and the last node is a declaration, then only \r\n            // declarations have so far been added.\r\n            bool wellLocated = false;\r\n\r\n            if (ToDocument()) {\r\n                if (FirstChild()) {\r\n                    wellLocated =\r\n                        FirstChild() &&\r\n                        FirstChild()->ToDeclaration() &&\r\n                        LastChild() &&\r\n                        LastChild()->ToDeclaration();\r\n                }\r\n                else {\r\n                    wellLocated = true;\r\n                }\r\n            }\r\n            if ( !wellLocated ) {\r\n                _document->SetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, \"XMLDeclaration value=%s\", decl->Value());\r\n                _document->DeleteNode( node );\r\n                break;\r\n            }\r\n        }\r\n\r\n        XMLElement* ele = node->ToElement();\r\n        if ( ele ) {\r\n            // We read the end tag. Return it to the parent.\r\n            if ( ele->ClosingType() == XMLElement::CLOSING ) {\r\n                if ( parentEndTag ) {\r\n                    ele->_value.TransferTo( parentEndTag );\r\n                }\r\n                node->_memPool->SetTracked();   // created and then immediately deleted.\r\n                DeleteNode( node );\r\n                return p;\r\n            }\r\n\r\n            // Handle an end tag returned to this level.\r\n            // And handle a bunch of annoying errors.\r\n            bool mismatch = false;\r\n            if ( endTag.Empty() ) {\r\n                if ( ele->ClosingType() == XMLElement::OPEN ) {\r\n                    mismatch = true;\r\n                }\r\n            }\r\n            else {\r\n                if ( ele->ClosingType() != XMLElement::OPEN ) {\r\n                    mismatch = true;\r\n                }\r\n                else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele->Name() ) ) {\r\n                    mismatch = true;\r\n                }\r\n            }\r\n            if ( mismatch ) {\r\n                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, \"XMLElement name=%s\", ele->Name());\r\n                _document->DeleteNode( node );\r\n                break;\r\n            }\r\n        }\r\n        InsertEndChild( node );\r\n    }\r\n    return 0;\r\n}\r\n\r\n/*static*/ void XMLNode::DeleteNode( XMLNode* node )\r\n{\r\n    if ( node == 0 ) {\r\n        return;\r\n    }\r\n\tTIXMLASSERT(node->_document);\r\n\tif (!node->ToDocument()) {\r\n\t\tnode->_document->MarkInUse(node);\r\n\t}\r\n\r\n    MemPool* pool = node->_memPool;\r\n    node->~XMLNode();\r\n    pool->Free( node );\r\n}\r\n\r\nvoid XMLNode::InsertChildPreamble( XMLNode* insertThis ) const\r\n{\r\n    TIXMLASSERT( insertThis );\r\n    TIXMLASSERT( insertThis->_document == _document );\r\n\r\n\tif (insertThis->_parent) {\r\n        insertThis->_parent->Unlink( insertThis );\r\n\t}\r\n\telse {\r\n\t\tinsertThis->_document->MarkInUse(insertThis);\r\n        insertThis->_memPool->SetTracked();\r\n\t}\r\n}\r\n\r\nconst XMLElement* XMLNode::ToElementWithName( const char* name ) const\r\n{\r\n    const XMLElement* element = this->ToElement();\r\n    if ( element == 0 ) {\r\n        return 0;\r\n    }\r\n    if ( name == 0 ) {\r\n        return element;\r\n    }\r\n    if ( XMLUtil::StringEqual( element->Name(), name ) ) {\r\n       return element;\r\n    }\r\n    return 0;\r\n}\r\n\r\n// --------- XMLText ---------- //\r\nchar* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )\r\n{\r\n    if ( this->CData() ) {\r\n        p = _value.ParseText( p, \"]]>\", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );\r\n        if ( !p ) {\r\n            _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );\r\n        }\r\n        return p;\r\n    }\r\n    else {\r\n        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;\r\n        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {\r\n            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;\r\n        }\r\n\r\n        p = _value.ParseText( p, \"<\", flags, curLineNumPtr );\r\n        if ( p && *p ) {\r\n            return p-1;\r\n        }\r\n        if ( !p ) {\r\n            _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nXMLNode* XMLText::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLText* text = doc->NewText( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    text->SetCData( this->CData() );\r\n    return text;\r\n}\r\n\r\n\r\nbool XMLText::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    TIXMLASSERT( compare );\r\n    const XMLText* text = compare->ToText();\r\n    return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );\r\n}\r\n\r\n\r\nbool XMLText::Accept( XMLVisitor* visitor ) const\r\n{\r\n    TIXMLASSERT( visitor );\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n\r\n// --------- XMLComment ---------- //\r\n\r\nXMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )\r\n{\r\n}\r\n\r\n\r\nXMLComment::~XMLComment()\r\n{\r\n}\r\n\r\n\r\nchar* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )\r\n{\r\n    // Comment parses as text.\r\n    p = _value.ParseText( p, \"-->\", StrPair::COMMENT, curLineNumPtr );\r\n    if ( p == 0 ) {\r\n        _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\nXMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLComment* comment = doc->NewComment( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    return comment;\r\n}\r\n\r\n\r\nbool XMLComment::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    TIXMLASSERT( compare );\r\n    const XMLComment* comment = compare->ToComment();\r\n    return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));\r\n}\r\n\r\n\r\nbool XMLComment::Accept( XMLVisitor* visitor ) const\r\n{\r\n    TIXMLASSERT( visitor );\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n\r\n// --------- XMLDeclaration ---------- //\r\n\r\nXMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )\r\n{\r\n}\r\n\r\n\r\nXMLDeclaration::~XMLDeclaration()\r\n{\r\n    //printf( \"~XMLDeclaration\\n\" );\r\n}\r\n\r\n\r\nchar* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )\r\n{\r\n    // Declaration parses as text.\r\n    p = _value.ParseText( p, \"?>\", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );\r\n    if ( p == 0 ) {\r\n        _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\nXMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLDeclaration* dec = doc->NewDeclaration( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    return dec;\r\n}\r\n\r\n\r\nbool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    TIXMLASSERT( compare );\r\n    const XMLDeclaration* declaration = compare->ToDeclaration();\r\n    return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));\r\n}\r\n\r\n\r\n\r\nbool XMLDeclaration::Accept( XMLVisitor* visitor ) const\r\n{\r\n    TIXMLASSERT( visitor );\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n// --------- XMLUnknown ---------- //\r\n\r\nXMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )\r\n{\r\n}\r\n\r\n\r\nXMLUnknown::~XMLUnknown()\r\n{\r\n}\r\n\r\n\r\nchar* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )\r\n{\r\n    // Unknown parses as text.\r\n    p = _value.ParseText( p, \">\", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );\r\n    if ( !p ) {\r\n        _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\nXMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLUnknown* text = doc->NewUnknown( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    return text;\r\n}\r\n\r\n\r\nbool XMLUnknown::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    TIXMLASSERT( compare );\r\n    const XMLUnknown* unknown = compare->ToUnknown();\r\n    return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));\r\n}\r\n\r\n\r\nbool XMLUnknown::Accept( XMLVisitor* visitor ) const\r\n{\r\n    TIXMLASSERT( visitor );\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n// --------- XMLAttribute ---------- //\r\n\r\nconst char* XMLAttribute::Name() const\r\n{\r\n    return _name.GetStr();\r\n}\r\n\r\nconst char* XMLAttribute::Value() const\r\n{\r\n    return _value.GetStr();\r\n}\r\n\r\nchar* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )\r\n{\r\n    // Parse using the name rules: bug fix, was using ParseText before\r\n    p = _name.ParseName( p );\r\n    if ( !p || !*p ) {\r\n        return 0;\r\n    }\r\n\r\n    // Skip white space before =\r\n    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );\r\n    if ( *p != '=' ) {\r\n        return 0;\r\n    }\r\n\r\n    ++p;\t// move up to opening quote\r\n    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );\r\n    if ( *p != '\\\"' && *p != '\\'' ) {\r\n        return 0;\r\n    }\r\n\r\n    const char endTag[2] = { *p, 0 };\r\n    ++p;\t// move past opening quote\r\n\r\n    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );\r\n    return p;\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetName( const char* n )\r\n{\r\n    _name.SetStr( n );\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryIntValue( int* value ) const\r\n{\r\n    if ( XMLUtil::ToInt( Value(), value )) {\r\n        return XML_SUCCESS;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const\r\n{\r\n    if ( XMLUtil::ToUnsigned( Value(), value )) {\r\n        return XML_SUCCESS;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryInt64Value(int64_t* value) const\r\n{\r\n\tif (XMLUtil::ToInt64(Value(), value)) {\r\n\t\treturn XML_SUCCESS;\r\n\t}\r\n\treturn XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const\r\n{\r\n    if(XMLUtil::ToUnsigned64(Value(), value)) {\r\n        return XML_SUCCESS;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryBoolValue( bool* value ) const\r\n{\r\n    if ( XMLUtil::ToBool( Value(), value )) {\r\n        return XML_SUCCESS;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryFloatValue( float* value ) const\r\n{\r\n    if ( XMLUtil::ToFloat( Value(), value )) {\r\n        return XML_SUCCESS;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryDoubleValue( double* value ) const\r\n{\r\n    if ( XMLUtil::ToDouble( Value(), value )) {\r\n        return XML_SUCCESS;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( const char* v )\r\n{\r\n    _value.SetStr( v );\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( int v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( unsigned v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute(int64_t v)\r\n{\r\n\tchar buf[BUF_SIZE];\r\n\tXMLUtil::ToStr(v, buf, BUF_SIZE);\r\n\t_value.SetStr(buf);\r\n}\r\n\r\nvoid XMLAttribute::SetAttribute(uint64_t v)\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr(v, buf, BUF_SIZE);\r\n    _value.SetStr(buf);\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( bool v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\nvoid XMLAttribute::SetAttribute( double v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\nvoid XMLAttribute::SetAttribute( float v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\n\r\n// --------- XMLElement ---------- //\r\nXMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),\r\n    _closingType( OPEN ),\r\n    _rootAttribute( 0 )\r\n{\r\n}\r\n\r\n\r\nXMLElement::~XMLElement()\r\n{\r\n    while( _rootAttribute ) {\r\n        XMLAttribute* next = _rootAttribute->_next;\r\n        DeleteAttribute( _rootAttribute );\r\n        _rootAttribute = next;\r\n    }\r\n}\r\n\r\n\r\nconst XMLAttribute* XMLElement::FindAttribute( const char* name ) const\r\n{\r\n    for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {\r\n        if ( XMLUtil::StringEqual( a->Name(), name ) ) {\r\n            return a;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst char* XMLElement::Attribute( const char* name, const char* value ) const\r\n{\r\n    const XMLAttribute* a = FindAttribute( name );\r\n    if ( !a ) {\r\n        return 0;\r\n    }\r\n    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {\r\n        return a->Value();\r\n    }\r\n    return 0;\r\n}\r\n\r\nint XMLElement::IntAttribute(const char* name, int defaultValue) const\r\n{\r\n\tint i = defaultValue;\r\n\tQueryIntAttribute(name, &i);\r\n\treturn i;\r\n}\r\n\r\nunsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const\r\n{\r\n\tunsigned i = defaultValue;\r\n\tQueryUnsignedAttribute(name, &i);\r\n\treturn i;\r\n}\r\n\r\nint64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const\r\n{\r\n\tint64_t i = defaultValue;\r\n\tQueryInt64Attribute(name, &i);\r\n\treturn i;\r\n}\r\n\r\nuint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const\r\n{\r\n\tuint64_t i = defaultValue;\r\n\tQueryUnsigned64Attribute(name, &i);\r\n\treturn i;\r\n}\r\n\r\nbool XMLElement::BoolAttribute(const char* name, bool defaultValue) const\r\n{\r\n\tbool b = defaultValue;\r\n\tQueryBoolAttribute(name, &b);\r\n\treturn b;\r\n}\r\n\r\ndouble XMLElement::DoubleAttribute(const char* name, double defaultValue) const\r\n{\r\n\tdouble d = defaultValue;\r\n\tQueryDoubleAttribute(name, &d);\r\n\treturn d;\r\n}\r\n\r\nfloat XMLElement::FloatAttribute(const char* name, float defaultValue) const\r\n{\r\n\tfloat f = defaultValue;\r\n\tQueryFloatAttribute(name, &f);\r\n\treturn f;\r\n}\r\n\r\nconst char* XMLElement::GetText() const\r\n{\r\n    /* skip comment node */\r\n    const XMLNode* node = FirstChild();\r\n    while (node) {\r\n        if (node->ToComment()) {\r\n            node = node->NextSibling();\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n\r\n    if ( node && node->ToText() ) {\r\n        return node->Value();\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nvoid\tXMLElement::SetText( const char* inText )\r\n{\r\n\tif ( FirstChild() && FirstChild()->ToText() )\r\n\t\tFirstChild()->SetValue( inText );\r\n\telse {\r\n\t\tXMLText*\ttheText = GetDocument()->NewText( inText );\r\n\t\tInsertFirstChild( theText );\r\n\t}\r\n}\r\n\r\n\r\nvoid XMLElement::SetText( int v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    SetText( buf );\r\n}\r\n\r\n\r\nvoid XMLElement::SetText( unsigned v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    SetText( buf );\r\n}\r\n\r\n\r\nvoid XMLElement::SetText(int64_t v)\r\n{\r\n\tchar buf[BUF_SIZE];\r\n\tXMLUtil::ToStr(v, buf, BUF_SIZE);\r\n\tSetText(buf);\r\n}\r\n\r\nvoid XMLElement::SetText(uint64_t v) {\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr(v, buf, BUF_SIZE);\r\n    SetText(buf);\r\n}\r\n\r\n\r\nvoid XMLElement::SetText( bool v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    SetText( buf );\r\n}\r\n\r\n\r\nvoid XMLElement::SetText( float v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    SetText( buf );\r\n}\r\n\r\n\r\nvoid XMLElement::SetText( double v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    SetText( buf );\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryIntText( int* ival ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->Value();\r\n        if ( XMLUtil::ToInt( t, ival ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryUnsignedText( unsigned* uval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->Value();\r\n        if ( XMLUtil::ToUnsigned( t, uval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryInt64Text(int64_t* ival) const\r\n{\r\n\tif (FirstChild() && FirstChild()->ToText()) {\r\n\t\tconst char* t = FirstChild()->Value();\r\n\t\tif (XMLUtil::ToInt64(t, ival)) {\r\n\t\t\treturn XML_SUCCESS;\r\n\t\t}\r\n\t\treturn XML_CAN_NOT_CONVERT_TEXT;\r\n\t}\r\n\treturn XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryUnsigned64Text(uint64_t* uval) const\r\n{\r\n    if(FirstChild() && FirstChild()->ToText()) {\r\n        const char* t = FirstChild()->Value();\r\n        if(XMLUtil::ToUnsigned64(t, uval)) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryBoolText( bool* bval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->Value();\r\n        if ( XMLUtil::ToBool( t, bval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryDoubleText( double* dval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->Value();\r\n        if ( XMLUtil::ToDouble( t, dval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryFloatText( float* fval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->Value();\r\n        if ( XMLUtil::ToFloat( t, fval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\nint XMLElement::IntText(int defaultValue) const\r\n{\r\n\tint i = defaultValue;\r\n\tQueryIntText(&i);\r\n\treturn i;\r\n}\r\n\r\nunsigned XMLElement::UnsignedText(unsigned defaultValue) const\r\n{\r\n\tunsigned i = defaultValue;\r\n\tQueryUnsignedText(&i);\r\n\treturn i;\r\n}\r\n\r\nint64_t XMLElement::Int64Text(int64_t defaultValue) const\r\n{\r\n\tint64_t i = defaultValue;\r\n\tQueryInt64Text(&i);\r\n\treturn i;\r\n}\r\n\r\nuint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const\r\n{\r\n\tuint64_t i = defaultValue;\r\n\tQueryUnsigned64Text(&i);\r\n\treturn i;\r\n}\r\n\r\nbool XMLElement::BoolText(bool defaultValue) const\r\n{\r\n\tbool b = defaultValue;\r\n\tQueryBoolText(&b);\r\n\treturn b;\r\n}\r\n\r\ndouble XMLElement::DoubleText(double defaultValue) const\r\n{\r\n\tdouble d = defaultValue;\r\n\tQueryDoubleText(&d);\r\n\treturn d;\r\n}\r\n\r\nfloat XMLElement::FloatText(float defaultValue) const\r\n{\r\n\tfloat f = defaultValue;\r\n\tQueryFloatText(&f);\r\n\treturn f;\r\n}\r\n\r\n\r\nXMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )\r\n{\r\n    XMLAttribute* last = 0;\r\n    XMLAttribute* attrib = 0;\r\n    for( attrib = _rootAttribute;\r\n            attrib;\r\n            last = attrib, attrib = attrib->_next ) {\r\n        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {\r\n            break;\r\n        }\r\n    }\r\n    if ( !attrib ) {\r\n        attrib = CreateAttribute();\r\n        TIXMLASSERT( attrib );\r\n        if ( last ) {\r\n            TIXMLASSERT( last->_next == 0 );\r\n            last->_next = attrib;\r\n        }\r\n        else {\r\n            TIXMLASSERT( _rootAttribute == 0 );\r\n            _rootAttribute = attrib;\r\n        }\r\n        attrib->SetName( name );\r\n    }\r\n    return attrib;\r\n}\r\n\r\n\r\nvoid XMLElement::DeleteAttribute( const char* name )\r\n{\r\n    XMLAttribute* prev = 0;\r\n    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {\r\n        if ( XMLUtil::StringEqual( name, a->Name() ) ) {\r\n            if ( prev ) {\r\n                prev->_next = a->_next;\r\n            }\r\n            else {\r\n                _rootAttribute = a->_next;\r\n            }\r\n            DeleteAttribute( a );\r\n            break;\r\n        }\r\n        prev = a;\r\n    }\r\n}\r\n\r\n\r\nchar* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )\r\n{\r\n    XMLAttribute* prevAttribute = 0;\r\n\r\n    // Read the attributes.\r\n    while( p ) {\r\n        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );\r\n        if ( !(*p) ) {\r\n            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, \"XMLElement name=%s\", Name() );\r\n            return 0;\r\n        }\r\n\r\n        // attribute.\r\n        if (XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {\r\n            XMLAttribute* attrib = CreateAttribute();\r\n            TIXMLASSERT( attrib );\r\n            attrib->_parseLineNum = _document->_parseCurLineNum;\r\n\r\n            const int attrLineNum = attrib->_parseLineNum;\r\n\r\n            p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );\r\n            if ( !p || Attribute( attrib->Name() ) ) {\r\n                DeleteAttribute( attrib );\r\n                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, \"XMLElement name=%s\", Name() );\r\n                return 0;\r\n            }\r\n            // There is a minor bug here: if the attribute in the source xml\r\n            // document is duplicated, it will not be detected and the\r\n            // attribute will be doubly added. However, tracking the 'prevAttribute'\r\n            // avoids re-scanning the attribute list. Preferring performance for\r\n            // now, may reconsider in the future.\r\n            if ( prevAttribute ) {\r\n                TIXMLASSERT( prevAttribute->_next == 0 );\r\n                prevAttribute->_next = attrib;\r\n            }\r\n            else {\r\n                TIXMLASSERT( _rootAttribute == 0 );\r\n                _rootAttribute = attrib;\r\n            }\r\n            prevAttribute = attrib;\r\n        }\r\n        // end of the tag\r\n        else if ( *p == '>' ) {\r\n            ++p;\r\n            break;\r\n        }\r\n        // end of the tag\r\n        else if ( *p == '/' && *(p+1) == '>' ) {\r\n            _closingType = CLOSED;\r\n            return p+2;\t// done; sealed element.\r\n        }\r\n        else {\r\n            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );\r\n            return 0;\r\n        }\r\n    }\r\n    return p;\r\n}\r\n\r\nvoid XMLElement::DeleteAttribute( XMLAttribute* attribute )\r\n{\r\n    if ( attribute == 0 ) {\r\n        return;\r\n    }\r\n    MemPool* pool = attribute->_memPool;\r\n    attribute->~XMLAttribute();\r\n    pool->Free( attribute );\r\n}\r\n\r\nXMLAttribute* XMLElement::CreateAttribute()\r\n{\r\n    TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );\r\n    XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();\r\n    TIXMLASSERT( attrib );\r\n    attrib->_memPool = &_document->_attributePool;\r\n    attrib->_memPool->SetTracked();\r\n    return attrib;\r\n}\r\n\r\n\r\nXMLElement* XMLElement::InsertNewChildElement(const char* name)\r\n{\r\n    XMLElement* node = _document->NewElement(name);\r\n    return InsertEndChild(node) ? node : 0;\r\n}\r\n\r\nXMLComment* XMLElement::InsertNewComment(const char* comment)\r\n{\r\n    XMLComment* node = _document->NewComment(comment);\r\n    return InsertEndChild(node) ? node : 0;\r\n}\r\n\r\nXMLText* XMLElement::InsertNewText(const char* text)\r\n{\r\n    XMLText* node = _document->NewText(text);\r\n    return InsertEndChild(node) ? node : 0;\r\n}\r\n\r\nXMLDeclaration* XMLElement::InsertNewDeclaration(const char* text)\r\n{\r\n    XMLDeclaration* node = _document->NewDeclaration(text);\r\n    return InsertEndChild(node) ? node : 0;\r\n}\r\n\r\nXMLUnknown* XMLElement::InsertNewUnknown(const char* text)\r\n{\r\n    XMLUnknown* node = _document->NewUnknown(text);\r\n    return InsertEndChild(node) ? node : 0;\r\n}\r\n\r\n\r\n\r\n//\r\n//\t<ele></ele>\r\n//\t<ele>foo<b>bar</b></ele>\r\n//\r\nchar* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )\r\n{\r\n    // Read the element name.\r\n    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );\r\n\r\n    // The closing element is the </element> form. It is\r\n    // parsed just like a regular element then deleted from\r\n    // the DOM.\r\n    if ( *p == '/' ) {\r\n        _closingType = CLOSING;\r\n        ++p;\r\n    }\r\n\r\n    p = _value.ParseName( p );\r\n    if ( _value.Empty() ) {\r\n        return 0;\r\n    }\r\n\r\n    p = ParseAttributes( p, curLineNumPtr );\r\n    if ( !p || !*p || _closingType != OPEN ) {\r\n        return p;\r\n    }\r\n\r\n    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );\r\n    return p;\r\n}\r\n\r\n\r\n\r\nXMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLElement* element = doc->NewElement( Value() );\t\t\t\t\t// fixme: this will always allocate memory. Intern?\r\n    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {\r\n        element->SetAttribute( a->Name(), a->Value() );\t\t\t\t\t// fixme: this will always allocate memory. Intern?\r\n    }\r\n    return element;\r\n}\r\n\r\n\r\nbool XMLElement::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    TIXMLASSERT( compare );\r\n    const XMLElement* other = compare->ToElement();\r\n    if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {\r\n\r\n        const XMLAttribute* a=FirstAttribute();\r\n        const XMLAttribute* b=other->FirstAttribute();\r\n\r\n        while ( a && b ) {\r\n            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {\r\n                return false;\r\n            }\r\n            a = a->Next();\r\n            b = b->Next();\r\n        }\r\n        if ( a || b ) {\r\n            // different count\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool XMLElement::Accept( XMLVisitor* visitor ) const\r\n{\r\n    TIXMLASSERT( visitor );\r\n    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {\r\n        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {\r\n            if ( !node->Accept( visitor ) ) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return visitor->VisitExit( *this );\r\n}\r\n\r\n\r\n// --------- XMLDocument ----------- //\r\n\r\n// Warning: List must match 'enum XMLError'\r\nconst char* XMLDocument::_errorNames[XML_ERROR_COUNT] = {\r\n    \"XML_SUCCESS\",\r\n    \"XML_NO_ATTRIBUTE\",\r\n    \"XML_WRONG_ATTRIBUTE_TYPE\",\r\n    \"XML_ERROR_FILE_NOT_FOUND\",\r\n    \"XML_ERROR_FILE_COULD_NOT_BE_OPENED\",\r\n    \"XML_ERROR_FILE_READ_ERROR\",\r\n    \"XML_ERROR_PARSING_ELEMENT\",\r\n    \"XML_ERROR_PARSING_ATTRIBUTE\",\r\n    \"XML_ERROR_PARSING_TEXT\",\r\n    \"XML_ERROR_PARSING_CDATA\",\r\n    \"XML_ERROR_PARSING_COMMENT\",\r\n    \"XML_ERROR_PARSING_DECLARATION\",\r\n    \"XML_ERROR_PARSING_UNKNOWN\",\r\n    \"XML_ERROR_EMPTY_DOCUMENT\",\r\n    \"XML_ERROR_MISMATCHED_ELEMENT\",\r\n    \"XML_ERROR_PARSING\",\r\n    \"XML_CAN_NOT_CONVERT_TEXT\",\r\n    \"XML_NO_TEXT_NODE\",\r\n\t\"XML_ELEMENT_DEPTH_EXCEEDED\"\r\n};\r\n\r\n\r\nXMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :\r\n    XMLNode( 0 ),\r\n    _writeBOM( false ),\r\n    _processEntities( processEntities ),\r\n    _errorID(XML_SUCCESS),\r\n    _whitespaceMode( whitespaceMode ),\r\n    _errorStr(),\r\n    _errorLineNum( 0 ),\r\n    _charBuffer( 0 ),\r\n    _parseCurLineNum( 0 ),\r\n\t_parsingDepth(0),\r\n    _unlinked(),\r\n    _elementPool(),\r\n    _attributePool(),\r\n    _textPool(),\r\n    _commentPool()\r\n{\r\n    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)\r\n    _document = this;\r\n}\r\n\r\n\r\nXMLDocument::~XMLDocument()\r\n{\r\n    Clear();\r\n}\r\n\r\n\r\nvoid XMLDocument::MarkInUse(const XMLNode* const node)\r\n{\r\n\tTIXMLASSERT(node);\r\n\tTIXMLASSERT(node->_parent == 0);\r\n\r\n\tfor (size_t i = 0; i < _unlinked.Size(); ++i) {\r\n\t\tif (node == _unlinked[i]) {\r\n\t\t\t_unlinked.SwapRemove(i);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid XMLDocument::Clear()\r\n{\r\n    DeleteChildren();\r\n\twhile( _unlinked.Size()) {\r\n\t\tDeleteNode(_unlinked[0]);\t// Will remove from _unlinked as part of delete.\r\n\t}\r\n\r\n#ifdef TINYXML2_DEBUG\r\n    const bool hadError = Error();\r\n#endif\r\n    ClearError();\r\n\r\n    delete [] _charBuffer;\r\n    _charBuffer = 0;\r\n\t_parsingDepth = 0;\r\n\r\n#if 0\r\n    _textPool.Trace( \"text\" );\r\n    _elementPool.Trace( \"element\" );\r\n    _commentPool.Trace( \"comment\" );\r\n    _attributePool.Trace( \"attribute\" );\r\n#endif\r\n\r\n#ifdef TINYXML2_DEBUG\r\n    if ( !hadError ) {\r\n        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );\r\n        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );\r\n        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );\r\n        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );\r\n    }\r\n#endif\r\n}\r\n\r\n\r\nvoid XMLDocument::DeepCopy(XMLDocument* target) const\r\n{\r\n\tTIXMLASSERT(target);\r\n    if (target == this) {\r\n        return; // technically success - a no-op.\r\n    }\r\n\r\n\ttarget->Clear();\r\n\tfor (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {\r\n\t\ttarget->InsertEndChild(node->DeepClone(target));\r\n\t}\r\n}\r\n\r\nXMLElement* XMLDocument::NewElement( const char* name )\r\n{\r\n    XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );\r\n    ele->SetName( name );\r\n    return ele;\r\n}\r\n\r\n\r\nXMLComment* XMLDocument::NewComment( const char* str )\r\n{\r\n    XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );\r\n    comment->SetValue( str );\r\n    return comment;\r\n}\r\n\r\n\r\nXMLText* XMLDocument::NewText( const char* str )\r\n{\r\n    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );\r\n    text->SetValue( str );\r\n    return text;\r\n}\r\n\r\n\r\nXMLDeclaration* XMLDocument::NewDeclaration( const char* str )\r\n{\r\n    XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );\r\n    dec->SetValue( str ? str : \"xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"\" );\r\n    return dec;\r\n}\r\n\r\n\r\nXMLUnknown* XMLDocument::NewUnknown( const char* str )\r\n{\r\n    XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );\r\n    unk->SetValue( str );\r\n    return unk;\r\n}\r\n\r\nstatic FILE* callfopen( const char* filepath, const char* mode )\r\n{\r\n    TIXMLASSERT( filepath );\r\n    TIXMLASSERT( mode );\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)\r\n    FILE* fp = 0;\r\n    const errno_t err = fopen_s( &fp, filepath, mode );\r\n    if ( err ) {\r\n        return 0;\r\n    }\r\n#else\r\n    FILE* fp = fopen( filepath, mode );\r\n#endif\r\n    return fp;\r\n}\r\n\r\nvoid XMLDocument::DeleteNode( XMLNode* node )\t{\r\n    TIXMLASSERT( node );\r\n    TIXMLASSERT(node->_document == this );\r\n    if (node->_parent) {\r\n        node->_parent->DeleteChild( node );\r\n    }\r\n    else {\r\n        // Isn't in the tree.\r\n        // Use the parent delete.\r\n        // Also, we need to mark it tracked: we 'know'\r\n        // it was never used.\r\n        node->_memPool->SetTracked();\r\n        // Call the static XMLNode version:\r\n        XMLNode::DeleteNode(node);\r\n    }\r\n}\r\n\r\n\r\nXMLError XMLDocument::LoadFile( const char* filename )\r\n{\r\n    if ( !filename ) {\r\n        TIXMLASSERT( false );\r\n        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, \"filename=<null>\" );\r\n        return _errorID;\r\n    }\r\n\r\n    Clear();\r\n    FILE* fp = callfopen( filename, \"rb\" );\r\n    if ( !fp ) {\r\n        SetError( XML_ERROR_FILE_NOT_FOUND, 0, \"filename=%s\", filename );\r\n        return _errorID;\r\n    }\r\n    LoadFile( fp );\r\n    fclose( fp );\r\n    return _errorID;\r\n}\r\n\r\nXMLError XMLDocument::LoadFile( FILE* fp )\r\n{\r\n    Clear();\r\n\r\n    TIXML_FSEEK( fp, 0, SEEK_SET );\r\n    if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    TIXML_FSEEK( fp, 0, SEEK_END );\r\n\r\n    unsigned long long filelength;\r\n    {\r\n        const long long fileLengthSigned = TIXML_FTELL( fp );\r\n        TIXML_FSEEK( fp, 0, SEEK_SET );\r\n        if ( fileLengthSigned == -1L ) {\r\n            SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n            return _errorID;\r\n        }\r\n        TIXMLASSERT( fileLengthSigned >= 0 );\r\n        filelength = static_cast<unsigned long long>(fileLengthSigned);\r\n    }\r\n\r\n    const size_t maxSizeT = static_cast<size_t>(-1);\r\n    // We'll do the comparison as an unsigned long long, because that's guaranteed to be at\r\n    // least 8 bytes, even on a 32-bit platform.\r\n    if ( filelength >= static_cast<unsigned long long>(maxSizeT) ) {\r\n        // Cannot handle files which won't fit in buffer together with null terminator\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    if ( filelength == 0 ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    const size_t size = static_cast<size_t>(filelength);\r\n    TIXMLASSERT( _charBuffer == 0 );\r\n    _charBuffer = new char[size+1];\r\n    const size_t read = fread( _charBuffer, 1, size, fp );\r\n    if ( read != size ) {\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    _charBuffer[size] = 0;\r\n\r\n    Parse();\r\n    return _errorID;\r\n}\r\n\r\n\r\nXMLError XMLDocument::SaveFile( const char* filename, bool compact )\r\n{\r\n    if ( !filename ) {\r\n        TIXMLASSERT( false );\r\n        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, \"filename=<null>\" );\r\n        return _errorID;\r\n    }\r\n\r\n    FILE* fp = callfopen( filename, \"w\" );\r\n    if ( !fp ) {\r\n        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, \"filename=%s\", filename );\r\n        return _errorID;\r\n    }\r\n    SaveFile(fp, compact);\r\n    fclose( fp );\r\n    return _errorID;\r\n}\r\n\r\n\r\nXMLError XMLDocument::SaveFile( FILE* fp, bool compact )\r\n{\r\n    // Clear any error from the last save, otherwise it will get reported\r\n    // for *this* call.\r\n    ClearError();\r\n    XMLPrinter stream( fp, compact );\r\n    Print( &stream );\r\n    return _errorID;\r\n}\r\n\r\n\r\nXMLError XMLDocument::Parse( const char* xml, size_t nBytes )\r\n{\r\n    Clear();\r\n\r\n    if ( nBytes == 0 || !xml || !*xml ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return _errorID;\r\n    }\r\n    if ( nBytes == static_cast<size_t>(-1) ) {\r\n        nBytes = strlen( xml );\r\n    }\r\n    TIXMLASSERT( _charBuffer == 0 );\r\n    _charBuffer = new char[ nBytes+1 ];\r\n    memcpy( _charBuffer, xml, nBytes );\r\n    _charBuffer[nBytes] = 0;\r\n\r\n    Parse();\r\n    if ( Error() ) {\r\n        // clean up now essentially dangling memory.\r\n        // and the parse fail can put objects in the\r\n        // pools that are dead and inaccessible.\r\n        DeleteChildren();\r\n        _elementPool.Clear();\r\n        _attributePool.Clear();\r\n        _textPool.Clear();\r\n        _commentPool.Clear();\r\n    }\r\n    return _errorID;\r\n}\r\n\r\n\r\nvoid XMLDocument::Print( XMLPrinter* streamer ) const\r\n{\r\n    if ( streamer ) {\r\n        Accept( streamer );\r\n    }\r\n    else {\r\n        XMLPrinter stdoutStreamer( stdout );\r\n        Accept( &stdoutStreamer );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLDocument::ClearError() {\r\n    _errorID = XML_SUCCESS;\r\n    _errorLineNum = 0;\r\n    _errorStr.Reset();\r\n}\r\n\r\n\r\nvoid XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )\r\n{\r\n    TIXMLASSERT(error >= 0 && error < XML_ERROR_COUNT);\r\n    _errorID = error;\r\n    _errorLineNum = lineNum;\r\n\t_errorStr.Reset();\r\n\r\n    const size_t BUFFER_SIZE = 1000;\r\n    char* buffer = new char[BUFFER_SIZE];\r\n\r\n    TIXMLASSERT(sizeof(error) <= sizeof(int));\r\n    TIXML_SNPRINTF(buffer, BUFFER_SIZE, \"Error=%s ErrorID=%d (0x%x) Line number=%d\",\r\n        ErrorIDToName(error), static_cast<int>(error), static_cast<unsigned int>(error), lineNum);\r\n\r\n\tif (format) {\r\n\t\tsize_t len = strlen(buffer);\r\n\t\tTIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, \": \");\r\n\t\tlen = strlen(buffer);\r\n\r\n\t\tva_list va;\r\n\t\tva_start(va, format);\r\n\t\tTIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);\r\n\t\tva_end(va);\r\n\t}\r\n\t_errorStr.SetStr(buffer);\r\n\tdelete[] buffer;\r\n}\r\n\r\n\r\n/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID)\r\n{\r\n\tTIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );\r\n    const char* errorName = _errorNames[errorID];\r\n    TIXMLASSERT( errorName && errorName[0] );\r\n    return errorName;\r\n}\r\n\r\nconst char* XMLDocument::ErrorStr() const\r\n{\r\n\treturn _errorStr.Empty() ? \"\" : _errorStr.GetStr();\r\n}\r\n\r\n\r\nvoid XMLDocument::PrintError() const\r\n{\r\n    printf(\"%s\\n\", ErrorStr());\r\n}\r\n\r\nconst char* XMLDocument::ErrorName() const\r\n{\r\n    return ErrorIDToName(_errorID);\r\n}\r\n\r\nvoid XMLDocument::Parse()\r\n{\r\n    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously\r\n    TIXMLASSERT( _charBuffer );\r\n    _parseCurLineNum = 1;\r\n    _parseLineNum = 1;\r\n    char* p = _charBuffer;\r\n    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );\r\n    p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );\r\n    if ( !*p ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return;\r\n    }\r\n    ParseDeep(p, 0, &_parseCurLineNum );\r\n}\r\n\r\nvoid XMLDocument::PushDepth()\r\n{\r\n\t_parsingDepth++;\r\n\tif (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {\r\n\t\tSetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, \"Element nesting is too deep.\" );\r\n\t}\r\n}\r\n\r\nvoid XMLDocument::PopDepth()\r\n{\r\n\tTIXMLASSERT(_parsingDepth > 0);\r\n\t--_parsingDepth;\r\n}\r\n\r\nXMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :\r\n    _elementJustOpened( false ),\r\n    _stack(),\r\n    _firstElement( true ),\r\n    _fp( file ),\r\n    _depth( depth ),\r\n    _textDepth( -1 ),\r\n    _processEntities( true ),\r\n    _compactMode( compact ),\r\n    _buffer()\r\n{\r\n    for( int i=0; i<ENTITY_RANGE; ++i ) {\r\n        _entityFlag[i] = false;\r\n        _restrictedEntityFlag[i] = false;\r\n    }\r\n    for( int i=0; i<NUM_ENTITIES; ++i ) {\r\n        const char entityValue = entities[i].value;\r\n        const unsigned char flagIndex = static_cast<unsigned char>(entityValue);\r\n        TIXMLASSERT( flagIndex < ENTITY_RANGE );\r\n        _entityFlag[flagIndex] = true;\r\n    }\r\n    _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;\r\n    _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;\r\n    _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;\t// not required, but consistency is nice\r\n    _buffer.Push( 0 );\r\n}\r\n\r\n\r\nvoid XMLPrinter::Print( const char* format, ... )\r\n{\r\n    va_list     va;\r\n    va_start( va, format );\r\n\r\n    if ( _fp ) {\r\n        vfprintf( _fp, format, va );\r\n    }\r\n    else {\r\n        const int len = TIXML_VSCPRINTF( format, va );\r\n        // Close out and re-start the va-args\r\n        va_end( va );\r\n        TIXMLASSERT( len >= 0 );\r\n        va_start( va, format );\r\n        TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );\r\n        char* p = _buffer.PushArr( len ) - 1;\t// back up over the null terminator.\r\n\t\tTIXML_VSNPRINTF( p, len+1, format, va );\r\n    }\r\n    va_end( va );\r\n}\r\n\r\n\r\nvoid XMLPrinter::Write( const char* data, size_t size )\r\n{\r\n    if ( _fp ) {\r\n        fwrite ( data , sizeof(char), size, _fp);\r\n    }\r\n    else {\r\n        char* p = _buffer.PushArr( static_cast<int>(size) ) - 1;   // back up over the null terminator.\r\n        memcpy( p, data, size );\r\n        p[size] = 0;\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::Putc( char ch )\r\n{\r\n    if ( _fp ) {\r\n        fputc ( ch, _fp);\r\n    }\r\n    else {\r\n        char* p = _buffer.PushArr( sizeof(char) ) - 1;   // back up over the null terminator.\r\n        p[0] = ch;\r\n        p[1] = 0;\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::PrintSpace( int depth )\r\n{\r\n    for( int i=0; i<depth; ++i ) {\r\n        Write( \"    \" );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::PrintString( const char* p, bool restricted )\r\n{\r\n    // Look for runs of bytes between entities to print.\r\n    const char* q = p;\r\n\r\n    if ( _processEntities ) {\r\n        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;\r\n        while ( *q ) {\r\n            TIXMLASSERT( p <= q );\r\n            // Remember, char is sometimes signed. (How many times has that bitten me?)\r\n            if ( *q > 0 && *q < ENTITY_RANGE ) {\r\n                // Check for entities. If one is found, flush\r\n                // the stream up until the entity, write the\r\n                // entity, and keep looking.\r\n                if ( flag[static_cast<unsigned char>(*q)] ) {\r\n                    while ( p < q ) {\r\n                        const size_t delta = q - p;\r\n                        const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);\r\n                        Write( p, toPrint );\r\n                        p += toPrint;\r\n                    }\r\n                    bool entityPatternPrinted = false;\r\n                    for( int i=0; i<NUM_ENTITIES; ++i ) {\r\n                        if ( entities[i].value == *q ) {\r\n                            Putc( '&' );\r\n                            Write( entities[i].pattern, entities[i].length );\r\n                            Putc( ';' );\r\n                            entityPatternPrinted = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if ( !entityPatternPrinted ) {\r\n                        // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release\r\n                        TIXMLASSERT( false );\r\n                    }\r\n                    ++p;\r\n                }\r\n            }\r\n            ++q;\r\n            TIXMLASSERT( p <= q );\r\n        }\r\n        // Flush the remaining string. This will be the entire\r\n        // string if an entity wasn't found.\r\n        if ( p < q ) {\r\n            const size_t delta = q - p;\r\n            const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);\r\n            Write( p, toPrint );\r\n        }\r\n    }\r\n    else {\r\n        Write( p );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushHeader( bool writeBOM, bool writeDec )\r\n{\r\n    if ( writeBOM ) {\r\n        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };\r\n        Write( reinterpret_cast< const char* >( bom ) );\r\n    }\r\n    if ( writeDec ) {\r\n        PushDeclaration( \"xml version=\\\"1.0\\\"\" );\r\n    }\r\n}\r\n\r\nvoid XMLPrinter::PrepareForNewNode( bool compactMode )\r\n{\r\n    SealElementIfJustOpened();\r\n\r\n    if ( compactMode ) {\r\n        return;\r\n    }\r\n\r\n    if ( _firstElement ) {\r\n        PrintSpace (_depth);\r\n    } else if ( _textDepth < 0) {\r\n        Putc( '\\n' );\r\n        PrintSpace( _depth );\r\n    }\r\n\r\n    _firstElement = false;\r\n}\r\n\r\nvoid XMLPrinter::OpenElement( const char* name, bool compactMode )\r\n{\r\n    PrepareForNewNode( compactMode );\r\n    _stack.Push( name );\r\n\r\n    Write ( \"<\" );\r\n    Write ( name );\r\n\r\n    _elementJustOpened = true;\r\n    ++_depth;\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, const char* value )\r\n{\r\n    TIXMLASSERT( _elementJustOpened );\r\n    Putc ( ' ' );\r\n    Write( name );\r\n    Write( \"=\\\"\" );\r\n    PrintString( value, false );\r\n    Putc ( '\\\"' );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, int v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, unsigned v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute(const char* name, int64_t v)\r\n{\r\n\tchar buf[BUF_SIZE];\r\n\tXMLUtil::ToStr(v, buf, BUF_SIZE);\r\n\tPushAttribute(name, buf);\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute(const char* name, uint64_t v)\r\n{\r\n\tchar buf[BUF_SIZE];\r\n\tXMLUtil::ToStr(v, buf, BUF_SIZE);\r\n\tPushAttribute(name, buf);\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, bool v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, double v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::CloseElement( bool compactMode )\r\n{\r\n    --_depth;\r\n    const char* name = _stack.Pop();\r\n\r\n    if ( _elementJustOpened ) {\r\n        Write( \"/>\" );\r\n    }\r\n    else {\r\n        if ( _textDepth < 0 && !compactMode) {\r\n            Putc( '\\n' );\r\n            PrintSpace( _depth );\r\n        }\r\n        Write ( \"</\" );\r\n        Write ( name );\r\n        Write ( \">\" );\r\n    }\r\n\r\n    if ( _textDepth == _depth ) {\r\n        _textDepth = -1;\r\n    }\r\n    if ( _depth == 0 && !compactMode) {\r\n        Putc( '\\n' );\r\n    }\r\n    _elementJustOpened = false;\r\n}\r\n\r\n\r\nvoid XMLPrinter::SealElementIfJustOpened()\r\n{\r\n    if ( !_elementJustOpened ) {\r\n        return;\r\n    }\r\n    _elementJustOpened = false;\r\n    Putc( '>' );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( const char* text, bool cdata )\r\n{\r\n    _textDepth = _depth-1;\r\n\r\n    SealElementIfJustOpened();\r\n    if ( cdata ) {\r\n        Write( \"<![CDATA[\" );\r\n        Write( text );\r\n        Write( \"]]>\" );\r\n    }\r\n    else {\r\n        PrintString( text, true );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( int64_t value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( uint64_t value )\r\n{\r\n\tchar buf[BUF_SIZE];\r\n\tXMLUtil::ToStr(value, buf, BUF_SIZE);\r\n\tPushText(buf, false);\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( int value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( unsigned value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( bool value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( float value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( double value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushComment( const char* comment )\r\n{\r\n    PrepareForNewNode( _compactMode );\r\n\r\n    Write( \"<!--\" );\r\n    Write( comment );\r\n    Write( \"-->\" );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushDeclaration( const char* value )\r\n{\r\n    PrepareForNewNode( _compactMode );\r\n\r\n    Write( \"<?\" );\r\n    Write( value );\r\n    Write( \"?>\" );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushUnknown( const char* value )\r\n{\r\n    PrepareForNewNode( _compactMode );\r\n\r\n    Write( \"<!\" );\r\n    Write( value );\r\n    Putc( '>' );\r\n}\r\n\r\n\r\nbool XMLPrinter::VisitEnter( const XMLDocument& doc )\r\n{\r\n    _processEntities = doc.ProcessEntities();\r\n    if ( doc.HasBOM() ) {\r\n        PushHeader( true, false );\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )\r\n{\r\n    const XMLElement* parentElem = 0;\r\n    if ( element.Parent() ) {\r\n        parentElem = element.Parent()->ToElement();\r\n    }\r\n    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;\r\n    OpenElement( element.Name(), compactMode );\r\n    while ( attribute ) {\r\n        PushAttribute( attribute->Name(), attribute->Value() );\r\n        attribute = attribute->Next();\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::VisitExit( const XMLElement& element )\r\n{\r\n    CloseElement( CompactMode(element) );\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::Visit( const XMLText& text )\r\n{\r\n    PushText( text.Value(), text.CData() );\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::Visit( const XMLComment& comment )\r\n{\r\n    PushComment( comment.Value() );\r\n    return true;\r\n}\r\n\r\nbool XMLPrinter::Visit( const XMLDeclaration& declaration )\r\n{\r\n    PushDeclaration( declaration.Value() );\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::Visit( const XMLUnknown& unknown )\r\n{\r\n    PushUnknown( unknown.Value() );\r\n    return true;\r\n}\r\n\r\n}   // namespace tinyxml2\r\n"
        },
        {
          "name": "tinyxml2.h",
          "type": "blob",
          "size": 72.720703125,
          "content": "/*\r\nOriginal code by Lee Thomason (www.grinninglizard.com)\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any\r\ndamages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you must\r\nnot claim that you wrote the original software. If you use this\r\nsoftware in a product, an acknowledgment in the product documentation\r\nwould be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#ifndef TINYXML2_INCLUDED\r\n#define TINYXML2_INCLUDED\r\n\r\n#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)\r\n#   include <ctype.h>\r\n#   include <limits.h>\r\n#   include <stdio.h>\r\n#   include <stdlib.h>\r\n#   include <string.h>\r\n#\tif defined(__PS3__)\r\n#\t\tinclude <stddef.h>\r\n#\tendif\r\n#else\r\n#   include <cctype>\r\n#   include <climits>\r\n#   include <cstdio>\r\n#   include <cstdlib>\r\n#   include <cstring>\r\n#endif\r\n#include <stdint.h>\r\n\r\n/*\r\n\tgcc:\r\n        g++ -Wall -DTINYXML2_DEBUG tinyxml2.cpp xmltest.cpp -o gccxmltest.exe\r\n\r\n    Formatting, Artistic Style:\r\n        AStyle.exe --style=1tbs --indent-switches --break-closing-brackets --indent-preprocessor tinyxml2.cpp tinyxml2.h\r\n*/\r\n\r\n#if defined( _DEBUG ) || defined (__DEBUG__)\r\n#   ifndef TINYXML2_DEBUG\r\n#       define TINYXML2_DEBUG\r\n#   endif\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#   pragma warning(push)\r\n#   pragma warning(disable: 4251)\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#   ifdef TINYXML2_EXPORT\r\n#       define TINYXML2_LIB __declspec(dllexport)\r\n#   elif defined(TINYXML2_IMPORT)\r\n#       define TINYXML2_LIB __declspec(dllimport)\r\n#   else\r\n#       define TINYXML2_LIB\r\n#   endif\r\n#elif __GNUC__ >= 4\r\n#   define TINYXML2_LIB __attribute__((visibility(\"default\")))\r\n#else\r\n#   define TINYXML2_LIB\r\n#endif\r\n\r\n\r\n#if !defined(TIXMLASSERT)\r\n#if defined(TINYXML2_DEBUG)\r\n#   if defined(_MSC_VER)\r\n#       // \"(void)0,\" is for suppressing C4127 warning in \"assert(false)\", \"assert(true)\" and the like\r\n#       define TIXMLASSERT( x )           do { if ( !((void)0,(x))) { __debugbreak(); } } while(false)\r\n#   elif defined (ANDROID_NDK)\r\n#       include <android/log.h>\r\n#       define TIXMLASSERT( x )           do { if ( !(x)) { __android_log_assert( \"assert\", \"grinliz\", \"ASSERT in '%s' at %d.\", __FILE__, __LINE__ ); } } while(false)\r\n#   else\r\n#       include <assert.h>\r\n#       define TIXMLASSERT                assert\r\n#   endif\r\n#else\r\n#   define TIXMLASSERT( x )               do {} while(false)\r\n#endif\r\n#endif\r\n\r\n/* Versioning, past 1.0.14:\r\n\thttp://semver.org/\r\n*/\r\nstatic const int TIXML2_MAJOR_VERSION = 10;\r\nstatic const int TIXML2_MINOR_VERSION = 0;\r\nstatic const int TIXML2_PATCH_VERSION = 0;\r\n\r\n#define TINYXML2_MAJOR_VERSION 10\r\n#define TINYXML2_MINOR_VERSION 0\r\n#define TINYXML2_PATCH_VERSION 0\r\n\r\n// A fixed element depth limit is problematic. There needs to be a\r\n// limit to avoid a stack overflow. However, that limit varies per\r\n// system, and the capacity of the stack. On the other hand, it's a trivial\r\n// attack that can result from ill, malicious, or even correctly formed XML,\r\n// so there needs to be a limit in place.\r\nstatic const int TINYXML2_MAX_ELEMENT_DEPTH = 500;\r\n\r\nnamespace tinyxml2\r\n{\r\nclass XMLDocument;\r\nclass XMLElement;\r\nclass XMLAttribute;\r\nclass XMLComment;\r\nclass XMLText;\r\nclass XMLDeclaration;\r\nclass XMLUnknown;\r\nclass XMLPrinter;\r\n\r\n/*\r\n\tA class that wraps strings. Normally stores the start and end\r\n\tpointers into the XML file itself, and will apply normalization\r\n\tand entity translation if actually read. Can also store (and memory\r\n\tmanage) a traditional char[]\r\n\r\n    Isn't clear why TINYXML2_LIB is needed; but seems to fix #719\r\n*/\r\nclass TINYXML2_LIB StrPair\r\n{\r\npublic:\r\n    enum Mode {\r\n        NEEDS_ENTITY_PROCESSING\t\t\t= 0x01,\r\n        NEEDS_NEWLINE_NORMALIZATION\t\t= 0x02,\r\n        NEEDS_WHITESPACE_COLLAPSING     = 0x04,\r\n\r\n        TEXT_ELEMENT\t\t            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,\r\n        TEXT_ELEMENT_LEAVE_ENTITIES\t\t= NEEDS_NEWLINE_NORMALIZATION,\r\n        ATTRIBUTE_NAME\t\t            = 0,\r\n        ATTRIBUTE_VALUE\t\t            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,\r\n        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,\r\n        COMMENT\t\t\t\t\t\t\t= NEEDS_NEWLINE_NORMALIZATION\r\n    };\r\n\r\n    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}\r\n    ~StrPair();\r\n\r\n    void Set( char* start, char* end, int flags ) {\r\n        TIXMLASSERT( start );\r\n        TIXMLASSERT( end );\r\n        Reset();\r\n        _start  = start;\r\n        _end    = end;\r\n        _flags  = flags | NEEDS_FLUSH;\r\n    }\r\n\r\n    const char* GetStr();\r\n\r\n    bool Empty() const {\r\n        return _start == _end;\r\n    }\r\n\r\n    void SetInternedStr( const char* str ) {\r\n        Reset();\r\n        _start = const_cast<char*>(str);\r\n    }\r\n\r\n    void SetStr( const char* str, int flags=0 );\r\n\r\n    char* ParseText( char* in, const char* endTag, int strFlags, int* curLineNumPtr );\r\n    char* ParseName( char* in );\r\n\r\n    void TransferTo( StrPair* other );\r\n\tvoid Reset();\r\n\r\nprivate:\r\n    void CollapseWhitespace();\r\n\r\n    enum {\r\n        NEEDS_FLUSH = 0x100,\r\n        NEEDS_DELETE = 0x200\r\n    };\r\n\r\n    int     _flags;\r\n    char*   _start;\r\n    char*   _end;\r\n\r\n    StrPair( const StrPair& other );\t// not supported\r\n    void operator=( const StrPair& other );\t// not supported, use TransferTo()\r\n};\r\n\r\n\r\n/*\r\n\tA dynamic array of Plain Old Data. Doesn't support constructors, etc.\r\n\tHas a small initial memory pool, so that low or no usage will not\r\n\tcause a call to new/delete\r\n*/\r\ntemplate <class T, size_t INITIAL_SIZE>\r\nclass DynArray\r\n{\r\npublic:\r\n    DynArray() :\r\n        _mem( _pool ),\r\n        _allocated( INITIAL_SIZE ),\r\n        _size( 0 )\r\n    {\r\n    }\r\n\r\n    ~DynArray() {\r\n        if ( _mem != _pool ) {\r\n            delete [] _mem;\r\n        }\r\n    }\r\n\r\n    void Clear() {\r\n        _size = 0;\r\n    }\r\n\r\n    void Push( T t ) {\r\n        TIXMLASSERT( _size < INT_MAX );\r\n        EnsureCapacity( _size+1 );\r\n        _mem[_size] = t;\r\n        ++_size;\r\n    }\r\n\r\n    T* PushArr( size_t count ) {\r\n        TIXMLASSERT( _size <= SIZE_MAX - count );\r\n        EnsureCapacity( _size+count );\r\n        T* ret = &_mem[_size];\r\n        _size += count;\r\n        return ret;\r\n    }\r\n\r\n    T Pop() {\r\n        TIXMLASSERT( _size > 0 );\r\n        --_size;\r\n        return _mem[_size];\r\n    }\r\n\r\n    void PopArr( size_t count ) {\r\n        TIXMLASSERT( _size >= count );\r\n        _size -= count;\r\n    }\r\n\r\n    bool Empty() const\t\t\t\t\t{\r\n        return _size == 0;\r\n    }\r\n\r\n    T& operator[](size_t i) {\r\n        TIXMLASSERT( i < _size );\r\n        return _mem[i];\r\n    }\r\n\r\n    const T& operator[](size_t i) const {\r\n        TIXMLASSERT( i < _size );\r\n        return _mem[i];\r\n    }\r\n\r\n    const T& PeekTop() const            {\r\n        TIXMLASSERT( _size > 0 );\r\n        return _mem[ _size - 1];\r\n    }\r\n\r\n    size_t Size() const {\r\n        TIXMLASSERT( _size >= 0 );\r\n        return _size;\r\n    }\r\n\r\n    size_t Capacity() const {\r\n        TIXMLASSERT( _allocated >= INITIAL_SIZE );\r\n        return _allocated;\r\n    }\r\n\r\n\tvoid SwapRemove(size_t i) {\r\n\t\tTIXMLASSERT(i < _size);\r\n\t\tTIXMLASSERT(_size > 0);\r\n\t\t_mem[i] = _mem[_size - 1];\r\n\t\t--_size;\r\n\t}\r\n\r\n    const T* Mem() const\t\t\t\t{\r\n        TIXMLASSERT( _mem );\r\n        return _mem;\r\n    }\r\n\r\n    T* Mem() {\r\n        TIXMLASSERT( _mem );\r\n        return _mem;\r\n    }\r\n\r\nprivate:\r\n    DynArray( const DynArray& ); // not supported\r\n    void operator=( const DynArray& ); // not supported\r\n\r\n    void EnsureCapacity( size_t cap ) {\r\n        TIXMLASSERT( cap > 0 );\r\n        if ( cap > _allocated ) {\r\n            TIXMLASSERT( cap <= SIZE_MAX / 2 / sizeof(T));\r\n            const size_t newAllocated = cap * 2;\r\n            T* newMem = new T[newAllocated];\r\n            TIXMLASSERT( newAllocated >= _size );\r\n            memcpy( newMem, _mem, sizeof(T) * _size );\t// warning: not using constructors, only works for PODs\r\n            if ( _mem != _pool ) {\r\n                delete [] _mem;\r\n            }\r\n            _mem = newMem;\r\n            _allocated = newAllocated;\r\n        }\r\n    }\r\n\r\n    T*  _mem;\r\n    T   _pool[INITIAL_SIZE];\r\n    size_t _allocated;\t\t// objects allocated\r\n    size_t _size;\t\t\t// number objects in use\r\n};\r\n\r\n\r\n/*\r\n\tParent virtual class of a pool for fast allocation\r\n\tand deallocation of objects.\r\n*/\r\nclass MemPool\r\n{\r\npublic:\r\n    MemPool() {}\r\n    virtual ~MemPool() {}\r\n\r\n    virtual size_t ItemSize() const = 0;\r\n    virtual void* Alloc() = 0;\r\n    virtual void Free( void* ) = 0;\r\n    virtual void SetTracked() = 0;\r\n};\r\n\r\n\r\n/*\r\n\tTemplate child class to create pools of the correct type.\r\n*/\r\ntemplate< size_t ITEM_SIZE >\r\nclass MemPoolT : public MemPool\r\n{\r\npublic:\r\n    MemPoolT() : _blockPtrs(), _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)\t{}\r\n    ~MemPoolT() {\r\n        MemPoolT< ITEM_SIZE >::Clear();\r\n    }\r\n\r\n    void Clear() {\r\n        // Delete the blocks.\r\n        while( !_blockPtrs.Empty()) {\r\n            Block* lastBlock = _blockPtrs.Pop();\r\n            delete lastBlock;\r\n        }\r\n        _root = 0;\r\n        _currentAllocs = 0;\r\n        _nAllocs = 0;\r\n        _maxAllocs = 0;\r\n        _nUntracked = 0;\r\n    }\r\n\r\n    virtual size_t ItemSize() const override {\r\n        return ITEM_SIZE;\r\n    }\r\n    size_t CurrentAllocs() const {\r\n        return _currentAllocs;\r\n    }\r\n\r\n    virtual void* Alloc() override{\r\n        if ( !_root ) {\r\n            // Need a new block.\r\n            Block* block = new Block;\r\n            _blockPtrs.Push( block );\r\n\r\n            Item* blockItems = block->items;\r\n            for( size_t i = 0; i < ITEMS_PER_BLOCK - 1; ++i ) {\r\n                blockItems[i].next = &(blockItems[i + 1]);\r\n            }\r\n            blockItems[ITEMS_PER_BLOCK - 1].next = 0;\r\n            _root = blockItems;\r\n        }\r\n        Item* const result = _root;\r\n        TIXMLASSERT( result != 0 );\r\n        _root = _root->next;\r\n\r\n        ++_currentAllocs;\r\n        if ( _currentAllocs > _maxAllocs ) {\r\n            _maxAllocs = _currentAllocs;\r\n        }\r\n        ++_nAllocs;\r\n        ++_nUntracked;\r\n        return result;\r\n    }\r\n\r\n    virtual void Free( void* mem ) override {\r\n        if ( !mem ) {\r\n            return;\r\n        }\r\n        --_currentAllocs;\r\n        Item* item = static_cast<Item*>( mem );\r\n#ifdef TINYXML2_DEBUG\r\n        memset( item, 0xfe, sizeof( *item ) );\r\n#endif\r\n        item->next = _root;\r\n        _root = item;\r\n    }\r\n    void Trace( const char* name ) {\r\n        printf( \"Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\\n\",\r\n                name, _maxAllocs, _maxAllocs * ITEM_SIZE / 1024, _currentAllocs,\r\n                ITEM_SIZE, _nAllocs, _blockPtrs.Size() );\r\n    }\r\n\r\n    void SetTracked() override {\r\n        --_nUntracked;\r\n    }\r\n\r\n    size_t Untracked() const {\r\n        return _nUntracked;\r\n    }\r\n\r\n\t// This number is perf sensitive. 4k seems like a good tradeoff on my machine.\r\n\t// The test file is large, 170k.\r\n\t// Release:\t\tVS2010 gcc(no opt)\r\n\t//\t\t1k:\t\t4000\r\n\t//\t\t2k:\t\t4000\r\n\t//\t\t4k:\t\t3900\t21000\r\n\t//\t\t16k:\t5200\r\n\t//\t\t32k:\t4300\r\n\t//\t\t64k:\t4000\t21000\r\n    // Declared public because some compilers do not accept to use ITEMS_PER_BLOCK\r\n    // in private part if ITEMS_PER_BLOCK is private\r\n    enum { ITEMS_PER_BLOCK = (4 * 1024) / ITEM_SIZE };\r\n\r\nprivate:\r\n    MemPoolT( const MemPoolT& ); // not supported\r\n    void operator=( const MemPoolT& ); // not supported\r\n\r\n    union Item {\r\n        Item*   next;\r\n        char    itemData[static_cast<size_t>(ITEM_SIZE)];\r\n    };\r\n    struct Block {\r\n        Item items[ITEMS_PER_BLOCK];\r\n    };\r\n    DynArray< Block*, 10 > _blockPtrs;\r\n    Item* _root;\r\n\r\n    size_t _currentAllocs;\r\n    size_t _nAllocs;\r\n    size_t _maxAllocs;\r\n    size_t _nUntracked;\r\n};\r\n\r\n\r\n\r\n/**\r\n\tImplements the interface to the \"Visitor pattern\" (see the Accept() method.)\r\n\tIf you call the Accept() method, it requires being passed a XMLVisitor\r\n\tclass to handle callbacks. For nodes that contain other nodes (Document, Element)\r\n\tyou will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs\r\n\tare simply called with Visit().\r\n\r\n\tIf you return 'true' from a Visit method, recursive parsing will continue. If you return\r\n\tfalse, <b>no children of this node or its siblings</b> will be visited.\r\n\r\n\tAll flavors of Visit methods have a default implementation that returns 'true' (continue\r\n\tvisiting). You need to only override methods that are interesting to you.\r\n\r\n\tGenerally Accept() is called on the XMLDocument, although all nodes support visiting.\r\n\r\n\tYou should never change the document from a callback.\r\n\r\n\t@sa XMLNode::Accept()\r\n*/\r\nclass TINYXML2_LIB XMLVisitor\r\n{\r\npublic:\r\n    virtual ~XMLVisitor() {}\r\n\r\n    /// Visit a document.\r\n    virtual bool VisitEnter( const XMLDocument& /*doc*/ )\t\t\t{\r\n        return true;\r\n    }\r\n    /// Visit a document.\r\n    virtual bool VisitExit( const XMLDocument& /*doc*/ )\t\t\t{\r\n        return true;\r\n    }\r\n\r\n    /// Visit an element.\r\n    virtual bool VisitEnter( const XMLElement& /*element*/, const XMLAttribute* /*firstAttribute*/ )\t{\r\n        return true;\r\n    }\r\n    /// Visit an element.\r\n    virtual bool VisitExit( const XMLElement& /*element*/ )\t\t\t{\r\n        return true;\r\n    }\r\n\r\n    /// Visit a declaration.\r\n    virtual bool Visit( const XMLDeclaration& /*declaration*/ )\t\t{\r\n        return true;\r\n    }\r\n    /// Visit a text node.\r\n    virtual bool Visit( const XMLText& /*text*/ )\t\t\t\t\t{\r\n        return true;\r\n    }\r\n    /// Visit a comment node.\r\n    virtual bool Visit( const XMLComment& /*comment*/ )\t\t\t\t{\r\n        return true;\r\n    }\r\n    /// Visit an unknown node.\r\n    virtual bool Visit( const XMLUnknown& /*unknown*/ )\t\t\t\t{\r\n        return true;\r\n    }\r\n};\r\n\r\n// WARNING: must match XMLDocument::_errorNames[]\r\nenum XMLError {\r\n    XML_SUCCESS = 0,\r\n    XML_NO_ATTRIBUTE,\r\n    XML_WRONG_ATTRIBUTE_TYPE,\r\n    XML_ERROR_FILE_NOT_FOUND,\r\n    XML_ERROR_FILE_COULD_NOT_BE_OPENED,\r\n    XML_ERROR_FILE_READ_ERROR,\r\n    XML_ERROR_PARSING_ELEMENT,\r\n    XML_ERROR_PARSING_ATTRIBUTE,\r\n    XML_ERROR_PARSING_TEXT,\r\n    XML_ERROR_PARSING_CDATA,\r\n    XML_ERROR_PARSING_COMMENT,\r\n    XML_ERROR_PARSING_DECLARATION,\r\n    XML_ERROR_PARSING_UNKNOWN,\r\n    XML_ERROR_EMPTY_DOCUMENT,\r\n    XML_ERROR_MISMATCHED_ELEMENT,\r\n    XML_ERROR_PARSING,\r\n    XML_CAN_NOT_CONVERT_TEXT,\r\n    XML_NO_TEXT_NODE,\r\n\tXML_ELEMENT_DEPTH_EXCEEDED,\r\n\r\n\tXML_ERROR_COUNT\r\n};\r\n\r\n\r\n/*\r\n\tUtility functionality.\r\n*/\r\nclass TINYXML2_LIB XMLUtil\r\n{\r\npublic:\r\n    static const char* SkipWhiteSpace( const char* p, int* curLineNumPtr )\t{\r\n        TIXMLASSERT( p );\r\n\r\n        while( IsWhiteSpace(*p) ) {\r\n            if (curLineNumPtr && *p == '\\n') {\r\n                ++(*curLineNumPtr);\r\n            }\r\n            ++p;\r\n        }\r\n        TIXMLASSERT( p );\r\n        return p;\r\n    }\r\n    static char* SkipWhiteSpace( char* const p, int* curLineNumPtr ) {\r\n        return const_cast<char*>( SkipWhiteSpace( const_cast<const char*>(p), curLineNumPtr ) );\r\n    }\r\n\r\n    // Anything in the high order range of UTF-8 is assumed to not be whitespace. This isn't\r\n    // correct, but simple, and usually works.\r\n    static bool IsWhiteSpace( char p )\t\t\t\t\t{\r\n        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );\r\n    }\r\n\r\n    inline static bool IsNameStartChar( unsigned char ch ) {\r\n        if ( ch >= 128 ) {\r\n            // This is a heuristic guess in attempt to not implement Unicode-aware isalpha()\r\n            return true;\r\n        }\r\n        if ( isalpha( ch ) ) {\r\n            return true;\r\n        }\r\n        return ch == ':' || ch == '_';\r\n    }\r\n\r\n    inline static bool IsNameChar( unsigned char ch ) {\r\n        return IsNameStartChar( ch )\r\n               || isdigit( ch )\r\n               || ch == '.'\r\n               || ch == '-';\r\n    }\r\n\r\n    inline static bool IsPrefixHex( const char* p) {\r\n        p = SkipWhiteSpace(p, 0);\r\n        return p && *p == '0' && ( *(p + 1) == 'x' || *(p + 1) == 'X');\r\n    }\r\n\r\n    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {\r\n        if ( p == q ) {\r\n            return true;\r\n        }\r\n        TIXMLASSERT( p );\r\n        TIXMLASSERT( q );\r\n        TIXMLASSERT( nChar >= 0 );\r\n        return strncmp( p, q, static_cast<size_t>(nChar) ) == 0;\r\n    }\r\n\r\n    inline static bool IsUTF8Continuation( const char p ) {\r\n        return ( p & 0x80 ) != 0;\r\n    }\r\n\r\n    static const char* ReadBOM( const char* p, bool* hasBOM );\r\n    // p is the starting location,\r\n    // the UTF-8 value of the entity will be placed in value, and length filled in.\r\n    static const char* GetCharacterRef( const char* p, char* value, int* length );\r\n    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );\r\n\r\n    // converts primitive types to strings\r\n    static void ToStr( int v, char* buffer, int bufferSize );\r\n    static void ToStr( unsigned v, char* buffer, int bufferSize );\r\n    static void ToStr( bool v, char* buffer, int bufferSize );\r\n    static void ToStr( float v, char* buffer, int bufferSize );\r\n    static void ToStr( double v, char* buffer, int bufferSize );\r\n\tstatic void ToStr(int64_t v, char* buffer, int bufferSize);\r\n    static void ToStr(uint64_t v, char* buffer, int bufferSize);\r\n\r\n    // converts strings to primitive types\r\n    static bool\tToInt( const char* str, int* value );\r\n    static bool ToUnsigned( const char* str, unsigned* value );\r\n    static bool\tToBool( const char* str, bool* value );\r\n    static bool\tToFloat( const char* str, float* value );\r\n    static bool ToDouble( const char* str, double* value );\r\n\tstatic bool ToInt64(const char* str, int64_t* value);\r\n    static bool ToUnsigned64(const char* str, uint64_t* value);\r\n\t// Changes what is serialized for a boolean value.\r\n\t// Default to \"true\" and \"false\". Shouldn't be changed\r\n\t// unless you have a special testing or compatibility need.\r\n\t// Be careful: static, global, & not thread safe.\r\n\t// Be sure to set static const memory as parameters.\r\n\tstatic void SetBoolSerialization(const char* writeTrue, const char* writeFalse);\r\n\r\nprivate:\r\n\tstatic const char* writeBoolTrue;\r\n\tstatic const char* writeBoolFalse;\r\n};\r\n\r\n\r\n/** XMLNode is a base class for every object that is in the\r\n\tXML Document Object Model (DOM), except XMLAttributes.\r\n\tNodes have siblings, a parent, and children which can\r\n\tbe navigated. A node is always in a XMLDocument.\r\n\tThe type of a XMLNode can be queried, and it can\r\n\tbe cast to its more defined type.\r\n\r\n\tA XMLDocument allocates memory for all its Nodes.\r\n\tWhen the XMLDocument gets deleted, all its Nodes\r\n\twill also be deleted.\r\n\r\n\t@verbatim\r\n\tA Document can contain:\tElement\t(container or leaf)\r\n\t\t\t\t\t\t\tComment (leaf)\r\n\t\t\t\t\t\t\tUnknown (leaf)\r\n\t\t\t\t\t\t\tDeclaration( leaf )\r\n\r\n\tAn Element can contain:\tElement (container or leaf)\r\n\t\t\t\t\t\t\tText\t(leaf)\r\n\t\t\t\t\t\t\tAttributes (not on tree)\r\n\t\t\t\t\t\t\tComment (leaf)\r\n\t\t\t\t\t\t\tUnknown (leaf)\r\n\r\n\t@endverbatim\r\n*/\r\nclass TINYXML2_LIB XMLNode\r\n{\r\n    friend class XMLDocument;\r\n    friend class XMLElement;\r\npublic:\r\n\r\n    /// Get the XMLDocument that owns this XMLNode.\r\n    const XMLDocument* GetDocument() const\t{\r\n        TIXMLASSERT( _document );\r\n        return _document;\r\n    }\r\n    /// Get the XMLDocument that owns this XMLNode.\r\n    XMLDocument* GetDocument()\t\t\t\t{\r\n        TIXMLASSERT( _document );\r\n        return _document;\r\n    }\r\n\r\n    /// Safely cast to an Element, or null.\r\n    virtual XMLElement*\t\tToElement()\t\t{\r\n        return 0;\r\n    }\r\n    /// Safely cast to Text, or null.\r\n    virtual XMLText*\t\tToText()\t\t{\r\n        return 0;\r\n    }\r\n    /// Safely cast to a Comment, or null.\r\n    virtual XMLComment*\t\tToComment()\t\t{\r\n        return 0;\r\n    }\r\n    /// Safely cast to a Document, or null.\r\n    virtual XMLDocument*\tToDocument()\t{\r\n        return 0;\r\n    }\r\n    /// Safely cast to a Declaration, or null.\r\n    virtual XMLDeclaration*\tToDeclaration()\t{\r\n        return 0;\r\n    }\r\n    /// Safely cast to an Unknown, or null.\r\n    virtual XMLUnknown*\t\tToUnknown()\t\t{\r\n        return 0;\r\n    }\r\n\r\n    virtual const XMLElement*\t\tToElement() const\t\t{\r\n        return 0;\r\n    }\r\n    virtual const XMLText*\t\t\tToText() const\t\t\t{\r\n        return 0;\r\n    }\r\n    virtual const XMLComment*\t\tToComment() const\t\t{\r\n        return 0;\r\n    }\r\n    virtual const XMLDocument*\t\tToDocument() const\t\t{\r\n        return 0;\r\n    }\r\n    virtual const XMLDeclaration*\tToDeclaration() const\t{\r\n        return 0;\r\n    }\r\n    virtual const XMLUnknown*\t\tToUnknown() const\t\t{\r\n        return 0;\r\n    }\r\n\r\n    // ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.\r\n\r\n    int ChildElementCount(const char *value) const;\r\n\r\n    int ChildElementCount() const;\r\n\r\n    /** The meaning of 'value' changes for the specific type.\r\n    \t@verbatim\r\n    \tDocument:\tempty (NULL is returned, not an empty string)\r\n    \tElement:\tname of the element\r\n    \tComment:\tthe comment text\r\n    \tUnknown:\tthe tag contents\r\n    \tText:\t\tthe text string\r\n    \t@endverbatim\r\n    */\r\n    const char* Value() const;\r\n\r\n    /** Set the Value of an XML node.\r\n    \t@sa Value()\r\n    */\r\n    void SetValue( const char* val, bool staticMem=false );\r\n\r\n    /// Gets the line number the node is in, if the document was parsed from a file.\r\n    int GetLineNum() const { return _parseLineNum; }\r\n\r\n    /// Get the parent of this node on the DOM.\r\n    const XMLNode*\tParent() const\t\t\t{\r\n        return _parent;\r\n    }\r\n\r\n    XMLNode* Parent()\t\t\t\t\t\t{\r\n        return _parent;\r\n    }\r\n\r\n    /// Returns true if this node has no children.\r\n    bool NoChildren() const\t\t\t\t\t{\r\n        return !_firstChild;\r\n    }\r\n\r\n    /// Get the first child node, or null if none exists.\r\n    const XMLNode*  FirstChild() const\t\t{\r\n        return _firstChild;\r\n    }\r\n\r\n    XMLNode*\t\tFirstChild()\t\t\t{\r\n        return _firstChild;\r\n    }\r\n\r\n    /** Get the first child element, or optionally the first child\r\n        element with the specified name.\r\n    */\r\n    const XMLElement* FirstChildElement( const char* name = 0 ) const;\r\n\r\n    XMLElement* FirstChildElement( const char* name = 0 )\t{\r\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( name ));\r\n    }\r\n\r\n    /// Get the last child node, or null if none exists.\r\n    const XMLNode*\tLastChild() const\t\t\t\t\t\t{\r\n        return _lastChild;\r\n    }\r\n\r\n    XMLNode*\t\tLastChild()\t\t\t\t\t\t\t\t{\r\n        return _lastChild;\r\n    }\r\n\r\n    /** Get the last child element or optionally the last child\r\n        element with the specified name.\r\n    */\r\n    const XMLElement* LastChildElement( const char* name = 0 ) const;\r\n\r\n    XMLElement* LastChildElement( const char* name = 0 )\t{\r\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(name) );\r\n    }\r\n\r\n    /// Get the previous (left) sibling node of this node.\r\n    const XMLNode*\tPreviousSibling() const\t\t\t\t\t{\r\n        return _prev;\r\n    }\r\n\r\n    XMLNode*\tPreviousSibling()\t\t\t\t\t\t\t{\r\n        return _prev;\r\n    }\r\n\r\n    /// Get the previous (left) sibling element of this node, with an optionally supplied name.\r\n    const XMLElement*\tPreviousSiblingElement( const char* name = 0 ) const ;\r\n\r\n    XMLElement*\tPreviousSiblingElement( const char* name = 0 ) {\r\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( name ) );\r\n    }\r\n\r\n    /// Get the next (right) sibling node of this node.\r\n    const XMLNode*\tNextSibling() const\t\t\t\t\t\t{\r\n        return _next;\r\n    }\r\n\r\n    XMLNode*\tNextSibling()\t\t\t\t\t\t\t\t{\r\n        return _next;\r\n    }\r\n\r\n    /// Get the next (right) sibling element of this node, with an optionally supplied name.\r\n    const XMLElement*\tNextSiblingElement( const char* name = 0 ) const;\r\n\r\n    XMLElement*\tNextSiblingElement( const char* name = 0 )\t{\r\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( name ) );\r\n    }\r\n\r\n    /**\r\n    \tAdd a child node as the last (right) child.\r\n\t\tIf the child node is already part of the document,\r\n\t\tit is moved from its old location to the new location.\r\n\t\tReturns the addThis argument or 0 if the node does not\r\n\t\tbelong to the same document.\r\n    */\r\n    XMLNode* InsertEndChild( XMLNode* addThis );\r\n\r\n    XMLNode* LinkEndChild( XMLNode* addThis )\t{\r\n        return InsertEndChild( addThis );\r\n    }\r\n    /**\r\n    \tAdd a child node as the first (left) child.\r\n\t\tIf the child node is already part of the document,\r\n\t\tit is moved from its old location to the new location.\r\n\t\tReturns the addThis argument or 0 if the node does not\r\n\t\tbelong to the same document.\r\n    */\r\n    XMLNode* InsertFirstChild( XMLNode* addThis );\r\n    /**\r\n    \tAdd a node after the specified child node.\r\n\t\tIf the child node is already part of the document,\r\n\t\tit is moved from its old location to the new location.\r\n\t\tReturns the addThis argument or 0 if the afterThis node\r\n\t\tis not a child of this node, or if the node does not\r\n\t\tbelong to the same document.\r\n    */\r\n    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );\r\n\r\n    /**\r\n    \tDelete all the children of this node.\r\n    */\r\n    void DeleteChildren();\r\n\r\n    /**\r\n    \tDelete a child of this node.\r\n    */\r\n    void DeleteChild( XMLNode* node );\r\n\r\n    /**\r\n    \tMake a copy of this node, but not its children.\r\n    \tYou may pass in a Document pointer that will be\r\n    \tthe owner of the new Node. If the 'document' is\r\n    \tnull, then the node returned will be allocated\r\n    \tfrom the current Document. (this->GetDocument())\r\n\r\n    \tNote: if called on a XMLDocument, this will return null.\r\n    */\r\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;\r\n\r\n\t/**\r\n\t\tMake a copy of this node and all its children.\r\n\r\n\t\tIf the 'target' is null, then the nodes will\r\n\t\tbe allocated in the current document. If 'target'\r\n        is specified, the memory will be allocated in the\r\n        specified XMLDocument.\r\n\r\n\t\tNOTE: This is probably not the correct tool to\r\n\t\tcopy a document, since XMLDocuments can have multiple\r\n\t\ttop level XMLNodes. You probably want to use\r\n        XMLDocument::DeepCopy()\r\n\t*/\r\n\tXMLNode* DeepClone( XMLDocument* target ) const;\r\n\r\n    /**\r\n    \tTest if 2 nodes are the same, but don't test children.\r\n    \tThe 2 nodes do not need to be in the same Document.\r\n\r\n    \tNote: if called on a XMLDocument, this will return false.\r\n    */\r\n    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;\r\n\r\n    /** Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the\r\n    \tXML tree will be conditionally visited and the host will be called back\r\n    \tvia the XMLVisitor interface.\r\n\r\n    \tThis is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse\r\n    \tthe XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this\r\n    \tinterface versus any other.)\r\n\r\n    \tThe interface has been based on ideas from:\r\n\r\n    \t- http://www.saxproject.org/\r\n    \t- http://c2.com/cgi/wiki?HierarchicalVisitorPattern\r\n\r\n    \tWhich are both good references for \"visiting\".\r\n\r\n    \tAn example of using Accept():\r\n    \t@verbatim\r\n    \tXMLPrinter printer;\r\n    \ttinyxmlDoc.Accept( &printer );\r\n    \tconst char* xmlcstr = printer.CStr();\r\n    \t@endverbatim\r\n    */\r\n    virtual bool Accept( XMLVisitor* visitor ) const = 0;\r\n\r\n\t/**\r\n\t\tSet user data into the XMLNode. TinyXML-2 in\r\n\t\tno way processes or interprets user data.\r\n\t\tIt is initially 0.\r\n\t*/\r\n\tvoid SetUserData(void* userData)\t{ _userData = userData; }\r\n\r\n\t/**\r\n\t\tGet user data set into the XMLNode. TinyXML-2 in\r\n\t\tno way processes or interprets user data.\r\n\t\tIt is initially 0.\r\n\t*/\r\n\tvoid* GetUserData() const\t\t\t{ return _userData; }\r\n\r\nprotected:\r\n    explicit XMLNode( XMLDocument* );\r\n    virtual ~XMLNode();\r\n\r\n    virtual char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr);\r\n\r\n    XMLDocument*\t_document;\r\n    XMLNode*\t\t_parent;\r\n    mutable StrPair\t_value;\r\n    int             _parseLineNum;\r\n\r\n    XMLNode*\t\t_firstChild;\r\n    XMLNode*\t\t_lastChild;\r\n\r\n    XMLNode*\t\t_prev;\r\n    XMLNode*\t\t_next;\r\n\r\n\tvoid*\t\t\t_userData;\r\n\r\nprivate:\r\n    MemPool*\t\t_memPool;\r\n    void Unlink( XMLNode* child );\r\n    static void DeleteNode( XMLNode* node );\r\n    void InsertChildPreamble( XMLNode* insertThis ) const;\r\n    const XMLElement* ToElementWithName( const char* name ) const;\r\n\r\n    XMLNode( const XMLNode& );\t// not supported\r\n    XMLNode& operator=( const XMLNode& );\t// not supported\r\n};\r\n\r\n\r\n/** XML text.\r\n\r\n\tNote that a text node can have child element nodes, for example:\r\n\t@verbatim\r\n\t<root>This is <b>bold</b></root>\r\n\t@endverbatim\r\n\r\n\tA text node can have 2 ways to output the next. \"normal\" output\r\n\tand CDATA. It will default to the mode it was parsed from the XML file and\r\n\tyou generally want to leave it alone, but you can change the output mode with\r\n\tSetCData() and query it with CData().\r\n*/\r\nclass TINYXML2_LIB XMLText : public XMLNode\r\n{\r\n    friend class XMLDocument;\r\npublic:\r\n    virtual bool Accept( XMLVisitor* visitor ) const override;\r\n\r\n    virtual XMLText* ToText() override\t\t{\r\n        return this;\r\n    }\r\n    virtual const XMLText* ToText() const override {\r\n        return this;\r\n    }\r\n\r\n    /// Declare whether this should be CDATA or standard text.\r\n    void SetCData( bool isCData )\t\t\t{\r\n        _isCData = isCData;\r\n    }\r\n    /// Returns true if this is a CDATA text element.\r\n    bool CData() const\t\t\t\t\t\t{\r\n        return _isCData;\r\n    }\r\n\r\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;\r\n    virtual bool ShallowEqual( const XMLNode* compare ) const override;\r\n\r\nprotected:\r\n    explicit XMLText( XMLDocument* doc )\t: XMLNode( doc ), _isCData( false )\t{}\r\n    virtual ~XMLText()\t\t\t\t\t\t\t\t\t\t\t\t{}\r\n\r\n    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;\r\n\r\nprivate:\r\n    bool _isCData;\r\n\r\n    XMLText( const XMLText& );\t// not supported\r\n    XMLText& operator=( const XMLText& );\t// not supported\r\n};\r\n\r\n\r\n/** An XML Comment. */\r\nclass TINYXML2_LIB XMLComment : public XMLNode\r\n{\r\n    friend class XMLDocument;\r\npublic:\r\n    virtual XMLComment*\tToComment() override\t\t{\r\n        return this;\r\n    }\r\n    virtual const XMLComment* ToComment() const override {\r\n        return this;\r\n    }\r\n\r\n    virtual bool Accept( XMLVisitor* visitor ) const override;\r\n\r\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;\r\n    virtual bool ShallowEqual( const XMLNode* compare ) const override;\r\n\r\nprotected:\r\n    explicit XMLComment( XMLDocument* doc );\r\n    virtual ~XMLComment();\r\n\r\n    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr) override;\r\n\r\nprivate:\r\n    XMLComment( const XMLComment& );\t// not supported\r\n    XMLComment& operator=( const XMLComment& );\t// not supported\r\n};\r\n\r\n\r\n/** In correct XML the declaration is the first entry in the file.\r\n\t@verbatim\r\n\t\t<?xml version=\"1.0\" standalone=\"yes\"?>\r\n\t@endverbatim\r\n\r\n\tTinyXML-2 will happily read or write files without a declaration,\r\n\thowever.\r\n\r\n\tThe text of the declaration isn't interpreted. It is parsed\r\n\tand written as a string.\r\n*/\r\nclass TINYXML2_LIB XMLDeclaration : public XMLNode\r\n{\r\n    friend class XMLDocument;\r\npublic:\r\n    virtual XMLDeclaration*\tToDeclaration() override\t\t{\r\n        return this;\r\n    }\r\n    virtual const XMLDeclaration* ToDeclaration() const override {\r\n        return this;\r\n    }\r\n\r\n    virtual bool Accept( XMLVisitor* visitor ) const override;\r\n\r\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;\r\n    virtual bool ShallowEqual( const XMLNode* compare ) const override;\r\n\r\nprotected:\r\n    explicit XMLDeclaration( XMLDocument* doc );\r\n    virtual ~XMLDeclaration();\r\n\r\n    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;\r\n\r\nprivate:\r\n    XMLDeclaration( const XMLDeclaration& );\t// not supported\r\n    XMLDeclaration& operator=( const XMLDeclaration& );\t// not supported\r\n};\r\n\r\n\r\n/** Any tag that TinyXML-2 doesn't recognize is saved as an\r\n\tunknown. It is a tag of text, but should not be modified.\r\n\tIt will be written back to the XML, unchanged, when the file\r\n\tis saved.\r\n\r\n\tDTD tags get thrown into XMLUnknowns.\r\n*/\r\nclass TINYXML2_LIB XMLUnknown : public XMLNode\r\n{\r\n    friend class XMLDocument;\r\npublic:\r\n    virtual XMLUnknown*\tToUnknown() override\t\t{\r\n        return this;\r\n    }\r\n    virtual const XMLUnknown* ToUnknown() const override {\r\n        return this;\r\n    }\r\n\r\n    virtual bool Accept( XMLVisitor* visitor ) const override;\r\n\r\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;\r\n    virtual bool ShallowEqual( const XMLNode* compare ) const override;\r\n\r\nprotected:\r\n    explicit XMLUnknown( XMLDocument* doc );\r\n    virtual ~XMLUnknown();\r\n\r\n    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;\r\n\r\nprivate:\r\n    XMLUnknown( const XMLUnknown& );\t// not supported\r\n    XMLUnknown& operator=( const XMLUnknown& );\t// not supported\r\n};\r\n\r\n\r\n\r\n/** An attribute is a name-value pair. Elements have an arbitrary\r\n\tnumber of attributes, each with a unique name.\r\n\r\n\t@note The attributes are not XMLNodes. You may only query the\r\n\tNext() attribute in a list.\r\n*/\r\nclass TINYXML2_LIB XMLAttribute\r\n{\r\n    friend class XMLElement;\r\npublic:\r\n    /// The name of the attribute.\r\n    const char* Name() const;\r\n\r\n    /// The value of the attribute.\r\n    const char* Value() const;\r\n\r\n    /// Gets the line number the attribute is in, if the document was parsed from a file.\r\n    int GetLineNum() const { return _parseLineNum; }\r\n\r\n    /// The next attribute in the list.\r\n    const XMLAttribute* Next() const {\r\n        return _next;\r\n    }\r\n\r\n    /** IntValue interprets the attribute as an integer, and returns the value.\r\n        If the value isn't an integer, 0 will be returned. There is no error checking;\r\n    \tuse QueryIntValue() if you need error checking.\r\n    */\r\n\tint\tIntValue() const {\r\n\t\tint i = 0;\r\n\t\tQueryIntValue(&i);\r\n\t\treturn i;\r\n\t}\r\n\r\n\tint64_t Int64Value() const {\r\n\t\tint64_t i = 0;\r\n\t\tQueryInt64Value(&i);\r\n\t\treturn i;\r\n\t}\r\n\r\n    uint64_t Unsigned64Value() const {\r\n        uint64_t i = 0;\r\n        QueryUnsigned64Value(&i);\r\n        return i;\r\n    }\r\n\r\n    /// Query as an unsigned integer. See IntValue()\r\n    unsigned UnsignedValue() const\t\t\t{\r\n        unsigned i=0;\r\n        QueryUnsignedValue( &i );\r\n        return i;\r\n    }\r\n    /// Query as a boolean. See IntValue()\r\n    bool\t BoolValue() const\t\t\t\t{\r\n        bool b=false;\r\n        QueryBoolValue( &b );\r\n        return b;\r\n    }\r\n    /// Query as a double. See IntValue()\r\n    double \t DoubleValue() const\t\t\t{\r\n        double d=0;\r\n        QueryDoubleValue( &d );\r\n        return d;\r\n    }\r\n    /// Query as a float. See IntValue()\r\n    float\t FloatValue() const\t\t\t\t{\r\n        float f=0;\r\n        QueryFloatValue( &f );\r\n        return f;\r\n    }\r\n\r\n    /** QueryIntValue interprets the attribute as an integer, and returns the value\r\n    \tin the provided parameter. The function will return XML_SUCCESS on success,\r\n    \tand XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.\r\n    */\r\n    XMLError QueryIntValue( int* value ) const;\r\n    /// See QueryIntValue\r\n    XMLError QueryUnsignedValue( unsigned int* value ) const;\r\n\t/// See QueryIntValue\r\n\tXMLError QueryInt64Value(int64_t* value) const;\r\n    /// See QueryIntValue\r\n    XMLError QueryUnsigned64Value(uint64_t* value) const;\r\n\t/// See QueryIntValue\r\n    XMLError QueryBoolValue( bool* value ) const;\r\n    /// See QueryIntValue\r\n    XMLError QueryDoubleValue( double* value ) const;\r\n    /// See QueryIntValue\r\n    XMLError QueryFloatValue( float* value ) const;\r\n\r\n    /// Set the attribute to a string value.\r\n    void SetAttribute( const char* value );\r\n    /// Set the attribute to value.\r\n    void SetAttribute( int value );\r\n    /// Set the attribute to value.\r\n    void SetAttribute( unsigned value );\r\n\t/// Set the attribute to value.\r\n\tvoid SetAttribute(int64_t value);\r\n    /// Set the attribute to value.\r\n    void SetAttribute(uint64_t value);\r\n    /// Set the attribute to value.\r\n    void SetAttribute( bool value );\r\n    /// Set the attribute to value.\r\n    void SetAttribute( double value );\r\n    /// Set the attribute to value.\r\n    void SetAttribute( float value );\r\n\r\nprivate:\r\n    enum { BUF_SIZE = 200 };\r\n\r\n    XMLAttribute() : _name(), _value(),_parseLineNum( 0 ), _next( 0 ), _memPool( 0 ) {}\r\n    virtual ~XMLAttribute()\t{}\r\n\r\n    XMLAttribute( const XMLAttribute& );\t// not supported\r\n    void operator=( const XMLAttribute& );\t// not supported\r\n    void SetName( const char* name );\r\n\r\n    char* ParseDeep( char* p, bool processEntities, int* curLineNumPtr );\r\n\r\n    mutable StrPair _name;\r\n    mutable StrPair _value;\r\n    int             _parseLineNum;\r\n    XMLAttribute*   _next;\r\n    MemPool*        _memPool;\r\n};\r\n\r\n\r\n/** The element is a container class. It has a value, the element name,\r\n\tand can contain other elements, text, comments, and unknowns.\r\n\tElements also contain an arbitrary number of attributes.\r\n*/\r\nclass TINYXML2_LIB XMLElement : public XMLNode\r\n{\r\n    friend class XMLDocument;\r\npublic:\r\n    /// Get the name of an element (which is the Value() of the node.)\r\n    const char* Name() const\t\t{\r\n        return Value();\r\n    }\r\n    /// Set the name of the element.\r\n    void SetName( const char* str, bool staticMem=false )\t{\r\n        SetValue( str, staticMem );\r\n    }\r\n\r\n    virtual XMLElement* ToElement() override\t{\r\n        return this;\r\n    }\r\n    virtual const XMLElement* ToElement() const override {\r\n        return this;\r\n    }\r\n    virtual bool Accept( XMLVisitor* visitor ) const override;\r\n\r\n    /** Given an attribute name, Attribute() returns the value\r\n    \tfor the attribute of that name, or null if none\r\n    \texists. For example:\r\n\r\n    \t@verbatim\r\n    \tconst char* value = ele->Attribute( \"foo\" );\r\n    \t@endverbatim\r\n\r\n    \tThe 'value' parameter is normally null. However, if specified,\r\n    \tthe attribute will only be returned if the 'name' and 'value'\r\n    \tmatch. This allow you to write code:\r\n\r\n    \t@verbatim\r\n    \tif ( ele->Attribute( \"foo\", \"bar\" ) ) callFooIsBar();\r\n    \t@endverbatim\r\n\r\n    \trather than:\r\n    \t@verbatim\r\n    \tif ( ele->Attribute( \"foo\" ) ) {\r\n    \t\tif ( strcmp( ele->Attribute( \"foo\" ), \"bar\" ) == 0 ) callFooIsBar();\r\n    \t}\r\n    \t@endverbatim\r\n    */\r\n    const char* Attribute( const char* name, const char* value=0 ) const;\r\n\r\n    /** Given an attribute name, IntAttribute() returns the value\r\n    \tof the attribute interpreted as an integer. The default\r\n        value will be returned if the attribute isn't present,\r\n        or if there is an error. (For a method with error\r\n    \tchecking, see QueryIntAttribute()).\r\n    */\r\n\tint IntAttribute(const char* name, int defaultValue = 0) const;\r\n    /// See IntAttribute()\r\n\tunsigned UnsignedAttribute(const char* name, unsigned defaultValue = 0) const;\r\n\t/// See IntAttribute()\r\n\tint64_t Int64Attribute(const char* name, int64_t defaultValue = 0) const;\r\n    /// See IntAttribute()\r\n    uint64_t Unsigned64Attribute(const char* name, uint64_t defaultValue = 0) const;\r\n\t/// See IntAttribute()\r\n\tbool BoolAttribute(const char* name, bool defaultValue = false) const;\r\n    /// See IntAttribute()\r\n\tdouble DoubleAttribute(const char* name, double defaultValue = 0) const;\r\n    /// See IntAttribute()\r\n\tfloat FloatAttribute(const char* name, float defaultValue = 0) const;\r\n\r\n    /** Given an attribute name, QueryIntAttribute() returns\r\n    \tXML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion\r\n    \tcan't be performed, or XML_NO_ATTRIBUTE if the attribute\r\n    \tdoesn't exist. If successful, the result of the conversion\r\n    \twill be written to 'value'. If not successful, nothing will\r\n    \tbe written to 'value'. This allows you to provide default\r\n    \tvalue:\r\n\r\n    \t@verbatim\r\n    \tint value = 10;\r\n    \tQueryIntAttribute( \"foo\", &value );\t\t// if \"foo\" isn't found, value will still be 10\r\n    \t@endverbatim\r\n    */\r\n    XMLError QueryIntAttribute( const char* name, int* value ) const\t\t\t\t{\r\n        const XMLAttribute* a = FindAttribute( name );\r\n        if ( !a ) {\r\n            return XML_NO_ATTRIBUTE;\r\n        }\r\n        return a->QueryIntValue( value );\r\n    }\r\n\r\n\t/// See QueryIntAttribute()\r\n    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const\t{\r\n        const XMLAttribute* a = FindAttribute( name );\r\n        if ( !a ) {\r\n            return XML_NO_ATTRIBUTE;\r\n        }\r\n        return a->QueryUnsignedValue( value );\r\n    }\r\n\r\n\t/// See QueryIntAttribute()\r\n\tXMLError QueryInt64Attribute(const char* name, int64_t* value) const {\r\n\t\tconst XMLAttribute* a = FindAttribute(name);\r\n\t\tif (!a) {\r\n\t\t\treturn XML_NO_ATTRIBUTE;\r\n\t\t}\r\n\t\treturn a->QueryInt64Value(value);\r\n\t}\r\n\r\n    /// See QueryIntAttribute()\r\n    XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {\r\n        const XMLAttribute* a = FindAttribute(name);\r\n        if(!a) {\r\n            return XML_NO_ATTRIBUTE;\r\n        }\r\n        return a->QueryUnsigned64Value(value);\r\n    }\r\n\r\n\t/// See QueryIntAttribute()\r\n    XMLError QueryBoolAttribute( const char* name, bool* value ) const\t\t\t\t{\r\n        const XMLAttribute* a = FindAttribute( name );\r\n        if ( !a ) {\r\n            return XML_NO_ATTRIBUTE;\r\n        }\r\n        return a->QueryBoolValue( value );\r\n    }\r\n    /// See QueryIntAttribute()\r\n    XMLError QueryDoubleAttribute( const char* name, double* value ) const\t\t\t{\r\n        const XMLAttribute* a = FindAttribute( name );\r\n        if ( !a ) {\r\n            return XML_NO_ATTRIBUTE;\r\n        }\r\n        return a->QueryDoubleValue( value );\r\n    }\r\n    /// See QueryIntAttribute()\r\n    XMLError QueryFloatAttribute( const char* name, float* value ) const\t\t\t{\r\n        const XMLAttribute* a = FindAttribute( name );\r\n        if ( !a ) {\r\n            return XML_NO_ATTRIBUTE;\r\n        }\r\n        return a->QueryFloatValue( value );\r\n    }\r\n\r\n\t/// See QueryIntAttribute()\r\n\tXMLError QueryStringAttribute(const char* name, const char** value) const {\r\n\t\tconst XMLAttribute* a = FindAttribute(name);\r\n\t\tif (!a) {\r\n\t\t\treturn XML_NO_ATTRIBUTE;\r\n\t\t}\r\n\t\t*value = a->Value();\r\n\t\treturn XML_SUCCESS;\r\n\t}\r\n\r\n\r\n\r\n    /** Given an attribute name, QueryAttribute() returns\r\n    \tXML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion\r\n    \tcan't be performed, or XML_NO_ATTRIBUTE if the attribute\r\n    \tdoesn't exist. It is overloaded for the primitive types,\r\n\t\tand is a generally more convenient replacement of\r\n\t\tQueryIntAttribute() and related functions.\r\n\r\n\t\tIf successful, the result of the conversion\r\n    \twill be written to 'value'. If not successful, nothing will\r\n    \tbe written to 'value'. This allows you to provide default\r\n    \tvalue:\r\n\r\n    \t@verbatim\r\n    \tint value = 10;\r\n    \tQueryAttribute( \"foo\", &value );\t\t// if \"foo\" isn't found, value will still be 10\r\n    \t@endverbatim\r\n    */\r\n\tXMLError QueryAttribute( const char* name, int* value ) const {\r\n\t\treturn QueryIntAttribute( name, value );\r\n\t}\r\n\r\n\tXMLError QueryAttribute( const char* name, unsigned int* value ) const {\r\n\t\treturn QueryUnsignedAttribute( name, value );\r\n\t}\r\n\r\n\tXMLError QueryAttribute(const char* name, int64_t* value) const {\r\n\t\treturn QueryInt64Attribute(name, value);\r\n\t}\r\n\r\n    XMLError QueryAttribute(const char* name, uint64_t* value) const {\r\n        return QueryUnsigned64Attribute(name, value);\r\n    }\r\n\r\n    XMLError QueryAttribute( const char* name, bool* value ) const {\r\n\t\treturn QueryBoolAttribute( name, value );\r\n\t}\r\n\r\n\tXMLError QueryAttribute( const char* name, double* value ) const {\r\n\t\treturn QueryDoubleAttribute( name, value );\r\n\t}\r\n\r\n\tXMLError QueryAttribute( const char* name, float* value ) const {\r\n\t\treturn QueryFloatAttribute( name, value );\r\n\t}\r\n\r\n\tXMLError QueryAttribute(const char* name, const char** value) const {\r\n\t\treturn QueryStringAttribute(name, value);\r\n\t}\r\n\r\n\t/// Sets the named attribute to value.\r\n    void SetAttribute( const char* name, const char* value )\t{\r\n        XMLAttribute* a = FindOrCreateAttribute( name );\r\n        a->SetAttribute( value );\r\n    }\r\n    /// Sets the named attribute to value.\r\n    void SetAttribute( const char* name, int value )\t\t\t{\r\n        XMLAttribute* a = FindOrCreateAttribute( name );\r\n        a->SetAttribute( value );\r\n    }\r\n    /// Sets the named attribute to value.\r\n    void SetAttribute( const char* name, unsigned value )\t\t{\r\n        XMLAttribute* a = FindOrCreateAttribute( name );\r\n        a->SetAttribute( value );\r\n    }\r\n\r\n\t/// Sets the named attribute to value.\r\n\tvoid SetAttribute(const char* name, int64_t value) {\r\n\t\tXMLAttribute* a = FindOrCreateAttribute(name);\r\n\t\ta->SetAttribute(value);\r\n\t}\r\n\r\n    /// Sets the named attribute to value.\r\n    void SetAttribute(const char* name, uint64_t value) {\r\n        XMLAttribute* a = FindOrCreateAttribute(name);\r\n        a->SetAttribute(value);\r\n    }\r\n\r\n    /// Sets the named attribute to value.\r\n    void SetAttribute( const char* name, bool value )\t\t\t{\r\n        XMLAttribute* a = FindOrCreateAttribute( name );\r\n        a->SetAttribute( value );\r\n    }\r\n    /// Sets the named attribute to value.\r\n    void SetAttribute( const char* name, double value )\t\t{\r\n        XMLAttribute* a = FindOrCreateAttribute( name );\r\n        a->SetAttribute( value );\r\n    }\r\n    /// Sets the named attribute to value.\r\n    void SetAttribute( const char* name, float value )\t\t{\r\n        XMLAttribute* a = FindOrCreateAttribute( name );\r\n        a->SetAttribute( value );\r\n    }\r\n\r\n    /**\r\n    \tDelete an attribute.\r\n    */\r\n    void DeleteAttribute( const char* name );\r\n\r\n    /// Return the first attribute in the list.\r\n    const XMLAttribute* FirstAttribute() const {\r\n        return _rootAttribute;\r\n    }\r\n    /// Query a specific attribute in the list.\r\n    const XMLAttribute* FindAttribute( const char* name ) const;\r\n\r\n    /** Convenience function for easy access to the text inside an element. Although easy\r\n    \tand concise, GetText() is limited compared to getting the XMLText child\r\n    \tand accessing it directly.\r\n\r\n    \tIf the first child of 'this' is a XMLText, the GetText()\r\n    \treturns the character string of the Text node, else null is returned.\r\n\r\n    \tThis is a convenient method for getting the text of simple contained text:\r\n    \t@verbatim\r\n    \t<foo>This is text</foo>\r\n    \t\tconst char* str = fooElement->GetText();\r\n    \t@endverbatim\r\n\r\n    \t'str' will be a pointer to \"This is text\".\r\n\r\n    \tNote that this function can be misleading. If the element foo was created from\r\n    \tthis XML:\r\n    \t@verbatim\r\n    \t\t<foo><b>This is text</b></foo>\r\n    \t@endverbatim\r\n\r\n    \tthen the value of str would be null. The first child node isn't a text node, it is\r\n    \tanother element. From this XML:\r\n    \t@verbatim\r\n    \t\t<foo>This is <b>text</b></foo>\r\n    \t@endverbatim\r\n    \tGetText() will return \"This is \".\r\n    */\r\n    const char* GetText() const;\r\n\r\n    /** Convenience function for easy access to the text inside an element. Although easy\r\n    \tand concise, SetText() is limited compared to creating an XMLText child\r\n    \tand mutating it directly.\r\n\r\n    \tIf the first child of 'this' is a XMLText, SetText() sets its value to\r\n\t\tthe given string, otherwise it will create a first child that is an XMLText.\r\n\r\n    \tThis is a convenient method for setting the text of simple contained text:\r\n    \t@verbatim\r\n    \t<foo>This is text</foo>\r\n    \t\tfooElement->SetText( \"Hullaballoo!\" );\r\n     \t<foo>Hullaballoo!</foo>\r\n\t\t@endverbatim\r\n\r\n    \tNote that this function can be misleading. If the element foo was created from\r\n    \tthis XML:\r\n    \t@verbatim\r\n    \t\t<foo><b>This is text</b></foo>\r\n    \t@endverbatim\r\n\r\n    \tthen it will not change \"This is text\", but rather prefix it with a text element:\r\n    \t@verbatim\r\n    \t\t<foo>Hullaballoo!<b>This is text</b></foo>\r\n    \t@endverbatim\r\n\r\n\t\tFor this XML:\r\n    \t@verbatim\r\n    \t\t<foo />\r\n    \t@endverbatim\r\n    \tSetText() will generate\r\n    \t@verbatim\r\n    \t\t<foo>Hullaballoo!</foo>\r\n    \t@endverbatim\r\n    */\r\n\tvoid SetText( const char* inText );\r\n    /// Convenience method for setting text inside an element. See SetText() for important limitations.\r\n    void SetText( int value );\r\n    /// Convenience method for setting text inside an element. See SetText() for important limitations.\r\n    void SetText( unsigned value );\r\n\t/// Convenience method for setting text inside an element. See SetText() for important limitations.\r\n\tvoid SetText(int64_t value);\r\n    /// Convenience method for setting text inside an element. See SetText() for important limitations.\r\n    void SetText(uint64_t value);\r\n\t/// Convenience method for setting text inside an element. See SetText() for important limitations.\r\n    void SetText( bool value );\r\n    /// Convenience method for setting text inside an element. See SetText() for important limitations.\r\n    void SetText( double value );\r\n    /// Convenience method for setting text inside an element. See SetText() for important limitations.\r\n    void SetText( float value );\r\n\r\n    /**\r\n    \tConvenience method to query the value of a child text node. This is probably best\r\n    \tshown by example. Given you have a document is this form:\r\n    \t@verbatim\r\n    \t\t<point>\r\n    \t\t\t<x>1</x>\r\n    \t\t\t<y>1.4</y>\r\n    \t\t</point>\r\n    \t@endverbatim\r\n\r\n    \tThe QueryIntText() and similar functions provide a safe and easier way to get to the\r\n    \t\"value\" of x and y.\r\n\r\n    \t@verbatim\r\n    \t\tint x = 0;\r\n    \t\tfloat y = 0;\t// types of x and y are contrived for example\r\n    \t\tconst XMLElement* xElement = pointElement->FirstChildElement( \"x\" );\r\n    \t\tconst XMLElement* yElement = pointElement->FirstChildElement( \"y\" );\r\n    \t\txElement->QueryIntText( &x );\r\n    \t\tyElement->QueryFloatText( &y );\r\n    \t@endverbatim\r\n\r\n    \t@returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted\r\n    \t\t\t to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.\r\n\r\n    */\r\n    XMLError QueryIntText( int* ival ) const;\r\n    /// See QueryIntText()\r\n    XMLError QueryUnsignedText( unsigned* uval ) const;\r\n\t/// See QueryIntText()\r\n\tXMLError QueryInt64Text(int64_t* uval) const;\r\n\t/// See QueryIntText()\r\n\tXMLError QueryUnsigned64Text(uint64_t* uval) const;\r\n\t/// See QueryIntText()\r\n    XMLError QueryBoolText( bool* bval ) const;\r\n    /// See QueryIntText()\r\n    XMLError QueryDoubleText( double* dval ) const;\r\n    /// See QueryIntText()\r\n    XMLError QueryFloatText( float* fval ) const;\r\n\r\n\tint IntText(int defaultValue = 0) const;\r\n\r\n\t/// See QueryIntText()\r\n\tunsigned UnsignedText(unsigned defaultValue = 0) const;\r\n\t/// See QueryIntText()\r\n\tint64_t Int64Text(int64_t defaultValue = 0) const;\r\n    /// See QueryIntText()\r\n    uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;\r\n\t/// See QueryIntText()\r\n\tbool BoolText(bool defaultValue = false) const;\r\n\t/// See QueryIntText()\r\n\tdouble DoubleText(double defaultValue = 0) const;\r\n\t/// See QueryIntText()\r\n    float FloatText(float defaultValue = 0) const;\r\n\r\n    /**\r\n        Convenience method to create a new XMLElement and add it as last (right)\r\n        child of this node. Returns the created and inserted element.\r\n    */\r\n    XMLElement* InsertNewChildElement(const char* name);\r\n    /// See InsertNewChildElement()\r\n    XMLComment* InsertNewComment(const char* comment);\r\n    /// See InsertNewChildElement()\r\n    XMLText* InsertNewText(const char* text);\r\n    /// See InsertNewChildElement()\r\n    XMLDeclaration* InsertNewDeclaration(const char* text);\r\n    /// See InsertNewChildElement()\r\n    XMLUnknown* InsertNewUnknown(const char* text);\r\n\r\n\r\n    // internal:\r\n    enum ElementClosingType {\r\n        OPEN,\t\t// <foo>\r\n        CLOSED,\t\t// <foo/>\r\n        CLOSING\t\t// </foo>\r\n    };\r\n    ElementClosingType ClosingType() const {\r\n        return _closingType;\r\n    }\r\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;\r\n    virtual bool ShallowEqual( const XMLNode* compare ) const override;\r\n\r\nprotected:\r\n    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;\r\n\r\nprivate:\r\n    XMLElement( XMLDocument* doc );\r\n    virtual ~XMLElement();\r\n    XMLElement( const XMLElement& );\t// not supported\r\n    void operator=( const XMLElement& );\t// not supported\r\n\r\n    XMLAttribute* FindOrCreateAttribute( const char* name );\r\n    char* ParseAttributes( char* p, int* curLineNumPtr );\r\n    static void DeleteAttribute( XMLAttribute* attribute );\r\n    XMLAttribute* CreateAttribute();\r\n\r\n    enum { BUF_SIZE = 200 };\r\n    ElementClosingType _closingType;\r\n    // The attribute list is ordered; there is no 'lastAttribute'\r\n    // because the list needs to be scanned for dupes before adding\r\n    // a new attribute.\r\n    XMLAttribute* _rootAttribute;\r\n};\r\n\r\n\r\nenum Whitespace {\r\n    PRESERVE_WHITESPACE,\r\n    COLLAPSE_WHITESPACE,\r\n    PEDANTIC_WHITESPACE\r\n};\r\n\r\n\r\n/** A Document binds together all the functionality.\r\n\tIt can be saved, loaded, and printed to the screen.\r\n\tAll Nodes are connected and allocated to a Document.\r\n\tIf the Document is deleted, all its Nodes are also deleted.\r\n*/\r\nclass TINYXML2_LIB XMLDocument : public XMLNode\r\n{\r\n    friend class XMLElement;\r\n    // Gives access to SetError and Push/PopDepth, but over-access for everything else.\r\n    // Wishing C++ had \"internal\" scope.\r\n    friend class XMLNode;\r\n    friend class XMLText;\r\n    friend class XMLComment;\r\n    friend class XMLDeclaration;\r\n    friend class XMLUnknown;\r\npublic:\r\n    /// constructor\r\n    XMLDocument( bool processEntities = true, Whitespace whitespaceMode = PRESERVE_WHITESPACE );\r\n    ~XMLDocument();\r\n\r\n    virtual XMLDocument* ToDocument() override\t\t{\r\n        TIXMLASSERT( this == _document );\r\n        return this;\r\n    }\r\n    virtual const XMLDocument* ToDocument() const override {\r\n        TIXMLASSERT( this == _document );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    \tParse an XML file from a character string.\r\n    \tReturns XML_SUCCESS (0) on success, or\r\n    \tan errorID.\r\n\r\n    \tYou may optionally pass in the 'nBytes', which is\r\n    \tthe number of bytes which will be parsed. If not\r\n    \tspecified, TinyXML-2 will assume 'xml' points to a\r\n    \tnull terminated string.\r\n    */\r\n    XMLError Parse( const char* xml, size_t nBytes=static_cast<size_t>(-1) );\r\n\r\n    /**\r\n    \tLoad an XML file from disk.\r\n    \tReturns XML_SUCCESS (0) on success, or\r\n    \tan errorID.\r\n    */\r\n    XMLError LoadFile( const char* filename );\r\n\r\n    /**\r\n    \tLoad an XML file from disk. You are responsible\r\n    \tfor providing and closing the FILE*.\r\n\r\n        NOTE: The file should be opened as binary (\"rb\")\r\n        not text in order for TinyXML-2 to correctly\r\n        do newline normalization.\r\n\r\n    \tReturns XML_SUCCESS (0) on success, or\r\n    \tan errorID.\r\n    */\r\n    XMLError LoadFile( FILE* );\r\n\r\n    /**\r\n    \tSave the XML file to disk.\r\n    \tReturns XML_SUCCESS (0) on success, or\r\n    \tan errorID.\r\n    */\r\n    XMLError SaveFile( const char* filename, bool compact = false );\r\n\r\n    /**\r\n    \tSave the XML file to disk. You are responsible\r\n    \tfor providing and closing the FILE*.\r\n\r\n    \tReturns XML_SUCCESS (0) on success, or\r\n    \tan errorID.\r\n    */\r\n    XMLError SaveFile( FILE* fp, bool compact = false );\r\n\r\n    bool ProcessEntities() const\t\t{\r\n        return _processEntities;\r\n    }\r\n    Whitespace WhitespaceMode() const\t{\r\n        return _whitespaceMode;\r\n    }\r\n\r\n    /**\r\n    \tReturns true if this document has a leading Byte Order Mark of UTF8.\r\n    */\r\n    bool HasBOM() const {\r\n        return _writeBOM;\r\n    }\r\n    /** Sets whether to write the BOM when writing the file.\r\n    */\r\n    void SetBOM( bool useBOM ) {\r\n        _writeBOM = useBOM;\r\n    }\r\n\r\n    /** Return the root element of DOM. Equivalent to FirstChildElement().\r\n        To get the first node, use FirstChild().\r\n    */\r\n    XMLElement* RootElement()\t\t\t\t{\r\n        return FirstChildElement();\r\n    }\r\n    const XMLElement* RootElement() const\t{\r\n        return FirstChildElement();\r\n    }\r\n\r\n    /** Print the Document. If the Printer is not provided, it will\r\n        print to stdout. If you provide Printer, this can print to a file:\r\n    \t@verbatim\r\n    \tXMLPrinter printer( fp );\r\n    \tdoc.Print( &printer );\r\n    \t@endverbatim\r\n\r\n    \tOr you can use a printer to print to memory:\r\n    \t@verbatim\r\n    \tXMLPrinter printer;\r\n    \tdoc.Print( &printer );\r\n    \t// printer.CStr() has a const char* to the XML\r\n    \t@endverbatim\r\n    */\r\n    void Print( XMLPrinter* streamer=0 ) const;\r\n    virtual bool Accept( XMLVisitor* visitor ) const override;\r\n\r\n    /**\r\n    \tCreate a new Element associated with\r\n    \tthis Document. The memory for the Element\r\n    \tis managed by the Document.\r\n    */\r\n    XMLElement* NewElement( const char* name );\r\n    /**\r\n    \tCreate a new Comment associated with\r\n    \tthis Document. The memory for the Comment\r\n    \tis managed by the Document.\r\n    */\r\n    XMLComment* NewComment( const char* comment );\r\n    /**\r\n    \tCreate a new Text associated with\r\n    \tthis Document. The memory for the Text\r\n    \tis managed by the Document.\r\n    */\r\n    XMLText* NewText( const char* text );\r\n    /**\r\n    \tCreate a new Declaration associated with\r\n    \tthis Document. The memory for the object\r\n    \tis managed by the Document.\r\n\r\n    \tIf the 'text' param is null, the standard\r\n    \tdeclaration is used.:\r\n    \t@verbatim\r\n    \t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    \t@endverbatim\r\n    */\r\n    XMLDeclaration* NewDeclaration( const char* text=0 );\r\n    /**\r\n    \tCreate a new Unknown associated with\r\n    \tthis Document. The memory for the object\r\n    \tis managed by the Document.\r\n    */\r\n    XMLUnknown* NewUnknown( const char* text );\r\n\r\n    /**\r\n    \tDelete a node associated with this document.\r\n    \tIt will be unlinked from the DOM.\r\n    */\r\n    void DeleteNode( XMLNode* node );\r\n\r\n    /// Clears the error flags.\r\n    void ClearError();\r\n\r\n    /// Return true if there was an error parsing the document.\r\n    bool Error() const {\r\n        return _errorID != XML_SUCCESS;\r\n    }\r\n    /// Return the errorID.\r\n    XMLError  ErrorID() const {\r\n        return _errorID;\r\n    }\r\n\tconst char* ErrorName() const;\r\n    static const char* ErrorIDToName(XMLError errorID);\r\n\r\n    /** Returns a \"long form\" error description. A hopefully helpful\r\n        diagnostic with location, line number, and/or additional info.\r\n    */\r\n\tconst char* ErrorStr() const;\r\n\r\n    /// A (trivial) utility function that prints the ErrorStr() to stdout.\r\n    void PrintError() const;\r\n\r\n    /// Return the line where the error occurred, or zero if unknown.\r\n    int ErrorLineNum() const\r\n    {\r\n        return _errorLineNum;\r\n    }\r\n\r\n    /// Clear the document, resetting it to the initial state.\r\n    void Clear();\r\n\r\n\t/**\r\n\t\tCopies this document to a target document.\r\n\t\tThe target will be completely cleared before the copy.\r\n\t\tIf you want to copy a sub-tree, see XMLNode::DeepClone().\r\n\r\n\t\tNOTE: that the 'target' must be non-null.\r\n\t*/\r\n\tvoid DeepCopy(XMLDocument* target) const;\r\n\r\n\t// internal\r\n    char* Identify( char* p, XMLNode** node, bool first );\r\n\r\n\t// internal\r\n\tvoid MarkInUse(const XMLNode* const);\r\n\r\n    virtual XMLNode* ShallowClone( XMLDocument* /*document*/ ) const override{\r\n        return 0;\r\n    }\r\n    virtual bool ShallowEqual( const XMLNode* /*compare*/ ) const override{\r\n        return false;\r\n    }\r\n\r\nprivate:\r\n    XMLDocument( const XMLDocument& );\t// not supported\r\n    void operator=( const XMLDocument& );\t// not supported\r\n\r\n    bool\t\t\t_writeBOM;\r\n    bool\t\t\t_processEntities;\r\n    XMLError\t\t_errorID;\r\n    Whitespace\t\t_whitespaceMode;\r\n    mutable StrPair\t_errorStr;\r\n    int             _errorLineNum;\r\n    char*\t\t\t_charBuffer;\r\n    int\t\t\t\t_parseCurLineNum;\r\n\tint\t\t\t\t_parsingDepth;\r\n\t// Memory tracking does add some overhead.\r\n\t// However, the code assumes that you don't\r\n\t// have a bunch of unlinked nodes around.\r\n\t// Therefore it takes less memory to track\r\n\t// in the document vs. a linked list in the XMLNode,\r\n\t// and the performance is the same.\r\n\tDynArray<XMLNode*, 10> _unlinked;\r\n\r\n    MemPoolT< sizeof(XMLElement) >\t _elementPool;\r\n    MemPoolT< sizeof(XMLAttribute) > _attributePool;\r\n    MemPoolT< sizeof(XMLText) >\t\t _textPool;\r\n    MemPoolT< sizeof(XMLComment) >\t _commentPool;\r\n\r\n\tstatic const char* _errorNames[XML_ERROR_COUNT];\r\n\r\n    void Parse();\r\n\r\n    void SetError( XMLError error, int lineNum, const char* format, ... );\r\n\r\n\t// Something of an obvious security hole, once it was discovered.\r\n\t// Either an ill-formed XML or an excessively deep one can overflow\r\n\t// the stack. Track stack depth, and error out if needed.\r\n\tclass DepthTracker {\r\n\tpublic:\r\n\t\texplicit DepthTracker(XMLDocument * document) {\r\n\t\t\tthis->_document = document;\r\n\t\t\tdocument->PushDepth();\r\n\t\t}\r\n\t\t~DepthTracker() {\r\n\t\t\t_document->PopDepth();\r\n\t\t}\r\n\tprivate:\r\n\t\tXMLDocument * _document;\r\n\t};\r\n\tvoid PushDepth();\r\n\tvoid PopDepth();\r\n\r\n    template<class NodeType, size_t PoolElementSize>\r\n    NodeType* CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool );\r\n};\r\n\r\ntemplate<class NodeType, size_t PoolElementSize>\r\ninline NodeType* XMLDocument::CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool )\r\n{\r\n    TIXMLASSERT( sizeof( NodeType ) == PoolElementSize );\r\n    TIXMLASSERT( sizeof( NodeType ) == pool.ItemSize() );\r\n    NodeType* returnNode = new (pool.Alloc()) NodeType( this );\r\n    TIXMLASSERT( returnNode );\r\n    returnNode->_memPool = &pool;\r\n\r\n\t_unlinked.Push(returnNode);\r\n    return returnNode;\r\n}\r\n\r\n/**\r\n\tA XMLHandle is a class that wraps a node pointer with null checks; this is\r\n\tan incredibly useful thing. Note that XMLHandle is not part of the TinyXML-2\r\n\tDOM structure. It is a separate utility class.\r\n\r\n\tTake an example:\r\n\t@verbatim\r\n\t<Document>\r\n\t\t<Element attributeA = \"valueA\">\r\n\t\t\t<Child attributeB = \"value1\" />\r\n\t\t\t<Child attributeB = \"value2\" />\r\n\t\t</Element>\r\n\t</Document>\r\n\t@endverbatim\r\n\r\n\tAssuming you want the value of \"attributeB\" in the 2nd \"Child\" element, it's very\r\n\teasy to write a *lot* of code that looks like:\r\n\r\n\t@verbatim\r\n\tXMLElement* root = document.FirstChildElement( \"Document\" );\r\n\tif ( root )\r\n\t{\r\n\t\tXMLElement* element = root->FirstChildElement( \"Element\" );\r\n\t\tif ( element )\r\n\t\t{\r\n\t\t\tXMLElement* child = element->FirstChildElement( \"Child\" );\r\n\t\t\tif ( child )\r\n\t\t\t{\r\n\t\t\t\tXMLElement* child2 = child->NextSiblingElement( \"Child\" );\r\n\t\t\t\tif ( child2 )\r\n\t\t\t\t{\r\n\t\t\t\t\t// Finally do something useful.\r\n\t@endverbatim\r\n\r\n\tAnd that doesn't even cover \"else\" cases. XMLHandle addresses the verbosity\r\n\tof such code. A XMLHandle checks for null pointers so it is perfectly safe\r\n\tand correct to use:\r\n\r\n\t@verbatim\r\n\tXMLHandle docHandle( &document );\r\n\tXMLElement* child2 = docHandle.FirstChildElement( \"Document\" ).FirstChildElement( \"Element\" ).FirstChildElement().NextSiblingElement();\r\n\tif ( child2 )\r\n\t{\r\n\t\t// do something useful\r\n\t@endverbatim\r\n\r\n\tWhich is MUCH more concise and useful.\r\n\r\n\tIt is also safe to copy handles - internally they are nothing more than node pointers.\r\n\t@verbatim\r\n\tXMLHandle handleCopy = handle;\r\n\t@endverbatim\r\n\r\n\tSee also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.\r\n*/\r\nclass TINYXML2_LIB XMLHandle\r\n{\r\npublic:\r\n    /// Create a handle from any node (at any depth of the tree.) This can be a null pointer.\r\n    explicit XMLHandle( XMLNode* node ) : _node( node ) {\r\n    }\r\n    /// Create a handle from a node.\r\n    explicit XMLHandle( XMLNode& node ) : _node( &node ) {\r\n    }\r\n    /// Copy constructor\r\n    XMLHandle( const XMLHandle& ref ) : _node( ref._node ) {\r\n    }\r\n    /// Assignment\r\n    XMLHandle& operator=( const XMLHandle& ref )\t\t\t\t\t\t\t{\r\n        _node = ref._node;\r\n        return *this;\r\n    }\r\n\r\n    /// Get the first child of this handle.\r\n    XMLHandle FirstChild() \t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n        return XMLHandle( _node ? _node->FirstChild() : 0 );\r\n    }\r\n    /// Get the first child element of this handle.\r\n    XMLHandle FirstChildElement( const char* name = 0 )\t\t\t\t\t\t{\r\n        return XMLHandle( _node ? _node->FirstChildElement( name ) : 0 );\r\n    }\r\n    /// Get the last child of this handle.\r\n    XMLHandle LastChild()\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n        return XMLHandle( _node ? _node->LastChild() : 0 );\r\n    }\r\n    /// Get the last child element of this handle.\r\n    XMLHandle LastChildElement( const char* name = 0 )\t\t\t\t\t\t{\r\n        return XMLHandle( _node ? _node->LastChildElement( name ) : 0 );\r\n    }\r\n    /// Get the previous sibling of this handle.\r\n    XMLHandle PreviousSibling()\t\t\t\t\t\t\t\t\t\t\t\t{\r\n        return XMLHandle( _node ? _node->PreviousSibling() : 0 );\r\n    }\r\n    /// Get the previous sibling element of this handle.\r\n    XMLHandle PreviousSiblingElement( const char* name = 0 )\t\t\t\t{\r\n        return XMLHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );\r\n    }\r\n    /// Get the next sibling of this handle.\r\n    XMLHandle NextSibling()\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n        return XMLHandle( _node ? _node->NextSibling() : 0 );\r\n    }\r\n    /// Get the next sibling element of this handle.\r\n    XMLHandle NextSiblingElement( const char* name = 0 )\t\t\t\t\t{\r\n        return XMLHandle( _node ? _node->NextSiblingElement( name ) : 0 );\r\n    }\r\n\r\n    /// Safe cast to XMLNode. This can return null.\r\n    XMLNode* ToNode()\t\t\t\t\t\t\t{\r\n        return _node;\r\n    }\r\n    /// Safe cast to XMLElement. This can return null.\r\n    XMLElement* ToElement() \t\t\t\t\t{\r\n        return ( _node ? _node->ToElement() : 0 );\r\n    }\r\n    /// Safe cast to XMLText. This can return null.\r\n    XMLText* ToText() \t\t\t\t\t\t\t{\r\n        return ( _node ? _node->ToText() : 0 );\r\n    }\r\n    /// Safe cast to XMLUnknown. This can return null.\r\n    XMLUnknown* ToUnknown() \t\t\t\t\t{\r\n        return ( _node ? _node->ToUnknown() : 0 );\r\n    }\r\n    /// Safe cast to XMLDeclaration. This can return null.\r\n    XMLDeclaration* ToDeclaration() \t\t\t{\r\n        return ( _node ? _node->ToDeclaration() : 0 );\r\n    }\r\n\r\nprivate:\r\n    XMLNode* _node;\r\n};\r\n\r\n\r\n/**\r\n\tA variant of the XMLHandle class for working with const XMLNodes and Documents. It is the\r\n\tsame in all regards, except for the 'const' qualifiers. See XMLHandle for API.\r\n*/\r\nclass TINYXML2_LIB XMLConstHandle\r\n{\r\npublic:\r\n    explicit XMLConstHandle( const XMLNode* node ) : _node( node ) {\r\n    }\r\n    explicit XMLConstHandle( const XMLNode& node ) : _node( &node ) {\r\n    }\r\n    XMLConstHandle( const XMLConstHandle& ref ) : _node( ref._node ) {\r\n    }\r\n\r\n    XMLConstHandle& operator=( const XMLConstHandle& ref )\t\t\t\t\t\t\t{\r\n        _node = ref._node;\r\n        return *this;\r\n    }\r\n\r\n    const XMLConstHandle FirstChild() const\t\t\t\t\t\t\t\t\t\t\t{\r\n        return XMLConstHandle( _node ? _node->FirstChild() : 0 );\r\n    }\r\n    const XMLConstHandle FirstChildElement( const char* name = 0 ) const\t\t\t\t{\r\n        return XMLConstHandle( _node ? _node->FirstChildElement( name ) : 0 );\r\n    }\r\n    const XMLConstHandle LastChild()\tconst\t\t\t\t\t\t\t\t\t\t{\r\n        return XMLConstHandle( _node ? _node->LastChild() : 0 );\r\n    }\r\n    const XMLConstHandle LastChildElement( const char* name = 0 ) const\t\t\t\t{\r\n        return XMLConstHandle( _node ? _node->LastChildElement( name ) : 0 );\r\n    }\r\n    const XMLConstHandle PreviousSibling() const\t\t\t\t\t\t\t\t\t{\r\n        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );\r\n    }\r\n    const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const\t\t{\r\n        return XMLConstHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );\r\n    }\r\n    const XMLConstHandle NextSibling() const\t\t\t\t\t\t\t\t\t\t{\r\n        return XMLConstHandle( _node ? _node->NextSibling() : 0 );\r\n    }\r\n    const XMLConstHandle NextSiblingElement( const char* name = 0 ) const\t\t\t{\r\n        return XMLConstHandle( _node ? _node->NextSiblingElement( name ) : 0 );\r\n    }\r\n\r\n\r\n    const XMLNode* ToNode() const\t\t\t\t{\r\n        return _node;\r\n    }\r\n    const XMLElement* ToElement() const\t\t\t{\r\n        return ( _node ? _node->ToElement() : 0 );\r\n    }\r\n    const XMLText* ToText() const\t\t\t\t{\r\n        return ( _node ? _node->ToText() : 0 );\r\n    }\r\n    const XMLUnknown* ToUnknown() const\t\t\t{\r\n        return ( _node ? _node->ToUnknown() : 0 );\r\n    }\r\n    const XMLDeclaration* ToDeclaration() const\t{\r\n        return ( _node ? _node->ToDeclaration() : 0 );\r\n    }\r\n\r\nprivate:\r\n    const XMLNode* _node;\r\n};\r\n\r\n\r\n/**\r\n\tPrinting functionality. The XMLPrinter gives you more\r\n\toptions than the XMLDocument::Print() method.\r\n\r\n\tIt can:\r\n\t-# Print to memory.\r\n\t-# Print to a file you provide.\r\n\t-# Print XML without a XMLDocument.\r\n\r\n\tPrint to Memory\r\n\r\n\t@verbatim\r\n\tXMLPrinter printer;\r\n\tdoc.Print( &printer );\r\n\tSomeFunction( printer.CStr() );\r\n\t@endverbatim\r\n\r\n\tPrint to a File\r\n\r\n\tYou provide the file pointer.\r\n\t@verbatim\r\n\tXMLPrinter printer( fp );\r\n\tdoc.Print( &printer );\r\n\t@endverbatim\r\n\r\n\tPrint without a XMLDocument\r\n\r\n\tWhen loading, an XML parser is very useful. However, sometimes\r\n\twhen saving, it just gets in the way. The code is often set up\r\n\tfor streaming, and constructing the DOM is just overhead.\r\n\r\n\tThe Printer supports the streaming case. The following code\r\n\tprints out a trivially simple XML file without ever creating\r\n\tan XML document.\r\n\r\n\t@verbatim\r\n\tXMLPrinter printer( fp );\r\n\tprinter.OpenElement( \"foo\" );\r\n\tprinter.PushAttribute( \"foo\", \"bar\" );\r\n\tprinter.CloseElement();\r\n\t@endverbatim\r\n*/\r\nclass TINYXML2_LIB XMLPrinter : public XMLVisitor\r\n{\r\npublic:\r\n    /** Construct the printer. If the FILE* is specified,\r\n    \tthis will print to the FILE. Else it will print\r\n    \tto memory, and the result is available in CStr().\r\n    \tIf 'compact' is set to true, then output is created\r\n    \twith only required whitespace and newlines.\r\n    */\r\n    XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 );\r\n    virtual ~XMLPrinter()\t{}\r\n\r\n    /** If streaming, write the BOM and declaration. */\r\n    void PushHeader( bool writeBOM, bool writeDeclaration );\r\n    /** If streaming, start writing an element.\r\n        The element must be closed with CloseElement()\r\n    */\r\n    void OpenElement( const char* name, bool compactMode=false );\r\n    /// If streaming, add an attribute to an open element.\r\n    void PushAttribute( const char* name, const char* value );\r\n    void PushAttribute( const char* name, int value );\r\n    void PushAttribute( const char* name, unsigned value );\r\n\tvoid PushAttribute( const char* name, int64_t value );\r\n\tvoid PushAttribute( const char* name, uint64_t value );\r\n\tvoid PushAttribute( const char* name, bool value );\r\n    void PushAttribute( const char* name, double value );\r\n    /// If streaming, close the Element.\r\n    virtual void CloseElement( bool compactMode=false );\r\n\r\n    /// Add a text node.\r\n    void PushText( const char* text, bool cdata=false );\r\n    /// Add a text node from an integer.\r\n    void PushText( int value );\r\n    /// Add a text node from an unsigned.\r\n    void PushText( unsigned value );\r\n\t/// Add a text node from a signed 64bit integer.\r\n\tvoid PushText( int64_t value );\r\n\t/// Add a text node from an unsigned 64bit integer.\r\n\tvoid PushText( uint64_t value );\r\n\t/// Add a text node from a bool.\r\n    void PushText( bool value );\r\n    /// Add a text node from a float.\r\n    void PushText( float value );\r\n    /// Add a text node from a double.\r\n    void PushText( double value );\r\n\r\n    /// Add a comment\r\n    void PushComment( const char* comment );\r\n\r\n    void PushDeclaration( const char* value );\r\n    void PushUnknown( const char* value );\r\n\r\n    virtual bool VisitEnter( const XMLDocument& /*doc*/ ) override;\r\n    virtual bool VisitExit( const XMLDocument& /*doc*/ ) override\t{\r\n        return true;\r\n    }\r\n\r\n    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute ) override;\r\n    virtual bool VisitExit( const XMLElement& element ) override;\r\n\r\n    virtual bool Visit( const XMLText& text ) override;\r\n    virtual bool Visit( const XMLComment& comment ) override;\r\n    virtual bool Visit( const XMLDeclaration& declaration ) override;\r\n    virtual bool Visit( const XMLUnknown& unknown ) override;\r\n\r\n    /**\r\n    \tIf in print to memory mode, return a pointer to\r\n    \tthe XML file in memory.\r\n    */\r\n    const char* CStr() const {\r\n        return _buffer.Mem();\r\n    }\r\n    /**\r\n    \tIf in print to memory mode, return the size\r\n    \tof the XML file in memory. (Note the size returned\r\n    \tincludes the terminating null.)\r\n    */\r\n    size_t CStrSize() const {\r\n        return _buffer.Size();\r\n    }\r\n    /**\r\n    \tIf in print to memory mode, reset the buffer to the\r\n    \tbeginning.\r\n    */\r\n    void ClearBuffer( bool resetToFirstElement = true ) {\r\n        _buffer.Clear();\r\n        _buffer.Push(0);\r\n\t\t_firstElement = resetToFirstElement;\r\n    }\r\n\r\nprotected:\r\n\tvirtual bool CompactMode( const XMLElement& )\t{ return _compactMode; }\r\n\r\n\t/** Prints out the space before an element. You may override to change\r\n\t    the space and tabs used. A PrintSpace() override should call Print().\r\n\t*/\r\n    virtual void PrintSpace( int depth );\r\n    virtual void Print( const char* format, ... );\r\n    virtual void Write( const char* data, size_t size );\r\n    virtual void Putc( char ch );\r\n\r\n    inline void Write(const char* data) { Write(data, strlen(data)); }\r\n\r\n    void SealElementIfJustOpened();\r\n    bool _elementJustOpened;\r\n    DynArray< const char*, 10 > _stack;\r\n\r\nprivate:\r\n    /**\r\n       Prepares to write a new node. This includes sealing an element that was\r\n       just opened, and writing any whitespace necessary if not in compact mode.\r\n     */\r\n    void PrepareForNewNode( bool compactMode );\r\n    void PrintString( const char*, bool restrictedEntitySet );\t// prints out, after detecting entities.\r\n\r\n    bool _firstElement;\r\n    FILE* _fp;\r\n    int _depth;\r\n    int _textDepth;\r\n    bool _processEntities;\r\n\tbool _compactMode;\r\n\r\n    enum {\r\n        ENTITY_RANGE = 64,\r\n        BUF_SIZE = 200\r\n    };\r\n    bool _entityFlag[ENTITY_RANGE];\r\n    bool _restrictedEntityFlag[ENTITY_RANGE];\r\n\r\n    DynArray< char, 20 > _buffer;\r\n\r\n    // Prohibit cloning, intentionally not implemented\r\n    XMLPrinter( const XMLPrinter& );\r\n    XMLPrinter& operator=( const XMLPrinter& );\r\n};\r\n\r\n\r\n} // namespace tinyxml2\r\n\r\n#if defined(_MSC_VER)\r\n#   pragma warning(pop)\r\n#endif\r\n\r\n#endif // TINYXML2_INCLUDED\r\n"
        },
        {
          "name": "xmltest.cpp",
          "type": "blob",
          "size": 94.4755859375,
          "content": "#if defined( _MSC_VER )\r\n\t#if !defined( _CRT_SECURE_NO_WARNINGS )\r\n\t\t#define _CRT_SECURE_NO_WARNINGS\t\t// This test file is not intended to be secure.\r\n\t#endif\r\n#endif\r\n\r\n#include \"tinyxml2.h\"\r\n#include <cerrno>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <ctime>\r\n\r\n#if defined( _MSC_VER ) || defined (WIN32)\r\n\t#include <crtdbg.h>\r\n\t#define WIN32_LEAN_AND_MEAN\r\n\t#include <windows.h>\r\n\t_CrtMemState startMemState;\r\n\t_CrtMemState endMemState;\r\n#else\r\n\t#include <sys/stat.h>\r\n\t#include <sys/types.h>\r\n#endif\r\n\r\nusing namespace tinyxml2;\r\nusing namespace std;\r\nint gPass = 0;\r\nint gFail = 0;\r\n\r\n\r\nbool XMLTest (const char* testString, const char* expected, const char* found, bool echo=true, bool extraNL=false )\r\n{\r\n\tbool pass;\r\n\tif ( !expected && !found )\r\n\t\tpass = true;\r\n\telse if ( !expected || !found )\r\n\t\tpass = false;\r\n\telse\r\n\t\tpass = !strcmp( expected, found );\r\n\tif ( pass )\r\n\t\tprintf (\"[pass]\");\r\n\telse\r\n\t\tprintf (\"[fail]\");\r\n\r\n\tif ( !echo ) {\r\n\t\tprintf (\" %s\\n\", testString);\r\n\t}\r\n\telse {\r\n\t\tif ( extraNL ) {\r\n\t\t\tprintf( \" %s\\n\", testString );\r\n\t\t\tprintf( \"%s\\n\", expected );\r\n\t\t\tprintf( \"%s\\n\", found );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tprintf (\" %s [%s][%s]\\n\", testString, expected, found);\r\n\t\t}\r\n\t}\r\n\r\n\tif ( pass )\r\n\t\t++gPass;\r\n\telse\r\n\t\t++gFail;\r\n\treturn pass;\r\n}\r\n\r\nbool XMLTest(const char* testString, XMLError expected, XMLError found, bool echo = true, bool extraNL = false)\r\n{\r\n    return XMLTest(testString, XMLDocument::ErrorIDToName(expected), XMLDocument::ErrorIDToName(found), echo, extraNL);\r\n}\r\n\r\nbool XMLTest(const char* testString, bool expected, bool found, bool echo = true, bool extraNL = false)\r\n{\r\n    return XMLTest(testString, expected ? \"true\" : \"false\", found ? \"true\" : \"false\", echo, extraNL);\r\n}\r\n\r\ntemplate< class T > bool XMLTest( const char* testString, T expected, T found, bool echo=true )\r\n{\r\n\tbool pass = ( expected == found );\r\n\tif ( pass )\r\n\t\tprintf (\"[pass]\");\r\n\telse\r\n\t\tprintf (\"[fail]\");\r\n\r\n\tif ( !echo )\r\n\t\tprintf (\" %s\\n\", testString);\r\n\telse {\r\n\t\tchar expectedAsString[64];\r\n\t\tXMLUtil::ToStr(expected, expectedAsString, sizeof(expectedAsString));\r\n\r\n\t\tchar foundAsString[64];\r\n\t\tXMLUtil::ToStr(found, foundAsString, sizeof(foundAsString));\r\n\r\n\t\tprintf (\" %s [%s][%s]\\n\", testString, expectedAsString, foundAsString );\r\n\t}\r\n\r\n\tif ( pass )\r\n\t\t++gPass;\r\n\telse\r\n\t\t++gFail;\r\n\treturn pass;\r\n}\r\n\r\n\r\nvoid NullLineEndings( char* p )\r\n{\r\n\twhile( p && *p ) {\r\n\t\tif ( *p == '\\n' || *p == '\\r' ) {\r\n\t\t\t*p = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t++p;\r\n\t}\r\n}\r\n\r\n\r\nint example_1()\r\n{\r\n\tXMLDocument doc;\r\n\tdoc.LoadFile( \"resources/dream.xml\" );\r\n\r\n\treturn doc.ErrorID();\r\n}\r\n/** @page Example_1 Load an XML File\r\n *  @dontinclude ./xmltest.cpp\r\n *  Basic XML file loading.\r\n *  The basic syntax to load an XML file from\r\n *  disk and check for an error. (ErrorID()\r\n *  will return 0 for no error.)\r\n *  @skip example_1()\r\n *  @until }\r\n */\r\n\r\n\r\nint example_2()\r\n{\r\n\tstatic const char* xml = \"<element/>\";\r\n\tXMLDocument doc;\r\n\tdoc.Parse( xml );\r\n\r\n\treturn doc.ErrorID();\r\n}\r\n/** @page Example_2 Parse an XML from char buffer\r\n *  @dontinclude ./xmltest.cpp\r\n *  Basic XML string parsing.\r\n *  The basic syntax to parse an XML for\r\n *  a char* and check for an error. (ErrorID()\r\n *  will return 0 for no error.)\r\n *  @skip example_2()\r\n *  @until }\r\n */\r\n\r\n\r\nint example_3()\r\n{\r\n\tstatic const char* xml =\r\n\t\t\"<?xml version=\\\"1.0\\\"?>\"\r\n\t\t\"<!DOCTYPE PLAY SYSTEM \\\"play.dtd\\\">\"\r\n\t\t\"<PLAY>\"\r\n\t\t\"<TITLE>A Midsummer Night's Dream</TITLE>\"\r\n\t\t\"</PLAY>\";\r\n\r\n\tXMLDocument doc;\r\n\tdoc.Parse( xml );\r\n\r\n\tXMLElement* titleElement = doc.FirstChildElement( \"PLAY\" )->FirstChildElement( \"TITLE\" );\r\n\tconst char* title = titleElement->GetText();\r\n\tprintf( \"Name of play (1): %s\\n\", title );\r\n\r\n\tXMLText* textNode = titleElement->FirstChild()->ToText();\r\n\ttitle = textNode->Value();\r\n\tprintf( \"Name of play (2): %s\\n\", title );\r\n\r\n\treturn doc.ErrorID();\r\n}\r\n/** @page Example_3 Get information out of XML\r\n\t@dontinclude ./xmltest.cpp\r\n\tIn this example, we navigate a simple XML\r\n\tfile, and read some interesting text. Note\r\n\tthat this example doesn't use error\r\n\tchecking; working code should check for null\r\n\tpointers when walking an XML tree, or use\r\n\tXMLHandle.\r\n\r\n\t(The XML is an excerpt from \"dream.xml\").\r\n\r\n\t@skip example_3()\r\n\t@until </PLAY>\";\r\n\r\n\tThe structure of the XML file is:\r\n\r\n\t<ul>\r\n\t\t<li>(declaration)</li>\r\n\t\t<li>(dtd stuff)</li>\r\n\t\t<li>Element \"PLAY\"</li>\r\n\t\t<ul>\r\n\t\t\t<li>Element \"TITLE\"</li>\r\n\t\t\t<ul>\r\n\t\t\t    <li>Text \"A Midsummer Night's Dream\"</li>\r\n\t\t\t</ul>\r\n\t\t</ul>\r\n\t</ul>\r\n\r\n\tFor this example, we want to print out the\r\n\ttitle of the play. The text of the title (what\r\n\twe want) is child of the \"TITLE\" element which\r\n\tis a child of the \"PLAY\" element.\r\n\r\n\tWe want to skip the declaration and dtd, so the\r\n\tmethod FirstChildElement() is a good choice. The\r\n\tFirstChildElement() of the Document is the \"PLAY\"\r\n\tElement, the FirstChildElement() of the \"PLAY\" Element\r\n\tis the \"TITLE\" Element.\r\n\r\n\t@until ( \"TITLE\" );\r\n\r\n\tWe can then use the convenience function GetText()\r\n\tto get the title of the play.\r\n\r\n\t@until title );\r\n\r\n\tText is just another Node in the XML DOM. And in\r\n\tfact you should be a little cautious with it, as\r\n\ttext nodes can contain elements.\r\n\r\n\t@verbatim\r\n\tConsider: A Midsummer Night's <b>Dream</b>\r\n\t@endverbatim\r\n\r\n\tIt is more correct to actually query the Text Node\r\n\tif in doubt:\r\n\r\n\t@until title );\r\n\r\n\tNoting that here we use FirstChild() since we are\r\n\tlooking for XMLText, not an element, and ToText()\r\n\tis a cast from a Node to a XMLText.\r\n*/\r\n\r\n\r\nbool example_4()\r\n{\r\n\tstatic const char* xml =\r\n\t\t\"<information>\"\r\n\t\t\"\t<attributeApproach v='2' />\"\r\n\t\t\"\t<textApproach>\"\r\n\t\t\"\t\t<v>2</v>\"\r\n\t\t\"\t</textApproach>\"\r\n\t\t\"</information>\";\r\n\r\n\tXMLDocument doc;\r\n\tdoc.Parse( xml );\r\n\r\n\tint v0 = 0;\r\n\tint v1 = 0;\r\n\r\n\tXMLElement* attributeApproachElement = doc.FirstChildElement()->FirstChildElement( \"attributeApproach\" );\r\n\tattributeApproachElement->QueryIntAttribute( \"v\", &v0 );\r\n\r\n\tXMLElement* textApproachElement = doc.FirstChildElement()->FirstChildElement( \"textApproach\" );\r\n\ttextApproachElement->FirstChildElement( \"v\" )->QueryIntText( &v1 );\r\n\r\n\tprintf( \"Both values are the same: %d and %d\\n\", v0, v1 );\r\n\r\n\treturn !doc.Error() && ( v0 == v1 );\r\n}\r\n/** @page Example_4 Read attributes and text information.\r\n\t@dontinclude ./xmltest.cpp\r\n\r\n\tThere are fundamentally 2 ways of writing a key-value\r\n\tpair into an XML file. (Something that's always annoyed\r\n\tme about XML.) Either by using attributes, or by writing\r\n\tthe key name into an element and the value into\r\n\tthe text node wrapped by the element. Both approaches\r\n\tare illustrated in this example, which shows two ways\r\n\tto encode the value \"2\" into the key \"v\":\r\n\r\n\t@skip example_4()\r\n\t@until \"</information>\";\r\n\r\n\tTinyXML-2 has accessors for both approaches.\r\n\r\n\tWhen using an attribute, you navigate to the XMLElement\r\n\twith that attribute and use the QueryIntAttribute()\r\n\tgroup of methods. (Also QueryFloatAttribute(), etc.)\r\n\r\n\t@skip XMLElement* attributeApproachElement\r\n\t@until &v0 );\r\n\r\n\tWhen using the text approach, you need to navigate\r\n\tdown one more step to the XMLElement that contains\r\n\tthe text. Note the extra FirstChildElement( \"v\" )\r\n\tin the code below. The value of the text can then\r\n\tbe safely queried with the QueryIntText() group\r\n\tof methods. (Also QueryFloatText(), etc.)\r\n\r\n\t@skip XMLElement* textApproachElement\r\n\t@until &v1 );\r\n*/\r\n\r\n\r\nint main( int argc, const char ** argv )\r\n{\r\n\t#if defined( _MSC_VER ) && defined( TINYXML2_DEBUG )\r\n\t\t_CrtMemCheckpoint( &startMemState );\r\n\t\t// Enable MS Visual C++ debug heap memory leaks dump on exit\r\n\t\t_CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);\r\n\t\t{\r\n\t\t\tint leaksOnStart = _CrtDumpMemoryLeaks();\r\n\t\t\tXMLTest( \"No leaks on start?\", FALSE, leaksOnStart );\r\n\t\t}\r\n\t#endif\r\n\r\n\t{\r\n\t\tTIXMLASSERT( true );\r\n\t}\r\n\r\n\tif ( argc > 1 ) {\r\n\t\tXMLDocument* doc = new XMLDocument();\r\n\t\tclock_t startTime = clock();\r\n\t\tdoc->LoadFile( argv[1] );\r\n \t\tclock_t loadTime = clock();\r\n\t\tint errorID = doc->ErrorID();\r\n\t\tdelete doc; doc = 0;\r\n \t\tclock_t deleteTime = clock();\r\n\r\n\t\tprintf( \"Test file '%s' loaded. ErrorID=%d\\n\", argv[1], errorID );\r\n\t\tif ( !errorID ) {\r\n\t\t\tprintf( \"Load time=%u\\n\",   (unsigned)(loadTime - startTime) );\r\n\t\t\tprintf( \"Delete time=%u\\n\", (unsigned)(deleteTime - loadTime) );\r\n\t\t\tprintf( \"Total time=%u\\n\",  (unsigned)(deleteTime - startTime) );\r\n\t\t}\r\n\t\texit(0);\r\n\t}\r\n\r\n\tFILE* fp = fopen( \"resources/dream.xml\", \"r\" );\r\n\tif ( !fp ) {\r\n\t\tprintf( \"Error opening test file 'dream.xml'.\\n\"\r\n\t\t\t\t\"Is your working directory the same as where \\n\"\r\n\t\t\t\t\"the xmltest.cpp and dream.xml file are?\\n\\n\"\r\n\t#if defined( _MSC_VER )\r\n\t\t\t\t\"In windows Visual Studio you may need to set\\n\"\r\n\t\t\t\t\"Properties->Debugging->Working Directory to '..'\\n\"\r\n\t#endif\r\n\t\t\t  );\r\n\t\texit( 1 );\r\n\t}\r\n\tfclose( fp );\r\n\r\n\tXMLTest( \"Example_1\", 0, example_1() );\r\n\tXMLTest( \"Example_2\", 0, example_2() );\r\n\tXMLTest( \"Example_3\", 0, example_3() );\r\n\tXMLTest( \"Example_4\", true, example_4() );\r\n\r\n\t/* ------ Example 2: Lookup information. ---- */\r\n\r\n\t{\r\n\t\tstatic const char* test[] = {\t\"<element />\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element><subelement/></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element><subelement></subelement></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element><subelement><subsub/></subelement></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<!--comment beside elements--><element><subelement></subelement></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<!--comment beside elements, this time with spaces-->  \\n <element>  <subelement> \\n </subelement> </element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element attrib1='foo' attrib2=\\\"bar\\\" ></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element attrib1='foo' attrib2=\\\"bar\\\" ><subelement attrib3='yeehaa' /></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element>Text inside element.</element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element><b></b></element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element>Text inside and <b>bolded</b> in the element.</element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<outer><element>Text inside and <b>bolded</b> in the element.</element></outer>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element>This &amp; That.</element>\",\r\n\t\t\t\t\t\t\t\t\t\t\"<element attrib='This&lt;That' />\",\r\n\t\t\t\t\t\t\t\t\t\t0\r\n\t\t};\r\n\t\tfor( int i=0; test[i]; ++i ) {\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.Parse( test[i] );\r\n\t\t\tXMLTest( \"Element test\", false, doc.Error() );\r\n\t\t\tdoc.Print();\r\n\t\t\tprintf( \"----------------------------------------------\\n\" );\r\n\t\t}\r\n\t}\r\n#if 1\r\n\t{\r\n\t\tstatic const char* test = \"<!--hello world\\n\"\r\n\t\t\t\t\t\t\t\t  \"          line 2\\r\"\r\n\t\t\t\t\t\t\t\t  \"          line 3\\r\\n\"\r\n\t\t\t\t\t\t\t\t  \"          line 4\\n\\r\"\r\n\t\t\t\t\t\t\t\t  \"          line 5\\r-->\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( test );\r\n\t\tXMLTest( \"Hello world declaration\", false, doc.Error() );\r\n\t\tdoc.Print();\r\n\t}\r\n\r\n\t{\r\n\t\t// This test is pre-test for the next one\r\n\t\t// (where Element1 is inserted \"after itself\".\r\n\t\t// This code didn't use to crash.\r\n\t\tXMLDocument doc;\r\n\t\tXMLElement* element1 = doc.NewElement(\"Element1\");\r\n\t\tXMLElement* element2 = doc.NewElement(\"Element2\");\r\n\t\tdoc.InsertEndChild(element1);\r\n\t\tdoc.InsertEndChild(element2);\r\n\t\tdoc.InsertAfterChild(element2, element2);\r\n\t\tdoc.InsertAfterChild(element2, element2);\r\n\t}\r\n\r\n\t{\r\n\t\tXMLDocument doc;\r\n\t\tXMLElement* element1 = doc.NewElement(\"Element1\");\r\n\t\tXMLElement* element2 = doc.NewElement(\"Element2\");\r\n\t\tdoc.InsertEndChild(element1);\r\n\t\tdoc.InsertEndChild(element2);\r\n\r\n\t\t// This insertion \"after itself\"\r\n\t\t// used to cause invalid memory access and crash\r\n\t\tdoc.InsertAfterChild(element1, element1);\r\n\t\tdoc.InsertAfterChild(element1, element1);\r\n\t\tdoc.InsertAfterChild(element2, element2);\r\n\t\tdoc.InsertAfterChild(element2, element2);\r\n\t}\r\n\r\n\t{\r\n\t\tstatic const char* test = \"<element>Text before.</element>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( test );\r\n\t\tXMLTest( \"Element text before\", false, doc.Error() );\r\n\t\tXMLElement* root = doc.FirstChildElement();\r\n\t\tXMLElement* newElement = doc.NewElement( \"Subelement\" );\r\n\t\troot->InsertEndChild( newElement );\r\n\t\tdoc.Print();\r\n\t}\r\n\t{\r\n\t\tXMLDocument* doc = new XMLDocument();\r\n\t\tstatic const char* test = \"<element><sub/></element>\";\r\n\t\tdoc->Parse( test );\r\n\t\tXMLTest( \"Element with sub element\", false, doc->Error() );\r\n\t\tdelete doc;\r\n\t}\r\n\t{\r\n\t\t// Test: Programmatic DOM nodes insertion return values\r\n\t\tXMLDocument doc;\r\n\r\n\t\tXMLNode* first = doc.NewElement( \"firstElement\" );\r\n\t\tXMLTest( \"New element\", true, first != 0 );\r\n\t\tXMLNode* firstAfterInsertion = doc.InsertFirstChild( first );\r\n\t\tXMLTest( \"New element inserted first\", true, firstAfterInsertion == first );\r\n\r\n\t\tXMLNode* last = doc.NewElement( \"lastElement\" );\r\n\t\tXMLTest( \"New element\", true, last != 0 );\r\n\t\tXMLNode* lastAfterInsertion = doc.InsertEndChild( last );\r\n\t\tXMLTest( \"New element inserted last\", true, lastAfterInsertion == last );\r\n\r\n\t\tXMLNode* middle = doc.NewElement( \"middleElement\" );\r\n\t\tXMLTest( \"New element\", true, middle != 0 );\r\n\t\tXMLNode* middleAfterInsertion = doc.InsertAfterChild( first, middle );\r\n\t\tXMLTest( \"New element inserted middle\", true, middleAfterInsertion == middle );\r\n\t}\r\n\t{\r\n\t\t// Test: Programmatic DOM\r\n\t\t// Build:\r\n\t\t//\t\t<element>\r\n\t\t//\t\t\t<!--comment-->\r\n\t\t//\t\t\t<sub attrib=\"0\" />\r\n\t\t//\t\t\t<sub attrib=\"1\" />\r\n\t\t//\t\t\t<sub attrib=\"2\" >& Text!</sub>\r\n\t\t//\t\t<element>\r\n\r\n\t\tXMLDocument* doc = new XMLDocument();\r\n\t\tXMLNode* element = doc->InsertEndChild( doc->NewElement( \"element\" ) );\r\n\r\n\t\tXMLElement* sub[3] = { doc->NewElement( \"sub\" ), doc->NewElement( \"sub\" ), doc->NewElement( \"sub\" ) };\r\n\t\tfor( int i=0; i<3; ++i ) {\r\n\t\t\tsub[i]->SetAttribute( \"attrib\", i );\r\n\t\t}\r\n\t\telement->InsertEndChild( sub[2] );\r\n\r\n\t\tconst int dummyInitialValue = 1000;\r\n\t\tint dummyValue = dummyInitialValue;\r\n\r\n\t\tXMLNode* comment = element->InsertFirstChild( doc->NewComment( \"comment\" ) );\r\n\t\tcomment->SetUserData(&dummyValue);\r\n\t\telement->InsertAfterChild( comment, sub[0] );\r\n\t\telement->InsertAfterChild( sub[0], sub[1] );\r\n\t\tsub[2]->InsertFirstChild( doc->NewText( \"& Text!\" ));\r\n\t\tdoc->Print();\r\n\t\tXMLTest( \"Programmatic DOM\", \"comment\", doc->FirstChildElement( \"element\" )->FirstChild()->Value() );\r\n\t\tXMLTest( \"Programmatic DOM\", \"0\", doc->FirstChildElement( \"element\" )->FirstChildElement()->Attribute( \"attrib\" ) );\r\n\t\tXMLTest( \"Programmatic DOM\", 2, doc->FirstChildElement()->LastChildElement( \"sub\" )->IntAttribute( \"attrib\" ) );\r\n\t\tXMLTest( \"Programmatic DOM\", \"& Text!\",\r\n\t\t\t\t doc->FirstChildElement()->LastChildElement( \"sub\" )->FirstChild()->ToText()->Value() );\r\n\t\tXMLTest(\"User data - pointer\", true, &dummyValue == comment->GetUserData(), false);\r\n\t\tXMLTest(\"User data - value behind pointer\", dummyInitialValue, dummyValue, false);\r\n\r\n\t\t// And now deletion:\r\n\t\telement->DeleteChild( sub[2] );\r\n\t\tdoc->DeleteNode( comment );\r\n\r\n\t\telement->FirstChildElement()->SetAttribute( \"attrib\", true );\r\n\t\telement->LastChildElement()->DeleteAttribute( \"attrib\" );\r\n\r\n\t\tXMLTest( \"Programmatic DOM\", true, doc->FirstChildElement()->FirstChildElement()->BoolAttribute( \"attrib\" ) );\r\n\t\tconst int defaultIntValue = 10;\r\n\t\tconst int replacementIntValue = 20;\r\n\t\tint value1 = defaultIntValue;\r\n\t\tint value2 = doc->FirstChildElement()->LastChildElement()->IntAttribute( \"attrib\", replacementIntValue );\r\n\t\tXMLError result = doc->FirstChildElement()->LastChildElement()->QueryIntAttribute( \"attrib\", &value1 );\r\n\t\tXMLTest( \"Programmatic DOM\", XML_NO_ATTRIBUTE, result );\r\n\t\tXMLTest( \"Programmatic DOM\", defaultIntValue, value1 );\r\n\t\tXMLTest( \"Programmatic DOM\", replacementIntValue, value2 );\r\n\r\n\t\tdoc->Print();\r\n\r\n\t\t{\r\n\t\t\tXMLPrinter streamer;\r\n\t\t\tdoc->Print( &streamer );\r\n\t\t\tprintf( \"%s\", streamer.CStr() );\r\n\t\t}\r\n\t\t{\r\n\t\t\tXMLPrinter streamer( 0, true );\r\n\t\t\tdoc->Print( &streamer );\r\n\t\t\tXMLTest( \"Compact mode\", \"<element><sub attrib=\\\"true\\\"/><sub/></element>\", streamer.CStr(), false );\r\n\t\t}\r\n\t\tdoc->SaveFile( \"./resources/out/pretty.xml\" );\r\n\t\tXMLTest( \"Save pretty.xml\", false, doc->Error() );\r\n\t\tdoc->SaveFile( \"./resources/out/compact.xml\", true );\r\n\t\tXMLTest( \"Save compact.xml\", false, doc->Error() );\r\n\t\tdelete doc;\r\n\t}\r\n\t{\r\n\t\t// Test: Dream\r\n\t\t// XML1 : 1,187,569 bytes\tin 31,209 allocations\r\n\t\t// XML2 :   469,073\tbytes\tin    323 allocations\r\n\t\t//int newStart = gNew;\r\n\t\tXMLDocument doc;\r\n\t\tdoc.LoadFile( \"resources/dream.xml\" );\r\n\t\tXMLTest( \"Load dream.xml\", false, doc.Error() );\r\n\r\n\t\tdoc.SaveFile( \"resources/out/dreamout.xml\" );\r\n\t\tXMLTest( \"Save dreamout.xml\", false, doc.Error() );\r\n\t\tdoc.PrintError();\r\n\r\n\t\tXMLTest( \"Dream\", \"xml version=\\\"1.0\\\"\",\r\n\t\t\t\t\t\t  doc.FirstChild()->ToDeclaration()->Value() );\r\n\t\tXMLTest( \"Dream\", true, doc.FirstChild()->NextSibling()->ToUnknown() != 0 );\r\n\t\tXMLTest( \"Dream\", \"DOCTYPE PLAY SYSTEM \\\"play.dtd\\\"\",\r\n\t\t\t\t\t\t  doc.FirstChild()->NextSibling()->ToUnknown()->Value() );\r\n\t\tXMLTest( \"Dream\", \"And Robin shall restore amends.\",\r\n\t\t\t\t\t\t  doc.LastChild()->LastChild()->LastChild()->LastChild()->LastChildElement()->GetText() );\r\n\t\tXMLTest( \"Dream\", \"And Robin shall restore amends.\",\r\n\t\t\t\t\t\t  doc.LastChild()->LastChild()->LastChild()->LastChild()->LastChildElement()->GetText() );\r\n\r\n\t\tXMLDocument doc2;\r\n\t\tdoc2.LoadFile( \"resources/out/dreamout.xml\" );\r\n\t\tXMLTest( \"Load dreamout.xml\", false, doc2.Error() );\r\n\t\tXMLTest( \"Dream-out\", \"xml version=\\\"1.0\\\"\",\r\n\t\t\t\t\t\t  doc2.FirstChild()->ToDeclaration()->Value() );\r\n\t\tXMLTest( \"Dream-out\", true, doc2.FirstChild()->NextSibling()->ToUnknown() != 0 );\r\n\t\tXMLTest( \"Dream-out\", \"DOCTYPE PLAY SYSTEM \\\"play.dtd\\\"\",\r\n\t\t\t\t\t\t  doc2.FirstChild()->NextSibling()->ToUnknown()->Value() );\r\n\t\tXMLTest( \"Dream-out\", \"And Robin shall restore amends.\",\r\n\t\t\t\t\t\t  doc2.LastChild()->LastChild()->LastChild()->LastChild()->LastChildElement()->GetText() );\r\n\r\n\t\t//gNewTotal = gNew - newStart;\r\n\t}\r\n\r\n\r\n\t{\r\n\t\tconst char* error =\t\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\" ?>\\n\"\r\n\t\t\t\t\t\t\t\"<passages count=\\\"006\\\" formatversion=\\\"20020620\\\">\\n\"\r\n\t\t\t\t\t\t\t\"    <wrong error>\\n\"\r\n\t\t\t\t\t\t\t\"</passages>\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( error );\r\n\t\tXMLTest( \"Bad XML\", XML_ERROR_PARSING_ATTRIBUTE, doc.ErrorID() );\r\n\t\tconst char* errorStr = doc.ErrorStr();\r\n\t\tXMLTest(\"Formatted error string\",\r\n\t\t\t\"Error=XML_ERROR_PARSING_ATTRIBUTE ErrorID=7 (0x7) Line number=3: XMLElement name=wrong\",\r\n\t\t\terrorStr);\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* str = \"<doc attr0='1' attr1='2.0' attr2='foo' />\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Top level attributes\", false, doc.Error() );\r\n\r\n\t\tXMLElement* ele = doc.FirstChildElement();\r\n\r\n\t\tint iVal;\r\n\t\tXMLError result;\r\n\t\tdouble dVal;\r\n\r\n\t\tresult = ele->QueryDoubleAttribute( \"attr0\", &dVal );\r\n\t\tXMLTest( \"Query attribute: int as double\", XML_SUCCESS, result);\r\n\t\tXMLTest( \"Query attribute: int as double\", 1, (int)dVal );\r\n\t\tXMLTest( \"Query attribute: int as double\", 1, (int)ele->DoubleAttribute(\"attr0\"));\r\n\r\n\t\tresult = ele->QueryDoubleAttribute( \"attr1\", &dVal );\r\n\t\tXMLTest( \"Query attribute: double as double\", XML_SUCCESS, result);\r\n\t\tXMLTest( \"Query attribute: double as double\", 2.0, dVal );\r\n\t\tXMLTest( \"Query attribute: double as double\", 2.0, ele->DoubleAttribute(\"attr1\") );\r\n\r\n\t\tresult = ele->QueryIntAttribute( \"attr1\", &iVal );\r\n\t\tXMLTest( \"Query attribute: double as int\", XML_SUCCESS, result);\r\n\t\tXMLTest( \"Query attribute: double as int\", 2, iVal );\r\n\r\n\t\tresult = ele->QueryIntAttribute( \"attr2\", &iVal );\r\n\t\tXMLTest( \"Query attribute: not a number\", XML_WRONG_ATTRIBUTE_TYPE, result );\r\n\t\tXMLTest( \"Query attribute: not a number\", 4.0, ele->DoubleAttribute(\"attr2\", 4.0) );\r\n\r\n\t\tresult = ele->QueryIntAttribute( \"bar\", &iVal );\r\n\t\tXMLTest( \"Query attribute: does not exist\", XML_NO_ATTRIBUTE, result );\r\n\t\tXMLTest( \"Query attribute: does not exist\", true, ele->BoolAttribute(\"bar\", true) );\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* str = \"<doc/>\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Empty top element\", false, doc.Error() );\r\n\r\n\t\tXMLElement* ele = doc.FirstChildElement();\r\n\r\n\t\tint iVal, iVal2;\r\n\t\tdouble dVal, dVal2;\r\n\r\n\t\tele->SetAttribute( \"str\", \"strValue\" );\r\n\t\tele->SetAttribute( \"int\", 1 );\r\n\t\tele->SetAttribute( \"double\", -1.0 );\r\n\r\n\t\tconst char* answer = 0;\r\n\t\tele->QueryAttribute(\"str\", &answer);\r\n\t\tXMLTest(\"Query char attribute\", \"strValue\", answer);\r\n\r\n\t\tconst char* cStr = ele->Attribute( \"str\" );\r\n\t\t{\r\n\t\t\tXMLError queryResult = ele->QueryIntAttribute( \"int\", &iVal );\r\n\t\t\tXMLTest( \"Query int attribute\", XML_SUCCESS, queryResult);\r\n\t\t}\r\n\t\t{\r\n\t\t\tXMLError queryResult = ele->QueryDoubleAttribute( \"double\", &dVal );\r\n\t\t\tXMLTest( \"Query double attribute\", XML_SUCCESS, queryResult);\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tXMLError queryResult = ele->QueryAttribute( \"int\", &iVal2 );\r\n\t\t\tXMLTest( \"Query int attribute generic\", (int)XML_SUCCESS, queryResult);\r\n\t\t}\r\n\t\t{\r\n\t\t\tXMLError queryResult = ele->QueryAttribute( \"double\", &dVal2 );\r\n\t\t\tXMLTest( \"Query double attribute generic\", (int)XML_SUCCESS, queryResult);\r\n\t\t}\r\n\r\n\t\tXMLTest( \"Attribute match test\", \"strValue\", ele->Attribute( \"str\", \"strValue\" ) );\r\n\t\tXMLTest( \"Attribute round trip. c-string.\", \"strValue\", cStr );\r\n\t\tXMLTest( \"Attribute round trip. int.\", 1, iVal );\r\n\t\tXMLTest( \"Attribute round trip. double.\", -1, (int)dVal );\r\n\t\tXMLTest( \"Alternate query\", true, iVal == iVal2 );\r\n\t\tXMLTest( \"Alternate query\", true, dVal == dVal2 );\r\n\t\tXMLTest( \"Alternate query\", true, iVal == ele->IntAttribute(\"int\") );\r\n\t\tXMLTest( \"Alternate query\", true, dVal == ele->DoubleAttribute(\"double\") );\r\n\t}\r\n\r\n\t{\r\n\t\tXMLDocument doc;\r\n\t\tdoc.LoadFile( \"resources/utf8test.xml\" );\r\n\t\tXMLTest( \"Load utf8test.xml\", false, doc.Error() );\r\n\r\n\t\t// Get the attribute \"value\" from the \"Russian\" element and check it.\r\n\t\tXMLElement* element = doc.FirstChildElement( \"document\" )->FirstChildElement( \"Russian\" );\r\n\t\tconst unsigned char correctValue[] = {\t0xd1U, 0x86U, 0xd0U, 0xb5U, 0xd0U, 0xbdU, 0xd0U, 0xbdU,\r\n\t\t\t\t\t\t\t\t\t\t\t\t0xd0U, 0xbeU, 0xd1U, 0x81U, 0xd1U, 0x82U, 0xd1U, 0x8cU, 0 };\r\n\r\n\t\tXMLTest( \"UTF-8: Russian value.\", (const char*)correctValue, element->Attribute( \"value\" ) );\r\n\r\n\t\tconst unsigned char russianElementName[] = {\t0xd0U, 0xa0U, 0xd1U, 0x83U,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t0xd1U, 0x81U, 0xd1U, 0x81U,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t0xd0U, 0xbaU, 0xd0U, 0xb8U,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t0xd0U, 0xb9U, 0 };\r\n\t\tconst char russianText[] = \"<\\xD0\\xB8\\xD0\\xBC\\xD0\\xB5\\xD0\\xB5\\xD1\\x82>\";\r\n\r\n\t\tXMLText* text = doc.FirstChildElement( \"document\" )->FirstChildElement( (const char*) russianElementName )->FirstChild()->ToText();\r\n\t\tXMLTest( \"UTF-8: Browsing russian element name.\",\r\n\t\t\t\t russianText,\r\n\t\t\t\t text->Value() );\r\n\r\n\t\t// Now try for a round trip.\r\n\t\tdoc.SaveFile( \"resources/out/utf8testout.xml\" );\r\n\t\tXMLTest( \"UTF-8: Save testout.xml\", false, doc.Error() );\r\n\r\n\t\t// Check the round trip.\r\n\t\tbool roundTripOkay = false;\r\n\r\n\t\tFILE* saved  = fopen( \"resources/out/utf8testout.xml\", \"r\" );\r\n\t\tXMLTest( \"UTF-8: Open utf8testout.xml\", true, saved != 0 );\r\n\r\n\t\tFILE* verify = fopen( \"resources/utf8testverify.xml\", \"r\" );\r\n\t\tXMLTest( \"UTF-8: Open utf8testverify.xml\", true, verify != 0 );\r\n\r\n\t\tif ( saved && verify )\r\n\t\t{\r\n\t\t\troundTripOkay = true;\r\n\t\t\tchar verifyBuf[256];\r\n\t\t\twhile ( fgets( verifyBuf, 256, verify ) )\r\n\t\t\t{\r\n\t\t\t\tchar savedBuf[256];\r\n\t\t\t\tfgets( savedBuf, 256, saved );\r\n\t\t\t\tNullLineEndings( verifyBuf );\r\n\t\t\t\tNullLineEndings( savedBuf );\r\n\r\n\t\t\t\tif ( strcmp( verifyBuf, savedBuf ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf( \"verify:%s<\\n\", verifyBuf );\r\n\t\t\t\t\tprintf( \"saved :%s<\\n\", savedBuf );\r\n\t\t\t\t\troundTripOkay = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ( saved )\r\n\t\t\tfclose( saved );\r\n\t\tif ( verify )\r\n\t\t\tfclose( verify );\r\n\t\tXMLTest( \"UTF-8: Verified multi-language round trip.\", true, roundTripOkay );\r\n\t}\r\n\r\n\t// --------GetText()-----------\r\n\t{\r\n\t\tconst char* str = \"<foo>This is  text</foo>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Double whitespace\", false, doc.Error() );\r\n\t\tconst XMLElement* element = doc.RootElement();\r\n\r\n\t\tXMLTest( \"GetText() normal use.\", \"This is  text\", element->GetText() );\r\n\r\n\t\tstr = \"<foo><b>This is text</b></foo>\";\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Bold text simulation\", false, doc.Error() );\r\n\t\telement = doc.RootElement();\r\n\r\n\t\tXMLTest( \"GetText() contained element.\", element->GetText() == 0, true );\r\n\t}\r\n\r\n\r\n\t// --------SetText()-----------\r\n\t{\r\n\t\tconst char* str = \"<foo></foo>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Empty closed element\", false, doc.Error() );\r\n\t\tXMLElement* element = doc.RootElement();\r\n\r\n\t\telement->SetText(\"darkness.\");\r\n\t\tXMLTest( \"SetText() normal use (open/close).\", \"darkness.\", element->GetText() );\r\n\r\n\t\telement->SetText(\"blue flame.\");\r\n\t\tXMLTest( \"SetText() replace.\", \"blue flame.\", element->GetText() );\r\n\r\n\t\tstr = \"<foo/>\";\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Empty self-closed element\", false, doc.Error() );\r\n\t\telement = doc.RootElement();\r\n\r\n\t\telement->SetText(\"The driver\");\r\n\t\tXMLTest( \"SetText() normal use. (self-closing)\", \"The driver\", element->GetText() );\r\n\r\n\t\telement->SetText(\"<b>horses</b>\");\r\n\t\tXMLTest( \"SetText() replace with tag-like text.\", \"<b>horses</b>\", element->GetText() );\r\n\t\t//doc.Print();\r\n\r\n\t\tstr = \"<foo><bar>Text in nested element</bar></foo>\";\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Text in nested element\", false, doc.Error() );\r\n\t\telement = doc.RootElement();\r\n\r\n\t\telement->SetText(\"wolves\");\r\n\t\tXMLTest( \"SetText() prefix to nested non-text children.\", \"wolves\", element->GetText() );\r\n\r\n\t\tstr = \"<foo/>\";\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Empty self-closed element round 2\", false, doc.Error() );\r\n\t\telement = doc.RootElement();\r\n\r\n\t\telement->SetText( \"str\" );\r\n\t\tXMLTest( \"SetText types\", \"str\", element->GetText() );\r\n\r\n\t\telement->SetText( 1 );\r\n\t\tXMLTest( \"SetText types\", \"1\", element->GetText() );\r\n\r\n\t\telement->SetText( 1U );\r\n\t\tXMLTest( \"SetText types\", \"1\", element->GetText() );\r\n\r\n\t\telement->SetText( true );\r\n\t\tXMLTest( \"SetText types\", \"true\", element->GetText() );\r\n\r\n\t\telement->SetText( 1.5f );\r\n\t\tXMLTest( \"SetText types\", \"1.5\", element->GetText() );\r\n\r\n\t\telement->SetText( 1.5 );\r\n\t\tXMLTest( \"SetText types\", \"1.5\", element->GetText() );\r\n\t}\r\n\r\n\t// ---------- Attributes ---------\r\n\t{\r\n\t\tstatic const int64_t BIG = -123456789012345678;\r\n        static const uint64_t BIG_POS = 123456789012345678;\r\n\t\tXMLDocument doc;\r\n\t\tXMLElement* element = doc.NewElement(\"element\");\r\n\t\tdoc.InsertFirstChild(element);\r\n\r\n\t\t{\r\n\t\t\telement->SetAttribute(\"attrib\", int(-100));\r\n\t\t\t{\r\n\t\t\t\tint v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryIntAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: int\", XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: int\", -100, v, true);\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tint v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: int\", (int)XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: int\", -100, v, true);\r\n\t\t\t}\r\n\t\t\tXMLTest(\"Attribute: int\", -100, element->IntAttribute(\"attrib\"), true);\r\n\t\t}\r\n\t\t{\r\n\t\t\telement->SetAttribute(\"attrib\", unsigned(100));\r\n\t\t\t{\r\n\t\t\t\tunsigned v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryUnsignedAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: unsigned\", XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: unsigned\", unsigned(100), v, true);\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tunsigned v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: unsigned\", (int)XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: unsigned\", unsigned(100), v, true);\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tconst char* v = \"failed\";\r\n\t\t\t\tXMLError queryResult = element->QueryStringAttribute(\"not-attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: string default\", false, queryResult == XML_SUCCESS);\r\n\t\t\t\tqueryResult = element->QueryStringAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: string\", XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: string\", \"100\", v);\r\n\t\t\t}\r\n\t\t\tXMLTest(\"Attribute: unsigned\", unsigned(100), element->UnsignedAttribute(\"attrib\"), true);\r\n\t\t}\r\n\t\t{\r\n\t\t\telement->SetAttribute(\"attrib\", BIG);\r\n\t\t\t{\r\n\t\t\t\tint64_t v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryInt64Attribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: int64_t\", XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: int64_t\", BIG, v, true);\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tint64_t v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: int64_t\", (int)XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: int64_t\", BIG, v, true);\r\n\t\t\t}\r\n\t\t\tXMLTest(\"Attribute: int64_t\", BIG, element->Int64Attribute(\"attrib\"), true);\r\n\t\t}\r\n        {\r\n            element->SetAttribute(\"attrib\", BIG_POS);\r\n            {\r\n                uint64_t v = 0;\r\n                XMLError queryResult = element->QueryUnsigned64Attribute(\"attrib\", &v);\r\n                XMLTest(\"Attribute: uint64_t\", XML_SUCCESS, queryResult, true);\r\n                XMLTest(\"Attribute: uint64_t\", BIG_POS, v, true);\r\n            }\r\n            {\r\n                uint64_t v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryAttribute(\"attrib\", &v);\r\n                XMLTest(\"Attribute: uint64_t\", (int)XML_SUCCESS, queryResult, true);\r\n                XMLTest(\"Attribute: uint64_t\", BIG_POS, v, true);\r\n            }\r\n            XMLTest(\"Attribute: uint64_t\", BIG_POS, element->Unsigned64Attribute(\"attrib\"), true);\r\n        }\r\n        {\r\n\t\t\telement->SetAttribute(\"attrib\", true);\r\n\t\t\t{\r\n\t\t\t\tbool v = false;\r\n\t\t\t\tXMLError queryResult = element->QueryBoolAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: bool\", XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: bool\", true, v, true);\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tbool v = false;\r\n\t\t\t\tXMLError queryResult = element->QueryAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: bool\", (int)XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: bool\", true, v, true);\r\n\t\t\t}\r\n\t\t\tXMLTest(\"Attribute: bool\", true, element->BoolAttribute(\"attrib\"), true);\r\n\t\t}\r\n\t\t{\r\n\t\t\telement->SetAttribute(\"attrib\", true);\r\n\t\t\tconst char* result = element->Attribute(\"attrib\");\r\n\t\t\tXMLTest(\"Bool true is 'true'\", \"true\", result);\r\n\r\n\t\t\tXMLUtil::SetBoolSerialization(\"1\", \"0\");\r\n\t\t\telement->SetAttribute(\"attrib\", true);\r\n\t\t\tresult = element->Attribute(\"attrib\");\r\n\t\t\tXMLTest(\"Bool true is '1'\", \"1\", result);\r\n\r\n\t\t\tXMLUtil::SetBoolSerialization(0, 0);\r\n\t\t}\r\n\t\t{\r\n\t\t\telement->SetAttribute(\"attrib\", 100.0);\r\n\t\t\t{\r\n\t\t\t\tdouble v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryDoubleAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: double\", XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: double\", 100.0, v, true);\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tdouble v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: bool\", (int)XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: double\", 100.0, v, true);\r\n\t\t\t}\r\n\t\t\tXMLTest(\"Attribute: double\", 100.0, element->DoubleAttribute(\"attrib\"), true);\r\n\t\t}\r\n\t\t{\r\n\t\t\telement->SetAttribute(\"attrib\", 100.0f);\r\n\t\t\t{\r\n\t\t\t\tfloat v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryFloatAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: float\", XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: float\", 100.0f, v, true);\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tfloat v = 0;\r\n\t\t\t\tXMLError queryResult = element->QueryAttribute(\"attrib\", &v);\r\n\t\t\t\tXMLTest(\"Attribute: float\", (int)XML_SUCCESS, queryResult, true);\r\n\t\t\t\tXMLTest(\"Attribute: float\", 100.0f, v, true);\r\n\t\t\t}\r\n\t\t\tXMLTest(\"Attribute: float\", 100.0f, element->FloatAttribute(\"attrib\"), true);\r\n\t\t}\r\n\t\t{\r\n\t\t\telement->SetText(BIG);\r\n\t\t\tint64_t v = 0;\r\n\t\t\tXMLError queryResult = element->QueryInt64Text(&v);\r\n\t\t\tXMLTest(\"Element: int64_t\", XML_SUCCESS, queryResult, true);\r\n\t\t\tXMLTest(\"Element: int64_t\", BIG, v, true);\r\n\t\t}\r\n        {\r\n            element->SetText(BIG_POS);\r\n            uint64_t v = 0;\r\n            XMLError queryResult = element->QueryUnsigned64Text(&v);\r\n            XMLTest(\"Element: uint64_t\", XML_SUCCESS, queryResult, true);\r\n            XMLTest(\"Element: uint64_t\", BIG_POS, v, true);\r\n        }\r\n    }\r\n\r\n\t// ---------- XMLPrinter stream mode ------\r\n\t{\r\n\t\t{\r\n\t\t\tFILE* printerfp = fopen(\"resources/out/printer.xml\", \"w\");\r\n\t\t\tXMLTest(\"Open printer.xml\", true, printerfp != 0);\r\n\t\t\tXMLPrinter printer(printerfp);\r\n\t\t\tprinter.OpenElement(\"foo\");\r\n\t\t\tprinter.PushAttribute(\"attrib-text\", \"text\");\r\n\t\t\tprinter.PushAttribute(\"attrib-int\", int(1));\r\n\t\t\tprinter.PushAttribute(\"attrib-unsigned\", unsigned(2));\r\n\t\t\tprinter.PushAttribute(\"attrib-int64\", int64_t(3));\r\n\t\t\tprinter.PushAttribute(\"attrib-uint64\", uint64_t(37));\r\n\t\t\tprinter.PushAttribute(\"attrib-bool\", true);\r\n\t\t\tprinter.PushAttribute(\"attrib-double\", 4.0);\r\n\t\t\tprinter.CloseElement();\r\n\t\t\tfclose(printerfp);\r\n\t\t}\r\n\t\t{\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.LoadFile(\"resources/out/printer.xml\");\r\n\t\t\tXMLTest(\"XMLPrinter Stream mode: load\", XML_SUCCESS, doc.ErrorID(), true);\r\n\r\n\t\t\tconst XMLDocument& cdoc = doc;\r\n\r\n\t\t\tconst XMLAttribute* attrib = cdoc.FirstChildElement(\"foo\")->FindAttribute(\"attrib-text\");\r\n\t\t\tXMLTest(\"attrib-text\", \"text\", attrib->Value(), true);\r\n\t\t\tattrib = cdoc.FirstChildElement(\"foo\")->FindAttribute(\"attrib-int\");\r\n\t\t\tXMLTest(\"attrib-int\", int(1), attrib->IntValue(), true);\r\n\t\t\tattrib = cdoc.FirstChildElement(\"foo\")->FindAttribute(\"attrib-unsigned\");\r\n\t\t\tXMLTest(\"attrib-unsigned\", unsigned(2), attrib->UnsignedValue(), true);\r\n\t\t\tattrib = cdoc.FirstChildElement(\"foo\")->FindAttribute(\"attrib-int64\");\r\n\t\t\tXMLTest(\"attrib-int64\", int64_t(3), attrib->Int64Value(), true);\r\n\t\t\tattrib = cdoc.FirstChildElement(\"foo\")->FindAttribute(\"attrib-uint64\");\r\n\t\t\tXMLTest(\"attrib-uint64\", uint64_t(37), attrib->Unsigned64Value(), true);\r\n\t\t\tattrib = cdoc.FirstChildElement(\"foo\")->FindAttribute(\"attrib-bool\");\r\n\t\t\tXMLTest(\"attrib-bool\", true, attrib->BoolValue(), true);\r\n\t\t\tattrib = cdoc.FirstChildElement(\"foo\")->FindAttribute(\"attrib-double\");\r\n\t\t\tXMLTest(\"attrib-double\", 4.0, attrib->DoubleValue(), true);\r\n\t\t}\r\n\t\t// Add API_testcatse :PushDeclaration();PushText();PushComment()\r\n\t\t{\r\n\t\t\tFILE* fp1 = fopen(\"resources/out/printer_1.xml\", \"w\");\r\n\t\t\tXMLPrinter printer(fp1);\r\n\r\n\t\t\tprinter.PushDeclaration(\"version = '1.0' enconding = 'utf-8'\");\r\n\r\n\t\t\tprinter.OpenElement(\"foo\");\r\n\t\t\tprinter.PushAttribute(\"attrib-text\", \"text\");\r\n\r\n\t\t\tprinter.OpenElement(\"text\");\r\n\t\t\tprinter.PushText(\"Tinyxml2\");\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"int\");\r\n\t\t\tprinter.PushText(int(11));\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"unsigned\");\r\n\t\t\tprinter.PushText(unsigned(12));\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"int64_t\");\r\n\t\t\tprinter.PushText(int64_t(13));\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"uint64_t\");\r\n\t\t\tprinter.PushText(uint64_t(14));\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"bool\");\r\n\t\t\tprinter.PushText(true);\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"float\");\r\n\t\t\tprinter.PushText(\"1.56\");\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"double\");\r\n\t\t\tprinter.PushText(\"12.12\");\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.OpenElement(\"comment\");\r\n\t\t\tprinter.PushComment(\"this is Tinyxml2\");\r\n\t\t\tprinter.CloseElement();\r\n\r\n\t\t\tprinter.CloseElement();\r\n\t\t\tfclose(fp1);\r\n\t\t}\r\n\t\t{\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.LoadFile(\"resources/out/printer_1.xml\");\r\n\t\t\tXMLTest(\"XMLPrinter Stream mode: load\", XML_SUCCESS, doc.ErrorID(), true);\r\n\r\n\t\t\tconst XMLDocument& cdoc = doc;\r\n\r\n\t\t\tconst  XMLElement* root = cdoc.FirstChildElement(\"foo\");\r\n\r\n\t\t\tconst char* text_value;\r\n\t\t\ttext_value = root->FirstChildElement(\"text\")->GetText();\r\n\t\t\tXMLTest(\"PushText( const char* text, bool cdata=false ) test\", \"Tinyxml2\", text_value);\r\n\r\n\t\t\tint  int_value;\r\n\t\t\tint_value = root->FirstChildElement(\"int\")->IntText();\r\n\t\t\tXMLTest(\"PushText( int value ) test\", 11, int_value);\r\n\r\n\t\t\tunsigned  unsigned_value;\r\n\t\t\tunsigned_value = root->FirstChildElement(\"unsigned\")->UnsignedText();\r\n\t\t\tXMLTest(\"PushText( unsigned value ) test\", (unsigned)12, unsigned_value);\r\n\r\n\t\t\tint64_t  int64_t_value;\r\n\t\t\tint64_t_value = root->FirstChildElement(\"int64_t\")->Int64Text();\r\n\t\t\tXMLTest(\"PushText( int64_t value ) test\", (int64_t) 13, int64_t_value);\r\n\r\n\t\t\tuint64_t uint64_t_value;\r\n\t\t\tuint64_t_value = root->FirstChildElement(\"uint64_t\")->Unsigned64Text();\r\n\t\t\tXMLTest(\"PushText( uint64_t value ) test\", (uint64_t) 14, uint64_t_value);\r\n\r\n\t\t\tfloat  float_value;\r\n\t\t\tfloat_value = root->FirstChildElement(\"float\")->FloatText();\r\n\t\t\tXMLTest(\"PushText( float value ) test\", 1.56f, float_value);\r\n\r\n\t\t\tdouble double_value;\r\n\t\t\tdouble_value = root->FirstChildElement(\"double\")->DoubleText();\r\n\t\t\tXMLTest(\"PushText( double value ) test\", 12.12, double_value);\r\n\r\n\t\t\tbool bool_value;\r\n\t\t\tbool_value = root->FirstChildElement(\"bool\")->BoolText();\r\n\t\t\tXMLTest(\"PushText( bool value ) test\", true, bool_value);\r\n\r\n\t\t\tconst XMLComment* comment = root->FirstChildElement(\"comment\")->FirstChild()->ToComment();\r\n\t\t\tconst char* comment_value = comment->Value();\r\n\t\t\tXMLTest(\"PushComment() test\", \"this is Tinyxml2\", comment_value);\r\n\r\n\t\t\tconst XMLDeclaration* declaration = cdoc.FirstChild()->ToDeclaration();\r\n\t\t\tconst char* declaration_value = declaration->Value();\r\n\t\t\tXMLTest(\"PushDeclaration() test\", \"version = '1.0' enconding = 'utf-8'\", declaration_value);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// ---------- CDATA ---------------\r\n\t{\r\n\t\tconst char* str =\t\"<xmlElement>\"\r\n\t\t\t\t\t\t\t\t\"<![CDATA[\"\r\n\t\t\t\t\t\t\t\t\t\"I am > the rules!\\n\"\r\n\t\t\t\t\t\t\t\t\t\"...since I make symbolic puns\"\r\n\t\t\t\t\t\t\t\t\"]]>\"\r\n\t\t\t\t\t\t\t\"</xmlElement>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"CDATA symbolic puns round 1\", false, doc.Error() );\r\n\t\tdoc.Print();\r\n\r\n\t\tXMLTest( \"CDATA parse.\", \"I am > the rules!\\n...since I make symbolic puns\",\r\n\t\t\t\t\t\t\t\t doc.FirstChildElement()->FirstChild()->Value(),\r\n\t\t\t\t\t\t\t\t false );\r\n\t}\r\n\r\n\t// ----------- CDATA -------------\r\n\t{\r\n\t\tconst char* str =\t\"<xmlElement>\"\r\n\t\t\t\t\t\t\t\t\"<![CDATA[\"\r\n\t\t\t\t\t\t\t\t\t\"<b>I am > the rules!</b>\\n\"\r\n\t\t\t\t\t\t\t\t\t\"...since I make symbolic puns\"\r\n\t\t\t\t\t\t\t\t\"]]>\"\r\n\t\t\t\t\t\t\t\"</xmlElement>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"CDATA symbolic puns round 2\", false, doc.Error() );\r\n\t\tdoc.Print();\r\n\r\n\t\tXMLTest( \"CDATA parse. [ tixml1:1480107 ]\",\r\n\t\t\t\t\t\t\t\t \"<b>I am > the rules!</b>\\n...since I make symbolic puns\",\r\n\t\t\t\t\t\t\t\t doc.FirstChildElement()->FirstChild()->Value(),\r\n\t\t\t\t\t\t\t\t false );\r\n\t}\r\n\r\n\t// InsertAfterChild causes crash.\r\n\t{\r\n\t\t// InsertBeforeChild and InsertAfterChild causes crash.\r\n\t\tXMLDocument doc;\r\n\t\tXMLElement* parent = doc.NewElement( \"Parent\" );\r\n\t\tdoc.InsertFirstChild( parent );\r\n\r\n\t\tXMLElement* childText0 = doc.NewElement( \"childText0\" );\r\n\t\tXMLElement* childText1 = doc.NewElement( \"childText1\" );\r\n\r\n\t\tXMLNode* childNode0 = parent->InsertEndChild( childText0 );\r\n\t\tXMLTest( \"InsertEndChild() return\", true, childNode0 == childText0 );\r\n\t\tXMLNode* childNode1 = parent->InsertAfterChild( childNode0, childText1 );\r\n\t\tXMLTest( \"InsertAfterChild() return\", true, childNode1 == childText1 );\r\n\r\n\t\tXMLTest( \"Test InsertAfterChild on empty node. \", true, ( childNode1 == parent->LastChild() ) );\r\n\t}\r\n\r\n\t{\r\n\t\t// Entities not being written correctly.\r\n\t\t// From Lynn Allen\r\n\r\n\t\tconst char* passages =\r\n\t\t\t\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\" ?>\"\r\n\t\t\t\"<passages count=\\\"006\\\" formatversion=\\\"20020620\\\">\"\r\n\t\t\t\t\"<psg context=\\\"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;.\"\r\n\t\t\t\t\" It also has &lt;, &gt;, and &amp;, as well as a fake copyright &#xA9;.\\\"> </psg>\"\r\n\t\t\t\"</passages>\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( passages );\r\n\t\tXMLTest( \"Entity transformation parse round 1\", false, doc.Error() );\r\n\t\tXMLElement* psg = doc.RootElement()->FirstChildElement();\r\n\t\tconst char* context = psg->Attribute( \"context\" );\r\n\t\tconst char* expected = \"Line 5 has \\\"quotation marks\\\" and 'apostrophe marks'. It also has <, >, and &, as well as a fake copyright \\xC2\\xA9.\";\r\n\r\n\t\tXMLTest( \"Entity transformation: read. \", expected, context, true );\r\n\r\n\t\tconst char* textFilePath = \"resources/out/textfile.txt\";\r\n\t\tFILE* textfile = fopen( textFilePath, \"w\" );\r\n\t\tXMLTest( \"Entity transformation: open text file for writing\", true, textfile != 0, true );\r\n\t\tif ( textfile )\r\n\t\t{\r\n\t\t\tXMLPrinter streamer( textfile );\r\n\t\t\tbool acceptResult = psg->Accept( &streamer );\r\n\t\t\tfclose( textfile );\r\n\t\t\tXMLTest( \"Entity transformation: Accept\", true, acceptResult );\r\n\t\t}\r\n\r\n\t\ttextfile = fopen( textFilePath, \"r\" );\r\n\t\tXMLTest( \"Entity transformation: open text file for reading\", true, textfile != 0, true );\r\n\t\tif ( textfile )\r\n\t\t{\r\n\t\t\tchar buf[ 1024 ];\r\n\t\t\tfgets( buf, 1024, textfile );\r\n\t\t\tXMLTest( \"Entity transformation: write. \",\r\n\t\t\t\t\t \"<psg context=\\\"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;.\"\r\n\t\t\t\t\t \" It also has &lt;, &gt;, and &amp;, as well as a fake copyright \\xC2\\xA9.\\\"/>\\n\",\r\n\t\t\t\t\t buf, false );\r\n\t\t\tfclose( textfile );\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\t// Suppress entities.\r\n\t\tconst char* passages =\r\n\t\t\t\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\" ?>\"\r\n\t\t\t\"<passages count=\\\"006\\\" formatversion=\\\"20020620\\\">\"\r\n\t\t\t\t\"<psg context=\\\"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;.\\\">Crazy &ttk;</psg>\"\r\n\t\t\t\"</passages>\";\r\n\r\n\t\tXMLDocument doc( false );\r\n\t\tdoc.Parse( passages );\r\n\t\tXMLTest( \"Entity transformation parse round 2\", false, doc.Error() );\r\n\r\n\t\tXMLTest( \"No entity parsing.\",\r\n\t\t\t\t \"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;.\",\r\n\t\t\t\t doc.FirstChildElement()->FirstChildElement()->Attribute( \"context\" ) );\r\n\t\tXMLTest( \"No entity parsing.\", \"Crazy &ttk;\",\r\n\t\t\t\t doc.FirstChildElement()->FirstChildElement()->FirstChild()->Value() );\r\n\t\tdoc.Print();\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* test = \"<?xml version='1.0'?><a.elem xmi.version='2.0'/>\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( test );\r\n\t\tXMLTest( \"dot in names\", false, doc.Error() );\r\n\t\tXMLTest( \"dot in names\", \"a.elem\", doc.FirstChildElement()->Name() );\r\n\t\tXMLTest( \"dot in names\", \"2.0\", doc.FirstChildElement()->Attribute( \"xmi.version\" ) );\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* test = \"<element><Name>1.1 Start easy ignore fin thickness&#xA;</Name></element>\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( test );\r\n\t\tXMLTest( \"fin thickness\", false, doc.Error() );\r\n\r\n\t\tXMLText* text = doc.FirstChildElement()->FirstChildElement()->FirstChild()->ToText();\r\n\t\tXMLTest( \"Entity with one digit.\",\r\n\t\t\t\t \"1.1 Start easy ignore fin thickness\\n\", text->Value(),\r\n\t\t\t\t false );\r\n\t}\r\n\r\n\t{\r\n\t\t// DOCTYPE not preserved (950171)\r\n\t\t//\r\n\t\tconst char* doctype =\r\n\t\t\t\"<?xml version=\\\"1.0\\\" ?>\"\r\n\t\t\t\"<!DOCTYPE PLAY SYSTEM 'play.dtd'>\"\r\n\t\t\t\"<!ELEMENT title (#PCDATA)>\"\r\n\t\t\t\"<!ELEMENT books (title,authors)>\"\r\n\t\t\t\"<element />\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( doctype );\r\n\t\tXMLTest( \"PLAY SYSTEM parse\", false, doc.Error() );\r\n\t\tdoc.SaveFile( \"resources/out/test7.xml\" );\r\n\t\tXMLTest( \"PLAY SYSTEM save\", false, doc.Error() );\r\n\t\tdoc.DeleteChild( doc.RootElement() );\r\n\t\tdoc.LoadFile( \"resources/out/test7.xml\" );\r\n\t\tXMLTest( \"PLAY SYSTEM load\", false, doc.Error() );\r\n\t\tdoc.Print();\r\n\r\n\t\tconst XMLUnknown* decl = doc.FirstChild()->NextSibling()->ToUnknown();\r\n\t\tXMLTest( \"Correct value of unknown.\", \"DOCTYPE PLAY SYSTEM 'play.dtd'\", decl->Value() );\r\n\r\n\t}\r\n\r\n\t{\r\n\t\t// Comments do not stream out correctly.\r\n\t\tconst char* doctype =\r\n\t\t\t\"<!-- Somewhat<evil> -->\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( doctype );\r\n\t\tXMLTest( \"Comment somewhat evil\", false, doc.Error() );\r\n\r\n\t\tXMLComment* comment = doc.FirstChild()->ToComment();\r\n\r\n\t\tXMLTest( \"Comment formatting.\", \" Somewhat<evil> \", comment->Value() );\r\n\t}\r\n\t{\r\n\t\t// Double attributes\r\n\t\tconst char* doctype = \"<element attr='red' attr='blue' />\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( doctype );\r\n\r\n\t\tXMLTest( \"Parsing repeated attributes.\", XML_ERROR_PARSING_ATTRIBUTE, doc.ErrorID() );\t// is an  error to tinyxml (didn't use to be, but caused issues)\r\n\t\tdoc.PrintError();\r\n\t}\r\n\r\n\t{\r\n\t\t// Embedded null in stream.\r\n\t\tconst char* doctype = \"<element att\\0r='red' attr='blue' />\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( doctype );\r\n\t\tXMLTest( \"Embedded null throws error.\", true, doc.Error() );\r\n\t}\r\n\r\n\t{\r\n\t\t// Empty documents should return TIXML_XML_ERROR_PARSING_EMPTY, bug 1070717\r\n\t\tconst char* str = \"\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"Empty document error\", XML_ERROR_EMPTY_DOCUMENT, doc.ErrorID() );\r\n\r\n\t\t// But be sure there is an error string!\r\n\t\tconst char* errorStr = doc.ErrorStr();\r\n\t\tXMLTest(\"Error string should be set\",\r\n\t\t\t\"Error=XML_ERROR_EMPTY_DOCUMENT ErrorID=13 (0xd) Line number=0\",\r\n\t\t\terrorStr);\r\n\t}\r\n\r\n\t{\r\n\t\t// Documents with all whitespaces should return TIXML_XML_ERROR_PARSING_EMPTY, bug 1070717\r\n\t\tconst char* str = \"    \";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( str );\r\n\t\tXMLTest( \"All whitespaces document error\", XML_ERROR_EMPTY_DOCUMENT, doc.ErrorID() );\r\n\t}\r\n\r\n\t{\r\n\t\t// Low entities\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( \"<test>&#x0e;</test>\" );\r\n\t\tXMLTest( \"Hex values\", false, doc.Error() );\r\n\t\tconst char result[] = { 0x0e, 0 };\r\n\t\tXMLTest( \"Low entities.\", result, doc.FirstChildElement()->GetText() );\r\n\t\tdoc.Print();\r\n\t}\r\n\r\n\t{\r\n\t\t// Attribute values with trailing quotes not handled correctly\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( \"<foo attribute=bar\\\" />\" );\r\n\t\tXMLTest( \"Throw error with bad end quotes.\", true, doc.Error() );\r\n\t}\r\n\r\n\t{\r\n\t\t// [ 1663758 ] Failure to report error on bad XML\r\n\t\tXMLDocument xml;\r\n\t\txml.Parse(\"<x>\");\r\n\t\tXMLTest(\"Missing end tag at end of input\", true, xml.Error());\r\n\t\txml.Parse(\"<x> \");\r\n\t\tXMLTest(\"Missing end tag with trailing whitespace\", true, xml.Error());\r\n\t\txml.Parse(\"<x></y>\");\r\n\t\tXMLTest(\"Mismatched tags\", XML_ERROR_MISMATCHED_ELEMENT, xml.ErrorID() );\r\n\t}\r\n\r\n\r\n\t{\r\n\t\t// [ 1475201 ] TinyXML parses entities in comments\r\n\t\tXMLDocument xml;\r\n\t\txml.Parse(\"<!-- declarations for <head> & <body> -->\"\r\n\t\t\t\t  \"<!-- far &amp; away -->\" );\r\n\t\tXMLTest( \"Declarations for head and body\", false, xml.Error() );\r\n\r\n\t\tXMLNode* e0 = xml.FirstChild();\r\n\t\tXMLNode* e1 = e0->NextSibling();\r\n\t\tXMLComment* c0 = e0->ToComment();\r\n\t\tXMLComment* c1 = e1->ToComment();\r\n\r\n\t\tXMLTest( \"Comments ignore entities.\", \" declarations for <head> & <body> \", c0->Value(), true );\r\n\t\tXMLTest( \"Comments ignore entities.\", \" far &amp; away \", c1->Value(), true );\r\n\t}\r\n\r\n\t{\r\n\t\tXMLDocument xml;\r\n\t\txml.Parse( \"<Parent>\"\r\n\t\t\t\t\t\t\"<child1 att=''/>\"\r\n\t\t\t\t\t\t\"<!-- With this comment, child2 will not be parsed! -->\"\r\n\t\t\t\t\t\t\"<child2 att=''/>\"\r\n\t\t\t\t\t\"</Parent>\" );\r\n\t\tXMLTest( \"Comments iteration\", false, xml.Error() );\r\n\t\txml.Print();\r\n\r\n\t\tint count = 0;\r\n\r\n\t\tfor( XMLNode* ele = xml.FirstChildElement( \"Parent\" )->FirstChild();\r\n\t\t\t ele;\r\n\t\t\t ele = ele->NextSibling() )\r\n\t\t{\r\n\t\t\t++count;\r\n\t\t}\r\n\r\n\t\tXMLTest( \"Comments iterate correctly.\", 3, count );\r\n\t}\r\n\r\n\t{\r\n\t\t// trying to repro [1874301]. If it doesn't go into an infinite loop, all is well.\r\n\t\tunsigned char buf[] = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><feed><![CDATA[Test XMLblablablalblbl\";\r\n\t\tbuf[60] = 239;\r\n\t\tbuf[61] = 0;\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( (const char*)buf);\r\n\t\tXMLTest( \"Broken CDATA\", true, doc.Error() );\r\n\t}\r\n\r\n\r\n\t{\r\n\t\t// bug 1827248 Error while parsing a little bit malformed file\r\n\t\t// Actually not malformed - should work.\r\n\t\tXMLDocument xml;\r\n\t\txml.Parse( \"<attributelist> </attributelist >\" );\r\n\t\tXMLTest( \"Handle end tag whitespace\", false, xml.Error() );\r\n\t}\r\n\r\n\t{\r\n\t\t// This one must not result in an infinite loop\r\n\t\tXMLDocument xml;\r\n\t\txml.Parse( \"<infinite>loop\" );\r\n\t\tXMLTest( \"No closing element\", true, xml.Error() );\r\n\t\tXMLTest( \"Infinite loop test.\", true, true );\r\n\t}\r\n#endif\r\n\t{\r\n\t\tconst char* pub = \"<?xml version='1.0'?> <element><sub/></element> <!--comment--> <!DOCTYPE>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( pub );\r\n\t\tXMLTest( \"Trailing DOCTYPE\", false, doc.Error() );\r\n\r\n\t\tXMLDocument clone;\r\n\t\tfor( const XMLNode* node=doc.FirstChild(); node; node=node->NextSibling() ) {\r\n\t\t\tXMLNode* copy = node->ShallowClone( &clone );\r\n\t\t\tclone.InsertEndChild( copy );\r\n\t\t}\r\n\r\n\t\tclone.Print();\r\n\r\n\t\tint count=0;\r\n\t\tconst XMLNode* a=clone.FirstChild();\r\n\t\tconst XMLNode* b=doc.FirstChild();\r\n\t\tfor( ; a && b; a=a->NextSibling(), b=b->NextSibling() ) {\r\n\t\t\t++count;\r\n\t\t\tXMLTest( \"Clone and Equal\", true, a->ShallowEqual( b ));\r\n\t\t}\r\n\t\tXMLTest( \"Clone and Equal\", 4, count );\r\n\t}\r\n\r\n\t{\r\n\t\t// Deep Cloning of root element.\r\n\t\tXMLDocument doc2;\r\n\t\tXMLPrinter printer1;\r\n\t\t{\r\n\t\t\t// Make sure doc1 is deleted before we test doc2\r\n\t\t\tconst char* xml =\r\n\t\t\t\t\"<root>\"\r\n\t\t\t\t\"    <child1 foo='bar'/>\"\r\n\t\t\t\t\"    <!-- comment thing -->\"\r\n\t\t\t\t\"    <child2 val='1'>Text</child2>\"\r\n\t\t\t\t\"</root>\";\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.Parse(xml);\r\n\t\t\tXMLTest( \"Parse before deep cloning root element\", false, doc.Error() );\r\n\r\n\t\t\tdoc.Print(&printer1);\r\n\t\t\tXMLNode* root = doc.RootElement()->DeepClone(&doc2);\r\n\t\t\tdoc2.InsertFirstChild(root);\r\n\t\t}\r\n\t\tXMLPrinter printer2;\r\n\t\tdoc2.Print(&printer2);\r\n\r\n\t\tXMLTest(\"Deep clone of element.\", printer1.CStr(), printer2.CStr(), true);\r\n\t}\r\n\r\n\t{\r\n\t\t// Deep Cloning of sub element.\r\n\t\tXMLDocument doc2;\r\n\t\tXMLPrinter printer1;\r\n\t\t{\r\n\t\t\t// Make sure doc1 is deleted before we test doc2\r\n\t\t\tconst char* xml =\r\n\t\t\t\t\"<?xml version ='1.0'?>\"\r\n\t\t\t\t\"<root>\"\r\n\t\t\t\t\"    <child1 foo='bar'/>\"\r\n\t\t\t\t\"    <!-- comment thing -->\"\r\n\t\t\t\t\"    <child2 val='1'>Text</child2>\"\r\n\t\t\t\t\"</root>\";\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.Parse(xml);\r\n\t\t\tXMLTest( \"Parse before deep cloning sub element\", false, doc.Error() );\r\n\r\n\t\t\tconst XMLElement* subElement = doc.FirstChildElement(\"root\")->FirstChildElement(\"child2\");\r\n\t\t\tbool acceptResult = subElement->Accept(&printer1);\r\n\t\t\tXMLTest( \"Accept before deep cloning\", true, acceptResult );\r\n\r\n\t\t\tXMLNode* clonedSubElement = subElement->DeepClone(&doc2);\r\n\t\t\tdoc2.InsertFirstChild(clonedSubElement);\r\n\t\t}\r\n\t\tXMLPrinter printer2;\r\n\t\tdoc2.Print(&printer2);\r\n\r\n\t\tXMLTest(\"Deep clone of sub-element.\", printer1.CStr(), printer2.CStr(), true);\r\n\t}\r\n\r\n\t{\r\n\t\t// Deep cloning of document.\r\n\t\tXMLDocument doc2;\r\n\t\tXMLPrinter printer1;\r\n\t\t{\r\n\t\t\t// Make sure doc1 is deleted before we test doc2\r\n\t\t\tconst char* xml =\r\n\t\t\t\t\"<?xml version ='1.0'?>\"\r\n\t\t\t\t\"<!-- Top level comment. -->\"\r\n\t\t\t\t\"<root>\"\r\n\t\t\t\t\"    <child1 foo='bar'/>\"\r\n\t\t\t\t\"    <!-- comment thing -->\"\r\n\t\t\t\t\"    <child2 val='1'>Text</child2>\"\r\n\t\t\t\t\"</root>\";\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.Parse(xml);\r\n\t\t\tXMLTest( \"Parse before deep cloning document\", false, doc.Error() );\r\n\t\t\tdoc.Print(&printer1);\r\n\r\n\t\t\tdoc.DeepCopy(&doc2);\r\n\t\t}\r\n\t\tXMLPrinter printer2;\r\n\t\tdoc2.Print(&printer2);\r\n\r\n\t\tXMLTest(\"DeepCopy of document.\", printer1.CStr(), printer2.CStr(), true);\r\n\t}\r\n\r\n\r\n \t{\r\n\t\t// This shouldn't crash.\r\n\t\tXMLDocument doc;\r\n\t\tif(XML_SUCCESS != doc.LoadFile( \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" ))\r\n\t\t{\r\n\t\t\tdoc.PrintError();\r\n\t\t}\r\n\t\tXMLTest( \"Error in snprinf handling.\", true, doc.Error() );\r\n\t}\r\n\r\n\t{\r\n\t\t// Attribute ordering.\r\n\t\tstatic const char* xml = \"<element attrib1=\\\"1\\\" attrib2=\\\"2\\\" attrib3=\\\"3\\\" />\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse for attribute ordering\", false, doc.Error() );\r\n\t\tXMLElement* ele = doc.FirstChildElement();\r\n\r\n\t\tconst XMLAttribute* a = ele->FirstAttribute();\r\n\t\tXMLTest( \"Attribute order\", \"1\", a->Value() );\r\n\t\ta = a->Next();\r\n\t\tXMLTest( \"Attribute order\", \"2\", a->Value() );\r\n\t\ta = a->Next();\r\n\t\tXMLTest( \"Attribute order\", \"3\", a->Value() );\r\n\t\tXMLTest( \"Attribute order\", \"attrib3\", a->Name() );\r\n\r\n\t\tele->DeleteAttribute( \"attrib2\" );\r\n\t\ta = ele->FirstAttribute();\r\n\t\tXMLTest( \"Attribute order\", \"1\", a->Value() );\r\n\t\ta = a->Next();\r\n\t\tXMLTest( \"Attribute order\", \"3\", a->Value() );\r\n\r\n\t\tele->DeleteAttribute( \"attrib1\" );\r\n\t\tele->DeleteAttribute( \"attrib3\" );\r\n\t\tXMLTest( \"Attribute order (empty)\", true, ele->FirstAttribute() == 0 );\r\n\t}\r\n\r\n\t{\r\n\t\t// Make sure an attribute with a space in it succeeds.\r\n\t\tstatic const char* xml0 = \"<element attribute1= \\\"Test Attribute\\\"/>\";\r\n\t\tstatic const char* xml1 = \"<element attribute1 =\\\"Test Attribute\\\"/>\";\r\n\t\tstatic const char* xml2 = \"<element attribute1 = \\\"Test Attribute\\\"/>\";\r\n\t\tXMLDocument doc0;\r\n\t\tdoc0.Parse( xml0 );\r\n\t\tXMLTest( \"Parse attribute with space 1\", false, doc0.Error() );\r\n\t\tXMLDocument doc1;\r\n\t\tdoc1.Parse( xml1 );\r\n\t\tXMLTest( \"Parse attribute with space 2\", false, doc1.Error() );\r\n\t\tXMLDocument doc2;\r\n\t\tdoc2.Parse( xml2 );\r\n\t\tXMLTest( \"Parse attribute with space 3\", false, doc2.Error() );\r\n\r\n\t\tXMLElement* ele = 0;\r\n\t\tele = doc0.FirstChildElement();\r\n\t\tXMLTest( \"Attribute with space #1\", \"Test Attribute\", ele->Attribute( \"attribute1\" ) );\r\n\t\tele = doc1.FirstChildElement();\r\n\t\tXMLTest( \"Attribute with space #2\", \"Test Attribute\", ele->Attribute( \"attribute1\" ) );\r\n\t\tele = doc2.FirstChildElement();\r\n\t\tXMLTest( \"Attribute with space #3\", \"Test Attribute\", ele->Attribute( \"attribute1\" ) );\r\n\t}\r\n\r\n\t{\r\n\t\t// Make sure we don't go into an infinite loop.\r\n\t\tstatic const char* xml = \"<doc><element attribute='attribute'/><element attribute='attribute'/></doc>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse two elements with attribute\", false, doc.Error() );\r\n\t\tXMLElement* ele0 = doc.FirstChildElement()->FirstChildElement();\r\n\t\tXMLElement* ele1 = ele0->NextSiblingElement();\r\n\t\tbool equal = ele0->ShallowEqual( ele1 );\r\n\r\n\t\tXMLTest( \"Infinite loop in shallow equal.\", true, equal );\r\n\t}\r\n\r\n\t// -------- Handles ------------\r\n\t{\r\n\t\tstatic const char* xml = \"<element attrib='bar'><sub>Text</sub></element>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Handle, parse element with attribute and nested element\", false, doc.Error() );\r\n\r\n\t\t{\r\n\t\t\tXMLElement* ele = XMLHandle( doc ).FirstChildElement( \"element\" ).FirstChild().ToElement();\r\n\t\t\tXMLTest( \"Handle, non-const, element is found\", true, ele != 0 );\r\n\t\t\tXMLTest( \"Handle, non-const, element name matches\", \"sub\", ele->Value() );\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tXMLHandle docH( doc );\r\n\t\t\tXMLElement* ele = docH.FirstChildElement( \"noSuchElement\" ).FirstChildElement( \"element\" ).ToElement();\r\n\t\t\tXMLTest( \"Handle, non-const, element not found\", true, ele == 0 );\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tconst XMLElement* ele = XMLConstHandle( doc ).FirstChildElement( \"element\" ).FirstChild().ToElement();\r\n\t\t\tXMLTest( \"Handle, const, element is found\", true, ele != 0 );\r\n\t\t\tXMLTest( \"Handle, const, element name matches\", \"sub\", ele->Value() );\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tXMLConstHandle docH( doc );\r\n\t\t\tconst XMLElement* ele = docH.FirstChildElement( \"noSuchElement\" ).FirstChildElement( \"element\" ).ToElement();\r\n\t\t\tXMLTest( \"Handle, const, element not found\", true, ele == 0 );\r\n\t\t}\r\n\t}\r\n\t{\r\n\t\t// Default Declaration & BOM\r\n\t\tXMLDocument doc;\r\n\t\tdoc.InsertEndChild( doc.NewDeclaration() );\r\n\t\tdoc.SetBOM( true );\r\n\r\n\t\tXMLPrinter printer;\r\n\t\tdoc.Print( &printer );\r\n\r\n\t\tstatic const char* result  = \"\\xef\\xbb\\xbf<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\";\r\n\t\tXMLTest( \"BOM and default declaration\", result, printer.CStr(), false );\r\n\t\tXMLTest( \"CStrSize\", true, printer.CStrSize() == 42, false );\r\n\t}\r\n\t{\r\n\t\tconst char* xml = \"<ipxml ws='1'><info bla=' /></ipxml>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Ill formed XML\", true, doc.Error() );\r\n\t}\r\n\r\n    {\r\n        //API:IntText(),UnsignedText(),Int64Text(),DoubleText(),BoolText() and FloatText() test\r\n        const char* xml = \"<point> <IntText>-24</IntText> <UnsignedText>42</UnsignedText> \\\r\n\t\t\t\t\t\t   <Int64Text>38</Int64Text> <BoolText>true</BoolText> <DoubleText>2.35</DoubleText> </point>\";\r\n        XMLDocument doc;\r\n        doc.Parse(xml);\r\n\r\n        const XMLElement* pointElement = doc.RootElement();\r\n        int test1 = pointElement->FirstChildElement(\"IntText\")->IntText();\r\n        XMLTest(\"IntText() test\", -24, test1);\r\n\r\n        unsigned test2 = pointElement->FirstChildElement(\"UnsignedText\")->UnsignedText();\r\n        XMLTest(\"UnsignedText() test\", static_cast<unsigned>(42), test2);\r\n\r\n        int64_t test3 = pointElement->FirstChildElement(\"Int64Text\")->Int64Text();\r\n        XMLTest(\"Int64Text() test\", static_cast<int64_t>(38), test3);\r\n\r\n        double test4 = pointElement->FirstChildElement(\"DoubleText\")->DoubleText();\r\n        XMLTest(\"DoubleText() test\", 2.35, test4);\r\n\r\n        float test5 = pointElement->FirstChildElement(\"DoubleText\")->FloatText();\r\n        XMLTest(\"FloatText()) test\", 2.35f, test5);\r\n\r\n        bool test6 = pointElement->FirstChildElement(\"BoolText\")->BoolText();\r\n        XMLTest(\"FloatText()) test\", true, test6);\r\n    }\r\n\r\n    {\r\n        // hex value test\r\n        const char* xml = \"<point> <IntText>  0x2020</IntText> <UnsignedText>0X2020</UnsignedText> \\\r\n\t\t\t\t\t\t   <Int64Text> 0x1234</Int64Text></point>\";\r\n        XMLDocument doc;\r\n        doc.Parse(xml);\r\n\r\n        const XMLElement* pointElement = doc.RootElement();\r\n        int test1 = pointElement->FirstChildElement(\"IntText\")->IntText();\r\n        XMLTest(\"IntText() hex value test\", 0x2020, test1);\r\n\r\n        unsigned test2 = pointElement->FirstChildElement(\"UnsignedText\")->UnsignedText();\r\n        XMLTest(\"UnsignedText() hex value test\", static_cast<unsigned>(0x2020), test2);\r\n\r\n        int64_t test3 = pointElement->FirstChildElement(\"Int64Text\")->Int64Text();\r\n        XMLTest(\"Int64Text() hex value test\", static_cast<int64_t>(0x1234), test3);\r\n    }\r\n\r\n\t{\r\n\t\t//API:ShallowEqual() test\r\n\t\tconst char* xml = \"<playlist id = 'playlist'>\"\r\n\t\t\t\t\t\t    \"<property name = 'track_name'>voice</property>\"\r\n\t\t\t\t\t\t  \"</playlist>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tconst XMLNode* PlaylistNode = doc.RootElement();\r\n\t\tconst XMLNode* PropertyNode = PlaylistNode->FirstChildElement();\r\n\t\tbool result;\r\n\t\tresult = PlaylistNode->ShallowEqual(PropertyNode);\r\n\t\tXMLTest(\"ShallowEqual() test\",false,result);\r\n\t\tresult = PlaylistNode->ShallowEqual(PlaylistNode);\r\n\t\tXMLTest(\"ShallowEqual() test\",true,result);\r\n\t}\r\n\r\n\t{\r\n\t\t//API: previousSiblingElement() and NextSiblingElement() test\r\n\t\tconst char* xml = \"<playlist id = 'playlist'>\"\r\n\t\t\t\t\t\t    \"<property name = 'track_name'>voice</property>\"\r\n\t\t\t\t\t\t    \"<entry out = '946' producer = '2_playlist1' in = '0'/>\"\r\n\t\t\t\t\t\t\t\"<blank length = '1'/>\"\r\n\t\t\t\t\t\t  \"</playlist>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLElement* ElementPlaylist = doc.FirstChildElement(\"playlist\");\r\n\t\tXMLTest(\"previousSiblingElement() test\",true,ElementPlaylist != 0);\r\n\t\tconst XMLElement* pre = ElementPlaylist->PreviousSiblingElement();\r\n\t\tXMLTest(\"previousSiblingElement() test\",true,pre == 0);\r\n\t\tconst XMLElement* ElementBlank = ElementPlaylist->FirstChildElement(\"entry\")->NextSiblingElement(\"blank\");\r\n\t\tXMLTest(\"NextSiblingElement() test\",true,ElementBlank != 0);\r\n\t\tconst XMLElement* next = ElementBlank->NextSiblingElement();\r\n\t\tXMLTest(\"NextSiblingElement() test\",true,next == 0);\r\n\t\tconst XMLElement* ElementEntry = ElementBlank->PreviousSiblingElement(\"entry\");\r\n\t\tXMLTest(\"PreviousSiblingElement test\",true,ElementEntry != 0);\r\n\t}\r\n\r\n\t// QueryXYZText\r\n\t{\r\n\t\tconst char* xml = \"<point> <x>1.2</x> <y>1</y> <z>38</z> <valid>true</valid> </point>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse points\", false, doc.Error() );\r\n\r\n\t\tconst XMLElement* pointElement = doc.RootElement();\r\n\r\n\t\t{\r\n\t\t\tint intValue = 0;\r\n\t\t\tXMLError queryResult = pointElement->FirstChildElement( \"y\" )->QueryIntText( &intValue );\r\n\t\t\tXMLTest( \"QueryIntText result\", XML_SUCCESS, queryResult, false );\r\n\t\t\tXMLTest( \"QueryIntText\", 1, intValue, false );\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tunsigned unsignedValue = 0;\r\n\t\t\tXMLError queryResult = pointElement->FirstChildElement( \"y\" )->QueryUnsignedText( &unsignedValue );\r\n\t\t\tXMLTest( \"QueryUnsignedText result\", XML_SUCCESS, queryResult, false );\r\n\t\t\tXMLTest( \"QueryUnsignedText\", (unsigned)1, unsignedValue, false );\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tfloat floatValue = 0;\r\n\t\t\tXMLError queryResult = pointElement->FirstChildElement( \"x\" )->QueryFloatText( &floatValue );\r\n\t\t\tXMLTest( \"QueryFloatText result\", XML_SUCCESS, queryResult, false );\r\n\t\t\tXMLTest( \"QueryFloatText\", 1.2f, floatValue, false );\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tdouble doubleValue = 0;\r\n\t\t\tXMLError queryResult = pointElement->FirstChildElement( \"x\" )->QueryDoubleText( &doubleValue );\r\n\t\t\tXMLTest( \"QueryDoubleText result\", XML_SUCCESS, queryResult, false );\r\n\t\t\tXMLTest( \"QueryDoubleText\", 1.2, doubleValue, false );\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tbool boolValue = false;\r\n\t\t\tXMLError queryResult = pointElement->FirstChildElement( \"valid\" )->QueryBoolText( &boolValue );\r\n\t\t\tXMLTest( \"QueryBoolText result\", XML_SUCCESS, queryResult, false );\r\n\t\t\tXMLTest( \"QueryBoolText\", true, boolValue, false );\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element><_sub/><:sub/><sub:sub/><sub-sub/></element>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Non-alpha element lead letter parses.\", false, doc.Error() );\r\n\t}\r\n\r\n    {\r\n        const char* xml = \"<element _attr1=\\\"foo\\\" :attr2=\\\"bar\\\"></element>\";\r\n        XMLDocument doc;\r\n        doc.Parse( xml );\r\n        XMLTest(\"Non-alpha attribute lead character parses.\", false, doc.Error());\r\n    }\r\n\r\n    {\r\n        const char* xml = \"<3lement></3lement>\";\r\n        XMLDocument doc;\r\n        doc.Parse( xml );\r\n        XMLTest(\"Element names with lead digit fail to parse.\", true, doc.Error());\r\n    }\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element/>WOA THIS ISN'T GOING TO PARSE\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml, 10 );\r\n\t\tXMLTest( \"Set length of incoming data\", false, doc.Error() );\r\n\t}\r\n\r\n    {\r\n        XMLDocument doc;\r\n        XMLTest( \"Document is initially empty\", true, doc.NoChildren() );\r\n        doc.Clear();\r\n        XMLTest( \"Empty is empty after Clear()\", true, doc.NoChildren() );\r\n        doc.LoadFile( \"resources/dream.xml\" );\r\n        XMLTest( \"Load dream.xml\", false, doc.Error() );\r\n        XMLTest( \"Document has something to Clear()\", false, doc.NoChildren() );\r\n        doc.Clear();\r\n        XMLTest( \"Document Clear()'s\", true, doc.NoChildren() );\r\n    }\r\n\r\n    {\r\n        XMLDocument doc;\r\n        XMLTest( \"No error initially\", false, doc.Error() );\r\n        XMLError error = doc.Parse( \"This is not XML\" );\r\n        XMLTest( \"Error after invalid XML\", true, doc.Error() );\r\n        XMLTest( \"Error after invalid XML\", error, doc.ErrorID() );\r\n        doc.Clear();\r\n        XMLTest( \"No error after Clear()\", false, doc.Error() );\r\n    }\r\n\r\n\t// ----------- Whitespace ------------\r\n\t{\r\n\t\tconst char* xml = \"<element>\"\r\n\t\t\t\t\t\t\t\"<a> This \\nis &apos;  text  &apos; </a>\"\r\n\t\t\t\t\t\t\t\"<b>  This is &apos; text &apos;  \\n</b>\"\r\n\t\t\t\t\t\t\t\"<c>This  is  &apos;  \\n\\n text &apos;</c>\"\r\n\t\t\t\t\t\t  \"</element>\";\r\n\t\tXMLDocument doc( true, COLLAPSE_WHITESPACE );\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse with whitespace collapsing and &apos\", false, doc.Error() );\r\n\r\n\t\tconst XMLElement* element = doc.FirstChildElement();\r\n\t\tfor( const XMLElement* parent = element->FirstChildElement();\r\n\t\t\t parent;\r\n\t\t\t parent = parent->NextSiblingElement() )\r\n\t\t{\r\n\t\t\tXMLTest( \"Whitespace collapse\", \"This is ' text '\", parent->GetText() );\r\n\t\t}\r\n\t}\r\n\r\n#if 0\r\n\t{\r\n\t\t// Passes if assert doesn't fire.\r\n\t\tXMLDocument xmlDoc;\r\n\r\n\t    xmlDoc.NewDeclaration();\r\n\t    xmlDoc.NewComment(\"Configuration file\");\r\n\r\n\t    XMLElement *root = xmlDoc.NewElement(\"settings\");\r\n\t    root->SetAttribute(\"version\", 2);\r\n\t}\r\n#endif\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>    </element>\";\r\n\t\tXMLDocument doc( true, COLLAPSE_WHITESPACE );\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse with all whitespaces\", false, doc.Error() );\r\n\t\tXMLTest( \"Whitespace  all space\", true, 0 == doc.FirstChildElement()->FirstChild() );\r\n\t}\r\n\r\n\t// ----------- Preserve Whitespace ------------\r\n\t{\r\n\t\tconst char* xml = \"<element>This  is  &apos;  \\n\\n text &apos;</element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", \"This  is  '  \\n\\n text '\", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element> This \\nis &apos;  text  &apos;  </element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", \" This \\nis '  text  '  \", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>  \\n This is &apos; text &apos;  \\n</element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", \"  \\n This is ' text '  \\n\", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t// Following cases are for text that is all whitespace which are not preserved intentionally\r\n\t{\r\n\t\tconst char* xml = \"<element> </element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", true, 0 == doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>   </element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", true, 0 == doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>\\n\\n</element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", true, 0 == doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>  \\n</element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", true, 0 == doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element> \\n \\n </element>\";\r\n\t\tXMLDocument doc(true, PRESERVE_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with whitespace preserved\", false, doc.Error());\r\n\t\tXMLTest(\"Whitespace preserved\", true, 0 == doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t// ----------- Pedantic Whitespace ------------\r\n\t{\r\n\t\tconst char* xml = \"<element>This  is  &apos;  \\n\\n text &apos;</element>\";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \"This  is  '  \\n\\n text '\", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element> This \\nis &apos;  text  &apos;  </element>\";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \" This \\nis '  text  '  \", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>  \\n This is &apos; text &apos;  \\n</element>\";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \"  \\n This is ' text '  \\n\", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t// Following cases are for text that is all whitespace which is preserved with pedantic mode\r\n\t{\r\n\t\tconst char* xml = \"<element> </element>\";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \" \", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>   </element>\";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \"   \", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>\\n\\n</element>\\n\";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \"\\n\\n\", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>  \\n</element> \\n \";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \"  \\n\", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element> \\n  \\n </element>  \";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \" \\n  \\n \", doc.FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t// Following cases are for checking nested elements are still parsed with pedantic whitespace\r\n\t{\r\n\t\tconst char* xml = \"<element>\\n\\t<a> This is nested text </a>\\n</element>  \";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse nested elements with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \" This is nested text \", doc.RootElement()->FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>  <b> </b>  </element>\\n\";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse nested elements with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", \" \", doc.RootElement()->FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<element>  <c attribute=\\\"test\\\"/>  </element>\\n \";\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest(\"Parse nested elements with pedantic whitespace\", false, doc.Error());\r\n\t\tXMLTest(\"Pedantic whitespace\", true, 0 == doc.RootElement()->FirstChildElement()->GetText());\r\n\t}\r\n\r\n\t// Check sample xml can be parsed with pedantic mode\r\n\t{\r\n\t\tXMLDocument doc(true, PEDANTIC_WHITESPACE);\r\n\t\tdoc.LoadFile(\"resources/dream.xml\");\r\n\t\tXMLTest(\"Load dream.xml with pedantic whitespace mode\", false, doc.Error());\r\n\r\n\t\tXMLTest(\"Dream\", \"xml version=\\\"1.0\\\"\",\r\n\t\t\tdoc.FirstChild()->ToDeclaration()->Value());\r\n\t\tXMLTest(\"Dream\", true, doc.FirstChild()->NextSibling()->ToUnknown() != 0);\r\n\t\tXMLTest(\"Dream\", \"DOCTYPE PLAY SYSTEM \\\"play.dtd\\\"\",\r\n\t\t\tdoc.FirstChild()->NextSibling()->ToUnknown()->Value());\r\n\t\tXMLTest(\"Dream\", \"And Robin shall restore amends.\",\r\n\t\t\tdoc.LastChild()->LastChild()->LastChild()->LastChild()->LastChildElement()->GetText());\r\n\t}\r\n\r\n\t{\r\n\t\t// An assert should not fire.\r\n\t\tconst char* xml = \"<element/>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse with self-closed element\", false, doc.Error() );\r\n\t\tXMLElement* ele = doc.NewElement( \"unused\" );\t\t// This will get cleaned up with the 'doc' going out of scope.\r\n\t\tXMLTest( \"Tracking unused elements\", true, ele != 0, false );\r\n\t}\r\n\r\n\r\n\t{\r\n\t\tconst char* xml = \"<parent><child>abc</child></parent>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse for printing of sub-element\", false, doc.Error() );\r\n\t\tXMLElement* ele = doc.FirstChildElement( \"parent\")->FirstChildElement( \"child\");\r\n\r\n\t\tXMLPrinter printer;\r\n\t\tbool acceptResult = ele->Accept( &printer );\r\n\t\tXMLTest( \"Accept of sub-element\", true, acceptResult );\r\n\t\tXMLTest( \"Printing of sub-element\", \"<child>abc</child>\\n\", printer.CStr(), false );\r\n\t}\r\n\r\n\r\n\t{\r\n\t\tXMLDocument doc;\r\n\t\tXMLError error = doc.LoadFile( \"resources/empty.xml\" );\r\n\t\tXMLTest( \"Loading an empty file\", XML_ERROR_EMPTY_DOCUMENT, error );\r\n\t\tXMLTest( \"Loading an empty file and ErrorName as string\", \"XML_ERROR_EMPTY_DOCUMENT\", doc.ErrorName() );\r\n\t\tdoc.PrintError();\r\n\t}\r\n\r\n\t{\r\n        // BOM preservation\r\n        static const char* xml_bom_preservation  = \"\\xef\\xbb\\xbf<element/>\\n\";\r\n        {\r\n\t\t\tXMLDocument doc;\r\n\t\t\tXMLTest( \"BOM preservation (parse)\", XML_SUCCESS, doc.Parse( xml_bom_preservation ), false );\r\n            XMLPrinter printer;\r\n            doc.Print( &printer );\r\n\r\n            XMLTest( \"BOM preservation (compare)\", xml_bom_preservation, printer.CStr(), false, true );\r\n\t\t\tdoc.SaveFile( \"resources/out/bomtest.xml\" );\r\n\t\t\tXMLTest( \"Save bomtest.xml\", false, doc.Error() );\r\n        }\r\n\t\t{\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.LoadFile( \"resources/out/bomtest.xml\" );\r\n\t\t\tXMLTest( \"Load bomtest.xml\", false, doc.Error() );\r\n\t\t\tXMLTest( \"BOM preservation (load)\", true, doc.HasBOM(), false );\r\n\r\n            XMLPrinter printer;\r\n            doc.Print( &printer );\r\n            XMLTest( \"BOM preservation (compare)\", xml_bom_preservation, printer.CStr(), false, true );\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\t// Insertion with Removal\r\n\t\tconst char* xml = \"<?xml version=\\\"1.0\\\" ?>\"\r\n\t\t\t\"<root>\"\r\n\t\t\t\"<one>\"\r\n\t\t\t\"<subtree>\"\r\n\t\t\t\"<elem>element 1</elem>text<!-- comment -->\"\r\n\t\t\t\"</subtree>\"\r\n\t\t\t\"</one>\"\r\n\t\t\t\"<two/>\"\r\n\t\t\t\"</root>\";\r\n\t\tconst char* xmlInsideTwo = \"<?xml version=\\\"1.0\\\" ?>\"\r\n\t\t\t\"<root>\"\r\n\t\t\t\"<one/>\"\r\n\t\t\t\"<two>\"\r\n\t\t\t\"<subtree>\"\r\n\t\t\t\"<elem>element 1</elem>text<!-- comment -->\"\r\n\t\t\t\"</subtree>\"\r\n\t\t\t\"</two>\"\r\n\t\t\t\"</root>\";\r\n\t\tconst char* xmlAfterOne = \"<?xml version=\\\"1.0\\\" ?>\"\r\n\t\t\t\"<root>\"\r\n\t\t\t\"<one/>\"\r\n\t\t\t\"<subtree>\"\r\n\t\t\t\"<elem>element 1</elem>text<!-- comment -->\"\r\n\t\t\t\"</subtree>\"\r\n\t\t\t\"<two/>\"\r\n\t\t\t\"</root>\";\r\n\t\tconst char* xmlAfterTwo = \"<?xml version=\\\"1.0\\\" ?>\"\r\n\t\t\t\"<root>\"\r\n\t\t\t\"<one/>\"\r\n\t\t\t\"<two/>\"\r\n\t\t\t\"<subtree>\"\r\n\t\t\t\"<elem>element 1</elem>text<!-- comment -->\"\r\n\t\t\t\"</subtree>\"\r\n\t\t\t\"</root>\";\r\n\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest( \"Insertion with removal parse round 1\", false, doc.Error() );\r\n\t\tXMLElement* subtree = doc.RootElement()->FirstChildElement(\"one\")->FirstChildElement(\"subtree\");\r\n\t\tXMLElement* two = doc.RootElement()->FirstChildElement(\"two\");\r\n\t\ttwo->InsertFirstChild(subtree);\r\n\t\tXMLPrinter printer1(0, true);\r\n\t\tbool acceptResult = doc.Accept(&printer1);\r\n\t\tXMLTest(\"Move node from within <one> to <two> - Accept()\", true, acceptResult);\r\n\t\tXMLTest(\"Move node from within <one> to <two>\", xmlInsideTwo, printer1.CStr());\r\n\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest( \"Insertion with removal parse round 2\", false, doc.Error() );\r\n\t\tsubtree = doc.RootElement()->FirstChildElement(\"one\")->FirstChildElement(\"subtree\");\r\n\t\ttwo = doc.RootElement()->FirstChildElement(\"two\");\r\n\t\tdoc.RootElement()->InsertAfterChild(two, subtree);\r\n\t\tXMLPrinter printer2(0, true);\r\n\t\tacceptResult = doc.Accept(&printer2);\r\n\t\tXMLTest(\"Move node from within <one> after <two> - Accept()\", true, acceptResult);\r\n\t\tXMLTest(\"Move node from within <one> after <two>\", xmlAfterTwo, printer2.CStr(), false);\r\n\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest( \"Insertion with removal parse round 3\", false, doc.Error() );\r\n\t\tXMLNode* one = doc.RootElement()->FirstChildElement(\"one\");\r\n\t\tsubtree = one->FirstChildElement(\"subtree\");\r\n\t\tdoc.RootElement()->InsertAfterChild(one, subtree);\r\n\t\tXMLPrinter printer3(0, true);\r\n\t\tacceptResult = doc.Accept(&printer3);\r\n\t\tXMLTest(\"Move node from within <one> after <one> - Accept()\", true, acceptResult);\r\n\t\tXMLTest(\"Move node from within <one> after <one>\", xmlAfterOne, printer3.CStr(), false);\r\n\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest( \"Insertion with removal parse round 4\", false, doc.Error() );\r\n\t\tsubtree = doc.RootElement()->FirstChildElement(\"one\")->FirstChildElement(\"subtree\");\r\n\t\ttwo = doc.RootElement()->FirstChildElement(\"two\");\r\n\t\tXMLTest(\"<two> is the last child at root level\", true, two == doc.RootElement()->LastChildElement());\r\n\t\tdoc.RootElement()->InsertEndChild(subtree);\r\n\t\tXMLPrinter printer4(0, true);\r\n\t\tacceptResult = doc.Accept(&printer4);\r\n\t\tXMLTest(\"Move node from within <one> after <two> - Accept()\", true, acceptResult);\r\n\t\tXMLTest(\"Move node from within <one> after <two>\", xmlAfterTwo, printer4.CStr(), false);\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<svg width = \\\"128\\\" height = \\\"128\\\">\"\r\n\t\t\t\"\t<text> </text>\"\r\n\t\t\t\"</svg>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest( \"Parse svg with text\", false, doc.Error() );\r\n\t\tdoc.Print();\r\n\t}\r\n\r\n\t{\r\n\t\t// Test that it doesn't crash.\r\n\t\tconst char* xml = \"<?xml version=\\\"1.0\\\"?><root><sample><field0><1</field0><field1>2</field1></sample></root>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse(xml);\r\n\t\tXMLTest( \"Parse root-sample-field0\", true, doc.Error() );\r\n\t\tdoc.PrintError();\r\n\t}\r\n\r\n#if 1\r\n\t\t// the question being explored is what kind of print to use:\r\n\t\t// https://github.com/leethomason/tinyxml2/issues/63\r\n\t{\r\n\t\t//const char* xml = \"<element attrA='123456789.123456789' attrB='1.001e9' attrC='1.0e-10' attrD='1001000000.000000' attrE='0.1234567890123456789'/>\";\r\n\t\tconst char* xml = \"<element/>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse self-closed empty element\", false, doc.Error() );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrA-f64\", 123456789.123456789 );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrB-f64\", 1.001e9 );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrC-f64\", 1.0e9 );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrC-f64\", 1.0e20 );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrD-f64\", 1.0e-10 );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrD-f64\", 0.123456789 );\r\n\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrA-f32\", 123456789.123456789f );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrB-f32\", 1.001e9f );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrC-f32\", 1.0e9f );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrC-f32\", 1.0e20f );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrD-f32\", 1.0e-10f );\r\n\t\tdoc.FirstChildElement()->SetAttribute( \"attrD-f32\", 0.123456789f );\r\n\r\n\t\tdoc.Print();\r\n\r\n\t\t/* The result of this test is platform, compiler, and library version dependent. :(\"\r\n\t\tXMLPrinter printer;\r\n\t\tdoc.Print( &printer );\r\n\t\tXMLTest( \"Float and double formatting.\",\r\n\t\t\t\"<element attrA-f64=\\\"123456789.12345679\\\" attrB-f64=\\\"1001000000\\\" attrC-f64=\\\"1e+20\\\" attrD-f64=\\\"0.123456789\\\" attrA-f32=\\\"1.2345679e+08\\\" attrB-f32=\\\"1.001e+09\\\" attrC-f32=\\\"1e+20\\\" attrD-f32=\\\"0.12345679\\\"/>\\n\",\r\n\t\t\tprinter.CStr(),\r\n\t\t\ttrue );\r\n\t\t*/\r\n\t}\r\n#endif\r\n\r\n    {\r\n        // Issue #184\r\n        // If it doesn't assert, it passes. Caused by objects\r\n        // getting created during parsing which are then\r\n        // inaccessible in the memory pools.\r\n        const char* xmlText = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><test>\";\r\n        {\r\n            XMLDocument doc;\r\n            doc.Parse(xmlText);\r\n            XMLTest( \"Parse hex no closing tag round 1\", true, doc.Error() );\r\n        }\r\n        {\r\n            XMLDocument doc;\r\n            doc.Parse(xmlText);\r\n            XMLTest( \"Parse hex no closing tag round 2\", true, doc.Error() );\r\n            doc.Clear();\r\n        }\r\n    }\r\n\r\n    {\r\n        // If this doesn't assert in TINYXML2_DEBUG, all is well.\r\n        tinyxml2::XMLDocument doc;\r\n        tinyxml2::XMLElement *pRoot = doc.NewElement(\"Root\");\r\n        doc.DeleteNode(pRoot);\r\n    }\r\n\r\n    {\r\n        XMLDocument doc;\r\n        XMLElement* root = doc.NewElement( \"Root\" );\r\n        XMLTest( \"Node document before insertion\", true, &doc == root->GetDocument() );\r\n        doc.InsertEndChild( root );\r\n        XMLTest( \"Node document after insertion\", true, &doc == root->GetDocument() );\r\n    }\r\n\r\n    {\r\n        // If this doesn't assert in TINYXML2_DEBUG, all is well.\r\n        XMLDocument doc;\r\n        XMLElement* unlinkedRoot = doc.NewElement( \"Root\" );\r\n        XMLElement* linkedRoot = doc.NewElement( \"Root\" );\r\n        doc.InsertFirstChild( linkedRoot );\r\n        unlinkedRoot->GetDocument()->DeleteNode( linkedRoot );\r\n        unlinkedRoot->GetDocument()->DeleteNode( unlinkedRoot );\r\n    }\r\n\r\n\t{\r\n\t\t// Should not assert in TINYXML2_DEBUG\r\n\t\tXMLPrinter printer;\r\n\t}\r\n\r\n\t{\r\n\t\t// Issue 291. Should not crash\r\n\t\tconst char* xml = \"&#0</a>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse( xml );\r\n\t\tXMLTest( \"Parse hex with closing tag\", false, doc.Error() );\r\n\r\n\t\tXMLPrinter printer;\r\n\t\tdoc.Print( &printer );\r\n\t}\r\n\t{\r\n\t\t// Issue 299. Can print elements that are not linked in.\r\n\t\t// Will crash if issue not fixed.\r\n\t\tXMLDocument doc;\r\n\t\tXMLElement* newElement = doc.NewElement( \"printme\" );\r\n\t\tXMLPrinter printer;\r\n\t\tbool acceptResult = newElement->Accept( &printer );\r\n\t\tXMLTest( \"printme - Accept()\", true, acceptResult );\r\n\t\t// Delete the node to avoid possible memory leak report in debug output\r\n\t\tdoc.DeleteNode( newElement );\r\n\t}\r\n\t{\r\n\t\t// Issue 302. Clear errors from LoadFile/SaveFile\r\n\t\tXMLDocument doc;\r\n\t\tXMLTest( \"Issue 302. Should be no error initially\", \"XML_SUCCESS\", doc.ErrorName() );\r\n\t\tdoc.SaveFile( \"./no/such/path/pretty.xml\" );\r\n\t\tXMLTest( \"Issue 302. Fail to save\", \"XML_ERROR_FILE_COULD_NOT_BE_OPENED\", doc.ErrorName() );\r\n\t\tdoc.SaveFile( \"./resources/out/compact.xml\", true );\r\n\t\tXMLTest( \"Issue 302. Subsequent success in saving\", \"XML_SUCCESS\", doc.ErrorName() );\r\n\t}\r\n\r\n\t{\r\n\t\t// If a document fails to load then subsequent\r\n\t\t// successful loads should clear the error\r\n\t\tXMLDocument doc;\r\n\t\tXMLTest( \"Should be no error initially\", false, doc.Error() );\r\n\t\tdoc.LoadFile( \"resources/no-such-file.xml\" );\r\n\t\tXMLTest( \"No such file - should fail\", true, doc.Error() );\r\n                \r\n\t\tdoc.LoadFile(\"resources/dream.xml\");\r\n\t\tXMLTest(\"Error should be cleared\", false, doc.Error());\r\n\r\n\t\tdoc.LoadFile( \"resources/xmltest-5330.xml\" );\r\n        XMLTest( \"parse errors occur - should fail\", true, doc.Error() );\r\n\r\n\t\tdoc.LoadFile( \"resources/dream.xml\" );\r\n\t\tXMLTest( \"Error should be cleared\", false, doc.Error() );\r\n\t}\r\n\r\n\t{\r\n\t\t// Check that declarations are allowed only at beginning of document\r\n\t    const char* xml0 = \"<?xml version=\\\"1.0\\\" ?>\"\r\n\t                       \"   <!-- xml version=\\\"1.1\\\" -->\"\r\n\t                       \"<first />\";\r\n\t    const char* xml1 = \"<?xml version=\\\"1.0\\\" ?>\"\r\n\t                       \"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"Anything.xsl\\\"?>\"\r\n\t                       \"<first />\";\r\n\t    const char* xml2 = \"<first />\"\r\n\t                       \"<?xml version=\\\"1.0\\\" ?>\";\r\n\t    const char* xml3 = \"<first></first>\"\r\n\t                       \"<?xml version=\\\"1.0\\\" ?>\";\r\n\r\n\t    const char* xml4 = \"<first><?xml version=\\\"1.0\\\" ?></first>\";\r\n\r\n\t    XMLDocument doc;\r\n\t    doc.Parse(xml0);\r\n\t    XMLTest(\"Test that the code changes do not affect normal parsing\", false, doc.Error() );\r\n\t    doc.Parse(xml1);\r\n\t    XMLTest(\"Test that the second declaration is allowed\", false, doc.Error() );\r\n\t    doc.Parse(xml2);\r\n\t    XMLTest(\"Test that declaration after self-closed child is not allowed\", XML_ERROR_PARSING_DECLARATION, doc.ErrorID() );\r\n\t    doc.Parse(xml3);\r\n\t    XMLTest(\"Test that declaration after a child is not allowed\", XML_ERROR_PARSING_DECLARATION, doc.ErrorID() );\r\n\t    doc.Parse(xml4);\r\n\t    XMLTest(\"Test that declaration inside a child is not allowed\", XML_ERROR_PARSING_DECLARATION, doc.ErrorID() );\r\n\t}\r\n\r\n    {\r\n\t    // No matter - before or after successfully parsing a text -\r\n\t    // calling XMLDocument::Value() used to cause an assert in debug.\r\n\t    // Null must be returned.\r\n\t    const char* validXml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\"\r\n\t                           \"<first />\"\r\n\t                           \"<second />\";\r\n\t    XMLDocument* doc = new XMLDocument();\r\n\t    XMLTest( \"XMLDocument::Value() returns null?\", NULL, doc->Value() );\r\n\t    doc->Parse( validXml );\r\n\t    XMLTest( \"Parse to test XMLDocument::Value()\", false, doc->Error());\r\n\t    XMLTest( \"XMLDocument::Value() returns null?\", NULL, doc->Value() );\r\n\t    delete doc;\r\n    }\r\n\r\n\t{\r\n\t\tXMLDocument doc;\r\n\t\tfor( int i = 0; i < XML_ERROR_COUNT; i++ ) {\r\n\t\t\tconst XMLError error = static_cast<XMLError>(i);\r\n\t\t\tconst char* name = XMLDocument::ErrorIDToName(error);\r\n\t\t\tXMLTest( \"ErrorName() not null after ClearError()\", true, name != 0 );\r\n\t\t\tif( name == 0 ) {\r\n\t\t\t\t// passing null pointer into strlen() is undefined behavior, so\r\n\t\t\t\t// compiler is allowed to optimise away the null test above if it's\r\n\t\t\t\t// as reachable as the strlen() call\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tXMLTest( \"ErrorName() not empty after ClearError()\", true, strlen(name) > 0 );\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* html(\"<!DOCTYPE html><html><body><p>test</p><p><br/></p></body></html>\");\r\n\t\tXMLDocument doc(false);\r\n\t\tdoc.Parse(html);\r\n\r\n\t\tXMLPrinter printer(0, true);\r\n\t\tdoc.Print(&printer);\r\n\r\n\t\tXMLTest(html, html, printer.CStr());\r\n\t}\r\n\r\n\t{\r\n\t\t// Evil memory leaks.\r\n\t\t// If an XMLElement (etc) is allocated via NewElement() (etc.)\r\n\t\t// and NOT added to the XMLDocument, what happens?\r\n\t\t//\r\n\t\t// Previously (buggy):\r\n\t\t//\t\tThe memory would be free'd when the XMLDocument is\r\n\t\t//      destructed. But the XMLElement destructor wasn't called, so\r\n\t\t//      memory allocated for the XMLElement text would not be free'd.\r\n\t\t//      In practice this meant strings allocated for the XMLElement\r\n\t\t//      text would be leaked. An edge case, but annoying.\r\n\t\t// Now:\r\n\t\t//      The XMLElement destructor is called. But the unlinked nodes\r\n\t\t//      have to be tracked using a list. This has a minor performance\r\n\t\t//      impact that can become significant if you have a lot of\r\n\t\t//      unlinked nodes. (But why would you do that?)\r\n\t\t// The only way to see this bug was in a Visual C++ runtime debug heap\r\n\t\t// leak tracker. This is compiled in by default on Windows Debug and\r\n\t\t// enabled with _CRTDBG_LEAK_CHECK_DF parameter passed to _CrtSetDbgFlag().\r\n\t\t{\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.NewElement(\"LEAK 1\");\r\n\t\t}\r\n\t\t{\r\n\t\t\tXMLDocument doc;\r\n\t\t\tXMLElement* ele = doc.NewElement(\"LEAK 2\");\r\n\t\t\tdoc.DeleteNode(ele);\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\t// Bad bad crash. Parsing error results in stack overflow, if uncaught.\r\n\t\tconst char* TESTS[] = {\r\n\t\t\t\"./resources/xmltest-5330.xml\",\r\n\t\t\t\"./resources/xmltest-4636783552757760.xml\",\r\n\t\t\t\"./resources/xmltest-5720541257269248.xml\",\r\n\t\t\t0\r\n\t\t};\r\n\t\tfor (int i=0; TESTS[i]; ++i) {\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.LoadFile(TESTS[i]);\r\n\t\t\tXMLTest(\"Stack overflow prevented.\", XML_ELEMENT_DEPTH_EXCEEDED, doc.ErrorID());\r\n\t\t}\r\n\t}\r\n    {\r\n        const char* TESTS[] = {\r\n            \"./resources/xmltest-5662204197076992.xml\",     // Security-level performance issue.\r\n            0\r\n        };\r\n        for (int i = 0; TESTS[i]; ++i) {\r\n            XMLDocument doc;\r\n            doc.LoadFile(TESTS[i]);\r\n            // Need only not crash / lock up.\r\n            XMLTest(\"Fuzz attack prevented.\", true, true);\r\n        }\r\n    }\r\n\t{\r\n\t\t// Crashing reported via email.\r\n\t\tconst char* xml =\r\n\t\t\t\"<playlist id='playlist1'>\"\r\n\t\t\t\"<property name='track_name'>voice</property>\"\r\n\t\t\t\"<property name='audio_track'>1</property>\"\r\n\t\t\t\"<entry out = '604' producer = '4_playlist1' in = '0' />\"\r\n\t\t\t\"<blank length = '1' />\"\r\n\t\t\t\"<entry out = '1625' producer = '3_playlist' in = '0' />\"\r\n\t\t\t\"<blank length = '2' />\"\r\n\t\t\t\"<entry out = '946' producer = '2_playlist1' in = '0' />\"\r\n\t\t\t\"<blank length = '1' />\"\r\n\t\t\t\"<entry out = '128' producer = '1_playlist1' in = '0' />\"\r\n\t\t\t\"</playlist>\";\r\n\r\n\t\t// It's not a good idea to delete elements as you walk the\r\n\t\t// list. I'm not sure this technically should work; but it's\r\n\t\t// an interesting test case.\r\n\t\tXMLDocument doc;\r\n\t\tXMLError err = doc.Parse(xml);\r\n\t\tXMLTest(\"Crash bug parsing\", XML_SUCCESS, err );\r\n\r\n\t\tXMLElement* playlist = doc.FirstChildElement(\"playlist\");\r\n\t\tXMLTest(\"Crash bug parsing\", true, playlist != 0);\r\n\r\n\t\t{\r\n\t\t\tconst char* elementName = \"entry\";\r\n\t\t\tXMLElement* entry = playlist->FirstChildElement(elementName);\r\n\t\t\tXMLTest(\"Crash bug parsing\", true, entry != 0);\r\n\t\t\twhile (entry) {\r\n\t\t\t\tXMLElement* todelete = entry;\r\n\t\t\t\tentry = entry->NextSiblingElement(elementName);\r\n\t\t\t\tplaylist->DeleteChild(todelete);\r\n\t\t\t}\r\n\t\t\tentry = playlist->FirstChildElement(elementName);\r\n\t\t\tXMLTest(\"Crash bug parsing\", true, entry == 0);\r\n\t\t}\r\n\t\t{\r\n\t\t\tconst char* elementName = \"blank\";\r\n\t\t\tXMLElement* blank = playlist->FirstChildElement(elementName);\r\n\t\t\tXMLTest(\"Crash bug parsing\", true, blank != 0);\r\n\t\t\twhile (blank) {\r\n\t\t\t\tXMLElement* todelete = blank;\r\n\t\t\t\tblank = blank->NextSiblingElement(elementName);\r\n\t\t\t\tplaylist->DeleteChild(todelete);\r\n\t\t\t}\r\n\t\t\tXMLTest(\"Crash bug parsing\", true, blank == 0);\r\n\t\t}\r\n\r\n\t\ttinyxml2::XMLPrinter printer;\r\n\t\tconst bool acceptResult = playlist->Accept(&printer);\r\n\t\tXMLTest(\"Crash bug parsing - Accept()\", true, acceptResult);\r\n\t\tprintf(\"%s\\n\", printer.CStr());\r\n\r\n\t\t// No test; it only need to not crash.\r\n\t\t// Still, wrap it up with a sanity check\r\n\t\tint nProperty = 0;\r\n\t\tfor (const XMLElement* p = playlist->FirstChildElement(\"property\"); p; p = p->NextSiblingElement(\"property\")) {\r\n\t\t\tnProperty++;\r\n\t\t}\r\n\t\tXMLTest(\"Crash bug parsing\", 2, nProperty);\r\n\t}\r\n\r\n    // ----------- Line Number Tracking --------------\r\n    {\r\n        struct TestUtil: XMLVisitor\r\n        {\r\n            TestUtil() : str() {}\r\n\r\n            void TestParseError(const char *testString, const char *docStr, XMLError expected_error, int expectedLine)\r\n            {\r\n                XMLDocument doc;\r\n                const XMLError parseError = doc.Parse(docStr);\r\n\r\n                XMLTest(testString, parseError, doc.ErrorID());\r\n                XMLTest(testString, true, doc.Error());\r\n                XMLTest(testString, expected_error, parseError);\r\n                XMLTest(testString, expectedLine, doc.ErrorLineNum());\r\n            };\r\n\r\n            void TestStringLines(const char *testString, const char *docStr, const char *expectedLines)\r\n            {\r\n                XMLDocument doc;\r\n                doc.Parse(docStr);\r\n                XMLTest(testString, false, doc.Error());\r\n                TestDocLines(testString, doc, expectedLines);\r\n            }\r\n\r\n            void TestFileLines(const char *testString, const char *file_name, const char *expectedLines)\r\n            {\r\n                XMLDocument doc;\r\n                doc.LoadFile(file_name);\r\n                XMLTest(testString, false, doc.Error());\r\n                TestDocLines(testString, doc, expectedLines);\r\n            }\r\n\r\n        private:\r\n            DynArray<char, 10> str;\r\n\r\n            void Push(char type, int lineNum)\r\n            {\r\n                str.Push(type);\r\n                str.Push(char('0' + (lineNum / 10)));\r\n                str.Push(char('0' + (lineNum % 10)));\r\n            }\r\n\r\n            bool VisitEnter(const XMLDocument& doc)\r\n            {\r\n                Push('D', doc.GetLineNum());\r\n                return true;\r\n            }\r\n            bool VisitEnter(const XMLElement& element, const XMLAttribute* firstAttribute)\r\n            {\r\n                Push('E', element.GetLineNum());\r\n                for (const XMLAttribute *attr = firstAttribute; attr != 0; attr = attr->Next())\r\n                    Push('A', attr->GetLineNum());\r\n                return true;\r\n            }\r\n            bool Visit(const XMLDeclaration& declaration)\r\n            {\r\n                Push('L', declaration.GetLineNum());\r\n                return true;\r\n            }\r\n            bool Visit(const XMLText& text)\r\n            {\r\n                Push('T', text.GetLineNum());\r\n                return true;\r\n            }\r\n            bool Visit(const XMLComment& comment)\r\n            {\r\n                Push('C', comment.GetLineNum());\r\n                return true;\r\n            }\r\n            bool Visit(const XMLUnknown& unknown)\r\n            {\r\n                Push('U', unknown.GetLineNum());\r\n                return true;\r\n            }\r\n\r\n            void TestDocLines(const char *testString, XMLDocument &doc, const char *expectedLines)\r\n            {\r\n                str.Clear();\r\n                const bool acceptResult = doc.Accept(this);\r\n                XMLTest(testString, true, acceptResult);\r\n                str.Push(0);\r\n                XMLTest(testString, expectedLines, str.Mem());\r\n            }\r\n        } tester;\r\n\r\n\t\ttester.TestParseError(\"ErrorLine-Parsing\", \"\\n<root>\\n foo \\n<unclosed/>\", XML_ERROR_PARSING, 2);\r\n        tester.TestParseError(\"ErrorLine-Declaration\", \"<root>\\n<?xml version=\\\"1.0\\\"?>\", XML_ERROR_PARSING_DECLARATION, 2);\r\n        tester.TestParseError(\"ErrorLine-Mismatch\", \"\\n<root>\\n</mismatch>\", XML_ERROR_MISMATCHED_ELEMENT, 2);\r\n        tester.TestParseError(\"ErrorLine-CData\", \"\\n<root><![CDATA[ \\n foo bar \\n\", XML_ERROR_PARSING_CDATA, 2);\r\n        tester.TestParseError(\"ErrorLine-Text\", \"\\n<root>\\n foo bar \\n\", XML_ERROR_PARSING_TEXT, 3);\r\n        tester.TestParseError(\"ErrorLine-Comment\", \"\\n<root>\\n<!-- >\\n\", XML_ERROR_PARSING_COMMENT, 3);\r\n        tester.TestParseError(\"ErrorLine-Declaration\", \"\\n<root>\\n<? >\\n\", XML_ERROR_PARSING_DECLARATION, 3);\r\n        tester.TestParseError(\"ErrorLine-Unknown\", \"\\n<root>\\n<! \\n\", XML_ERROR_PARSING_UNKNOWN, 3);\r\n        tester.TestParseError(\"ErrorLine-Element\", \"\\n<root>\\n<unclosed \\n\", XML_ERROR_PARSING_ELEMENT, 3);\r\n        tester.TestParseError(\"ErrorLine-Attribute\", \"\\n<root>\\n<unclosed \\n att\\n\", XML_ERROR_PARSING_ATTRIBUTE, 4);\r\n        tester.TestParseError(\"ErrorLine-ElementClose\", \"\\n<root>\\n<unclosed \\n/unexpected\", XML_ERROR_PARSING_ELEMENT, 3);\r\n\r\n\t\ttester.TestStringLines(\r\n            \"LineNumbers-String\",\r\n\r\n            \"<?xml version=\\\"1.0\\\"?>\\n\"\t\t\t\t\t// 1 Doc, DecL\r\n                \"<root a='b' \\n\"\t\t\t\t\t\t// 2 Element Attribute\r\n                \"c='d'> d <blah/>  \\n\"\t\t\t\t\t// 3 Attribute Text Element\r\n                \"newline in text \\n\"\t\t\t\t\t// 4 Text\r\n                \"and second <zxcv/><![CDATA[\\n\"\t\t\t// 5 Element Text\r\n                \" cdata test ]]><!-- comment -->\\n\"\t\t// 6 Comment\r\n                \"<! unknown></root>\",\t\t\t\t\t// 7 Unknown\r\n\r\n            \"D01L01E02A02A03T03E03T04E05T05C06U07\");\r\n\r\n\t\ttester.TestStringLines(\r\n            \"LineNumbers-CRLF\",\r\n\r\n            \"\\r\\n\"\t\t\t\t\t\t\t\t\t\t// 1 Doc (arguably should be line 2)\r\n            \"<?xml version=\\\"1.0\\\"?>\\n\"\t\t\t\t\t// 2 DecL\r\n            \"<root>\\r\\n\"\t\t\t\t\t\t\t\t// 3 Element\r\n            \"\\n\"\t\t\t\t\t\t\t\t\t\t// 4\r\n            \"text contining new line \\n\"\t\t\t\t// 5 Text\r\n            \" and also containing crlf \\r\\n\"\t\t\t// 6\r\n            \"<sub><![CDATA[\\n\"\t\t\t\t\t\t\t// 7 Element Text\r\n            \"cdata containing new line \\n\"\t\t\t\t// 8\r\n            \" and also containing cflr\\r\\n\"\t\t\t\t// 9\r\n            \"]]></sub><sub2/></root>\",\t\t\t\t\t// 10 Element\r\n\r\n            \"D01L02E03T05E07T07E10\");\r\n\r\n\t\ttester.TestFileLines(\r\n            \"LineNumbers-File\",\r\n            \"resources/utf8test.xml\",\r\n            \"D01L01E02E03A03A03T03E04A04A04T04E05A05A05T05E06A06A06T06E07A07A07T07E08A08A08T08E09T09E10T10\");\r\n    }\r\n\r\n    {\r\n    \tconst char* xml = \"<Hello>Text</Error>\";\r\n    \tXMLDocument doc;\r\n    \tdoc.Parse(xml);\r\n    \tXMLTest(\"Test mismatched elements.\", true, doc.Error());\r\n    \tXMLTest(\"Test mismatched elements.\", XML_ERROR_MISMATCHED_ELEMENT, doc.ErrorID());\r\n    \t// For now just make sure calls work & doesn't crash.\r\n    \t// May solidify the error output in the future.\r\n    \tprintf(\"%s\\n\", doc.ErrorStr());\r\n    \tdoc.PrintError();\r\n    }\r\n\r\n\t// ---------- CVE-2024-50615 -----------\r\n\t{\r\n\t\tconst char* xml = \"<Hello value='12&#65;34' value2='56&#x42;78'>Text</Hello>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse(xml);\r\n\t\tconst char* value = doc.FirstChildElement()->Attribute(\"value\");\r\n\t\tconst char* value2 = doc.FirstChildElement()->Attribute(\"value2\");\r\n\t\tXMLTest(\"Test attribute encode\", false, doc.Error());\r\n\t\tXMLTest(\"Test decimal value\", value, \"12A34\");\r\n\t\tXMLTest(\"Test hex encode\", value2, \"56B78\");\r\n\t}\r\n\r\n\t{\r\n\t\tconst char* xml = \"<Hello value='&#ABC9000000065;' value2='&#xffffffff;' value3='&#5000000000;' value4='&#x00000045;' value5='&#x000000000000000021;'>Text</Hello>\";\r\n\t\tXMLDocument doc;\r\n\t\tdoc.Parse(xml);\r\n\t\tconst char* value = doc.FirstChildElement()->Attribute(\"value\");\r\n\t\tconst char* value2 = doc.FirstChildElement()->Attribute(\"value2\");\r\n\t\tconst char* value3 = doc.FirstChildElement()->Attribute(\"value3\");\r\n\t\tconst char* value4 = doc.FirstChildElement()->Attribute(\"value4\");\r\n\t\tconst char* value5 = doc.FirstChildElement()->Attribute(\"value5\");\r\n\t\tXMLTest(\"Test attribute encode\", false, doc.Error());\r\n\t\tXMLTest(\"Test attribute encode too long value\", value, \"&#ABC9000000065;\"); // test long value\r\n\t\tXMLTest(\"Test attribute encode out of unicode range\", value2, \"&#xffffffff;\"); // out of unicode range\r\n\t\tXMLTest(\"Test attribute encode out of int max value\", value3, \"&#5000000000;\"); // out of int max value\r\n\t\tXMLTest(\"Test attribute encode with a Hex value\", value4, \"E\"); // hex value in unicode value\r\n\t\tXMLTest(\"Test attribute encode with a Hex value\", value5, \"!\"); // hex value in unicode value\r\n\t}\r\n\r\n    // ----------- Performance tracking --------------\r\n\t{\r\n#if defined( _MSC_VER )\r\n\t\t__int64 start, end, freq;\r\n\t\tQueryPerformanceFrequency((LARGE_INTEGER*)&freq);\r\n#endif\r\n\r\n\t\tFILE* perfFP = fopen(\"resources/dream.xml\", \"r\");\r\n\t\tXMLTest(\"Open dream.xml\", true, perfFP != 0);\r\n\t\tfseek(perfFP, 0, SEEK_END);\r\n\t\tlong size = ftell(perfFP);\r\n\t\tfseek(perfFP, 0, SEEK_SET);\r\n\r\n\t\tchar* mem = new char[size + 1];\r\n\t\tmemset(mem, 0xfe, size);\r\n\t\tsize_t bytesRead = fread(mem, 1, size, perfFP);\r\n\t\tXMLTest(\"Read dream.xml\", true, uint32_t(size) >= uint32_t(bytesRead));\r\n\t\tfclose(perfFP);\r\n\t\tmem[size] = 0;\r\n\r\n#if defined( _MSC_VER )\r\n\t\tQueryPerformanceCounter((LARGE_INTEGER*)&start);\r\n#else\r\n\t\tclock_t cstart = clock();\r\n#endif\r\n\t\tbool parseDreamXmlFailed = false;\r\n\t\tstatic const int COUNT = 10;\r\n\t\tfor (int i = 0; i < COUNT; ++i) {\r\n\t\t\tXMLDocument doc;\r\n\t\t\tdoc.Parse(mem);\r\n\t\t\tparseDreamXmlFailed = parseDreamXmlFailed || doc.Error();\r\n\t\t}\r\n#if defined( _MSC_VER )\r\n\t\tQueryPerformanceCounter((LARGE_INTEGER*)&end);\r\n#else\r\n\t\tclock_t cend = clock();\r\n#endif\r\n\t\tXMLTest( \"Parse dream.xml\", false, parseDreamXmlFailed );\r\n\r\n\t\tdelete[] mem;\r\n\r\n\t\tstatic const char* note =\r\n#ifdef TINYXML2_DEBUG\r\n\t\t\t\"DEBUG\";\r\n#else\r\n\t\t\t\"Release\";\r\n#endif\r\n\r\n#if defined( _MSC_VER )\r\n\t\tconst double duration = 1000.0 * (double)(end - start) / ((double)freq * (double)COUNT);\r\n#else\r\n\t\tconst double duration = (double)(cend - cstart) / (double)COUNT;\r\n#endif\r\n\t\tprintf(\"\\nParsing dream.xml (%s): %.3f milli-seconds\\n\", note, duration);\r\n\t}\r\n\r\n#if defined( _MSC_VER ) &&  defined( TINYXML2_DEBUG )\r\n\t{\r\n\t\t_CrtMemCheckpoint( &endMemState );\r\n\r\n\t\t_CrtMemState diffMemState;\r\n\t\t_CrtMemDifference( &diffMemState, &startMemState, &endMemState );\r\n\t\t_CrtMemDumpStatistics( &diffMemState );\r\n\r\n\t\t{\r\n\t\t\tint leaksBeforeExit = _CrtDumpMemoryLeaks();\r\n\t\t\tXMLTest( \"No leaks before exit?\", FALSE, leaksBeforeExit );\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\tprintf (\"\\nPass %d, Fail %d\\n\", gPass, gFail);\r\n\r\n\treturn gFail;\r\n}\r\n"
        }
      ]
    }
  ]
}