{
  "metadata": {
    "timestamp": 1736566225280,
    "page": 237,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "0voice/cpp_new_features",
      "stars": 5284,
      "defaultBranch": "main",
      "files": [
        {
          "name": "C++ 20语言特性.md",
          "type": "blob",
          "size": 16.0556640625,
          "content": "> 本文为译文，原文链接：https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/CPP20.md\n\n### Coroutines（协程）\n\n协程是一种特殊的函数，它的执行可以被暂停或恢复。要定义协程，关键字`co_return `，` co_await `，或`co_yield `必须出现在函数体中。c++ 20的协程是无栈的;除非编译器进行了优化，否则它们的状态是在堆上分配的。\n\n协程的一个例子是**generator**函数，它在每次调用时生成一个值:\n\n```cpp\ngenerator<int> range(int start, int end) {\n  while (start < end) {\n    co_yield start;\n    start++;\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n\nfor (int n : range(0, 10)) {\n  std::cout << n << std::endl;\n}\n```\n\n上面的` range `生成器函数生成的值从` start `开始直到` end `(互斥)，每个迭代步骤生成存储在` start `中的当前值。生成器在每次调用` range `时都保持它的状态(在本例中，调用是针对for循环中的每次迭代)。` co_yield `接受给定的表达式，生成(即返回)它的值，并在那一点暂停协程。在恢复时，在` co_yield `之后继续执行。\n\n协程的另一个例子是*task*，它是一个在等待任务时执行的异步计算:\n\n```cpp\ntask<void> echo(socket s) {\n  for (;;) {\n    auto data = co_await s.async_read();\n    co_await async_write(s, data);\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n```\n\n在本例中，引入了` co_await `关键字。这个关键字接受一个表达式，如果您正在等待的东西(在本例中是读或写)没有准备好，则挂起执行，否则继续执行。(注意，在内部，` co_yield `使用` co_await `。)\n\n使用任务惰性地评估一个值:\n\n```cpp\ntask<int> calculate_meaning_of_life() {\n  co_return 42;\n}\n\nauto meaning_of_life = calculate_meaning_of_life();\n// ...\nco_await meaning_of_life; // == 42\n```\n\n注意:虽然这些示例说明了如何在基本级别上使用协程，但在编译代码时还有更多内容。这些例子并不意味着完全覆盖c++ 20的协程。由于标准库还没有提供` generator `和` task `类，所以我使用cppcoro库来编译这些示例。\n\n### Concepts（概念）\n\n*概念*被命名为约束类型的编译时谓词。它们的形式如下:\n\n```cpp\ntemplate < template-parameter-list >\nconcept concept-name = constraint-expression;\n```\n\n其中` constraint-expression `计算为constexpr布尔值。*约束*应该对语义需求进行建模，例如类型是数字类型还是可哈希类型。如果给定的类型不满足它所绑定的概念(例如:“约束表达式”返回“false”)。因为约束是在编译时计算的，所以它们可以提供更有意义的错误消息和运行时安全性。\n\n```cpp\n// `T` is not limited by any constraints.\ntemplate <typename T>\nconcept always_satisfied = true;\n// Limit `T` to integrals.\ntemplate <typename T>\nconcept integral = std::is_integral_v<T>;\n// Limit `T` to both the `integral` constraint and signedness.\ntemplate <typename T>\nconcept signed_integral = integral<T> && std::is_signed_v<T>;\n// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.\ntemplate <typename T>\nconcept unsigned_integral = integral<T> && !signed_integral<T>;\n```\n\n有各种各样的语法形式来加强概念:\n\n```cpp\n// Forms for function parameters:\n// `T` is a constrained type template parameter.\ntemplate <my_concept T>\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate <typename T>\n  requires my_concept<T>\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate <typename T>\nvoid f(T v) requires my_concept<T>;\n\n// `v` is a constrained deduced parameter.\nvoid f(my_concept auto v);\n\n// `v` is a constrained non-type template parameter.\ntemplate <my_concept auto v>\nvoid g();\n\n// Forms for auto-deduced variables:\n// `foo` is a constrained auto-deduced value.\nmy_concept auto foo = ...;\n\n// Forms for lambdas:\n// `T` is a constrained type template parameter.\nauto f = []<my_concept T> (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []<typename T> requires my_concept<T> (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []<typename T> (T v) requires my_concept<T> {\n  // ...\n};\n// `v` is a constrained deduced parameter.\nauto f = [](my_concept auto v) {\n  // ...\n};\n// `v` is a constrained non-type template parameter.\nauto g = []<my_concept auto v> () {\n  // ...\n};\n```\n\n` requires `关键字可以用来启动一个require子句或一个require表达式:\n\n```cpp\ntemplate <typename T>\n  requires my_concept<T> // `requires` clause.\nvoid f(T);\n\ntemplate <typename T>\nconcept callable = requires (T f) { f(); }; // `requires` expression.\n\ntemplate <typename T>\n  requires requires (T x) { x + x; } // `requires` clause and expression on same line.\nT add(T a, T b) {\n  return a + b;\n}\n```\n\n注意，requires表达式中的参数列表是可选的。require表达式中的每个需求都是下列要求之一:\n\n- **Simple requirements** - 断言给定表达式是否有效。\n\n```cpp\ntemplate <typename T>\nconcept callable = requires (T f) { f(); };\n```\n\n- **Type requirements** - 关键字` typename `后跟一个类型名表示，断言给定的类型名是有效的。\n\n```cpp\nstruct foo {\n  int foo;\n};\n\nstruct bar {\n  using value = int;\n  value data;\n};\n\nstruct baz {\n  using value = int;\n  value data;\n};\n\n// Using SFINAE, enable if `T` is a `baz`.\ntemplate <typename T, typename = std::enable_if_t<std::is_same_v<T, baz>>>\nstruct S {};\n\ntemplate <typename T>\nusing Ref = T&;\n\ntemplate <typename T>\nconcept C = requires {\n                     // Requirements on type `T`:\n  typename T::value; // A) has an inner member named `value`\n  typename S<T>;     // B) must have a valid class template specialization for `S`\n  typename Ref<T>;   // C) must be a valid alias template substitution\n};\n\ntemplate <C T>\nvoid g(T a);\n\ng(foo{}); // ERROR: Fails requirement A.\ng(bar{}); // ERROR: Fails requirement B.\ng(baz{}); // PASS.\n```\n\n- **Compound requirements** - 用大括号括起来的表达式，后面跟着返回类型或类型约束。\n\n```cpp\ntemplate <typename T>\nconcept C = requires(T x) {\n  {*x} -> typename T::inner; // the type of the expression `*x` is convertible to `T::inner`\n  {x + 1} -> std::same_as<int>; // the expression `x + 1` satisfies `std::same_as<decltype((x + 1))>`\n  {x * 1} -> T; // the type of the expression `x * 1` is convertible to `T`\n};\n```\n\n- **Nested requirements** - 由` requires `关键字表示，指定额外的约束(例如本地参数参数)。\n\n```cpp\ntemplate <typename T>\nconcept C = requires(T x) {\n  requires std::same_as<sizeof(x), size_t>;\n};\n```\n\n### Designated initializers(指定初始化式)\n\nc风格指定初始化式语法。任何未显式列出在指定初始化列表中的成员字段都是默认初始化的。\n\n```cpp\nstruct A {\n  int x;\n  int y;\n  int z = 123;\n};\n\nA a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2\n```\n\n### Template syntax for lambdas(lambda的模板语法)\n\n在lambda表达式中使用熟悉的模板语法。\n\n```cpp\nauto f = []<typename T>(std::vector<T> v) {\n  // ...\n};\n```\n\n### Range-based for loop with initializer(带初始化器的基于范围的for循环)\n\n该特性简化了常见的代码模式，有助于保持范围紧凑，并为常见的生存期问题提供了优雅的解决方案。\n\n```cpp\nfor (std::vector v{1, 2, 3}; auto& e : v) {\n  std::cout << e;\n}\n// prints \"123\"\n```\n\n### likely and unlikely attributes(可能和不可能的属性)\n\n向优化器提供提示，说明已标记语句执行的概率很高。\n\n```cpp\nswitch (n) {\ncase 1:\n  // ...\n  break;\n\n[[likely]] case 2:  // n == 2 is considered to be arbitrarily more\n  // ...            // likely than any other value of n\n  break;\n}\n```\n\n如果一个可能/不太可能的属性出现在If语句的右括号之后，则表明分支可能/不太可能执行其子语句(体)。\n\n```cpp\nint random = get_random_number_between_x_and_y(0, 3);\nif (random > 0) [[likely]] {\n  // body of if statement\n  // ...\n}\n```\n\n它也可以应用于迭代语句的子语句(体)。\n\n```cpp\nwhile (unlikely_truthy_condition) [[unlikely]] {\n  // body of while statement\n  // ...\n}\n```\n\n### Deprecate implicit capture of this(不建议隐式捕获)\n\n在lamdba捕获中使用`[=]`隐式捕获` this `现在已弃用;更喜欢使用` [=，this] `或` [=，*this] `显式捕获。\n\n```cpp\nstruct int_value {\n  int n = 0;\n  auto getter_fn() {\n    // BAD:\n    // return [=]() { return n; };\n\n    // GOOD:\n    return [=, *this]() { return n; };\n  }\n};\n```\n\n### Class types in non-type template parameters(非类型模板形参中的类型)\n\n类现在可以在非类型模板参数中使用。作为模板参数传入的对象的类型为` const T `，其中` T `是对象的类型，并且具有静态存储时间。\n\n```cpp\nstruct foo {\n  foo() = default;\n  constexpr foo(int) {}\n};\n\ntemplate <foo f>\nauto get_foo() {\n  return f;\n}\n\nget_foo(); // uses implicit constructor\nget_foo<foo{123}>();\n```\n\n### constexpr virtual functions(constexpr虚函数)\n\n虚函数现在可以是` constexpr `并在编译时计算。` constexpr `虚函数可以覆盖非` constexpr `虚函数，反之亦然。\n\n```cpp\nstruct X1 {\n  virtual int f() const = 0;\n};\n\nstruct X2: public X1 {\n  constexpr virtual int f() const { return 2; }\n};\n\nstruct X3: public X2 {\n  virtual int f() const { return 3; }\n};\n\nstruct X4: public X3 {\n  constexpr virtual int f() const { return 4; }\n};\n\nconstexpr X4 x4;\nx4.f(); // == 4\n```\n\n### explicit(bool)(是否显式)\n\n在编译时有条件地选择构造函数是否显式。` explicit(true) `与指定` explicit `相同。\n\n```cpp\nstruct foo {\n  // Specify non-integral types (strings, floats, etc.) require explicit construction.\n  template <typename T>\n  explicit(!std::is_integral_v<T>) foo(T) {}\n};\n\nfoo a = 123; // OK\nfoo b = \"123\"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)\nfoo c {\"123\"}; // OK\n```\n\n### Immediate functions\n\n类似于` constexpr `函数，但是带有` consteval `说明符的函数必须产生一个常量。这些被称为“直接函数”。\n\n```cpp\nconsteval int sqr(int n) {\n  return n * n;\n}\n\nconstexpr int r = sqr(100); // OK\nint x = 100;\nint r2 = sqr(x); // ERROR: the value of `x` is not usable in a constant expression\n                 // OK if `sqr` were a `constexpr` function\n```\n\n### using enum\n\n将枚举成员引入作用域以提高可读性。之前:\n\n```cpp\nenum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel channel) {\n  switch (channel) {\n    case rgba_color_channel::red:   return \"red\";\n    case rgba_color_channel::green: return \"green\";\n    case rgba_color_channel::blue:  return \"blue\";\n    case rgba_color_channel::alpha: return \"alpha\";\n  }\n}\n```\n\n之后:\n\n```cpp\nenum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel my_channel) {\n  switch (my_channel) {\n    using enum rgba_color_channel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n```\n\n### Lambda capture of parameter pack(参数包的Lambda捕获)\n\n捕获参数按值包:\n\n```cpp\ntemplate <typename... Args>\nauto f(Args&&... args){\n    // BY VALUE:\n    return [...args = std::forward<Args>(args)] {\n        // ...\n    };\n}\n```\n\n通过引用捕获参数包:\n\n```cpp\ntemplate <typename... Args>\nauto f(Args&&... args){\n    // BY REFERENCE:\n    return [&...args = std::forward<Args>(args)] {\n        // ...\n    };\n}\n```\n\n### char8_t\n\n提供表示UTF-8字符串的标准类型。\n\n```cpp\nchar8_t utf8_str[] = u8\"\\u0123\";\n```\n\n## c++ 20库功能\n\n### Concepts library\n\n标准库还提供了用于构建更复杂概念的概念。其中包括:\n\n**核心语言概念:**\n\n- `same_as` - 指定两种相同的类型。\n- `derived_from` - 指定一个类型派生自另一个类型。\n- `convertible_to` - 指定一个类型可隐式转换为另一个类型。\n- `common_with` - 指定两个类型共享一个公共类型。\n- `integral` - 指定类型为整型。\n- `default_constructible` - 指定可以默认构造类型的对象。\n\n**Comparison concepts:**\n\n- `boolean` - 指定可在布尔上下文中使用的类型。\n- `equality_comparable` - 指定` operator== `是一个等价关系。\n\n**Object concepts:**\n\n- `movable` - 指定可移动和交换某一类型的对象。\n- `copyable` - 指定可复制、移动和交换某一类型的对象。\n- `semiregular` - 指定某个类型的对象可以被复制、移动、交换和默认构造。\n- `regular` - 指定类型为*regular*，即既为` semiregular `又为` equality_comparable `。\n\n**Callable concepts:**\n\n- `invocable` - 指定可使用给定参数类型集调用可调用类型。\n- `predicate` - 指定可调用类型是布尔谓词。\n\n### Synchronized buffered outputstream\n\n缓冲包装输出流的输出操作，以确保同步(即输出没有交错)。\n\n```cpp\nstd::osyncstream{std::cout} << \"The value of x is:\" << x << std::endl;\n```\n\n### std::span\n\nspan是容器的一个视图(即非所有者视图)，它提供了对连续元素组的边界检查访问。由于视图不拥有它们自己的元素，它们的构造和复制成本很低——考虑视图的一种简单方法是它们持有对其数据的引用。跨度可以是动态大小的，也可以是固定大小的。\n\n```cpp\nvoid f(std::span<int> ints) {\n    std::for_each(ints.begin(), ints.end(), [](auto i) {\n        // ...\n    });\n}\n\nstd::vector<int> v = {1, 2, 3};\nf(v);\nstd::array<int, 3> a = {1, 2, 3};\nf(a);\n// etc.\n```\n\n示例:与维护指针和长度字段不同，span将这两个字段打包在一个容器中。\n\n```cpp\nconstexpr size_t LENGTH_ELEMENTS = 3;\nint* arr = new int[LENGTH_ELEMENTS]; // arr = {0, 0, 0}\n\n// Fixed-sized span which provides a view of `arr`.\nstd::span<int, LENGTH_ELEMENTS> span = arr;\nspan[1] = 1; // arr = {0, 1, 0}\n\n// Dynamic-sized span which provides a view of `arr`.\nstd::span<int> d_span = arr;\nspan[0] = 1; // arr = {1, 1, 0}\nconstexpr size_t LENGTH_ELEMENTS = 3;\nint* arr = new int[LENGTH_ELEMENTS];\n\nstd::span<int, LENGTH_ELEMENTS> span = arr; // OK\nstd::span<double, LENGTH_ELEMENTS> span2 = arr; // ERROR\nstd::span<int, 1> span3 = arr; // ERROR\n```\n\n### Bit operations\n\nc++ 20提供了一个新的` <bit> `头，它提供了一些位操作，包括popcount。\n\n```cpp\nstd::popcount(0u); // 0\nstd::popcount(1u); // 1\nstd::popcount(0b1111`0000u); // 4\n```\n\n### Math constants\n\n在` <numbers> ` header中定义的数学常量，包括PI、欧拉数等。\n\n```cpp\nstd::numbers::pi; // 3.14159...\nstd::numbers::e; // 2.71828...\n```\n\n### std::is_constant_evaluated\n\n谓词函数，当它在编译时上下文中被调用时为真\n\n```cpp\nconstexpr bool is_compile_time() {\n    return std::is_constant_evaluated();\n}\n\nconstexpr bool a = is_compile_time(); // true\nbool b = is_compile_time(); // false\n```\n\n### std::make_shared supports arrays\n\n```cpp\nauto p = std::make_shared<int[]>(5); // pointer to `int[5]`\n// OR\nauto p = std::make_shared<int[5]>(); // pointer to `int[5]`\n```\n\n### starts_with and ends_with on strings\n\n字符串(和字符串视图)现在有` starts_with `和` ends_with `成员函数来检查一个字符串是否以给定的字符串开始或结束。\n\n```cpp\nstd::string str = \"foobar\";\nstr.starts_with(\"foo\"); // true\nstr.ends_with(\"baz\"); // false\n```\n\n### Check if associative container has element\n\n像集合和映射这样的关联容器有一个“contains”成员函数，它可以用来代替“查找和检查迭代器的结束”习惯用法。\n\n```cpp\nstd::map<int, char> map {{1, `a`}, {2, `b`}};\nmap.contains(2); // true\nmap.contains(123); // false\n\nstd::set<int> set {1, 2, 3};\nset.contains(2); // true\n```\n\n### std::bit_cast\n\n将对象从一种类型重新解释为另一种类型的更安全的方法。\n\n```cpp\nfloat f = 123.0;\nint i = std::bit_cast<int>(f);\n```\n\n### std::midpoint\n\n安全地计算两个整数的中点(不溢出)。\n\n```cpp\nstd::midpoint(1, 3); // == 2\n```\n\n### std::to_array\n\n将给定的数组/\"array-like\"对象转换为` std::array `。\n\n```cpp\nstd::to_array(\"foo\"); // returns `std::array<char, 4>`\nstd::to_array<int>({1, 2, 3}); // returns `std::array<int, 3>`\n\nint a[] = {1, 2, 3};\nstd::to_array(a); // returns `std::array<int, 3>`\n```\n"
        },
        {
          "name": "C++ 入门教程（41课时） - 阿里云大学.md",
          "type": "blob",
          "size": 210.0263671875,
          "content": "# C++ 教程\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png)\n\nC++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。\n\n本教程通过通俗易懂的语言来讲解 C++ 编程语言。\n\n**现在开始学习 C++ 编程！**\n\n \n\n## 谁适合阅读本教程？\n\n本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。\n\n## 阅读本教程前，您需要了解的知识：\n\n在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。\n\n## 编译/执行 C++ 程序\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std;int main(){\n    cout << \"Hello, world!\" << endl;    return 0;\n}\n```\n\n运行结果：\n\n```cpp\nHello, world!\n```\n\n你可以用 \"\\n\" 代替以上代码里的 \"endl\"。\n\n# C++ 简介\n\nC++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\n\nC++ 被认为是一种**中级**语言，它综合了高级语言和低级语言的特点。\n\nC++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。\n\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n\n**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。\n\n## 面向对象程序设计\n\nC++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：\n\n- 封装\n- 抽象\n- 继承\n- 多态\n\n## 标准库\n\n标准的 C++ 由三个重要部分组成：\n\n- 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。\n- C++ 标准库，提供了大量的函数，用于操作文件、字符串等。\n- 标准模板库（STL），提供了大量的方法，用于操作数据结构等。\n\n## ANSI 标准\n\nANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。\n\n由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。\n\n## 学习 C++\n\n学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。\n\n学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。\n\nC++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。\n\n## C++ 的使用\n\n基本上每个应用程序领域的程序员都有使用 C++。\n\nC++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。\n\nC++ 广泛用于教学和研究。\n\n任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。\n\n------\n\n## 标准化\n\n| 发布时间 | 文档                  | 通称   | 备注                |      |\n| :------- | :-------------------- | :----- | :------------------ | :--- |\n| 2015     | ISO/IEC TS 19570:2015 | -      | 用于并行计算的扩展  |      |\n| 2015     | ISO/IEC TS 18822:2015 | -      | 文件系统            |      |\n| 2014     | ISO/IEC 14882:2014    | C++14  | 第四个C++标准       |      |\n| 2011     | ISO/IEC TR 24733:2011 | -      | 十进制浮点数扩展    |      |\n| 2011     | ISO/IEC 14882:2011    | C++11  | 第三个C++标准       |      |\n| 2010     | ISO/IEC TR 29124:2010 | -      | 数学函数扩展        |      |\n| 2007     | ISO/IEC TR 19768:2007 | C++TR1 | C++技术报告：库扩展 |      |\n| 2006     | ISO/IEC TR 18015:2006 | -      | C++性能技术报告     |      |\n| 2003     | ISO/IEC 14882:2003    | C++03  | 第二个C++标准       |      |\n| 1998     | ISO/IEC 14882:1998    | C++98  | 第一个C++标准       |      |\n\n# C++ 环境设置\n\n## 本地环境设置\n\n如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。\n\n## 文本编辑器\n\n这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。\n\n文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。\n\n通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。\n\n在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。\n\n## C++ 编译器\n\n写在源文件中的源代码是人类可读的源。它需要\"编译\"，转为机器语言，这样 CPU 可以按给定指令执行程序。\n\nC++ 编译器用于把源代码编译成最终的可执行程序。\n\n大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。\n\n最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。\n\n以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。\n\n## 安装 GNU 的 C/C++ 编译器\n\n### UNIX/Linux 上的安装\n\n如果您使用的是 **Linux 或 UNIX**，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：\n\n```cpp\n$ g++ -v\n```\n\n如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：\n\n```cpp\nUsing built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix\ngcc version 4.1.2 20080704 (Red Hat 4.1.2-46)\n```\n\n如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。\n\n### Mac OS X 上的安装\n\n如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。\n\nXcode 目前可从 developer.apple.com/technologies/tools/ 上下载。\n\n### Windows 上的安装\n\n为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 www.mingw.org，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。\n\n当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。\n\n添加您安装的 MinGW 的 bin 子目录到您的 **PATH** 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。\n\n当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。\n\n------\n\n## 使用 Visual Studio (Graphical Interface) 编译\n\n1、下载及安装 Visual Studio Community 2015。\n\n2、打开 Visual Studio Community\n\n3、点击 File -> New -> Project\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png)\n\n4、左侧列表选择 Templates -> Visual C++ -> Win32 Console Application，并设置项目名为 MyFirstProgram。\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png)\n\n \n\n5、点击 OK。\n\n6、在以下窗口中点击 Next\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png)\n\n7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：\n\n8、右击文件夹 Source File 并点击 Add --> New Item... :\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png)\n\n9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png)\n\n \n\n10、拷贝以下代码到 main.cpp 中：\n\n```cpp\n#include <iostream>int main(){\n    std::cout << \"Hello World!\\n\";\n    return 0;}\n```\n\n界面如下所示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png)\n\n11、点击菜单上的 Debug -> Start Without Debugging (或按下 ctrl + F5) :\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png)\n\n12、完成以上操作后，你可以看到以下输出：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png)\n\n------\n\n## g++ 应用说明\n\n程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：\n\n```cpp\n$ gcc main.cpp -lstdc++ -o main\n```\n\n下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：\n\n```cpp\n#include <iostream>using namespace std;int main(){\n    cout << \"Hello, world!\" << endl;\n    return 0;}\n```\n\n最简单的编译方式：\n\n```cpp\n$ g++ helloworld.cpp\n```\n\n由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：\n\n```cpp\n$ ./a.outHello, world!\n```\n\n通常我们使用 **-o** 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：\n\n```cpp\n$ g++ helloworld.cpp -o helloworld\n```\n\n执行 helloworld:\n\n```cpp\n$ ./helloworldHello, world!\n```\n\n如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：\n\n```cpp\n$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob\n```\n\n生成一个 runoob 可执行文件。\n\ng++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：\n\n```cpp\ng++ -g -Wall -std=c++11 main.cpp\n```\n\n### g++ 常用命令选项\n\n| 选项         | 解释                                                         |\n| :----------- | :----------------------------------------------------------- |\n| -ansi        | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |\n| -c           | 只编译并生成目标文件。                                       |\n| -DMACRO      | 以字符串\"1\"定义 MACRO 宏。                                   |\n| -DMACRO=DEFN | 以字符串\"DEFN\"定义 MACRO 宏。                                |\n| -E           | 只运行 C 预编译器。                                          |\n| -g           | 生成调试信息。GNU 调试器可利用该信息。                       |\n| -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |\n| -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |\n| -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |\n| -m486        | 针对 486 进行代码优化。                                      |\n| -o           | FILE 生成指定的输出文件。用在生成可执行文件时。              |\n| -O0          | 不进行优化处理。                                             |\n| -O           | 或 -O1 优化生成代码。                                        |\n| -O2          | 进一步优化。                                                 |\n| -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |\n| -shared      | 生成共享目标文件。通常用在建立共享库时。                     |\n| -static      | 禁止使用共享连接。                                           |\n| -UMACRO      | 取消对 MACRO 宏的定义。                                      |\n| -w           | 不生成任何警告信息。                                         |\n| -Wall        | 生成所有警告信息。                                           |\n\n# C++ 基本语法\n\nC++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。\n\n- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。\n- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。\n- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。\n- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。\n\n## C++ 程序结构\n\n让我们看一段简单的代码，可以输出单词 *Hello World*。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; // main() 是程序开始执行的地方 \n\tint main(){   \n\tcout << \"Hello World\"; // 输出 Hello World   return 0;\n\t}\n```\n\n接下来我们讲解一下上面这段程序：\n\n- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。\n- 行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。\n- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。\n- 下一行 **int main()** 是主函数，程序从这里开始执行。\n- 下一行 **cout << \"Hello World\";** 会在屏幕上显示消息 \"Hello World\"。\n- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。\n\n## 编译 & 执行 C++ 程序\n\n接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：\n\n- 打开一个文本编辑器，添加上述代码。\n- 保存文件为 hello.cpp。\n- 打开命令提示符，进入到保存文件所在的目录。\n- 键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。\n- 现在，键入 ' a.out' 来运行程序。\n- 您可以看到屏幕上显示 ' Hello World '。\n\n```cpp\n$ g++ hello.cpp$ ./a.outHello World\n```\n\n请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。\n\n您也可以使用 makefile 来编译 C/C++ 程序。\n\n## C++ 中的分号 & 块\n\n在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。\n\n例如，下面是三个不同的语句：\n\n```cpp\nx = y;y = y+1;add(x, y);\n```\n\n块是一组使用大括号括起来的按逻辑连接的语句。例如：\n\n```cpp\n{   cout << \"Hello World\"; // 输出 Hello World   return 0;}\n```\n\nC++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：\n\n```cpp\nx = y;y = y+1;add(x, y);\n```\n\n等同于\n\n```cpp\nx = y; y = y+1; add(x, y);\n```\n\n## C++ 标识符\n\nC++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。\n\nC++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。\n\n下面列出几个有效的标识符：\n\n```cpp\nmohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal\n```\n\n## C++ 关键字\n\n下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。\n\n| asm          | else      | new              | this     |\n| ------------ | --------- | ---------------- | -------- |\n| auto         | enum      | operator         | throw    |\n| bool         | explicit  | private          | true     |\n| break        | export    | protected        | try      |\n| case         | extern    | public           | typedef  |\n| catch        | false     | register         | typeid   |\n| char         | float     | reinterpret_cast | typename |\n| class        | for       | return           | union    |\n| const        | friend    | short            | unsigned |\n| const_cast   | goto      | signed           | using    |\n| continue     | if        | sizeof           | virtual  |\n| default      | inline    | static           | void     |\n| delete       | int       | static_cast      | volatile |\n| do           | long      | struct           | wchar_t  |\n| double       | mutable   | switch           | while    |\n| dynamic_cast | namespace | template         |          |\n\n \n\n## 三字符组\n\n三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。\n\n三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。\n\n三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。\n\n下面列出了最常用的三字符序列：\n\n| 三字符组 | 替换 |\n| :------- | :--- |\n| ??=      | #    |\n| ??/      | \\    |\n| ??'      | ^    |\n| ??(      | [    |\n| ??)      | ]    |\n| ??!      | \\|   |\n| ??<      | {    |\n| ??>      | }    |\n| ??-      | ~    |\n\n如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\"...?\"\"?...\"或者转义序列：\"...?\\?...\"。\n\n从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs\n\ng++仍默认支持三字符组，但会给出编译警告。\n\n## C++ 中的空格\n\n只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。\n\n在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：\n\n```cpp\nint age;\n```\n\n在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：\n\n```cpp\nfruit = apples + oranges;   // 获取水果的总数\n```\n\nfruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。\n\n# C++ 注释\n\n程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。\n\nC++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。\n\nC++ 注释以 /* 开始，以 */ 终止。例如：\n\n```cpp\n/* 这是注释 *//* C++ 注释也可以\n * 跨行\n */\n```\n\n注释也能以 // 开始，直到行末为止。例如：\n\n```cpp\n#include <iostream>using namespace std;main(){\n   cout << \"Hello World\"; // 输出 Hello World\n\n   return 0;}\n```\n\n当上面的代码被编译时，编译器会忽略 **// 输出 Hello World**，最后会产生以下结果：\n\n```cpp\nHello World\n```\n\n在 /* 和 */ 注释内部，// 字符没有特殊的含义。在 // 注释内，/* 和 */ 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：\n\n```\n \n/* 用于输出 Hello World 的注释\n\ncout << \"Hello World\"; // 输出 Hello World\n\n*/\n```\n\n# C++ 数据类型\n\n使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。\n\n您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。\n\n## 基本的内置类型\n\nC++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：\n\n| 类型     | 关键字  |\n| :------- | :------ |\n| 布尔型   | bool    |\n| 字符型   | char    |\n| 整型     | int     |\n| 浮点型   | float   |\n| 双浮点型 | double  |\n| 无类型   | void    |\n| 宽字符型 | wchar_t |\n\n一些基本类型可以使用一个或多个类型修饰符进行修饰：\n\n- signed\n- unsigned\n- short\n- long\n\n下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。\n\n| 类型               | 位            | 范围                                                    |\n| :----------------- | :------------ | :------------------------------------------------------ |\n| char               | 1 个字节      | -128 到 127 或者 0 到 255                               |\n| unsigned char      | 1 个字节      | 0 到 255                                                |\n| signed char        | 1 个字节      | -128 到 127                                             |\n| int                | 4 个字节      | -2147483648 到 2147483647                               |\n| unsigned int       | 4 个字节      | 0 到 4294967295                                         |\n| signed int         | 4 个字节      | -2147483648 到 2147483647                               |\n| short int          | 2 个字节      | -32768 到 32767                                         |\n| unsigned short int | 2 个字节      | 0 到 65,535                                             |\n| signed short int   | 2 个字节      | -32768 到 32767                                         |\n| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |\n| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |\n| unsigned long int  | 8 个字节      | 0 to 18,446,744,073,709,551,615                         |\n| float              | 4 个字节      | +/- 3.4e +/- 38 (~7 个数字)                             |\n| double             | 8 个字节      | +/- 1.7e +/- 308 (~15 个数字)                           |\n| long double        | 8 个字节      | +/- 1.7e +/- 308 (~15 个数字)                           |\n| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                              |\n\n从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。\n\n下面实例会输出您电脑上各种数据类型的大小。\n\n```cpp\n#include <iostream>using namespace std;int main(){   \n\tcout << \"Size of char : \" << sizeof(char) << endl;   \n\tcout << \"Size of int : \" << sizeof(int) << endl;  \n\tcout << \"Size of short int : \" << sizeof(short int) << endl;  \n\tcout << \"Size of long int : \" << sizeof(long int) << endl;   \n\tcout << \"Size of float : \" << sizeof(float) << endl;   \n\tcout << \"Size of double : \" << sizeof(double) << endl;  \n\tcout << \"Size of wchar_t : \" << sizeof(wchar_t) << endl;   return 0;\n}\n```\n\n本实例使用了 **endl**，这将在每一行后插入一个换行符，<< 运算符用于向屏幕传多个值。我们也使用 **sizeof()** 函数来获取各种数据类型的大小。\n\n当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：\n\n```cpp\nSize of char : 1Size of int : 4Size of short int : 2Size of long int : 8Size of float : 4Size of double : 8Size of wchar_t : 4\n```\n\n## typedef 声明\n\n您可以使用 **typedef** 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：\n\n```cpp\ntypedef type newname;\n```\n\n例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：\n\n```cpp\ntypedef int feet;\n```\n\n现在，下面的声明是完全合法的，它创建了一个整型变量 distance：\n\n```cpp\nfeet distance;\n```\n\n## 枚举类型\n\n枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n\n创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：\n\n```cpp\nenum enum-name { list of names } var-list;\n```\n\n在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。\n\n例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。\n\n```cpp\nenum color { red, green, blue } c;c = blue;\n```\n\n默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，**green** 的值为 5。\n\n```cpp\nenum color { red, green=5, blue };\n```\n\n在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。\n\n# C++ 变量类型\n\n变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。\n\n变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。\n\n基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：\n\n| 类型    | 描述                                               |\n| :------ | :------------------------------------------------- |\n| bool    | 存储值 true 或 false。                             |\n| char    | 通常是一个八位字节（一个字节）。这是一个整数类型。 |\n| int     | 对机器而言，整数的最自然的大小。                   |\n| float   | 单精度浮点值。                                     |\n| double  | 双精度浮点值。                                     |\n| void    | 表示类型的缺失。                                   |\n| wchar_t | 宽字符类型。                                       |\n\nC++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等，这将会在后续的章节中进行讲解。\n\n下面我们将讲解如何定义、声明和使用各种类型的变量。\n\n## C++ 中的变量定义\n\n变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：\n\n```cpp\ntype variable_list;\n```\n\n在这里，**type** 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：\n\n```cpp\nint    i, j, k;char   c, ch;float  f, salary;double d;\n```\n\n行 **int i, j, k;** 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。\n\n变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：\n\n```cpp\ntype variable_name = value;\n```\n\n下面列举几个实例：\n\n```cpp\nextern int d = 3, f = 5;   \n\t// d 和 f 的声明 int d = 3, f = 5;          \n\t// 定义并初始化 d 和 fbyte z = 22;               \n\t// 定义并初始化 zchar x = 'x';              \n\t// 变量 x 的值为 'x'\n```\n\n不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。\n\n## C++ 中的变量声明\n\n变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n\n当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。\n\n## 实例\n\n尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：\n\n```cpp\n#include <iostream>using namespace std;// 变量声明extern int a, b;extern int c;extern float f;\n  int main (){\n  // 变量定义\n  int a, b;\n  int c;\n  float f;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n \n  cout << c << endl ;\n\n  f = 70.0/3.0;\n  cout << f << endl ;\n \n  return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n3023.3333\n```\n\n同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：\n\n```cpp\n// 函数声明int func();int main(){\n    // 函数调用\n    int i = func();}// 函数定义int func(){\n    return 0;}\n```\n\n## C++ 中的左值（Lvalues）和右值（Rvalues）\n\nC++ 中有两种类型的表达式：\n\n- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：\n\n```cpp\nint g = 20;\n```\n\n但是下面这个就不是一个有效的语句，会生成编译时错误：\n\n```cpp\n10 = 20;\n```\n\n# C++ 变量作用域\n\n作用域是程序的一个区域，一般来说有三个地方可以声明变量：\n\n- 在函数或一个代码块内部声明的变量，称为局部变量。\n- 在函数参数的定义中声明的变量，称为形式参数。\n- 在所有函数外部声明的变量，称为全局变量。\n\n我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。\n\n## 局部变量\n\n在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n  // 局部变量声明\n  int a, b;\n  int c;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n \n  cout << c;\n \n  return 0;}\n```\n\n## 全局变量\n\n在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。\n\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n\n```cpp\n#include <iostream>using namespace std;\n // 全局变量声明int g;\n int main (){\n  // 局部变量声明\n  int a, b;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  g = a + b;\n \n  cout << g;\n \n  return 0;}\n```\n\n在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：\n\n```cpp\n#include <iostream>using namespace std;\n // 全局变量声明int g = 20;\n int main (){\n  // 局部变量声明\n  int g = 10;\n \n  cout << g;\n \n  return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n10\n```\n\n## 初始化局部变量和全局变量\n\n当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：\n\n| 数据类型 | 初始化默认值 |\n| :------- | :----------- |\n| int      | 0            |\n| char     | '\\0'         |\n| float    | 0            |\n| double   | 0            |\n| pointer  | NULL         |\n\n正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。\n\n# C++ 常量\n\n常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。\n\n常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。\n\n常量就像是常规的变量，只不过常量的值在定义后不能进行修改。\n\n## 整数常量\n\n整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n\n下面列举几个整数常量的实例：\n\n```cpp\n212         // 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀\n```\n\n以下是各种类型的整数常量的实例：\n\n```cpp\n85         // 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数\n```\n\n## 浮点常量\n\n浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n\n下面列举几个浮点常量的实例：\n\n```cpp\n3.14159       // 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数\n```\n\n## 布尔常量\n\n布尔常量共有两个，它们都是标准的 C++ 关键字：\n\n- **true** 值代表真。\n- **false** 值代表假。\n\n我们不应把 true 的值看成 1，把 false 的值看成 0。\n\n## 字符常量\n\n字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。\n\n字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\\t'），或一个通用的字符（例如 '\\u02C0'）。\n\n在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码：\n\n| 转义序列   | 含义                       |\n| :--------- | :------------------------- |\n| \\\\         | \\ 字符                     |\n| \\'         | ' 字符                     |\n| \\\"         | \" 字符                     |\n| \\?         | ? 字符                     |\n| \\a         | 警报铃声                   |\n| \\b         | 退格键                     |\n| \\f         | 换页符                     |\n| \\n         | 换行符                     |\n| \\r         | 回车                       |\n| \\t         | 水平制表符                 |\n| \\v         | 垂直制表符                 |\n| \\ooo       | 一到三位的八进制数         |\n| \\xhh . . . | 一个或多个数字的十六进制数 |\n\n下面的实例显示了一些转义序列字符：\n\n```cpp\n#include <iostream>using namespace std;int main(){   cout << \"Hello\\tWorld\\n\\n\";   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nHello   World\n```\n\n## 字符串常量\n\n字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。\n\n您可以使用空格做分隔符，把一个很长的字符串常量进行分行。\n\n下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。\n\n```cpp\n\"quot;hello, dear\"\"hello, \\dear\"\"hello, \" \"d\" \"ear\"\n```\n\n## 定义常量\n\n在 C++ 中，有两种简单的定义常量的方式：\n\n- 使用 **#define** 预处理器。\n- 使用 **const** 关键字。\n\n## #define 预处理器\n\n下面是使用 #define 预处理器定义常量的形式：\n\n```cpp\n#define identifier value\n```\n\n具体请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;#define LENGTH 10   #define WIDTH  5#define NEWLINE '\\n'int main(){\n\n   int area;  \n   \n   area = LENGTH * WIDTH;\n   cout << area;\n   cout << NEWLINE;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n50\n```\n\n## const 关键字\n\n您可以使用 **const** 前缀声明指定类型的常量，如下所示：\n\n```cpp\nconst type variable = value;\n```\n\n具体请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;int main(){\n   const int  LENGTH = 10;\n   const int  WIDTH  = 5;\n   const char NEWLINE = '\\n';\n   int area;  \n   \n   area = LENGTH * WIDTH;\n   cout << area;\n   cout << NEWLINE;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n50\n```\n\n请注意，把常量定义为大写字母形式，是一个很好的编程实践。\n\n# C++ 修饰符类型\n\nC++ 允许在 **char、int 和 double** 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。\n\n下面列出了数据类型修饰符：\n\n- signed\n- unsigned\n- long\n- short\n\n修饰符 **signed、unsigned、long 和 short** 可应用于整型，**signed** 和 **unsigned** 可应用于字符型，**long** 可应用于双精度型。\n\n修饰符 **signed** 和 **unsigned** 也可以作为 **long** 或 **short** 修饰符的前缀。例如：**unsigned long int**。\n\nC++ 允许使用速记符号来声明**无符号短整数**或**无符号长整数**。您可以不写 int，只写单词 **unsigned、short** 或 **unsigned、long**，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。\n\n```cpp\nunsigned x;\nunsigned int y;\n```\n\n为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：\n\n```cpp\n#include <iostream>\nusing namespace std;\n \n/* \n * 这个程序演示了有符号整数和无符号整数之间的差别\n*/\nint main()\n{\n   short int i;           // 有符号短整数\n   short unsigned int j;  // 无符号短整数\n\n   j = 50000;\n\n   i = j;\n   cout << i << \" \" << j;\n\n   return 0;\n}\n```\n\n当上面的程序运行时，会输出下列结果：\n\n```cpp\n-15536 50000\n```\n\n上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。\n\n## C++ 中的类型限定符\n\n类型限定符提供了变量的额外信息。\n\n| 限定符   | 含义                                                         |\n| :------- | :----------------------------------------------------------- |\n| const    | **const** 类型的对象在程序执行期间不能被修改改变。           |\n| volatile | 修饰符 **volatile** 告诉编译器，变量的值可能以程序未明确指定的方式被改变。 |\n| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |\n\n# C++ 存储类\n\n存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：\n\n- auto\n- register\n- static\n- extern\n- mutable\n- thread_local (C++11)\n\n从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。\n\n## auto 存储类\n\n自 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\n\nC++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。\n\n根据初始化表达式自动推断被声明的变量的类型，如：\n\nauto f=3.14;    //doubleauto s(\"hello\");  //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\n\n## register 存储类\n\n**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。\n\n{  register int miles;}\n\n寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。\n\n## static 存储类\n\n**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\n\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\n\n在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。\n\n## 实例\n\n```cpp\n#include <iostream>\n // 函数声明 void func(void); \nstatic int count = 10; /* 全局变量 */\n int main(){\n    while(count--)\n    {\n       func();    }\n    return 0;}// 函数定义void func( void ){\n    static int i = 5; // 局部静态变量\n    i++;    std::cout << \"变量 i 为 \" << i ;    std::cout << \" , 变量 count 为 \" << count << std::endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n变量 i 为 6 , 变量 count 为 9变量 i 为 7 , 变量 count 为 8变量 i 为 8 , 变量 count 为 7变量 i 为 9 , 变量 count 为 6变量 i 为 10 , 变量 count 为 5变量 i 为 11 , 变量 count 为 4变量 i 为 12 , 变量 count 为 3变量 i 为 13 , 变量 count 为 2变量 i 为 14 , 变量 count 为 1变量 i 为 15 , 变量 count 为 0\n```\n\n## extern 存储类\n\n**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。\n\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n\n第一个文件：main.cpp\n\n## 实例\n\n```cpp\n#include <iostream>\n int count ;extern void write_extern(); \nint main(){\n   count = 5;   write_extern();}\n```\n\n第二个文件：support.cpp\n\n## 实例\n\n```cpp\n#include <iostream>\n extern int count; \nvoid write_extern(void){\n   std::cout << \"Count is \" << count << std::endl;}\n```\n\n在这里，第二个文件中的 *extern* 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：\n\n```cpp\n$ g++ main.cpp support.cpp -o write\n```\n\n这会产生 **write** 可执行程序，尝试执行 **write**，它会产生下列结果：\n\n```cpp\n$ ./writeCount is 5\n```\n\n## mutable 存储类\n\n**mutable** 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。\n\n## thread_local 存储类\n\n使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\n\nthread_local 说明符可以与 static 或 extern 合并。\n\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\n\n以下演示了可以被声明为 thread_local 的变量：\n\n```cpp\nthread_local int x;  // 命名空间下的全局变量class X{\n    static thread_local std::string s; // 类的static成员变量};static thread_local std::string X::s;  // X::s 是需要定义的\n void foo(){\n    thread_local std::vector<int> v;  // 本地变量}\n```\n\n# C++ 运算符\n\n运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：\n\n- 算术运算符\n- 关系运算符\n- 逻辑运算符\n- 位运算符\n- 赋值运算符\n- 杂项运算符\n\n本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。\n\n## 算术运算符\n\n下表显示了 C++ 支持的算术运算符。\n\n假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n| 运算符 | 描述                                                         | 实例             |\n| :----- | :----------------------------------------------------------- | :--------------- |\n| +      | 把两个操作数相加                                             | A + B 将得到 30  |\n| -      | 从第一个操作数中减去第二个操作数                             | A - B 将得到 -10 |\n| *      | 把两个操作数相乘                                             | A * B 将得到 200 |\n| /      | 分子除以分母                                                 | B / A 将得到 2   |\n| %      | 取模运算符，整除后的余数                                     | B % A 将得到 0   |\n| ++     | [自增运算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整数值增加 1 | A++ 将得到 11    |\n| --     | [自减运算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整数值减少 1 | A-- 将得到 9     |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的算术运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int b = 10;   int c ; \n   c = a + b;   cout << \"Line 1 - c 的值是 \" << c << endl ;   c = a - b;   cout << \"Line 2 - c 的值是 \" << c << endl ;   c = a * b;   cout << \"Line 3 - c 的值是 \" << c << endl ;   c = a / b;   cout << \"Line 4 - c 的值是 \" << c << endl ;   c = a % b;   cout << \"Line 5 - c 的值是 \" << c << endl ; \n   int d = 10;   //  测试自增、自减\n   c = d++;   cout << \"Line 6 - c 的值是 \" << c << endl ; \n   d = 10;    // 重新赋值\n   c = d--;   cout << \"Line 7 - c 的值是 \" << c << endl ;   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - c 的值是 31Line 2 - c 的值是 11Line 3 - c 的值是 210Line 4 - c 的值是 2Line 5 - c 的值是 1Line 6 - c 的值是 10Line 7 - c 的值是 10\n```\n\n## 关系运算符\n\n下表显示了 C++ 支持的关系运算符。\n\n假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |\n| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |\n| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |\n| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |\n| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |\n| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的关系运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int b = 10;   int c ; \n   if( a == b )\n   {\n      cout << \"Line 1 - a 等于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 1 - a 不等于 b\" << endl ;   }\n   if ( a < b )\n   {\n      cout << \"Line 2 - a 小于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 2 - a 不小于 b\" << endl ;   }\n   if ( a > b )\n   {\n      cout << \"Line 3 - a 大于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 3 - a 不大于 b\" << endl ;   }\n   /* 改变 a 和 b 的值 */\n   a = 5;   b = 20;   if ( a <= b )\n   {\n      cout << \"Line 4 - a 小于或等于 b\" << endl ;   }\n   if ( b >= a )\n   {\n      cout << \"Line 5 - b 大于或等于 a\" << endl ;   }\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - a 不等于 bLine 2 - a 不小于 bLine 3 - a 大于 bLine 4 - a 小于或等于 bLine 5 - b 大于或等于 a\n```\n\n## 逻辑运算符\n\n下表显示了 C++ 支持的关系逻辑运算符。\n\n假设变量 A 的值为 1，变量 B 的值为 0，则：\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (A && B) 为假。   |\n| \\|\\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \\|\\| B) 为真。 |\n| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的逻辑运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 5;   int b = 20;   int c ; \n   if ( a && b )\n   {\n      cout << \"Line 1 - 条件为真\"<< endl ;   }\n   if ( a || b )\n   {\n      cout << \"Line 2 - 条件为真\"<< endl ;   }\n   /* 改变 a 和 b 的值 */\n   a = 0;   b = 10;   if ( a && b )\n   {\n      cout << \"Line 3 - 条件为真\"<< endl ;   }\n   else\n   {\n      cout << \"Line 4 - 条件不为真\"<< endl ;   }\n   if ( !(a && b) )\n   {\n      cout << \"Line 5 - 条件为真\"<< endl ;   }\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - 条件为真Line 2 - 条件为真Line 4 - 条件不为真Line 5 - 条件为真\n```\n\n## 位运算符\n\n位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：\n\n| p    | q    | p & q | p \\| q | p ^ q |\n| :--- | :--- | :---- | :----- | :---- |\n| 0    | 0    | 0     | 0      | 0     |\n| 0    | 1    | 0     | 1      | 1     |\n| 1    | 1    | 1     | 1      | 0     |\n| 1    | 0    | 0     | 1      | 1     |\n\n假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：\n\nA = 0011 1100\n\nB = 0000 1101\n\n\\-----------------\n\nA&B = 0000 1100\n\nA|B = 0011 1101\n\nA^B = 0011 0001\n\n~A = 1100 0011\n\n下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n\n| 运算符 | 描述                                                         | 实例                                                         |\n| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100                            |\n| \\|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。   | (A \\| B) 将得到 61，即为 0011 1101                           |\n| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001                            |\n| ~      | 二进制补码运算符是一元运算符，具有\"翻转\"位效果，即0变成1，1变成0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |\n| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。   | A << 2 将得到 240，即为 1111 0000                            |\n| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。   | A >> 2 将得到 15，即为 0000 1111                             |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的位运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   unsigned int a = 60;      // 60 = 0011 1100  \n   unsigned int b = 13;      // 13 = 0000 1101\n   int c = 0;           \n \n   c = a & b;             // 12 = 0000 1100\n   cout << \"Line 1 - c 的值是 \" << c << endl ; \n   c = a | b;             // 61 = 0011 1101\n   cout << \"Line 2 - c 的值是 \" << c << endl ; \n   c = a ^ b;             // 49 = 0011 0001\n   cout << \"Line 3 - c 的值是 \" << c << endl ; \n   c = ~a;                // -61 = 1100 0011\n   cout << \"Line 4 - c 的值是 \" << c << endl ; \n   c = a << 2;            // 240 = 1111 0000\n   cout << \"Line 5 - c 的值是 \" << c << endl ; \n   c = a >> 2;            // 15 = 0000 1111\n   cout << \"Line 6 - c 的值是 \" << c << endl ; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```\n \nLine 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15\n```\n\n## 赋值运算符\n\n下表列出了 C++ 支持的赋值运算符：\n\n| 运算符 | 描述                                                         | 实例                            |\n| :----- | :----------------------------------------------------------- | :------------------------------ |\n| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |\n| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |\n| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |\n| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |\n| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |\n| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |\n| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |\n| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |\n| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |\n| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |\n| \\|=    | 按位或且赋值运算符                                           | C \\|= 2 等同于 C = C \\| 2       |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的赋值运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int c ; \n   c =  a;   cout << \"Line 1 - =  运算符实例，c 的值 = : \" <<c<< endl ; \n   c +=  a;   cout << \"Line 2 - += 运算符实例，c 的值 = : \" <<c<< endl ; \n   c -=  a;   cout << \"Line 3 - -= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c *=  a;   cout << \"Line 4 - *= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c /=  a;   cout << \"Line 5 - /= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c  = 200;   c %=  a;   cout << \"Line 6 - %= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c <<=  2;   cout << \"Line 7 - <<= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c >>=  2;   cout << \"Line 8 - >>= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c &=  2;   cout << \"Line 9 - &= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c ^=  2;   cout << \"Line 10 - ^= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c |=  2;   cout << \"Line 11 - |= 运算符实例，c 的值 = : \" <<c<< endl ; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - =  运算符实例，c 的值 = 21Line 2 - += 运算符实例，c 的值 = 42Line 3 - -= 运算符实例，c 的值 = 21Line 4 - *= 运算符实例，c 的值 = 441Line 5 - /= 运算符实例，c 的值 = 21Line 6 - %= 运算符实例，c 的值 = 11Line 7 - <<= 运算符实例，c 的值 = 44Line 8 - >>= 运算符实例，c 的值 = 11Line 9 - &= 运算符实例，c 的值 = 2Line 10 - ^= 运算符实例，c 的值 = 0Line 11 - |= 运算符实例，c 的值 = 2\n```\n\n## 杂项运算符\n\n下表列出了 C++ 支持的其他一些重要的运算符。\n\n| 运算符               | 描述                                                         |\n| :------------------- | :----------------------------------------------------------- |\n| sizeof               | [sizeof 运算符](https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |\n| Condition ? X : Y    | [条件运算符](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |\n| ,                    | [逗号运算符](https://edu.aliyun.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |\n| .（点）和 ->（箭头） | [成员运算符](https://edu.aliyun.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |\n| Cast                 | [强制转换运算符](https://edu.aliyun.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |\n| &                    | [指针运算符 &](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |\n| *                    | [指针运算符 *](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |\n\n## C++ 中的运算符优先级\n\n运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。\n\n例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。\n\n下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n\n| 类别       | 运算符                            | 结合性   |\n| :--------- | :-------------------------------- | :------- |\n| 后缀       | () [] -> . ++ - -                 | 从左到右 |\n| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |\n| 乘除       | * / %                             | 从左到右 |\n| 加减       | + -                               | 从左到右 |\n| 移位       | << >>                             | 从左到右 |\n| 关系       | < <= > >=                         | 从左到右 |\n| 相等       | == !=                             | 从左到右 |\n| 位与 AND   | &                                 | 从左到右 |\n| 位异或 XOR | ^                                 | 从左到右 |\n| 位或 OR    | \\|                                | 从左到右 |\n| 逻辑与 AND | &&                                | 从左到右 |\n| 逻辑或 OR  | \\|\\|                              | 从左到右 |\n| 条件       | ?:                                | 从右到左 |\n| 赋值       | = += -= *= /= %=>>= <<= &= ^= \\|= | 从右到左 |\n| 逗号       | ,                                 | 从左到右 |\n\n### 实例\n\n请看下面的实例，了解 C++ 中运算符的优先级。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 /、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 20;   int b = 10;   int c = 15;   int d = 5;   int e; \n   e = (a + b) * c / d;      // ( 30 * 15 ) / 5\n   cout << \"(a + b) * c / d 的值是 \" << e << endl ; \n   e = ((a + b) * c) / d;    // (30 * 15 ) / 5\n   cout << \"((a + b) * c) / d 的值是 \" << e << endl ; \n   e = (a + b) * (c / d);   // (30) * (15/5)\n   cout << \"(a + b) * (c / d) 的值是 \" << e << endl ; \n   e = a + (b * c) / d;     //  20 + (150/5)\n   cout << \"a + (b * c) / d 的值是 \" << e << endl ;  \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\n(a + b) * c / d 的值是 90((a + b) * c) / d 的值是 90(a + b) * (c / d) 的值是 90a + (b * c) / d 的值是 50\n```\n\n# C++ 循环\n\n有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。\n\n编程语言提供了允许更为复杂的执行路径的多种控制结构。\n\n循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png)\n\n## 循环类型\n\nC++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。\n\n| 循环类型        | 描述                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| while 循环      | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |\n| for 循环        | 多次执行一个语句序列，简化管理循环变量的代码。               |\n| do...while 循环 | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |\n| 嵌套循环        | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |\n\n \n\n## 循环控制语句\n\n循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。\n\nC++ 提供了下列的控制语句。点击链接查看每个语句的细节。\n\n| 控制语句      | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| break 语句    | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |\n| continue 语句 | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |\n| goto 语句     | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 |\n\n \n\n## 无限循环\n\n如果条件永远不为假，则循环将变成无限循环。**for** 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n\n   for( ; ; )\n   {\n      printf(\"This loop will run forever.\\n\");\n   }\n\n   return 0;}\n```\n\n当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。\n\n**注意：**您可以按 Ctrl + C 键终止一个无限循环。\n\n# C++ 判断\n\n判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。\n\n下面是大多数编程语言中典型的判断结构的一般形式：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png)\n\n## 判断语句\n\nC++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。\n\n| 语句             | 描述                                                         |\n| :--------------- | :----------------------------------------------------------- |\n| if 语句          | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |\n| if...else 语句   | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |\n| 嵌套 if 语句     | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |\n| switch 语句      | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |\n| 嵌套 switch 语句 | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |\n\n \n\n## ? : 运算符\n\n我们已经在前面的章节中讲解了 [**条件运算符 ? :**](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)，可以用来替代 **if...else** 语句。它的一般形式如下：\n\n```cpp\nExp1 ? Exp2 : Exp3;\n```\n\n其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。\n\n? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。\n\n# C++ 函数\n\n函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。\n\n您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。\n\n函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。\n\nC++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。\n\n函数还有很多叫法，比如方法、子例程或程序，等等。\n\n## 定义函数\n\nC++ 中的函数定义的一般形式如下：\n\n```cpp\nreturn_type function_name( parameter list ){   body of the function}\n```\n\n在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：\n\n- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。\n- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。\n- **函数主体：**函数主体包含一组定义函数执行任务的语句。\n\n## 实例\n\n以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：\n\n```cpp\n// 函数返回两个数中较大的那个数 int max(int num1, int num2) {   // 局部变量声明   int result;    if (num1 > num2)      result = num1;   else      result = num2;    return result; }\n```\n\n## 函数声明\n\n函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n\n函数声明包括以下几个部分：\n\n```cpp\nreturn_type function_name( parameter list );\n```\n\n针对上面定义的函数 max()，以下是函数声明：\n\n```cpp\nint max(int num1, int num2);\n```\n\n在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：\n\n```cpp\nint max(int, int);\n```\n\n当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。\n\n## 调用函数\n\n创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。\n\n当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。\n\n调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：\n\n```cpp\n#include <iostream>using namespace std;\n // 函数声明int max(int num1, int num2);\n int main (){\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int ret;\n \n   // 调用函数来获取最大值\n   ret = max(a, b);\n \n   cout << \"Max value is : \" << ret << endl;\n \n   return 0;}\n // 函数返回两个数中较大的那个数int max(int num1, int num2) {\n   // 局部变量声明\n   int result;\n \n   if (num1 > num2)\n      result = num1;\n   else\n      result = num2;\n \n   return result; }\n```\n\n把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：\n\n```cpp\nMax value is : 200\n```\n\n## 函数参数\n\n如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。\n\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n\n当调用函数时，有两种向函数传递参数的方式：\n\n| 调用类型                                                     | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [传值调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |\n| [指针调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n| [引用调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n\n默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。\n\n## 参数的默认值\n\n当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。\n\n这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;\n int sum(int a, int b=20){\n  int result;\n\n  result = a + b;\n  \n  return (result);}int main (){\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int result;\n \n   // 调用函数来添加值\n   result = sum(a, b);\n   cout << \"Total value is :\" << result << endl;\n\n   // 再次调用函数\n   result = sum(a);\n   cout << \"Total value is :\" << result << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal value is :300Total value is :120\n```\n\n------\n\n## Lambda 函数与表达式\n\nC++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。\n\nLambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。\n\nLambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:\n\n```cpp\n[capture](parameters)->return-type{body}\n```\n\n例如：\n\n```\n \n[](int x, int y){ return x < y ; }\n```\n\n如果没有参数可以表示为：\n\n```cpp\n[capture](parameters){body}\n```\n\n例如：\n\n```cpp\n[]{ ++global_x; }\n```\n\n在一个更为复杂的例子中，返回类型可以被明确的指定如下：\n\n```cpp\n[](int x, int y) -> int { int z = x + y; return z + x; }\n```\n\n本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。\n\n如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。\n\n在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：\n\n```cpp\n[]      // 沒有定义任何变量。使用未定义变量会引发错误。[x, &y] // x以传值方式传入（默认），y以引用方式传入。[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n```\n\n另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：\n\n```cpp\n[this]() { this->someFunc(); }();\n```\n\n# C++ 数字\n\n通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。\n\n## C++ 定义数字\n\n我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n   // 数字定义\n   short  s;\n   int    i;\n   long   l;\n   float  f;\n   double d;\n   \n   // 数字赋值\n   s = 10;      \n   i = 1000;    \n   l = 1000000; \n   f = 230.47;  \n   d = 30949.374;\n   \n   // 数字输出\n   cout << \"short  s :\" << s << endl;\n   cout << \"int    i :\" << i << endl;\n   cout << \"long   l :\" << l << endl;\n   cout << \"float  f :\" << f << endl;\n   cout << \"double d :\" << d << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nshort  s :10int    i :1000long   l :1000000float  f :230.47double d :30949.4\n```\n\n## C++ 数学运算\n\n在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做**内置**函数。您可以在程序中引用这些函数。\n\nC++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。\n\n为了利用这些函数，您需要引用数学头文件 **<cmath>**。\n\n| 序号 | 函数 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **double cos(double);** 该函数返回弧度角（double 型）的余弦。 |\n| 2    | **double sin(double);** 该函数返回弧度角（double 型）的正弦。 |\n| 3    | **double tan(double);** 该函数返回弧度角（double 型）的正切。 |\n| 4    | **double log(double);** 该函数返回参数的自然对数。           |\n| 5    | **double pow(double, double);** 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |\n| 6    | **double hypot(double, double);** 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |\n| 7    | **double sqrt(double);** 该函数返回参数的平方根。            |\n| 8    | **int abs(int);** 该函数返回整数的绝对值。                   |\n| 9    | **double fabs(double);** 该函数返回任意一个十进制数的绝对值。 |\n| 10   | **double floor(double);** 该函数返回一个小于或等于传入参数的最大整数。 |\n\n下面是一个关于数学运算的简单实例：\n\n```cpp\n#include <iostream>#include <cmath>using namespace std;\n int main (){\n   // 数字定义\n   short  s = 10;\n   int    i = -1000;\n   long   l = 100000;\n   float  f = 230.47;\n   double d = 200.374;\n\n   // 数学运算\n   cout << \"sin(d) :\" << sin(d) << endl;\n   cout << \"abs(i)  :\" << abs(i) << endl;\n   cout << \"floor(d) :\" << floor(d) << endl;\n   cout << \"sqrt(f) :\" << sqrt(f) << endl;\n   cout << \"pow( d, 2) :\" << pow(d, 2) << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nsign(d) :-0.634939abs(i)  :1000floor(d) :200sqrt(f) :15.1812pow( d, 2 ) :40149.7\n```\n\n## C++ 随机数\n\n在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。\n\n下面是一个关于生成随机数的简单实例。实例中使用了 **time()** 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：\n\n```cpp\n#include <iostream>#include <ctime>#include <cstdlib>using namespace std;\n int main (){\n   int i,j;\n \n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n\n   /* 生成 10 个随机数 */\n   for( i = 0; i < 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout <<\"随机数： \" << j << endl;\n   }\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n随机数： 1748144778随机数： 630873888随机数： 2134540646随机数： 219404170随机数： 902129458随机数： 920445370随机数： 1319072661随机数： 257938873随机数： 1256201101随机数： 580322989\n```\n\n# C++ 数组\n\nC++ 支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。\n\n数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。\n\n所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。\n\n## 声明数组\n\n在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：\n\n```cpp\ntype arrayName [ arraySize ];\n```\n\n这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：\n\n```cpp\ndouble balance[10];\n```\n\n现在 *balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。\n\n## 初始化数组\n\n在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：\n\n```cpp\ndouble balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};\n```\n\n大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。\n\n如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：\n\n```cpp\ndouble balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};\n```\n\n您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：\n\n```cpp\nbalance[4] = 50.0;\n```\n\n上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：\n\n![数组表示](https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg)\n\n## 访问数组元素\n\n数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：\n\n```cpp\ndouble salary = balance[9];\n```\n\n上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：\n\n```cpp\n#include <iostream>using namespace std;\n #include <iomanip>using std::setw;\n int main (){\n   int n[ 10 ]; // n 是一个包含 10 个整数的数组\n \n   // 初始化数组元素          \n   for ( int i = 0; i < 10; i++ )\n   {\n      n[ i ] = i + 100; // 设置元素 i 为 i + 100\n   }\n   cout << \"Element\" << setw( 13 ) << \"Value\" << endl;\n \n   // 输出数组中每个元素的值                     \n   for ( int j = 0; j < 10; j++ )\n   {\n      cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;\n   }\n \n   return 0;}\n```\n\n上面的程序使用了 **setw()** 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nElement        Value\n      0          100\n      1          101\n      2          102\n      3          103\n      4          104\n      5          105\n      6          106\n      7          107\n      8          108\n      9          109\n```\n\n## C++ 中数组详解\n\n在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：\n\n| 概念           | 描述                                                         |\n| :------------- | :----------------------------------------------------------- |\n| 多维数组       | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |\n| 指向数组的指针 | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |\n| 传递数组给函数 | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |\n| 从函数返回数组 | C++ 允许从函数返回数组。                                     |\n\n# C++ 字符串\n\nC++ 提供了以下两种类型的字符串表示形式：\n\n- C 风格字符串\n- C++ 引入的 string 类类型\n\n## C 风格字符串\n\nC 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 **null** 字符 '\\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n\n下面的声明和初始化创建了一个 \"Hello\" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 \"Hello\" 的字符数多一个。\n\n```cpp\nchar greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};\n```\n\n依据数组初始化规则，您可以把上面的语句写成以下语句：\n\n```cpp\nchar greeting[] = \"Hello\";\n```\n\n以下是 C/C++ 中定义的字符串的内存表示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg)\n\n其实，您不需要把 *null* 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '\\0' 放在字符串的末尾。让我们尝试输出上面的字符串：\n\n## 实例\n\n```cpp\n#include <iostream>\n using namespace std; \nint main (){\n   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; \n   cout << \"Greeting message: \";   cout << greeting << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nGreeting message: Hello\n```\n\nC++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:\n\n| 序号 | 函数 & 目的                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |\n| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |\n| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |\n| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |\n| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |\n| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |\n\n下面的实例使用了上述的一些函数：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std; \nint main (){\n   char str1[11] = \"Hello\";   char str2[11] = \"World\";   char str3[11];   int  len ; \n   // 复制 str1 到 str3\n   strcpy( str3, str1);   cout << \"strcpy( str3, str1) : \" << str3 << endl; \n   // 连接 str1 和 str2\n   strcat( str1, str2);   cout << \"strcat( str1, str2): \" << str1 << endl; \n   // 连接后，str1 的总长度\n   len = strlen(str1);   cout << \"strlen(str1) : \" << len << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstrcpy( str3, str1) : Hellostrcat( str1, str2): HelloWorldstrlen(str1) : 10\n```\n\n## C++ 中的 String 类\n\nC++ 标准库提供了 **string** 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：\n\n现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。\n\n## 实例\n\n```cpp\n#include <iostream>#include <string>\n using namespace std; \nint main (){\n   string str1 = \"Hello\";   string str2 = \"World\";   string str3;   int  len ; \n   // 复制 str1 到 str3\n   str3 = str1;   cout << \"str3 : \" << str3 << endl; \n   // 连接 str1 和 str2\n   str3 = str1 + str2;   cout << \"str1 + str2 : \" << str3 << endl; \n   // 连接后，str3 的总长度\n   len = str3.size();   cout << \"str3.size() :  \" << len << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstr3 : Hellostr1 + str2 : HelloWorldstr3.size() :  10\n```\n\n# C++ 指针\n\n学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。\n\n正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   int  var1;\n   char var2[10];\n\n   cout << \"var1 变量的地址： \";\n   cout << &var1 << endl;\n\n   cout << \"var2 变量的地址： \";\n   cout << &var2 << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nvar1 变量的地址： 0xbfebd5c0var2 变量的地址： 0xbfebd5b6\n```\n\n通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。\n\n## 什么是指针？\n\n**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：\n\n```cpp\ntype *var-name;\n```\n\n在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：\n\n```cpp\nint    *ip;    /* 一个整型的指针 */double *dp;    /* 一个 double 型的指针 */float  *fp;    /* 一个浮点型的指针 */char   *ch;    /* 一个字符型的指针 */\n```\n\n所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n\n## C++ 中使用指针\n\n使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   int  var = 20;   // 实际变量的声明\n   int  *ip;        // 指针变量的声明\n\n   ip = &var;       // 在指针变量中存储 var 的地址\n\n   cout << \"Value of var variable: \";\n   cout << var << endl;\n\n   // 输出在指针变量中存储的地址\n   cout << \"Address stored in ip variable: \";\n   cout << ip << endl;\n\n   // 访问指针中地址的值\n   cout << \"Value of *ip variable: \";\n   cout << *ip << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of var variable: 20Address stored in ip variable: 0xbfc601acValue of *ip variable: 20\n```\n\n## C++ 指针详解\n\n在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：\n\n| 概念               | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| C++ Null 指针      | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |\n| C++ 指针的算术运算 | 可以对指针进行四种算术运算：++、--、+、-                     |\n| C++ 指针 vs 数组   | 指针和数组之间有着密切的关系。                               |\n| C++ 指针数组       | 可以定义用来存储指针的数组。                                 |\n| C++ 指向指针的指针 | C++ 允许指向指针的指针。                                     |\n| C++ 传递指针给函数 | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |\n| C++ 从函数返回指针 | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |\n\n# C++ 引用\n\n引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n\n## C++ 引用 vs 指针\n\n引用很容易与指针混淆，它们之间有三个主要的不同：\n\n- 不存在空引用。引用必须连接到一块合法的内存。\n- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n- 引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n## C++ 中创建引用\n\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：\n\n```cpp\nint i = 17;\n```\n\n我们可以为 i 声明引用变量，如下所示：\n\n```cpp\nint&    r = i;\n```\n\n在这些声明中，& 读作**引用**。因此，第一个声明可以读作 \"r 是一个初始化为 i 的整型引用\"，第二个声明可以读作 \"s 是一个初始化为 d 的 double 型引用\"。下面的实例使用了 int 和 double 引用：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main (){\n   // 声明简单的变量\n   int    i;\n   double d;\n \n   // 声明引用变量\n   int&    r = i;\n   double& s = d;\n   \n   i = 5;\n   cout << \"Value of i : \" << i << endl;\n   cout << \"Value of i reference : \" << r  << endl;\n \n   d = 11.7;\n   cout << \"Value of d : \" << d << endl;\n   cout << \"Value of d reference : \" << s  << endl;\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of i : 5Value of i reference : 5Value of d : 11.7Value of d reference : 11.7\n```\n\n引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：\n\n| 概念             | 描述                                                     |\n| :--------------- | :------------------------------------------------------- |\n| 把引用作为参数   | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 |\n| 把引用作为返回值 | 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。    |\n\n# C++ 日期 & 时间\n\nC++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。\n\n有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。\n\n结构类型 **tm** 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：\n\n```cpp\nstruct tm {\n  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61\n  int tm_min;   // 分，范围从 0 到 59\n  int tm_hour;  // 小时，范围从 0 到 23\n  int tm_mday;  // 一月中的第几天，范围从 1 到 31\n  int tm_mon;   // 月，范围从 0 到 11\n  int tm_year;  // 自 1900 年起的年数\n  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起\n  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起\n  int tm_isdst; // 夏令时}\n```\n\n下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。\n\n| 序号 | 函数 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **time_t time(time_t \\*time);** 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 |\n| 2    | **char \\*ctime(const time_t \\*time);** 该返回一个表示当地时间的字符串指针，字符串形式 *day month year hours:minutes:seconds year\\n\\0*。 |\n| 3    | **struct tm \\*localtime(const time_t \\*time);** 该函数返回一个指向表示本地时间的 **tm** 结构的指针。 |\n| 4    | **clock_t clock(void);** 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 |\n| 5    | **char \\* asctime ( const struct tm \\* time );** 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 |\n| 6    | **struct tm \\*gmtime(const time_t \\*time);** 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 |\n| 7    | **time_t mktime(struct tm \\*time);** 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 |\n| 8    | **double difftime ( time_t time2, time_t time1 );** 该函数返回 time1 和 time2 之间相差的秒数。 |\n| 9    | **size_t strftime();** 该函数可用于格式化日期和时间为指定的格式。 |\n\n## 当前日期和时间\n\n下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。\n\n```cpp\n#include <iostream>#include <ctime>using namespace std;int main( ){\n   // 基于当前系统的当前日期/时间\n   time_t now = time(0);\n   \n   // 把 now 转换为字符串形式\n   char* dt = ctime(&now);\n\n   cout << \"本地日期和时间：\" << dt << endl;\n\n   // 把 now 转换为 tm 结构\n   tm *gmtm = gmtime(&now);\n   dt = asctime(gmtm);\n   cout << \"UTC 日期和时间：\"<< dt << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n本地日期和时间：Sat Jan  8 20:07:41 2011UTC 日期和时间：Sun Jan  9 03:07:41 2011\n```\n\n## 使用结构 tm 格式化时间\n\n**tm** 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。\n\n在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -> 运算符来访问结构成员。\n\n```cpp\n#include <iostream>#include <ctime>using namespace std;int main( ){\n   // 基于当前系统的当前日期/时间\n   time_t now = time(0);\n\n   cout << \"Number of sec since January 1,1970:\" << now << endl;\n\n   tm *ltm = localtime(&now);\n\n   // 输出 tm 结构的各个组成部分\n   cout << \"Year: \"<< 1900 + ltm->tm_year << endl;\n   cout << \"Month: \"<< 1 + ltm->tm_mon<< endl;\n   cout << \"Day: \"<<  ltm->tm_mday << endl;\n   cout << \"Time: \"<< 1 + ltm->tm_hour << \":\";\n   cout << 1 + ltm->tm_min << \":\";\n   cout << 1 + ltm->tm_sec << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nNumber of sec since January 1, 1970:1294548238Year: 2011Month: 1Day: 8Time: 22: 44:59\n```\n\n# C++ 基本的输入输出\n\nC++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。\n\nC++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做**输入操作**。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做**输出操作**。\n\n## I/O 库头文件\n\n下列的头文件在 C++ 编程中很重要。\n\n| 头文件     | 函数和描述                                                   |\n| :--------- | :----------------------------------------------------------- |\n| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |\n| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |\n| <fstream>  | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 |\n\n## 标准输出流（cout）\n\n预定义的对象 **cout** 是 **ostream** 类的一个实例。cout 对象\"连接\"到标准输出设备，通常是显示屏。**cout** 是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream> using namespace std; int main( ){   char str[] = \"Hello C++\";    cout << \"Value of str is : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of str is : Hello C++\n```\n\nC++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。<< 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。\n\n流插入运算符 << 在一个语句中可以多次使用，如上面实例中所示，**endl** 用于在行末添加一个换行符。\n\n## 标准输入流（cin）\n\n预定义的对象 **cin** 是 **istream** 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。**cin** 是与流提取运算符 >> 结合使用的，如下所示：\n\n```cpp\n#include <iostream> using namespace std; int main( ){  \n\tchar name[50];    cout << \"请输入您的名称： \";   \n\tcin >> name;   cout << \"您的名称是： \" << name << endl; }\n```\n\n当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：\n\n```cpp\n请输入您的名称： cplusplus您的名称是： cplusplus\n```\n\nC++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。\n\n流提取运算符 >> 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：\n\n```cpp\ncin >> name >> age;\n```\n\n这相当于下面两个语句：\n\n```cpp\ncin >> name;cin >> age;\n```\n\n## 标准错误流（cerr）\n\n预定义的对象 **cerr** 是 **ostream** 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 **cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。\n\n**cerr** 也是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main( ){\n   char str[] = \"Unable to read....\";\n \n   cerr << \"Error message : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nError message : Unable to read....\n```\n\n## 标准日志流（clog）\n\n预定义的对象 **clog** 是 **ostream** 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。\n\n**clog** 也是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main( ){\n   char str[] = \"Unable to read....\";\n \n   clog << \"Error message : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nError message : Unable to read....\n```\n\n通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。\n\n# C++ 数据结构\n\nC/C++ 数组允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。\n\n结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：\n\n- Title ：标题\n- Author ：作者\n- Subject ：类目\n- Book ID ：书的 ID\n\n## 定义结构\n\n为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：\n\n \n\n```cpp\nstruct type_name {member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..} object_names;\n```\n\n**type_name** 是结构体类型的名称，**member_type1 member_name1** 是标准的变量定义，比如 **int i;** 或者 **float f;** 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 **Books**，变量为 **book**：\n\n```cpp\nstruct Books{   char  title[50];   char  author[50];   char  subject[100];      int   book_id;} book;\n```\n\n## 访问结构成员\n\n为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。\n\n下面的实例演示了结构的用法：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std; \n// 声明一个结构体类型 Books struct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n   // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 输出 Book1 信息\n   cout << \"第一本书标题 : \" << Book1.title <<endl;   cout << \"第一本书作者 : \" << Book1.author <<endl;   cout << \"第一本书类目 : \" << Book1.subject <<endl;   cout << \"第一本书 ID : \" << Book1.book_id <<endl; \n   // 输出 Book2 信息\n   cout << \"第二本书标题 : \" << Book2.title <<endl;   cout << \"第二本书作者 : \" << Book2.author <<endl;   cout << \"第二本书类目 : \" << Book2.subject <<endl;   cout << \"第二本书 ID : \" << Book2.book_id <<endl; \n   return 0;}\n```\n\n实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n第一本书标题 : C++ 教程第一本书作者 : Runoob第一本书类目 : 编程语言第一本书 ID : 12345第二本书标题 : CSS 教程第二本书作者 : Runoob第二本书类目 : 前端技术第二本书 ID : 12346\n```\n\n## 结构作为函数参数\n\n您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std;void printBook( struct Books book ); \n// 声明一个结构体类型 Books struct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n    // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   \n   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 输出 Book1 信息\n   printBook( Book1 ); \n   // 输出 Book2 信息\n   printBook( Book2 ); \n   return 0;}void printBook( struct Books book ){\n   cout << \"书标题 : \" << book.title <<endl;   cout << \"书作者 : \" \n   << book.author <<endl;   cout << \"书类目 : \" << book.subject <<endl;   \n   cout << \"书 ID : \" << book.book_id <<endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n书标题 : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345书标题 : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : 12346\n```\n\n## 指向结构的指针\n\n您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：\n\n```cpp\nstruct Books *struct_pointer;\n```\n\n现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示：\n\n```cpp\nstruct_pointer = &Book1;\n```\n\n为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，如下所示：\n\n```cpp\nstruct_pointer->title;\n```\n\n让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std;void printBook( struct Books *book ); \nstruct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n    // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   \n   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 通过传 Book1 的地址来输出 Book1 信息\n   printBook( &Book1 ); \n   // 通过传 Book2 的地址来输出 Book2 信息\n   printBook( &Book2 ); \n   return 0;}// 该函数以结构指针作为参数void printBook( struct Books *book ){\n   cout << \"书标题  : \" << book->title <<endl;   cout << \"书作者 : \" \n   << book->author <<endl;   cout << \"书类目 : \" << book->subject <<endl;   \n   cout << \"书 ID : \" << book->book_id <<endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n书标题  : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345书标题  : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : 12346\n```\n\n## typedef 关键字\n\n下面是一种更简单的定义结构的方式，您可以为创建的类型取一个\"别名\"。例如：\n\n```cpp\ntypedef struct{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;}Books;\n```\n\n现在，您可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。下面是实例：\n\n```cpp\nBooks Book1, Book2;\n```\n\n您可以使用 **typedef** 关键字来定义非结构类型，如下所示：\n\n```cpp\ntypedef long int *pint32;\n pint32 x, y, z;\n```\n\nx, y 和 z 都是指向长整型 long int 的指针。\n\n# C++ 类 & 对象\n\nC++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。\n\n类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。\n\n## C++ 类定义\n\n定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。\n\n类定义是以关键字 **class** 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 **class** 定义 Box 数据类型，如下所示：\n\n```cpp\nclass Box{   public:      double length;   // Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box};\n```\n\n关键字 **public** 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 **private** 或 **protected**，这个我们稍后会进行讲解。\n\n## 定义 C++ 对象\n\n类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：\n\n```cpp\nBox Box1;          // 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box\n```\n\n对象 Box1 和 Box2 都有它们各自的数据成员。\n\n## 访问数据成员\n\n类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n      double length;   // 长度\n      double breadth;  // 宽度\n      double height;   // 高度};int main( ){\n   Box Box1;        // 声明 Box1，类型为 Box\n   Box Box2;        // 声明 Box2，类型为 Box\n   double volume = 0.0;     // 用于存储体积\n \n   // box 1 详述\n   Box1.height = 5.0; \n   Box1.length = 6.0; \n   Box1.breadth = 7.0;\n\n   // box 2 详述\n   Box2.height = 10.0;\n   Box2.length = 12.0;\n   Box2.breadth = 13.0;\n\n   // box 1 的体积\n   volume = Box1.height * Box1.length * Box1.breadth;\n   cout << \"Box1 的体积：\" << volume <<endl;\n\n   // box 2 的体积\n   volume = Box2.height * Box2.length * Box2.breadth;\n   cout << \"Box2 的体积：\" << volume <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nBox1 的体积：210Box2 的体积：1560\n```\n\n需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。\n\n# 类 & 对象详解\n\n到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。\n\n| 概念                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 类成员函数          | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |\n| 类访问修饰符        | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |\n| 构造函数 & 析构函数 | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |\n| C++ 拷贝构造函数    | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |\n| C++ 友元函数        | **友元函数**可以访问类的 private 和 protected 成员。         |\n| C++ 内联函数        | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |\n| C++ 中的 this 指针  | 每个对象都有一个特殊的指针 **this**，它指向对象本身。        |\n| C++ 中指向类的指针  | 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 |\n| C++ 类的静态成员    | 类的数据成员和函数成员都可以被声明为静态的。                 |\n\n# C++ 继承\n\n面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。\n\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。\n\n继承代表了 **is a** 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。\n\n## 基类 & 派生类\n\n一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：\n\n```cpp\nclass derived-class: access-specifier base-class\n```\n\n其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n\n假设有一个基类 **Shape**，**Rectangle** 是它的派生类，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;// 基类class Shape {\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;};// 派生类class Rectangle: public Shape{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }};int main(void){\n   Rectangle Rect;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\n Total area: 35\n```\n\n## 访问控制和继承\n\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n\n| 访问     | public | protected | private |\n| :------- | :----- | :-------- | :------ |\n| 同一个类 | yes    | yes       | yes     |\n| 派生类   | yes    | yes       | no      |\n| 外部的类 | yes    | no        | no      |\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n- 基类的构造函数、析构函数和拷贝构造函数。\n- 基类的重载运算符。\n- 基类的友元函数。\n\n## 继承类型\n\n当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。\n\n我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：\n\n- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。\n- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。\n- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。\n\n## 多继承\n\n多继承即一个子类可以有多个父类，它继承了多个父类的特性。\n\nC++ 类可以从多个类继承成员，语法如下：\n\n```cpp\nclass <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…{<派生类类体>};\n```\n\n其中，访问修饰符继承方式是 **public、protected** 或 **private** 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：\n\n```cpp\n#include <iostream>\n using namespace std;// 基类 Shapeclass Shape {\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;};// 基类 PaintCostclass PaintCost {\n   public:\n      int getCost(int area)\n      {\n         return area * 70;\n      }};// 派生类class Rectangle: public Shape, public PaintCost{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }};int main(void){\n   Rectangle Rect;\n   int area;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   area = Rect.getArea();\n   \n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   // 输出总花费\n   cout << \"Total paint cost: $\" << Rect.getCost(area) << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal area: 35Total paint cost: $2450\n```\n\n# C++ 重载运算符和重载函数\n\nC++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。\n\n重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n\n当您调用一个**重载函数**或**重载运算符**时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。\n\n## C++ 中的函数重载\n\n在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。\n\n下面的实例中，同名函数 **print()** 被用于输出不同的数据类型：\n\n```cpp\n#include <iostream>using namespace std;\n class printData \n{\n   public:\n      void print(int i) {\n        cout << \"Printing int: \" << i << endl;\n      }\n\n      void print(double  f) {\n        cout << \"Printing float: \" << f << endl;\n      }\n\n      void print(char* c) {\n        cout << \"Printing character: \" << c << endl;\n      }};int main(void){\n   printData pd;\n \n   // Call print to print integer\n   pd.print(5);\n   // Call print to print float\n   pd.print(500.263);\n   // Call print to print character\n   pd.print(\"Hello C++\");\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nPrinting int: 5Printing float: 500.263Printing character: Hello C++\n```\n\n## C++ 中的运算符重载\n\n您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。\n\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n\n```cpp\nBox operator+(const Box&);\n```\n\n声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：\n\n```cpp\nBox operator+(const Box&, const Box&);\n```\n\n下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 **this** 运算符进行访问，如下所示：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n      void setLength( double len )\n      {\n          length = len;\n      }\n\n      void setBreadth( double bre )\n      {\n          breadth = bre;\n      }\n\n      void setHeight( double hei )\n      {\n          height = hei;\n      }\n      // 重载 + 运算符，用于把两个 Box 对象相加\n      Box operator+(const Box& b)\n      {\n         Box box;\n         box.length = this->length + b.length;\n         box.breadth = this->breadth + b.breadth;\n         box.height = this->height + b.height;\n         return box;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度};// 程序的主函数int main( ){\n   Box Box1;                // 声明 Box1，类型为 Box\n   Box Box2;                // 声明 Box2，类型为 Box\n   Box Box3;                // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 把体积存储在该变量中\n \n   // Box1 详述\n   Box1.setLength(6.0); \n   Box1.setBreadth(7.0); \n   Box1.setHeight(5.0);\n \n   // Box2 详述\n   Box2.setLength(12.0); \n   Box2.setBreadth(13.0); \n   Box2.setHeight(10.0);\n \n   // Box1 的体积\n   volume = Box1.getVolume();\n   cout << \"Volume of Box1 : \" << volume <<endl;\n \n   // Box2 的体积\n   volume = Box2.getVolume();\n   cout << \"Volume of Box2 : \" << volume <<endl;\n\n   // 把两个对象相加，得到 Box3\n   Box3 = Box1 + Box2;\n\n   // Box3 的体积\n   volume = Box3.getVolume();\n   cout << \"Volume of Box3 : \" << volume <<endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nVolume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400\n```\n\n## 可重载运算符/不可重载运算符\n\n下面是可重载的运算符列表：\n\n| +    | -    | *    | /      | %      | ^         |\n| ---- | ---- | ---- | ------ | ------ | --------- |\n| &    | \\|   | ~    | !      | ,      | =         |\n| <    | >    | <=   | >=     | ++     | --        |\n| <<   | >>   | ==   | !=     | &&     | \\|\\|      |\n| +=   | -=   | /=   | %=     | ^=     | &=        |\n| \\|=  | *=   | <<=  | >>=    | []     | ()        |\n| ->   | ->*  | new  | new [] | delete | delete [] |\n\n下面是不可重载的运算符列表：\n\n| ::   | .*   | .    | ?:   |\n| ---- | ---- | ---- | ---- |\n|      |      |      |      |\n\n## 运算符重载实例\n\n下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。\n\n| 序号 | 运算符和实例             |\n| :--- | :----------------------- |\n| 1    | 一元运算符重载           |\n| 2    | 二元运算符重载           |\n| 3    | 关系运算符重载           |\n| 4    | 输入/输出运算符重载      |\n| 5    | ++ 和 -- 运算符重载      |\n| 6    | 赋值运算符重载           |\n| 7    | 函数调用运算符 () 重载   |\n| 8    | 下标运算符 [] 重载       |\n| 9    | 类成员访问运算符 -> 重载 |\n\n# C++ 多态\n\n**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。\n\nC++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。\n\n下面的实例中，基类 Shape 被派生为两个类，如下所示：\n\n```cpp\n#include <iostream> using namespace std;\n class Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      int area()\n      {\n         cout << \"Parent class area :\" <<endl;\n         return 0;\n      }};class Rectangle: public Shape{\n   public:\n      Rectangle( int a=0, int b=0):Shape(a, b) { }\n      int area ()\n      { \n         cout << \"Rectangle class area :\" <<endl;\n         return (width * height); \n      }};class Triangle: public Shape{\n   public:\n      Triangle( int a=0, int b=0):Shape(a, b) { }\n      int area ()\n      { \n         cout << \"Triangle class area :\" <<endl;\n         return (width * height / 2); \n      }};// 程序的主函数int main( ){\n   Shape *shape;\n   Rectangle rec(10,7);\n   Triangle  tri(10,5);\n\n   // 存储矩形的地址\n   shape = &rec;\n   // 调用矩形的求面积函数 area\n   shape->area();\n\n   // 存储三角形的地址\n   shape = &tri;\n   // 调用三角形的求面积函数 area\n   shape->area();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nParent class areaParent class area\n```\n\n导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的**静态多态**，或**静态链接** - 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。\n\n但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 **virtual**，如下所示：\n\n```cpp\nclass Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      virtual int area()\n      {\n         cout << \"Parent class area :\" <<endl;\n         return 0;\n      }};\n```\n\n修改后，当编译和执行前面的实例代码时，它会产生以下结果：\n\n```cpp\nRectangle class areaTriangle class area\n```\n\n此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。\n\n正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是**多态**的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。\n\n## 虚函数\n\n**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。\n\n## 纯虚函数\n\n您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。\n\n我们可以把基类中的虚函数 area() 改写如下：\n\n```cpp\nclass Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      // pure virtual function\n      virtual int area() = 0;};\n```\n\n= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。\n\n# C++ 数据抽象\n\n数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。\n\n数据抽象是一种依赖于接口和实现分离的编程（设计）技术。\n\n让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。\n\n因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。\n\n现在，让我们言归正传，就 C++ 编程而言，C++ 类为**数据抽象**提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。\n\n例如，您的程序可以调用 **sort()** 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。\n\n在 C++ 中，我们使用**类**来定义我们自己的抽象数据类型（ADT）。您可以使用类 **ostream** 的 **cout** 对象来输出数据到标准输出，如下所示：\n\n```cpp\n#include <iostream>using namespace std;int main( ){   cout << \"Hello C++\" <<endl;   return 0;}\n```\n\n在这里，您不需要理解 **cout** 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。\n\n## 访问标签强制抽象\n\n在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：\n\n- 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。\n- 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。\n\n访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。\n\n## 数据抽象的好处\n\n数据抽象有两个重要的优势：\n\n- 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。\n- 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。\n\n如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。\n\n## 数据抽象的实例\n\nC++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Adder{\n   public:\n      // 构造函数\n      Adder(int i = 0)\n      {\n        total = i;\n      }\n      // 对外的接口\n      void addNum(int number)\n      {\n          total += number;\n      }\n      // 对外的接口\n      int getTotal()\n      {\n          return total;\n      };\n   private:\n      // 对外隐藏的数据\n      int total;};int main( ){\n   Adder a;\n   \n   a.addNum(10);\n   a.addNum(20);\n   a.addNum(30);\n\n   cout << \"Total \" << a.getTotal() <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal 60\n```\n\n上面的类把数字相加，并返回总和。公有成员 **addNum** 和 **getTotal** 是对外的接口，用户需要知道它们以便使用类。私有成员 **total** 是用户不需要了解的，但又是类能正常工作所必需的。\n\n## 设计策略\n\n抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。\n\n在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。\n\n# C++ 数据封装\n\n所有的 C++ 程序都有以下两个基本要素：\n\n- **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。\n- **程序数据：**数据是程序的信息，会受到程序函数的影响。\n\n封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即**数据隐藏**。\n\n**数据封装**是一种把数据和操作数据的函数捆绑在一起的机制，**数据抽象**是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。\n\nC++ 通过创建**类**来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：\n\n```cpp\nclass Box{\n   public:\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n\t};\n```\n\n变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。\n\n为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 **public** 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。\n\n把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。\n\n## 数据封装的实例\n\nC++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Adder{\n   public:\n      // 构造函数\n      Adder(int i = 0)\n      {\n        total = i;\n      }\n      // 对外的接口\n      void addNum(int number)\n      {\n          total += number;\n      }\n      // 对外的接口\n      int getTotal()\n      {\n          return total;\n      };\n   private:\n      // 对外隐藏的数据\n      int total;};int main( ){\n   Adder a;\n   \n   a.addNum(10);\n   a.addNum(20);\n   a.addNum(30);\n\n   cout << \"Total \" << a.getTotal() <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal 60\n```\n\n上面的类把数字相加，并返回总和。公有成员 **addNum** 和 **getTotal** 是对外的接口，用户需要知道它们以便使用类。私有成员 **total** 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。\n\n## 设计策略\n\n通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的**封装性**。\n\n这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。\n\n# C++ 接口（抽象类）\n\n接口描述了类的行为和功能，而不需要完成类的特定实现。\n\nC++ 接口是使用**抽象类**来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。\n\n如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \"= 0\" 来指定的，如下所示：\n\n```cpp\nclass Box{\n   public:\n      // 纯虚函数\n      virtual double getVolume() = 0;\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度};\n```\n\n设计**抽象类**（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n\n可用于实例化对象的类被称为**具体类**。\n\n## 抽象类的实例\n\n请看下面的实例，基类 Shape 提供了一个接口 **getArea()**，在两个派生类 Rectangle 和 Triangle 中分别实现了 **getArea()**：\n\n```cpp\n#include <iostream>\n using namespace std;\n // 基类class Shape {public:\n   // 提供接口框架的纯虚函数\n   virtual int getArea() = 0;\n   void setWidth(int w)\n   {\n      width = w;\n   }\n   void setHeight(int h)\n   {\n      height = h;\n   }protected:\n   int width;\n   int height;};\n // 派生类class Rectangle: public Shape{public:\n   int getArea()\n   { \n      return (width * height); \n   }};class Triangle: public Shape{public:\n   int getArea()\n   { \n      return (width * height)/2; \n   }};\n int main(void){\n   Rectangle Rect;\n   Triangle  Tri;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n   // 输出对象的面积\n   cout << \"Total Rectangle area: \" << Rect.getArea() << endl;\n\n   Tri.setWidth(5);\n   Tri.setHeight(7);\n   // 输出对象的面积\n   cout << \"Total Triangle area: \" << Tri.getArea() << endl; \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal Rectangle area: 35Total Triangle area: 17\n```\n\n从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。\n\n## 设计策略\n\n面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。\n\n外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。\n\n这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。\n\n# C++ 文件和流\n\n到目前为止，我们已经使用了 **iostream** 标准库，它提供了 **cin** 和 **cout** 方法分别用于从标准输入读取流和向标准输出写入流。\n\n本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 **fstream**，它定义了三个新的数据类型：\n\n| 数据类型 | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。     |\n| ifstream | 该数据类型表示输入文件流，用于从文件读取信息。               |\n| fstream  | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |\n\n要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。\n\n## 打开文件\n\n在从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。\n\n下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。\n\n```cpp\nvoid open(const char *filename, ios::openmode mode);\n```\n\n在这里，**open()** 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。\n\n| 模式标志   | 描述                                                         |\n| :--------- | :----------------------------------------------------------- |\n| ios::app   | 追加模式。所有写入都追加到文件末尾。                         |\n| ios::ate   | 文件打开后定位到文件末尾。                                   |\n| ios::in    | 打开文件用于读取。                                           |\n| ios::out   | 打开文件用于写入。                                           |\n| ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |\n\n您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：\n\n```cpp\nofstream outfile;outfile.open(\"file.dat\", ios::out | ios::trunc );\n```\n\n类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：\n\n```cpp\nfstream  afile;afile.open(\"file.dat\", ios::out | ios::in );\n```\n\n## 关闭文件\n\n当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。\n\n下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。\n\n```cpp\nvoid close();\n```\n\n## 写入文件\n\n在 C++ 编程中，我们使用流插入运算符（ << ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 **ofstream** 或 **fstream** 对象，而不是 **cout** 对象。\n\n## 读取文件\n\n在 C++ 编程中，我们使用流提取运算符（ >> ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 **ifstream** 或 **fstream** 对象，而不是 **cin** 对象。\n\n## 读取 & 写入实例\n\n下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：\n\n```cpp\n#include <fstream>#include <iostream>using namespace std;\n int main (){\n    \n   char data[100];\n\n   // 以写模式打开文件\n   ofstream outfile;\n   outfile.open(\"afile.dat\");\n\n   cout << \"Writing to the file\" << endl;\n   cout << \"Enter your name: \"; \n   cin.getline(data, 100);\n\n   // 向文件写入用户输入的数据\n   outfile << data << endl;\n\n   cout << \"Enter your age: \"; \n   cin >> data;\n   cin.ignore();\n   \n   // 再次向文件写入用户输入的数据\n   outfile << data << endl;\n\n   // 关闭打开的文件\n   outfile.close();\n\n   // 以读模式打开文件\n   ifstream infile; \n   infile.open(\"afile.dat\"); \n \n   cout << \"Reading from the file\" << endl; \n   infile >> data; \n\n   // 在屏幕上写入数据\n   cout << data << endl;\n   \n   // 再次从文件读取数据，并显示它\n   infile >> data; \n   cout << data << endl; \n\n   // 关闭打开的文件\n   infile.close();\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列输入和输出：\n\n```cpp\n$./a.outWriting to the fileEnter your name: ZaraEnter your age: 9Reading from the fileZara9\n```\n\n上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。\n\n## 文件位置指针\n\n**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（\"seek get\"）和关于 ostream 的 **seekp**（\"seek put\"）。\n\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。\n\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 \"get\" 文件位置指针的实例：\n\n```cpp\n// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );\n```\n\n# C++ 异常处理\n\n异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。\n\n异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try、catch、throw**。\n\n- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。\n- **catch:** 在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。\n- **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。\n\n如果有一个块抛出一个异常，捕获异常的方法会使用 **try** 和 **catch** 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：\n\n```cpp\ntry{\n   // 保护代码}catch( ExceptionName e1 ){\n   // catch 块}catch( ExceptionName e2 ){\n   // catch 块}catch( ExceptionName eN ){\n   // catch 块}\n```\n\n如果 **try** 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 **catch** 语句，用于捕获不同类型的异常。\n\n## 抛出异常\n\n您可以使用 **throw** 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。\n\n以下是尝试除以零时抛出异常的实例：\n\n```cpp\ndouble division(int a, int b){\n   if( b == 0 )\n   {\n      throw \"Division by zero condition!\";\n   }\n   return (a/b);}\n```\n\n## 捕获异常\n\n**catch** 块跟在 **try** 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。\n\n```cpp\ntry{\n   // 保护代码}catch( ExceptionName e ){\n  // 处理 ExceptionName 异常的代码}\n```\n\n上面的代码会捕获一个类型为 **ExceptionName** 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：\n\n```cpp\ntry{\n   // 保护代码}catch(...){\n  // 能处理任何异常的代码}\n```\n\n下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。\n\n```cpp\n#include <iostream>using namespace std;double division(int a, int b){\n   if( b == 0 )\n   {\n      throw \"Division by zero condition!\";\n   }\n   return (a/b);}int main (){\n   int x = 50;\n   int y = 0;\n   double z = 0;\n \n   try {\n     z = division(x, y);\n     cout << z << endl;\n   }catch (const char* msg) {\n     cerr << msg << endl;\n   }\n\n   return 0;}\n```\n\n由于我们抛出了一个类型为 **const char\\*** 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nDivision by zero condition!\n```\n\n## C++ 标准的异常\n\nC++ 提供了一系列标准的异常，定义在 **<exception>** 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg)\n\n下表是对上面层次结构中出现的每个异常的说明：\n\n| 异常                   | 描述                                                         |\n| :--------------------- | :----------------------------------------------------------- |\n| **std::exception**     | 该异常是所有标准 C++ 异常的父类。                            |\n| std::bad_alloc         | 该异常可以通过 **new** 抛出。                                |\n| std::bad_cast          | 该异常可以通过 **dynamic_cast** 抛出。                       |\n| std::bad_exception     | 这在处理 C++ 程序中无法预期的异常时非常有用。                |\n| std::bad_typeid        | 该异常可以通过 **typeid** 抛出。                             |\n| **std::logic_error**   | 理论上可以通过读取代码来检测到的异常。                       |\n| std::domain_error      | 当使用了一个无效的数学域时，会抛出该异常。                   |\n| std::invalid_argument  | 当使用了无效的参数时，会抛出该异常。                         |\n| std::length_error      | 当创建了太长的 std::string 时，会抛出该异常。                |\n| std::out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 |\n| **std::runtime_error** | 理论上不可以通过读取代码来检测到的异常。                     |\n| std::overflow_error    | 当发生数学上溢时，会抛出该异常。                             |\n| std::range_error       | 当尝试存储超出范围的值时，会抛出该异常。                     |\n| std::underflow_error   | 当发生数学下溢时，会抛出该异常。                             |\n\n## 定义新的异常\n\n您可以通过继承和重载 **exception** 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：\n\n```cpp\n#include <iostream>#include <exception>using namespace std;struct MyException : public exception{\n  const char * what () const throw ()\n  {\n    return \"C++ Exception\";\n  }};\n int main(){\n  try\n  {\n    throw MyException();\n  }\n  catch(MyException& e)\n  {\n    std::cout << \"MyException caught\" << std::endl;\n    std::cout << e.what() << std::endl;\n  }\n  catch(std::exception& e)\n  {\n    //其他的错误\n  }}\n```\n\n这将产生以下结果：\n\n```cpp\nMyException caught\nC++ Exception\n```\n\n在这里，**what()** 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。\n\n# C++ 动态内存\n\n了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：\n\n- **栈：**在函数内部声明的所有变量都将占用栈内存。\n- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。\n\n很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。\n\n在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 **new** 运算符。\n\n如果您不需要动态分配内存，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。\n\n## new 和 delete 运算符\n\n下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：\n\n```cpp\nnew data-type;\n```\n\n在这里，**data-type** 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 **new** 运算符来完成这点：\n\n```cpp\ndouble* pvalue  = NULL; // 初始化为 null 的指针pvalue  = new double;   // 为变量请求内存\n```\n\n如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：\n\n```cpp\ndouble* pvalue  = NULL;if( !(pvalue  = new double )){\n   cout << \"Error: out of memory.\" <<endl;\n   exit(1);}\n```\n\n**malloc()** 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。\n\n在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：\n\n```cpp\ndelete pvalue;        // 释放 pvalue 所指向的内存\n```\n\n下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   double* pvalue  = NULL; // 初始化为 null 的指针\n   pvalue  = new double;   // 为变量请求内存\n \n   *pvalue = 29494.99;     // 在分配的地址存储值\n   cout << \"Value of pvalue : \" << *pvalue << endl;\n\n   delete pvalue;         // 释放内存\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of pvalue : 29495\n```\n\n## 数组的动态内存分配\n\n假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：\n\n```cpp\nchar* pvalue  = NULL;   // 初始化为 null 的指针pvalue  = new char[20]; // 为变量请求内存\n```\n\n要删除我们刚才创建的数组，语句如下：\n\n```cpp\ndelete [] pvalue;        // 删除 pvalue 所指向的数组\n```\n\n下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：\n\n```cpp\nint ROW = 2;int COL = 3;double **pvalue  = new double* [ROW]; // 为行分配内存// 为列分配内存for(int i = 0; i < COL; i++) {\n    pvalue[i] = new double[COL];}\n```\n\n释放多维数组内存：\n\n```cpp\nfor(int i = 0; i < COL; i++) {\n    delete[] pvalue[i];}delete [] pvalue;\n```\n\n## 对象的动态内存分配\n\n对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n      Box() { \n         cout << \"调用构造函数！\" <<endl; \n      }\n      ~Box() { \n         cout << \"调用析构函数！\" <<endl; \n      }};int main( ){\n   Box* myBoxArray = new Box[4];\n\n   delete [] myBoxArray; // Delete array\n\n   return 0;}\n```\n\n如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！\n```\n\n# C++ 命名空间\n\n假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。\n\n同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。\n\n因此，引入了**命名空间**这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。\n\n## 定义命名空间\n\n命名空间的定义使用关键字 **namespace**，后跟命名空间的名称，如下所示：\n\n```cpp\nnamespace namespace_name {   // 代码声明}\n```\n\n为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：\n\n```cpp\nname::code;  // code 可以是变量或函数\n```\n\n让我们来看看命名空间如何为变量或函数等实体定义范围：\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }}// 第二个命名空间namespace second_space{\n   void func(){\n      cout << \"Inside second_space\" << endl;\n   }}int main (){\n \n   // 调用第一个命名空间中的函数\n   first_space::func();\n   \n   // 调用第二个命名空间中的函数\n   second_space::func(); \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside first_spaceInside second_space\n```\n\n## using 指令\n\n您可以使用 **using namespace** 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }}// 第二个命名空间namespace second_space{\n   void func(){\n      cout << \"Inside second_space\" << endl;\n   }}using namespace first_space;int main (){\n \n   // 调用第一个命名空间中的函数\n   func();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside first_space\n```\n\nusing 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：\n\n```cpp\nusing std::cout;\n```\n\n随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 **std** 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：\n\n```cpp\n#include <iostream>using std::cout;int main (){   \n\tcout << \"std::endl is used with std!\" << std::endl;      \n\treturn 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstd::endl is used with std!\n```\n\n**using** 指令引入的名称遵循正常的范围规则。名称从使用 **using** 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。\n\n## 不连续的命名空间\n\n命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。\n\n所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：\n\n```cpp\nnamespace namespace_name {\n   // 代码声明}\n```\n\n## 嵌套的命名空间\n\n命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：\n\n```cpp\nnamespace namespace_name1 {\n   // 代码声明\n   namespace namespace_name2 {\n      // 代码声明\n   }}\n```\n\n您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：\n\n```cpp\n// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2;// 访问 namespace:name1 中的成员using namespace namespace_name1;\n```\n\n在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }\n   // 第二个命名空间\n   namespace second_space{\n      void func(){\n         cout << \"Inside second_space\" << endl;\n      }\n   }}using namespace first_space::second_space;int main (){\n \n   // 调用第二个命名空间中的函数\n   func();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside second_space\n```\n\n# C++ 模板\n\n模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。\n\n模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。\n\n每个容器都有一个单一的定义，比如 **向量**，我们可以定义许多不同类型的向量，比如 **vector <int>** 或 **vector <string>**。\n\n您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。\n\n## 函数模板\n\n模板函数定义的一般形式如下所示：\n\n```cpp\ntemplate <class type> ret-type func-name(parameter list){   // 函数的主体}\n```\n\n在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。\n\n下面是函数模板的实例，返回两个数种的最大值：\n\n```cpp\n#include <iostream>#include <string>using namespace std;template <typename T>inline T const& Max (T const& a, T const& b) { \n    return a < b ? b:a; } int main (){\n \n    int i = 39;\n    int j = 20;\n    cout << \"Max(i, j): \" << Max(i, j) << endl; \n\n    double f1 = 13.5; \n    double f2 = 20.7; \n    cout << \"Max(f1, f2): \" << Max(f1, f2) << endl; \n\n    string s1 = \"Hello\"; \n    string s2 = \"World\"; \n    cout << \"Max(s1, s2): \" << Max(s1, s2) << endl; \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nMax(i, j): 39Max(f1, f2): 20.7Max(s1, s2): World\n```\n\n## 类模板\n\n正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：\n\n```cpp\ntemplate <class type> class class-name {...}\n```\n\n在这里，**type** 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。\n\n下面的实例定义了类 Stack<>，并实现了泛型方法来对元素进行入栈出栈操作：\n\n```cpp\n#include <iostream>#include <vector>#include <cstdlib>#include <string>#include <stdexcept>using namespace std;template <class T>class Stack { \n  private: \n    vector<T> elems;     // 元素 \n\n  public: \n    void push(T const&);  // 入栈\n    void pop();               // 出栈\n    T top() const;            // 返回栈顶元素\n    bool empty() const{       // 如果为空则返回真。\n        return elems.empty(); \n    } }; template <class T>void Stack<T>::push (T const& elem) { \n    // 追加传入元素的副本\n    elems.push_back(elem);    } template <class T>void Stack<T>::pop () { \n    if (elems.empty()) { \n        throw out_of_range(\"Stack<>::pop(): empty stack\"); \n    }\n\t// 删除最后一个元素\n    elems.pop_back();         } template <class T>T Stack<T>::top () const { \n    if (elems.empty()) { \n        throw out_of_range(\"Stack<>::top(): empty stack\"); \n    }\n\t// 返回最后一个元素的副本 \n    return elems.back();      } int main() { \n    try { \n        Stack<int>         intStack;  // int 类型的栈 \n        Stack<string> stringStack;    // string 类型的栈 \n\n        // 操作 int 类型的栈 \n        intStack.push(7); \n        cout << intStack.top() <<endl; \n\n        // 操作 string 类型的栈 \n        stringStack.push(\"hello\"); \n        cout << stringStack.top() << std::endl; \n        stringStack.pop(); \n        stringStack.pop(); \n    } \n    catch (exception const& ex) { \n        cerr << \"Exception: \" << ex.what() <<endl; \n        return -1;\n    } }\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n7helloException: Stack<>::pop(): empty stack\n```\n\n# C++ 预处理器\n\n预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。\n\n所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。\n\n我们已经看到，之前所有的实例中都有 **#include** 指令。这个宏用于把头文件包含到源文件中。\n\nC++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。\n\n## #define 预处理\n\n\\#define 预处理指令用于创建符号常量。该符号常量通常称为**宏**，指令的一般形式是：\n\n```cpp\n#define macro-name replacement-text\n```\n\n当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：\n\n```cpp\n#include <iostream>using namespace std;#define PI 3.14159int main (){     cout << \"Value of PI :\" << PI << endl;     return 0;}\n```\n\n现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：\n\n```cpp\n$gcc -E test.cpp > test.p...int main (){     cout << \"Value of PI :\" << 3.14159 << endl;     return 0;}\n```\n\n## 函数宏\n\n您可以使用 #define 来定义一个带有参数的宏，如下所示：\n\n```cpp\n#include <iostream>using namespace std;#define MIN(a,b) (a<b ? a : b)int main (){\n   int i, j;\n   i = 100;\n   j = 30;\n   cout <<\"较小的值为：\" << MIN(i, j) << endl;\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n较小的值为：30\n```\n\n## 条件编译\n\n有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。\n\n条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：\n\n```cpp\n#ifndef NULL   #define NULL 0#endif\n```\n\n您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：\n\n```cpp\n#ifdef DEBUG   cerr <<\"Variable x = \" << x << endl;#endif\n```\n\n如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 **cerr** 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：\n\n```cpp\n#if 0   不进行编译的代码#endif\n```\n\n让我们尝试下面的实例：\n\n```cpp\n#include <iostream>using namespace std;#define DEBUG#define MIN(a,b) (((a)<(b)) ? a : b)int main (){\n   int i, j;\n   i = 100;\n   j = 30;#ifdef DEBUG\n   cerr <<\"Trace: Inside main function\" << endl;#endif#if 0\n   /* 这是注释部分 */\n   cout << MKSTR(HELLO C++) << endl;#endif\n\n   cout <<\"The minimum is \" << MIN(i, j) << endl;#ifdef DEBUG\n   cerr <<\"Trace: Coming out of main function\" << endl;#endif\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTrace: Inside main functionThe minimum is 30Trace: Coming out of main function\n```\n\n## # 和 ## 运算符\n\n\\# 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。\n\n请看下面的宏定义：\n\n```cpp\n#include <iostream>using namespace std;#define MKSTR( x ) #xint main (){    cout << MKSTR(HELLO C++) << endl;    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nHELLO C++\n```\n\n让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：\n\n```cpp\ncout << MKSTR(HELLO C++) << endl;\n```\n\n转换成了：\n\n```cpp\ncout << \"HELLO C++\" << endl;\n```\n\n\\## 运算符用于连接两个令牌。下面是一个实例：\n\n```cpp\n#define CONCAT( x, y )  x ## y\n```\n\n当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 \"HELLO C++\"，如下面实例所示。\n\n```cpp\n#include <iostream>using namespace std;#define concat(a, b) a ## bint main(){   int xy = 100;      cout << concat(x, y);   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n100\n```\n\n让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：\n\n```cpp\ncout << concat(x, y);\n```\n\n转换成了：\n\n```cpp\ncout << xy;\n```\n\n## C++ 中的预定义宏\n\nC++ 提供了下表所示的一些预定义宏：\n\n| 宏       | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| __LINE__ | 这会在程序编译时包含当前行号。                               |\n| __FILE__ | 这会在程序编译时包含当前文件名。                             |\n| __DATE__ | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |\n| __TIME__ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |\n\n让我们看看上述这些宏的实例：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n    cout << \"Value of __LINE__ : \" << __LINE__ << endl;\n    cout << \"Value of __FILE__ : \" << __FILE__ << endl;\n    cout << \"Value of __DATE__ : \" << __DATE__ << endl;\n    cout << \"Value of __TIME__ : \" << __TIME__ << endl;\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of __LINE__ : 6Value of __FILE__ : test.cppValue of __DATE__ : Feb 28 2011Value of __TIME__ : 18:52:48\n```\n\n# C++ 信号处理\n\n信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。\n\n有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。\n\n| 信号    | 描述                                         |\n| :------ | :------------------------------------------- |\n| SIGABRT | 程序的异常终止，如调用 **abort**。           |\n| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作。 |\n| SIGILL  | 检测非法指令。                               |\n| SIGINT  | 接收到交互注意信号。                         |\n| SIGSEGV | 非法访问内存。                               |\n| SIGTERM | 发送到程序的终止请求。                       |\n\n## signal() 函数\n\nC++ 信号处理库提供了 **signal** 函数，用来捕获突发事件。以下是 signal() 函数的语法：\n\n```cpp\nvoid (*signal (int sig, void (*func)(int)))(int);\n```\n\n这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。\n\n让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 **signal** 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：\n\n```cpp\n#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n\n    // 清理并关闭\n    // 终止程序  \n\n   exit(signum);  }int main (){\n    // 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n\n    while(1){\n       cout << \"Going to sleep....\" << endl;\n       sleep(1);\n    }\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....\n```\n\n现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.\n```\n\n## raise() 函数\n\n您可以使用函数 **raise()** 生成信号，该函数带有一个整数信号编号作为参数，语法如下：\n\n```cpp\nint raise (signal sig);\n```\n\n在这里，**sig** 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：\n\n```cpp\n#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n\n    // 清理并关闭\n    // 终止程序 \n\n   exit(signum);  }int main (){\n    int i = 0;\n    // 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n\n    while(++i){\n       cout << \"Going to sleep....\" << endl;\n       if( i == 3 ){\n          raise( SIGINT);\n       }\n       sleep(1);\n    }\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.\n```\n\n# C++ 多线程\n\n多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：**基于进程和基于线程**。\n\n- 基于进程的多任务处理是程序的并发执行。\n- 基于线程的多任务处理是同一程序的片段的并发执行。\n\n多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。\n\n本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。\n\n## 创建线程\n\n下面的程序，我们可以用它来创建一个 POSIX 线程：\n\n```cpp\n#include <pthread.h>pthread_create (thread, attr, start_routine, arg)\n```\n\n在这里，**pthread_create** 创建一个新的线程，并让它可执行。下面是关于参数的说明：\n\n| 参数          | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| thread        | 指向线程标识符指针。                                         |\n| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |\n| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |\n| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |\n\n创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。\n\n## 终止线程\n\n使用下面的程序，我们可以用它来终止一个 POSIX 线程：\n\n```cpp\n#include <pthread.h>pthread_exit (status)\n```\n\n在这里，**pthread_exit** 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。\n\n如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。\n\n## 实例\n\n以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出\"Hello Runoob！\":\n\n```cpp\n#include <iostream>// 必须的头文件是#include <pthread.h>using namespace std;#define NUM_THREADS 5// 线程的运行函数void* say_hello(void* args){\n    cout << \"Hello Runoob！\" << endl;}int main(){\n    // 定义线程的 id 变量，多个变量使用数组\n    pthread_t tids[NUM_THREADS];\n    for(int i = 0; i < NUM_THREADS; ++i)\n    {\n        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数\n        int ret = pthread_create(&tids[i], NULL, say_hello, NULL);\n        if (ret != 0)\n        {\n           cout << \"pthread_create error: error_code=\" << ret << endl;\n        }\n    }\n    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；\n    pthread_exit(NULL);}\n```\n\n使用 -lpthread 库编译下面的程序：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o\n```\n\n现在，执行程序，将产生下列结果：\n\n```cpp\n$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！\n```\n\n以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 \"Hello Runoob!\" 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。\n\n```cpp\n//文件名：test.cpp#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid){  \n   // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取\n   int tid = *((int*)threadid);\n   cout << \"Hello Runoob! 线程 ID, \" << tid << endl;\n   pthread_exit(NULL);}int main (){\n   pthread_t threads[NUM_THREADS];\n   int indexes[NUM_THREADS];// 用数组来保存i的值\n   int rc;\n   int i;\n   for( i=0; i < NUM_THREADS; i++ ){      \n      cout << \"main() : 创建线程, \" << i << endl;\n      indexes[i] = i; //先保存i的值\n      // 传入的时候必须强制转换为void* 类型，即无类型指针        \n      rc = pthread_create(&threads[i], NULL, \n                          PrintHello, (void *)&(indexes[i]));\n      if (rc){\n         cout << \"Error:无法创建线程,\" << rc << endl;\n         exit(-1);\n      }\n   }\n   pthread_exit(NULL);}\n```\n\n现在编译并执行程序，将产生下列结果：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o$ ./test.omain() : 创建线程, 0main() : 创建线程, 1main() : 创建线程, 2main() : 创建线程, 3main() : 创建线程, 4Hello Runoob! 线程 ID, 4Hello Runoob! 线程 ID, 3Hello Runoob! 线程 ID, 2Hello Runoob! 线程 ID, 1Hello Runoob! 线程 ID, 0\n```\n\n## 向线程传递参数\n\n这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：\n\n```cpp\n#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5struct thread_data{   int  thread_id;   char *message;};void *PrintHello(void *threadarg){   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout << \"Thread ID : \" << my_data->thread_id ;   cout << \" Message : \" << my_data->message << endl;   pthread_exit(NULL);}int main (){   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i < NUM_THREADS; i++ ){      cout <<\"main() : creating thread, \" << i << endl;      td[i].thread_id = i;      td[i].message = \"This is message\";      rc = pthread_create(&threads[i], NULL,                          PrintHello, (void *)&td[i]);      if (rc){         cout << \"Error:unable to create thread,\" << rc << endl;         exit(-1);      }   }   pthread_exit(NULL);}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o\n$ ./test.o\nmain() : 创建线程, 0main() : 创建线程, 1main() : 创建线程, 2main() : 创建线程, 3main() : 创建线程, 4Hello Runoob! 线程 ID, 4Hello Runoob! 线程 ID, 3Hello Runoob! 线程 ID, 2Hello Runoob! 线程 ID, 1Hello Runoob! 线程 ID, 0\n```\n\n## 连接和分离线程\n\n我们可以使用以下两个函数来连接或分离线程：\n\n```cpp\npthread_join (threadid, status) pthread_detach (threadid)\n```\n\npthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。\n\n这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。\n\n```cpp\n#include <iostream>#include <cstdlib>#include <pthread.h>#include <unistd.h>using namespace std;#define NUM_THREADS     5void *wait(void *t){\n   int i;\n   long tid;\n\n   tid = (long)t;\n\n   sleep(1);\n   cout << \"Sleeping in thread \" << endl;\n   cout << \"Thread with id : \" << tid << \"  ...exiting \" << endl;\n   pthread_exit(NULL);}int main (){\n   int rc;\n   int i;\n   pthread_t threads[NUM_THREADS];\n   pthread_attr_t attr;\n   void *status;\n\n   // 初始化并设置线程为可连接的（joinable）\n   pthread_attr_init(&attr);\n   pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n   for( i=0; i < NUM_THREADS; i++ ){\n      cout << \"main() : creating thread, \" << i << endl;\n      rc = pthread_create(&threads[i], NULL, wait, (void *)&i );\n      if (rc){\n         cout << \"Error:unable to create thread,\" << rc << endl;\n         exit(-1);\n      }\n   }\n\n   // 删除属性，并等待其他线程\n   pthread_attr_destroy(&attr);\n   for( i=0; i < NUM_THREADS; i++ ){\n      rc = pthread_join(threads[i], &status);\n      if (rc){\n         cout << \"Error:unable to join,\" << rc << endl;\n         exit(-1);\n      }\n      cout << \"Main: completed thread id :\" << i ;\n      cout << \"  exiting with status :\" << status << endl;\n   }\n\n   cout << \"Main: program exiting.\" << endl;\n   pthread_exit(NULL);}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nmain() : creating thread, 0main() : creating thread, 1main() : creating thread, 2main() : creating thread, 3main() : creating thread, 4Sleeping in thread \nThread with id : 4  ...exiting \nSleeping in thread \nThread with id : 3  ...exiting \nSleeping in thread \nThread with id : 2  ...exiting \nSleeping in thread \nThread with id : 1  ...exiting \nSleeping in thread \nThread with id : 0  ...exiting \nMain: completed thread id :0  exiting with status :0Main: completed thread id :1  exiting with status :0Main: completed thread id :2  exiting with status :0Main: completed thread id :3  exiting with status :0Main: completed thread id :4  exiting with status :0Main: program exiting.\n```\n\n# C++ Web 编程\n\n## 什么是 CGI？\n\n- 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。\n- CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：\n- 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。\n- 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。\n\n## Web 浏览\n\n为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。\n\n- 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。\n- Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。\n- Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。\n\n然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。\n\n公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。\n\n## CGI 架构图\n\n下图演示了 CGI 的架构：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif)\n\n## Web 服务器配置\n\n在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 **.cgi**。\n\n默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：\n\n```cpp\n<Directory \"/var/www/cgi-bin\">   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all</Directory> <Directory \"/var/www/cgi-bin\">Options All</Directory>\n```\n\n在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。\n\n## 第一个 CGI 程序\n\n请看下面的 C++ 程序：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n    \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>Hello World - 第一个 CGI 程序</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<h2>Hello World! 这是我的第一个 CGI 程序</h2>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 **chmod 755 cplusplus.cgi** UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：\n\n## Hello World! 这是我的第一个 CGI 程序\n\n上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 **Content-type:text/html\\r\\n\\r\\n**。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。\n\n## HTTP 头信息\n\n行 **Content-type:text/html\\r\\n\\r\\n** 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：\n\n```cpp\nHTTP 字段名称: 字段内容 例如Content-type: text/html\\r\\n\\r\\n\n```\n\n还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。\n\n| 头信息              | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| Content-type:       | MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。 |\n| Expires: Date       | 信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。 |\n| Location: URL       | 这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。 |\n| Last-modified: Date | 资源的最后修改日期。                                         |\n| Content-length: N   | 要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。 |\n| Set-Cookie: String  | 通过 *string* 设置 cookie。                                  |\n\n## CGI 环境变量\n\n所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。\n\n| 变量名          | 描述                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| CONTENT_TYPE    | 内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。 |\n| CONTENT_LENGTH  | 查询的信息长度。只对 POST 请求可用。                         |\n| HTTP_COOKIE     | 以键 & 值对的形式返回设置的 cookies。                        |\n| HTTP_USER_AGENT | 用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。 |\n| PATH_INFO       | CGI 脚本的路径。                                             |\n| QUERY_STRING    | 通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。 |\n| REMOTE_ADDR     | 发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。 |\n| REMOTE_HOST     | 发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。 |\n| REQUEST_METHOD  | 用于发出请求的方法。最常见的方法是 GET 和 POST。             |\n| SCRIPT_FILENAME | CGI 脚本的完整路径。                                         |\n| SCRIPT_NAME     | CGI 脚本的名称。                                             |\n| SERVER_NAME     | 服务器的主机名或 IP 地址。                                   |\n| SERVER_SOFTWARE | 服务器上运行的软件的名称和版本。                             |\n\n下面的 CGI 程序列出了所有的 CGI 变量。\n\n```cpp\n#include <iostream>#include <stdlib.h>using namespace std;const string ENV[ 24 ] = {                 \n        \"COMSPEC\", \"DOCUMENT_ROOT\", \"GATEWAY_INTERFACE\",   \n        \"HTTP_ACCEPT\", \"HTTP_ACCEPT_ENCODING\",    &nbsnbsp;        \n        \"HTTP_ACCEPT_LANGUAGE\", \"HTTP_CONNECTION\",         \n        \"HTTP_HOST\", \"HTTP_USER_AGENT\", \"PATH\",            \n        \"QUERY_STRING\", \"REMOTE_ADDR\", \"REMOTE_PORT\",      \n        \"REQUEST_METHOD\", \"REQUEST_URI\", \"SCRIPT_FILENAME\",\n        \"SCRIPT_NAME\", \"SERVER_ADDR\", \"SERVER_ADMIN\",      \n        \"SERVER_NAME\",\"SERVER_PORT\",\"SERVER_PROTOCOL\",     \n        \"SERVER_SIGNATURE\",\"SERVER_SOFTWARE\" };   int main (){\n    \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 环境变量</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<table border = \\\"0\\\" cellspacing = \\\"2\\\">\";\n\n   for ( int i = 0; i < 24; i++ )\n   {\n       cout << \"<tr><td>\" << ENV[ i ] << \"</td><td>\";\n       // 尝试检索环境变量的值\n       char *value = getenv( ENV[ i ].c_str() );  \n       if ( value != 0 ){\n         cout << value;                                 \n       }else{\n         cout << \"环境变量不存在。\";\n       }\n       cout << \"</td></tr>\\n\";\n   }\n   cout << \"</table><\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## C++ CGI 库\n\n在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 [ftp://ftp.gnu.org/gnu/cgicc/](ftp://ftp.gnu.org/gnu/cgicc/) 上下载这个 CGI 库，并按照下面的步骤安装库：\n\n```cpp\n$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install\n```\n\n您可以点击 C++ CGI Lib Documentation，查看相关的库文档。\n\n## GET 和 POST 方法\n\n您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。\n\n## 使用 GET 方法传递信息\n\nGET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：\n\n```cpp\nhttp://www.test.com/cgi-bin/cpp.cgi?key1=value1&key2=value2\n```\n\nGET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。\n\n当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。\n\n您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML <FORM> 标签的 GET 方法来传信息。\n\n## 简单的 URL 实例：Get 方法\n\n下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。\n\n/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI\n\n下面的实例生成 **cpp_get.cgi** CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>  using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n   \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>使用 GET 和 POST 方法</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"first_name\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"名：\" << **fi << endl;  \n   }else{\n      cout << \"No text entered for first name\" << endl;  \n   }\n   cout << \"<br/>\\n\";\n   fi = formData.getElement(\"last_name\");  \n   if( !fi->isEmpty() &&fi != (*formData).end()) {  \n      cout << \"姓：\" << **fi << endl;  \n   }else{\n      cout << \"No text entered for last name\" << endl;  \n   }\n   cout << \"<br/>\\n\";\n\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n现在，编译上面的程序，如下所示：\n\n```cpp\n$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc\n```\n\n生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：\n\n/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI\n\n这会产生以下结果：\n\n```cpp\n名：ZARA 姓：ALI\n```\n\n## 简单的表单实例：GET 方法\n\n下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。\n\n```cpp\n<form action=\"/cgi-bin/cpp_get.cgi\" method=\"get\">名：<input type=\"text\" name=\"first_name\">  <br /> 姓：<input type=\"text\" name=\"last_name\" /><input type=\"submit\" value=\"提交\" /></form>\n```\n\n下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。\n\n## 使用 POST 方法传递信息\n\n一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。\n\n我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：\n\n```cpp\n<form action=\"/cgi-bin/cpp_get.cgi\" method=\"post\">名：<input type=\"text\" name=\"first_name\"><br />姓：<input type=\"text\" name=\"last_name\" /> <input type=\"submit\" value=\"提交\" /></form>\n```\n\n## 向 CGI 程序传递复选框数据\n\n当需要选择多个选项时，我们使用复选框。\n\n下面的 HTML 代码实例是一个带有两个复选框的表单：\n\n```html\n<form action=\"/cgi-bin/cpp_checkbox.cgi\" \n         method=\"POST\" \n         target=\"_blank\"><input type=\"checkbox\" name=\"maths\" value=\"on\" /> 数学<input type=\"checkbox\" name=\"physics\" value=\"on\" /> 物理<input type=\"submit\" value=\"选择学科\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n   bool maths_flag, physics_flag;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递复选框数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   maths_flag = formData.queryCheckbox(\"maths\");\n   if( maths_flag ) {  \n      cout << \"Maths Flag: ON \" << endl;  \n   }else{\n      cout << \"Maths Flag: OFF \" << endl;  \n   }\n   cout << \"<br/>\\n\";\n\n   physics_flag = formData.queryCheckbox(\"physics\");\n   if( physics_flag ) {  \n      cout << \"Physics Flag: ON \" << endl;  \n   }else{\n      cout << \"Physics Flag: OFF \" << endl;  \n   }\n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递单选按钮数据\n\n当只需要选择一个选项时，我们使用单选按钮。\n\n下面的 HTML 代码实例是一个带有两个单选按钮的表单：\n\n```cpp\n<form action=\"/cgi-bin/cpp_radiobutton.cgi\" \n         method=\"post\" \n         target=\"_blank\"><input type=\"radio\" name=\"subject\" value=\"maths\" \n                                    checked=\"checked\"/> 数学 \n<input type=\"radio\" name=\"subject\" value=\"physics\" /> 物理<input type=\"submit\" value=\"选择学科\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递单选按钮数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"subject\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Radio box selected: \" << **fi << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递文本区域数据\n\n当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。\n\n下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：\n\n```\n<form action=\"/cgi-bin/cpp_textarea.cgi\" \n         method=\"post\" \n         target=\"_blank\"><textarea name=\"textcontent\" cols=\"40\" rows=\"4\">请在这里输入文本...</textarea><input type=\"submit\" value=\"提交\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递文本区域数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"textcontent\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Text Content: \" << **fi << endl;  \n   }else{\n      cout << \"No text entered\" << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递下拉框数据\n\n当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。\n\n下面的 HTML 代码实例是一个带有下拉框的表单：\n\n```cpp\n<form action=\"/cgi-bin/cpp_dropdown.cgi\" \n                       method=\"post\" target=\"_blank\"><select name=\"dropdown\"><option value=\"Maths\" selected>数学</option><option value=\"Physics\">物理</option></select><input type=\"submit\" value=\"提交\"/></form>\n```\n\n下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递下拉框数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"dropdown\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Value Selected: \" << **fi << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 在 CGI 中使用 Cookies\n\nHTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。\n\n在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。\n\n### 它是如何工作的\n\n服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。\n\ncookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：\n\n- **Expires :** cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。\n- **Domain :** 网站的域名。\n- **Path :** 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。\n- **Secure :** 如果此字段包含单词 \"secure\"，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。\n- **Name=Value :** cookie 以键值对的形式被设置和获取。\n\n### 设置 Cookies\n\n向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n \n   cout << \"Set-Cookie:UserID=XYZ;\\r\\n\";\n   cout << \"Set-Cookie:Password=XYZ123;\\r\\n\";\n   cout << \"Set-Cookie:Domain=www.w3cschool.cc;\\r\\n\";\n   cout << \"Set-Cookie:Path=/perl;\\n\";\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的 Cookies</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   cout << \"设置 cookies\" << endl;  \n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n从这个实例中，我们了解了如何设置 cookies。我们使用 **Set-Cookie** HTTP 头来设置 cookies。\n\n在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 **\"Content-type:text/html\\r\\n\\r\\n** 之前被设置的。\n\n编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：\n\n/cgi-bin/setcookies.cgi\n\n### 获取 Cookies\n\n检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：\n\n```cpp\nkey1=value1;key2=value2;key3=value3....\n```\n\n下面的实例演示了如何获取 cookies。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){\n   Cgicc cgi;\n   const_cookie_iterator cci;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的 Cookies</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<table border = \\\"0\\\" cellspacing = \\\"2\\\">\";\n   \n   // 获取环境变量\n   const CgiEnvironment& env = cgi.getEnvironment();\n\n   for( cci = env.getCookieList().begin();\n        cci != env.getCookieList().end(); \n        ++cci )\n   {\n      cout << \"<tr><td>\" << cci->getName() << \"</td><td>\";\n      cout << cci->getValue();                                 \n      cout << \"</td></tr>\\n\";\n   }\n   cout << \"</table><\\n\";\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：\n\n/cgi-bin/getcookies.cgi\n\n这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：\n\n```cpp\nUserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl\n```\n\n## 文件上传实例\n\n为了上传一个文件，HTML 表单必须把 enctype 属性设置为 **multipart/form-data**。带有文件类型的 input 标签会创建一个 \"Browse\" 按钮。\n\n```cpp\n<html><body>\n   <form enctype=\"multipart/form-data\" \n            action=\"/cgi-bin/cpp_uploadfile.cgi\" \n            method=\"post\">\n   <p>文件：<input type=\"file\" name=\"userfile\" /></p>\n   <p><input type=\"submit\" value=\"上传\" /></p>\n   </form></body></html>\n```\n\n这段代码的结果是下面的表单：\n\n文件：\n\n \n\n**注意：**上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。\n\n下面是用于处理文件上传的脚本 **cpp_uploadfile.cpp**：\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){\n   Cgicc cgi;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的文件上传</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   // 获取要被上传的文件列表\n   const_file_iterator file = cgi.getFile(\"userfile\");\n   if(file != cgi.getFiles().end()) {\n      // 在 cout 中发送数据类型\n      cout << HTTPContentHeader(file->getDataType());\n      // 在 cout 中写入内容\n      file->writeToStream(cout);\n   }\n   cout << \"<文件上传成功>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n上面的实例是在 **cout** 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。\n\n# C++ STL 教程\n\n在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。\n\nC++ 标准模板库的核心包括以下三个组件：\n\n| 组件                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |\n| 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |\n| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |\n\n这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。\n\n下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：\n\n```cpp\n#include <iostream>#include <vector>using namespace std;\n int main(){\n   // 创建一个向量存储 int\n   vector<int> vec; \n   int i;\n\n   // 显示 vec 的原始大小\n   cout << \"vector size = \" << vec.size() << endl;\n\n   // 推入 5 个值到向量中\n   for(i = 0; i < 5; i++){\n      vec.push_back(i);\n   }\n\n   // 显示 vec 扩展后的大小\n   cout << \"extended vector size = \" << vec.size() << endl;\n\n   // 访问向量中的 5 个值\n   for(i = 0; i < 5; i++){\n      cout << \"value of vec [\" << i << \"] = \" << vec[i] << endl;\n   }\n\n   // 使用迭代器 iterator 访问值\n   vector<int>::iterator v = vec.begin();\n   while( v != vec.end()) {\n      cout << \"value of v = \" << *v << endl;\n      v++;\n   }\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nvector size = 0extended vector size = 5value of vec [0] = 0value of vec [1] = 1value of vec [2] = 2value of vec [3] = 3value of vec [4] = 4value of v = 0value of v = 1value of v = 2value of v = 3value of v = 4\n```\n\n关于上面实例中所使用的各种函数，有几点要注意：\n\n- push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。\n- size( ) 函数显示向量的大小。\n- begin( ) 函数返回一个指向向量开头的迭代器。\n- end( ) 函数返回一个指向向量末尾的迭代器。\n\n# C++ 标准库\n\nC++ 标准库可以分为两部分：\n\n- **标准函数库：** 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。\n- **面向对象类库：** 这个库是类及其相关函数的集合。\n\nC++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。\n\n## 标准函数库\n\n标准函数库分为以下几类：\n\n- 输入/输出 I/O\n- 字符串和字符处理\n- 数学\n- 时间、日期和本地化\n- 动态分配\n- 其他\n- 宽字符函数\n\n## 面向对象类库\n\n标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：\n\n- 标准的 C++ I/O 类\n- String 类\n- 数值类\n- STL 容器类\n- STL 算法\n- STL 函数对象\n- STL 迭代器\n- STL 分配器\n- 本地化库\n- 异常处理类\n- 杂项支持库\n\n"
        },
        {
          "name": "C++11常用新特性（一）.md",
          "type": "blob",
          "size": 15.2080078125,
          "content": "# C++11常用新特性（一）\n\n最近工作中，遇到一些问题，使用C11实现起来会更加方便，而线上的生产环境还不支持C11，于是决定新年开工后，在组内把C++11推广开来，整理以下文档，方便自己查阅，也方便同事快速上手。（对于异步编程十分实用的Future/Promise以及智能指针等，将不做整理介绍，组内使用的框架已经支持并广泛使用了，用的是自己公司参考boost实现的版本）\n\n\n\n# nullptr\n\nnullptr 出现的目的是为了替代 NULL。\n\n在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。\n\nC++ 不允许直接将 void  *隐式转换到其他类型，但如果 NULL 被定义为 ((void*)0)，那么当编译char *ch = NULL;时，NULL 只好被定义为 0。\n\n而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：\n\n```c\nvoid foo(char *);\nvoid foo(int);\n```\n\n对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。\n\n为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。\n\nnullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。\n\n当需要使用 NULL 时候，养成直接使用 nullptr的习惯。\n\n# 类型推导\n\nC++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。\n\n## auto\n\nauto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。而随着 register 被弃用，对 auto 的语义变更也就非常自然了。\n\n使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。在以前我们需要这样来书写一个迭代器：\n\n```c\nfor(vector<int>::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr)\n```\n\n而有了 auto 之后可以：\n\n```c\n// 由于 cbegin() 将返回 vector<int>::const_iterator \n// 所以 itr 也应该是 vector<int>::const_iterator 类型\nfor(auto itr = vec.cbegin(); itr != vec.cend(); ++itr);\n```\n\n一些其他的常见用法：\n\n```c\nauto i = 5;             // i 被推导为 int\nauto arr = new auto(10) // arr 被推导为 int *\n```\n\n注意：auto 不能用于函数传参，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）：\n\n```c\nint add(auto x, auto y);\n```\n\n此外，auto 还不能用于推导数组类型：\n\n```c\n#include <iostream>\n\nint main() {\n auto i = 5;\n\n int arr[10] = {0};\n auto auto_arr = arr;\n auto auto_arr2[10] = arr;\n\n return 0;\n}\n```\n\n## decltype\n\ndecltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：\n\n```c\ndecltype(表达式)\n```\n\n在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。\n\n有时候，我们可能需要计算某个表达式的类型，例如：\n\n```c\nauto x = 1;\nauto y = 2;\ndecltype(x+y) z;\n```\n\n## 拖尾返回类型、auto 与 decltype 配合\n\n你可能会思考，auto 能不能用于推导函数的返回类型。考虑这样一个例子加法函数的例子，在传统 C++ 中我们必须这么写：\n\n```c\ntemplate<typename R, typename T, typename U>\nR add(T x, U y) {\n    return x+y\n}\n```\n\n这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。\n\n在 C++11 中这个问题得到解决。虽然你可能马上回反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：\n\n```c\ndecltype(x+y) add(T x, U y);\n```\n\n但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：\n\n\n\n```c\ntemplate<typename T, typename U>\nauto add(T x, U y) -> decltype(x+y) {\n    return x+y;\n}\n```\n\n\n\n从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：\n\n\n\n```c\ntemplate<typename T, typename U>\nauto add(T x, U y) {\n    return x+y;\n}\n```\n\n\n\n# 区间迭代\n\n\n\n## 基于范围的 for 循环\n\n\n\nC++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句。\n最常用的 std::vector 遍历将从原来的样子：\n\n\n\n```c\nstd::vector<int> arr(5, 100);\nfor(std::vector<int>::iterator i = arr.begin(); i != arr.end(); ++i) {\n    std::cout << *i << std::endl;\n}\n```\n\n\n\n变得非常的简单：\n\n\n\n```c\n// & 启用了引用\nfor(auto &i : arr) {    \n    std::cout << i << std::endl;\n}\n```\n\n\n\n# 初始化列表\n\n\n\nC++11 提供了统一的语法来初始化任意的对象，例如：\n\n\n\n```c\nstruct A {\n    int a;\n    float b;\n};\nstruct B {\n  B(int _a, float _b): a(_a), b(_b) {}\n  private:\n    int a;\n    float b;\n};\n\nA a {1, 1.1};    // 统一的初始化语法\nB b {2, 2.2};\n```\n\n\n\nC++11 还把初始化列表的概念绑定到了类型上，并将其称之为`std::initializer_list`，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：\n\n\n\n```c\n#include <initializer_list>\n\nclass Magic {\npublic:\n    Magic(std::initializer_list<int> list) {}\n};\n\nMagic magic = {1,2,3,4,5};\nstd::vector<int> v = {1, 2, 3, 4};\n```\n\n\n\n# 模板增强\n\n\n\n## 外部模板\n\n\n\n传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。\n\n\n\nC++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：\n\n\n\n```c\ntemplate class std::vector<bool>;            // 强行实例化\nextern template class std::vector<double>;  // 不在该编译文件中实例化模板\n```\n\n\n\n## 尖括号 “>”\n\n\n\n在传统 C++ 的编译器中，`>>`一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：\n\n\n\n```c\nstd::vector<std::vector<int>> wow;\n```\n\n\n\n这在传统C编译器下是不能够被编译的，而 C11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。\n\n\n\n## 类型别名模板\n\n\n\n在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：\n\n\n\n```c\ntemplate< typename T, typename U, int value>\nclass SuckType {\npublic:\n    T a;\n    U b;\n    SuckType():a(value),b(value){}\n};\ntemplate< typename U>\ntypedef SuckType<std::vector<int>, U, 1> NewType; // 不合法\n```\n\n\n\nC++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：\n\n\n\n```c\ntemplate <typename T>\nusing NewType = SuckType<int, T, 1>;    // 合法\n```\n\n\n\n## 默认模板参数\n\n\n\n我们可能定义了一个加法函数：\n\n\n\n```c\ntemplate<typename T, typename U>\nauto add(T x, U y) -> decltype(x+y) {\n    return x+y\n}\n```\n\n\n\n但在使用时发现，要使用 add，就必须每次都指定其模板参数的类型。\n\n\n\n在 C++11 中提供了一种便利，可以指定模板的默认参数：\n\n\n\n```c\ntemplate<typename T = int, typename U = int>\nauto add(T x, U y) -> decltype(x+y) {\n    return x+y;\n}\n```\n\n\n\n# 构造函数\n\n\n\n## 委托构造\n\n\n\nC++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：\n\n\n\n```c\nclass Base {\npublic:\n    int value1;\n    int value2;\n    Base() {\n        value1 = 1;\n    }\n    Base(int value) : Base() {  // 委托 Base() 构造函数\n        value2 = 2;\n    }\n};\n```\n\n\n\n## 继承构造\n\n\n\n在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。\n\n\n\n假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：\n\n\n\n```c\nstruct A\n{\n  A(int i) {}\n  A(double d,int i){}\n  A(float f,int i,const char* c){}\n  //...等等系列的构造函数版本\n}；\nstruct B:A\n{\n  B(int i):A(i){}\n  B(double d,int i):A(d,i){}\n  B(folat f,int i,const char* c):A(f,i,e){}\n  //......等等好多个和基类构造函数对应的构造函数\n}；\n```\n\n\n\nC++11的继承构造：\n\n\n\n```c\nstruct A\n{\n  A(int i) {}\n  A(double d,int i){}\n  A(float f,int i,const char* c){}\n  //...等等系列的构造函数版本\n}；\nstruct B:A\n{\n  using A::A;\n  //关于基类各构造函数的继承一句话搞定\n  //......\n}；\n```\n\n\n\n如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。\n\n\n\n# \n\n# 新增容器\n\n\n\n## std::array\n\n\n\nstd::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。\n\n\n\nstd::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：\n\n\n\n```c\nstd::array<int, 4> arr= {1,2,3,4};\n\nint len = 4;\nstd::array<int, len> arr = {1,2,3,4}; // 非法, 数组大小参数必须是常量表达式\n```\n\n\n\n当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：\n\n\n\n```c\nvoid foo(int *p, int len) {\n    return;\n}\n\nstd::array<int 4> arr = {1,2,3,4};\n\n// C 风格接口传参\n// foo(arr, arr.size());           // 非法, 无法隐式转换\nfoo(&arr[0], arr.size());\nfoo(arr.data(), arr.size());\n\n// 使用 `std::sort`\nstd::sort(arr.begin(), arr.end());\n```\n\n\n\n## std::forward_list\n\n\n\nstd::forward_list 是一个列表容器，使用方法和 std::list 基本类似。\n\n\n\n和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。\n\n\n\n## 无序容器\n\n\n\nC++11 引入了两组无序容器：\n`std::unordered_map/std::unordered_multimap`和 `std::unordered_set/std::unordered_multiset`。\n\n\n\n无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。\n\n\n\n## 元组 std::tuple\n\n\n\n元组的使用有三个核心的函数：\n\n\n\n`std::make_tuple`: 构造元组\n`std::get`: 获得元组某个位置的值\n`std::tie`: 元组拆包\n\n\n\n```c\n#include <tuple>\n#include <iostream>\n\nauto get_student(int id)\n{\n    // 返回类型被推断为 std::tuple<double, char, std::string>\n    if (id == 0)\n        return std::make_tuple(3.8, 'A', \"张三\");\n    if (id == 1)\n        return std::make_tuple(2.9, 'C', \"李四\");\n    if (id == 2)\n        return std::make_tuple(1.7, 'D', \"王五\");\n    return std::make_tuple(0.0, 'D', \"null\");   \n    // 如果只写 0 会出现推断错误, 编译失败\n}\n\nint main()\n{\n    auto student = get_student(0);\n    std::cout << \"ID: 0, \"\n    << \"GPA: \" << std::get<0>(student) << \", \"\n    << \"成绩: \" << std::get<1>(student) << \", \"\n    << \"姓名: \" << std::get<2>(student) << '\\n';\n\n    double gpa;\n    char grade;\n    std::string name;\n    \n    // 元组进行拆包\n    std::tie(gpa, grade, name) = get_student(1);\n    std::cout << \"ID: 1, \"\n    << \"GPA: \" << gpa << \", \"\n    << \"成绩: \" << grade << \", \"\n    << \"姓名: \" << name << '\\n';\n\n}\n```\n\n\n\n合并两个元组，可以通过 std::tuple_cat 来实现。\n\n\n\n```c\nauto new_tuple = std::tuple_cat(get_student(1), std::move(t));\n```\n\n\n\n# 正则表达式\n\n\n\n正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：\n\n\n\n1. 检查一个串是否包含某种形式的子串；\n2. 将匹配的子串替换；\n\n1. 从某个串中取出符合条件的子串。\n\n\n\nC++11 提供的正则表达式库操作 std::string 对象，对模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。\n\n\n\n我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式：\n\n\n\n[a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个及以上小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 . 转义后则表示匹配字符 . ，最后的 txt 表示严格匹配 txt 这三个字母。因此这个正则表达式的所要匹配的内容就是文件名为纯小写字母的文本文件。\nstd::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如：\n\n\n\n```c\n#include <iostream>\n#include <string>\n#include <regex>\n\nint main() {\n    std::string fnames[] = {\"foo.txt\", \"bar.txt\", \"test\", \"a0.txt\", \"AAA.txt\"};\n    // 在 C++ 中 `\\` 会被作为字符串内的转义符，为使 `\\.` 作为正则表达式传递进去生效，需要对 `\\` 进行二次转义，从而有 `\\\\.`\n    std::regex txt_regex(\"[a-z]+\\\\.txt\");\n    for (const auto &fname: fnames)\n        std::cout << fname << \": \" << std::regex_match(fname, txt_regex) << std::endl;\n}\n```\n\n\n\n另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results，在标准库中， std::smatch 被定义为了 std::match_results，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如：\n\n\n\n```c\nstd::regex base_regex(\"([a-z]+)\\\\.txt\");\nstd::smatch base_match;\nfor(const auto &fname: fnames) {\n    if (std::regex_match(fname, base_match, base_regex)) {\n        // sub_match 的第一个元素匹配整个字符串\n        // sub_match 的第二个元素匹配了第一个括号表达式\n        if (base_match.size() == 2) {\n            std::string base = base_match[1].str();\n            std::cout << \"sub-match[0]: \" << base_match[0].str() << std::endl;\n            std::cout << fname << \" sub-match[1]: \" << base << std::endl;\n        }\n    }\n}\n```\n\n\n\n以上两个代码段的输出结果为：\n\n\n\n```bash\nfoo.txt: 1\nbar.txt: 1\ntest: 0\na0.txt: 0\nAAA.txt: 0\nsub-match[0]: foo.txt\nfoo.txt sub-match[1]: foo\nsub-match[0]: bar.txt\nbar.txt sub-match[1]: bar\n```\n\n\n\n# 语言级线程支持\n\n\n\nstd::thread<br>\nstd::mutex/std::unique_lock<br>\nstd::future/std::packaged_task<br>\nstd::condition_variable<br>\n"
        },
        {
          "name": "C++11常用新特性（二）.md",
          "type": "blob",
          "size": 22.6513671875,
          "content": "# C++11常用新特性(二）\n\n# Lambda 表达式\n\n\n\nLambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。\n\n\n\n## Lambda 表达式的基本语法如下：\n\n\n\n```c\n[ caputrue ] ( params ) opt -> ret { body; };\n```\n\n\n\n1. capture是捕获列表；\n2. params是参数表；(选填)\n\n1. opt是函数选项；可以填`mutable`,`exception`,`attribute`（选填）\n\n\n\n- mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。\n- exception说明lambda表达式是否抛出异常以及何种异常。\n\n- attribute用来声明属性。\n\n\n\n1. ret是返回值类型（拖尾返回类型）。(选填)\n2. body是函数体。\n\n\n\n捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。\n\n\n\n1.  []不捕获任何变量。 \n2.  [&]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。 \n\n1.  [=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，**且被捕获的量在 lambda 表达式被创建时拷贝，而非调用时才拷贝**。如果希望lambda表达式在调用时能即时访问外部变量，我们应当用引用方式捕获。  \n\n```c\nint a = 0;\nauto f = [=] { return a; };\n\na+=1;\n\ncout << f() << endl;       //输出0\n\nint a = 0;\nauto f = [&a] { return a; };\n\na+=1;\n\ncout << f() <<endl;       //输出1\n```\n\n1.  [=,&foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。 \n2.  [bar]按值捕获bar变量，同时不捕获其他变量。 \n\n1.  [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。**如果已经使用了&或者=，就默认添加此选项**。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。 \n\n\n\n```c\nclass A\n{\n public:\n     int i_ = 0;\n\n     void func(int x,int y){\n         auto x1 = [] { return i_; };                   //error,没有捕获外部变量\n         auto x2 = [=] { return i_ + x + y; };          //OK\n         auto x3 = [&] { return i_ + x + y; };        //OK\n         auto x4 = [this] { return i_; };               //OK\n         auto x5 = [this] { return i_ + x + y; };       //error,没有捕获x,y\n         auto x6 = [this, x, y] { return i_ + x + y; };     //OK\n         auto x7 = [this] { return i_++; };             //OK\n\n};\n\nint a=0 , b=1;\nauto f1 = [] { return a; };                         //error,没有捕获外部变量    \nauto f2 = [&] { return a++ };                      //OK\nauto f3 = [=] { return a; };                        //OK\nauto f4 = [=] {return a++; };                       //error,a是以复制方式捕获的，无法修改\nauto f5 = [a] { return a+b; };                      //error,没有捕获变量b\nauto f6 = [a, &b] { return a + (b++); };                //OK\nauto f7 = [=, &b] { return a + (b++); };                //OK\n```\n\n\n\n\n\n注意f4，虽然**按值捕获的变量**值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但**我们却仍然无法修改它们**。如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。**被mutable修饰的lambda表达式就算没有参数也要写明参数列表。**\n\n\n\n```cpp\nint a = 0;\nauto f1 = [=] { return a++; };                //error\nauto f2 = [=] () mutable { return a++; };       //OK\n```\n\n\n\n原因：**lambda表达式可以说是就地定义仿函数闭包的“语法糖”**。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，**lambda表达式的operator()默认是const的**，一个const成员函数是无法修改成员变量的值的。**而mutable的作用，就在于取消operator()的const。**  \n\n\n\n## lambda表达式的大致原理：\n\n\n\n每当你定义一个lambda表达式后，**编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）**。那么在运行时，**这个lambda表达式就会返回一个匿名的闭包实例**，是一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。**对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员**。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。\n\n\n\n## lambda表达式是不能被赋值的：\n\n\n\n```c\nauto a = [] { cout << \"A\" << endl; };\nauto b = [] { cout << \"B\" << endl; };\n\na = b;   // 非法，lambda无法赋值\nauto c = a;   // 合法，生成一个副本\n```\n\n\n\n闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以用一个lambda表达式去初始化另外一个lambda表达式而产生副本。\n\n\n\n在多种捕获方式中，**最好不要使用[=]和[&]默认捕获所有变量**。\n\n\n\n默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的生命周期：\n\n\n\n```c\nstd::function<int(int)> add_x(int x)\n{\n    return [&](int a) { return x + a; };\n}\n```\n\n\n\n上面函数返回了一个lambda表达式，参数x仅是一个临时变量，函数add_x调用后就被销毁了，但是返回的lambda表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。\n\n\n\n但是采用默认值捕获所有变量仍然有风险，看下面的例子：\n\n\n\n```c\nclass Filter\n{\npublic:\n    Filter(int divisorVal):\n        divisor{divisorVal}\n    {}\n\n    std::function<bool(int)> getFilter() \n    {\n        return [=](int value) {return value % divisor == 0; };\n    }\n\nprivate:\n    int divisor;\n};\n```\n\n\n\n这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上并没有。因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：\n\n\n\n```c\n// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围\nstd::function<bool(int)> getFilter() \n{\n    return [divisor](int value) {return value % divisor == 0; };\n}\n```\n\n\n\n原代码中，lambda表达式实际上捕捉的是this指针的副本，所以原来的代码等价于：\n\n\n\n```c\nstd::function<bool(int)> getFilter() {    return [this](int value) {return value % this->divisor == 0; };}\n```\n\n\n\n尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，**所以lambda表达式的闭包与一个类对象绑定在一起了，这很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式**，那么类似“悬挂引用”的问题也会产生。所以，**采用默认值捕捉所有变量仍然是不安全的**，主要是由于指针变量的复制，实际上还是按引用传值。\n\n\n\nlambda表达式可以赋值给对应类型的函数指针。但是使用函数指针并不是那么方便。所以STL定义在< functional >头文件提供了一个多态的函数对象封装std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：\n\n\n\n```c\nstd::function<bool(int, int)> wrapper = [](int x, int y) { return x < y; };\n```\n\n\n\nlambda表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。\n\n\n\n最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量，通过lambda表达式给出条件，传递给count_if函数：\n\n\n\n```c\nint value = 3;\nvector<int> v {1, 3, 5, 2, 6, 10};\nint count = std::count_if(v.beigin(), v.end(), [value](int x) { return x > value; });\n```\n\n\n\n再比如你想生成斐波那契数列，然后保存在数组中，此时你可以使用generate函数，并辅助lambda表达式：\n\n\n\n```cpp\nvector<int> v(10);\nint a = 0;\nint b = 1;\nstd::generate(v.begin(), v.end(), \n              [&a, &b] { int value = b; b = b + a; a = value; return value; });\n// 此时v {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}\n```\n\n\n\n当需要遍历容器并对每个元素进行操作时：\n\n\n\n```c\nstd::vector<int> v = { 1, 2, 3, 4, 5, 6 };\nint even_count = 0;\nfor_each(v.begin(), v.end(), [&even_count](int val){\n    if(!(val & 1)){\n        ++ even_count;\n    }\n});\nstd::cout << \"The number of even is \" << even_count << std::endl;\n```\n\n\n\n大部分STL算法，可以非常灵活地搭配lambda表达式来实现想要的效果。\n\n\n\n# C++ std::function\n\n\n\nstd::function是一个函数对象的包装器，std::function的实例可以存储，复制和调用任何可调用的目标，包括：\n\n\n\n1.  函数。 \n2.  lamada表达式。 \n\n1.  绑定表达式或其他函数对象。 \n2.  指向成员函数和指向数据成员的指针。 \n\n\n\n当`std::function`对象没有初始化任何实际的可调用元素，调用`std::function`对象将抛出`std::bad_function_call`异常。\n\n\n\n## std::function简介\n\n\n\n类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。\n\n\n\n**通常std::function是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为T1, …,TN的N个参数，并且返回一个可转换到R类型的值**。std::function使用 模板转换构造函数接收被包装的函数对象；特别是，闭包类型可以隐式地转换为std::function。\n\n\n\nC++标准库详细说明了这个的基本使用http://www.cplusplus.com/reference/functional/function/.\n\n\n\n这里我们大概总结一下。\n\n\n\n### Member types\n\n| 成员类型             | 说明                                                   |\n| -------------------- | ------------------------------------------------------ |\n| result_type          | 返回类型                                               |\n| argument_type        | 如果函数对象只有一个参数，那么这个代表参数类型。       |\n| first_argument_type  | 如果函数对象有两个个参数，那么这个代表第一个参数类型。 |\n| second_argument_type | 如果函数对象有两个个参数，那么这个代表第二个参数类型。 |\n\n\n\n### Member functions\n\n| 成员函数声明  | 说明                                              |\n| ------------- | ------------------------------------------------- |\n| constructor   | 构造函数：constructs a new std::function instance |\n| destructor    | 析构函数： destroys a std::function instance      |\n| operator=     | 给定义的function对象赋值                          |\n| operator bool | 检查定义的function对象是否包含一个有效的对象      |\n| operator()    | 调用一个对象                                      |\n\n\n\n## std::function使用\n\n\n\n封装普通函数例子：\n\n\n\n```c\n#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;int TestFunc(int a)  {      return a;  }int main(){    Functional obj = TestFunc;        int res = obj(1);    std::cout << res << std::endl;    while(1);    return 0;}\n```\n\n\n\n封装lambda表达式 ：\n\n\n\n```c\n#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;auto lambda = [](int a)->int{return a;};int main(){    Functional obj = lambda;        res = obj(2);    std::cout << res << std::endl;    while(1);    return 0;}\n```\n\n\n\n封装仿函数：\n\n\n\n```c\n#include <iostream>#include <vector>#include <list>#include <map>#include <set>#include <string>#include <algorithm>#include <functional>#include <memory>using namespace std;typedef std::function<int(int)> Functional;class Functor{public:    int operator()(int a)    {        return a;    }};int main(){    Functor func;    Functional obj = func;    res = obj(3);    std::cout << res << std::endl;    while(1);    return 0;}\n```\n\n\n\n封装类的成员函数和static成员函数 ：\n\n\n\n```c\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <memory>\n\nusing namespace std;\n\ntypedef std::function<int(int)> Functional;\n\nclass CTest\n{\npublic:\n    int Func(int a)\n    {\n        return a;\n    }\n    static int SFunc(int a)\n    {\n        return a;\n    }\n};\n\nint main()\n{\n    CTest t;  \n    obj = std::bind(&CTest::Func, &t, std::placeholders::_1);  \n    res = obj(3);  \n    cout << \"member function : \" << res << endl;  \n  \n    obj = CTest::SFunc;  \n    res = obj(4);  \n    cout << \"static member function : \" << res << endl;  \n\n    while(1);\n    return 0;\n}\n```\n\n\n\n关于可调用实体转换为std::function对象需要遵守以下两条原则：\n\n\n\n1. 转换后的std::function对象的参数能转换为可调用实体的参数；\n2. 可调用实体的返回值能转换为std::function对象的返回值。\n\n\n\n**std::function对象最大的用处就是在实现函数回调**，使用者需要注意，**它不能被用来检查相等或者不相等，但是可以与NULL或者nullptr进行比较。**\n\n\n\n**为什么要用std::function？**\n\n\n\n好用并实用的东西才会加入标准的。因为好用，实用，我们才在项目中使用它。std::function实现了一套类型消除机制，可以统一处理不同的函数对象类型。以前我们使用函数指针来完成这些；现在我们可以使用更安全的std::function来完成这些任务。\n\n\n\n参考文档：\n\n \n\n[C++ std::function技术浅谈](https://blog.csdn.net/xiangbaohui/article/details/106741654)\n\n# \n\n# 右值引用和move语义\n\n\n\n先看一个简单的例子直观感受下：\n\n\n\n```c\nstring a(x);                                    // line 1\nstring b(x + y);                                    // line 2\nstring c(some_function_returning_a_string());       // line 3\n```\n\n\n\n如果使用以下拷贝构造函数：\n\n\n\n```c\nstring(const string& that)\n{\n    size_t size = strlen(that.data) + 1;\n    data = new char[size];\n    memcpy(data, that.data, size);\n}\n```\n\n\n\n以上3行中，只有第一行(line 1)的x深度拷贝是有必要的，因为我们可能会在后边用到x，x是一个左值(lvalues)。\n\n\n\n第二行和第三行的参数则是右值，因为表达式产生的string对象是匿名对象，之后没有办法再使用了。\n\n\n\nC++ 11引入了一种新的机制叫做“右值引用”，以便我们通过重载直接使用右值参数。我们所要做的就是写一个以右值引用为参数的构造函数：\n\n\n\n```c\nstring(string&& that)   // string&& is an rvalue reference to a string\n{\ndata = that.data;\nthat.data = 0;\n}\n```\n\n\n\n我们没有深度拷贝堆内存中的数据，而是仅仅复制了指针，并把源对象的指针置空。事实上，我们“偷取”了属于源对象的内存数据。由于源对象是一个右值，不会再被使用，因此客户并不会觉察到源对象被改变了。在这里，我们并没有真正的复制，所以我们把这个构造函数叫做“转移构造函数”（move constructor），他的工作就是把资源从一个对象转移到另一个对象，而不是复制他们。\n\n\n\n有了右值引用，再来看看赋值操作符：\n\n\n\n```c\nstring& operator=(string that)\n{\nstd::swap(data, that.data);\nreturn *this;\n}\n```\n\n\n\n注意到我们是直接对参数that传值，所以that会像其他任何对象一样被初始化，那么确切的说，that是怎样被初始化的呢？对于C++ 98，答案是复制构造函数，**但是对于C++ 11，编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择。**\n\n\n\n如果是a=b，这样就会调用复制构造函数来初始化that（因为b是左值），赋值操作符会与新创建的对象交换数据，深度拷贝。这就是copy and swap 惯用法的定义：构造一个副本，与副本交换数据，并让副本在作用域内自动销毁。这里也一样。\n\n\n\n如果是a = x + y，这样就会调用转移构造函数来初始化that（因为x+y是右值），所以这里没有深度拷贝，只有高效的数据转移。相对于参数，that依然是一个独立的对象，但是他的构造函数是无用的（trivial），因此堆中的数据没有必要复制，而仅仅是转移。没有必要复制他，因为x+y是右值，再次，从右值指向的对象中转移是没有问题的。\n\n\n\n总结一下：复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。\n\n\n\n下面我们进一步讨论右值引用和move语义。\n\n\n\nC98标准库中提供了一种唯一拥有性的智能指针`std::auto_ptr`，**该类型在C11中已被废弃**，因为其“复制”行为是危险的。\n\n\n\n```c\nauto_ptr<Shape> a(new Triangle);auto_ptr<Shape> b(a);\n```\n\n\n\n注意b是怎样使用a进行初始化的，它不复制triangle，而是把triangle的所有权从a传递给了b，也可以说成“a 被转移进了b”或者“triangle被从a转移到了b”。\n\n\n\nauto_ptr 的复制构造函数可能看起来像这样（简化）：\n\n\n\n```c\nauto_ptr(auto_ptr& source)   // note the missing const\n{\np = source.p;\nsource.p = 0;   // now the source no longer owns the object\n}\n```\n\n\n\nauto_ptr 的危险之处在于看上去应该是复制，但实际上确是转移。调用被转移过的auto_ptr 的成员函数将会导致不可预知的后果。所以你必须非常谨慎的使用auto_ptr ，如果他被转移过。\n\n\n\n```c\nauto_ptr<Shape> make_triangle()\n{\n    return auto_ptr<Shape>(new Triangle);\n}\n\nauto_ptr<Shape> c(make_triangle());      // move temporary into c\ndouble area = make_triangle()->area();   // perfectly safe\n\nauto_ptr<Shape> a(new Triangle);    // create triangle\nauto_ptr<Shape> b(a);               // move a into b\ndouble area = a->area();                // undefined behavior\n```\n\n\n\n显然，在持有auto_ptr 对象的a表达式和持有调用函数返回的auto_ptr值类型的make_triangle()表达式之间一定有一些潜在的区别，每调用一次后者就会创建一个新的auto_ptr对象。这里a 其实就是一个左值（lvalue）的例子，而make_triangle()就是右值（rvalue）的例子。\n\n\n\n转移像a这样的左值是非常危险的，因为我们可能调用a的成员函数，这会导致不可预知的行为。另一方面，转移像make_triangle()这样的右值却是非常安全的，因为复制构造函数之后，我们不能再使用这个临时对象了，因为这个转移后的临时对象会在下一行之前销毁掉。\n\n\n\n我们现在知道转移左值是十分危险的，但是转移右值却是很安全的。如果C++能从语言级别支持区分左值和右值参数，我就可以完全杜绝对左值转移，或者把转移左值在调用的时候暴露出来，以使我们不会不经意的转移左值。\n\n\n\nC++ 11对这个问题的答案是右值引用。右值引用是针对右值的新的引用类型，语法是X&&。以前的老的引用类型X& 现在被称作左值引用。\n\n\n\n使用右值引用X&&作为参数的最有用的函数之一就是转移构造函数X::X(X&& source)，它的主要作用是把源对象的本地资源转移给当前对象。\n\n\n\nC++ 11中，std::auto_ptr< T >已经被std::unique_ptr< T >所取代，后者就是利用的右值引用。\n\n\n\n其转移构造函数：\n\n\n\n```c\nunique_ptr(unique_ptr&& source)   // note the rvalue reference\n{\n    ptr = source.ptr;\n    source.ptr = nullptr;\n}\n```\n\n\n\n这个转移构造函数跟auto_ptr中复制构造函数做的事情一样，但是它却只能接受右值作为参数。\n\n\n\n```c\nunique_ptr<Shape> a(new Triangle);\nunique_ptr<Shape> b(a);                 // error\nunique_ptr<Shape> c(make_triangle());       // okay\n```\n\n\n\n第二行不能编译通过，因为a是左值，但是参数unique_ptr&& source只能接受右值，这正是我们所需要的，杜绝危险的隐式转移。第三行编译没有问题，因为make_triangle()是右值，转移构造函数会将临时对象的所有权转移给对象c，这正是我们需要的。\n\n\n\n## 转移左值\n\n\n\n有时候，我们可能想转移左值，也就是说，有时候我们想让编译器把左值当作右值对待，以便能使用转移构造函数，即便这有点不安全。出于这个目的，C++ 11在标准库的头文件< utility >中提供了一个模板函数std::move。实际上，std::move仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移。\n\n\n\n以下是如何正确的转移左值：\n\n\n\n```c\nunique_ptr<Shape> a(new Triangle);\nunique_ptr<Shape> b(a);              // still an error\nunique_ptr<Shape> c(std::move(a));   // okay\n```\n\n\n\n请注意，第三行之后，a不再拥有Triangle对象。不过这没有关系，因为通过明确的写出std::move(a)，我们很清楚我们的意图：亲爱的转移构造函数，你可以对a做任何想要做的事情来初始化c；我不再需要a了，对于a，您请自便。\n\n\n\n当然，如果你在使用了mova(a)之后，还继续使用a，那无疑是搬起石头砸自己的脚，还是会导致严重的运行错误。\n\n\n\n总之，std::move(some_lvalue)将左值转换为右值（可以理解为一种类型转换），使接下来的转移成为可能。\n\n\n\n一个例子：\n\n\n\n```c\nclass Foo\n{\n    unique_ptr<Shape> member;\n\npublic:\n    Foo(unique_ptr<Shape>&& parameter)\n    : member(parameter)   // error\n    {}\n\n};\n```\n\n\n\n上面的parameter，其类型是一个右值引用，只能说明parameter是指向右值的引用，而parameter本身是个左值。（Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.）\n\n\n\n因此以上对parameter的转移是不允许的，需要使用`std::move`来显示转换成右值。\n"
        },
        {
          "name": "C++14新特性的所有知识点全在这儿啦！.md",
          "type": "blob",
          "size": 7.5498046875,
          "content": "> 本文转自：https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484757&idx=1&sn=523a55fcf636113e678f1de297ec4691&chksm=c21d37e9f56abeffca414c0d43d55b36396956735e3cff1c13e1a229a3d21336371a54da84ce&scene=21#wechat_redirect\n\n**「函数返回值类型推导」**\n\nC++14对函数返回类型推导规则做了优化，先看一段代码：\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nauto func(int i) {\n   return i;\n}\n\nint main() {\n   cout << func(4) << endl;\n   return 0;\n}\n```\n\n使用C++11编译：\n\n```cpp\n~/test$ g++ test.cc -std=c++11\ntest.cc:5:16: error: ‘func’ function uses ‘auto’ type specifier without trailing return type\nauto func(int i) {\n               ^\ntest.cc:5:16: note: deduced return type only available with -std=c++14 or -std=gnu++14\n```\n\n上面的代码使用C++11是不能通过编译的，通过编译器输出的信息也可以看见这个特性需要到C++14才被支持。\n\n返回值类型推导也可以用在模板中：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\ntemplate<typename T> auto func(T t) { return t; }\n\nint main() {\n   cout << func(4) << endl;\n   cout << func(3.4) << endl;\n   return 0;\n}\n```\n\n**注意**：\n\n**函数内如果有多个return语句，它们必须返回相同的类型，否则编译失败**\n\n```cpp\nauto func(bool flag) {\n   if (flag) return 1;\n   else return 2.3; // error\n}\n// inconsistent deduction for auto return type: ‘int’ and then ‘double’\n```\n\n**如果return语句返回初始化列表，返回值类型推导也会失败**\n\n```cpp\nauto func() {\n   return {1, 2, 3}; // error returning initializer list\n}\n```\n\n**如果函数是虚函数，不能使用返回值类型推导**\n\n```cpp\nstruct A {\n// error: virtual function cannot have deduced return type\nvirtual auto func() { return 1; }\n}\n```\n\n**返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义**\n\n```cpp\nauto f();               // declared, not yet defined\nauto f() { return 42; } // defined, return type is int\n\nint main() {\ncout << f() << endl;\n}\n```\n\n**返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。**\n\n```cpp\nauto sum(int i) {\n   if (i == 1)\n       return i;              // return int\n   else\n       return sum(i - 1) + i; // ok\n}\n```\n\n**lambda参数auto**\n\n在C++11中，lambda表达式参数需要使用具体的类型声明：\n\n```cpp\nauto f = [] (int a) { return a; }\n```\n\n在C++14中，对此进行优化，lambda表达式参数可以直接是auto：\n\n```cpp\nauto f = [] (auto a) { return a; };\ncout << f(1) << endl;\ncout << f(2.3f) << endl;\n```\n\n**变量模板**\n\nC++14支持变量模板：\n\n```cpp\ntemplate<class T>\nconstexpr T pi = T(3.1415926535897932385L);\n\nint main() {\n   cout << pi<int> << endl; // 3\n   cout << pi<double> << endl; // 3.14159\n   return 0;\n}\n```\n\n**别名模板**\n\nC++14也支持别名模板：\n\n```cpp\ntemplate<typename T, typename U>\nstruct A {\n   T t;\n   U u;\n};\n\ntemplate<typename T>\nusing B = A<T, int>;\n\nint main() {\n   B<double> b;\n   b.t = 10;\n   b.u = 20;\n   cout << b.t << endl;\n   cout << b.u << endl;\n   return 0;\n}\n```\n\n**constexpr的限制**\n\nC++14相较于C++11对constexpr减少了一些限制：\n\n**C++11中constexpr函数可以使用递归，在C++14中可以使用局部变量和循环**\n\n```cpp\nconstexpr int factorial(int n) { // C++14 和 C++11均可\n   return n <= 1 ? 1 : (n * factorial(n - 1));\n}\n```\n\n在C++14中可以这样做：\n\n```cpp\nconstexpr int factorial(int n) { // C++11中不可，C++14中可以\n   int ret = 0;\n   for (int i = 0; i < n; ++i) {\n       ret += i;\n  }\n   return ret;\n}\n```\n\n**C++11中constexpr函数必须必须把所有东西都放在一个单独的return语句中，而constexpr则无此限制**\n\n```cpp\nconstexpr int func(bool flag) { // C++14 和 C++11均可\n   return 0;\n}\n```\n\n在C++14中可以这样：\n\n```cpp\nconstexpr int func(bool flag) { // C++11中不可，C++14中可以\n   if (flag) return 1;\n   else return 0;\n}\n```\n\n**[[deprecated]]标记**\n\nC++14中增加了deprecated标记，修饰类、变、函数等，当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用。\n\n```cpp\nstruct [[deprecated]] A { };\n\nint main() {\n    A a;\n    return 0;\n}\n```\n\n当编译时，会出现如下警告：\n\n```cpp\n~/test$ g++ test.cc -std=c++14\ntest.cc: In function ‘int main()’:\ntest.cc:11:7: warning: ‘A’ is deprecated [-Wdeprecated-declarations]\n     A a;\n       ^\ntest.cc:6:23: note: declared here\n struct [[deprecated]] A {\n```\n\n**二进制字面量与整形字面量分隔符**\n\nC++14引入了二进制字面量，也引入了分隔符，防止看起来眼花哈~\n\n```cpp\nint a = 0b0001'0011'1010;\ndouble b = 3.14'1234'1234'1234;\n```\n\n**std::make_unique**\n\n我们都知道C++11中有std::make_shared，却没有std::make_unique，在C++14已经改善。\n\n```cpp\nstruct A {};\nstd::unique_ptr<A> ptr = std::make_unique<A>();\n```\n\n**std::shared_timed_mutex与std::shared_lock**\n\nC++14通过std::shared_timed_mutex和std::shared_lock来实现读写锁，保证多个线程可以同时读，但是写线程必须独立运行，写操作不可以同时和读操作一起进行。\n\n实现方式如下：\n\n```cpp\nstruct ThreadSafe {\n    mutable std::shared_timed_mutex mutex_;\n    int value_;\n\n    ThreadSafe() {\n        value_ = 0;\n    }\n\n    int get() const {\n        std::shared_lock<std::shared_timed_mutex> loc(mutex_);\n        return value_;\n    }\n\n    void increase() {\n        std::unique_lock<std::shared_timed_mutex> lock(mutex_);\n        value_ += 1;\n    }\n};\n```\n\n为什么是timed的锁呢，因为可以带超时时间，具体可以自行查询相关资料哈，网上有很多。\n\n**std::integer_sequence**\n\n```cpp\ntemplate<typename T, T... ints>\nvoid print_sequence(std::integer_sequence<T, ints...> int_seq)\n{\n    std::cout << \"The sequence of size \" << int_seq.size() << \": \";\n    ((std::cout << ints << ' '), ...);\n    std::cout << '\\n';\n}\n\nint main() {\n    print_sequence(std::integer_sequence<int, 9, 2, 5, 1, 9, 1, 6>{});\n    return 0;\n}\n\n输出：7 9 2 5 1 9 1 6\n```\n\nstd::integer_sequence和std::tuple的配合使用：\n\n```cpp\ntemplate <std::size_t... Is, typename F, typename T>\nauto map_filter_tuple(F f, T& t) {\n    return std::make_tuple(f(std::get<Is>(t))...);\n}\n\ntemplate <std::size_t... Is, typename F, typename T>\nauto map_filter_tuple(std::index_sequence<Is...>, F f, T& t) {\n    return std::make_tuple(f(std::get<Is>(t))...);\n}\n\ntemplate <typename S, typename F, typename T>\nauto map_filter_tuple(F&& f, T& t) {\n    return map_filter_tuple(S{}, std::forward<F>(f), t);\n}\n```\n\n**std::exchange**\n\n直接看代码吧：\n\n```cpp\nint main() {\n    std::vector<int> v;\n    std::exchange(v, {1,2,3,4});\n    cout << v.size() << endl;\n    for (int a : v) {\n        cout << a << \" \";\n    }\n    return 0;\n}\n```\n\n看样子貌似和std::swap作用相同，那它俩有什么区别呢？\n\n可以看下exchange的实现：\n\n```cpp\ntemplate<class T, class U = T>\nconstexpr T exchange(T& obj, U&& new_value) {\n    T old_value = std::move(obj);\n    obj = std::forward<U>(new_value);\n    return old_value;\n}\n```\n\n可以看见new_value的值给了obj，而没有对new_value赋值，这里相信您已经知道了它和swap的区别了吧！\n\n**std::quoted**\n\nC++14引入std::quoted用于给字符串添加双引号，直接看代码：\n\n```cpp\nint main() {\n    string str = \"hello world\";\n    cout << str << endl;\n    cout << std::quoted(str) << endl;\n    return 0;\n}\n```\n\n编译&输出：\n\n```cpp\n~/test$ g++ test.cc -std=c++14\n~/test$ ./a.out\nhello world\n\"hello world\"\n```\n"
        },
        {
          "name": "C++基础入门.md",
          "type": "blob",
          "size": 60.64453125,
          "content": "# C++基础入门\r\n\r\n## 1 C++初识\r\n\r\n### 1.1  第一个C++程序\r\n\r\n编写一个C++程序总共分为4个步骤\r\n\r\n* 创建项目\r\n* 创建文件\r\n* 编写代码\r\n* 运行程序\r\n\r\n#### 1.1.1 创建项目\r\n\r\n​\tVisual Studio是我们用来编写C++程序的主要工具，我们先将它打开\r\n\r\n![1541383178746](assets/1541383178746.png)\r\n\r\n\r\n\r\n![1541384366413](assets/1541384366413.png)\r\n\r\n#### 1.1.2 创建文件\r\n\r\n右键源文件，选择添加->新建项\r\n\r\n![1541383817248](assets/1541383817248.png)\r\n\r\n给C++文件起个名称，然后点击添加即可。\r\n\r\n![1541384140042](assets/1541384140042.png)\r\n\r\n\r\n\r\n#### 1.1.3 编写代码\r\n\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n\r\n\tcout << \"Hello world\" << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n#### 1.1.4 运行程序\r\n\r\n![1541384818688](assets/1541384818688.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 1.2 注释\r\n\r\n**作用**：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码\r\n\r\n**两种格式**\r\n\r\n1. **单行注释**：`// 描述信息` \r\n   - 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==\r\n2. **多行注释**： `/* 描述信息 */`\r\n   - 通常放在一段代码的上方，==对该段代码做整体说明==\r\n\r\n> 提示：编译器在编译代码时，会忽略注释的内容\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 1.3 变量\r\n\r\n**作用**：给一段指定的内存空间起名，方便操作这段内存\r\n\r\n**语法**：`数据类型 变量名 = 初始值;`\r\n\r\n**示例：**\r\n\r\n```C++\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n\r\n\t//变量的定义\r\n\t//语法：数据类型  变量名 = 初始值\r\n\r\n\tint a = 10;\r\n\r\n\tcout << \"a = \" << a << endl;\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 注意：C++在创建变量时，必须给变量一个初始值，否则会报错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 1.4  常量\r\n\r\n**作用**：用于记录程序中不可更改的数据\r\n\r\nC++定义常量两种方式\r\n\r\n1. **\\#define** 宏常量： `#define 常量名 常量值`\r\n   * ==通常在文件上方定义==，表示一个常量\r\n\r\n\r\n2. **const**修饰的变量 `const 数据类型 常量名 = 常量值`\r\n   * ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//1、宏常量\r\n#define day 7\r\n\r\nint main() {\r\n\r\n\tcout << \"一周里总共有 \" << day << \" 天\" << endl;\r\n\t//day = 8;  //报错，宏常量不可以修改\r\n\r\n\t//2、const修饰变量\r\n\tconst int month = 12;\r\n\tcout << \"一年里总共有 \" << month << \" 个月份\" << endl;\r\n\t//month = 24; //报错，常量是不可以修改的\r\n\t\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 1.5 关键字\r\n\r\n**作用：**关键字是C++中预先保留的单词（标识符）\r\n\r\n* **在定义变量或者常量时候，不要用关键字**\r\n\r\n\r\n\r\nC++关键字如下：\r\n\r\n| asm        | do           | if               | return      | typedef  |\r\n| ---------- | ------------ | ---------------- | ----------- | -------- |\r\n| auto       | double       | inline           | short       | typeid   |\r\n| bool       | dynamic_cast | int              | signed      | typename |\r\n| break      | else         | long             | sizeof      | union    |\r\n| case       | enum         | mutable          | static      | unsigned |\r\n| catch      | explicit     | namespace        | static_cast | using    |\r\n| char       | export       | new              | struct      | virtual  |\r\n| class      | extern       | operator         | switch      | void     |\r\n| const      | false        | private          | template    | volatile |\r\n| const_cast | float        | protected        | this        | wchar_t  |\r\n| continue   | for          | public           | throw       | while    |\r\n| default    | friend       | register         | true        |          |\r\n| delete     | goto         | reinterpret_cast | try         |          |\r\n\r\n`提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 1.6 标识符命名规则\r\n\r\n**作用**：C++规定给标识符（变量、常量）命名时，有一套自己的规则\r\n\r\n* 标识符不能是关键字\r\n* 标识符只能由字母、数字、下划线组成\r\n* 第一个字符必须为字母或下划线\r\n* 标识符中字母区分大小写\r\n\r\n> 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 2 数据类型\r\n\r\nC++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存\r\n\r\n### 2.1 整型\r\n\r\n**作用**：整型变量表示的是==整数类型==的数据\r\n\r\nC++中能够表示整型的类型有以下几种方式，**区别在于所占内存空间不同**：\r\n\r\n| **数据类型**        | **占用空间**                                    | 取值范围         |\r\n| ------------------- | ----------------------------------------------- | ---------------- |\r\n| short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |\r\n| int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |\r\n| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |\r\n| long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.2 sizeof关键字\r\n\r\n**作用：**利用sizeof关键字可以==统计数据类型所占内存大小==\r\n\r\n**语法：** `sizeof( 数据类型 / 变量)`\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tcout << \"short 类型所占内存空间为： \" << sizeof(short) << endl;\r\n\r\n\tcout << \"int 类型所占内存空间为： \" << sizeof(int) << endl;\r\n\r\n\tcout << \"long 类型所占内存空间为： \" << sizeof(long) << endl;\r\n\r\n\tcout << \"long long 类型所占内存空间为： \" << sizeof(long long) << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n> **整型结论**：==short < int <= long <= long long==\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.3 实型（浮点型）\r\n\r\n**作用**：用于==表示小数==\r\n\r\n浮点型变量分为两种：\r\n\r\n1. 单精度float \r\n2. 双精度double\r\n\r\n两者的**区别**在于表示的有效数字范围不同。\r\n\r\n| **数据类型** | **占用空间** | **有效数字范围** |\r\n| ------------ | ------------ | ---------------- |\r\n| float        | 4字节        | 7位有效数字      |\r\n| double       | 8字节        | 15～16位有效数字 |\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tfloat f1 = 3.14f;\r\n\tdouble d1 = 3.14;\r\n\r\n\tcout << f1 << endl;\r\n\tcout << d1<< endl;\r\n\r\n\tcout << \"float  sizeof = \" << sizeof(f1) << endl;\r\n\tcout << \"double sizeof = \" << sizeof(d1) << endl;\r\n\r\n\t//科学计数法\r\n\tfloat f2 = 3e2; // 3 * 10 ^ 2 \r\n\tcout << \"f2 = \" << f2 << endl;\r\n\r\n\tfloat f3 = 3e-2;  // 3 * 0.1 ^ 2\r\n\tcout << \"f3 = \" << f3 << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.4 字符型\r\n\r\n**作用：**字符型变量用于显示单个字符\r\n\r\n**语法：**`char ch = 'a';`\r\n\r\n\r\n\r\n> 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号\r\n\r\n> 注意2：单引号内只能有一个字符，不可以是字符串\r\n\r\n\r\n\r\n- C和C++中字符型变量只占用==1个字节==。\r\n- 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元\r\n\r\n\r\n\r\n示例：\r\n\r\n```C++\r\nint main() {\r\n\t\r\n\tchar ch = 'a';\r\n\tcout << ch << endl;\r\n\tcout << sizeof(char) << endl;\r\n\r\n\t//ch = \"abcde\"; //错误，不可以用双引号\r\n\t//ch = 'abcde'; //错误，单引号内只能引用一个字符\r\n\r\n\tcout << (int)ch << endl;  //查看字符a对应的ASCII码\r\n\tch = 97; //可以直接用ASCII给字符型变量赋值\r\n\tcout << ch << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\nASCII码表格：\r\n\r\n| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |\r\n| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |\r\n| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |\r\n| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |\r\n| 2           | STX          | 34          | \"        | 66          | B        | 98          | b        |\r\n| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |\r\n| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |\r\n| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |\r\n| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |\r\n| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |\r\n| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |\r\n| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |\r\n| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |\r\n| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |\r\n| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |\r\n| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |\r\n| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |\r\n| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |\r\n| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |\r\n| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |\r\n| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |\r\n| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |\r\n| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |\r\n| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |\r\n| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |\r\n| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |\r\n| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |\r\n| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |\r\n| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |\r\n| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |\r\n| 28          | FS           | 60          | <        | 92          | /        | 124         | \\|       |\r\n| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |\r\n| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |\r\n| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |\r\n\r\nASCII 码大致由以下**两部分组**成：\r\n\r\n* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。\r\n* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.5 转义字符\r\n\r\n**作用：**用于表示一些==不能显示出来的ASCII字符==\r\n\r\n现阶段我们常用的转义字符有：` \\n  \\\\  \\t`\r\n\r\n| **转义字符** | **含义**                                | **ASCII**码值（十进制） |\r\n| ------------ | --------------------------------------- | ----------------------- |\r\n| \\a           | 警报                                    | 007                     |\r\n| \\b           | 退格(BS) ，将当前位置移到前一列         | 008                     |\r\n| \\f           | 换页(FF)，将当前位置移到下页开头        | 012                     |\r\n| **\\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |\r\n| \\r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |\r\n| **\\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |\r\n| \\v           | 垂直制表(VT)                            | 011                     |\r\n| **\\\\\\\\**     | **代表一个反斜线字符\"\\\"**               | **092**                 |\r\n| \\'           | 代表一个单引号（撇号）字符              | 039                     |\r\n| \\\"           | 代表一个双引号字符                      | 034                     |\r\n| \\?           | 代表一个问号                            | 063                     |\r\n| \\0           | 数字0                                   | 000                     |\r\n| \\ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |\r\n| \\xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |\r\n\r\n示例：\r\n\r\n```C++\r\nint main() {\r\n\t\r\n\t\r\n\tcout << \"\\\\\" << endl;\r\n\tcout << \"\\tHello\" << endl;\r\n\tcout << \"\\n\" << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.6 字符串型\r\n\r\n**作用**：用于表示一串字符\r\n\r\n**两种风格**\r\n\r\n1. **C风格字符串**： `char 变量名[] = \"字符串值\"`\r\n\r\n   示例：\r\n\r\n   ```C++\r\n   int main() {\r\n\r\n   \tchar str1[] = \"hello world\";\r\n   \tcout << str1 << endl;\r\n       \r\n   \tsystem(\"pause\");\r\n\r\n   \treturn 0;\r\n   }\r\n   ```\r\n\r\n> 注意：C风格的字符串要用双引号括起来\r\n\r\n1. **C++风格字符串**：  `string  变量名 = \"字符串值\"`\r\n\r\n   示例：\r\n\r\n   ```C++\r\n   int main() {\r\n\r\n   \tstring str = \"hello world\";\r\n   \tcout << str << endl;\r\n   \t\r\n   \tsystem(\"pause\");\r\n\r\n   \treturn 0;\r\n   }\r\n   ```\r\n\r\n   ​\r\n\r\n> 注意：C++风格字符串，需要加入头文件==#include\\<string>==\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.7 布尔类型 bool\r\n\r\n**作用：**布尔数据类型代表真或假的值 \r\n\r\nbool类型只有两个值：\r\n\r\n* true  --- 真（本质是1）\r\n* false --- 假（本质是0）\r\n\r\n**bool类型占==1个字节==大小**\r\n\r\n示例：\r\n\r\n```C++\r\nint main() {\r\n\r\n\tbool flag = true;\r\n\tcout << flag << endl; // 1\r\n\r\n\tflag = false;\r\n\tcout << flag << endl; // 0\r\n\r\n\tcout << \"size of bool = \" << sizeof(bool) << endl; //1\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.8 数据的输入\r\n\r\n**作用：用于从键盘获取数据**\r\n\r\n**关键字：**cin\r\n\r\n**语法：** `cin >> 变量 `\r\n\r\n示例：\r\n\r\n```C++\r\nint main(){\r\n\r\n\t//整型输入\r\n\tint a = 0;\r\n\tcout << \"请输入整型变量：\" << endl;\r\n\tcin >> a;\r\n\tcout << a << endl;\r\n\r\n\t//浮点型输入\r\n\tdouble d = 0;\r\n\tcout << \"请输入浮点型变量：\" << endl;\r\n\tcin >> d;\r\n\tcout << d << endl;\r\n\r\n\t//字符型输入\r\n\tchar ch = 0;\r\n\tcout << \"请输入字符型变量：\" << endl;\r\n\tcin >> ch;\r\n\tcout << ch << endl;\r\n\r\n\t//字符串型输入\r\n\tstring str;\r\n\tcout << \"请输入字符串型变量：\" << endl;\r\n\tcin >> str;\r\n\tcout << str << endl;\r\n\r\n\t//布尔类型输入\r\n\tbool flag = true;\r\n\tcout << \"请输入布尔型变量：\" << endl;\r\n\tcin >> flag;\r\n\tcout << flag << endl;\r\n\tsystem(\"pause\");\r\n\treturn EXIT_SUCCESS;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 3 运算符\r\n\r\n**作用：**用于执行代码的运算\r\n\r\n本章我们主要讲解以下几类运算符：\r\n\r\n| **运算符类型** | **作用**                               |\r\n| -------------- | -------------------------------------- |\r\n| 算术运算符     | 用于处理四则运算                       |\r\n| 赋值运算符     | 用于将表达式的值赋给变量               |\r\n| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |\r\n| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |\r\n\r\n### 3.1 算术运算符\r\n\r\n**作用**：用于处理四则运算 \r\n\r\n算术运算符包括以下符号：\r\n\r\n| **运算符** | **术语**   | **示例**    | **结果**  |\r\n| ---------- | ---------- | ----------- | --------- |\r\n| +          | 正号       | +3          | 3         |\r\n| -          | 负号       | -3          | -3        |\r\n| +          | 加         | 10 + 5      | 15        |\r\n| -          | 减         | 10 - 5      | 5         |\r\n| *          | 乘         | 10 * 5      | 50        |\r\n| /          | 除         | 10 / 5      | 2         |\r\n| %          | 取模(取余) | 10 % 3      | 1         |\r\n| ++         | 前置递增   | a=2; b=++a; | a=3; b=3; |\r\n| ++         | 后置递增   | a=2; b=a++; | a=3; b=2; |\r\n| --         | 前置递减   | a=2; b=--a; | a=1; b=1; |\r\n| --         | 后置递减   | a=2; b=a--; | a=1; b=2; |\r\n\r\n**示例1：**\r\n\r\n```C++\r\n//加减乘除\r\nint main() {\r\n\r\n\tint a1 = 10;\r\n\tint b1 = 3;\r\n\r\n\tcout << a1 + b1 << endl;\r\n\tcout << a1 - b1 << endl;\r\n\tcout << a1 * b1 << endl;\r\n\tcout << a1 / b1 << endl;  //两个整数相除结果依然是整数\r\n\r\n\tint a2 = 10;\r\n\tint b2 = 20;\r\n\tcout << a2 / b2 << endl; \r\n\r\n\tint a3 = 10;\r\n\tint b3 = 0;\r\n\t//cout << a3 / b3 << endl; //报错，除数不可以为0\r\n\r\n\r\n\t//两个小数可以相除\r\n\tdouble d1 = 0.5;\r\n\tdouble d2 = 0.25;\r\n\tcout << d1 / d2 << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结：在除法运算中，除数不能为0\r\n\r\n\r\n\r\n\r\n\r\n**示例2：**\r\n\r\n```C++\r\n//取模\r\nint main() {\r\n\r\n\tint a1 = 10;\r\n\tint b1 = 3;\r\n\r\n\tcout << 10 % 3 << endl;\r\n\r\n\tint a2 = 10;\r\n\tint b2 = 20;\r\n\r\n\tcout << a2 % b2 << endl;\r\n\r\n\tint a3 = 10;\r\n\tint b3 = 0;\r\n\r\n\t//cout << a3 % b3 << endl; //取模运算时，除数也不能为0\r\n\r\n\t//两个小数不可以取模\r\n\tdouble d1 = 3.14;\r\n\tdouble d2 = 1.1;\r\n\r\n\t//cout << d1 % d2 << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n> 总结：只有整型变量可以进行取模运算\r\n\r\n\r\n\r\n**示例3：**\r\n\r\n```C++\r\n//递增\r\nint main() {\r\n\r\n\t//后置递增\r\n\tint a = 10;\r\n\ta++; //等价于a = a + 1\r\n\tcout << a << endl; // 11\r\n\r\n\t//前置递增\r\n\tint b = 10;\r\n\t++b;\r\n\tcout << b << endl; // 11\r\n\r\n\t//区别\r\n\t//前置递增先对变量进行++，再计算表达式\r\n\tint a2 = 10;\r\n\tint b2 = ++a2 * 10;\r\n\tcout << b2 << endl;\r\n\r\n\t//后置递增先计算表达式，后对变量进行++\r\n\tint a3 = 10;\r\n\tint b3 = a3++ * 10;\r\n\tcout << b3 << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n> 总结：前置递增先对变量进行++，再计算表达式，后置递增相反\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 3.2 赋值运算符\r\n\r\n**作用：**用于将表达式的值赋给变量\r\n\r\n赋值运算符包括以下几个符号：\r\n\r\n| **运算符** | **术语** | **示例**   | **结果**  |\r\n| ---------- | -------- | ---------- | --------- |\r\n| =          | 赋值     | a=2; b=3;  | a=2; b=3; |\r\n| +=         | 加等于   | a=0; a+=2; | a=2;      |\r\n| -=         | 减等于   | a=5; a-=3; | a=2;      |\r\n| *=         | 乘等于   | a=2; a*=2; | a=4;      |\r\n| /=         | 除等于   | a=4; a/=2; | a=2;      |\r\n| %=         | 模等于   | a=3; a%2;  | a=1;      |\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//赋值运算符\r\n\r\n\t// =\r\n\tint a = 10;\r\n\ta = 100;\r\n\tcout << \"a = \" << a << endl;\r\n\r\n\t// +=\r\n\ta = 10;\r\n\ta += 2; // a = a + 2;\r\n\tcout << \"a = \" << a << endl;\r\n\r\n\t// -=\r\n\ta = 10;\r\n\ta -= 2; // a = a - 2\r\n\tcout << \"a = \" << a << endl;\r\n\r\n\t// *=\r\n\ta = 10;\r\n\ta *= 2; // a = a * 2\r\n\tcout << \"a = \" << a << endl;\r\n\r\n\t// /=\r\n\ta = 10;\r\n\ta /= 2;  // a = a / 2;\r\n\tcout << \"a = \" << a << endl;\r\n\r\n\t// %=\r\n\ta = 10;\r\n\ta %= 2;  // a = a % 2;\r\n\tcout << \"a = \" << a << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 3.3 比较运算符\r\n\r\n**作用：**用于表达式的比较，并返回一个真值或假值\r\n\r\n比较运算符有以下符号：\r\n\r\n| **运算符** | **术语** | **示例** | **结果** |\r\n| ---------- | -------- | -------- | -------- |\r\n| ==         | 相等于   | 4 == 3   | 0        |\r\n| !=         | 不等于   | 4 != 3   | 1        |\r\n| <          | 小于     | 4 < 3    | 0        |\r\n| \\>         | 大于     | 4 > 3    | 1        |\r\n| <=         | 小于等于 | 4 <= 3   | 0        |\r\n| \\>=        | 大于等于 | 4 >= 1   | 1        |\r\n\r\n示例：\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 20;\r\n\r\n\tcout << (a == b) << endl; // 0 \r\n\r\n\tcout << (a != b) << endl; // 1\r\n\r\n\tcout << (a > b) << endl; // 0\r\n\r\n\tcout << (a < b) << endl; // 1\r\n\r\n\tcout << (a >= b) << endl; // 0\r\n\r\n\tcout << (a <= b) << endl; // 1\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 3.4 逻辑运算符\r\n\r\n**作用：**用于根据表达式的值返回真值或假值\r\n\r\n逻辑运算符有以下符号：\r\n\r\n| **运算符** | **术语** | **示例** | **结果**                                                 |\r\n| ---------- | -------- | -------- | -------------------------------------------------------- |\r\n| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |\r\n| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |\r\n| \\|\\|       | 或       | a \\|\\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |\r\n\r\n**示例1：**逻辑非\r\n\r\n```C++\r\n//逻辑运算符  --- 非\r\nint main() {\r\n\r\n\tint a = 10;\r\n\r\n\tcout << !a << endl; // 0\r\n\r\n\tcout << !!a << endl; // 1\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结： 真变假，假变真\r\n\r\n\r\n\r\n\r\n\r\n**示例2：**逻辑与\r\n\r\n```C++\r\n//逻辑运算符  --- 与\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 10;\r\n\r\n\tcout << (a && b) << endl;// 1\r\n\r\n\ta = 10;\r\n\tb = 0;\r\n\r\n\tcout << (a && b) << endl;// 0 \r\n\r\n\ta = 0;\r\n\tb = 0;\r\n\r\n\tcout << (a && b) << endl;// 0\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n> 总结：逻辑==与==运算符总结： ==同真为真，其余为假==\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例3：**逻辑或\r\n\r\n```c++\r\n//逻辑运算符  --- 或\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 10;\r\n\r\n\tcout << (a || b) << endl;// 1\r\n\r\n\ta = 10;\r\n\tb = 0;\r\n\r\n\tcout << (a || b) << endl;// 1 \r\n\r\n\ta = 0;\r\n\tb = 0;\r\n\r\n\tcout << (a || b) << endl;// 0\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 逻辑==或==运算符总结： ==同假为假，其余为真==\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 4 程序流程结构\r\n\r\nC/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==\r\n\r\n* 顺序结构：程序按顺序执行，不发生跳转\r\n* 选择结构：依据条件是否满足，有选择的执行相应功能\r\n* 循环结构：依据条件是否满足，循环多次执行某段代码\r\n\r\n\r\n\r\n### 4.1 选择结构\r\n\r\n#### 4.1.1 if语句\r\n\r\n**作用：**执行满足条件的语句\r\n\r\nif语句的三种形式\r\n\r\n* 单行格式if语句\r\n\r\n* 多行格式if语句\r\n\r\n* 多条件的if语句\r\n\r\n  ​\r\n\r\n1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }`\r\n\r\n   ![img](assets/clip_image002.png)\r\n\r\n   示例：\r\n\r\n   ```C++\r\n   int main() {\r\n\r\n   \t//选择结构-单行if语句\r\n   \t//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印\r\n\r\n   \tint score = 0;\r\n   \tcout << \"请输入一个分数：\" << endl;\r\n   \tcin >> score;\r\n\r\n   \tcout << \"您输入的分数为： \" << score << endl;\r\n\r\n   \t//if语句\r\n   \t//注意事项，在if判断语句后面，不要加分号\r\n   \tif (score > 600)\r\n   \t{\r\n   \t\tcout << \"我考上了一本大学！！！\" << endl;\r\n   \t}\r\n\r\n   \tsystem(\"pause\");\r\n\r\n   \treturn 0;\r\n   }\r\n   ```\r\n\r\n   ​\r\n\r\n\r\n> 注意：if条件表达式后不要加分号\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`\r\n\r\n![img](assets/clip_image002-1541662519170.png)\r\n\r\n​\r\n\r\n示例：\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint score = 0;\r\n\r\n\tcout << \"请输入考试分数：\" << endl;\r\n\r\n\tcin >> score;\r\n\r\n\tif (score > 600)\r\n\t{\r\n\t\tcout << \"我考上了一本大学\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"我未考上一本大学\" << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`\r\n\r\n![img](assets/clip_image002-1541662566808.png)\r\n\r\n​\r\n\r\n​\r\n\r\n​\r\n\r\n示例：\r\n\r\n```C++\r\n\tint main() {\r\n\r\n\tint score = 0;\r\n\r\n\tcout << \"请输入考试分数：\" << endl;\r\n\r\n\tcin >> score;\r\n\r\n\tif (score > 600)\r\n\t{\r\n\t\tcout << \"我考上了一本大学\" << endl;\r\n\t}\r\n\telse if (score > 500)\r\n\t{\r\n\t\tcout << \"我考上了二本大学\" << endl;\r\n\t}\r\n\telse if (score > 400)\r\n\t{\r\n\t\tcout << \"我考上了三本大学\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"我未考上本科\" << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n​\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**嵌套if语句**：在if语句中，可以嵌套使用if语句，达到更精确的条件判断\r\n\r\n\r\n\r\n案例需求：\r\n\r\n* 提示用户输入一个高考考试分数，根据分数做如下判断\r\n* 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；\r\n* 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```c++\r\nint main() {\r\n\r\n\tint score = 0;\r\n\r\n\tcout << \"请输入考试分数：\" << endl;\r\n\r\n\tcin >> score;\r\n\r\n\tif (score > 600)\r\n\t{\r\n\t\tcout << \"我考上了一本大学\" << endl;\r\n\t\tif (score > 700)\r\n\t\t{\r\n\t\t\tcout << \"我考上了北大\" << endl;\r\n\t\t}\r\n\t\telse if (score > 650)\r\n\t\t{\r\n\t\t\tcout << \"我考上了清华\" << endl;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"我考上了人大\" << endl;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\telse if (score > 500)\r\n\t{\r\n\t\tcout << \"我考上了二本大学\" << endl;\r\n\t}\r\n\telse if (score > 400)\r\n\t{\r\n\t\tcout << \"我考上了三本大学\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"我未考上本科\" << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例：** 三只小猪称体重\r\n\r\n有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](assets/三只小猪.jpg)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.1.2 三目运算符\r\n\r\n**作用：** 通过三目运算符实现简单的判断\r\n\r\n**语法：**`表达式1 ? 表达式2 ：表达式3`\r\n\r\n**解释：**\r\n\r\n如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\r\n\r\n如果表达式1的值为假，执行表达式3，并返回表达式3的结果。\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 20;\r\n\tint c = 0;\r\n\r\n\tc = a > b ? a : b;\r\n\tcout << \"c = \" << c << endl;\r\n\r\n\t//C++中三目运算符返回的是变量,可以继续赋值\r\n\r\n\t(a > b ? a : b) = 100;\r\n\r\n\tcout << \"a = \" << a << endl;\r\n\tcout << \"b = \" << b << endl;\r\n\tcout << \"c = \" << c << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.1.3 switch语句\r\n\r\n**作用：**执行多条件分支语句\r\n\r\n**语法：**\r\n\r\n```C++\r\nswitch(表达式)\r\n\r\n{\r\n\r\n\tcase 结果1：执行语句;break;\r\n\r\n\tcase 结果2：执行语句;break;\r\n\r\n\t...\r\n\r\n\tdefault:执行语句;break;\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//请给电影评分 \r\n\t//10 ~ 9   经典   \r\n\t// 8 ~ 7   非常好\r\n\t// 6 ~ 5   一般\r\n\t// 5分以下 烂片\r\n\r\n\tint score = 0;\r\n\tcout << \"请给电影打分\" << endl;\r\n\tcin >> score;\r\n\r\n\tswitch (score)\r\n\t{\r\n\tcase 10:\r\n\tcase 9:\r\n\t\tcout << \"经典\" << endl;\r\n\t\tbreak;\r\n\tcase 8:\r\n\t\tcout << \"非常好\" << endl;\r\n\t\tbreak;\r\n\tcase 7:\r\n\tcase 6:\r\n\t\tcout << \"一般\" << endl;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tcout << \"烂片\" << endl;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 注意1：switch语句中表达式类型只能是整型或者字符型\r\n\r\n> 注意2：case里如果没有break，那么程序会一直向下执行\r\n\r\n> 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.2 循环结构\r\n\r\n#### 4.2.1 while循环语句\r\n\r\n**作用：**满足循环条件，执行循环语句\r\n\r\n**语法：**` while(循环条件){ 循环语句 }`\r\n\r\n**解释：**==只要循环条件的结果为真，就执行循环语句==\r\n\r\n![img](assets/clip_image002-1541668640382.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint num = 0;\r\n\twhile (num < 10)\r\n\t{\r\n\t\tcout << \"num = \" << num << endl;\r\n\t\tnum++;\r\n\t}\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**while循环练习案例：**==猜数字==\r\n\r\n**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。\r\n\r\n\r\n\r\n![猜数字](assets/猜数字.jpg)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.2 do...while循环语句\r\n\r\n**作用：** 满足循环条件，执行循环语句\r\n\r\n**语法：** `do{ 循环语句 } while(循环条件);`\r\n\r\n**注意：**与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件\r\n\r\n![img](assets/clip_image002-1541671163478.png)\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint num = 0;\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << num << endl;\r\n\t\tnum++;\r\n\r\n\t} while (num < 10);\r\n\t\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例：水仙花数**\r\n\r\n**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身\r\n\r\n例如：1^3 + 5^3+ 3^3 = 153\r\n\r\n请利用do...while语句，求出所有3位数中的水仙花数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.3 for循环语句\r\n\r\n**作用：** 满足循环条件，执行循环语句\r\n\r\n**语法：**` for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tcout << i << endl;\r\n\t}\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**详解：**\r\n\r\n![1541673704101](assets/1541673704101.png)\r\n\r\n\r\n\r\n> 注意：for循环中的表达式，要用分号进行分隔\r\n\r\n> 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例：敲桌子**\r\n\r\n案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。\r\n\r\n![timg](assets/timg.gif)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.4 嵌套循环\r\n\r\n**作用：** 在循环体中再嵌套一层循环，解决一些实际问题\r\n\r\n例如我们想在屏幕中打印如下图片，就需要利用嵌套循环\r\n\r\n![1541676003486](assets/1541676003486.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//外层循环执行1次，内层循环执行1轮\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 10; j++)\r\n\t\t{\r\n\t\t\tcout << \"*\" << \" \";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例：**乘法口诀表\r\n\r\n案例描述：利用嵌套循环，实现九九乘法表\r\n\r\n![0006018857256120_b](assets/0006018857256120_b.jpg)\r\n\r\n\r\n\r\n\r\n\r\n### 4.3 跳转语句\r\n\r\n#### 4.3.1 break语句\r\n\r\n**作用:** 用于跳出==选择结构==或者==循环结构==\r\n\r\nbreak使用的时机：\r\n\r\n* 出现在switch条件语句中，作用是终止case并跳出switch\r\n* 出现在循环语句中，作用是跳出当前的循环语句\r\n* 出现在嵌套循环中，跳出最近的内层循环语句\r\n\r\n\r\n\r\n**示例1：**\r\n\r\n```C++\r\nint main() {\r\n\t//1、在switch 语句中使用break\r\n\tcout << \"请选择您挑战副本的难度：\" << endl;\r\n\tcout << \"1、普通\" << endl;\r\n\tcout << \"2、中等\" << endl;\r\n\tcout << \"3、困难\" << endl;\r\n\r\n\tint num = 0;\r\n\r\n\tcin >> num;\r\n\r\n\tswitch (num)\r\n\t{\r\n\tcase 1:\r\n\t\tcout << \"您选择的是普通难度\" << endl;\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tcout << \"您选择的是中等难度\" << endl;\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tcout << \"您选择的是困难难度\" << endl;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**示例2：**\r\n\r\n```C++\r\nint main() {\r\n\t//2、在循环语句中用break\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tif (i == 5)\r\n\t\t{\r\n\t\t\tbreak; //跳出循环语句\r\n\t\t}\r\n\t\tcout << i << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**示例3：**\r\n\r\n```C++\r\nint main() {\r\n\t//在嵌套循环语句中使用break，退出内层循环\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 10; j++)\r\n\t\t{\r\n\t\t\tif (j == 5)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcout << \"*\" << \" \";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.3.2 continue语句\r\n\r\n**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tfor (int i = 0; i < 100; i++)\r\n\t{\r\n\t\tif (i % 2 == 0)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tcout << i << endl;\r\n\t}\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 注意：continue并没有使整个循环终止，而break会跳出循环\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.3.3 goto语句\r\n\r\n**作用：**可以无条件跳转语句\r\n\r\n\r\n\r\n**语法：** `goto 标记;`\r\n\r\n**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tcout << \"1\" << endl;\r\n\r\n\tgoto FLAG;\r\n\r\n\tcout << \"2\" << endl;\r\n\tcout << \"3\" << endl;\r\n\tcout << \"4\" << endl;\r\n\r\n\tFLAG:\r\n\r\n\tcout << \"5\" << endl;\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 注意：在程序中不建议使用goto语句，以免造成程序流程混乱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 5 数组\r\n\r\n### 5.1 概述\r\n\r\n所谓数组，就是一个集合，里面存放了相同类型的数据元素\r\n\r\n\r\n\r\n**特点1：**数组中的每个==数据元素都是相同的数据类型==\r\n\r\n**特点2：**数组是由==连续的内存==位置组成的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n![1541748375356](assets/1541748375356.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 5.2 一维数组\r\n\r\n#### 5.2.1 一维数组定义方式\r\n\r\n一维数组定义的三种方式：\r\n\r\n1. ` 数据类型  数组名[ 数组长度 ]; `\r\n2. `数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};`\r\n3. `数据类型  数组名[ ] = { 值1，值2 ...};`\r\n\r\n\r\n\r\n示例\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//定义方式1\r\n\t//数据类型 数组名[元素个数];\r\n\tint score[10];\r\n\r\n\t//利用下标赋值\r\n\tscore[0] = 100;\r\n\tscore[1] = 99;\r\n\tscore[2] = 85;\r\n\r\n\t//利用下标输出\r\n\tcout << score[0] << endl;\r\n\tcout << score[1] << endl;\r\n\tcout << score[2] << endl;\r\n\r\n\r\n\t//第二种定义方式\r\n\t//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};\r\n\t//如果{}内不足10个数据，剩余数据用0补全\r\n\tint score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };\r\n\t\r\n\t//逐个输出\r\n\t//cout << score2[0] << endl;\r\n\t//cout << score2[1] << endl;\r\n\r\n\t//一个一个输出太麻烦，因此可以利用循环进行输出\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tcout << score2[i] << endl;\r\n\t}\r\n\r\n\t//定义方式3\r\n\t//数据类型 数组名[] =  {值1，值2 ，值3 ...};\r\n\tint score3[] = { 100,90,80,70,60,50,40,30,20,10 };\r\n\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tcout << score3[i] << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名\r\n\r\n> 总结2：数组中下标是从0开始索引\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 5.2.2 一维数组数组名\r\n\r\n一维数组名称的**用途**：\r\n\r\n1. 可以统计整个数组在内存中的长度\r\n2. 可以获取数组在内存中的首地址\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//数组名用途\r\n\t//1、可以获取整个数组占用内存空间大小\r\n\tint arr[10] = { 1,2,3,4,5,6,7,8,9,10 };\r\n\r\n\tcout << \"整个数组所占内存空间为： \" << sizeof(arr) << endl;\r\n\tcout << \"每个元素所占内存空间为： \" << sizeof(arr[0]) << endl;\r\n\tcout << \"数组的元素个数为： \" << sizeof(arr) / sizeof(arr[0]) << endl;\r\n\r\n\t//2、可以通过数组名获取到数组首地址\r\n\tcout << \"数组首地址为： \" << (int)arr << endl;\r\n\tcout << \"数组中第一个元素地址为： \" << (int)&arr[0] << endl;\r\n\tcout << \"数组中第二个元素地址为： \" << (int)&arr[1] << endl;\r\n\r\n\t//arr = 100; 错误，数组名是常量，因此不可以赋值\r\n\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 注意：数组名是常量，不可以赋值\r\n\r\n> 总结1：直接打印数组名，可以查看数组所占内存的首地址\r\n\r\n>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例1**：五只小猪称体重\r\n\r\n**案例描述：**\r\n\r\n在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};\r\n\r\n找出并打印最重的小猪体重。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例2：**数组元素逆置\r\n\r\n**案例描述：**请声明一个5个元素的数组，并且将元素逆置.\r\n\r\n(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 5.2.3 冒泡排序\r\n\r\n**作用：** 最常用的排序算法，对数组内元素进行排序\r\n\r\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\r\n2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。\r\n3. 重复以上的步骤，每次比较次数-1，直到不需要比较\r\n\r\n![1541905327273](assets/1541905327273.png)\r\n\r\n**示例：** 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint arr[9] = { 4,2,8,0,5,7,1,3,9 };\r\n\r\n\tfor (int i = 0; i < 9 - 1; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 9 - 1 - i; j++)\r\n\t\t{\r\n\t\t\tif (arr[j] > arr[j + 1])\r\n\t\t\t{\r\n\t\t\t\tint temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j + 1];\r\n\t\t\t\tarr[j + 1] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < 9; i++)\r\n\t{\r\n\t\tcout << arr[i] << endl;\r\n\t}\r\n    \r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 5.3 二维数组\r\n\r\n二维数组就是在一维数组上，多加一个维度。\r\n\r\n![1541905559138](assets/1541905559138.png)\r\n\r\n#### 5.3.1 二维数组定义方式\r\n\r\n二维数组定义的四种方式：\r\n\r\n1. ` 数据类型  数组名[ 行数 ][ 列数 ]; `\r\n2. `数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`\r\n3. `数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};`\r\n4. ` 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};`\r\n\r\n\r\n\r\n> 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==\r\n\r\n示例：\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//方式1  \r\n\t//数组类型 数组名 [行数][列数]\r\n\tint arr[2][3];\r\n\tarr[0][0] = 1;\r\n\tarr[0][1] = 2;\r\n\tarr[0][2] = 3;\r\n\tarr[1][0] = 4;\r\n\tarr[1][1] = 5;\r\n\tarr[1][2] = 6;\r\n\r\n\tfor (int i = 0; i < 2; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 3; j++)\r\n\t\t{\r\n\t\t\tcout << arr[i][j] << \" \";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\r\n\t//方式2 \r\n\t//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };\r\n\tint arr2[2][3] =\r\n\t{\r\n\t\t{1,2,3},\r\n\t\t{4,5,6}\r\n\t};\r\n\r\n\t//方式3\r\n\t//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };\r\n\tint arr3[2][3] = { 1,2,3,4,5,6 }; \r\n\r\n\t//方式4 \r\n\t//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };\r\n\tint arr4[][3] = { 1,2,3,4,5,6 };\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：在定义二维数组时，如果初始化了数据，可以省略行数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 5.3.2 二维数组数组名\r\n\r\n\r\n\r\n* 查看二维数组所占内存空间\r\n* 获取二维数组首地址\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//二维数组数组名\r\n\tint arr[2][3] =\r\n\t{\r\n\t\t{1,2,3},\r\n\t\t{4,5,6}\r\n\t};\r\n\r\n\tcout << \"二维数组大小： \" << sizeof(arr) << endl;\r\n\tcout << \"二维数组一行大小： \" << sizeof(arr[0]) << endl;\r\n\tcout << \"二维数组元素大小： \" << sizeof(arr[0][0]) << endl;\r\n\r\n\tcout << \"二维数组行数： \" << sizeof(arr) / sizeof(arr[0]) << endl;\r\n\tcout << \"二维数组列数： \" << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;\r\n\r\n\t//地址\r\n\tcout << \"二维数组首地址：\" << arr << endl;\r\n\tcout << \"二维数组第一行地址：\" << arr[0] << endl;\r\n\tcout << \"二维数组第二行地址：\" << arr[1] << endl;\r\n\r\n\tcout << \"二维数组第一个元素地址：\" << &arr[0][0] << endl;\r\n\tcout << \"二维数组第二个元素地址：\" << &arr[0][1] << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结1：二维数组名就是这个数组的首地址\r\n\r\n> 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### **5.3.3 二维数组应用案例**\r\n\r\n**考试成绩统计：**\r\n\r\n案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，**请分别输出三名同学的总成绩**\r\n\r\n|      | 语文 | 数学 | 英语 |\r\n| ---- | ---- | ---- | ---- |\r\n| 张三 | 100  | 100  | 100  |\r\n| 李四 | 90   | 50   | 100  |\r\n| 王五 | 60   | 70   | 80   |\r\n\r\n\r\n\r\n\r\n\r\n**参考答案：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint scores[3][3] =\r\n\t{\r\n\t\t{100,100,100},\r\n\t\t{90,50,100},\r\n\t\t{60,70,80},\r\n\t};\r\n\r\n\tstring names[3] = { \"张三\",\"李四\",\"王五\" };\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tint sum = 0;\r\n\t\tfor (int j = 0; j < 3; j++)\r\n\t\t{\r\n\t\t\tsum += scores[i][j];\r\n\t\t}\r\n\t\tcout << names[i] << \"同学总成绩为： \" << sum << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 6 函数\r\n\r\n### 6.1 概述\r\n\r\n**作用：**将一段经常使用的代码封装起来，减少重复代码\r\n\r\n一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。\r\n\r\n### 6.2 函数的定义\r\n\r\n函数的定义一般主要有5个步骤：\r\n\r\n1、返回值类型 \r\n\r\n2、函数名\r\n\r\n3、参数表列\r\n\r\n4、函数体语句 \r\n\r\n5、return 表达式\r\n\r\n**语法：** \r\n\r\n```C++\r\n返回值类型 函数名 （参数列表）\r\n{\r\n\r\n       函数体语句\r\n\r\n       return表达式\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n* 返回值类型 ：一个函数可以返回一个值。在函数定义中\r\n* 函数名：给函数起个名称\r\n* 参数列表：使用该函数时，传入的数据\r\n* 函数体语句：花括号内的代码，函数内需要执行的语句\r\n* return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据\r\n\r\n\r\n\r\n\r\n\r\n**示例：**定义一个加法函数，实现两个数相加\r\n\r\n```C++\r\n//函数定义\r\nint add(int num1, int num2)\r\n{\r\n\tint sum = num1 + num2;\r\n\treturn sum;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 6.3 函数的调用\r\n\r\n**功能：**使用定义好的函数\r\n\r\n**语法：**` 函数名（参数）`\r\n\r\n**示例：**\r\n\r\n```C++\r\n//函数定义\r\nint add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参\r\n{\r\n\tint sum = num1 + num2;\r\n\treturn sum;\r\n}\r\n\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 10;\r\n\t//调用add函数\r\n\tint sum = add(a, b);//调用时的a，b称为实际参数，简称实参\r\n\tcout << \"sum = \" << sum << endl;\r\n\r\n\ta = 100;\r\n\tb = 100;\r\n\r\n\tsum = add(a, b);\r\n\tcout << \"sum = \" << sum << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 6.4 值传递\r\n\r\n* 所谓值传递，就是函数调用时实参将数值传入给形参\r\n* 值传递时，==如果形参发生，并不会影响实参==\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nvoid swap(int num1, int num2)\r\n{\r\n\tcout << \"交换前：\" << endl;\r\n\tcout << \"num1 = \" << num1 << endl;\r\n\tcout << \"num2 = \" << num2 << endl;\r\n\r\n\tint temp = num1;\r\n\tnum1 = num2;\r\n\tnum2 = temp;\r\n\r\n\tcout << \"交换后：\" << endl;\r\n\tcout << \"num1 = \" << num1 << endl;\r\n\tcout << \"num2 = \" << num2 << endl;\r\n\r\n\t//return ; 当函数声明时候，不需要返回值，可以不写return\r\n}\r\n\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 20;\r\n\r\n\tswap(a, b);\r\n\r\n\tcout << \"mian中的 a = \" << a << endl;\r\n\tcout << \"mian中的 b = \" << b << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结： 值传递时，形参是修饰不了实参的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### **6.5 函数的常见样式**\r\n\r\n常见的函数样式有4种\r\n\r\n1. 无参无返\r\n2. 有参无返\r\n3. 无参有返\r\n4. 有参有返\r\n\r\n**示例：**\r\n\r\n```C++\r\n//函数常见样式\r\n//1、 无参无返\r\nvoid test01()\r\n{\r\n\t//void a = 10; //无类型不可以创建变量,原因无法分配内存\r\n\tcout << \"this is test01\" << endl;\r\n\t//test01(); 函数调用\r\n}\r\n\r\n//2、 有参无返\r\nvoid test02(int a)\r\n{\r\n\tcout << \"this is test02\" << endl;\r\n\tcout << \"a = \" << a << endl;\r\n}\r\n\r\n//3、无参有返\r\nint test03()\r\n{\r\n\tcout << \"this is test03 \" << endl;\r\n\treturn 10;\r\n}\r\n\r\n//4、有参有返\r\nint test04(int a, int b)\r\n{\r\n\tcout << \"this is test04 \" << endl;\r\n\tint sum = a + b;\r\n\treturn sum;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 6.6 函数的声明\r\n\r\n**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\r\n\r\n\r\n\r\n*  函数的**声明可以多次**，但是函数的**定义只能有一次**\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//声明可以多次，定义只能一次\r\n//声明\r\nint max(int a, int b);\r\nint max(int a, int b);\r\n//定义\r\nint max(int a, int b)\r\n{\r\n\treturn a > b ? a : b;\r\n}\r\n\r\nint main() {\r\n\r\n\tint a = 100;\r\n\tint b = 200;\r\n\r\n\tcout << max(a, b) << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 6.7 函数的分文件编写\r\n\r\n**作用：**让代码结构更加清晰\r\n\r\n函数分文件编写一般有4个步骤\r\n\r\n1. 创建后缀名为.h的头文件  \r\n2. 创建后缀名为.cpp的源文件\r\n3. 在头文件中写函数的声明\r\n4. 在源文件中写函数的定义\r\n\r\n**示例：**\r\n\r\n```C++\r\n//swap.h文件\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n//实现两个数字交换的函数声明\r\nvoid swap(int a, int b);\r\n\r\n```\r\n\r\n```C++\r\n//swap.cpp文件\r\n#include \"swap.h\"\r\n\r\nvoid swap(int a, int b)\r\n{\r\n\tint temp = a;\r\n\ta = b;\r\n\tb = temp;\r\n\r\n\tcout << \"a = \" << a << endl;\r\n\tcout << \"b = \" << b << endl;\r\n}\r\n```\r\n\r\n```C++\r\n//main函数文件\r\n#include \"swap.h\"\r\nint main() {\r\n\r\n\tint a = 100;\r\n\tint b = 200;\r\n\tswap(a, b);\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 7 指针\r\n\r\n### 7.1 指针的基本概念\r\n\r\n**指针的作用：** 可以通过指针间接访问内存\r\n\r\n\r\n\r\n* 内存编号是从0开始记录的，一般用十六进制数字表示\r\n* 可以利用指针变量保存地址\r\n\r\n  ​\r\n\r\n### 7.2 指针变量的定义和使用\r\n\r\n指针变量定义语法： `数据类型 * 变量名；`\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//1、指针的定义\r\n\tint a = 10; //定义整型变量a\r\n\t\r\n\t//指针定义语法： 数据类型 * 变量名 ;\r\n\tint * p;\r\n\r\n\t//指针变量赋值\r\n\tp = &a; //指针指向变量a的地址\r\n\tcout << &a << endl; //打印数据a的地址\r\n\tcout << p << endl;  //打印指针变量p\r\n\r\n\t//2、指针的使用\r\n\t//通过*操作指针变量指向的内存\r\n\tcout << \"*p = \" << *p << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n指针变量和普通变量的区别\r\n\r\n* 普通变量存放的是数据,指针变量存放的是地址\r\n* 指针变量可以通过\" * \"操作符，操作指针变量指向的内存空间，这个过程称为解引用\r\n\r\n\r\n\r\n> 总结1： 我们可以通过 & 符号 获取变量的地址\r\n\r\n> 总结2：利用指针可以记录地址\r\n\r\n> 总结3：对指针变量解引用，可以操作指针指向的内存\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 7.3 指针所占内存空间\r\n\r\n\r\n\r\n提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint a = 10;\r\n\r\n\tint * p;\r\n\tp = &a; //指针指向数据a的地址\r\n\r\n\tcout << *p << endl; //* 解引用\r\n\tcout << sizeof(p) << endl;\r\n\tcout << sizeof(char *) << endl;\r\n\tcout << sizeof(float *) << endl;\r\n\tcout << sizeof(double *) << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：所有指针类型在32位操作系统下是4个字节\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 7.4 空指针和野指针\r\n\r\n**空指针**：指针变量指向内存中编号为0的空间\r\n\r\n**用途：**初始化指针变量\r\n\r\n**注意：**空指针指向的内存是不可以访问的\r\n\r\n\r\n\r\n**示例1：空指针**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//指针变量p指向内存地址编号为0的空间\r\n\tint * p = NULL;\r\n\r\n\t//访问空指针报错 \r\n\t//内存编号0 ~255为系统占用内存，不允许用户访问\r\n\tcout << *p << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**野指针**：指针变量指向非法的内存空间\r\n\r\n**示例2：野指针**\r\n\r\n```C++\r\nint main() {\r\n\r\n\t//指针变量p指向内存地址编号为0x1100的空间\r\n\tint * p = (int *)0x1100;\r\n\r\n\t//访问野指针报错 \r\n\tcout << *p << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n> 总结：空指针和野指针都不是我们申请的空间，因此不要访问。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 7.5 const修饰指针\r\n\r\nconst修饰指针有三种情况\r\n\r\n1. const修饰指针   --- 常量指针\r\n2. const修饰常量   --- 指针常量\r\n3. const即修饰指针，又修饰常量\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n\r\n```c++\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 10;\r\n\r\n\t//const修饰的是指针，指针指向可以改，指针指向的值不可以更改\r\n\tconst int * p1 = &a; \r\n\tp1 = &b; //正确\r\n\t//*p1 = 100;  报错\r\n\t\r\n\r\n\t//const修饰的是常量，指针指向不可以改，指针指向的值可以更改\r\n\tint * const p2 = &a;\r\n\t//p2 = &b; //错误\r\n\t*p2 = 100; //正确\r\n\r\n    //const既修饰指针又修饰常量\r\n\tconst int * const p3 = &a;\r\n\t//p3 = &b; //错误\r\n\t//*p3 = 100; //错误\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 7.6 指针和数组\r\n\r\n**作用：**利用指针访问数组中元素\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint arr[] = { 1,2,3,4,5,6,7,8,9,10 };\r\n\r\n\tint * p = arr;  //指向数组的指针\r\n\r\n\tcout << \"第一个元素： \" << arr[0] << endl;\r\n\tcout << \"指针访问第一个元素： \" << *p << endl;\r\n\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\t//利用指针遍历数组\r\n\t\tcout << *p << endl;\r\n\t\tp++;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 7.7 指针和函数\r\n\r\n**作用：**利用指针作函数参数，可以修改实参的值\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//值传递\r\nvoid swap1(int a ,int b)\r\n{\r\n\tint temp = a;\r\n\ta = b; \r\n\tb = temp;\r\n}\r\n//地址传递\r\nvoid swap2(int * p1, int *p2)\r\n{\r\n\tint temp = *p1;\r\n\t*p1 = *p2;\r\n\t*p2 = temp;\r\n}\r\n\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 20;\r\n\tswap1(a, b); // 值传递不会改变实参\r\n\r\n\tswap2(&a, &b); //地址传递会改变实参\r\n\r\n\tcout << \"a = \" << a << endl;\r\n\r\n\tcout << \"b = \" << b << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 7.8 指针、数组、函数\r\n\r\n**案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序\r\n\r\n例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```c++\r\n//冒泡排序函数\r\nvoid bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]\r\n{\r\n\tfor (int i = 0; i < len - 1; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < len - 1 - i; j++)\r\n\t\t{\r\n\t\t\tif (arr[j] > arr[j + 1])\r\n\t\t\t{\r\n\t\t\t\tint temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j + 1];\r\n\t\t\t\tarr[j + 1] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//打印数组函数\r\nvoid printArray(int arr[], int len)\r\n{\r\n\tfor (int i = 0; i < len; i++)\r\n\t{\r\n\t\tcout << arr[i] << endl;\r\n\t}\r\n}\r\n\r\nint main() {\r\n\r\n\tint arr[10] = { 4,3,6,9,1,2,10,8,7,5 };\r\n\tint len = sizeof(arr) / sizeof(int);\r\n\r\n\tbubbleSort(arr, len);\r\n\r\n\tprintArray(arr, len);\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 8 结构体\r\n\r\n### 8.1 结构体基本概念\r\n\r\n结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型\r\n\r\n\r\n\r\n### 8.2 结构体定义和使用\r\n\r\n**语法：**`struct 结构体名 { 结构体成员列表 }；`\r\n\r\n通过结构体创建变量的方式有三种：\r\n\r\n* struct 结构体名 变量名\r\n* struct 结构体名 变量名 = { 成员1值 ， 成员2值...}\r\n* 定义结构体时顺便创建变量\r\n\r\n**示例：**\r\n\r\n```C++\r\n//结构体定义\r\nstruct student\r\n{\r\n\t//成员列表\r\n\tstring name;  //姓名\r\n\tint age;      //年龄\r\n\tint score;    //分数\r\n}stu3; //结构体变量创建方式3 \r\n\r\n\r\nint main() {\r\n\r\n\t//结构体变量创建方式1\r\n\tstruct student stu1; //struct 关键字可以省略\r\n\r\n\tstu1.name = \"张三\";\r\n\tstu1.age = 18;\r\n\tstu1.score = 100;\r\n\t\r\n\tcout << \"姓名：\" << stu1.name << \" 年龄：\" << stu1.age  << \" 分数：\" << stu1.score << endl;\r\n\r\n\t//结构体变量创建方式2\r\n\tstruct student stu2 = { \"李四\",19,60 };\r\n\r\n\tcout << \"姓名：\" << stu2.name << \" 年龄：\" << stu2.age  << \" 分数：\" << stu2.score << endl;\r\n\r\n\r\n\tstu3.name = \"王五\";\r\n\tstu3.age = 18;\r\n\tstu3.score = 80;\r\n\t\r\n\r\n\tcout << \"姓名：\" << stu3.name << \" 年龄：\" << stu3.age  << \" 分数：\" << stu3.score << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结1：定义结构体时的关键字是struct，不可省略\r\n\r\n> 总结2：创建结构体变量时，关键字struct可以省略\r\n\r\n> 总结3：结构体变量利用操作符 ''.''  访问成员\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 8.3 结构体数组\r\n\r\n**作用：**将自定义的结构体放入到数组中方便维护\r\n\r\n**语法：**` struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }`\r\n\r\n**示例：**\r\n\r\n```C++\r\n//结构体定义\r\nstruct student\r\n{\r\n\t//成员列表\r\n\tstring name;  //姓名\r\n\tint age;      //年龄\r\n\tint score;    //分数\r\n}\r\n\r\nint main() {\r\n\t\r\n\t//结构体数组\r\n\tstruct student arr[3]=\r\n\t{\r\n\t\t{\"张三\",18,80 },\r\n\t\t{\"李四\",19,60 },\r\n\t\t{\"王五\",20,70 }\r\n\t};\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tcout << \"姓名：\" << arr[i].name << \" 年龄：\" << arr[i].age << \" 分数：\" << arr[i].score << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 8.4 结构体指针\r\n\r\n**作用：**通过指针访问结构体中的成员\r\n\r\n\r\n\r\n* 利用操作符 `-> `可以通过结构体指针访问结构体属性\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//结构体定义\r\nstruct student\r\n{\r\n\t//成员列表\r\n\tstring name;  //姓名\r\n\tint age;      //年龄\r\n\tint score;    //分数\r\n};\r\n\r\n\r\nint main() {\r\n\t\r\n\tstruct student stu = { \"张三\",18,100, };\r\n\t\r\n\tstruct student * p = &stu;\r\n\t\r\n\tp->score = 80; //指针通过 -> 操作符可以访问成员\r\n\r\n\tcout << \"姓名：\" << p->name << \" 年龄：\" << p->age << \" 分数：\" << p->score << endl;\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：结构体指针可以通过 -> 操作符 来访问结构体中的成员\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 8.5 结构体嵌套结构体\r\n\r\n**作用：** 结构体中的成员可以是另一个结构体\r\n\r\n**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体\r\n\r\n**示例：**\r\n\r\n```C++\r\n//学生结构体定义\r\nstruct student\r\n{\r\n\t//成员列表\r\n\tstring name;  //姓名\r\n\tint age;      //年龄\r\n\tint score;    //分数\r\n};\r\n\r\n//教师结构体定义\r\nstruct teacher\r\n{\r\n    //成员列表\r\n\tint id; //职工编号\r\n\tstring name;  //教师姓名\r\n\tint age;   //教师年龄\r\n\tstruct student stu; //子结构体 学生\r\n};\r\n\r\n\r\nint main() {\r\n\r\n\tstruct teacher t1;\r\n\tt1.id = 10000;\r\n\tt1.name = \"老王\";\r\n\tt1.age = 40;\r\n\r\n\tt1.stu.name = \"张三\";\r\n\tt1.stu.age = 18;\r\n\tt1.stu.score = 100;\r\n\r\n\tcout << \"教师 职工编号： \" << t1.id << \" 姓名： \" << t1.name << \" 年龄： \" << t1.age << endl;\r\n\t\r\n\tcout << \"辅导学员 姓名： \" << t1.stu.name << \" 年龄：\" << t1.stu.age << \" 考试分数： \" << t1.stu.score << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 8.6 结构体做函数参数 \r\n\r\n**作用：**将结构体作为参数向函数中传递\r\n\r\n传递方式有两种：\r\n\r\n* 值传递\r\n* 地址传递\r\n\r\n**示例：**\r\n\r\n```C++\r\n//学生结构体定义\r\nstruct student\r\n{\r\n\t//成员列表\r\n\tstring name;  //姓名\r\n\tint age;      //年龄\r\n\tint score;    //分数\r\n};\r\n\r\n//值传递\r\nvoid printStudent(student stu )\r\n{\r\n\tstu.age = 28;\r\n\tcout << \"子函数中 姓名：\" << stu.name << \" 年龄： \" << stu.age  << \" 分数：\" << stu.score << endl;\r\n}\r\n\r\n//地址传递\r\nvoid printStudent2(student *stu)\r\n{\r\n\tstu->age = 28;\r\n\tcout << \"子函数中 姓名：\" << stu->name << \" 年龄： \" << stu->age  << \" 分数：\" << stu->score << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\tstudent stu = { \"张三\",18,100};\r\n\t//值传递\r\n\tprintStudent(stu);\r\n\tcout << \"主函数中 姓名：\" << stu.name << \" 年龄： \" << stu.age << \" 分数：\" << stu.score << endl;\r\n\r\n\tcout << endl;\r\n\r\n\t//地址传递\r\n\tprintStudent2(&stu);\r\n\tcout << \"主函数中 姓名：\" << stu.name << \" 年龄： \" << stu.age  << \" 分数：\" << stu.score << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 8.7 结构体中 const使用场景\r\n\r\n**作用：**用const来防止误操作\r\n\r\n**示例：**\r\n\r\n```C++\r\n//学生结构体定义\r\nstruct student\r\n{\r\n\t//成员列表\r\n\tstring name;  //姓名\r\n\tint age;      //年龄\r\n\tint score;    //分数\r\n};\r\n\r\n//const使用场景\r\nvoid printStudent(const student *stu) //加const防止函数体中的误操作\r\n{\r\n\t//stu->age = 100; //操作失败，因为加了const修饰\r\n\tcout << \"姓名：\" << stu->name << \" 年龄：\" << stu->age << \" 分数：\" << stu->score << endl;\r\n\r\n}\r\n\r\nint main() {\r\n\r\n\tstudent stu = { \"张三\",18,100 };\r\n\r\n\tprintStudent(&stu);\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 8.8 结构体案例\r\n\r\n#### 8.8.1 案例1\r\n\r\n**案例描述：**\r\n\r\n学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下\r\n\r\n设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员\r\n\r\n学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值\r\n\r\n最终打印出老师数据以及老师所带的学生数据。\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nstruct Student\r\n{\r\n\tstring name;\r\n\tint score;\r\n};\r\nstruct Teacher\r\n{\r\n\tstring name;\r\n\tStudent sArray[5];\r\n};\r\n\r\nvoid allocateSpace(Teacher tArray[] , int len)\r\n{\r\n\tstring tName = \"教师\";\r\n\tstring sName = \"学生\";\r\n\tstring nameSeed = \"ABCDE\";\r\n\tfor (int i = 0; i < len; i++)\r\n\t{\r\n\t\ttArray[i].name = tName + nameSeed[i];\r\n\t\t\r\n\t\tfor (int j = 0; j < 5; j++)\r\n\t\t{\r\n\t\t\ttArray[i].sArray[j].name = sName + nameSeed[j];\r\n\t\t\ttArray[i].sArray[j].score = rand() % 61 + 40;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid printTeachers(Teacher tArray[], int len)\r\n{\r\n\tfor (int i = 0; i < len; i++)\r\n\t{\r\n\t\tcout << tArray[i].name << endl;\r\n\t\tfor (int j = 0; j < 5; j++)\r\n\t\t{\r\n\t\t\tcout << \"\\t姓名：\" << tArray[i].sArray[j].name << \" 分数：\" << tArray[i].sArray[j].score << endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main() {\r\n\r\n\tsrand((unsigned int)time(NULL)); //随机数种子 头文件 #include <ctime>\r\n\r\n\tTeacher tArray[3]; //老师数组\r\n\r\n\tint len = sizeof(tArray) / sizeof(Teacher);\r\n\r\n\tallocateSpace(tArray, len); //创建数据\r\n\r\n\tprintTeachers(tArray, len); //打印数据\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 8.8.2 案例2\r\n\r\n**案例描述：**\r\n\r\n设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。\r\n\r\n通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。\r\n\r\n\r\n\r\n五名英雄信息如下：\r\n\r\n```C++\r\n\t\t{\"刘备\",23,\"男\"},\r\n\t\t{\"关羽\",22,\"男\"},\r\n\t\t{\"张飞\",20,\"男\"},\r\n\t\t{\"赵云\",21,\"男\"},\r\n\t\t{\"貂蝉\",19,\"女\"},\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//英雄结构体\r\nstruct hero\r\n{\r\n\tstring name;\r\n\tint age;\r\n\tstring sex;\r\n};\r\n//冒泡排序\r\nvoid bubbleSort(hero arr[] , int len)\r\n{\r\n\tfor (int i = 0; i < len - 1; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < len - 1 - i; j++)\r\n\t\t{\r\n\t\t\tif (arr[j].age > arr[j + 1].age)\r\n\t\t\t{\r\n\t\t\t\thero temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j + 1];\r\n\t\t\t\tarr[j + 1] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n//打印数组\r\nvoid printHeros(hero arr[], int len)\r\n{\r\n\tfor (int i = 0; i < len; i++)\r\n\t{\r\n\t\tcout << \"姓名： \" << arr[i].name << \" 性别： \" << arr[i].sex << \" 年龄： \" << arr[i].age << endl;\r\n\t}\r\n}\r\n\r\nint main() {\r\n\r\n\tstruct hero arr[5] =\r\n\t{\r\n\t\t{\"刘备\",23,\"男\"},\r\n\t\t{\"关羽\",22,\"男\"},\r\n\t\t{\"张飞\",20,\"男\"},\r\n\t\t{\"赵云\",21,\"男\"},\r\n\t\t{\"貂蝉\",19,\"女\"},\r\n\t};\r\n\r\n\tint len = sizeof(arr) / sizeof(hero); //获取数组元素个数\r\n\r\n\tbubbleSort(arr, len); //排序\r\n\r\n\tprintHeros(arr, len); //打印\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n# "
        },
        {
          "name": "C++学习笔记.md",
          "type": "blob",
          "size": 26.6962890625,
          "content": "# C++学习笔记\n\n## 一、基础知识\n\n## [📎C++基础入门.md](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md)\n\n### 1、goto 语句(不建议使用)\n\n**作用：** 可以无条件的跳转语句\n\n**语法：** `goto 标记;`\n\n**解释：** 如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n\n```cpp\nint main() {\n    cout << 1 << endl;\n    cout << 2 << endl;\n    goto FLAG;\n    cout << 3 << endl;\n    cout << 4 << endl;\n    FLAG:\n    cout << 5 << endl;\n    return 0;\n}\n```\n\n### 2、一维数组\n\n一维数组名称的**用途**\n\n1. 可以统计整个数组在内存中的长度\n2. 可以获取数组在内存中的首地址\n\n\n\n**示例：**\n\n```cpp\nint main() {\n\n\t//数组名用途\n\t//1、可以获取整个数组占用内存空间大小\n\tint arr[10] = { 1,2,3,4,5,6,7,8,9,10 };\n\n\tcout << \"整个数组所占内存空间为： \" << sizeof(arr) << endl;\n\tcout << \"每个元素所占内存空间为： \" << sizeof(arr[0]) << endl;\n\tcout << \"数组的元素个数为： \" << sizeof(arr) / sizeof(arr[0]) << endl;\n\n\t//2、可以通过数组名获取到数组首地址\n\tcout << \"数组首地址为： \" << (int)arr << endl;\n\tcout << \"数组中第一个元素地址为： \" << (int)&arr[0] << endl;\n\tcout << \"数组中第二个元素地址为： \" << (int)&arr[1] << endl;\n\n\t//arr = 100; 错误，数组名是常量，因此不可以赋值\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n注意：数组名是常量，不可以赋值\n\n总结1：直接打印数组名，可以查看数组所占内存的首地址\n\n总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小\n\n\n\n### 3、二维数组\n\n\n\n二维数组定义的四种方式：\n\n1. `数据类型 数组名[ 行数 ][ 列数 ];`\n2. `数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`\n3. `数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};`\n4. `数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4};`\n\n- 查看二维数组所占内存空间\n- 获取二维数组首地址\n\n```cpp\nint main() {\n\n\t//二维数组数组名\n\tint arr[2][3] =\n\t{\n\t\t{1,2,3},\n\t\t{4,5,6}\n\t};\n\n\tcout << \"二维数组大小： \" << sizeof(arr) << endl;\n\tcout << \"二维数组一行大小： \" << sizeof(arr[0]) << endl;\n\tcout << \"二维数组元素大小： \" << sizeof(arr[0][0]) << endl;\n\n\tcout << \"二维数组行数： \" << sizeof(arr) / sizeof(arr[0]) << endl;\n\tcout << \"二维数组列数： \" << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;\n\n\t//地址\n\tcout << \"二维数组首地址：\" << arr << endl;\n\tcout << \"二维数组第一行地址：\" << arr[0] << endl;\n\tcout << \"二维数组第二行地址：\" << arr[1] << endl;\n\n\tcout << \"二维数组第一个元素地址：\" << &arr[0][0] << endl;\n\tcout << \"二维数组第二个元素地址：\" << &arr[0][1] << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结1：二维数组名就是这个数组的首地址\n\n总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\n\n\n\n### 4、函数中的值传递\n\n- 所谓值传递，就是函数调用时实参将数值传入给形参\n- 值传递时，如果形参发生，并不会影响实参(注意：和Java中不同)\n\n```cpp\nvoid swap(int num1, int num2)\n{\n\tcout << \"交换前：\" << endl;\n\tcout << \"num1 = \" << num1 << endl;\n\tcout << \"num2 = \" << num2 << endl;\n\n\tint temp = num1;\n\tnum1 = num2;\n\tnum2 = temp;\n\n\tcout << \"交换后：\" << endl;\n\tcout << \"num1 = \" << num1 << endl;\n\tcout << \"num2 = \" << num2 << endl;\n\n\t//return ; 当函数声明时候，不需要返回值，可以不写return\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tswap(a, b);\n\n\tcout << \"mian中的 a = \" << a << endl;\n\tcout << \"mian中的 b = \" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结： 值传递时，形参是修饰不了实参的\n\n\n\n### 5、函数的声明\n\n\n\n**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n\n- 函数的**声明可以多次**，但是函数的**定义只能有一次**\n\n\n\n**(在C中，如果不自定义函数在main方法之后定义，如果main方法调用了此函数，则main方法找不到此函数，因此需要提前声明)**\n\n和Java中不同\n\n\n\n### 6、函数的分文件编写\n\n\n\n**作用：** 让代码结构更加清晰\n\n函数分文件编写一般有4个步骤\n\n1. 创建后缀名为.h的头文件  \n2. 创建后缀名为.cpp的源文件\n\n1. 在头文件中写函数的声明\n2. 在源文件中写函数的定义\n\n\n\n**示例：**\n\n```cpp\n//swap.h文件\n#include<iostream>\nusing namespace std;\n\n//实现两个数字交换的函数声明\nvoid swap(int a, int b);\n//swap.cpp文件\n#include \"swap.h\"\n\nvoid swap(int a, int b)\n{\n\tint temp = a;\n\ta = b;\n\tb = temp;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n}\n//main函数文件\n#include \"swap.h\"\nint main() {\n\n\tint a = 100;\n\tint b = 200;\n\tswap(a, b);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n### 7、指针\n\n\n\n#### 7.1 指针的基本概念\n\n**指针的作用：** 可以通过指针间接访问内存\n\n- 内存编号是从0开始记录的，一般用十六进制数字表示\n- 可以利用指针变量保存地址\n\n\n\n#### 7.2 指针变量的定义和使用\n\n指针变量定义语法： `数据类型 * 变量名;`\n\n**示例：**\n\n```cpp\nint main() {\n\n\t//1、指针的定义\n\tint a = 10; //定义整型变量a\n\t\n\t//指针定义语法： 数据类型 * 变量名 ;\n\tint * p;\n\n\t//指针变量赋值\n\tp = &a; //指针指向变量a的地址\n\tcout << &a << endl; //打印数据a的地址\n\tcout << p << endl;  //打印指针变量p\n\n\t//2、指针的使用\n\t//通过*操作指针变量指向的内存\n\tcout << \"*p = \" << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n指针变量和普通变量的区别\n\n- 普通变量存放的是数据,指针变量存放的是地址\n- 指针变量可以通过\" * \"操作符，操作指针变量指向的内存空间，这个过程称为解引用\n\n总结1： 我们可以通过 & 符号 获取变量的地址\n\n总结2：利用指针可以记录地址\n\n总结3：对指针变量解引用，可以操作指针指向的内存\n\n\n\n#### 7.3 指针所占内存空间\n\n提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？\n\n**示例：**\n\n```cpp\nint main() {\n\n\tint a = 10;\n\n\tint * p;\n\tp = &a; //指针指向数据a的地址\n\n\tcout << *p << endl; //* 解引用\n\tcout << sizeof(p) << endl;\n\tcout << sizeof(char *) << endl;\n\tcout << sizeof(float *) << endl;\n\tcout << sizeof(double *) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：所有指针类型在32位操作系统下是4个字节，64位操作系统为8个字节\n\n#### 7.4 空指针和野指针\n\n**空指针**：指针变量指向内存中编号为0的空间\n\n**用途：** 初始化指针变量\n\n**注意：** 空指针指向的内存是不可以访问的\n\n\n**示例1：空指针**\n\n```cpp\nint main() {\n\n\t//指针变量p指向内存地址编号为0的空间\n\tint * p = NULL;\n\n\t//访问空指针报错 \n\t//内存编号0 ~255为系统占用内存，不允许用户访问\n\tcout << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**野指针**：指针变量指向非法的内存空间\n\n**示例2：野指针**\n\n```cpp\nint main() {\n\n\t//指针变量p指向内存地址编号为0x1100的空间\n\tint * p = (int *)0x1100;\n\n\t//访问野指针报错 \n\tcout << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：空指针和野指针都不是我们申请的空间，因此不要访问。\n\n\n#### 7.5 const修饰指针\n\n\nconst修饰指针有三种情况\n\n1. const修饰指针   --- 常量指针\n2. const修饰常量   --- 指针常量\n\n1. const既修饰指针，又修饰常量\n\n\n**示例：**\n\n```cpp\nint main() {\n\n\tint a = 10;\n\tint b = 10;\n\n\t//const修饰的是指针，指针指向可以改，指针指向的值不可以更改\n\tconst int * p1 = &a; \n\tp1 = &b; //正确\n\t//*p1 = 100;  报错\n\t\n\n\t//const修饰的是常量，指针指向不可以改，指针指向的值可以更改\n\tint * const p2 = &a;\n\t//p2 = &b; //错误\n\t*p2 = 100; //正确\n\n    //const既修饰指针又修饰常量\n\tconst int * const p3 = &a;\n\t//p3 = &b; //错误\n\t//*p3 = 100; //错误\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量\n\n\n\n#### 7.6 指针和数组\n\n\n\n**作用：** 利用指针访问数组中元素\n\n**示例：**\n\n```cpp\nint main() {\n\n\tint arr[] = { 1,2,3,4,5,6,7,8,9,10 };\n\n\tint * p = arr;  //指向数组的指针\n\n\tcout << \"第一个元素： \" << arr[0] << endl;\n\tcout << \"指针访问第一个元素： \" << *p << endl;\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\t//利用指针遍历数组\n\t\tcout << *p << endl;\n\t\tp++;\n\t}\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n#### 7.7 指针和函数\n\n**作用：** 利用指针作函数参数，可以修改实参的值(和前边形参相反)\n\n\n\n**示例：**\n\n```cpp\n//值传递\nvoid swap1(int a ,int b)\n{\n\tint temp = a;\n\ta = b; \n\tb = temp;\n}\n//地址传递\nvoid swap2(int * p1, int *p2)\n{\n\tint temp = *p1;\n\t*p1 = *p2;\n\t*p2 = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\tswap1(a, b); // 值传递不会改变实参\n\n\tswap2(&a, &b); //地址传递会改变实参\n\n\tcout << \"a = \" << a << endl;\n\n\tcout << \"b = \" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递\n\n\n\n#### 7.8 指针、数组、函数\n\n\n\n**案例描述：** 封装一个函数，利用冒泡排序，实现对整型数组的升序排序\n\n例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };\n\n\n\n**示例：**\n\n```cpp\n//冒泡排序函数\nvoid bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]\n{\n\tfor (int i = 0; i < len - 1; i++)\n\t{\n\t\tfor (int j = 0; j < len - 1 - i; j++)\n\t\t{\n\t\t\tif (arr[j] > arr[j + 1])\n\t\t\t{\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//打印数组函数\nvoid printArray(int arr[], int len)\n{\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n}\n\nint main() {\n\n\tint arr[10] = { 4,3,6,9,1,2,10,8,7,5 };\n\tint len = sizeof(arr) / sizeof(int);\n\n\tbubbleSort(arr, len);\n\n\tprintArray(arr, len);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n### 8、结构体\n\n\n\n#### 8.1 结构体基本概念\n\n结构体属于用户 自定义的数据类型，允许用户存储不同的数据类型\n\n(跟Java中的对象比较像，但是只有属性，没有方法。下面其他的结构体使用，都可以类比Java中对象的使用)\n\n\n\n#### 8.2 结构体定义和使用\n\n**语法：** `struct 结构体名 { 结构体成员列表 }；`\n\n通过结构体创建变量的方式有三种：\n\n- struct 结构体名 变量名\n- struct 结构体名 变量名 = { 成员1值 ， 成员2值...}\n\n- 定义结构体时顺便创建变量\n- \n\n**示例：**\n\n```cpp\n//结构体定义\nstruct student\n{\n\t//成员列表\n\tstring name;  //姓名\n\tint age;      //年龄\n\tint score;    //分数\n}stu3; //结构体变量创建方式3 \n\n\nint main() {\n\n\t//结构体变量创建方式1\n\tstruct student stu1; //struct 关键字可以省略\n\n\tstu1.name = \"张三\";\n\tstu1.age = 18;\n\tstu1.score = 100;\n\t\n\tcout << \"姓名：\" << stu1.name << \" 年龄：\" << stu1.age  << \" 分数：\" << stu1.score << endl;\n\n\t//结构体变量创建方式2\n\tstruct student stu2 = { \"李四\",19,60 };\n\n\tcout << \"姓名：\" << stu2.name << \" 年龄：\" << stu2.age  << \" 分数：\" << stu2.score << endl;\n\n\n\tstu3.name = \"王五\";\n\tstu3.age = 18;\n\tstu3.score = 80;\n\t\n\n\tcout << \"姓名：\" << stu3.name << \" 年龄：\" << stu3.age  << \" 分数：\" << stu3.score << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结1：定义结构体时的关键字是struct，不可省略\n\n总结2：创建结构体变量时，关键字struct可以省略\n\n总结3：结构体变量利用操作符 ''.''  访问成员\n\n\n\n#### 8.3 结构体数组\n\n**作用：** 将自定义的结构体放入到数组中方便维护\n\n**语法：** `struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }`\n\n\n\n**示例：**\n\n```cpp\n//结构体定义\nstruct student\n{\n\t//成员列表\n\tstring name;  //姓名\n\tint age;      //年龄\n\tint score;    //分数\n}\n\nint main() {\n\t\n\t//结构体数组\n\tstruct student arr[3]=\n\t{\n\t\t{\"张三\",18,80 },\n\t\t{\"李四\",19,60 },\n\t\t{\"王五\",20,70 }\n\t};\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tcout << \"姓名：\" << arr[i].name << \" 年龄：\" << arr[i].age << \" 分数：\" << arr[i].score << endl;\n\t}\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n#### 8.4 结构体指针\n\n**作用：** 通过指针访问结构体中的成员\n\n- 利用操作符 `->`可以通过结构体指针访问结构体属性\n\n\n\n**示例：**\n\n```cpp\n//结构体定义\nstruct student\n{\n\t//成员列表\n\tstring name;  //姓名\n\tint age;      //年龄\n\tint score;    //分数\n};\n\n\nint main() {\n\t\n\tstruct student stu = { \"张三\",18,100, };\n\t\n\tstruct student * p = &stu;\n\t\n\tp->score = 80; //指针通过 -> 操作符可以访问成员\n\n\tcout << \"姓名：\" << p->name << \" 年龄：\" << p->age << \" 分数：\" << p->score << endl;\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：结构体指针可以通过 -> 操作符 来访问结构体中的成员\n\n\n\n#### 8.5 结构体嵌套结构体\n\n**作用：** 结构体中的成员可以是另一个结构体\n\n**例如：** 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体\n\n**示例：**\n\n```cpp\n//学生结构体定义struct student{\t//成员列表\tstring name;  //姓名\tint age;      //年龄\tint score;    //分数};//教师结构体定义struct teacher{    //成员列表\tint id; //职工编号\tstring name;  //教师姓名\tint age;   //教师年龄\tstruct student stu; //子结构体 学生};int main() {\tstruct teacher t1;\tt1.id = 10000;\tt1.name = \"老王\";\tt1.age = 40;\tt1.stu.name = \"张三\";\tt1.stu.age = 18;\tt1.stu.score = 100;\tcout << \"教师 职工编号： \" << t1.id << \" 姓名： \" << t1.name << \" 年龄： \" << t1.age << endl;\t\tcout << \"辅导学员 姓名： \" << t1.stu.name << \" 年龄：\" << t1.stu.age << \" 考试分数： \" << t1.stu.score << endl;\tsystem(\"pause\");\treturn 0;}\n```\n\n**总结：** 在结构体中可以定义另一个结构体作为成员，用来解决实际问题\n\n\n\n\n\n#### 8.6 结构体做函数参数 \n\n**作用：** 将结构体作为参数向函数中传递\n\n传递方式有两种：\n\n- 值传递\n- 地址传递\n\n**示例：**\n\n```cpp\n//学生结构体定义\nstruct student\n{\n\t//成员列表\n\tstring name;  //姓名\n\tint age;      //年龄\n\tint score;    //分数\n};\n\n//值传递\nvoid printStudent(student stu )\n{\n\tstu.age = 28;\n\tcout << \"子函数中 姓名：\" << stu.name << \" 年龄： \" << stu.age  << \" 分数：\" << stu.score << endl;\n}\n\n//地址传递\nvoid printStudent2(student *stu)\n{\n\tstu->age = 28;\n\tcout << \"子函数中 姓名：\" << stu->name << \" 年龄： \" << stu->age  << \" 分数：\" << stu->score << endl;\n}\n\nint main() {\n\n\tstudent stu = { \"张三\",18,100};\n\t//值传递\n\tprintStudent(stu);\n\tcout << \"主函数中 姓名：\" << stu.name << \" 年龄： \" << stu.age << \" 分数：\" << stu.score << endl;\n\n\tcout << endl;\n\n\t//地址传递\n\tprintStudent2(&stu);\n\tcout << \"主函数中 姓名：\" << stu.name << \" 年龄： \" << stu.age  << \" 分数：\" << stu.score << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：如果不想修改主函数中的数据，用值传递，反之用地址传递\n\n\n\n#### 8.7 结构体中 const使用场景\n\n**作用：** 用const来防止误操作\n\n**示例：**\n\n```cpp\n//学生结构体定义\nstruct student\n{\n\t//成员列表\n\tstring name;  //姓名\n\tint age;      //年龄\n\tint score;    //分数\n};\n\n//const使用场景\nvoid printStudent(const student *stu) //加const防止函数体中的误操作\n{\n\t//stu->age = 100; //操作失败，因为加了const修饰\n\tcout << \"姓名：\" << stu->name << \" 年龄：\" << stu->age << \" 分数：\" << stu->score << endl;\n\n}\n\nint main() {\n\n\tstudent stu = { \"张三\",18,100 };\n\n\tprintStudent(&stu);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n## 二、核心编程\n\nC++中的面向对象编程（笑）\n\n## [📎C++核心编程.md](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.md)\n\n\n\n### 1、内存分区模型\n\nC++程序在执行时，将内存大方向划分为**4个区域**\n\n- 代码区：存放函数体的二进制代码，由操作系统进行管理的\n- 全局区：存放全局变量和静态变量以及常量\n\n- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n\n\n**内存四区意义：**\n\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n\n\n#### 1.1 程序运行前\n\n在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\n\n- 代码区：\n\n- - 存放 CPU 执行的机器指令\n  - 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\n- - 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\n\n- 全局区：\n\n- - 全局变量和静态变量存放在此\n  - 全局区还包含了常量区, 字符串常量和其他常量也存放在此\n\n- - 该区域的数据在程序结束后由操作系统释放\n\n\n\n**示例：**\n\n```cpp\n//全局变量\nint g_a = 10;\nint g_b = 10;\n\n//全局常量\nconst int c_g_a = 10;\nconst int c_g_b = 10;\n\nint main() {\n\n\t//局部变量\n\tint a = 10;\n\tint b = 10;\n\n\t//打印地址\n\tcout << \"局部变量a地址为： \" << (int)&a << endl;\n\tcout << \"局部变量b地址为： \" << (int)&b << endl;\n\n\tcout << \"全局变量g_a地址为： \" <<  (int)&g_a << endl;\n\tcout << \"全局变量g_b地址为： \" <<  (int)&g_b << endl;\n\n\t//静态变量\n\tstatic int s_a = 10;\n\tstatic int s_b = 10;\n\n\tcout << \"静态变量s_a地址为： \" << (int)&s_a << endl;\n\tcout << \"静态变量s_b地址为： \" << (int)&s_b << endl;\n\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world\" << endl;\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world1\" << endl;\n\n\tcout << \"全局常量c_g_a地址为： \" << (int)&c_g_a << endl;\n\tcout << \"全局常量c_g_b地址为： \" << (int)&c_g_b << endl;\n\n\tconst int c_l_a = 10;\n\tconst int c_l_b = 10;\n\tcout << \"局部常量c_l_a地址为： \" << (int)&c_l_a << endl;\n\tcout << \"局部常量c_l_b地址为： \" << (int)&c_l_b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n![img](https://cdn.nlark.com/yuque/0/2021/png/2797977/1627450152945-bd009327-0c74-498d-8950-d300ec297b88.png)\n\n总结：\n\n- C++中在程序运行前分为全局区和代码区\n- 代码区特点是共享和只读\n\n- 全局区中存放全局变量、静态变量、常量\n- 常量区中存放 const修饰的全局常量  和 字符串常量\n\n\n\n\n\n#### 1.2 程序运行后\n\n**栈区：**\n\n- 由编译器自动分配释放, 存放函数的参数值,局部变量等\n- 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n\n\n**示例：**  \n\n```cpp\nint * func()\n{\n\tint a = 10;\n\treturn &a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n**堆区：**\n\n- 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n- 在C++中主要利用new在堆区开辟内存\n\n\n**示例：**\n\n```cpp\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n    \n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n- 堆区数据由程序员管理开辟和释放\n- 堆区数据利用new关键字进行开辟内存\n\n\n\n\n\n#### 1.3 new操作符\n\n- C++中利用 new 操作符在堆区开辟数据\n- 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete \n\n- 语法：`new 数据类型`\n- 利用new创建的数据，会返回该数据对应的类型的指针\n\n\n\n**示例1： 基本语法**\n\n```cpp\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\t//利用delete释放堆区数据\n\tdelete p;\n\n\t//cout << *p << endl; //报错，释放的空间不可访问\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：开辟数组**\n\n```cpp\n//堆区开辟数组\nint main() {\n\n\tint* arr = new int[10];\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tarr[i] = i + 100;\n\t}\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n\t//释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n### 2、引用\n\n\n#### 2.1 引用的基本使用\n\n**作用：** 给变量起别名\n\n**语法：** `数据类型 &别名 = 原名`\n\n**示例：**\n\n```cpp\nint main() {\n\n\tint a = 10;\n\tint &b = a;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tb = 100;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n#### 2.2 引用注意事项\n\n- 引用必须初始化\n- 引用在初始化后，不可以改变\n\n\n**示例：**\n\n```cpp\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\t//int &c; //错误，引用必须初始化\n\tint &c = a; //一旦初始化后，就不可以更改\n\tc = b; //这是赋值操作，不是更改引用\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\tcout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 2.3 引用做函数参数\n\n**作用：** 函数传参时，可以利用引用的技术让形参修饰实参\n\n**优点：** 可以简化指针修改实参\n\n**示例：**\n\n```cpp\n//1. 值传递\nvoid mySwap01(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2. 地址传递\nvoid mySwap02(int* a, int* b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//3. 引用传递\nvoid mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tmySwap01(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap02(&a, &b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap03(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n\n\n#### 2.4 引用做函数返回值\n\n\n**作用：** 引用是可以作为函数的返回值存在的\n\n**注意：** **不要返回局部变量引用**\n\n**用法：** 函数调用作为左值\n\n\n\n**示例：**\n\n```cpp\n//返回局部变量引用\nint& test01() {\n\tint a = 10; //局部变量\n\treturn a;\n}\n\n//返回静态变量引用\nint& test02() {\n\tstatic int a = 20;\n\treturn a;\n}\n\nint main() {\n\n\t//不能返回局部变量的引用\n\tint& ref = test01();\n\tcout << \"ref = \" << ref << endl;\n\tcout << \"ref = \" << ref << endl;\n\n\t//如果函数做左值，那么必须返回引用\n\tint& ref2 = test02();\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\ttest02() = 1000;\n\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n#### 2.5 引用的本质\n\n本质：**引用的本质在c++内部实现是一个指针常量.**\n\n讲解示例：\n\n```cpp\n//发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n    \n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint& ref = a; \n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n    \n\tcout << \"a:\" << a << endl;\n\tcout << \"ref:\" << ref << endl;\n    \n\tfunc(a);\n\treturn 0;\n}\n```\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n\n\n\n\n\n\n\n#### 2.6 常量引用\n\n**作用：** 常量引用主要用来修饰形参，防止误操作\n\n在函数形参列表中，可以加const修饰形参，防止形参改变实参\n\n**示例：**\n\n```cpp\n//引用使用的场景，通常用来修饰形参\nvoid showValue(const int& v) {\n\t//v += 10;\n\tcout << v << endl;\n}\n\nint main() {\n\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\n\t//ref = 100;  //加入const后不可以修改变量\n\tcout << ref << endl;\n\n\t//函数中利用常量引用防止误操作修改实参\n\tint a = 10;\n\tshowValue(a);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n### 3、函数\n\n#### 3.1 函数默认参数\n\n在C++中，函数的形参列表中的形参是可以有默认值的。\n\n语法：`返回值类型  函数名 （参数= 默认值）{}`\n\n**示例：**\n\n```cpp\nint func(int a, int b = 10, int c = 10) {\n\treturn a + b + c;\n}\n\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a = 10, int b = 10);\nint func2(int a, int b) {\n\treturn a + b;\n}\n\nint main() {\n\n\tcout << \"ret = \" << func(20, 20) << endl;\n\tcout << \"ret = \" << func(100) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 3.2 函数占位参数\n\nC++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n\n**语法：** `返回值类型 函数名 (数据类型){}`\n\n**示例：**\n\n```cpp\n//函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) {\n\tcout << \"this is func\" << endl;\n}\n\nint main() {\n\n\tfunc(10,10); //占位参数必须填补\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 3.3 函数重载\n\n##### 3.3.1 函数重载概述\n\n**作用：** 函数名可以相同，提高复用性\n\n\n**函数重载满足条件：**\n\n- 同一个作用域下\n- 函数名称相同\n\n- 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**\n\n**注意:**  函数的返回值不可以作为函数重载的条件\n\n**示例：**\n\n```cpp\n//函数重载需要函数都在同一个作用域下\nvoid func()\n{\n\tcout << \"func 的调用！\" << endl;\n}\nvoid func(int a)\n{\n\tcout << \"func (int a) 的调用！\" << endl;\n}\nvoid func(double a)\n{\n\tcout << \"func (double a)的调用！\" << endl;\n}\nvoid func(int a ,double b)\n{\n\tcout << \"func (int a ,double b) 的调用！\" << endl;\n}\nvoid func(double a ,int b)\n{\n\tcout << \"func (double a ,int b)的调用！\" << endl;\n}\n\n//函数返回值不可以作为函数重载条件\n//int func(double a, int b)\n//{\n//\tcout << \"func (double a ,int b)的调用！\" << endl;\n//}\n\n\nint main() {\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n##### 3.3.2 函数重载注意事项\n\n- 引用作为重载条件\n- 函数重载碰到函数默认参数\n\n\n\n**示例：**\n\n```cpp\n//函数重载注意事项\n//1、引用作为重载条件\n\nvoid func(int &a)\n{\n\tcout << \"func (int &a) 调用 \" << endl;\n}\n\nvoid func(const int &a)\n{\n\tcout << \"func (const int &a) 调用 \" << endl;\n}\n\n\n//2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b = 10)\n{\n\tcout << \"func2(int a, int b = 10) 调用\" << endl;\n}\n\nvoid func2(int a)\n{\n\tcout << \"func2(int a) 调用\" << endl;\n}\n\nint main() {\n\t\n\tint a = 10;\n\tfunc(a); //调用无const\n\tfunc(10);//调用有const\n\n\n\t//func2(10); //碰到默认参数产生歧义，需要避免\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n"
        },
        {
          "name": "C++核心编程.md",
          "type": "blob",
          "size": 75.576171875,
          "content": "# C++核心编程\r\n\r\n本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\r\n\r\n\r\n\r\n## 1 内存分区模型\r\n\r\nC++程序在执行时，将内存大方向划分为**4个区域**\r\n\r\n- 代码区：存放函数体的二进制代码，由操作系统进行管理的\r\n- 全局区：存放全局变量和静态变量以及常量\r\n- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\r\n- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**内存四区意义：**\r\n\r\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\r\n\r\n\r\n\r\n\r\n\r\n### 1.1 程序运行前\r\n\r\n​\t在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\r\n\r\n​\t**代码区：**\r\n\r\n​\t\t存放 CPU 执行的机器指令\r\n\r\n​\t\t代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\r\n\r\n​\t\t代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\r\n\r\n​\t**全局区：**\r\n\r\n​\t\t全局变量和静态变量存放在此.\r\n\r\n​\t\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\r\n\r\n​\t\t==该区域的数据在程序结束后由操作系统释放==.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```c++\r\n//全局变量\r\nint g_a = 10;\r\nint g_b = 10;\r\n\r\n//全局常量\r\nconst int c_g_a = 10;\r\nconst int c_g_b = 10;\r\n\r\nint main() {\r\n\r\n\t//局部变量\r\n\tint a = 10;\r\n\tint b = 10;\r\n\r\n\t//打印地址\r\n\tcout << \"局部变量a地址为： \" << (int)&a << endl;\r\n\tcout << \"局部变量b地址为： \" << (int)&b << endl;\r\n\r\n\tcout << \"全局变量g_a地址为： \" <<  (int)&g_a << endl;\r\n\tcout << \"全局变量g_b地址为： \" <<  (int)&g_b << endl;\r\n\r\n\t//静态变量\r\n\tstatic int s_a = 10;\r\n\tstatic int s_b = 10;\r\n\r\n\tcout << \"静态变量s_a地址为： \" << (int)&s_a << endl;\r\n\tcout << \"静态变量s_b地址为： \" << (int)&s_b << endl;\r\n\r\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world\" << endl;\r\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world1\" << endl;\r\n\r\n\tcout << \"全局常量c_g_a地址为： \" << (int)&c_g_a << endl;\r\n\tcout << \"全局常量c_g_b地址为： \" << (int)&c_g_b << endl;\r\n\r\n\tconst int c_l_a = 10;\r\n\tconst int c_l_b = 10;\r\n\tcout << \"局部常量c_l_a地址为： \" << (int)&c_l_a << endl;\r\n\tcout << \"局部常量c_l_b地址为： \" << (int)&c_l_b << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n打印结果：\r\n\r\n![1545017602518](assets/1545017602518.png)\r\n\r\n\r\n\r\n总结：\r\n\r\n* C++中在程序运行前分为全局区和代码区\r\n* 代码区特点是共享和只读\r\n* 全局区中存放全局变量、静态变量、常量\r\n* 常量区中存放 const修饰的全局常量  和 字符串常量\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 1.2 程序运行后\r\n\r\n\r\n\r\n​\t**栈区：**\r\n\r\n​\t\t由编译器自动分配释放, 存放函数的参数值,局部变量等\r\n\r\n​\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```c++\r\nint * func()\r\n{\r\n\tint a = 10;\r\n\treturn &a;\r\n}\r\n\r\nint main() {\r\n\r\n\tint *p = func();\r\n\r\n\tcout << *p << endl;\r\n\tcout << *p << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n​\t**堆区：**\r\n\r\n​\t\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\r\n\r\n​\t\t在C++中主要利用new在堆区开辟内存\r\n\r\n**示例：**\r\n\r\n```c++\r\nint* func()\r\n{\r\n\tint* a = new int(10);\r\n\treturn a;\r\n}\r\n\r\nint main() {\r\n\r\n\tint *p = func();\r\n\r\n\tcout << *p << endl;\r\n\tcout << *p << endl;\r\n    \r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**总结：**\r\n\r\n堆区数据由程序员管理开辟和释放\r\n\r\n堆区数据利用new关键字进行开辟内存\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 1.3 new操作符\r\n\r\n\r\n\r\n​\tC++中利用==new==操作符在堆区开辟数据\r\n\r\n​\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\r\n\r\n​\t语法：` new 数据类型`\r\n\r\n​\t利用new创建的数据，会返回该数据对应的类型的指针\r\n\r\n\r\n\r\n**示例1： 基本语法**\r\n\r\n```c++\r\nint* func()\r\n{\r\n\tint* a = new int(10);\r\n\treturn a;\r\n}\r\n\r\nint main() {\r\n\r\n\tint *p = func();\r\n\r\n\tcout << *p << endl;\r\n\tcout << *p << endl;\r\n\r\n\t//利用delete释放堆区数据\r\n\tdelete p;\r\n\r\n\t//cout << *p << endl; //报错，释放的空间不可访问\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**示例2：开辟数组**\r\n\r\n```c++\r\n//堆区开辟数组\r\nint main() {\r\n\r\n\tint* arr = new int[10];\r\n\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tarr[i] = i + 100;\r\n\t}\r\n\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tcout << arr[i] << endl;\r\n\t}\r\n\t//释放数组 delete 后加 []\r\n\tdelete[] arr;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 2 引用\r\n\r\n### 2.1 引用的基本使用\r\n\r\n**作用： **给变量起别名\r\n\r\n**语法：** `数据类型 &别名 = 原名`\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint &b = a;\r\n\r\n\tcout << \"a = \" << a << endl;\r\n\tcout << \"b = \" << b << endl;\r\n\r\n\tb = 100;\r\n\r\n\tcout << \"a = \" << a << endl;\r\n\tcout << \"b = \" << b << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.2 引用注意事项\r\n\r\n* 引用必须初始化\r\n* 引用在初始化后，不可以改变\r\n\r\n示例：\r\n\r\n```C++\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 20;\r\n\t//int &c; //错误，引用必须初始化\r\n\tint &c = a; //一旦初始化后，就不可以更改\r\n\tc = b; //这是赋值操作，不是更改引用\r\n\r\n\tcout << \"a = \" << a << endl;\r\n\tcout << \"b = \" << b << endl;\r\n\tcout << \"c = \" << c << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.3 引用做函数参数\r\n\r\n**作用：**函数传参时，可以利用引用的技术让形参修饰实参\r\n\r\n**优点：**可以简化指针修改实参\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//1. 值传递\r\nvoid mySwap01(int a, int b) {\r\n\tint temp = a;\r\n\ta = b;\r\n\tb = temp;\r\n}\r\n\r\n//2. 地址传递\r\nvoid mySwap02(int* a, int* b) {\r\n\tint temp = *a;\r\n\t*a = *b;\r\n\t*b = temp;\r\n}\r\n\r\n//3. 引用传递\r\nvoid mySwap03(int& a, int& b) {\r\n\tint temp = a;\r\n\ta = b;\r\n\tb = temp;\r\n}\r\n\r\nint main() {\r\n\r\n\tint a = 10;\r\n\tint b = 20;\r\n\r\n\tmySwap01(a, b);\r\n\tcout << \"a:\" << a << \" b:\" << b << endl;\r\n\r\n\tmySwap02(&a, &b);\r\n\tcout << \"a:\" << a << \" b:\" << b << endl;\r\n\r\n\tmySwap03(a, b);\r\n\tcout << \"a:\" << a << \" b:\" << b << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.4 引用做函数返回值\r\n\r\n\r\n\r\n作用：引用是可以作为函数的返回值存在的\r\n\r\n\r\n\r\n注意：**不要返回局部变量引用**\r\n\r\n用法：函数调用作为左值\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//返回局部变量引用\r\nint& test01() {\r\n\tint a = 10; //局部变量\r\n\treturn a;\r\n}\r\n\r\n//返回静态变量引用\r\nint& test02() {\r\n\tstatic int a = 20;\r\n\treturn a;\r\n}\r\n\r\nint main() {\r\n\r\n\t//不能返回局部变量的引用\r\n\tint& ref = test01();\r\n\tcout << \"ref = \" << ref << endl;\r\n\tcout << \"ref = \" << ref << endl;\r\n\r\n\t//如果函数做左值，那么必须返回引用\r\n\tint& ref2 = test02();\r\n\tcout << \"ref2 = \" << ref2 << endl;\r\n\tcout << \"ref2 = \" << ref2 << endl;\r\n\r\n\ttest02() = 1000;\r\n\r\n\tcout << \"ref2 = \" << ref2 << endl;\r\n\tcout << \"ref2 = \" << ref2 << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n​\t\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.5 引用的本质\r\n\r\n本质：**引用的本质在c++内部实现是一个指针常量.**\r\n\r\n讲解示例：\r\n\r\n```C++\r\n//发现是引用，转换为 int* const ref = &a;\r\nvoid func(int& ref){\r\n\tref = 100; // ref是引用，转换为*ref = 100\r\n}\r\nint main(){\r\n\tint a = 10;\r\n    \r\n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\r\n\tint& ref = a; \r\n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\r\n    \r\n\tcout << \"a:\" << a << endl;\r\n\tcout << \"ref:\" << ref << endl;\r\n    \r\n\tfunc(a);\r\n\treturn 0;\r\n}\r\n```\r\n\r\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.6 常量引用\r\n\r\n\r\n\r\n**作用：**常量引用主要用来修饰形参，防止误操作\r\n\r\n\r\n\r\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\r\n\r\n\r\n\r\n**示例：**\r\n\r\n\r\n\r\n```C++\r\n//引用使用的场景，通常用来修饰形参\r\nvoid showValue(const int& v) {\r\n\t//v += 10;\r\n\tcout << v << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\r\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\r\n\tconst int& ref = 10;\r\n\r\n\t//ref = 100;  //加入const后不可以修改变量\r\n\tcout << ref << endl;\r\n\r\n\t//函数中利用常量引用防止误操作修改实参\r\n\tint a = 10;\r\n\tshowValue(a);\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 3 函数提高\r\n\r\n### 3.1 函数默认参数\r\n\r\n\r\n\r\n在C++中，函数的形参列表中的形参是可以有默认值的。\r\n\r\n语法：` 返回值类型  函数名 （参数= 默认值）{}`\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nint func(int a, int b = 10, int c = 10) {\r\n\treturn a + b + c;\r\n}\r\n\r\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\r\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\r\nint func2(int a = 10, int b = 10);\r\nint func2(int a, int b) {\r\n\treturn a + b;\r\n}\r\n\r\nint main() {\r\n\r\n\tcout << \"ret = \" << func(20, 20) << endl;\r\n\tcout << \"ret = \" << func(100) << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 3.2 函数占位参数\r\n\r\n\r\n\r\nC++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\r\n\r\n\r\n\r\n**语法：** `返回值类型 函数名 (数据类型){}`\r\n\r\n\r\n\r\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//函数占位参数 ，占位参数也可以有默认参数\r\nvoid func(int a, int) {\r\n\tcout << \"this is func\" << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\tfunc(10,10); //占位参数必须填补\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 3.3 函数重载\r\n\r\n#### 3.3.1 函数重载概述\r\n\r\n\r\n\r\n**作用：**函数名可以相同，提高复用性\r\n\r\n\r\n\r\n**函数重载满足条件：**\r\n\r\n* 同一个作用域下\r\n* 函数名称相同\r\n* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**\r\n\r\n\r\n\r\n**注意:**  函数的返回值不可以作为函数重载的条件\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//函数重载需要函数都在同一个作用域下\r\nvoid func()\r\n{\r\n\tcout << \"func 的调用！\" << endl;\r\n}\r\nvoid func(int a)\r\n{\r\n\tcout << \"func (int a) 的调用！\" << endl;\r\n}\r\nvoid func(double a)\r\n{\r\n\tcout << \"func (double a)的调用！\" << endl;\r\n}\r\nvoid func(int a ,double b)\r\n{\r\n\tcout << \"func (int a ,double b) 的调用！\" << endl;\r\n}\r\nvoid func(double a ,int b)\r\n{\r\n\tcout << \"func (double a ,int b)的调用！\" << endl;\r\n}\r\n\r\n//函数返回值不可以作为函数重载条件\r\n//int func(double a, int b)\r\n//{\r\n//\tcout << \"func (double a ,int b)的调用！\" << endl;\r\n//}\r\n\r\n\r\nint main() {\r\n\r\n\tfunc();\r\n\tfunc(10);\r\n\tfunc(3.14);\r\n\tfunc(10,3.14);\r\n\tfunc(3.14 , 10);\r\n\t\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 3.3.2 函数重载注意事项\r\n\r\n\r\n\r\n* 引用作为重载条件\r\n* 函数重载碰到函数默认参数\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//函数重载注意事项\r\n//1、引用作为重载条件\r\n\r\nvoid func(int &a)\r\n{\r\n\tcout << \"func (int &a) 调用 \" << endl;\r\n}\r\n\r\nvoid func(const int &a)\r\n{\r\n\tcout << \"func (const int &a) 调用 \" << endl;\r\n}\r\n\r\n\r\n//2、函数重载碰到函数默认参数\r\n\r\nvoid func2(int a, int b = 10)\r\n{\r\n\tcout << \"func2(int a, int b = 10) 调用\" << endl;\r\n}\r\n\r\nvoid func2(int a)\r\n{\r\n\tcout << \"func2(int a) 调用\" << endl;\r\n}\r\n\r\nint main() {\r\n\t\r\n\tint a = 10;\r\n\tfunc(a); //调用无const\r\n\tfunc(10);//调用有const\r\n\r\n\r\n\t//func2(10); //碰到默认参数产生歧义，需要避免\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## **4** 类和对象\r\n\r\n\r\n\r\nC++面向对象的三大特性为：==封装、继承、多态==\r\n\r\n\r\n\r\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\r\n\r\n\r\n\r\n**例如：**\r\n\r\n​\t人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...\r\n\r\n​\t车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...\r\n\r\n​\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\r\n\r\n### 4.1 封装\r\n\r\n#### 4.1.1  封装的意义\r\n\r\n封装是C++面向对象三大特性之一\r\n\r\n封装的意义：\r\n\r\n* 将属性和行为作为一个整体，表现生活中的事物\r\n* 将属性和行为加以权限控制\r\n\r\n\r\n\r\n**封装意义一：**\r\n\r\n​\t在设计类的时候，属性和行为写在一起，表现事物\r\n\r\n**语法：** `class 类名{   访问权限： 属性  / 行为  };`\r\n\r\n\r\n\r\n**示例1：**设计一个圆类，求圆的周长\r\n\r\n**示例代码：**\r\n\r\n```C++\r\n//圆周率\r\nconst double PI = 3.14;\r\n\r\n//1、封装的意义\r\n//将属性和行为作为一个整体，用来表现生活中的事物\r\n\r\n//封装一个圆类，求圆的周长\r\n//class代表设计一个类，后面跟着的是类名\r\nclass Circle\r\n{\r\npublic:  //访问权限  公共的权限\r\n\r\n\t//属性\r\n\tint m_r;//半径\r\n\r\n\t//行为\r\n\t//获取到圆的周长\r\n\tdouble calculateZC()\r\n\t{\r\n\t\t//2 * pi  * r\r\n\t\t//获取圆的周长\r\n\t\treturn  2 * PI * m_r;\r\n\t}\r\n};\r\n\r\nint main() {\r\n\r\n\t//通过圆类，创建圆的对象\r\n\t// c1就是一个具体的圆\r\n\tCircle c1;\r\n\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\r\n\r\n\t//2 * pi * 10 = = 62.8\r\n\tcout << \"圆的周长为： \" << c1.calculateZC() << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\r\n\r\n\r\n\r\n\r\n\r\n**示例2代码：**\r\n\r\n```C++\r\n//学生类\r\nclass Student {\r\npublic:\r\n\tvoid setName(string name) {\r\n\t\tm_name = name;\r\n\t}\r\n\tvoid setID(int id) {\r\n\t\tm_id = id;\r\n\t}\r\n\r\n\tvoid showStudent() {\r\n\t\tcout << \"name:\" << m_name << \" ID:\" << m_id << endl;\r\n\t}\r\npublic:\r\n\tstring m_name;\r\n\tint m_id;\r\n};\r\n\r\nint main() {\r\n\r\n\tStudent stu;\r\n\tstu.setName(\"德玛西亚\");\r\n\tstu.setID(250);\r\n\tstu.showStudent();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**封装意义二：**\r\n\r\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\r\n\r\n访问权限有三种：\r\n\r\n\r\n\r\n1. public        公共权限  \r\n2. protected 保护权限\r\n3. private      私有权限\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//三种权限\r\n//公共权限  public     类内可以访问  类外可以访问\r\n//保护权限  protected  类内可以访问  类外不可以访问\r\n//私有权限  private    类内可以访问  类外不可以访问\r\n\r\nclass Person\r\n{\r\n\t//姓名  公共权限\r\npublic:\r\n\tstring m_Name;\r\n\r\n\t//汽车  保护权限\r\nprotected:\r\n\tstring m_Car;\r\n\r\n\t//银行卡密码  私有权限\r\nprivate:\r\n\tint m_Password;\r\n\r\npublic:\r\n\tvoid func()\r\n\t{\r\n\t\tm_Name = \"张三\";\r\n\t\tm_Car = \"拖拉机\";\r\n\t\tm_Password = 123456;\r\n\t}\r\n};\r\n\r\nint main() {\r\n\r\n\tPerson p;\r\n\tp.m_Name = \"李四\";\r\n\t//p.m_Car = \"奔驰\";  //保护权限类外访问不到\r\n\t//p.m_Password = 123; //私有权限类外访问不到\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.1.2 struct和class区别\r\n\r\n\r\n\r\n在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**\r\n\r\n区别：\r\n\r\n* struct 默认权限为公共\r\n* class   默认权限为私有\r\n\r\n\r\n\r\n```C++\r\nclass C1\r\n{\r\n\tint  m_A; //默认是私有权限\r\n};\r\n\r\nstruct C2\r\n{\r\n\tint m_A;  //默认是公共权限\r\n};\r\n\r\nint main() {\r\n\r\n\tC1 c1;\r\n\tc1.m_A = 10; //错误，访问权限是私有\r\n\r\n\tC2 c2;\r\n\tc2.m_A = 10; //正确，访问权限是公共\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.1.3 成员属性设置为私有\r\n\r\n\r\n\r\n**优点1：**将所有成员属性设置为私有，可以自己控制读写权限\r\n\r\n**优点2：**对于写权限，我们可以检测数据的有效性\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\r\n\t//姓名设置可读可写\r\n\tvoid setName(string name) {\r\n\t\tm_Name = name;\r\n\t}\r\n\tstring getName()\r\n\t{\r\n\t\treturn m_Name;\r\n\t}\r\n\r\n\r\n\t//获取年龄 \r\n\tint getAge() {\r\n\t\treturn m_Age;\r\n\t}\r\n\t//设置年龄\r\n\tvoid setAge(int age) {\r\n\t\tif (age < 0 || age > 150) {\r\n\t\t\tcout << \"你个老妖精!\" << endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tm_Age = age;\r\n\t}\r\n\r\n\t//情人设置为只写\r\n\tvoid setLover(string lover) {\r\n\t\tm_Lover = lover;\r\n\t}\r\n\r\nprivate:\r\n\tstring m_Name; //可读可写  姓名\r\n\t\r\n\tint m_Age; //只读  年龄\r\n\r\n\tstring m_Lover; //只写  情人\r\n};\r\n\r\n\r\nint main() {\r\n\r\n\tPerson p;\r\n\t//姓名设置\r\n\tp.setName(\"张三\");\r\n\tcout << \"姓名： \" << p.getName() << endl;\r\n\r\n\t//年龄设置\r\n\tp.setAge(50);\r\n\tcout << \"年龄： \" << p.getAge() << endl;\r\n\r\n\t//情人设置\r\n\tp.setLover(\"苍井\");\r\n\t//cout << \"情人： \" << p.m_Lover << endl;  //只写属性，不可以读取\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例1：设计立方体类**\r\n\r\n设计立方体类(Cube)\r\n\r\n求出立方体的面积和体积\r\n\r\n分别用全局函数和成员函数判断两个立方体是否相等。\r\n\r\n\r\n\r\n![1545533548532](assets/1545533548532.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**练习案例2：点和圆的关系**\r\n\r\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\r\n\r\n\r\n\r\n![1545533829184](assets/1545533829184.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.2 对象的初始化和清理\r\n\r\n\r\n\r\n*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\r\n*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.1 构造函数和析构函数\r\n\r\n对象的**初始化和清理**也是两个非常重要的安全问题\r\n\r\n​\t一个对象或者变量没有初始状态，对其使用后果是未知\r\n\r\n​\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\r\n\r\n\r\n\r\nc++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\r\n\r\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**\r\n\r\n**编译器提供的构造函数和析构函数是空实现。**\r\n\r\n\r\n\r\n* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\r\n* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。\r\n\r\n\r\n\r\n\r\n\r\n**构造函数语法：**`类名(){}`\r\n\r\n1. 构造函数，没有返回值也不写void\r\n2. 函数名称与类名相同\r\n3. 构造函数可以有参数，因此可以发生重载\r\n4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\r\n\r\n\r\n\r\n\r\n\r\n**析构函数语法：** `~类名(){}`\r\n\r\n1. 析构函数，没有返回值也不写void\r\n2. 函数名称与类名相同,在名称前加上符号  ~\r\n3. 析构函数不可以有参数，因此不可以发生重载\r\n4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\r\n\r\n\r\n\r\n\r\n\r\n```C++\r\nclass Person\r\n{\r\npublic:\r\n\t//构造函数\r\n\tPerson()\r\n\t{\r\n\t\tcout << \"Person的构造函数调用\" << endl;\r\n\t}\r\n\t//析构函数\r\n\t~Person()\r\n\t{\r\n\t\tcout << \"Person的析构函数调用\" << endl;\r\n\t}\r\n\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tPerson p;\r\n}\r\n\r\nint main() {\r\n\t\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.2 构造函数的分类及调用\r\n\r\n两种分类方式：\r\n\r\n​\t按参数分为： 有参构造和无参构造\r\n\r\n​\t按类型分为： 普通构造和拷贝构造\r\n\r\n三种调用方式：\r\n\r\n​\t括号法\r\n\r\n​\t显示法\r\n\r\n​\t隐式转换法\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//1、构造函数分类\r\n// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\r\n// 按照类型分类分为 普通构造和拷贝构造\r\n\r\nclass Person {\r\npublic:\r\n\t//无参（默认）构造函数\r\n\tPerson() {\r\n\t\tcout << \"无参构造函数!\" << endl;\r\n\t}\r\n\t//有参构造函数\r\n\tPerson(int a) {\r\n\t\tage = a;\r\n\t\tcout << \"有参构造函数!\" << endl;\r\n\t}\r\n\t//拷贝构造函数\r\n\tPerson(const Person& p) {\r\n\t\tage = p.age;\r\n\t\tcout << \"拷贝构造函数!\" << endl;\r\n\t}\r\n\t//析构函数\r\n\t~Person() {\r\n\t\tcout << \"析构函数!\" << endl;\r\n\t}\r\npublic:\r\n\tint age;\r\n};\r\n\r\n//2、构造函数的调用\r\n//调用无参构造函数\r\nvoid test01() {\r\n\tPerson p; //调用无参构造函数\r\n}\r\n\r\n//调用有参的构造函数\r\nvoid test02() {\r\n\r\n\t//2.1  括号法，常用\r\n\tPerson p1(10);\r\n\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\r\n\t//Person p2();\r\n\r\n\t//2.2 显式法\r\n\tPerson p2 = Person(10); \r\n\tPerson p3 = Person(p2);\r\n\t//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\r\n\r\n\t//2.3 隐式转换法\r\n\tPerson p4 = 10; // Person p4 = Person(10); \r\n\tPerson p5 = p4; // Person p5 = Person(p4); \r\n\r\n\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\r\n\t//Person p5(p4);\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\t//test02();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.3 拷贝构造函数调用时机\r\n\r\n\r\n\r\nC++中拷贝构造函数调用时机通常有三种情况\r\n\r\n* 使用一个已经创建完毕的对象来初始化一个新对象\r\n* 值传递的方式给函数参数传值\r\n* 以值方式返回局部对象\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\tPerson() {\r\n\t\tcout << \"无参构造函数!\" << endl;\r\n\t\tmAge = 0;\r\n\t}\r\n\tPerson(int age) {\r\n\t\tcout << \"有参构造函数!\" << endl;\r\n\t\tmAge = age;\r\n\t}\r\n\tPerson(const Person& p) {\r\n\t\tcout << \"拷贝构造函数!\" << endl;\r\n\t\tmAge = p.mAge;\r\n\t}\r\n\t//析构函数在释放内存之前调用\r\n\t~Person() {\r\n\t\tcout << \"析构函数!\" << endl;\r\n\t}\r\npublic:\r\n\tint mAge;\r\n};\r\n\r\n//1. 使用一个已经创建完毕的对象来初始化一个新对象\r\nvoid test01() {\r\n\r\n\tPerson man(100); //p对象已经创建完毕\r\n\tPerson newman(man); //调用拷贝构造函数\r\n\tPerson newman2 = man; //拷贝构造\r\n\r\n\t//Person newman3;\r\n\t//newman3 = man; //不是调用拷贝构造函数，赋值操作\r\n}\r\n\r\n//2. 值传递的方式给函数参数传值\r\n//相当于Person p1 = p;\r\nvoid doWork(Person p1) {}\r\nvoid test02() {\r\n\tPerson p; //无参构造函数\r\n\tdoWork(p);\r\n}\r\n\r\n//3. 以值方式返回局部对象\r\nPerson doWork2()\r\n{\r\n\tPerson p1;\r\n\tcout << (int *)&p1 << endl;\r\n\treturn p1;\r\n}\r\n\r\nvoid test03()\r\n{\r\n\tPerson p = doWork2();\r\n\tcout << (int *)&p << endl;\r\n}\r\n\r\n\r\nint main() {\r\n\r\n\t//test01();\r\n\t//test02();\r\n\ttest03();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.4 构造函数调用规则\r\n\r\n默认情况下，c++编译器至少给一个类添加3个函数\r\n\r\n1．默认构造函数(无参，函数体为空)\r\n\r\n2．默认析构函数(无参，函数体为空)\r\n\r\n3．默认拷贝构造函数，对属性进行值拷贝\r\n\r\n\r\n\r\n构造函数调用规则如下：\r\n\r\n* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\r\n\r\n\r\n* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数\r\n\r\n\r\n\r\n示例：\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\t//无参（默认）构造函数\r\n\tPerson() {\r\n\t\tcout << \"无参构造函数!\" << endl;\r\n\t}\r\n\t//有参构造函数\r\n\tPerson(int a) {\r\n\t\tage = a;\r\n\t\tcout << \"有参构造函数!\" << endl;\r\n\t}\r\n\t//拷贝构造函数\r\n\tPerson(const Person& p) {\r\n\t\tage = p.age;\r\n\t\tcout << \"拷贝构造函数!\" << endl;\r\n\t}\r\n\t//析构函数\r\n\t~Person() {\r\n\t\tcout << \"析构函数!\" << endl;\r\n\t}\r\npublic:\r\n\tint age;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tPerson p1(18);\r\n\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\r\n\tPerson p2(p1);\r\n\r\n\tcout << \"p2的年龄为： \" << p2.age << endl;\r\n}\r\n\r\nvoid test02()\r\n{\r\n\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\r\n\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\r\n\tPerson p2(10); //用户提供的有参\r\n\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\r\n\r\n\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\r\n\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\r\n\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\r\n\tPerson p6(p5); //用户自己提供拷贝构造\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.5 深拷贝与浅拷贝\r\n\r\n\r\n\r\n深浅拷贝是面试经典问题，也是常见的一个坑\r\n\r\n\r\n\r\n浅拷贝：简单的赋值拷贝操作\r\n\r\n\r\n\r\n深拷贝：在堆区重新申请空间，进行拷贝操作\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\t//无参（默认）构造函数\r\n\tPerson() {\r\n\t\tcout << \"无参构造函数!\" << endl;\r\n\t}\r\n\t//有参构造函数\r\n\tPerson(int age ,int height) {\r\n\t\t\r\n\t\tcout << \"有参构造函数!\" << endl;\r\n\r\n\t\tm_age = age;\r\n\t\tm_height = new int(height);\r\n\t\t\r\n\t}\r\n\t//拷贝构造函数  \r\n\tPerson(const Person& p) {\r\n\t\tcout << \"拷贝构造函数!\" << endl;\r\n\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\r\n\t\tm_age = p.m_age;\r\n\t\tm_height = new int(*p.m_height);\r\n\t\t\r\n\t}\r\n\r\n\t//析构函数\r\n\t~Person() {\r\n\t\tcout << \"析构函数!\" << endl;\r\n\t\tif (m_height != NULL)\r\n\t\t{\r\n\t\t\tdelete m_height;\r\n\t\t}\r\n\t}\r\npublic:\r\n\tint m_age;\r\n\tint* m_height;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tPerson p1(18, 180);\r\n\r\n\tPerson p2(p1);\r\n\r\n\tcout << \"p1的年龄： \" << p1.m_age << \" 身高： \" << *p1.m_height << endl;\r\n\r\n\tcout << \"p2的年龄： \" << p2.m_age << \" 身高： \" << *p2.m_height << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.6 初始化列表\r\n\r\n\r\n\r\n**作用：**\r\n\r\nC++提供了初始化列表语法，用来初始化属性\r\n\r\n\r\n\r\n**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\r\n\t////传统方式初始化\r\n\t//Person(int a, int b, int c) {\r\n\t//\tm_A = a;\r\n\t//\tm_B = b;\r\n\t//\tm_C = c;\r\n\t//}\r\n\r\n\t//初始化列表方式初始化\r\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\r\n\tvoid PrintPerson() {\r\n\t\tcout << \"mA:\" << m_A << endl;\r\n\t\tcout << \"mB:\" << m_B << endl;\r\n\t\tcout << \"mC:\" << m_C << endl;\r\n\t}\r\nprivate:\r\n\tint m_A;\r\n\tint m_B;\r\n\tint m_C;\r\n};\r\n\r\nint main() {\r\n\r\n\tPerson p(1, 2, 3);\r\n\tp.PrintPerson();\r\n\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.7 类对象作为类成员\r\n\r\n\r\n\r\nC++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\r\n\r\n\r\n\r\n例如：\r\n\r\n```C++\r\nclass A {}\r\nclass B\r\n{\r\n    A a；\r\n}\r\n```\r\n\r\n\r\n\r\nB类中有对象A作为成员，A为对象成员\r\n\r\n\r\n\r\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Phone\r\n{\r\npublic:\r\n\tPhone(string name)\r\n\t{\r\n\t\tm_PhoneName = name;\r\n\t\tcout << \"Phone构造\" << endl;\r\n\t}\r\n\r\n\t~Phone()\r\n\t{\r\n\t\tcout << \"Phone析构\" << endl;\r\n\t}\r\n\r\n\tstring m_PhoneName;\r\n\r\n};\r\n\r\n\r\nclass Person\r\n{\r\npublic:\r\n\r\n\t//初始化列表可以告诉编译器调用哪一个构造函数\r\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\r\n\t{\r\n\t\tcout << \"Person构造\" << endl;\r\n\t}\r\n\r\n\t~Person()\r\n\t{\r\n\t\tcout << \"Person析构\" << endl;\r\n\t}\r\n\r\n\tvoid playGame()\r\n\t{\r\n\t\tcout << m_Name << \" 使用\" << m_Phone.m_PhoneName << \" 牌手机! \" << endl;\r\n\t}\r\n\r\n\tstring m_Name;\r\n\tPhone m_Phone;\r\n\r\n};\r\nvoid test01()\r\n{\r\n\t//当类中成员是其他类对象时，我们称该成员为 对象成员\r\n\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\r\n\t//析构顺序与构造相反\r\n\tPerson p(\"张三\" , \"苹果X\");\r\n\tp.playGame();\r\n\r\n}\r\n\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.2.8 静态成员\r\n\r\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\r\n\r\n静态成员分为：\r\n\r\n\r\n\r\n*  静态成员变量\r\n   *  所有对象共享同一份数据\r\n   *  在编译阶段分配内存\r\n   *  类内声明，类外初始化\r\n*  静态成员函数\r\n   *  所有对象共享同一个函数\r\n   *  静态成员函数只能访问静态成员变量\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例1 ：**静态成员变量\r\n\r\n```C++\r\nclass Person\r\n{\r\n\t\r\npublic:\r\n\r\n\tstatic int m_A; //静态成员变量\r\n\r\n\t//静态成员变量特点：\r\n\t//1 在编译阶段分配内存\r\n\t//2 类内声明，类外初始化\r\n\t//3 所有对象共享同一份数据\r\n\r\nprivate:\r\n\tstatic int m_B; //静态成员变量也是有访问权限的\r\n};\r\nint Person::m_A = 10;\r\nint Person::m_B = 10;\r\n\r\nvoid test01()\r\n{\r\n\t//静态成员变量两种访问方式\r\n\r\n\t//1、通过对象\r\n\tPerson p1;\r\n\tp1.m_A = 100;\r\n\tcout << \"p1.m_A = \" << p1.m_A << endl;\r\n\r\n\tPerson p2;\r\n\tp2.m_A = 200;\r\n\tcout << \"p1.m_A = \" << p1.m_A << endl; //共享同一份数据\r\n\tcout << \"p2.m_A = \" << p2.m_A << endl;\r\n\r\n\t//2、通过类名\r\n\tcout << \"m_A = \" << Person::m_A << endl;\r\n\r\n\r\n\t//cout << \"m_B = \" << Person::m_B << endl; //私有权限访问不到\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**示例2：**静态成员函数\r\n\r\n```C++\r\nclass Person\r\n{\r\n\r\npublic:\r\n\r\n\t//静态成员函数特点：\r\n\t//1 程序共享一个函数\r\n\t//2 静态成员函数只能访问静态成员变量\r\n\t\r\n\tstatic void func()\r\n\t{\r\n\t\tcout << \"func调用\" << endl;\r\n\t\tm_A = 100;\r\n\t\t//m_B = 100; //错误，不可以访问非静态成员变量\r\n\t}\r\n\r\n\tstatic int m_A; //静态成员变量\r\n\tint m_B; // \r\nprivate:\r\n\r\n\t//静态成员函数也是有访问权限的\r\n\tstatic void func2()\r\n\t{\r\n\t\tcout << \"func2调用\" << endl;\r\n\t}\r\n};\r\nint Person::m_A = 10;\r\n\r\n\r\nvoid test01()\r\n{\r\n\t//静态成员变量两种访问方式\r\n\r\n\t//1、通过对象\r\n\tPerson p1;\r\n\tp1.func();\r\n\r\n\t//2、通过类名\r\n\tPerson::func();\r\n\r\n\r\n\t//Person::func2(); //私有权限访问不到\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.3 C++对象模型和this指针\r\n\r\n\r\n\r\n#### 4.3.1 成员变量和成员函数分开存储\r\n\r\n\r\n\r\n在C++中，类内的成员变量和成员函数分开存储\r\n\r\n只有非静态成员变量才属于类的对象上\r\n\r\n\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\tPerson() {\r\n\t\tmA = 0;\r\n\t}\r\n\t//非静态成员变量占对象空间\r\n\tint mA;\r\n\t//静态成员变量不占对象空间\r\n\tstatic int mB; \r\n\t//函数也不占对象空间，所有函数共享一个函数实例\r\n\tvoid func() {\r\n\t\tcout << \"mA:\" << this->mA << endl;\r\n\t}\r\n\t//静态成员函数也不占对象空间\r\n\tstatic void sfunc() {\r\n\t}\r\n};\r\n\r\nint main() {\r\n\r\n\tcout << sizeof(Person) << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.3.2 this指针概念\r\n\r\n通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\r\n\r\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\r\n\r\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\r\n\r\n\r\n\r\nc++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**\r\n\r\n\r\n\r\nthis指针是隐含每一个非静态成员函数内的一种指针\r\n\r\nthis指针不需要定义，直接使用即可\r\n\r\n\r\n\r\nthis指针的用途：\r\n\r\n*  当形参和成员变量同名时，可用this指针来区分\r\n*  在类的非静态成员函数中返回对象本身，可使用return *this\r\n\r\n```C++\r\nclass Person\r\n{\r\npublic:\r\n\r\n\tPerson(int age)\r\n\t{\r\n\t\t//1、当形参和成员变量同名时，可用this指针来区分\r\n\t\tthis->age = age;\r\n\t}\r\n\r\n\tPerson& PersonAddPerson(Person p)\r\n\t{\r\n\t\tthis->age += p.age;\r\n\t\t//返回对象本身\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tint age;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tPerson p1(10);\r\n\tcout << \"p1.age = \" << p1.age << endl;\r\n\r\n\tPerson p2(10);\r\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\r\n\tcout << \"p2.age = \" << p2.age << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.3.3 空指针访问成员函数\r\n\r\n\r\n\r\nC++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\r\n\r\n\r\n\r\n如果用到this指针，需要加以判断保证代码的健壮性\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//空指针访问成员函数\r\nclass Person {\r\npublic:\r\n\r\n\tvoid ShowClassName() {\r\n\t\tcout << \"我是Person类!\" << endl;\r\n\t}\r\n\r\n\tvoid ShowPerson() {\r\n\t\tif (this == NULL) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcout << mAge << endl;\r\n\t}\r\n\r\npublic:\r\n\tint mAge;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tPerson * p = NULL;\r\n\tp->ShowClassName(); //空指针，可以调用成员函数\r\n\tp->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.3.4 const修饰成员函数\r\n\r\n\r\n\r\n**常函数：**\r\n\r\n* 成员函数后加const后我们称为这个函数为**常函数**\r\n* 常函数内不可以修改成员属性\r\n* 成员属性声明时加关键字mutable后，在常函数中依然可以修改\r\n\r\n\r\n\r\n**常对象：**\r\n\r\n* 声明对象前加const称该对象为常对象\r\n* 常对象只能调用常函数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\tPerson() {\r\n\t\tm_A = 0;\r\n\t\tm_B = 0;\r\n\t}\r\n\r\n\t//this指针的本质是一个指针常量，指针的指向不可修改\r\n\t//如果想让指针指向的值也不可以修改，需要声明常函数\r\n\tvoid ShowPerson() const {\r\n\t\t//const Type* const pointer;\r\n\t\t//this = NULL; //不能修改指针的指向 Person* const this;\r\n\t\t//this->mA = 100; //但是this指针指向的对象的数据是可以修改的\r\n\r\n\t\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\r\n\t\tthis->m_B = 100;\r\n\t}\r\n\r\n\tvoid MyFunc() const {\r\n\t\t//mA = 10000;\r\n\t}\r\n\r\npublic:\r\n\tint m_A;\r\n\tmutable int m_B; //可修改 可变的\r\n};\r\n\r\n\r\n//const修饰对象  常对象\r\nvoid test01() {\r\n\r\n\tconst Person person; //常量对象  \r\n\tcout << person.m_A << endl;\r\n\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\r\n\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\r\n\r\n\t//常对象访问成员函数\r\n\tperson.MyFunc(); //常对象不能调用const的函数\r\n\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.4 友元\r\n\r\n\r\n\r\n生活中你的家有客厅(Public)，有你的卧室(Private)\r\n\r\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\r\n\r\n但是呢，你也可以允许你的好闺蜜好基友进去。\r\n\r\n\r\n\r\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\r\n\r\n\r\n\r\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\r\n\r\n\r\n\r\n友元的关键字为  ==friend==\r\n\r\n\r\n\r\n友元的三种实现\r\n\r\n* 全局函数做友元\r\n* 类做友元\r\n* 成员函数做友元\r\n\r\n\r\n\r\n\r\n\r\n#### 4.4.1 全局函数做友元\r\n\r\n```C++\r\nclass Building\r\n{\r\n\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\r\n\tfriend void goodGay(Building * building);\r\n\r\npublic:\r\n\r\n\tBuilding()\r\n\t{\r\n\t\tthis->m_SittingRoom = \"客厅\";\r\n\t\tthis->m_BedRoom = \"卧室\";\r\n\t}\r\n\r\n\r\npublic:\r\n\tstring m_SittingRoom; //客厅\r\n\r\nprivate:\r\n\tstring m_BedRoom; //卧室\r\n};\r\n\r\n\r\nvoid goodGay(Building * building)\r\n{\r\n\tcout << \"好基友正在访问： \" << building->m_SittingRoom << endl;\r\n\tcout << \"好基友正在访问： \" << building->m_BedRoom << endl;\r\n}\r\n\r\n\r\nvoid test01()\r\n{\r\n\tBuilding b;\r\n\tgoodGay(&b);\r\n}\r\n\r\nint main(){\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n#### 4.4.2 类做友元\r\n\r\n\r\n\r\n```C++\r\nclass Building;\r\nclass goodGay\r\n{\r\npublic:\r\n\r\n\tgoodGay();\r\n\tvoid visit();\r\n\r\nprivate:\r\n\tBuilding *building;\r\n};\r\n\r\n\r\nclass Building\r\n{\r\n\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\r\n\tfriend class goodGay;\r\n\r\npublic:\r\n\tBuilding();\r\n\r\npublic:\r\n\tstring m_SittingRoom; //客厅\r\nprivate:\r\n\tstring m_BedRoom;//卧室\r\n};\r\n\r\nBuilding::Building()\r\n{\r\n\tthis->m_SittingRoom = \"客厅\";\r\n\tthis->m_BedRoom = \"卧室\";\r\n}\r\n\r\ngoodGay::goodGay()\r\n{\r\n\tbuilding = new Building;\r\n}\r\n\r\nvoid goodGay::visit()\r\n{\r\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\r\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\r\n}\r\n\r\nvoid test01()\r\n{\r\n\tgoodGay gg;\r\n\tgg.visit();\r\n\r\n}\r\n\r\nint main(){\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 4.4.3 成员函数做友元\r\n\r\n\r\n\r\n```C++\r\n\r\nclass Building;\r\nclass goodGay\r\n{\r\npublic:\r\n\r\n\tgoodGay();\r\n\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\r\n\tvoid visit2(); \r\n\r\nprivate:\r\n\tBuilding *building;\r\n};\r\n\r\n\r\nclass Building\r\n{\r\n\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\r\n\tfriend void goodGay::visit();\r\n\r\npublic:\r\n\tBuilding();\r\n\r\npublic:\r\n\tstring m_SittingRoom; //客厅\r\nprivate:\r\n\tstring m_BedRoom;//卧室\r\n};\r\n\r\nBuilding::Building()\r\n{\r\n\tthis->m_SittingRoom = \"客厅\";\r\n\tthis->m_BedRoom = \"卧室\";\r\n}\r\n\r\ngoodGay::goodGay()\r\n{\r\n\tbuilding = new Building;\r\n}\r\n\r\nvoid goodGay::visit()\r\n{\r\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\r\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\r\n}\r\n\r\nvoid goodGay::visit2()\r\n{\r\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\r\n\t//cout << \"好基友正在访问\" << building->m_BedRoom << endl;\r\n}\r\n\r\nvoid test01()\r\n{\r\n\tgoodGay  gg;\r\n\tgg.visit();\r\n\r\n}\r\n\r\nint main(){\r\n    \r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.5 运算符重载\r\n\r\n\r\n\r\n运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\r\n\r\n\r\n\r\n#### 4.5.1 加号运算符重载\r\n\r\n\r\n\r\n作用：实现两个自定义数据类型相加的运算\r\n\r\n\r\n\r\n```C++\r\nclass Person {\r\npublic:\r\n\tPerson() {};\r\n\tPerson(int a, int b)\r\n\t{\r\n\t\tthis->m_A = a;\r\n\t\tthis->m_B = b;\r\n\t}\r\n\t//成员函数实现 + 号运算符重载\r\n\tPerson operator+(const Person& p) {\r\n\t\tPerson temp;\r\n\t\ttemp.m_A = this->m_A + p.m_A;\r\n\t\ttemp.m_B = this->m_B + p.m_B;\r\n\t\treturn temp;\r\n\t}\r\n\r\n\r\npublic:\r\n\tint m_A;\r\n\tint m_B;\r\n};\r\n\r\n//全局函数实现 + 号运算符重载\r\n//Person operator+(const Person& p1, const Person& p2) {\r\n//\tPerson temp(0, 0);\r\n//\ttemp.m_A = p1.m_A + p2.m_A;\r\n//\ttemp.m_B = p1.m_B + p2.m_B;\r\n//\treturn temp;\r\n//}\r\n\r\n//运算符重载 可以发生函数重载 \r\nPerson operator+(const Person& p2, int val)  \r\n{\r\n\tPerson temp;\r\n\ttemp.m_A = p2.m_A + val;\r\n\ttemp.m_B = p2.m_B + val;\r\n\treturn temp;\r\n}\r\n\r\nvoid test() {\r\n\r\n\tPerson p1(10, 10);\r\n\tPerson p2(20, 20);\r\n\r\n\t//成员函数方式\r\n\tPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\r\n\tcout << \"mA:\" << p3.m_A << \" mB:\" << p3.m_B << endl;\r\n\r\n\r\n\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\r\n\tcout << \"mA:\" << p4.m_A << \" mB:\" << p4.m_B << endl;\r\n\r\n}\r\n\r\nint main() {\r\n\r\n\ttest();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\r\n\r\n> 总结2：不要滥用运算符重载\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.5.2 左移运算符重载\r\n\r\n\r\n\r\n作用：可以输出自定义数据类型\r\n\r\n\r\n\r\n```C++\r\nclass Person {\r\n\tfriend ostream& operator<<(ostream& out, Person& p);\r\n\r\npublic:\r\n\r\n\tPerson(int a, int b)\r\n\t{\r\n\t\tthis->m_A = a;\r\n\t\tthis->m_B = b;\r\n\t}\r\n\r\n\t//成员函数 实现不了  p << cout 不是我们想要的效果\r\n\t//void operator<<(Person& p){\r\n\t//}\r\n\r\nprivate:\r\n\tint m_A;\r\n\tint m_B;\r\n};\r\n\r\n//全局函数实现左移重载\r\n//ostream对象只能有一个\r\nostream& operator<<(ostream& out, Person& p) {\r\n\tout << \"a:\" << p.m_A << \" b:\" << p.m_B;\r\n\treturn out;\r\n}\r\n\r\nvoid test() {\r\n\r\n\tPerson p1(10, 20);\r\n\r\n\tcout << p1 << \"hello world\" << endl; //链式编程\r\n}\r\n\r\nint main() {\r\n\r\n\ttest();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：重载左移运算符配合友元可以实现输出自定义数据类型\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.5.3 递增运算符重载\r\n\r\n\r\n\r\n作用： 通过重载递增运算符，实现自己的整型数据\r\n\r\n\r\n\r\n```C++\r\n\r\nclass MyInteger {\r\n\r\n\tfriend ostream& operator<<(ostream& out, MyInteger myint);\r\n\r\npublic:\r\n\tMyInteger() {\r\n\t\tm_Num = 0;\r\n\t}\r\n\t//前置++\r\n\tMyInteger& operator++() {\r\n\t\t//先++\r\n\t\tm_Num++;\r\n\t\t//再返回\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t//后置++\r\n\tMyInteger operator++(int) {\r\n\t\t//先返回\r\n\t\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\r\n\t\tm_Num++;\r\n\t\treturn temp;\r\n\t}\r\n\r\nprivate:\r\n\tint m_Num;\r\n};\r\n\r\n\r\nostream& operator<<(ostream& out, MyInteger myint) {\r\n\tout << myint.m_Num;\r\n\treturn out;\r\n}\r\n\r\n\r\n//前置++ 先++ 再返回\r\nvoid test01() {\r\n\tMyInteger myInt;\r\n\tcout << ++myInt << endl;\r\n\tcout << myInt << endl;\r\n}\r\n\r\n//后置++ 先返回 再++\r\nvoid test02() {\r\n\r\n\tMyInteger myInt;\r\n\tcout << myInt++ << endl;\r\n\tcout << myInt << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\t//test02();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结： 前置递增返回引用，后置递增返回值\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.5.4 赋值运算符重载\r\n\r\n\r\n\r\nc++编译器至少给一个类添加4个函数\r\n\r\n1. 默认构造函数(无参，函数体为空)\r\n2. 默认析构函数(无参，函数体为空)\r\n3. 默认拷贝构造函数，对属性进行值拷贝\r\n4. 赋值运算符 operator=, 对属性进行值拷贝\r\n\r\n\r\n\r\n\r\n\r\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Person\r\n{\r\npublic:\r\n\r\n\tPerson(int age)\r\n\t{\r\n\t\t//将年龄数据开辟到堆区\r\n\t\tm_Age = new int(age);\r\n\t}\r\n\r\n\t//重载赋值运算符 \r\n\tPerson& operator=(Person &p)\r\n\t{\r\n\t\tif (m_Age != NULL)\r\n\t\t{\r\n\t\t\tdelete m_Age;\r\n\t\t\tm_Age = NULL;\r\n\t\t}\r\n\t\t//编译器提供的代码是浅拷贝\r\n\t\t//m_Age = p.m_Age;\r\n\r\n\t\t//提供深拷贝 解决浅拷贝的问题\r\n\t\tm_Age = new int(*p.m_Age);\r\n\r\n\t\t//返回自身\r\n\t\treturn *this;\r\n\t}\r\n\r\n\r\n\t~Person()\r\n\t{\r\n\t\tif (m_Age != NULL)\r\n\t\t{\r\n\t\t\tdelete m_Age;\r\n\t\t\tm_Age = NULL;\r\n\t\t}\r\n\t}\r\n\r\n\t//年龄的指针\r\n\tint *m_Age;\r\n\r\n};\r\n\r\n\r\nvoid test01()\r\n{\r\n\tPerson p1(18);\r\n\r\n\tPerson p2(20);\r\n\r\n\tPerson p3(30);\r\n\r\n\tp3 = p2 = p1; //赋值操作\r\n\r\n\tcout << \"p1的年龄为：\" << *p1.m_Age << endl;\r\n\r\n\tcout << \"p2的年龄为：\" << *p2.m_Age << endl;\r\n\r\n\tcout << \"p3的年龄为：\" << *p3.m_Age << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\t//int a = 10;\r\n\t//int b = 20;\r\n\t//int c = 30;\r\n\r\n\t//c = b = a;\r\n\t//cout << \"a = \" << a << endl;\r\n\t//cout << \"b = \" << b << endl;\r\n\t//cout << \"c = \" << c << endl;\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.5.5 关系运算符重载\r\n\r\n\r\n\r\n**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Person\r\n{\r\npublic:\r\n\tPerson(string name, int age)\r\n\t{\r\n\t\tthis->m_Name = name;\r\n\t\tthis->m_Age = age;\r\n\t};\r\n\r\n\tbool operator==(Person & p)\r\n\t{\r\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tbool operator!=(Person & p)\r\n\t{\r\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tstring m_Name;\r\n\tint m_Age;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\t//int a = 0;\r\n\t//int b = 0;\r\n\r\n\tPerson a(\"孙悟空\", 18);\r\n\tPerson b(\"孙悟空\", 18);\r\n\r\n\tif (a == b)\r\n\t{\r\n\t\tcout << \"a和b相等\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"a和b不相等\" << endl;\r\n\t}\r\n\r\n\tif (a != b)\r\n\t{\r\n\t\tcout << \"a和b不相等\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"a和b相等\" << endl;\r\n\t}\r\n}\r\n\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 4.5.6 函数调用运算符重载\r\n\r\n\r\n\r\n* 函数调用运算符 ()  也可以重载\r\n* 由于重载后使用的方式非常像函数的调用，因此称为仿函数\r\n* 仿函数没有固定写法，非常灵活\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass MyPrint\r\n{\r\npublic:\r\n\tvoid operator()(string text)\r\n\t{\r\n\t\tcout << text << endl;\r\n\t}\r\n\r\n};\r\nvoid test01()\r\n{\r\n\t//重载的（）操作符 也称为仿函数\r\n\tMyPrint myFunc;\r\n\tmyFunc(\"hello world\");\r\n}\r\n\r\n\r\nclass MyAdd\r\n{\r\npublic:\r\n\tint operator()(int v1, int v2)\r\n\t{\r\n\t\treturn v1 + v2;\r\n\t}\r\n};\r\n\r\nvoid test02()\r\n{\r\n\tMyAdd add;\r\n\tint ret = add(10, 10);\r\n\tcout << \"ret = \" << ret << endl;\r\n\r\n\t//匿名对象调用  \r\n\tcout << \"MyAdd()(100,100) = \" << MyAdd()(100, 100) << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\ttest02();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.6  继承\r\n\r\n**继承是面向对象三大特性之一**\r\n\r\n有些类与类之间存在特殊的关系，例如下图中：\r\n\r\n![1544861202252](assets/1544861202252.png)\r\n\r\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\r\n\r\n这个时候我们就可以考虑利用继承的技术，减少重复代码\r\n\r\n\r\n\r\n#### 4.6.1 继承的基本语法\r\n\r\n\r\n\r\n例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\r\n\r\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\r\n\r\n\r\n\r\n**普通实现：**\r\n\r\n```C++\r\n//Java页面\r\nclass Java \r\n{\r\npublic:\r\n\tvoid header()\r\n\t{\r\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\r\n\t}\r\n\tvoid footer()\r\n\t{\r\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\r\n\t}\r\n\tvoid left()\r\n\t{\r\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\r\n\t}\r\n\tvoid content()\r\n\t{\r\n\t\tcout << \"JAVA学科视频\" << endl;\r\n\t}\r\n};\r\n//Python页面\r\nclass Python\r\n{\r\npublic:\r\n\tvoid header()\r\n\t{\r\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\r\n\t}\r\n\tvoid footer()\r\n\t{\r\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\r\n\t}\r\n\tvoid left()\r\n\t{\r\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\r\n\t}\r\n\tvoid content()\r\n\t{\r\n\t\tcout << \"Python学科视频\" << endl;\r\n\t}\r\n};\r\n//C++页面\r\nclass CPP \r\n{\r\npublic:\r\n\tvoid header()\r\n\t{\r\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\r\n\t}\r\n\tvoid footer()\r\n\t{\r\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\r\n\t}\r\n\tvoid left()\r\n\t{\r\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\r\n\t}\r\n\tvoid content()\r\n\t{\r\n\t\tcout << \"C++学科视频\" << endl;\r\n\t}\r\n};\r\n\r\nvoid test01()\r\n{\r\n\t//Java页面\r\n\tcout << \"Java下载视频页面如下： \" << endl;\r\n\tJava ja;\r\n\tja.header();\r\n\tja.footer();\r\n\tja.left();\r\n\tja.content();\r\n\tcout << \"--------------------\" << endl;\r\n\r\n\t//Python页面\r\n\tcout << \"Python下载视频页面如下： \" << endl;\r\n\tPython py;\r\n\tpy.header();\r\n\tpy.footer();\r\n\tpy.left();\r\n\tpy.content();\r\n\tcout << \"--------------------\" << endl;\r\n\r\n\t//C++页面\r\n\tcout << \"C++下载视频页面如下： \" << endl;\r\n\tCPP cp;\r\n\tcp.header();\r\n\tcp.footer();\r\n\tcp.left();\r\n\tcp.content();\r\n\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**继承实现：**\r\n\r\n```C++\r\n//公共页面\r\nclass BasePage\r\n{\r\npublic:\r\n\tvoid header()\r\n\t{\r\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\r\n\t}\r\n\r\n\tvoid footer()\r\n\t{\r\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\r\n\t}\r\n\tvoid left()\r\n\t{\r\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\r\n\t}\r\n\r\n};\r\n\r\n//Java页面\r\nclass Java : public BasePage\r\n{\r\npublic:\r\n\tvoid content()\r\n\t{\r\n\t\tcout << \"JAVA学科视频\" << endl;\r\n\t}\r\n};\r\n//Python页面\r\nclass Python : public BasePage\r\n{\r\npublic:\r\n\tvoid content()\r\n\t{\r\n\t\tcout << \"Python学科视频\" << endl;\r\n\t}\r\n};\r\n//C++页面\r\nclass CPP : public BasePage\r\n{\r\npublic:\r\n\tvoid content()\r\n\t{\r\n\t\tcout << \"C++学科视频\" << endl;\r\n\t}\r\n};\r\n\r\nvoid test01()\r\n{\r\n\t//Java页面\r\n\tcout << \"Java下载视频页面如下： \" << endl;\r\n\tJava ja;\r\n\tja.header();\r\n\tja.footer();\r\n\tja.left();\r\n\tja.content();\r\n\tcout << \"--------------------\" << endl;\r\n\r\n\t//Python页面\r\n\tcout << \"Python下载视频页面如下： \" << endl;\r\n\tPython py;\r\n\tpy.header();\r\n\tpy.footer();\r\n\tpy.left();\r\n\tpy.content();\r\n\tcout << \"--------------------\" << endl;\r\n\r\n\t//C++页面\r\n\tcout << \"C++下载视频页面如下： \" << endl;\r\n\tCPP cp;\r\n\tcp.header();\r\n\tcp.footer();\r\n\tcp.left();\r\n\tcp.content();\r\n\r\n\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n**总结：**\r\n\r\n继承的好处：==可以减少重复的代码==\r\n\r\nclass A : public B; \r\n\r\nA 类称为子类 或 派生类\r\n\r\nB 类称为父类 或 基类\r\n\r\n\r\n\r\n**派生类中的成员，包含两大部分**：\r\n\r\n一类是从基类继承过来的，一类是自己增加的成员。\r\n\r\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.6.2 继承方式\r\n\r\n\r\n\r\n继承的语法：`class 子类 : 继承方式  父类`\r\n\r\n\r\n\r\n**继承方式一共有三种：**\r\n\r\n* 公共继承\r\n* 保护继承\r\n* 私有继承\r\n\r\n\r\n\r\n\r\n\r\n![img](assets/clip_image002.png)\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Base1\r\n{\r\npublic: \r\n\tint m_A;\r\nprotected:\r\n\tint m_B;\r\nprivate:\r\n\tint m_C;\r\n};\r\n\r\n//公共继承\r\nclass Son1 :public Base1\r\n{\r\npublic:\r\n\tvoid func()\r\n\t{\r\n\t\tm_A; //可访问 public权限\r\n\t\tm_B; //可访问 protected权限\r\n\t\t//m_C; //不可访问\r\n\t}\r\n};\r\n\r\nvoid myClass()\r\n{\r\n\tSon1 s1;\r\n\ts1.m_A; //其他类只能访问到公共权限\r\n}\r\n\r\n//保护继承\r\nclass Base2\r\n{\r\npublic:\r\n\tint m_A;\r\nprotected:\r\n\tint m_B;\r\nprivate:\r\n\tint m_C;\r\n};\r\nclass Son2:protected Base2\r\n{\r\npublic:\r\n\tvoid func()\r\n\t{\r\n\t\tm_A; //可访问 protected权限\r\n\t\tm_B; //可访问 protected权限\r\n\t\t//m_C; //不可访问\r\n\t}\r\n};\r\nvoid myClass2()\r\n{\r\n\tSon2 s;\r\n\t//s.m_A; //不可访问\r\n}\r\n\r\n//私有继承\r\nclass Base3\r\n{\r\npublic:\r\n\tint m_A;\r\nprotected:\r\n\tint m_B;\r\nprivate:\r\n\tint m_C;\r\n};\r\nclass Son3:private Base3\r\n{\r\npublic:\r\n\tvoid func()\r\n\t{\r\n\t\tm_A; //可访问 private权限\r\n\t\tm_B; //可访问 private权限\r\n\t\t//m_C; //不可访问\r\n\t}\r\n};\r\nclass GrandSon3 :public Son3\r\n{\r\npublic:\r\n\tvoid func()\r\n\t{\r\n\t\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\r\n\t\t//m_A;\r\n\t\t//m_B;\r\n\t\t//m_C;\r\n\t}\r\n};\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.6.3 继承中的对象模型\r\n\r\n\r\n\r\n**问题：**从父类继承过来的成员，哪些属于子类对象中？\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Base\r\n{\r\npublic:\r\n\tint m_A;\r\nprotected:\r\n\tint m_B;\r\nprivate:\r\n\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去\r\n};\r\n\r\n//公共继承\r\nclass Son :public Base\r\n{\r\npublic:\r\n\tint m_D;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tcout << \"sizeof Son = \" << sizeof(Son) << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n利用工具查看：\r\n\r\n\r\n\r\n![1545881904150](assets/1545881904150.png)\r\n\r\n\r\n\r\n打开工具窗口后，定位到当前CPP文件的盘符\r\n\r\n然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名\r\n\r\n\r\n\r\n效果如下图：\r\n\r\n\r\n\r\n![1545882158050](assets/1545882158050.png)\r\n\r\n\r\n\r\n> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.6.4 继承中构造和析构顺序\r\n\r\n\r\n\r\n子类继承父类后，当创建子类对象，也会调用父类的构造函数\r\n\r\n\r\n\r\n问题：父类和子类的构造和析构顺序是谁先谁后？\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Base \r\n{\r\npublic:\r\n\tBase()\r\n\t{\r\n\t\tcout << \"Base构造函数!\" << endl;\r\n\t}\r\n\t~Base()\r\n\t{\r\n\t\tcout << \"Base析构函数!\" << endl;\r\n\t}\r\n};\r\n\r\nclass Son : public Base\r\n{\r\npublic:\r\n\tSon()\r\n\t{\r\n\t\tcout << \"Son构造函数!\" << endl;\r\n\t}\r\n\t~Son()\r\n\t{\r\n\t\tcout << \"Son析构函数!\" << endl;\r\n\t}\r\n\r\n};\r\n\r\n\r\nvoid test01()\r\n{\r\n\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\r\n\tSon s;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.6.5 继承同名成员处理方式\r\n\r\n\r\n\r\n问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\r\n\r\n\r\n\r\n* 访问子类同名成员   直接访问即可\r\n* 访问父类同名成员   需要加作用域\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Base {\r\npublic:\r\n\tBase()\r\n\t{\r\n\t\tm_A = 100;\r\n\t}\r\n\r\n\tvoid func()\r\n\t{\r\n\t\tcout << \"Base - func()调用\" << endl;\r\n\t}\r\n\r\n\tvoid func(int a)\r\n\t{\r\n\t\tcout << \"Base - func(int a)调用\" << endl;\r\n\t}\r\n\r\npublic:\r\n\tint m_A;\r\n};\r\n\r\n\r\nclass Son : public Base {\r\npublic:\r\n\tSon()\r\n\t{\r\n\t\tm_A = 200;\r\n\t}\r\n\r\n\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\r\n\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\r\n\tvoid func()\r\n\t{\r\n\t\tcout << \"Son - func()调用\" << endl;\r\n\t}\r\npublic:\r\n\tint m_A;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tSon s;\r\n\r\n\tcout << \"Son下的m_A = \" << s.m_A << endl;\r\n\tcout << \"Base下的m_A = \" << s.Base::m_A << endl;\r\n\r\n\ts.func();\r\n\ts.Base::func();\r\n\ts.Base::func(10);\r\n\r\n}\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\treturn EXIT_SUCCESS;\r\n}\r\n```\r\n\r\n总结：\r\n\r\n1. 子类对象可以直接访问到子类中同名成员\r\n2. 子类对象加作用域可以访问到父类同名成员\r\n3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.6.6 继承同名静态成员处理方式\r\n\r\n\r\n\r\n问题：继承中同名的静态成员在子类对象上如何进行访问？\r\n\r\n\r\n\r\n静态成员和非静态成员出现同名，处理方式一致\r\n\r\n\r\n\r\n- 访问子类同名成员   直接访问即可\r\n- 访问父类同名成员   需要加作用域\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Base {\r\npublic:\r\n\tstatic void func()\r\n\t{\r\n\t\tcout << \"Base - static void func()\" << endl;\r\n\t}\r\n\tstatic void func(int a)\r\n\t{\r\n\t\tcout << \"Base - static void func(int a)\" << endl;\r\n\t}\r\n\r\n\tstatic int m_A;\r\n};\r\n\r\nint Base::m_A = 100;\r\n\r\nclass Son : public Base {\r\npublic:\r\n\tstatic void func()\r\n\t{\r\n\t\tcout << \"Son - static void func()\" << endl;\r\n\t}\r\n\tstatic int m_A;\r\n};\r\n\r\nint Son::m_A = 200;\r\n\r\n//同名成员属性\r\nvoid test01()\r\n{\r\n\t//通过对象访问\r\n\tcout << \"通过对象访问： \" << endl;\r\n\tSon s;\r\n\tcout << \"Son  下 m_A = \" << s.m_A << endl;\r\n\tcout << \"Base 下 m_A = \" << s.Base::m_A << endl;\r\n\r\n\t//通过类名访问\r\n\tcout << \"通过类名访问： \" << endl;\r\n\tcout << \"Son  下 m_A = \" << Son::m_A << endl;\r\n\tcout << \"Base 下 m_A = \" << Son::Base::m_A << endl;\r\n}\r\n\r\n//同名成员函数\r\nvoid test02()\r\n{\r\n\t//通过对象访问\r\n\tcout << \"通过对象访问： \" << endl;\r\n\tSon s;\r\n\ts.func();\r\n\ts.Base::func();\r\n\r\n\tcout << \"通过类名访问： \" << endl;\r\n\tSon::func();\r\n\tSon::Base::func();\r\n\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\r\n\tSon::Base::func(100);\r\n}\r\nint main() {\r\n\r\n\t//test01();\r\n\ttest02();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.6.7 多继承语法\r\n\r\n\r\n\r\nC++允许**一个类继承多个类**\r\n\r\n\r\n\r\n语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...`\r\n\r\n\r\n\r\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\r\n\r\n\r\n\r\n**C++实际开发中不建议用多继承**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Base1 {\r\npublic:\r\n\tBase1()\r\n\t{\r\n\t\tm_A = 100;\r\n\t}\r\npublic:\r\n\tint m_A;\r\n};\r\n\r\nclass Base2 {\r\npublic:\r\n\tBase2()\r\n\t{\r\n\t\tm_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确\r\n\t}\r\npublic:\r\n\tint m_A;\r\n};\r\n\r\n//语法：class 子类：继承方式 父类1 ，继承方式 父类2 \r\nclass Son : public Base2, public Base1 \r\n{\r\npublic:\r\n\tSon()\r\n\t{\r\n\t\tm_C = 300;\r\n\t\tm_D = 400;\r\n\t}\r\npublic:\r\n\tint m_C;\r\n\tint m_D;\r\n};\r\n\r\n\r\n//多继承容易产生成员同名的情况\r\n//通过使用类名作用域可以区分调用哪一个基类的成员\r\nvoid test01()\r\n{\r\n\tSon s;\r\n\tcout << \"sizeof Son = \" << sizeof(s) << endl;\r\n\tcout << s.Base1::m_A << endl;\r\n\tcout << s.Base2::m_A << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n> 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.6.8 菱形继承\r\n\r\n\r\n\r\n**菱形继承概念：**\r\n\r\n​\t两个派生类继承同一个基类\r\n\r\n​\t又有某个类同时继承者两个派生类\r\n\r\n​\t这种继承被称为菱形继承，或者钻石继承\r\n\r\n\r\n\r\n**典型的菱形继承案例：**\r\n\r\n\r\n\r\n![IMG_256](assets/clip_image002.jpg)\r\n\r\n\r\n\r\n**菱形继承问题：**\r\n\r\n\r\n\r\n1.     羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\r\n\r\n2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Animal\r\n{\r\npublic:\r\n\tint m_Age;\r\n};\r\n\r\n//继承前加virtual关键字后，变为虚继承\r\n//此时公共的父类Animal称为虚基类\r\nclass Sheep : virtual public Animal {};\r\nclass Tuo   : virtual public Animal {};\r\nclass SheepTuo : public Sheep, public Tuo {};\r\n\r\nvoid test01()\r\n{\r\n\tSheepTuo st;\r\n\tst.Sheep::m_Age = 100;\r\n\tst.Tuo::m_Age = 200;\r\n\r\n\tcout << \"st.Sheep::m_Age = \" << st.Sheep::m_Age << endl;\r\n\tcout << \"st.Tuo::m_Age = \" <<  st.Tuo::m_Age << endl;\r\n\tcout << \"st.m_Age = \" << st.m_Age << endl;\r\n}\r\n\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n总结：\r\n\r\n* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\r\n* 利用虚继承可以解决菱形继承问题\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.7  多态\r\n\r\n#### 4.7.1 多态的基本概念\r\n\r\n\r\n\r\n**多态是C++面向对象三大特性之一**\r\n\r\n多态分为两类\r\n\r\n* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\r\n* 动态多态: 派生类和虚函数实现运行时多态\r\n\r\n\r\n\r\n静态多态和动态多态区别：\r\n\r\n* 静态多态的函数地址早绑定  -  编译阶段确定函数地址\r\n* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址\r\n\r\n\r\n\r\n下面通过案例进行讲解多态\r\n\r\n\r\n\r\n```C++\r\nclass Animal\r\n{\r\npublic:\r\n\t//Speak函数就是虚函数\r\n\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\r\n\tvirtual void speak()\r\n\t{\r\n\t\tcout << \"动物在说话\" << endl;\r\n\t}\r\n};\r\n\r\nclass Cat :public Animal\r\n{\r\npublic:\r\n\tvoid speak()\r\n\t{\r\n\t\tcout << \"小猫在说话\" << endl;\r\n\t}\r\n};\r\n\r\nclass Dog :public Animal\r\n{\r\npublic:\r\n\r\n\tvoid speak()\r\n\t{\r\n\t\tcout << \"小狗在说话\" << endl;\r\n\t}\r\n\r\n};\r\n//我们希望传入什么对象，那么就调用什么对象的函数\r\n//如果函数地址在编译阶段就能确定，那么静态联编\r\n//如果函数地址在运行阶段才能确定，就是动态联编\r\n\r\nvoid DoSpeak(Animal & animal)\r\n{\r\n\tanimal.speak();\r\n}\r\n//\r\n//多态满足条件： \r\n//1、有继承关系\r\n//2、子类重写父类中的虚函数\r\n//多态使用：\r\n//父类指针或引用指向子类对象\r\n\r\nvoid test01()\r\n{\r\n\tCat cat;\r\n\tDoSpeak(cat);\r\n\r\n\r\n\tDog dog;\r\n\tDoSpeak(dog);\r\n}\r\n\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n总结：\r\n\r\n多态满足条件\r\n\r\n* 有继承关系\r\n* 子类重写父类中的虚函数\r\n\r\n多态使用条件\r\n\r\n* 父类指针或引用指向子类对象\r\n\r\n重写：函数返回值类型  函数名 参数列表 完全一致称为重写\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.7.2 多态案例一-计算器类\r\n\r\n\r\n\r\n案例描述：\r\n\r\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\r\n\r\n\r\n\r\n多态的优点：\r\n\r\n* 代码组织结构清晰\r\n* 可读性强\r\n* 利于前期和后期的扩展以及维护\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//普通实现\r\nclass Calculator {\r\npublic:\r\n\tint getResult(string oper)\r\n\t{\r\n\t\tif (oper == \"+\") {\r\n\t\t\treturn m_Num1 + m_Num2;\r\n\t\t}\r\n\t\telse if (oper == \"-\") {\r\n\t\t\treturn m_Num1 - m_Num2;\r\n\t\t}\r\n\t\telse if (oper == \"*\") {\r\n\t\t\treturn m_Num1 * m_Num2;\r\n\t\t}\r\n\t\t//如果要提供新的运算，需要修改源码\r\n\t}\r\npublic:\r\n\tint m_Num1;\r\n\tint m_Num2;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\t//普通实现测试\r\n\tCalculator c;\r\n\tc.m_Num1 = 10;\r\n\tc.m_Num2 = 10;\r\n\tcout << c.m_Num1 << \" + \" << c.m_Num2 << \" = \" << c.getResult(\"+\") << endl;\r\n\r\n\tcout << c.m_Num1 << \" - \" << c.m_Num2 << \" = \" << c.getResult(\"-\") << endl;\r\n\r\n\tcout << c.m_Num1 << \" * \" << c.m_Num2 << \" = \" << c.getResult(\"*\") << endl;\r\n}\r\n\r\n\r\n\r\n//多态实现\r\n//抽象计算器类\r\n//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\r\nclass AbstractCalculator\r\n{\r\npublic :\r\n\r\n\tvirtual int getResult()\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tint m_Num1;\r\n\tint m_Num2;\r\n};\r\n\r\n//加法计算器\r\nclass AddCalculator :public AbstractCalculator\r\n{\r\npublic:\r\n\tint getResult()\r\n\t{\r\n\t\treturn m_Num1 + m_Num2;\r\n\t}\r\n};\r\n\r\n//减法计算器\r\nclass SubCalculator :public AbstractCalculator\r\n{\r\npublic:\r\n\tint getResult()\r\n\t{\r\n\t\treturn m_Num1 - m_Num2;\r\n\t}\r\n};\r\n\r\n//乘法计算器\r\nclass MulCalculator :public AbstractCalculator\r\n{\r\npublic:\r\n\tint getResult()\r\n\t{\r\n\t\treturn m_Num1 * m_Num2;\r\n\t}\r\n};\r\n\r\n\r\nvoid test02()\r\n{\r\n\t//创建加法计算器\r\n\tAbstractCalculator *abc = new AddCalculator;\r\n\tabc->m_Num1 = 10;\r\n\tabc->m_Num2 = 10;\r\n\tcout << abc->m_Num1 << \" + \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\r\n\tdelete abc;  //用完了记得销毁\r\n\r\n\t//创建减法计算器\r\n\tabc = new SubCalculator;\r\n\tabc->m_Num1 = 10;\r\n\tabc->m_Num2 = 10;\r\n\tcout << abc->m_Num1 << \" - \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\r\n\tdelete abc;  \r\n\r\n\t//创建乘法计算器\r\n\tabc = new MulCalculator;\r\n\tabc->m_Num1 = 10;\r\n\tabc->m_Num2 = 10;\r\n\tcout << abc->m_Num1 << \" * \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\r\n\tdelete abc;\r\n}\r\n\r\nint main() {\r\n\r\n\t//test01();\r\n\r\n\ttest02();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.7.3 纯虚函数和抽象类\r\n\r\n\r\n\r\n在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\r\n\r\n\r\n\r\n因此可以将虚函数改为**纯虚函数**\r\n\r\n\r\n\r\n纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`\r\n\r\n\r\n\r\n当类中有了纯虚函数，这个类也称为==抽象类==\r\n\r\n\r\n\r\n**抽象类特点**：\r\n\r\n * 无法实例化对象\r\n * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Base\r\n{\r\npublic:\r\n\t//纯虚函数\r\n\t//类中只要有一个纯虚函数就称为抽象类\r\n\t//抽象类无法实例化对象\r\n\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\r\n\tvirtual void func() = 0;\r\n};\r\n\r\nclass Son :public Base\r\n{\r\npublic:\r\n\tvirtual void func() \r\n\t{\r\n\t\tcout << \"func调用\" << endl;\r\n\t};\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tBase * base = NULL;\r\n\t//base = new Base; // 错误，抽象类无法实例化对象\r\n\tbase = new Son;\r\n\tbase->func();\r\n\tdelete base;//记得销毁\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.7.4 多态案例二-制作饮品\r\n\r\n**案例描述：**\r\n\r\n制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料\r\n\r\n\r\n\r\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\r\n\r\n\r\n\r\n![1545985945198](assets/1545985945198.png)\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n//抽象制作饮品\r\nclass AbstractDrinking {\r\npublic:\r\n\t//烧水\r\n\tvirtual void Boil() = 0;\r\n\t//冲泡\r\n\tvirtual void Brew() = 0;\r\n\t//倒入杯中\r\n\tvirtual void PourInCup() = 0;\r\n\t//加入辅料\r\n\tvirtual void PutSomething() = 0;\r\n\t//规定流程\r\n\tvoid MakeDrink() {\r\n\t\tBoil();\r\n\t\tBrew();\r\n\t\tPourInCup();\r\n\t\tPutSomething();\r\n\t}\r\n};\r\n\r\n//制作咖啡\r\nclass Coffee : public AbstractDrinking {\r\npublic:\r\n\t//烧水\r\n\tvirtual void Boil() {\r\n\t\tcout << \"煮农夫山泉!\" << endl;\r\n\t}\r\n\t//冲泡\r\n\tvirtual void Brew() {\r\n\t\tcout << \"冲泡咖啡!\" << endl;\r\n\t}\r\n\t//倒入杯中\r\n\tvirtual void PourInCup() {\r\n\t\tcout << \"将咖啡倒入杯中!\" << endl;\r\n\t}\r\n\t//加入辅料\r\n\tvirtual void PutSomething() {\r\n\t\tcout << \"加入牛奶!\" << endl;\r\n\t}\r\n};\r\n\r\n//制作茶水\r\nclass Tea : public AbstractDrinking {\r\npublic:\r\n\t//烧水\r\n\tvirtual void Boil() {\r\n\t\tcout << \"煮自来水!\" << endl;\r\n\t}\r\n\t//冲泡\r\n\tvirtual void Brew() {\r\n\t\tcout << \"冲泡茶叶!\" << endl;\r\n\t}\r\n\t//倒入杯中\r\n\tvirtual void PourInCup() {\r\n\t\tcout << \"将茶水倒入杯中!\" << endl;\r\n\t}\r\n\t//加入辅料\r\n\tvirtual void PutSomething() {\r\n\t\tcout << \"加入枸杞!\" << endl;\r\n\t}\r\n};\r\n\r\n//业务函数\r\nvoid DoWork(AbstractDrinking* drink) {\r\n\tdrink->MakeDrink();\r\n\tdelete drink;\r\n}\r\n\r\nvoid test01() {\r\n\tDoWork(new Coffee);\r\n\tcout << \"--------------\" << endl;\r\n\tDoWork(new Tea);\r\n}\r\n\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.7.5 虚析构和纯虚析构\r\n\r\n\r\n\r\n多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\r\n\r\n\r\n\r\n解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**\r\n\r\n\r\n\r\n虚析构和纯虚析构共性：\r\n\r\n* 可以解决父类指针释放子类对象\r\n* 都需要有具体的函数实现\r\n\r\n虚析构和纯虚析构区别：\r\n\r\n* 如果是纯虚析构，该类属于抽象类，无法实例化对象\r\n\r\n\r\n\r\n虚析构语法：\r\n\r\n`virtual ~类名(){}`\r\n\r\n纯虚析构语法：\r\n\r\n` virtual ~类名() = 0;`\r\n\r\n`类名::~类名(){}`\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\nclass Animal {\r\npublic:\r\n\r\n\tAnimal()\r\n\t{\r\n\t\tcout << \"Animal 构造函数调用！\" << endl;\r\n\t}\r\n\tvirtual void Speak() = 0;\r\n\r\n\t//析构函数加上virtual关键字，变成虚析构函数\r\n\t//virtual ~Animal()\r\n\t//{\r\n\t//\tcout << \"Animal虚析构函数调用！\" << endl;\r\n\t//}\r\n\r\n\r\n\tvirtual ~Animal() = 0;\r\n};\r\n\r\nAnimal::~Animal()\r\n{\r\n\tcout << \"Animal 纯虚析构函数调用！\" << endl;\r\n}\r\n\r\n//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\r\n\r\nclass Cat : public Animal {\r\npublic:\r\n\tCat(string name)\r\n\t{\r\n\t\tcout << \"Cat构造函数调用！\" << endl;\r\n\t\tm_Name = new string(name);\r\n\t}\r\n\tvirtual void Speak()\r\n\t{\r\n\t\tcout << *m_Name <<  \"小猫在说话!\" << endl;\r\n\t}\r\n\t~Cat()\r\n\t{\r\n\t\tcout << \"Cat析构函数调用!\" << endl;\r\n\t\tif (this->m_Name != NULL) {\r\n\t\t\tdelete m_Name;\r\n\t\t\tm_Name = NULL;\r\n\t\t}\r\n\t}\r\n\r\npublic:\r\n\tstring *m_Name;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tAnimal *animal = new Cat(\"Tom\");\r\n\tanimal->Speak();\r\n\r\n\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\r\n\t//怎么解决？给基类增加一个虚析构函数\r\n\t//虚析构函数就是用来解决通过父类指针释放子类对象\r\n\tdelete animal;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n总结：\r\n\r\n​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\r\n\r\n​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\r\n\r\n​\t3. 拥有纯虚析构函数的类也属于抽象类\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 4.7.6 多态案例三-电脑组装\r\n\r\n\r\n\r\n**案例描述：**\r\n\r\n\r\n\r\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\r\n\r\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\r\n\r\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\r\n\r\n测试时组装三台不同的电脑进行工作\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n//抽象CPU类\r\nclass CPU\r\n{\r\npublic:\r\n\t//抽象的计算函数\r\n\tvirtual void calculate() = 0;\r\n};\r\n\r\n//抽象显卡类\r\nclass VideoCard\r\n{\r\npublic:\r\n\t//抽象的显示函数\r\n\tvirtual void display() = 0;\r\n};\r\n\r\n//抽象内存条类\r\nclass Memory\r\n{\r\npublic:\r\n\t//抽象的存储函数\r\n\tvirtual void storage() = 0;\r\n};\r\n\r\n//电脑类\r\nclass Computer\r\n{\r\npublic:\r\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\r\n\t{\r\n\t\tm_cpu = cpu;\r\n\t\tm_vc = vc;\r\n\t\tm_mem = mem;\r\n\t}\r\n\r\n\t//提供工作的函数\r\n\tvoid work()\r\n\t{\r\n\t\t//让零件工作起来，调用接口\r\n\t\tm_cpu->calculate();\r\n\r\n\t\tm_vc->display();\r\n\r\n\t\tm_mem->storage();\r\n\t}\r\n\r\n\t//提供析构函数 释放3个电脑零件\r\n\t~Computer()\r\n\t{\r\n\r\n\t\t//释放CPU零件\r\n\t\tif (m_cpu != NULL)\r\n\t\t{\r\n\t\t\tdelete m_cpu;\r\n\t\t\tm_cpu = NULL;\r\n\t\t}\r\n\r\n\t\t//释放显卡零件\r\n\t\tif (m_vc != NULL)\r\n\t\t{\r\n\t\t\tdelete m_vc;\r\n\t\t\tm_vc = NULL;\r\n\t\t}\r\n\r\n\t\t//释放内存条零件\r\n\t\tif (m_mem != NULL)\r\n\t\t{\r\n\t\t\tdelete m_mem;\r\n\t\t\tm_mem = NULL;\r\n\t\t}\r\n\t}\r\n\r\nprivate:\r\n\r\n\tCPU * m_cpu; //CPU的零件指针\r\n\tVideoCard * m_vc; //显卡零件指针\r\n\tMemory * m_mem; //内存条零件指针\r\n};\r\n\r\n//具体厂商\r\n//Intel厂商\r\nclass IntelCPU :public CPU\r\n{\r\npublic:\r\n\tvirtual void calculate()\r\n\t{\r\n\t\tcout << \"Intel的CPU开始计算了！\" << endl;\r\n\t}\r\n};\r\n\r\nclass IntelVideoCard :public VideoCard\r\n{\r\npublic:\r\n\tvirtual void display()\r\n\t{\r\n\t\tcout << \"Intel的显卡开始显示了！\" << endl;\r\n\t}\r\n};\r\n\r\nclass IntelMemory :public Memory\r\n{\r\npublic:\r\n\tvirtual void storage()\r\n\t{\r\n\t\tcout << \"Intel的内存条开始存储了！\" << endl;\r\n\t}\r\n};\r\n\r\n//Lenovo厂商\r\nclass LenovoCPU :public CPU\r\n{\r\npublic:\r\n\tvirtual void calculate()\r\n\t{\r\n\t\tcout << \"Lenovo的CPU开始计算了！\" << endl;\r\n\t}\r\n};\r\n\r\nclass LenovoVideoCard :public VideoCard\r\n{\r\npublic:\r\n\tvirtual void display()\r\n\t{\r\n\t\tcout << \"Lenovo的显卡开始显示了！\" << endl;\r\n\t}\r\n};\r\n\r\nclass LenovoMemory :public Memory\r\n{\r\npublic:\r\n\tvirtual void storage()\r\n\t{\r\n\t\tcout << \"Lenovo的内存条开始存储了！\" << endl;\r\n\t}\r\n};\r\n\r\n\r\nvoid test01()\r\n{\r\n\t//第一台电脑零件\r\n\tCPU * intelCpu = new IntelCPU;\r\n\tVideoCard * intelCard = new IntelVideoCard;\r\n\tMemory * intelMem = new IntelMemory;\r\n\r\n\tcout << \"第一台电脑开始工作：\" << endl;\r\n\t//创建第一台电脑\r\n\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\r\n\tcomputer1->work();\r\n\tdelete computer1;\r\n\r\n\tcout << \"-----------------------\" << endl;\r\n\tcout << \"第二台电脑开始工作：\" << endl;\r\n\t//第二台电脑组装\r\n\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\r\n\tcomputer2->work();\r\n\tdelete computer2;\r\n\r\n\tcout << \"-----------------------\" << endl;\r\n\tcout << \"第三台电脑开始工作：\" << endl;\r\n\t//第三台电脑组装\r\n\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\r\n\tcomputer3->work();\r\n\tdelete computer3;\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 5 文件操作\r\n\r\n\r\n\r\n程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\r\n\r\n通过**文件可以将数据持久化**\r\n\r\nC++中对文件操作需要包含头文件 ==&lt; fstream &gt;==\r\n\r\n\r\n\r\n文件类型分为两种：\r\n\r\n1. **文本文件**     -  文件以文本的**ASCII码**形式存储在计算机中\r\n2. **二进制文件** -  文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们\r\n\r\n\r\n\r\n操作文件的三大类:\r\n\r\n1. ofstream：写操作\r\n2. ifstream： 读操作\r\n3. fstream ： 读写操作\r\n\r\n\r\n\r\n### 5.1文本文件\r\n\r\n#### 5.1.1写文件\r\n\r\n   写文件步骤如下：\r\n\r\n1. 包含头文件   \r\n\r\n     \\#include <fstream\\>\r\n\r\n2. 创建流对象  \r\n\r\n   ofstream ofs;\r\n\r\n3. 打开文件\r\n\r\n   ofs.open(\"文件路径\",打开方式);\r\n\r\n4. 写数据\r\n\r\n   ofs << \"写入的数据\";\r\n\r\n5. 关闭文件\r\n\r\n   ofs.close();\r\n\r\n   ​\r\n\r\n文件打开方式：\r\n\r\n| 打开方式    | 解释                       |\r\n| ----------- | -------------------------- |\r\n| ios::in     | 为读文件而打开文件         |\r\n| ios::out    | 为写文件而打开文件         |\r\n| ios::ate    | 初始位置：文件尾           |\r\n| ios::app    | 追加方式写文件             |\r\n| ios::trunc  | 如果文件存在先删除，再创建 |\r\n| ios::binary | 二进制方式                 |\r\n\r\n**注意：** 文件打开方式可以配合使用，利用|操作符\r\n\r\n**例如：**用二进制方式写文件 `ios::binary |  ios:: out`\r\n\r\n\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n#include <fstream>\r\n\r\nvoid test01()\r\n{\r\n\tofstream ofs;\r\n\tofs.open(\"test.txt\", ios::out);\r\n\r\n\tofs << \"姓名：张三\" << endl;\r\n\tofs << \"性别：男\" << endl;\r\n\tofs << \"年龄：18\" << endl;\r\n\r\n\tofs.close();\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n总结：\r\n\r\n* 文件操作必须包含头文件 fstream\r\n* 读文件可以利用 ofstream  ，或者fstream类\r\n* 打开文件时候需要指定操作文件的路径，以及打开方式\r\n* 利用<<可以向文件中写数据\r\n* 操作完毕，要关闭文件\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 5.1.2读文件\r\n\r\n\r\n\r\n读文件与写文件步骤相似，但是读取方式相对于比较多\r\n\r\n\r\n\r\n读文件步骤如下：\r\n\r\n1. 包含头文件   \r\n\r\n     \\#include <fstream\\>\r\n\r\n2. 创建流对象  \r\n\r\n   ifstream ifs;\r\n\r\n3. 打开文件并判断文件是否打开成功\r\n\r\n   ifs.open(\"文件路径\",打开方式);\r\n\r\n4. 读数据\r\n\r\n   四种方式读取\r\n\r\n5. 关闭文件\r\n\r\n   ifs.close();\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n#include <fstream>\r\n#include <string>\r\nvoid test01()\r\n{\r\n\tifstream ifs;\r\n\tifs.open(\"test.txt\", ios::in);\r\n\r\n\tif (!ifs.is_open())\r\n\t{\r\n\t\tcout << \"文件打开失败\" << endl;\r\n\t\treturn;\r\n\t}\r\n\r\n\t//第一种方式\r\n\t//char buf[1024] = { 0 };\r\n\t//while (ifs >> buf)\r\n\t//{\r\n\t//\tcout << buf << endl;\r\n\t//}\r\n\r\n\t//第二种\r\n\t//char buf[1024] = { 0 };\r\n\t//while (ifs.getline(buf,sizeof(buf)))\r\n\t//{\r\n\t//\tcout << buf << endl;\r\n\t//}\r\n\r\n\t//第三种\r\n\t//string buf;\r\n\t//while (getline(ifs, buf))\r\n\t//{\r\n\t//\tcout << buf << endl;\r\n\t//}\r\n\r\n\tchar c;\r\n\twhile ((c = ifs.get()) != EOF)\r\n\t{\r\n\t\tcout << c;\r\n\t}\r\n\r\n\tifs.close();\r\n\r\n\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n总结：\r\n\r\n- 读文件可以利用 ifstream  ，或者fstream类\r\n- 利用is_open函数可以判断文件是否打开成功\r\n- close 关闭文件 \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 5.2 二进制文件\r\n\r\n以二进制的方式对文件进行读写操作\r\n\r\n打开方式要指定为 ==ios::binary==\r\n\r\n\r\n\r\n#### 5.2.1 写文件\r\n\r\n二进制方式写文件主要利用流对象调用成员函数write\r\n\r\n函数原型 ：`ostream& write(const char * buffer,int len);`\r\n\r\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\r\n\r\n\r\n\r\n**示例：**\r\n\r\n```C++\r\n#include <fstream>\r\n#include <string>\r\n\r\nclass Person\r\n{\r\npublic:\r\n\tchar m_Name[64];\r\n\tint m_Age;\r\n};\r\n\r\n//二进制文件  写文件\r\nvoid test01()\r\n{\r\n\t//1、包含头文件\r\n\r\n\t//2、创建输出流对象\r\n\tofstream ofs(\"person.txt\", ios::out | ios::binary);\r\n\t\r\n\t//3、打开文件\r\n\t//ofs.open(\"person.txt\", ios::out | ios::binary);\r\n\r\n\tPerson p = {\"张三\"  , 18};\r\n\r\n\t//4、写文件\r\n\tofs.write((const char *)&p, sizeof(p));\r\n\r\n\t//5、关闭文件\r\n\tofs.close();\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n总结：\r\n\r\n* 文件输出流对象 可以通过write函数，以二进制方式写数据\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 5.2.2 读文件\r\n\r\n二进制方式读文件主要利用流对象调用成员函数read\r\n\r\n函数原型：`istream& read(char *buffer,int len);`\r\n\r\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\r\n\r\n示例：\r\n\r\n```C++\r\n#include <fstream>\r\n#include <string>\r\n\r\nclass Person\r\n{\r\npublic:\r\n\tchar m_Name[64];\r\n\tint m_Age;\r\n};\r\n\r\nvoid test01()\r\n{\r\n\tifstream ifs(\"person.txt\", ios::in | ios::binary);\r\n\tif (!ifs.is_open())\r\n\t{\r\n\t\tcout << \"文件打开失败\" << endl;\r\n\t}\r\n\r\n\tPerson p;\r\n\tifs.read((char *)&p, sizeof(p));\r\n\r\n\tcout << \"姓名： \" << p.m_Name << \" 年龄： \" << p.m_Age << endl;\r\n}\r\n\r\nint main() {\r\n\r\n\ttest01();\r\n\r\n\tsystem(\"pause\");\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n\r\n\r\n- 文件输入流对象 可以通过read函数，以二进制方式读数据\r\n\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 166.185546875,
          "content": "\n# 🌞🌞🌞 2021年最新整理， C++ 学习资料，含C++ 11 / 14 / 17 / 20 / 23 新特性、入门教程、推荐书籍、优质文章、学习笔记、教学视频等\n<br>\n\n<div align=center>\n\t\n<img width=\"70%\" height=\"70%\" src=\"https://user-images.githubusercontent.com/87457873/134297801-d13053cc-0a5d-4efd-9f02-9343b513fc33.png\"/>\n\t\n## 🚀 直达  [（# C++11）](#cpp_11) [（# C++14）](#cpp_14) [（# C++17）](#cpp_17) [（# C++20）](#cpp_20) [（# C++23）](#cpp_23)\n\n<br>\n\n</div>\n\n# 🔥🔥🔥 [【重磅推荐收藏：C++ 参考手册】](https://c-cpp.com/cpp) - 11~20你想要查的，他都有\n\n# 🌋 C++ 发展历程\n\n* C++ 编程语言的历史可以追溯到 **1979 年**，当时 Bjarne Stroustrup 为博士学位论文进行了一些开发。在 Stroustrup 可以使用的所有语言中，有一种被称为 Simula 的语言，顾名思义，它可能是一种主要为仿真而设计的语言。Simula 67 语言是 Stroustrup 使用的变体，被认为是支持面向对象编程范例的主要语言。Stroustrup 发现这种范例对包装开发很有帮助。但是，Simula 语言对于实践和实际使用而言太慢了。\n随后不久，Bjarne Stroustrup 希望通过支持面向对象范例来增强 C。他深入研究了 Smalltalk 的 OO 实现，以获取有关实现的想法。但是他不愿意为此放弃性能，因此他开始从事 “C with Classes (带有类的 C）” 的工作，希望 C++ 代码运行时应具有与 C 代码相似（或更好）的性能。\n\n* **1983 年**，语言的名称从 “带有类的 C” 更改为 C++。C 语言中的 ++ 运算符是用于递增变量的运算符，它使您可以深入了解 Stroustrup 如何看待该语言。在此期间添加了许多新功能，其中最引人注目的是虚函数，函数重载，带有＆符号的引用，const 关键字和使用两个正斜杠的单行注释。\n\n* **1985 年**，Stroustrup 出版了名为*“C++ 编程语言” 的书籍*。同年，C++ 被实现为商业产品。该语言尚未正式标准化，因此使该书成为非常重要的参考。该语言在 1989 年再次进行了更新，以包括受保护的成员和静态成员，以及从多个类的继承。\n\n* **1990 年**，发行了*《带注释的 C++ 参考手册*》。同年，Borland 的 Turbo C++ 编译器将作为商业产品发布。Turbo C++ 添加了许多其他库，这些库会对 C++ 的开发产生相当大的影响。尽管 Turbo C++ 的最后一个稳定版本是 2006 年，但该编译器仍被广泛使用。\n\n* **1998 年**，C++ 标准委员会发布了第一个 C++ ISO / IEC 14882：1998 国际标准，其非正式名称为 C++ 98。据说*《带注释的 C++ 参考手册*》对标准的制定产生了很大的影响。还包括标准模板库，该模板库于 1979 年开始概念开发。2003 年，该委员会对 1998 年标准所报告的多个问题做出了回应，并对其进行了相应的修订。更改的语言称为 C++ 03。\n\n* **2005 年**，C++ 标准委员会发布了一份技术报告（称为 TR1），详细介绍了他们计划添加到最新 C++ 标准中的各种功能。新标准被非正式地称为 C++ 0x，因为它有望在第一个十年结束之前的某个时间发布。具有讽刺意味的是，新标准要到 2011 年年中才会发布。直到那时为止，已经发布了几份技术报告，并且一些编译器开始为新功能添加实验性支持。\n\n* **2011 年中**，新的 C++ 标准（称为 C++ 11）完成。Boost 库项目对新标准产生了重大影响，其中一些新模块直接来自相应的 Boost 库。一些新功能包括正则表达式支持，全面的随机化库，新的 C++ 时间库，原子支持，标准线程库 ，一种新的 for 循环语法，提供的功能类似于某些其他语言中的 foreach 循环，auto 关键字，新的容器类，对联合和数组初始化列表以及可变参数模板的更好支持。\n\n* **2014 年**，C++ 14（也称为 C++ 1y）作为 C++11 的一个小扩展发布，主要功能是错误修复和小的改进，国际标准投票程序草案于 2014 年 8 月中完成，加强 lambda 函数，constexpr 和类型推导特性。\n\n* **2017 年**，发布 C17 标准，C17 提供了很多东西。增强了核心语言和库。\n\n* **2020 年**，发布 C++20 标准，推出了很多重量级功能，其中比较重要的有：\n\n  - Concepts：概念改变了我们思考和编程模板的方式。它们是模板参数的语义类别。它们使您可以直接在类型系统中表达您的意图。如果出了什么问题，您会收到清晰的错误消息。\n  - Ranges library：新的 ranges 库使它可以直接在容器上执行算法，用管道符号组成算法，并将其应用于无限数据流。\n  - Coroutines：由于协程，C++ 中的异步编程成为主流。协程是协作任务，事件循环，无限数据流或管道的基础。\n  - Modules：模块克服了头文件的限制。头文件和源文件的分离变得和预处理器一样过时了。最后，我们有更快的构建时间和更轻松的构建软件包的方法。\n  - Concurrency：Atomic Smart Pointers,Joining & Cancellable Threads,The C20 Synchronization Library，增强了 C++ 并发编程能力；\n</br>\n\n---\n\n\n# 🚪 入门教程 \n### [C++ 入门教程（41课时） - 阿里云大学](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md)\n* [C++ 教程](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%95%99%E7%A8%8B)\n* [C++ 简介](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E7%AE%80%E4%BB%8B)\n* [C++ 环境设置](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE)\n* [C++ 基本语法](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95)\n* [C++ 注释](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%B3%A8%E9%87%8A)\n* [C++ 数据类型](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)\n* [C++ 变量类型](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B)\n* [C++ 变量作用域](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F)\n* [C++ 常量](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%B8%B8%E9%87%8F)\n* [C++ 修饰符类型](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B)\n* [C++ 存储类](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%AD%98%E5%82%A8%E7%B1%BB)\n* [C++ 运算符](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E8%BF%90%E7%AE%97%E7%AC%A6)\n* [C++ 循环](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%BE%AA%E7%8E%AF)\n* [C++ 判断](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%88%A4%E6%96%AD)\n* [C++ 函数](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%87%BD%E6%95%B0)\n* [C++ 数字](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%95%B0%E5%AD%97)\n* [C++ 数组](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%95%B0%E7%BB%84)\n* [C++ 字符串](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%AD%97%E7%AC%A6%E4%B8%B2)\n* [C++ 指针](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%8C%87%E9%92%88)\n* [C++ 引用](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%BC%95%E7%94%A8)\n* [C++ 日期 & 时间](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%97%A5%E6%9C%9F--%E6%97%B6%E9%97%B4)\n* [C++ 基本的输入输出](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA)\n* [C++ 数据结构](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\n* [C++ 类 & 对象](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E7%B1%BB--%E5%AF%B9%E8%B1%A1)\n* [C++ 继承](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E7%BB%A7%E6%89%BF)\n* [C++ 重载运算符和重载函数](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0)\n* [C++ 多态](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%A4%9A%E6%80%81)\n* [C++ 数据抽象](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1)\n* [C++ 数据封装](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85)\n* [C++ 接口（抽象类）](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB)\n* [C++ 文件和流](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81)\n* [C++ 异常处理](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)\n* [C++ 动态内存](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98)\n* [C++ 命名空间](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4)\n* [C++ 模板](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%A8%A1%E6%9D%BF)\n* [C++ 预处理器](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n* [C++ 信号处理](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86)\n* [C++ 多线程](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E5%A4%9A%E7%BA%BF%E7%A8%8B)\n* [C++ Web 编程](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-web-%E7%BC%96%E7%A8%8B)\n* [C++ STL 教程](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-stl-%E6%95%99%E7%A8%8B)\n* [C++ 标准库](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8841%E8%AF%BE%E6%97%B6%EF%BC%89%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E5%AD%A6.md#c-%E6%A0%87%E5%87%86%E5%BA%93)\n\n### [C++ 学习笔记](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md)\n\n* [一、基础知识](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E4%B8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)\n  * 1、goto 语句(不建议使用)\n  * 2、一维数组\n  * 3、二维数组\n  * 4、函数中的值传递\n  * 5、函数的声明\n  * 6、函数的分文件编写\n  * 7、指针\n    * 7.1 指针的基本概念\n    * 7.2 指针变量的定义和使用\n    * 7.3 指针所占内存空间\n    * 7.4 空指针和野指针\n    * 7.5 const修饰指针\n    * 7.6 指针和数组\n    * 7.7 指针和函数\n    * 7.8 指针、数组、函数\n  * 8、结构体\n    * 8.1 结构体基本概念\n    * 8.2 结构体定义和使用\n    * 8.3 结构体数组\n    * 8.4 结构体指针\n    * 8.5 结构体嵌套结构体\n    * 8.6 结构体做函数参数\n    * 8.7 结构体中 const使用场景\n* [二、核心编程](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E4%BA%8C%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B)\n  * 1、内存分区模型\n    * 1.1 程序运行前\n    * 1.2 程序运行后\n    * 1.3 new操作符\n  * 2、引用\n    * 2.1 引用的基本使用\n    * 2.2 引用注意事项\n    * 2.3 引用做函数参数\n    * 2.4 引用做函数返回值\n    * 2.5 引用的本质\n    * 2.6 常量引用\n  * 3、函数\n    * 3.1 函数默认参数\n    * 3.2 函数占位参数\n    * 3.3 函数重载\n\n# 📚 书籍推荐\n\n* [《深入理解C++11：C++11新特性解析与应用》](https://www.aliyundrive.com/s/LKc1X2mL9G9)\n* [《C++入门经典（第10版）》](https://book.douban.com/subject/30247747/)\n* [《C++ Primer Plus 第6版 中文版(异步图书出品)》](https://www.epubit.com/bookDetails?id=UB7209840d845c9)\n* [《清华计算机图书译丛：精通C++（第9版）》](https://item.jd.com/12432130.html)\n* [《C++高级编程(第4版)》](http://www.tup.tsinghua.edu.cn/booksCenter/book_07894801.html)\n* [《C++游戏编程入门（第4版）(异步图书出品)》](https://item.jd.com/13265350.html)\n* [《STL源码剖析》](https://book.douban.com/subject/1110934/)\n* [《C++程序设计:原理与实践(基础篇)(原书第2版)》](https://book.douban.com/subject/27023080/)\n* [《Accelerated C++中文版》](https://book.douban.com/subject/2280545//)\n* [《C++编程思想(两卷合订本)》](https://book.douban.com/subject/6558198/)\n* [《中文版Effective STL:50条有效使用STL的经验》](https://book.douban.com/subject/1792179/)\n* [《C++编程剖析:问题、方案和设计准则》](https://book.douban.com/subject/5367371/)\n* [《C++ Templates中文版》](https://book.douban.com/subject/1144020/)\n* [《C++设计新思维》](https://book.douban.com/subject/1103566/)\n* [《C++模板元编程》](https://book.douban.com/subject/4136223/)\n* [《C++并发编程实战》](https://book.douban.com/subject/26386925/)\n* [《C++程序设计语言(第1-3部分)(原书第4版)》](https://book.douban.com/subject/26857943/)\n* [《C++标准库(第2版)》](https://book.douban.com/subject/26419721/)\n* [《Essential C++》](https://book.douban.com/subject/24868427/)\n* [《C++ 语言的设计与演化》](https://book.douban.com/subject/1096216/)\n* [《深度探索C++ 对象模型》](https://book.douban.com/subject/1091086/)\n* [《泛型编程与STL》](https://book.douban.com/subject/1241423/)\n\n# 📰 文章推荐\n* [每个c++开发人员都应该使用的10个c++11特性](https://github.com/0voice/cpp_new_features/blob/main/%E6%AF%8F%E4%B8%AAc%2B%2B%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E7%9A%8410%E4%B8%AAc%2B%2B%2011%E7%89%B9%E6%80%A7.md)\n* [在c++项目中你必须真正使用的15个c++11特性](https://github.com/0voice/cpp_new_features/blob/main/%E5%9C%A8c%2B%2B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9C%9F%E6%AD%A3%E4%BD%BF%E7%94%A8%E7%9A%8415%E4%B8%AAc%2B%2B%E7%89%B9%E6%80%A7.md)\n* [如何在 C++11 中使用 Lambda 表达式](https://github.com/0voice/cpp_new_features/blob/main/%E5%A6%82%E4%BD%95%E5%9C%A8%20C%2B%2B11%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F.md)\n* [深入理解C++11](https://github.com/0voice/cpp_new_features/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C%2B%2B11.md)\n* [吐血整理：C++11新特性](https://github.com/0voice/cpp_new_features/blob/main/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86%EF%BC%9AC%2B%2B11%E6%96%B0%E7%89%B9%E6%80%A7.md)\n* [C++11新特性之auto和decltype知识点](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bauto%E5%92%8Cdecltype%E7%9F%A5%E8%AF%86%E7%82%B9)\n* [C++11新特性之左值引用、右值引用、移动语义、完美转发](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91)\n* [C++11新特性之列表初始化](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96)\n* [C++11新特性std::function和lambda表达式](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11%E6%96%B0%E7%89%B9%E6%80%A7stdfunction%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F)\n* [C++11新特性之模板改进](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%94%B9%E8%BF%9B)\n* [C++11新特性之线程相关知识点](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9)\n* [C++11新特性之异步操作-async](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11-%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C-async)\n* [C++11新特性之智能指针](https://github.com/0voice/cpp_new_features/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%2011%E6%96%B0%E7%89%B9%E6%80%A7.md#c11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88)\n* [C++11常用新特性（一）](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B11%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89.md)\n* [C++11常用新特性（二）](https://github.com/0voice/cpp_new_features/blob/main/C++11%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89.md)\n* [C++14新特性浅谈](https://github.com/0voice/cpp_new_features/blob/main/%E3%80%8CNotes%E3%80%8DC%2B%2B14%E6%96%B0%E7%89%B9%E6%80%A7%E6%B5%85%E8%B0%88.md)\n* [C++14新特性的所有知识点全在这儿啦](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B14%E6%96%B0%E7%89%B9%E6%80%A7%E7%9A%84%E6%89%80%E6%9C%89%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A8%E5%9C%A8%E8%BF%99%E5%84%BF%E5%95%A6%EF%BC%81.md)\n* [总结归纳：C++17新特性](https://github.com/0voice/cpp_new_features/blob/main/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%EF%BC%9AC%2B%2B17%E6%96%B0%E7%89%B9%E6%80%A7.md)\n* [C++ 20语言特性](https://github.com/0voice/cpp_new_features/blob/main/C%2B%2B%2020%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7.md)\n\n\n# ▶ 教学视频\n\n#### [【GeekBand】侯捷 - C++面向对象高级编程](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n\n* [P1 C++编程简介](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P2 头文件与类的声明](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P3 构造函数](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P4 参数传递与返回值](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P5 操作符重载与临时对象](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P6 复习Complex类的实现过程](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P7 三大函数：拷贝构造，拷贝复制，析构](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P8 堆，栈与内存管理](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P9 复习String类的实现过程](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P10 扩展补充：类模板，函数模板，及其他](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P11 组合与继承](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P13 委托相关设计](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P14 1 导读](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P15 2 conversion function](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P16 3 non explicit one argument constructor](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P17 4 pointer like classes](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P18 5 function like classes](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P19 6 namespace经验谈](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P20 7 class template](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P21 8 Funtion Template](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P22 9 Member Template](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P23 10 specialization](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P24 11 模板偏特化](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P25 12 模板模板参数](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P26 13 关于C++标准库](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P27 14 三个主题](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P28 15 Reference](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P29 16 复合&继承关系下的构造和析构](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P30 17 关于vptr和vtbl](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P31 18 关于this](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P32 19 0 关于Dynamic Binding](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P33 19 1 关于Dynamic Binding](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P34 20 关于New,Delete](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P35 21 Operator new，operator delete](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P36 22  示例](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P37 23  重载new,delete$示例](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n* [P38 24 Basic String使用newextra扩充申请量](https://www.aliyundrive.com/s/HapPXxjQ1U7)\n\n\n# 🌰 干货铺\n* [C++ Standard Library](http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library) - 一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分\n* [Standard Template Library](https://en.wikipedia.org/wiki/Standard_Template_Library) - 标准模板库\n* [C POSIX library](https://en.wikipedia.org/wiki/C_POSIX_library) - POSIX系统的C标准库规范\n* [ISO C++ Standards Committee](https://github.com/cplusplus) - C++标准委员会\n* [C++ FAQ](https://isocpp.org/faq) − C++ 常见问题\n* [Free Country](https://www.thefreecountry.com/sourcecode/cpp.shtml?spm=5176.10731542.0.0.4fc35bde2jHhz4) − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。\n* [C and C++ Users Group](http://www.hal9k.com/cug/?spm=5176.10731542.0.0.4fc35bde2jHhz4) − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等\n* [LearnCpp](https://www.learncpp.com/) - 免费学习c++编程\n* [CodeCogs](https://www.codecogs.com/) - CodeCogs是一项协作的开放源码库，C/C++的数值方面的组件\n* [codeproject](https://www.codeproject.com/) - codeproject提供的C/C++资源代码项目\n* [thoughtco](https://www.thoughtco.com/c-and-c-plus-programming-4133470) - 游戏有关的C++源代码\n* [Free C/C++ Libraries](https://www.programmerworld.net/resources/c_library.htm) - 免费C++源代码和其它有用的工具\n* [The C++ Standard Library](http://www.josuttis.com/libbook/examples.html) - 这是一个收集了数C/C++网站链接列表的网页\n* [cplusplus](http://www.cplusplus.com/) - C++学习网站\n* [C++ Source Codes](https://people.sc.fsu.edu/~jburkardt/cpp_src/cpp_src.html) - 这是一个全面的关于C++的345个源代码清单\n\n# 🗜 框架\n* [Apache C++ Standard Library](http://stdcxx.apache.org/) : 是一系列算法，容器，迭代器和其他基本组件的集合\n* [ASL](http://stlab.adobe.com/) : Adobe源代码库提供了同行的评审和可移植的C++源代码库。\n* [Boost](https://github.com/boostorg) : 大量通用C++库的集合。\n* [BDE](https://github.com/bloomberg/bde) : 来自于彭博资讯实验室的开发环境。\n* [Cinder](https://libcinder.org/) : 提供专业品质创造性编码的开源开发社区。\n* [Bxxomfort](http://ryan.gulix.cl/fossil.cgi/cxxomfort/index) : 轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。\n* [Dlib](http://dlib.net/) : 使用契约式编程和现代C++科技设计的通用的跨平台的C++库。\n* [EASTL](https://github.com/paulhodge/EASTL) : EA-STL公共部分\n* [ffead-cpp](https://github.com/sumeetchhetri/ffead-cpp) : 企业应用程序开发框架\n* [Folly](https://github.com/facebook/folly) : 由Facebook开发和使用的开源C++库。\n* [JUCE](https://github.com/WeAreROLI/JUCE) : 包罗万象的C++类库，用于开发跨平台软件\n* [libphenom](https://github.com/facebookarchive/libphenom) : 用于构建高性能和高度可扩展性系统的事件框架。\n* [LibSourcey](https://github.com/sourcey/libsourcey) : 用于实时的视频流和高性能网络应用程序的C++11 evented IO\n* [Loki](http://loki-lib.sourceforge.net/) : C++库的设计，包括常见的设计模式和习语的实现。\n* [MiLi](https://code.google.com/p/mili/) : 只含头文件的小型C++库\n* [openFrameworks](https://openframeworks.cc/) : 开发C++工具包，用于创意性编码。\n* [Qt](https://www.qt.io/developers/) : 跨平台的应用程序和用户界面框架\n* [Reason](http://code.google.com/p/reason/) : 跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。\n* [ROOT](https://root.cern.ch/) : 具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。\n* [STLport](http://www.stlport.org/) : 是STL具有代表性的版本\n* [STXXL](http://stxxl.sourceforge.net/) : 用于额外的大型数据集的标准模板库。\n* [Ultimate++](https://www.ultimatepp.org/) : C++跨平台快速应用程序开发框架\n* [Windows Template Library](https://sourceforge.net/projects/wtl/) : 用于开发Windows应用程序和UI组件的C++库\n* [Yomm11](https://github.com/jll63/yomm11) : C++11的开放multi-methods.\n\n<br>\n\n### 异步事件循环\n* [Boost.Asio](https://think-async.com/Asio/) : 用于网络和底层I/O编程的跨平台的C++库。\n* [libev](http://libev.schmorp.de/) : 功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。\n* [libevent](http://libevent.org/) : 事件通知库\n* [libuv](https://github.com/joyent/libuv) : 跨平台异步I/O。\n* [libco](https://github.com/Tencent/libco) : 协程，微信支持8亿用户同时在线的底层IO库。功能强大\n* [libgo](https://github.com/yyzybb537/libgo) : golang风格的并发框架，C++11实现协程库\n\n\n<br>\n\n### 网络库\n* [ACE](https://github.com/cflowe/ACE) : C++面向对象网络变成工具包\n* [Casablanca](https://archive.codeplex.com/?p=casablanca) : C++ REST SDK\n* [cpp-netlib](https://cpp-netlib.org/) : 高级网络编程的开源库集合\n* [libCurl](https://curl.haxx.se/libcurl/) : 多协议文件传输库\n* [Mongoose](https://github.com/cesanta/mongoose) : 非常轻量级的网络服务器\n* [Muduo](https://github.com/chenshuo/muduo) : 用于Linux多线程服务器的C++非阻塞网络库\n* [net_skeleton](https://github.com/cesanta/fossa) : C/C++的TCP 客户端/服务器库\n* [POCO](https://github.com/pocoproject/poco) : 用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。\n* [RakNet](https://github.com/facebookarchive/RakNet) : 为游戏开发人员提供的跨平台的开源C++网络引擎。\n* [Tufao](https://github.com/vinipsmaker/tufao) : 用于Qt之上的C++构建的异步Web框架。\n* [WebSocket++](https://github.com/zaphoyd/websocketpp) : 基于C++/Boost Aiso的websocket 客户端/服务器库\n* [ZeroMQ](http://zeromq.org/) : 高速，模块化的异步通信库\n\n\n<br>\n\n### TCP/IP协议栈\n* [f-stack](https://github.com/f-stack/f-stack) : 腾讯开源的协议栈，基于DPDK的高性能用户态协议栈。\n* [NtyTcp](https://github.com/wangbojing/NtyTcp) : 单线程的协议栈的，基于netmap,DPDK,rawSocket的实现。\n* [LWIP](http://savannah.nongnu.org/projects/lwip/) : 针对 RAM 平台的精简版的 TCP/IP 协议栈实现。\n* [mTCP](https://github.com/mtcp-stack/mtcp) : 针对多核系统的高可扩展性的用户空间 TCP/IP 协议栈。\n* [4.4BSD](https://www.freebsd.org/zh_CN/copyright/license.html) : * nix的协议栈是源于4.4BSD的。\n\n<br>\n\n### WEB应用框架\n\n* [Nginx](http://nginx.org/) : 一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。\n* [Lighttpd](http://www.lighttpd.net/) : 一款开源 Web 服务器软件，安全快速,符合行业标准,适配性强并且针对高配置环境进行了优化。\n* [Libmicrohttpd](http://www.gnu.org/software/libmicrohttpd/) : GNU软件下的简单c库的Web服务器。API简单，快速。\n* [shttpd](http://shttpd.sourceforge.net/) : 基于Mongoose的Web服务器框架。\n* [CivetWeb](https://github.com/bel2125/civetweb) : 提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。\n* [CppCMS](http://cppcms.com/wikipp/en/page/main) : 免费高性能的Web开发框架（不是 CMS）.\n* [Crow](https://github.com/ipkn/crow) : 一个C++微型web框架（灵感来自于Python Flask）\n* [Kore](https://kore.io/) : 使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。\n* [libOnion](https://www.coralbits.com/libonion/) : 轻量级的库，帮助你使用C编程语言创建web服务器。\n* [QDjango](https://github.com/jlaine/qdjango/) : 使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。\n* [Wt](https://www.webtoolkit.eu/wt) : 开发Web应用的C++库。\n\n<br>\n\n### 标准库，算法与函数\n* [C++ Standard Library](http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library) : 是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。\n* [Standard Template Library](https://en.wikipedia.org/wiki/Standard_Template_Library) : 标准模板库, STL\n* [ISO C++ Standards Committee](https://github.com/cplusplus) : C++标准委员会\n\n<br>\n\n### 音频库\n* [FMOD](https://www.fmod.com/) : 易于使用的跨平台的音频引擎和音频内容的游戏创作工具。\n* [Maximilian](https://github.com/micknoise/Maximilian) : C++音频和音乐数字信号处理库\n* [OpenAL](http://www.openal.org/) : 开源音频库—跨平台的音频API\n* [Opus](http://opus-codec.org/) : 一个完全开放的，免版税的，高度通用的音频编解码器\n* [Speex](https://www.speex.org/) : 免费编解码器，为Opus所废弃\n* [Tonic](https://github.com/TonicAudio/Tonic) : C++易用和高效的音频合成\n* [Vorbis](http://xiph.org/vorbis/) : Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。\n\n<br>\n\n### 生态学\n* [lisequence](http://molpopgen.github.io/libsequence/) : 用于表示和分析群体遗传学数据的C++库。\n* [SeqAn](http://www.seqan.de/) : 专注于生物数据序列分析的算法和数据结构。\n* [Vcflib](https://github.com/vcflib/vcflib) : 用于解析和处理VCF文件的C++库\n* [Wham](https://github.com/zeeev/wham) : 直接把联想测试应用到BAM文件的基因结构变异。\n\n<br>\n\n### 压缩\n* [bzip2](http://www.bzip.org/) : 一个完全免费，免费专利和高质量的数据压缩\n* [doboz](https://bitbucket.org/attila_afra/doboz/src) : 能够快速解压缩的压缩库\n* [PhysicsFS](https://icculus.org/physfs/) : 对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。\n* [KArchive](https://projects.kde.org/projects/frameworks/karchive) : 用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。\n* [LZ4](https://code.google.com/p/lz4/) : 非常快速的压缩算法\n* [LZHAM](https://code.google.com/p/lzham/) : 无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。\n* [LZMA](http://www.7-zip.org/sdk.html) : 7z格式默认和通用的压缩方法。\n* [LZMAT](http://www.matcode.com/lzmat.htm) : 及其快速的实时无损数据压缩库\n* [Minizip](https://code.google.com/p/miniz/) : Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。\n* [Snappy](https://code.google.com/p/snappy/) : 快速压缩和解压缩\n* [ZLib](http://zlib.net/) : 非常紧凑的数据流压缩库\n* [ZZIPlib](http://zziplib.sourceforge.net/) : 提供ZIP归档的读权限。\n\n\n<br>\n\n### 并发性\n* [Boost.Compute](https://github.com/boostorg/compute) : 用于OpenCL的C++GPU计算库\n* [Bolt](https://github.com/HSA-Libraries/Bolt) :  针对GPU进行优化的C++模板库\n* [C++React](https://github.com/schlangster/cpp.react) : 用于C++11的反应性编程库\n* [Intel TBB](https://www.threadingbuildingblocks.org/) : Intel线程构件块\n* [Libclsph](https://github.com/libclsph/libclsph) : 基于OpenCL的GPU加速SPH流体仿真库\n* [OpenCL](https://www.khronos.org/opencl/) : 并行编程的异构系统的开放标准\n* [OpenMP](https://www.openmp.org/) : OpenMP API\n* [Thrust](http://thrust.github.io/) : 类似于C++标准模板库的并行算法库\n* [HPX](https://github.com/STEllAR-GROUP/hpx/) : 用于任何规模的并行和分布式应用程序的通用C++运行时系统\n* [VexCL](https://github.com/ddemidov/vexcl) : 用于OpenCL/CUDA 的C++向量表达式模板库。\n\n\n<br>\n\n### 密码学\n* [Bcrypt](http://bcrypt.sourceforge.net/) : 一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。\n* [BeeCrypt](https://github.com/klchang/beecrypt) : 快速的加密图形库，功能强大，接口方便。\n* [Botan](https://botan.randombit.net/) : C++加密库\n* [Crypto++](https://www.cryptopp.com/) : 一个有关加密方案的免费的C++库\n* [GnuPG](https://www.gnupg.org/) : OpenPGP标准的完整实现\n* [GnuTLS](https://www.gnutls.org/) : 实现了SSL，TLS和DTLS协议的安全通信库\n* [Libgcrypt](https://gnupg.org/related_software/libgcrypt/) : 基于GnuPG的加密图形库。\n* [Libmcrypt](https://github.com/winlibs/libmcrypt) : 线程安全，提供统一的API。\n* [LibreSSL](http://www.libressl.org/) : 免费的SSL/TLS协议，属于2014 OpenSSL的一个分支\n* [LibTomCrypt](https://github.com/libtom/libtomcrypt) : 一个非常全面的，模块化的，可移植的加密工具\n* [libsodium](https://github.com/jedisct1/libsodium) : 基于NaCI的加密库，固执己见，容易使用\n* [Nettle](http://www.lysator.liu.se/~nisse/nettle/) : 底层的加密库\n* [OpenSSL](https://www.openssl.org/) : 一个强大的，商用的，功能齐全的，开放源代码的加密库。\n\n<br>\n\n### 数据库\n* [hiberlite](https://github.com/paulftw/hiberlite) : 用于Sqlite3的C++对象关系映射\n* [LevelDB](https://github.com/google/leveldb) : 快速键值存储库\n* [LMDB](https://symas.com/lmdb/technical/) : 符合数据库四大基本元素的嵌入键值存储\n* [MySQL++](https://tangentsoft.com/mysqlpp/home) : 封装了MySql的C API的C++ 包装器\n* [RocksDB](https://github.com/facebook/rocksdb) : 来自Facebook的嵌入键值的快速存储\n* [SQLite](https://www.sqlite.org/index.html) : 一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。\n* [MongoDB](https://www.mongodb.com/) : 一个基于分布式文件存储的数据库\n\n<br>\n\n### 调试\n* [Boost.Test](https://www.boost.org/doc/libs/master/libs/test/doc/html/index.html) : Boost测试库\n* [Catch](https://github.com/catchorg/Catch2) : 一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。\n* [CppUnit](https://www.freedesktop.org/wiki/Software/cppunit/) : 由JUnit移植过来的C++测试框架\n* [GoogleTest](http://code.google.com/p/googletest/) : 谷歌C++测试框架\n* [ig-debugheap](https://github.com/deplinenoise/ig-debugheap) : 用于跟踪内存错误的多平台调试堆\n* [MemTrack](http://www.almostinfinite.com/memtrack.html) : 用于C++跟踪内存分配\n* [MicroProfile](https://bitbucket.org/jonasmeyer/microprofile/src/default/) : 跨平台的网络试图分析器\n* [UnitTest++](http://unittest-cpp.sourceforge.net/) : 轻量级的C++单元测试框架\n\n\n<br>\n\n### 容器\n* [C++ B-Tree](https://code.google.com/p/cpp-btree/) : 基于B树数据结构，实现命令内存容器的模板库\n* [Hashmaps](https://github.com/goossaert/hashmap) : C++中开放寻址哈希表算法的实现\n\n<br>\n\n### 游戏引擎\n* [Cocos2d-x](https://cocos2d-x.org/) : 一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。\n* [Grit](http://gritengine.com/) : 社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。\n* [lrrlicht](http://irrlicht.sourceforge.net/) : C++语言编写的开源高性能的实时#D引擎\n* [PolyCode](http://polycode.org/) : C++实现的用于创建游戏的开源框架（与Lua绑定）。\n\n\n<br>\n\n### 图形库\n* [bgfx](https://github.com/bkaradzic/bgfx) : 跨平台的渲染库\n* [Cairo](http://www.cairographics.org/) : 支持多种输出设备的2D图形库\n* [Horde3D](https://github.com/horde3d/Horde3D) : 一个小型的3D渲染和动画引擎\n* [magnum](https://github.com/mosra/magnum) : C++11和OpenGL 2D/3D 图形引擎\n* [Ogre 3D](https://www.ogre3d.org/) : 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）\n* [OpenSceneGraph](http://www.openscenegraph.org/) : 具有高性能的开源3D图形工具包\n* [Panda3D](https://www.panda3d.org/) : 用于3D渲染和游戏开发的框架，用Python和C++编写。\n* [Skia](https://github.com/google/skia) : 用于绘制文字，图形和图像的完整的2D图形库\n* [urho3d](https://github.com/urho3d/Urho3D) : 跨平台的渲染和游戏引擎。\n\n<br>\n\n### 图像处理\n* [Boost.GIL](https://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html) : 通用图像库\n* [CImg](https://sourceforge.net/projects/cimg/) : 用于图像处理的小型开源C++工具包\n* [FreeImage](http://freeimage.sourceforge.net/) : 开源库，支持现在多媒体应用所需的通用图片格式和其他格式。\n* [GDCM](http://gdcm.sourceforge.net/wiki/index.php/Main_Page) : Grassroots DICOM 库\n* [ITK](https://itk.org/) : 跨平台的开源图像分析系统\n* [Magick++](http://www.imagemagick.org/script/api.php) : ImageMagick程序的C++接口\n* [OpenCV](https://opencv.org/) : 开源计算机视觉类库\n* [tesseract-ocr](https://code.google.com/p/tesseract-ocr/) : OCR引擎\n* [VIGRA](https://github.com/ukoethe/vigra) : 用于图像分析通用C++计算机视觉库\n* [VTK](https://vtk.org/) : 用于3D计算机图形学，图像处理和可视化的开源免费软件系统。\n\n\n<br>\n\n### 国际化\n* [gettext](http://www.gnu.org/software/gettext/) :  GNU gettext\n* [IBM ICU](http://site.icu-project.org/) : 提供Unicode 和全球化支持的C、C++ 和Java库\n* [libiconv](http://www.gnu.org/software/libiconv/) : 用于不同字符编码之间的编码转换库\n\n\n<br>\n\n### Json库\n* [frozen](https://github.com/cesanta/frozen) : C/C++的Jason解析生成器\n* [Jansson](https://github.com/akheron/jansson) : 进行编解码和处理Jason数据的C语言库\n* [jbson](https://github.com/chrismanning/jbson) : C++14中构建和迭代BSON data,和Json 文档的库\n* [JeayeSON](https://github.com/jeaye/jeayeson) : 非常健全的C++ JSON库，只包含头文件\n* [JSON++](https://github.com/hjiang/jsonxx) : C++ JSON 解析器\n* [json-parser](https://github.com/udp/json-parser) : 用可移植的ANSI C编写的JSON解析器，占用内存非常少\n* [json11](https://github.com/dropbox/json11) : 一个迷你的C++11 JSON库\n* [jute](https://github.com/amir-s/jute) : 非常简单的C++ JSON解析器\n* [ibjson](https://github.com/vincenthz/libjson) : C语言中的JSON解析和打印库，很容易和任何模型集成\n* [libjson](https://sourceforge.net/projects/libjson/) : 轻量级的JSON库\n* [PicoJSON](https://github.com/kazuho/picojson) : C++中JSON解析序列化，只包含头文件\n* [Qt-Json](https://github.com/qt-json/qt-json) : 用于JSON数据和 QVariant层次间的相互解析的简单类\n* [QJson](https://github.com/flavio/qjson) : 将JSON数据映射到QVariant对象的基于Qt的库\n* [RepidJSON](https://github.com/Tencent/rapidjson) : 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API\n\n\n<br>\n\n### 日志\n* [Boost.Log](http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html) : 设计非常模块化，并且具有扩展性\n* [easyloggingpp](https://github.com/zuhd-org/easyloggingpp) : C++日志库，只包含单一的头文件。\n* [Log4cpp](http://log4cpp.sourceforge.net/) : 一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。\n* [templog](http://www.templog.org/) : 轻量级C++库，可以添加日志到你的C++应用程序中\n\n\n<br>\n\n### 机器学习，人工智能\n\n* [btsk](https://github.com/aigamedev/btsk) : 游戏行为树启动器工具\n* [Evolving Objects](http://eodev.sourceforge.net/) : 基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。\n* [Caffe](https://github.com/BVLC/caffe) : 快速的神经网络框架\n* [CCV](https://github.com/liuliu/ccv) : 以C语言为核心的现代计算机视觉库\n* [mlpack](http://www.mlpack.org/) :  可扩展的C++机器学习库\n* [OpenCV](https://github.com/opencv/opencv) : 开源计算机视觉库\n* [Recommender](https://github.com/GHamrouni/Recommender) : 使用协同过滤进行产品推荐/建议的C语言库。\n* [SHOGUN](https://github.com/shogun-toolbox/shogun) : Shogun 机器学习工具\n* [sofia-ml](https://code.google.com/p/sofia-ml/) : 用于机器学习的快速增量算法套件\n\n\n\n<br>\n\n### 数学库\n\n* [Armadillo](http://arma.sourceforge.net/) : 高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似\n* [blaze](https://code.google.com/p/blaze-lib/) : 高性能的C++数学库，用于密集和稀疏算法。\n* [ceres-solver](http://ceres-solver.org/) : 来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。\n* [CGal](http://www.cgal.org/) : 高效，可靠的集合算法集合\n* [CML](https://github.com/demianmnave/CML/wiki/The-Configurable-Math-Library) : 用于游戏和图形的免费C++数学库\n* [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page) : 高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。\n* [GMTL](http://ggt.sourceforge.net/) : 数学图形模板库是一组广泛实现基本图形的工具。\n* [GMP](https://gmplib.org/) : 用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。\n\n\n<br>\n\n### 多媒体库\n\n* [GStreamer](https://gstreamer.freedesktop.org/) : 构建媒体处理组件图形的库\n* [LIVE555 Streaming Media](http://www.live555.com/liveMedia/) : 使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库\n* [libVLC](https://wiki.videolan.org/LibVLC) : libVLC (VLC SDK)媒体框架\n* [QtAV](https://github.com/wang-bin/QtAV) : 基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器\n* [SDL](http://www.libsdl.org/) : 简单直控媒体层\n* [SFML](http://www.sfml-dev.org/) : 快速，简单的多媒体库\n\n\n<br>\n\n### 物理学\n* [Box2D](https://code.google.com/p/box2d/) : 2D的游戏物理引擎。\n* [Bullet](https://github.com/bulletphysics/bullet3) : 3D的游戏物理引擎。\n* [Chipmunk](https://github.com/slembcke/Chipmunk2D) : 快速，轻量级的2D游戏物理库\n* [LiquidFun](https://github.com/google/liquidfun) : 2D的游戏物理引擎\n* [ODE](http://www.ode.org/) : 开放动力学引擎-开源，高性能库，模拟刚体动力学。\n* [ofxBox2D](https://github.com/vanderlin/ofxBox2d) : Box2D开源框架包装器。\n* [Simbody](https://github.com/simbody/simbody) : 高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。\n\n<br>\n\n### 机器人学\n* [MOOS-Ivp](http://moos-ivp.org/) : 一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。\n* [MRPT](https://www.mrpt.org/) : 移动机器人编程工具包\n* [PCL](https://github.com/PointCloudLibrary/pcl) : 点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。\n* [Robotics Library](http://www.roboticslibrary.org/) : 一个独立的C++库，包括机器人动力学，运动规划和控制。\n* [RobWork](http://www.robwork.dk/apidoc/nightly/rw/) : 一组C++库的集合，用于机器人系统的仿真和控制。\n* [ROS](http://wiki.ros.org/) : 机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。\n\n<br>\n\n\n<br>\n\n### 脚本\n* [ChaiScript](https://github.com/ChaiScript/ChaiScript/) : 用于C++的易于使用的嵌入式脚本语言。\n* [Lua](http://www.lua.org/) : 用于配置文件和基本应用程序脚本的小型快速脚本引擎。\n* [luacxx](https://github.com/dafrito/luacxx) : 用于创建Lua绑定的C++ 11 API\n* [SWIG](http://www.swig.org/) : 一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器\n* [V7](https://github.com/cesanta/v7) : 嵌入式的JavaScript 引擎。\n* [V8](http://code.google.com/p/v8/) : 谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。\n\n<br>\n\n### 序列化\n* [Cap'n Proto](https://capnproto.org/) : 快速数据交换格式和RPC系统。\n* [cereal](https://github.com/USCiLab/cereal) : C++11 序列化库\n* [FlatBuffers](https://github.com/google/flatbuffers) : 内存高效的序列化库\n* [MessagePack](https://github.com/msgpack/msgpack-c) : C/C++的高效二进制序列化库，例如 JSON\n* [ProtoBuf](http://code.google.com/p/protobuf/) : 协议缓冲，谷歌的数据交换格式。\n* [SimpleBinaryEncoding](https://github.com/real-logic/simple-binary-encoding) : 用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。\n* [Thrift](https://thrift.apache.org/) : 高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Facebook开发。\n\n\n<br>\n\n### 视频库\n* [libvpx](http://www.webmproject.org/code/) : VP8/VP9编码解码SDK\n* [FFMpeg](https://www.ffmpeg.org/) : 一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。\n* [libde265](https://github.com/strukturag/libde265) : 开放的h.265视频编解码器的实现。\n* [OpenH264](https://github.com/cisco/openh264) : 开源H.364 编解码器。\n* [Theora](https://www.theora.org/) : 免费开源的视频压缩格式。\n\n\n\n<br>\n\n### XML库\n\n* [LibXml++](http://libxmlplusplus.sourceforge.net/) : C++的xml解析器\n* [PugiXML](https://pugixml.org/) : 用于C++的，支持XPath的轻量级，简单快速的XML解析器。\n* [RapidXML](http://rapidxml.sourceforge.net/) : 试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。\n* [TinyXML](https://sourceforge.net/projects/tinyxml/) : 简单小型的C++XML解析器，可以很容易地集成到其它项目中。\n* [TinyXML2](https://github.com/leethomason/tinyxml2) : 简单快速的C++CML解析器，可以很容易集成到其它项目中。\n* [TinyXML++](https://code.google.com/p/ticpp/) : TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。\n* [Xerces-C++](http://xerces.apache.org/xerces-c/) : 用可移植的C++的子集编写的XML验证解析器。\n\n\n---\n\n<div id=\"cpp_11\" align=center>\n\t\n<img width=\"30%\" height=\"30%\" src=\"https://user-images.githubusercontent.com/87457873/134301566-dfe24e96-44a5-48b7-9294-f72c49010c2f.jpg\"/>\n\n</div>\n\n# 🖥 部分代码案例\n\n### <h3 id=\"cpp_11_keywords\">关键字</h3>\n\n#### <h5 id=\"cpp_11_new_keywords\">新增关键字</h5>\n\n* [thread_local](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#thread_local)\n* [static_assert](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#static_assert)\n* [nullptr](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#nullptr)\n* [noexcept](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#noexcept)\n* [decltype](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#decltype)\n* [constexpr](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#constexpr)\n* [char16_t](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#char16_t)\n* [char32_t](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#char16_t)\n* [alignof](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#alignof)\n* [alignas](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_new_keywords_README.md#alignof)\n\n\n#### <h5 id=\"cpp_11_meaning_changed__OR__new_meaning_added\">含义变化或者新增含义关键字（meaning changed or new meaning added）</h5>\n\n* [auto](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#auto)\n* [class](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#clazz)\n* [default](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#default)\n* [delete](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#delete)\n* [export](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#export)\n* [extern](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#extern)\n* [inline](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#inline)\n* [mutable](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#mutable)\n* [sizeof](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#sizeof)\n* [struct](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#struct)\n* [using](https://github.com/0voice/cpp_new_features/blob/main/cpp_11/001_meaning_keywords_README.md#using)\n\n### <h3 id=\"cpp_11_RTTI\">类型支持（基本类型、RTTI、类型特性）</h3>\n\n#### <h5 id=\"cpp_11_RTTI_Primary_type_categories\">Defined in header &lt;type_traits&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_void.cpp\">is_void</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_integral.cpp\">is_integral</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_floating_point.cpp\">is_floating_point</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_array.cpp\">is_array</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_enum.cpp\">is_enum</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_union.cpp\">is_union</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_class.cpp\">is_class</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_function.cpp\">is_function</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_pointer.cpp\">is_pointer</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_lvalue_reference.cpp\">is_lvalue_reference</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_rvalue_reference.cpp\">is_rvalue_reference</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_member_object_pointer.cpp\">is_member_object_pointer</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_member_function_pointer.cpp\">is_member_function_pointer</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_fundamental.cpp\">is_fundamental</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_arithmetic.cpp\">is_arithmetic</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_scalar.cpp\">is_scalar</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_object.cpp\">is_object</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_compound.cpp\">is_compound</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_reference.cpp\">is_reference</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_member_pointer.cpp\">is_member_pointer</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_const.cpp\">is_const</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_volatile.cpp\">is_volatile</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivial.cpp\">is_trivial</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_copyable.cpp\">is_trivially_copyable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_standard_layout.cpp\">is_standard_layout</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_literal_type.cpp\">is_literal_type</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_empty.cpp\">is_empty</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_polymorphic.cpp\">is_polymorphic</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_abstract.cpp\">is_abstract</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_signed.cpp\">is_signed</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_unsigned.cpp\">is_unsigned</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_constructible.cpp\">is_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_constructible.cpp\">is_trivially_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_constructible.cpp\">is_nothrow_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_default_constructible.cpp\">is_default_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_default_constructible.cpp\">is_trivially_default_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_default_constructible.cpp\">is_nothrow_default_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_copy_constructible.cpp\">is_copy_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_copy_constructible.cpp\">is_trivially_copy_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_copy_constructible.cpp\">is_nothrow_copy_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_move_constructible.cpp\">is_move_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_move_constructible.cpp\">is_trivially_move_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_move_constructible.cpp\">is_nothrow_move_constructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_assignable.cpp\">is_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_assignable.cpp\">is_trivially_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_assignable.cpp\">is_nothrow_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_copy_assignable.cpp\">is_copy_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_copy_assignable.cpp\">is_trivially_copy_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_copy_assignable.cpp\">is_nothrow_copy_assignable</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_is_move_assignable.cpp\">is_move_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_move_assignable.cpp\">is_trivially_move_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_move_assignable.cpp\">is_nothrow_move_assignable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_destructible.cpp\">is_destructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_trivially_destructible.cpp\">is_trivially_destructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_is_nothrow_destructible.cpp\">is_nothrow_destructible</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_rtti_std_has_virtual_destructor.cpp\">has_virtual_destructor</a>\n\n\n### <h3 id=\"cpp_11_stl\">STL容器</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_array.cpp\">std::array</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_forward_list.cpp\">std::forward_list</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_begin.cpp\">std::begin</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_end.cpp\">std::end</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_move.cpp\">std::move</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_container_init.cpp\">容器初始化</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_emplace.cpp\">emplace</a>\n\n#### <h5 id=\"cpp_11_unordered_containers\">无序容器</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unordered_map.cpp\">std::unordered_map</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unordered_multimap.cpp\">std::unordered_multimap</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unordered_set.cpp\">std::unordered_set</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unordered_multiset.cpp\">std::unordered_multiset</a>\n\n#### <h5 id=\"cpp_11_tuple\">元组std::tuple</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_make_tuple.cpp\">std::make_tuple</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_get.cpp\">std::get</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_tie.cpp\">std::tie</a>\n\n#### <h5 id=\"cpp_11_hash\">hash</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_string.cpp\">std::hash&lt;std::string&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_u16string.cpp\">std::hash&lt;std::u16string&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_u32string.cpp\">std::hash&lt;std::u32string&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_wstring.cpp\">std::hash&lt;std::wstring&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_error_code.cpp\">std::hash&lt;std::error_code&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_bitset.cpp\">std::hash&lt;std::bitset&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_type_index.cpp\">std::hash&lt;std::type_index&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_hash_std_vector_bool.cpp\">std::hash&lt;std::vector&lt;bool&gt;&gt;</a>\n<!-- \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_hash_std_thread_id.cpp\">std::hash&lt;std&#58;&#58;thread&#58;&#58;id&gt;</a>\n -->\n\n### <h3 id=\"cpp_11_smart_pointer\">智能指针</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_shared_ptr.cpp\">std::shared_ptr</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_weak_ptr.cpp\">std::weak_ptr</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unique_ptr.cpp\">std::unique_ptr</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_auto_ptr.cpp\">auto_ptr(弃用)</a>\n\n### <h3 id=\"cpp_11_regex\">正则表达式</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_shared_ptr.cpp\">basic_regex</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_weak_ptr.cpp\">sub_match</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unique_ptr.cpp\">match_results</a>\n\n### <h3 id=\"cpp_11_function\">函数</h3>\n\n#### <h5 id=\"cpp_11_function_nonstatic\">非静态成员函数</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_shared_ptr.cpp\">cv限定函数</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_weak_ptr.cpp\">引用限定</a>\n\n#### <h5 id=\"cpp_11_function_template\">函数对象模板</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unique_ptr.cpp\">std::function</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unique_ptr.cpp\">std::bind</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unique_ptr.cpp\">std::bad_function_call</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_stl_std_unique_ptr.cpp\">mem_fn</a>\n\n### <h3 id=\"cpp_11_class\">类</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_class_type_alias.cpp\">类型别名</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_class_member_init.cpp\">类成员初始化</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_class_functor.cpp\">仿函数(functor)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_class_delegating_constructors.cpp\">委托构造函数</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_class_inheritance_constructor.cpp\">继承构造函数</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_class_move_constructor.cpp\">移动构造函数</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_class_move_assignment_operator.cpp\">移动赋值运算符</a>\n\n### <h3 id=\"cpp_11_template\">模板</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_template_angle_bracket.cpp\">尖括号“>”</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_template_aliases.cpp\">别名模板</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_template_external_template.cpp\">外部模板</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_template_variable_parameter_template.cpp\">可变参数模板</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_template_default_template_parameters.cpp\">默认模板参数</a>\n\n\n### <h3 id=\"cpp_11_template\">原子操作</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_bool.cpp\">std::atomic&lt;bool&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_char.cpp\">std::atomic&lt;char&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_signed_char.cpp\">std::atomic&lt;signed char&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_unsigned_char.cpp\">std::atomic&lt;unsigned char&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_short.cpp\">std::atomic&lt;short&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_unsigned_short.cpp\">std::atomic&lt;unsigned short&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_int.cpp\">std::atomic&lt;int&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_unsigned_int.cpp\">std::atomic&lt;unsigned int&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_long.cpp\">std::atomic&lt;long&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_unsigned_long.cpp\">std::atomic&lt;unsigned long&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_long_long.cpp\">std::atomic&lt;long long&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_unsigned_long_long.cpp\">std::atomic&lt;unsigned long long&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_char8_t.cpp\">std::atomic&lt;char8_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_char16_t.cpp\">std::atomic&lt;char16_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_char32_t.cpp\">std::atomic&lt;char32_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_wchar_t.cpp\">std::atomic&lt;wchar_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int8_t.cpp\">std::atomic&lt;std::int8_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint8_t.cpp\">std::atomic&lt;std::uint8_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int16_t.cpp\">std::atomic&lt;std::int16_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint16_t.cpp\">std::atomic&lt;std::uint16_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int32_t.cpp\">std::atomic&lt;std::int32_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint32_t.cpp\">std::atomic&lt;std::uint32_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int64_t.cpp\">std::atomic&lt;std::int64_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint64_t.cpp\">std::atomic&lt;std::uint64_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_least8_t.cpp\">std::atomic&lt;std::int_least8_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_least8_t.cpp\">std::atomic&lt;std::uint_least8_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_least16_t.cpp\">std::atomic&lt;std::int_least16_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_least16_t.cpp\">std::atomic&lt;std::uint_least16_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_least32_t.cpp\">std::atomic&lt;std::int_least32_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_least32_t.cpp\">std::atomic&lt;std::uint_least32_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_least64_t.cpp\">std::atomic&lt;std::int_least64_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_least64_t.cpp\">std::atomic&lt;std::uint_least64_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_fast8_t.cpp\">std::atomic&lt;std::int_fast8_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_fast8_t.cpp\">std::atomic&lt;std::uint_fast8_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_fast16_t.cpp\">std::atomic&lt;std::int_fast16_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_fast16_t.cpp\">std::atomic&lt;std::uint_fast16_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_fast32_t.cpp\">std::atomic&lt;std::int_fast32_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_fast32_t.cpp\">std::atomic&lt;std::uint_fast32_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_int_fast64_t.cpp\">std::atomic&lt;std::int_fast64_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uint_fast64_t.cpp\">std::atomic&lt;std::uint_fast64_t&gt;</a>\n<!--\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_intptr_t.cpp\">std::atomic&lt;std::intptr_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uintptr_t.cpp\">std::atomic&lt;std::uintptr_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_size_t.cpp\">std::atomic&lt;std::size_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_ptrdiff_t.cpp\">std::atomic&lt;std::ptrdiff_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_intmax_t.cpp\">std::atomic&lt;std::intmax_t&gt;</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_atomic_std_uintmax_t.cpp\">std::atomic&lt;std::uintmax_t&gt;</a>\n-->\n\n\n### <h3 id=\"cpp_11_template\">线程</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_thread.cpp\">std::thread</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_mutex.cpp\">std::mutex</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_lock.cpp\">std::lock</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_call_once.cpp\">std::call_once</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_atomic.cpp\">std::atomic</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_cond_ition_variable.cpp\">std::cond_ition_variable</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_async.cpp\">std::async</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_volatile.cpp\">volatile</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_future.cpp\">std::future</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_std_thread_std_thread_local.cpp\">std::thread_local</a>\n\n\n### <h3 id=\"cpp_11_exception\">异常</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_exception_ptr.cpp\">std::exception_ptr</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_make_exception_ptr.cpp\">std::make_exception_ptr</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_current_exception.cpp\">std::current_exception</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_rethrow_exception.cpp\">std::rethrow_exception</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_nested_exception.cpp\">std::nested_exception</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_throw_with_nested.cpp\">std::throw_with_nested</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_rethrow_if_nested.cpp\">std::rethrow_if_nested</a>\n<!--\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_noexcept.cpp\">std::noexcept</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_exception_std_terminate_handler.cpp\">std::terminate_handler</a>\n-->\n### <h3 id=\"cpp_11_error\">错误</h3>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_error_std_error_category.cpp\">std::error_category</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_error_std_generic_category.cpp\">std::generic_category</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_error_std_error_condition.cpp\">std::error_condition</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_error_std_errc.cpp\">std::errc</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_error_std_error_code.cpp\">std::error_code</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/003_error_std_system_error.cpp\">std::system_error</a>\n\n\n### <h3 id=\"cpp_11_keywords\">新语法</h3>\n\n#### <h5 id=\"cpp_11_new_pretreatment\">预处理</h5>\n\n* <p>语法：__pragma(字符串字面量)</p>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_pragma.cpp\">_Pragma运算符</a>\n\n#### <h5 id=\"cpp_11_cplusplus_macro\">C++宏(cplusplus macro)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_cpluscplus.h\">_cplusplus宏</a>\n\n#### <h5 id=\"cpp_11_for\">基于范围的for语句</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_for_loop.cpp\">for循环 for(x:range)</a>\n\n####  <h5 id=\"cpp_11_alignment_support\">对齐支持(alignment support)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_alignof.cpp\">alignof</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_alignas.cpp\">alignas</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_alignment_of.cpp\">std::alignment_of</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_aligned_storage.cpp\">std::aligned_storage</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_max_align_t.cpp\">std::max_align_t</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_align.cpp\">std::align</a>\n\n####  <h5 id=\"cpp_11_explicit_conversion_operators\">显式转换操作符(explicit conversion operators)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_explicit.cpp\">explicit关键字</a>\n\n####  <h5 id=\"cpp_11_static_assert\">静态断言(static assert)</h5>\n\n* <p>语法：static_assert(常量表达式，\"提示字符串\")</p>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_static_assert.cpp\">static assert</a>\n\n####  <h5 id=\"cpp_11_numeric_limits\">数字限制(numeric limits)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_numeric_limits.cpp\">数字限制</a>\n\n####  <h5 id=\"cpp_11_raw_string\">原始字符串(raw string)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_raw_string.cpp\">原始字符串</a>\n\n####  <h5 id=\"cpp_11_trailing_return_type_syntax\">追踪返回类型语法(trailing return type syntax)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_trailing_return_type_syntax.cpp\">追踪返回类型语法</a>\n\n####  <h5 id=\"cpp_11_extended_friend_syntax\">扩展的friend语法(extended friend syntax)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_extended_friend_syntax.cpp\">扩展的friend语法</a>\n\n####  <h5 id=\"cpp_11_extended_integer_types\">扩展的整型(extended integer types)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_extended_integer_types.cpp\">扩展的整型</a>\n\n####  <h5 id=\"cpp_11_unrestricted_union\">非受限联合体(unrestricted union)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_unrestricted_union.cpp\">非受限联合体</a>\n\n####  <h5 id=\"cpp_11_lnline_namespace\">内联名字空间(lnline namespace)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_lnline.cpp\">内联名字空间</a>\n\n####  <h5 id=\"cpp_11_user_defined_literals\">用户定义的字面量(user-defined literals)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_user_defined_literals.cpp\">用户定义的字面量</a>\n\n####  <h5 id=\"cpp_11_enum_class\">强类型枚举(scoped and strongly typed enums)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_scoped_and_strongly_typed_enums.cpp\">强类型枚举</a>\n\n####  <h5 id=\"cpp_11_random_device\">随机装置(random device)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_random_device.cpp\">random device</a>\n\n####  <h5 id=\"cpp_11_stdref_std_cref\">std::ref和std::cref</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_stdref_stdcref.cpp\">std::ref和std::cref</a>\n\n####  <h5 id=\"cpp_11_constexpr\">常量表达式(constexpr)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_constexpr.cpp\">constexpr</a>\n\n####  <h5 id=\"cpp_11_lamda\">lamda表达式</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_lamda.cpp\">lamda表达式</a>\n\n####  <h5 id=\"cpp_11_nullptr\">指针空值(nullptr)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_nullptr.cpp\">nullptr</a>\n\n####  <h5 id=\"cpp_11_preventing_narrowing\">防止类型收窄(Preventing narrowing)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_preventing_narrowing.cpp\">防止类型收窄</a>\n\n####  <h5 id=\"cpp_11_initializer_lists\">初始化列表(initializer lists)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_initializer_lists01.cpp\">初始化列表——Initializer List</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_initializer_lists02.cpp\">initializer_list<T>(作入参)</a>\n\n####  <h5 id=\"cpp_11_Uniform_initialization_syntax_and_semantics\">统一的初始化语法和语义(Uniform initialization syntax and semantics)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_Uniform_initialization_syntax_and_semantics.cpp\">统一的初始化语法和语义</a>\n\n####  <h5 id=\"cpp_11_POD\">POD(plain old data)</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_POD.cpp\">POD</a>\n\t\t\t\t\t\t\t\n####  <h5 id=\"cpp_11_POD\">long long整型</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_long_long.cpp\">long long</a>\n\t\n####  <h5 id=\"cpp_11_move_semantics\">移动语义(move semantics)</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_move_semantics.cpp\">move semantics</a>\n\t\n####  <h5 id=\"cpp_11_rvalue_reference\">右值引用(rvalue reference)</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_rvalue_reference.cpp\">rvalue reference</a>\n\n####  <h5 id=\"cpp_11_c99\">c99特性(c99)</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_c99.cpp\">c99特性</a>\n\n####  <h5 id=\"cpp_11_SFINAE\">一般化的SFINAE规则(generalized SFINAE rules)</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_11/002_grammar_SFINAE.cpp\">generalized SFINAE rules</a>\n\t\n-----\t\n\t\n<div  id=\"cpp_14\" align=center>\n\t\n<img width=\"30%\" height=\"30%\" src=\"https://user-images.githubusercontent.com/87457873/134302218-7e6d1586-7210-4121-8aa0-244ddb37572a.jpg\"/>\n\n</div>\t\t\n\t\n\n### <h3 id=\"cpp_14_RTTI\">类型支持（基本类型、RTTI、类型特性）</h3>\n\t\n### <h5 id=\"cpp_headfile_type_traits\">Defined in header&lt;type_traits&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_type_traits_is_null_pointer.cpp\">检查类型是否为 std::nullptr_t</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_type_traits_is_final.cpp\">is_final(检查类型是否为 final 类类型)</a>\n\n### <h5 id=\"cpp_headfile_utility\">Defined in header&lt;utility&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_utility_exchange.cpp\">exchange(将实参替换为一个新值，并返回其先前值)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_utility_integer_sequence.cpp\">integer_sequence(实现编译时整数数列)</a>\n\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header&lt;initializer_list&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_initializer_list_rbegin.cpp\">rbegin(返回指向一个容器或数组的逆向迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_initializer_list_crbegin.cpp\">crbegin(返回指向一个容器或数组的逆向迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_initializer_list_rend.cpp\">rend(返回容器或数组的逆向尾迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_initializer_list_crend.cpp\">crend(返回容器或数组的逆向尾迭代器)</a>\n\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header&lt;iterator&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in namespace std</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_iterator_make_reverse_iterator.cpp\">make_reverse_iterator(创建拥有从实参推出的类型的 std::reverse_iterator)</a>\n\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;array&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;deque&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;forward_list&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;iterator&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;list&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;map&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;regex&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;set&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;span&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;string&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;string_view&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;unordered_map&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;unordered_set&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;vector&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in namespace std</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_begin.cpp\">begin(返回指向容器或数组起始的迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_cbegin.cpp\">cbegin(返回指向容器或数组起始的迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_end.cpp\">end(返回指向容器或数组结尾的迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_cend.cpp\">cend(返回指向容器或数组结尾的迭代器)</a>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_rbegin.cpp\">rbegin(返回指向一个容器或数组的逆向迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_crbegin.cpp\">crbegin(返回指向一个容器或数组的逆向迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_rend.cpp\">rend(返回容器或数组的逆向尾迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_14/001_stl_crend.cpp\">crend(返回容器或数组的逆向尾迭代器)</a>\t\n\n\n<!--\t\n* [函数返回值类型推导](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_01)\n* [lambda参数auto](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_02)\n* [变量模板](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_03)\n* [别名模板](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_04)\n* [[[deprecated]]标记](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_05)\n* [二进制字面量与整形字面量分隔符](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_06)\n* [std::make_unique](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_07)\n* [std::shared_timed_mutex与std::shared_lock](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_08)\n* [std::integer_sequence](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_09)\n* [std::exchange](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_10)\n* [std::quoted](https://github.com/0voice/cpp_new_features/blob/main/cpp_14/README.md#cpp_14_11)\n-->\n\t\n-----\n\n<div id=\"cpp_17\" align=center>\n\t\n<img width=\"30%\" height=\"30%\" src=\"https://user-images.githubusercontent.com/87457873/134302312-2c3ddfc0-7942-4263-9b02-4cec08c18e2f.jpg\"/>\n\n</div>\t\n\t\n\n### <h3 id=\"cpp_17_keywords\">关键字</h3>\n\n#### <h5 id=\"cpp_17_meaning_changed__OR__new_meaning_added\">含义变化或者新增含义关键字（meaning changed or new meaning added）</h5>\n\n* [register](https://github.com/0voice/cpp_new_features/blob/main/cpp_17/001_keywords_README.md#register)\n\t\n### <h3 id=\"cpp_17_RTTI\">类型支持（基本类型、RTTI、类型特性）</h3>\n\t\n### <h5 id=\"cpp_headfile_type_traits\">Defined in header&lt;type_traits&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_byte.cpp\">byte(字节类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_aggregate.cpp\">is_aggregate(检查类型是否聚合类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_swappable_with.cpp\">is_swappable_with(检查一个类型的对象是否能与同类型或不同类型的对象交换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_swappable.cpp\">is_swappable(检查一个类型的对象是否能与同类型或不同类型的对象交换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_nothrow_swappable_with.cpp\">is_nothrow_swappable_with(检查一个类型的对象是否能与同类型或不同类型的对象交换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_nothrow_swappable.cpp\">is_nothrow_swappable(检查一个类型的对象是否能与同类型或不同类型的对象交换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_invocable.cpp\">is_invocable(检查类型能否以给定的实参类型调用（如同以 std::invoke）)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_invocable_r.cpp\">is_invocable_r(检查类型能否以给定的实参类型调用（如同以 std::invoke）)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_nothrow_invocable.cpp\">is_nothrow_invocable(检查类型能否以给定的实参类型调用（如同以 std::invoke）)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_is_nothrow_invocable_r.cpp\">is_nothrow_invocable_r(检查类型能否以给定的实参类型调用（如同以 std::invoke）)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_invoke_result.cpp\">invoke_result(推导以一组实参调用一个可调用对象的结果类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_void_t.cpp\">void_t(变参别名模板)</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_conjunction.cpp\">conjunction(变参的逻辑与元函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_disjunction.cpp\">disjunction(变参的逻辑或元函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_ndisjunctionegation.cpp\">ndisjunctionegation(逻辑非元函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/002_type_traits_integral_constant.cpp\">integral_constant(具有指定值的指定类型的编译期常量)</a>\n\n### <h5 id=\"cpp_headfile_utility\">Defined in header&lt;utility&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/003_utility_as_const.cpp\">as_const(获得到其实参的 const 引用)</a>\n<!--\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/003_utility_in_place.cpp\">in_place(原位构造标签)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/003_utility_in_place_type.cpp\">in_place_type(原位构造标签)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/003_utility_in_place_index.cpp\">in_place_index(原位构造标签)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/003_utility_in_place_t.cpp\">in_place_t(原位构造标签)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/003_utility_in_place_type_t.cpp\">in_place_type_t(原位构造标签)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/003_utility_in_place_index_t.cpp\">in_place_index_t(原位构造标签)</a>\n-->\n\t\n### <h5 id=\"cpp_headfile_tuple\">Defined in header&lt;tuple&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/004_tuple_apply.cpp\">apply(以一个实参的元组来调用函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/004_tuple_make_from_tuple.cpp\">make_from_tuple(以一个实参元组构造对象)</a>\n\n### <h5 id=\"cpp_headfile_optional\">Defined in header&lt;optional&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/005_optional_optional.cpp\">optional(可能或可能不保有一个对象的包装器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/005_optional_make_optional.cpp\">make_optional(创建一个 optional 对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/005_optional_std_swap.cpp\">std::swap(std::optional)(特化 std::swap 算法)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/005_optional_std_hash.cpp\">std::hash&lt;std::optional&gt;(特化 std::hash 算法)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/005_optional_nullopt_t.cpp\">nullopt_t(带未初始化状态的 optional 类型的指示器)</a>\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/005_optional_bad_optional_access.cpp\">bad_optional_access(指示进行了到不含值的 optional 的有检查访问的异常)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/005_optional_nullopt.cpp\">nullopt(nullopt_t 类型对象)</a>\n\n### <h5 id=\"cpp_headfile_variant\">Defined in header&lt;variant&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_variant.cpp\">variant(类型安全的可辨识联合体)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_visit.cpp\">visit(以一或多个 variant 所保有的各实参调用所提供的函数对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_holds_alternative.cpp\">holds_alternative(检查某个 variant 是否当前持有某个给定类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_std_get.cpp\">std::get(std::variant)(以给定索引或类型（若类型唯一）读取 variant 的值，错误时抛出异常)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_get_if.cpp\">get_if(以给定索引或类型（若其唯一），获得指向被指向的 variant 的值的指针，错误时返回空指针)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_std_swap.cpp\">std::swap(std::variant)(特化 std::swap 算法)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_monostate.cpp\">monostate(用作非可默认构造类型的 variant 的首个可选项的占位符类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_bad_variant_access.cpp\">bad_variant_access(非法地访问 variant 的值时抛出的异常)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_variant_size.cpp\">variant_size(在编译时获得 variant 可选项列表的大小)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_variant_size_v.cpp\">variant_size_v(在编译时获得 variant 可选项列表的大小)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_variant_alternative.cpp\">variant_alternative(在编译时获得以其下标指定的可选项的类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_variant_alternative_t.cpp\">variant_alternative_t(在编译时获得以其下标指定的可选项的类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_std_hash.cpp\">std::hash&lt;std::variant&gt;(特化 std::hash 算法)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/006_variant_variant_npos.cpp\">variant_npos(非法状态的 variant 的下标)</a>\n\t\n### <h5 id=\"cpp_headfile_any\">Defined in header&lt;any&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/007_any_any.cpp\">any(可保有任何可复制构造 (CopyConstructible) 类型的实例的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/007_any_std_swap.cpp\">std::swap(std::any)(特化 std::swap 算法)</a>\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/007_any_any_cast.cpp\">any_cast(对被容纳对象的类型安全访问)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/007_any_make_any.cpp\">make_any(创建 any 对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/007_any_bad_any_cast.cpp\">bad_any_cast(当类型不匹配时按值返回形式的 any_cast 所抛出的异常)</a>\n\n### <h5 id=\"cpp_headfile_charconv\">Defined in header&lt;charconv&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/008_charconv_to_chars.cpp\">to_chars(转换整数或浮点值到字符序列象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/008_charconv_from_chars.cpp\">from_chars(转换字符序列到整数或浮点值)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/008_charconv_chars_format.cpp\">chars_format(指定 std::to_chars 和 std::from_chars 所用的格式)</a>\n\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header&lt;initializer_list&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/009_initializer_list_empty.cpp\">empty(检查容器是否为空)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/009_initializer_list_data.cpp\">data(获得指向底层数组的指针)</a>\n\n### <h3 id=\"cpp_17_Containers_library\">容器库</h3>\n### <h5 id=\"cpp_headfile_map\">Defined in header&lt;map&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/010_map_insert_or_assign.cpp\">insert_or_assign(插入元素，或若键已存在则赋值给当前元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/010_map_try_emplace.cpp\">try_emplace(若键不存在则原位插入，若键存在则不做任何事)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/010_map_extract.cpp\">extract(从另一容器释出结点)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/010_map_merge.cpp\">merge(从另一容器接合结点)</a>\n\n### <h5 id=\"cpp_headfile_unordered_map\">Defined in header&lt;unordered_map&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/011_unordered_map_insert_or_assign.cpp\">insert_or_assign(插入元素，或若键已存在则赋值给当前元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/011_unordered_map_try_emplace.cpp\">try_emplace(若键不存在则原位插入，若键存在则不做任何事)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/011_unordered_map_extract.cpp\">extract(从另一容器释出结点)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/011_unordered_map_merge.cpp\">merge(从另一容器接合结点)</a>\n\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;array&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;deque&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;forward_list&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;iterator&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;list&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;map&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;regex&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;set&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;span&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;string&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;string_view&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;unordered_map&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;unordered_set&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;vector&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in namespace std</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/012_stl_size.cpp\">size(返回容器或数组的大小)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/012_stl_empty.cpp\">empty(检查容器是否为空)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_17/012_stl_data.cpp\">data(获得指向底层数组的指针)</a>\n\n---- \n\t\n<div id=\"cpp_20\" align=center>\n\t\n<img width=\"30%\" height=\"30%\" src=\"https://user-images.githubusercontent.com/87457873/134302390-53b4bfe7-eb75-4325-8376-dabd620c3a9d.jpg\"/>\n\n</div>\t\t\n\t\n### <h3 id=\"cpp_20_keywords\">关键字</h3>\n\n#### <h5 id=\"cpp_20_new_keywords\">新增关键字</h5>\n\n* [char8_t](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#char8_t)\n* [concept](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#concept)\n* [consteval](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#consteval)\n* [co_await](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#co_await)\n* [co_return](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#co_return)\n* [co_yield](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#co_yield)\n* [requires](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#requires)\n\t\n#### <h5 id=\"cpp_20_meaning_changed__OR__new_meaning_added\">含义变化或者新增含义关键字（meaning changed or new meaning added）</h5>\n\n* [export](https://github.com/0voice/cpp_new_features/blob/main/cpp_20/001_keywords_README.md#export)\n\t\n### <h3 id=\"cpp_20_RTTI\">类型支持（基本类型、RTTI、类型特性）</h3>\n\n### <h5 id=\"cpp_headfile_type_traits\">Defined in header&lt;type_traits&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_bounded_array.cpp\">is_bounded_array(检查类型是否为有已知边界的数组类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_unbounded_array.cpp\">is_unbounded_array(检查类型是否为有未知边界的数组类型)</a>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_layout_compatible.cpp\">is_layout_compatible(检查二个类型是否布局兼容)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_pointer_interconvertible_base_of.cpp\">is_pointer_interconvertible_base_of(检查一个类型是否为另一类型的指针可互转换（起始）基类)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_pointer_interconvertible_with_class.cpp\">is_pointer_interconvertible_with_class(检查一个类型的对象是否与该类型的指定子对象指针可互转换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_corresponding_member.cpp\">is_corresponding_member(检查二个指定成员是否在二个指定类型中的公共起始序列中彼此对应)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_nothrow_convertible.cpp\">is_nothrow_convertible(检查是否能转换一个类型为另一类型)</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_remove_cvref.cpp\">remove_cvref(将 std::remove_cv 与 std::remove_reference 结合)</a>\n<!--\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_common_reference.cpp\">common_reference(确定类型组的共用引用类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_basic_common_reference.cpp\">basic_common_reference(确定类型组的共用引用类型)</a>\n-->\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_type_identity.cpp\">type_identity(返回不更改的类型实参)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/002_rtti_is_constant_evaluated.cpp\">is_constant_evaluated(检测调用是否在常量求值的语境内发生)</a>\n\n### <h3 id=\"cpp_20_Coroutine\">协程支持</h3>\n\n### <h5 id=\"cpp_headfile_coroutine\">Defined in header&lt;coroutine&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/003_rtti_coroutine_traits.cpp\">coroutine_traits(用于发现协程承诺类型的特征类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/003_rtti_coroutine_handle.cpp\">coroutine_handle(用于指代暂停或执行的协程)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/003_rtti_noop_coroutine.cpp\">noop_coroutine(创建在等待或销毁时无操作的协程柄)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/003_rtti_noop_coroutine_promise.cpp\">noop_coroutine_promise(用于无可观察作用的协程)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/003_rtti_noop_coroutine_handle.cpp\">noop_coroutine_handle(std::coroutine_handle&lt;std::noop_coroutine_promise&gt; ，有意用于指代无操作协程)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/003_rtti_suspend_never.cpp\">suspend_never(指示 await 表达式应该决不暂停)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/003_rtti_suspend_always.cpp\">suspend_always(指示 await 表达式应该始终暂停)</a>\n\n### <h3 id=\"cpp_20_compare\">三路比较</h3>\n\n### <h5 id=\"cpp_headfile_compare\">Defined in header&lt;compare&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_std_coroutine_traits.cpp\">std::coroutine_traits</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_std_coroutine_handle.cpp\">std::coroutine_handle</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_three_way_comparable.cpp\">three_way_comparable(指定运算符 <=> 在给定类型上产生一致的结果)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_three_way_comparable_with.cpp\">three_way_comparable_with(指定运算符 <=> 在给定类型上产生一致的结果)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_partial_ordering.cpp\">partial_ordering(三路比较的结果类型，支持所有 6 种运算符，不可替换，并允许不可比较的值)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_weak_ordering.cpp\">weak_ordering(三路比较的结果类型，支持所有 6 种运算符且不可替换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_strong_ordering.cpp\">strong_ordering(三路比较的结果类型，支持所有 6 种运算符且可替换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_is_eq.cpp\">is_eq(具名比较函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_is_neq.cpp\">is_neq(具名比较函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_is_lt.cpp\">is_lt(具名比较函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_is_lteq.cpp\">is_lteq(具名比较函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_is_gt.cpp\">is_gt(具名比较函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_is_gteq.cpp\">is_gteq(具名比较函数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_compare_three_way.cpp\">compare_three_way(实现 x <=> y 的函数对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_compare_three_way_result.cpp\">compare_three_way_result(获得三路比较运算符 <=> 在给定类型上的结果)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_common_comparison_category.cpp\">common_comparison_category(给定的全部类型都能转换到的最强比较类别)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_strong_order.cpp\">strong_order(进行三路比较并产生 std::strong_ordering 类型结果)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_weak_order.cpp\">weak_order(进行三路比较并产生 std::weak_ordering 类型结果)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_partial_order.cpp\">partial_order(进行三路比较并产生 std::partial_ordering 类型结果)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_compare_strong_order_fallback.cpp\">compare_strong_order_fallback(进行三路比较并产生 std::strong_ordering 类型的结果，即使 operator<=> 不可用)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_compare_weak_order_fallback.cpp\">compare_weak_order_fallback(进行三路比较并产生 std::weak_ordering 类型的结果，即使 operator<=> 不可用)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/004_rtti_compare_compare_partial_order_fallback.cpp\">compare_partial_order_fallback(进行三路比较并产生 std::partial_ordering 类型的结果，即使 operator<=> 不可用</a>\n\n### <h5 id=\"cpp_headfile_concepts\">Defined in header&lt;concepts&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/005_rtti_concepts_ranges_swap.cpp\">ranges::swap(交换两个对象的值)</a>\n\n### <h5 id=\"cpp_headfile_utility\">Defined in header&lt;utility&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/006_utility_cmp_equal.cpp\">cmp_equal(比较二个整数值，而无转换所致的值更改)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/006_utility_cmp_not_equal.cpp\">cmp_not_equal(比较二个整数值，而无转换所致的值更改)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/006_utility_cmp_less.cpp\">cmp_less(比较二个整数值，而无转换所致的值更改)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/006_utility_cmp_less_equal.cpp\">cmp_less_equal(比较二个整数值，而无转换所致的值更改)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/006_utility_cmp_greater_equal.cpp\">cmp_greater_equal(比较二个整数值，而无转换所致的值更改)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/006_utility_in_range.cpp\">in_range(检查整数值是否在给定整数类型的范围内)</a>\n\n<!--\n### <h5 id=\"cpp_headfile_format\">Defined in header&lt;format&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_format.cpp\">format(在新 string 中存储参数的格式化表示)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_format_to.cpp\">format_to(通过输出迭代器写其参数的格式化表示)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_format_to_n.cpp\">format_to_n(通过输出迭代器写其参数的格式化表示，不超出指定的大小)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_formatted_size.cpp\">formatted_size(确定存储其参数的格式化表示所需的字符数)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_vformat.cpp\">vformat(std::format 的使用类型擦除的参数表示的非模板变体)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_vformat_to.cpp\">vformat_to(std::format_to 的使用类型擦除的参数表示的非模板变体)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_formatter.cpp\">formatter(定义给定类型的格式化规则的类模板)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_format_error.cpp\">format_error(格式化错误时抛出的异常类型)</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_basic_format_arg.cpp\">basic_format_arg(提供对用户定义格式化器的格式化参数的访问的类模板)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_basic_format_parse_context.cpp\">basic_format_parse_context(格式化字符串分析器状态)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_format_parse_context.cpp\">format_parse_context(格式化字符串分析器状态)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_wformat_parse_context.cpp\">wformat_parse_context(格式化字符串分析器状态)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_basic_format_context.cpp\">basic_format_context(格式化状态，包括所有格式化参数和输出迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_format_context.cpp\">format_context(格式化状态，包括所有格式化参数和输出迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_wformat_context.cpp\">wformat_context(格式化状态，包括所有格式化参数和输出迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_visit_format_arg.cpp\">visit_format_arg(用户定义格式化器的参数观览接口)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_make_format_args.cpp\">make_format_args(创建引用所有格式化参数的类型擦除对象，可转换到 format_args)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_make_wformat_args.cpp\">make_wformat_args(创建引用所有格式化参数的类型擦除对象，可转换到 format_args)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_basic_format_args.cpp\">basic_format_args(提供对所有格式化参数的访问的类)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_format_args.cpp\">format_args(提供对所有格式化参数的访问的类)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/007_format_wformat_args.cpp\">wformat_args(提供对所有格式化参数的访问的类)</a>\n-->\n\n### <h5 id=\"cpp_headfile_memory\">Defined in header&lt;memory&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_uninitialized_move.cpp\">uninitialized_move(移动一个范围的对象到未初始化的内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_uninitialized_move_n.cpp\">uninitialized_move_n(移动一定数量对象到未初始化内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_uninitialized_default_construct.cpp\">uninitialized_default_construct(在范围所定义的未初始化的内存区域以默认初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_uninitialized_default_construct_n.cpp\">uninitialized_default_construct_n(在起始和计数所定义的未初始化内存区域用默认初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_uninitialized_value_construct.cpp\">uninitialized_value_construct(在范围所定义的未初始化内存中用值初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_uninitialized_value_construct_n.cpp\">uninitialized_value_construct_n(在起始和计数所定义的未初始化内存区域以值初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_destroy_at.cpp\">destroy_at(销毁在给定地址的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_destroy.cpp\">destroy(销毁一个范围中的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/008_memory_destroy_n.cpp\">destroy_n(销毁范围中一定数量的对象)</a>\n\n\t\n<!--\n### <h5 id=\"cpp_headfile_concepts\">Defined in header&lt;memory_resource&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_polymorphic_allocator.cpp\">polymorphic_allocator(以 std::memory_resource 构造，支持基于它的运行时多态的分配器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_memory_resource.cpp\">memory_resource(一个抽象接口，用于各种封装内存资源的类)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_new_delete_resource.cpp\">new_delete_resource(返回一个静态的程序范围 std::pmr::memory_resource，它使用全局 operator new 与 operator delete 分配和解分配内存</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_null_memory_resource.cpp\">null_memory_resource(返回一个不进行任何分配的静态 std::pmr::memory_resource)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_get_default_resource.cpp\">get_default_resource(获取缺省 std::pmr::memory_resource)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_set_default_resource.cpp\">set_default_resource(设置缺省 std::pmr::memory_resource)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_pool_options.cpp\">pool_options(一组池资源的构造函数选项)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_synchronized_pool_resource.cpp\">synchronized_pool_resource(线程安全的 std::pmr::memory_resource，用于管理具有不同块大小的池中的分配)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_unsynchronized_pool_resource.cpp\">unsynchronized_pool_resource(线程不安全的 std::pmr::memory_resource，用于管理具有不同块大小的池中的分配)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/009_memory_resource_monotonic_buffer_resource.cpp\">monotonic_buffer_resource(一种特殊用途的 std::pmr::memory_resource，仅在资源被销毁时才释放所分配内存)</a>\t\n-->\n\n### <h3 id=\"cpp_20_compare\">Concepts library(概念库)</h3>\n\n### <h5 id=\"cpp_headfile_concepts\">Defined in header&lt;concepts&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_same_as.cpp\">same_as(指定一个类型与另一类型相同)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_derived_from.cpp\">derived_from(指定一个类型派生自另一类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_convertible_to.cpp\">convertible_to(指定一个类型能隐式转换成另一类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_common_reference_with.cpp\">common_reference_with(指定两个类型共有一个公共引用类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_common_with.cpp\">common_with(指定两个类型共有一个公共类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_integral.cpp\">integral(指定类型为整型类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_signed_integral.cpp\">signed_integral(指定类型为有符号的整型类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_unsigned_integral.cpp\">unsigned_integral(指定类型为无符号的整型类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_floating_point.cpp\">floating_point(指定类型为浮点类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_assignable_from.cpp\">assignable_from(指定一个类型能从另一类型赋值)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_swappable.cpp\">swappable(指定一个类型能进行交换，或两个类型能彼此交换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_swappable_with.cpp\">swappable_with(指定一个类型能进行交换，或两个类型能彼此交换)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_destructible.cpp\">destructible(指定能销毁该类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_constructible_from.cpp\">constructible_from(指定该类型的变量能从一组实参类型进行构造，或绑定到一组实参类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_default_initializable.cpp\">default_initializable(指定能默认构造一个类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_move_constructible.cpp\">move_constructible(指定能移动构造一个类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_copy_constructible.cpp\">copy_constructible(指定能复制构造和移动构造一个类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_boolean_testable.cpp\">boolean-testable(指定能用于布尔语境的类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_equality_comparable.cpp\">equality_comparable(指定运算符 == 为等价关系)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_equality_comparable_with.cpp\">equality_comparable_with(指定运算符 == 为等价关系)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_totally_ordered.cpp\">totally_ordered(指定比较运算符在该类型上产生全序)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_totally_ordered_with.cpp\">totally_ordered_with(指定比较运算符在该类型上产生全序)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_movable.cpp\">movable(指定能移动及交换一个类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_copyable.cpp\">copyable(指定能复制、移动及交换一个类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_semiregular.cpp\">semiregular(指定能赋值、移动、交换及默认构造一个类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_regular.cpp\">regular(指定类型为正则，即它既为 semiregular 亦为 equality_comparable)</a>\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_invocable.cpp\">invocable(指定能以给定的一组实参类型调用的可调用类型)</a>\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_regular_invocable.cpp\">regular_invocable(指定能以给定的一组实参类型调用的可调用类型)</a>\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_predicate.cpp\">predicate(指定可调用类型为布尔谓词)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_relation.cpp\">relation(指定可调用类型为二元关系)</a>\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_equivalence_relation.cpp\">equivalence_relation(指定 relation 施加等价关系)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/010_concepts_strict_weak_order.cpp\">strict_weak_order(指定一个 relation 所强加的是严格弱序)</a>\n\n### <h3 id=\"cpp_20_memory\">动态内存管理</h3>\n\n### <h5 id=\"cpp_headfile_memory\">Defined in header&lt;memory&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_uses_allocator_construction_args.cpp\">uses_allocator_construction_args(准备匹配给定类型所要求的使用分配器构造的口味的参数列表)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_make_obj_using_allocator.cpp\">make_obj_using_allocator(以使用分配器构造的手段创建给类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_uninitialized_construct_using_allocator.cpp\">uninitialized_construct_using_allocator(以使用分配器构造的手段在指定的内存位置创建给定类型的对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_construct_at.cpp\">construct_at(在给定地址创建对象)</a>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_no-throw-input-iterator.cpp\">no-throw-input-iterator(指定迭代器、哨位和范围上的某些操作不抛出)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_no-throw-forward-iterator.cpp\">no-throw-forward-iterator(指定迭代器、哨位和范围上的某些操作不抛出)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_no-throw-sentinel-for.cpp\">no-throw-sentinel-for(指定迭代器、哨位和范围上的某些操作不抛出)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_no-throw-input-range.cpp\">no-throw-input-range(指定迭代器、哨位和范围上的某些操作不抛出)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_no-throw-forward-range.cpp\">no-throw-forward-range(指定迭代器、哨位和范围上的某些操作不抛出)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_copy.cpp\">ranges::uninitialized_copy(复制元素范围到未初始化的内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_copy_n.cpp\">ranges::uninitialized_copy_n(复制一定量元素到未初始化的内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_fill.cpp\">ranges::uninitialized_fill(复制一个对象到范围所定义的未初始化的内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_fill_n.cpp\">ranges::uninitialized_fill_n(复制一个对象到起始与计数所定义的未初始化的内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_move.cpp\">ranges::uninitialized_move(移动对象范围到未初始化的内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_move_n.cpp\">ranges::uninitialized_move_n(移动一定量对象到未初始化的内存区域)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_default_construct.cpp\">ranges::uninitialized_default_construct(在范围所定义的未初始化的内存区域以默认初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_default_construct_n.cpp\">ranges::uninitialized_default_construct_n(在起始与计数所定义的未初始化的内存区域以默认初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_value_construct.cpp\">ranges::uninitialized_value_construct(在范围所定义的未初始化的内存区域以值初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_uninitialized_value_construct_n.cpp\">ranges::uninitialized_value_construct_n(在起始与计数所定义的未初始化的内存区域以值初始化构造对象)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_destroy_at.cpp\">ranges::destroy_at(销毁位于给定地址的元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_destroy.cpp\">ranges::destroy(销毁范围中的元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_destroy_n.cpp\">ranges::destroy_n(销毁范围中一定量的元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_ranges_construct_at.cpp\">ranges::construct_at(在给定地址创建对象)</a>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_to_address.cpp\">to_address(从指针式类型获得裸指针)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/011_memory_assume_aligned.cpp\">assume_aligned(告知编译器指针已对齐)</a>\n\n### <h3 id=\"cpp_20_memory\">日期和时间工具</h3>\n\n### <h5 id=\"cpp_headfile_chrono\">Defined in header&lt;chrono&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_is_clock.cpp\">is_clock(确定类型是否为时钟 (Clock))</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_is_clock_v.cpp\">is_clock_v(确定类型是否为时钟 (Clock))</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_utc_clock.cpp\">utc_clock(协调世界时 (UTC) 的时钟 (Clock))</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_tai_clock.cpp\">tai_clock(国际原子时 (TAI) 的时钟 (Clock))</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_gps_clock.cpp\">gps_clock(GPS 时间的时钟 (Clock))</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_file_clock.cpp\">file_clock(用于文件时间的时钟 (Clock))</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_local_t.cpp\">local_t(表示本地时间的伪时钟)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_clock_time_conversion.cpp\">clock_time_conversion(定义如何转换一个时钟的时间点为另一个的特性类)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_clock_cast.cpp\">clock_cast(转换一个时钟的时间点为另一个)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_time_of_day.cpp\">time_of_day(表示一日中的时间)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_is_am.cpp\">is_am(在 12 时和 24 时格式当天时刻之间翻译)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_is_pm.cpp\">is_pm(在 12 时和 24 时格式当天时刻之间翻译)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_make12.cpp\">make12(在 12 时和 24 时格式当天时刻之间翻译)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_make24.cpp\">make24(在 12 时和 24 时格式当天时刻之间翻译)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_last_spec.cpp\">last_spec(指示一个月中最后日期或星期的标签类)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_day.cpp\">day(表示月之日期)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_month.cpp\">month(表示年之月份)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_year.cpp\">year(表示格里高利历中的年)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_weekday.cpp\">weekday(表示格里高利历中星期之日)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_weekday_indexed.cpp\">weekday_indexed(表示月份的第 n 个 weekday)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_weekday_last.cpp\">weekday_last(表示月份的最后一个 weekday)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_month_day.cpp\">month_day(表示特定 month 的特定 day)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_month_day_last.cpp\">month_day_last(表示特定 month 的最后一日)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_month_weekday.cpp\">month_weekday(表示特定 month 的第 n 个 weekday)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_month_weekday_last.cpp\">month_weekday_last(表示特定 month 的最后一个 weekday)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_year_month.cpp\">year_month(表示特定 year 的特定 month)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_year_month_day.cpp\">year_month_day(表示特定的 year 、 month 和 day)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_year_month_day_last.cpp\">year_month_day_last(表示特定 year 和 month 的最后一日)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_year_month_weekday.cpp\">year_month_weekday(表示特定 year 和 month 的第 n 个 weekday)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_year_month_weekday_last.cpp\">year_month_weekday_last(表示特定 year 和 month 的最后一个 weekday)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_operator.cpp\">operator/(创建格里高利历日期的约定语法)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_tzdb.cpp\">tzdb(描述 IANA 时区数据库的副本)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_tzdb_list.cpp\">tzdb_list(表示 tzdb 的链表)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_get_tzdb.cpp\">get_tzdb(访问和控制全球时区数据库信息)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_get_tzdb_list.cpp\">get_tzdb_list(访问和控制全球时区数据库信息)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_reload_tzdb.cpp\">reload_tzdb(访问和控制全球时区数据库信息)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_remote_version.cpp\">remote_version(访问和控制全球时区数据库信息)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_locate_zone.cpp\">locate_zone(定位基于其名称的 time_zone)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_current_zone.cpp\">current_zone(返回当前的 time_zone)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_time_zone.cpp\">time_zone(表示时区)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_sys_info.cpp\">sys_info(表示在特定时间点的关于时区的信息)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_local_info.cpp\">local_info(表示关于从本地时间转换到 UNIX 时间的信息)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_choose.cpp\">choose(选择应如何解析歧义的本地时间)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_zoned_traits.cpp\">zoned_traits(zoned_time 所用的时区指针的特性类)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_zoned_time.cpp\">zoned_time(表示时区和时间点)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_leap_second.cpp\">leap_second(含有关于插入闰秒的信息)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_time_zone_link.cpp\">time_zone_link(表示时区的替用名)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_nonexistent_local_time.cpp\">nonexistent_local_time(抛出以报告本地时间不存在的异常)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_ambiguous_local_time.cpp\">ambiguous_local_time(抛出以报告本地时间有歧义的异常)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/012_chrono_parse.cpp\">parse(从流分析 chrono 对象)</a>\n\t\n### <h3 id=\"cpp_20_string\">字符串</h3>\n\n### <h5 id=\"cpp_headfile_string\">Defined in header&lt;string&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/013_string_starts_with.cpp\">starts_with(检查 string 是否始于给定前缀)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/013_string_ends_with.cpp\">ends_with(检查 string 是否终于给定后缀)</a>\n\t\n### <h5 id=\"cpp_headfile_string_view\">Defined in header&lt;string_view&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/014_string_view_starts_with.cpp\">starts_with(检查 string_view 是否始于给定前缀)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/014_string_view_ends_with.cpp\">ends_with(检查 string_view 是否终于给定后缀)</a>\n\t\n### <h5 id=\"cpp_headfile_cuchar\">Defined in header&lt;cuchar&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/015_cuchar_mbrtoc8.cpp\">mbrtoc8(转换窄多字节字符为 UTF-8 编码)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/015_cuchar_c8rtomb.cpp\">c8rtomb(转换 UTF-8 字符串为窄多字节编码)</a>\t\n\n### <h3 id=\"cpp_20_Containers_library\">容器库</h3>\n\n### <h5 id=\"cpp_headfile_array\">Defined in header&lt;array&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/016_array_to_array.cpp\">to_array(从内建数组创建 std::array 对象)</a>\n\n### <h5 id=\"cpp_headfile_vector\">Defined in header&lt;vector&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/017_vector_erase.cpp\">erase(std::vector)(擦除所有满足特定判别标准的元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/017_vector_erase_if.cpp\">erase_if(std::vector)(擦除所有满足特定判别标准的元素)</a>\n\n### <h5 id=\"cpp_headfile_map\">Defined in header&lt;map&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/018_map_contains.cpp\">contains(检查容器是否含有带特定键的元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/018_map_erase_if.cpp\">erase_if(std::map)(擦除所有满足特定判别标准的元素)</a>\n\n### <h5 id=\"cpp_headfile_unordered_map\">Defined in header&lt;unordered_map&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/019_unordered_map_contains.cpp\">contains(检查容器是否含有带特定键的元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/019_unordered_map_erase_if.cpp\">erase_if(std::unordered_map)(擦除所有满足特定判别标准的元素)</a>\n\n### <h5 id=\"cpp_headfile_span\">Defined in header&lt;span&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/020_span_begin.cpp\">begin(返回指向起始的迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/020_span_end.cpp\">end(返回指向末尾的迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/020_span_rbegin.cpp\">rbegin(返回指向起始的逆向迭代器)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/020_span_rend.cpp\">rend(返回指向末尾的逆向迭代器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/020_span_front.cpp\">front(访问第一个元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/020_span_back.cpp\">back(访问最后一个元素)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/020_span_dynamic_extent.cpp\">dynamic_extent(size_t 类型常量，指明 span 拥有动态长度)</a>\n\n### <h5 id=\"cpp_headfile_span\">Defined in namespace std</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_indirectly_readable.cpp\">indirectly_readable(指定类型通过应用运算符 * 可读)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_indirectly_writable.cpp\">indirectly_writable(指定可向迭代器所引用的对象写入值)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_weakly_incrementable.cpp\">weakly_incrementable(指定 semiregular 类型能以前后自增运算符自增)</a> \t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_incrementable.cpp\">incrementable(指定 weakly_incrementable 类型上的自增操作保持相等性，而且该类型为 equality_comparable)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_input_or_output_iterator.cpp\">input_or_output_iterator(指定该类型对象可以自增且可以解引用)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_sentinel_for.cpp\">sentinel_for(指定类型为某个 input_or_output_iterator 类型的哨位类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_sized_sentinel_for.cpp\">sized_sentinel_for(指定可对一个迭代器和一个哨位应用 - 运算符，以在常数时间计算其距离)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_input_iterator.cpp\">input_iterator(指定类型为输入迭代器，即可读取其所引用的值，且可前/后自增)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_output_iterator.cpp\">output_iterator(指定类型为给定的值类型的输出迭代器，即可向其写入该类型的值，且可前/后自增)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_forward_iterator.cpp\">forward_iterator(指定 input_iterator 为向前迭代器，支持相等比较与多趟操作)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_bidirectional_iterator.cpp\">bidirectional_iterator(指定 forward_iterator 为双向迭代器，支持向后移动)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_random_access_iterator.cpp\">random_access_iterator(指定 bidirectional_iterator 为随机访问迭代器，支持常数时间内的前进和下标访问)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_contiguous_iterator.cpp\">contiguous_iterator(指定 random_access_iterator 为连续迭代器，指代内存中连续相接的元素)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_indirectly_readable_traits.cpp\">indirectly_readable_traits(计算 indirectly_readable 类型的值类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_iter_value_t.cpp\">iter_value_t(计算迭代器的关联类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_iter_reference_t.cpp\">iter_reference_t(计算迭代器的关联类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_iter_difference_t.cpp\">iter_difference_t(计算迭代器的关联类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_iter_rvalue_reference_t.cpp\">iter_rvalue_reference_t(计算迭代器的关联类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_iter_common_reference_t.cpp\">iter_common_reference_t(计算迭代器的关联类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_iterator_traits.cpp\">iterator_traits(为迭代器各项性质提供统一接口)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_input_iterator_tag.cpp\">input_iterator_tag(用于指示迭代器类别的空类类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_output_iterator_tag.cpp\">output_iterator_tag(用于指示迭代器类别的空类类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_forward_iterator_tag.cpp\">forward_iterator_tag(用于指示迭代器类别的空类类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_bidirectional_iterator_tag.cpp\">bidirectional_iterator_tag(用于指示迭代器类别的空类类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_random_access_iterator_tag.cpp\">random_access_iterator_tag(用于指示迭代器类别的空类类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/021_std_contiguous_iterator_tag.cpp\">contiguous_iterator_tag(用于指示迭代器类别的空类类型)</a> \n\n### <h5 id=\"cpp_headfile_span\">Defined in namespace std::ranges</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/022_ranges_iter_move.cpp\">iter_move(将解引用迭代器的结果转型为其关联的右值引用类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/022_ranges_iter_swap.cpp\">iter_swap(交换两个可解引用对象所引用的值)</a> \n\n### <h5 id=\"cpp_headfile_span\">Defined in namespace std</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_indirectly_readable.cpp\">indirectly_readable(指定类型通过应用运算符 * 可读)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_indirectly_writable.cpp\">indirectly_writable(指定可向迭代器所引用的对象写入值)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_weakly_incrementable.cpp\">weakly_incrementable(指定 semiregular 类型能以前后自增运算符自增)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_incrementable.cpp\">incrementable(指定 weakly_incrementable 类型上的自增操作保持相等性，而且该类型为 equality_comparable)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_input_or_output_iterator.cpp\">input_or_output_iterator(指定该类型对象可以自增且可以解引用)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_sentinel_for.cpp\">sentinel_for(指定类型为某个 input_or_output_iterator 类型的哨位类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_sized_sentinel_for.cpp\">sized_sentinel_for(指定可对一个迭代器和一个哨位应用 - 运算符，以在常数时间计算其距离)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_input_iterator.cpp\">input_iterator(指定类型为输入迭代器，即可读取其所引用的值，且可前/后自增)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_output_iterator.cpp\">output_iterator(指定类型为给定的值类型的输出迭代器，即可向其写入该类型的值，且可前/后自增)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_forward_iterator.cpp\">forward_iterator(指定 input_iterator 为向前迭代器，支持相等比较与多趟操作)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_bidirectional_iterator.cpp\">bidirectional_iterator(指定 forward_iterator 为双向迭代器，支持向后移动)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_random_access_iterator.cpp\">random_access_iterator(指定 bidirectional_iterator 为随机访问迭代器，支持常数时间内的前进和下标访问)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_contiguous_iterator.cpp\">contiguous_iterator(指定 random_access_iterator 为连续迭代器，指代内存中连续相接的元素)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_incrementable_traits.cpp\">incrementable_traits(计算 weakly_incrementable 类型的差类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_indirectly_readable_traits.cpp\">indirectly_readable_traits(计算 indirectly_readable 类型的值类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_iter_value_t.cpp\">iter_value_t(计算迭代器的关联类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_iter_reference_t.cpp\">iter_reference_t(计算迭代器的关联类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_iter_difference_t.cpp\">iter_difference_t(计算迭代器的关联类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_iter_rvalue_reference_t.cpp\">iter_rvalue_reference_t(计算迭代器的关联类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_iter_common_reference_t.cpp\">iter_common_reference_t(计算迭代器的关联类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_iterator_traits.cpp\">iterator_traits(为迭代器各项性质提供统一接口)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_input_iterator_tag.cpp\">input_iterator_tag(用于指示迭代器类别的空类类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_output_iterator_tag.cpp\">output_iterator_tag(用于指示迭代器类别的空类类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_forward_iterator_tag.cpp\">forward_iterator_tag(用于指示迭代器类别的空类类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_bidirectional_iterator_tag.cpp\">bidirectional_iterator_tag(用于指示迭代器类别的空类类型)</a>\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_random_access_iterator_tag.cpp\">random_access_iterator_tag(用于指示迭代器类别的空类类型)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/023_std_contiguous_iterator_tag.cpp\">contiguous_iterator_tag(用于指示迭代器类别的空类类型)</a>\n\t\n### <h5 id=\"cpp_headfile_span\">Defined in header <iterator></h5>\n### <h5 id=\"cpp_headfile_span\">Defined in namespace std</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_unary_invocable.cpp\">indirectly_unary_invocable(指定可调用类型能以解引用某个 indirectly_readable 类型的结果进行调用)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_regular_unary_invocable.cpp\">indirectly_regular_unary_invocable(指定可调用类型能以解引用某个 indirectly_readable 类型的结果进行调用)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirect_unary_predicate.cpp\">indirect_unary_predicate(指定可调用类型，在以解引用一个 indirectly_readable 类型的结果进行调用时，满足 predicate)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirect_binary_predicate.cpp\">indirect_binary_predicate(指定可调用类型，在以解引用两个 indirectly_readable 类型的结果进行调用时，满足 predicate)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirect_equivalence_relation.cpp\">indirect_equivalence_relation(指定可调用类型，在以解引用两个 indirectly_readable 类型的结果进行调用时，满足 equivalence_relation)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirect_strict_weak_order.cpp\">indirect_strict_weak_order(指定可调用类型，在以解引用两个 indirectly_readable 类型的结果进行调用时，满足 strict_weak_order)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_movable.cpp\">indirectly_movable(指定可从 indirectly_readable 类型移动值给 indirectly_writable 类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_movable_storable.cpp\">indirectly_movable_storable(指定可从 indirectly_readable 类型移动值给 indirectly_writable 类型，且该移动可以通过中间对象进行)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_copyable.cpp\">indirectly_copyable(指定可从 indirectly_readable 类型复制值给 indirectly_writable 类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_copyable_storable.cpp\">indirectly_copyable_storable(指定可从 indirectly_readable 类型复制值给 indirectly_writable 类型，且该复制可以通过中间对象进行)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_swappable.cpp\">indirectly_swappable(指定能交换两个 indirectly_readable 类型所引用的值)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirectly_comparable.cpp\">indirectly_comparable(指定能比较两个 indirectly_readable 类型所引用的值)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_permutable.cpp\">permutable(指定在原位重排元素的算法的共用要求)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_mergeable.cpp\">mergeable(指定通过复制元素将已排序序列归并到输出序列中的算法的要求)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_sortable.cpp\">sortable(指定重排序列为有序序列的算法的共用要求)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_indirect_result_t.cpp\">indirect_result_t(计算在解引用某组 indirectly_readable 类型的结果上调用可调用对象的结果)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_projected.cpp\">projected(用于对接受投影的算法指定约束的辅助模板)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_move_sentinel.cpp\">move_sentinel(用于 std::move_iterator 的哨位适配器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_common_iterator.cpp\">common_iterator(适配一个迭代器类型及其哨位为一个公共迭代器类型)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_default_sentinel_t.cpp\">default_sentinel_t(用于知晓其边界的迭代器的默认哨位)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_counted_iterator.cpp\">counted_iterator(对到范围结尾距离进行跟踪的迭代器适配器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/024_iterator_unreachable_sentinel_t.cpp\">unreachable_sentinel_t(始终与任何 weakly_incrementable 类型比较都不相等的哨位)</a> \n\n### <h5 id=\"cpp_headfile_span\">Defined in header <iterator></h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/025_iterator_ranges_advanc.cpp\">ranges::advance(令迭代器前进给定的距离或到给定的边界)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/025_iterator_ranges_distance.cpp\">ranges::distance(返回迭代器与哨位间的距离，或范围起始与结尾间的距离)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/025_iterator_ranges_next.cpp\">ranges::next(自增迭代器给定的距离或到边界)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/025_iterator_ranges_prev.cpp\">ranges::prev(自减迭代器给定的距离或到边界)</a> \n\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;array&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;deque&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;forward_list&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;iterator&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;list&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;map&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;regex&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;set&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;span&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;string&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;string_view&gt;</h5>\t\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;unordered_map&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;unordered_set&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in header &lt;vector&gt;</h5>\n### <h5 id=\"cpp_headfile_initializer_list\">Defined in namespace std</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/026_std_ssize.cpp\">ssize(返回容器或数组的大小)</a> \n\n### <h5 id=\"cpp_headfile_span\">Defined in header &lt;ranges&gt;</h5>\n### <h5 id=\"cpp_headfile_span\">Defined in header &lt;iterator&gt;</h5>\n### <h5 id=\"cpp_headfile_span\">Defined in namespace std::ranges</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_begin.cpp\">ranges::begin(返回指向范围起始的迭代器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_cbegin.cpp\">ranges::cbegin(返回指向只读范围起始的迭代器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_end.cpp\">ranges::end(返回指示范围结尾的哨位)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_cend.cpp\">ranges::cend(返回指示只读范围结尾的哨位)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_rbegin.cpp\">ranges::rbegin(返回指向范围的逆向迭代器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_crbegin.cpp\">ranges::crbegin(返回指向只读范围的逆向迭代器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_rend.cpp\">ranges::rend(返回指向范围的逆向尾迭代器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_crend.cpp\">ranges::crend(返回指向只读范围的逆向尾迭代器)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_size.cpp\">ranges::size(获得能在常数时间内计算大小的范围的大小)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_ssize.cpp\">ranges::ssize(获得能在常数时间内计算大小的范围的大小，并将它转换成有符号整数)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_empty.cpp\">ranges::empty(检查范围是否为空)</a> \n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_data.cpp\">ranges::data(获得指向连续范围的起始的指针)</a> \t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_20/027_ranges_ranges_cdata.cpp\">ranges::cdata(获得指向只读连续范围的起始的指针)</a> \n\n\n-----\n\t\n<div id=\"cpp_23\" align=center>\n\t\n<img width=\"30%\" height=\"30%\" src=\"https://user-images.githubusercontent.com/87457873/134302554-85d6bf7c-1e1d-4579-8141-8a4c3e8d92e2.jpg\"/>\n\n</div>\t\t\n\t\n### <h3 id=\"cpp_23_RTTI\">类型支持（基本类型、RTTI、类型特性）</h3>\n\n### <h5 id=\"cpp_headfile_type_traits\">Defined in header&lt;type_traits&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/001_rtti_is_scoped_enum.cpp\">is_scoped_enum(检查类型是否为有作用域枚举类型)</a>\n\n### <h5 id=\"cpp_headfile_utility\">Defined in header&lt;utility&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/002_utility_to_underlying.cpp\">to_underlying(转换枚举到其底层类型)</a>\n\n### <h5 id=\"cpp_headfile_stacktrace\">Defined in header&lt;stacktrace&gt;</h5>\n\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/003_stacktrace_stacktrace_entry.cpp\">stacktrace_entry(栈踪中求值的表示)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/003_stacktrace_basic_stacktrace.cpp\">basic_stacktrace(由栈踪条目组成的调用序列的近似表示)</a>\n\n### <h3 id=\"cpp_23_memory\">动态内存管理</h3>\n\n### <h5 id=\"cpp_headfile_memory\">Defined in header&lt;memory&gt;</h5>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/004_memory_out_ptr_t.cpp\">out_ptr_t(与外来指针设置器交互，并在析构时重设智能指针)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/004_memory_out_ptr.cpp\">out_ptr(以关联的智能指针和重设参数创建 out_ptr_t)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/004_memory_inout_ptr_t.cpp\">inout_ptr_t(与外来指针设置器交互，从智能指针获得初始指针值，并在析构时重设它)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/004_memory_inout_ptr.cpp\">inout_ptr(以关联的智能指针和重设参数创建 inout_ptr_t)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/004_memory_allocation_result.cpp\">allocation_result(记录由 allocate_at_least 分配的存储的地址与实际大小)</a>\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/004_memory_allocate_at_least.cpp\">allocate_at_least(经由分配器分配至少与请求的大小一样大的存储)</a>\n\t\n### <h3 id=\"cpp_23_string\">字符串</h3>\n\n### <h5 id=\"cpp_headfile_string\">Defined in header&lt;string&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/005_string_contains.cpp\">contains(检查字符串是否含有给定的子串或字符)</a>\n\n### <h5 id=\"cpp_headfile_string_view\">Defined in header&lt;string_view&gt;</h5>\n\t\n* <a href=\"https://github.com/0voice/cpp_new_features/blob/main/cpp_23/005_string_view_contains.cpp\">contains(检查字符串视图是否含有给定的子串或字符)</a>\n\n---\n\n\n## 联系专栏\n\n#### 零声教育，专注于c/c++Linux后台服务器开发架构技术学习提升。<br>\n每天晚上8点【免费技术直播】：[分享Linux，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒体，CDN，P2P，K8S，Docker，TCP/IP，协程，DPDK等技术内容，立即学习。](https://ke.qq.com/course/417774?flowToken=1037711)\n\n#### 关注微信公众号【后台服务架构师】——【联系我们】，获取本repo最全PDF学习文档！\n\n<img width=\"65%\" height=\"65%\" src=\"https://user-images.githubusercontent.com/87457873/130796999-03af3f54-3719-47b4-8e41-2e762ab1c68b.png\"/>\n"
        },
        {
          "name": "cpp_11",
          "type": "tree",
          "content": null
        },
        {
          "name": "cpp_14",
          "type": "tree",
          "content": null
        },
        {
          "name": "cpp_17",
          "type": "tree",
          "content": null
        },
        {
          "name": "cpp_20",
          "type": "tree",
          "content": null
        },
        {
          "name": "cpp_23",
          "type": "tree",
          "content": null
        },
        {
          "name": "「Notes」C++14新特性浅谈.md",
          "type": "blob",
          "size": 10.26171875,
          "content": "> 原文链接：https://liuxizai.ac.cn/post/notes-cpp14/\n\n基于 Ubuntu 20.04 的 NOI 2.0 发布后，我们或许有机会开始使用 C++14。\n\n这篇 Blog 将对 OI 中可能会使用到的 C++14 的新特性进行简要总结。\n\n> 由于大部分 OIer 被 CCF 迫害可能是 C++98 转 C++14，文中部分特性实际上是来源于 C++11 标准的。\n>\n> 另一个重要原因是，C++14 并不是 C++ 的一个主要版本（主要版本：C++03 C++11 C++17），其被认为是 C++11 一个更加完善的版本，C++11 这一更新经历了整整8年时间，引入了大量更改，可以说是 C++98 以来最重要的更新，所以提到 C++11 的特性确实很有必要。\n\n这篇 Blog 以简洁易懂为主要目标，为此可能有些地方会在不影响理解的情况下使用一些不准确的表达，这些地方往往都有脚注，可以通过我给出的链接查看更详细的内容。\n\n## constexpr\n\nC++ 中一直存在着常量表达式的概念，在 C++98 中我们可以这样定义一个常量\n\n```cpp\nconst int SIZE = 100005;\n```\n\n常量将无法修改，并且这也是编译器的一个优化机会，编译器往往会在编译时就处理好常量表达式的值，并在程序中硬编码结果，也就是不会在程序运行时再去计算表达式的值。\n\n```cpp\nconst int MOD = 1e9 + 7;\n\n// source code\nans = ans % MOD;\n\n// after compilation\nans = ans % 1000000007; // yes, 1e9 + 7 has been calculated\nans = ans % (1e9 + 7); // no\n```\n\n另外，常量可以用来初始化数组\n\n```cpp\nint len = 10;\nint a[len]; // compile error\n\nconst int len = 10;\nint a[len]; // ok\n```\n\nC++11 中的 `constexpr` 关键字更进一步放宽了常量表达式的限制\n\n```cpp\nconst int f() { return 10; }\nint a[f()+5]; // compile error\n\nconstexpr int f() { return 10; }\nint a[f()+5]; // ok\n```\n\n你可能已经发现了，C++11 允许将函数作为常量表达式，但是 C++11 要求函数必须恰由一条 `return` 语句组成，而 C++14 解除了这一限制，但你仍需要保证函数中没有：\n\n- `goto` 语句\n\n- 未进行初始化的变量定义\n\n  ```cpp\n  int a; // no\n  int a = 10; // yes\n  ```\n\n- 非字面类型的变量定义（算术类型如 `int` 属于字面类型，而自定义类型如 `string` 属于非字面类型）\n\n为了方便 OIer 理解，以上内容并不完全准确。\n\n## lambda\n\nC++11 中允许使用匿名函数，其能够内联于语句中\n\n```cpp\nstruct node { int x, y; };\nstd::vector<node> arr;\n\n// C++98\nbool cmp(node a, node b) { return a.x < b.x; }\nstd::sort(arr.begin(), arr.end(), cmp);\n\n// C++11\nstd::sort(arr.begin(), arr.end(), [](node a, node b){ return a.x < b.x; });\n```\n\n两种写法效果都是一样的。\n\n具体地说，`lambda` 表达式的语法为\n\n```cpp\n[捕获](形参){函数体}\n```\n\n其中需要具体讲解的是捕获这一部分。\n\n捕获分为这样几个类型：\n\n- `[]` - 空捕获列表，`lambda` 表达式只能够使用非局部变量。\n- `[names]` - `names` 是一个逗号分割的名字列表，这些名字为匿名函数所在的局部变量，这些局部变量将被拷贝（也就是说在函数中修改其值后并不会影响到其本身），如果 `name` 前面使用了 `&`，将会使用引用的方式捕获。\n- `[&]` - 隐式的以引用方式捕获所有匿名函数使用的局部变量。\n- `[=]` - 隐式的以值方式（即拷贝）捕获所有匿名函数使用的局部变量。\n- `[&, list]` - `list` 是一个逗号分割的列表，列表中的变量以值方式捕获，其他局部变量隐式的以引用方式捕获。\n- `[=, list]` - `list` 是一个逗号分割的列表，列表中的变量以引用方式捕获，其他局部变量隐式的以值方式捕获。\n\nC++14 标准中规定了泛型 `lambda`，由于过于复杂，选择不将其写入 Blog。\n\n另外，你会发现匿名函数没有规定返回值，编译器将会自行判断函数的返回值，如果需要指定函数返回值，可以使用以下语法\n\n```cpp\n[捕获](形参)->返回值类型 {函数体}\n```\n\n## 变量模板（variable template）\n\nC++14 允许通过变量模板定义一族变量。\n\n```cpp\ntemplate<typename T> // variable template\nconst T pi = T(3.14159265);\n\ntemplate<typename T> // function template\nT circleArea(T r){\n    return pi<T> * r * r; // variable template instantiation\n}\n```\n\n## 聚合初始化（aggregate initialization）\n\n聚合初始化是 C++11 中列表初始化的一种形式。\n\n首先，聚合体是下列类型之一：\n\n- 数组类型\n- 满足一下条件的类类型（常为struct）\n  - 没有私有或受保护的非静态数据成员（在类中声明的非 `static` 数据成员）\n  - 没有用户提供的构造函数\n  - 没有虚成员函数\n\n你可以像这样进行聚合初始化\n\n```cpp\nstruct node{\n    int a, b;\n    int c[3];\n    int d;\n};\nnode nd = {2, 3, 5, 6, 3, 4};\n```\n\n这样初始化过后\n\n```cpp\na = 2;\nb = 3;\nc = {5, 6, 3};\nd = 4;\n```\n\n可以发现聚合初始化是按照地址顺序依次进行的，所以对于类中的数组成员可以很方便的进行初始化，当然这也意味着聚合初始化无法直接指定一些成员进行初始化。\n\n> 在 C++20 中允许进行指派初始化器的聚合初始化，即可以指定成员进行初始化\n\n另一个很重要的特性，聚合初始化是递归进行的，也就是说其允许嵌套\n\n```cpp\nstruct A{\n    struct B{\n        int a;\n        int b;\n        int c;\n    };\n    B d;\n    int e;\n    vector<int> f;\n};\n```\n\n这样一个结构体我们仍然可以使用聚合初始化\n\n```cpp\nA a = {{1, 2, 3}, 4, {5, 6}};\n```\n\n初始化结果如下\n\n```cpp\nd.a = 1;\nd.b = 2;\nd.c = 3;\ne = 4;\nf = {5, 6};\n```\n\n在 C++11 中，聚合初始化要求类成员没有默认初始化器（`int a = 10`），但在 C++14 中允许我们这么做，所以另外很重要的一点是，当聚合初始化与默认初始化器结合时，到底会产生怎么样的结果。\n\n举个例子说明\n\n```cpp\nstruct A {\n    struct B {\n        int a = 21;\n        int b;\n        int c = 22;\n        int d;\n        int e = 23;\n    };\n    B b1  = { 11, 12 };\n    B b2  = { 11, 12, 13 };\n    int x;\n};\n```\n\n接下来进行聚合初始化\n\n```cpp\nA a = { { 1, 2, 3, 4 }, { 1 }, 5 };\n```\n\n你会得到这样的结果\n\n```cpp\nb1.a = 1;\nb1.b = 2;\nb1.c = 3;\nb1.d = 4;\nb1.e = 23;\nb2.a = 1;\nb2.b = 0;\nb2.c = 22;\nb2.d = 0;\nb2.e = 23;\nx = 5;\n```\n\n你会发现，`b2`的初始化好像失效了，否则我们应该得到这样的结果\n\n```cpp\nb2.a = 1;\nb2.b = 12;\nb2.c = 13;\nb2.d = 0;\nb2.e = 23;\n```\n\n初始化器提供的值比类成员少时，根据 N3605，C++14 会采用如下策略\n\n- 从成员的默认初始化器进行初始化\n- 如果没有默认初始化器，用一个空初始化器列表进行初始化\n\n那么，我们在对 `a` 进行聚合初始化时， 实际上为 `b2` 提供了值 `{1}`，所以 `b2` 的初始化器**完全失效**，接下来，`b2.a` 从聚合初始化中的到了值，其他成员没有得到值，所以隐式的按照 N3605 进行初始化。\n\n这正是我们得到的结果。\n\n## auto\n\n`auto` 于 C++11 引入作为占位类型说明符，其能够从初始化器自动推导变量类型。\n\n```cpp\nauto a = 12;        // int\nauto b = 2 + 4 * 7; // int\nauto c = 0.17;      // double\nauto d = a;         // int\nauto e = a + c;     // double\n复制代码\n```\n\nC++14 还允许使用 `auto` 自动推断函数返回值类型\n\n```cpp\nauto f() { return 2 + 3; } // int\n```\n\n如下写法将会被推导为列表初始化器\n\n```cpp\nauto g = {1, 2, 3, 4, 5}; // std::initializer_list<int>\nauto h{1, 2, 3, 4, 5}; // std::initializer_list<int>\n```\n\n> 第二种写法在 C++17 中被弃用\n\n另外，`auto` 还常用于无名类型，如 `lambda` 表达式类型\n\n```cpp\nauto lambda = []() { return 9 + 12; }\nstd::cout << lambda() << std::endl; // 21\n```\n\n需要注意的是，`auto` 说明符要求变量必须拥有初始化器\n\n```cpp\nauto x; // compile error\nauto y = 10; // ok\n```\n\n> `auto x;` 这种写法在 C 中被允许。\n\n如果想要了解更多，可以参考 cppreference。\n\n## 基于范围的 for 循环（range-based for loop）\n\nC++11 规定了基于范围的 `for` 循环，其在一个范围上执行 `for` 循环，是传统 `for` 循环一个更加可读的等价版本，OI 中常用于图遍历。\n\n其语法如下\n\n```cpp\n[属性-可选]\nfor(范围声明: 范围表达式){\n    循环语句\n}\n```\n\n> 属性：属性说明符序列，不在 Blog 中进行说明，几乎不会用到。\n\n- 范围声明：一个具名变量的声明，类型为范围表达式中元素的类型或其引用，一般使用 `auto` 对其类型进行推导。\n- 范围表达式：一个序列（数组，或是定义了 `begin` 和 `end` 的对象，如 `vector`），或是一个花括号列表初始化器（如 `{1, 2, 3, 4, 5}`）。\n- 循环语句：常规函数体。\n\n基于范围的 `for` 循环可以用这样的常规 `for` 循环替代\n\n```cpp\nfor(auto __begin = 首表达式, __end = 尾表达式; __begin != __end; __begin++){\n    范围声明 = *__begin;\n    循环语句\n}\n```\n\n其中，对于数组 `a[]`，其首表达式为 `a`，尾表达式为 `(a + __bound)`，`__bound` 为数组长度，我们要求数组是有确定长度的。\n\n对于定义了 `begin` 和 `end` 的对象 `b`，其首表达式为 `b.begin()`，尾表达式为 `b.end()`。\n\n否则，通过实参依赖查找进行查找。\n\n一些实际使用的例子\n\n```cpp\nvector<int> g[10005];\nfor(auto v: g[u]){\n    /* something here */\n}\n\nint a[] = {1, 2, 3, 4, 5};\nfor(auto &x: a){\n   \tx++;\n    std::cout << x << ' ';\n}\n// after - a: {2, 3, 4, 5, 6}\n\nfor(auto x: {1, 3, 5, 7}){\n    std::cout << x << ' ';\n}\n```\n\n## 变参数模板（variadic template）\n\n在我看来无比实用的特性之一，你可以在我的 `template` 中找到这样一个函数\n\n```cpp\nvoid input() {}\ntemplate<typename Type, typename... Types>\nvoid input(Type& arg, Types&... args){\n    arg = read<Type>();\n    input(args...);\n}\n```\n\n这就是一个变参数模板的使用案例，你可以通过 `input()` 函数一次性对任意个变量通过快读进行读入。\n\n```cpp\nint x, y, z;\ninput(x); // ok\ninput(x, y, z); // ok\n```\n\n常用的变参数模板格式和上面大同小异，都是通过递归调用，`input(Type& arg, Types&... args)` 递归变参函数，`input(args...)` 就是在进行递归调用，我们当然需要给这样一个递归函数一个终止条件，`input()` 被称为基础函数，递归变参数函数最终在这里停止。\n"
        },
        {
          "name": "吐血整理：C++11新特性.md",
          "type": "blob",
          "size": 23.697265625,
          "content": "### auto & decltype\n\n关于C++11新特性，最先提到的肯定是类型推导，C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。\n\n- auto：让编译器在编译器就推导出变量的类型，可以通过=右边的类型推导出变量的类型。\n\n```c++\nauto a = 10; // 10是int型，可以自动推导出a是int\n```\n\n- decltype：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。\n\n```c++\ncont int &i = 1;int a = 2;decltype(i) b = 2; // b是const int&\n```\n\n### 左值右值\n\n众所周知C++11新增了右值引用，这里涉及到很多概念：\n\n- 左值：可以取地址并且有名字的东西就是左值。\n- 右值：不能取地址的没有名字的东西就是右值。\n\n- 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。\n- 将亡值：可以理解为即将要销毁的值。\n\n- 左值引用：对左值进行引用的类型。\n- 右值引用：对右值进行引用的类型。\n\n- 移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。\n- 完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。\n\n- 返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。\n\n### 列表初始化\n\n在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化。\n\n### std::function & std::bind & lambda表达式\n\nc++11新增了std::function、std::bind、lambda表达式等封装使函数调用更加方便。\n\n### 模板的改进\n\nC++11关于模板有一些细节的改进：\n\n- 模板的右尖括号\n- 模板的别名\n\n- 函数模板的默认模板参数\n\n### 并发\n\nc++11关于并发引入了好多好东西，有：\n\n- std::thread相关\n- std::mutex相关\n\n- std::lock相关\n- std::atomic相关\n\n- std::call_once相关\n- volatile相关\n\n- std::condition_variable相关\n- std::future相关\n\n- async相关\n\n### 智能指针\n\n很多人谈到c++，说它特别难，可能有一部分就是因为c++的内存管理，不像java那样有虚拟机动态的管理内存，在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过c++11引入的智能指针来解决，这种内存管理还是c++语言的优势，因为尽在掌握。\n\nc++11引入了三种智能指针：\n\n- std::shared_ptr\n- std::weak_ptr\n\n- std::unique_ptr\n\n### 基于范围的for循环\n\n看代码\n\n```c++\nvector<int> vec;\n\nfor (auto iter = vec.begin(); iter != vec.end(); iter++) { // before c++11\n    cout << *iter << endl;\n}\n\nfor (int i : vec) { // c++11基于范围的for循环\n    cout << \"i\" << endl;\n}\n```\n\n### 委托构造函数\n\n委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处：\n\n不使用委托构造函数：\n\n```c++\nstruct A {\n    A(){}\n    A(int a) { a_ = a; }\n\n    A(int a, int b) { // 好麻烦\n        a_ = a;\n        b_ = b;\n    }\n\n    A(int a, int b, int c) { // 好麻烦\n        a_ = a;\n        b_ = b;\n        c_ = c;\n    }\n\n    int a_;\n    int b_;\n    int c_;\n};\n```\n\n使用委托构造函数：\n\n```c++\nstruct A {\n    A(){}\n    A(int a) { a_ = a; }\n\n    A(int a, int b) : A(a) { b_ = b; }\n\n    A(int a, int b, int c) : A(a, b) { c_ = c; }\n\n    int a_;\n    int b_;\n    int c_;\n};\n```\n\n初始化变量是不是方便了许多。\n\n### 继承构造函数\n\n继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数，老规矩，看代码：\n\n不使用继承构造函数：\n\n```c++\nstruct Base {\n    Base() {}\n    Base(int a) { a_ = a; }\n\n    Base(int a, int b) : Base(a) { b_ = b; }\n\n    Base(int a, int b, int c) : Base(a, b) { c_ = c; }\n\n    int a_;\n    int b_;\n    int c_;\n};\n\nstruct Derived : Base {\n    Derived() {}\n    Derived(int a) : Base(a) {} // 好麻烦\n    Derived(int a, int b) : Base(a, b) {} // 好麻烦\n    Derived(int a, int b, int c) : Base(a, b, c) {} // 好麻烦\n};\nint main() {\n    Derived a(1, 2, 3);\n    return 0;\n}\n```\n\n使用继承构造函数：\n\n```c++\nstruct Base {\n    Base() {}\n    Base(int a) { a_ = a; }\n\n    Base(int a, int b) : Base(a) { b_ = b; }\n\n    Base(int a, int b, int c) : Base(a, b) { c_ = c; }\n\n    int a_;\n    int b_;\n    int c_;\n};\n\nstruct Derived : Base {\n    using Base::Base;\n};\n\nint main() {\n    Derived a(1, 2, 3);\n    return 0;\n}\n```\n\n只需要使用using Base::Base继承构造函数，就免去了很多重写代码的麻烦。\n\n### nullptr\n\nnullptr是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。举例：\n\n```c++\nvoid func(void *ptr) {\n    cout << \"func ptr\" << endl;\n}\n\nvoid func(int i) {\n    cout << \"func i\" << endl;\n}\n\nint main() {\n    func(NULL); // 编译失败，会产生二义性\n    func(nullptr); // 输出func ptr\n    return 0;\n}\n```\n\n### final & override\n\nc++11关于继承新增了两个关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。\n\n示例代码1：\n\n```c++\nstruct Base {\n    virtual void func() {\n        cout << \"base\" << endl;\n    }\n};\n\nstruct Derived : public Base{\n    void func() override { // 确保func被重写\n        cout << \"derived\" << endl;\n    }\n\n    void fu() override { // error，基类没有fu()，不可以被重写\n    }\n};\n```\n\n示例代码2：\n\n```c++\nstruct Base final {\n    virtual void func() {\n        cout << \"base\" << endl;\n    }\n};\n\nstruct Derived : public Base{ // 编译失败，final修饰的类不可以被继承\n    void func() override {\n        cout << \"derived\" << endl;\n    }\n};\n```\n\n### default\n\nc++11引入default特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码：\n\n```c++\nstruct A {\n    int a;\n    A(int i) { a = i; }\n};\n\nint main() {\n    A a; // 编译出错\n    return 0;\n}\n```\n\n上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过default，程序员只需在函数声明后加上“=default;”，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，如下：\n\n```c++\nstruct A {\n    A() = default;\n    int a;\n    A(int i) { a = i; }\n};\n\nint main() {\n    A a;\n    return 0;\n}\n```\n\n编译通过。\n\n### delete\n\nc++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，如下代码：\n\n```c++\nstruct A {\n    A() = default;\n    int a;\n    A(int i) { a = i; }\n};\n\nint main() {\n    A a1;\n    A a2 = a1;  // 正确，调用编译器隐式生成的默认拷贝构造函数\n    A a3;\n    a3 = a1;  // 正确，调用编译器隐式生成的默认拷贝赋值操作符\n}\n```\n\n有时候想禁止对象的拷贝与赋值，可以使用delete修饰，如下：\n\n```c++\nstruct A {\n    A() = default;\n    A(const A&) = delete;\n    A& operator=(const A&) = delete;\n    int a;\n    A(int i) { a = i; }\n};\n\nint main() {\n    A a1;\n    A a2 = a1;  // 错误，拷贝构造函数被禁用\n    A a3;\n    a3 = a1;  // 错误，拷贝赋值操作符被禁用\n}\n```\n\ndelele函数在c++11中很常用，std::unique_ptr就是通过delete修饰来禁止对象的拷贝的。\n\n### explicit\n\nexplicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看explicit的作用：\n\n不用explicit：\n\n```c++\nstruct A {\n    A(int value) { // 没有explicit关键字\n        cout << \"value\" << endl;\n    }\n};\n\nint main() {\n    A a = 1; // 可以隐式转换\n    return 0;\n}\n```\n\n使用explicit:\n\n```c++\nstruct A {\n    explicit A(int value) {\n        cout << \"value\" << endl;\n    }\n};\n\nint main() {\n    A a = 1; // error，不可以隐式转换\n    A aa(2); // ok\n    return 0;\n}\n```\n\n### const\n\n因为要讲后面的constexpr，所以这里简单介绍下const。\n\nconst字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。\n\n主要用法如下：\n\n1. 用于定义常量，const的修饰的变量不可更改。\n\n```c++\nconst int value = 5;\n```\n\n1. 指针也可以使用const，这里有个小技巧，从右向左读，即可知道const究竟修饰的是指针还是指针所指向的内容。\n\n```c++\nchar *const ptr; // 指针本身是常量\nconst char* ptr; // 指针指向的变量为常量\n```\n\n1. 在函数参数中使用const，一般会传递类对象时会传递一个const的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。\n\n```c++\nclass A{};\nvoid func(const A& a);\n```\n\n1. const修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。\n\n```c++\nclass A {\n    const int value = 5;\n};\nclass B {\n    const int value;\n    B(int v) : value(v){}\n};\n```\n\n1. 修饰类成员函数，表示在该函数内不可以修改该类的成员变量。\n\n```c++\nclass A{\n    void func() const;\n};\n```\n\n1. 修饰类对象，类对象只能调用该对象的const成员函数。\n\n```c++\nclass A {\n    void func() const;\n};\nconst A a;\na.func();\n```\n\n### constexpr\n\nconstexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：\n\n两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：\n\n```c++\n#include<iostream>\nusing namespace std;\n\nconstexpr int func(int i) {\n    return i + 1;\n}\n\nint main() {\n    int i = 2;\n    func(i);// 普通函数\n    func(2);// 编译期间就会被计算出来\n}\n```\n\n### enum class\n\nc++11新增有作用域的枚举类型，看代码\n\n不带作用域的枚举代码：\n\n```c++\nenum AColor {\n    kRed,\n    kGreen,\n    kBlue\n};\n\nenum BColor {\n    kWhite,\n    kBlack,\n    kYellow\n};\n\nint main() {\n    if (kRed == kWhite) {\n        cout << \"red == white\" << endl;\n    }\n    return 0;\n}\n```\n\n如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的bug，而这种完全可以通过有作用域的枚举来规避。\n\n有作用域的枚举代码：\n\n```c++\nenum class AColor {\n    kRed,\n    kGreen,\n    kBlue\n};\n\nenum class BColor {\n    kWhite,\n    kBlack,\n    kYellow\n};\n\nint main() {\n    if (AColor::kRed == BColor::kWhite) { // 编译失败\n        cout << \"red == white\" << endl;\n    }\n    return 0;\n}\n```\n\n使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。\n\n```c++\nenum class AColor : char {\n    kRed,\n    kGreen,\n    kBlue\n};\n```\n\n平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。\n\n### 非受限联合体\n\nc++11之前union中数据成员的类型不允许有非POD类型，而这个限制在c++11被取消，允许数据成员类型有非POD类型，看代码：\n\n```c++\nstruct A {\n    int a;\n    int *b;\n};\n\nunion U {\n    A a; // 非POD类型 c++11之前不可以这样定义联合体\n    int b;\n};\n```\n\n对于什么是POD类型，大家可以自行查下资料，大体上可以理解为对象可以直接memcpy的类型。\n\n### sizeof\n\nc++11中sizeof可以用的类的数据成员上，看代码：\n\nc++11前：\n\n```c++\nstruct A {\n    int data[10];\n    int a;\n};\n\nint main() {\n    A a;\n    cout << \"size \" << sizeof(a.data) << endl;\n    return 0;\n}\n```\n\nc++11后：\n\n```c++\nstruct A {\n    int data[10];\n    int a;\n};\n\nint main() {\n    cout << \"size \" << sizeof(A::data) << endl;\n    return 0;\n}\n```\n\n想知道类中数据成员的大小在c++11中是不是方便了许多，而不需要定义一个对象，在计算对象的成员大小。\n\n### assertion\n\n```c++\nstatic_assert(true/false, message);\n```\n\nc++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。\n\n### 自定义字面量\n\nc++11可以自定义字面量，平时c++中都或多或少使用过chrono中的时间，例如：\n\n```c++\nstd::this_thread::sleep_for(std::chrono::milliseconds(100)); // 100ms\nstd::this_thread::sleep_for(std::chrono::seconds(100)); // 100s\n```\n\n其实没必要这么麻烦，也可以这么写：\n\n```c++\nstd::this_thread::sleep_for(100ms); // c++14里可以这么使用，这里只是举个自定义字面量使用的例子\nstd::this_thread::sleep_for(100s);\n```\n\n这就是自定义字面量的使用，示例如下：\n\n```c++\nstruct mytype {\n    unsigned long long value;\n};\nconstexpr mytype operator\"\" _mytype ( unsigned long long n ) {\n    return mytype{n};\n}\nmytype mm = 123_mytype;\ncout << mm.value << endl;\n```\n\n关于自定义字面量，可以看下chrono的源代码。\n\n### 内存对齐\n\n#### 什么是内存对齐\n\n理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数N的倍数，这就是内存对齐。\n\n#### 为什么要内存对齐\n\n1. 硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。\n2. 提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。\n\n在c++11之前如果想创建内存对齐需要：\n\n```c++\nvoid align_cpp11_before(){\n    static char data[sizeof(void *) + sizeof(A)];\n    const uintptr_t kAlign = sizeof(void *) - 1;\n    char *align_ptr =\n        reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(data + kAlign) & ~kAlign);\n    A *attr = new (align_ptr) A;\n}\n```\n\nc++11关于内存对齐新增了一些函数：\n\n```c++\nvoid align_cpp11_after()\n{\n    static std::aligned_storage<sizeof(A),\n    alignof(A)>::type data;\n    A *attr = new (&data) A;\n}\n```\n\n还有：alignof()、std::alignment_of()、alignas()。\n\n### thread_local\n\nc++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。\n\n```c++\n#include <iostream>\n#include <thread>\n\nclass A {\n    public:\n    A() {}\n    ~A() {}\n\n    void test(const std::string &name) {\n        thread_local int count = 0;\n        ++count;\n        std::cout << name << \": \" << count << std::endl;\n    }\n};\n\nvoid func(const std::string &name) {\n    A a1;\n    a1.test(name);\n    a1.test(name);\n    A a2;\n    a2.test(name);\n    a2.test(name);\n}\n\nint main() {\n    std::thread(func, \"thread1\").join();\n    std::thread(func, \"thread2\").join();\n    return 0;\n}\n```\n\n输出：\n\n```c++\nthread1: 1\nthread1: 2\nthread1: 3\nthread1: 4\nthread2: 1\nthread2: 2\nthread2: 3\nthread2: 4\n```\n\n验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。\n\n### 基础数值类型\n\nc++11新增了几种数据类型：long long、char16_t、char32_t等\n\n### 随机数功能\n\nc++11关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码：\n\n```c++\n#include <time.h>\n\n#include <iostream>\n#include <random>\n\nusing namespace std;\n\nint main() {\n    std::default_random_engine random(time(nullptr));\n\n    std::uniform_int_distribution<int> int_dis(0, 100); // 整数均匀分布\n    std::uniform_real_distribution<float> real_dis(0.0, 1.0); // 浮点数均匀分布\n\n    for (int i = 0; i < 10; ++i) {\n        cout << int_dis(random) << ' ';\n    }\n    cout << endl;\n\n    for (int i = 0; i < 10; ++i) {\n        cout << real_dis(random) << ' ';\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n输出：\n\n```c++\n38 100 93 7 66 0 68 99 41 7\n0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863\n```\n\n代码中举例的是整数均匀分布和浮点数均匀分布，c++11提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。\n\n### 正则表达式\n\nc++11引入了regex库更好的支持正则表达式，见代码：\n\n```c++\n#include <iostream>\n#include <iterator>\n#include <regex>\n#include <string>\n\nint main() {\n    std::string s = \"I know, I'll use2 regular expressions.\";\n    // 忽略大小写\n    std::regex self_regex(\"REGULAR EXPRESSIONS\", std::regex_constants::icase);\n    if (std::regex_search(s, self_regex)) {\n        std::cout << \"Text contains the phrase 'regular expressions'\\n\";\n    }\n\n    std::regex word_regex(\"(\\\\w+)\");  // 匹配字母数字等字符\n    auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);\n    auto words_end = std::sregex_iterator();\n\n    std::cout << \"Found \" << std::distance(words_begin, words_end) << \" words\\n\";\n\n    const int N = 6;\n    std::cout << \"Words longer than \" << N << \" characters:\\n\";\n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;\n        std::string match_str = match.str();\n        if (match_str.size() > N) {\n            std::cout << \" \" << match_str << '\\n';\n        }\n    }\n\n    std::regex long_word_regex(\"(\\\\w{7,})\");\n    // 超过7个字符的单词用[]包围\n    std::string new_s = std::regex_replace(s, long_word_regex, \"[$&]\");\n    std::cout << new_s << '\\n';\n}\n```\n\n### chrono\n\nc++11关于时间引入了chrono库，源于boost，功能强大，chrono主要有三个点：\n\n- duration\n- time_point\n\n- clocks\n\n### duration\n\nstd::chrono::duration表示一段时间，常见的单位有s、ms等，示例代码：\n\n```c++\n// 拿休眠一段时间举例，这里表示休眠100ms\nstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n```\n\nsleep_for里面其实就是std::chrono::duration，表示一段时间，实际是这样：\n\n```c++\ntypedef duration<int64_t, milli> milliseconds;\ntypedef duration<int64_t> seconds;\n```\n\nduration具体模板如下：\n\n```c++\ntemplate <class Rep, class Period = ratio<1> > class duration;\n```\n\nRep表示一种数值类型，用来表示Period的数量，比如int、float、double，Period是ratio类型，用来表示【用秒表示的时间单位】比如second，常用的duration<Rep, Period>已经定义好了，在std::chrono::duration下：\n\n- ratio<3600, 1>：hours\n- ratio<60, 1>：minutes\n\n- ratio<1, 1>：seconds\n- ratio<1, 1000>：microseconds\n\n- ratio<1, 1000000>：microseconds\n- ratio<1, 1000000000>：nanosecons\n\nratio的具体模板如下：\n\n```c++\ntemplate <intmax_t N, intmax_t D = 1> class ratio;\n```\n\nN代表分子，D代表分母，所以ratio表示一个分数，可以自定义Period，比如ratio<2, 1>表示单位时间是2秒。\n\n#### time_point\n\n表示一个具体时间点，如2020年5月10日10点10分10秒，拿获取当前时间举例：\n\n```c++\nstd::chrono::time_point<std::chrono::high_resolution_clock> Now() {\n    return std::chrono::high_resolution_clock::now();\n}\n// std::chrono::high_resolution_clock为高精度时钟，下面会提到\n```\n\nclocks\n\n时钟，chrono里面提供了三种时钟：\n\n- steady_clock\n- system_clock\n\n- high_resolution_clock\n\n#### steady_clock\n\n稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用now()肯定比前一次调用now()的数值大，可用于计时。\n\n#### system_clock\n\n表示当前的系统时钟，可以用于获取当前时间：\n\n```c++\nint main() {\n    using std::chrono::system_clock;\n    system_clock::time_point today = system_clock::now();\n\n    std::time_t tt = system_clock::to_time_t(today);\n    std::cout << \"today is: \" << ctime(&tt);\n\n    return 0;\n}\n// today is: Sun May 10 09:48:36 2020\n```\n\n#### high_resolution_clock\n\nhigh_resolution_clock表示系统可用的最高精度的时钟，实际上就是system_clock或者steady_clock其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，看gcc chrono源码中high_resolution_clock是steady_clock的typedef。\n\n### 新增数据结构\n\n- std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存，提高了性能\n\n```c++\nstd::forward_list<int> fl = {1, 2, 3, 4, 5};\nfor (const auto &elem : fl) {\n    cout << elem;\n}\n```\n\n- std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似\n- std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似\n\n- std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组\n- std::tuple：元组类型，类似pair，但比pair扩展性好\n\n```c++\ntypedef std::tuple<int, double, int, double> Mytuple;\nMytuple t(0, 1, 2, 3);\nstd::cout << \"0 \" << std::get<0>(t);\nstd::cout << \"1 \" << std::get<1>(t);\nstd::cout << \"2 \" << std::get<2>(t);\nstd::cout << \"3 \" << std::get<3>(t);\n```\n\n### 新增算法\n\n- all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果都满足，则返回true\n\n```c++\nstd::vector<int> v(10, 2);\nif (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; })) {\n    std::cout << \"All numbers are even\\n\";\n}\n```\n\n- any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样\n- none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样\n\n- find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反\n- copy_if：复制满足条件的元素\n\n- itoa：对容器内的元素按序递增\n\n```c++\nstd::vector<int> l(10);\nstd::iota(l.begin(), l.end(), 19); // 19为初始值\nfor (auto n : l) std::cout << n << ' ';\n// 19 20 21 22 23 24 25 26 27 28\n```\n\n- minmax_element：返回容器内最大元素和最小元素位置\n\n```c++\nint main() {\n    std::vector<int> v = {3, 9, 1, 4, 2, 5, 9};\n\n    auto result = std::minmax_element(v.begin(), v.end());\n    std::cout << \"min element at: \" << *(result.first) << '\\n';\n    std::cout << \"max element at: \" << *(result.second) << '\\n';\n    return 0;\n}\n// min element at: 1\n// max element at: 9\n```\n\n- is_sorted、is_sorted_until：返回容器内元素是否已经排好序。\n"
        },
        {
          "name": "在c++项目中你必须真正使用的15个c++特性.md",
          "type": "blob",
          "size": 9.0703125,
          "content": "> 本文转载自：https://cppdepend.com/blog/?p=319\n\nDuring the last few years, we talk about the “C++ Renaissance”. We have to admit that Microsoft was a major part of this movement, I remember this [video](http://channel9.msdn.com/Shows/Going+Deep/Craig-Symonds-and-Mohsen-Agsen-C-Renaissance) where Craig Symonds and Mohsen Agsen talked about it.\n\nIn 2011 Microsoft announced in many articles the comeback of C++, and Microsoft C++ experts like Herb Sutter did many conferences to explain why C++ was back and mostly recommended the use of Modern C++. At the same time, the standard C++11 was approved and we began to talk about C++ as a new language.\n\nBy 2011, C++ had been in use for more than 30 years. It was not easy to convince developers that the new C++ actually simplified many frustrating facets of C++ usage and that there was a new modern way to improve the C++ Code.\n\nFor the C++ developers who do not yet switch to C++11, they can use clang-tidy to get suggestions on where they can modernize the codebase or try the [CppDepend modernization feature](https://www.cppdepend.com/Modernize). And here are the 15 features mostly used in the C++ open source libraries.\n\nLet’s take as example  [Folly](https://github.com/facebook/folly) released six years ago by Facebook, Folly is a large collection of reusable C++ library components that internally at Facebook are used extensively. And here’s the motivations from their website behind  its utility:\n\n> Folly (acronymed loosely after Facebook Open Source Library) is a library of C++11 components designed with practicality and efficiency in mind. It complements (as opposed to competing against) offerings such as Boost and of course `std`. In fact, we embark on defining our own component only when something we need is either not available, or does not meet the needed performance profile.\n\nLet’s explore from its source code 15 C++11 features:\n\n### **1- auto**\n\nC++11 introduces type inference capability using the auto keyword, which means that the compiler infers the type of a variable at the point of declaration. Folly uses  auto for almost all its variable declarations, here’s an example from its source code\n\n[![c1](http://www.javadepend.com/Blog/wp-content/uploads/c1.png)](http://www.javadepend.com/Blog/wp-content/uploads/c1.png)\n\nUsing the auto keyword permits to spend less time having to write out things the compiler already knows.\n\n### **2- nullptr**\n\nThe constant 0 has had the double role of constant integer and null pointer constant.C++11 corrects this by introducing a new keyword to serve as a distinguished null pointer constant:nulptr\n\nIn the Folly source code, all null pointers are represented by the new keyword nullptr, there ‘s no place where the constant 0 is used.\n\n### **3- shared_ptr**\n\nThe smart pointer is not a new concept, many libraries implemented it many years ago, the popular one is [boost::shared_ptr](http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/shared_ptr.htm), what’s new is its standardization, and no need anymore to use an external library to work with smart pointers.\n\nFolly uses extensively the standardized shared pointer, only a few raw pointers remain in its source code.\n\n### **4- Strongly-typed enums**\n\n“Traditional” enums in C++ export their enumerators in the surrounding scope, which can lead to name collisions, if two different enums in the same have scope define enumerators with the same name,\n\nC++11 introduces the enum class keywords. They no longer export their enumerators in the surrounding scope. Moreover, we can also now inherit from an enum.\n\n[![c2](http://www.javadepend.com/Blog/wp-content/uploads/c2.png)](http://www.javadepend.com/Blog/wp-content/uploads/c2.png)\n\n \n\n### **5- static assert**\n\nC++11 introduces a new way to test assertions at compile-time, using the new keyword static_assert, this feature is very useful to add conditions to the template parameters, as shown in this template class from Folly source code:\n\n[![c3](http://www.javadepend.com/Blog/wp-content/uploads/c3.png)](http://www.javadepend.com/Blog/wp-content/uploads/c3.png)\n\n### 6- Variadic template\n\nThe variadic template is a template, which can take an arbitrary number of template arguments of any type. Both the classes & functions can be variadic. Folly defines many variadic templates, here are two variadic template functions from the Folly source code:\n\n[![c4](http://www.javadepend.com/Blog/wp-content/uploads/c4.png)](http://www.javadepend.com/Blog/wp-content/uploads/c4.png)\n\n### **7- Range-based for loops**\n\nC++11 augmented the for statement to support the “foreach” paradigm of iterating over collections. it makes the code more simple and cleaner. Folly uses extensively this feature, here’s an example for Folly\n\n[![c6](http://www.javadepend.com/Blog/wp-content/uploads/c6.png)](http://www.javadepend.com/Blog/wp-content/uploads/c6.png)\n\n### **8-Initializer lists**\n\nIn C++03 Initializer lists concern only arrays, in C++11 are not just for arrays anymore. The mechanism for accepting a **{}**-list is a function (often a constructor) accepting an argument of type **std::initializer_list<T>**. Here’s an example of function accepting std::initializer_list as an argument\n\n[![c7](http://www.javadepend.com/Blog/wp-content/uploads/c7.png)](http://www.javadepend.com/Blog/wp-content/uploads/c7.png)\n\nAnd here’s how it’s invoked\n\n[![c8](http://www.javadepend.com/Blog/wp-content/uploads/c8.png)](http://www.javadepend.com/Blog/wp-content/uploads/c8.png)\n\n### **9- noexcept**\n\nIf a function cannot throw an exception or if the program isn’t written to handle exceptions thrown by a function, that function can be declared **noexcept.**\n\nHere’s an example from Folly source code\n\n[![c9](http://www.javadepend.com/Blog/wp-content/uploads/c9.png)](http://www.javadepend.com/Blog/wp-content/uploads/c9.png)\n\n### **10- move**\n\nC++11 has introduced the concept of rvalue references (specified with &&) to differentiate a reference to an lvalue or an rvalue. An lvalue is an object that has a name, while an rvalue is an object that does not have a name (a temporary object). The move semantics allow modifying rvalues.\n\nFor that C++11 introduces two new special member functions: the *move constructor* and the *move assignment operator*.\n\n[![c12](http://www.javadepend.com/Blog/wp-content/uploads/c12.png)](http://www.javadepend.com/Blog/wp-content/uploads/c12.png)\n\n[![c10](http://www.javadepend.com/Blog/wp-content/uploads/c10.png)](http://www.javadepend.com/Blog/wp-content/uploads/c10.png)\n\nHere’s a [good document](http://www.stroustrup.com/move.pdf) that explains better the benefits of move semantics.\n\n### **11-lambda**\n\nC++11 provides the ability to create anonymous functions, called lambda functions, you can refer [here](http://www.stroustrup.com/C++11FAQ.html#lambda) for more details about this new feature.\n\nFolly uses it in many functions, here’s an example from its source code:\n\n[![c14](http://www.javadepend.com/Blog/wp-content/uploads/c14.png)](http://www.javadepend.com/Blog/wp-content/uploads/c14.png)\n\n### **12- Explicitly defaulted and deleted special member functions**\n\nIn C++03, the compiler provides, for classes that do not provide them for themselves, a default constructor, a copy constructor, a copy assignment operator (`operator=`), and a destructor. The programmer can override these defaults by defining custom versions.\n\nHowever, there is very little control over the creation of these defaults. Making a class inherently non-copyable, for example, requires declaring a private copy constructor and copy assignment operator and not defining them.\n\nIn C++11, certain features can be explicitly disabled. For example, the following type is non-copyable, which makes the code more simple and clean.\n\n[![c15](http://www.javadepend.com/Blog/wp-content/uploads/c15.png)](http://www.javadepend.com/Blog/wp-content/uploads/c15.png)\n\n### **13- override identifier**\n\nIn C++03, it is possible to accidentally create a new virtual function, when one intended to override a base class function.\n\nThe `override` special identifier means that the compiler will check the base class(es) to see if there is a virtual function with this exact signature. And if there is not, the compiler will indicate an error.\n\nFolly uses extensively this new feature:\n\n[![c18](http://www.javadepend.com/Blog/wp-content/uploads/c18.png)](http://www.javadepend.com/Blog/wp-content/uploads/c18.png)\n\n \n\n### **14- std::thread**\n\nA thread class (`std::thread`) is provided which takes a function object — and an optional series of arguments to pass to it — to run in the new thread.\n\nIn C++11 working with threads is more simplified, here’s from Folly source code the new standard way to defines a new thread:\n\n[![c20](http://www.javadepend.com/Blog/wp-content/uploads/c20.png)](http://www.javadepend.com/Blog/wp-content/uploads/c20.png)\n\n### **15- Unordered containers**\n\nAn unordered container is a kind of hash table. C++11 offers four standard ones:\n\n- unordered_map\n- unordered_set\n- unordered_multimap\n- unordered_multiset\n\nFolly uses in many places these new containers\n\n[![c21](http://www.javadepend.com/Blog/wp-content/uploads/c21.png)](http://www.javadepend.com/Blog/wp-content/uploads/c21.png)\n"
        },
        {
          "name": "如何在 C++11 中使用 Lambda 表达式.md",
          "type": "blob",
          "size": 8.0859375,
          "content": "> 原文链接：https://www.oracle.com/cn/servers/technologies/howto-use-lambda-exp-cpp11.html\n### Lambda 表达式不仅具有函数指针的灵活性，还可以通过捕获局部变量提高可扩展性。本文介绍 Lambda 表达式的语法和用法。\n\n### 简介\n\nLambda 可能是最新的 C++11 标准的典型特性之一。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。\n\n当一个函数需要将另一个函数用作参数时，可以使用 Lambda。例如，C qsort() 函数接受一个指向比较函数的指针，如清单 1 所示。\n\n```c++\n#include <stdlib.h> \n #include <stdio.h> \n static int intcompare(const void *p1, const void *p2) \n {   \n int i = *((int *)p1);  \n int j = *((int *)p2); \n return (i < j) ;\n }  \n int main() \n {   \n int a[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }; \n qsort((void *)a, 10, sizeof (int), intcompare);\n for (int i = 0; i < 10; i++) { printf(\"%d \", a[i]); }  \n printf(\"\\n\"); \n return 0;  }\n```\n\n**清单 1**\n\n清单 1 中的代码有以下几点不足：\n\n- 比较函数需要单独声明。这增加了将错误的比较函数传递给 qsort() 操作的风险。\n- 比较函数接受 void * 参数，因此缺失了某种程度的类型检查。\n- 比较函数看不到任何局部作用的变量。因此，如果存在其他影响排序的因素，必须在更大范围内声明。\n\n清单 2 显示重新编写后的清单 1 中的示例，将 C++ std::sort() 算法与 lambda 表达式结合使用。由于 std::sort() 是一个模板，因此会保留所有类型信息。注意如何在通常出现函数名的位置编写 lambda 表达式。\n\n```c++\n#include <algorithm> \n int main() \n {\n int a[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };   \nstd::sort( a, &a[10], [](int x, int y){ return x < y; } );\n    for(int i=0; i<10; i++) { printf(\"%i \", a[i]); }  \n  printf(\"\\n\");    \n  return 0; \n  }\n```\n\n**清单 2**\n\n### Lambda 表达式的基本语法\n\nLambda 表达式本质上与函数声明非常类似。我们可以提取清单 2 中的 lambda 表达式，详加说明。提取的 lambda 表达式如清单 3 所示：\n\n```c++\n[](int x, int y){ return x < y ; }\n```\n\n**清单 3**\n\n如果我们将 lambda 表达式比作函数，可以看到它与函数名对应的是一对空的方括号，即*捕获表达式*。这些括号表示后面跟着一个 lambda 表达式。这些方括号不必为空；稍后将讨论其内容。\n\n如果 lambda 主体只含一个返回类型，则暗示返回的表达式类型为 lambda 返回类型。如果要显式指定返回类型，需使用新的 C++11 语法表示函数声明中的后置返回类型。对于返回类型 T 的普通函数，您可以这样编写：\n\n```c++\nauto foo(...) -> T { ... }\n```\n\n对于 lambda，您需要要这样编写：\n\n```c++\n[] (...) -> T { ... }\n```\n\nlambda 表达式的其余部分与常规 C 或 C++ 函数主体类似。\n\n### 将 Lambda 传递到函数指针\n\nC++11 标准库中有一个名为 function 的模板，它可以接受指定类型的函数或者具有匹配的返回类型和参数列表的 lambda。这将产生一个指向函数类型的指针，例如，清单 4 可用作函数参数类型，接受 int 参数，返回 void。您可以向其传递任何类似匹配函数或 lambda 的内容。\n\n```c++\nstd::function<void(int)>\n```\n\n**清单 4**\n\n清单 5 显示的函数扫描一个数组，对每个元素应用一个给定函数。\n\n```c++\nvoid scan( int* a, int length, std::function<void(int)> process ) \n {  \n for(int i=0; i<length; i++) \n {   \n process(a[i]); \n } \n }\n```\n\n**清单 5**\n\n清单 6 显示如何通过传递一个函数或 lambda 表达式作为参数来调用 scan() 函数。\n\n```c++\nvoid f(int);\n  int a[10];  \n  ... \n  scan(a, 10, f); \n  scan(a, 10, [](int k)->void { ... } );\n```\n\n**清单 6**\n\n### Lambda 表达式中的变量捕获\n\n到目前为止，我们对 lambda 表达式的处理基本与标准函数调用类似：传入参数，返回结果。然而，在函数主体中声明的 lambda 表达式还是可以捕获在声明 lambda 处可见的函数的任何局部变量。\n\n假设我们需要使用函数 scan()，但希望 process 函数只对大于某个阈值的值起作用。我们不能修改 scan()，不能让 scan() 向 process 函数传递多个参数。但如果我们将一个 lambda 表达式传递给 scan() 函数，则可以从其环境捕获一个局部变量。\n\n在清单 7 中，我们将希望捕获的变量放在方括号中，即放在捕获表达式中。这实际上向 lambda 表达式中额外传递了一个参数，但无需更改 scan 函数的定义。就像传递参数给函数一样，我们实际上是在函数的调用点捕获值 threshold 的副本，这称为*通过值捕获*。\n\n```c++\n#include <algorithm> \n void scan( int* a, int length, std::function<void(int)> process) \n {  \n for(int i=0; i<length; i++) {   \n process(a[i]); \n } \n } \n int main()  \n {   \n int a[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };   \n int threshold = 5;   \nscan(a, 10,\n     [threshold](int v)\n  { if (v>threshold) { printf(\"%i \", v); } }\n  );  \n  printf(\"\\n\");   \n  return 0;  }\n```\n\n**清单 7**\n\n有一个简写形式 [=]，表示“通过值捕获每个变量”。在清单 8 中，我们将函数调用重新编写为使用这种更短的表达式。\n\n```c++\nscan(a, 10, [=](int v) { if (v>threshold) { printf(\"%i \", v); } });\n```\n\n**清单 8**\n\n**注**：通过值捕获变量意味着生成局部副本。如果有多个局部变量，全部捕获可能会导致 lambda 产生显著开销。\n\n但有些情况下，我们希望修改捕获的变量。例如，假设我们要计算最大值并将其存储在变量 max 中。在这种情况下，我们不想使用该变量值的副本，而是希望使用该变量的引用，这样，我们就可以在模板中修改该变量。这称为*通过引用捕获变量*。清单 9 显示了这样一个示例。\n\n```c++\n#include <algorithm> \n void scan(int * a, int length, std::function<void (int)> func) \n {   \n for(int i=0; i<length; i++) {  \n func(a[i]);   \n } \n } \n int main() \n {  \n int a[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }; \n int threshold = 5; \n int max =0;   \n std::sort( a, &a[10], [](int x, int y){return (x < y);});  \n scan(a, 10,\n [threshold,&max](int v) { if (v>max) {max = v;}\nif (v>threshold) { printf(\"%i \", v); } });\n   printf(\"\\n\");  \n   printf(\"Max = %i\\n\",max);  \n   return 0; \n   }\n```\n\n**清单 9**\n\n同样，也有一个简写形式 [&]，用于应通过引用捕获每个变量的情况。\n\n### Lambda 表达式、函数对象和函子\n\n虽然 lambda 表达式是 C++11 的新特性，但用这种方式访问现有语言特性的确很方便。lambda 表达式是*函数对象* 的速记表示法。函数对象是一个具有成员 operator()()（函数调用运算符）的类类型对象，因此可以像函数一样调用。函数对象类型被称作*函子*。清单 10 显示了一个函子的示例。\n\n```c++\nclass compare_ints { \n public:  \n compare_ints(int j, int k ) : l(j), r(k) { } \n bool operator()() { return l < r; }  \n private:  \n int l, r;  };\n```\n\n**清单 10**\n\n您可以创建一个 compare_ints 对象，用两个整型值初始化，如果第一个值小于第二个值，使用函数调用运算符返回 true：\n\n```c++\ncompare_ints comp(j, k); \n bool less_than = comp();\n```\n\n也可以动态创建一个临时对象，然后直接使用：\n\n```c++\nbool less_than = compare_ints(j, k)();\n```\n\n使用 lambda 表达式不必创建和命名函子类即可达到这种效果。编译器为您创建一个匿名函子，如清单 11 所示。\n\n```c++\nauto comp = [](int j, int k) { return j < k; };  \nbool less_than =  comp(l,r);\n```\n\n**清单 11**\n\n在清单 11 中，comp 是匿名函子类型的对象。\n\n您也可以动态执行此操作：\n\n```c++\nbool less_than = [l,r]() { return l < r; }();\n```\n\n### 总结\n\nLambda 表达式是一种非常强大的 C++ 扩展。它们不仅具有函数指针的灵活性，还可以通过捕获局部变量提高可扩展性。\n\n显然，与 C++11 中广泛的模板特性结合时，lambda 表达式会变得更加 有用，这种情况在按 C++11 标准编写的代码中会经常遇到。\n"
        },
        {
          "name": "学习笔记：C++ 11新特性.md",
          "type": "blob",
          "size": 53.837890625,
          "content": "# C++11新特性之auto和decltype知识点\n\nC++11引入了auto和decltype关键字，使用它们可以在编译期就推导出变量或者表达式的类型，方便开发者编码的同时也简化了代码。\n\n## auto\n\nauto可以让编译器在编译器就推导出变量的类型，看代码：\n\n```c++\nauto a = 10; // 10是int型，可以自动推导出a是int\nint i = 10;auto b = i; // b是int型\nauto d = 2.0; // d是double型\n```\n\n这就是auto的基本用法，可以通过=右边的类型推导出变量的类型。\n\n### auto推导规则\n\n直接看代码\n\n代码1：\n\n```c++\nint i = 10;\nauto a = i, &b = i, *c = &i; // a是int，b是i的引用，c是i的指针，auto就相当于int\nauto d = 0, f = 1.0; // error，0和1.0类型不同，对于编译器有二义性，没法推导\nauto e; // error，使用auto必须马上初始化，否则无法推导类型\n```\n\n代码2：\n\n```c++\nvoid func(auto value) {} // error，auto不能用作函数参数\n\nclass A {\n    auto a = 1; // error，在类中auto不能用作非静态成员变量\n    static auto b = 1; // error，这里与auto无关，正常static int b = 1也不可以\n    static const auto int c = 1; // ok\n};\n\nvoid func2() {\n    int a[10] = {0};\n    auto b = a; // ok\n    auto c[10] = a; // error，auto不能定义数组，可以定义指针\n    vector<int> d;\n    vector<auto> f = d; // error，auto无法推导出模板参数\n}\n```\n\nauto的限制：\n\n- auto的使用必须马上初始化，否则无法推导出类型\n- auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败\n\n- auto不能用作函数参数\n- 在类中auto不能用作非静态成员变量\n\n- auto不能定义数组，可以定义指针\n- auto无法推导出模板参数\n\n再看这段代码：\n\n```c++\nint i = 0;\nauto *a = &i; // a是int*\nauto &b = i; // b是int&\nauto c = b; // c是int，忽略了引用\n\nconst auto d = i; // d是const int\nauto e = d; // e是int\n\nconst auto& f = e; // f是const int&\nauto &g = f; // g是const int&\n```\n\n首先，介绍下，这里的cv是指const 和volatile\n\n推导规则\n\n- 在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定\n- 在声明为引用或者指针时，auto会保留等号右边的引用和cv属性\n\n### 什么时候使用auto？\n\n这里没有绝对答案，在不影响代码代码可读性的前提下尽可能使用auto是蛮好的，复杂类型就使用auto，int、double这种就没有必要使用auto了，看下面这段代码：\n\n```c++\nauto func = [&] {\n    cout << \"xxx\";\n}; // 对于func难道不使用auto吗，反正是不关心lambda表达式究竟是什么类型。\n\nauto asyncfunc = std::async(std::launch::async, func);\n// 对于asyncfunc难道不使用auto吗，懒得写std::futurexxx等代码，而且也记不住它返回的究竟是什么...\n```\n\n## decltype\n\n上面介绍auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算，上代码：\n\n```c++\nint func() { return 0; }\ndecltype(func()) i; // i为int类型\n\nint x = 0;\ndecltype(x) y; // y是int类型\ndecltype(x + y) z; // z是int类型\n```\n\n注意：decltype不会像auto一样忽略引用和cv属性，decltype会保留表达式的引用和cv属性\n\n```c++\ncont int &i = 1;\nint a = 2;\ndecltype(i) b = 2; // b是const int&\n```\n\n### decltype推导规则\n\n对于decltype(exp)有\n\n- exp是表达式，decltype(exp)和exp类型相同\n- exp是函数调用，decltype(exp)和函数返回值类型相同\n\n- 其它情况，若exp是左值，decltype(exp)是exp类型的左值引用\n\n```c++\nint a = 0, b = 0;\ndecltype(a + b) c = 0; // c是int，因为(a+b)返回一个右值\ndecltype(a += b) d = c;// d是int&，因为(a+=b)返回一个左值\n\nd = 20;\ncout << \"c \" << c << endl; // 输出c 20\n```\n\n## auto和decltype的配合使用\n\nauto和decltype一般配合使用在推导函数返回值的类型问题上。\n\n下面这段代码\n\n```c++\ntemplate<typename T, typename U>\nreturn_value add(T t, U u) { // t和v类型不确定，无法推导出return_value类型\n    return t + u;\n}\n```\n\n上面代码由于t和u类型不确定，那如何推导出返回值类型呢，可能会想到这种\n\n```c++\ntemplate<typename T, typename U>\ndecltype(t + u) add(T t, U u) { // t和u尚未定义\n    return t + u;\n}\n```\n\n这段代码在C++11上是编译不过的，因为在decltype(t +u)推导时，t和u尚未定义，就会编译出错，所以有了下面的叫做返回类型后置的配合使用方法：\n\n```c++\ntemplate<typename T, typename U>\nauto add(T t, U u) -> decltype(t + u) {\n    return t + u;\n}\n```\n\n返回值后置类型语法就是为了解决函数返回值类型依赖于参数但却难以确定返回值类型的问题。\n\n# C++11新特性之左值引用、右值引用、移动语义、完美转发\n\nC++11新增了右值引用，谈右值引用也可以扩展一些相关概念：\n\n- 左值\n- 右值\n\n- 纯右值\n- 将亡值\n\n- 左值引用\n- 右值引用\n\n- 移动语义\n- 完美转发\n\n- 返回值优化\n\n### 左值、右值\n\n概念1：\n\n左值：可以放到等号左边的东西叫左值。\n\n右值：不可以放到等号左边的东西就叫右值。\n\n概念2：\n\n左值：可以取地址并且有名字的东西就是左值。\n\n右值：不能取地址的没有名字的东西就是右值。\n\n举例：\n\n```c++\nint a = b + c;\n```\n\na是左值，有变量名，可以取地址，也可以放到等号左边, 表达式b+c的返回值是右值，没有名字且不能取地址，&(b+c)不能通过编译，而且也不能放到等号左边。\n\n```c++\nint a = 4; // a是左值，4作为普通字面量是右值\n```\n\n左值一般有：\n\n- 函数名和变量名\n- 返回左值引用的函数调用\n\n- 前置自增自减表达式++i、--i\n- 由赋值表达式或赋值运算符连接的表达式(a=b, a += b等)\n\n- 解引用表达式*p\n- 字符串字面值\"abcd\"\n\n### 纯右值、将亡值\n\n纯右值和将亡值都属于右值。\n\n#### 纯右值\n\n运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。\n\n举例：\n\n- 除字符串字面值外的字面值\n- 返回非引用类型的函数调用\n\n- 后置自增自减表达式i++、i--\n- 算术表达式(a+b, a*b, a&&b, a==b等)\n\n- 取地址表达式等(&a)\n\n#### 将亡值\n\n将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、T&&函数的返回值、std::move函数的返回值、转换为T&&类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。\n\n举例：\n\n```c++\nclass A {\n    xxx;\n};\nA a;\nauto c = std::move(a); // c是将亡值\nauto d = static_cast<A&&>(a); // d是将亡值\n```\n\n#### 左值引用、右值引用\n\n根据名字大概就可以猜到意思，左值引用就是对左值进行引用的类型，右值引用就是对右值进行引用的类型，他们都是引用，都是对象的一个别名，并不拥有所绑定对象的堆存，所以都必须立即初始化。\n\n```c++\ntype &name = exp; // 左值引用\ntype &&name = exp; // 右值引用\n```\n\n左值引用\n\n看代码：\n\n```c++\nint a = 5;\nint &b = a; // b是左值引用\nb = 4;\nint &c = 10; // error，10无法取地址，无法进行引用\nconst int &d = 10; // ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址\n```\n\n可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。\n\n右值引用\n\n如果使用右值引用，那表达式等号右边的值需要时右值，可以使用std::move函数强制把左值转换为右值。\n\n```c++\nint a = 4;\nint &&b = a; // error, a是左值\nint &&c = std::move(a); // ok\n```\n\n### 移动语义\n\n谈移动语义前，首先需要了解深拷贝与浅拷贝的概念\n\n#### 深拷贝、浅拷贝\n\n直接拿代码举例:\n\n```c++\nclass A {\npublic:\n    A(int size) : size_(size) {\n        data_ = new int[size];\n    }\n    A(){}\n    A(const A& a) {\n        size_ = a.size_;\n        data_ = a.data_;\n        cout << \"copy \" << endl;\n    }\n    ~A() {\n        delete[] data_;\n    }\n    int *data_;\n    int size_;\n};\nint main() {\n    A a(10);\n    A b = a;\n    cout << \"b \" << b.data_ << endl;\n    cout << \"a \" << a.data_ << endl;\n    return 0;\n}\n```\n\n上面代码中，两个输出的是相同的地址，a和b的data_指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时data_内存会被释放两次，导致程序出问题，这里正常会出现double free导致程序崩溃的，这样的程序肯定是有隐患的，如何消除这种隐患呢，可以使用如下深拷贝：\n\n```c++\nclass A {\npublic:\n    A(int size) : size_(size) {\n        data_ = new int[size];\n    }\n    A(){}\n    A(const A& a) {\n        size_ = a.size_;\n        data_ = new int[size_];\n        cout << \"copy \" << endl;\n    }\n    ~A() {\n        delete[] data_;\n    }\n    int *data_;\n    int size_;\n};\nint main() {\n    A a(10);\n    A b = a;\n    cout << \"b \" << b.data_ << endl;\n    cout << \"a \" << a.data_ << endl;\n    return 0;\n}\n```\n\n深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值。\n\n移动语义可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数。\n\n```c++\nclass A {\npublic:\n    A(int size) : size_(size) {\n        data_ = new int[size];\n    }\n    A(){}\n    A(const A& a) {\n        size_ = a.size_;\n        data_ = new int[size_];\n        cout << \"copy \" << endl;\n    }\n    A(A&& a) {\n        this->data_ = a.data_;\n        a.data_ = nullptr;\n        cout << \"move \" << endl;\n    }\n    ~A() {\n        if (data_ != nullptr) {\n         delete[] data_;\n        }\n    }\n    int *data_;\n    int size_;\n};\nint main() {\n    A a(10);\n    A b = a;\n    A c = std::move(a); // 调用移动构造函数\n    return 0;\n}\n```\n\n如果不使用std::move()，会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++所有的STL都实现了移动语义，方便使用。例如：\n\n```c++\nstd::vector<string> vecs;\n...\nstd::vector<string> vecm = std::move(vecs); // 免去很多拷贝\n```\n\n注意：移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。\n\n### 完美转发\n\n完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。\n\n```c++\nvoid PrintV(int &t) {\n    cout << \"lvalue\" << endl;\n}\n\nvoid PrintV(int &&t) {\n    cout << \"rvalue\" << endl;\n}\n\ntemplate<typename T>\nvoid Test(T &&t) {\n    PrintV(t);\n    PrintV(std::forward<T>(t));\n\n    PrintV(std::move(t));\n}\n\nint main() {\n    Test(1); // lvalue rvalue rvalue\n    int a = 1;\n    Test(a); // lvalue lvalue rvalue\n    Test(std::forward<int>(a)); // lvalue rvalue rvalue\n    Test(std::forward<int&>(a)); // lvalue lvalue rvalue\n    Test(std::forward<int&&>(a)); // lvalue rvalue rvalue\n    return 0;\n}\n```\n\n分析\n\n- Test(1)：1是右值，模板中T &&t这种为万能引用，右值1传到Test函数中变成了右值引用，但是调用PrintV()时候，t变成了左值，因为它变成了一个拥有名字的变量，所以打印lvalue，而PrintV(std::forward<T>(t))时候，会进行完美转发，按照原来的类型转发，所以打印rvalue，PrintV(std::move(t))毫无疑问会打印rvalue。\n- Test(a)：a是左值，模板中T &&这种为万能引用，左值a传到Test函数中变成了左值引用，所以有代码中打印。\n\n- Test(std::forward<T>(a))：转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值。\n\n### 返回值优化\n\n返回值优化(RVO)是一种C++编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。\n\n那什么时候编译器会进行返回值优化呢?\n\n- return的值类型与函数的返回值类型相同\n- return的是一个局部对象\n\n看几个例子:\n\n示例1：\n\n```c++\nstd::vector<int> return_vector(void) {\n    std::vector<int> tmp {1,2,3,4,5};\n    return tmp;\n}\nstd::vector<int> &&rval_ref = return_vector();\n```\n\n不会触发RVO，拷贝构造了一个临时的对象，临时对象的生命周期和rval_ref绑定，等价于下面这段代码：\n\n```c++\nconst std::vector<int>& rval_ref = return_vector();\n```\n\n示例2：\n\n```c++\nstd::vector<int>&& return_vector(void) {\n    std::vector<int> tmp {1,2,3,4,5};\n    return std::move(tmp);\n}\n\nstd::vector<int> &&rval_ref = return_vector();\n```\n\n这段代码会造成运行时错误，因为rval_ref引用了被析构的tmp。讲道理来说这段代码是错的，自己运行过程中却成功了，继续向下看什么时候会触发RVO。\n\n示例3：\n\n```c++\nstd::vector<int> return_vector(void) {\n    std::vector<int> tmp {1,2,3,4,5};\n    return std::move(tmp);\n}\n\nstd::vector<int> &&rval_ref = return_vector();\n```\n\n和示例1类似，std::move一个临时对象是没有必要的，也会忽略掉返回值优化。\n\n最好的代码：\n\n```c++\nstd::vector<int> return_vector(void) {\n    std::vector<int> tmp {1,2,3,4,5};\n    return tmp;\n}\n\nstd::vector<int> rval_ref = return_vector();\n```\n\n这段代码会触发RVO，不拷贝也不移动，不生成临时对象。\n\n# C++11新特性之列表初始化\n\nC++11新增了列表初始化的概念。\n\n在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化。\n\n```c++\nstruct A {\n    public:\n    A(int) {}\n    private:\n    A(const A&) {}\n};\nint main() {\n    A a(123);\n    A b = 123; // error\n    A c = { 123 };\n    A d{123}; // c++11\n\n    int e = {123};\n    int f{123}; // c++11\n\n    return 0;\n}\n```\n\n列表初始化也可以用在函数的返回值上\n\n```c++\nstd::vector<int> func() {\n    return {};\n}\n```\n\n### 列表初始化的一些规则\n\n首先说下聚合类型可以进行直接列表初始化，这里需要了解什么是聚合类型：\n\n1. 类型是一个普通数组，如int[5]，char[]，double[]等\n2. 类型是一个类，且满足以下条件：\n\n- - 没有用户声明的构造函数\n  - 没有用户提供的构造函数(允许显示预置或弃置的构造函数)\n\n- - 没有私有或保护的非静态数据成员\n  - 没有基类\n\n- - 没有虚函数\n  - 没有{}和=直接初始化的非静态数据成员\n\n- - 没有默认成员初始化器\n\n```c++\nstruct A {\n    int a;\n    int b;\n    int c;\n    A(int, int){}\n};\nint main() {\n    A a{1, 2, 3};// error，A有自定义的构造函数，不能列表初始化\n}\n```\n\n上述代码类A不是聚合类型，无法进行列表初始化，必须以自定义的构造函数来构造对象。\n\n```c++\nstruct A {\n    int a;\n    int b;\n    virtual void func() {} // 含有虚函数，不是聚合类\n};\n\nstruct Base {};\nstruct B : public Base { // 有基类，不是聚合类\n    int a;\n    int b;\n};\n\nstruct C {\n    int a;\n    int b = 10; // 有等号初始化，不是聚合类\n};\n\nstruct D {\n    int a;\n    int b;\n    private:\n    int c; // 含有私有的非静态数据成员，不是聚合类\n};\n\nstruct E {\n    int a;\n    int b;\n    E() : a(0), b(0) {} // 含有默认成员初始化器，不是聚合类\n};\n```\n\n上面列举了一些不是聚合类的例子，对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值；对于非聚合类型，需要先自定义一个对应的构造函数，此时列表初始化将调用相应的构造函数。\n\n### std::initializer_list\n\n平时开发使用STL过程中可能发现它的初始化列表可以是任意长度，大家有没有想过它是怎么实现的呢，答案是std::initializer_list，看下面这段示例代码：\n\n```c++\nstruct CustomVec {\n    std::vector<int> data;\n    CustomVec(std::initializer_list<int> list) {\n        for (auto iter = list.begin(); iter != list.end(); ++iter) {\n            data.push_back(*iter);\n        }\n    }\n};\n```\n\n这个std::initializer_list其实也可以作为函数参数。\n\n注意：std::initializer_list<T>，它可以接收任意长度的初始化列表，但是里面必须是相同类型T，或者都可以转换为T。\n\n### 列表初始化的好处\n\n列表初始化的好处如下：\n\n1. 方便，且基本上可以替代括号初始化\n2. 可以使用初始化列表接受任意长度\n\n1. 可以防止类型窄化，避免精度丢失的隐式类型转换\n\n什么是类型窄化，列表初始化通过禁止下列转换，对隐式转化加以限制：\n\n- 从浮点类型到整数类型的转换\n- 从 long double 到 double 或 float 的转换，以及从 double 到 float 的转换，除非源是常量表达式且不发生溢出\n\n- 从整数类型到浮点类型的转换，除非源是其值能完全存储于目标类型的常量表达式\n- 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是其值能完全存储于目标类型的常量表达式\n\n示例：\n\n```c++\nint main() {\n    int a = 1.2; // ok\n    int b = {1.2}; // error\n\n    float c = 1e70; // ok\n    float d = {1e70}; // error\n\n    float e = (unsigned long long)-1; // ok\n    float f = {(unsigned long long)-1}; // error\n    float g = (unsigned long long)1; // ok\n    float h = {(unsigned long long)1}; // ok\n\n    const int i = 1000;\n    const int j = 2;\n    char k = i; // ok\n    char l = {i}; // error\n\n    char m = j; // ok\n    char m = {j}; // ok，因为是const类型，这里如果去掉const属性，也会报错\n}\n```\n\n打印如下：\n\n```c++\ntest.cc:24:17: error: narrowing conversion of ‘1.2e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]\n    int b = {1.2};\n                ^\ntest.cc:27:20: error: narrowing conversion of ‘1.0000000000000001e+70’ from ‘double’ to ‘float’ inside { } [-Wnarrowing]\n     float d = {1e70};\n\ntest.cc:30:38: error: narrowing conversion of ‘18446744073709551615’ from ‘long long unsigned int’ to ‘float’ inside { } [-Wnarrowing]\n    float f = {(unsigned long long)-1};\n                                     ^\ntest.cc:36:14: warning: overflow in implicit constant conversion [-Woverflow]\n    char k = i;\n             ^\ntest.cc:37:16: error: narrowing conversion of ‘1000’ from ‘int’ to ‘char’ inside { } [-Wnarrowing]\n    char l = {i};\n```\n\n# C++11新特性std::function和lambda表达式\n\nc++11新增了`std::function`、`std::bind`、`lambda`表达式等封装使函数调用更加方便。\n\n## `std::function`\n\n讲`std::function`前首先需要了解下什么是可调用对象\n\n满足以下条件之一就可称为可调用对象：\n\n- 是一个函数指针\n- 是一个具有`operator()`成员函数的类对象(传说中的仿函数)，lambda表达式\n\n- 是一个可被转换为函数指针的类对象\n- 是一个类成员(函数)指针\n\n- bind表达式或其它函数对象\n\n而`std::function`就是上面这种可调用对象的封装器，可以把`std::function`看做一个函数对象，用于表示函数这个抽象概念。`std::function`的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为`std::function`的目标，若`std::function`不含目标，则称它为空，调用空的`std::function`的目标会抛出`std::bad_function_call`异常。\n\n使用参考如下实例代码：\n\n```c++\nstd::function<void(int)> f; // 这里表示function的对象f的参数是int，返回值是void\n#include <functional>\n#include <iostream>\n\nstruct Foo {\n    Foo(int num) : num_(num) {}\n    void print_add(int i) const { std::cout << num_ + i << '\\n'; }\n    int num_;\n};\n\nvoid print_num(int i) { std::cout << i << '\\n'; }\n\nstruct PrintNum {\n    void operator()(int i) const { std::cout << i << '\\n'; }\n};\n\nint main() {\n    // 存储自由函数\n    std::function<void(int)> f_display = print_num;\n    f_display(-9);\n\n    // 存储 lambda\n    std::function<void()> f_display_42 = []() { print_num(42); };\n    f_display_42();\n\n    // 存储到 std::bind 调用的结果\n    std::function<void()> f_display_31337 = std::bind(print_num, 31337);\n    f_display_31337();\n\n    // 存储到成员函数的调用\n    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;\n    const Foo foo(314159);\n    f_add_display(foo, 1);\n    f_add_display(314159, 1);\n\n    // 存储到数据成员访问器的调用\n    std::function<int(Foo const&)> f_num = &Foo::num_;\n    std::cout << \"num_: \" << f_num(foo) << '\\n';\n\n    // 存储到成员函数及对象的调用\n    using std::placeholders::_1;\n    std::function<void(int)> f_add_display2 = std::bind(&Foo::print_add, foo, _1);\n    f_add_display2(2);\n\n    // 存储到成员函数和对象指针的调用\n    std::function<void(int)> f_add_display3 = std::bind(&Foo::print_add, &foo, _1);\n    f_add_display3(3);\n\n    // 存储到函数对象的调用\n    std::function<void(int)> f_display_obj = PrintNum();\n    f_display_obj(18);\n}\n```\n\n从上面可以看到`std::function`的使用方法，当给`std::function`填入合适的参数表和返回值后，它就变成了可以容纳所有这一类调用方式的函数封装器。`std::function`还可以用作回调函数，或者在C++里如果需要使用回调那就一定要使用`std::function`，特别方便。\n\n## `std::bind`\n\n使用`std::bind`可以将可调用对象和参数一起绑定，绑定后的结果使用`std::function`进行保存，并延迟调用到任何需要的时候。\n\n`std::bind`通常有两大作用：\n\n- 将可调用对象与参数一起绑定为另一个`std::function`供调用\n- 将n元可调用对象转成m(m < n)元可调用对象，绑定一部分参数，这里需要使用`std::placeholders`\n\n具体示例：\n\n```c++\n#include <functional>\n#include <iostream>\n#include <memory>\n\nvoid f(int n1, int n2, int n3, const int& n4, int n5) {\n    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << std::endl;\n}\n\nint g(int n1) { return n1; }\n\nstruct Foo {\n    void print_sum(int n1, int n2) { std::cout << n1 + n2 << std::endl; }\n    int data = 10;\n};\n\nint main() {\n    using namespace std::placeholders;  // 针对 _1, _2, _3...\n\n    // 演示参数重排序和按引用传递\n    int n = 7;\n    // （ _1 与 _2 来自 std::placeholders ，并表示将来会传递给 f1 的参数）\n    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);\n    n = 10;\n    f1(1, 2, 1001);  // 1 为 _1 所绑定， 2 为 _2 所绑定，不使用 1001\n    // 进行到 f(2, 42, 1, n, 7) 的调用\n\n    // 嵌套 bind 子表达式共享占位符\n    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);\n    f2(10, 11, 12);  // 进行到 f(12, g(12), 12, 4, 5); 的调用\n\n    // 绑定指向成员函数指针\n    Foo foo;\n    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);\n    f3(5);\n\n    // 绑定指向数据成员指针\n    auto f4 = std::bind(&Foo::data, _1);\n    std::cout << f4(foo) << std::endl;\n\n    // 智能指针亦能用于调用被引用对象的成员\n    std::cout << f4(std::make_shared<Foo>(foo)) << std::endl;\n}\n```\n\n## `lambda`表达式\n\nlambda表达式可以说是c++11引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：\n\n```c++\nauto func = [capture] (params) opt -> ret { func_body; };\n```\n\n其中`func`是可以当作`lambda`表达式的名字，作为一个函数使用，`capture`是捕获列表，`params`是参数表，`opt`是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。\n\n一个完整的lambda表达式：\n\n```c++\nauto func1 = [](int a) -> int { return a + 1; };\nauto func2 = [](int a) { return a + 2; };\ncout << func1(1) << \" \" << func2(2) << endl;\n```\n\n如上代码，很多时候lambda表达式返回值是很明显的，c++11允许省略表达式的返回值定义。\n\n`lambda`表达式允许捕获一定范围内的变量：\n\n- `[]`不捕获任何变量\n- `[&]`引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用\n\n- `[=]`值捕获，捕获外部作用域所有变量，在函数内内有个副本使用\n- `[=, &a]`值捕获外部作用域所有变量，按引用捕获a变量\n\n- `[a]`只值捕获a变量，不捕获其它变量\n- `[this]`捕获当前类中的this指针\n\nlambda表达式示例代码：\n\n```c++\nint a = 0;\nauto f1 = [=](){ return a; }; // 值捕获a\ncout << f1() << endl;\n\nauto f2 = [=]() { return a++; }; // 修改按值捕获的外部变量，error\nauto f3 = [=]() mutable { return a++; };\n```\n\n代码中的f2是编译不过的，因为修改了按值捕获的外部变量，其实lambda表达式就相当于是一个仿函数，仿函数是一个有`operator()`成员函数的类对象，这个`operator()`默认是`const`的，所以不能修改成员变量，而加了`mutable`，就是去掉`const`属性。\n\n还可以使用lambda表达式自定义stl的规则，例如自定义sort排序规则：\n\n```c++\nstruct A {\n    int a;\n    int b;\n};\n\nint main() {\n    vector<A> vec;\n    std::sort(vec.begin(), vec.end(), [](const A &left, const A &right) { return left.a < right.a; });\n}\n```\n\n## 总结\n\n`std::function`和`std::bind`在平时编程过程中封装函数更加的方便，而lambda表达式将这种方便发挥到了极致，可以在需要的时间就地定义匿名函数，不再需要定义类或者函数等，在自定义STL规则时候也非常方便，让代码更简洁，更灵活，提高开发效率。\n\n# C++11新特性之模板改进\n\nC++11关于模板有一些细节的改进：\n\n- 模板的右尖括号\n- 模板的别名\n\n- 函数模板的默认模板参数\n\n### 模板的右尖括号\n\nC++11之前是不允许两个右尖括号出现的，会被认为是右移操作符，所以需要中间加个空格进行分割，避免发生编译错误。\n\n### 模板的别名\n\nC++11引入了using，可以轻松的定义别名，而不是使用繁琐的typedef。\n\n```c++\nint main() {\n    std::vector<std::vector<int>> a; // error\n    std::vector<std::vector<int> > b; // ok\n}\n```\n\n使用using明显简洁并且易读，大家可能之前也见过使用typedef定义函数指针之类的操作。\n\n```c++\ntypedef void (*func)(int, int); \nusing func = void (*)(int, int); // 起码比typedef容易看的懂\n```\n\n上面的代码使用using起码比typedef容易看的懂一些，但是我还是看不懂，因为我从来不用这种来表示函数指针，用std::function()、std::bind()、std::placeholder()、lambda表达式它不香吗。\n\n### 函数模板的默认模板参数\n\nC++11之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，C++11后都支持。\n\n```c++\ntemplate <typename T, typename U=int>\nclass A {\n    T value;  \n};\n\ntemplate <typename T=int, typename U> // error\nclass A {\n    T value;  \n};\n```\n\n类模板的默认模板参数必须从右往左定义，而函数模板则没有这个限制。\n\n```c++\ntemplate <typename R, typename U=int>\nR func1(U val) {\n   return val;\n}\n\ntemplate <typename R=int, typename U>\nR func2(U val) {\n    return val;\n}\n\nint main() {\n    cout << func1<int, double>(99.9) << endl; // 99\n    cout << func1<double, double>(99.9) << endl; // 99.9\n    cout << func1<double>(99.9) << endl; // 99.9\n    cout << func1<int>(99.9) << endl; // 99\n    cout << func2<int, double>(99.9) << endl; // 99\n    cout << func1<double, double>(99.9) << endl; // 99.9\n    cout << func2<double>(99.9) << endl; // 99.9\n    cout << func2<int>(99.9) << endl; // 99\n    return 0;\n}\n```\n\n# C++11新特性之线程相关知识点\n\nc++11关于并发引入了好多新东西，这里按照如下顺序介绍：\n\n- std::thread相关\n- std::mutex相关\n\n- std::lock相关\n- std::atomic相关\n\n- std::call_once相关\n- volatile相关\n\n- std::condition_variable相关\n- std::future相关\n\n- async相关\n\n## std::thread相关\n\nc++11之前可能使用pthread_xxx来创建线程，繁琐且不易读，c++11引入了std::thread来创建线程，支持对线程join或者detach。直接看代码：\n\n```c++\n#include <iostream>\n#include <thread>\n\nusing namespace std;\n\nint main() {\n    auto func = []() {\n        for (int i = 0; i < 10; ++i) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    };\n    std::thread t(func);\n    if (t.joinable()) {\n        t.detach();\n    }\n    auto func1 = [](int k) {\n        for (int i = 0; i < k; ++i) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    };\n    std::thread tt(func1, 20);\n    if (tt.joinable()) { // 检查线程可否被join\n        tt.join();\n    }\n    return 0;\n}\n```\n\n上述代码中，函数func和func1运行在线程对象t和tt中，从刚创建对象开始就会新建一个线程用于执行函数，调用join函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的detach函数，表示将线程和线程对象分离。\n\n如果没有调用join或者detach函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生错误，这里有两种解决办法，一个是调用join()，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用detach()，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那就再也无法控制线程什么时候结束了，不能再通过join来等待线程执行完。\n\n这里可以对thread进行封装，避免没有调用join或者detach可导致程序出错的情况出现：\n\n```c++\nclass ThreadGuard {\n    public:\n    enum class DesAction { join, detach };\n\n    ThreadGuard(std::thread&& t, DesAction a) : t_(std::move(t)), action_(a){};\n\n    ~ThreadGuard() {\n        if (t_.joinable()) {\n            if (action_ == DesAction::join) {\n                t_.join();\n            } else {\n                t_.detach();\n            }\n        }\n    }\n\n    ThreadGuard(ThreadGuard&&) = default;\n    ThreadGuard& operator=(ThreadGuard&&) = default;\n\n    std::thread& get() { return t_; }\n\n    private:\n    std::thread t_;\n    DesAction action_;\n};\n\nint main() {\n    ThreadGuard t(std::thread([]() {\n        for (int i = 0; i < 10; ++i) {\n            std::cout << \"thread guard \" << i << \" \";\n        }\n        std::cout << std::endl;}), ThreadGuard::DesAction::join);\n    return 0;\n}\n```\n\nc++11还提供了获取线程id，或者系统cpu个数，获取thread native_handle，使得线程休眠等功能\n\n```c++\nstd::thread t(func);\ncout << \"当前线程ID \" << t.get_id() << endl;\ncout << \"当前cpu个数 \" << std::thread::hardware_concurrency() << endl;\nauto handle = t.native_handle();// handle可用于pthread相关操作\nstd::this_thread::sleep_for(std::chrono::seconds(1));\n```\n\n## std::mutex相关\n\nstd::mutex是一种线程同步的手段，用于保存多线程同时操作的共享数据。\n\nmutex分为四种：\n\n- std::mutex：独占的互斥量，不能递归使用，不带超时功能\n- std::recursive_mutex：递归互斥量，可重入，不带超时功能\n\n- std::timed_mutex：带超时的互斥量，不能递归\n- std::recursive_timed_mutex：带超时的互斥量，可以递归使用\n\n拿一个std::mutex和std::timed_mutex举例，别的都是类似的使用方式：\n\nstd::mutex:\n\n```c++\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nusing namespace std;\nstd::mutex mutex_;\n\nint main() {\n    auto func1 = [](int k) {\n        mutex_.lock();\n        for (int i = 0; i < k; ++i) {\n            cout << i << \" \";\n        }\n        cout << endl;\n        mutex_.unlock();\n    };\n    std::thread threads[5];\n    for (int i = 0; i < 5; ++i) {\n        threads[i] = std::thread(func1, 200);\n    }\n    for (auto& th : threads) {\n        th.join();\n    }\n    return 0;\n}\n```\n\nstd::timed_mutex:\n\n```c++\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\nstd::timed_mutex timed_mutex_;\n\nint main() {\n    auto func1 = [](int k) {\n        timed_mutex_.try_lock_for(std::chrono::milliseconds(200));\n        for (int i = 0; i < k; ++i) {\n            cout << i << \" \";\n        }\n        cout << endl;\n        timed_mutex_.unlock();\n    };\n    std::thread threads[5];\n    for (int i = 0; i < 5; ++i) {\n        threads[i] = std::thread(func1, 200);\n    }\n    for (auto& th : threads) {\n        th.join();\n    }\n    return 0;\n}\n```\n\n## std::lock相关\n\n这里主要介绍两种RAII方式的锁封装，可以动态的释放锁资源，防止线程由于编码失误导致一直持有锁。\n\nc++11主要有std::lock_guard和std::unique_lock两种方式，使用方式都类似，如下：\n\n```c++\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\nstd::mutex mutex_;\n\nint main() {\n    auto func1 = [](int k) {\n        // std::lock_guard<std::mutex> lock(mutex_);\n        std::unique_lock<std::mutex> lock(mutex_);\n        for (int i = 0; i < k; ++i) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    };\n    std::thread threads[5];\n    for (int i = 0; i < 5; ++i) {\n        threads[i] = std::thread(func1, 200);\n    }\n    for (auto& th : threads) {\n        th.join();\n    }\n    return 0;\n}\n```\n\nstd::lock_gurad相比于std::unique_lock更加轻量级，少了一些成员函数，std::unique_lock类有unlock函数，可以手动释放锁，所以条件变量都配合std::unique_lock使用，而不是std::lock_guard，因为条件变量在wait时需要有手动释放锁的能力，具体关于条件变量后面会讲到。\n\n## std::atomic相关\n\nc++11提供了原子类型std::atomic<T>，理论上这个T可以是任意类型，但是平时只存放整形，别的还真的没用过，整形有这种原子变量已经足够方便，就不需要使用std::mutex来保护该变量啦。看一个计数器的代码：\n\n```c++\nstruct OriginCounter { // 普通的计数器\n    int count;\n    std::mutex mutex_;\n    void add() {\n        std::lock_guard<std::mutex> lock(mutex_);\n        ++count;\n    }\n\n    void sub() {\n        std::lock_guard<std::mutex> lock(mutex_);\n        --count;\n    }\n\n    int get() {\n        std::lock_guard<std::mutex> lock(mutex_);\n        return count;\n    }\n};\n\nstruct NewCounter { // 使用原子变量的计数器\n    std::atomic<int> count;\n    void add() {\n        ++count;\n        // count.store(++count);这种方式也可以\n    }\n\n    void sub() {\n        --count;\n        // count.store(--count);\n    }\n\n    int get() {\n        return count.load();\n    }\n};\n```\n\n是不是使用原子变量更加方便了呢？\n\n## std::call_once相关\n\nc++11提供了std::call_once来保证某一函数在多线程环境中只调用一次，它需要配合std::once_flag使用，直接看使用代码：\n\n```c++\nstd::once_flag onceflag;\n\nvoid CallOnce() {\n    std::call_once(onceflag, []() {\n        cout << \"call once\" << endl;\n    });\n}\n\nint main() {\n    std::thread threads[5];\n    for (int i = 0; i < 5; ++i) {\n        threads[i] = std::thread(CallOnce);\n    }\n    for (auto& th : threads) {\n        th.join();\n    }\n    return 0;\n}\n```\n\n## volatile相关\n\n貌似把volatile放在并发里介绍不太合适，但是貌似很多人都会把volatile和多线程联系在一起，一起介绍下。\n\nvolatile通常用来建立内存屏障，volatile修饰的变量，编译器对访问该变量的代码通常不再进行优化，看下面代码：\n\n```c++\nint *p = xxx;\nint a = *p;\nint b = *p;\n```\n\na和b都等于p指向的值，一般编译器会对此做优化，把*p的值放入寄存器，就是传说中的工作内存(不是主内存)，之后a和b都等于寄存器的值，但是如果中间p地址的值改变，内存上的值改变啦，但a,b还是从寄存器中取的值(不一定，看编译器优化结果)，这就不符合需求，所以在此对p加volatile修饰可以避免进行此类优化。\n\n注意：volatile不能解决多线程安全问题，针对特种内存才需要使用volatile，它和atomic的特点如下：• std::atomic用于多线程访问的数据，且不用互斥量，用于并发编程中• volatile用于读写操作不可以被优化掉的内存，用于特种内存中\n\n## std::condition_variable相关\n\n条件变量是c++11引入的一种同步机制，它可以阻塞一个线程或者个线程，直到有线程通知或者超时才会唤醒正在阻塞的线程，条件变量需要和锁配合使用，这里的锁就是上面介绍的std::unique_lock。\n\n这里使用条件变量实现一个CountDownLatch：\n\n```c++\nclass CountDownLatch {\n    public:\n    explicit CountDownLatch(uint32_t count) : count_(count);\n\n    void CountDown() {\n        std::unique_lock<std::mutex> lock(mutex_);\n        --count_;\n        if (count_ == 0) {\n            cv_.notify_all();\n        }\n    }\n\n    void Await(uint32_t time_ms = 0) {\n        std::unique_lock<std::mutex> lock(mutex_);\n        while (count_ > 0) {\n            if (time_ms > 0) {\n                cv_.wait_for(lock, std::chrono::milliseconds(time_ms));\n            } else {\n                cv_.wait(lock);\n            }\n        }\n    }\n\n    uint32_t GetCount() const {\n        std::unique_lock<std::mutex> lock(mutex_);\n        return count_;\n    }\n\n    private:\n    std::condition_variable cv_;\n    mutable std::mutex mutex_;\n    uint32_t count_ = 0;\n};\n```\n\n关于条件变量其实还涉及到通知丢失和虚假唤醒问题，因为不是本文的主题，这里暂不介绍，大家有需要可以留言。\n\n## std::future相关\n\nc++11关于异步操作提供了future相关的类，主要有std::future、std::promise和std::packaged_task，std::future比std::thread高级些，std::future作为异步结果的传输通道，通过get()可以很方便的获取线程函数的返回值，std::promise用来包装一个值，将数据和future绑定起来，而std::packaged_task则用来包装一个调用对象，将函数和future绑定起来，方便异步调用。而std::future是不可以复制的，如果需要复制放到容器中可以使用std::shared_future。\n\n### std::promise与std::future配合使用\n\n```c++\n#include <functional>\n#include <future>\n#include <iostream>\n#include <thread>\n\nusing namespace std;\n\nvoid func(std::future<int>& fut) {\n    int x = fut.get();\n    cout << \"value: \" << x << endl;\n}\n\nint main() {\n    std::promise<int> prom;\n    std::future<int> fut = prom.get_future();\n    std::thread t(func, std::ref(fut));\n    prom.set_value(144);\n    t.join();\n    return 0;\n}\n```\n\n### std::packaged_task与std::future配合使用\n\n```c++\n#include <functional>\n#include <future>\n#include <iostream>\n#include <thread>\n\nusing namespace std;\n\nint func(int in) {\n    return in + 1;\n}\n\nint main() {\n    std::packaged_task<int(int)> task(func);\n    std::future<int> fut = task.get_future();\n    std::thread(std::move(task), 5).detach();\n    cout << \"result \" << fut.get() << endl;\n    return 0;\n}\n```\n\n### 三者之间的关系\n\nstd::future用于访问异步操作的结果，而std::promise和std::packaged_task在future高一层，它们内部都有一个future，promise包装的是一个值，packaged_task包装的是一个函数，当需要获取线程中的某个值，可以使用std::promise，当需要获取线程函数返回值，可以使用std::packaged_task。\n\n## async相关\n\nasync是比future，packaged_task，promise更高级的东西，它是基于任务的异步操作，通过async可以直接创建异步的任务，返回的结果会保存在future中，不需要像packaged_task和promise那么麻烦，关于线程操作应该优先使用async，看一段使用代码：\n\n```c++\n#include <functional>\n#include <future>\n#include <iostream>\n#include <thread>\n\nusing namespace std;\n\nint func(int in) { return in + 1; }\n\nint main() {\n    auto res = std::async(func, 5);\n    // res.wait();\n    cout << res.get() << endl; // 阻塞直到函数返回\n    return 0;\n}\n```\n\n使用async异步执行函数是不是方便多啦。\n\nasync具体语法如下：\n\n```c++\nasync(std::launch::async | std::launch::deferred, func, args...);\n```\n\n第一个参数是创建策略：\n\n- std::launch::async表示任务执行在另一线程\n- std::launch::deferred表示延迟执行任务，调用get或者wait时才会执行，不会创建线程，惰性执行在当前线程。\n\n如果不明确指定创建策略，以上两个都不是async的默认策略，而是未定义，它是一个基于任务的程序设计，内部有一个调度器(线程池)，会根据实际情况决定采用哪种策略。\n\n若从 std::async 获得的 std::future 未被移动或绑定到引用，则在完整表达式结尾， std::future的析构函数将阻塞直至异步计算完成，实际上相当于同步操作：\n\n```c++\nstd::async(std::launch::async, []{ f(); }); // 临时量的析构函数等待 f()\nstd::async(std::launch::async, []{ g(); }); // f() 完成前不开始\n```\n\n注意：关于async启动策略这里以cppreference为主。\n\n有时候如果想真正执行异步操作可以对async进行封装，强制使用std::launch::async策略来调用async。\n\n```c++\ntemplate <typename F, typename... Args>\ninline auto ReallyAsync(F&& f, Args&&... params) {\n    return std::async(std::launch::async, std::forward<F>(f), std::forward<Args>(params)...);\n}\n```\n\n## 总结\n\n• std::thread使线程的创建变得非常简单，还可以获取线程id等信息。\n• std::mutex通过多种方式保证了线程安全，互斥量可以独占，也可以重入，还可以设置互斥量的超时时间，避免一直阻塞等锁。\n• std::lock通过RAII技术方便了加锁和解锁调用，有std::lock_guard和std::unique_lock。\n• std::atomic提供了原子变量，更方便实现实现保护，不需要使用互斥量\n• std::call_once保证函数在多线程环境下只调用一次，可用于实现单例。\n• volatile常用于读写操作不可以被优化掉的内存中。\n• std::condition_variable提供等待的同步机制，可阻塞一个或多个线程，等待其它线程通知后唤醒。\n• std::future用于异步调用的包装和返回值。\n• async更方便的实现了异步调用，异步调用优先使用async取代创建线程。\n\n# C++11 的异步操作-async\n\nC++11中增加了async，如它的名字一样，这个关键字就是用来创建异步操作的，c++11中有个更常用的异步操作，叫做线程thread，那么thread和async有什么区别呢？以及async的优势是什么？应该怎么使用？\n\n### C++11 使用 std::async创建异步程序\n\nC++11中增加了线程，可以非常方便的创建线程，它的基本用法是这样的：\n\n```c++\nvoid f(int n);\nstd::thread t(f, n + 1);\nt.join();\n```\n\n但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如希望获取线程函数的返回结果的时候，就不能直接通过 `thread.join()`得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join，最后得到结果，这个过程是比较繁琐的。\n\nc++11还提供了异步接口`std::async`，通过这个异步接口可以很方便的获取线程函数的执行结果。`std::async`会自动创建一个线程去调用线程函数，它返回一个`std::future`，这个future中存储了线程函数返回的结果，当需要线程函数的结果时，直接从future中获取，非常方便。\n\n其实std::async提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程），可以以多种方式去创建线程。在介绍`async`具体用法以及为什么要用`std::async`代替线程的创建之前，先看看`std::future`、`std::promise`和 `std::packaged_task`。\n\n### std::future\n\nstd::future是一个非常有用也很有意思的东西，简单说std::future提供了一种访问异步操作结果的机制。从字面意思来理解， 它表示未来，因为一个异步操作是不可能马上就获取操作结果的，只能在未来某个时候获取，但是可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态：\n\n- deferred：异步操作还没开始\n- ready：异步操作已经完成\n\n- timeout：异步操作超时\n\n```c++\n//查询future的状态\nstd::future_status status;\ndo {\n    status = future.wait_for(std::chrono::seconds(1));\n    if (status == std::future_status::deferred) {\n        std::cout << \"deferred\\n\";\n    } else if (status == std::future_status::timeout) {\n        std::cout << \"timeout\\n\";\n    } else if (status == std::future_status::ready) {\n        std::cout << \"ready!\\n\";\n} while (status != std::future_status::ready);\n```\n\n获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果，`wait`只是等待异步操作完成，没有返回值，`wait_for`是超时等待返回结果。\n\n### std::promise\n\nstd::promise为获取线程函数中的某个值提供便利，在线程函数中给外面传进来的promise赋值，当线程函数执行完成之后就可以通过promis获取该值了，值得注意的是取值是间接的通过promise内部提供的future来获取的。它的基本用法：\n\n```c++\nstd::promise<int> pr;\nstd::thread t([](std::promise<int>& p){\n    p.set_value_at_thread_exit(9);\n},std::ref(pr));\nstd::future<int> f = pr.get_future();\nauto r = f.get();\n```\n\n### std::packaged_task\n\nstd::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而`packaged_task`保存的是一 个函数。它的基本用法：\n\n```c++\nstd::packaged_task<int()> task([](){ return 7; });\nstd::thread t1(std::ref(task)); \nstd::future<int> f1 = task.get_future(); \nauto r1 = f1.get();\n```\n\n### std::promise、std::packaged_task和std::future的关系\n\n看了`std::async`相关的几个对象`std::future`、`std::promise`和`std::packaged_task`，其中 `std::promise`和`std::packaged_task`的结果最终都是通过其内部的future返回出来的，看看他们之间的关系到底是怎样的，`std::future`提供了一个访问异步操作结果的机制，它和线程是一个级别的属于低层次的对象，在它之上高一层的是`std::packaged_task`和`std::promise`，他们内部都有future以便访问异步操作结果，`std::packaged_task`包装的是一个异步操作，而`std::promise`包装的是一个值，都是为了方便异步操作的，因为有时需要获取线程中的某个值，这时就用`std::promise`，而有时需要获一个异步操作的返回值，这时就用`std::packaged_task`。\n\n那 `std::promise`和`std::packaged_task`之间又是什么关系呢？说他们没关系也没关系，说他们有关系也有关系，都取决于如何使用他们了，可以将一个异步操作的结果保存到`std::promise`中。\n\n### 为什么要用`std::async`代替线程的创建\n\n`std::async`是为了让开发者的少费点脑子的，它让这三个对象默契的工作。大概的工作过程是这样的：`std::async`先将异步操作用`std::packaged_task`包 装起来，然后将异步操作的结果放到`std::promise`中，这个过程就是创造未来的过程。外面再通过`future.get/wait`来获取这个未来的结果！\n\n现在来看看`std::async`的原型\n\n`async(std::launch::async | std::launch::deferred, f, args...)` 第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：\n\n`std::launch::async`：在调用async就开始创建线程。\n\n`std::launch::deferred`：延迟加载方式创建线程。调用async时不创建线程，直到调用了`future`的`get`或者`wait`时才创建线程。\n\n第二个参数是线程函数，第三个参数是线程函数的参数。\n\n### `std::async`基本用法\n\n```c++\nstd::future<int> f1 = std::async(std::launch::async, []() {\n    return 8;\n    });\ncout << f1.get() << endl; //output: 8\nstd::future<void> f2 = std::async(std::launch::async, []() {\n    cout << 8 << endl;\n    //return 8;\n    });\nf2.wait(); //output: 8\nstd::future<int> future = std::async(std::launch::async, []() {\n    std::this_thread::sleep_for(std::chrono::seconds(3));\n    return 8;\n    });\nstd::cout << \"waiting...\\n\";\n//Test12();\nstd::future_status status;\nSleep(3000);\ndo {\n    status = future.wait_for(std::chrono::seconds(1));\n    if (status == std::future_status::deferred) {\n        std::cout << \"deferred\\n\";\n    }\n    else if (status == std::future_status::timeout) {\n        std::cout << \"timeout\\n\";\n    }\n    else if (status == std::future_status::ready) {\n        std::cout << \"ready!\\n\";\n    }\n} while (status != std::future_status::ready);\nstd::cout << \"result is \" << future.get() << '\\n';\n```\n\n可能的结果：waiting... timeout timeout ready! result is 8\n\n### 总结\n\n`std::async`是更高层次上的异步操作，它的存在可以使开发者不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用`std::async`替代线程的创建，让它成为做异步操作的首选。\n\n# C++11新特性之智能指针\n\nc++11引入了三种智能指针：\n\n- std::shared_ptr\n- std::weak_ptr\n\n- std::unique_ptr\n\n## shared_ptr\n\nshared_ptr使用了引用计数，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。\n\n使用方法如下：\n\n```c++\nstruct ClassWrapper {\n    ClassWrapper() {\n        cout << \"construct\" << endl;\n        data = new int[10];\n    }\n    ~ClassWrapper() {\n        cout << \"deconstruct\" << endl;\n        if (data != nullptr) {\n            delete[] data;\n        }\n    }\n    void Print() {\n        cout << \"print\" << endl;\n    }\n    int* data;\n};\n\nvoid Func(std::shared_ptr<ClassWrapper> ptr) {\n    ptr->Print();\n}\n\nint main() {\n    auto smart_ptr = std::make_shared<ClassWrapper>();\n    auto ptr2 = smart_ptr; // 引用计数+1\n    ptr2->Print();\n    Func(smart_ptr); // 引用计数+1\n    smart_ptr->Print();\n    ClassWrapper *p = smart_ptr.get(); // 可以通过get获取裸指针\n    p->Print();\n    return 0;\n}\n```\n\n智能指针还可以自定义删除器，在引用计数为0的时候自动调用删除器来释放对象的内存，代码如下：\n\n```c++\nstd::shared_ptr<int> ptr(new int, [](int *p){ delete p; });\n```\n\n关于shared_ptr有几点需要注意：\n\n• 不要用一个裸指针初始化多个shared_ptr，会出现double_free导致程序崩溃\n\n• 通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能 会导致重复析构，不能把this指针交给智能指针管理。\n\n```c++\nclass A {\n    shared_ptr<A> GetSelf() {\n        return shared_from_this();\n        // return shared_ptr<A>(this); 错误，会导致double free\n    }  \n};\n```\n\n- 尽量使用make_shared，少用new。\n- 不要delete get()返回来的裸指针。\n\n- 不是new出来的空间要自定义删除器。\n- 要避免循环引用，循环引用导致内存永远不会被释放，造成内存泄漏。\n\n```c++\nusing namespace std;\nstruct A;\nstruct B;\n\nstruct A {\n    std::shared_ptr<B> bptr;\n    ~A() {\n        cout << \"A delete\" << endl;\n    }\n};\n\nstruct B {\n    std::shared_ptr<A> aptr;\n    ~B() {\n        cout << \"B delete\" << endl;\n    }\n};\n\nint main() {\n    auto aaptr = std::make_shared<A>();\n    auto bbptr = std::make_shared<B>();\n    aaptr->bptr = bbptr;\n    bbptr->aptr = aaptr;\n    return 0;\n}\n```\n\n上面代码，产生了循环引用，导致aptr和bptr的引用计数为2，离开作用域后aptr和bptr的引用计数-1，但是永远不会为0，导致指针永远不会析构，产生了内存泄漏，如何解决这种问题呢，答案是使用weak_ptr。\n\n## weak_ptr\n\nweak_ptr是用来监视shared_ptr的生命周期，它不管理shared_ptr内部的指针，它的拷贝的析构都不会影响引用计数，纯粹是作为一个旁观者监视shared_ptr中管理的资源是否存在，可以用来返回this指针和解决循环引用问题。\n\n- 作用1：返回this指针，上面介绍的shared_from_this()其实就是通过weak_ptr返回的this指针。\n- 作用2：解决循环引用问题。\n\n```c++\nstruct A;\nstruct B;\n\nstruct A {\n    std::shared_ptr<B> bptr;\n    ~A() {\n        cout << \"A delete\" << endl;\n    }\n    void Print() {\n        cout << \"A\" << endl;\n    }\n};\n\nstruct B {\n    std::weak_ptr<A> aptr; // 这里改成weak_ptr\n    ~B() {\n        cout << \"B delete\" << endl;\n    }\n    void PrintA() {\n        if (!aptr.expired()) { // 监视shared_ptr的生命周期\n            auto ptr = aptr.lock();\n            ptr->Print();\n        }\n    }\n};\n\nint main() {\n    auto aaptr = std::make_shared<A>();\n    auto bbptr = std::make_shared<B>();\n    aaptr->bptr = bbptr;\n    bbptr->aptr = aaptr;\n    bbptr->PrintA();\n    return 0;\n}\n```\n\n输出：\n\n```c++\nA\nA delete\nB delete\n```\n\n## unique_ptr\n\nstd::unique_ptr是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。使用方法和shared_ptr类似，区别是不可以拷贝：\n\n```c++\nusing namespace std;\n\nstruct A {\n    ~A() {\n        cout << \"A delete\" << endl;\n    }\n    void Print() {\n        cout << \"A\" << endl;\n    }\n};\n\n\nint main() {\n    auto ptr = std::unique_ptr<A>(new A);\n    auto tptr = std::make_unique<A>(); // error, c++11还不行，需要c++14\n    std::unique_ptr<A> tem = ptr; // error, unique_ptr不允许移动\n    ptr->Print();\n    return 0;\n}\n```\n\n"
        },
        {
          "name": "总结归纳：C++17新特性.md",
          "type": "blob",
          "size": 15.9921875,
          "content": "## 关键字\n\n### constexpr\n\n扩展constexpr使用范围，可用于if语句中，也可用于lambda表达式中。\n\n```c++\n#include<iostream>\n \ntemplate<bool ok>\nconstexpr void foo()\n{\n    //在编译期进行判断，if和else语句不生成代码\n    if constexpr (ok == true)\n    {\n        //当ok为true时，下面的else块不生成汇编代码\n        std::cout << \"ok\" << std::endl;\n    }\n    else\n    {\n        //当ok为false时，上面的if块不生成汇编代码\n        std::cout << \"not ok\" << std::endl;\n    }\n}\n \nint main()\n{\n    foo<true>();//输出ok，并且汇编代码中只有std::cout << \"ok\" << std::endl;这一句\n    foo<false>();//输出not ok，并且汇编代码中只有std::cout << \"not ok\" << std::endl;这一句\n    return 0;\n}\n```\n\n### static_assert\n\n扩展static_assert用法，静态断言的显示文本可选。\n\n如：\n\n```c++\nstatic_assert(true, \"\");\nstatic_assert(true);//c++17支持\n```\n\n### typename\n\n扩展用法，允许出现在模板的模板的参数中。\n\n首先回顾一下typename的用法，①用于模板中，表示模板参数为类型；②用于声明某名字是变量名\n\n如\n\n```c++\nstruct A\n{\n    typedef int Example;\n};\n//第一种用法：声明模板参数为类型\ntemplate<typename T>\nstruct B { };\n \nstruct C\n{\n    typedef typename A::Example E;//第二种用法：声明某名字为一种类型\n};\n \nint main()\n{\n    typename A::Example e;//第二种用法：声明某名字为一种类型\n    return 0;\n}\n```\n\n新特性下的typename用法，\n\n如：\n\n```c++\n#include<iostream>\n#include<typeinfo>\n \ntemplate<typename T>\nstruct A\n{\n    int num;\n    A()\n    {\n        std::cout << \"A Construct\" << std::endl;\n        std::cout << \"template typename is: \" << typeid (T).name() << std::endl;\n    }\n};\n//此处的T可省略，X代表模板类型，T和X前的typename可替换成class\ntemplate<template<typename T> typename X>\nstruct B\n{\n    X<double> e;\n    B() { std::cout << \"B Construct\" << std::endl; }\n};\n \nint main()\n{\n    A<B<A>> a;\n    std::cout << \"***************************\" << std::endl;\n    B<A> b;\n    return 0;\n}\n```\n\n### inline\n\nInline 变量, inline变量可以让变量有多于一次的定义。C++17之前，我们定义全局变量， 总需要将变量定义在cpp文件中，然后在通过extern关键字来告诉编译器 这个变量已经在其他地方定义过了。 inline变量出现后，我们可以直接将全局变量定义在头文件中，而不用担心出现redefine的错误信息。\n\n扩展用法，可用于定义内联变量，功能与内联函数相似。inline可避免函数或变量多重定义的问题，如果已定义相同的函数或变量（且该函数或变量声明为inline），编译器会自动链接到该函数或变量。\n\n如（不发生错误）：\n\n```c++\n//  test.h\ninline void print()\n{\n    std::cout << \"hello world\" << std::endl;\n}\n \ninline int num = 0;\n//  func.h\ninclude \"test.h\"\ninline void add(int arg)\n{\n    num += arg;\n    print();\n}\n//  main.cpp\ninclude \"func.h\"\nint main()\n{\n    num = 0;\n    print();\n    add(10);\n    return 0;\n}\n```\n\n### auto\n\n从c++11开始，auto关键字能够通过初始化器推导出变量的类型。在c++14中，auto关键字的能力进一步提升，能够通过return语句推导出函数的返回类型。\n\n使用auto关键字能够提高编码效率，同时能够简化重构流程。但是，C++11中的auto推导，往往结果与预期的不同。\n\nc++11 中为了支持统一初始化，引入了新的统一初始化语法，如下所示。\n\n```c++\n// c++11\nauto x3{ 1, 2 }; // std::initializer_list<int>\nauto x4 = { 3 }; // decltype(x4) is std::initializer_list<int>\nauto x5{ 3 };    // std::initializer_list<int>\n```\n\n这三种方式初始化的变量，最终类型推导的结果都是 std::initializer_list ， 而不是我们认为的int。 这是因为\n\n当用于auto声明变量的表达式是{}括起来的，推导的型别就会变成 std::initializer_list。\n\n在C++17中，对auto表达式推导的规则进行了改变\n\n```c++\n// c++17\nauto x3{ 1, 2 }; // error: not a single element\nauto x4 = { 3 }; // decltype(x4) is std::initializer_list<int>\nauto x5{ 3 };    // decltype(x5) is int\n```\n\n对比发现， auto x5{3}, 会直接将变量推导成 x5， 而 x3{1, 2} 这种方式也会编译失败。auto推导的规则变得更加直观。\n\n## 语法\n\n### lambda表达式\n\nlambda也是c++11中引入的，在C++11中，lambda表达式只能用捕获this，this是当前对象的一个只读的引用。\n\n在C++17中，可以捕获this, this是当前对象的一个拷贝，捕获当前对象的拷贝，能够确保当前对象释放后，\n\nlambda表达式能安全的调用this中的变量和方法。\n\n### 条件表达式中支持初始化语句\n\nc++17中支持在 if 或者switch 语句中进行初始化， 这个能力的出现能够让代码更加的简洁。\n\n```c++\n// c++17之前\nmap<int, string> c = { {1,\"a\"}};\n{\n    auto res = c.insert(make_pair(2, \"b\"));\n    if(!res.second) {\n\t    cout << \"key 1 exist\" << endl;\n    } else {\n\t    cout << \"insert success, value:\" << res.first->second << endl;\n    }\n}\n```\n\n上面的一段代码，由于res是一个临时变量，不想影响到后面的代码，所以用一对花括号限制了其作用域。但是如果使用c++17的语法，\n\n在if条件中初始化res，则代码就会显得更加简洁\n\n```c++\n// c++17\nmap<int, string> c = { {1,\"a\"}};\nif(auto res = c.insert(make_pair(2, \"b\")); !res.second ) {\n\tcout << \"key 1 exist\" << endl;\n} else {\n\tcout << \"insert success, value:\" << res.first->second << endl;\n}\n```\n\n### 折叠表达式\n\n用于变长参数模板的解包，只支持各种运算符（和操作符），分左、右折叠\n\n如：\n```c++\n#include<string>\n \ntemplate<typename ... T>\nauto sum(T ... arg)\n{\n    return (arg + ...);//右折叠\n}\n \ntemplate<typename ... T>\ndouble sum_strong(T ... arg)\n{\n    return (arg + ... + 0);//右折叠\n}\n \ntemplate<typename ... T>\ndouble sub1(T ... arg)\n{\n    return (arg - ...);//右折叠\n}\n \ntemplate<typename ... T>\ndouble sub2(T ... arg)\n{\n    return (... - arg);//左折叠\n}\n \nint main()\n{\n    int s1 = sum(1, 2, 2, 4, 5);//解包：((((1+)2+)3+)4+)5 = 15\n    double s2 = sum(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);\n    double s3 = sum(1, 2.2, 3, 4.4, 5);\n \n    double s4 = sub1(5, 2, 1, 1);//解包：((((5-)2-)1-)1) = 1\n    double s5 = sub2(5, 2, 1, 1);//解包：(5-(2-(1-(1)))) = 3\n \n    double s6 = sum_strong();//s6 = 0\n \n    std::string str1(\"he\");\n    std::string str2(\"ll\");\n    std::string str3(\"o \");\n    std::string str4(\"world\");\n    std::string str5 = sum(str1, str2, str3, str4);//str5 = \"hello world\"\n    return 0;\n}\n```\n\n### 结构化绑定\n\n用一对包含一个或多个变量的中括号，表示结构化绑定，但是使用结构化绑定时，须用auto关键字，即绑定时声明变量\n\n例子：\n\n```c++\n/*\n * 例子：多值返回\n */\nstruct S\n{\n    double num1;\n    long num2;\n};\n \nS foo(int arg1, double arg2)\n{\n    double result1 = arg1 * arg2;\n    long result2 = arg2 / arg1;\n    return {result1, result2};//返回结构体S对象\n};\n \nint main()\n{\n    auto [num1, num2] = foo(10, 20.2);//自动推导num1为double，num2为long\n    return 0;\n}\n```\n\n### 允许非类型模板参数进行常量计算\n\n非类型模板参数可传入类的静态成员\n\n如：\n\n```c++\nclass MyClass\n{\npublic:\n    static int a;\n};\n \ntemplate<int *arg>\nvoid foo() {}\n \nint main()\n{\n    foo<&MyClass::a>();\n    return 0;\n}\n```\n\n### 条件分支语句初始化\n\n在if和switch中可进行初始化\n\n如：\n\n```c++\ntemplate<long value>\nvoid foo(int &ok)\n{\n    if constexpr (ok = 10; value > 0)\n    {\n \n    }\n}\n \nint main()\n{\n    int num = 0;\n    if(int i = 0; i == 0)\n    {\n \n    }\n    foo<10>(num);\n    switch(int k = 10; k)\n    {\n        case 0:break;\n        case 1:break;\n        default:break;\n    }\n    return 0;\n}\n``` \n\n### 聚合初始化\n\n在初始化对象时，可用花括号进行对其成员进行赋值\n\n如：\n\n```c++\nstruct MyStruct1\n{\n    int a;\n    int b;\n};\n \nstruct MyStruct2\n{\n    int a;\n    MyStruct1 ms;\n};\n \nint main()\n{\n    MyStruct1 a{10};\n    MyStruct2 b{10, 20};\n    MyStruct2 c{1, {}};\n    MyStruct2 d{ {}, {}};\n    MyStruct2 e{ {}, {1, 2}};\n    return 0;\n}\n```\n\n### 嵌套命名空间\n\n简化多层命名空间的写法\n\n如：\n\n```c++\n//传统写法\nnamespace A\n{\n    namespace B\n    {\n        namespace C\n        {\n \n        };\n    };\n};\n//新写法\nnamespace A::B::C\n{\n \n};\n```\n\n### lambda表达式捕获*this的值\n\nlambda表达式可捕获*this的值，但this及其成员为只读\n\n如：\n\n```c++\nstruct MyStruct {\n    double ohseven = 100.7;\n    auto f() {\n        return [this] {\n            return [*this] {\n                this->ohseven = 200.2;//错误，只读变量不可赋值\n                return ohseven;//正确\n            };\n        }();\n    }\n    auto g() {\n        return []{\n            return [*this]{};//错误，外层lambda表达式没有捕获this\n        }();\n    }\n};\n```\n\n### 枚举[类]对象的构造\n\n可以给枚举[类]对象赋值\n\n如：\n\n```c++\nenum MyEnum { value };\nMyEnum me {10};//错误：不能用int右值初始化MyEnum类型对象\n \nenum byte : unsigned char { };\nbyte b { 42 }; //正确\nbyte c = { 42 }; //错误：不能用int右值初始化byte类型对象\nbyte d = byte{ 42 }; //正确，其值与b相等\nbyte e { -1 }; //错误：常量表达式-1不能缩小范围为byte类型\n \nstruct A { byte b; };\nA a1 = { { 42 } }; //错误：不能用int右值初始化byte类型对象\nA a2 = { byte{ 42 } }; //正确\n \nvoid f(byte);\nf({ 42 }); //错误：无类型说明符\n \nenum class Handle : unsigned int { value = 0 };\nHandle h { 42 }; //正确\n```\n\n### 十六进制单精度浮点数字面值\n\n以0x前缀开头的十六进制数，以f后缀的单精度浮点数，合并，就有了十六进制的单精度浮点数\n\n如：\n\n```c++\nint main()\n{\n    float value = 0x1111f;\n    return 0;\n}\n```\n\n### 基于对齐内存的动态内存分配\n\n谈到动态内存分配，少不了new和delete运算符，新标准中的new和delete运算符新增了按照对齐内存值来分配、释放内存空间的功能（即一个新的带对齐内存值的new、delete运算符重载）\n\n函数原型：\n\n```c++\nvoid* operator new(std::size_t size, std::align_val_t alignment);\nvoid* operator new[](std::size_t size, std::align_val_t alignment);\nvoid operator delete(void*, std::size_t size, std::align_val_t alignment);\n```\n\n### 细化表达式的计算顺序\n\n为了支持泛型编程和重载运算符的广泛使用，新特性将计算顺序进行的细化\n\n如以下争议代码段：\n\n```c++\n#include<map>\n \nint main()\n{\n    std::map<int, int> tmp;\n    //对于std::map的[]运算符重载函数，在使用[]新增key时，std::map就已经插入了一个新的键值对\n    tmp[0] = tmp.size();//此处不知道插入的是{0, 0}还是{0, 1}\n    return 0;\n}\n```\n\n为了解决该情况，新计算顺序规则为：\n\n1. 后缀表达式从左到右求值。这包括函数调用和成员选择表达式。\n2. 赋值表达式从右向左求值。这包括复合赋值。\n3. 从左到右计算移位操作符的操作数。\n\n### 模板类的模板参数自动推导\n\n定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数\n\n如：\n\n```c++\ntemplate<class T> struct A {\n    explicit A(const T&, ...) noexcept {} // #1\n    A(T&&, ...){} // #2\n};\n \nint i;\n \nA a1 = { i, i }; //错误，不能根据#1推导为右值引用，也不能通过#1实现复制初始化\nA a2{i, i}; //正确，调用#1初始化成功，a2推导为A<int>类型\nA a3{0, i}; //正确，调用#2初始化成功，a2推导为A<int>类型\nA a4 = {0, i}; //正确，调用#2初始化成功，a2推导为A<int>类型\n \ntemplate<class T> A(const T&, const T&) -> A<T&>; // #3\ntemplate<class T> explicit A(T&&, T&&) -> A<T>; // #4\n \nA a5 = {0, 1}; //错误，#1和#2构造函数结果相同（即冲突）。根据#3推导为A<int&>类型\nA a6{0, 1}; //正确，通过#2推断为A<int>类型\nA a7 = {0, i}; //错误，不能将非静态左值引用绑定到右值。根据#3推导为A<int&>类型\nA a8{0, i}; //错误，不能将非静态左值引用绑定到右值。根据#3推导为A<int&>类型\n \ntemplate<class T> \nstruct B {\n \n    template<class U> \n    using TA = T;//定义别名\n \n    template<class U> \n    B(U, TA<U>);//构造函数\n};\n \nB b{(int*)0, (char*)0}; //正确，推导为B<char *>类型\n```\n\n### 简化重复命名空间的属性列表\n\n如：\n\n```c++\n[[ using CC: opt(1), debug ]] void f() {}\n//作用相同于 [[ CC::opt(1), CC::debug ]] void f() {}\n```\n\n### 不支持、非标准的属性\n\n在添加属性列表时，编译器会忽略不支持的非标准的属性，不会发出警告和错误。\n\n### 改写与继承构造函数\n\n在类的继承体系中，构造函数的自动调用是一个令人头疼的问题。新特性引入继承与改写构造函数的用法。\n\n例：\n\n```c++\n#include<iostream>\n \nstruct B1\n{\n    B1(int) { std::cout << \"B1\" << std::endl; }\n};\n \nstruct D1 : B1 {\n    using B1::B1;//表示继承B1的构造函数\n};\n \nD1 d1(0);    //正确，委托基类构造函数进行初始化，调用B1::B1(int)\n```\n\n## 宏\n\n### __has_include\n\n判断有没有包含某文件\n\n如：\n\n```c++\nint main()\n{\n#if __has_include(<cstdio>)\n    printf(\"hehe\");\n#endif\n#if __has_include(\"iostream\")\n    std::cout << \"hehe\" << std::endl;\n#endif\nreturn 0;\n}\n```\n\n## 属性\n\n### fallthrough\n\n用于switch语句块内，表示会执行下一个case或default\n\n如：\n\n```cpp\nint main()\n{\n    int ok1, ok2;\n    switch (0)\n    {\n        case 0:\n        ok1 = 0;\n        [[fallthrough]];\n        case 1:\n        ok2 = 1;\n        [[fallthrough]];\n    }\n    return 0;\n}\n```\n\n### nodiscard\n\n可用于类声明、函数声明、枚举声明中，表示函数的返回值没有被接收，在编译时会出现警告。\n\n如：\n\n```cpp\n[[nodiscard]] class A {}; //该属性在这其实没用\n[[nodiscard]] enum class B {}; //该属性在这其实没用\nclass C {};\n \n[[nodiscard]] int foo()\n{ return 10; }\n \n[[nodiscard]] A func1() { return A(); }\n[[nodiscard]] B func2() { return B(); }\n[[nodiscard]] C func3() { return C(); }\n \nint main()\n{\n    foo();//warning: ignoring return value\n    func1();//warning: ignoring return value\n    func2();//warning: ignoring return value\n    func3();//warning: ignoring return value\n    return 0;\n}\n```\n\n### maybe_unused\n\n可用于类、typedef、变量、非静态数据成员、函数、枚举或枚举值中。用于抑制编译器对没用实体的警告。即加上该属性后，对某一实体不会发出“没有用”的警告。\n\n用法例子：\n\n```cpp\n[[maybe_unused]] class A {};\n[[maybe_unused]] enum B {};\n[[maybe_unused]] int C;\n[[maybe_unused]] void fun();\n```\n\n## 数据类型\n\nc++17的标准库也进行了扩充， 新增了下面几种数据类型：\n\n### std::variant\n\nstd::variant是类型安全的联合体，是一个加强版的 union，variant支持更加复杂的数据类型，例如map，string等等\n\n### std::optional\n\nstd::optional表示一个可能存在的值。 当我们通过函数创建一个对象时，通常使用通过函数返回错误码，而通过出参返回对象本身。\n\n如果通过optional返回创建的实例，就会变得更加直观，\n\nstd::optional 提供了下面几个方法：\n\nhas_value() // 检查对象是否有值 value() // 返回对象的值，值不存在时则抛出 std::bad_optional_access 异常 value_or() // 值存在时返回值，不存在时返回默认值\n\n### std::any\n\n一个类型安全的可以保存任何值的容器\n\n### std::string_view\n\nstring_view我最早使用的是boost版本的，c++17中的string_view 和 boost类似。\n\nstring_view可以理解成原始字符串一个只读引用。 string_view 本身没有申请额外的内存来存储原始字符串的data，\n\n仅仅保存了原始字符串地址和长度等信息。 在很多情况下，我们只是临时处理字符串，本不需要对原始字符串的一份拷贝。\n\n使用string_view可以减少不必要的内存拷贝，可以提高程序性能。相比使用字符串指针，string_view做了更好的封装。\n\n需要注意的是，string_view 由于没有原始字符串的所有权，使用string_view 一定要注意原始字符串的生命周期。\n\n当原始的字符串已经销毁，则不能再调用string_view。\n"
        },
        {
          "name": "每个c++开发人员都应该使用的10个c++ 11特性.md",
          "type": "blob",
          "size": 24.2197265625,
          "content": "> 本文转载自：https://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer\n## 目录\n\n- auto\n- nullptr\n- Range-Based for Loops\n- Override and Final\n- Strongly-typed Enums\n- Smart Pointers\n- Lambdas\n- Non-Member begin() and end()\n- static_assert and Type Traits\n- Move Semantics\n\n## auto\n\nBefore C++11, the `auto` keyword was used for storage duration specification. In the new standard, its purpose was changed towards type inference. `auto` is now a sort of placeholder for a type, telling the compiler it has to deduce the actual type of a variable that is being declared from its initializer. It can be used when declaring variables in different scopes such as namespaces, blocks or initialization statement of `for` loops.\n\n```c++\nauto i = 42;        // i is an int\nauto l = 42LL;      // l is an long long\nauto p = new foo(); // p is a foo*\n```\n\nUsing `auto` usually means less code (unless your type is `int` which is one letter shorter). Think of iterators in STL that you always had to write while iterating over containers. It makes obsolete creating `typedef`s just for the sake of simplicity.\n\n```c++\nstd::map<std::string, std::vector<int>> map;\nfor(auto it = begin(map); it != end(map); ++it) \n{\n}\n```\n\nYou should note that `auto` cannot be used as the return type of a function. However, you can use `auto` in place of the return type of function, but in this case the function must have a trailing return type. In this case, `auto` does not tell the compiler it has to infer the type, it only instructs it to look for the return type at the end of the function. In the example below, the return type of function `compose` is the return type of operator+ that sums values of types `T1` and `T2`.\n\n```c++\ntemplate <typename T1, typename T2>\nauto compose(T1 t1, T2 t2) -> decltype(t1 + t2)\n{\n   return t1+t2;\n}\nauto v = compose(2, 3.14); // v's type is double\n```\n\n## nullptr\n\nZero used to be the value of `null` pointers, and that has drawbacks due to the implicit conversion to integral types. The keyword `nullptr` denotes a value of type `std::nullptr_t` that represents the `null` pointer literal. Implicit conversions exists from `nullptr` to `null` pointer value of any pointer type and any pointer-to-member types, but also to `bool` (as `false`). But no implicit conversion to integral types exist.\n\n```c++\nvoid foo(int* p) {}\n\nvoid bar(std::shared_ptr<int> p) {}\n\nint* p1 = NULL;\nint* p2 = nullptr;   \nif(p1 == p2)\n{\n}\n\nfoo(nullptr);\nbar(nullptr);\n\nbool f = nullptr;\nint i = nullptr; // error: A native nullptr can only be converted to bool or, \n                 // using reinterpret_cast, to an integral type\n```\n\nFor backward compatibility, `0` is still a valid `null` pointer value.\n\n## 基于范围的循环\n\nC++11 augmented the `for` statement to support the \"`foreach`\" paradigm of iterating over collections. In the new form, it is possible to iterate over C-like arrays, initializer lists and anything for which the non-member `begin()` and `end()` functions are overloaded.\n\nThis for each `for` is useful when you just want to get and do something with the elements of a collection/array and don't care about indexes, iterators or number of elements.\n\n```c++\nstd::map<std::string, std::vector<int>> map;\nstd::vector<int> v;\nv.push_back(1);\nv.push_back(2);\nv.push_back(3);\nmap[\"one\"] = v;\n\nfor(const auto& kvp : map) \n{\n  std::cout << kvp.first << std::endl;\n\n  for(auto v : kvp.second)\n  {\n     std::cout << v << std::endl;\n  }\n}\n\nint arr[] = {1,2,3,4,5};\nfor(int& e : arr) \n{\n  e = e*e;\n}\n```\n\n## Override 和 Final\n\nI always found the `virtual` methods badly designed in C++ because there wasn't (and still isn't) a mandatory mechanism to mark `virtual` methods as overridden in derived classes. The `virtual` keyword is optional and that makes reading code a bit harder, because you may have to look through the top of the hierarchy to check if the method is `virtual`. I have always used, and encouraged people to use the `virtual` keyword on derived classes also, to make the code easier to read. However, there are subtle errors that can still arise. Take for instance, the following example:\n\n```c++\nclass B \n{\npublic:\n   virtual void f(short) {std::cout << \"B::f\" << std::endl;}\n};\n\nclass D : public B\n{\npublic:\n   virtual void f(int) {std::cout << \"D::f\" << std::endl;}\n};\n```\n\n`D::f` is supposed to override `B::f`. However, the signatures differ, one takes a `short`, one takes an `int`, therefore `B::f` is just another method with the same name (and overload) and not an override. You may call `f()` through a pointer to `B` and expect to print `D::f`, but it's printing `B::f`.\n\nHere is another subtle error: the parameters are the same, but the method in the base class is marked `const`, while the method in the derived is not.\n\n```c++\nclass B \n{\npublic:\n   virtual void f(int) const {std::cout << \"B::f \" << std::endl;}\n};\n\nclass D : public B\n{\npublic:\n   virtual void f(int) {std::cout << \"D::f\" << std::endl;}\n};\n```\n\nAgain, these two are overloads and not overrides, so if you call `f()` through a pointer to `B`, it will print `B::f` and not `D::f`.\n\nFortunately, there is now a way to describe your intentions. Two new special identifiers (not keywords) have been added: `override`, to indicate that a method is supposed to be an override of a `virtual` method in a base class, and `final`, to indicate that a derived class shall not override a `virtual` method. The first example would become:\n\n```c++\nclass B \n{\npublic:\n   virtual void f(short) {std::cout << \"B::f\" << std::endl;}\n};\n\nclass D : public B\n{\npublic:\n   virtual void f(int) override {std::cout << \"D::f\" << std::endl;}\n};\n```\n\nThis now triggers a compiler error (the same error you'd get for the second example too, if using the `override` specifier):\n\n```c++\n'D::f' : method with override specifier 'override' did not override any base class methods\n```\n\nOn the other hand, if you intend to make a method impossible to override any more (down the hierarchy), mark it as `final`. That can be in the base class, or any derived class. If it's in a derived classe, you can use both the `override` and `final` specifiers.\n\n```c++\nclass B \n{\npublic:\n   virtual void f(int) {std::cout << \"B::f\" << std::endl;}\n};\n\nclass D : public B\n{\npublic:\n   virtual void f(int) override final {std::cout << \"D::f\" << std::endl;}\n};\n\nclass F : public D\n{\npublic:\n   virtual void f(int) override {std::cout << \"F::f\" << std::endl;}\n};\n```\n\n```c++\nfunction declared as 'final' cannot be overridden by 'F::f'\n```\n\n## 强类型枚举\n\n\"Traditional\" `enum`s in C++ have some drawbacks: they export their enumerators in the surrounding scope (which can lead to name collisions, if two different `enum`s in the same have scope define enumerators with the same name), they are implicitly converted to integral types and cannot have a user-specified underlying type.\n\nThese issues have been fixed in C++ 11 with the introduction of a new category of `enum`s, called strongly-typed enums. They are specified with the `enum class` keywords. They no longer export their enumerators in the surrounding scope, are no longer implicitly converted to integral types and can have a user-specified underlying type (a feature also added for traditional `enum`s).\n\n```c++\nenum class Options {None, One, All};\nOptions o = Options::All;\n```\n\n## 智能指针\n\nThere have been tons of articles written on this subject, therefore I just want to mention the smart pointers with reference counting and auto releasing of owned memory that are available:\n\n- [unique_ptr](http://en.cppreference.com/w/cpp/memory/unique_ptr): should be used when ownership of a memory resource does not have to be shared (it doesn't have a copy constructor), but it can be transferred to another `unique_ptr` (move constructor exists).\n- [shared_ptr](http://en.cppreference.com/w/cpp/memory/shared_ptr): should be used when ownership of a memory resource should be shared (hence the name).\n- [weak_ptr](http://en.cppreference.com/w/cpp/memory/weak_ptr): holds a reference to an object managed by a `shared_ptr`, but does not contribute to the reference count; it is used to break dependency cycles (think of a tree where the parent holds an owning reference (`shared_ptr`) to its children, but the children also must hold a reference to the parent; if this second reference was also an owning one, a cycle would be created and no object would ever be released).\n\nOn the other hand, the `auto_ptr` is obsolete and should no longer be used.\n\nWhen you should use `unique_ptr` and when you should use `shared_ptr` depends on the ownership requirements and I recommend reading this [discussion](http://stackoverflow.com/questions/15648844/using-smart-pointers-for-class-members).\n\nThe first example below shows `unique_ptr`. If you want to transfer ownership of an object to another `unique_ptr`, use `std::move` (I'll discuss this function in the last paragraph). After the ownership transfer, the smart pointer that ceded the ownership becomes `null` and `get()` returns `nullptr`.\n\n```c++\nvoid foo(int* p)\n{\n   std::cout << *p << std::endl;\n}\nstd::unique_ptr<int> p1(new int(42));\nstd::unique_ptr<int> p2 = std::move(p1); // transfer ownership\n\nif(p1)\n  foo(p1.get());\n\n(*p2)++;\n\nif(p2)\n  foo(p2.get());\n```\n\nThe second example shows `shared_ptr`. Usage is similar, though the semantics are different since ownership is shared.\n\n```c++\nvoid foo(int* p)\n{\n}\nvoid bar(std::shared_ptr<int> p)\n{\n   ++(*p);\n}\nstd::shared_ptr<int> p1(new int(42));\nstd::shared_ptr<int> p2 = p1;\n   \nbar(p1);   \nfoo(p2.get());\n```\n\nThe first declaration is equivalent to this one.\n\n```c++\nauto p3 = std::make_shared<int>(42);\n```\n\n[make_shared](http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared) is a non-member function and has the advantage of allocating memory for the shared object and the smart pointer with a single allocation, as opposed to the explicit construction of a `shared_ptr` via the contructor, that requires at least two allocations. In addition to possible overhead, there can be situations where memory leaks can occur because of that. In the next example, memory leaks could occur if `seed()` throws an error.\n\n```c++\nvoid foo(std::shared_ptr<int> p, int init)\n{\n   *p = init;\n}\nfoo(std::shared_ptr<int>(new int(42)), seed());\n```\n\nNo such problem exists if using `make_shared`. The third sample shows usage of `weak_ptr`. Notice that you must always get a `shared_ptr` to the referred object by calling `lock()`, in order to access the object.\n\n```c++\nauto p = std::make_shared<int>(42);\nstd::weak_ptr<int> wp = p;\n\n{\n  auto sp = wp.lock();\n  std::cout << *sp << std::endl;\n}\n\np.reset();\n\nif(wp.expired())\n  std::cout << \"expired\" << std::endl;\n```\n\nIf you try to lock on an expired `weak_ptr` (the object is weakly reference has been released), you get an empty `shared_ptr`.\n\n## 匿名函数\n\nAnonymous functions, called lambda, have been added to C++ and quickly rose to prominence. It is a powerful feature borrowed from functional programming, that in turn enabled other features or powered libraries. You can use lambdas wherever a function object or a functor or a `std::function` is expected. You can read about the syntax [here](http://msdn.microsoft.com/en-us/library/dd293603.aspx).\n\n```c++\nstd::vector<int> v;\nv.push_back(1);\nv.push_back(2);\nv.push_back(3);\n\nstd::for_each(std::begin(v), std::end(v), [](int n) {std::cout << n << std::endl;});\n\nauto is_odd = [](int n) {return n%2==1;};\nauto pos = std::find_if(std::begin(v), std::end(v), is_odd);\nif(pos != std::end(v))\n  std::cout << *pos << std::endl;\n```\n\nA bit trickier are recursive lambdas. Imagine a lambda that represents a Fibonacci function. If you attempt to write it using `auto`, you get a compilation error:\n\n```c++\nauto fib = [&fib](int n) {return n < 2 ? 1 : fib(n-1) + fib(n-2);};\n```\n\n```c++\nerror C3533: 'auto &': a parameter cannot have a type that contains 'auto'\nerror C3531: 'fib': a symbol whose type contains 'auto' must have an initializer\nerror C3536: 'fib': cannot be used before it is initialized\nerror C2064: term does not evaluate to a function taking 1 arguments\n```\n\nThe problem is `auto` means the type of the object is inferred from its initializer, yet the initializer contains a reference to it, therefore needs to know its type. This is a cyclic problem. The key is to break this dependency cycle and explicitly specify the function's type using `std::function`.\n\n```c++\nstd::function<int(int)> lfib = [&lfib](int n) {return n < 2 ? 1 : lfib(n-1) + lfib(n-2);};\n```\n\n## 非成员begin()和end()\n\nYou probably noticed that I have used in the samples above non-member `begin()` and `end()` functions. These are a new addition to the standard library, promoting uniformity, consistency and enabling more generic programming. They work with all STL containers, but more than that, they are overloadable, so they can be extended to work with any type. Overloads for C-like arrays are also provided.\n\nLet's take, for instance, the previous example where I was printing a vector and then looking for its first odd element. If the `std::vector` was instead a C-like array, the code might have looked like this:\n\n```c++\nint arr[] = {1,2,3};\nstd::for_each(&arr[0], &arr[0]+sizeof(arr)/sizeof(arr[0]), [](int n) \n             {std::cout << n << std::endl;});\n\nauto is_odd = [](int n) {return n%2==1;};\nauto begin = &arr[0];\nauto end = &arr[0]+sizeof(arr)/sizeof(arr[0]);\nauto pos = std::find_if(begin, end, is_odd);\nif(pos != end)\n  std::cout << *pos << std::endl;\n```\n\nWith non-member `begin()` and `end()`, it could be put as this:\n\n```c++\nint arr[] = {1,2,3};\nstd::for_each(std::begin(arr), std::end(arr), [](int n) {std::cout << n << std::endl;});\n\nauto is_odd = [](int n) {return n%2==1;};\nauto pos = std::find_if(std::begin(arr), std::end(arr), is_odd);\nif(pos != std::end(arr))\n  std::cout << *pos << std::endl;\n```\n\nThis is basically identical code to the `std::vector` version. That means we can write a single generic method for all types supported by `begin()` and `end()`.\n\n```c++\ntemplate <typename Iterator>\nvoid bar(Iterator begin, Iterator end) \n{\n   std::for_each(begin, end, [](int n) {std::cout << n << std::endl;});\n\n   auto is_odd = [](int n) {return n%2==1;};\n   auto pos = std::find_if(begin, end, is_odd);\n   if(pos != end)\n      std::cout << *pos << std::endl;\n}\n\ntemplate <typename C>\nvoid foo(C c)\n{\n   bar(std::begin(c), std::end(c));\n}\n\ntemplate <typename T, size_t N>\nvoid foo(T(&arr)[N])\n{\n   bar(std::begin(arr), std::end(arr));\n}\n\nint arr[] = {1,2,3};\nfoo(arr);\n\nstd::vector<int> v;\nv.push_back(1);\nv.push_back(2);\nv.push_back(3);\nfoo(v);\n```\n\n## static_assert和Type Traits\n\n`static_assert` performs an assertion check at compile-time. If the assertion is `true`, nothing happens. If the assertion is `false`, the compiler displays the specified error message.\n\n```c++\ntemplate <typename T, size_t Size>\nclass Vector\n{\n   static_assert(Size < 3, \"Size is too small\");\n   T _points[Size];\n};\n\nint main()\n{\n   Vector<int, 16> a1;\n   Vector<double, 2> a2;\n   return 0;\n}\n```\n\n\n\n```c++\nerror C2338: Size is too small\nsee reference to class template instantiation 'Vector<T,Size>' being compiled\n   with\n   [\n      T=double,\n      Size=2\n   ]\n```\n\n`static_assert` becomes more useful when used together with type traits. These are a series of classes that provide information about types at compile time. They are available in the [](http://www.cplusplus.com/reference/type_traits/) header. There are several categories of classes in this header: helper classes, for creating compile-time constants, type traits classes, to get type information at compile time, and type transformation classes, for getting new types by applying transformation on existing types.\n\nIn the following example, function `add` is supposed to work only with integral types.\n\n```c++\ntemplate <typename T1, typename T2>\nauto add(T1 t1, T2 t2) -> decltype(t1 + t2)\n{\n   return t1 + t2;\n}\n```\n\nHowever, there are no compiler errors if one writes:\n\n```c++\nstd::cout << add(1, 3.14) << std::endl;\nstd::cout << add(\"one\", 2) << std::endl;\n```\n\nThe program actually prints `4.14` and \"`e`\". But if we add some compile-time asserts, both these lines would generate compiler errors.\n\n```c++\ntemplate <typename T1, typename T2>\nauto add(T1 t1, T2 t2) -> decltype(t1 + t2)\n{\n   static_assert(std::is_integral<T1>::value, \"Type T1 must be integral\");\n   static_assert(std::is_integral<T2>::value, \"Type T2 must be integral\");\n\n   return t1 + t2;\n}\n```\n\n```c++\nerror C2338: Type T2 must be integral\nsee reference to function template instantiation 'T2 add<int,double>(T1,T2)' being compiled\n   with\n   [\n      T2=double,\n      T1=int\n   ]\nerror C2338: Type T1 must be integral\nsee reference to function template instantiation 'T1 add<const char*,int>(T1,T2)' being compiled\n   with\n   [\n      T1=const char *,\n      T2=int\n   ]\n```\n\n## 转移语义\n\nThis is yet another important and well covered topic from C++11, that one could write a series of articles, not just a paragraph. Therefore, I will not get into too many details, but encourage you to find additional readings, if you're not already familiar with the topic.\n\nC++11 has introduced the concept of `rvalue` references (specified with `&&`) to differentiate a reference to an `lvalue` or an `rvalue`. An `lvalue` is an object that has a name, while an `rvalue` is an object that does not have a name (a temporary object). The move semantics allow modifying `rvalue`s (previously considered immutable and indistinguishable from `const T&` types).\n\nA C++ class/struct used to have some implicit member functions: default constructor (only if another constructor is not explicitly defined) and copy constructor, a destructor and a copy assignment operator. The copy constructor and the copy assignment operator perform a bit-wise (or shallow) copy, i.e., copying the variables bitwise. That means if you have a class that contains pointers to some objects, they just copy the value of the pointers and not the objects they point to. This might be OK in some cases, but for many cases, you actually want a deep-copy, meaning that you want to copy the objects pointers refer to, and not the values of the pointers. In this case, you have to explicitly write copy constructor and copy assignment operator to perform a deep-copy.\n\nWhat if the object you initialize or copy from is an rvalue (a temporary). You still have to copy its value, but soon after the rvalue goes away. That means an overhead of operations, including allocations and memory copying that after all, should not be necessary.\n\nEnter the move constructor and move assignment operator. These two special functions take a T&& argument, which is an `rvalue`. Knowing that fact, they can modify the object, such as \"stealing\" the objects their pointers refer to. For instance, a container implementation (such as a vector or a queue) may have a pointer to an array of elements. When an object is instantiating from a temporary, instead of allocating another array, copying the values from the temporary, and then deleting the memory from the temporary when that is destroyed, we just copy the value of the pointer that refers to the allocated array, thus saving an allocation, copying a sequence of elements, and a later de-allocation.\n\nThe following example shows a dummy buffer implementation. The buffer is identified by a name (just for the sake of showing a point revealed below), has a pointer (wrapper in an `std::unique_ptr`) to an array of elements of type `T` and variable that tells the size of the array.\n\n```c++\ntemplate <typename T>\nclass Buffer \n{\n   std::string          _name;\n   size_t               _size;\n   std::unique_ptr<T[]> _buffer;\n\npublic:\n   // default constructor\n   Buffer():\n      _size(16),\n      _buffer(new T[16])\n   {}\n\n   // constructor\n   Buffer(const std::string& name, size_t size):\n      _name(name),\n      _size(size),\n      _buffer(new T[size])\n   {}\n\n   // copy constructor\n   Buffer(const Buffer& copy):\n      _name(copy._name),\n      _size(copy._size),\n      _buffer(new T[copy._size])\n   {\n      T* source = copy._buffer.get();\n      T* dest = _buffer.get();\n      std::copy(source, source + copy._size, dest);\n   }\n\n   // copy assignment operator\n   Buffer& operator=(const Buffer& copy)\n   {\n      if(this != &copy)\n      {\n         _name = copy._name;\n\n         if(_size != copy._size)\n         {\n            _buffer = nullptr;\n            _size = copy._size;\n            _buffer = _size > 0 > new T[_size] : nullptr;\n         }\n\n         T* source = copy._buffer.get();\n         T* dest = _buffer.get();\n         std::copy(source, source + copy._size, dest);\n      }\n\n      return *this;\n   }\n\n   // move constructor\n   Buffer(Buffer&& temp):\n      _name(std::move(temp._name)),\n      _size(temp._size),\n      _buffer(std::move(temp._buffer))\n   {\n      temp._buffer = nullptr;\n      temp._size = 0;\n   }\n\n   // move assignment operator\n   Buffer& operator=(Buffer&& temp)\n   {\n      assert(this != &temp); // assert if this is not a temporary\n\n      _buffer = nullptr;\n      _size = temp._size;\n      _buffer = std::move(temp._buffer);\n\n      _name = std::move(temp._name);\n\n      temp._buffer = nullptr;\n      temp._size = 0;\n      \n      return *this;\n   }\n};\n\ntemplate <typename T>\nBuffer<T> getBuffer(const std::string& name) \n{\n   Buffer<T> b(name, 128);\n   return b;\n}\nint main()\n{\n   Buffer<int> b1;\n   Buffer<int> b2(\"buf2\", 64);\n   Buffer<int> b3 = b2;\n   Buffer<int> b4 = getBuffer<int>(\"buf4\");\n   b1 = getBuffer<int>(\"buf5\");\n   return 0;\n}\n```\n\nThe default copy constructor and copy assignment operator should look familiar. What's new to C++11 is the move constructor and move assignment operator, implemented in the spirit of the aforementioned move semantics. If you run this code, you'll see that when b4 is constructed, the move constructor is called. Also, when `b1` is assigned a value, the move assignment operator is called. The reason is the value returned by `getBuffer()` is a temporary, i.e., an `rvalue`.\n\nYou probably noticed the use of [std::move](http://en.cppreference.com/w/cpp/utility/move) in the move constructor, when initializing the name variable and the pointer to the buffer. The name is actually a `string`, and `std::string` also implements move semantics. Same for the `std::unique_ptr`. However, if we just said `_name(temp._name)` the copy constructor would have been called. For `_buffer`, that would not have been even possible because `std::unique_ptr` does not have a copy constructor. But why wasn't the move constructor for `std::string` called in this case? Because even if the object the move constructor for `Buffer` is called with is an `rvalue`, inside the constructor, it is actually an `lvalue`. Why? Because it has a name, \"`temp`\" and a named object is an `lvalue`. To make it again an `rvalue` (and be able to invoke the appropriate move constructor), one must use `std::move`. This function just turns an `lvalue` reference into an `rvalue` reference.\n\n**UPDATE**: Though the purpose of this example was to show how move constructor and move assignment operator should be implemented, the exact details of an implementation may vary. An alternative implementation was provided by [Member 7805758](http://www.codeproject.com/script/Membership/View.aspx?mid=7805758) in the comments. To be easier to see it, I will show it here:\n\n```c++\ntemplate <typename T>\nclass Buffer\n{\n   std::string          _name;\n   size_t               _size;\n   std::unique_ptr<T[]> _buffer;\n \npublic:\n   // constructor\n   Buffer(const std::string& name = \"\", size_t size = 16):\n      _name(name),\n      _size(size),\n      _buffer(size? new T[size] : nullptr)\n   {}\n \n   // copy constructor\n   Buffer(const Buffer& copy):\n      _name(copy._name),\n      _size(copy._size),\n      _buffer(copy._size? new T[copy._size] : nullptr)\n   {\n      T* source = copy._buffer.get();\n      T* dest = _buffer.get();\n      std::copy(source, source + copy._size, dest);\n   }\n \n   // copy assignment operator\n   Buffer& operator=(Buffer copy)\n   {\n       swap(*this, copy);\n       return *this;\n   }\n \n   // move constructor\n   Buffer(Buffer&& temp):Buffer()\n   {\n      swap(*this, temp);\n   }\n \n   friend void swap(Buffer& first, Buffer& second) noexcept\n   {\n       using std::swap;\n       swap(first._name  , second._name);\n       swap(first._size  , second._size);\n       swap(first._buffer, second._buffer);\n   }\n};\n```\n\n## 总结\n\nThere are many more things to say about C++11; this was just one of many possible beginnings. This article presented a series of core language and standard library features that every C++ developer should use. However, I recommend you additional readings, at least for some of these features.\n"
        },
        {
          "name": "深入理解C++11.md",
          "type": "blob",
          "size": 35.853515625,
          "content": "# 前言\n\n## 说到C++11，应该想到什么？\n\n- 什么是 lambda，及怎么样使用它是最好的？\n- decltype 和 auto 类型推导有什么关系？\n\n- 什么是移动语义，以及(右值引用)是如何解决转发问题的？\n- default/deleted 函数以及 override 是怎么回事?\n\n- 异常描述符被什么替代了? noexcept 是如何工作的?\n- 什么是原子类型以及新的内存模型?\n\n- 如何在 C++11 中做并行编程?\n\n\n\n## 语言的哪些关键字和C++11有关？\n\n- alignas\n- alignof decltype\n\n- auto(重新定义)\n- static_assert\n\n- using(重新定义)\n- noexcept\n\n- export(弃用，不过未来可能留作他用)\n- nullptr\n\n- constexpr\n- thread_local\n\n\n\n# 保证稳定性和兼容性\n\n## 将C99标准纳入C++11\n\n### 确定编译环境的预定义宏\n\n- __STDC_HOSTED__：编译器的目标系统环境中是否包含完整的C库\n- __STDC__：编译器对于标准C库的实现是否和C标准一致（是否定义、如何定义由编译器决定）\n\n-  __STDC_VERSION__：编译器支持的C标准的版本（是否定义、如何定义由编译器决定）\n- __STDC_ISO_10646__：yyyymmL格式的整数常量，表示C++编译环境符合某个版本的ISO/IEC 10646标准\n\n\n\n### __func__ 预定义标识符\n\n函数中可以使用__func__标识符函数名称，编译器会在函数定义开始时隐式地插入__func__标识符定义：\n\nstatic const char* __func__ = \"<函数名称>\";\n\n\n\n### _Pragma 操作符\n\n在之前的C/C++标准中已经规定了可以使用#pragma预处理指令向编译器传递信息，比如可以通过在头文件首行放置#pragma once来告诉编译器这个头文件只应该被include一次。\n\nC++11中，规定了一个新的操作符_Pragma，它的作用与#pragma完全相同，_Pragma(\"once\")就相当于#pragma once。但是，_Pragma由于是一个操作符而不是预处理指令，它的使用更为灵活，可以在宏中展开。\n\n\n\n### 不定参数宏定义以及 __VA_ARGS__\n\nC99规定宏定义中，在参数列表的最后，可以使用...省略参数定义，而__VA_ARGS__可以用来替换被省略号代表的字符串。\n\n\n\n### 宽窄字符串连接\n\n\n\n## long long整形\n\n## 扩展的整形\n\n## 宏__cplusplus\n\n一般会和extern \"C\"配合使用，来让一个头文件即可以同时被include到C和C++中编译，使用extern \"C\"避免C++对符号名称进行重整，确保C++编译器编译出的目标文件中的符号名维持原样。\n\n```c++\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n// 一些代码\n#ifdef __cplusplus \n}\n#endif\n```\n\n\n\n## 静态断言\n\n标准C库assert.h中，提供了assert函数来进行运行时的断言，表明某些情况一定不会发生。（在 C++ 中，程序员也可以定义宏 NDEBUG 来禁用 assert 宏。这对发布程序来说还是必 要的。因为程序用户对程序退出总是敏感的，而且部分的程序错误也未必会导致程序全部功 能失效。那么通过定义 NDEBUG 宏发布程序就可以尽量避免程序退出的状况。而当程序有 问题时，通过没有定义宏 NDEBUG 的版本，程序员则可以比较容易地找到出问题的位置。）\n\n如果希望在预处理时确定某些情况一定不会发生，也可以使用#if进行判断，使用#error终止编译流程并给出错误提示。\n\nC++11引入static_assert来补充编译时断言。之前Boost库也实现了类似的功能，它是利用编译器在编译时会检查除以0这个特性，如果条件为假就构建一个除以0的语句迫使编译器报错来实现的，虽然可以达成编译时检查的目的，但报错信息比较不明确。使用C++11的static_assert，在断言失败时，可以得到明确的错误提示。\n\n\n\n## noexcept修饰符与noexcept操作符\n\n### 作为修饰符\n\nnoexcept作为修饰符可以用来表明函数是否会抛出异常，noexcept修饰符后面可以跟随一个常量表达式，当常量表达式可以转为true时表示不会抛出异常，false则表示会抛出异常。被noexcept修饰符标记为不会抛出异常的函数如果运行时抛出异常，会直接导致程序调用std::terminate终止执行，异常不会继续沿栈传播。\n\n### 作为操作符\n\nnoexcept作为操作符可以用来判断某个表达式是否会抛出异常。该操作符帮助我们在进行泛型编程时通过noexcept操作符判断一个依赖模板参数的表达式是否会抛出异常。\n\n```c++\ntemplate <class T>\nvoid fun() noexcept(noexcept(T())) {}\n```\n\n\n\n### 替代废弃的throw\n\nC++98曾经定义了throw修饰符，用来表明表达式是否会抛出异常，一个空的throw()就和noexcept(true)表达的意思一样，但throw要求明确指出会抛出哪些类型的异常，实际编程中大家很少需要了解异常类型，只希望了解是否会抛出异常，因此新的noexcept(false)用于替代throw(<异常类型>)。\n\n\n\n## 快速初始化成员变量\n\nC++98中，允许直接在类的静态常量整型成员声明时使用“=”对其初始化，这种声明+初始化的做法被叫做“就地”声明。这种声明方式很便捷，但仅能对【静态】【常量】【整型】成员进行这样的声明，使用场景很少，语法也不一致。\n\nC++11中允许对非静态成员进行就地的初始化，不再必须在构造函数中通过initializer-list进行初始化了。可以使用等号或者一对花括号{}进行就地初始化，其他形式无法通过编译。\n\n在成员同时使用就地初始化，并且在构造函数的初始化列表中进行初始化时，最终仅会以初始化列表为准对其进行初始化。\n\n\n\n## 非静态成员的sizeof\n\nC++98中，sizeof可以作用于类的静态成员，但对于非静态成员，必须通过一个类实例来引用，因此之前为了获取一个非静态成员的大小，同时避免创建无用的类实例，通常会使用下面的技巧：\n\nsizeof(((People*)0)->hand);\n\nC++11后，sizeof可以直接作用于类成员表达式了，上面的技巧可以简化成：\n\nsizeof(People::hand)\n\n\n\n## 扩展的friend语法\n\n在C++98，如果要指定另一个类是当前类的友元，必须要使用friend class/struct <友元类>这样的写法，并且无法使用模板参数作为友元类，C++11允许省略class，而且可以使用模板参数作为友元类。\n\nhttps://zh.cppreference.com/w/cpp/language/friend\n\n\n\n## final/override\n\nfinal用于在继承关系的中间终止一个虚函数被子类重载的可能性。override用于显式声明某个函数是父类虚函数的重载，提升了代码可读性和健壮性（因为virtual修饰符只有在顶级父类声明虚函数时才是必须的，子类为同名虚函数添加virtual修饰符会被忽略，而override修饰符会被编=‘译器检查以确保函数的确重载了虚函数）。它们都在函数声明的参数列表之后。\n\n为了尽可能兼容已有程序，C++11没有将final和override规定为关键字，因此可以在代码中使用final，override变量，但最好别这么做。\n\n\n\n## 模板函数的默认模板参数\n\nC++98允许为类模板参数指定默认参数，但却禁止为函数模板参数指定默认参数，语法上不一致，逻辑上不合理。\n\nC++11放宽了这一限制，可以为函数模板指定默认模板参数了。\n\n\n\n## 外部模板\n\nC++中，如果多个源文件都使用了同一个模板，会对该模板进行多次实例化，但最后编译时，编译器会仅保留一份模板实例化产生的代码。在一些比较大的项目中，冗余的模板实例化会明显拖慢编译速度，可以使用“外部模板”技术告诉编译器不需要对模板进行实例化，在某一个源文件中仅进行一次显式实例化。\n\ntemplate void fun<int>(int); // 显示地实例化\n\nextern template void fun<int>(int); // 外部模板的声明\n\n\n\n## 局部和匿名类型作为模板实参\n\nC++98禁止局部或者匿名的类型作为模板参数，这个限制没什么道理，因此C++11放宽了该限制。\n\n\n\n```c++\n// C++98中，只有A或者a可以作为模板参数\nstruct A {int a;} a;\n// 匿名类型\ntypedef struct {int a;} B;\n// 匿名类型变量\nstruct {int a;} b;\n\nvoid test() {\n    // 局部类型\n \tstruct C {int a;} c;\n}\n```\n\n\n\n# 通用为本，专用为末\n\n## 继承构造函数\n\n继承关系中，子类可以自动或得父类的成员和接口，但构造函数无法自动地被子类继承。因为通常子类也有自己的成员，我们要定义子类自己的构造函数，在子类构造函数中去调用父类构造函数以及初始化自己的成员。\n\n但是，如果子类中没有任何成员，或者其成员都用C++11的新特性“快速初始化成员变量”进行了初始化乃至于没有必要再用构造函数初始化了，那这时候我们很可能希望直接将父类的构造函数继承到子类，毕竟这时候只需要初始化父类成员。C++11允许我们使用using <父类名>::<父类名>来将所有父类构造函数引入子类，被using引入的父类构造函数是隐式声明的（也就是说，只有用到的函数才会被生成，以节省生成的代码）。\n\n（书中这一节很多描述都和XCode实验现象对不上，很可能是因为成书时还无实验环境，导致描述有误）\n\n\n\n## 委派构造函数\n\n可以在构造函数的initializer-list中调用另一个构造函数来完成构造，这种将构造委托给另一个构造函数的行为  就叫委派构造函数。\n\n一旦在initializer-list中进行了委派构造，就不能再用正常的initializer-list初始化成员变量了。因此，通常被委派的构造函数会负责初始化类的所有成员变量。\n\n\n\n## 右值引用\n\n可以使用两个引用符号 && 来声明并定义一个右值引用。和左值引用一样，右值引用的声明和定义必须在一块。\n\n在C++98中，已经对右值有了一些描述，C++11对右值进行了更进一步的定义：右值就是将亡值。\n\n**C++98中，可以使用常量左值引用来引用右值**，比如：\n\nconst MyCls &myRef = getTemp();\n\n这样的常量左值引用的确引用了getTemp返回的临时变量，延长了它的声明周期，但由于C++98对于右值的定义是“不可被改变的常量”，因此之前只能使用对const的引用来引用右值。\n\nC++11改变了对右值的定义，因此使用C++11的右值引用方式引用的右值，其内容可以被修改。\n\n\n\n### 移动语意\n\n在C++中，如果自定义类中含有指针，通常需要自定义拷贝构造函数和赋值运算符，在对指针进行赋值时，要为指针开辟新的堆内存，并将原指针内容拷贝过来，不要使用编译器生成的默认函数。因为默认函数在赋值时通通采用浅拷贝，会导致两个对象的指针指向同一地址，几乎一定会导致野指针问题。\n\n但是，有时候我们拷贝或赋值时，比如a = b，其中b如果是一个右值，那么直接将b的指针赋值给a，并且阻止b对象在析构函数被调用时释放指针内存，是更合适的做法。因此如果b是一个右值，这意味着b马上就要被析构了，与其为a的指针开辟一片内存，不如直接利用b的指针现在使用的内存。**这种做法就被称作“移动”b的资源到a，也就是“移动语意”。**\n\nC++11中可以通过声明移动构造函数/赋值函数实现移动语意，这样的函数和普通函数的区别在于它们接受的参数类型是右值引用，因此当这样的函数被调用时，可以确保被引用的值马上就要被销毁，可以直接移动其资源。\n\n移动构造函数应该是不会抛出异常的，因为如果移动到一半被终止了，会导致对象的一部分指针成员变成悬挂指针。标准库提供了move_if_noexcept函数，它会判断对象是否实现了noexcept的移动构造函数，如果实现了才返回右值引用，不然就返回左值引用，避免使用移动语意，退化为使用普通的拷贝。\n\n\n\n### 完美转发\n\n#### 右值引用的问题\n\n有了右值引用，看起来我们可以完美地实现移动语意了，但是，需要留意的是，我们在将右值赋给一个右值引用后，这个右值引用其实会被当成一个左值引用（毕竟移动语意本身就要求对右值引用进行修改）！类似的，右值引用的成员也是一个左值。\n\n因此，在访问右值引用，或者在访问右值引用的成员时，必须将其转换成右值引用，否则就会被当成普通的左值引用。\n\n```c++\n// 像这样的声明赋值没有意义，实际上，a依然会成为一个左值引用\n// A &&a = getTemp();\nA &a = getTemp();\nacceptRValueRef(std::move(a));\t// OK，这里使用move把一个被当作左值引用的右值引用转成右值引用\naccestRValueRef(std::forward<A>(a));\t// OK，forward也能起到转为右值引用的作用\n```\n\n这个现象要求我们在创建移动构造函数时，必须要使用标准库<utility>中提供的std::move对右值引用的每一个成员转为右值引用，来保证移动语意。std::move会将其参数转化为一个右值引用。之所以可以进行这样的转换，是因为我们已经知道了拥有成员的对象是一个右值引用，既然成员对象的拥有者本身马上就要被销毁，那么成员对象也一定马上就会被销毁，此时将成员对象转为左值处理才是正确的。\n\n在将右值引用传入参数为右值引用的函数时，编译器会报错，因为右值引用实际上一旦被赋给引用变量，就会被当成左值引用。要让编译器重新将其重新当成一个右值引用，必须使用std::move，std::forward将其转成右值引用。\n\n\n\n#### 引用折叠\n\n为了在模板编程时，让模板能够同时处理左值和右值引用，C++11引入了引用折叠的规则：\n\n\n\n```c++\nusing MyClsLRef = MyCls&;\nusing MyClsRRef = MyCls&&;\n\n// C++11中被引用折叠规则理解为左值引用\nMyClsLRef&& lRef = getMyCls();\n// 下面两行是一样的，其中第一行在C++11中被引用折叠规则理解为右值引用\nMyClsRRef&& rRef = getMyCls();\nMyClsRRef rRef = getMyCls();\n\n// 利用引用折叠规则，可以在模板编写中将参数声明为左值引用类型，这样的模板函数实际上可以同时接收\n// 左值引用和右值引用\ntemplate <typename T>\nvoid test(T&& t) { ... }\n// 当T是一个右值引用时，T&&&&被折叠成右值引用\n// 当T是一个左值引用时，T&&&被折叠成左值引用\n// 不用考虑T不是一个引用，会有这样的考虑说明对C++不够熟悉，函数参数被声明为引用，传进来的肯定是引用\n```\n\n\n\n除了std::move，标准库还提供了std::forward，它的作用其实和std::move有重叠，都可以用来将变量转换为右值引用的。只不过它被规定应该专门用于“转发”场景，并且在调用时必须指定模板参数，从而可以利用引用折叠规则，将参数的左右值引用保留下来：\n\n```c++\nA getTemp() {\n    return A();\n}\n\n// 转发函数\nvoid forwardToTest(A&& a) {\n    // do something\n//    test(a);  无法通过编译，因为一旦右值引用被赋给变量，这个变量就表现成了左值引用\n    test(std::forward<A&&>(a));\n}\n\n// 转发函数\ntemplate<typename T>\nvoid forwardToTestTemplate(T&& a) {\n//    test(a);\t同样无法通过编译\n    test(std::forward<T>(a));\n}\n\ntemplate<typename T>\nvoid test(T&& a) {\n    \n}\n          \n\nint main() {\n    forwardToTest(getTemp());\n    forwardToTestTemplate(getTemp());\n    A a;\n//    forwardToTest(a); 无法通过编译，因为a不是右值引用\n    forwardToTestTemplate(a);   // 可以通过编译，因为模板方法有引用折叠规则\n}\n```\n\n\n\n### move和forward的区别\n\n- move调用时不需要提供模板参数，它仅被用于将参数强制转为右值引用；\n- forward调用时必须要提供模板参数，通常会提供这样的模板参数：forward<T&&>，这样的好处是T如果被声明为左值，转换后还是左值，T如果被声明为右值，转换后还是右值。\n\n\n\n## explicit 显示转换操作符\n\n默认情况下，C++编译器会在函数调用的参数和函数声明不匹配时，想方设法地将参数转为匹配的类型，让函数调用能够通过，这中间会检查：\n\n- 实参的类型转换运算符，如果有转换为目标类型的转换运算符就调用；\n- 目标类型的构造函数，看是否有接收实参类型的构造函数，如果有就调用；\n\n有时这很方便，但更多场景下这样的行为只会导致语意上的混乱。为了避免编译器的隐式转换，可以使用explicit修饰类型转换运算符或构造函数，这样编译器就不会尝试使用对应函数进行转换。\n\n\n\n## initializer_list 初始化列表\n\n### 如何使用初始化列表\n\nC++98中，仅允许使用initializer-list初始化数组，C++11扩展了initializer-list的概念，使得普通类型也可以使用initializer-list初始化（不要把它和类的成员初始化搞混，它们的确都叫initializer-list，要区分时，可以将类的成员初始化叫做member initializer list）：\n\n\n\n```c++\nint a[]={1,3,5};//C++98通过，C++11通过\nint b[]{2,4,6};//C++98失败，C++11通过\nvector<int> c{1,3,5};//C++98失败，C++11通过\nmap<int,float> d = {{1,1.0f},{2,2.0f},{5,3.2f}};//C++98失败，C++11通过\n```\n\n\n\n如果要让自定义的类支持这种初始化方式，只要声明一个接收在<initializer_list>中定义的initializer_list类型的构造函数就可以了。该类型是一个Iterable类型，可以使用begin, end等标准遍历方法。\n\n\n\n### 防止类型收窄\n\n使用初始化列表还可以促使编译器检查类型收窄的情况。初始化列表是目前唯一一种检查类型收窄的方式（不过事实上现在的大多数编译器在没有使用初始化列表时也会检查类型收窄并给出警告，但使用初始化列表编译器会直接给出错误）。\n\n\n\n## POD类型\n\nPOD，也就是Plain Ordinary Data，纯数据类型。\n\nC++11对POD的定义是：平凡的，且是标准布局的。定义上，比C++98更宽容了，C++98只规定了C风格的struct是POD，但从POD的定义上，只要类对象布局是标准的，这样的类应该都是POD类。\n\n（但是，对POD定义得更宽容似乎并没有什么意义？C++11更多的是对于哪些情况会导致对象布局变化进行了更进一步的明确，只有不导致对象布局变化的类定义才是POD类。）\n\n\n\n## union 非受限联合体\n\nC++11将C++98对union的一些限制移除了。\n\n- 在C++98，union中只能包含基础类型和POD类型，并且不能包含静态方法，但在C++11中，union中可以包含任意非引用类型。\n- C++11中，如果union任何一个成员拥有非平凡的构造函数，那么编译器就不会为union生成默认构造函数。\n\n- C++11中，允许在类定义使用union声明成员变量，用这种方式声明的union不需要有类型名称，被称为匿名的非受限联合体，此时联合体内的所有成员都会自动的成为类的“变长成员”，即实际上它们共享同一处内存，应该只使用它们中的某一个。\n\n\n\n## 用户定义字面量\n\n### 字面量操作符\n\n- 接收字符串：<用户类型> operator \"\" _<后缀字符>(const char* col, size_t size)\n- 接收整数：<用户类型> operator \"\" _<后缀字符>(unsigned long long val)\n\n- 接收整数，但整数越界，此时会传入'\\0'结尾的char*：<用户类型> operator \"\" _<后缀字符>(const char*)\n- 接收浮点：<用户类型> operator \"\" _<后缀字符>(long double val)\n\n- 接收字符：<用户类型> operator \"\" _<后缀字符>(char val)\n\n\n\n## 内联名字空间\n\nC++11规定可以在namespace前加上inline，将名字空间默认导出到声明名字空间的作用域。\n\n这样的行为和C++98就有的匿名名字空间非常类似，除了内联名字空间有自己的名字以外。不过，它们被创建出来的目的是不同的：\n\n- 匿名名字空间在C++98中用于替代static修饰符，因为C++为类引入了static成员后，static的语意变得非常模糊且矛盾，因此在原本使用static声明文件作用域的变量的地方，可以改成使用匿名名字空间来包围这些变量起到同样的效果；\n- 内联名字空间则是被标准库用于和宏配合使用，根据当前编译环境决定默认导出同一个功能的哪一个版本的实现，这样做的好处是不关心具体实现的用户可以直接使用默认导出的功能，而了解更全面的细节的用户也可以使用名字空间来指定使用的是哪一个版本的功能。\n\n\n\n## 使用using声明模板别名\n\n在C++11中，已经可以使用using完全替代typedef了。\n\nusing不仅有更清晰的语意，还可以部分声明模板参数：\n\n\n\n```c++\ntemplate <typename T> using StringObjectMap = std::map<string, T>;\nStringObjectMap<MyCls> myMap;\n```\n\n\n\n## SFINAE规则\n\nSFINAE，就是Substitution Failure Is Not An Error。\n\n指的是，编译器在尝试模板参数匹配时，只要能够最终找到合适的匹配，中间尝试过的任何匹配失败都不会报错。\n\n只不过，C++98对于模板参数中使用表达式的情况支持的不友好，C++11明确了任何在编译期合法的表达式都能够作为模板参数，比如下面的这个例子就在C++98中无法通过编译，而在C++11中可以：\n\n\n\n```c++\ntemplate<int I> struct A{};char xxx(int);char xxx(float);template <class T> A<sizeof(xxx((T)0))> f(T){}\n```\n\n\n\n# 新手易学，老兵易用\n\n## 右尖括号的改进\n\nC++98曾经规定应该把 >> 优先判定为右移操作符，但这个规定在C++11被取消了，C++11规定编译器可以自行智能地判断>>是否是右移操作符。\n\n\n\n## auto类型推导\n\n在C++98中，auto其实是用于声明一个变量具有“自动存储期”，但实际上除了static以外的变量都是默认具有自动存储期的，因此过去的auto几乎没有人使用。\n\nC++11中，auto被赋予了新的含义，以前的auto含义被取消了。auto成为了新的类型指示符，auto声明的变量的类型必须在编译期由编译器推导出来。\n\n\n\n## decltype\n\ndecltype是在编译时对表达式进行类型推导，推导出的类型可用于定义新的变量。decltype主要是为了解决泛型编程中由于泛型参数类型不确定，导致和泛型参数相关的表达式类型无法确定的问题的。比如：\n\nt1是泛型Type1类型，t2是泛型Type2类型，由于开发泛型代码时无法确定Type1和Type2的类型，自然无法确定t1 + t2的类型，但该类型其实是可以由编译器推导出来的，decltype如今即可用在此处：\n\nauto add(t1, t2) -> decltype(t1 + t2) {return t1 + t2;}\n\n或者可以声明原本无法声明的变量：decltype(t1 + t2) addResult = t1 + t2;（当然，auto也可以完成此工作）。\n\n\n\n有时会将decltype和auto搭配使用：decltype(auto)。这是因为一方面，我们希望依赖C++11的类型推导能力（auto的作用），但另一方面，又想保留cv限定符和引用（decltype的作用）（auto的类型推导规则和模板类似，如果不把auto声明为auto&或者auto*，auto就会被视为不具备cv限定符的值类型，如果auto被声明为auto&或者auto*，auto推导出的类型才会保留cv限定符）。但是使用这样的写法时要小心：decltype在推导类型时，如果表达式是一个简单的名字，它会推导出名字的类型，但如果表达式不只是一个名字，比如decltype((x))，那么即使x只是一个int，该decltype也会推导出引用类型：int&。\n\n\n\n## 追踪返回类型\n\nauto func(char* a,int b) -> int;\n\n\n\n## 基于范围的for循环\n\n自定义集合类型要想支持这样的for循环，需要实现begin, end, ++, ==四个函数。\n\n\n\n# 提高类型安全\n\n## 强类型枚举\n\nC++98: enum X {...};\n\nC++11: enum class X {...};\n\n\n\n## 堆内存管理：智能指针与垃圾回收\n\n\n\n# 提高性能及操作硬件的能力\n\n## 常量表达式\n\nC++11规定使用constexpr修饰符来修饰常量表达式。常量表达式可以是函数或者值。常量表达式函数中不可以出现非常量表达式。常量表达式可以在编译期使用，但如果常量表达式并没有一定要在编译期被计算出来，标准规定编译器在这种情况下可以将常量表达式编译成普通的表达式，表达式会在运行时被计算。\n\n\n\n## 变长模板\n\n过去，C++可以使用C风格的方法来实现可变参函数，但这种实现方式是类型不安全的。\n\n现在，C++11为可变参函数提出了更合理（类型安全）的解决方案：变长模板。可以使用变长模板来声明变长模板函数或者变长模板类。\n\n\n\n### 模板参数包与递归\n\n使用template <typename... Elements>这种方式可以声明一个变长模板参数，使用Elements...这种方式可以将变长模板参数展开成实际的多个参数类型；\n\n不定长的变长模板类可以通过模板类的递归来解包：\n\n\n\n```c++\ntemplate <typename... Elements> class tuple;\t// 变长模板声明\n// 以下是两个模板偏特化定义，利用模板偏特化会被优先匹配的规则，让变长模板参数递归地被解包\n// 对于类型，可以使用递归的继承\ntemplate <typename Head, typename... Tail> \nclass tuple <Head, Tail...> : private tuple<Tail...> {\n\tHead head;\n}\ntemplate <> class tuple {};\n\n// 对于函数，可以使用递归的函数调用\n// 下面实现一个更强大的Printf，不论%后面跟的是什么符号，这个Printf总是会打印正确的类型\nvoid Printf(const char* s) {\n    while (*s) {\n        if (*s == '%' && ++s != '%') {\n         \t   throw runtime_error(\"invalide format\");\n        }\n        cout *s++;\n    }\n}\n\ntemplate <typename T, typename... Args>\nvoid Printf(char* s, T value, Args... args) {\n\twhile(*s) {\n    \tif (*s == '%' && *s++ != '%') {\n        \tcout << value;\n            return Printf(++s, args...);\n        }\n        cout << *s++;\n    }\n    // 若百分号的数量和参数数量对不上，就抛异常\n    throw runtime_error(\"extra arguments provided\");\n}\n```\n\n\n\n### 进阶\n\n#### 引用类型\n\n定义了模板参数包后，还可以在展开模板参数包时使用引用标记：Args&&...，这样的写法是合法的；\n\n#### 特殊展开\n\n解包时，有些非常特殊的规则，需要特别说明一下：\n\n\n\n```c++\ntemplate <typename... Args> class MyCls: private A<Args>... {};\n// 上面的表达式在解包时会解包成多继承：\nT<Parent1, Parent2>  t;\t// t的类型是：class MyCls: private A<Parent1>, A<Parent2>\n\ntemplate <typename Args...> class MyCls: private A<Args...> {};\n// 而这个表达式在解包时，会在泛型参数表达式中直接展开\nT<Parent1, Parent2>  t;\t// t的类型是：class MyCls: private A<Parent1, Parent2>\n\ntemplate <typename Args...> void test(Args... args) {\n    // 下面这个会被展开成call(a(arg1), a(arg2), ...)\n\tcall(a(args)...);\n    // 而下面这个会被展开成call(a(arg1, arg2, ...))\n    call(a(args...));\n}\n```\n\n#### 获取变长参数包长度\n\n可以使用sizeof...获取模板参数包的长度；\n\n\n\n#### 模板的模板（的模板的模板...）\n\n变长参数的模板类型本身也可以是一个模板，这一点和以前的非变长模板参数一样。\n\n\n\n\n\n## 原子类型和原子操作\n\nC++11以前，已经有很多使用多线程能力的C++程序了，但之前语言本身并没有定义任何同多线程有关的内容，这些多线程能力来自于多线程接口pthread。pthread是一套C的接口。\n\n通常情况下，如果我们不需要太精细的互斥控制，可以直接使用posix提供的mutex互斥锁API，而如果想达到更优化的性能，可能会考虑为不同处理器编写内敛汇编代码。\n\nC++11标准为多线程程序在标准库中添加了原子类型，并允许指定原子类型的内存访问顺序一致性，让开发者可以不必操心操作系统和处理器的底层细节，也可以获得最优化的性能。\n\n\n\n## 线程局部存储\n\nC++11定义了thread_local关键字来定义线程局部存储变量，这样的变量生命期是线程启动到线程结束，除了本线程外，没有其他线程可以访问到这样的变量。\n\nC++11仅规定了线程局部存储的行为，而没有规定其具体实现，不同的编译器在不同的环境中可能会有不同的实现方式。\n\n\n\n## 快速退出：quick_exit, at_quick_exit\n\n在过去，大体上有三种退出程序的方式：terminate(), abort(), exit()。\n\n- terminate是有未处理的异常时会被调用的方法，可以使用set_terminate方法更改默认行为，terminate默认调用abort；\n- abort是进程不得不终止时，被调用的函数，它会向本进程发送一个SIGABRT信号，该信号默认会导致操作系统直接释放该进程的所有资源并终止进程；\n\n- exit是进程自发调用的退出函数，它代表着进程运行到了某个节点，该退出了，它会导致每一个自动变量的析构函数被调用（是的，仅自动变量，也就是栈变量会被调用析构函数，至于单例什么的需要自己处理），并调用at_exit注册的函数，然后才会回收进程；\n\nC++11新增了quick_exit标准方法，该方法语意上和exit一样，都是程序自发终止，但和exit不同的是，它不会进行本进程的清理工作，在多线程环境下也不会先等待线程结束，而是直接让操作系统终止进程并回收资源。\n\n\n\n# 为改变思想方式而改变\n\n## 指针空值-nullptr\n\nC++11定义了nullptr_t和nullptr，前者是类型，后者是该类型的值。\n\nnullptr可以隐式转换为任何指针，但无法被隐式转换为bool类型，无法使用if (nullptr)这样的表达式；此外它所属的nullptr_t是一个基础类型，nullptr无法被推导为T*这样的模板参数。\n\n\n\n## 默认函数的控制\n\nC++11规定可以使用 = default 来使编译器生成默认版本的成员函数，可以由编译器生成的函数包括：\n\n- 空构造函数\n- 拷贝构造函数\n\n- 拷贝赋值函数\n- 移动构造函数\n\n- 移动拷贝函数\n- 析构函数\n\n此外，编译器还为所有自定义类型提供以下全局默认操作符函数：\n\n- operator, \n- operator&\n\n- operator&&\n- operator*\n\n- operator->\n- operator->*\n\n- operator new\n- operator delete\n\n\n\n## lambda函数\n\nlambda语法：\n\n[<捕获外部变量>]<(可选)mutable>(<(可选)参数列表>) -> <(可选)返回值> {<函数体>}\n\n- 捕获外部变量：变量需要用&或者=开头来引用，直接写&或者=后面不跟变量表示捕获所有外部变量，=表示按值捕获，&表示引用捕获；\n- mutable：labmda默认是内联的const函数，不可以修改任何捕获的外部的按值捕获的变量（因为目前lambda的语意其实和仿函数完全一致，在仿函数中，所有捕获的外部变量都是仿函数类的成员，因此const函数不可以修改类成员，到lambda这里变成了lambda不可以修改捕获变量），但是引用捕获的变量则可以修改（这个行为也是和仿函数一致的，const函数内可以调用任意成员引用的方法，修改其属性，因为将引用声明成const，和将指针声明成const类似，都仅仅是禁止修改引用本身，但并没有限制对引用或者指针指向的变量进行修改）。如果希望lambda不是一个const函数，就要添加mutable声明；\n\n- 参数列表：\n- 返回值：当能够从函数体中推测出明确的返回值类型时，可以忽略；\n\n- 函数体：\n\n\n\n# 融入实际应用\n\n## 对齐支持\n\nC和C++都是具备直接操作底层硬件能力的语言，因此某些开发者会对数据结构的对齐方式特别关注。\n\nC++11规定了alignof和alignas关键字，前者可以查询某个类型的对齐方式（一般来说都是32位-4字节或者64位-8字节对齐），而后者可以规定某个自定义类的对齐方式。比如如果我们想要使用内联汇编的向量指令（可以同时处理4组处理器位数的数据）来优化处理速度，就可能想要将数据对齐到4*处理器位数的位置处。\n\n需要注意的是，之前很多编译器也规定了指定数据对齐方式的方式，比如GNU就规定可以使用如下方式规定对齐字节：__attribute__((__aligned__(8)))；\n\n需要注意的是，虽然标准规定了指定对齐的方式，但每个平台具体支持对齐到多少是不确定的。如果使用alignas(2^64)，那显然是不合法的。不幸的是，目前标准似乎没办法查询每个平台支持的最大对齐字节。不过一般来说我们也用不到太大的对齐字节。\n\n\n\n## 通用属性\n\n有时C/C++提供的语言能力无法完全满足开发者的需求，编译器厂商为了解决这些问题，提供了一系列的语言扩展来扩展C/C++的语法。这其中最常见的就是“属性”，可以告诉编译器一个符号的额外信息，让编译器做一些语言规范之外的处理。\n\n- GNU使用__attribute__((<属性列表>))来声明属性；\n- Windows使用__declspec(<属性列表>)来声明属性\n\nC++11也规定了类似的属性，之所以在语言中添加属性，是为了避免再给C++增加更多的关键字。C++11的属性和之前各个平台的编译器实现的属性的目的是一致的，它们提供的能力都是一般用不到，可以忽略的能力，语言规范不会考虑使用关键字来实现这些能力，因此将它们定义到通用属性里。C++规定通用属性的写法是：[[<属性列表>]]，这样的通用属性可以用来修饰任何语言元素。不过目前C++11只定义了两个通用属性：[[noreturn]]和[[carries_dependency]]。\n\n\n\n## Unicode支持\n\n### 字符集和编码\n\nASCII码是最早的编码，使用7位二进制位来表示所有英文字母和在英文排版印刷中用到的字符，后来ISO和Unicode组织共同制定了一套能够唯一的表示世界上所有字符的标准字符集，称为ISO/Unicode字符集或者Unicode字符集。Unicode规定了每个字符在整个字符集中的具体值（范围0x0-0x10FFFFF），但并没有规定计算机中如何存储这样的值，UTF-8 UTF-16 UTF-32是Unicode字符集事实上的编码标准。\n\nUTF-8使用1～6字节的变长编码方式来编码Unicode，由于UTF-8较为节约存储空间，因此使用的比较广泛。\n\n![img](https://cdn.nlark.com/yuque/0/2019/png/244132/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png)\n\nGB2312早于Unicode被定义，是和Unicode不同的一种编码（不过Unicode汉字部分编码其实就是GB2312的变种），采用2字节表示一个中文字符，和Unicode不一样的是，GB2312既是字符集，又是字符编码。\n\n### C++中的Unicode支持\n\nC++98已经规定了wchar_t类型，但是C++98对wchar_t的定义不够明确，不同的编译器中wchar_t的位数不一致，导致移植性问题。\n\nC++11重新规定了char16_t char32_t，用于存储UTF-16 UTF-32编码的Unicode数据，UTF-8的数据则直接使用char来存储。C++中可以在字符串常量前加前缀来让编译器产生不同编码的数据：\n\n- u8 - UTF8\n- u - UTF-16\n\n- U - UTF-32\n- L - wchar_t\n\n之所以没有为UTF-8规定类型，是因为UTF-16和UTF-32都是定长编码，而UTF-8是变长编码（有误，过去某段时间Unicode还比较少，当时UTF16编码Unicode的确是事实上的定长编码，但现在Unicode字符集已经收录了更多字符，早已超出了UTF-16的表示范围，UTF-16已经成为了事实上的变长编码，一些历史程序如果还假定UTF-16是定长编码的话，遇到超出UTF-16表示范围的字符时就会出问题。），变长编码会导致很多算法变得极其复杂（比如无法确定一个utf_8[]中的第N个字符究竟被存储在数组中的哪个位置）。对于语言来说，定长编码处理起来更自然，且增加的内存占用和减少的程序设计复杂度也大体可以认为相互抵消，可以使用定长编码进行处理，需要保存时再存成变长编码以节省存储空间。\n\nC++中，影响Unicode字符能够正确保存和输出的因素有以下三点：\n\n- 文件编码\n- 编译器编码设置\n\n- 输出设备\n\n为了确保得到正确的输出，需要确保源文件的编码同系统编码一致、并且用于输出的设备支持被输出的编码（比如不少shell就只支持UTF-8编码，非UTF-8编码的会直接输出十六进制的编码值）。\n\n### 标准库支持\n\nC++11新增了几个字符类型，也同步地在标准库中新增了字符类型的转换函数。\n"
        }
      ]
    }
  ]
}