{
  "metadata": {
    "timestamp": 1736566134199,
    "page": 139,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tzapu/WiFiManager",
      "stars": 6700,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.154296875,
          "content": ".pio\n.cache\n.pioenvs\n.piolibdeps\n.idea\n.vscode\n!.vscode/extensions.json\n/platformio_override.ini\n/build_output\n.DS_Store\n.gitignore\n.clang-format\nnode_modules"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.5908203125,
          "content": "language: c\nsudo: false\n\nbefore_install:\n  - \"/sbin/start-stop-daemon --start --quiet --pidfile /tmp/custom_xvfb_1.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :1 -ac -screen 0 1280x1024x16\"\n  - sleep 3\n  - export DISPLAY=:1.0\n  - wget http://downloads.arduino.cc/arduino-1.8.10-linux64.tar.xz\n  - tar xf arduino-1.8.10-linux64.tar.xz\n  - sudo mv arduino-1.8.10 /usr/local/share/arduino\n  - sudo ln -s /usr/local/share/arduino/arduino /usr/local/bin/arduino\n\ninstall:\n  - ln -s $PWD /usr/local/share/arduino/libraries/WiFiManager\n  - arduino --pref \"boardsmanager.additional.urls=http://arduino.esp8266.com/stable/package_esp8266com_index.json,http://dl.espressif.com/dl/package_esp32_index.json\" --save-prefs\n  - arduino --install-library \"ArduinoJson:6.18.0\"\n  - arduino --install-boards esp8266:esp8266\n  - arduino --pref \"compiler.warning_level=all\" --save-prefs\n# install esp32\n  - arduino --install-boards esp32:esp32\n\nscript:\n  - \"echo $PWD\"\n  - \"echo $HOME\"\n  - \"ls $PWD\"\n  - source $TRAVIS_BUILD_DIR/travis/common.sh\n  - arduino --board esp8266:esp8266:generic:xtal=80,eesz=4M1M,FlashMode=qio,FlashFreq=80,dbg=Serial,lvl=CORE --save-prefs\n  - build_examples\n  - arduino --board esp32:esp32:esp32:FlashFreq=80,FlashSize=4M,DebugLevel=info --save-prefs\n# some examples fail (SPIFFS defines differ esp32 vs esp8266) so we exclude them\n  - build_examples\n#  - arduino -v --verbose-build --verify $PWD/examples/AutoConnect/AutoConnect.ino\n\n# no coverage generated, no need to run\n#\n#after_success:\n#  - bash <(curl -s https://codecov.io/bash)\n\nnotifications:\n  email:\n    on_success: change\n    on_failure: change\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.2109375,
          "content": "cmake_minimum_required(VERSION 3.5)\n\nidf_component_register(\n                       SRCS \"WiFiManager.cpp\"\n                       INCLUDE_DIRS \".\"\n                       PRIV_REQUIRES arduino\n)\n\nproject(WiFiManager)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 tzapu\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.396484375,
          "content": "\n# WiFiManager\n\nEspressif ESPx WiFi Connection manager with fallback web configuration portal\n\n:warning: This Documentation is out of date, see notes below\n\n<a name=\"release\"></a>\n[![Release](https://img.shields.io/github/v/release/tzapu/WiFiManager?include_prereleases)](#release)\n\n[![Build CI Status](https://github.com/tzapu/WiFiManager/actions/workflows/compile_library.yml/badge.svg)](https://github.com/tzapu/WiFiManager/actions/workflows/compile_library.yml)\n\n[![Build CI Status Examples](https://github.com/tzapu/WiFiManager/actions/workflows/compile_examples.yaml/badge.svg)](https://github.com/tzapu/WiFiManager/actions/workflows/compile_examples.yaml)\n\n[![arduino-library-badge](https://www.ardu-badge.com/badge/WiFiManager.svg?)](https://www.ardu-badge.com/WiFiManager)\n\n[![Build with PlatformIO](https://img.shields.io/badge/PlatformIO-Library-orange?)](https://platformio.org/lib/show/567/WiFiManager/installation)\n\n[![ESP8266](https://img.shields.io/badge/ESP-8266-000000.svg?longCache=true&style=flat&colorA=CC101F)](https://www.espressif.com/en/products/socs/esp8266)\n\n[![ESP32](https://img.shields.io/badge/ESP-32-000000.svg?longCache=true&style=flat&colorA=CC101F)](https://www.espressif.com/en/products/socs/esp32)\n[![ESP32](https://img.shields.io/badge/ESP-32S2-000000.svg?longCache=true&style=flat&colorA=CC101F)](https://www.espressif.com/en/products/socs/esp32-s2)\n[![ESP32](https://img.shields.io/badge/ESP-32C3-000000.svg?longCache=true&style=flat&colorA=CC101F)](https://www.espressif.com/en/products/socs/esp32-c3)\n[![ESP32](https://img.shields.io/badge/ESP-32S3-000000.svg?longCache=true&style=flat&colorA=CC101F)](https://www.espressif.com/en/products/socs/esp32-S3)\n\nMember to Member Support / Chat\n\n [![Join the chat at https://gitter.im/tablatronix/WiFiManager](https://badges.gitter.im/tablatronix/WiFiManager.svg)](https://gitter.im/tablatronix/WiFiManager?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n \n[![Discord](https://img.shields.io/badge/Discord-WiFiManager-%237289da.svg?logo=discord)](https://discord.gg/nS5WGkaQH5)\nThe configuration portal is of the captive variety, so on various devices it will present the configuration dialogue as soon as you connect to the created access point.\n\nWorks with the [ESP8266 Arduino](https://github.com/esp8266/Arduino) and [ESP32 Arduino](https://github.com/espressif/arduino-esp32) platforms.\n\n### Known Issues\n\n* Documentation needs to be updated, see [https://github.com/tzapu/WiFiManager/issues/500](https://github.com/tzapu/WiFiManager/issues/500)\n-------\n\n## Contents\n - [How it works](#how-it-works)\n - [Wishlist](#wishlist)\n - [Quick start](#quick-start)\n   - Installing\n     - [Arduino - Through Library Manager](#install-through-library-manager)\n     - [Arduino - From Github](#checkout-from-github)\n     - [PlatformIO](#install-using-platformio)\n   - [Using](#using)\n - [Documentation](#documentation)\n   - [Access Point Password](#password-protect-the-configuration-access-point)\n   - [Callbacks](#callbacks)\n   - [Configuration Portal Timeout](#configuration-portal-timeout)\n   - [On Demand Configuration](#on-demand-configuration-portal)\n   - [Custom Parameters](#custom-parameters)\n   - [Custom IP Configuration](#custom-ip-configuration)\n   - [Filter Low Quality Networks](#filter-networks)\n   - [Debug Output](#debug)\n - [Troubleshooting](#troubleshooting)\n - [Releases](#releases)\n - [Contributors](#contributions-and-thanks)\n\n\n## How It Works\n- When your ESP starts up, it sets it up in Station mode and tries to connect to a previously saved Access Point\n- if this is unsuccessful (or no previous network saved) it moves the ESP into Access Point mode and spins up a DNS and WebServer (default ip 192.168.4.1)\n- using any wifi enabled device with a browser (computer, phone, tablet) connect to the newly created Access Point\n- because of the Captive Portal and the DNS server you will either get a 'Join to network' type of popup or get any domain you try to access redirected to the configuration portal\n- choose one of the access points scanned, enter password, click save\n- ESP will try to connect. If successful, it relinquishes control back to your app. If not, reconnect to AP and reconfigure.\n- There are options to change this behavior or manually start the configportal and webportal independantly as well as run them in non blocking mode.\n\n## How It Looks\n![ESP8266 WiFi Captive Portal Homepage](http://i.imgur.com/YPvW9eql.png) ![ESP8266 WiFi Captive Portal Configuration](http://i.imgur.com/oicWJ4gl.png)\n\n## Wishlist\n- [x] remove dependency on EEPROM library\n- [x] move HTML Strings to PROGMEM\n- [x] cleanup and streamline code (although this is ongoing)\n- [x] if timeout is set, extend it when a page is fetched in AP mode\n- [x] add ability to configure more parameters than ssid/password\n- [x] maybe allow setting ip of ESP after reboot\n- [x] add to Arduino Library Manager\n- [x] add to PlatformIO\n- [ ] add multiple sets of network credentials\n- [x] allow users to customize CSS\n- [ ] rewrite documentation for simplicity, based on scenarios/goals\n\n### Development\n- [x] ESP32 support\n- [x] rely on the SDK's built in auto connect more than forcing a connect\n- [x] add non blocking mode\n- [x] easy customization of strings\n- [x] hostname support\n- [x] fix various bugs and workarounds for esp SDK issues\n- [x] additional info page items\n- [x] last status display / faiilure reason\n- [x] customizeable menu\n- [x] seperate custom params page\n- [x] ondemand webportal\n- [x] complete refactor of code to segment functions\n- [x] wiif scan icons or percentage display\n- [x] invert class for dark mode\n- [x] more template tokens\n- [x] progmem for all strings\n- [ ] new callbacks\n- [ ] new callouts / filters\n- [ ] shared web server instance\n- [x] latest esp idf/sdk support\n- [x] wm is now non persistent, will not erase or change stored esp config on esp8266\n- [x] tons of debugging output / levels\n- [ ] disable captiveportal\n- [ ] preload wiifscans, faster page loads\n- [ ] softap stability fixes when sta is not connected\n\n\n## Quick Start\n\n### Installing\nYou can either install through the Arduino Library Manager or checkout the latest changes or a release from github\n\n#### Install through Library Manager\n__Currently version 0.8+ works with release 2.4.0 or newer of the [ESP8266 core for Arduino](https://github.com/esp8266/Arduino)__\n - in Arduino IDE got to Sketch/Include Library/Manage Libraries\n  ![Manage Libraries](http://i.imgur.com/9BkEBkR.png)\n\n - search for WiFiManager\n  ![WiFiManager package](http://i.imgur.com/18yIai8.png)\n\n - click Install and start [using it](#using)\n\n####  Checkout from github\n__Github version works with release 2.4.0 or newer of the [ESP8266 core for Arduino](https://github.com/esp8266/Arduino)__\n- Checkout library to your Arduino libraries folder\n\n### Using\n- Include in your sketch\n```cpp\n#include <WiFiManager.h>          //https://github.com/tzapu/WiFiManager WiFi Configuration Magic\n```\n\n- Initialize library, in your setup function add, NOTEif you are using non blocking you will make sure you create this in global scope or handle appropriatly , it will not work if in setup and using non blocking mode.\n```cpp\nWiFiManager wifiManager;\n```\n\n- Also in the setup function add\n```cpp\n//first parameter is name of access point, second is the password\nwifiManager.autoConnect(\"AP-NAME\", \"AP-PASSWORD\");\n```\nif you just want an unsecured access point\n```cpp\nwifiManager.autoConnect(\"AP-NAME\");\n```\nor if you want to use and auto generated name from 'ESP' and the esp's Chip ID use\n```cpp\nwifiManager.autoConnect();\n```\n\nAfter you write your sketch and start the ESP, it will try to connect to WiFi. If it fails it starts in Access Point mode.\nWhile in AP mode, connect to it then open a browser to the gateway IP, default 192.168.4.1, configure wifi, save and it should reboot and connect.\n\nAlso see [examples](https://github.com/tzapu/WiFiManager/tree/master/examples).\n\n#### Install Using PlatformIO\n\n[PlatformIO](https://platformio.org/) is an emerging ecosystem for IoT development, and \nis an alternative to using the Arduino IDE. Install `WiFiManager`\nusing the platformio [library manager](https://docs.platformio.org/en/latest/librarymanager/index.html#librarymanager) in your editor, \nor using the [PlatformIO Core CLI](https://docs.platformio.org/en/latest/core/index.html),\nor by adding it to your `platformio.ini` as shown below (recommended approach).\n\nThe simplest way is to open the `platformio.ini` file at the root of your project, and `WifiManager` to the common top-level env\n`lib_deps` key like so:\n\n```\n[env]\nlib_deps =\n\tWiFiManager\n```\n\n\n```\n[env]\nlib_deps =\n\thttps://github.com/tzapu/WiFiManager.git\n```\n\n## Documentation\n\n#### Password protect the configuration Access Point\nYou can and should password protect the configuration access point.  Simply add the password as a second parameter to `autoConnect`.\nA short password seems to have unpredictable results so use one that's around 8 characters or more in length.\nThe guidelines are that a wifi password must consist of 8 to 63 ASCII-encoded characters in the range of 32 to 126 (decimal)\n```cpp\nwifiManager.autoConnect(\"AutoConnectAP\", \"password\")\n```\n\n#### Callbacks\n##### Enter Config mode\nUse this if you need to do something when your device enters configuration mode on failed WiFi connection attempt.\nBefore `autoConnect()`\n```cpp\nwifiManager.setAPCallback(configModeCallback);\n```\n`configModeCallback` declaration and example\n```cpp\nvoid configModeCallback (WiFiManager *myWiFiManager) {\n  Serial.println(\"Entered config mode\");\n  Serial.println(WiFi.softAPIP());\n\n  Serial.println(myWiFiManager->getConfigPortalSSID());\n}\n```\n\n##### Save settings\nThis gets called when custom parameters have been set **AND** a connection has been established. Use it to set a flag, so when all the configuration finishes, you can save the extra parameters somewhere.\n\n\nIF YOU NEED TO SAVE PARAMETERS EVEN ON WIFI FAIL OR EMPTY, you must set `setBreakAfterConfig` to true, or else saveConfigCallback will not be called.\n\n```C++\n//if this is set, it will exit after config, even if connection is unsuccessful.\n    void          setBreakAfterConfig(boolean shouldBreak);\n```\n\nSee [AutoConnectWithFSParameters Example](https://github.com/tzapu/WiFiManager/tree/master/examples/Parameters/SPIFFS/AutoConnectWithFSParameters).\n```cpp\nwifiManager.setSaveConfigCallback(saveConfigCallback);\n```\n`saveConfigCallback` declaration and example\n```cpp\n//flag for saving data\nbool shouldSaveConfig = false;\n\n//callback notifying us of the need to save config\nvoid saveConfigCallback () {\n  Serial.println(\"Should save config\");\n  shouldSaveConfig = true;\n}\n```\n\n#### Configuration Portal Timeout\nIf you need to set a timeout so the ESP doesn't hang waiting to be configured, for instance after a power failure, you can add\n```cpp\nwifiManager.setConfigPortalTimeout(180);\n```\nwhich will wait 3 minutes (180 seconds). When the time passes, the autoConnect function will return, no matter the outcome.\nCheck for connection and if it's still not established do whatever is needed (on some modules I restart them to retry, on others I enter deep sleep)\n\n#### On Demand Configuration Portal\nIf you would rather start the configuration portal on demand rather than automatically on a failed connection attempt, then this is for you.\n\nInstead of calling `autoConnect()` which does all the connecting and failover configuration portal setup for you, you need to use `startConfigPortal()`. __Do not use BOTH.__\n\nExample usage\n```cpp\nvoid loop() {\n  // is configuration portal requested?\n  if ( digitalRead(TRIGGER_PIN) == LOW ) {\n    WiFiManager wifiManager;\n    wifiManager.startConfigPortal(\"OnDemandAP\");\n    Serial.println(\"connected...yeey :)\");\n  }\n}\n```\nSee example for a more complex version. [OnDemandConfigPortal](https://github.com/tzapu/WiFiManager/tree/master/examples/OnDemand/OnDemandConfigPortal)\n\n#### Exiting from the Configuration Portal\nNormally, once entered, the configuration portal will continue to loop until WiFi credentials have been successfully entered or a timeout is reached.\nIf you'd prefer to exit without joining a WiFi network, say becuase you're going to put the ESP into AP mode, then press the \"Exit\" button\non the main webpage.\nIf started via `autoConnect` or `startConfigPortal` then it will return `false (portalAbortResult)`\n\n#### Custom Parameters\nYou can use WiFiManager to collect more parameters than just SSID and password.\nThis could be helpful for configuring stuff like MQTT host and port, [blynk](http://www.blynk.cc) or [emoncms](http://emoncms.org) tokens, just to name a few.\n**You are responsible for saving and loading these custom values.** The library just collects and displays the data for you as a convenience.\nUsage scenario would be:\n- load values from somewhere (EEPROM/FS) or generate some defaults\n- add the custom parameters to WiFiManager using\n```cpp\n // id/name, placeholder/prompt, default, length\n WiFiManagerParameter custom_mqtt_server(\"server\", \"mqtt server\", mqtt_server, 40);\n wifiManager.addParameter(&custom_mqtt_server);\n\n```\n- if connection to AP fails, configuration portal starts and you can set /change the values (or use on demand configuration portal)\n- once configuration is done and connection is established save config callback() is called\n- once WiFiManager returns control to your application, read and save the new values using the `WiFiManagerParameter` object.\n```cpp\n mqtt_server = custom_mqtt_server.getValue();\n```  \nThis feature is a lot more involved than all the others, so here are some examples to fully show how it is done.\nYou should also take a look at adding custom HTML to your form.\n\n- Save and load custom parameters to file system in json form [AutoConnectWithFSParameters](https://github.com/tzapu/WiFiManager/tree/master/examples/Parameters/SPIFFS/AutoConnectWithFSParameters)\n- *Save and load custom parameters to EEPROM* (not done yet)\n\n#### Custom IP Configuration\nYou can set a custom IP for both AP (access point, config mode) and STA (station mode, client mode, normal project state)\n\n##### Custom Access Point IP Configuration\nThis will set your captive portal to a specific IP should you need/want such a feature. Add the following snippet before `autoConnect()`\n```cpp\n//set custom ip for portal\nwifiManager.setAPStaticIPConfig(IPAddress(10,0,1,1), IPAddress(10,0,1,1), IPAddress(255,255,255,0));\n```\n\n##### Custom Station (client) Static IP Configuration\nThis will make use the specified IP configuration instead of using DHCP in station mode.\n```cpp\nwifiManager.setSTAStaticIPConfig(IPAddress(192,168,0,99), IPAddress(192,168,0,1), IPAddress(255,255,255,0)); // optional DNS 4th argument\n```\nThere are a couple of examples in the examples folder that show you how to set a static IP and even how to configure it through the web configuration portal.\n\nNOTE: You should fill DNS server if you have HTTP requests with hostnames or syncronize time (NTP). It's the same as gateway ip or a popular (Google DNS: 8.8.8.8).\n\n#### Custom HTML, CSS, Javascript\nThere are various ways in which you can inject custom HTML, CSS or Javascript into the configuration portal.\nThe options are:\n- inject custom head element\nYou can use this to any html bit to the head of the configuration portal. If you add a `<style>` element, bare in mind it overwrites the included css, not replaces.\n```cpp\nwifiManager.setCustomHeadElement(\"<style>html{filter: invert(100%); -webkit-filter: invert(100%);}</style>\");\n```\n- inject a custom bit of html in the configuration/param form\n```cpp\nWiFiManagerParameter custom_text(\"<p>This is just a text paragraph</p>\");\nwifiManager.addParameter(&custom_text);\n```\n- inject a custom bit of html in a configuration form element\nJust add the bit you want added as the last parameter to the custom parameter constructor.\n```cpp\nWiFiManagerParameter custom_mqtt_server(\"server\", \"mqtt server\", \"iot.eclipse\", 40, \" readonly\");\nwifiManager.addParameter(&custom_mqtt_server);\n```\n\n#### Theming\nYou can customize certain elements of the default template with some builtin classes\n```CPP\nwifiManager.setClass(\"invert\"); // dark theme\nwifiManager.setScanDispPerc(true); // display percentages instead of graphs for RSSI\n```\nThere are additional classes in the css you can use in your custom html , see the example template.\n\n#### Filter Networks\nYou can filter networks based on signal quality and show/hide duplicate networks.\n\n- If you would like to filter low signal quality networks you can tell WiFiManager to not show networks below an arbitrary quality %;\n```cpp\nwifiManager.setMinimumSignalQuality(10);\n```\nwill not show networks under 10% signal quality. If you omit the parameter it defaults to 8%;\n\n- You can also remove or show duplicate networks (default is remove).\nUse this function to show (or hide) all networks.\n```cpp\nwifiManager.setRemoveDuplicateAPs(false);\n```\n\n#### Debug\nDebug is enabled by default on `Serial` in non-stable releases. To disable add before autoConnect/startConfigPortal\n```cpp\nwifiManager.setDebugOutput(false);\n```\n\nYou can pass in a custom stream via constructor \n```CPP\nWiFiManager wifiManager(Serial1);\n```\n\nYou can customize the debug level by changing `_debugLevel` in source\noptions are:\n* DEBUG_ERROR\n* DEBUG_NOTIFY\n* DEBUG_VERBOSE\n* DEBUG_DEV\n* DEBUG_MAX\n\n## Troubleshooting\nIf you get compilation errors, more often than not, you may need to install a newer version of the ESP8266 core for Arduino.\n\nChanges added on 0.8 should make the latest trunk work without compilation errors. Tested down to ESP8266 core 2.0.0. **Please update to version 0.8**\n\nI am trying to keep releases working with release versions of the core, so they can be installed through boards manager, but if you checkout the latest version directly from github, sometimes, the library will only work if you update the ESP8266 core to the latest version because I am using some newly added function.\n\nIf you connect to the created configuration Access Point but the configuration portal does not show up, just open a browser and type in the IP of the web portal, by default `192.168.4.1`.\n\nIf trying to connect ends up in an endless loop, try to add `setConnectTimeout(60)` before `autoConnect();`. The parameter is timeout to try connecting in seconds.\n\nI get stuck in ap mode when the power goes out or modem resets, try a setConfigPortalTimeout(seconds). This will cause the configportal to close after no activity, and you can reboot or attempt reconnection in your code.\n\n## Releases\n### 1.0.1\n\n### Development Overview\n\n#### Added Public Methods\n`setConfigPortalBlocking`\n\n`setShowStaticFields`\n\n`setCaptivePortalEnable`\n\n`setRestorePersistent`\n\n`setCaptivePortalClientCheck`\n\n`setWebPortalClientCheck`\n\n`startWebPortal`\n\n`stopWebPortal`\n\n`process`\n\n`disconnect`\n\n`erase`\n\n` debugSoftAPConfig`\n\n` debugPlatformInfo`\n\n`setScanDispPerc`\n\n`setHostname`\n\n`setMenu(menu_page_t[])`\n\n`setWiFiAutoReconnect`\n\n` setSTAStaticIPConfig(..,dns)`\n\n`setShowDnsFields`\n\n`getLastConxResult`\n\n`getWLStatusString`\n\n`getModeString`\n\n`getWiFiIsSaved`\n\n`setShowInfoErase`\n\n`setEnableConfigPortal`\n\n`setCountry`\n\n`setClass`\n\n`htmleEtities`\n\n\n#### WiFiManagerParameter\n`WiFiManagerParameter(id,label)`\n\n`WiFiManagerParameter.setValue(value,length)`\n\n`getParameters`\n\n`getParametersCount`\n\n\n#### Constructors\n`WiFiManager(Stream& consolePort)`\n\n#### define flags\n❗️  **Defines cannot be set in user sketches**\n`#define WM_MDNS       // use MDNS`\n\n`#define WM_FIXERASECONFIG // use erase flash fix, esp8266 2.4.0`\n\n`#define WM_ERASE_NVS // esp32 erase(true) will erase NVS`\n\n`#include <rom/rtc.h> // esp32 info page will show last reset reasons if this file is included`\n\n#### Changes Overview\n- ESP32 support ( fairly stable )\n- complete refactor of strings `strings_en.h`\n- adds new tokens for wifiscan, and some classes (left , invert icons, MSG color)\n- adds status callout panel default, primary, special colors\n-  adds tons of info on info page, and erase capability\n- adds signal icons, replaces percentage ( has hover titles )\n- adds labels to all inputs (replaces placeholders)\n- all html ( and eventually all strings except debug) moved to `strings_en.h`\n- added additional debugging, compressed debug lines, debuglevels\n- persistent disabled, and restored via de/con-stuctor (uses `setRestorePersistent`)\n- should retain all user modes including AP, should not overwrite or persist user modes or configs,even STA (`storeSTAmode`) (BUGGY)\n- ⚠️ return values may have changed depending on portal abort, or timeout ( `portalTimeoutResult`,`portalAbortResult`)\n- params memory is auto allocated by increment of `WIFI_MANAGER_MAX_PARAMS(5)` when exceeded, user no longer needs to specify this at all.\n- addparameter now returns bool, and it returns false if param ID is not alphanum [0-9,A-Z,a-z,_]\n- param field ids allow {I} token to use param_n instead of string in case someones wants to change this due to i18n or character issues\n- provides `#DEFINE FIXERASECONFIG` to help deal with https://github.com/esp8266/Arduino/pull/3635\n- failure reason reporting on portal\n- set esp8266 sta hostname, esp32 sta+ap hostname ( DHCP client id)\n- pass in debug stream in constructor WiFiManager(Stream& consolePort)\n- you can force ip fields off with showxfields(false) if you set _disableIpFields=true\n- param menu/page (setup) added to separate params from wifi page, handled automatically by setMenu\n- set custom root menu\n- disable configportal on autoconnect\n- wm parameters init is now protected, allowing child classes, example included\n- wifiscans are precached and async for faster page loads, refresh forces rescan\n- adds esp32 gettemperature ( currently commented out, useful for relative measurement only )\n\n#### 0.12\n- removed 204 header response\n- fixed incompatibility with other libs using isnan and other std:: functions without namespace\n\n##### 0.11\n- a lot more reliable reconnecting to networks\n- custom html in custom parameters (for read only params)\n- custom html in custom parameter form (like labels)\n- custom head element (like custom css)\n- sort networks based on signal quality\n- remove duplicate networks\n\n##### 0.10\n- some css changes\n- bug fixes and speed improvements\n- added an alternative to waitForConnectResult() for debugging\n- changed `setTimeout(seconds)` to `setConfigPortalTimeout(seconds)`\n\n### Contributions and thanks\nThe support and help I got from the community has been nothing short of phenomenal. I can't thank you guys enough. This is my first real attept in developing open source stuff and I must say, now I understand why people are so dedicated to it, it is because of all the wonderful people involved.\n\n__THANK YOU__\n\nThe esp8266 and esp32 arduino and idf maintainers!\n\n[Shawn A aka tablatronix](https://github.com/tablatronix)\n\n[liebman](https://github.com/liebman)\n\n[Evgeny Dontsov](https://github.com/dontsovcmc)\n\n[Chris Marrin](https://github.com/cmarrin)\n\n[bbx10](https://github.com/bbx10)\n\n[kentaylor](https://github.com/kentaylor)\n\n[Maximiliano Duarte](https://github.com/domonetic)\n\n[alltheblinkythings](https://github.com/alltheblinkythings)\n\n[Niklas Wall](https://github.com/niklaswall)\n\n[Jakub Piasecki](https://github.com/zaporylie)\n\n[Peter Allan](https://github.com/alwynallan)\n\n[John Little](https://github.com/j0hnlittle)\n\n[markaswift](https://github.com/markaswift)\n\n[franklinvv](https://github.com/franklinvv)\n\n[Alberto Ricci Bitti](https://github.com/riccibitti)\n\n[SebiPanther](https://github.com/SebiPanther)\n\n[jonathanendersby](https://github.com/jonathanendersby)\n\n[walthercarsten](https://github.com/walthercarsten)\n\nAnd countless others\n\n#### Inspiration\n * http://www.esp8266.com/viewtopic.php?f=29&t=2520\n * https://github.com/chriscook8/esp-arduino-apboot\n * https://github.com/esp8266/Arduino/tree/master/libraries/DNSServer/examples/CaptivePortalAdvanced\n * Built by AlexT https://github.com/tzapu\n\n"
        },
        {
          "name": "WiFiManager.cpp",
          "type": "blob",
          "size": 120.0068359375,
          "content": "/**\n * WiFiManager.cpp\n * \n * WiFiManager, a library for the ESP8266/Arduino platform\n * for configuration of WiFi credentials using a Captive Portal\n * \n * @author Creator tzapu\n * @author tablatronix\n * @version 0.0.0\n * @license MIT\n */\n\n#include \"WiFiManager.h\"\n\n#if defined(ESP8266) || defined(ESP32)\n\n#ifdef ESP32\nuint8_t WiFiManager::_lastconxresulttmp = WL_IDLE_STATUS;\n#endif\n\n/**\n * --------------------------------------------------------------------------------\n *  WiFiManagerParameter\n * --------------------------------------------------------------------------------\n**/\n\nWiFiManagerParameter::WiFiManagerParameter() {\n  WiFiManagerParameter(\"\");\n}\n\nWiFiManagerParameter::WiFiManagerParameter(const char *custom) {\n  _id             = NULL;\n  _label          = NULL;\n  _length         = 0;\n  _value          = nullptr;\n  _labelPlacement = WFM_LABEL_DEFAULT;\n  _customHTML     = custom;\n}\n\nWiFiManagerParameter::WiFiManagerParameter(const char *id, const char *label) {\n  init(id, label, \"\", 0, \"\", WFM_LABEL_DEFAULT);\n}\n\nWiFiManagerParameter::WiFiManagerParameter(const char *id, const char *label, const char *defaultValue, int length) {\n  init(id, label, defaultValue, length, \"\", WFM_LABEL_DEFAULT);\n}\n\nWiFiManagerParameter::WiFiManagerParameter(const char *id, const char *label, const char *defaultValue, int length, const char *custom) {\n  init(id, label, defaultValue, length, custom, WFM_LABEL_DEFAULT);\n}\n\nWiFiManagerParameter::WiFiManagerParameter(const char *id, const char *label, const char *defaultValue, int length, const char *custom, int labelPlacement) {\n  init(id, label, defaultValue, length, custom, labelPlacement);\n}\n\nvoid WiFiManagerParameter::init(const char *id, const char *label, const char *defaultValue, int length, const char *custom, int labelPlacement) {\n  _id             = id;\n  _label          = label;\n  _labelPlacement = labelPlacement;\n  _customHTML     = custom;\n  _length         = 0;\n  _value          = nullptr;\n  setValue(defaultValue,length);\n}\n\nWiFiManagerParameter::~WiFiManagerParameter() {\n  if (_value != NULL) {\n    delete[] _value;\n  }\n  _length=0; // setting length 0, ideally the entire parameter should be removed, or added to wifimanager scope so it follows\n}\n\n// WiFiManagerParameter& WiFiManagerParameter::operator=(const WiFiManagerParameter& rhs){\n//   Serial.println(\"copy assignment op called\");\n//   (*this->_value) = (*rhs._value);\n//   return *this;\n// }\n\n// @note debug is not available in wmparameter class\nvoid WiFiManagerParameter::setValue(const char *defaultValue, int length) {\n  if(!_id){\n    // Serial.println(\"cannot set value of this parameter\");\n    return;\n  }\n  \n  // if(strlen(defaultValue) > length){\n  //   // Serial.println(\"defaultValue length mismatch\");\n  //   // return false; //@todo bail \n  // }\n\n  if(_length != length || _value == nullptr){\n    _length = length;\n    if( _value != nullptr){\n      delete[] _value;\n    }\n    _value  = new char[_length + 1];  \n  }\n\n  memset(_value, 0, _length + 1); // explicit null\n  \n  if (defaultValue != NULL) {\n    strncpy(_value, defaultValue, _length);\n  }\n}\nconst char* WiFiManagerParameter::getValue() const {\n  // Serial.println(printf(\"Address of _value is %p\\n\", (void *)_value)); \n  return _value;\n}\nconst char* WiFiManagerParameter::getID() const {\n  return _id;\n}\nconst char* WiFiManagerParameter::getPlaceholder() const {\n  return _label;\n}\nconst char* WiFiManagerParameter::getLabel() const {\n  return _label;\n}\nint WiFiManagerParameter::getValueLength() const {\n  return _length;\n}\nint WiFiManagerParameter::getLabelPlacement() const {\n  return _labelPlacement;\n}\nconst char* WiFiManagerParameter::getCustomHTML() const {\n  return _customHTML;\n}\n\n/**\n * [addParameter description]\n * @access public\n * @param {[type]} WiFiManagerParameter *p [description]\n */\nbool WiFiManager::addParameter(WiFiManagerParameter *p) {\n\n  // check param id is valid, unless null\n  if(p->getID()){\n    for (size_t i = 0; i < strlen(p->getID()); i++){\n       if(!(isAlphaNumeric(p->getID()[i])) && !(p->getID()[i]=='_')){\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] parameter IDs can only contain alpha numeric chars\"));\n        #endif\n        return false;\n       }\n    }\n  }\n\n  // init params if never malloc\n  if(_params == NULL){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"allocating params bytes:\"),_max_params * sizeof(WiFiManagerParameter*));        \n    #endif\n    _params = (WiFiManagerParameter**)malloc(_max_params * sizeof(WiFiManagerParameter*));\n  }\n\n  // resize the params array by increment of WIFI_MANAGER_MAX_PARAMS\n  if(_paramsCount == _max_params){\n    _max_params += WIFI_MANAGER_MAX_PARAMS;\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"Updated _max_params:\"),_max_params);\n    DEBUG_WM(WM_DEBUG_DEV,F(\"re-allocating params bytes:\"),_max_params * sizeof(WiFiManagerParameter*));    \n    #endif\n    WiFiManagerParameter** new_params = (WiFiManagerParameter**)realloc(_params, _max_params * sizeof(WiFiManagerParameter*));\n    #ifdef WM_DEBUG_LEVEL\n    // DEBUG_WM(WIFI_MANAGER_MAX_PARAMS);\n    // DEBUG_WM(_paramsCount);\n    // DEBUG_WM(_max_params);\n    #endif\n    if (new_params != NULL) {\n      _params = new_params;\n    } else {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] failed to realloc params, size not increased!\"));\n      #endif\n      return false;\n    }\n  }\n\n  _params[_paramsCount] = p;\n  _paramsCount++;\n  \n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Added Parameter:\"),p->getID());\n  #endif\n  return true;\n}\n\n/**\n * [getParameters description]\n * @access public\n */\nWiFiManagerParameter** WiFiManager::getParameters() {\n  return _params;\n}\n\n/**\n * [getParametersCount description]\n * @access public\n */\nint WiFiManager::getParametersCount() {\n  return _paramsCount;\n}\n\n/**\n * --------------------------------------------------------------------------------\n *  WiFiManager \n * --------------------------------------------------------------------------------\n**/\n\n// constructors\nWiFiManager::WiFiManager(Print& consolePort):_debugPort(consolePort){\n  WiFiManagerInit();\n}\n\nWiFiManager::WiFiManager() {\n  WiFiManagerInit();  \n}\n\nvoid WiFiManager::WiFiManagerInit(){\n  setMenu(_menuIdsDefault);\n  if(_debug && _debugLevel >= WM_DEBUG_DEV) debugPlatformInfo();\n  _max_params = WIFI_MANAGER_MAX_PARAMS;\n}\n\n// destructor\nWiFiManager::~WiFiManager() {\n  _end();\n  // parameters\n  // @todo below belongs to wifimanagerparameter\n  if (_params != NULL){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"freeing allocated params!\"));\n    #endif\n    free(_params);\n    _params = NULL;\n  }\n\n  // remove event\n  // WiFi.onEvent(std::bind(&WiFiManager::WiFiEvent,this,_1,_2));\n  #ifdef ESP32\n    WiFi.removeEvent(wm_event_id);\n  #endif\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"unloading\"));\n  #endif\n}\n\nvoid WiFiManager::_begin(){\n  if(_hasBegun) return;\n  _hasBegun = true;\n  // _usermode = WiFi.getMode();\n\n  #ifndef ESP32\n  WiFi.persistent(false); // disable persistent so scannetworks and mode switching do not cause overwrites\n  #endif\n}\n\nvoid WiFiManager::_end(){\n  _hasBegun = false;\n  if(_userpersistent) WiFi.persistent(true); // reenable persistent, there is no getter we rely on _userpersistent\n  // if(_usermode != WIFI_OFF) WiFi.mode(_usermode);\n}\n\n// AUTOCONNECT\n\nboolean WiFiManager::autoConnect() {\n  String ssid = getDefaultAPName();\n  return autoConnect(ssid.c_str(), NULL);\n}\n\n/**\n * [autoConnect description]\n * @access public\n * @param  {[type]} char const         *apName     [description]\n * @param  {[type]} char const         *apPassword [description]\n * @return {[type]}      [description]\n */\nboolean WiFiManager::autoConnect(char const *apName, char const *apPassword) {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"AutoConnect\"));\n  #endif\n\n  // bool wifiIsSaved = getWiFiIsSaved();\n  bool wifiIsSaved = true; // workaround until I can check esp32 wifiisinit and has nvs\n\n  #ifdef ESP32\n  setupHostname(true);\n\n  if(_hostname != \"\"){\n    // disable wifi if already on\n    if(WiFi.getMode() & WIFI_STA){\n      WiFi.mode(WIFI_OFF);\n      int timeout = millis()+1200;\n      // async loop for mode change\n      while(WiFi.getMode()!= WIFI_OFF && millis()<timeout){\n        delay(0);\n      }\n    }\n  }\n  #endif\n\n  // check if wifi is saved, (has autoconnect) to speed up cp start\n  // NOT wifi init safe\n  if(wifiIsSaved){\n     _startconn = millis();\n    _begin();\n\n    // attempt to connect using saved settings, on fail fallback to AP config portal\n    if(!WiFi.enableSTA(true)){\n      // handle failure mode Brownout detector etc.\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_ERROR,F(\"[FATAL] Unable to enable wifi!\"));\n      #endif\n      return false;\n    }\n    \n    WiFiSetCountry();\n\n    #ifdef ESP32\n    if(esp32persistent) WiFi.persistent(false); // disable persistent for esp32 after esp_wifi_start or else saves wont work\n    #endif\n\n    _usermode = WIFI_STA; // When using autoconnect , assume the user wants sta mode on permanently.\n\n    // no getter for autoreconnectpolicy before this\n    // https://github.com/esp8266/Arduino/pull/4359\n    // so we must force it on else, if not connectimeout then waitforconnectionresult gets stuck endless loop\n    WiFi_autoReconnect();\n\n    #ifdef ESP8266\n    if(_hostname != \"\"){\n      setupHostname(true);\n    }\n    #endif\n\n    // if already connected, or try stored connect \n    // @note @todo ESP32 has no autoconnect, so connectwifi will always be called unless user called begin etc before\n    // @todo check if correct ssid == saved ssid when already connected\n    bool connected = false;\n    if (WiFi.status() == WL_CONNECTED){\n      connected = true;\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"AutoConnect: ESP Already Connected\"));\n      #endif\n      setSTAConfig();\n      // @todo not sure if this is safe, causes dup setSTAConfig in connectwifi,\n      // and we have no idea WHAT we are connected to\n    }\n\n    if(connected || connectWifi(_defaultssid, _defaultpass) == WL_CONNECTED){\n      //connected\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"AutoConnect: SUCCESS\"));\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Connected in\"),(String)((millis()-_startconn)) + \" ms\");\n      DEBUG_WM(F(\"STA IP Address:\"),WiFi.localIP());\n      #endif\n      // Serial.println(\"Connected in \" + (String)((millis()-_startconn)) + \" ms\");\n      _lastconxresult = WL_CONNECTED;\n\n      if(_hostname != \"\"){\n        #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_DEV,F(\"hostname: STA: \"),getWiFiHostname());\n        #endif\n      }\n      return true; // connected success\n    }\n\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"AutoConnect: FAILED for \"),(String)((millis()-_startconn)) + \" ms\");\n    #endif\n  }\n  else {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"No Credentials are Saved, skipping connect\"));\n    #endif\n  }\n\n  // possibly skip the config portal\n  if (!_enableConfigPortal) {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"enableConfigPortal: FALSE, skipping \"));\n    #endif\n\n    return false; // not connected and not cp\n  }\n\n  // not connected start configportal\n  bool res = startConfigPortal(apName, apPassword);\n  return res;\n}\n\nbool WiFiManager::setupHostname(bool restart){\n  if(_hostname == \"\") {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"No Hostname to set\"));\n    #endif\n    return false;\n  } \n  else {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Setting Hostnames: \"),_hostname);\n    #endif\n  }\n  bool res = true;\n  #ifdef ESP8266\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Setting WiFi hostname\"));\n    #endif\n    res = WiFi.hostname(_hostname.c_str());\n    // #ifdef ESP8266MDNS_H\n    #ifdef WM_MDNS\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Setting MDNS hostname, tcp 80\"));\n      #endif\n      if(MDNS.begin(_hostname.c_str())){\n        MDNS.addService(\"http\", \"tcp\", 80);\n      }\n    #endif\n  #elif defined(ESP32)\n    // @note hostname must be set after STA_START\n    // @note, this may have changed at some point, now it wont work, I have to set it before.\n    // same for S2, must set it before mode(STA) now\n  \n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Setting WiFi hostname\"));\n    #endif\n\n    res = WiFi.setHostname(_hostname.c_str());\n    // esp_err_t err;\n    //   // err = set_esp_interface_hostname(ESP_IF_WIFI_STA, \"TEST_HOSTNAME\");\n    //   err = esp_netif_set_hostname(esp_netifs[ESP_IF_WIFI_STA], \"TEST_HOSTNAME\");\n    //     if(err){\n    //         log_e(\"Could not set hostname! %d\", err);\n    //         return false;\n    //     } \n    // #ifdef ESP32MDNS_H\n      #ifdef WM_MDNS\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Setting MDNS hostname, tcp 80\"));\n        #endif\n      if(MDNS.begin(_hostname.c_str())){\n        MDNS.addService(\"http\", \"tcp\", 80);\n      }\n    #endif\n  #endif\n\n  #ifdef WM_DEBUG_LEVEL\n  if(!res)DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] hostname: set failed!\"));\n  #endif\n\n  if(restart && (WiFi.status() == WL_CONNECTED)){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"reconnecting to set new hostname\"));\n    #endif\n    // WiFi.reconnect(); // This does not reset dhcp\n    WiFi_Disconnect();\n    delay(200); // do not remove, need a delay for disconnect to change status()\n  }\n\n  return res;\n}\n\n// CONFIG PORTAL\nbool WiFiManager::startAP(){\n  bool ret = true;\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"StartAP with SSID: \"),_apName);\n  #endif\n\n  #ifdef ESP8266\n    // @bug workaround for bug #4372 https://github.com/esp8266/Arduino/issues/4372\n    if(!WiFi.enableAP(true)) {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] enableAP failed!\"));\n      #endif\n      return false;\n    }\n    delay(500); // workaround delay\n  #endif\n\n  // setup optional soft AP static ip config\n  if (_ap_static_ip) {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"Custom AP IP/GW/Subnet:\"));\n    #endif\n    if(!WiFi.softAPConfig(_ap_static_ip, _ap_static_gw, _ap_static_sn)){\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] softAPConfig failed!\"));\n      #endif\n    }\n  }\n\n  //@todo add callback here if needed to modify ap but cannot use setAPStaticIPConfig\n  //@todo rework wifi channelsync as it will work unpredictably when not connected in sta\n \n  int32_t channel = 0;\n  if(_channelSync) channel = WiFi.channel();\n  else channel = _apChannel;\n\n  if(channel>0){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Starting AP on channel:\"),channel);\n    #endif\n  }\n\n  // start soft AP with password or anonymous\n  // default channel is 1 here and in esplib, @todo just change to default remove conditionals\n  if (_apPassword != \"\") {\n    if(channel>0){\n      ret = WiFi.softAP(_apName.c_str(), _apPassword.c_str(),channel,_apHidden);\n    }  \n    else{\n      ret = WiFi.softAP(_apName.c_str(), _apPassword.c_str(),1,_apHidden);//password option\n    }\n  } else {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"AP has anonymous access!\"));    \n    #endif\n    if(channel>0){\n      ret = WiFi.softAP(_apName.c_str(),\"\",channel,_apHidden);\n    }  \n    else{\n      ret = WiFi.softAP(_apName.c_str(),\"\",1,_apHidden);\n    }  \n  }\n\n  if(_debugLevel >= WM_DEBUG_DEV) debugSoftAPConfig();\n\n  // @todo add softAP retry here to dela with unknown failures\n  \n  delay(500); // slight delay to make sure we get an AP IP\n  #ifdef WM_DEBUG_LEVEL\n  if(!ret) DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] There was a problem starting the AP\"));\n  DEBUG_WM(F(\"AP IP address:\"),WiFi.softAPIP());\n  #endif\n\n  // set ap hostname\n  #ifdef ESP32\n    if(ret && _hostname != \"\"){\n      bool res =  WiFi.softAPsetHostname(_hostname.c_str());\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"setting softAP Hostname:\"),_hostname);\n      if(!res)DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] hostname: AP set failed!\"));\n      DEBUG_WM(WM_DEBUG_DEV,F(\"hostname: AP: \"),WiFi.softAPgetHostname());\n      #endif\n   }\n  #endif\n\n  return ret;\n}\n\n/**\n * [startWebPortal description]\n * @access public\n * @return {[type]} [description]\n */\nvoid WiFiManager::startWebPortal() {\n  if(configPortalActive || webPortalActive) return;\n  connect = abort = false;\n  setupConfigPortal();\n  webPortalActive = true;\n}\n\n/**\n * [stopWebPortal description]\n * @access public\n * @return {[type]} [description]\n */\nvoid WiFiManager::stopWebPortal() {\n  if(!configPortalActive && !webPortalActive) return;\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Stopping Web Portal\"));  \n  #endif\n  webPortalActive = false;\n  shutdownConfigPortal();\n}\n\nboolean WiFiManager::configPortalHasTimeout(){\n    if(!configPortalActive) return false;\n    uint16_t logintvl = 30000; // how often to emit timeing out counter logging\n\n    // handle timeout portal client check\n    if(_configPortalTimeout == 0 || (_apClientCheck && (WiFi_softap_num_stations() > 0))){\n      // debug num clients every 30s\n      if(millis() - timer > logintvl){\n        timer = millis();\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"NUM CLIENTS: \"),(String)WiFi_softap_num_stations());\n        #endif\n      }\n      _configPortalStart = millis(); // kludge, bump configportal start time to skew timeouts\n      return false;\n    }\n\n    // handle timeout webclient check\n    if(_webClientCheck && (_webPortalAccessed>_configPortalStart)>0) _configPortalStart = _webPortalAccessed;\n\n    // handle timed out\n    if(millis() > _configPortalStart + _configPortalTimeout){\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"config portal has timed out\"));\n      #endif\n      return true; // timeout bail, else do debug logging\n    } \n    else if(_debug && _debugLevel > 0) {\n      // log timeout time remaining every 30s\n      if((millis() - timer) > logintvl){\n        timer = millis();\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Portal Timeout In\"),(String)((_configPortalStart + _configPortalTimeout-millis())/1000) + (String)F(\" seconds\"));\n        #endif\n      }\n    }\n\n    return false;\n}\n\nvoid WiFiManager::setupHTTPServer(){\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"Starting Web Portal\"));\n  #endif\n\n  if(_httpPort != 80) {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"http server started with custom port: \"),_httpPort); // @todo not showing ip\n    #endif\n  }\n\n  server.reset(new WM_WebServer(_httpPort));\n  // This is not the safest way to reset the webserver, it can cause crashes on callbacks initilized before this and since its a shared pointer...\n\n  if ( _webservercallback != NULL) {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[CB] _webservercallback calling\"));\n    #endif\n    _webservercallback(); // @CALLBACK\n  }\n  // @todo add a new callback maybe, after webserver started, callback cannot override handlers, but can grab them first\n  \n  /* Setup httpd callbacks, web pages: root, wifi config pages, SO captive portal detectors and not found. */\n\n  // G macro workaround for Uri() bug https://github.com/esp8266/Arduino/issues/7102\n  server->on(WM_G(R_root),       std::bind(&WiFiManager::handleRoot, this));\n  server->on(WM_G(R_wifi),       std::bind(&WiFiManager::handleWifi, this, true));\n  server->on(WM_G(R_wifinoscan), std::bind(&WiFiManager::handleWifi, this, false));\n  server->on(WM_G(R_wifisave),   std::bind(&WiFiManager::handleWifiSave, this));\n  server->on(WM_G(R_info),       std::bind(&WiFiManager::handleInfo, this));\n  server->on(WM_G(R_param),      std::bind(&WiFiManager::handleParam, this));\n  server->on(WM_G(R_paramsave),  std::bind(&WiFiManager::handleParamSave, this));\n  server->on(WM_G(R_restart),    std::bind(&WiFiManager::handleReset, this));\n  server->on(WM_G(R_exit),       std::bind(&WiFiManager::handleExit, this));\n  server->on(WM_G(R_close),      std::bind(&WiFiManager::handleClose, this));\n  server->on(WM_G(R_erase),      std::bind(&WiFiManager::handleErase, this, false));\n  server->on(WM_G(R_status),     std::bind(&WiFiManager::handleWiFiStatus, this));\n  server->onNotFound (std::bind(&WiFiManager::handleNotFound, this));\n  \n  server->on(WM_G(R_update), std::bind(&WiFiManager::handleUpdate, this));\n  server->on(WM_G(R_updatedone), HTTP_POST, std::bind(&WiFiManager::handleUpdateDone, this), std::bind(&WiFiManager::handleUpdating, this));\n  \n  server->begin(); // Web server start\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"HTTP server started\"));\n  #endif\n}\n\nvoid WiFiManager::setupDNSD(){\n  dnsServer.reset(new DNSServer());\n\n  /* Setup the DNS server redirecting all the domains to the apIP */\n  dnsServer->setErrorReplyCode(DNSReplyCode::NoError);\n  #ifdef WM_DEBUG_LEVEL\n  // DEBUG_WM(\"dns server started port: \",DNS_PORT);\n  DEBUG_WM(WM_DEBUG_DEV,F(\"dns server started with ip: \"),WiFi.softAPIP()); // @todo not showing ip\n  #endif\n  dnsServer->start(DNS_PORT, F(\"*\"), WiFi.softAPIP());\n}\n\nvoid WiFiManager::setupConfigPortal() {\n  setupHTTPServer();\n  _lastscan = 0; // reset network scan cache\n  if(_preloadwifiscan) WiFi_scanNetworks(true,true); // preload wifiscan , async\n}\n\nboolean WiFiManager::startConfigPortal() {\n  String ssid = getDefaultAPName();\n  return startConfigPortal(ssid.c_str(), NULL);\n}\n\n/**\n * [startConfigPortal description]\n * @access public\n * @param  {[type]} char const         *apName     [description]\n * @param  {[type]} char const         *apPassword [description]\n * @return {[type]}      [description]\n */\nboolean  WiFiManager::startConfigPortal(char const *apName, char const *apPassword) {\n  _begin();\n\n  if(configPortalActive){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Starting Config Portal FAILED, is already running\"));\n    #endif    \n    return false;\n  }\n\n  //setup AP\n  _apName     = apName; // @todo check valid apname ?\n  _apPassword = apPassword;\n  \n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Starting Config Portal\"));\n  #endif\n\n  if(_apName == \"\") _apName = getDefaultAPName();\n\n  if(!validApPassword()) return false;\n  \n  // HANDLE issues with STA connections, shutdown sta if not connected, or else this will hang channel scanning and softap will not respond\n  if(_disableSTA || (!WiFi.isConnected() && _disableSTAConn)){\n    // this fixes most ap problems, however, simply doing mode(WIFI_AP) does not work if sta connection is hanging, must `wifi_station_disconnect` \n    #ifdef WM_DISCONWORKAROUND\n      WiFi.mode(WIFI_AP_STA);\n    #endif\n    WiFi_Disconnect();\n    WiFi_enableSTA(false);\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Disabling STA\"));\n    #endif\n  }\n  else {\n    // WiFi_enableSTA(true);\n  }\n\n  // init configportal globals to known states\n  configPortalActive = true;\n  bool result = connect = abort = false; // loop flags, connect true success, abort true break\n  uint8_t state;\n\n  _configPortalStart = millis();\n\n  // start access point\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Enabling AP\"));\n  #endif\n  startAP();\n  WiFiSetCountry();\n\n  // do AP callback if set\n  if ( _apcallback != NULL) {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[CB] _apcallback calling\"));\n    #endif\n    _apcallback(this);\n  }\n\n  // init configportal\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"setupConfigPortal\"));\n  #endif\n  setupConfigPortal();\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"setupDNSD\"));\n  #endif  \n  setupDNSD();\n  \n\n  if(!_configPortalIsBlocking){\n    #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Config Portal Running, non blocking (processing)\"));\n      if(_configPortalTimeout > 0) DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Portal Timeout In\"),(String)(_configPortalTimeout/1000) + (String)F(\" seconds\"));\n    #endif\n    return result; // skip blocking loop\n  }\n\n  // enter blocking loop, waiting for config\n  \n  #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Config Portal Running, blocking, waiting for clients...\"));\n    if(_configPortalTimeout > 0) DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Portal Timeout In\"),(String)(_configPortalTimeout/1000) + (String)F(\" seconds\"));\n  #endif\n\n  while(1){\n\n    // if timed out or abort, break\n    if(configPortalHasTimeout() || abort){\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_DEV,F(\"configportal loop abort\"));\n      #endif\n      shutdownConfigPortal();\n      result = abort ? portalAbortResult : portalTimeoutResult; // false, false\n      if (_configportaltimeoutcallback != NULL) {\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[CB] config portal timeout callback\"));\n        #endif\n        _configportaltimeoutcallback();  // @CALLBACK\n      }\n      break;\n    }\n\n    state = processConfigPortal();\n    \n    // status change, break\n    // @todo what is this for, should be moved inside the processor\n    // I think.. this is to detect autoconnect by esp in background, there are also many open issues about autoreconnect not working\n    if(state != WL_IDLE_STATUS){\n        result = (state == WL_CONNECTED); // true if connected\n        DEBUG_WM(WM_DEBUG_DEV,F(\"configportal loop break\"));\n        break;\n    }\n\n    if(!configPortalActive) break;\n\n    yield(); // watchdog\n  }\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_NOTIFY,F(\"config portal exiting\"));\n  #endif\n  return result;\n}\n\n/**\n * [process description]\n * @access public\n * @return bool connected\n */\nboolean WiFiManager::process(){\n    // process mdns, esp32 not required\n    #if defined(WM_MDNS) && defined(ESP8266)\n    MDNS.update();\n    #endif\n\t\n    if(webPortalActive || (configPortalActive && !_configPortalIsBlocking)){\n      // if timed out or abort, break\n      if(_allowExit && (configPortalHasTimeout() || abort)){\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_DEV,F(\"process loop abort\"));\n        #endif\n        webPortalActive = false;\n        shutdownConfigPortal();\n        if (_configportaltimeoutcallback != NULL) {\n          #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[CB] config portal timeout callback\"));\n          #endif\n          _configportaltimeoutcallback();  // @CALLBACK\n        }\n        return false;\n      }\n\n      uint8_t state = processConfigPortal(); // state is WL_IDLE or WL_CONNECTED/FAILED\n      return state == WL_CONNECTED;\n    }\n    return false;\n}\n\n/**\n * [processConfigPortal description]\n * using esp wl_status enums as returns for now, should be fine\n * returns WL_IDLE_STATUS or WL_CONNECTED/WL_CONNECT_FAILED upon connect/save flag\n * \n * @return {[type]} [description]\n */\nuint8_t WiFiManager::processConfigPortal(){\n    if(configPortalActive){\n      //DNS handler\n      dnsServer->processNextRequest();\n    }\n\n    //HTTP handler\n    server->handleClient();\n\n    // Waiting for save...\n    if(connect) {\n      connect = false;\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"processing save\"));\n      #endif\n      if(_enableCaptivePortal) delay(_cpclosedelay); // keeps the captiveportal from closing to fast.\n\n      // skip wifi if no ssid\n      if(_ssid == \"\"){\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"No ssid, skipping wifi save\"));\n        #endif\n      }\n      else{\n        // attempt sta connection to submitted _ssid, _pass\n        uint8_t res = connectWifi(_ssid, _pass, _connectonsave) == WL_CONNECTED;\n        if (res || (!_connectonsave)) {\n          #ifdef WM_DEBUG_LEVEL\n          if(!_connectonsave){\n            DEBUG_WM(F(\"SAVED with no connect to new AP\"));\n          } else {\n            DEBUG_WM(F(\"Connect to new AP [SUCCESS]\"));\n            DEBUG_WM(F(\"Got IP Address:\"));\n            DEBUG_WM(WiFi.localIP());\n          }\n          #endif\n\n          if ( _savewificallback != NULL) {\n            #ifdef WM_DEBUG_LEVEL\n            DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[CB] _savewificallback calling\"));\n            #endif\n            _savewificallback(); // @CALLBACK\n          }\n          if(!_connectonsave) return WL_IDLE_STATUS;\n          if(_disableConfigPortal) shutdownConfigPortal();\n          return WL_CONNECTED; // CONNECT SUCCESS\n        }\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] Connect to new AP Failed\"));\n        #endif\n      }\n \n      if (_shouldBreakAfterConfig) {\n\n        // do save callback\n        // @todo this is more of an exiting callback than a save, clarify when this should actually occur\n        // confirm or verify data was saved to make this more accurate callback\n        if ( _savewificallback != NULL) {\n          #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[CB] WiFi/Param save callback\"));\n          #endif\n          _savewificallback(); // @CALLBACK\n        }\n        if(_disableConfigPortal) shutdownConfigPortal();\n        return WL_CONNECT_FAILED; // CONNECT FAIL\n      }\n      else if(_configPortalIsBlocking){\n        // clear save strings\n        _ssid = \"\";\n        _pass = \"\";\n        // if connect fails, turn sta off to stabilize AP\n        WiFi_Disconnect();\n        WiFi_enableSTA(false);\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Processing - Disabling STA\"));\n        #endif\n      }\n      else{\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Portal is non blocking - remaining open\"));\n        #endif        \n      }\n    }\n\n    return WL_IDLE_STATUS;\n}\n\n/**\n * [shutdownConfigPortal description]\n * @access public\n * @return bool success (softapdisconnect)\n */\nbool WiFiManager::shutdownConfigPortal(){\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"shutdownConfigPortal\"));\n  #endif\n\n  if(webPortalActive) return false;\n\n  if(configPortalActive){\n    //DNS handler\n    dnsServer->processNextRequest();\n  }\n\n  //HTTP handler\n  server->handleClient();\n\n  // @todo what is the proper way to shutdown and free the server up\n  // debug - many open issues aobut port not clearing for use with other servers\n  server->stop();\n  server.reset();\n\n  WiFi.scanDelete(); // free wifi scan results\n\n  if(!configPortalActive) return false;\n\n  dnsServer->stop(); //  free heap ?\n  dnsServer.reset();\n\n  // turn off AP\n  // @todo bug workaround\n  // https://github.com/esp8266/Arduino/issues/3793\n  // [APdisconnect] set_config failed! *WM: disconnect configportal - softAPdisconnect failed\n  // still no way to reproduce reliably\n\n  bool ret = false;\n  ret = WiFi.softAPdisconnect(false);\n  \n  #ifdef WM_DEBUG_LEVEL\n  if(!ret)DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] disconnect configportal - softAPdisconnect FAILED\"));\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"restoring usermode\"),getModeString(_usermode));\n  #endif\n  delay(1000);\n  WiFi_Mode(_usermode); // restore users wifi mode, BUG https://github.com/esp8266/Arduino/issues/4372\n  if(WiFi.status()==WL_IDLE_STATUS){\n    WiFi.reconnect(); // restart wifi since we disconnected it in startconfigportal\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Reconnect, was idle\"));\n    #endif\n  }\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"wifi status:\"),getWLStatusString(WiFi.status()));\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"wifi mode:\"),getModeString(WiFi.getMode()));\n  #endif\n  configPortalActive = false;\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"configportal closed\"));\n  _end();\n  return ret;\n}\n\n// @todo refactor this up into seperate functions\n// one for connecting to flash , one for new client\n// clean up, flow is convoluted, and causes bugs\nuint8_t WiFiManager::connectWifi(String ssid, String pass, bool connect) {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Connecting as wifi client...\"));\n  #endif\n  uint8_t retry = 1;\n  uint8_t connRes = (uint8_t)WL_NO_SSID_AVAIL;\n\n  setSTAConfig();\n  //@todo catch failures in set_config\n  \n  // make sure sta is on before `begin` so it does not call enablesta->mode while persistent is ON ( which would save WM AP state to eeprom !)\n  // WiFi.setAutoReconnect(false);\n  if(_cleanConnect) WiFi_Disconnect(); // disconnect before begin, in case anything is hung, this causes a 2 seconds delay for connect\n  // @todo find out what status is when this is needed, can we detect it and handle it, say in between states or idle_status to avoid these\n\n  // if retry without delay (via begin()), the IDF is still busy even after returning status\n  // E (5130) wifi:sta is connecting, return error\n  // [E][WiFiSTA.cpp:221] begin(): connect failed!\n\n  while(retry <= _connectRetries && (connRes!=WL_CONNECTED)){\n  if(_connectRetries > 1){\n    if(_aggresiveReconn) delay(1000); // add idle time before recon\n    #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"Connect Wifi, ATTEMPT #\"),(String)retry+\" of \"+(String)_connectRetries); \n      #endif\n  }\n  // if ssid argument provided connect to that\n  // NOTE: this also catches preload() _defaultssid @todo rework\n  if (ssid != \"\") {\n    wifiConnectNew(ssid,pass,connect);\n    // @todo connect=false seems to disconnect sta in begin() so not sure if _connectonsave is useful at all\n    // skip wait if not connecting\n    // if(connect){\n      if(_saveTimeout > 0){\n        connRes = waitForConnectResult(_saveTimeout); // use default save timeout for saves to prevent bugs in esp->waitforconnectresult loop\n      }\n      else {\n         connRes = waitForConnectResult();\n      }\n    // }\n  }\n  else {\n    // connect using saved ssid if there is one\n    if (WiFi_hasAutoConnect()) {\n      wifiConnectDefault();\n      connRes = waitForConnectResult();\n    }\n    else {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"No wifi saved, skipping\"));\n      #endif\n    }\n  }\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Connection result:\"),getWLStatusString(connRes));\n  #endif\n  retry++;\n}\n\n// WPS enabled? https://github.com/esp8266/Arduino/pull/4889\n#ifdef NO_EXTRA_4K_HEAP\n  // do WPS, if WPS options enabled and not connected and no password was supplied\n  // @todo this seems like wrong place for this, is it a fallback or option?\n  if (_tryWPS && connRes != WL_CONNECTED && pass == \"\") {\n    startWPS();\n    // should be connected at the end of WPS\n    connRes = waitForConnectResult();\n  }\n#endif\n\n  if(connRes != WL_SCAN_COMPLETED){\n    updateConxResult(connRes);\n  }\n\n  return connRes;\n}\n\n/**\n * connect to a new wifi ap\n * @since $dev\n * @param  String ssid \n * @param  String pass \n * @return bool success\n * @return connect only save if false\n */\nbool WiFiManager::wifiConnectNew(String ssid, String pass,bool connect){\n  bool ret = false;\n  #ifdef WM_DEBUG_LEVEL\n  // DEBUG_WM(WM_DEBUG_DEV,F(\"CONNECTED: \"),WiFi.status() == WL_CONNECTED ? \"Y\" : \"NO\");\n  DEBUG_WM(F(\"Connecting to NEW AP:\"),ssid);\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Using Password:\"),pass);\n  #endif\n  WiFi_enableSTA(true,storeSTAmode); // storeSTAmode will also toggle STA on in default opmode (persistent) if true (default)\n  WiFi.persistent(true);\n  ret = WiFi.begin(ssid.c_str(), pass.c_str(), 0, NULL, connect);\n  WiFi.persistent(false);\n  #ifdef WM_DEBUG_LEVEL\n  if(!ret) DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] wifi begin failed\"));\n  #endif\n  return ret;\n}\n\n/**\n * connect to stored wifi\n * @since dev\n * @return bool success\n */\nbool WiFiManager::wifiConnectDefault(){\n  bool ret = false;\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"Connecting to SAVED AP:\"),WiFi_SSID(true));\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Using Password:\"),WiFi_psk(true));\n  #endif\n\n  ret = WiFi_enableSTA(true,storeSTAmode);\n  delay(500); // THIS DELAY ?\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Mode after delay: \"),getModeString(WiFi.getMode()));\n  if(!ret) DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] wifi enableSta failed\"));\n  #endif\n\n  ret = WiFi.begin();\n\n  #ifdef WM_DEBUG_LEVEL\n  if(!ret) DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] wifi begin failed\"));\n  #endif\n\n  return ret;\n}\n\n\n/**\n * set sta config if set\n * @since $dev\n * @return bool success\n */\nbool WiFiManager::setSTAConfig(){\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"STA static IP:\"),_sta_static_ip);  \n  #endif\n  bool ret = true;\n  if (_sta_static_ip) {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Custom static IP/GW/Subnet/DNS\"));\n      #endif\n    if(_sta_static_dns) {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Custom static DNS\"));\n      #endif\n      ret = WiFi.config(_sta_static_ip, _sta_static_gw, _sta_static_sn, _sta_static_dns);\n    }\n    else {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Custom STA IP/GW/Subnet\"));\n      #endif\n      ret = WiFi.config(_sta_static_ip, _sta_static_gw, _sta_static_sn);\n    }\n\n      #ifdef WM_DEBUG_LEVEL\n      if(!ret) DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] wifi config failed\"));\n      else DEBUG_WM(F(\"STA IP set:\"),WiFi.localIP());\n      #endif\n  } \n  else {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"setSTAConfig static ip not set, skipping\"));\n      #endif\n  }\n  return ret;\n}\n\n// @todo change to getLastFailureReason and do not touch conxresult\nvoid WiFiManager::updateConxResult(uint8_t status){\n  // hack in wrong password detection\n  _lastconxresult = status;\n    #ifdef ESP8266\n      if(_lastconxresult == WL_CONNECT_FAILED){\n        if(wifi_station_get_connect_status() == STATION_WRONG_PASSWORD){\n          _lastconxresult = WL_STATION_WRONG_PASSWORD;\n        }\n      }\n    #elif defined(ESP32)\n      // if(_lastconxresult == WL_CONNECT_FAILED){\n      if(_lastconxresult == WL_CONNECT_FAILED || _lastconxresult == WL_DISCONNECTED){\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_DEV,F(\"lastconxresulttmp:\"),getWLStatusString(_lastconxresulttmp));            \n        #endif\n        if(_lastconxresulttmp != WL_IDLE_STATUS){\n          _lastconxresult    = _lastconxresulttmp;\n          // _lastconxresulttmp = WL_IDLE_STATUS;\n        }\n      }\n    DEBUG_WM(WM_DEBUG_DEV,F(\"lastconxresult:\"),getWLStatusString(_lastconxresult));\n    #endif\n}\n\n \nuint8_t WiFiManager::waitForConnectResult() {\n  #ifdef WM_DEBUG_LEVEL\n  if(_connectTimeout > 0) DEBUG_WM(WM_DEBUG_DEV,_connectTimeout,F(\"ms connectTimeout set\")); \n  #endif\n  return waitForConnectResult(_connectTimeout);\n}\n\n/**\n * waitForConnectResult\n * @param  uint16_t timeout  in seconds\n * @return uint8_t  WL Status\n */\nuint8_t WiFiManager::waitForConnectResult(uint32_t timeout) {\n  if (timeout == 0){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"connectTimeout not set, ESP waitForConnectResult...\"));\n    #endif\n    return WiFi.waitForConnectResult();\n  }\n\n  unsigned long timeoutmillis = millis() + timeout;\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,timeout,F(\"ms timeout, waiting for connect...\"));\n  #endif\n  uint8_t status = WiFi.status();\n  \n  while(millis() < timeoutmillis) {\n    status = WiFi.status();\n    // @todo detect additional states, connect happens, then dhcp then get ip, there is some delay here, make sure not to timeout if waiting on IP\n    if (status == WL_CONNECTED || status == WL_CONNECT_FAILED) {\n      return status;\n    }\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM (WM_DEBUG_VERBOSE,F(\".\"));\n    #endif\n    delay(100);\n  }\n  return status;\n}\n\n// WPS enabled? https://github.com/esp8266/Arduino/pull/4889\n#ifdef NO_EXTRA_4K_HEAP\nvoid WiFiManager::startWPS() {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"START WPS\"));\n  #endif\n  #ifdef ESP8266  \n    WiFi.beginWPSConfig();\n  #else\n    // @todo\n  #endif\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"END WPS\"));\n  #endif\n}\n#endif\n\nString WiFiManager::getHTTPHead(String title, String classes){\n  String page;\n  page += FPSTR(HTTP_HEAD_START);\n  page.replace(FPSTR(T_v), title);\n  page += FPSTR(HTTP_SCRIPT);\n  page += FPSTR(HTTP_STYLE);\n  page += _customHeadElement;\n\n  String p = FPSTR(HTTP_HEAD_END);\n  if (_bodyClass != \"\") {\n    if (classes != \"\") {\n      classes += \" \";  // add spacing, if necessary\n    }\n    classes += _bodyClass;  // add class str\n  }\n  p.replace(FPSTR(T_c), classes);\n  page += p;\n\n  if (_customBodyHeader) {\n    page += _customBodyHeader;\n  }\n\n  return page;\n}\n\nString WiFiManager::getHTTPEnd() {\n  String end = FPSTR(HTTP_END);\n\n  if (_customBodyFooter) {\n    end = String(_customBodyFooter) + end;\n  }\n\n  return end;\n}\n\nvoid WiFiManager::HTTPSend(const String &content){\n  server->send(200, FPSTR(HTTP_HEAD_CT), content);\n}\n\n/** \n * HTTPD handler for page requests\n */\nvoid WiFiManager::handleRequest() {\n  _webPortalAccessed = millis();\n\n  // TESTING HTTPD AUTH RFC 2617\n  // BASIC_AUTH will hold onto creds, hard to \"logout\", but convienent\n  // DIGEST_AUTH will require new auth often, and nonce is random\n  // bool authenticate(const char * username, const char * password);\n  // bool authenticateDigest(const String& username, const String& H1);\n  // void requestAuthentication(HTTPAuthMethod mode = BASIC_AUTH, const char* realm = NULL, const String& authFailMsg = String(\"\") );\n\n  // 2.3 NO AUTH available\n  bool testauth = false;\n  if(!testauth) return;\n  \n  DEBUG_WM(WM_DEBUG_DEV,F(\"DOING AUTH\"));\n  bool res = server->authenticate(\"admin\",\"12345\");\n  if(!res){\n    #ifndef WM_NOAUTH\n    server->requestAuthentication(HTTPAuthMethod::BASIC_AUTH); // DIGEST_AUTH\n    #endif\n    DEBUG_WM(WM_DEBUG_DEV,F(\"AUTH FAIL\"));\n  }\n}\n\n/** \n * HTTPD CALLBACK root or redirect to captive portal\n */\nvoid WiFiManager::handleRoot() {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP Root\"));\n  #endif\n  if (captivePortal()) return; // If captive portal redirect instead of displaying the page\n  handleRequest();\n  String page = getHTTPHead(_title, FPSTR(C_root)); // @token options @todo replace options with title\n  String str  = FPSTR(HTTP_ROOT_MAIN); // @todo custom title\n  str.replace(FPSTR(T_t),_title);\n  str.replace(FPSTR(T_v),configPortalActive ? _apName : (getWiFiHostname() + \" - \" + WiFi.localIP().toString())); // use ip if ap is not active for heading @todo use hostname?\n  page += str;\n  page += FPSTR(HTTP_PORTAL_OPTIONS);\n  page += getMenuOut();\n  reportStatus(page);\n  page += getHTTPEnd();\n\n  HTTPSend(page);\n  if(_preloadwifiscan) WiFi_scanNetworks(_scancachetime,true); // preload wifiscan throttled, async\n  // @todo buggy, captive portals make a query on every page load, causing this to run every time in addition to the real page load\n  // I dont understand why, when you are already in the captive portal, I guess they want to know that its still up and not done or gone\n  // if we can detect these and ignore them that would be great, since they come from the captive portal redirect maybe there is a refferer\n}\n\n/**\n * HTTPD CALLBACK Wifi config page handler\n */\nvoid WiFiManager::handleWifi(boolean scan) {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP Wifi\"));\n  #endif\n  handleRequest();\n  String page = getHTTPHead(FPSTR(S_titlewifi), FPSTR(C_wifi)); // @token titlewifi\n  if (scan) {\n    #ifdef WM_DEBUG_LEVEL\n    // DEBUG_WM(WM_DEBUG_DEV,\"refresh flag:\",server->hasArg(F(\"refresh\")));\n    #endif\n    WiFi_scanNetworks(server->hasArg(F(\"refresh\")),false); //wifiscan, force if arg refresh\n    page += getScanItemOut();\n  }\n  String pitem = \"\";\n\n  pitem = FPSTR(HTTP_FORM_START);\n  pitem.replace(FPSTR(T_v), F(\"wifisave\")); // set form action\n  page += pitem;\n\n  pitem = FPSTR(HTTP_FORM_WIFI);\n  pitem.replace(FPSTR(T_v), WiFi_SSID());\n\n  if(_showPassword){\n    pitem.replace(FPSTR(T_p), WiFi_psk());\n  }\n  else if(WiFi_psk() != \"\"){\n    pitem.replace(FPSTR(T_p),FPSTR(S_passph));    \n  }\n  else {\n    pitem.replace(FPSTR(T_p),\"\");    \n  }\n\n  page += pitem;\n\n  page += getStaticOut();\n  page += FPSTR(HTTP_FORM_WIFI_END);\n  if(_paramsInWifi && _paramsCount>0){\n    page += FPSTR(HTTP_FORM_PARAM_HEAD);\n    page += getParamOut();\n  }\n  page += FPSTR(HTTP_FORM_END);\n  page += FPSTR(HTTP_SCAN_LINK);\n  if(_showBack) page += FPSTR(HTTP_BACKBTN);\n  reportStatus(page);\n  page += getHTTPEnd();\n\n  HTTPSend(page);\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Sent config page\"));\n  #endif\n}\n\n/**\n * HTTPD CALLBACK Wifi param page handler\n */\nvoid WiFiManager::handleParam(){\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP Param\"));\n  #endif\n  handleRequest();\n  String page = getHTTPHead(FPSTR(S_titleparam), FPSTR(C_param)); // @token titlewifi\n\n  String pitem = \"\";\n\n  pitem = FPSTR(HTTP_FORM_START);\n  pitem.replace(FPSTR(T_v), F(\"paramsave\"));\n  page += pitem;\n\n  page += getParamOut();\n  page += FPSTR(HTTP_FORM_END);\n  if(_showBack) page += FPSTR(HTTP_BACKBTN);\n  reportStatus(page);\n  page += getHTTPEnd();\n\n  HTTPSend(page);\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Sent param page\"));\n  #endif\n}\n\n\nString WiFiManager::getMenuOut(){\n  String page;  \n\n  for(auto menuId :_menuIds ){\n    if((String)_menutokens[menuId] == \"param\" && _paramsCount == 0) continue; // no params set, omit params from menu, @todo this may be undesired by someone, use only menu to force?\n    if((String)_menutokens[menuId] == \"custom\" && _customMenuHTML!=NULL){\n      page += _customMenuHTML;\n      continue;\n    }\n    page += HTTP_PORTAL_MENU[menuId];\n    delay(0);\n  }\n\n  return page;\n}\n\n// // is it possible in softap mode to detect aps without scanning\n// bool WiFiManager::WiFi_scanNetworksForAP(bool force){\n//   WiFi_scanNetworks(force);\n// }\n\nvoid WiFiManager::WiFi_scanComplete(int networksFound){\n  _lastscan = millis();\n  _numNetworks = networksFound;\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Scan ASYNC completed\"), \"in \"+(String)(_lastscan - _startscan)+\" ms\");  \n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Scan ASYNC found:\"),_numNetworks);\n  #endif\n}\n\nbool WiFiManager::WiFi_scanNetworks(){\n  return WiFi_scanNetworks(false,false);\n}\n \nbool WiFiManager::WiFi_scanNetworks(unsigned int cachetime,bool async){\n    return WiFi_scanNetworks(millis()-_lastscan > cachetime,async);\n}\nbool WiFiManager::WiFi_scanNetworks(unsigned int cachetime){\n    return WiFi_scanNetworks(millis()-_lastscan > cachetime,false);\n}\nbool WiFiManager::WiFi_scanNetworks(bool force,bool async){\n    #ifdef WM_DEBUG_LEVEL\n    // DEBUG_WM(WM_DEBUG_DEV,\"scanNetworks async:\",async == true);\n    // DEBUG_WM(WM_DEBUG_DEV,_numNetworks,(millis()-_lastscan ));\n    // DEBUG_WM(WM_DEBUG_DEV,\"scanNetworks force:\",force == true);\n    #endif\n\n    // if 0 networks, rescan @note this was a kludge, now disabling to test real cause ( maybe wifi not init etc)\n    // enable only if preload failed? \n    if(_numNetworks == 0 && _autoforcerescan){\n      DEBUG_WM(WM_DEBUG_DEV,\"NO APs found forcing new scan\");\n      force = true;\n    }\n\n    // if scan is empty or stale (last scantime > _scancachetime), this avoids fast reloading wifi page and constant scan delayed page loads appearing to freeze.\n    if(!_lastscan || (_lastscan>0 && (millis()-_lastscan > _scancachetime))){\n      force = true;\n    }\n\n    if(force){\n      int8_t res;\n      _startscan = millis();\n      if(async && _asyncScan){\n        #ifdef ESP8266\n          #ifndef WM_NOASYNC // no async available < 2.4.0\n          #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Scan ASYNC started\"));\n          #endif\n          using namespace std::placeholders; // for `_1`\n          WiFi.scanNetworksAsync(std::bind(&WiFiManager::WiFi_scanComplete,this,_1));\n          #else\n          DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Scan SYNC started\"));\n          res = WiFi.scanNetworks();\n          #endif\n        #else\n        #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Scan ASYNC started\"));\n          #endif\n          res = WiFi.scanNetworks(true);\n        #endif\n        return false;\n      }\n      else{\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Scan SYNC started\"));\n        res = WiFi.scanNetworks();\n      }\n      if(res == WIFI_SCAN_FAILED){\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] scan failed\"));\n        #endif\n      }  \n      else if(res == WIFI_SCAN_RUNNING){\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] scan waiting\"));\n        #endif\n        while(WiFi.scanComplete() == WIFI_SCAN_RUNNING){\n          #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_ERROR,\".\");\n          #endif\n          delay(100);\n        }\n        _numNetworks = WiFi.scanComplete();\n      }\n      else if(res >=0 ) _numNetworks = res;\n      _lastscan = millis();\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFi Scan completed\"), \"in \"+(String)(_lastscan - _startscan)+\" ms\");\n      #endif\n      return true;\n    }\n    else {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Scan is cached\"),(String)(millis()-_lastscan )+\" ms ago\");\n      #endif\n    }\n    return false;\n}\n\nString WiFiManager::WiFiManager::getScanItemOut(){\n    String page;\n\n    if(!_numNetworks) WiFi_scanNetworks(); // scan in case this gets called before any scans\n\n    int n = _numNetworks;\n    if (n == 0) {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"No networks found\"));\n      #endif\n      page += FPSTR(S_nonetworks); // @token nonetworks\n      page += F(\"<br/><br/>\");\n    }\n    else {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(n,F(\"networks found\"));\n      #endif\n      //sort networks\n      int indices[n];\n      for (int i = 0; i < n; i++) {\n        indices[i] = i;\n      }\n\n      // RSSI SORT\n      for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n          if (WiFi.RSSI(indices[j]) > WiFi.RSSI(indices[i])) {\n            std::swap(indices[i], indices[j]);\n          }\n        }\n      }\n\n      /* test std:sort\n        std::sort(indices, indices + n, [](const int & a, const int & b) -> bool\n        {\n        return WiFi.RSSI(a) > WiFi.RSSI(b);\n        });\n       */\n\n      // remove duplicates ( must be RSSI sorted )\n      if (_removeDuplicateAPs) {\n        String cssid;\n        for (int i = 0; i < n; i++) {\n          if (indices[i] == -1) continue;\n          cssid = WiFi.SSID(indices[i]);\n          for (int j = i + 1; j < n; j++) {\n            if (cssid == WiFi.SSID(indices[j])) {\n              #ifdef WM_DEBUG_LEVEL\n              DEBUG_WM(WM_DEBUG_VERBOSE,F(\"DUP AP:\"),WiFi.SSID(indices[j]));\n              #endif\n              indices[j] = -1; // set dup aps to index -1\n            }\n          }\n        }\n      }\n\n      // token precheck, to speed up replacements on large ap lists\n      String HTTP_ITEM_STR = FPSTR(HTTP_ITEM);\n\n      // toggle icons with percentage\n      HTTP_ITEM_STR.replace(\"{qp}\", FPSTR(HTTP_ITEM_QP));\n      HTTP_ITEM_STR.replace(\"{h}\",_scanDispOptions ? \"\" : \"h\");\n      HTTP_ITEM_STR.replace(\"{qi}\", FPSTR(HTTP_ITEM_QI));\n      HTTP_ITEM_STR.replace(\"{h}\",_scanDispOptions ? \"h\" : \"\");\n \n      // set token precheck flags\n      bool tok_r = HTTP_ITEM_STR.indexOf(FPSTR(T_r)) > 0;\n      bool tok_R = HTTP_ITEM_STR.indexOf(FPSTR(T_R)) > 0;\n      bool tok_e = HTTP_ITEM_STR.indexOf(FPSTR(T_e)) > 0;\n      bool tok_q = HTTP_ITEM_STR.indexOf(FPSTR(T_q)) > 0;\n      bool tok_i = HTTP_ITEM_STR.indexOf(FPSTR(T_i)) > 0;\n      \n      //display networks in page\n      for (int i = 0; i < n; i++) {\n        if (indices[i] == -1) continue; // skip dups\n\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"AP: \"),(String)WiFi.RSSI(indices[i]) + \" \" + (String)WiFi.SSID(indices[i]));\n        #endif\n\n        int rssiperc = getRSSIasQuality(WiFi.RSSI(indices[i]));\n        uint8_t enc_type = WiFi.encryptionType(indices[i]);\n\n        if (_minimumQuality == -1 || _minimumQuality < rssiperc) {\n          String item = HTTP_ITEM_STR;\n          if(WiFi.SSID(indices[i]) == \"\"){\n            // Serial.println(WiFi.BSSIDstr(indices[i]));\n            continue; // No idea why I am seeing these, lets just skip them for now\n          }\n          item.replace(FPSTR(T_V), htmlEntities(WiFi.SSID(indices[i]))); // ssid no encoding\n          item.replace(FPSTR(T_v), htmlEntities(WiFi.SSID(indices[i]),true)); // ssid no encoding\n          if(tok_e) item.replace(FPSTR(T_e), encryptionTypeStr(enc_type));\n          if(tok_r) item.replace(FPSTR(T_r), (String)rssiperc); // rssi percentage 0-100\n          if(tok_R) item.replace(FPSTR(T_R), (String)WiFi.RSSI(indices[i])); // rssi db\n          if(tok_q) item.replace(FPSTR(T_q), (String)int(round(map(rssiperc,0,100,1,4)))); //quality icon 1-4\n          if(tok_i){\n            if (enc_type != WM_WIFIOPEN) {\n              item.replace(FPSTR(T_i), F(\"l\"));\n            } else {\n              item.replace(FPSTR(T_i), \"\");\n            }\n          }\n          #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_DEV,item);\n          #endif\n          page += item;\n          delay(0);\n        } else {\n          #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Skipping , does not meet _minimumQuality\"));\n          #endif\n        }\n\n      }\n      page += FPSTR(HTTP_BR);\n    }\n\n    return page;\n}\n\nString WiFiManager::getIpForm(String id, String title, String value){\n    String item = FPSTR(HTTP_FORM_LABEL);\n    item += FPSTR(HTTP_FORM_PARAM);\n    item.replace(FPSTR(T_i), id);\n    item.replace(FPSTR(T_n), id);\n    item.replace(FPSTR(T_p), FPSTR(T_t));\n    // item.replace(FPSTR(T_p), default);\n    item.replace(FPSTR(T_t), title);\n    item.replace(FPSTR(T_l), F(\"15\"));\n    item.replace(FPSTR(T_v), value);\n    item.replace(FPSTR(T_c), \"\");\n    return item;  \n}\n\nString WiFiManager::getStaticOut(){\n  String page;\n  if ((_staShowStaticFields || _sta_static_ip) && _staShowStaticFields>=0) {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"_staShowStaticFields\"));\n    #endif\n    page += FPSTR(HTTP_FORM_STATIC_HEAD);\n    // @todo how can we get these accurate settings from memory , wifi_get_ip_info does not seem to reveal if struct ip_info is static or not\n    page += getIpForm(FPSTR(S_ip),FPSTR(S_staticip),(_sta_static_ip ? _sta_static_ip.toString() : \"\")); // @token staticip\n    // WiFi.localIP().toString();\n    page += getIpForm(FPSTR(S_gw),FPSTR(S_staticgw),(_sta_static_gw ? _sta_static_gw.toString() : \"\")); // @token staticgw\n    // WiFi.gatewayIP().toString();\n    page += getIpForm(FPSTR(S_sn),FPSTR(S_subnet),(_sta_static_sn ? _sta_static_sn.toString() : \"\")); // @token subnet\n    // WiFi.subnetMask().toString();\n  }\n\n  if((_staShowDns || _sta_static_dns) && _staShowDns>=0){\n    page += getIpForm(FPSTR(S_dns),FPSTR(S_staticdns),(_sta_static_dns ? _sta_static_dns.toString() : \"\")); // @token dns\n  }\n\n  if(page!=\"\") page += FPSTR(HTTP_BR); // @todo remove these, use css\n\n  return page;\n}\n\nString WiFiManager::getParamOut(){\n  String page;\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"getParamOut\"),_paramsCount);\n  #endif\n\n  if(_paramsCount > 0){\n\n    String HTTP_PARAM_temp = FPSTR(HTTP_FORM_LABEL);\n    HTTP_PARAM_temp += FPSTR(HTTP_FORM_PARAM);\n    bool tok_I = HTTP_PARAM_temp.indexOf(FPSTR(T_I)) > 0;\n    bool tok_i = HTTP_PARAM_temp.indexOf(FPSTR(T_i)) > 0;\n    bool tok_n = HTTP_PARAM_temp.indexOf(FPSTR(T_n)) > 0;\n    bool tok_p = HTTP_PARAM_temp.indexOf(FPSTR(T_p)) > 0;\n    bool tok_t = HTTP_PARAM_temp.indexOf(FPSTR(T_t)) > 0;\n    bool tok_l = HTTP_PARAM_temp.indexOf(FPSTR(T_l)) > 0;\n    bool tok_v = HTTP_PARAM_temp.indexOf(FPSTR(T_v)) > 0;\n    bool tok_c = HTTP_PARAM_temp.indexOf(FPSTR(T_c)) > 0;\n\n    char valLength[5];\n\n    for (int i = 0; i < _paramsCount; i++) {\n      //Serial.println((String)_params[i]->_length);\n      if (_params[i] == NULL || _params[i]->_length > 99999) {\n        // try to detect param scope issues, doesnt always catch but works ok\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] WiFiManagerParameter is out of scope\"));\n        #endif\n        return \"\";\n      }\n    }\n\n    // add the extra parameters to the form\n    for (int i = 0; i < _paramsCount; i++) {\n     // label before or after, @todo this could be done via floats or CSS and eliminated\n     String pitem;\n      switch (_params[i]->getLabelPlacement()) {\n        case WFM_LABEL_BEFORE:\n          pitem = FPSTR(HTTP_FORM_LABEL);\n          pitem += FPSTR(HTTP_FORM_PARAM);\n          break;\n        case WFM_LABEL_AFTER:\n          pitem = FPSTR(HTTP_FORM_PARAM);\n          pitem += FPSTR(HTTP_FORM_LABEL);\n          break;\n        default:\n          // WFM_NO_LABEL\n          pitem = FPSTR(HTTP_FORM_PARAM);\n          break;\n      }\n\n      // Input templating\n      // \"<br/><input id='{i}' name='{n}' maxlength='{l}' value='{v}' {c}>\";\n      // if no ID use customhtml for item, else generate from param string\n      if (_params[i]->getID() != NULL) {\n        if(tok_I)pitem.replace(FPSTR(T_I), (String)FPSTR(S_parampre)+(String)i); // T_I id number\n        if(tok_i)pitem.replace(FPSTR(T_i), _params[i]->getID()); // T_i id name\n        if(tok_n)pitem.replace(FPSTR(T_n), _params[i]->getID()); // T_n id name alias\n        if(tok_p)pitem.replace(FPSTR(T_p), FPSTR(T_t)); // T_p replace legacy placeholder token\n        if(tok_t)pitem.replace(FPSTR(T_t), _params[i]->getLabel()); // T_t title/label\n        snprintf(valLength, 5, \"%d\", _params[i]->getValueLength());\n        if(tok_l)pitem.replace(FPSTR(T_l), valLength); // T_l value length\n        if(tok_v)pitem.replace(FPSTR(T_v), _params[i]->getValue()); // T_v value\n        if(tok_c)pitem.replace(FPSTR(T_c), _params[i]->getCustomHTML()); // T_c meant for additional attributes, not html, but can stuff\n      } else {\n        pitem = _params[i]->getCustomHTML();\n      }\n\n      page += pitem;\n    }\n  }\n\n  return page;\n}\n\nvoid WiFiManager::handleWiFiStatus(){\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP WiFi status \"));\n  #endif\n  handleRequest();\n  String page;\n  // String page = \"{\\\"result\\\":true,\\\"count\\\":1}\";\n  #ifdef WM_JSTEST\n    page = FPSTR(HTTP_JS);\n  #endif\n  HTTPSend(page);\n}\n\n/** \n * HTTPD CALLBACK save form and redirect to WLAN config page again\n */\nvoid WiFiManager::handleWifiSave() {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP WiFi save \"));\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Method:\"),server->method() == HTTP_GET  ? (String)FPSTR(S_GET) : (String)FPSTR(S_POST));\n  #endif\n  handleRequest();\n\n  //SAVE/connect here\n  _ssid = server->arg(F(\"s\")).c_str();\n  _pass = server->arg(F(\"p\")).c_str();\n\n  if(_ssid == \"\" && _pass != \"\"){\n    _ssid = WiFi_SSID(true); // password change, placeholder ssid, @todo compare pass to old?, confirm ssid is clean\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Detected WiFi password change\"));\n    #endif    \n  }\n\n  #ifdef WM_DEBUG_LEVEL\n  String requestinfo = \"SERVER_REQUEST\\n----------------\\n\";\n  requestinfo += \"URI: \";\n  requestinfo += server->uri();\n  requestinfo += \"\\nMethod: \";\n  requestinfo += (server->method() == HTTP_GET) ? \"GET\" : \"POST\";\n  requestinfo += \"\\nArguments: \";\n  requestinfo += server->args();\n  requestinfo += \"\\n\";\n  for (uint8_t i = 0; i < server->args(); i++) {\n    requestinfo += \" \" + server->argName(i) + \": \" + server->arg(i) + \"\\n\";\n  }\n\n  DEBUG_WM(WM_DEBUG_MAX,requestinfo);\n  #endif\n\n  // set static ips from server args\n  if (server->arg(FPSTR(S_ip)) != \"\") {\n    //_sta_static_ip.fromString(server->arg(FPSTR(S_ip));\n    String ip = server->arg(FPSTR(S_ip));\n    optionalIPFromString(&_sta_static_ip, ip.c_str());\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"static ip:\"),ip);\n    #endif\n  }\n  if (server->arg(FPSTR(S_gw)) != \"\") {\n    String gw = server->arg(FPSTR(S_gw));\n    optionalIPFromString(&_sta_static_gw, gw.c_str());\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"static gateway:\"),gw);\n    #endif\n  }\n  if (server->arg(FPSTR(S_sn)) != \"\") {\n    String sn = server->arg(FPSTR(S_sn));\n    optionalIPFromString(&_sta_static_sn, sn.c_str());\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"static netmask:\"),sn);\n    #endif\n  }\n  if (server->arg(FPSTR(S_dns)) != \"\") {\n    String dns = server->arg(FPSTR(S_dns));\n    optionalIPFromString(&_sta_static_dns, dns.c_str());\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"static DNS:\"),dns);\n    #endif\n  }\n\n  if (_presavewificallback != NULL) {\n    _presavewificallback();  // @CALLBACK \n  }\n\n  if(_paramsInWifi) doParamSave();\n\n  String page;\n\n  if(_ssid == \"\"){\n    page = getHTTPHead(FPSTR(S_titlewifisettings), FPSTR(C_wifi)); // @token titleparamsaved\n    page += FPSTR(HTTP_PARAMSAVED);\n  }\n  else {\n    page = getHTTPHead(FPSTR(S_titlewifisaved), FPSTR(C_wifi)); // @token titlewifisaved\n    page += FPSTR(HTTP_SAVED);\n  }\n\n  if(_showBack) page += FPSTR(HTTP_BACKBTN);\n  page += getHTTPEnd();\n\n  server->sendHeader(FPSTR(HTTP_HEAD_CORS), FPSTR(HTTP_HEAD_CORS_ALLOW_ALL)); // @HTTPHEAD send cors\n  HTTPSend(page);\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Sent wifi save page\"));\n  #endif\n\n  connect = true; //signal ready to connect/reset process in processConfigPortal\n}\n\nvoid WiFiManager::handleParamSave() {\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP Param save \"));\n  #endif\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Method:\"),server->method() == HTTP_GET  ? (String)FPSTR(S_GET) : (String)FPSTR(S_POST));\n  #endif\n  handleRequest();\n\n  doParamSave();\n\n  String page = getHTTPHead(FPSTR(S_titleparamsaved), FPSTR(C_param)); // @token titleparamsaved\n  page += FPSTR(HTTP_PARAMSAVED);\n  if(_showBack) page += FPSTR(HTTP_BACKBTN); \n  page += getHTTPEnd();\n\n  HTTPSend(page);\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Sent param save page\"));\n  #endif\n}\n\nvoid WiFiManager::doParamSave(){\n   // @todo use new callback for before paramsaves, is this really needed?\n  if ( _presaveparamscallback != NULL) {\n    _presaveparamscallback();  // @CALLBACK\n  }\n\n  //parameters\n  if(_paramsCount > 0){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Parameters\"));\n    DEBUG_WM(WM_DEBUG_VERBOSE,FPSTR(D_HR));\n    #endif\n\n    for (int i = 0; i < _paramsCount; i++) {\n      if (_params[i] == NULL || _params[i]->_length > 99999) {\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] WiFiManagerParameter is out of scope\"));\n        #endif\n        break; // @todo might not be needed anymore\n      }\n      //read parameter from server\n      String name = (String)FPSTR(S_parampre)+(String)i;\n      String value;\n      if(server->hasArg(name)) {\n        value = server->arg(name);\n      } else {\n        value = server->arg(_params[i]->getID());\n      }\n\n      //store it in params array\n      value.toCharArray(_params[i]->_value, _params[i]->_length+1); // length+1 null terminated\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,(String)_params[i]->getID() + \":\",value);\n      #endif\n    }\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,FPSTR(D_HR));\n    #endif\n  }\n\n   if ( _saveparamscallback != NULL) {\n    _saveparamscallback();  // @CALLBACK\n  }\n   \n}\n\n/** \n * HTTPD CALLBACK info page\n */\nvoid WiFiManager::handleInfo() {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP Info\"));\n  #endif\n  handleRequest();\n  String page = getHTTPHead(FPSTR(S_titleinfo), FPSTR(C_info)); // @token titleinfo\n  reportStatus(page);\n\n  uint16_t infos = 0;\n\n  //@todo convert to enum or refactor to strings\n  //@todo wrap in build flag to remove all info code for memory saving\n  #ifdef ESP8266\n    infos = 28;\n    String infoids[] = {\n      F(\"esphead\"),\n      F(\"uptime\"),\n      F(\"chipid\"),\n      F(\"fchipid\"),\n      F(\"idesize\"),\n      F(\"flashsize\"),\n      F(\"corever\"),\n      F(\"bootver\"),\n      F(\"cpufreq\"),\n      F(\"freeheap\"),\n      F(\"memsketch\"),\n      F(\"memsmeter\"),\n      F(\"lastreset\"),\n      F(\"wifihead\"),\n      F(\"conx\"),\n      F(\"stassid\"),\n      F(\"staip\"),\n      F(\"stagw\"),\n      F(\"stasub\"),\n      F(\"dnss\"),\n      F(\"host\"),\n      F(\"stamac\"),\n      F(\"autoconx\"),\n      F(\"wifiaphead\"),\n      F(\"apssid\"),\n      F(\"apip\"),\n      F(\"apbssid\"),\n      F(\"apmac\")\n    };\n\n  #elif defined(ESP32)\n    // add esp_chip_info ?\n    infos = 27;\n    String infoids[] = {\n      F(\"esphead\"),\n      F(\"uptime\"),\n      F(\"chipid\"),\n      F(\"chiprev\"),\n      F(\"idesize\"),\n      F(\"flashsize\"),      \n      F(\"cpufreq\"),\n      F(\"freeheap\"),\n      F(\"memsketch\"),\n      F(\"memsmeter\"),      \n      F(\"lastreset\"),\n      F(\"temp\"),\n      // F(\"hall\"),\n      F(\"wifihead\"),\n      F(\"conx\"),\n      F(\"stassid\"),\n      F(\"staip\"),\n      F(\"stagw\"),\n      F(\"stasub\"),\n      F(\"dnss\"),\n      F(\"host\"),\n      F(\"stamac\"),\n      F(\"apssid\"),\n      F(\"wifiaphead\"),\n      F(\"apip\"),\n      F(\"apmac\"),\n      F(\"aphost\"),\n      F(\"apbssid\")\n    };\n  #endif\n\n  for(size_t i=0; i<infos;i++){\n    if(infoids[i] != NULL) page += getInfoData(infoids[i]);\n  }\n  page += F(\"</dl>\");\n\n  page += F(\"<h3>About</h3><hr><dl>\");\n  page += getInfoData(\"aboutver\");\n  page += getInfoData(\"aboutarduinover\");\n  page += getInfoData(\"aboutidfver\");\n  page += getInfoData(\"aboutdate\");\n  page += F(\"</dl>\");\n\n  if(_showInfoUpdate){\n    page += HTTP_PORTAL_MENU[8];\n    page += HTTP_PORTAL_MENU[9];\n  }\n  if(_showInfoErase) page += FPSTR(HTTP_ERASEBTN);\n  if(_showBack) page += FPSTR(HTTP_BACKBTN);\n  page += FPSTR(HTTP_HELP);\n  page += getHTTPEnd();\n\n  HTTPSend(page);\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,F(\"Sent info page\"));\n  #endif\n}\n\nString WiFiManager::getInfoData(String id){\n\n  String p;\n  if(id==F(\"esphead\")){\n    p = FPSTR(HTTP_INFO_esphead);\n    #ifdef ESP32\n      p.replace(FPSTR(T_1), (String)ESP.getChipModel());\n    #endif\n  }\n  else if(id==F(\"wifihead\")){\n    p = FPSTR(HTTP_INFO_wifihead);\n    p.replace(FPSTR(T_1),getModeString(WiFi.getMode()));\n  }\n  else if(id==F(\"uptime\")){\n    // subject to rollover!\n    p = FPSTR(HTTP_INFO_uptime);\n    p.replace(FPSTR(T_1),(String)(millis() / 1000 / 60));\n    p.replace(FPSTR(T_2),(String)((millis() / 1000) % 60));\n  }\n  else if(id==F(\"chipid\")){\n    p = FPSTR(HTTP_INFO_chipid);\n    p.replace(FPSTR(T_1),String(WIFI_getChipId(),HEX));\n  }\n  #ifdef ESP32\n  else if(id==F(\"chiprev\")){\n      p = FPSTR(HTTP_INFO_chiprev);\n      String rev = (String)ESP.getChipRevision();\n      #ifdef _SOC_EFUSE_REG_H_\n        String revb = (String)(REG_READ(EFUSE_BLK0_RDATA3_REG) >> (EFUSE_RD_CHIP_VER_RESERVE_S)&&EFUSE_RD_CHIP_VER_RESERVE_V);\n        p.replace(FPSTR(T_1),rev+\"<br/>\"+revb);\n      #else\n        p.replace(FPSTR(T_1),rev);\n      #endif\n  }\n  #endif\n  #ifdef ESP8266\n  else if(id==F(\"fchipid\")){\n      p = FPSTR(HTTP_INFO_fchipid);\n      p.replace(FPSTR(T_1),(String)ESP.getFlashChipId());\n  }\n  #endif\n  else if(id==F(\"idesize\")){\n    p = FPSTR(HTTP_INFO_idesize);\n    p.replace(FPSTR(T_1),(String)ESP.getFlashChipSize());\n  }\n  else if(id==F(\"flashsize\")){\n    #ifdef ESP8266\n      p = FPSTR(HTTP_INFO_flashsize);\n      p.replace(FPSTR(T_1),(String)ESP.getFlashChipRealSize());\n    #elif defined ESP32\n      p = FPSTR(HTTP_INFO_psrsize);\n      p.replace(FPSTR(T_1),(String)ESP.getPsramSize());      \n    #endif\n  }\n  else if(id==F(\"corever\")){\n    #ifdef ESP8266\n      p = FPSTR(HTTP_INFO_corever);\n      p.replace(FPSTR(T_1),(String)ESP.getCoreVersion());\n    #endif      \n  }\n  #ifdef ESP8266\n  else if(id==F(\"bootver\")){\n      p = FPSTR(HTTP_INFO_bootver);\n      p.replace(FPSTR(T_1),(String)system_get_boot_version());\n  }\n  #endif\n  else if(id==F(\"cpufreq\")){\n    p = FPSTR(HTTP_INFO_cpufreq);\n    p.replace(FPSTR(T_1),(String)ESP.getCpuFreqMHz());\n  }\n  else if(id==F(\"freeheap\")){\n    p = FPSTR(HTTP_INFO_freeheap);\n    p.replace(FPSTR(T_1),(String)ESP.getFreeHeap());\n  }\n  else if(id==F(\"memsketch\")){\n    p = FPSTR(HTTP_INFO_memsketch);\n    p.replace(FPSTR(T_1),(String)(ESP.getSketchSize()));\n    p.replace(FPSTR(T_2),(String)(ESP.getSketchSize()+ESP.getFreeSketchSpace()));\n  }\n  else if(id==F(\"memsmeter\")){\n    p = FPSTR(HTTP_INFO_memsmeter);\n    p.replace(FPSTR(T_1),(String)(ESP.getSketchSize()));\n    p.replace(FPSTR(T_2),(String)(ESP.getSketchSize()+ESP.getFreeSketchSpace()));\n  }\n  else if(id==F(\"lastreset\")){\n    #ifdef ESP8266\n      p = FPSTR(HTTP_INFO_lastreset);\n      p.replace(FPSTR(T_1),(String)ESP.getResetReason());\n    #elif defined(ESP32) && defined(_ROM_RTC_H_)\n      // requires #include <rom/rtc.h>\n      p = FPSTR(HTTP_INFO_lastreset);\n      for(int i=0;i<2;i++){\n        int reason = rtc_get_reset_reason(i);\n        String tok = (String)T_ss+(String)(i+1)+(String)T_es;\n        switch (reason)\n        {\n          //@todo move to array\n          case 1  : p.replace(tok,F(\"Vbat power on reset\"));break;\n          case 3  : p.replace(tok,F(\"Software reset digital core\"));break;\n          case 4  : p.replace(tok,F(\"Legacy watch dog reset digital core\"));break;\n          case 5  : p.replace(tok,F(\"Deep Sleep reset digital core\"));break;\n          case 6  : p.replace(tok,F(\"Reset by SLC module, reset digital core\"));break;\n          case 7  : p.replace(tok,F(\"Timer Group0 Watch dog reset digital core\"));break;\n          case 8  : p.replace(tok,F(\"Timer Group1 Watch dog reset digital core\"));break;\n          case 9  : p.replace(tok,F(\"RTC Watch dog Reset digital core\"));break;\n          case 10 : p.replace(tok,F(\"Instrusion tested to reset CPU\"));break;\n          case 11 : p.replace(tok,F(\"Time Group reset CPU\"));break;\n          case 12 : p.replace(tok,F(\"Software reset CPU\"));break;\n          case 13 : p.replace(tok,F(\"RTC Watch dog Reset CPU\"));break;\n          case 14 : p.replace(tok,F(\"for APP CPU, reseted by PRO CPU\"));break;\n          case 15 : p.replace(tok,F(\"Reset when the vdd voltage is not stable\"));break;\n          case 16 : p.replace(tok,F(\"RTC Watch dog reset digital core and rtc module\"));break;\n          default : p.replace(tok,F(\"NO_MEAN\"));\n        }\n      }\n    #endif\n  }\n  else if(id==F(\"apip\")){\n    p = FPSTR(HTTP_INFO_apip);\n    p.replace(FPSTR(T_1),WiFi.softAPIP().toString());\n  }\n  else if(id==F(\"apmac\")){\n    p = FPSTR(HTTP_INFO_apmac);\n    p.replace(FPSTR(T_1),(String)WiFi.softAPmacAddress());\n  }\n  #ifdef ESP32\n  else if(id==F(\"aphost\")){\n      p = FPSTR(HTTP_INFO_aphost);\n      p.replace(FPSTR(T_1),WiFi.softAPgetHostname());\n  }\n  #endif\n  #ifndef WM_NOSOFTAPSSID\n  #ifdef ESP8266\n  else if(id==F(\"apssid\")){\n    p = FPSTR(HTTP_INFO_apssid);\n    p.replace(FPSTR(T_1),htmlEntities(WiFi.softAPSSID()));\n  }\n  #endif\n  #endif\n  else if(id==F(\"apbssid\")){\n    p = FPSTR(HTTP_INFO_apbssid);\n    p.replace(FPSTR(T_1),(String)WiFi.BSSIDstr());\n  }\n  // softAPgetHostname // esp32\n  // softAPSubnetCIDR\n  // softAPNetworkID\n  // softAPBroadcastIP\n\n  else if(id==F(\"stassid\")){\n    p = FPSTR(HTTP_INFO_stassid);\n    p.replace(FPSTR(T_1),htmlEntities((String)WiFi_SSID()));\n  }\n  else if(id==F(\"staip\")){\n    p = FPSTR(HTTP_INFO_staip);\n    p.replace(FPSTR(T_1),WiFi.localIP().toString());\n  }\n  else if(id==F(\"stagw\")){\n    p = FPSTR(HTTP_INFO_stagw);\n    p.replace(FPSTR(T_1),WiFi.gatewayIP().toString());\n  }\n  else if(id==F(\"stasub\")){\n    p = FPSTR(HTTP_INFO_stasub);\n    p.replace(FPSTR(T_1),WiFi.subnetMask().toString());\n  }\n  else if(id==F(\"dnss\")){\n    p = FPSTR(HTTP_INFO_dnss);\n    p.replace(FPSTR(T_1),WiFi.dnsIP().toString());\n  }\n  else if(id==F(\"host\")){\n    p = FPSTR(HTTP_INFO_host);\n    #ifdef ESP32\n      p.replace(FPSTR(T_1),WiFi.getHostname());\n    #else\n    p.replace(FPSTR(T_1),WiFi.hostname());\n    #endif\n  }\n  else if(id==F(\"stamac\")){\n    p = FPSTR(HTTP_INFO_stamac);\n    p.replace(FPSTR(T_1),WiFi.macAddress());\n  }\n  else if(id==F(\"conx\")){\n    p = FPSTR(HTTP_INFO_conx);\n    p.replace(FPSTR(T_1),WiFi.isConnected() ? FPSTR(S_y) : FPSTR(S_n));\n  }\n  #ifdef ESP8266\n  else if(id==F(\"autoconx\")){\n    p = FPSTR(HTTP_INFO_autoconx);\n    p.replace(FPSTR(T_1),WiFi.getAutoConnect() ? FPSTR(S_enable) : FPSTR(S_disable));\n  }\n  #endif\n  #if defined(ESP32) && !defined(WM_NOTEMP)\n  else if(id==F(\"temp\")){\n    // temperature is not calibrated, varying large offsets are present, use for relative temp changes only\n    p = FPSTR(HTTP_INFO_temp);\n    p.replace(FPSTR(T_1),(String)temperatureRead());\n    p.replace(FPSTR(T_2),(String)((temperatureRead()+32)*1.8f));\n  }\n  // else if(id==F(\"hall\")){ \n  //   p = FPSTR(HTTP_INFO_hall);\n  //   p.replace(FPSTR(T_1),(String)hallRead()); // hall sensor reads can cause issues with adcs\n  // }\n  #endif\n  else if(id==F(\"aboutver\")){\n    p = FPSTR(HTTP_INFO_aboutver);\n    p.replace(FPSTR(T_1),FPSTR(WM_VERSION_STR));\n  }\n  else if(id==F(\"aboutarduinover\")){\n    #ifdef VER_ARDUINO_STR\n    p = FPSTR(HTTP_INFO_aboutarduino);\n    p.replace(FPSTR(T_1),String(VER_ARDUINO_STR));\n    #endif\n  }\n  // else if(id==F(\"aboutidfver\")){\n  //   #ifdef VER_IDF_STR\n  //   p = FPSTR(HTTP_INFO_aboutidf);\n  //   p.replace(FPSTR(T_1),String(VER_IDF_STR));\n  //   #endif\n  // }\n  else if(id==F(\"aboutsdkver\")){\n    p = FPSTR(HTTP_INFO_sdkver);\n    #ifdef ESP32\n      p.replace(FPSTR(T_1),(String)esp_get_idf_version());\n      // p.replace(FPSTR(T_1),(String)system_get_sdk_version()); // deprecated\n    #else\n    p.replace(FPSTR(T_1),(String)system_get_sdk_version());\n    #endif\n  }\n  else if(id==F(\"aboutdate\")){\n    p = FPSTR(HTTP_INFO_aboutdate);\n    p.replace(FPSTR(T_1),String(__DATE__ \" \" __TIME__));\n  }\n  return p;\n}\n\n/** \n * HTTPD CALLBACK exit, closes configportal if blocking, if non blocking undefined\n */\nvoid WiFiManager::handleExit() {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP Exit\"));\n  #endif\n  handleRequest();\n  String page = getHTTPHead(FPSTR(S_titleexit), FPSTR(C_exit)); // @token titleexit\n  page += FPSTR(S_exiting); // @token exiting\n  page += getHTTPEnd();\n  // ('Logout', 401, {'WWW-Authenticate': 'Basic realm=\"Login required\"'})\n  server->sendHeader(F(\"Cache-Control\"), F(\"no-cache, no-store, must-revalidate\")); // @HTTPHEAD send cache\n  HTTPSend(page);\n  delay(2000);\n  abort = true;\n}\n\n/** \n * HTTPD CALLBACK reset page\n */\nvoid WiFiManager::handleReset() {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP Reset\"));\n  #endif\n  handleRequest();\n  String page = getHTTPHead(FPSTR(S_titlereset), FPSTR(C_restart)); //@token titlereset\n  page += FPSTR(S_resetting); //@token resetting\n  page += getHTTPEnd();\n\n  HTTPSend(page);\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"RESETTING ESP\"));\n  #endif\n  delay(1000);\n  reboot();\n}\n\n/** \n * HTTPD CALLBACK erase page\n */\n\n// void WiFiManager::handleErase() {\n//   handleErase(false);\n// }\nvoid WiFiManager::handleErase(boolean opt) {\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_NOTIFY,F(\"<- HTTP Erase\"));\n  #endif\n  handleRequest();\n  String page = getHTTPHead(FPSTR(S_titleerase), FPSTR(C_erase)); // @token titleerase\n\n  bool ret = erase(opt);\n\n  if(ret) page += FPSTR(S_resetting); // @token resetting\n  else {\n    page += FPSTR(S_error); // @token erroroccur\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] WiFi EraseConfig failed\"));\n    #endif\n  }\n\n  page += getHTTPEnd();\n  HTTPSend(page);\n\n  if(ret){\n    delay(2000);\n    #ifdef WM_DEBUG_LEVEL\n  \tDEBUG_WM(F(\"RESETTING ESP\"));\n    #endif\n  \treboot();\n  }\t\n}\n\n/** \n * HTTPD CALLBACK 404\n */\nvoid WiFiManager::handleNotFound() {\n  if (captivePortal()) return; // If captive portal redirect instead of displaying the page\n  handleRequest();\n  String message = FPSTR(S_notfound); // @token notfound\n\n  bool verbose404 = false; // show info in 404 body, uri,method, args\n  if(verbose404){\n    message += FPSTR(S_uri); // @token uri\n    message += server->uri();\n    message += FPSTR(S_method); // @token method\n    message += ( server->method() == HTTP_GET ) ? FPSTR(S_GET) : FPSTR(S_POST);\n    message += FPSTR(S_args); // @token args\n    message += server->args();\n    message += F(\"\\n\");\n\n    for ( uint8_t i = 0; i < server->args(); i++ ) {\n      message += \" \" + server->argName ( i ) + \": \" + server->arg ( i ) + \"\\n\";\n    }\n  }\n  server->sendHeader(F(\"Cache-Control\"), F(\"no-cache, no-store, must-revalidate\")); // @HTTPHEAD send cache\n  server->sendHeader(F(\"Pragma\"), F(\"no-cache\"));\n  server->sendHeader(F(\"Expires\"), F(\"-1\"));\n  server->send ( 404, FPSTR(HTTP_HEAD_CT2), message );\n}\n\n/**\n * HTTPD redirector\n * Redirect to captive portal if we got a request for another domain. \n * Return true in that case so the page handler do not try to handle the request again. \n */\nboolean WiFiManager::captivePortal() {\n  \n  if(!_enableCaptivePortal || !configPortalActive) return false; // skip redirections if cp not enabled or not in ap mode\n  \n  String serverLoc =  toStringIp(server->client().localIP());\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_DEV,\"-> \" + server->hostHeader());\n  DEBUG_WM(WM_DEBUG_DEV,\"serverLoc \" + serverLoc);\n  #endif\n\n  // fallback for ipv6 bug\n  if(serverLoc == \"0.0.0.0\"){\n    if ((WiFi.status()) != WL_CONNECTED)\n      serverLoc = toStringIp(WiFi.softAPIP());\n    else\n      serverLoc = toStringIp(WiFi.localIP());\n  }\n  \n  if(_httpPort != 80) serverLoc += \":\" + (String)_httpPort; // add port if not default\n  bool doredirect = serverLoc != server->hostHeader(); // redirect if hostheader not server ip, prevent redirect loops\n  \n  if (doredirect) {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- Request redirected to captive portal\"));\n    DEBUG_WM(WM_DEBUG_DEV,\"serverLoc \" + serverLoc);\n    #endif\n    server->sendHeader(F(\"Location\"), (String)F(\"http://\") + serverLoc, true); // @HTTPHEAD send redirect\n    server->send ( 302, FPSTR(HTTP_HEAD_CT2), \"\"); // Empty content inhibits Content-length header so we have to close the socket ourselves.\n    server->client().stop(); // Stop is needed because we sent no content length\n    return true;\n  }\n  return false;\n}\n\nvoid WiFiManager::stopCaptivePortal(){\n  _enableCaptivePortal= false;\n  // @todo maybe disable configportaltimeout(optional), or just provide callback for user\n}\n\n// HTTPD CALLBACK, handle close,  stop captive portal, if not enabled undefined\nvoid WiFiManager::handleClose(){\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Disabling Captive Portal\"));\n  stopCaptivePortal();\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- HTTP close\"));\n  #endif\n  handleRequest();\n  String page = getHTTPHead(FPSTR(S_titleclose), FPSTR(C_close)); // @token titleclose\n  page += FPSTR(S_closing); // @token closing\n  page += getHTTPEnd();\n  HTTPSend(page);\n}\n\nvoid WiFiManager::reportStatus(String &page){\n  // updateConxResult(WiFi.status()); // @todo: this defeats the purpose of last result, update elsewhere or add logic here\n  DEBUG_WM(WM_DEBUG_DEV,F(\"[WIFI] reportStatus prev:\"),getWLStatusString(_lastconxresult));\n  DEBUG_WM(WM_DEBUG_DEV,F(\"[WIFI] reportStatus current:\"),getWLStatusString(WiFi.status()));\n  String str;\n  if (WiFi_SSID() != \"\"){\n    if (WiFi.status()==WL_CONNECTED){\n      str = FPSTR(HTTP_STATUS_ON);\n      str.replace(FPSTR(T_i),WiFi.localIP().toString());\n      str.replace(FPSTR(T_v),htmlEntities(WiFi_SSID()));\n    }\n    else {\n      str = FPSTR(HTTP_STATUS_OFF);\n      str.replace(FPSTR(T_v),htmlEntities(WiFi_SSID()));\n      if(_lastconxresult == WL_STATION_WRONG_PASSWORD){\n        // wrong password\n        str.replace(FPSTR(T_c),\"D\"); // class\n        str.replace(FPSTR(T_r),FPSTR(HTTP_STATUS_OFFPW));\n      }\n      else if(_lastconxresult == WL_NO_SSID_AVAIL){\n        // connect failed, or ap not found\n        str.replace(FPSTR(T_c),\"D\");\n        str.replace(FPSTR(T_r),FPSTR(HTTP_STATUS_OFFNOAP));\n      }\n      else if(_lastconxresult == WL_CONNECT_FAILED){\n        // connect failed\n        str.replace(FPSTR(T_c),\"D\");\n        str.replace(FPSTR(T_r),FPSTR(HTTP_STATUS_OFFFAIL));\n      }\n      else if(_lastconxresult == WL_CONNECTION_LOST){\n        // connect failed, MOST likely 4WAY_HANDSHAKE_TIMEOUT/incorrect password, state is ambiguous however\n        str.replace(FPSTR(T_c),\"D\");\n        str.replace(FPSTR(T_r),FPSTR(HTTP_STATUS_OFFFAIL));\n      }\n      else{\n        str.replace(FPSTR(T_c),\"\");\n        str.replace(FPSTR(T_r),\"\");\n      } \n    }\n  }\n  else {\n    str = FPSTR(HTTP_STATUS_NONE);\n  }\n  page += str;\n}\n\n// PUBLIC\n\n// METHODS\n\n/**\n * reset wifi settings, clean stored ap password\n */\n\n/**\n * [stopConfigPortal description]\n * @return {[type]} [description]\n */\nbool WiFiManager::stopConfigPortal(){\n  if(_configPortalIsBlocking){\n    abort = true;\n    return true;\n  }\n  return shutdownConfigPortal();  \n}\n\n/**\n * disconnect\n * @access public\n * @since $dev\n * @return bool success\n */\nbool WiFiManager::disconnect(){\n  if(WiFi.status() != WL_CONNECTED){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"Disconnecting: Not connected\"));\n    #endif\n    return false;\n  }  \n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"Disconnecting\"));\n  #endif\n  return WiFi_Disconnect();\n}\n\n/**\n * reboot the device\n * @access public\n */\nvoid WiFiManager::reboot(){\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"Restarting\"));\n  #endif\n  ESP.restart();\n}\n\n/**\n * reboot the device\n * @access public\n */\nbool WiFiManager::erase(){\n  return erase(false);\n}\n\nbool WiFiManager::erase(bool opt){\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(\"Erasing\");\n  #endif\n\n  #if defined(ESP32) && ((defined(WM_ERASE_NVS) || defined(nvs_flash_h)))\n    // if opt true, do nvs erase\n    if(opt){\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"Erasing NVS\"));\n      #endif\n      esp_err_t err;\n      err = nvs_flash_init();\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"nvs_flash_init: \"),err!=ESP_OK ? (String)err : \"Success\");\n      #endif\n      err = nvs_flash_erase();\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"nvs_flash_erase: \"), err!=ESP_OK ? (String)err : \"Success\");\n      #endif\n      return err == ESP_OK;\n    }\n  #elif defined(ESP8266) && defined(spiffs_api_h)\n    if(opt){\n      bool ret = false;\n      if(SPIFFS.begin()){\n      #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(F(\"Erasing SPIFFS\"));\n        #endif\n        bool ret = SPIFFS.format();\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"spiffs erase: \"),ret ? \"Success\" : \"ERROR\");\n        #endif\n      } else{\n      #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(F(\"[ERROR] Could not start SPIFFS\"));\n        #endif\n      }\n      return ret;\n    }\n  #else\n    (void)opt;\n  #endif\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"Erasing WiFi Config\"));\n  #endif\n  return WiFi_eraseConfig();\n}\n\n/**\n * [resetSettings description]\n * ERASES STA CREDENTIALS\n * @access public\n */\nvoid WiFiManager::resetSettings() {\n#ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"resetSettings\"));\n  #endif\n  WiFi_enableSTA(true,true); // must be sta to disconnect erase\n  delay(500); // ensure sta is enabled\n  if (_resetcallback != NULL){\n      _resetcallback();  // @CALLBACK\n  }\n  \n  #ifdef ESP32\n    WiFi.disconnect(true,true);\n  #else\n    WiFi.persistent(true);\n    WiFi.disconnect(true);\n    WiFi.persistent(false);\n  #endif\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(F(\"SETTINGS ERASED\"));\n  #endif\n}\n\n// SETTERS\n\n/**\n * [setTimeout description]\n * @access public\n * @param {[type]} unsigned long seconds [description]\n */\nvoid WiFiManager::setTimeout(unsigned long seconds) {\n  setConfigPortalTimeout(seconds);\n}\n\n/**\n * [setConfigPortalTimeout description]\n * @access public\n * @param {[type]} unsigned long seconds [description]\n */\nvoid WiFiManager::setConfigPortalTimeout(unsigned long seconds) {\n  _configPortalTimeout = seconds * 1000;\n}\n\n/**\n * [setConnectTimeout description]\n * @access public\n * @param {[type]} unsigned long seconds [description]\n */\nvoid WiFiManager::setConnectTimeout(unsigned long seconds) {\n  _connectTimeout = seconds * 1000;\n}\n\n/**\n * [setConnectRetries description]\n * @access public\n * @param {[type]} uint8_t numRetries [description]\n */\nvoid WiFiManager::setConnectRetries(uint8_t numRetries){\n  _connectRetries = constrain(numRetries,1,10);\n}\n\n/**\n * toggle _cleanconnect, always disconnect before connecting\n * @param {[type]} bool enable [description]\n */\nvoid WiFiManager::setCleanConnect(bool enable){\n  _cleanConnect = enable;\n}\n\n/**\n * [setConnectTimeout description\n * @access public\n * @param {[type]} unsigned long seconds [description]\n */\nvoid WiFiManager::setSaveConnectTimeout(unsigned long seconds) {\n  _saveTimeout = seconds * 1000;\n}\n\n/**\n * Set save portal connect on save option, \n * if false, will only save credentials not connect\n * @access public\n * @param {[type]} bool connect [description]\n */\nvoid WiFiManager::setSaveConnect(bool connect) {\n  _connectonsave = connect;\n}\n\n/**\n * [setDebugOutput description]\n * @access public\n * @param {[type]} boolean debug [description]\n */\nvoid WiFiManager::setDebugOutput(boolean debug) {\n  _debug = debug;\n  if(_debug && _debugLevel == WM_DEBUG_DEV) debugPlatformInfo();\n  if(_debug && _debugLevel >= WM_DEBUG_NOTIFY)DEBUG_WM((__FlashStringHelper *)WM_VERSION_STR,\" D:\"+String(_debugLevel));\n}\n\nvoid WiFiManager::setDebugOutput(boolean debug, String prefix) {\n  _debugPrefix = prefix;\n  setDebugOutput(debug);\n}\n\nvoid WiFiManager::setDebugOutput(boolean debug, wm_debuglevel_t level) {\n  _debugLevel = level;\n  // _debugPrefix = prefix;\n  setDebugOutput(debug);\n}\n\n\n/**\n * [setAPStaticIPConfig description]\n * @access public\n * @param {[type]} IPAddress ip [description]\n * @param {[type]} IPAddress gw [description]\n * @param {[type]} IPAddress sn [description]\n */\nvoid WiFiManager::setAPStaticIPConfig(IPAddress ip, IPAddress gw, IPAddress sn) {\n  _ap_static_ip = ip;\n  _ap_static_gw = gw;\n  _ap_static_sn = sn;\n}\n\n/**\n * [setSTAStaticIPConfig description]\n * @access public\n * @param {[type]} IPAddress ip [description]\n * @param {[type]} IPAddress gw [description]\n * @param {[type]} IPAddress sn [description]\n */\nvoid WiFiManager::setSTAStaticIPConfig(IPAddress ip, IPAddress gw, IPAddress sn) {\n  _sta_static_ip = ip;\n  _sta_static_gw = gw;\n  _sta_static_sn = sn;\n}\n\n/**\n * [setSTAStaticIPConfig description]\n * @since $dev\n * @access public\n * @param {[type]} IPAddress ip [description]\n * @param {[type]} IPAddress gw [description]\n * @param {[type]} IPAddress sn [description]\n * @param {[type]} IPAddress dns [description]\n */\nvoid WiFiManager::setSTAStaticIPConfig(IPAddress ip, IPAddress gw, IPAddress sn, IPAddress dns) {\n  setSTAStaticIPConfig(ip,gw,sn);\n  _sta_static_dns = dns;\n}\n\n/**\n * [setMinimumSignalQuality description]\n * @access public\n * @param {[type]} int quality [description]\n */\nvoid WiFiManager::setMinimumSignalQuality(int quality) {\n  _minimumQuality = quality;\n}\n\n/**\n * [setBreakAfterConfig description]\n * @access public\n * @param {[type]} boolean shouldBreak [description]\n */\nvoid WiFiManager::setBreakAfterConfig(boolean shouldBreak) {\n  _shouldBreakAfterConfig = shouldBreak;\n}\n\n/**\n * setAPCallback, set a callback when softap is started\n * @access public \n * @param {[type]} void (*func)(WiFiManager* wminstance)\n */\nvoid WiFiManager::setAPCallback( std::function<void(WiFiManager*)> func ) {\n  _apcallback = func;\n}\n\n/**\n * setWebServerCallback, set a callback after webserver is reset, and before routes are setup\n * if we set webserver handlers before wm, they are used and wm is not by esp webserver\n * on events cannot be overrided once set, and are not mutiples\n * @access public \n * @param {[type]} void (*func)(void)\n */\nvoid WiFiManager::setWebServerCallback( std::function<void()> func ) {\n  _webservercallback = func;\n}\n\n/**\n * setSaveConfigCallback, set a save config callback after closing configportal\n * @note calls only if wifi is saved or changed, or setBreakAfterConfig(true)\n * @access public\n * @param {[type]} void (*func)(void)\n */\nvoid WiFiManager::setSaveConfigCallback( std::function<void()> func ) {\n  _savewificallback = func;\n}\n\n/**\n * setPreSaveConfigCallback, set a callback to fire before saving wifi or params\n * @access public\n * @param {[type]} void (*func)(void)\n */\nvoid WiFiManager::setPreSaveConfigCallback( std::function<void()> func ) {\n  _presavewificallback = func;\n}\n\n/**\n * setConfigResetCallback, set a callback to occur when a resetSettings() occurs\n * @access public\n * @param {[type]} void(*func)(void)\n */\nvoid WiFiManager::setConfigResetCallback( std::function<void()> func ) {\n    _resetcallback = func;\n}\n\n/**\n * setSaveParamsCallback, set a save params callback on params save in wifi or params pages\n * @access public\n * @param {[type]} void (*func)(void)\n */\nvoid WiFiManager::setSaveParamsCallback( std::function<void()> func ) {\n  _saveparamscallback = func;\n}\n\n/**\n * setPreSaveParamsCallback, set a pre save params callback on params save prior to anything else\n * @access public\n * @param {[type]} void (*func)(void)\n */\nvoid WiFiManager::setPreSaveParamsCallback( std::function<void()> func ) {\n  _presaveparamscallback = func;\n}\n\n/**\n * setPreOtaUpdateCallback, set a callback to fire before OTA update\n * @access public\n * @param {[type]} void (*func)(void)\n */\nvoid WiFiManager::setPreOtaUpdateCallback( std::function<void()> func ) {\n  _preotaupdatecallback = func;\n}\n\n/**\n * setConfigPortalTimeoutCallback, set a callback to config portal is timeout\n * @access public\n * @param {[type]} void (*func)(void)\n */\nvoid WiFiManager::setConfigPortalTimeoutCallback( std::function<void()> func ) {\n  _configportaltimeoutcallback = func;\n}\n\n/**\n * set custom head html\n * custom element will be added to head, eg. new meta,style,script tag etc.\n * @access public\n * @param char element\n */\nvoid WiFiManager::setCustomHeadElement(const char* html) {\n  _customHeadElement = html;\n}\n\n/**\n * set custom html at the top of the body\n * custom element will be added after the body tag is opened, eg. to show a logo etc.\n * @access public\n * @param char element\n */\nvoid WiFiManager::setCustomBodyHeader(const char* html) {\n    _customBodyHeader = html;\n}\n\n/**\n * set custom html at the bottom of the body\n * custom element will be added before the body tag is closed\n * @access public\n * @param char element\n */\nvoid WiFiManager::setCustomBodyFooter(const char* html) {\n    _customBodyFooter = html;\n}\n\n/**\n * set custom menu html\n * custom element will be added to menu under custom menu item.\n * @access public\n * @param char element\n */\nvoid WiFiManager::setCustomMenuHTML(const char* html) {\n  _customMenuHTML = html;\n}\n\n/**\n * toggle wifiscan hiding of duplicate ssid names\n * if this is false, wifiscan will remove duplicat Access Points - defaut true\n * @access public\n * @param boolean removeDuplicates [true]\n */\nvoid WiFiManager::setRemoveDuplicateAPs(boolean removeDuplicates) {\n  _removeDuplicateAPs = removeDuplicates;\n}\n\n/**\n * toggle configportal blocking loop\n * if enabled, then the configportal will enter a blocking loop and wait for configuration\n * if disabled use with process() to manually process webserver\n * @since $dev\n * @access public\n * @param boolean shoudlBlock [false]\n */\nvoid WiFiManager::setConfigPortalBlocking(boolean shouldBlock) {\n  _configPortalIsBlocking = shouldBlock;\n}\n\n/**\n * toggle restore persistent, track internally\n * sets ESP wifi.persistent so we can remember it and restore user preference on destruct\n * there is no getter in esp8266 platform prior to https://github.com/esp8266/Arduino/pull/3857\n * @since $dev\n * @access public\n * @param boolean persistent [true]\n */\nvoid WiFiManager::setRestorePersistent(boolean persistent) {\n  _userpersistent = persistent;\n  if(!persistent){\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"persistent is off\"));\n    #endif\n  }\n}\n\n/**\n * toggle showing static ip form fields\n * if enabled, then the static ip, gateway, subnet fields will be visible, even if not set in code\n * @since $dev\n * @access public\n * @param boolean alwaysShow [false]\n */\nvoid WiFiManager::setShowStaticFields(boolean alwaysShow){\n  if(_disableIpFields) _staShowStaticFields = alwaysShow ? 1 : -1;\n  else _staShowStaticFields = alwaysShow ? 1 : 0;\n}\n\n/**\n * toggle showing dns fields\n * if enabled, then the dns1 field will be visible, even if not set in code\n * @since $dev\n * @access public\n * @param boolean alwaysShow [false]\n */\nvoid WiFiManager::setShowDnsFields(boolean alwaysShow){\n  if(_disableIpFields) _staShowDns = alwaysShow ? 1 : -1;\n  else _staShowDns = alwaysShow ? 1 : 0;\n}\n\n/**\n * toggle showing password in wifi password field\n * if not enabled, placeholder will be S_passph\n * @since $dev\n * @access public\n * @param boolean alwaysShow [false]\n */\nvoid WiFiManager::setShowPassword(boolean show){\n  _showPassword = show;\n}\n\n/**\n * toggle captive portal\n * if enabled, then devices that use captive portal checks will be redirected to root\n * if not you will automatically have to navigate to ip [192.168.4.1]\n * @since $dev\n * @access public\n * @param boolean enabled [true]\n */\nvoid WiFiManager::setCaptivePortalEnable(boolean enabled){\n  _enableCaptivePortal = enabled;\n}\n\n/**\n * toggle wifi autoreconnect policy\n * if enabled, then wifi will autoreconnect automatically always\n * On esp8266 we force this on when autoconnect is called, see notes\n * On esp32 this is handled on SYSTEM_EVENT_STA_DISCONNECTED since it does not exist in core yet\n * @since $dev\n * @access public\n * @param boolean enabled [true]\n */\nvoid WiFiManager::setWiFiAutoReconnect(boolean enabled){\n  _wifiAutoReconnect = enabled;\n}\n\n/**\n * toggle configportal timeout wait for station client\n * if enabled, then the configportal will start timeout when no stations are connected to softAP\n * disabled by default as rogue stations can keep it open if there is no auth\n * @since $dev\n * @access public\n * @param boolean enabled [false]\n */\nvoid WiFiManager::setAPClientCheck(boolean enabled){\n  _apClientCheck = enabled;\n}\n\n/**\n * toggle configportal timeout wait for web client\n * if enabled, then the configportal will restart timeout when client requests come in\n * @since $dev\n * @access public\n * @param boolean enabled [true]\n */\nvoid WiFiManager::setWebPortalClientCheck(boolean enabled){\n  _webClientCheck = enabled;\n}\n\n/**\n * toggle wifiscan percentages or quality icons\n * @since $dev\n * @access public\n * @param boolean enabled [false]\n */\nvoid WiFiManager::setScanDispPerc(boolean enabled){\n  _scanDispOptions = enabled;\n}\n\n/**\n * toggle configportal if autoconnect failed\n * if enabled, then the configportal will be activated on autoconnect failure\n * @since $dev\n * @access public\n * @param boolean enabled [true]\n */\nvoid WiFiManager::setEnableConfigPortal(boolean enable)\n{\n    _enableConfigPortal = enable;\n}\n\n/**\n * toggle configportal if autoconnect failed\n * if enabled, then the configportal will be de-activated on wifi save\n * @since $dev\n * @access public\n * @param boolean enabled [true]\n */\nvoid WiFiManager::setDisableConfigPortal(boolean enable)\n{\n    _disableConfigPortal = enable;\n}\n\n/**\n * set the hostname (dhcp client id)\n * @since $dev\n * @access public\n * @param  char* hostname 32 character hostname to use for sta+ap in esp32, sta in esp8266\n * @return bool false if hostname is not valid\n */\nbool  WiFiManager::setHostname(const char * hostname){\n  //@todo max length 32\n  _hostname = String(hostname);\n  return true;\n}\n\nbool  WiFiManager::setHostname(String hostname){\n  //@todo max length 32\n  _hostname = hostname;\n  return true;\n}\n\n/**\n * set the soft ao channel, ignored if channelsync is true and connected\n * @param int32_t   wifi channel, 0 to disable\n */\nvoid WiFiManager::setWiFiAPChannel(int32_t channel){\n  _apChannel = channel;\n}\n\n/**\n * set the soft ap hidden\n * @param bool   wifi ap hidden, default is false\n */\nvoid WiFiManager::setWiFiAPHidden(bool hidden){\n  _apHidden = hidden;\n}\n\n\n/**\n * toggle showing erase wifi config button on info page\n * @param boolean enabled\n */\nvoid WiFiManager::setShowInfoErase(boolean enabled){\n  _showInfoErase = enabled;\n}\n\n/**\n * toggle showing update upload web ota button on info page\n * @param boolean enabled\n */\nvoid WiFiManager::setShowInfoUpdate(boolean enabled){\n  _showInfoUpdate = enabled;\n}\n\n/**\n * check if the config portal is running\n * @return bool true if active\n */\nbool WiFiManager::getConfigPortalActive(){\n  return configPortalActive;\n}\n\n/**\n * [getConfigPortalActive description]\n * @return bool true if active\n */\nbool WiFiManager::getWebPortalActive(){\n  return webPortalActive;\n}\n\n\nString WiFiManager::getWiFiHostname(){\n  #ifdef ESP32\n    return (String)WiFi.getHostname();\n  #else\n    return (String)WiFi.hostname();\n  #endif\n}\n\n/**\n * [setTitle description]\n * @param String title, set app title\n */\nvoid WiFiManager::setTitle(String title){\n  _title = title;\n}\n\n/**\n * set menu items and order\n * if param is present in menu , params will be removed from wifi page automatically\n * eg.\n *  const char * menu[] = {\"wifi\",\"setup\",\"sep\",\"info\",\"exit\"};\n *  WiFiManager.setMenu(menu);\n * @since $dev\n * @param uint8_t menu[] array of menu ids\n */\nvoid WiFiManager::setMenu(const char * menu[], uint8_t size){\n#ifdef WM_DEBUG_LEVEL\n  // DEBUG_WM(WM_DEBUG_DEV,\"setmenu array\");\n  #endif\n  _menuIds.clear();\n  for(size_t i = 0; i < size; i++){\n    for(size_t j = 0; j < _nummenutokens; j++){\n      if((String)menu[i] == (__FlashStringHelper *)(_menutokens[j])){\n        if((String)menu[i] == \"param\") _paramsInWifi = false; // param auto flag\n        _menuIds.push_back(j);\n      }\n      delay(0);\n    }\n    delay(0);\n  }\n  #ifdef WM_DEBUG_LEVEL\n  // DEBUG_WM(getMenuOut());\n  #endif\n}\n\n/**\n * setMenu with vector\n * eg.\n * std::vector<const char *> menu = {\"wifi\",\"setup\",\"sep\",\"info\",\"exit\"};\n * WiFiManager.setMenu(menu);\n * tokens can be found in _menutokens array in strings_en.h\n * @shiftIncrement $dev\n * @param {[type]} std::vector<const char *>& menu [description]\n */\nvoid WiFiManager::setMenu(std::vector<const char *>& menu){\n#ifdef WM_DEBUG_LEVEL\n  // DEBUG_WM(WM_DEBUG_DEV,\"setmenu vector\");\n  #endif\n  _menuIds.clear();\n  for(auto menuitem : menu ){\n    for(size_t j = 0; j < _nummenutokens; j++){\n      if((String)menuitem == (__FlashStringHelper *)(_menutokens[j])){\n        if((String)menuitem == \"param\") _paramsInWifi = false; // param auto flag\n        _menuIds.push_back(j);\n      }\n    }\n  }\n  #ifdef WM_DEBUG_LEVEL\n  // DEBUG_WM(WM_DEBUG_DEV,getMenuOut());\n  #endif\n}\n\n\n/**\n * set params as sperate page not in wifi\n * NOT COMPATIBLE WITH setMenu! \n * @todo scan menuids and insert param after wifi or something, same for ota\n * @param bool enable \n * @since $dev\n */\nvoid WiFiManager::setParamsPage(bool enable){\n  _paramsInWifi  = !enable;\n  setMenu(enable ? _menuIdsParams : _menuIdsDefault);\n}\n\n// GETTERS\n\n/**\n * get config portal AP SSID\n * @since 0.0.1\n * @access public\n * @return String the configportal ap name\n */\nString WiFiManager::getConfigPortalSSID() {\n  return _apName;\n}\n\n/**\n * return the last known connection result\n * logged on autoconnect and wifisave, can be used to check why failed\n * get as readable string with getWLStatusString(getLastConxResult);\n * @since $dev\n * @access public\n * @return bool return wl_status codes\n */\nuint8_t WiFiManager::getLastConxResult(){\n  return _lastconxresult;\n}\n\n/**\n * check if wifi has a saved ap or not\n * @since $dev\n * @access public\n * @return bool true if a saved ap config exists\n */\nbool WiFiManager::getWiFiIsSaved(){\n  return WiFi_hasAutoConnect();\n}\n\n/**\n * getDefaultAPName\n * @since $dev\n * @return string \n */\nString WiFiManager::getDefaultAPName(){\n  String hostString = String(WIFI_getChipId(),HEX);\n  hostString.toUpperCase();\n  // char hostString[16] = {0};\n  // sprintf(hostString, \"%06X\", ESP.getChipId());  \n  return _wifissidprefix + \"_\" + hostString;\n}\n\n/**\n * setCountry\n * @since $dev\n * @param String cc country code, must be defined in WiFiSetCountry, US, JP, CN\n */\nvoid WiFiManager::setCountry(String cc){\n  _wificountry = cc;\n}\n\n/**\n * setClass\n * @param String str body class string\n */\nvoid WiFiManager::setClass(String str){\n  _bodyClass = str;\n}\n\n/**\n * setDarkMode\n * @param bool enable, enable dark mode via invert class\n */\nvoid WiFiManager::setDarkMode(bool enable){\n  _bodyClass = enable ? \"invert\" : \"\";\n}\n\n/**\n * setHttpPort\n * @param uint16_t port webserver port number default 80\n */\nvoid WiFiManager::setHttpPort(uint16_t port){\n  _httpPort = port;\n}\n\n\nbool WiFiManager::preloadWiFi(String ssid, String pass){\n  _defaultssid = ssid;\n  _defaultpass = pass;\n  return true;\n}\n\n// HELPERS\n\n/**\n * getWiFiSSID\n * @since $dev\n * @param bool persistent\n * @return String\n */\nString WiFiManager::getWiFiSSID(bool persistent){\n  return WiFi_SSID(persistent);\n}\n\n/**\n * getWiFiPass\n * @since $dev\n * @param bool persistent\n * @return String\n */\nString WiFiManager::getWiFiPass(bool persistent){\n  return WiFi_psk(persistent);\n} \n\n// DEBUG\n// @todo fix DEBUG_WM(0,0);\ntemplate <typename Generic>\nvoid WiFiManager::DEBUG_WM(Generic text) {\n  DEBUG_WM(WM_DEBUG_NOTIFY,text,\"\");\n}\n\ntemplate <typename Generic>\nvoid WiFiManager::DEBUG_WM(wm_debuglevel_t level,Generic text) {\n  if(_debugLevel >= level) DEBUG_WM(level,text,\"\");\n}\n\ntemplate <typename Generic, typename Genericb>\nvoid WiFiManager::DEBUG_WM(Generic text,Genericb textb) {\n  DEBUG_WM(WM_DEBUG_NOTIFY,text,textb);\n}\n\ntemplate <typename Generic, typename Genericb>\nvoid WiFiManager::DEBUG_WM(wm_debuglevel_t level,Generic text,Genericb textb) {\n  if(!_debug || _debugLevel < level) return;\n\n  if(_debugLevel >= WM_DEBUG_MAX){\n    #ifdef ESP8266\n    // uint32_t free;\n    // uint16_t max;\n    // uint8_t frag;\n    // ESP.getHeapStats(&free, &max, &frag);// @todo Does not exist in 2.3.0\n    // _debugPort.printf(\"[MEM] free: %5d | max: %5d | frag: %3d%% \\n\", free, max, frag); \n    #elif defined ESP32\n    // total_free_bytes;      ///<  Total free bytes in the heap. Equivalent to multi_free_heap_size().\n    // total_allocated_bytes; ///<  Total bytes allocated to data in the heap.\n    // largest_free_block;    ///<  Size of largest free block in the heap. This is the largest malloc-able size.\n    // minimum_free_bytes;    ///<  Lifetime minimum free heap size. Equivalent to multi_minimum_free_heap_size().\n    // allocated_blocks;      ///<  Number of (variable size) blocks allocated in the heap.\n    // free_blocks;           ///<  Number of (variable size) free blocks in the heap.\n    // total_blocks;          ///<  Total number of (variable size) blocks in the heap.\n    multi_heap_info_t info;\n    heap_caps_get_info(&info, MALLOC_CAP_INTERNAL);\n    uint32_t free = info.total_free_bytes;\n    uint16_t max  = info.largest_free_block;\n    uint8_t frag = 100 - (max * 100) / free;\n    _debugPort.printf(\"[MEM] free: %5lu | max: %5u | frag: %3u%% \\n\", free, max, frag);\n    #endif\n  }\n\n  _debugPort.print(_debugPrefix);\n  if(_debugLevel >= debugLvlShow) _debugPort.print(\"[\"+(String)level+\"] \");\n  _debugPort.print(text);\n  if(textb){\n    _debugPort.print(\" \");\n    _debugPort.print(textb);\n  }\n  _debugPort.println();\n}\n\n/**\n * [debugSoftAPConfig description]\n * @access public\n * @return {[type]} [description]\n */\nvoid WiFiManager::debugSoftAPConfig(){\n    \n    #ifdef ESP8266\n      softap_config config;\n      wifi_softap_get_config(&config);\n      #if !defined(WM_NOCOUNTRY)\n        wifi_country_t country;\n        wifi_get_country(&country);\n      #endif\n    #elif defined(ESP32)\n      wifi_country_t country;\n      wifi_config_t conf_config;\n      esp_wifi_get_config(WIFI_IF_AP, &conf_config); // == ESP_OK\n      wifi_ap_config_t config = conf_config.ap;\n      esp_wifi_get_country(&country);\n    #endif\n\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"SoftAP Configuration\"));\n    DEBUG_WM(FPSTR(D_HR));\n    DEBUG_WM(F(\"ssid:            \"),(char *) config.ssid);\n    DEBUG_WM(F(\"password:        \"),(char *) config.password);\n    DEBUG_WM(F(\"ssid_len:        \"),config.ssid_len);\n    DEBUG_WM(F(\"channel:         \"),config.channel);\n    DEBUG_WM(F(\"authmode:        \"),config.authmode);\n    DEBUG_WM(F(\"ssid_hidden:     \"),config.ssid_hidden);\n    DEBUG_WM(F(\"max_connection:  \"),config.max_connection);\n    #endif\n    #if !defined(WM_NOCOUNTRY) \n    #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"country:         \"),(String)country.cc);\n      #endif\n    DEBUG_WM(F(\"beacon_interval: \"),(String)config.beacon_interval + \"(ms)\");\n    DEBUG_WM(FPSTR(D_HR));\n    #endif\n}\n\n/**\n * [debugPlatformInfo description]\n * @access public\n * @return {[type]} [description]\n */\nvoid WiFiManager::debugPlatformInfo(){\n  #ifdef ESP8266\n    system_print_meminfo();\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"[SYS] getCoreVersion():         \"),ESP.getCoreVersion());\n    DEBUG_WM(F(\"[SYS] system_get_sdk_version(): \"),system_get_sdk_version());\n    DEBUG_WM(F(\"[SYS] system_get_boot_version():\"),system_get_boot_version());\n    DEBUG_WM(F(\"[SYS] getFreeHeap():            \"),(String)ESP.getFreeHeap());\n    #endif\n  #elif defined(ESP32)\n  #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"[SYS] WM version: \"), String((__FlashStringHelper *)WM_VERSION_STR) +\" D:\"+String(_debugLevel));\n    DEBUG_WM(F(\"[SYS] Arduino version: \"), VER_ARDUINO_STR);\n    DEBUG_WM(F(\"[SYS] ESP SDK version: \"), ESP.getSdkVersion());\n    DEBUG_WM(F(\"[SYS] Free heap:       \"), ESP.getFreeHeap());\n    #endif\n\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(F(\"[SYS] Chip ID:\"),WIFI_getChipId());\n    DEBUG_WM(F(\"[SYS] Chip Model:\"), ESP.getChipModel());\n    DEBUG_WM(F(\"[SYS] Chip Cores:\"), ESP.getChipCores());\n    DEBUG_WM(F(\"[SYS] Chip Rev:\"),   ESP.getChipRevision());\n    #endif\n  #endif\n}\n\nint WiFiManager::getRSSIasQuality(int RSSI) {\n  int quality = 0;\n\n  if (RSSI <= -100) {\n    quality = 0;\n  } else if (RSSI >= -50) {\n    quality = 100;\n  } else {\n    quality = 2 * (RSSI + 100);\n  }\n  return quality;\n}\n\n/** Is this an IP? */\nboolean WiFiManager::isIp(String str) {\n  for (size_t i = 0; i < str.length(); i++) {\n    int c = str.charAt(i);\n    if (c != '.' && (c < '0' || c > '9')) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** IP to String? */\nString WiFiManager::toStringIp(IPAddress ip) {\n  String res = \"\";\n  for (int i = 0; i < 3; i++) {\n    res += String((ip >> (8 * i)) & 0xFF) + \".\";\n  }\n  res += String(((ip >> 8 * 3)) & 0xFF);\n  return res;\n}\n\nboolean WiFiManager::validApPassword(){\n  // check that ap password is valid, return false\n  if (_apPassword == NULL) _apPassword = \"\";\n  if (_apPassword != \"\") {\n    if (_apPassword.length() < 8 || _apPassword.length() > 63) {\n    #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(F(\"AccessPoint set password is INVALID or <8 chars\"));\n      #endif\n      _apPassword = \"\";\n      return false; // @todo FATAL or fallback to empty , currently fatal, fail secure.\n    }\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,F(\"AccessPoint set password is VALID\"));\n    DEBUG_WM(WM_DEBUG_DEV,\"ap pass\",_apPassword);\n    #endif\n  }\n  return true;\n}\n\n/**\n * encode htmlentities\n * @since $dev\n * @param  string str  string to replace entities\n * @return string      encoded string\n */\nString WiFiManager::htmlEntities(String str, bool whitespace) {\n  str.replace(\"&\",\"&amp;\");\n  str.replace(\"<\",\"&lt;\");\n  str.replace(\">\",\"&gt;\");\n  str.replace(\"'\",\"&#39;\");\n  if(whitespace) str.replace(\" \",\"&#160;\");\n  // str.replace(\"-\",\"&ndash;\");\n  // str.replace(\"\\\"\",\"&quot;\");\n  // str.replace(\"/\": \"&#x2F;\");\n  // str.replace(\"`\": \"&#x60;\");\n  // str.replace(\"=\": \"&#x3D;\");\nreturn str;\n}\n\n/**\n * [getWLStatusString description]\n * @access public\n * @param  {[type]} uint8_t status        [description]\n * @return {[type]}         [description]\n */\nString WiFiManager::getWLStatusString(uint8_t status){\n  if(status <= 7) return WIFI_STA_STATUS[status];\n  return FPSTR(S_NA);\n}\n\nString WiFiManager::getWLStatusString(){\n  uint8_t status = WiFi.status();\n  if(status <= 7) return WIFI_STA_STATUS[status];\n  return FPSTR(S_NA);\n}\n\nString WiFiManager::encryptionTypeStr(uint8_t authmode) {\n#ifdef WM_DEBUG_LEVEL\n  // DEBUG_WM(\"enc_tye: \",authmode);\n  #endif\n  return AUTH_MODE_NAMES[authmode];\n}\n\nString WiFiManager::getModeString(uint8_t mode){\n  if(mode <= 3) return WIFI_MODES[mode];\n  return FPSTR(S_NA);\n}\n\nbool WiFiManager::WiFiSetCountry(){\n  if(_wificountry == \"\") return false; // skip not set\n\n  #ifdef WM_DEBUG_LEVEL\n  DEBUG_WM(WM_DEBUG_VERBOSE,F(\"WiFiSetCountry to\"),_wificountry);\n  #endif\n\n/*\n  * @return\n  *    - ESP_OK: succeed\n  *    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by eps_wifi_init\n  *    - ESP_ERR_WIFI_IF: invalid interface\n  *    - ESP_ERR_WIFI_ARG: invalid argument\n  *    - others: refer to error codes in esp_err.h\n  */\n\n  // @todo move these definitions, and out of cpp `esp_wifi_set_country(&WM_COUNTRY_US)`\n  bool ret = true;\n  // ret = esp_wifi_set_bandwidth(WIFI_IF_AP,WIFI_BW_HT20); // WIFI_BW_HT40\n  #ifdef ESP32\n  esp_err_t err = ESP_OK;\n  // @todo check if wifi is init, no idea how, doesnt seem to be exposed atm ( check again it might be now! )\n  if(WiFi.getMode() == WIFI_MODE_NULL){\n      DEBUG_WM(WM_DEBUG_ERROR,\"[ERROR] cannot set country, wifi not init\");        \n  } // exception if wifi not init!\n  // Assumes that _wificountry is set to one of the supported country codes : \"01\"(world safe mode) \"AT\",\"AU\",\"BE\",\"BG\",\"BR\",\n  //               \"CA\",\"CH\",\"CN\",\"CY\",\"CZ\",\"DE\",\"DK\",\"EE\",\"ES\",\"FI\",\"FR\",\"GB\",\"GR\",\"HK\",\"HR\",\"HU\",\n  //               \"IE\",\"IN\",\"IS\",\"IT\",\"JP\",\"KR\",\"LI\",\"LT\",\"LU\",\"LV\",\"MT\",\"MX\",\"NL\",\"NO\",\"NZ\",\"PL\",\"PT\",\n  //               \"RO\",\"SE\",\"SI\",\"SK\",\"TW\",\"US\"\n  // If an invalid country code is passed, ESP_ERR_WIFI_ARG will be returned\n  // This also uses 802.11d mode, which matches the STA to the country code of the AP it connects to (meaning\n  // that the country code will be overridden if connecting to a \"foreign\" AP)\n  else {\n    #ifndef WM_NOCOUNTRY\n    err = esp_wifi_set_country_code(_wificountry.c_str(), true);\n    #else\n    DEBUG_WM(WM_DEBUG_ERROR,\"[ERROR] esp wifi set country is not available\");\n    err = true;\n    #endif\n  }\n  #ifdef WM_DEBUG_LEVEL\n    if(err){\n      if(err == ESP_ERR_WIFI_NOT_INIT) DEBUG_WM(WM_DEBUG_ERROR,\"[ERROR] ESP_ERR_WIFI_NOT_INIT\");\n      else if(err == ESP_ERR_INVALID_ARG) DEBUG_WM(WM_DEBUG_ERROR,\"[ERROR] ESP_ERR_WIFI_ARG (invalid country code)\");\n      else if(err != ESP_OK)DEBUG_WM(WM_DEBUG_ERROR,\"[ERROR] unknown error\",(String)err);\n    }\n  #endif\n  ret = err == ESP_OK;\n  \n  #elif defined(ESP8266) && !defined(WM_NOCOUNTRY)\n       // if(WiFi.getMode() == WIFI_OFF); // exception if wifi not init!\n       if(_wificountry == \"US\") ret = wifi_set_country((wifi_country_t*)&WM_COUNTRY_US);\n  else if(_wificountry == \"JP\") ret = wifi_set_country((wifi_country_t*)&WM_COUNTRY_JP);\n  else if(_wificountry == \"CN\") ret = wifi_set_country((wifi_country_t*)&WM_COUNTRY_CN);\n  #ifdef WM_DEBUG_LEVEL\n  else DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] country code not found\"));\n  #endif\n  #endif\n  \n  #ifdef WM_DEBUG_LEVEL\n  if(ret) DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[OK] esp_wifi_set_country: \"),_wificountry);\n  else DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] esp_wifi_set_country failed\"));  \n  #endif\n  return ret;\n}\n\n// set mode ignores WiFi.persistent \nbool WiFiManager::WiFi_Mode(WiFiMode_t m,bool persistent) {\n    bool ret;\n    #ifdef ESP8266\n      if((wifi_get_opmode() == (uint8) m ) && !persistent) {\n          return true;\n      }\n      ETS_UART_INTR_DISABLE();\n      if(persistent) ret = wifi_set_opmode(m);\n      else ret = wifi_set_opmode_current(m);\n      ETS_UART_INTR_ENABLE();\n    return ret;\n    #elif defined(ESP32)\n      if(persistent && esp32persistent) WiFi.persistent(true);\n      ret = WiFi.mode(m); // @todo persistent check persistant mode, was eventually added to esp lib, but have to add version checking probably\n      if(persistent && esp32persistent) WiFi.persistent(false);\n      return ret;\n    #endif\n}\nbool WiFiManager::WiFi_Mode(WiFiMode_t m) {\n\treturn WiFi_Mode(m,false);\n}\n\n// sta disconnect without persistent\nbool WiFiManager::WiFi_Disconnect() {\n    #ifdef ESP8266\n      if((WiFi.getMode() & WIFI_STA) != 0) {\n          bool ret;\n          #ifdef WM_DEBUG_LEVEL\n          DEBUG_WM(WM_DEBUG_DEV,F(\"WiFi station disconnect\"));\n          #endif\n          ETS_UART_INTR_DISABLE(); // @todo possibly not needed\n          ret = wifi_station_disconnect();\n          ETS_UART_INTR_ENABLE();        \n          return ret;\n      }\n    #elif defined(ESP32)\n    #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_DEV,F(\"WiFi station disconnect\"));\n      #endif\n      return WiFi.disconnect(); // not persistent atm\n    #endif\n    return false;\n}\n\n// toggle STA without persistent\nbool WiFiManager::WiFi_enableSTA(bool enable,bool persistent) {\n#ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"WiFi_enableSTA\"),(String) enable? \"enable\" : \"disable\");\n    #endif\n    #ifdef ESP8266\n      WiFiMode_t newMode;\n      WiFiMode_t currentMode = WiFi.getMode();\n      bool isEnabled         = (currentMode & WIFI_STA) != 0;\n      if(enable) newMode     = (WiFiMode_t)(currentMode | WIFI_STA);\n      else newMode           = (WiFiMode_t)(currentMode & (~WIFI_STA));\n\n      if((isEnabled != enable) || persistent) {\n          if(enable) {\n          #ifdef WM_DEBUG_LEVEL\n          \tif(persistent) DEBUG_WM(WM_DEBUG_DEV,F(\"enableSTA PERSISTENT ON\"));\n            #endif\n              return WiFi_Mode(newMode,persistent);\n          }\n          else {\n              return WiFi_Mode(newMode,persistent);\n          }\n      } else {\n          return true;\n      }\n    #elif defined(ESP32)\n      bool ret;\n      if(persistent && esp32persistent) WiFi.persistent(true);\n      ret =  WiFi.enableSTA(enable); // @todo handle persistent when it is implemented in platform\n      if(persistent && esp32persistent) WiFi.persistent(false);\n      return ret;\n    #endif\n}\n\nbool WiFiManager::WiFi_enableSTA(bool enable) {\n\treturn WiFi_enableSTA(enable,false);\n}\n\nbool WiFiManager::WiFi_eraseConfig() {\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_DEV,F(\"WiFi_eraseConfig\"));\n    #endif\n\n    #ifdef ESP8266\n      #ifndef WM_FIXERASECONFIG \n        return ESP.eraseConfig();\n      #else\n        // erase config BUG replacement\n        // https://github.com/esp8266/Arduino/pull/3635\n        const size_t cfgSize = 0x4000;\n        size_t cfgAddr = ESP.getFlashChipSize() - cfgSize;\n\n        for (size_t offset = 0; offset < cfgSize; offset += SPI_FLASH_SEC_SIZE) {\n            if (!ESP.flashEraseSector((cfgAddr + offset) / SPI_FLASH_SEC_SIZE)) {\n                return false;\n            }\n        }\n        return true;\n      #endif\n    #elif defined(ESP32)\n\n      bool ret;\n      WiFi.mode(WIFI_AP_STA); // cannot erase if not in STA mode !\n      WiFi.persistent(true);\n      ret = WiFi.disconnect(true,true); // disconnect(bool wifioff, bool eraseap)\n      delay(500);\n      WiFi.persistent(false);\n      return ret;\n    #endif\n}\n\nuint8_t WiFiManager::WiFi_softap_num_stations(){\n  #ifdef ESP8266\n    return wifi_softap_get_station_num();\n  #elif defined(ESP32)\n    return WiFi.softAPgetStationNum();\n  #endif\n}\n\nbool WiFiManager::WiFi_hasAutoConnect(){\n  return WiFi_SSID(true) != \"\";\n}\n\nString WiFiManager::WiFi_SSID(bool persistent) const{\n\n    #ifdef ESP8266\n    struct station_config conf;\n    if(persistent) wifi_station_get_config_default(&conf);\n    else wifi_station_get_config(&conf);\n\n    char tmp[33]; //ssid can be up to 32chars, => plus null term\n    memcpy(tmp, conf.ssid, sizeof(conf.ssid));\n    tmp[32] = 0; //nullterm in case of 32 char ssid\n    return String(reinterpret_cast<char*>(tmp));\n    \n    #elif defined(ESP32)\n    // bool res = WiFi.wifiLowLevelInit(true); // @todo fix for S3, not found\n    // wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    if(persistent){\n      wifi_config_t conf;\n      esp_wifi_get_config(WIFI_IF_STA, &conf);\n      return String(reinterpret_cast<const char*>(conf.sta.ssid));\n    }\n    else {\n      if(WiFiGenericClass::getMode() == WIFI_MODE_NULL){\n          return String();\n      }\n      wifi_ap_record_t info;\n      if(!esp_wifi_sta_get_ap_info(&info)) {\n          return String(reinterpret_cast<char*>(info.ssid));\n      }\n      return String();\n    }\n    #endif\n}\n\nString WiFiManager::WiFi_psk(bool persistent) const {\n    #ifdef ESP8266\n    struct station_config conf;\n\n    if(persistent) wifi_station_get_config_default(&conf);\n    else wifi_station_get_config(&conf);\n\n    char tmp[65]; //psk is 64 bytes hex => plus null term\n    memcpy(tmp, conf.password, sizeof(conf.password));\n    tmp[64] = 0; //null term in case of 64 byte psk\n    return String(reinterpret_cast<char*>(tmp));\n    \n    #elif defined(ESP32)\n    // only if wifi is init\n    if(WiFiGenericClass::getMode() == WIFI_MODE_NULL){\n      return String();\n    }\n    wifi_config_t conf;\n    esp_wifi_get_config(WIFI_IF_STA, &conf);\n    return String(reinterpret_cast<char*>(conf.sta.password));\n    #endif\n}\n\n#ifdef ESP32\n  #ifdef WM_ARDUINOEVENTS\n  void WiFiManager::WiFiEvent(WiFiEvent_t event,arduino_event_info_t info){\n  #else\n  void WiFiManager::WiFiEvent(WiFiEvent_t event,system_event_info_t info){\n    #define wifi_sta_disconnected disconnected\n    #define ARDUINO_EVENT_WIFI_STA_DISCONNECTED SYSTEM_EVENT_STA_DISCONNECTED\n    #define ARDUINO_EVENT_WIFI_SCAN_DONE SYSTEM_EVENT_SCAN_DONE\n  #endif\n    if(!_hasBegun){\n      #ifdef WM_DEBUG_LEVEL\n        // DEBUG_WM(WM_DEBUG_VERBOSE,\"[ERROR] WiFiEvent, not ready\");\n      #endif\n      // Serial.println(F(\"\\n[EVENT] WiFiEvent logging (wm debug not available)\"));\n      // Serial.print(F(\"[EVENT] ID: \"));\n      // Serial.println(event);\n      return;\n    }\n    #ifdef WM_DEBUG_LEVEL\n    // DEBUG_WM(WM_DEBUG_VERBOSE,\"[EVENT]\",event);\n    #endif\n    if(event == ARDUINO_EVENT_WIFI_STA_DISCONNECTED){\n    #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[EVENT] WIFI_REASON: \"),info.wifi_sta_disconnected.reason);\n      #endif\n      if(info.wifi_sta_disconnected.reason == WIFI_REASON_AUTH_EXPIRE || info.wifi_sta_disconnected.reason == WIFI_REASON_AUTH_FAIL){\n        _lastconxresulttmp = 7; // hack in wrong password internally, sdk emit WIFI_REASON_AUTH_EXPIRE on some routers on auth_fail\n      } else _lastconxresulttmp = WiFi.status();\n      #ifdef WM_DEBUG_LEVEL\n      if(info.wifi_sta_disconnected.reason == WIFI_REASON_NO_AP_FOUND) DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[EVENT] WIFI_REASON: NO_AP_FOUND\"));\n      if(info.wifi_sta_disconnected.reason == WIFI_REASON_ASSOC_FAIL){\n        if(_aggresiveReconn && _connectRetries<4) _connectRetries=4;\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[EVENT] WIFI_REASON: AUTH FAIL\"));\n      }  \n      #endif\n      #ifdef esp32autoreconnect\n      #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_VERBOSE,F(\"[Event] SYSTEM_EVENT_STA_DISCONNECTED, reconnecting\"));\n        #endif\n        WiFi.reconnect();\n      #endif\n  }\n  else if(event == ARDUINO_EVENT_WIFI_SCAN_DONE && _asyncScan){\n    uint16_t scans = WiFi.scanComplete();\n    WiFi_scanComplete(scans);\n  }\n}\n#endif\n\nvoid WiFiManager::WiFi_autoReconnect(){\n  #ifdef ESP8266\n    WiFi.setAutoReconnect(_wifiAutoReconnect);\n  #elif defined(ESP32)\n    // if(_wifiAutoReconnect){\n      // @todo move to seperate method, used for event listener now\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"ESP32 event handler enabled\"));\n      #endif\n      using namespace std::placeholders;\n      if(wm_event_id == 0) wm_event_id = WiFi.onEvent(std::bind(&WiFiManager::WiFiEvent,this,_1,_2));\n    // }\n  #endif\n}\n\n// Called when /update is requested\nvoid WiFiManager::handleUpdate() {\n  #ifdef WM_DEBUG_LEVEL\n\tDEBUG_WM(WM_DEBUG_VERBOSE,F(\"<- Handle update\"));\n  #endif\n\tif (captivePortal()) return; // If captive portal redirect instead of displaying the page\n\tString page = getHTTPHead(_title, FPSTR(C_update)); // @token options\n\tString str = FPSTR(HTTP_ROOT_MAIN);\n  str.replace(FPSTR(T_t), _title);\n\tstr.replace(FPSTR(T_v), configPortalActive ? _apName : (getWiFiHostname() + \" - \" + WiFi.localIP().toString())); // use ip if ap is not active for heading\n\tpage += str;\n\n\tpage += FPSTR(HTTP_UPDATE);\n\tpage += getHTTPEnd();\n\n\tHTTPSend(page);\n\n}\n\n// upload via /u POST\nvoid WiFiManager::handleUpdating(){\n  // @todo\n  // cannot upload files in captive portal, file select is not allowed, show message with link or hide\n  // cannot upload if softreset after upload, maybe check for hard reset at least for dev, ERROR[11]: Invalid bootstrapping state, reset ESP8266 before updating\n  // add upload status to webpage somehow\n  // abort upload if error detected ?\n  // [x] supress cp timeout on upload, so it doesnt keep uploading?\n  // add progress handler for debugging\n  // combine route handlers into one callback and use argument or post checking instead of mutiple functions maybe, if POST process else server upload page?\n  // [x] add upload checking, do we need too check file?\n  // convert output to debugger if not moving to example\n\t\n  // if (captivePortal()) return; // If captive portal redirect instead of displaying the page\n  bool error = false;\n  unsigned long _configPortalTimeoutSAV = _configPortalTimeout; // store cp timeout\n  _configPortalTimeout = 0; // disable timeout\n\n  // handler for the file upload, get's the sketch bytes, and writes\n\t// them through the Update object\n\tHTTPUpload& upload = server->upload();\n\n  // UPLOAD START\n\tif (upload.status == UPLOAD_FILE_START) {\n\t  // if(_debug) Serial.setDebugOutput(true);\n    uint32_t maxSketchSpace;\n    \n    // Use new callback for before OTA update\n    if (_preotaupdatecallback != NULL) {\n      _preotaupdatecallback();  // @CALLBACK\n    }\n    #ifdef ESP8266\n    \t\tWiFiUDP::stopAll();\n    \t\tmaxSketchSpace = (ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000;\n    #elif defined(ESP32)\n          // Think we do not need to stop WiFIUDP because we haven't started a listener\n    \t\t  // maxSketchSpace = (ESP.getFlashChipSize() - 0x1000) & 0xFFFFF000;\n          // #define UPDATE_SIZE_UNKNOWN 0xFFFFFFFF // include update.h\n          maxSketchSpace = UPDATE_SIZE_UNKNOWN;\n    #endif\n\n    #ifdef WM_DEBUG_LEVEL\n    DEBUG_WM(WM_DEBUG_VERBOSE,\"[OTA] Update file: \", upload.filename.c_str());\n    #endif\n\n    // Update.onProgress(THandlerFunction_Progress fn);\n    // Update.onProgress([](unsigned int progress, unsigned int total) {\n    //       Serial.printf(\"Progress: %u%%\\r\", (progress / (total / 100)));\n    // });\n\n  \tif (!Update.begin(maxSketchSpace)) { // start with max available size\n        #ifdef WM_DEBUG_LEVEL\n        DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] OTA Update ERROR\"), Update.getError());\n        #endif\n        error = true;\n        Update.end(); // Not sure the best way to abort, I think client will keep sending..\n  \t}\n\t}\n  // UPLOAD WRITE\n  else if (upload.status == UPLOAD_FILE_WRITE) {\n\t\t// Serial.print(\".\");\n\t\tif (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_ERROR,F(\"[ERROR] OTA Update WRITE ERROR\"), Update.getError());\n\t\t\t//Update.printError(Serial); // write failure\n      #endif\n      error = true;\n\t\t}\n\t}\n  // UPLOAD FILE END\n  else if (upload.status == UPLOAD_FILE_END) {\n\t\tif (Update.end(true)) { // true to set the size to the current progress\n      #ifdef WM_DEBUG_LEVEL\n      DEBUG_WM(WM_DEBUG_VERBOSE,F(\"\\n\\n[OTA] OTA FILE END bytes: \"), upload.totalSize);\n\t\t\t// Serial.printf(\"Updated: %u bytes\\r\\nRebooting...\\r\\n\", upload.totalSize);\n      #endif\n\t\t}\n    else {\n\t\t\t// Update.printError(Serial);\n      error = true;\n\t\t}\n\t}\n  // UPLOAD ABORT\n  else if (upload.status == UPLOAD_FILE_ABORTED) {\n\t\tUpdate.end();\n\t\tDEBUG_WM(F(\"[OTA] Update was aborted\"));\n    error = true;\n  }\n  if(error) _configPortalTimeout = _configPortalTimeoutSAV;\n\tdelay(0);\n}\n\n// upload and ota done, show status\nvoid WiFiManager::handleUpdateDone() {\n\tDEBUG_WM(WM_DEBUG_VERBOSE, F(\"<- Handle update done\"));\n\t// if (captivePortal()) return; // If captive portal redirect instead of displaying the page\n\n\tString page = getHTTPHead(FPSTR(S_options), FPSTR(C_update)); // @token options\n\tString str  = FPSTR(HTTP_ROOT_MAIN);\n  str.replace(FPSTR(T_t),_title);\n\tstr.replace(FPSTR(T_v), configPortalActive ? _apName : WiFi.localIP().toString()); // use ip if ap is not active for heading\n\tpage += str;\n\n\tif (Update.hasError()) {\n\t\tpage += FPSTR(HTTP_UPDATE_FAIL);\n    #ifdef ESP32\n    page += \"OTA Error: \" + (String)Update.errorString();\n    #else\n    page += \"OTA Error: \" + (String)Update.getError();\n    #endif\n\t\tDEBUG_WM(F(\"[OTA] update failed\"));\n\t}\n\telse {\n\t\tpage += FPSTR(HTTP_UPDATE_SUCCESS);\n\t\tDEBUG_WM(F(\"[OTA] update ok\"));\n\t}\n\tpage += getHTTPEnd();\n\n\tHTTPSend(page);\n\n\tdelay(1000); // send page\n\tif (!Update.hasError()) {\n\t\tESP.restart();\n\t}\n}\n\n#endif\n"
        },
        {
          "name": "WiFiManager.h",
          "type": "blob",
          "size": 34.7158203125,
          "content": "/**\n * WiFiManager.h\n * \n * WiFiManager, a library for the ESP8266/Arduino platform\n * for configuration of WiFi credentials using a Captive Portal\n * \n * @author Creator tzapu\n * @author tablatronix\n * @version 0.0.0\n * @license MIT\n */\n\n\n#ifndef WiFiManager_h\n#define WiFiManager_h\n\n#if defined(ESP8266) || defined(ESP32)\n\n#ifdef ESP8266\n#include <core_version.h>\n#endif\n\n#include <vector>\n\n// #define WM_MDNS            // includes MDNS, also set MDNS with sethostname\n// #define WM_FIXERASECONFIG  // use erase flash fix\n// #define WM_ERASE_NVS       // esp32 erase(true) will erase NVS \n// #define WM_RTC             // esp32 info page will include reset reasons\n\n// #define WM_JSTEST                      // build flag for enabling js xhr tests\n// #define WIFI_MANAGER_OVERRIDE_STRINGS // build flag for using own strings include\n\n#ifdef ARDUINO_ESP8266_RELEASE_2_3_0\n#warning \"ARDUINO_ESP8266_RELEASE_2_3_0, some WM features disabled\" \n// @todo check failing on platform = espressif8266@1.7.3\n#define WM_NOASYNC         // esp8266 no async scan wifi\n#define WM_NOCOUNTRY       // esp8266 no country\n#define WM_NOAUTH          // no httpauth\n#define WM_NOSOFTAPSSID    // no softapssid() @todo shim\n#endif\n\n// #ifdef CONFIG_IDF_TARGET_ESP32S2\n// #warning ESP32S2\n// #endif\n\n// #ifdef CONFIG_IDF_TARGET_ESP32C3\n// #warning ESP32C3\n// #endif\n\n// #ifdef CONFIG_IDF_TARGET_ESP32S3\n// #warning ESP32S3\n// #endif\n\n// #if defined(ARDUINO_ESP32S3_DEV) || defined(CONFIG_IDF_TARGET_ESP32S3)\n// #warning \"WM_NOTEMP\"\n// #define WM_NOTEMP // disabled temp sensor, have to determine which chip we are on\n// #endif\n\n// #include \"soc/efuse_reg.h\" // include to add efuse chip rev to info, getChipRevision() is almost always the same though, so not sure why it matters.\n\n// #define esp32autoreconnect    // implement esp32 autoreconnect event listener kludge, @DEPRECATED\n// autoreconnect is WORKING https://github.com/espressif/arduino-esp32/issues/653#issuecomment-405604766\n\n#define WM_WEBSERVERSHIM      // use webserver shim lib\n\n#define WM_G(string_literal)  (String(FPSTR(string_literal)).c_str())\n\n#ifdef ESP8266\n\n    extern \"C\" {\n      #include \"user_interface.h\"\n    }\n    #include <ESP8266WiFi.h>\n    #include <ESP8266WebServer.h>\n\n    #ifdef WM_MDNS\n        #include <ESP8266mDNS.h>\n    #endif\n\n    #define WIFI_getChipId() ESP.getChipId() \n    #define WM_WIFIOPEN   ENC_TYPE_NONE\n\n#elif defined(ESP32)\n\n    #include <WiFi.h>\n    #include <esp_wifi.h>  \n    #include <Update.h>\n    \n    #define WIFI_getChipId() (uint32_t)ESP.getEfuseMac()\n    #define WM_WIFIOPEN   WIFI_AUTH_OPEN\n\n    #ifndef WEBSERVER_H\n        #ifdef WM_WEBSERVERSHIM\n            #include <WebServer.h>\n        #else\n            #include <ESP8266WebServer.h>\n            // Forthcoming official ? probably never happening\n            // https://github.com/esp8266/ESPWebServer\n        #endif\n    #endif\n\n    #ifdef WM_ERASE_NVS\n       #include <nvs.h>\n       #include <nvs_flash.h>\n    #endif\n\n    #ifdef WM_MDNS\n        #include <ESPmDNS.h>\n    #endif\n\n    #ifdef WM_RTC\n        #ifdef ESP_IDF_VERSION_MAJOR // IDF 4+\n        #if CONFIG_IDF_TARGET_ESP32 // ESP32/PICO-D4\n        #include \"esp32/rom/rtc.h\"\n        #elif CONFIG_IDF_TARGET_ESP32S2\n        #include \"esp32s2/rom/rtc.h\"\n        #elif CONFIG_IDF_TARGET_ESP32C3\n        #include \"esp32c3/rom/rtc.h\"\n        #elif CONFIG_IDF_TARGET_ESP32S3\n        #include \"esp32s3/rom/rtc.h\"\n        #else\n        #error Target CONFIG_IDF_TARGET is not supported\n        #endif\n        #else // ESP32 Before IDF 4.0\n        #include \"rom/rtc.h\"\n        #endif\n    #endif\n\n#else\n#endif\n\n#include <DNSServer.h>\n#include <memory>\n\n\n// Include wm strings vars\n// Pass in strings env override via WM_STRINGS_FILE\n#ifndef WM_STRINGS_FILE\n#define WM_STRINGS_FILE \"wm_strings_en.h\" // this includes constants as dependency\n#endif\n#include WM_STRINGS_FILE\n\n// prep string concat vars\n#define WM_STRING2(x) #x\n#define WM_STRING(x) WM_STRING2(x)    \n\n// #include <esp_idf_version.h>\n#ifdef ESP_IDF_VERSION\n    // #pragma message \"ESP_IDF_VERSION_MAJOR = \" WM_STRING(ESP_IDF_VERSION_MAJOR)\n    // #pragma message \"ESP_IDF_VERSION_MINOR = \" WM_STRING(ESP_IDF_VERSION_MINOR)\n    // #pragma message \"ESP_IDF_VERSION_PATCH = \" WM_STRING(ESP_IDF_VERSION_PATCH)\n    #define VER_IDF_STR WM_STRING(ESP_IDF_VERSION_MAJOR)  \".\"  WM_STRING(ESP_IDF_VERSION_MINOR)  \".\"  WM_STRING(ESP_IDF_VERSION_PATCH)\n#else \n    #define VER_IDF_STR \"Unknown\"\n#endif\n\n#ifdef Arduino_h\n    #ifdef ESP32\n    // #include \"esp_arduino_version.h\" // esp32 arduino > 2.x\n    #endif\n    // esp_get_idf_version\n    #ifdef ESP_ARDUINO_VERSION\n        // #pragma message \"ESP_ARDUINO_VERSION_MAJOR = \" WM_STRING(ESP_ARDUINO_VERSION_MAJOR)\n        // #pragma message \"ESP_ARDUINO_VERSION_MINOR = \" WM_STRING(ESP_ARDUINO_VERSION_MINOR)\n        // #pragma message \"ESP_ARDUINO_VERSION_PATCH = \" WM_STRING(ESP_ARDUINO_VERSION_PATCH)\n        #ifdef ESP_ARDUINO_VERSION_MAJOR\n        #define VER_ARDUINO_STR WM_STRING(ESP_ARDUINO_VERSION_MAJOR)  \".\"  WM_STRING(ESP_ARDUINO_VERSION_MINOR)  \".\"  WM_STRING(ESP_ARDUINO_VERSION_PATCH)\n        #else\n        #define VER_ARDUINO_STR \"Unknown\"\n        #endif\n    #else\n        #include <core_version.h>\n        // #pragma message \"ESP_ARDUINO_VERSION_GIT  = \" WM_STRING(ARDUINO_ESP32_GIT_VER)//  0x46d5afb1\n        // #pragma message \"ESP_ARDUINO_VERSION_DESC = \" WM_STRING(ARDUINO_ESP32_GIT_DESC) //  1.0.6\n        // #pragma message \"ESP_ARDUINO_VERSION_REL  = \" WM_STRING(ARDUINO_ESP32_RELEASE) //\"1_0_6\"\n        #ifdef ESP_ARDUINO_VERSION_MAJOR\n        #define VER_ARDUINO_STR WM_STRING(ESP_ARDUINO_VERSION_MAJOR)  \".\"  WM_STRING(ESP_ARDUINO_VERSION_MINOR)  \".\"  WM_STRING(ESP_ARDUINO_VERSION_PATCH)\n        #else\n        #define VER_ARDUINO_STR \"Unknown\"\n        #endif\n    #endif\n#else \n#define VER_ARDUINO_STR \"Unknown\"\n#endif\n\n// #pragma message \"VER_IDF_STR = \" WM_STRING(VER_IDF_STR)\n// #pragma message \"VER_ARDUINO_STR = \" WM_STRING(VER_ARDUINO_STR)\n\n#ifndef WIFI_MANAGER_MAX_PARAMS\n    #define WIFI_MANAGER_MAX_PARAMS 5 // params will autoincrement and realloc by this amount when max is reached\n#endif\n\n#define WFM_LABEL_BEFORE 1\n#define WFM_LABEL_AFTER 2\n#define WFM_NO_LABEL 0\n#define WFM_LABEL_DEFAULT 1\n\nclass WiFiManagerParameter {\n  public:\n    /** \n        Create custom parameters that can be added to the WiFiManager setup web page\n        @id is used for HTTP queries and must not contain spaces nor other special characters\n    */\n    WiFiManagerParameter();\n    WiFiManagerParameter(const char *custom);\n    WiFiManagerParameter(const char *id, const char *label);\n    WiFiManagerParameter(const char *id, const char *label, const char *defaultValue, int length);\n    WiFiManagerParameter(const char *id, const char *label, const char *defaultValue, int length, const char *custom);\n    WiFiManagerParameter(const char *id, const char *label, const char *defaultValue, int length, const char *custom, int labelPlacement);\n    ~WiFiManagerParameter();\n    // WiFiManagerParameter& operator=(const WiFiManagerParameter& rhs);\n\n    const char *getID() const;\n    const char *getValue() const;\n    const char *getLabel() const;\n    const char *getPlaceholder() const; // @deprecated, use getLabel\n    int         getValueLength() const;\n    int         getLabelPlacement() const;\n    virtual const char *getCustomHTML() const;\n    void        setValue(const char *defaultValue, int length);\n\n  protected:\n    void init(const char *id, const char *label, const char *defaultValue, int length, const char *custom, int labelPlacement);\n\n    WiFiManagerParameter& operator=(const WiFiManagerParameter&);\n    const char *_id;\n    const char *_label;\n    char       *_value;\n    int         _length;\n    int         _labelPlacement;\n  \n    const char *_customHTML;\n    friend class WiFiManager;\n};\n\n\n    // debugging\n    typedef enum {\n        WM_DEBUG_SILENT    = 0, // debug OFF but still compiled for runtime\n        WM_DEBUG_ERROR     = 1, // error only\n        WM_DEBUG_NOTIFY    = 2, // default stable,INFO\n        WM_DEBUG_VERBOSE   = 3, // move verbose info\n        WM_DEBUG_DEV       = 4, // development useful debugging info\n        WM_DEBUG_MAX       = 5  // MAX extra dev auditing, var dumps etc (MAX+1 will print timing,mem and frag info)\n    } wm_debuglevel_t;\n\nclass WiFiManager\n{\n  public:\n    WiFiManager(Print& consolePort);\n    WiFiManager();\n    ~WiFiManager();\n    void WiFiManagerInit();\n\n    // auto connect to saved wifi, or custom, and start config portal on failures\n    boolean       autoConnect();\n    boolean       autoConnect(char const *apName, char const *apPassword = NULL);\n\n    //manually start the config portal, autoconnect does this automatically on connect failure\n    boolean       startConfigPortal(); // auto generates apname\n    boolean       startConfigPortal(char const *apName, char const *apPassword = NULL);\n\n    //manually stop the config portal if started manually, stop immediatly if non blocking, flag abort if blocking\n    bool          stopConfigPortal();\n    \n    //manually start the web portal, autoconnect does this automatically on connect failure    \n    void          startWebPortal();\n\n    //manually stop the web portal if started manually\n    void          stopWebPortal();\n\n    // Run webserver processing, if setConfigPortalBlocking(false)\n    boolean       process();\n\n    // get the AP name of the config portal, so it can be used in the callback\n    String        getConfigPortalSSID();\n    int           getRSSIasQuality(int RSSI);\n\n    // erase wifi credentials\n    void          resetSettings();\n\n    // reboot esp\n    void          reboot();\n\n    // disconnect wifi, without persistent saving or erasing\n    bool          disconnect();\n\n    // erase esp\n    bool          erase();\n    bool          erase(bool opt);\n\n    //adds a custom parameter, returns false on failure\n    bool          addParameter(WiFiManagerParameter *p);\n\n    //returns the list of Parameters\n    WiFiManagerParameter** getParameters();\n\n    // returns the Parameters Count\n    int           getParametersCount();\n\n    // SET CALLBACKS\n\n    //called after AP mode and config portal has started\n    void          setAPCallback( std::function<void(WiFiManager*)> func );\n\n    //called after webserver has started\n    void          setWebServerCallback( std::function<void()> func );\n\n    //called when settings reset have been triggered\n    void          setConfigResetCallback( std::function<void()> func );\n\n    //called when wifi settings have been changed and connection was successful ( or setBreakAfterConfig(true) )\n    void          setSaveConfigCallback( std::function<void()> func );\n\n    //called when saving params-in-wifi or params before anything else happens (eg wifi)\n    void          setPreSaveConfigCallback( std::function<void()> func );\n\n    //called when saving params before anything else happens\n    void          setPreSaveParamsCallback( std::function<void()> func );\n\n    //called when saving either params-in-wifi or params page\n    void          setSaveParamsCallback( std::function<void()> func );\n\n    //called just before doing OTA update\n    void          setPreOtaUpdateCallback( std::function<void()> func );\n\n    //called when config portal is timeout\n    void          setConfigPortalTimeoutCallback( std::function<void()> func );\n\n    //sets timeout before AP,webserver loop ends and exits even if there has been no setup.\n    //useful for devices that failed to connect at some point and got stuck in a webserver loop\n    //in seconds setConfigPortalTimeout is a new name for setTimeout, ! not used if setConfigPortalBlocking\n    void          setConfigPortalTimeout(unsigned long seconds);\n    void          setTimeout(unsigned long seconds); // @deprecated, alias\n\n    //sets timeout for which to attempt connecting, useful if you get a lot of failed connects\n    void          setConnectTimeout(unsigned long seconds);\n\n    // sets number of retries for autoconnect, force retry after wait failure exit\n    void          setConnectRetries(uint8_t numRetries); // default 1\n    \n    //sets timeout for which to attempt connecting on saves, useful if there are bugs in esp waitforconnectloop\n    void          setSaveConnectTimeout(unsigned long seconds);\n    \n    // lets you disable automatically connecting after save from webportal\n    void          setSaveConnect(bool connect = true);\n    \n    // toggle debug output\n    void          setDebugOutput(boolean debug);\n    void          setDebugOutput(boolean debug, String prefix); // log line prefix, default \"*wm:\"\n    void          setDebugOutput(boolean debug, wm_debuglevel_t level ); // log line prefix, default \"*wm:\"\n\n    //set min quality percentage to include in scan, defaults to 8% if not specified\n    void          setMinimumSignalQuality(int quality = 8);\n    \n    //sets a custom ip /gateway /subnet configuration\n    void          setAPStaticIPConfig(IPAddress ip, IPAddress gw, IPAddress sn);\n    \n    //sets config for a static IP\n    void          setSTAStaticIPConfig(IPAddress ip, IPAddress gw, IPAddress sn);\n    \n    //sets config for a static IP with DNS\n    void          setSTAStaticIPConfig(IPAddress ip, IPAddress gw, IPAddress sn, IPAddress dns);\n    \n    //if this is set, it will exit after config, even if connection is unsuccessful.\n    void          setBreakAfterConfig(boolean shouldBreak);\n    \n    // if this is set, portal will be blocking and wait until save or exit, \n    // is false user must manually `process()` to handle config portal,\n    // setConfigPortalTimeout is ignored in this mode, user is responsible for closing configportal\n    void          setConfigPortalBlocking(boolean shouldBlock);\n    \n    //add custom html at inside <head> for all pages\n    void          setCustomHeadElement(const char* html);\n\n    //add custom html at start of <body> for all pages\n    void          setCustomBodyHeader(const char* html);\n\n    //add custom html at end of <body> for all pages\n    void          setCustomBodyFooter(const char* html);\n\n    //if this is set, customise style\n    void          setCustomMenuHTML(const char* html);\n\n    //if this is true, remove duplicated Access Points - defaut true\n    void          setRemoveDuplicateAPs(boolean removeDuplicates);\n    \n    //setter for ESP wifi.persistent so we can remember it and restore user preference, as WIFi._persistent is protected\n    void          setRestorePersistent(boolean persistent);\n    \n    //if true, always show static net inputs, IP, subnet, gateway, else only show if set via setSTAStaticIPConfig\n    void          setShowStaticFields(boolean alwaysShow);\n    \n    //if true, always show static dns, esle only show if set via setSTAStaticIPConfig\n    void          setShowDnsFields(boolean alwaysShow);\n    \n    // toggle showing the saved wifi password in wifi form, could be a security issue.\n    void          setShowPassword(boolean show);\n    \n    //if false, disable captive portal redirection\n    void          setCaptivePortalEnable(boolean enabled);\n    \n    //if false, timeout captive portal even if a STA client connected to softAP (false), suggest disabling if captiveportal is open\n    void          setAPClientCheck(boolean enabled);\n    \n    //if true, reset timeout when webclient connects (true), suggest disabling if captiveportal is open    \n    void          setWebPortalClientCheck(boolean enabled);\n    \n    // if true, enable autoreconnecting\n    void          setWiFiAutoReconnect(boolean enabled);\n    \n    // if true, wifiscan will show percentage instead of quality icons, until we have better templating\n    void          setScanDispPerc(boolean enabled);\n    \n    // if true (default) then start the config portal from autoConnect if connection failed\n    void          setEnableConfigPortal(boolean enable);\n\n    // if true (default) then stop the config portal from autoConnect when wifi is saved\n    void          setDisableConfigPortal(boolean enable);\n\n    // set a custom hostname, sets sta and ap dhcp client id for esp32, and sta for esp8266\n    bool          setHostname(const char * hostname);\n    bool          setHostname(String hostname);\n\n    // show erase wifi onfig button on info page, true\n    void          setShowInfoErase(boolean enabled);\n\n    // show OTA upload button on info page\n    void          setShowInfoUpdate(boolean enabled);\n\n    // set ap channel\n    void          setWiFiAPChannel(int32_t channel);\n    \n    // set ap hidden\n    void          setWiFiAPHidden(bool hidden); // default false\n    \n    // clean connect, always disconnect before connecting\n    void          setCleanConnect(bool enable); // default false\n\n    // set custom menu items and order, vector or arr\n    // see _menutokens for ids\n    void          setMenu(std::vector<const char*>& menu);\n    void          setMenu(const char* menu[], uint8_t size);\n    \n    // set the webapp title, default WiFiManager\n    void          setTitle(String title);\n\n    // add params to its own menu page and remove from wifi, NOT TO BE COMBINED WITH setMenu!\n    void          setParamsPage(bool enable);\n\n    // get last connection result, includes autoconnect and wifisave\n    uint8_t       getLastConxResult();\n    \n    // get a status as string\n    String        getWLStatusString(uint8_t status);    \n    String        getWLStatusString();    \n\n    // get wifi mode as string\n    String        getModeString(uint8_t mode);\n\n    // check if the module has a saved ap to connect to\n    bool          getWiFiIsSaved();\n\n    // helper to get saved password, if persistent get stored, else get current if connected    \n    String        getWiFiPass(bool persistent = true);\n\n    // helper to get saved ssid, if persistent get stored, else get current if connected\n    String        getWiFiSSID(bool persistent = true);\n\n    // debug output the softap config\n    void          debugSoftAPConfig();\n\n    // debug output platform info and versioning\n    void          debugPlatformInfo();\n\n    // helper for html\n    String        htmlEntities(String str, bool whitespace = false);\n    \n    // set the country code for wifi settings, CN\n    void          setCountry(String cc);\n\n    // set body class (invert), may be used for hacking in alt classes\n    void          setClass(String str);\n\n    // set dark mode via invert class\n    void          setDarkMode(bool enable);\n\n    // get default ap esp uses , esp_chipid etc\n    String        getDefaultAPName();\n    \n    // set port of webserver, 80\n    void          setHttpPort(uint16_t port);\n\n    // check if config portal is active (true)\n    bool          getConfigPortalActive();\n    \n    // check if web portal is active (true)\n    bool          getWebPortalActive();\n\n    // to preload autoconnect for test fixtures or other uses that skip esp sta config\n    bool          preloadWiFi(String ssid, String pass);\n\n    // get hostname helper\n    String        getWiFiHostname();\n\n\n    std::unique_ptr<DNSServer>        dnsServer;\n\n    #if defined(ESP32) && defined(WM_WEBSERVERSHIM)\n        using WM_WebServer = WebServer;\n    #else\n        using WM_WebServer = ESP8266WebServer;\n    #endif\n    \n    std::unique_ptr<WM_WebServer> server;\n\n  protected:\n    // vars\n    std::vector<uint8_t> _menuIds;\n    std::vector<const char *> _menuIdsParams  = {\"wifi\",\"param\",\"info\",\"exit\"};\n    std::vector<const char *> _menuIdsUpdate  = {\"wifi\",\"param\",\"info\",\"update\",\"exit\"};\n    std::vector<const char *> _menuIdsDefault = {\"wifi\",\"info\",\"exit\",\"sep\",\"update\"};\n\n    // ip configs @todo struct ?\n    IPAddress     _ap_static_ip;\n    IPAddress     _ap_static_gw;\n    IPAddress     _ap_static_sn;\n    IPAddress     _sta_static_ip;\n    IPAddress     _sta_static_gw;\n    IPAddress     _sta_static_sn;\n    IPAddress     _sta_static_dns;\n\n    unsigned long _configPortalStart      = 0; // ms config portal start time (updated for timeouts)\n    unsigned long _webPortalAccessed      = 0; // ms last web access time\n    uint8_t       _lastconxresult         = WL_IDLE_STATUS; // store last result when doing connect operations\n    int           _numNetworks            = 0; // init index for numnetworks wifiscans\n    unsigned long _lastscan               = 0; // ms for timing wifi scans\n    unsigned long _startscan              = 0; // ms for timing wifi scans\n    unsigned long _startconn              = 0; // ms for timing wifi connects\n\n    // defaults\n    const uint8_t  DNS_PORT               = 53;\n    String        _apName                 = \"no-net\";\n    String        _apPassword             = \"\";\n    String        _ssid                   = \"\"; // var temp ssid\n    String        _pass                   = \"\"; // var temp psk\n    String        _defaultssid            = \"\"; // preload ssid\n    String        _defaultpass            = \"\"; // preload pass\n\n    // options flags\n    unsigned long _configPortalTimeout    = 0; // ms close config portal loop if set (depending on  _cp/webClientCheck options)\n    unsigned long _connectTimeout         = 0; // ms stop trying to connect to ap if set\n    unsigned long _saveTimeout            = 0; // ms stop trying to connect to ap on saves, in case bugs in esp waitforconnectresult\n    \n    WiFiMode_t    _usermode               = WIFI_STA; // Default user mode\n    String        _wifissidprefix         = FPSTR(S_ssidpre); // auto apname prefix prefix+chipid\n    int           _cpclosedelay           = 2000; // delay before wifisave, prevents captive portal from closing to fast.\n    bool          _cleanConnect           = false; // disconnect before connect in connectwifi, increases stability on connects\n    bool          _connectonsave          = true; // connect to wifi when saving creds\n    bool          _disableSTA             = false; // disable sta when starting ap, always\n    bool          _disableSTAConn         = true;  // disable sta when starting ap, if sta is not connected ( stability )\n    bool          _channelSync            = false; // use same wifi sta channel when starting ap\n    int32_t       _apChannel              = 0; // default channel to use for ap, 0 for auto\n    bool          _apHidden               = false; // store softap hidden value\n    uint16_t      _httpPort               = 80; // port for webserver\n    // uint8_t       _retryCount             = 0; // counter for retries, probably not needed if synchronous\n    uint8_t       _connectRetries         = 1; // number of sta connect retries, force reconnect, wait loop (connectimeout) does not always work and first disconnect bails\n    bool          _aggresiveReconn        = false; // use an agrressive reconnect strategy, WILL delay conxs\n                                                   // on some conn failure modes will add delays and many retries to work around esp and ap bugs, ie, anti de-auth protections\n                                                   // https://github.com/tzapu/WiFiManager/issues/1067\n    bool          _allowExit              = true; // allow exit in nonblocking, else user exit/abort calls will be ignored including cptimeout\n\n    #ifdef ESP32\n    wifi_event_id_t wm_event_id           = 0;\n    static uint8_t _lastconxresulttmp; // tmp var for esp32 callback\n    #endif\n\n    #ifndef WL_STATION_WRONG_PASSWORD\n    uint8_t WL_STATION_WRONG_PASSWORD     = 7; // @kludge define a WL status for wrong password\n    #endif\n\n    // parameter options\n    int           _minimumQuality         = -1;    // filter wifiscan ap by this rssi\n    int           _staShowStaticFields    = 0;     // ternary 1=always show static ip fields, 0=only if set, -1=never(cannot change ips via web!)\n    int           _staShowDns             = 0;     // ternary 1=always show dns, 0=only if set, -1=never(cannot change dns via web!)\n    boolean       _removeDuplicateAPs     = true;  // remove dup aps from wifiscan\n    boolean       _showPassword           = false; // show or hide saved password on wifi form, might be a security issue!\n    boolean       _shouldBreakAfterConfig = false; // stop configportal on save failure\n    boolean       _configPortalIsBlocking = true;  // configportal enters blocking loop \n    boolean       _enableCaptivePortal    = true;  // enable captive portal redirection\n    boolean       _userpersistent         = true;  // users preffered persistence to restore\n    boolean       _wifiAutoReconnect      = true;  // there is no platform getter for this, we must assume its true and make it so\n    boolean       _apClientCheck          = false; // keep cp alive if ap have station\n    boolean       _webClientCheck         = true;  // keep cp alive if web have client\n    boolean       _scanDispOptions        = false; // show percentage in scans not icons\n    boolean       _paramsInWifi           = true;  // show custom parameters on wifi page\n    boolean       _showInfoErase          = true;  // info page erase button\n    boolean       _showInfoUpdate         = true;  // info page update button\n    boolean       _showBack               = false; // show back button\n    boolean       _enableConfigPortal     = true;  // FOR autoconnect - start config portal if autoconnect failed\n    boolean       _disableConfigPortal    = true;  // FOR autoconnect - stop config portal if cp wifi save\n    String        _hostname               = \"\";    // hostname for esp8266 for dhcp, and or MDNS\n\n    const char*   _customHeadElement      = \"\"; // store custom head element html from user inside <head>\n    const char*   _customBodyHeader       = \"\"; // store custom top body element html from user inside <body>\n    const char*   _customBodyFooter       = \"\"; // store custom bottom body element html from user inside <body>\n    const char*   _customMenuHTML         = \"\"; // store custom menu html from user\n    String        _bodyClass              = \"\"; // class to add to body\n    String        _title                  = FPSTR(S_brand); // app title -  default WiFiManager\n\n    // internal options\n    \n    // wifiscan notes\n    // currently disabled due to issues with caching, sometimes first scan is empty esp32 wifi not init yet race, or portals hit server nonstop flood\n    // The following are background wifi scanning optimizations\n    // experimental to make scans faster, preload scans after starting cp, and visiting home page, so when you click wifi its already has your list\n    // ideally we would add async and xhr here but I am holding off on js requirements atm\n    // might be slightly buggy since captive portals hammer the home page, @todo workaround this somehow.\n    // cache time helps throttle this\n    // async enables asyncronous scans, so they do not block anything\n    // the refresh button bypasses cache\n    // no aps found is problematic as scans are always going to want to run, leading to page load delays\n    // \n    // These settings really only make sense with _preloadwifiscan true\n    // but not limited to, we could run continuous background scans on various page hits, or xhr hits\n    // which would be better coupled with asyncscan\n    // atm preload is only done on root hit and startcp\n    // \n    // preload scanning causes AP to delay showing for users, but also caches and lets the cp load faster once its open\n    //  my scan takes 7-10 seconds\npublic:\n    boolean       _preloadwifiscan        = false; // preload wifiscan if true\n    unsigned int  _scancachetime          = 30000; // ms cache time for preload scans\n    boolean       _asyncScan              = false; // perform wifi network scan async\n    \nprotected:\n\n    boolean       _autoforcerescan        = false;  // automatically force rescan if scan networks is 0, ignoring cache\n    \n    boolean       _disableIpFields        = false; // modify function of setShow_X_Fields(false), forces ip fields off instead of default show if set, eg. _staShowStaticFields=-1\n\n    String        _wificountry            = \"\";  // country code, @todo define in strings lang\n\n    // wrapper functions for handling setting and unsetting persistent for now.\n    bool          esp32persistent         = false;\n    bool          _hasBegun               = false; // flag wm loaded,unloaded\n    void          _begin();\n    void          _end();\n\n    void          setupConfigPortal();\n    bool          shutdownConfigPortal();\n    bool          setupHostname(bool restart);\n    \n#ifdef NO_EXTRA_4K_HEAP\n    boolean       _tryWPS                 = false; // try WPS on save failure, unsupported\n    void          startWPS();\n#endif\n\n    bool          startAP();\n    void          setupDNSD();\n    void          setupHTTPServer();\n\n    uint8_t       connectWifi(String ssid, String pass, bool connect = true);\n    bool          setSTAConfig();\n    bool          wifiConnectDefault();\n    bool          wifiConnectNew(String ssid, String pass,bool connect = true);\n\n    uint8_t       waitForConnectResult();\n    uint8_t       waitForConnectResult(uint32_t timeout);\n    void          updateConxResult(uint8_t status);\n\n    // webserver handlers\npublic:\n    void          handleNotFound();\nprotected:\n    void          HTTPSend(const String &content);\n    void          handleRoot();\n    void          handleWifi(boolean scan);\n    void          handleWifiSave();\n    void          handleInfo();\n    void          handleReset();\n\n    void          handleExit();\n    void          handleClose();\n    // void          handleErase();\n    void          handleErase(boolean opt);\n    void          handleParam();\n    void          handleWiFiStatus();\n    void          handleRequest();\n    void          handleParamSave();\n    void          doParamSave();\n\n    boolean       captivePortal();\n    boolean       configPortalHasTimeout();\n    uint8_t       processConfigPortal();\n    void          stopCaptivePortal();\n\t// OTA Update handler\n\tvoid          handleUpdate();\n\tvoid          handleUpdating();\n\tvoid          handleUpdateDone();\n\n\n    // wifi platform abstractions\n    bool          WiFi_Mode(WiFiMode_t m);\n    bool          WiFi_Mode(WiFiMode_t m,bool persistent);\n    bool          WiFi_Disconnect();\n    bool          WiFi_enableSTA(bool enable);\n    bool          WiFi_enableSTA(bool enable,bool persistent);\n    bool          WiFi_eraseConfig();\n    uint8_t       WiFi_softap_num_stations();\n    bool          WiFi_hasAutoConnect();\n    void          WiFi_autoReconnect();\n    String        WiFi_SSID(bool persistent = true) const;\n    String        WiFi_psk(bool persistent = true) const;\n    bool          WiFi_scanNetworks();\n    bool          WiFi_scanNetworks(bool force,bool async);\n    bool          WiFi_scanNetworks(unsigned int cachetime,bool async);\n    bool          WiFi_scanNetworks(unsigned int cachetime);\n    void          WiFi_scanComplete(int networksFound);\n    bool          WiFiSetCountry();\n\n    #ifdef ESP32\n\n    // check for arduino or system event system, handle esp32 arduino v2 and IDF\n    #if defined(ESP_ARDUINO_VERSION) && defined(ESP_ARDUINO_VERSION_VAL)\n\n        #define WM_ARDUINOVERCHECK ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(2, 0, 0)\n        #define WM_ARDUINOVERCHECK_204 ESP_ARDUINO_VERSION <= ESP_ARDUINO_VERSION_VAL(2, 0, 5)\n\n        #ifdef WM_ARDUINOVERCHECK\n            #define WM_ARDUINOEVENTS\n        #else\n            #define WM_NOSOFTAPSSID\n            #define WM_NOCOUNTRY\n        #endif\n\n        #ifdef WM_ARDUINOVERCHECK_204\n            #define WM_DISCONWORKAROUND\n        #endif\n\n    #else \n        #define WM_NOCOUNTRY\n    #endif\n\n    #ifdef WM_NOCOUNTRY\n        #warning \"ESP32 set country unavailable\" \n    #endif\n\n\n    #ifdef WM_ARDUINOEVENTS\n        void   WiFiEvent(WiFiEvent_t event, arduino_event_info_t info);\n    #else\n        void   WiFiEvent(WiFiEvent_t event, system_event_info_t info);\n    #endif\n    #endif\n\n    // output helpers\n    String        getParamOut();\n    String        getIpForm(String id, String title, String value);\n    String        getScanItemOut();\n    String        getStaticOut();\n    String        getHTTPHead(String title, String classes = \"\");\n    String        getHTTPEnd();\n    String        getMenuOut();\n    //helpers\n    boolean       isIp(String str);\n    String        toStringIp(IPAddress ip);\n    boolean       validApPassword();\n    String        encryptionTypeStr(uint8_t authmode);\n    void          reportStatus(String &page);\n    String        getInfoData(String id);\n\n    // flags\n    boolean       connect             = false;\n    boolean       abort               = false;\n    boolean       reset               = false;\n    boolean       configPortalActive  = false;\n\n\n    // these are state flags for portal mode, we are either in webportal mode(STA) or configportal mode(AP)\n    // these are mutually exclusive as STA+AP mode is not supported due to channel restrictions and stability\n    // if we decide to support this, these checks will need to be replaced with something client aware to check if client origin is ap or web\n    // These state checks are critical and used for internal function checks\n    boolean       webPortalActive     = false;\n    boolean       portalTimeoutResult = false;\n\n    boolean       portalAbortResult   = false;\n    boolean       storeSTAmode        = true; // option store persistent STA mode in connectwifi \n    int           timer               = 0;    // timer for debug throttle for numclients, and portal timeout messages\n    \n    // WiFiManagerParameter\n    int         _paramsCount          = 0;\n    int         _max_params;\n    WiFiManagerParameter** _params    = NULL;\n\n    boolean _debug  = true;\n    String _debugPrefix = FPSTR(S_debugPrefix);\n\n    wm_debuglevel_t debugLvlShow = WM_DEBUG_VERBOSE; // at which level start showing [n] level tags\n\n    // build debuglevel support\n    // @todo use DEBUG_ESP_x?\n    \n    // Set default debug level\n    #ifndef WM_DEBUG_LEVEL\n    #define WM_DEBUG_LEVEL WM_DEBUG_NOTIFY\n    #endif\n\n    // override debug level OFF\n    #ifdef WM_NODEBUG\n    #undef WM_DEBUG_LEVEL\n    #endif\n\n    #ifdef WM_DEBUG_LEVEL\n    uint8_t _debugLevel = (uint8_t)WM_DEBUG_LEVEL;\n    #else \n    uint8_t _debugLevel = 0; // default debug level\n    #endif\n\n    // @todo use DEBUG_ESP_PORT ?\n    #ifdef WM_DEBUG_PORT\n    Print& _debugPort = WM_DEBUG_PORT;\n    #else\n    Print& _debugPort = Serial; // debug output stream ref\n    #endif\n\n    template <typename Generic>\n    void        DEBUG_WM(Generic text);\n\n    template <typename Generic>\n    void        DEBUG_WM(wm_debuglevel_t level,Generic text);\n    template <typename Generic, typename Genericb>\n    void        DEBUG_WM(Generic text,Genericb textb);\n    template <typename Generic, typename Genericb>\n    void        DEBUG_WM(wm_debuglevel_t level, Generic text,Genericb textb);\n\n    // callbacks\n    // @todo use cb list (vector) maybe event ids, allow no return value\n    std::function<void(WiFiManager*)> _apcallback;\n    std::function<void()> _webservercallback;\n    std::function<void()> _savewificallback;\n    std::function<void()> _presavewificallback;\n    std::function<void()> _presaveparamscallback;\n    std::function<void()> _saveparamscallback;\n    std::function<void()> _resetcallback;\n    std::function<void()> _preotaupdatecallback;\n    std::function<void()> _configportaltimeoutcallback;\n\n    template <class T>\n    auto optionalIPFromString(T *obj, const char *s) -> decltype(  obj->fromString(s)  ) {\n      return  obj->fromString(s);\n    }\n    auto optionalIPFromString(...) -> bool {\n      // DEBUG_WM(\"NO fromString METHOD ON IPAddress, you need ESP8266 core 2.1.0 or newer for Custom IP configuration to work.\");\n      return false;\n    }\n\n};\n\n#endif\n\n#endif\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "extras",
          "type": "tree",
          "content": null
        },
        {
          "name": "keywords.txt",
          "type": "blob",
          "size": 0.927734375,
          "content": "#######################################\n# Syntax Coloring Map For WifiManager\n#######################################\n\n#######################################\n# Datatypes (KEYWORD1)\n#######################################\n\nWiFiManager\tKEYWORD1\nWiFiManagerParameter KEYWORD1\n\n\n#######################################\n# Methods and Functions (KEYWORD2)\n#######################################\nautoConnect\tKEYWORD2\ngetSSID\tKEYWORD2\ngetPassword\tKEYWORD2\ngetConfigPortalSSID KEYWORD2\nresetSettings\tKEYWORD2\nsetConfigPortalTimeout\tKEYWORD2\nsetConnectTimeout KEYWORD2\nsetDebugOutput\tKEYWORD2\nsetMinimumSignalQuality KEYWORD2\nsetAPStaticIPConfig\tKEYWORD2\nsetSTAStaticIPConfig KEYWORD2\nsetAPCallback\tKEYWORD2\nsetSaveConfigCallback KEYWORD2\naddParameter KEYWORD2\ngetID KEYWORD2\ngetValue KEYWORD2\ngetPlaceholder KEYWORD2\ngetValueLength KEYWORD2\n\n#######################################\n# Constants (LITERAL1)\n#######################################\n\n#\tLITERAL1\n"
        },
        {
          "name": "library.json",
          "type": "blob",
          "size": 0.630859375,
          "content": "{\n  \"name\": \"WiFiManager\",\n  \"version\": \"2.0.17\",\n  \"keywords\": \"wifi,wi-fi,esp,esp8266,esp32,espressif8266,espressif32,nodemcu,wemos,arduino\",\n  \"description\": \"WiFi Configuration manager with web configuration portal for ESP boards\",\n  \"authors\":\n  [\n    {\n        \"name\": \"tzapu\",\n        \"url\": \"https://github.com/tzapu\"\n    },\n    {\n        \"name\": \"tablatronix\",\n        \"url\": \"https://github.com/tablatronix\",\n        \"maintainer\": true\n    }\n  ],\n  \"repository\":\n  {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/tzapu/WiFiManager.git\"\n  },\n  \"frameworks\": \"arduino\",\n  \"platforms\": \n  [\n    \"espressif8266\",\n    \"espressif32\"\n  ]\n}"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.3837890625,
          "content": "name=WiFiManager\nversion=2.0.17\nauthor=tzapu\nmaintainer=tablatronix\nsentence=WiFi Configuration manager with web configuration portal for Espressif ESPx boards, by tzapu\nparagraph=Library for configuring ESP8266/ESP32 modules WiFi credentials and custom parameters at runtime with captive portal.\ncategory=Communication\nurl=https://github.com/tzapu/WiFiManager.git\narchitectures=esp8266,esp32\n"
        },
        {
          "name": "strings_en.h",
          "type": "blob",
          "size": 0.2939453125,
          "content": "/**\n * Contents of this file have moved to 2 new locations\n * wm_strings_nn.h\n *  wm_consts_nn.h\n */\n\n#warning \"This file is deprecated\"\n\n#ifndef _STRINGS_EN_H_\n#define _STRINGS_EN_H_\n\n// strings files must include a consts file!\n#include \"wm_strings_en.h\" // include constants, tokens, routes\n\n#endif"
        },
        {
          "name": "travis",
          "type": "tree",
          "content": null
        },
        {
          "name": "wm_consts_en.h",
          "type": "blob",
          "size": 10.8466796875,
          "content": "/**\n * wm_consts.h\n * internal const strings/tokens\n * WiFiManager, a library for the ESP8266/Arduino platform\n * for configuration of WiFi credentials using a Captive Portal\n *\n * @author Creator tzapu\n * @author tablatronix\n * @version 0.0.0\n * @license MIT\n */\n\n#ifndef _WM_CONSTS_H\n#define _WM_CONSTS_H\n\n\n// -----------------------------------------------------------------------------------------------\n// TOKENS\n\nconst char WM_VERSION_STR[] PROGMEM = \"v2.0.17\";\n\nstatic const char _wifi_token[]       PROGMEM = \"wifi\";\nstatic const char _wifinoscan_token[] PROGMEM = \"wifinoscan\";\nstatic const char _info_token[]       PROGMEM = \"info\";\nstatic const char _param_token[]      PROGMEM = \"param\";\nstatic const char _close_token[]      PROGMEM = \"close\";\nstatic const char _restart_token[]    PROGMEM = \"restart\";\nstatic const char _exit_token[]       PROGMEM = \"exit\";\nstatic const char _erase_token[]      PROGMEM = \"erase\";\nstatic const char _update_token[]     PROGMEM = \"update\";\nstatic const char _sep_token[]        PROGMEM = \"sep\";\nstatic const char _custom_token[]     PROGMEM = \"custom\";\nstatic PGM_P _menutokens[] PROGMEM = {\n    _wifi_token,\n    _wifinoscan_token,\n    _info_token,\n    _param_token,\n    _close_token,\n    _restart_token,\n    _exit_token,\n    _erase_token,\n    _update_token,\n    _sep_token,\n    _custom_token\n};\nconst uint8_t _nummenutokens = (sizeof(_menutokens) / sizeof(PGM_P));\n\n\n// Routes\nconst char R_root[]               PROGMEM = \"/\";\nconst char R_wifi[]               PROGMEM = \"/wifi\";\nconst char R_wifinoscan[]         PROGMEM = \"/0wifi\";\nconst char R_wifisave[]           PROGMEM = \"/wifisave\";\nconst char R_info[]               PROGMEM = \"/info\";\nconst char R_param[]              PROGMEM = \"/param\";\nconst char R_paramsave[]          PROGMEM = \"/paramsave\";\nconst char R_restart[]            PROGMEM = \"/restart\";\nconst char R_exit[]               PROGMEM = \"/exit\";\nconst char R_close[]              PROGMEM = \"/close\";\nconst char R_erase[]              PROGMEM = \"/erase\";\nconst char R_status[]             PROGMEM = \"/status\";\nconst char R_update[]             PROGMEM = \"/update\";\nconst char R_updatedone[]         PROGMEM = \"/u\";\n\n\n// Classes\nconst char C_root[]               PROGMEM = \"home\";\nconst char C_wifi[]               PROGMEM = \"wifi\";\nconst char C_info[]               PROGMEM = \"info\";\nconst char C_param[]              PROGMEM = \"param\";\nconst char C_close[]              PROGMEM = \"close\";\nconst char C_restart[]            PROGMEM = \"restart\";\nconst char C_exit[]               PROGMEM = \"exit\";\nconst char C_erase[]              PROGMEM = \"erase\";\nconst char C_update[]             PROGMEM = \"update\";\n\n\n//Strings\nconst char S_ip[]                 PROGMEM = \"ip\";\nconst char S_gw[]                 PROGMEM = \"gw\";\nconst char S_sn[]                 PROGMEM = \"sn\";\nconst char S_dns[]                PROGMEM = \"dns\";\n\n\n\n//Tokens\n//@todo consolidate and reduce\nconst char T_ss[]                 PROGMEM = \"{\"; // token start sentinel\nconst char T_es[]                 PROGMEM = \"}\"; // token end sentinel\nconst char T_1[]                  PROGMEM = \"{1}\"; // @token 1\nconst char T_2[]                  PROGMEM = \"{2}\"; // @token 2\nconst char T_3[]                  PROGMEM = \"{3}\"; // @token 2\nconst char T_v[]                  PROGMEM = \"{v}\"; // @token v\nconst char T_V[]                  PROGMEM = \"{V}\"; // @token v\nconst char T_I[]                  PROGMEM = \"{I}\"; // @token I\nconst char T_i[]                  PROGMEM = \"{i}\"; // @token i\nconst char T_n[]                  PROGMEM = \"{n}\"; // @token n\nconst char T_p[]                  PROGMEM = \"{p}\"; // @token p\nconst char T_t[]                  PROGMEM = \"{t}\"; // @token t\nconst char T_l[]                  PROGMEM = \"{l}\"; // @token l\nconst char T_c[]                  PROGMEM = \"{c}\"; // @token c\nconst char T_e[]                  PROGMEM = \"{e}\"; // @token e\nconst char T_q[]                  PROGMEM = \"{q}\"; // @token q\nconst char T_r[]                  PROGMEM = \"{r}\"; // @token r\nconst char T_R[]                  PROGMEM = \"{R}\"; // @token R\nconst char T_h[]                  PROGMEM = \"{h}\"; // @token h\n\n// http\nconst char HTTP_HEAD_CL[]         PROGMEM = \"Content-Length\";\nconst char HTTP_HEAD_CT[]         PROGMEM = \"text/html\";\nconst char HTTP_HEAD_CT2[]        PROGMEM = \"text/plain\";\nconst char HTTP_HEAD_CORS[]       PROGMEM = \"Access-Control-Allow-Origin\";\nconst char HTTP_HEAD_CORS_ALLOW_ALL[]  PROGMEM = \"*\";\n\nconst char * const WIFI_STA_STATUS[] PROGMEM\n{\n  \"WL_IDLE_STATUS\",     // 0 STATION_IDLE\n  \"WL_NO_SSID_AVAIL\",   // 1 STATION_NO_AP_FOUND\n  \"WL_SCAN_COMPLETED\",  // 2\n  \"WL_CONNECTED\",       // 3 STATION_GOT_IP\n  \"WL_CONNECT_FAILED\",  // 4 STATION_CONNECT_FAIL, STATION_WRONG_PASSWORD(NI)\n  \"WL_CONNECTION_LOST\", // 5\n  \"WL_DISCONNECTED\",    // 6\n  \"WL_STATION_WRONG_PASSWORD\" // 7 KLUDGE\n};\n\n#ifdef ESP32\nconst char * const AUTH_MODE_NAMES[] PROGMEM\n{\n    \"OPEN\",\n    \"WEP\",\n    \"WPA_PSK\",\n    \"WPA2_PSK\",\n    \"WPA_WPA2_PSK\",\n    \"WPA2_ENTERPRISE\",\n    \"MAX\"\n};\n#elif defined(ESP8266)\nconst char * const AUTH_MODE_NAMES[] PROGMEM\n{\n    \"\",\n    \"\",\n    \"WPA_PSK\",      // 2 ENC_TYPE_TKIP\n    \"\",\n    \"WPA2_PSK\",     // 4 ENC_TYPE_CCMP\n    \"WEP\",          // 5 ENC_TYPE_WEP\n    \"\",\n    \"OPEN\",         //7 ENC_TYPE_NONE\n    \"WPA_WPA2_PSK\", // 8 ENC_TYPE_AUTO\n};\n#endif\n\nconst char* const WIFI_MODES[] PROGMEM = { \"NULL\", \"STA\", \"AP\", \"STA+AP\" };\n\n\n#ifdef ESP32\n// as 2.5.2\n// typedef struct {\n//     char                  cc[3];   /**< country code string */\n//     uint8_t               schan;   /**< start channel */\n//     uint8_t               nchan;   /**< total channel number */\n//     int8_t                max_tx_power;   /**< This field is used for getting WiFi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power. */\n//     wifi_country_policy_t policy;  /**< country policy */\n// } wifi_country_t;\nconst wifi_country_t WM_COUNTRY_US{\"US\",1,11,CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_CN{\"CN\",1,13,CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_JP{\"JP\",1,14,CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER,WIFI_COUNTRY_POLICY_AUTO};\n#elif defined(ESP8266) && !defined(WM_NOCOUNTRY)\n// typedef struct {\n//     char cc[3];               /**< country code string */\n//     uint8_t schan;            /**< start channel */\n//     uint8_t nchan;            /**< total channel number */\n//     uint8_t policy;           /**< country policy */\n// } wifi_country_t;\nconst wifi_country_t WM_COUNTRY_US{\"US\",1,11,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_CN{\"CN\",1,13,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_JP{\"JP\",1,14,WIFI_COUNTRY_POLICY_AUTO};\n#endif\n\n\n/*\n* ESP32 WiFi Events\n\n0  SYSTEM_EVENT_WIFI_READY               < ESP32 WiFi ready\n1  SYSTEM_EVENT_SCAN_DONE                < ESP32 finish scanning AP\n2  SYSTEM_EVENT_STA_START                < ESP32 station start\n3  SYSTEM_EVENT_STA_STOP                 < ESP32 station stop\n4  SYSTEM_EVENT_STA_CONNECTED            < ESP32 station connected to AP\n5  SYSTEM_EVENT_STA_DISCONNECTED         < ESP32 station disconnected from AP\n6  SYSTEM_EVENT_STA_AUTHMODE_CHANGE      < the auth mode of AP connected by ESP32 station changed\n7  SYSTEM_EVENT_STA_GOT_IP               < ESP32 station got IP from connected AP\n8  SYSTEM_EVENT_STA_LOST_IP              < ESP32 station lost IP and the IP is reset to 0\n9  SYSTEM_EVENT_STA_WPS_ER_SUCCESS       < ESP32 station wps succeeds in enrollee mode\n10 SYSTEM_EVENT_STA_WPS_ER_FAILED        < ESP32 station wps fails in enrollee mode\n11 SYSTEM_EVENT_STA_WPS_ER_TIMEOUT       < ESP32 station wps timeout in enrollee mode\n12 SYSTEM_EVENT_STA_WPS_ER_PIN           < ESP32 station wps pin code in enrollee mode\n13 SYSTEM_EVENT_AP_START                 < ESP32 soft-AP start\n14 SYSTEM_EVENT_AP_STOP                  < ESP32 soft-AP stop\n15 SYSTEM_EVENT_AP_STACONNECTED          < a station connected to ESP32 soft-AP\n16 SYSTEM_EVENT_AP_STADISCONNECTED       < a station disconnected from ESP32 soft-AP\n17 SYSTEM_EVENT_AP_STAIPASSIGNED         < ESP32 soft-AP assign an IP to a connected station\n18 SYSTEM_EVENT_AP_PROBEREQRECVED        < Receive probe request packet in soft-AP interface\n19 SYSTEM_EVENT_GOT_IP6                  < ESP32 station or ap or ethernet interface v6IP addr is preferred\n20 SYSTEM_EVENT_ETH_START                < ESP32 ethernet start\n21 SYSTEM_EVENT_ETH_STOP                 < ESP32 ethernet stop\n22 SYSTEM_EVENT_ETH_CONNECTED            < ESP32 ethernet phy link up\n23 SYSTEM_EVENT_ETH_DISCONNECTED         < ESP32 ethernet phy link down\n24 SYSTEM_EVENT_ETH_GOT_IP               < ESP32 ethernet got IP from connected AP\n25 SYSTEM_EVENT_MAX\n\n\ntypedef enum {\n    ARDUINO_EVENT_WIFI_READY = 0,\n    ARDUINO_EVENT_WIFI_SCAN_DONE,\n    ARDUINO_EVENT_WIFI_STA_START,\n    ARDUINO_EVENT_WIFI_STA_STOP,\n    ARDUINO_EVENT_WIFI_STA_CONNECTED,\n    ARDUINO_EVENT_WIFI_STA_DISCONNECTED,\n    ARDUINO_EVENT_WIFI_STA_AUTHMODE_CHANGE,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP6,\n    ARDUINO_EVENT_WIFI_STA_LOST_IP,\n    ARDUINO_EVENT_WIFI_AP_START,\n    ARDUINO_EVENT_WIFI_AP_STOP,\n    ARDUINO_EVENT_WIFI_AP_STACONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STADISCONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STAIPASSIGNED,\n    ARDUINO_EVENT_WIFI_AP_PROBEREQRECVED,\n    ARDUINO_EVENT_WIFI_AP_GOT_IP6,\n    ARDUINO_EVENT_WIFI_FTM_REPORT,\n    ARDUINO_EVENT_ETH_START,\n    ARDUINO_EVENT_ETH_STOP,\n    ARDUINO_EVENT_ETH_CONNECTED,\n    ARDUINO_EVENT_ETH_DISCONNECTED,\n    ARDUINO_EVENT_ETH_GOT_IP,\n    ARDUINO_EVENT_ETH_GOT_IP6,\n    ARDUINO_EVENT_WPS_ER_SUCCESS,\n    ARDUINO_EVENT_WPS_ER_FAILED,\n    ARDUINO_EVENT_WPS_ER_TIMEOUT,\n    ARDUINO_EVENT_WPS_ER_PIN,\n    ARDUINO_EVENT_WPS_ER_PBC_OVERLAP,\n    ARDUINO_EVENT_SC_SCAN_DONE,\n    ARDUINO_EVENT_SC_FOUND_CHANNEL,\n    ARDUINO_EVENT_SC_GOT_SSID_PSWD,\n    ARDUINO_EVENT_SC_SEND_ACK_DONE,\n    ARDUINO_EVENT_PROV_INIT,\n    ARDUINO_EVENT_PROV_DEINIT,\n    ARDUINO_EVENT_PROV_START,\n    ARDUINO_EVENT_PROV_END,\n    ARDUINO_EVENT_PROV_CRED_RECV,\n    ARDUINO_EVENT_PROV_CRED_FAIL,\n    ARDUINO_EVENT_PROV_CRED_SUCCESS,\n    ARDUINO_EVENT_MAX\n} arduino_event_id_t;\n\ntypedef union {\n    wifi_event_sta_scan_done_t wifi_scan_done;\n    wifi_event_sta_authmode_change_t wifi_sta_authmode_change;\n    wifi_event_sta_connected_t wifi_sta_connected;\n    wifi_event_sta_disconnected_t wifi_sta_disconnected;\n    wifi_event_sta_wps_er_pin_t wps_er_pin;\n    wifi_event_sta_wps_fail_reason_t wps_fail_reason;\n    wifi_event_ap_probe_req_rx_t wifi_ap_probereqrecved;\n    wifi_event_ap_staconnected_t wifi_ap_staconnected;\n    wifi_event_ap_stadisconnected_t wifi_ap_stadisconnected;\n    wifi_event_ftm_report_t wifi_ftm_report;\n    ip_event_ap_staipassigned_t wifi_ap_staipassigned;\n    ip_event_got_ip_t got_ip;\n    ip_event_got_ip6_t got_ip6;\n    smartconfig_event_got_ssid_pswd_t sc_got_ssid_pswd;\n    esp_eth_handle_t eth_connected;\n    wifi_sta_config_t prov_cred_recv;\n    wifi_prov_sta_fail_reason_t prov_fail_reason;\n} arduino_event_info_t;\n\n*/\n\n#endif"
        },
        {
          "name": "wm_consts_fr.h",
          "type": "blob",
          "size": 10.8740234375,
          "content": "/**\n * wm_consts.h\n * internal const strings/tokens\n * WiFiManager, a library for the ESP8266/Arduino platform\n * for configuration of WiFi credentials using a Captive Portal\n *\n * @author Creator tzapu\n * @author tablatronix\n * @version 0.0.1\n * @translated AByGCreation\n * @license MIT\n */\n\n#ifndef _WM_CONSTS_H\n#define _WM_CONSTS_H\n\n\n// -----------------------------------------------------------------------------------------------\n// TOKENS\n\nconst char WM_VERSION_STR[] PROGMEM = \"v2.0.17\";\n\nstatic const char _wifi_token[]       PROGMEM = \"wifi\";\nstatic const char _wifinoscan_token[] PROGMEM = \"wifinoscan\";\nstatic const char _info_token[]       PROGMEM = \"info\";\nstatic const char _param_token[]      PROGMEM = \"param\";\nstatic const char _close_token[]      PROGMEM = \"close\";\nstatic const char _restart_token[]    PROGMEM = \"restart\";\nstatic const char _exit_token[]       PROGMEM = \"exit\";\nstatic const char _erase_token[]      PROGMEM = \"erase\";\nstatic const char _update_token[]     PROGMEM = \"update\";\nstatic const char _sep_token[]        PROGMEM = \"sep\";\nstatic const char _custom_token[]     PROGMEM = \"custom\";\nstatic PGM_P _menutokens[] PROGMEM = {\n    _wifi_token,\n    _wifinoscan_token,\n    _info_token,\n    _param_token,\n    _close_token,\n    _restart_token,\n    _exit_token,\n    _erase_token,\n    _update_token,\n    _sep_token,\n    _custom_token\n};\nconst uint8_t _nummenutokens = (sizeof(_menutokens) / sizeof(PGM_P));\n\n\n// Routes\nconst char R_root[]               PROGMEM = \"/\";\nconst char R_wifi[]               PROGMEM = \"/wifi\";\nconst char R_wifinoscan[]         PROGMEM = \"/0wifi\";\nconst char R_wifisave[]           PROGMEM = \"/wifisave\";\nconst char R_info[]               PROGMEM = \"/info\";\nconst char R_param[]              PROGMEM = \"/param\";\nconst char R_paramsave[]          PROGMEM = \"/paramsave\";\nconst char R_restart[]            PROGMEM = \"/restart\";\nconst char R_exit[]               PROGMEM = \"/exit\";\nconst char R_close[]              PROGMEM = \"/close\";\nconst char R_erase[]              PROGMEM = \"/erase\";\nconst char R_status[]             PROGMEM = \"/status\";\nconst char R_update[]             PROGMEM = \"/update\";\nconst char R_updatedone[]         PROGMEM = \"/u\";\n\n\n// Classes\nconst char C_root[]               PROGMEM = \"home\";\nconst char C_wifi[]               PROGMEM = \"wifi\";\nconst char C_info[]               PROGMEM = \"info\";\nconst char C_param[]              PROGMEM = \"param\";\nconst char C_close[]              PROGMEM = \"close\";\nconst char C_restart[]            PROGMEM = \"restart\";\nconst char C_exit[]               PROGMEM = \"exit\";\nconst char C_erase[]              PROGMEM = \"erase\";\nconst char C_update[]             PROGMEM = \"update\";\n\n\n//Strings\nconst char S_ip[]                 PROGMEM = \"ip\";\nconst char S_gw[]                 PROGMEM = \"gw\";\nconst char S_sn[]                 PROGMEM = \"sn\";\nconst char S_dns[]                PROGMEM = \"dns\";\n\n\n\n//Tokens\n//@todo consolidate and reduce\nconst char T_ss[]                 PROGMEM = \"{\"; // token start sentinel\nconst char T_es[]                 PROGMEM = \"}\"; // token end sentinel\nconst char T_1[]                  PROGMEM = \"{1}\"; // @token 1\nconst char T_2[]                  PROGMEM = \"{2}\"; // @token 2\nconst char T_3[]                  PROGMEM = \"{3}\"; // @token 2\nconst char T_v[]                  PROGMEM = \"{v}\"; // @token v\nconst char T_V[]                  PROGMEM = \"{V}\"; // @token v\nconst char T_I[]                  PROGMEM = \"{I}\"; // @token I\nconst char T_i[]                  PROGMEM = \"{i}\"; // @token i\nconst char T_n[]                  PROGMEM = \"{n}\"; // @token n\nconst char T_p[]                  PROGMEM = \"{p}\"; // @token p\nconst char T_t[]                  PROGMEM = \"{t}\"; // @token t\nconst char T_l[]                  PROGMEM = \"{l}\"; // @token l\nconst char T_c[]                  PROGMEM = \"{c}\"; // @token c\nconst char T_e[]                  PROGMEM = \"{e}\"; // @token e\nconst char T_q[]                  PROGMEM = \"{q}\"; // @token q\nconst char T_r[]                  PROGMEM = \"{r}\"; // @token r\nconst char T_R[]                  PROGMEM = \"{R}\"; // @token R\nconst char T_h[]                  PROGMEM = \"{h}\"; // @token h\n\n// http\nconst char HTTP_HEAD_CL[]         PROGMEM = \"Content-Length\";\nconst char HTTP_HEAD_CT[]         PROGMEM = \"text/html\";\nconst char HTTP_HEAD_CT2[]        PROGMEM = \"text/plain\";\nconst char HTTP_HEAD_CORS[]       PROGMEM = \"Access-Control-Allow-Origin\";\nconst char HTTP_HEAD_CORS_ALLOW_ALL[]  PROGMEM = \"*\";\n\nconst char * const WIFI_STA_STATUS[] PROGMEM\n{\n  \"WL_IDLE_STATUS\",     // 0 STATION_IDLE\n  \"WL_NO_SSID_AVAIL\",   // 1 STATION_NO_AP_FOUND\n  \"WL_SCAN_COMPLETED\",  // 2\n  \"WL_CONNECTED\",       // 3 STATION_GOT_IP\n  \"WL_CONNECT_FAILED\",  // 4 STATION_CONNECT_FAIL, STATION_WRONG_PASSWORD(NI)\n  \"WL_CONNECTION_LOST\", // 5\n  \"WL_DISCONNECTED\",    // 6\n  \"WL_STATION_WRONG_PASSWORD\" // 7 KLUDGE\n};\n\n#ifdef ESP32\nconst char * const AUTH_MODE_NAMES[] PROGMEM\n{\n    \"OPEN\",\n    \"WEP\",\n    \"WPA_PSK\",\n    \"WPA2_PSK\",\n    \"WPA_WPA2_PSK\",\n    \"WPA2_ENTERPRISE\",\n    \"MAX\"\n};\n#elif defined(ESP8266)\nconst char * const AUTH_MODE_NAMES[] PROGMEM\n{\n    \"\",\n    \"\",\n    \"WPA_PSK\",      // 2 ENC_TYPE_TKIP\n    \"\",\n    \"WPA2_PSK\",     // 4 ENC_TYPE_CCMP\n    \"WEP\",          // 5 ENC_TYPE_WEP\n    \"\",\n    \"OPEN\",         //7 ENC_TYPE_NONE\n    \"WPA_WPA2_PSK\", // 8 ENC_TYPE_AUTO\n};\n#endif\n\nconst char* const WIFI_MODES[] PROGMEM = { \"NULL\", \"STA\", \"AP\", \"STA+AP\" };\n\n\n#ifdef ESP32\n// as 2.5.2\n// typedef struct {\n//     char                  cc[3];   /**< country code string */\n//     uint8_t               schan;   /**< start channel */\n//     uint8_t               nchan;   /**< total channel number */\n//     int8_t                max_tx_power;   /**< This field is used for getting WiFi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power. */\n//     wifi_country_policy_t policy;  /**< country policy */\n// } wifi_country_t;\nconst wifi_country_t WM_COUNTRY_US{\"US\",1,11,CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_CN{\"CN\",1,13,CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_JP{\"JP\",1,14,CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER,WIFI_COUNTRY_POLICY_AUTO};\n#elif defined(ESP8266) && !defined(WM_NOCOUNTRY)\n// typedef struct {\n//     char cc[3];               /**< country code string */\n//     uint8_t schan;            /**< start channel */\n//     uint8_t nchan;            /**< total channel number */\n//     uint8_t policy;           /**< country policy */\n// } wifi_country_t;\nconst wifi_country_t WM_COUNTRY_US{\"US\",1,11,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_CN{\"CN\",1,13,WIFI_COUNTRY_POLICY_AUTO};\nconst wifi_country_t WM_COUNTRY_JP{\"JP\",1,14,WIFI_COUNTRY_POLICY_AUTO};\n#endif\n\n\n/*\n* ESP32 WiFi Events\n\n0  SYSTEM_EVENT_WIFI_READY               < ESP32 WiFi ready\n1  SYSTEM_EVENT_SCAN_DONE                < ESP32 finish scanning AP\n2  SYSTEM_EVENT_STA_START                < ESP32 station start\n3  SYSTEM_EVENT_STA_STOP                 < ESP32 station stop\n4  SYSTEM_EVENT_STA_CONNECTED            < ESP32 station connected to AP\n5  SYSTEM_EVENT_STA_DISCONNECTED         < ESP32 station disconnected from AP\n6  SYSTEM_EVENT_STA_AUTHMODE_CHANGE      < the auth mode of AP connected by ESP32 station changed\n7  SYSTEM_EVENT_STA_GOT_IP               < ESP32 station got IP from connected AP\n8  SYSTEM_EVENT_STA_LOST_IP              < ESP32 station lost IP and the IP is reset to 0\n9  SYSTEM_EVENT_STA_WPS_ER_SUCCESS       < ESP32 station wps succeeds in enrollee mode\n10 SYSTEM_EVENT_STA_WPS_ER_FAILED        < ESP32 station wps fails in enrollee mode\n11 SYSTEM_EVENT_STA_WPS_ER_TIMEOUT       < ESP32 station wps timeout in enrollee mode\n12 SYSTEM_EVENT_STA_WPS_ER_PIN           < ESP32 station wps pin code in enrollee mode\n13 SYSTEM_EVENT_AP_START                 < ESP32 soft-AP start\n14 SYSTEM_EVENT_AP_STOP                  < ESP32 soft-AP stop\n15 SYSTEM_EVENT_AP_STACONNECTED          < a station connected to ESP32 soft-AP\n16 SYSTEM_EVENT_AP_STADISCONNECTED       < a station disconnected from ESP32 soft-AP\n17 SYSTEM_EVENT_AP_STAIPASSIGNED         < ESP32 soft-AP assign an IP to a connected station\n18 SYSTEM_EVENT_AP_PROBEREQRECVED        < Receive probe request packet in soft-AP interface\n19 SYSTEM_EVENT_GOT_IP6                  < ESP32 station or ap or ethernet interface v6IP addr is preferred\n20 SYSTEM_EVENT_ETH_START                < ESP32 ethernet start\n21 SYSTEM_EVENT_ETH_STOP                 < ESP32 ethernet stop\n22 SYSTEM_EVENT_ETH_CONNECTED            < ESP32 ethernet phy link up\n23 SYSTEM_EVENT_ETH_DISCONNECTED         < ESP32 ethernet phy link down\n24 SYSTEM_EVENT_ETH_GOT_IP               < ESP32 ethernet got IP from connected AP\n25 SYSTEM_EVENT_MAX\n\n\ntypedef enum {\n    ARDUINO_EVENT_WIFI_READY = 0,\n    ARDUINO_EVENT_WIFI_SCAN_DONE,\n    ARDUINO_EVENT_WIFI_STA_START,\n    ARDUINO_EVENT_WIFI_STA_STOP,\n    ARDUINO_EVENT_WIFI_STA_CONNECTED,\n    ARDUINO_EVENT_WIFI_STA_DISCONNECTED,\n    ARDUINO_EVENT_WIFI_STA_AUTHMODE_CHANGE,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP6,\n    ARDUINO_EVENT_WIFI_STA_LOST_IP,\n    ARDUINO_EVENT_WIFI_AP_START,\n    ARDUINO_EVENT_WIFI_AP_STOP,\n    ARDUINO_EVENT_WIFI_AP_STACONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STADISCONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STAIPASSIGNED,\n    ARDUINO_EVENT_WIFI_AP_PROBEREQRECVED,\n    ARDUINO_EVENT_WIFI_AP_GOT_IP6,\n    ARDUINO_EVENT_WIFI_FTM_REPORT,\n    ARDUINO_EVENT_ETH_START,\n    ARDUINO_EVENT_ETH_STOP,\n    ARDUINO_EVENT_ETH_CONNECTED,\n    ARDUINO_EVENT_ETH_DISCONNECTED,\n    ARDUINO_EVENT_ETH_GOT_IP,\n    ARDUINO_EVENT_ETH_GOT_IP6,\n    ARDUINO_EVENT_WPS_ER_SUCCESS,\n    ARDUINO_EVENT_WPS_ER_FAILED,\n    ARDUINO_EVENT_WPS_ER_TIMEOUT,\n    ARDUINO_EVENT_WPS_ER_PIN,\n    ARDUINO_EVENT_WPS_ER_PBC_OVERLAP,\n    ARDUINO_EVENT_SC_SCAN_DONE,\n    ARDUINO_EVENT_SC_FOUND_CHANNEL,\n    ARDUINO_EVENT_SC_GOT_SSID_PSWD,\n    ARDUINO_EVENT_SC_SEND_ACK_DONE,\n    ARDUINO_EVENT_PROV_INIT,\n    ARDUINO_EVENT_PROV_DEINIT,\n    ARDUINO_EVENT_PROV_START,\n    ARDUINO_EVENT_PROV_END,\n    ARDUINO_EVENT_PROV_CRED_RECV,\n    ARDUINO_EVENT_PROV_CRED_FAIL,\n    ARDUINO_EVENT_PROV_CRED_SUCCESS,\n    ARDUINO_EVENT_MAX\n} arduino_event_id_t;\n\ntypedef union {\n    wifi_event_sta_scan_done_t wifi_scan_done;\n    wifi_event_sta_authmode_change_t wifi_sta_authmode_change;\n    wifi_event_sta_connected_t wifi_sta_connected;\n    wifi_event_sta_disconnected_t wifi_sta_disconnected;\n    wifi_event_sta_wps_er_pin_t wps_er_pin;\n    wifi_event_sta_wps_fail_reason_t wps_fail_reason;\n    wifi_event_ap_probe_req_rx_t wifi_ap_probereqrecved;\n    wifi_event_ap_staconnected_t wifi_ap_staconnected;\n    wifi_event_ap_stadisconnected_t wifi_ap_stadisconnected;\n    wifi_event_ftm_report_t wifi_ftm_report;\n    ip_event_ap_staipassigned_t wifi_ap_staipassigned;\n    ip_event_got_ip_t got_ip;\n    ip_event_got_ip6_t got_ip6;\n    smartconfig_event_got_ssid_pswd_t sc_got_ssid_pswd;\n    esp_eth_handle_t eth_connected;\n    wifi_sta_config_t prov_cred_recv;\n    wifi_prov_sta_fail_reason_t prov_fail_reason;\n} arduino_event_info_t;\n\n*/\n\n#endif"
        },
        {
          "name": "wm_strings_en.h",
          "type": "blob",
          "size": 18.97265625,
          "content": "/**\n * wm_strings_en.h\n * engligh strings for\n * WiFiManager, a library for the ESP8266/Arduino platform\n * for configuration of WiFi credentials using a Captive Portal\n *\n * @author Creator tzapu\n * @author tablatronix\n * @version 0.0.0\n * @license MIT\n */\n\n#ifndef _WM_STRINGS_EN_H_\n#define _WM_STRINGS_EN_H_\n\n\n#ifndef WIFI_MANAGER_OVERRIDE_STRINGS\n// !!! ABOVE WILL NOT WORK if you define in your sketch, must be build flag, if anyone one knows how to order includes to be able to do this it would be neat.. I have seen it done..\n\n// strings files must include a consts file!\n#include \"wm_consts_en.h\" // include constants, tokens, routes\n\nconst char WM_LANGUAGE[] PROGMEM = \"en-US\"; // i18n lang code\n\nconst char HTTP_HEAD_START[]       PROGMEM = \"<!DOCTYPE html>\"\n\"<html lang='en'><head>\"\n\"<meta name='format-detection' content='telephone=no'>\"\n\"<meta charset='UTF-8'>\"\n\"<meta  name='viewport' content='width=device-width,initial-scale=1,user-scalable=no'/>\"\n\"<title>{v}</title>\";\n\nconst char HTTP_SCRIPT[]           PROGMEM = \"<script>function c(l){\"\n\"document.getElementById('s').value=l.getAttribute('data-ssid')||l.innerText||l.textContent;\"\n\"p = l.nextElementSibling.classList.contains('l');\"\n\"document.getElementById('p').disabled = !p;\"\n\"if(p)document.getElementById('p').focus();};\"\n\"function f() {var x = document.getElementById('p');x.type==='password'?x.type='text':x.type='password';}\"\n\"</script>\"; // @todo add button states, disable on click , show ack , spinner etc\n\nconst char HTTP_HEAD_END[]         PROGMEM = \"</head><body class='{c}'><div class='wrap'>\"; // {c} = _bodyclass\n// example of embedded logo, base64 encoded inline, No styling here\n// const char HTTP_ROOT_MAIN[]        PROGMEM = \"<img title=' alt=' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADQElEQVRoQ+2YjW0VQQyE7Q6gAkgFkAogFUAqgFQAVACpAKiAUAFQAaECQgWECggVGH1PPrRvn3dv9/YkFOksoUhhfzwz9ngvKrc89JbnLxuA/63gpsCmwCADWwkNEji8fVNgotDM7osI/x777x5l9F6JyB8R4eeVql4P0y8yNsjM7KGIPBORp558T04A+CwiH1UVUItiUQmZ2XMReSEiAFgjAPBeVS96D+sCYGaUx4cFbLfmhSpnqnrZuqEJgJnd8cQplVLciAgX//Cf0ToIeOB9wpmloLQAwpnVmAXgdf6pwjpJIz+XNoeZQQZlODV9vhc1Tuf6owrAk/8qIhFbJH7eI3eEzsvydQEICqBEkZwiALfF70HyHPpqScPV5HFjeFu476SkRA0AzOfy4hYwstj2ZkDgaphE7m6XqnoS7Q0BOPs/sw0kDROzjdXcCMFCNwzIy0EcRcOvBACfh4k0wgOmBX4xjfmk4DKTS31hgNWIKBCI8gdzogTgjYjQWFMw+o9LzJoZ63GUmjWm2wGDc7EvDDOj/1IVMIyD9SUAL0WEhpriRlXv5je5S+U1i2N88zdPuoVkeB+ls4SyxCoP3kVm9jsjpEsBLoOBNC5U9SwpGdakFkviuFP1keblATkTENTYcxkzgxTKOI3jyDxqLkQT87pMA++H3XvJBYtsNbBN6vuXq5S737WqHkW1VgMQNXJ0RshMqbbT33sJ5kpHWymzcJjNTeJIymJZtSQd9NHQHS1vodoFoTMkfbJzpRnLzB2vi6BZAJxWaCr+62BC+jzAxVJb3dmmiLzLwZhZNPE5e880Suo2AZgB8e8idxherqUPnT3brBDTlPxO3Z66rVwIwySXugdNd+5ejhqp/+NmgIwGX3Py3QBmlEi54KlwmjkOytQ+iJrLJj23S4GkOeecg8G091no737qvRRdzE+HLALQoMTBbJgBsCj5RSWUlUVJiZ4SOljb05eLFWgoJ5oY6yTyJp62D39jDANoKKcSocPJD5dQYzlFAFZJflUArgTPZKZwLXAnHmerfJquUkKZEgyzqOb5TuDt1P3nwxobqwPocZA11m4A1mBx5IxNgRH21ti7KbAGiyNn3HoF/gJ0w05A8xclpwAAAABJRU5ErkJggg==' /><h1>{v}</h1><h3>WiFiManager</h3>\";\nconst char HTTP_ROOT_MAIN[]        PROGMEM = \"<h1>{t}</h1><h3>{v}</h3>\";\n\nconst char * const HTTP_PORTAL_MENU[] PROGMEM = {\n\"<form action='/wifi'    method='get'><button>Configure WiFi</button></form><br/>\\n\", // MENU_WIFI\n\"<form action='/0wifi'   method='get'><button>Configure WiFi (No scan)</button></form><br/>\\n\", // MENU_WIFINOSCAN\n\"<form action='/info'    method='get'><button>Info</button></form><br/>\\n\", // MENU_INFO\n\"<form action='/param'   method='get'><button>Setup</button></form><br/>\\n\",//MENU_PARAM\n\"<form action='/close'   method='get'><button>Close</button></form><br/>\\n\", // MENU_CLOSE\n\"<form action='/restart' method='get'><button>Restart</button></form><br/>\\n\",// MENU_RESTART\n\"<form action='/exit'    method='get'><button>Exit</button></form><br/>\\n\",  // MENU_EXIT\n\"<form action='/erase'   method='get'><button class='D'>Erase</button></form><br/>\\n\", // MENU_ERASE\n\"<form action='/update'  method='get'><button>Update</button></form><br/>\\n\",// MENU_UPDATE\n\"<hr><br/>\" // MENU_SEP\n};\n\n// const char HTTP_PORTAL_OPTIONS[]   PROGMEM = strcat(HTTP_PORTAL_MENU[0] , HTTP_PORTAL_MENU[3] , HTTP_PORTAL_MENU[7]);\nconst char HTTP_PORTAL_OPTIONS[]   PROGMEM = \"\";\nconst char HTTP_ITEM_QI[]          PROGMEM = \"<div role='img' aria-label='{r}%' title='{r}%' class='q q-{q} {i} {h}'></div>\"; // rssi icons\nconst char HTTP_ITEM_QP[]          PROGMEM = \"<div class='q {h}'>{r}%</div>\"; // rssi percentage {h} = hidden showperc pref\nconst char HTTP_ITEM[]             PROGMEM = \"<div><a href='#p' onclick='c(this)' data-ssid='{V}'>{v}</a>{qi}{qp}</div>\"; // {q} = HTTP_ITEM_QI, {r} = HTTP_ITEM_QP\n// const char HTTP_ITEM[]            PROGMEM = \"<div><a href='#p' onclick='c(this)'>{v}</a> {R} {r}% {q} {e}</div>\"; // test all tokens\n\nconst char HTTP_FORM_START[]       PROGMEM = \"<form method='POST' action='{v}'>\";\nconst char HTTP_FORM_WIFI[]        PROGMEM = \"<label for='s'>SSID</label><input id='s' name='s' maxlength='32' autocorrect='off' autocapitalize='none' placeholder='{v}'><br/><label for='p'>Password</label><input id='p' name='p' maxlength='64' type='password' placeholder='{p}'><input type='checkbox' id='showpass' onclick='f()'> <label for='showpass'>Show Password</label><br/>\";\nconst char HTTP_FORM_WIFI_END[]    PROGMEM = \"\";\nconst char HTTP_FORM_STATIC_HEAD[] PROGMEM = \"<hr><br/>\";\nconst char HTTP_FORM_END[]         PROGMEM = \"<br/><br/><button type='submit'>Save</button></form>\";\nconst char HTTP_FORM_LABEL[]       PROGMEM = \"<label for='{i}'>{t}</label>\";\nconst char HTTP_FORM_PARAM_HEAD[]  PROGMEM = \"<hr><br/>\";\nconst char HTTP_FORM_PARAM[]       PROGMEM = \"<br/><input id='{i}' name='{n}' maxlength='{l}' value='{v}' {c}>\\n\"; // do not remove newline!\n\nconst char HTTP_SCAN_LINK[]        PROGMEM = \"<br/><form action='/wifi?refresh=1' method='POST'><button name='refresh' value='1'>Refresh</button></form>\";\nconst char HTTP_SAVED[]            PROGMEM = \"<div class='msg'>Saving Credentials<br/>Trying to connect ESP to network.<br />If it fails reconnect to AP to try again</div>\";\nconst char HTTP_PARAMSAVED[]       PROGMEM = \"<div class='msg S'>Saved<br/></div>\";\nconst char HTTP_END[]              PROGMEM = \"</div></body></html>\";\nconst char HTTP_ERASEBTN[]         PROGMEM = \"<br/><form action='/erase' method='get'><button class='D'>Erase WiFi config</button></form>\";\nconst char HTTP_UPDATEBTN[]        PROGMEM = \"<br/><form action='/update' method='get'><button>Update</button></form>\";\nconst char HTTP_BACKBTN[]          PROGMEM = \"<hr><br/><form action='/' method='get'><button>Back</button></form>\";\n\nconst char HTTP_STATUS_ON[]        PROGMEM = \"<div class='msg S'><strong>Connected</strong> to {v}<br/><em><small>with IP {i}</small></em></div>\";\nconst char HTTP_STATUS_OFF[]       PROGMEM = \"<div class='msg {c}'><strong>Not connected</strong> to {v}{r}</div>\"; // {c=class} {v=ssid} {r=status_off}\nconst char HTTP_STATUS_OFFPW[]     PROGMEM = \"<br/>Authentication failure\"; // STATION_WRONG_PASSWORD,  no eps32\nconst char HTTP_STATUS_OFFNOAP[]   PROGMEM = \"<br/>AP not found\";   // WL_NO_SSID_AVAIL\nconst char HTTP_STATUS_OFFFAIL[]   PROGMEM = \"<br/>Could not connect\"; // WL_CONNECT_FAILED\nconst char HTTP_STATUS_NONE[]      PROGMEM = \"<div class='msg'>No AP set</div>\";\nconst char HTTP_BR[]               PROGMEM = \"<br/>\";\n\nconst char HTTP_STYLE[]            PROGMEM = \"<style>\"\n\".c,body{text-align:center;font-family:verdana}div,input,select{padding:5px;font-size:1em;margin:5px 0;box-sizing:border-box}\"\n\"input,button,select,.msg{border-radius:.3rem;width: 100%}input[type=radio],input[type=checkbox]{width:auto}\"\n\"button,input[type='button'],input[type='submit']{cursor:pointer;border:0;background-color:#1fa3ec;color:#fff;line-height:2.4rem;font-size:1.2rem;width:100%}\"\n\"input[type='file']{border:1px solid #1fa3ec}\"\n\".wrap {text-align:left;display:inline-block;min-width:260px;max-width:500px}\"\n// links\n\"a{color:#000;font-weight:700;text-decoration:none}a:hover{color:#1fa3ec;text-decoration:underline}\"\n// quality icons\n\".q{height:16px;margin:0;padding:0 5px;text-align:right;min-width:38px;float:right}.q.q-0:after{background-position-x:0}.q.q-1:after{background-position-x:-16px}.q.q-2:after{background-position-x:-32px}.q.q-3:after{background-position-x:-48px}.q.q-4:after{background-position-x:-64px}.q.l:before{background-position-x:-80px;padding-right:5px}.ql .q{float:left}.q:after,.q:before{content:'';width:16px;height:16px;display:inline-block;background-repeat:no-repeat;background-position: 16px 0;\"\n\"background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAQCAMAAADeZIrLAAAAJFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADHJj5lAAAAC3RSTlMAIjN3iJmqu8zd7vF8pzcAAABsSURBVHja7Y1BCsAwCASNSVo3/v+/BUEiXnIoXkoX5jAQMxTHzK9cVSnvDxwD8bFx8PhZ9q8FmghXBhqA1faxk92PsxvRc2CCCFdhQCbRkLoAQ3q/wWUBqG35ZxtVzW4Ed6LngPyBU2CobdIDQ5oPWI5nCUwAAAAASUVORK5CYII=');}\"\n// icons @2x media query (32px rescaled)\n\"@media (-webkit-min-device-pixel-ratio: 2),(min-resolution: 192dpi){.q:before,.q:after {\"\n\"background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALwAAAAgCAMAAACfM+KhAAAALVBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAOrOgAAAADnRSTlMAESIzRGZ3iJmqu8zd7gKjCLQAAACmSURBVHgB7dDBCoMwEEXRmKlVY3L//3NLhyzqIqSUggy8uxnhCR5Mo8xLt+14aZ7wwgsvvPA/ofv9+44334UXXngvb6XsFhO/VoC2RsSv9J7x8BnYLW+AjT56ud/uePMdb7IP8Bsc/e7h8Cfk912ghsNXWPpDC4hvN+D1560A1QPORyh84VKLjjdvfPFm++i9EWq0348XXnjhhT+4dIbCW+WjZim9AKk4UZMnnCEuAAAAAElFTkSuQmCC');\"\n\"background-size: 95px 16px;}}\"\n// msg callouts\n\".msg{padding:20px;margin:20px 0;border:1px solid #eee;border-left-width:5px;border-left-color:#777}.msg h4{margin-top:0;margin-bottom:5px}.msg.P{border-left-color:#1fa3ec}.msg.P h4{color:#1fa3ec}.msg.D{border-left-color:#dc3630}.msg.D h4{color:#dc3630}.msg.S{border-left-color: #5cb85c}.msg.S h4{color: #5cb85c}\"\n// lists\n\"dt{font-weight:bold}dd{margin:0;padding:0 0 0.5em 0;min-height:12px}\"\n\"td{vertical-align: top;}\"\n\".h{display:none}\"\n\"button{transition: 0s opacity;transition-delay: 3s;transition-duration: 0s;cursor: pointer}\"\n\"button.D{background-color:#dc3630}\"\n\"button:active{opacity:50% !important;cursor:wait;transition-delay: 0s}\"\n// invert\n\"body.invert{background-color:#060606;}\"\n\"body.invert,body.invert a,body.invert h1 {color:#fff;}\"\n\"body.invert .msg{color:#fff;background-color:#282828;border-top:1px solid #555;border-right:1px solid #555;border-bottom:1px solid #555;}\"\n\"body.invert .q[role=img]{-webkit-filter:invert(1);filter:invert(1);}\"\n\":disabled {opacity: 0.5;}\"\n\"</style>\";\n\n#ifndef WM_NOHELP\nconst char HTTP_HELP[]             PROGMEM =\n \"<br/><h3>Available pages</h3><hr>\"\n \"<table class='table'>\"\n \"<thead><tr><th>Page</th><th>Function</th></tr></thead><tbody>\"\n \"<tr><td><a href='/'>/</a></td>\"\n \"<td>Menu page.</td></tr>\"\n \"<tr><td><a href='/wifi'>/wifi</a></td>\"\n \"<td>Show WiFi scan results and enter WiFi configuration.(/0wifi noscan)</td></tr>\"\n \"<tr><td><a href='/wifisave'>/wifisave</a></td>\"\n \"<td>Save WiFi configuration information and configure device. Needs variables supplied.</td></tr>\"\n \"<tr><td><a href='/param'>/param</a></td>\"\n \"<td>Parameter page</td></tr>\"\n \"<tr><td><a href='/info'>/info</a></td>\"\n \"<td>Information page</td></tr>\"\n \"<tr><td><a href='/u'>/u</a></td>\"\n \"<td>OTA Update</td></tr>\"\n \"<tr><td><a href='/close'>/close</a></td>\"\n \"<td>Close the captiveportal popup, config portal will remain active</td></tr>\"\n \"<tr><td>/exit</td>\"\n \"<td>Exit Config portal, config portal will close</td></tr>\"\n \"<tr><td>/restart</td>\"\n \"<td>Reboot the device</td></tr>\"\n \"<tr><td>/erase</td>\"\n \"<td>Erase WiFi configuration and reboot device. Device will not reconnect to a network until new WiFi configuration data is entered.</td></tr>\"\n \"</table>\"\n \"<p/>Github <a href='https://github.com/tzapu/WiFiManager'>https://github.com/tzapu/WiFiManager</a>.\";\n#else\nconst char HTTP_HELP[]             PROGMEM = \"\";\n#endif\n\nconst char HTTP_UPDATE[] PROGMEM = \"Upload new firmware<br/><form method='POST' action='u' enctype='multipart/form-data' onchange=\\\"(function(el){document.getElementById('uploadbin').style.display = el.value=='' ? 'none' : 'initial';})(this)\\\"><input type='file' name='update' accept='.bin,application/octet-stream'><button id='uploadbin' type='submit' class='h D'>Update</button></form><small><a href='http://192.168.4.1/update' target='_blank'>* May not function inside captive portal, open in browser http://192.168.4.1</a></small>\";\nconst char HTTP_UPDATE_FAIL[] PROGMEM = \"<div class='msg D'><strong>Update failed!</strong><Br/>Reboot device and try again</div>\";\nconst char HTTP_UPDATE_SUCCESS[] PROGMEM = \"<div class='msg S'><strong>Update successful.  </strong> <br/> Device rebooting now...</div>\";\n\n#ifdef WM_JSTEST\nconst char HTTP_JS[] PROGMEM =\n\"<script>function postAjax(url, data, success) {\"\n\"    var params = typeof data == 'string' ? data : Object.keys(data).map(\"\n\"            function(k){ return encodeURIComponent(k) + '=' + encodeURIComponent(data[k]) }\"\n\"        ).join('&');\"\n\"    var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\\\"Microsoft.XMLHTTP\\\");\"\n\"    xhr.open('POST', url);\"\n\"    xhr.onreadystatechange = function() {\"\n\"        if (xhr.readyState>3 && xhr.status==200) { success(xhr.responseText); }\"\n\"    };\"\n\"    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\"\n\"    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\"\n\"    xhr.send(params);\"\n\"    return xhr;}\"\n\"postAjax('/status', 'p1=1&p2=Hello+World', function(data){ console.log(data); });\"\n\"postAjax('/status', { p1: 1, p2: 'Hello World' }, function(data){ console.log(data); });\"\n\"</script>\";\n#endif\n\n// Info html\n// @todo remove html elements from progmem, repetetive strings\n#ifdef ESP32\n\tconst char HTTP_INFO_esphead[]    PROGMEM = \"<h3>esp32</h3><hr><dl>\";\n\tconst char HTTP_INFO_chiprev[]    PROGMEM = \"<dt>Chip rev</dt><dd>{1}</dd>\";\n  \tconst char HTTP_INFO_lastreset[]  PROGMEM = \"<dt>Last reset reason</dt><dd>CPU0: {1}<br/>CPU1: {2}</dd>\";\n  \tconst char HTTP_INFO_aphost[]     PROGMEM = \"<dt>Access point hostname</dt><dd>{1}</dd>\";\n    const char HTTP_INFO_psrsize[]    PROGMEM = \"<dt>PSRAM Size</dt><dd>{1} bytes</dd>\";\n\tconst char HTTP_INFO_temp[]       PROGMEM = \"<dt>Temperature</dt><dd>{1} C&deg; / {2} F&deg;</dd>\";\n    const char HTTP_INFO_hall[]       PROGMEM = \"<dt>Hall</dt><dd>{1}</dd>\";\n#else\n\tconst char HTTP_INFO_esphead[]    PROGMEM = \"<h3>esp8266</h3><hr><dl>\";\n\tconst char HTTP_INFO_fchipid[]    PROGMEM = \"<dt>Flash chip ID</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_corever[]    PROGMEM = \"<dt>Core version</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_bootver[]    PROGMEM = \"<dt>Boot version</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_lastreset[]  PROGMEM = \"<dt>Last reset reason</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_flashsize[]  PROGMEM = \"<dt>Real flash size</dt><dd>{1} bytes</dd>\";\n#endif\n\nconst char HTTP_INFO_memsmeter[]  PROGMEM = \"<br/><progress value='{1}' max='{2}'></progress></dd>\";\nconst char HTTP_INFO_memsketch[]  PROGMEM = \"<dt>Memory - Sketch size</dt><dd>Used / Total bytes<br/>{1} / {2}\";\nconst char HTTP_INFO_freeheap[]   PROGMEM = \"<dt>Memory - Free heap</dt><dd>{1} bytes available</dd>\";\nconst char HTTP_INFO_wifihead[]   PROGMEM = \"<br/><h3>WiFi</h3><hr>\";\nconst char HTTP_INFO_uptime[]     PROGMEM = \"<dt>Uptime</dt><dd>{1} mins {2} secs</dd>\";\nconst char HTTP_INFO_chipid[]     PROGMEM = \"<dt>Chip ID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_idesize[]    PROGMEM = \"<dt>Flash size</dt><dd>{1} bytes</dd>\";\nconst char HTTP_INFO_sdkver[]     PROGMEM = \"<dt>SDK version</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_cpufreq[]    PROGMEM = \"<dt>CPU frequency</dt><dd>{1}MHz</dd>\";\nconst char HTTP_INFO_apip[]       PROGMEM = \"<dt>Access point IP</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apmac[]      PROGMEM = \"<dt>Access point MAC</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apssid[]     PROGMEM = \"<dt>Access point SSID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apbssid[]    PROGMEM = \"<dt>BSSID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stassid[]    PROGMEM = \"<dt>Station SSID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_staip[]      PROGMEM = \"<dt>Station IP</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stagw[]      PROGMEM = \"<dt>Station gateway</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stasub[]     PROGMEM = \"<dt>Station subnet</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_dnss[]       PROGMEM = \"<dt>DNS Server</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_host[]       PROGMEM = \"<dt>Hostname</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stamac[]     PROGMEM = \"<dt>Station MAC</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_conx[]       PROGMEM = \"<dt>Connected</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_autoconx[]   PROGMEM = \"<dt>Autoconnect</dt><dd>{1}</dd>\";\n\nconst char HTTP_INFO_aboutver[]     PROGMEM = \"<dt>WiFiManager</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutarduino[] PROGMEM = \"<dt>Arduino</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutsdk[]     PROGMEM = \"<dt>ESP-SDK/IDF</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutdate[]    PROGMEM = \"<dt>Build date</dt><dd>{1}</dd>\";\n\nconst char S_brand[]              PROGMEM = \"WiFiManager\";\nconst char S_debugPrefix[]        PROGMEM = \"*wm:\";\nconst char S_y[]                  PROGMEM = \"Yes\";\nconst char S_n[]                  PROGMEM = \"No\";\nconst char S_enable[]             PROGMEM = \"Enabled\";\nconst char S_disable[]            PROGMEM = \"Disabled\";\nconst char S_GET[]                PROGMEM = \"GET\";\nconst char S_POST[]               PROGMEM = \"POST\";\nconst char S_NA[]                 PROGMEM = \"Unknown\";\nconst char S_passph[]             PROGMEM = \"********\";\nconst char S_titlewifisaved[]     PROGMEM = \"Credentials saved\";\nconst char S_titlewifisettings[]  PROGMEM = \"Settings saved\";\nconst char S_titlewifi[]          PROGMEM = \"Config ESP\";\nconst char S_titleinfo[]          PROGMEM = \"Info\";\nconst char S_titleparam[]         PROGMEM = \"Setup\";\nconst char S_titleparamsaved[]    PROGMEM = \"Setup saved\";\nconst char S_titleexit[]          PROGMEM = \"Exit\";\nconst char S_titlereset[]         PROGMEM = \"Reset\";\nconst char S_titleerase[]         PROGMEM = \"Erase\";\nconst char S_titleclose[]         PROGMEM = \"Close\";\nconst char S_options[]            PROGMEM = \"options\";\nconst char S_nonetworks[]         PROGMEM = \"No networks found. Refresh to scan again.\";\nconst char S_staticip[]           PROGMEM = \"Static IP\";\nconst char S_staticgw[]           PROGMEM = \"Static gateway\";\nconst char S_staticdns[]          PROGMEM = \"Static DNS\";\nconst char S_subnet[]             PROGMEM = \"Subnet\";\nconst char S_exiting[]            PROGMEM = \"Exiting\";\nconst char S_resetting[]          PROGMEM = \"Module will reset in a few seconds.\";\nconst char S_closing[]            PROGMEM = \"You can close the page, portal will continue to run\";\nconst char S_error[]              PROGMEM = \"An error occured\";\nconst char S_notfound[]           PROGMEM = \"File not found\\n\\n\";\nconst char S_uri[]                PROGMEM = \"URI: \";\nconst char S_method[]             PROGMEM = \"\\nMethod: \";\nconst char S_args[]               PROGMEM = \"\\nArguments: \";\nconst char S_parampre[]           PROGMEM = \"param_\";\n\n// debug strings\nconst char D_HR[]                 PROGMEM = \"--------------------\";\n\n\n// softap ssid default prefix\n#ifdef ESP8266\n    const char S_ssidpre[]        PROGMEM = \"ESP\";\n#elif defined(ESP32)\n    const char S_ssidpre[]        PROGMEM = \"ESP32\";\n#else\n    const char S_ssidpre[]        PROGMEM = \"WM\";\n#endif\n\n// END WIFI_MANAGER_OVERRIDE_STRINGS\n#endif\n\n#endif\n"
        },
        {
          "name": "wm_strings_es.h",
          "type": "blob",
          "size": 19.0947265625,
          "content": "/**\n * SAMPLE SAMPLE SAMPLE\n * \n * wm_strings_es.h\n * spanish strings for\n * WiFiManager, a library for the ESPX/Arduino platform\n * for configuration of WiFi credentials using a Captive Portal\n *\n * @author Creator tzapu\n * @author tablatronix\n * @version 0.0.0\n * @license MIT\n */\n\n#ifndef _WM_STRINGS_EN_H_\n#define _WM_STRINGS_EN_H_\n\n\n/**\n * ADD TO BUILD FLAGS\n * -DWM_STRINGS_FILE=\"\\\"wm_strings_es.h\\\"\"\n */\n\n#ifndef WIFI_MANAGER_OVERRIDE_STRINGS\n// !!! ABOVE WILL NOT WORK if you define in your sketch, must be build flag, if anyone one knows how to order includes to be able to do this it would be neat.. I have seen it done..\n\n// strings files must include a consts file!\n// Copy and change to custom locale tokens if necessary, but strings should be good enough\n#include \"wm_consts_en.h\" // include constants, tokens, routes\n\nconst char WM_LANGUAGE[] PROGMEM = \"es-ES\"; // i18n lang code\n\nconst char HTTP_HEAD_START[]       PROGMEM = \"<!DOCTYPE html>\"\n\"<html lang='en'><head>\"\n\"<meta name='format-detection' content='telephone=no'>\"\n\"<meta charset='UTF-8'>\"\n\"<meta  name='viewport' content='width=device-width,initial-scale=1,user-scalable=no'/>\"\n\"<title>{v}</title>\";\n\nconst char HTTP_SCRIPT[]           PROGMEM = \"<script>function c(l){\"\n\"document.getElementById('s').value=l.getAttribute('data-ssid')||l.innerText||l.textContent;\"\n\"p = l.nextElementSibling.classList.contains('l');\"\n\"document.getElementById('p').disabled = !p;\"\n\"if(p)document.getElementById('p').focus();};\"\n\"function f() {var x = document.getElementById('p');x.type==='password'?x.type='text':x.type='password';}\"\n\"</script>\"; // @todo add button states, disable on click , show ack , spinner etc\n\nconst char HTTP_HEAD_END[]         PROGMEM = \"</head><body class='{c}'><div class='wrap'>\"; // {c} = _bodyclass\n// example of embedded logo, base64 encoded inline, No styling here\n// const char HTTP_ROOT_MAIN[]        PROGMEM = \"<img title=' alt=' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADQElEQVRoQ+2YjW0VQQyE7Q6gAkgFkAogFUAqgFQAVACpAKiAUAFQAaECQgWECggVGH1PPrRvn3dv9/YkFOksoUhhfzwz9ngvKrc89JbnLxuA/63gpsCmwCADWwkNEji8fVNgotDM7osI/x777x5l9F6JyB8R4eeVql4P0y8yNsjM7KGIPBORp558T04A+CwiH1UVUItiUQmZ2XMReSEiAFgjAPBeVS96D+sCYGaUx4cFbLfmhSpnqnrZuqEJgJnd8cQplVLciAgX//Cf0ToIeOB9wpmloLQAwpnVmAXgdf6pwjpJIz+XNoeZQQZlODV9vhc1Tuf6owrAk/8qIhFbJH7eI3eEzsvydQEICqBEkZwiALfF70HyHPpqScPV5HFjeFu476SkRA0AzOfy4hYwstj2ZkDgaphE7m6XqnoS7Q0BOPs/sw0kDROzjdXcCMFCNwzIy0EcRcOvBACfh4k0wgOmBX4xjfmk4DKTS31hgNWIKBCI8gdzogTgjYjQWFMw+o9LzJoZ63GUmjWm2wGDc7EvDDOj/1IVMIyD9SUAL0WEhpriRlXv5je5S+U1i2N88zdPuoVkeB+ls4SyxCoP3kVm9jsjpEsBLoOBNC5U9SwpGdakFkviuFP1keblATkTENTYcxkzgxTKOI3jyDxqLkQT87pMA++H3XvJBYtsNbBN6vuXq5S737WqHkW1VgMQNXJ0RshMqbbT33sJ5kpHWymzcJjNTeJIymJZtSQd9NHQHS1vodoFoTMkfbJzpRnLzB2vi6BZAJxWaCr+62BC+jzAxVJb3dmmiLzLwZhZNPE5e880Suo2AZgB8e8idxherqUPnT3brBDTlPxO3Z66rVwIwySXugdNd+5ejhqp/+NmgIwGX3Py3QBmlEi54KlwmjkOytQ+iJrLJj23S4GkOeecg8G091no737qvRRdzE+HLALQoMTBbJgBsCj5RSWUlUVJiZ4SOljb05eLFWgoJ5oY6yTyJp62D39jDANoKKcSocPJD5dQYzlFAFZJflUArgTPZKZwLXAnHmerfJquUkKZEgyzqOb5TuDt1P3nwxobqwPocZA11m4A1mBx5IxNgRH21ti7KbAGiyNn3HoF/gJ0w05A8xclpwAAAABJRU5ErkJggg==' /><h1>{v}</h1><h3>WiFiManager</h3>\";\nconst char HTTP_ROOT_MAIN[]        PROGMEM = \"<h1>{t}</h1><h3>{v}</h3>\";\n\nconst char * const HTTP_PORTAL_MENU[] PROGMEM = {\n\"<form action='/wifi'    method='get'><button>Configurar WiFi</button></form><br/>\\n\", // MENU_WIFI\n\"<form action='/0wifi'   method='get'><button>Configurar WiFi (sin escanear)</button></form><br/>\\n\", // MENU_WIFINOSCAN\n\"<form action='/info'    method='get'><button>Información</button></form><br/>\\n\", // MENU_INFO\n\"<form action='/param'   method='get'><button>Configuración</button></form><br/>\\n\",//MENU_PARAM\n\"<form action='/close'   method='get'><button>Cerca</button></form><br/>\\n\", // MENU_CLOSE\n\"<form action='/restart' method='get'><button>Reanudar</button></form><br/>\\n\",// MENU_RESTART\n\"<form action='/exit'    method='get'><button>Salida</button></form><br/>\\n\",  // MENU_EXIT\n\"<form action='/erase'   method='get'><button class='D'>Borrar</button></form><br/>\\n\", // MENU_ERASE\n\"<form action='/update'  method='get'><button>Actualizer</button></form><br/>\\n\",// MENU_UPDATE\n\"<hr><br/>\" // MENU_SEP\n};\n\n// const char HTTP_PORTAL_OPTIONS[]   PROGMEM = strcat(HTTP_PORTAL_MENU[0] , HTTP_PORTAL_MENU[3] , HTTP_PORTAL_MENU[7]);\nconst char HTTP_PORTAL_OPTIONS[]   PROGMEM = \"\";\nconst char HTTP_ITEM_QI[]          PROGMEM = \"<div role='img' aria-label='{r}%' title='{r}%' class='q q-{q} {i} {h}'></div>\"; // rssi icons\nconst char HTTP_ITEM_QP[]          PROGMEM = \"<div class='q {h}'>{r}%</div>\"; // rssi percentage {h} = hidden showperc pref\nconst char HTTP_ITEM[]             PROGMEM = \"<div><a href='#p' onclick='c(this)' data-ssid='{V}'>{v}</a>{qi}{qp}</div>\"; // {q} = HTTP_ITEM_QI, {r} = HTTP_ITEM_QP\n// const char HTTP_ITEM[]            PROGMEM = \"<div><a href='#p' onclick='c(this)'>{v}</a> {R} {r}% {q} {e}</div>\"; // test all tokens\n\nconst char HTTP_FORM_START[]       PROGMEM = \"<form method='POST' action='{v}'>\";\nconst char HTTP_FORM_WIFI[]        PROGMEM = \"<label for='s'>SSID</label><input id='s' name='s' maxlength='32' autocorrect='off' autocapitalize='none' placeholder='{v}'><br/><label for='p'>Contraseña</label><input id='p' name='p' maxlength='64' type='password' placeholder='{p}'><input type='checkbox' onclick='f()'> Mostrar contraseña\";\nconst char HTTP_FORM_WIFI_END[]    PROGMEM = \"\";\nconst char HTTP_FORM_STATIC_HEAD[] PROGMEM = \"<hr><br/>\";\nconst char HTTP_FORM_END[]         PROGMEM = \"<br/><br/><button type='submit'>Save</button></form>\";\nconst char HTTP_FORM_LABEL[]       PROGMEM = \"<label for='{i}'>{t}</label>\";\nconst char HTTP_FORM_PARAM_HEAD[]  PROGMEM = \"<hr><br/>\";\nconst char HTTP_FORM_PARAM[]       PROGMEM = \"<br/><input id='{i}' name='{n}' maxlength='{l}' value='{v}' {c}>\\n\"; // do not remove newline!\n\nconst char HTTP_SCAN_LINK[]        PROGMEM = \"<br/><form action='/wifi?refresh=1' method='POST'><button name='refresh' value='1'>Refresh</button></form>\";\nconst char HTTP_SAVED[]            PROGMEM = \"<div class='msg'>Saving Credentials<br/>Trying to connect ESP to network.<br />If it fails reconnect to AP to try again</div>\";\nconst char HTTP_PARAMSAVED[]       PROGMEM = \"<div class='msg S'>Saved<br/></div>\";\nconst char HTTP_END[]              PROGMEM = \"</div></body></html>\";\nconst char HTTP_ERASEBTN[]         PROGMEM = \"<br/><form action='/erase' method='get'><button class='D'>Erase WiFi Config</button></form>\";\nconst char HTTP_UPDATEBTN[]        PROGMEM = \"<br/><form action='/update' method='get'><button>Actualizer</button></form>\";\nconst char HTTP_BACKBTN[]          PROGMEM = \"<hr><br/><form action='/' method='get'><button>Atrás</button></form>\";\n\nconst char HTTP_STATUS_ON[]        PROGMEM = \"<div class='msg S'><strong>Conectado</strong> a {v}<br/><em><small>con IP {i}</small></em></div>\";\nconst char HTTP_STATUS_OFF[]       PROGMEM = \"<div class='msg {c}'><strong>No conectado</strong> a {v}{r}</div>\"; // {c=class} {v=ssid} {r=status_off}\nconst char HTTP_STATUS_OFFPW[]     PROGMEM = \"<br/>Authentication Failure\"; // STATION_WRONG_PASSWORD,  no eps32\nconst char HTTP_STATUS_OFFNOAP[]   PROGMEM = \"<br/>No Encontrado\";   // WL_NO_SSID_AVAIL\nconst char HTTP_STATUS_OFFFAIL[]   PROGMEM = \"<br/>No se pudo conectar\"; // WL_CONNECT_FAILED\nconst char HTTP_STATUS_NONE[]      PROGMEM = \"<div class='msg'>Sin AP establecido</div>\";\nconst char HTTP_BR[]               PROGMEM = \"<br/>\";\n\nconst char HTTP_STYLE[]            PROGMEM = \"<style>\"\n\".c,body{text-align:center;font-family:verdana}div,input,select{padding:5px;font-size:1em;margin:5px 0;box-sizing:border-box}\"\n\"input,button,select,.msg{border-radius:.3rem;width: 100%}input[type=radio],input[type=checkbox]{width:auto}\"\n\"button,input[type='button'],input[type='submit']{cursor:pointer;border:0;background-color:#1fa3ec;color:#fff;line-height:2.4rem;font-size:1.2rem;width:100%}\"\n\"input[type='file']{border:1px solid #1fa3ec}\"\n\".wrap {text-align:left;display:inline-block;min-width:260px;max-width:500px}\"\n// links\n\"a{color:#000;font-weight:700;text-decoration:none}a:hover{color:#1fa3ec;text-decoration:underline}\"\n// quality icons\n\".q{height:16px;margin:0;padding:0 5px;text-align:right;min-width:38px;float:right}.q.q-0:after{background-position-x:0}.q.q-1:after{background-position-x:-16px}.q.q-2:after{background-position-x:-32px}.q.q-3:after{background-position-x:-48px}.q.q-4:after{background-position-x:-64px}.q.l:before{background-position-x:-80px;padding-right:5px}.ql .q{float:left}.q:after,.q:before{content:'';width:16px;height:16px;display:inline-block;background-repeat:no-repeat;background-position: 16px 0;\"\n\"background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAQCAMAAADeZIrLAAAAJFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADHJj5lAAAAC3RSTlMAIjN3iJmqu8zd7vF8pzcAAABsSURBVHja7Y1BCsAwCASNSVo3/v+/BUEiXnIoXkoX5jAQMxTHzK9cVSnvDxwD8bFx8PhZ9q8FmghXBhqA1faxk92PsxvRc2CCCFdhQCbRkLoAQ3q/wWUBqG35ZxtVzW4Ed6LngPyBU2CobdIDQ5oPWI5nCUwAAAAASUVORK5CYII=');}\"\n// icons @2x media query (32px rescaled)\n\"@media (-webkit-min-device-pixel-ratio: 2),(min-resolution: 192dpi){.q:before,.q:after {\"\n\"background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALwAAAAgCAMAAACfM+KhAAAALVBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAOrOgAAAADnRSTlMAESIzRGZ3iJmqu8zd7gKjCLQAAACmSURBVHgB7dDBCoMwEEXRmKlVY3L//3NLhyzqIqSUggy8uxnhCR5Mo8xLt+14aZ7wwgsvvPA/ofv9+44334UXXngvb6XsFhO/VoC2RsSv9J7x8BnYLW+AjT56ud/uePMdb7IP8Bsc/e7h8Cfk912ghsNXWPpDC4hvN+D1560A1QPORyh84VKLjjdvfPFm++i9EWq0348XXnjhhT+4dIbCW+WjZim9AKk4UZMnnCEuAAAAAElFTkSuQmCC');\"\n\"background-size: 95px 16px;}}\"\n// msg callouts\n\".msg{padding:20px;margin:20px 0;border:1px solid #eee;border-left-width:5px;border-left-color:#777}.msg h4{margin-top:0;margin-bottom:5px}.msg.P{border-left-color:#1fa3ec}.msg.P h4{color:#1fa3ec}.msg.D{border-left-color:#dc3630}.msg.D h4{color:#dc3630}.msg.S{border-left-color: #5cb85c}.msg.S h4{color: #5cb85c}\"\n// lists\n\"dt{font-weight:bold}dd{margin:0;padding:0 0 0.5em 0;min-height:12px}\"\n\"td{vertical-align: top;}\"\n\".h{display:none}\"\n\"button{transition: 0s opacity;transition-delay: 3s;transition-duration: 0s;cursor: pointer}\"\n\"button.D{background-color:#dc3630}\"\n\"button:active{opacity:50% !important;cursor:wait;transition-delay: 0s}\"\n// invert\n\"body.invert,body.invert a,body.invert h1 {background-color:#060606;color:#fff;}\"\n\"body.invert .msg{color:#fff;background-color:#282828;border-top:1px solid #555;border-right:1px solid #555;border-bottom:1px solid #555;}\"\n\"body.invert .q[role=img]{-webkit-filter:invert(1);filter:invert(1);}\"\n\":disabled {opacity: 0.5;}\"\n\"</style>\";\n\n#ifndef WM_NOHELP\nconst char HTTP_HELP[]             PROGMEM =\n \"<br/><h3>Available Pages</h3><hr>\"\n \"<table class='table'>\"\n \"<thead><tr><th>Page</th><th>Function</th></tr></thead><tbody>\"\n \"<tr><td><a href='/'>/</a></td>\"\n \"<td>Menu page.</td></tr>\"\n \"<tr><td><a href='/wifi'>/wifi</a></td>\"\n \"<td>Show WiFi scan results and enter WiFi configuration.(/0wifi noscan)</td></tr>\"\n \"<tr><td><a href='/wifisave'>/wifisave</a></td>\"\n \"<td>Save WiFi configuration information and configure device. Needs variables supplied.</td></tr>\"\n \"<tr><td><a href='/param'>/param</a></td>\"\n \"<td>Parameter page</td></tr>\"\n \"<tr><td><a href='/info'>/info</a></td>\"\n \"<td>Information page</td></tr>\"\n \"<tr><td><a href='/u'>/u</a></td>\"\n \"<td>OTA Update</td></tr>\"\n \"<tr><td><a href='/close'>/close</a></td>\"\n \"<td>Close the captiveportal popup,configportal will remain active</td></tr>\"\n \"<tr><td>/exit</td>\"\n \"<td>Exit Config Portal, configportal will close</td></tr>\"\n \"<tr><td>/restart</td>\"\n \"<td>Reboot the device</td></tr>\"\n \"<tr><td>/erase</td>\"\n \"<td>Erase WiFi configuration and reboot Device. Device will not reconnect to a network until new WiFi configuration data is entered.</td></tr>\"\n \"</table>\"\n \"<p/>Github <a href='https://github.com/tzapu/WiFiManager'>https://github.com/tzapu/WiFiManager</a>.\";\n#else\nconst char HTTP_HELP[]             PROGMEM = \"\";\n#endif\n\nconst char HTTP_UPDATE[] PROGMEM = \"Upload New Firmware<br/><form method='POST' action='u' enctype='multipart/form-data' onchange=\\\"(function(el){document.getElementById('uploadbin').style.display = el.value=='' ? 'none' : 'initial';})(this)\\\"><input type='file' name='update' accept='.bin,application/octet-stream'><button id='uploadbin' type='submit' class='h D'>Update</button></form><small><a href='http://192.168.4.1/update' target='_blank'>* May not function inside captive portal, Open in browser http://192.168.4.1</a></small>\";\nconst char HTTP_UPDATE_FAIL[] PROGMEM = \"<div class='msg D'><strong>Update Failed!</strong><Br/>Reboot device and try again</div>\";\nconst char HTTP_UPDATE_SUCCESS[] PROGMEM = \"<div class='msg S'><strong>Update Successful.  </strong> <br/> Device Rebooting now...</div>\";\n\n#ifdef WM_JSTEST\nconst char HTTP_JS[] PROGMEM =\n\"<script>function postAjax(url, data, success) {\"\n\"    var params = typeof data == 'string' ? data : Object.keys(data).map(\"\n\"            function(k){ return encodeURIComponent(k) + '=' + encodeURIComponent(data[k]) }\"\n\"        ).join('&');\"\n\"    var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\\\"Microsoft.XMLHTTP\\\");\"\n\"    xhr.open('POST', url);\"\n\"    xhr.onreadystatechange = function() {\"\n\"        if (xhr.readyState>3 && xhr.status==200) { success(xhr.responseText); }\"\n\"    };\"\n\"    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\"\n\"    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\"\n\"    xhr.send(params);\"\n\"    return xhr;}\"\n\"postAjax('/status', 'p1=1&p2=Hello+World', function(data){ console.log(data); });\"\n\"postAjax('/status', { p1: 1, p2: 'Hello World' }, function(data){ console.log(data); });\"\n\"</script>\";\n#endif\n\n// Info html\n// @todo remove html elements from progmem, repetetive strings\n#ifdef ESP32\n\tconst char HTTP_INFO_esphead[]    PROGMEM = \"<h3>esp32</h3><hr><dl>\";\n\tconst char HTTP_INFO_chiprev[]    PROGMEM = \"<dt>Chip Rev</dt><dd>{1}</dd>\";\n  \tconst char HTTP_INFO_lastreset[]  PROGMEM = \"<dt>Last reset reason</dt><dd>CPU0: {1}<br/>CPU1: {2}</dd>\";\n  \tconst char HTTP_INFO_aphost[]     PROGMEM = \"<dt>Access Point Hostname</dt><dd>{1}</dd>\";\n    const char HTTP_INFO_psrsize[]    PROGMEM = \"<dt>PSRAM Size</dt><dd>{1} bytes</dd>\";\n\tconst char HTTP_INFO_temp[]       PROGMEM = \"<dt>Temperature</dt><dd>{1} C&deg; / {2} F&deg;</dd><dt>Hall</dt><dd>{3}</dd>\";\n#else\n\tconst char HTTP_INFO_esphead[]    PROGMEM = \"<h3>esp8266</h3><hr><dl>\";\n\tconst char HTTP_INFO_fchipid[]    PROGMEM = \"<dt>Flash Chip ID</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_corever[]    PROGMEM = \"<dt>Core Version</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_bootver[]    PROGMEM = \"<dt>Boot Version</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_lastreset[]  PROGMEM = \"<dt>Last reset reason</dt><dd>{1}</dd>\";\n\tconst char HTTP_INFO_flashsize[]  PROGMEM = \"<dt>Real Flash Size</dt><dd>{1} bytes</dd>\";\n#endif\n\nconst char HTTP_INFO_memsmeter[]  PROGMEM = \"<br/><progress value='{1}' max='{2}'></progress></dd>\";\nconst char HTTP_INFO_memsketch[]  PROGMEM = \"<dt>Memory - Sketch Size</dt><dd>Used / Total bytes<br/>{1} / {2}\";\nconst char HTTP_INFO_freeheap[]   PROGMEM = \"<dt>Memory - Free Heap</dt><dd>{1} bytes available</dd>\";\nconst char HTTP_INFO_wifihead[]   PROGMEM = \"<br/><h3>WiFi</h3><hr>\";\nconst char HTTP_INFO_uptime[]     PROGMEM = \"<dt>Uptime</dt><dd>{1} Mins {2} Secs</dd>\";\nconst char HTTP_INFO_chipid[]     PROGMEM = \"<dt>Chip ID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_idesize[]    PROGMEM = \"<dt>Flash Size</dt><dd>{1} bytes</dd>\";\nconst char HTTP_INFO_sdkver[]     PROGMEM = \"<dt>SDK Version</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_cpufreq[]    PROGMEM = \"<dt>CPU Frequency</dt><dd>{1}MHz</dd>\";\nconst char HTTP_INFO_apip[]       PROGMEM = \"<dt>Access Point IP</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apmac[]      PROGMEM = \"<dt>Access Point MAC</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apssid[]     PROGMEM = \"<dt>Access Point SSID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apbssid[]    PROGMEM = \"<dt>BSSID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stassid[]    PROGMEM = \"<dt>Station SSID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_staip[]      PROGMEM = \"<dt>Station IP</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stagw[]      PROGMEM = \"<dt>Station Gateway</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stasub[]     PROGMEM = \"<dt>Station Subnet</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_dnss[]       PROGMEM = \"<dt>DNS Server</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_host[]       PROGMEM = \"<dt>Hostname</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stamac[]     PROGMEM = \"<dt>Station MAC</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_conx[]       PROGMEM = \"<dt>Connected</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_autoconx[]   PROGMEM = \"<dt>Autoconnect</dt><dd>{1}</dd>\";\n\nconst char HTTP_INFO_aboutver[]     PROGMEM = \"<dt>WiFiManager</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutarduino[] PROGMEM = \"<dt>Arduino</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutsdk[]     PROGMEM = \"<dt>ESP-SDK/IDF</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutdate[]    PROGMEM = \"<dt>Build Date</dt><dd>{1}</dd>\";\n\nconst char S_brand[]              PROGMEM = \"WiFiManager\";\nconst char S_debugPrefix[]        PROGMEM = \"*wm:\";\nconst char S_y[]                  PROGMEM = \"Yes\";\nconst char S_n[]                  PROGMEM = \"No\";\nconst char S_enable[]             PROGMEM = \"Enabled\";\nconst char S_disable[]            PROGMEM = \"Disabled\";\nconst char S_GET[]                PROGMEM = \"GET\";\nconst char S_POST[]               PROGMEM = \"POST\";\nconst char S_NA[]                 PROGMEM = \"Unknown\";\nconst char S_passph[]             PROGMEM = \"********\";\nconst char S_titlewifisaved[]     PROGMEM = \"Credentials Saved\";\nconst char S_titlewifisettings[]  PROGMEM = \"Settings Saved\";\nconst char S_titlewifi[]          PROGMEM = \"Config ESP\";\nconst char S_titleinfo[]          PROGMEM = \"Info\";\nconst char S_titleparam[]         PROGMEM = \"Setup\";\nconst char S_titleparamsaved[]    PROGMEM = \"Setup Saved\";\nconst char S_titleexit[]          PROGMEM = \"Exit\";\nconst char S_titlereset[]         PROGMEM = \"Reset\";\nconst char S_titleerase[]         PROGMEM = \"Erase\";\nconst char S_titleclose[]         PROGMEM = \"Close\";\nconst char S_options[]            PROGMEM = \"options\";\nconst char S_nonetworks[]         PROGMEM = \"No networks found. Refresh to scan again.\";\nconst char S_staticip[]           PROGMEM = \"Static IP\";\nconst char S_staticgw[]           PROGMEM = \"Static Gateway\";\nconst char S_staticdns[]          PROGMEM = \"Static DNS\";\nconst char S_subnet[]             PROGMEM = \"Subnet\";\nconst char S_exiting[]            PROGMEM = \"Exiting\";\nconst char S_resetting[]          PROGMEM = \"Module will reset in a few seconds.\";\nconst char S_closing[]            PROGMEM = \"You can close the page, portal will continue to run\";\nconst char S_error[]              PROGMEM = \"An Error Occured\";\nconst char S_notfound[]           PROGMEM = \"File Not Found\\n\\n\";\nconst char S_uri[]                PROGMEM = \"URI: \";\nconst char S_method[]             PROGMEM = \"\\nMethod: \";\nconst char S_args[]               PROGMEM = \"\\nArguments: \";\nconst char S_parampre[]           PROGMEM = \"param_\";\n\n// debug strings\nconst char D_HR[]                 PROGMEM = \"--------------------\";\n\n\n// softap ssid default prefix\n#ifdef ESP8266\n    const char S_ssidpre[]        PROGMEM = \"ESP\";\n#elif defined(ESP32)\n    const char S_ssidpre[]        PROGMEM = \"ESP32\";\n#else\n    const char S_ssidpre[]        PROGMEM = \"WM\";\n#endif\n\n// END WIFI_MANAGER_OVERRIDE_STRINGS\n#endif\n\n#endif\n"
        },
        {
          "name": "wm_strings_fr.h",
          "type": "blob",
          "size": 19.6328125,
          "content": "/**\n * wm_strings_fr.h\n * French strings for\n * WiFiManager, a library for the ESP8266/Arduino platform\n * for configuration of WiFi credentials using a Captive Portal\n *\n * @author Creator tzapu\n * @author tablatronix\n * @version 0.0.1\n * @translated AByGCreation\n * @license MIT\n */\n\n#ifndef _WM_STRINGS_EN_H_\n#define _WM_STRINGS_EN_H_\n\n\n#ifndef WIFI_MANAGER_OVERRIDE_STRINGS\n// !!! ABOVE WILL NOT WORK if you define in your sketch, must be build flag, if anyone one knows how to order includes to be able to do this it would be neat.. I have seen it done..\n\n// strings files must include a consts file!\n#include \"wm_consts_en.h\" // include constants, tokens, routes\n\nconst char WM_LANGUAGE[] PROGMEM = \"fr-FR\"; // i18n lang code\n\nconst char HTTP_HEAD_START[]       PROGMEM = \"<!DOCTYPE html>\"\n\"<html lang='fr'><head>\"\n\"<meta name='format-detection' content='telephone=no'>\"\n\"<meta charset='UTF-8'>\"\n\"<meta  name='viewport' content='width=device-width,initial-scale=1,user-scalable=no'/>\"\n\"<title>{v}</title>\";\n\nconst char HTTP_SCRIPT[]           PROGMEM = \"<script>function c(l){\"\n\"document.getElementById('s').value=l.getAttribute('data-ssid')||l.innerText||l.textContent;\"\n\"p = l.nextElementSibling.classList.contains('l');\"\n\"document.getElementById('p').disabled = !p;\"\n\"if(p)document.getElementById('p').focus();};\"\n\"function f() {var x = document.getElementById('p');x.type==='password'?x.type='text':x.type='password';}\"\n\"</script>\"; // @todo add button states, disable on click , show ack , spinner etc\n\nconst char HTTP_HEAD_END[]         PROGMEM = \"</head><body class='{c}'><div class='wrap'>\"; // {c} = _bodyclass\n// example of embedded logo, base64 encoded inline, No styling here\n// const char HTTP_ROOT_MAIN[]        PROGMEM = \"<img title=' alt=' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADQElEQVRoQ+2YjW0VQQyE7Q6gAkgFkAogFUAqgFQAVACpAKiAUAFQAaECQgWECggVGH1PPrRvn3dv9/YkFOksoUhhfzwz9ngvKrc89JbnLxuA/63gpsCmwCADWwkNEji8fVNgotDM7osI/x777x5l9F6JyB8R4eeVql4P0y8yNsjM7KGIPBORp558T04A+CwiH1UVUItiUQmZ2XMReSEiAFgjAPBeVS96D+sCYGaUx4cFbLfmhSpnqnrZuqEJgJnd8cQplVLciAgX//Cf0ToIeOB9wpmloLQAwpnVmAXgdf6pwjpJIz+XNoeZQQZlODV9vhc1Tuf6owrAk/8qIhFbJH7eI3eEzsvydQEICqBEkZwiALfF70HyHPpqScPV5HFjeFu476SkRA0AzOfy4hYwstj2ZkDgaphE7m6XqnoS7Q0BOPs/sw0kDROzjdXcCMFCNwzIy0EcRcOvBACfh4k0wgOmBX4xjfmk4DKTS31hgNWIKBCI8gdzogTgjYjQWFMw+o9LzJoZ63GUmjWm2wGDc7EvDDOj/1IVMIyD9SUAL0WEhpriRlXv5je5S+U1i2N88zdPuoVkeB+ls4SyxCoP3kVm9jsjpEsBLoOBNC5U9SwpGdakFkviuFP1keblATkTENTYcxkzgxTKOI3jyDxqLkQT87pMA++H3XvJBYtsNbBN6vuXq5S737WqHkW1VgMQNXJ0RshMqbbT33sJ5kpHWymzcJjNTeJIymJZtSQd9NHQHS1vodoFoTMkfbJzpRnLzB2vi6BZAJxWaCr+62BC+jzAxVJb3dmmiLzLwZhZNPE5e880Suo2AZgB8e8idxherqUPnT3brBDTlPxO3Z66rVwIwySXugdNd+5ejhqp/+NmgIwGX3Py3QBmlEi54KlwmjkOytQ+iJrLJj23S4GkOeecg8G091no737qvRRdzE+HLALQoMTBbJgBsCj5RSWUlUVJiZ4SOljb05eLFWgoJ5oY6yTyJp62D39jDANoKKcSocPJD5dQYzlFAFZJflUArgTPZKZwLXAnHmerfJquUkKZEgyzqOb5TuDt1P3nwxobqwPocZA11m4A1mBx5IxNgRH21ti7KbAGiyNn3HoF/gJ0w05A8xclpwAAAABJRU5ErkJggg==' /><h1>{v}</h1><h3>WiFiManager</h3>\";\nconst char HTTP_ROOT_MAIN[]        PROGMEM = \"<h1>{t}</h1><h3>{v}</h3>\";\n\nconst char * const HTTP_PORTAL_MENU[] PROGMEM = {\n\"<form action='/wifi'    method='get'><button>Configure WiFi</button></form><br/>\\n\", // MENU_WIFI\n\"<form action='/0wifi'   method='get'><button>Configure WiFi (Sans scan)</button></form><br/>\\n\", // MENU_WIFINOSCAN\n\"<form action='/info'    method='get'><button>Info</button></form><br/>\\n\", // MENU_INFO\n\"<form action='/param'   method='get'><button>Configuration</button></form><br/>\\n\",//MENU_PARAM\n\"<form action='/close'   method='get'><button>Fermer</button></form><br/>\\n\", // MENU_CLOSE\n\"<form action='/restart' method='get'><button>Redémarrer</button></form><br/>\\n\",// MENU_RESTART\n\"<form action='/exit'    method='get'><button>Quitter</button></form><br/>\\n\",  // MENU_EXIT\n\"<form action='/erase'   method='get'><button class='D'>Effacer</button></form><br/>\\n\", // MENU_ERASE\n\"<form action='/update'  method='get'><button>Mettre à jour</button></form><br/>\\n\",// MENU_UPDATE\n\"<hr><br/>\" // MENU_SEP\n};\n\n// const char HTTP_PORTAL_OPTIONS[]   PROGMEM = strcat(HTTP_PORTAL_MENU[0] , HTTP_PORTAL_MENU[3] , HTTP_PORTAL_MENU[7]);\nconst char HTTP_PORTAL_OPTIONS[]   PROGMEM = \"\";\nconst char HTTP_ITEM_QI[]          PROGMEM = \"<div role='img' aria-label='{r}%' title='{r}%' class='q q-{q} {i} {h}'></div>\"; // rssi icons\nconst char HTTP_ITEM_QP[]          PROGMEM = \"<div class='q {h}'>{r}%</div>\"; // rssi percentage {h} = hidden showperc pref\nconst char HTTP_ITEM[]             PROGMEM = \"<div><a href='#p' onclick='c(this)' data-ssid='{V}'>{v}</a>{qi}{qp}</div>\"; // {q} = HTTP_ITEM_QI, {r} = HTTP_ITEM_QP\n// const char HTTP_ITEM[]            PROGMEM = \"<div><a href='#p' onclick='c(this)'>{v}</a> {R} {r}% {q} {e}</div>\"; // test all tokens\n\nconst char HTTP_FORM_START[]       PROGMEM = \"<form method='POST' action='{v}'>\";\nconst char HTTP_FORM_WIFI[]        PROGMEM = \"<label for='s'>SSID</label><input id='s' name='s' maxlength='32' autocorrect='off' autocapitalize='none' placeholder='{v}'><br/><label for='p'>Mot de passe</label><input id='p' name='p' maxlength='64' type='password' placeholder='{p}'><input type='checkbox' id='showpass' onclick='f()'> <label for='showpass'>Voir le mot de passe</label><br/>\";\nconst char HTTP_FORM_WIFI_END[]    PROGMEM = \"\";\nconst char HTTP_FORM_STATIC_HEAD[] PROGMEM = \"<hr><br/>\";\nconst char HTTP_FORM_END[]         PROGMEM = \"<br/><br/><button type='submit'>Enregistrer</button></form>\";\nconst char HTTP_FORM_LABEL[]       PROGMEM = \"<label for='{i}'>{t}</label>\";\nconst char HTTP_FORM_PARAM_HEAD[]  PROGMEM = \"<hr><br/>\";\nconst char HTTP_FORM_PARAM[]       PROGMEM = \"<br/><input id='{i}' name='{n}' maxlength='{l}' value='{v}' {c}>\\n\"; // do not remove newline!\n\nconst char HTTP_SCAN_LINK[]        PROGMEM = \"<br/><form action='/wifi?refresh=1' method='POST'><button name='refresh' value='1'>Rafraichir</button></form>\";\nconst char HTTP_SAVED[]            PROGMEM = \"<div class='msg'>Enregistrer l'accès<br/>L'ESP essai de se connecter au réseau.<br />Si échec, merci de vous reconnecter à nouveau.</div>\";\nconst char HTTP_PARAMSAVED[]       PROGMEM = \"<div class='msg S'>Enregistré<br/></div>\";\nconst char HTTP_END[]              PROGMEM = \"</div></body></html>\";\nconst char HTTP_ERASEBTN[]         PROGMEM = \"<br/><form action='/erase' method='get'><button class='D'>Effacer la configuration WiFi</button></form>\";\nconst char HTTP_UPDATEBTN[]        PROGMEM = \"<br/><form action='/update' method='get'><button>Mettre à jour</button></form>\";\nconst char HTTP_BACKBTN[]          PROGMEM = \"<hr><br/><form action='/' method='get'><button>Retour</button></form>\";\n\nconst char HTTP_STATUS_ON[]        PROGMEM = \"<div class='msg S'><strong>Connecté</strong> to {v}<br/><em><small>with IP {i}</small></em></div>\";\nconst char HTTP_STATUS_OFF[]       PROGMEM = \"<div class='msg {c}'><strong>Non connecté</strong> à {v}{r}</div>\"; // {c=class} {v=ssid} {r=status_off}\nconst char HTTP_STATUS_OFFPW[]     PROGMEM = \"<br/>Echec d'authentication\"; // STATION_WRONG_PASSWORD,  no eps32\nconst char HTTP_STATUS_OFFNOAP[]   PROGMEM = \"<br/>Point d'accès introuvable\";   // WL_NO_SSID_AVAIL\nconst char HTTP_STATUS_OFFFAIL[]   PROGMEM = \"<br/>Impossible de se connecter\"; // WL_CONNECT_FAILED\nconst char HTTP_STATUS_NONE[]      PROGMEM = \"<div class='msg'>Aucune borne sélectionnée</div>\";\nconst char HTTP_BR[]               PROGMEM = \"<br/>\";\n\nconst char HTTP_STYLE[]            PROGMEM = \"<style>\"\n\".c,body{text-align:center;font-family:verdana}div,input,select{padding:5px;font-size:1em;margin:5px 0;box-sizing:border-box}\"\n\"input,button,select,.msg{border-radius:.3rem;width: 100%}input[type=radio],input[type=checkbox]{width:auto}\"\n\"button,input[type='button'],input[type='submit']{cursor:pointer;border:0;background-color:#1fa3ec;color:#fff;line-height:2.4rem;font-size:1.2rem;width:100%}\"\n\"input[type='file']{border:1px solid #1fa3ec}\"\n\".wrap {text-align:left;display:inline-block;min-width:260px;max-width:500px}\"\n// links\n\"a{color:#000;font-weight:700;text-decoration:none}a:hover{color:#1fa3ec;text-decoration:underline}\"\n// quality icons\n\".q{height:16px;margin:0;padding:0 5px;text-align:right;min-width:38px;float:right}.q.q-0:after{background-position-x:0}.q.q-1:after{background-position-x:-16px}.q.q-2:after{background-position-x:-32px}.q.q-3:after{background-position-x:-48px}.q.q-4:after{background-position-x:-64px}.q.l:before{background-position-x:-80px;padding-right:5px}.ql .q{float:left}.q:after,.q:before{content:'';width:16px;height:16px;display:inline-block;background-repeat:no-repeat;background-position: 16px 0;\"\n\"background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAQCAMAAADeZIrLAAAAJFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADHJj5lAAAAC3RSTlMAIjN3iJmqu8zd7vF8pzcAAABsSURBVHja7Y1BCsAwCASNSVo3/v+/BUEiXnIoXkoX5jAQMxTHzK9cVSnvDxwD8bFx8PhZ9q8FmghXBhqA1faxk92PsxvRc2CCCFdhQCbRkLoAQ3q/wWUBqG35ZxtVzW4Ed6LngPyBU2CobdIDQ5oPWI5nCUwAAAAASUVORK5CYII=');}\"\n// icons @2x media query (32px rescaled)\n\"@media (-webkit-min-device-pixel-ratio: 2),(min-resolution: 192dpi){.q:before,.q:after {\"\n\"background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALwAAAAgCAMAAACfM+KhAAAALVBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAOrOgAAAADnRSTlMAESIzRGZ3iJmqu8zd7gKjCLQAAACmSURBVHgB7dDBCoMwEEXRmKlVY3L//3NLhyzqIqSUggy8uxnhCR5Mo8xLt+14aZ7wwgsvvPA/ofv9+44334UXXngvb6XsFhO/VoC2RsSv9J7x8BnYLW+AjT56ud/uePMdb7IP8Bsc/e7h8Cfk912ghsNXWPpDC4hvN+D1560A1QPORyh84VKLjjdvfPFm++i9EWq0348XXnjhhT+4dIbCW+WjZim9AKk4UZMnnCEuAAAAAElFTkSuQmCC');\"\n\"background-size: 95px 16px;}}\"\n// msg callouts\n\".msg{padding:20px;margin:20px 0;border:1px solid #eee;border-left-width:5px;border-left-color:#777}.msg h4{margin-top:0;margin-bottom:5px}.msg.P{border-left-color:#1fa3ec}.msg.P h4{color:#1fa3ec}.msg.D{border-left-color:#dc3630}.msg.D h4{color:#dc3630}.msg.S{border-left-color: #5cb85c}.msg.S h4{color: #5cb85c}\"\n// lists\n\"dt{font-weight:bold}dd{margin:0;padding:0 0 0.5em 0;min-height:12px}\"\n\"td{vertical-align: top;}\"\n\".h{display:none}\"\n\"button{transition: 0s opacity;transition-delay: 3s;transition-duration: 0s;cursor: pointer}\"\n\"button.D{background-color:#dc3630}\"\n\"button:active{opacity:50% !important;cursor:wait;transition-delay: 0s}\"\n// invert\n\"body.invert,body.invert a,body.invert h1 {background-color:#060606;color:#fff;}\"\n\"body.invert .msg{color:#fff;background-color:#282828;border-top:1px solid #555;border-right:1px solid #555;border-bottom:1px solid #555;}\"\n\"body.invert .q[role=img]{-webkit-filter:invert(1);filter:invert(1);}\"\n\":disabled {opacity: 0.5;}\"\n\"</style>\";\n\n#ifndef WM_NOHELP\nconst char HTTP_HELP[]             PROGMEM =\n \"<br/><h3>Pages disponibles</h3><hr>\"\n \"<table class='table'>\"\n \"<thead><tr><th></th><th>Fonctions</th></tr></thead><tbody>\"\n \"<tr><td><a href='/'>/</a></td>\"\n \"<td>Menu.</td></tr>\"\n \"<tr><td><a href='/wifi'>/wifi</a></td>\"\n \"<td>Afficher les résultats de l'analyse WiFi et entrer dans la configuration WiFi.(/0wifi noscan)</td></tr>\"\n \"<tr><td><a href='/wifisave'>/wifisave</a></td>\"\n \"<td>Sauvegarde les informations de configuration WiFi et configure l'appareil. Veuillez entrer vos informations de connexion</td></tr>\"\n \"<tr><td><a href='/param'>/param</a></td>\"\n \"<td>Parametres</td></tr>\"\n \"<tr><td><a href='/info'>/info</a></td>\"\n \"<td>Informations</td></tr>\"\n \"<tr><td><a href='/u'>/u</a></td>\"\n \"<td>Mise à jour OTA</td></tr>\"\n \"<tr><td><a href='/close'>/close</a></td>\"\n \"<td>Fermer la fenêtre contextuelle du portail captif, le portail de configuration reste actif.</td></tr>\"\n \"<tr><td>/exit</td>\"\n \"<td>Quitter le portail de configuration, le portail de configuration se ferme</td></tr>\"\n \"<tr><td>/restart</td>\"\n \"<td>Redémarrer l'appareil</td></tr>\"\n \"<tr><td>/erase</td>\"\n \"<td>Effacer la configuration WiFi et redémarrer l'appareil. L'appareil ne se reconnectera pas à un réseau tant que de nouvelles données de configuration WiFi n'auront pas été saisies.</td></tr>\"\n \"</table>\"\n \"<p/>Github <a href='https://github.com/tzapu/WiFiManager'>https://github.com/tzapu/WiFiManager</a>.\";\n#else\nconst char HTTP_HELP[]             PROGMEM = \"\";\n#endif\n\nconst char HTTP_UPDATE[] PROGMEM = \"Charger le nouveau firmware<br/><form method='POST' action='u' enctype='multipart/form-data' onchange=\\\"(function(el){document.getElementById('uploadbin').style.display = el.value=='' ? 'none' : 'initial';})(this)\\\"><input type='file' name='update' accept='.bin,application/octet-stream'><button id='uploadbin' type='submit' class='h D'>Mise à jour</button></form><small><a href='http://192.168.4.1/update' target='_blank'>* Peut ne pas fonctionner à l'intérieur du portail captif, ouvrir dans le navigateur http://192.168.4.1</a></small>\";\nconst char HTTP_UPDATE_FAIL[] PROGMEM = \"<div class='msg D'><strong>Echec de la mise à jour !</strong><Br/>Redémarrer l'appareil et réessayer</div>\";\nconst char HTTP_UPDATE_SUCCESS[] PROGMEM = \"<div class='msg S'><strong>Mise à jour réussie. </strong> <br/> L'appareil redémarre maintenant...</div>\";\n\n#ifdef WM_JSTEST\nconst char HTTP_JS[] PROGMEM =\n\"<script>function postAjax(url, data, success) {\"\n\"    var params = typeof data == 'string' ? data : Object.keys(data).map(\"\n\"            function(k){ return encodeURIComponent(k) + '=' + encodeURIComponent(data[k]) }\"\n\"        ).join('&');\"\n\"    var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\\\"Microsoft.XMLHTTP\\\");\"\n\"    xhr.open('POST', url);\"\n\"    xhr.onreadystatechange = function() {\"\n\"        if (xhr.readyState>3 && xhr.status==200) { success(xhr.responseText); }\"\n\"    };\"\n\"    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\"\n\"    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\"\n\"    xhr.send(params);\"\n\"    return xhr;}\"\n\"postAjax('/status', 'p1=1&p2=Hello+World', function(data){ console.log(data); });\"\n\"postAjax('/status', { p1: 1, p2: 'Hello World' }, function(data){ console.log(data); });\"\n\"</script>\";\n#endif\n\n// Info html\n// @todo remove html elements from progmem, repetetive strings\n#ifdef ESP32\n  const char HTTP_INFO_esphead[]    PROGMEM = \"<h3>esp32</h3><hr><dl>\";\n  const char HTTP_INFO_chiprev[]    PROGMEM = \"<dt>Version Puce</dt><dd>{1}</dd>\";\n    const char HTTP_INFO_lastreset[]  PROGMEM = \"<dt>Motif de la dernière réinitialisation</dt><dd>CPU0: {1}<br/>CPU1: {2}</dd>\";\n    const char HTTP_INFO_aphost[]     PROGMEM = \"<dt>Nom du point d'accès</dt><dd>{1}</dd>\";\n    const char HTTP_INFO_psrsize[]    PROGMEM = \"<dt>Taille PSRAM </dt><dd>{1} octets</dd>\";\n  const char HTTP_INFO_temp[]       PROGMEM = \"<dt>Temperature</dt><dd>{1} C&deg; / {2} F&deg;</dd>\";\n    const char HTTP_INFO_hall[]       PROGMEM = \"<dt>Hall</dt><dd>{1}</dd>\";\n#else\n  const char HTTP_INFO_esphead[]    PROGMEM = \"<h3>esp8266</h3><hr><dl>\";\n  const char HTTP_INFO_fchipid[]    PROGMEM = \"<dt>ID de la puce flash</dt><dd>{1}</dd>\";\n  const char HTTP_INFO_corever[]    PROGMEM = \"<dt>Version Core</dt><dd>{1}</dd>\";\n  const char HTTP_INFO_bootver[]    PROGMEM = \"<dt>Version Boot </dt><dd>{1}</dd>\";\n  const char HTTP_INFO_lastreset[]  PROGMEM = \"<dt>Motif de la dernière réinitialisation</dt><dd>{1}</dd>\";\n  const char HTTP_INFO_flashsize[]  PROGMEM = \"<dt>Taille réelle de la mémoire Flash</dt><dd>{1} octets</dd>\";\n#endif\n\nconst char HTTP_INFO_memsmeter[]  PROGMEM = \"<br/><progress value='{1}' max='{2}'></progress></dd>\";\nconst char HTTP_INFO_memsketch[]  PROGMEM = \"<dt>Mémoire - Taille du programme</dt><dd>Utilisée / Total<br/>{1} / {2}\";\nconst char HTTP_INFO_freeheap[]   PROGMEM = \"<dt>Mémoire - Tampon</dt><dd>{1} octets disponibles</dd>\";\nconst char HTTP_INFO_wifihead[]   PROGMEM = \"<br/><h3>WiFi</h3><hr>\";\nconst char HTTP_INFO_uptime[]     PROGMEM = \"<dt>Temps de fonctionnement </dt><dd>{1} mins {2} secs</dd>\";\nconst char HTTP_INFO_chipid[]     PROGMEM = \"<dt>ID de l'ESP</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_idesize[]    PROGMEM = \"<dt>Taille mémoire Flash</dt><dd>{1} octets</dd>\";\nconst char HTTP_INFO_sdkver[]     PROGMEM = \"<dt>Version SDK</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_cpufreq[]    PROGMEM = \"<dt>Fréquence processeur</dt><dd>{1}MHz</dd>\";\nconst char HTTP_INFO_apip[]       PROGMEM = \"<dt>IP du point d'accès</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apmac[]      PROGMEM = \"<dt>Adresse MAC du point d'accès</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apssid[]     PROGMEM = \"<dt>SSID du point d'accès</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_apbssid[]    PROGMEM = \"<dt>BSSID</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stassid[]    PROGMEM = \"<dt>Identifiant réseau WiFi</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_staip[]      PROGMEM = \"<dt>Adresse IP</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stagw[]      PROGMEM = \"<dt>Passerelle</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stasub[]     PROGMEM = \"<dt>Masque de sous-réseau</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_dnss[]       PROGMEM = \"<dt>Serveur DNS</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_host[]       PROGMEM = \"<dt>Nom d'hôte</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_stamac[]     PROGMEM = \"<dt>Adresse MAC</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_conx[]       PROGMEM = \"<dt>Connecté</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_autoconx[]   PROGMEM = \"<dt>Autoconnect</dt><dd>{1}</dd>\";\n\nconst char HTTP_INFO_aboutver[]     PROGMEM = \"<dt>WiFiManager</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutarduino[] PROGMEM = \"<dt>Arduino</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutsdk[]     PROGMEM = \"<dt>ESP-SDK/IDF</dt><dd>{1}</dd>\";\nconst char HTTP_INFO_aboutdate[]    PROGMEM = \"<dt>Date de compilation</dt><dd>{1}</dd>\";\n\nconst char S_brand[]              PROGMEM = \"WiFiManager\";\nconst char S_debugPrefix[]        PROGMEM = \"*wm:\";\nconst char S_y[]                  PROGMEM = \"Oui\";\nconst char S_n[]                  PROGMEM = \"Non\";\nconst char S_enable[]             PROGMEM = \"Activé\";\nconst char S_disable[]            PROGMEM = \"Desactivé\";\nconst char S_GET[]                PROGMEM = \"GET\";\nconst char S_POST[]               PROGMEM = \"POST\";\nconst char S_NA[]                 PROGMEM = \"Inconnue\";\nconst char S_passph[]             PROGMEM = \"********\";\nconst char S_titlewifisaved[]     PROGMEM = \"Identifiants sauvegardés\";\nconst char S_titlewifisettings[]  PROGMEM = \"Paramètres enregistrés\";\nconst char S_titlewifi[]          PROGMEM = \"Configuration ESP\";\nconst char S_titleinfo[]          PROGMEM = \"Info\";\nconst char S_titleparam[]         PROGMEM = \"Configuration\";\nconst char S_titleparamsaved[]    PROGMEM = \"Configuration sauvegardée\";\nconst char S_titleexit[]          PROGMEM = \"Quitter\";\nconst char S_titlereset[]         PROGMEM = \"Réinitialiser\";\nconst char S_titleerase[]         PROGMEM = \"Effacer\";\nconst char S_titleclose[]         PROGMEM = \"Fermer\";\nconst char S_options[]            PROGMEM = \"options\";\nconst char S_nonetworks[]         PROGMEM = \"Aucun réseau trouvé. Rafraîchir pour scanner à nouveau.\";\nconst char S_staticip[]           PROGMEM = \"IP Statique\";\nconst char S_staticgw[]           PROGMEM = \"Passerelle\";\nconst char S_staticdns[]          PROGMEM = \"DNS\";\nconst char S_subnet[]             PROGMEM = \"Sous réseau\";\nconst char S_exiting[]            PROGMEM = \"Exiting\";\nconst char S_resetting[]          PROGMEM = \"Module will reset in a few seconds.\";\nconst char S_closing[]            PROGMEM = \"You can close the page, portal will continue to run\";\nconst char S_error[]              PROGMEM = \"An error occured\";\nconst char S_notfound[]           PROGMEM = \"File not found\\n\\n\";\nconst char S_uri[]                PROGMEM = \"URI: \";\nconst char S_method[]             PROGMEM = \"\\nMethod: \";\nconst char S_args[]               PROGMEM = \"\\nArguments: \";\nconst char S_parampre[]           PROGMEM = \"param_\";\n\n// debug strings\nconst char D_HR[]                 PROGMEM = \"--------------------\";\n\n\n// softap ssid default prefix\n#ifdef ESP8266\n    const char S_ssidpre[]        PROGMEM = \"ESP\";\n#elif defined(ESP32)\n    const char S_ssidpre[]        PROGMEM = \"ESP32\";\n#else\n    const char S_ssidpre[]        PROGMEM = \"WM\";\n#endif\n\n// END WIFI_MANAGER_OVERRIDE_STRINGS\n#endif\n\n#endif\n"
        }
      ]
    }
  ]
}