{
  "metadata": {
    "timestamp": 1736566125387,
    "page": 128,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "klzgrad/naiveproxy",
      "stars": 6812,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.16015625,
          "content": "src/chrome/android/profiles/afdo.prof\nsrc/chrome/build/pgo_profiles/\nsrc/gn/\nsrc/third_party/llvm-build/\nsrc/third_party/android_toolchain/\nsrc/out/\n.vscode/\n*.pyc\n"
        },
        {
          "name": "CHROMIUM_VERSION",
          "type": "blob",
          "size": 0.013671875,
          "content": "131.0.6778.86\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.5224609375,
          "content": "// Copyright 2015 The Chromium Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//    * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//    * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//    * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.33203125,
          "content": "# NaïveProxy ![build workflow](https://github.com/klzgrad/naiveproxy/actions/workflows/build.yml/badge.svg)\n\nNaïveProxy uses Chromium's network stack to camouflage traffic with strong censorship resistence and low detectablility. Reusing Chrome's stack also ensures best practices in performance and security.\n\nThe following traffic attacks are mitigated by using Chromium's network stack:\n\n* Website fingerprinting / traffic classification: [mitigated](https://arxiv.org/abs/1707.00641) by traffic multiplexing in HTTP/2.\n* [TLS parameter fingerprinting](https://arxiv.org/abs/1607.01639): defeated by reusing [Chrome's network stack](https://www.chromium.org/developers/design-documents/network-stack).\n* [Active probing](https://ensa.fi/active-probing/): defeated by *application fronting*, i.e. hiding proxy servers behind a commonly used frontend server with application-layer routing.\n* Length-based traffic analysis: mitigated by length padding.\n\n## Architecture\n\n[Browser → Naïve client] ⟶ Censor ⟶ [Frontend → Naïve server] ⟶ Internet\n\nNaïveProxy uses Chromium's network stack to parrot traffic between regular Chrome browsers and standard frontend servers.\n\nThe frontend server can be any well-known reverse proxy that is able to route HTTP/2 traffic based on HTTP authorization headers, preventing active probing of proxy existence. Known ones include Caddy with its forwardproxy plugin and HAProxy.\n\nThe Naïve server here works as a forward proxy and a packet length padding layer. Caddy forwardproxy is also a forward proxy but it lacks a padding layer. A [fork](https://github.com/klzgrad/forwardproxy) adds the NaïveProxy padding layer to forwardproxy, combining both in one.\n\n## Download NaïveProxy\n\nDownload [here](https://github.com/klzgrad/naiveproxy/releases/latest). Supported platforms include: Windows, Android (with [Exclave](https://github.com/dyhkwong/Exclave), [NekoBox](https://github.com/MatsuriDayo/NekoBoxForAndroid)), Linux, Mac OS, and OpenWrt ([support status](https://github.com/klzgrad/naiveproxy/wiki/OpenWrt-Support)).\n\nUsers should always use the latest version to keep signatures identical to Chrome.\n\nBuild from source: Please see [.github/workflows/build.yml](https://github.com/klzgrad/naiveproxy/blob/master/.github/workflows/build.yml).\n\n## Server setup\n\nThe following describes the naïve fork of Caddy forwardproxy setup.\n\nDownload [here](https://github.com/klzgrad/forwardproxy/releases/latest) or build from source:\n```sh\ngo install github.com/caddyserver/xcaddy/cmd/xcaddy@latest\n~/go/bin/xcaddy build --with github.com/caddyserver/forwardproxy=github.com/klzgrad/forwardproxy@naive\n```\n\nExample Caddyfile (replace `user` and `pass` accordingly):\n```\n{\n  order forward_proxy before file_server\n}\n:443, example.com {\n  tls me@example.com\n  forward_proxy {\n    basic_auth user pass\n    hide_ip\n    hide_via\n    probe_resistance\n  }\n  file_server {\n    root /var/www/html\n  }\n}\n```\n`:443` must appear first for this Caddyfile to work. See Caddyfile [docs](https://caddyserver.com/docs/caddyfile/directives/tls) for customizing TLS certificates. For more advanced usage consider using [JSON for Caddy 2's config](https://caddyserver.com/docs/json/).\n\nRun with the Caddyfile:\n```\nsudo setcap cap_net_bind_service=+ep ./caddy\n./caddy start\n```\n\nSee also [Systemd unit example](https://github.com/klzgrad/naiveproxy/wiki/Run-Caddy-as-a-daemon) and [HAProxy setup](https://github.com/klzgrad/naiveproxy/wiki/HAProxy-Setup).\n\n## Client setup\n\nRun `./naive` with the following `config.json` to get a SOCKS5 proxy at local port 1080.\n```json\n{\n  \"listen\": \"socks://127.0.0.1:1080\",\n  \"proxy\": \"https://user:pass@example.com\"\n}\n```\n\nOr `quic://user:pass@example.com`, if it works better. See also [parameter usage](https://github.com/klzgrad/naiveproxy/blob/master/USAGE.txt) and [performance tuning](https://github.com/klzgrad/naiveproxy/wiki/Performance-Tuning).\n\n## Third-party integration\n\n* [v2rayN](https://github.com/2dust/v2rayN), GUI client, Windows\n* [NekoBox for Android](https://github.com/MatsuriDayo/NekoBoxForAndroid), Proxy toolchain, Android\n* [NekoRay / NekoBox For PC](https://github.com/MatsuriDayo/nekoray), Qt based GUI, Windows, Linux\n\n## Notes for downstream\n\nDo not use the master branch to track updates, as it rebases from a new root commit for every new Chrome release. Use stable releases and the associated tags to track new versions, where short release notes are also provided.\n\n## Padding protocol, an informal specification\n\nThe design of this padding protocol opts for low overhead and easier implementation, in the belief that proliferation of expendable, improvised circumvention protocol designs is a better logistical impediment to censorship research than sophisicated designs.\n\n### Proxy payload padding\n\nNaïveProxy proxies bidirectional streams through HTTP/2 (or HTTP/3) CONNECT tunnels. The bidirectional streams operate in a sequence of reads and writes of data. The first `kFirstPaddings` (8) reads and writes in a bidirectional stream after the stream is established are padded in this format:\n```c\nstruct PaddedData {\n  uint8_t original_data_size_high;  // original_data_size / 256\n  uint8_t original_data_size_low;  // original_data_size % 256\n  uint8_t padding_size;\n  uint8_t original_data[original_data_size];\n  uint8_t zeros[padding_size];\n};\n```\n`padding_size` is a random integer uniformally distributed in [0, `kMaxPaddingSize`] (`kMaxPaddingSize`: 255). `original_data_size` cannot be greater than 65535, or it has to be split into several reads or writes.\n\n`kFirstPaddings` is chosen to be 8 to flatten the packet length distribution spikes formed from common initial handshakes:\n- Common client initial sequence: 1. TLS ClientHello; 2. TLS ChangeCipherSpec, Finished; 3. H2 Magic, SETTINGS, WINDOW_UPDATE; 4. H2 HEADERS GET; 5. H2 SETTINGS ACK.\n- Common server initial sequence: 1. TLS ServerHello, ChangeCipherSpec, ...; 2. TLS Certificate, ...; 3. H2 SETTINGS; 4. H2 WINDOW_UPDATE; 5. H2 SETTINGS ACK; 6. H2 HEADERS 200 OK.\n\nFurther reads and writes after `kFirstPaddings` are unpadded to avoid performance overhead. Also later packet lengths are usually considered less informative.\n\n### H2 RST_STREAM frame padding\n\nIn experiments, NaïveProxy tends to send too many RST_STREAM frames per session, an uncommon behavior from regular browsers. To solve this, an END_STREAM DATA frame padded with total length distributed in [48, 72] is prepended to the RST_STREAM frame so it looks like a HEADERS frame. The server often replies to this with a WINDOW_UPDATE because padding is accounted in flow control. Whether this results in a new uncommon behavior is still unclear.\n\n### H2 HEADERS frame padding\n\nThe CONNECT request and response frames are too short and too uncommon. To make its length similar to realistic HEADERS frames, a `padding` header is filled with a sequence of symbols that are not Huffman coded and are pseudo-random enough to avoid being indexed. The length of the padding sequence is randomly distributed in [16, 32] (request) or [30, 62] (response).\n\n### Opt-in of padding protocol\n\nNaïveProxy clients should interoperate with any regular HTTP/2 proxies unaware of this padding protocol. NaïveProxy servers (i.e. any proxy server capable of the this padding protocol) should interoperate with any regular HTTP/2 clients (e.g. regular browsers) unaware of this padding protocol.\n\nNaïveProxy servers and clients determines whether the counterpart is capable of this padding protocol by the presence of the `padding` header in the CONNECT request and response respectively. The padding procotol is enabled only if the `padding` header exists.\n\nThe first CONNECT request to a server cannot use \"Fast Open\" to send payload before response, because the server's padding capability has not been determined from the first response and it's unknown whether to send padded or unpadded payload for Fast Open.\n\n## Changes from Chromium upstream\n\n- Minimize source code and build size (0.3% of the original)\n- Disable exceptions and RTTI, except on Mac and Android.\n- Support OpenWrt builds\n- (Android, Linux) Use the builtin verifier instead of the system verifier (drop dependency of NSS on Linux) and read the system trust store from (following Go's behavior in crypto/x509/root_unix.go and crypto/x509/root_linux.go):\n  - The file in environment variable SSL_CERT_FILE\n  - The first available file of\n    -  /etc/ssl/certs/ca-certificates.crt (Debian/Ubuntu/Gentoo etc.)\n    -  /etc/pki/tls/certs/ca-bundle.crt (Fedora/RHEL 6)\n    -  /etc/ssl/ca-bundle.pem (OpenSUSE)\n    -  /etc/pki/tls/cacert.pem (OpenELEC)\n    -  /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem (CentOS/RHEL 7)\n    -  /etc/ssl/cert.pem (Alpine Linux)\n  - Files in the directory of environment variable SSL_CERT_DIR\n  - Files in the first available directory of\n    -  /etc/ssl/certs (SLES10/SLES11, https://golang.org/issue/12139)\n    -  /etc/pki/tls/certs (Fedora/RHEL)\n    -  /system/etc/security/cacerts (Android)\n- Handle AIA response in PKCS#7 format\n- Allow higher socket limits for proxies\n- Force tunneling for all sockets\n- Support HTTP/2 and HTTP/3 CONNECT tunnel Fast Open using the `fastopen` header\n- Pad RST_STREAM frames\n\n## Known weaknesses\n\n* HTTP CONNECT Fast Open creates back to back h2 packets consistently, which should not appear so often. This could be fixed with a little bit of corking but it would require surgical change deep in Chromium h2 stack, not very easy to do.\n* TLS over TLS requires more handshake round trips than needed by common h2 requests, that is, no h2 requests need these many back and forth handshakes. There is no simple way to avoid this besides doing MITM proxying, breaking E2E encryption.\n* TLS over TLS overhead causes visible packet length enlargement and lack of small packets. Removing this overhead also requires MITM proxying.\n* TLS over TLS overhead also causes packets to consistently exceed MTU limits, which should not happen for an originating user agent. Fixing this requires re-segmentation and it is not easy to do.\n* Packet length obfuscation partly relies on h2 multiplexing, which does not work if there is only one connection, a scenario not uncommon. It is not clear how to create covering co-connections organically (i.e. not hard coded).\n* Multiplexing requires use of a few long-lived tunnel connections. It is not clearly how long is appropriate for parroting and how to convincingly rotate the connections if there is an age limit or how to detect and recover stuck tunnel connections convincingly.\n\n"
        },
        {
          "name": "USAGE.txt",
          "type": "blob",
          "size": 3.6796875,
          "content": "Usage: naive --listen=... --proxy=...\r\n       naive [/path/to/config.json]\r\n\r\nDescription:\r\n\r\n  naive is a proxy that transports traffic in Chromium's pattern.\r\n  It works as both a proxy client and a proxy server or together.\r\n\r\n  Options in the form of `naive --listen=... --proxy=...` can also be\r\n  specified using a JSON file:\r\n\r\n    {\r\n      \"listen\": \"...\",\r\n      \"proxy\": \"...\"\r\n    }\r\n\r\n  Specifying a flag multiple times on the command line is equivalent to\r\n  having an array of multiple strings in the JSON file.\r\n\r\n  Uses \"config.json\" by default if run without arguments.\r\n\r\nOptions:\r\n\r\n  -h, --help\r\n\r\n    Shows help message.\r\n\r\n  --version\r\n\r\n    Prints version.\r\n\r\n  --listen=LISTEN-URI\r\n\r\n    LISTEN-URI = <LISTEN-PROTO>\"://\"[<USER>\":\"<PASS>\"@\"][<ADDR>][\":\"<PORT>]\r\n    LISTEN-PROTO = \"socks\" | \"http\" | \"redir\"\r\n\r\n    Listens at addr:port with protocol <LISTEN-PROTO>.\r\n    Can be specified multiple times to listen on multiple ports.\r\n    Default proto, addr, port: socks, 0.0.0.0, 1080.\r\n\r\n    Note: redir requires specific iptables rules and uses no authentication.\r\n\r\n      (Redirecting locally originated traffic)\r\n      iptables -t nat -A OUTPUT -d $proxy_server_ip -j RETURN\r\n      iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-ports 1080\r\n\r\n      (Redirecting forwarded traffic on a router)\r\n      iptables -t nat -A PREROUTING -p tcp -j REDIRECT --to-ports 1080\r\n\r\n      Also activates a DNS resolver on the same UDP port. Similar iptables\r\n      rules can redirect DNS queries to this resolver. The resolver returns\r\n      artificial addresses that are translated back to the original domain\r\n      names in proxy requests and then resolved remotely.\r\n\r\n      The artificial results are not saved for privacy, so restarting the\r\n      resolver may cause downstream to cache stale results.\r\n\r\n  --proxy=PROXY\r\n\r\n    PROXY = PROXY-CHAIN | SOCKS-PROXY\r\n    PROXY-CHAIN = <PROXY-URI>[\",\"<PROXY-CHAIN>] \r\n    PROXY-URI = <PROXY-PROTO>\"://\"[<USER>\":\"<PASS>\"@\"]<HOSTNAME>[\":\"<PORT>]\r\n    PROXY-PROTO = \"http\" | \"https\" | \"quic\"\r\n    SOCKS-PROXY = \"socks://\"<HOSTNAME>[\":\"<PORT>]\r\n\r\n    Routes traffic via the proxy chain.\r\n    The default proxy is directly connection without proxying.\r\n    The last PROXY-URI is negotiated automatically for Naive padding.\r\n    Limitations:\r\n      * QUIC proxies cannot follow TCP-based proxies in a proxy chain.\r\n      * The user needs to ensure there is no loop in the proxy chain.\r\n      * SOCKS proxies do not support chaining, authentication, or Naive padding.\r\n\r\n  --insecure-concurrency=<N>\r\n\r\n    Use N concurrent tunnel connections to be more robust under bad network\r\n    conditions. More connections make the tunneling easier to detect and less\r\n    secure. This project strives for the strongest security against traffic\r\n    analysis. Using it in an insecure way defeats its purpose.\r\n\r\n    If you must use this, try N=2 first to see if it solves your issues.\r\n    Strongly recommend against using more than 4 connections here.\r\n\r\n  --extra-headers=...\r\n\r\n    Appends extra headers in requests to the proxy server.\r\n    Multiple headers are separated by CRLF.\r\n\r\n  --host-resolver-rules=\"MAP proxy.example.com 1.2.3.4\"\r\n\r\n    Statically resolves a domain name to an IP address.\r\n\r\n  --resolver-range=CIDR\r\n\r\n    Uses this range in the builtin resolver. Default: 100.64.0.0/10.\r\n\r\n  --log=[<path>]\r\n\r\n    Saves log to the file at <path>. If path is empty, prints to\r\n    console. No log is saved or printed by default for privacy.\r\n\r\n  --log-net-log=<path>\r\n\r\n    Saves NetLog. View at https://netlog-viewer.appspot.com/.\r\n\r\n  --ssl-key-log-file=<path>\r\n\r\n    Saves SSL keys for Wireshark inspection.\r\n\r\n  --no-post-quantum\r\n\r\n    Overrides the default and disables post-quantum key agreement.\r\n"
        },
        {
          "name": "apk",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}