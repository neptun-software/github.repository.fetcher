{
  "metadata": {
    "timestamp": 1736566236854,
    "page": 254,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mhammond/pywin32",
      "stars": 5132,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.615234375,
          "content": "# A clang-format style that approximates Python's PEP 7\n# Useful for IDE integration\n# https://clang.llvm.org/docs/ClangFormatStyleOptions.html#configurable-format-style-options\nLanguage: Cpp\nBasedOnStyle: Google\n\nAlignAfterOpenBracket: Align\nAllowShortIfStatementsOnASingleLine: false\nAlwaysBreakAfterReturnType: None # Don't break after return type\nBreakBeforeBraces: Stroustrup\nColumnLimit: 120\nDerivePointerAlignment: false\nIndentWidth: 4\nPointerAlignment: Right\nReflowComments: true\nSortIncludes: false # Sorting includes breaks build\nSpaceBeforeParens: ControlStatements\nSpacesInParentheses: false\nTabWidth: 4\nUseTab: Never\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.3212890625,
          "content": "root = true\n\n[*]\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nend_of_line = crlf\nindent_style = space\nindent_size = 4\nmax_line_length = 120 # Same as .clang-format\n\n[*.py]\nmax_line_length = 88 # Same as Ruff's default\n\n[*.md]\ntrim_trailing_whitespace = false\n\n[*.{yaml,yml,json,toml,clang-format}]\nindent_size = 2\n"
        },
        {
          "name": ".git-blame-ignore-revs",
          "type": "blob",
          "size": 0.6376953125,
          "content": "# This file contains hashes of commits git blame should ignore.\n# Run `git config blame.ignoreRevsFile .git-blame-ignore-revs` to enable.\n# Requires git 2.23+.\n\n# 2019-09-07 formatted c++ source with clang-format\n059b7beb928225e389621802db758c75a7b8c58f\n\n# 2021-09-11 formatted Python source with black.\n858e19a76e08fc175a667ffc97409f2ef15bfc19\n\n# 2024-05-28 formatted trailing-whitespaces and end-of-file with pre-commit\n452e3dafc126faa978d67a946385bf2514477411\n\n# 2024-05-28 formatted c++ source with clang-format\n637448f8252ab142eedd539ddf9b08259b73eecc\n\n# 2024-10-14 formatted Python source with Ruff format\n2b5191d8fc6f1d1fbde01481b49278c1957ef8f1\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1572265625,
          "content": "# Files that must be \\r\\n in the working tree.\nAutoDuck/*.fmt          text eol=crlf\n*.dsp                   text eol=crlf\n*.dsw                   text eol=crlf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.3857421875,
          "content": "MANIFEST\nbuild\ndist\n__pycache__\n*.zip\n*.dbg\n*.exp\n*.ncb\n*.opt\n*.plg\n*.flg\n*.chm\n*.chw\n*.pyo\n*.pdb\n*.whl\narm64libs/\npywin32.egg-info/\nPyWin32.kpf\n\n# COM test bits\ncom/TestSources/Build\ncom/TestSources/PyCOMTest/PyCOMTest.h\ncom/TestSources/PyCOMTest/PyCOMTest.sln\ncom/TestSources/PyCOMTest/PyCOMTest.suo\ncom/TestSources/PyCOMTest/PyCOMTest.tlb\ncom/TestSources/PyCOMTest/PyCOMTest.vc*proj*\ncom/TestSources/PyCOMTest/PyCOMTest_i.c\ncom/TestSources/PyCOMTest/.vs/\n\n# SWIG generated files.\ncom/win32comext/adsi/src/*.cpp\n!com/win32comext/adsi/src/PyADSIUtil.cpp\ncom/win32comext/adsi/src/Py*.h\n!com/win32comext/adsi/src/PyADSIUtil.cpp\ncom/win32comext/mapi/src/*.cpp\n!com/win32comext/mapi/src/mapiutil.cpp\n!com/win32comext/mapi/src/mapiguids.cpp\n!com/win32comext/mapi/src/PyIMAPIAdviseSink.cpp\n!com/win32comext/mapi/src/exchangeguids.cpp\ncom/win32comext/mapi/src/Py*.h\n!com/win32comext/mapi/src/PyIMAPIAdviseSink.h\n!com/win32comext/mapi/src/PyMAPIUtil.h\nwin32/src/*_swig.cpp\n\n# Generated from message files\nwin32/src/PerfMon/PyPerfMsgs.h\nwin32/src/PythonServiceMessages.h\nwin32/src/win32service_messages.h\nwin32/src/win32evtlog_messages.h\nisapi/src/pyISAPI_messages.h\n\n# Visual Studio project files\n*.sln\n*.suo\n*.vcproj\n*.user\n\n# Eclipse + PyDev\n.project\n.pydevproject\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n.vagrant/\n\n# other IDEs, MacOS, etc\n.idea/\n.DS_Store\nvagrant_helpers/bootstrap-salt.ps1\n.vscode/\n"
        },
        {
          "name": ".hgeol",
          "type": "blob",
          "size": 0.2626953125,
          "content": "[patterns]\n**.dsp = CRLF\n**.dsw = CRLF\n**.vbp = CRLF\n# adodbapi appears to have been checked in with windows line endings\n# and without the 'eol' extension enabled, so we say it's binary to stop\n# hg continually thinking it has changed.\npath:adodbapi = bin\n** = native\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 1.5517578125,
          "content": "# You can run this locally with `pre-commit run --all`\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v5.0.0\n    hooks:\n      - id: trailing-whitespace\n        args: [--markdown-linebreak-ext=md]\n      - id: end-of-file-fixer\n      - id: mixed-line-ending\n        args: [--fix=crlf]\n      - id: check-case-conflict\n  - repo: https://github.com/macisamuele/language-formatters-pre-commit-hooks\n    rev: v2.14.0\n    hooks:\n      # Has unsafe autofixes. Let's find a better formatter: macisamuele/language-formatters-pre-commit-hooks#202\n      # - id: pretty-format-toml\n      #   args: [--autofix, --trailing-commas, --inline-comment-spaces, \"1\", --no-sort]\n      - id: pretty-format-yaml\n        args: [--autofix, --indent, \"2\", --offset, \"2\", --preserve-quotes]\n      - id: pretty-format-ini\n        args: [--autofix]\n  - repo: https://github.com/hadialqattan/pycln\n    rev: v2.4.0\n    hooks:\n      - id: pycln\n        args: [--config=pycln.toml]\n        verbose: true\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.8.4\n    hooks:\n      - id: ruff # Run the linter.\n        args: [--fix]\n      - id: ruff-format\n  - repo: https://github.com/pre-commit/mirrors-clang-format\n    rev: v18.1.8\n    hooks:\n      - id: clang-format\n        # Supports a lot more filetypes, but only tagging those we use\n        # https://github.com/pre-commit/mirrors-clang-format/blob/main/.pre-commit-hooks.yaml#L6\n        types: [c++]\n\n# Vendored\nexclude: ^(com/win32comext/mapi/src/MAPIStubLibrary/|Pythonwin/Scintilla/).*$\n\nci:\n  autoupdate_schedule: quarterly\n"
        },
        {
          "name": "AutoDuck",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGES.txt",
          "type": "blob",
          "size": 22.77734375,
          "content": "Notable changes in recent builds.\n\nMaintained by hand, so what's \"notable\" is subjective! Contributors are\nencouraged to add entries for their work.\n\nAll changes can be found via git - eg, for all changes after a build:\n    git log -rb3xx:\nor\n    https://github.com/mhammond/pywin32/compare/b3xx...main\n\nAs of build 305, installation .exe files have been deprecated; see\nhttps://mhammond.github.io/pywin32_installers.html.\n\nComing in build 309, as yet unreleased\n--------------------------------------\n\n* Removed param `hIcon` from `win32comext.shell.ShellExecuteEx`. It was unusable since Windows Vista (#2423, @Avasam)\n* Fixed `nbios.NCBStruct` packing (#2406, @Avasam)\n* Restored axdebug builds on Python 3.10 (#2416, @Avasam)\n* Pythonwin: Bumped Scintilla from 1.77 to 4.4.6. The full changelog can be found here: https://www.scintilla.org/ScintillaHistory.html\n* Fixed `ddeclient` and `ddeserver` demos import error (#2290, @Avasam)\n* The `EvtSubscribe_push` demo now actually demonstrates the callback action and the event context being filled. (#2281, @Avasam)\n* Fixed Pythonwin's editor failing due to invalid regex import (#2419, @Avasam)\n* Last error wrongly set by some modules (#2302, @CristiFati)\n* Dropped support for Python 3.7 (#2207, @Avasam)\n* Implement the creation of SAFEARRAY(VT_RECORD) from a sequence of COM Records (#2317, @geppi)\n* Implement record pointers as [in, out] method parameters of a Dispatch Interface (#2304, #2310, @geppi)\n* Fix memory leak converting to PyObject from some SAFEARRAY elements (#2316)\n* Fix bug where makepy support was unnecessarily generated (#2354, #2353, @geppi)\n* Fail sooner on invalid `win32timezone.TimeZoneInfo` creation (#2338, @Avasam)\n* Removed temporary `win32com.server.policy` reexports hack (#2344, @Avasam)\n  Import `DispatcherWin32trace` and `DispatcherTrace` from `win32com.server.dispatcher` instead.\n* Fixed `win32timezone.TimeZoneInfo` initialization from a `[DYNAMIC_]TIME_ZONE_INFORMATION` (#2339, @Avasam)\n* Added runtime deprecation warning of `win2kras`, use `win32ras` instead (#2356, @Avasam)\n* Improved handling of dict iterations and fallbacks (removes Python 2 support code, small general speed improvement) (#2332, #2330, @Avasam)\n* Fixed \"Open GL Demo\" (`Pythonwin/pywin/Demos/openGLDemo.py`) and restore \"Font\" demo in `Pythonwin/pywin/Demos/guidemo.py` (#2345, @Avasam)\n* Fixed accidentally trying to raise an undefined name instead of an `Exception` in `Pythonwin/pywin/debugger/debugger.py` (#2326, @Avasam)\n* Fixed PythonService DoLogMessage raising fatal GIL lock error (#2426, JacobNolan1)\n\nBuild 308, released 2024-10-12\n------------------------------\n* Fix Pythonwin displaying syntax errors in Python 3.13 (#2393)\n* Allowed installs from source w/o having pywin32 pre-installed (for instance, from GitHub) (#2349, @Avasam)\n* Restored version stamping of installed DLLs (#2349, @Avasam)\n* Fixed a circular import between `win32comext.axscript.client.framework` and `win32comext.axscript.client.error` (#2381, @Avasam)\n* Remove long-deprecated `win32com.server.dispatcher.DispatcherWin32dbg` (#2382, @Avasam)\n\nBuild 307, released 2024-10-04\n------------------------------\n### Release process changes\n\npywin32 is now released from artifacts created by Github actions, whereas previously they were\ncreated from an environment where certain tools and libraries were located and installed\nby hand.\n\nThis means some capabilities are no longer provided - this includes some documentation artifacts, such\nas the .chm file, certain MAPI libraries etc, and .exe installers.\n\n### pywin32\n* Remove obsolete and unused `pywin.is_platform_unicode` (#2343, @Avasam)\n* Fix `isapi.ThreadPoolExtension`'s printing of exception traceback broken on Python 3.8+ (#2312, @Avasam)\n* Add RealGetWindowClass (#2299, @CristiFati)\n* Make it compile on Python 3.13 (#2260, @clin1234)\n* Fixed accidentally trying to raise a `str` instead of an `Exception` in (#2270, @Avasam)\n  * `Pythonwin/pywin/debugger/debugger.py`\n  * `Pythonwin/pywin/framework/dlgappcore.py`\n  * `com/win32com/server/policy.py`\n  * `win32/Lib/regutil.py`\n  * `win32/scripts/VersionStamp/vssutil.py`\n* Removed the following unused symbols. They were meant to be used as Exceptions, but were accidentally strings (#2270, #2269, @Avasam)\n  * `pywin.debugger.debugger.error`\n  * `pywin.framework.dlgappcore.error`\n  * `win32com.server.policy.error`\n  * `regutil.error`\n  * `win32.scripts.VersionStamp.vssutil.error`\n  * `win32com.universal.com_error`\n  * `win32com.client.build.error`\n  * `win32com.client.genpy.error`\n* Add EnumDesktopWindows (#2219, @CristiFati)\n* Marked `exc_type` and `exc_traceback` in `win32comext.axscript.client.error.AXScriptException.__init__` as deprecated. (#2236, @Avasam)\n  They are now unused and all information is taken from the `exc_value` parameter.\n* Fixed non-overriden `pywin.scintilla.formatter.Formatter.ColorizeString` raising `TypeError` instead of `RuntimeError` due to too many parameters (#2216, @Avasam)\n* Fixed broken since Python 3 tokenization in `win32comext.axdebug.codecontainer.pySourceCodeContainer.GetSyntaxColorAttributes` (#2216, @Avasam)\n* Fixed a `TypeError` due to incorrect kwargs in `win32comext.axscript.client.pydumper.Register` (#2216, @Avasam)\n* Fixed error reporting of file copy failure for for installing debug dlls (#2216, @Avasam)\n* Fixed `py.exe -m win32verstamp` command and other quote typos caused by Implied String Concatenation (#2225, @Avasam)\n* Fixed tons of quote-related typos in strings, docs and comments (#2271 , @Avasam)\n* Fixed VT_SAFEARRAY(VT_RECORD) which were missing the last element (#2247)\n* Fixed `MFC redist DLLs not found` by preferring corresponding version but accepting different version (#2248, @andreabravetti)\n* Fixed `pywintypes.error: (5, 'RegOpenKeyEx', 'Access is denied.')` when running service with debug parameter and no elevation (#2238, @jmartens)\n* Fixed handling of `SyntaxError` exception from a Windows Scripting Host Python Script on Python 3.10+ (#2235, @nbbeatty)\n* Add `CredGetSessionTypes` support (#2232, @CristiFati)\n* Fixed `win32clipboard` increasing size of data when `SetClipboardData` used with `CF_DIB` (#2184, @CristiFati)\n* Add `StoreLogoff` to `PyIMsgStore` to prevent possible hang when MAPI uninitializes or during session logoff (#2196, @avivbrg)\n* Enhance CredDelete to work with dictionaries (#2198, @CristiFati)\n* Add UnregisterHotKey support (#2185, @CristiFati)\n* IFolderView COM client support (#2180, #2181, #2182, @CristiFati)\n* Release GIL when calling CreateService or StartService (#2062, @adamkbmc)\n* Drop support for Internet Explorer 10 (#2229, @Avasam)\n* Removed considerations for never-built Windows CE (#2218, @Avasam)\n* Stopped building `winxpgui` (#2217, @Avasam)\n  * Raise `DeprecationWarning` when importing `winxpgui`\n  * Added `GetWindowRgnBox` to `win32gui`\n  * `winxpgui.GetConsoleWindow` now aliases `win32console.GetConsoleWindow`\n  * Everything else is re-exported from `win32gui`\n* Fixed the `win32com.demos.ietoolbar` demo (#2217, @Avasam)\n* Fixed undefined names reported by Flake8/Ruff (#2101, @Avasam, @kxrob)\n  Fixed the following public API:\n    * Fixed `NameError` in `pywin.Demos`'s `fontdemo.FontView.SetFont`\n    * The `Pythonwin/pywin/Demos/ocx/msoffice` demo now uses the docName argument\n    * Fixed `NameError` in `WordFrame.Create`, even though it wasn't used\n    * Fixed a handful of `NameError` in `pywin.dialogs.ideoptions.OptionsPropPage` with format\n    * Fixed `AttributeError` in `pywin.framework.dlgappcore.AppDialog.OnPaint`\n    * Fixed trying to write banner to `sdterr` in `pywin.framework.interact.InteractiveCore.Init`\n    * Fixed a `NameError` in `pywin.framework.mdi_pychecker.TheDocument.doSearch`\n    * Removes unusable `HandleToUlong`, `UlongToHandle`, `UlongToPtr` and `UintToPtr` from `pywin.scintilla.scintillacon`\n    * Fixed a `NameError` in `win32comext.axscript.client.pydumper.Register`\n    * Fixed a `NameError` in `win32comext.shell.demos.servers.context_menu.ShellExtension.QueryContextMenu`\n    * Fixed a `NameError` in `win32comext.shell.demos.servers.shell_view.ScintillaShellView.CreateViewWindow`\n  The following methods no longer throw errors (although their implementation is still unvalidated):\n    * `mmsystem.MEVT_EVENTTYPE`\n    * `mmsystem.MEVT_EVENTPARM`\n    * `mmsystem.MCI_MSF_MINUTE`\n    * `mmsystem.MCI_MSF_SECOND`\n    * `mmsystem.MCI_TMSF_TRACK`\n    * `mmsystem.MCI_TMSF_MINUTE`\n    * `mmsystem.MCI_TMSF_SECOND`\n    * `mmsystem.MCI_TMSF_FRAME`\n    * `mmsystem.MCI_HMS_HOUR`\n    * `mmsystem.MCI_HMS_MINUTE`\n    * `mmsystem.MCI_HMS_SECOND`\n    * `mmsystem.DIBINDEX`\n    * `winnt.IMAGE_SNAP_BY_ORDINAL`\n    * `winnt.IMAGE_ORDINAL`\n* Removed `Unicode` and `UnicodeType` from `pywintypes` and `win32api` (#2200, @Avasam)\n* Deprecate `afxres` in favor of `pywin.mfc.afxres`. The modules were identical (#2177, @Avasam)\n* Improved `DispatcherWin32dbg`'s deprecation warning and raise an error when used (#2145, @Avasam)\n* Removed obsolete/legacy way of registering a Pythonwin app and its Idle handlers from `pywin.framework.app` (#2144, @Avasam)\n* Removed unused `win32comext.axscript.server.error` (#2202, @Avasam)\n* Removed deprecated `win32com.server.exception.Exception` (#2142, @Avasam)\n* Removed long-deprecated `UnicodeToString` param from multiple methods (#2143, @Avasam)\n* Fixed `win32api.SetClassWord` being overwritten by `win32api.SetWindowWord` (#2199, @Avasam)\n  * If you were using `win32api.SetClassWord` for its current behaviour, use `win32api.SetWindowWord` instead.\n  * This also adds missing support for `win32api.SetWindowWord`\n* Annotated module-level variables with ambiguous typing (#2175, @Avasam)\n* `win32com.client.build.NoTranslateMap` is now a `set` (#2176, @Avasam)\n* Fixed `ModuleNotFoundError: No module named 'dialog'` in `pywin.tools.regpy` (#2187, @Avasam)\n* Fixed passing a `float` to `range` in `win32pdhquery.Query.collectdatafor` (#2170, @Avasam)\n* Check that the filename w/o extension ends with `_d` rather than checking for `_d` anywhere in the file path (#2169, @Avasam)\n* Cleaned up and fixed Axdebug (#2126, @Avasam)\n    * `win32comext.axdebug.codecontainer.SourceCodeContainer` now uses the `debugDocument` parameter\n    * `win32comext.axdebug.codecontainer` script can now be run independent of location\n    * Fixed Method Resolution Order issue in `win32comext.axdebug.documents` (also #2071, @wxinix-2022)\n    * Fixed undefined names (`NameError`) in `win32comext.axdebug.expressions.DebugProperty.GetPropertyInfo`\n    * Removed unused `win32comext.axdebug.util.all_wrapped`\n    * Fixed multiple `ModuleNotFoundError` in `win32comext.axdebug` (#1983, @Avasam)\n* Change `mbcs` encoding to `utf-8` in `com.win32com.client` (#2097, @Avasam)\n* Avoid using `importlib` directly (#2123, @Avasam)\n* Replace most usages of deprecated `distutils`:\n    * Replace distutils.dep_util with setuptools.modified (#2148, @Avasam)\n    * Replaced `distutils.FileList` usage with `pathlib` (#2138, @Avasam)\n    * Replace `distutils.log` with `logging` (#2134, @Avasam)\n    * Replace `distutils` with direct `setuptools` equivalents where possible (#2134, @Avasam)\n* Replaced usages of the removed (in Python 3.12) `imp` module (#2113, @Avasam)\n  * Fixed registering Python as a scripting language for `axscript`\n  * Fixed `isapi` install\n* Use collection literals and comprehensions where applicable (slight performance improvement) (#2108, @Avasam)\n* Cleanup obsolete code for unsupported Python versions (#1990, #2127, #2205, #2214, @Avasam)\n  The following public names have been removed:\n    * `pywin.framework.app.Win32RawInput`\n    * `win32com.client.makepy.error`\n    * Long obsoleted `dbi` module, use the `odbc` module instead\n    * `win32com.client.dynamic.MakeMethod`\n  Added support for the following Python 3 methods:\n    * `pywin.mfc.dialog.Dialog.__contains__`\n    * `win32com.client.CoClassBaseClass.__bool__`\n    * `win32com.client.combrowse.HLIRoot.__lt__`\n    * `win32com.client.genpy.WritableItem.__lt__`\n    * `__bool__` in classes generated by `win32com.client.genpy.WritableItem.WriteClassBody`\n    * `win32/Demos`'s `win32clipboardDemo.Foo.__lt__`\n    * `win32timezone._SimpleStruct.__le__` (subclassed by `SYSTEMTIME`, `TIME_ZONE_INFORMATION`, `DYNAMIC_TIME_ZONE_INFORMATION`, `TimeZoneDefinition`)\n  The following methods no longer throw errors (although their implementation is still unvalidated):\n    * `winnt.PRIMARYLANGID`\n    * `winnt.SUBLANGID`\n    * `winnt.LANGIDFROMLCID`\n    * `winnt.SORTIDFROMLCID`\n* Removed obsolete compatibility aliases (#2087, @Avasam)\n  The following public names have been removed:\n    * `win32comext.mapi.mapiutil.TupleType`\n    * `win32comext.mapi.mapiutil.ListType`\n    * `win32comext.mapi.mapiutil.IntType`\n    * `netbios.byte_to_int`\n* Resolved invalid string escapes warnings (#2045, #2124, @Avasam)\n* Idiomatic type comparisons. Better handling of subclasses. (#1991, @Avasam)\n* Cleaned up obsolete and redundant code (this should not directly affect the end-user):\n  * Update and standardise obsolete `OSError` aliases (#2107, @Avasam)\n  * Removed redundant and obsolete references to older python unicode compatibility (#2085, @Avasam)\n  * Use byte-string (`b\"\"`) for constant bytes values instead of superfluous `.encode` calls (#2046, @Avasam)\n  * Cleaned up unused imports (#1986, #2051, #1990, #2124, #2126, @Avasam)\n  * Removed duplicated declarations, constants and definitions (#2050, #1950, #1990, @Avasam)\n* Small generalized optimization by using augmented assignments (in-place operators) where possible (#2274, @Avasam)\n* General speed and size improvements due to all the removed code. (#2046, #1986, #2050, #1950, #2085, #2087, #2051, #1990, #2106, #2127, #2124, #2126, #2177, #2218, #2202, #2205, #2217)\n\n### adodbapi\n* Remove references to outdated IronPython (#2049, @Avasam)\n  This removes the following public names:\n  * `adodbapi.adodbapi.onWin32`\n  * `adodbapi.apibase.onIronPython`\n  * `adodbapi.apibase.NullTypes`\n  * `adodbapi.apibase.DateTime`\n* Remove references to outdated `mxDateTime` (#2048, @Avasam)\n  This removes the following public names:\n  * `adodbapi.apibase.mxDateTime`\n  * `adodbapi.apibase.mxDateTimeConverter`\n* Removed obsolete Python 2 aliases (#2088, @Avasam)\n  This removes the following public names:\n  * `adodbapi.adodbapi.unicodeType`\n  * `adodbapi.adodbapi.longType`\n  * `adodbapi.adodbapi.StringTypes`\n  * `adodbapi.adodbapi.maxint`\n  * `adodbapi.apibase.unicodeType`\n  * `adodbapi.apibase.longType`\n  * `adodbapi.apibase.StringTypes`\n  * `adodbapi.apibase.makeByteBuffer`\n  * `adodbapi.apibase.memoryViewType`\n* Remove outdated and unused remote feature (#2098, @Avasam)\n* Migrated from `distutils` to `setuptools` (#2133, @Avasam)\n\nBuild 306, released 2023-03-26\n------------------------------\n* Add GetSystemPowerStatus (#2010, @CristiFati)\n\n* Add CascadeWindows (#1999, @CristiFati)\n\n* Add win32gui.ResetDC\n\n* Fix leak in win32pdh.GetFormattedCounterArray\n\n* Fix IIS on later python versions (#2025)\n\n* Fix for service registration code updated in build 305 (#1985)\n\n* Support for Python 3.6 was dropped, support for later versions was improved.\n\nBuild 305, released 2022-11-06\n------------------------------\n* Installation .exe files were deprecated.\n\n* @kxrob put a lot of work towards removing use of the deprecated Unicode\n  API so we can build on Python 3.12. This should be largely invisible, but\n  please report any unintended consequences.\n\n* odbc: Handle `varchar(max)`/`nvarchar(max)` column sizes (#1954)\n\n* win32api.GetTickCount() now returns an unsigned 64bit integer (@kxrob, #1946)\n\n* win32pipe.GetNamedPipeHandleState() now takes a 3rd optional param\n  indicating whether the username should be returned, and related constants\n  added. (@kxrob, #1946)\n\n* Add win32gui.GetTopWindow() and win32gui.GetAncestor() (#1928, @CristiFati)\n\n* Tweaks to how pywintypes searches for DLLs to better support virtualenvs\n  created with --system-site-packages. (@saaketp, #1933)\n\n* Added win32event.CreateWaitableTimerExW (#1945, @zariiii9003)\n\n* Changes in PARAM handling. Some functions which returned a WPARAM or LPARAM\n  allowed you to return a pointer to a Python buffer object or a PyUnicode.\n  These functions now only accept a Python long to be returned. Note that\n  this DOES NOT apply to functions with accept WPARAM or LPARAM as arguments,\n  only when they are being returned. Impacted functions are `OnNotify`\n  handler, LV_ITEM/TV_ITEM objects, PyIContextMenu3::HandleMenuMsg2, and the\n  result of a WNDPROC/DLGPROC (#1927).\n\n* service registration had an overhaul, avoiding a complicated, and ultimately\n  unnecessary \"single globally registered service runner\" concept.\n  Now, when registering a service, the host pythonservice.exe runner will be\n  copied to `sys.exec_prefix`, along with possibly `pywintypesXX.dll` and run\n  from there. (#1908)\n\n* Dropped support for allowing a bytes object to be passed where a COM BSTR\n  is expected - this support was accidental on the path from Python 2 -> 3.\n\n* win32crypt's PyCERTSTORE.CertCloseStore()'s `Flags` argument has been\n  deprecated as it is likely to crash the process if\n  `CERT_CLOSE_STORE_FORCE_FLAG` is specified. The underlying function is now\n  always called with `CERT_CLOSE_STORE_CHECK_FLAG`, and support for this\n  param will be dropped at some point in the future.\n\n* Fix a bug where win32crypt.CryptQueryObject() would return a PyCTL_CONTEXT\n  object instead of a PyCERT_CONTEXT for base64 encoded certificates (#1859)\n\n* win32crypt.CryptQueryObject() is now able to return PyCTL_CONTEXT objects.\n  This is technically a breaking change as previously it would return the\n  address in memory of the object, but this address wasn't practically usable,\n  so it's very unlikely anyone relied on this behavior. (#1859)\n\nBuild 304, released 2022-05-02\n------------------------------\n* Fixed Unicode issues in the `dde` module (#1861, @markuskimius )\n\n* Add `PRINTER_INFO_6` support for Set/GetPrinter (#1853, @CristiFati)\n\n* Fixed codepage/mojibake issues when non-ascii characters were included in\n  COM exceptions raised by Python apps. This should be invisible, but might\n  break any workarounds which were used, such as using specific encodings in\n  these strings. (#1823, #1833)\n\n* Fixed a bug triggering `win32print.SetJob` to fail due to data type\n  (`char*` / `wchar_t*`) mismatch (#1849, @CristiFati)\n\n* Fix eventlog initialization (#1845, #1846, @kxrob)\n\nBuild 303, released 2021-12-20\n------------------------------\n* Tweaks to how DLLs are loaded and our installation found, which should\n  improve virtualenv support and version mismatch issues (#1787, #1794)\n\n* Fixed a bug where `win32clipboard.GetClipboardData()` may have returned extra\n  data.\n\n* Binary installers for 32-bit 3.10+ are no longer released (#1805)\n\nBuild 302, released 2021-10-11\n------------------------------\n* Fixed support for unicode as a `win32crypt.CREDENTIAL_ATTRIBUTE.Value`\n\n* Support for Python 3.10, dropped support for Python 3.5 (3.5 security support\n  ended 13 Sep 2020)\n\n* Merged win2kras into win32ras. In the unlikely case that anyone is still\n  using win2kras, there is a win2kras.py that imports all of win32ras. If you\n  import win2kras and it fails with 'you must import win32ras first', then it\n  means an old win2kras.pyd exists, which you should remove.\n\n* github branch 'master' was renamed to 'main'.\n\nBuild 301, released 2021-05-30\n------------------------------\n* Fix some confusion on how dynamic COM object properties work. The old\n  code was confused, so there's a chance there will be some subtle\n  regression here - please open a bug if you find anything, but this\n  should fix #1427.\n\n* COM objects are now registered with the full path to pythoncomXX.dll, fixes\n  #1704.\n\n* Creating a `win32crypt.CRYPT_ATTRIBUTE` object now correctly sets `cbData`.\n\n* Add wrap and unwrap operations defined in the GSSAPI to the sspi module\n  and enhance the examples given in this module.\n  (#1692, Emmanuel Coirier)\n\n* Fix a bug in `win32profile.GetEnvironmentStrings()` relating to environment\n  variables with an equals sign (@maxim-krikun in #1661)\n\n* Fixed a bug where certain COM dates would fail to be converted to a Python\n  datetime object with `ValueError: microsecond must be in 0..999999`. Shoutout\n  to @hujiaxing for reporting and helping reproduce the issue (#1655)\n\n* Added win32com.shell.SHGetKnownFolderPath() and related constants.\n\n* CoClass objects should work better with special methods like __len__ etc.\n  (#1699)\n\n* Shifted work in win32.lib.pywin32_bootstrap to Python's import system from\n  manual path manipulations (@wkschwartz in #1651)\n\n* Fixed a bug where win32print.DeviceCapabilities would return strings\n  containing the null character followed by junk characters.\n  (#1654, #1660, Lincoln Puzey)\n\nBuild 300, released 2020-11-14\n------------------------------\n* Fixed a bug where win32com.client.VARIANT params were returned in the reverse\n  order. This only happened when win32com.client.VARIANT was explicitly used\n  (ie, not when normal params were passed) For example:\n  ```python\n      arg1 = VARIANT(pythoncom.VT_R4 | pythoncom.VT_BYREF, 2.0)\n      arg2 = VARIANT(pythoncom.VT_BOOL | pythoncom.VT_BYREF, True)\n      object.SomeFunction(arg1, arg2)\n  ```\n  after this call, `arg1.value` was actually the value for `arg2`, and\n  vice-versa (#1303, #622).\n\n* Fixed a bug that Pythonwin had an empty `sys.argv` (@kxrob in #1607)\n\n* Fixed a bug that prevented win32process.ReadProcessMemory() from working\n  in all scenarios (#1599)\n\n* Changed how Services implemented with win32serviceutil.ServiceFramework\n  report that they have stopped. Now if the SvcRun() method (or the SvcDoRun()\n  method, which is called by SvcRun() by default) raises on Exception,\n  the Service will report a final SERVICE_STOPPED status with a non-zero error\n  code. This will cause the Service's recovery actions to be triggered if the\n  Service has the \"Enable actions for stops with errors\" option enabled.\n  (#1563, Lincoln Puzey)\n\n* adodbapi connect() method now accepts a \"mode\" keyword argument which is the\n  \"Mode\" property to set on the ADO \"Connection\" object before opening the\n  Connection. See \"ConnectModeEnum\" for valid values.\n  (Lincoln Puzey)\n\n* The Windows 10 SDK is now used to build the project. This shouldn't cause any\n  visible changes, but should make it much easier to build the project yourself.\n\nPython 2 is no longer supported - so long, Python 2, you served us well!\n\nNotable changes in this transition:\n\n* Python 3 builds used to erroneously turn \"bytes\" into a tuple of integers\n  instead of a buffer type object. Because this special-casing is important for\n  performance when using massive buffers, this has been fixed in Python 3 so\n  it matches the old Python 2 behavior. If you use arrays of VT_UI1 and expect\n  get back tuples of integers, your code may break.\n\n* Pythonwin's default encoding is now utf-8 (#1559)\n\n* The build environment has been greatly simplified - you just need Visual\n  Studio and a Windows 10 SDK. (The free compilers probably work too, but\n  haven't been tested - let me know your experiences!)\n\nPrevious\n--------\nBuild 228 (2020-06-13) was the last to support Python 2.0.\n\nOlder entries are periodically removed - see the git history of this file\nfor them.\n"
        },
        {
          "name": "Pythonwin",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.6630859375,
          "content": "# pywin32\n\n[![CI](https://github.com/mhammond/pywin32/workflows/CI/badge.svg)](https://github.com/mhammond/pywin32/actions?query=workflow%3ACI)\n[![PyPI - Version](https://img.shields.io/pypi/v/pywin32.svg)](https://pypi.org/project/pywin32)\n[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/pywin32.svg)](https://pypi.org/project/pywin32)\n[![PyPI - Downloads](https://img.shields.io/pypi/dm/pywin32.svg)](https://pypi.org/project/pywin32)\n[![License - PSF-2.0](https://img.shields.io/badge/license-PSF--2.0-9400d3.svg)](https://spdx.org/licenses/PSF-2.0.html)\n\n-----\n\nThis is the readme for the Python for Win32 (pywin32) extensions, which provides access to many of the Windows APIs from Python.\n\nSee [CHANGES.txt](https://github.com/mhammond/pywin32/blob/master/CHANGES.txt) for recent notable changes.\n\n## Docs\n\nThe docs are a long and sad story, but [there's now an online version](https://mhammond.github.io/pywin32/)\nof the `PyWin32.chm` helpfile (thanks [@ofek](https://github.com/mhammond/pywin32/pull/1774)!).\nLots of that is very old, but some is auto-generated and current. Would love help untangling the docs!\n\n## Support\n\nFeel free to [open issues](https://github.com/mhammond/pywin32/issues) for\nall bugs (or suspected bugs) in pywin32. [pull-requests](https://github.com/mhammond/pywin32/pulls)\nfor all bugs or features are also welcome.\n\nHowever, please **do not open github issues for general support requests**, or\nfor problems or questions using the modules in this package - they will be\nclosed. For such issues, please email the\n[python-win32 mailing list](http://mail.python.org/mailman/listinfo/python-win32) -\nnote that you must be subscribed to the list before posting.\n\n## Binaries\n\n[Binary releases are no longer supported.](https://mhammond.github.io/pywin32_installers.html)\n\nBuild 306 was the last with .exe installers. You really shouldn't use them, but if you really need them,\n[find them here](https://github.com/mhammond/pywin32/releases/tag/b306)\n\n## Installing via PIP\n\nYou should install pywin32 via pip - eg,\n\n```shell\npython -m pip install --upgrade pywin32\n```\n\nThere is a post-install script (see below) which should *not* be run inside virtual environments;\nit should only be run in \"global\" installs.\n\nFor unreleased changes, you can download builds made by [github actions](https://github.com/mhammond/pywin32/actions/) -\nchoose any \"workflow\" from the `main` branch and download its \"artifacts\")\n\n### Installing globally\n\nOutside of a virtual environment you might want to install COM objects, services, etc. You can do\nthis by executing:\n\n```shell\npython Scripts/pywin32_postinstall.py -install\n```\n\nFrom the root of your Python installation.\n\nIf you do this with normal permissions it will be global for your user (a few files will be\ncopied to the root of your Python install and some changes made to HKCU). If you execute this from\nan elevated process, it will be global for the machine (files will be copied to System32, HKLM\nwill be changed, etc)\n\n### Running as a Windows Service\n\nTo run as a service, you probably want to install pywin32 globally from an elevated\ncommand prompt - see above.\n\nYou also need to ensure Python is installed in a location where the user running\nthe service has access to the installation and is able to load `pywintypesXX.dll` and `pythonXX.dll`.\nIn particular, the `LocalSystem` account typically will not have access to your local `%USER%` directory structure.\n\n## Troubleshooting\n\nIf you encounter any problems when upgrading like the following:\n\n```text\nThe specified procedure could not be found\nEntry-point not found\n```\n\nIt usually means one of 2 things:\n\n* You've upgraded an install where the post-install script has previously run.\nSo you should run it again:\n\n    ```shell\n    python Scripts/pywin32_postinstall.py -install\n    ```\n\n    This will make some small attempts to cleanup older conflicting installs.\n\n* There are other pywin32 DLLs installed in your system,\nbut in a different location than the new ones. This sometimes happens in environments that\ncome with pywin32 pre-shipped (eg, anaconda?).\n\n  The possible solutions here are:\n\n  * Run the \"post_install\" script documented above.\n  * Otherwise, find and remove all other copies of `pywintypesXX.dll` and `pythoncomXX.dll`\n  (where `XX` is the Python version - eg, \"39\")\n\n## Building from source\n\nInstall Visual Studio 2019 (later probably works, but options might be different),\nfollow the instructions in [Build environment](/build_env.md#build-environment)\nfor the version you install.\n\nThen follow the [Build](/build_env.md#build) instructions for the build itself (including ARM64 cross-compilation).\n\n## Release process\n\nThe following steps are performed when making a new release - this is mainly\nto form a checklist so @mhammond doesn't forget what to do :)\n\nSince build 307 the release process is based on the artifacts created by Github actions.\n\n* Ensure CHANGES.txt has everything worth noting. Update the header to reflect\n  the about-to-be released build and date, commit it.\n\n* Update setup.py with the new build number. Update CHANGES.txt to have a new heading\n  section for the next unreleased version. (ie, a new, empty \"Coming in build XXX, as yet unreleased\"\n  section)\n\n* Push these changes to github, wait for the actions to complete, then\n  download the artifacts from that run.\n\n* Upload `.whl` artifacts to pypi - we do this before pushing the tag because they might be\n  rejected for an invalid `README.md`. Done via `py -3.? -m twine upload dist/*XXX*.whl`.\n\n* Create a new git tag for the release.\n\n* Update setup.py with the new build number + \".1\" (eg, 123.1), to ensure\n  future test builds aren't mistaken for the real release.\n\n* Make sure everything is pushed to github, including the tag (ie,\n  `git push --tags`)\n\n* Send mail to python-win32\n\n### Older Manual Release Process\n\nThis is the old process used when a local dev environment was used to create\nthe builds. Build 306 was the last released with this process.\n\n* Ensure CHANGES.txt has everything worth noting. Update the header to reflect\n  the about-to-be released build and date, commit it.\n\n* Update setup.py with the new build number.\n\n* Execute `make_all.bat`, wait forever, test the artifacts.\n\n* Upload .whl artifacts to pypi - we do this before pushing the tag because they might be\n  rejected for an invalid `README.md`. Done via `py -3.? -m twine upload dist/*XXX*.whl`.\n\n* Commit setup.py (so the new build number is in the repo), create a new git tag\n\n* Upload the .exe installers to github.\n\n* Update setup.py with the new build number + \".1\" (eg, 123.1), to ensure\n  future test builds aren't mistaken for the real release.\n\n* Make sure everything is pushed to github, including the tag (ie,\n  `git push --tags`)\n\n* Send mail to python-win32\n"
        },
        {
          "name": "SWIG",
          "type": "tree",
          "content": null
        },
        {
          "name": "adodbapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "build_env.md",
          "type": "blob",
          "size": 6.1787109375,
          "content": "# Build environment\n\nThis describes how to setup the build environment for pywin32.\n\nDouble check the compiler version you need in the [Python wiki](https://wiki.python.org/moin/WindowsCompilers)\nbut note that Python 3.5 -> 3.13 all use version 14.X of the compiler, which,\nconfusingly, report themselves as V.19XX (eg, note in Python's banner,\n3.5's \"MSC v.1900\", even 3.9b4's \"MSC v.1924\")\n\nThis compiler first shipped with Visual Studio 2015, although Visual Studio\n2017, 2019 and 2022 all have this compiler available, just not installed\nby default.\n\nIn the Visual Studio Installer:\n\n## For Visual Studio 2017\n\nLocate the \"Desktop development with C++\" section:\n\nEnsure the following components are installed:\n\n- `VC++ 2015.3 v14.00 (v140) toolset for desktop`\n- `Windows 10 SDK and UCRT SDK`\n- `Visual C++ MFC for x86 and x64`\n\nif you want to cross-compile for ARM, you will need at least the following (from \"Individual Components\")\n\n- `Visual C++ compilers and libraries for ARM64`\n- `Visual C++ for MFC for ARM64`\n\n(You should be able to check everything you need is installed by opening a\ncommand prompt and executing:\n\n```shell\n\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x86_amd64 10.0.18362.0 -vcvars_ver=14.0\n```\n\nif that works, then executing:\n\n```shell\ncl\n```\n\nshould report the compiler version:\n> Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24234.1 for x64\n\n)\n\nNote however that it's *not* necessary to configure the environment in this\nway to build pywin32 - it's build process should find these tools automatically.\n\n## For Visual Studio 2019\n\n- Install the [Build Tools for Visual Studio 2019](https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16#) (`vs_BuildTools.exe` ~ 1 MB)\n\n- Maybe stop your virus scanner\n- In `Visual Studio Installer`:\n  - Select `Visual Studio Build Tools 2019`\n    - Press `Modify`\n      - In `Visual Studio Build Tools 2019`\n        - Check `C++ build tools`\n          - In the menu to the right, check:\n            - `MSVC v142 - VS 2019 C++ x64/x86 build tools`\n            - `Windows 10 SDK` (latest offered I guess? At time of writing, 10.0.18362)\n            - `C++ MFC for latest v142 build tools (x86 & x64)`\n            - `C++ ATL for latest v142 build tools`\n        - If building for ARM64 (optional), select the \"Individual Components\" tab, and search for and select:\n              - `MSVC v142 - VS 2019 C++ ARM64 build tools`\n              - `C++ MFC for latest v142 build tools (ARM64)`\n              - `C++ ATL for latest v142 build tools (ARM64)`\n        - Press `Install` (~ 4.6 GB shown in the overview, but ~ 1.1 GB shown during download; approximately double with the ARM64 components)\n- Restart your virus scanner\n- Restart\n\n## For Visual Studio 2022\n\n- Install the [Visual Studio 2022](https://visualstudio.microsoft.com/downloads/) (`VisualStudioSetup.exe` ~ 4.22 MB)\n\n- Maybe stop your virus scanner\n- In `Visual Studio Installer`:\n  - Select `Visual Studio Build Tools 2022`\n    - Press `Modify`\n      - In `Visual Studio Build Tools 2022`\n        - Check `Desktop development with C++`\n          - In the menu to the right, check:\n            - `MSVC v143 - VS 2022 C++ x64/x86 build tools`\n            - `Windows 10 SDK`\n            - `C++ MFC for latest v143 build tools (x86 & x64)`\n            - `C++ ATL for latest v143 build tools`\n        - If building for ARM64 (optional), select the \"Individual Components\" tab, and search for and select:\n              - `MSVC v143 - VS 2022 C++ ARM64/ARM64EC build tools (Latest)`\n              - `C++ MFC for latest v143 build tools (ARM64/ARM64EC)`\n              - `C++ ATL for latest v143 build tools (ARM64/ARM64EC)`\n        - Press `Install`\n- Restart your virus scanner\n- Restart\n\n### Microsoft Message Compiler\n\nSearch the executable\n\n```shell\ncd \"c:\\Program Files (x86)\\Windows Kits\"\ndir /b /s mc.exe\n```\n\nAppend location to the `path` (example)\n\n```shell\nset \"path=%path%;c:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.18362.0\\x64\"\n```\n\nTest with\n\n```shell\nwhere mc\n```\n\n(Note that the above process for 'mc' doesn't appear necessary for VS2017, but\n@mhammond hasn't tried with VS2019 - please share your experiences!)\n\n# Build\n\nOnce everything is setup, just execute the following from the pywin32 directory:\n\n```shell\npip install . -v\n```\n\nSome modules need obscure SDKs to build - `pip install` should succeed, gracefully\ntelling you why it failed to build them with the `-v` flag - if the build actually fails with your\nconfiguration, please [open an issue](https://github.com/mhammond/pywin32/issues).\n\n## Cross-compiling for ARM64 (Microsoft Visual C++ 14.1 and up)\n\n- Follow the `For Visual Studio XXXX` instructions above and pick the optional ARM64 build tools\n\n- Download prebuilt Python ARM64 binaries to a temporary location on your machine. You will need this location in a later step.\n\n    ```shell\n    python .github\\workflows\\download-arm64-libraries.py \"<temporary path>\"\n    ```\n\n  - This script downloads a Python ARM64 build [from NuGet](https://www.nuget.org/packages/pythonarm64/#versions-tab) that matches the version you used to run it.\n- Setup the cross-compilation environment:\n\n    ```shell\n    \"C:\\Program Files (x86)\\Microsoft Visual Studio\\XXXX\\BuildTools\\vc\\Auxiliary\\Build\\vcvarsall.bat\" x86_arm64\n    ```\n\n- Update `setuptools` and set the following environment variables to ensure it is used:\n\n    ```shell\n    set DISTUTILS_USE_SDK=1\n    ```\n\n- Build the extensions, passing the directory from earlier. You may optionally add the `bdist_wheel` command to generate a wheel.\n\n    ```shell\n    python -m build --wheel --config-setting=--build-option=build_ext --config-setting=--build-option=-L.\\arm64libs --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=bdist_wheel --config-setting=--build-option=--plat-name=win-arm64\n    ```\n\n  - If you are not using an initialized build environment, you will need to specify the `build_ext`, `build` and `bdist_wheel` commands and pass `--plat-name win-arm64` to *each* of them separately. Otherwise you may get a mixed platform build and/or linker errors.\n\n- Copy the built wheel to the target machine and install directly:\n\n    ```shell\n    pip install \"<path to wheel>\" -v\n    ```\n"
        },
        {
          "name": "com",
          "type": "tree",
          "content": null
        },
        {
          "name": "isapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "make_all.bat",
          "type": "blob",
          "size": 2.013671875,
          "content": "@if \"%1\"==\"quick\" goto quick\nif exist build\\. rd /s/q build\nif exist build\\. goto couldnt_rm\n:quick\npy autoduck\\make.py\n@if errorlevel 1 goto failed\n\nrem Check /build_env.md#build-environment to make sure you have all the required components installed\n\npy -3.8-32 -m build --wheel\npy -3.8 -m build --wheel\n\npy -3.9-32 -m build --wheel\npy -3.9 -m build --wheel\n\npy -3.10-32 -m build --wheel\npy -3.10 -m build --wheel\n\npy -3.11-32 -m build --wheel\npy -3.11 -m build --wheel\n\npy -3.12-32 -m build --wheel\npy -3.12 -m build --wheel\n\npy -3.13-32 -m build --wheel\npy -3.13 -m build --wheel\n\nrem Check /build_env.md#build-environment to make sure you have all the required ARM64 components installed\npy -3.10 -m build --wheel --config-setting=--build-option=build_ext --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=build --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=bdist_wheel --config-setting=--build-option=--plat-name=win-arm64\npy -3.11 -m build --wheel --config-setting=--build-option=build_ext --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=build --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=bdist_wheel --config-setting=--build-option=--plat-name=win-arm64\npy -3.12 -m build --wheel --config-setting=--build-option=build_ext --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=build --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=bdist_wheel --config-setting=--build-option=--plat-name=win-arm64\npy -3.13 -m build --wheel --config-setting=--build-option=build_ext --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=build --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=bdist_wheel --config-setting=--build-option=--plat-name=win-arm64\n\n@goto xit\n:couldnt_rm\n@echo Could not remove the build directory!\ngoto xit\n:failed\n@echo Oops - failed!\n@exit /b 1\n:xit\n"
        },
        {
          "name": "mypy.ini",
          "type": "blob",
          "size": 2.814453125,
          "content": "[mypy]\nshow_column_numbers = true\n; Target the oldest supported version in editors and default CLI\npython_version = 3.8\n\nstrict = true\nimplicit_reexport = true\n; Necessary to avoid \"same module name\" issues\nexplicit_package_bases = true\n; Must specify top-level packages and scripts folders for mypy to work with explicit_package_bases\nmypy_path =\n    $MYPY_CONFIG_FILE_DIR/com,\n    $MYPY_CONFIG_FILE_DIR/win32/Lib,\n    $MYPY_CONFIG_FILE_DIR/Pythonwin,\n    $MYPY_CONFIG_FILE_DIR/AutoDuck,\n    $MYPY_CONFIG_FILE_DIR/win32/scripts/VersionStamp,\n\n; TODO: Gradually type classes and functions until we can turn back check_untyped_defs to true.\n; For now this allows us to at least put mypy in place by massively reducing checked code\ncheck_untyped_defs = false\n; Implicit return types !\ndisallow_untyped_calls = false\ndisallow_untyped_defs = false\ndisallow_incomplete_defs = false\n\ndisable_error_code =\n    ; Module has no attribute; (Dynamic modules will be hard to type without first-party stubs, ie: pythoncom.*)\n    attr-defined,\n    ; Class cannot subclass \"...\" (has type \"Any\"); (IDEM)\n    ; TODO: Use typeshed's types-pywin32 stubs after a few more fixes there\n    misc,\n    ; These are the other error codes that would currently fail with check_untyped_defs = true\n    ; TODO: Gradually fix them until we can turn on check_untyped_defs\n    ; arg-type,\n    ; assignment,\n    ; call-arg,\n    ; comparison-overlap,\n    ; has-type,\n    ; index,\n    ; list-item,\n    ; operator,\n    ; override,\n    ; str-format,\n    ; type-var,\n    ; union-attr,\n    ; valid-type,\n    ; var-annotated,\n    ; ; And these only happen when checking against types-pywin32\n    ; func-returns-value,\n    ; call-overload,\n    ; no-redef,\nexclude = (?x)(\n          ^build/\n          ; Vendored\n          | ^Pythonwin/Scintilla/\n          ; Forked IDLE extensions predating Python 2.3. They now live in idlelib in https://github.com/python/cpython/tree/main/Lib/idlelib\n          | ^Pythonwin/pywin/idle/\n          ; TODO: Ignoring non-public APIs until all public API is typed\n          | ([Tt]est|[Dd]emos?)/\n          )\n\n; C-modules that will need type-stubs\n[mypy-adsi.*,dde,exchange,mapi,perfmon,servicemanager,win32api,win32console,win32clipboard,win32comext.adsi.adsi,win32event,win32evtlog,win32file,win32gui,win32help,win32pdh,win32process,win32ras,win32security,win32service,win32trace,win32ui,win32uiole,win32wnet,_win32sysloader,_winxptheme]\nignore_missing_imports = True\n\n; Most of win32com re-exports win32comext\n; Test is a local untyped module in win32comext.axdebug\n; pywin32_system32 is an empty module created in setup.py to store dlls\n[mypy-win32com.*,Test,pywin32_system32]\nignore_missing_imports = True\n\n; Distutils being removed from stdlib currently causes some issues on Python 3.12\n; https://github.com/mhammond/pywin32/issues/2119\n[mypy-distutils.*]\nignore_missing_imports = True\n"
        },
        {
          "name": "pycln.toml",
          "type": "blob",
          "size": 0.572265625,
          "content": "[tool.pycln]\nall = true\nskip_imports = [\n  # Modules with known side-effects\n  \"coloreditor\", # Adds doc template\n  \"IDLEenvironment\", # Injects fast_readline into the IDLE auto-indent extension\n  \"pythoncom\", # pythoncomXX.dll loader\n  \"pywintypes\", # pywintypesXX.dll loader\n  \"win32com\", # Sets pythoncom.frozen and adds modules to path based on the registry\n  \"win32traceutil\", # Redirects output to win32trace remote collector\n  \"win32ui\", # Must always be imported before dde\n]\n# Note: com/win32com/client/gencache.py does read files but only to fill in it's own dicts from cache\n"
        },
        {
          "name": "pyrightconfig.json",
          "type": "blob",
          "size": 2.3720703125,
          "content": "{\n  \"typeCheckingMode\": \"basic\",\n  // Target the oldest supported version in editors and default CLI\n  \"pythonVersion\": \"3.9\",\n  // Keep it simple for now by allowing both mypy and pyright to use `type: ignore`\n  \"enableTypeIgnoreComments\": true,\n  // Exclude from scanning when running pyright\n  \"exclude\": [\n    \".git/\",\n    \"build/\",\n    // Vendored\n    \"Pythonwin/Scintilla/\",\n    // Forked IDLE extensions predating Python 2.3. They now live in idlelib in https://github.com/python/cpython/tree/main/Lib/idlelib\n    \"Pythonwin/pywin/idle/\",\n    // Ignoring non-public apis for now\n    \"**/Test/\",\n    \"**/test/\",\n    \"**/Demos/\",\n    \"**/demo/\",\n  ],\n  // Packages that will be accessible globally.\n  // Setting this makes pyright use the repo's code for those modules instead of typeshed or pywin32 in site-packages\n  \"extraPaths\": [\n    \"com\",\n    \"win32/Lib\",\n    \"Pythonwin\",\n  ],\n  \"reportConstantRedefinition\": \"error\",\n  // TODO: For now this allows us to at least put pyright in place by massively reducing checked code\n  // it also reduces issues with the shipped types-pywin32 from typeshed\n  \"reportGeneralTypeIssues\": \"none\",\n  \"reportArgumentType\": \"none\",\n  \"reportAttributeAccessIssue\": \"none\",\n  // FIXE: These all need to be fixed first and turned back to error\n  // some of the fixes need to be done in types-pywin32 from typeshed\n  \"reportCallIssue\": \"warning\",\n  \"reportOperatorIssue\": \"warning\",\n  \"reportOptionalCall\": \"warning\",\n  \"reportOptionalIterable\": \"warning\",\n  \"reportOptionalMemberAccess\": \"warning\",\n  \"reportOptionalSubscript\": \"warning\",\n  // Needs fixes in types-pywin32 and requires Python 3.8 to annotate ambiguous global variables\n  \"reportUnnecessaryComparison\": \"warning\",\n  // Too many dynamically generated modules. This will require type stubs to properly fix.\n  \"reportMissingImports\": \"warning\",\n  // IDEM, but happens when pywin32 is not in site-packages but module is found from typeshed.\n  // TODO: Is intended to be fixed with an editable install\n  // Since we're a library, and not user code, we care less about forgetting to install a dependency,\n  // as long as we have its stubs. So just disabling for now is fine.\n  \"reportMissingModuleSource\": \"none\",\n  // External type stubs may not be completable, and this will require type stubs for dynamic modules.\n  \"reportMissingTypeStubs\": \"information\",\n  // Use Flake8/Pycln/Ruff instead\n  \"reportUnusedImport\": \"none\",\n}\n"
        },
        {
          "name": "pywin32.pth",
          "type": "blob",
          "size": 0.173828125,
          "content": "# .pth file for the PyWin32 extensions\nwin32\nwin32\\lib\nPythonwin\n# And some hackery to deal with environments where the post_install script\n# isn't run.\nimport pywin32_bootstrap\n"
        },
        {
          "name": "pywin32_postinstall.py",
          "type": "blob",
          "size": 24.44140625,
          "content": "# postinstall script for pywin32\n#\n# copies pywintypesXX.dll and pythoncomXX.dll into the system directory,\n# and creates a pth file\nimport argparse\nimport glob\nimport os\nimport shutil\nimport sys\nimport sysconfig\nimport tempfile\nimport winreg\n\ntee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\n\n\nclass Tee:\n    def __init__(self, file):\n        self.f = file\n\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)\n\n    def flush(self):\n        if self.f is not None:\n            try:\n                self.f.flush()\n            except OSError:\n                pass\n        tee_f.flush()\n\n\nsys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\n\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n\n# Verbosity of output messages.\nverbose = 1\n\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\n\n\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER\n\n\n# Create a function with the same signature as create_shortcut\n# previously provided by bdist_wininst\ndef create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,\n    )\n    ilink.SetPath(path)\n    ilink.SetDescription(description)\n    if arguments:\n        ilink.SetArguments(arguments)\n    if workdir:\n        ilink.SetWorkingDirectory(workdir)\n    if iconpath or iconindex:\n        ilink.SetIconLocation(iconpath, iconindex)\n    # now save it.\n    ipf = ilink.QueryInterface(pythoncom.IID_IPersistFile)\n    ipf.Save(filename, 0)\n\n\n# Support the same list of \"path names\" as bdist_wininst used to\ndef get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)\n            return shell.SHGetSpecialFolderPath(0, csidl, False)\n    raise ValueError(f\"{path_name} is an unknown path ID\")\n\n\ndef CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise\n            if silent:\n                # Running silent mode - just re-raise the error.\n                raise\n            full_desc = (\n                f\"Error {desc}\\n\\n\"\n                \"If you have any Python applications running, \"\n                f\"please close them now\\nand select 'Retry'\\n\\n{details.strerror}\"\n            )\n            rc = win32api.MessageBox(\n                0, full_desc, \"Installation Error\", win32con.MB_ABORTRETRYIGNORE\n            )\n            if rc == win32con.IDABORT:\n                raise\n            elif rc == win32con.IDIGNORE:\n                return\n            # else retry - around we go again.\n\n\n# We need to import win32api to determine the Windows system directory,\n# so we can copy our system files there - but importing win32api will\n# load the pywintypes.dll already in the system directory preventing us\n# from updating them!\n# So, we pull the same trick pywintypes.py does, but it loads from\n# our pywintypes_system32 directory.\ndef LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,\n    )\n    filename = os.path.join(lib_dir, \"pywin32_system32\", filename)\n    loader = importlib.machinery.ExtensionFileLoader(modname, filename)\n    spec = importlib.machinery.ModuleSpec(name=modname, loader=loader, origin=filename)\n    mod = importlib.util.module_from_spec(spec)\n    loader.exec_module(mod)\n\n\ndef SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:\n            my_key.Close()\n    finally:\n        root_key.Close()\n\n\ndef UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:\n            my_key.Close()\n        if delete_key:\n            winreg.DeleteKey(root_key, key_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}\")\n    except OSError as why:\n        winerror = getattr(why, \"winerror\", why.errno)\n        if winerror != 2:  # file not found\n            raise\n    finally:\n        root_key.Close()\n\n\ndef RegisterCOMObjects(register=True):\n    import win32com.server.register\n\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:\n        __import__(module)\n        mod = sys.modules[module]\n        flags[\"finalize_register\"] = getattr(mod, \"DllRegisterServer\", None)\n        flags[\"finalize_unregister\"] = getattr(mod, \"DllUnregisterServer\", None)\n        klass = getattr(mod, klass_name)\n        func(klass, **flags)\n\n\ndef RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)\n            return chm_file\n        else:\n            print(\"NOTE: PyWin32.chm can not be located, so has not been registered\")\n    else:\n        UnsetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, delete_key=True)\n    return None\n\n\ndef RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()\n    ## Installer executable doesn't seem to pass anything to postinstall script indicating if it's a debug build\n    pythonwin_exe = os.path.join(lib_dir, \"Pythonwin\", \"Pythonwin.exe\")\n    pythonwin_edit_command = pythonwin_exe + ' -edit \"%1\"'\n\n    keys_vals = [\n        (\n            \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App Paths\\\\Pythonwin.exe\",\n            \"\",\n            pythonwin_exe,\n        ),\n        (\n            \"Software\\\\Classes\\\\Python.File\\\\shell\\\\Edit with Pythonwin\",\n            \"command\",\n            pythonwin_edit_command,\n        ),\n        (\n            \"Software\\\\Classes\\\\Python.NoConFile\\\\shell\\\\Edit with Pythonwin\",\n            \"command\",\n            pythonwin_edit_command,\n        ),\n    ]\n\n    try:\n        if register:\n            for key, sub_key, val in keys_vals:\n                ## Since winreg only uses the character Api functions, this can fail if Python\n                ##  is installed to a path containing non-ascii characters\n                hkey = winreg.CreateKey(classes_root, key)\n                if sub_key:\n                    hkey = winreg.CreateKey(hkey, sub_key)\n                winreg.SetValueEx(hkey, None, 0, winreg.REG_SZ, val)\n                hkey.Close()\n        else:\n            for key, sub_key, val in keys_vals:\n                try:\n                    if sub_key:\n                        hkey = winreg.OpenKey(classes_root, key)\n                        winreg.DeleteKey(hkey, sub_key)\n                        hkey.Close()\n                    winreg.DeleteKey(classes_root, key)\n                except OSError as why:\n                    winerror = getattr(why, \"winerror\", why.errno)\n                    if winerror != 2:  # file not found\n                        raise\n    finally:\n        # tell windows about the change\n        from win32com.shell import shell, shellcon\n\n        shell.SHChangeNotify(\n            shellcon.SHCNE_ASSOCCHANGED, shellcon.SHCNF_IDLIST, None, None\n        )\n\n\ndef get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n\n    try:\n        install_group = winreg.QueryValue(\n            get_root_hkey(), root_key_name + \"\\\\InstallPath\\\\InstallGroup\"\n        )\n    except OSError:\n        install_group = \"Python %d.%d\" % (\n            sys.version_info.major,\n            sys.version_info.minor,\n        )\n    return os.path.join(fldr, install_group)\n\n\n# Get the system directory, which may be the Wow64 directory if we are a 32bit\n# python on a 64bit OS.\ndef get_system_dir():\n    import win32api  # we assume this exists.\n\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)\n        except (pythoncom.com_error, win32process.error):\n            return win32api.GetSystemDirectory()\n    except ImportError:\n        return win32api.GetSystemDirectory()\n\n\ndef fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):\n        this_dest = this_pyd + \".old\"\n        if os.path.isfile(this_pyd) and os.path.isfile(py_name):\n            try:\n                if os.path.isfile(this_dest):\n                    print(\n                        f\"Old dbi '{this_dest}' already exists - deleting '{this_pyd}'\"\n                    )\n                    os.remove(this_pyd)\n                else:\n                    os.rename(this_pyd, this_dest)\n                    print(f\"renamed '{this_pyd}'->'{this_pyd}.old'\")\n            except OSError as exc:\n                print(f\"FAILED to rename '{this_pyd}': {exc}\")\n\n\ndef install(lib_dir):\n    import traceback\n\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():\n        sys.path.append(os.path.join(lib_dir, name))\n    # It is possible people with old versions installed with still have\n    # pywintypes and pythoncom registered.  We no longer need this, and stale\n    # entries hurt us.\n    for name in \"pythoncom pywintypes\".split():\n        keyname = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver + \"\\\\Modules\\\\\" + name\n        for root in winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER:\n            try:\n                winreg.DeleteKey(root, keyname + \"\\\\Debug\")\n            except OSError:\n                pass\n            try:\n                winreg.DeleteKey(root, keyname)\n            except OSError:\n                pass\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    import win32api\n\n    # and now we can get the system directory:\n    files = glob.glob(os.path.join(lib_dir, \"pywin32_system32\\\\*.*\"))\n    if not files:\n        raise RuntimeError(\"No system files to copy!!\")\n    # Try the system32 directory first - if that fails due to \"access denied\",\n    # it implies a non-admin user, and we use sys.prefix\n    for dest_dir in [get_system_dir(), sys.prefix]:\n        # and copy some files over there\n        worked = 0\n        try:\n            for fname in files:\n                base = os.path.basename(fname)\n                dst = os.path.join(dest_dir, base)\n                CopyTo(\"installing %s\" % base, fname, dst)\n                if verbose:\n                    print(f\"Copied {base} to {dst}\")\n                worked = 1\n                # Nuke any other versions that may exist - having\n                # duplicates causes major headaches.\n                bad_dest_dirs = [\n                    os.path.join(sys.prefix, \"Library\\\\bin\"),\n                    os.path.join(sys.prefix, \"Lib\\\\site-packages\\\\win32\"),\n                ]\n                if dest_dir != sys.prefix:\n                    bad_dest_dirs.append(sys.prefix)\n                for bad_dest_dir in bad_dest_dirs:\n                    bad_fname = os.path.join(bad_dest_dir, base)\n                    if os.path.exists(bad_fname):\n                        # let exceptions go here - delete must succeed\n                        os.unlink(bad_fname)\n            if worked:\n                break\n        except win32api.error as details:\n            if details.winerror == 5:\n                # access denied - user not admin - try sys.prefix dir,\n                # but first check that a version doesn't already exist\n                # in that place - otherwise that one will still get used!\n                if os.path.exists(dst):\n                    msg = (\n                        \"The file '%s' exists, but can not be replaced \"\n                        \"due to insufficient permissions.  You must \"\n                        \"reinstall this software as an Administrator\" % dst\n                    )\n                    print(msg)\n                    raise RuntimeError(msg)\n                continue\n            raise\n    else:\n        raise RuntimeError(\n            \"You don't have enough permissions to install the system files\"\n        )\n\n    # Register our demo COM objects.\n    try:\n        try:\n            RegisterCOMObjects()\n        except win32api.error as details:\n            if details.winerror != 5:  # ERROR_ACCESS_DENIED\n                raise\n            print(\"You do not have the permissions to install COM objects.\")\n            print(\"The sample COM objects were not registered.\")\n    except Exception:\n        print(\"FAILED to register the Python COM objects\")\n        traceback.print_exc()\n\n    # There may be no main Python key in HKCU if, eg, an admin installed\n    # python itself.\n    winreg.CreateKey(get_root_hkey(), root_key_name)\n\n    chm_file = None\n    try:\n        chm_file = RegisterHelpFile(True, lib_dir)\n    except Exception:\n        print(\"Failed to register help file\")\n        traceback.print_exc()\n    else:\n        if verbose:\n            print(\"Registered help file\")\n\n    # misc other fixups.\n    fixup_dbi()\n\n    # Register Pythonwin in context menu\n    try:\n        RegisterPythonwin(True, lib_dir)\n    except Exception:\n        print(\"Failed to register pythonwin as editor\")\n        traceback.print_exc()\n    else:\n        if verbose:\n            print(\"Pythonwin has been registered in context menu\")\n\n    # Create the win32com\\gen_py directory.\n    make_dir = os.path.join(lib_dir, \"win32com\", \"gen_py\")\n    if not os.path.isdir(make_dir):\n        if verbose:\n            print(f\"Creating directory {make_dir}\")\n        os.mkdir(make_dir)\n\n    try:\n        # create shortcuts\n        # CSIDL_COMMON_PROGRAMS only available works on NT/2000/XP, and\n        # will fail there if the user has no admin rights.\n        fldr = get_shortcuts_folder()\n        # If the group doesn't exist, then we don't make shortcuts - its\n        # possible that this isn't a \"normal\" install.\n        if os.path.isdir(fldr):\n            dst = os.path.join(fldr, \"PythonWin.lnk\")\n            create_shortcut(\n                os.path.join(lib_dir, \"Pythonwin\\\\Pythonwin.exe\"),\n                \"The Pythonwin IDE\",\n                dst,\n                \"\",\n                sys.prefix,\n            )\n            if verbose:\n                print(\"Shortcut for Pythonwin created\")\n            # And the docs.\n            if chm_file:\n                dst = os.path.join(fldr, \"Python for Windows Documentation.lnk\")\n                doc = \"Documentation for the PyWin32 extensions\"\n                create_shortcut(chm_file, doc, dst)\n                if verbose:\n                    print(\"Shortcut to documentation created\")\n        else:\n            if verbose:\n                print(f\"Can't install shortcuts - {fldr!r} is not a folder\")\n    except Exception as details:\n        print(details)\n\n    # importing win32com.client ensures the gen_py dir created - not strictly\n    # necessary to do now, but this makes the installation \"complete\"\n    try:\n        import win32com.client  # noqa\n    except ImportError:\n        # Don't let this error sound fatal\n        pass\n    print(\"The pywin32 extensions were successfully installed.\")\n\n\ndef uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n\n    try:\n        RegisterHelpFile(False, lib_dir)\n    except Exception as why:\n        print(f\"Failed to unregister help file: {why}\")\n    else:\n        if verbose:\n            print(\"Unregistered help file\")\n\n    try:\n        RegisterPythonwin(False, lib_dir)\n    except Exception as why:\n        print(f\"Failed to unregister Pythonwin: {why}\")\n    else:\n        if verbose:\n            print(\"Unregistered Pythonwin\")\n\n    try:\n        # remove gen_py directory.\n        gen_dir = os.path.join(lib_dir, \"win32com\", \"gen_py\")\n        if os.path.isdir(gen_dir):\n            shutil.rmtree(gen_dir)\n            if verbose:\n                print(f\"Removed directory {gen_dir}\")\n\n        # Remove pythonwin compiled \"config\" files.\n        pywin_dir = os.path.join(lib_dir, \"Pythonwin\", \"pywin\")\n        for fname in glob.glob(os.path.join(pywin_dir, \"*.cfc\")):\n            os.remove(fname)\n\n        # The dbi.pyd.old files we may have created.\n        try:\n            os.remove(os.path.join(lib_dir, \"win32\", \"dbi.pyd.old\"))\n        except OSError:\n            pass\n        try:\n            os.remove(os.path.join(lib_dir, \"win32\", \"dbi_d.pyd.old\"))\n        except OSError:\n            pass\n\n    except Exception as why:\n        print(f\"Failed to remove misc files: {why}\")\n\n    try:\n        fldr = get_shortcuts_folder()\n        for link in (\"PythonWin.lnk\", \"Python for Windows Documentation.lnk\"):\n            fqlink = os.path.join(fldr, link)\n            if os.path.isfile(fqlink):\n                os.remove(fqlink)\n                if verbose:\n                    print(f\"Removed {link}\")\n    except Exception as why:\n        print(f\"Failed to remove shortcuts: {why}\")\n    # Now remove the system32 files.\n    files = glob.glob(os.path.join(lib_dir, \"pywin32_system32\\\\*.*\"))\n    # Try the system32 directory first - if that fails due to \"access denied\",\n    # it implies a non-admin user, and we use sys.prefix\n    try:\n        for dest_dir in [get_system_dir(), sys.prefix]:\n            # and copy some files over there\n            worked = 0\n            for fname in files:\n                base = os.path.basename(fname)\n                dst = os.path.join(dest_dir, base)\n                if os.path.isfile(dst):\n                    try:\n                        os.remove(dst)\n                        worked = 1\n                        if verbose:\n                            print(\"Removed file %s\" % (dst))\n                    except Exception:\n                        print(f\"FAILED to remove {dst}\")\n            if worked:\n                break\n    except Exception as why:\n        print(f\"FAILED to remove system files: {why}\")\n\n\n# NOTE: This used to be run from inside the bdist_wininst created binary un/installer.\n# From inside the binary installer this script HAD to NOT\n# call sys.exit() or raise SystemExit, otherwise the installer would also terminate!\n# Out of principle, we're still not using system exits.\n\n\ndef verify_destination(location):\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(f'Path \"{location}\" does not exist!')\n    return location\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n\n    * Typical usage:\n\n    > python pywin32_postinstall.py -install\n\n    This should be run automatically after installation,\n    but if it fails you can run it again.\n\n    Given EXE installers are no longer provided,\n    and wheel installs can't run postinstall scripts,\n    you almost certainly need to run this to\n    setup the environment correctly.\n\n    Execute this script with a '-install' parameter, to ensure the environment\n    is setup correctly.\n    \"\"\",\n    )\n    parser.add_argument(\n        \"-install\",\n        default=False,\n        action=\"store_true\",\n        help=\"Configure the Python environment correctly for pywin32.\",\n    )\n    parser.add_argument(\n        \"-remove\",\n        default=False,\n        action=\"store_true\",\n        help=\"Try and remove everything that was installed or copied.\",\n    )\n    parser.add_argument(\n        \"-wait\",\n        type=int,\n        help=\"Wait for the specified process to terminate before starting.\",\n    )\n    parser.add_argument(\n        \"-silent\",\n        default=False,\n        action=\"store_true\",\n        help='Don\\'t display the \"Abort/Retry/Ignore\" dialog for files in use.',\n    )\n    parser.add_argument(\n        \"-quiet\",\n        default=False,\n        action=\"store_true\",\n        help=\"Don't display progress messages.\",\n    )\n    parser.add_argument(\n        \"-destination\",\n        default=sysconfig.get_paths()[\"platlib\"],\n        type=verify_destination,\n        help=\"Location of the PyWin32 installation\",\n    )\n\n    args = parser.parse_args()\n\n    if not args.quiet:\n        print(f\"Parsed arguments are: {args}\")\n\n    if not args.install ^ args.remove:\n        parser.error(\"You need to either choose to -install or -remove!\")\n\n    if args.wait is not None:\n        try:\n            os.waitpid(args.wait, 0)\n        except OSError:\n            # child already dead\n            pass\n\n    silent = args.silent\n    verbose = not args.quiet\n\n    if args.install:\n        install(args.destination)\n\n    if args.remove:\n        uninstall(args.destination)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "pywin32_testall.py",
          "type": "blob",
          "size": 3.6318359375,
          "content": "\"\"\"A test runner for pywin32\"\"\"\n\nimport os\nimport site\nimport subprocess\nimport sys\n\n# locate the dirs based on where this script is - it may be either in the\n# source tree, or in an installed Python 'Scripts' tree.\nthis_dir = os.path.dirname(__file__)\nsite_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\n\nfailures = []\n\n\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:\n        failures.append(script)\n\n\ndef find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\n\n\ndef main():\n    import argparse\n\n    code_directories = [this_dir] + site_packages\n\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",\n        help=\"(This is now the default - use `-user-interaction` to include them)\",\n    )\n\n    parser.add_argument(\n        \"-user-interaction\",\n        action=\"store_true\",\n        help=\"Include tests which require user interaction\",\n    )\n\n    parser.add_argument(\n        \"-skip-adodbapi\",\n        default=False,\n        action=\"store_true\",\n        help=\"Skip the adodbapi tests; useful for CI where there's no provider\",\n    )\n\n    args, remains = parser.parse_known_args()\n\n    # win32, win32ui / Pythonwin\n\n    extras = []\n    if args.user_interaction:\n        extras.append(\"-user-interaction\")\n    extras.extend(remains)\n    scripts = [\n        \"win32/test/testall.py\",\n        \"Pythonwin/pywin/test/all.py\",\n    ]\n    for script in scripts:\n        maybes = [os.path.join(directory, script) for directory in code_directories]\n        find_and_run(maybes, extras)\n\n    # win32com\n    maybes = [\n        os.path.join(directory, \"win32com\", \"test\", \"testall.py\")\n        for directory in [\n            os.path.join(this_dir, \"com\"),\n        ]\n        + site_packages\n    ]\n    extras = remains + [\"1\"]  # only run \"level 1\" tests in CI\n    find_and_run(maybes, extras)\n\n    # adodbapi\n    if not args.skip_adodbapi:\n        maybes = [\n            os.path.join(directory, \"adodbapi\", \"test\", \"adodbapitest.py\")\n            for directory in code_directories\n        ]\n        find_and_run(maybes, remains)\n        # This script has a hard-coded sql server name in it, (and markh typically\n        # doesn't have a different server to test on) but there is now supposed to be a server out there on the Internet\n        # just to run these tests, so try it...\n        maybes = [\n            os.path.join(directory, \"adodbapi\", \"test\", \"test_adodbapi_dbapi20.py\")\n            for directory in code_directories\n        ]\n        find_and_run(maybes, remains)\n\n    if failures:\n        print(\"The following scripts failed\")\n        for failure in failures:\n            print(\">\", failure)\n        sys.exit(1)\n    print(\"All tests passed \\\\o/\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "ruff.toml",
          "type": "blob",
          "size": 2.259765625,
          "content": "target-version = \"py38\" # Target the oldest supported version in editors and default CLI\n# This file is not UTF-8\nextend-exclude = [\"Pythonwin/pywin/test/_dbgscript.py\"]\n\n[format]\nline-ending = \"cr-lf\"\n\n[lint]\nselect = [\n  \"C4\", # flake8-comprehensions\n  \"F811\", # redefined-while-unused\n  \"I\", # isort\n  \"PLC\", # Pylint Convention\n  \"PLE\", # Pylint Error\n  \"RSE\", # flake8-raise\n  \"W\", # pycodestyle Warning\n  \"YTT\", # flake8-2020\n\n  # String formatting, concatenating, interpolation, ...\n  \"FLY\", # static-join-to-f-string\n  \"G\", # flake8-logging-format\n  # Note, we still want to allow multiline ISC\n  \"UP025\", # Remove unicode literals from strings\n  \"UP030\", # Use implicit references for positional format fields\n  # TODO: Still lots of manual fixes needed\n  # \"UP031\", # Use format specifiers instead of percent format\n  # \"UP032\", # Use f-string instead of format call\n\n  # Ensure modern type annotation syntax and best practices\n  # Not including those covered by type-checkers\n  \"FA\", # flake8-future-annotations\n  \"F404\", # late-future-import\n  \"PYI\", # flake8-pyi\n  \"UP006\", # non-pep585-annotation\n  \"UP007\", # non-pep604-annotation\n  \"UP010\", # unnecessary-future-import\n  \"UP037\", # quoted-annotation\n\n  # Helps prevent circular imports and other unneeded imports\n  \"TC\", # flake8-type-checking\n]\n\nextend-ignore = [\n  # TODO: Consider passing exception around to ensure methods are only ever used within exception handlers\n  \"PLE0704\", # misplaced-bare-raise\n\n  # No such concerns for stdlib\n  \"TC003\", # typing-only-standard-library-import\n]\n\n[lint.per-file-ignores]\n# Explicit re-exports is fine in __init__.py, still a code smell elsewhere.\n\"__init__.py\" = [\"PLC0414\"]\n# TODO: Make adodbapi changes in their own PRs\n\"adodbapi/*\" = [\"C4\", \"YTT301\", \"UP031\", \"UP032\"]\n\n[lint.isort]\ncombine-as-imports = true\n# Because pywin32 has a mix of relative and absolute imports, with undetectable first-party c-extensions\n# This makes import grouping more consistent\ndetect-same-package = false\nknown-third-party = [\n  \"__main__\",\n  # This forces distutils imports to always be after setuptools\n  # setuptools must be imported before distutils because it monkey-patches it.\n  # distutils is also removed in Python 3.12 and deprecated with setuptools\n  \"distutils\",\n]\nextra-standard-library = [\"setuptools\"]\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 89.0439453125,
          "content": "from __future__ import annotations\n\nbuild_id = \"308.1\"  # may optionally include a \".{patchno}\" suffix.\n\n__doc__ = \"\"\"This is a distutils setup-script for the pywin32 extensions.\n\nThe canonical source of truth for supported versions and build environments\nis [the GitHub CI](https://github.com/mhammond/pywin32/tree/main/.github/workflows).\n\nTo build and install locally for testing etc, you need a build environment\nwhich is capable of building the version of Python you are targeting, then:\n  pip install . -v\n\nFor a debug (_d) version, you need a local debug build of Python, but must use\nthe release version executable for the build. eg:\n  pip install . -v --config-setting=--build-option=build --config-setting=--build-option=--debug\n\nCross-compilation from x86 to ARM is well supported (assuming installed vs tools etc) - eg:\n  python -m build --wheel --config-setting=--build-option=build_ext --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=build --config-setting=--build-option=--plat-name=win-arm64 --config-setting=--build-option=bdist_wheel --config-setting=--build-option=--plat-name=win-arm64\n\nSome modules require special SDKs or toolkits to build (eg, mapi/exchange),\nwhich often aren't available in CI. The build process treats them as optional -\ninstead of a failing, it will report what was skipped, and why. See also\nbuild_env.md, which is getting out of date but might help getting everything\nrequired for an official build - see README.md for that process.\n\"\"\"\n# Originally by Thomas Heller, started in 2000 or so.\nimport glob\nimport logging\nimport os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport winreg\nfrom pathlib import Path\nfrom setuptools import Extension, setup\nfrom setuptools.command.build import build\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.install import install\nfrom setuptools.modified import newer_group\nfrom tempfile import gettempdir\nfrom typing import Iterable\n\nfrom distutils import ccompiler\nfrom distutils._msvccompiler import MSVCCompiler\nfrom distutils.command.install_data import install_data\n\nbuild_id_patch = build_id\nif not \".\" in build_id_patch:\n    build_id_patch += \".0\"\npywin32_version = \"%d.%d.%s\" % (\n    sys.version_info.major,\n    sys.version_info.minor,\n    build_id_patch,\n)\nprint(\"Building pywin32\", pywin32_version)\n\ntry:\n    this_file = __file__\nexcept NameError:\n    this_file = sys.argv[0]\n\nthis_file = os.path.abspath(this_file)\n# We get upset if the cwd is not our source dir, but it is a PITA to\n# insist people manually CD there first!\nif os.path.dirname(this_file):\n    os.chdir(os.path.dirname(this_file))\n\n# Start address we assign base addresses from.  See comment re\n# dll_base_address later in this file...\ndll_base_address = 0x1E200000\n\n\nclass WinExt(Extension):\n    # Base class for all win32 extensions, with some predefined\n    # library and include dirs, and predefined windows libraries.\n    # Additionally a method to parse .def files into lists of exported\n    # symbols, and to read\n    def __init__(\n        self,\n        name,\n        sources,\n        include_dirs=[],\n        define_macros=None,\n        undef_macros=None,\n        library_dirs=[],\n        libraries=\"\",\n        runtime_library_dirs=None,\n        extra_objects=None,\n        extra_compile_args=None,\n        extra_link_args=None,\n        export_symbols=None,\n        export_symbol_file=None,\n        pch_header=None,\n        extra_swig_commands=None,\n        is_regular_dll=False,  # regular Windows DLL?\n        # list of headers which may not be installed forcing us to\n        # skip this extension\n        optional_headers=[],\n        base_address=None,\n        depends=None,\n        platforms=None,  # none means 'all platforms'\n        implib_name=None,\n        delay_load_libraries=\"\",\n    ):\n        include_dirs = [\"com/win32com/src/include\", \"win32/src\"] + include_dirs\n        libraries = libraries.split()\n        self.delay_load_libraries = delay_load_libraries.split()\n        libraries.extend(self.delay_load_libraries)\n\n        extra_link_args = extra_link_args or []\n        if export_symbol_file:\n            extra_link_args.append(\"/DEF:\" + export_symbol_file)\n\n        # Some of our swigged files behave differently in distutils vs\n        # MSVC based builds.  Always define DISTUTILS_BUILD so they can tell.\n        define_macros = define_macros or []\n        define_macros.extend(\n            (\n                (\"DISTUTILS_BUILD\", None),\n                (\"_CRT_SECURE_NO_WARNINGS\", None),\n                # CRYPT_DECRYPT_MESSAGE_PARA.dwflags is in an ifdef for some unknown reason\n                # See github PR #1444 for more details...\n                (\"CRYPT_DECRYPT_MESSAGE_PARA_HAS_EXTRA_FIELDS\", None),\n                # Minimum Windows version supported (Vista)\n                # https://learn.microsoft.com/en-us/cpp/porting/modifying-winver-and-win32-winnt\n                (\"_WIN32_WINNT\", hex(0x0600)),\n                (\"WINVER\", hex(0x0600)),\n            )\n        )\n        self.pch_header = pch_header\n        self.extra_swig_commands = extra_swig_commands or []\n        self.optional_headers = optional_headers\n        self.is_regular_dll = is_regular_dll\n        self.base_address = base_address\n        self.platforms = platforms\n        self.implib_name = implib_name\n        Extension.__init__(\n            self,\n            name,\n            sources,\n            include_dirs,\n            define_macros,\n            undef_macros,\n            library_dirs,\n            libraries,\n            runtime_library_dirs,\n            extra_objects,\n            extra_compile_args,\n            extra_link_args,\n            export_symbols,\n        )\n        self.depends = depends or []  # stash it here, as py22 doesn't have it.\n\n    def finalize_options(self, build_ext):\n        # distutils doesn't define this function for an Extension - it is\n        # our own invention, and called just before the extension is built.\n        if not build_ext.mingw32:\n            if self.pch_header:\n                self.extra_compile_args = self.extra_compile_args or []\n\n            # bugger - add this to python!\n            if build_ext.plat_name == \"win32\":\n                self.extra_link_args.append(\"/MACHINE:x86\")\n            else:\n                self.extra_link_args.append(\"/MACHINE:%s\" % build_ext.plat_name[4:])\n\n            # like Python, always use debug info, even in release builds\n            # (note the compiler doesn't include debug info, so you only get\n            # basic info - but it's better than nothing!)\n            # For now use the temp dir - later we may package them, so should\n            # maybe move them next to the output file.\n            pch_dir = os.path.join(build_ext.build_temp)\n            if not build_ext.debug:\n                self.extra_compile_args.append(\"/Zi\")\n            self.extra_compile_args.append(f\"/Fd{pch_dir}\\\\{self.name}_vc.pdb\")\n            self.extra_link_args.append(\"/DEBUG\")\n            self.extra_link_args.append(f\"/PDB:{pch_dir}\\\\{self.name}.pdb\")\n            # enable unwind semantics - some stuff needs it and I can't see\n            # it hurting\n            self.extra_compile_args.append(\"/EHsc\")\n\n            # silence: warning C4163: '__cpuidex' : not available as an intrinsic function\n            self.extra_compile_args.append(\"/wd4163\")\n\n            if self.delay_load_libraries:\n                self.libraries.append(\"delayimp\")\n                for delay_lib in self.delay_load_libraries:\n                    self.extra_link_args.append(\"/delayload:%s.dll\" % delay_lib)\n\n            # If someone needs a specially named implib created, handle that\n            if self.implib_name:\n                implib = os.path.join(build_ext.build_temp, self.implib_name)\n                suffix = \"_d\" if build_ext.debug else \"\"\n                self.extra_link_args.append(f\"/IMPLIB:{implib}{suffix}.lib\")\n            # Try and find the MFC headers, so we can reach inside for\n            # some of the ActiveX support we need.  We need to do this late, so\n            # the environment is setup correctly.\n            # Only used by the win32uiole extensions, but I can't be\n            # bothered making a subclass just for this - so they all get it!\n            found_mfc = False\n            for incl in os.environ.get(\"INCLUDE\", \"\").split(os.pathsep):\n                # first is a \"standard\" MSVC install, second is the Vista SDK.\n                for candidate in (r\"..\\src\\occimpl.h\", r\"..\\..\\src\\mfc\\occimpl.h\"):\n                    check = os.path.join(incl, candidate)\n                    if os.path.isfile(check):\n                        self.extra_compile_args.append(\n                            '/DMFC_OCC_IMPL_H=\\\\\"%s\\\\\"' % candidate\n                        )\n                        found_mfc = True\n                        break\n                if found_mfc:\n                    break\n\n        self.extra_compile_args.append(\"-DUNICODE\")\n        self.extra_compile_args.append(\"-D_UNICODE\")\n        self.extra_compile_args.append(\"-DWINNT\")\n\n\nclass WinExt_pythonwin(WinExt):\n    def __init__(self, name, **kw):\n        kw.setdefault(\"extra_compile_args\", []).extend([\"-D_AFXDLL\", \"-D_AFXEXT\"])\n\n        WinExt.__init__(self, name, **kw)\n\n    def get_pywin32_dir(self):\n        return \"pythonwin\"\n\n\nclass WinExt_pythonwin_subsys_win(WinExt_pythonwin):\n    def finalize_options(self, build_ext):\n        WinExt_pythonwin.finalize_options(self, build_ext)\n\n        if build_ext.mingw32:\n            self.extra_link_args.append(\"-mwindows\")\n        else:\n            self.extra_link_args.append(\"/SUBSYSTEM:WINDOWS\")\n\n            # Unicode, Windows executables seem to need this magic:\n            self.extra_link_args.append(\"/ENTRY:wWinMainCRTStartup\")\n\n\nclass WinExt_win32(WinExt):\n    def __init__(self, name, **kw):\n        WinExt.__init__(self, name, **kw)\n\n    def get_pywin32_dir(self):\n        return \"win32\"\n\n\nclass WinExt_ISAPI(WinExt):\n    def get_pywin32_dir(self):\n        return \"isapi\"\n\n\n# Note this is used only for \"win32com extensions\", not pythoncom\n# itself - thus, output is \"win32comext\"\nclass WinExt_win32com(WinExt):\n    def __init__(self, name, **kw):\n        kw[\"libraries\"] = kw.get(\"libraries\", \"\") + \" oleaut32 ole32\"\n        WinExt.__init__(self, name, **kw)\n\n    def get_pywin32_dir(self):\n        return \"win32comext/\" + self.name\n\n\n# Exchange extensions get special treatment:\n# * Look for the Exchange SDK in the registry.\n# * Output directory is different than the module's basename.\n# * Require use of the Exchange 2000 SDK - this works for both VC6 and 7\n# NOTE: sadly the old Exchange SDK does *not* include MAPI files - these used\n# to be bundled with the Windows SDKs and/or Visual Studio, but no longer are.\nclass WinExt_win32com_mapi(WinExt_win32com):\n    def __init__(self, name, **kw):\n        # The Exchange 2000 SDK seems to install itself without updating\n        # LIB or INCLUDE environment variables.  It does register the core\n        # directory in the registry tho - look it up\n        sdk_install_dir = None\n        libs = kw.get(\"libraries\", \"\")\n        keyname = r\"SOFTWARE\\Microsoft\\Exchange\\SDK\"\n        flags = winreg.KEY_READ\n        try:\n            flags |= winreg.KEY_WOW64_32KEY\n        except AttributeError:\n            pass  # this version doesn't support 64 bits, so must already be using 32bit key.\n        for root in winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER:\n            try:\n                keyob = winreg.OpenKey(root, keyname, 0, flags)\n                value, type_id = winreg.QueryValueEx(keyob, \"INSTALLDIR\")\n                if type_id == winreg.REG_SZ:\n                    sdk_install_dir = value\n                    break\n            except OSError:\n                pass\n        if sdk_install_dir is not None:\n            d = os.path.join(sdk_install_dir, \"SDK\", \"Include\")\n            if os.path.isdir(d):\n                kw.setdefault(\"include_dirs\", []).insert(0, d)\n            d = os.path.join(sdk_install_dir, \"SDK\", \"Lib\")\n            if os.path.isdir(d):\n                kw.setdefault(\"library_dirs\", []).insert(0, d)\n\n        # The stand-alone exchange SDK has these libs\n        # Additional utility functions are only available for 32-bit builds.\n        if not platform.machine() in (\"AMD64\", \"ARM64\"):\n            libs += \" version user32 advapi32 Ex2KSdk sadapi netapi32\"\n        kw[\"libraries\"] = libs\n        WinExt_win32com.__init__(self, name, **kw)\n\n    def get_pywin32_dir(self):\n        # 'win32com.mapi.exchange' is currently the only\n        # one with this special requirement\n        return \"win32comext/mapi\"\n\n\n# A hacky extension class for pywintypesXX.dll and pythoncomXX.dll\nclass WinExt_system32(WinExt):\n    def get_pywin32_dir(self):\n        return \"pywin32_system32\"\n\n\nclass WinExt_pythonservice(WinExt):\n    # special handling because it's a \"console\" exe.\n    def finalize_options(self, build_ext):\n        WinExt.finalize_options(self, build_ext)\n\n        if build_ext.mingw32:\n            self.extra_link_args.append(\"-mconsole\")\n            self.extra_link_args.append(\"-municode\")\n        else:\n            self.extra_link_args.append(\"/SUBSYSTEM:CONSOLE\")\n\n    # pythonservice.exe goes in win32, where it doesn't actually work, but\n    # win32serviceutil manages to copy it to where it does.\n    def get_pywin32_dir(self):\n        return \"win32\"\n\n\n################################################################\n# Extensions to the distutils commands.\n\n\n# 'build' command\nclass my_build(build):\n    def run(self):\n        build.run(self)\n        # write a pywin32.version.txt.\n        ver_fname = os.path.join(gettempdir(), \"pywin32.version.txt\")\n        try:\n            f = open(ver_fname, \"w\")\n            f.write(\"%s\\n\" % build_id)\n            f.close()\n        except OSError as why:\n            print(f\"Failed to open '{ver_fname}': {why}\")\n\n\nclass my_build_ext(build_ext):\n    def finalize_options(self):\n        build_ext.finalize_options(self)\n\n        self.plat_dir = {\n            \"win-amd64\": \"x64\",\n            \"win-arm64\": \"arm64\",\n        }.get(self.plat_name, \"x86\")\n\n        # The pywintypes library is created in the build_temp\n        # directory, so we need to add this to library_dirs\n        self.library_dirs.append(self.build_temp)\n        self.mingw32 = self.compiler == \"mingw32\"\n        if self.mingw32:\n            self.libraries.append(\"stdc++\")\n\n        self.excluded_extensions = []  # list of (ext, why)\n        self.swig_cpp = True  # hrm - deprecated - should use swig_opts=-c++??\n\n    def _why_cant_build_extension(self, ext):\n        \"\"\"Return None, or a reason it can't be built.\"\"\"\n        # axdebug fails to build on 3.11 due to Python \"frame\" objects changing.\n        # This could be fixed, but is almost certainly not in use any more, so\n        # just skip it.\n        if ext.name == \"axdebug\" and sys.version_info >= (3, 11):\n            return \"AXDebug no longer builds on 3.11 and up\"\n\n        include_dirs = self.compiler.include_dirs + os.environ.get(\"INCLUDE\", \"\").split(\n            os.pathsep\n        )\n\n        look_dirs = include_dirs\n        for h in ext.optional_headers:\n            for d in look_dirs:\n                if os.path.isfile(os.path.join(d, h)):\n                    break\n            else:\n                logging.debug(\"Header '%s' not found  in %s\", h, look_dirs)\n                return f\"The header '{h}' can not be located.\"\n\n        common_dirs = self.compiler.library_dirs[:]\n        common_dirs += os.environ.get(\"LIB\", \"\").split(os.pathsep)\n        patched_libs = []\n        for lib in ext.libraries:\n            if lib.lower() in self.found_libraries:\n                found = self.found_libraries[lib.lower()]\n            else:\n                look_dirs = common_dirs + ext.library_dirs\n                found = self.compiler.find_library_file(look_dirs, lib, self.debug)\n                if not found:\n                    logging.debug(\"Lib '%s' not found in %s\", lib, look_dirs)\n                    return \"No library '%s'\" % lib\n                self.found_libraries[lib.lower()] = found\n            patched_libs.append(os.path.splitext(os.path.basename(found))[0])\n\n        if ext.platforms and self.plat_name not in ext.platforms:\n            return f\"Only available on platforms {ext.platforms}\"\n\n        # We update the .libraries list with the resolved library name.\n        # This is really only so \"_d\" works.\n        ext.libraries = patched_libs\n        return None  # no reason - it can be built!\n\n    def _build_scintilla(self):\n        path = \"pythonwin\\\\Scintilla\"\n        makefile = \"makefile_pythonwin\"\n        makeargs = []\n\n        if self.debug:\n            makeargs.append(\"DEBUG=1\")\n        if not self.verbose:\n            makeargs.append(\"/C\")  # nmake: /C Suppress output messages\n            makeargs.append(\"QUIET=1\")\n        # We build the DLL into our own temp directory, then copy it to the\n        # real directory - this avoids the generated .lib/.exp\n        build_temp = os.path.abspath(os.path.join(self.build_temp, \"scintilla\"))\n        self.mkpath(build_temp)\n        # Use short-names, as the scintilla makefiles barf with spaces.\n        if \" \" in build_temp:\n            # ack - can't use win32api!!!  This is the best I could come up\n            # with:\n            # C:\\>for %I in (\"C:\\Program Files\",) do @echo %~sI\n            # C:\\PROGRA~1\n            cs = os.environ.get(\"comspec\", \"cmd.exe\")\n            cmd = cs + ' /c for %I in (\"' + build_temp + '\",) do @echo %~sI'\n            build_temp = os.popen(cmd).read().strip()\n            assert os.path.isdir(build_temp), build_temp\n        makeargs.append(\"SUB_DIR_O=%s\" % build_temp)\n        makeargs.append(\"SUB_DIR_BIN=%s\" % build_temp)\n\n        nmake = \"nmake.exe\"\n        # Attempt to resolve nmake to the same one that our compiler object\n        # would use. compiler.spawn() ought to do this, but it does not search\n        # its own PATH value for the initial command. It does, however, set it\n        # correctly for any subsequent commands.\n        try:\n            for p in self.compiler._paths.split(os.pathsep):\n                if os.path.isfile(os.path.join(p, nmake)):\n                    nmake = os.path.join(p, nmake)\n                    break\n        except (AttributeError, TypeError):\n            pass\n\n        cwd = os.getcwd()\n        old_env = os.environ.copy()\n        os.environ[\"INCLUDE\"] = os.pathsep.join(self.compiler.include_dirs)\n        os.environ[\"LIB\"] = os.pathsep.join(self.compiler.library_dirs)\n        os.chdir(path)\n        try:\n            cmd = [nmake, \"/nologo\", \"/f\", makefile] + makeargs\n            self.compiler.spawn(cmd)\n        finally:\n            os.chdir(cwd)\n            os.environ[\"INCLUDE\"] = old_env.get(\"INCLUDE\", \"\")\n            os.environ[\"LIB\"] = old_env.get(\"LIB\", \"\")\n\n        # The DLL goes in the Pythonwin directory.\n        if self.debug:\n            base_name = \"scintilla_d.dll\"\n        else:\n            base_name = \"scintilla.dll\"\n        self.copy_file(\n            os.path.join(self.build_temp, \"scintilla\", base_name),\n            os.path.join(self.build_lib, \"pythonwin\"),\n        )\n\n    # find the VC base path corresponding to distutils paths, and\n    # potentially upgrade for extra include / lib paths (MFC)\n    def _check_vc(self):\n        vcbase = vcverdir = None\n        atlmfc_found = False\n        for _dir in self.compiler.library_dirs:\n            m = re.search(r\"(?i)VC\\\\([\\d.]+\\\\)?(LIB)\\b\", _dir)\n            if m and not vcbase:\n                vcbase = _dir[: m.start(2)]\n                vcverdir = m.group(1)\n            m = re.search(r\"(?i)ATLMFC\\\\LIB\\b\", _dir)\n            if m:\n                atlmfc_found = True  # ATLMFC libs/includes already found by distutils\n\n        if not vcbase and not self.mingw32:\n            print(\"-- compiler.library_dirs:\", self.compiler.library_dirs)\n            # Error or warn? last hope would be a non-standard build environment\n            print(\"-- Visual C base path not found !?\")\n\n        # The afxres.h/atls.lib files aren't always included by default,\n        # so find and add them\n        if vcbase and not atlmfc_found:\n            atls_lib = glob.glob(vcbase + rf\"ATLMFC\\lib\\{self.plat_dir}\\atls.lib\")\n            if atls_lib:\n                self.library_dirs.append(os.path.dirname(atls_lib[0]))\n                self.include_dirs.append(\n                    os.path.join(\n                        os.path.dirname(os.path.dirname(os.path.dirname(atls_lib[0]))),\n                        \"Include\",\n                    )\n                )\n            else:\n                print(\"-- compiler.library_dirs:\", self.compiler.library_dirs)\n                print(\"-- ATLMFC paths likely missing (Required for win32ui)\")\n        return vcbase, vcverdir\n\n    def build_extensions(self):\n        # First, sanity-check the 'extensions' list\n        self.check_extensions_list(self.extensions)\n\n        self.found_libraries = {}\n\n        if hasattr(self.compiler, \"initialize\") and not self.compiler.initialized:\n            self.compiler.initialize()\n\n        # XXX this distutils class var peek hack should become obsolete\n        # (silently) when https://github.com/pypa/distutils/pull/172 is\n        # resolved.\n        # _why_cant_build_extension() and _build_scintilla() at least need\n        # complete VC+SDK inspectable inc / lib dirs.\n        classincs = getattr(self.compiler.__class__, \"include_dirs\", [])\n        if classincs:\n            print(\"-- distutils hack to expose all include & lib dirs\")\n            print(\"-- orig compiler.include_dirs:\", self.compiler.include_dirs)\n            print(\"-- orig compiler.library_dirs:\", self.compiler.library_dirs)\n            self.compiler.include_dirs += classincs\n            self.compiler.__class__.include_dirs = []\n            classlibs = getattr(self.compiler.__class__, \"library_dirs\", [])\n            self.compiler.library_dirs += classlibs\n            self.compiler.__class__.library_dirs = []\n        else:\n            print(\"-- FIX ME ! distutils may expose complete inc/lib dirs again\")\n\n        vcbase, vcverdir = self._check_vc()\n\n        # Here we hack a \"pywin32\" directory (one of 'win32', 'win32com',\n        # 'pythonwin' etc), as distutils doesn't seem to like the concept\n        # of multiple top-level directories.\n        assert self.package is None\n        for ext in self.extensions:\n            try:\n                self.package = ext.get_pywin32_dir()\n            except AttributeError:\n                raise RuntimeError(\"Not a win32 package!\")\n            self.build_extension(ext)\n\n        for ext in W32_exe_files:\n            self.package = ext.get_pywin32_dir()\n            ext.finalize_options(self)\n            why = self._why_cant_build_extension(ext)\n            if why is not None:\n                self.excluded_extensions.append((ext, why))\n                assert why, \"please give a reason, or None\"\n                print(f\"Skipping {ext.name}: {why}\")\n                continue\n            self.build_exefile(ext)\n\n        # Error when too many skips\n        if len(self.excluded_extensions) > 0.3 * (\n            len(self.extensions) + len(W32_exe_files)\n        ):\n            print(\"-- compiler.include_dirs:\", self.compiler.include_dirs)\n            print(\"-- compiler.library_dirs:\", self.compiler.library_dirs)\n            raise RuntimeError(\"Too many extensions skipped, check build environment\")\n\n        # Not sure how to make this completely generic, and there is no\n        # need at this stage.\n        self._build_scintilla()\n        # Copy cpp lib files needed to create Python COM extensions\n        clib_files = (\n            [\"win32\", \"pywintypes%s.lib\"],\n            [\"win32com\", \"pythoncom%s.lib\"],\n            [\"win32com\", \"axscript%s.lib\"],\n        )\n        for clib_file in clib_files:\n            target_dir = os.path.join(self.build_lib, clib_file[0], \"libs\")\n            if not os.path.exists(target_dir):\n                self.mkpath(target_dir)\n            suffix = \"_d\" if self.debug else \"\"\n            fname = clib_file[1] % suffix\n            self.copy_file(os.path.join(self.build_temp, fname), target_dir)\n\n        # Finally find and copy the MFC redistributable DLLs.\n        win32ui_ext = pythonwin_extensions[0]\n        if win32ui_ext not in set(self.extensions) - {\n            ext for ext, why in self.excluded_extensions\n        }:\n            return\n        if not vcbase:\n            raise RuntimeError(\"Can't find MFC redist DLLs with unkown VC base path\")\n        redist_globs = [vcbase + r\"redist\\%s\\*MFC\\mfc140u.dll\" % self.plat_dir]\n        m = re.search(r\"\\\\VC\\\\Tools\\\\\", vcbase)\n        if m:\n            # typical path on newer Visual Studios\n            # prefere corresponding version but accept different version\n            same_version = vcverdir is not None and os.path.isdir(\n                vcbase[: m.start()]\n                + r\"\\VC\\Redist\\MSVC\\{}{}\".format(vcverdir, self.plat_dir)\n            )\n            redist_globs.append(\n                vcbase[: m.start()]\n                + r\"\\VC\\Redist\\MSVC\\{}{}\\*\\mfc140u.dll\".format(\n                    vcverdir if same_version else \"*\\\\\", self.plat_dir\n                )\n            )\n        # Only mfcNNNu DLL is required (mfcmNNNX is Windows Forms, rest is ANSI)\n        mfc_contents = next(filter(None, map(glob.glob, redist_globs)), [])[:1]\n        if not mfc_contents:\n            raise RuntimeError(\"MFC redist DLLs not found like %r!\" % redist_globs)\n\n        target_dir = os.path.join(self.build_lib, win32ui_ext.get_pywin32_dir())\n        for mfc_content in mfc_contents:\n            self.copy_file(mfc_content, target_dir)\n\n    def build_exefile(self, ext):\n        suffix = \"_d\" if self.debug else \"\"\n        logging.info(\"building exe '%s'\", ext.name)\n        leaf_name = f\"{ext.get_pywin32_dir()}\\\\{ext.name}{suffix}.exe\"\n        full_name = os.path.join(self.build_lib, leaf_name)\n\n        sources = list(ext.sources)\n        depends = sources + ext.depends\n        # unclear why we need to check this!?\n        if not (self.force or newer_group(depends, full_name, \"newer\")):\n            logging.debug(\"skipping '%s' executable (up-to-date)\", ext.name)\n            return\n        else:\n            logging.info(\"building '%s' executable\", ext.name)\n\n        objects = self.compiler.compile(\n            sources,\n            output_dir=os.path.join(self.build_temp, ext.name),\n            include_dirs=ext.include_dirs,\n            debug=self.debug,\n            extra_postargs=ext.extra_compile_args,\n            depends=ext.depends,\n        )\n\n        self.compiler.link(\n            \"executable\",\n            objects,\n            full_name,\n            libraries=self.get_libraries(ext),\n            library_dirs=ext.library_dirs,\n            runtime_library_dirs=ext.runtime_library_dirs,\n            extra_postargs=ext.extra_link_args,\n            debug=self.debug,\n            build_temp=self.build_temp,\n        )\n\n    def build_extension(self, ext):\n        # Some of these extensions are difficult to build, requiring various\n        # hard-to-track libraries et (eg, exchange sdk, etc).  So we\n        # check the extension list for the extra libraries explicitly\n        # listed.  We then search for this library the same way the C\n        # compiler would - if we can't find a library, we exclude the\n        # extension from the build.\n        # Note we can't do this in advance, as some of the .lib files\n        # we depend on may be built as part of the process - thus we can\n        # only check an extension's lib files as we are building it.\n        why = self._why_cant_build_extension(ext)\n        if why is not None:\n            assert why, \"please give a reason, or None\"\n            self.excluded_extensions.append((ext, why))\n            print(f\"Skipping {ext.name}: {why}\")\n            return\n        self.current_extension = ext\n\n        ext.finalize_options(self)\n\n        # ensure the SWIG .i files are treated as dependencies.\n        for source in ext.sources:\n            if source.endswith(\".i\"):\n                self.find_swig()  # for the side-effect of the environment value.\n                # Find the swig_lib .i files we care about for dependency tracking.\n                ext.swig_deps = glob.glob(\n                    os.path.join(os.environ[\"SWIG_LIB\"], \"python\", \"*.i\")\n                )\n                ext.depends.extend(ext.swig_deps)\n                break\n        else:\n            ext.swig_deps = None\n\n        # some source files are compiled for different extensions\n        # with special defines. So we cannot use a shared\n        # directory for objects, we must use a special one for each extension.\n        old_build_temp = self.build_temp\n\n        try:\n            build_ext.build_extension(self, ext)\n            # Convincing distutils to create .lib files with the name we\n            # need is difficult, so we just hack around it by copying from\n            # the created name to the name we need.\n            extra = \"_d.lib\" if self.debug else \".lib\"\n            if ext.name in (\"pywintypes\", \"pythoncom\"):\n                # The import libraries are created as PyWinTypes23.lib, but\n                # are expected to be pywintypes.lib.\n                created = \"%s%d%d%s\" % (\n                    ext.name,\n                    sys.version_info.major,\n                    sys.version_info.minor,\n                    extra,\n                )\n                needed = f\"{ext.name}{extra}\"\n            elif ext.name in (\"win32ui\",):\n                # This one just needs a copy.\n                created = needed = ext.name + extra\n            else:\n                created = needed = None\n            if created is not None:\n                # To keep us on our toes, MSVCCompiler constructs the .lib files\n                # in the same directory as the first source file's object file:\n                #    os.path.dirname(objects[0])\n                # rather than in the self.build_temp directory\n                src = os.path.join(\n                    old_build_temp, os.path.dirname(ext.sources[0]), created\n                )\n                dst = os.path.join(old_build_temp, needed)\n                if os.path.abspath(src) != os.path.abspath(dst):\n                    self.copy_file(src, dst)\n        finally:\n            self.build_temp = old_build_temp\n\n    def get_ext_filename(self, name):\n        # We need to fixup some target filenames.\n        suffix = \"_d\" if self.debug else \"\"\n        if name in [\"pywintypes\", \"pythoncom\"]:\n            ver = f\"{sys.version_info.major}{sys.version_info.minor}\"\n            return f\"{name}{ver}{suffix}.dll\"\n        if name in [\"perfmondata\", \"PyISAPI_loader\"]:\n            return f\"{name}{suffix}.dll\"\n        # everything else a .pyd - calling base-class might give us a more\n        # complicated name, so return a simple one.\n        return f\"{name}{suffix}.pyd\"\n\n    def get_export_symbols(self, ext):\n        if ext.is_regular_dll:\n            return ext.export_symbols\n        return build_ext.get_export_symbols(self, ext)\n\n    def find_swig(self):\n        if \"SWIG\" in os.environ:\n            swig = os.environ[\"SWIG\"]\n        else:\n            # We know where our swig is\n            swig = os.path.abspath(\"swig\\\\swig.exe\")\n        lib = os.path.join(os.path.dirname(swig), \"swig_lib\")\n        os.environ[\"SWIG_LIB\"] = lib\n        return swig\n\n    def swig_sources(self, sources, ext=None):\n        new_sources = []\n        swig_sources = []\n        swig_targets = {}\n        # XXX this drops generated C/C++ files into the source tree, which\n        # is fine for developers who want to distribute the generated\n        # source -- but there should be an option to put SWIG output in\n        # the temp dir.\n        # Adding py3k to the mix means we *really* need to move to generating\n        # to the temp dir...\n        target_ext = \".cpp\"\n        for source in sources:\n            (base, sext) = os.path.splitext(source)\n            if sext == \".i\":  # SWIG interface file\n                if os.path.split(base)[1] in swig_include_files:\n                    continue\n                swig_sources.append(source)\n                # Patch up the filenames for various special cases...\n                if os.path.basename(base) in swig_interface_parents:\n                    swig_targets[source] = base + target_ext\n                else:\n                    new_target = f\"{base}_swig{target_ext}\"\n                    new_sources.append(new_target)\n                    swig_targets[source] = new_target\n            else:\n                new_sources.append(source)\n\n        if not swig_sources:\n            return new_sources\n\n        swig = self.find_swig()\n        for source in swig_sources:\n            swig_cmd = [\n                swig,\n                \"-python\",\n                \"-c++\",\n                # we never use the .doc files.\n                \"-dnone\",\n            ]\n            swig_cmd.extend(self.current_extension.extra_swig_commands)\n            if platform.machine() in (\"AMD64\", \"ARM64\"):\n                swig_cmd.append(\"-DSWIG_PY64BIT\")\n            else:\n                swig_cmd.append(\"-DSWIG_PY32BIT\")\n            target = swig_targets[source]\n            interface_parent = swig_interface_parents.get(\n                os.path.basename(os.path.splitext(source)[0]),\n                None,  # \"normal\" swig file - no special win32 issues.\n            )\n            # Using win32 extensions to SWIG for generating COM classes.\n            if interface_parent is not None:\n                # generating a class, not a module.\n                swig_cmd.append(\"-pythoncom\")\n                if interface_parent:\n                    # A class deriving from other than the default\n                    swig_cmd.extend([\"-com_interface_parent\", interface_parent])\n\n            # This 'newer' check helps Python 2.2 builds, which otherwise\n            # *always* regenerate the .cpp files, meaning every future\n            # build for any platform sees these as dirty.\n            # This could probably go once we generate .cpp into the temp dir.\n            fqsource = os.path.abspath(source)\n            fqtarget = os.path.abspath(target)\n            rebuild = self.force or (\n                ext and newer_group(ext.swig_deps + [fqsource], fqtarget)\n            )\n\n            # can remove once edklib is no longer used for 32-bit builds\n            if source == \"com/win32comext/mapi/src/exchange.i\":\n                rebuild = True\n\n            logging.debug(\"should swig %s->%s=%s\", source, target, rebuild)\n            if rebuild:\n                swig_cmd.extend([\"-o\", fqtarget, fqsource])\n                logging.info(\"swigging %s to %s\", source, target)\n                out_dir = os.path.dirname(source)\n                cwd = os.getcwd()\n                os.chdir(out_dir)\n                try:\n                    self.spawn(swig_cmd)\n                finally:\n                    os.chdir(cwd)\n            else:\n                logging.info(\"skipping swig of %s\", source)\n\n        return new_sources\n\n\nclass my_install(install):\n    def run(self):\n        \"\"\"Custom script we run at the end of installing\n        This is only run for local installs. Wheel-based installs won't run this code.\n        \"\"\"\n        install.run(self)\n        # If self.root has a value, it means we are being \"installed\" into some other\n        # directory than Python itself - in which case we must *not* run our installer.\n        # bdist_wininst used to trigger this by using a temp directory.\n        # Is this still a concern ?\n        if self.root:\n            print(\n                \"Not executing post install script when \"\n                + f\"not installing in Python itself (self.root={self.root})\"\n            )\n            return\n        self.execute(self._postinstall, (), msg=\"Executing post install script...\")\n\n    def _postinstall(self):\n        filename = os.path.join(self.install_scripts, \"pywin32_postinstall.py\")\n        if not os.path.isfile(filename):\n            raise RuntimeError(f\"Can't find '{filename}'\")\n        # As of setuptools>=74.0.0, we no longer need to\n        # be concerned about distutils calling win32api\n        subprocess.Popen(\n            [\n                sys.executable,\n                filename,\n                \"-install\",\n                \"-destination\",\n                self.install_lib,\n                \"-quiet\",\n                \"-wait\",\n                str(os.getpid()),\n            ]\n        )\n\n\ndef my_new_compiler(**kw):\n    if \"compiler\" in kw and kw[\"compiler\"] in (None, \"msvc\"):\n        return my_compiler()\n    return orig_new_compiler(**kw)\n\n\n# No way to cleanly wedge our compiler sub-class in.\norig_new_compiler = ccompiler.new_compiler\nccompiler.new_compiler = my_new_compiler  # type: ignore[assignment] # Assuming the caller will always use only kwargs\n\n\nclass my_compiler(MSVCCompiler):\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        *args,\n        **kw,\n    ):\n        super().link(\n            target_desc,\n            objects,\n            output_filename,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            *args,\n            **kw,\n        )\n        # Here seems a good place to stamp the version of the built\n        # target.  Do this externally to avoid suddenly dragging in the\n        # modules needed by this process, and which we will soon try and\n        # update.\n        args = [\n            sys.executable,\n            # NOTE: On Python 3.7, all args must be str\n            str(Path(__file__).parent / \"win32\" / \"Lib\" / \"win32verstamp.py\"),\n            f\"--version={pywin32_version}\",\n            \"--comments=https://github.com/mhammond/pywin32\",\n            f\"--original-filename={os.path.basename(output_filename)}\",\n            \"--product=PyWin32\",\n            \"--quiet\" if \"-v\" not in sys.argv else \"\",\n            output_filename,\n        ]\n        self.spawn(args)\n\n    # Work around bpo-36302/bpo-42009 - it sorts sources but this breaks\n    # support for building .mc files etc :(\n    def compile(self, sources, **kwargs):\n        # re-sort the list of source files but ensure all .mc files come first.\n        def key_reverse_mc(a):\n            b, e = os.path.splitext(a)\n            e = \"\" if e == \".mc\" else e\n            return (e, b)\n\n        sources = sorted(sources, key=key_reverse_mc)\n        return MSVCCompiler.compile(self, sources, **kwargs)\n\n    def spawn(self, cmd):\n        is_link = cmd[0].endswith(\"link.exe\") or cmd[0].endswith('\"link.exe\"')\n        is_mt = cmd[0].endswith(\"mt.exe\") or cmd[0].endswith('\"mt.exe\"')\n        if is_mt:\n            # We don't want mt.exe run...\n            return\n        if is_link:\n            # remove /MANIFESTFILE:... and add MANIFEST:NO\n            for i in range(len(cmd)):\n                if cmd[i].startswith((\"/MANIFESTFILE:\", \"/MANIFEST:EMBED\")):\n                    cmd[i] = \"/MANIFEST:NO\"\n                    break\n        if is_mt:\n            # We want mt.exe run with the original manifest\n            for i in range(len(cmd)):\n                if cmd[i] == \"-manifest\":\n                    cmd[i + 1] += \".orig\"\n                    break\n        super().spawn(cmd)\n        if is_link:\n            # We want a copy of the original manifest so we can use it later.\n            for i in range(len(cmd)):\n                if cmd[i].startswith(\"/MANIFESTFILE:\"):\n                    mfname = cmd[i][14:]\n                    shutil.copyfile(mfname, mfname + \".orig\")\n                    break\n\n    # CCompiler's implementations of these methods completely replace the values\n    # determined by the build environment. This seems like a design that must\n    # always have been broken, but we work around it here.\n    def set_include_dirs(self, dirs):\n        self.include_dirs[:0] = dirs\n\n    def set_library_dirs(self, dirs):\n        self.library_dirs[:0] = dirs\n\n    def set_libraries(self, libs):\n        self.libraries.extend(libs)\n\n\n################################################################\n\n\nclass my_install_data(install_data):\n    \"\"\"A custom install_data command, which will install it's files\n    into the standard directories (normally lib/site-packages).\n    \"\"\"\n\n    def finalize_options(self):\n        if self.install_dir is None:\n            installobj = self.distribution.get_command_obj(\"install\")\n            self.install_dir = installobj.install_lib\n        print(\"Installing data files to %s\" % self.install_dir)\n        install_data.finalize_options(self)\n\n\n################################################################\n\npywintypes = WinExt_system32(\n    \"pywintypes\",\n    sources=[\n        \"win32/src/PyACL.cpp\",\n        \"win32/src/PyDEVMODE.cpp\",\n        \"win32/src/PyHANDLE.cpp\",\n        \"win32/src/PyIID.cpp\",\n        \"win32/src/PyLARGE_INTEGER.cpp\",\n        \"win32/src/PyOVERLAPPED.cpp\",\n        \"win32/src/PySECURITY_ATTRIBUTES.cpp\",\n        \"win32/src/PySECURITY_DESCRIPTOR.cpp\",\n        \"win32/src/PySID.cpp\",\n        \"win32/src/PyTime.cpp\",\n        \"win32/src/PyUnicode.cpp\",\n        \"win32/src/PyWAVEFORMATEX.cpp\",\n        \"win32/src/PyWinTypesmodule.cpp\",\n    ],\n    depends=[\n        \"win32/src/PyWinObjects.h\",\n        \"win32/src/PyWinTypes.h\",\n        \"win32/src/PySoundObjects.h\",\n        \"win32/src/PySecurityObjects.h\",\n    ],\n    extra_compile_args=[\"-DBUILD_PYWINTYPES\"],\n    libraries=\"advapi32 user32 ole32 oleaut32\",\n    pch_header=\"PyWinTypes.h\",\n)\n\nwin32_extensions: list[WinExt] = [pywintypes]\n\nwin32_extensions.append(\n    WinExt_win32(\n        \"perfmondata\",\n        sources=[\n            \"win32/src/PerfMon/PyPerfMsgs.mc\",\n            \"win32/src/PerfMon/perfmondata.cpp\",\n        ],\n        libraries=\"advapi32\",\n        export_symbol_file=\"win32/src/PerfMon/perfmondata.def\",\n        is_regular_dll=1,\n        depends=[\n            \"win32/src/PerfMon/perfutil.h\",\n            \"win32/src/PerfMon/PyPerfMonControl.h\",\n        ],\n    ),\n)\n\nfor name, libraries, sources in (\n    (\"mmapfile\", \"\", \"win32/src/mmapfilemodule.cpp\"),\n    (\"odbc\", \"odbc32 odbccp32\", \"win32/src/odbc.cpp\"),\n    (\n        \"perfmon\",\n        \"\",\n        \"\"\"\n        win32/src/PerfMon/MappingManager.cpp\n        win32/src/PerfMon/PerfCounterDefn.cpp\n        win32/src/PerfMon/PerfObjectType.cpp\n        win32/src/PerfMon/PyPerfMon.cpp\n        \"\"\",\n    ),\n    (\"timer\", \"user32\", \"win32/src/timermodule.cpp\"),\n    (\"win32cred\", \"AdvAPI32 credui\", \"win32/src/win32credmodule.cpp\"),\n    (\n        \"win32crypt\",\n        \"Crypt32 Advapi32\",\n        \"\"\"\n        win32/src/win32crypt/win32cryptmodule.cpp\n        win32/src/win32crypt/win32crypt_structs.cpp\n        win32/src/win32crypt/PyCERTSTORE.cpp\n        win32/src/win32crypt/PyCERT_CONTEXT.cpp\n        win32/src/win32crypt/PyCRYPTHASH.cpp\n        win32/src/win32crypt/PyCRYPTKEY.cpp\n        win32/src/win32crypt/PyCRYPTMSG.cpp\n        win32/src/win32crypt/PyCRYPTPROV.cpp\n        win32/src/win32crypt/PyCTL_CONTEXT.cpp\n        \"\"\",\n    ),\n    (\n        \"win32file\",\n        \"ws2_32 mswsock\",\n        \"\"\"\n        win32/src/win32file.i\n        win32/src/win32file_comm.cpp\n        \"\"\",\n    ),\n    (\"win32event\", \"user32\", \"win32/src/win32event.i\"),\n    (\n        \"win32clipboard\",\n        \"gdi32 user32 shell32\",\n        \"win32/src/win32clipboardmodule.cpp\",\n    ),\n    # win32gui handled below\n    (\"win32job\", \"user32\", \"win32/src/win32job.i\"),\n    (\"win32lz\", \"lz32\", \"win32/src/win32lzmodule.cpp\"),\n    (\n        \"win32net\",\n        \"netapi32 advapi32\",\n        \"\"\"\n        win32/src/win32net/win32netfile.cpp\n        win32/src/win32net/win32netgroup.cpp\n        win32/src/win32net/win32netmisc.cpp\n        win32/src/win32net/win32netmodule.cpp\n        win32/src/win32net/win32netsession.cpp\n        win32/src/win32net/win32netuse.cpp\n        win32/src/win32net/win32netuser.cpp\n        \"\"\",\n    ),\n    (\"win32pdh\", \"\", \"win32/src/win32pdhmodule.cpp\"),\n    (\"win32pipe\", \"\", \"win32/src/win32pipe.i\"),\n    (\n        \"win32print\",\n        \"winspool user32 gdi32\",\n        \"win32/src/win32print/win32print.cpp\",\n    ),\n    (\"win32process\", \"advapi32 user32\", \"win32/src/win32process.i\"),\n    (\"win32profile\", \"Userenv\", \"win32/src/win32profilemodule.cpp\"),\n    (\"win32ras\", \"rasapi32 user32\", \"win32/src/win32rasmodule.cpp\"),\n    (\n        \"win32security\",\n        \"advapi32 user32 netapi32\",\n        \"\"\"\n        win32/src/win32security.i\n        win32/src/win32security_sspi.cpp\n        win32/src/win32security_ds.cpp\n        \"\"\",\n    ),\n    (\n        \"win32service\",\n        \"advapi32 oleaut32 user32\",\n        \"\"\"\n        win32/src/win32service_messages.mc\n        win32/src/win32service.i\n        \"\"\",\n    ),\n    (\"win32trace\", \"advapi32\", \"win32/src/win32trace.cpp\"),\n    (\n        \"win32wnet\",\n        \"netapi32 mpr\",\n        \"\"\"\n        win32/src/win32wnet/PyNCB.cpp\n        win32/src/win32wnet/PyNetresource.cpp\n        win32/src/win32wnet/win32wnet.cpp\n        \"\"\",\n    ),\n    (\n        \"win32inet\",\n        \"wininet\",\n        \"\"\"\n        win32/src/win32inet.i\n        win32/src/win32inet_winhttp.cpp\n        \"\"\",\n    ),\n    (\"win32console\", \"kernel32\", \"win32/src/win32consolemodule.cpp\"),\n    (\"win32ts\", \"WtsApi32\", \"win32/src/win32tsmodule.cpp\"),\n    (\"_win32sysloader\", \"\", \"win32/src/_win32sysloader.cpp\"),\n    (\"win32transaction\", \"kernel32\", \"win32/src/win32transactionmodule.cpp\"),\n):\n    ext = WinExt_win32(\n        name,\n        libraries=libraries,\n        extra_compile_args=[],\n        sources=sources.split(),\n    )\n    win32_extensions.append(ext)\n\n# The few that need slightly special treatment\nwin32_extensions += [\n    WinExt_win32(\n        \"win32evtlog\",\n        sources=\"\"\"\n                win32\\\\src\\\\win32evtlog_messages.mc win32\\\\src\\\\win32evtlog.i\n                \"\"\".split(),\n        libraries=\"advapi32 oleaut32\",\n        delay_load_libraries=\"wevtapi\",\n    ),\n    WinExt_win32(\n        \"win32api\",\n        sources=\"\"\"\n                win32/src/win32apimodule.cpp win32/src/win32api_display.cpp\n                \"\"\".split(),\n        libraries=\"user32 advapi32 shell32 version\",\n        delay_load_libraries=\"powrprof\",\n    ),\n    WinExt_win32(\n        \"win32gui\",\n        sources=\"\"\"\n                win32/src/win32dynamicdialog.cpp\n                win32/src/win32gui.i\n               \"\"\".split(),\n        libraries=\"gdi32 user32 comdlg32 comctl32 shell32\",\n        define_macros=[(\"WIN32GUI\", None)],\n    ),\n    # winxptheme\n    WinExt_win32(\n        \"_winxptheme\",\n        sources=[\"win32/src/_winxptheme.i\"],\n        libraries=\"gdi32 user32 comdlg32 comctl32 shell32 Uxtheme\",\n    ),\n]\nwin32_extensions += [\n    WinExt_win32(\n        \"servicemanager\",\n        sources=[\"win32/src/PythonServiceMessages.mc\", \"win32/src/PythonService.cpp\"],\n        extra_compile_args=[\"-DPYSERVICE_BUILD_DLL\"],\n        libraries=\"user32 ole32 advapi32 shell32\",\n    ),\n]\n\nwin32_extensions += [\n    WinExt_win32(\n        \"win32help\",\n        sources=[\"win32/src/win32helpmodule.cpp\"],\n        libraries=\"htmlhelp user32 advapi32\",\n    ),\n]\n\ndirs = {\n    \"adsi\": \"com/win32comext/adsi/src\",\n    \"propsys\": \"com/win32comext/propsys/src\",\n    \"shell\": \"com/win32comext/shell/src\",\n    \"axcontrol\": \"com/win32comext/axcontrol/src\",\n    \"axdebug\": \"com/win32comext/axdebug/src\",\n    \"axscript\": \"com/win32comext/axscript/src\",\n    \"directsound\": \"com/win32comext/directsound/src\",\n    \"ifilter\": \"com/win32comext/ifilter/src\",\n    \"internet\": \"com/win32comext/internet/src\",\n    \"mapi\": \"com/win32comext/mapi/src\",\n    \"authorization\": \"com/win32comext/authorization/src\",\n    \"taskscheduler\": \"com/win32comext/taskscheduler/src\",\n    \"bits\": \"com/win32comext/bits/src\",\n    \"win32com\": \"com/win32com/src\",\n}\n\n# The COM modules.\npythoncom = WinExt_system32(\n    \"pythoncom\",\n    sources=(\n        \"\"\"\n                        {win32com}/dllmain.cpp            {win32com}/ErrorUtils.cpp\n                        {win32com}/MiscTypes.cpp          {win32com}/oleargs.cpp\n                        {win32com}/PyComHelpers.cpp       {win32com}/PyFactory.cpp\n                        {win32com}/PyGatewayBase.cpp      {win32com}/PyIBase.cpp\n                        {win32com}/PyIClassFactory.cpp    {win32com}/PyIDispatch.cpp\n                        {win32com}/PyIUnknown.cpp         {win32com}/PyRecord.cpp\n                        {win32com}/extensions/PySTGMEDIUM.cpp {win32com}/PyStorage.cpp\n                        {win32com}/PythonCOM.cpp          {win32com}/Register.cpp\n                        {win32com}/stdafx.cpp             {win32com}/univgw.cpp\n                        {win32com}/univgw_dataconv.cpp    {win32com}/extensions/PyFUNCDESC.cpp\n                        {win32com}/extensions/PyGConnectionPoint.cpp      {win32com}/extensions/PyGConnectionPointContainer.cpp\n                        {win32com}/extensions/PyGEnumVariant.cpp          {win32com}/extensions/PyGErrorLog.cpp\n                        {win32com}/extensions/PyGPersist.cpp              {win32com}/extensions/PyGPersistPropertyBag.cpp\n                        {win32com}/extensions/PyGPersistStorage.cpp       {win32com}/extensions/PyGPersistStream.cpp\n                        {win32com}/extensions/PyGPersistStreamInit.cpp    {win32com}/extensions/PyGPropertyBag.cpp\n                        {win32com}/extensions/PyGStream.cpp               {win32com}/extensions/PyIBindCtx.cpp\n                        {win32com}/extensions/PyICatInformation.cpp       {win32com}/extensions/PyICatRegister.cpp\n                        {win32com}/extensions/PyIConnectionPoint.cpp      {win32com}/extensions/PyIConnectionPointContainer.cpp\n                        {win32com}/extensions/PyICreateTypeInfo.cpp       {win32com}/extensions/PyICreateTypeLib.cpp\n                        {win32com}/extensions/PyICreateTypeLib2.cpp       {win32com}/extensions/PyIDataObject.cpp\n                        {win32com}/extensions/PyIDropSource.cpp           {win32com}/extensions/PyIDropTarget.cpp\n                        {win32com}/extensions/PyIEnumCATEGORYINFO.cpp     {win32com}/extensions/PyIEnumConnectionPoints.cpp\n                        {win32com}/extensions/PyIEnumConnections.cpp      {win32com}/extensions/PyIEnumFORMATETC.cpp\n                        {win32com}/extensions/PyIEnumGUID.cpp             {win32com}/extensions/PyIEnumSTATPROPSETSTG.cpp\n                        {win32com}/extensions/PyIEnumSTATPROPSTG.cpp      {win32com}/extensions/PyIEnumSTATSTG.cpp\n                        {win32com}/extensions/PyIEnumString.cpp           {win32com}/extensions/PyIEnumVARIANT.cpp\n                        {win32com}/extensions/PyIErrorLog.cpp             {win32com}/extensions/PyIExternalConnection.cpp\n                        {win32com}/extensions/PyIGlobalInterfaceTable.cpp {win32com}/extensions/PyILockBytes.cpp\n                        {win32com}/extensions/PyIMoniker.cpp              {win32com}/extensions/PyIOleWindow.cpp\n                        {win32com}/extensions/PyIPersist.cpp              {win32com}/extensions/PyIPersistFile.cpp\n                        {win32com}/extensions/PyIPersistPropertyBag.cpp   {win32com}/extensions/PyIPersistStorage.cpp\n                        {win32com}/extensions/PyIPersistStream.cpp        {win32com}/extensions/PyIPersistStreamInit.cpp\n                        {win32com}/extensions/PyIPropertyBag.cpp          {win32com}/extensions/PyIPropertySetStorage.cpp\n                        {win32com}/extensions/PyIPropertyStorage.cpp      {win32com}/extensions/PyIProvideClassInfo.cpp\n                        {win32com}/extensions/PyIRunningObjectTable.cpp   {win32com}/extensions/PyIServiceProvider.cpp\n                        {win32com}/extensions/PyIStorage.cpp              {win32com}/extensions/PyIStream.cpp\n                        {win32com}/extensions/PyIType.cpp                 {win32com}/extensions/PyITypeObjects.cpp\n                        {win32com}/extensions/PyTYPEATTR.cpp              {win32com}/extensions/PyVARDESC.cpp\n                        {win32com}/extensions/PyICancelMethodCalls.cpp    {win32com}/extensions/PyIContext.cpp\n                        {win32com}/extensions/PyIEnumContextProps.cpp     {win32com}/extensions/PyIClientSecurity.cpp\n                        {win32com}/extensions/PyIServerSecurity.cpp\n                        \"\"\".format(**dirs)\n    ).split(),\n    depends=(\n        \"\"\"\n                        {win32com}/include\\\\propbag.h          {win32com}/include\\\\PyComTypeObjects.h\n                        {win32com}/include\\\\PyFactory.h        {win32com}/include\\\\PyGConnectionPoint.h\n                        {win32com}/include\\\\PyGConnectionPointContainer.h\n                        {win32com}/include\\\\PyGPersistStorage.h {win32com}/include\\\\PyIBindCtx.h\n                        {win32com}/include\\\\PyICatInformation.h {win32com}/include\\\\PyICatRegister.h\n                        {win32com}/include\\\\PyIDataObject.h    {win32com}/include\\\\PyIDropSource.h\n                        {win32com}/include\\\\PyIDropTarget.h    {win32com}/include\\\\PyIEnumConnectionPoints.h\n                        {win32com}/include\\\\PyIEnumConnections.h {win32com}/include\\\\PyIEnumFORMATETC.h\n                        {win32com}/include\\\\PyIEnumGUID.h      {win32com}/include\\\\PyIEnumSTATPROPSETSTG.h\n                        {win32com}/include\\\\PyIEnumSTATSTG.h   {win32com}/include\\\\PyIEnumString.h\n                        {win32com}/include\\\\PyIEnumVARIANT.h   {win32com}/include\\\\PyIExternalConnection.h\n                        {win32com}/include\\\\PyIGlobalInterfaceTable.h {win32com}/include\\\\PyILockBytes.h\n                        {win32com}/include\\\\PyIMoniker.h       {win32com}/include\\\\PyIOleWindow.h\n                        {win32com}/include\\\\PyIPersist.h       {win32com}/include\\\\PyIPersistFile.h\n                        {win32com}/include\\\\PyIPersistStorage.h {win32com}/include\\\\PyIPersistStream.h\n                        {win32com}/include\\\\PyIPersistStreamInit.h {win32com}/include\\\\PyIRunningObjectTable.h\n                        {win32com}/include\\\\PyIStorage.h       {win32com}/include\\\\PyIStream.h\n                        {win32com}/include\\\\PythonCOM.h        {win32com}/include\\\\PythonCOMRegister.h\n                        {win32com}/include\\\\PythonCOMServer.h  {win32com}/include\\\\stdafx.h\n                        {win32com}/include\\\\univgw_dataconv.h\n                        {win32com}/include\\\\PyICancelMethodCalls.h    {win32com}/include\\\\PyIContext.h\n                        {win32com}/include\\\\PyIEnumContextProps.h     {win32com}/include\\\\PyIClientSecurity.h\n                        {win32com}/include\\\\PyIServerSecurity.h\n                        \"\"\".format(**dirs)\n    ).split(),\n    libraries=\"oleaut32 ole32 user32 urlmon\",\n    export_symbol_file=\"com/win32com/src/PythonCOM.def\",\n    extra_compile_args=[\"-DBUILD_PYTHONCOM\"],\n    pch_header=\"stdafx.h\",\n    base_address=dll_base_address,\n)\ndll_base_address += 0x80000  # pythoncom is large!\ncom_extensions = [\n    pythoncom,\n    WinExt_win32com(\n        \"adsi\",\n        libraries=\"ACTIVEDS ADSIID user32 advapi32\",\n        sources=(\n            \"\"\"\n                        {adsi}/adsi.i                 {adsi}/adsi.cpp\n                        {adsi}/PyIADsContainer.i      {adsi}/PyIADsContainer.cpp\n                        {adsi}/PyIADsUser.i           {adsi}/PyIADsUser.cpp\n                        {adsi}/PyIADsDeleteOps.i      {adsi}/PyIADsDeleteOps.cpp\n                        {adsi}/PyIDirectoryObject.i   {adsi}/PyIDirectoryObject.cpp\n                        {adsi}/PyIDirectorySearch.i   {adsi}/PyIDirectorySearch.cpp\n                        {adsi}/PyIDsObjectPicker.i    {adsi}/PyIDsObjectPicker.cpp\n\n                        {adsi}/adsilib.i\n                        {adsi}/PyADSIUtil.cpp         {adsi}/PyDSOPObjects.cpp\n                        {adsi}/PyIADs.cpp\n                        \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com(\n        \"axcontrol\",\n        pch_header=\"axcontrol_pch.h\",\n        sources=(\n            \"\"\"\n                        {axcontrol}/AXControl.cpp\n                        {axcontrol}/PyIOleControl.cpp          {axcontrol}/PyIOleControlSite.cpp\n                        {axcontrol}/PyIOleInPlaceActiveObject.cpp\n                        {axcontrol}/PyIOleInPlaceSiteEx.cpp    {axcontrol}/PyISpecifyPropertyPages.cpp\n                        {axcontrol}/PyIOleInPlaceUIWindow.cpp  {axcontrol}/PyIOleInPlaceFrame.cpp\n                        {axcontrol}/PyIObjectWithSite.cpp      {axcontrol}/PyIOleInPlaceObject.cpp\n                        {axcontrol}/PyIOleInPlaceSiteWindowless.cpp  {axcontrol}/PyIViewObject.cpp\n                        {axcontrol}/PyIOleClientSite.cpp       {axcontrol}/PyIOleInPlaceSite.cpp\n                        {axcontrol}/PyIOleObject.cpp           {axcontrol}/PyIViewObject2.cpp\n                        {axcontrol}/PyIOleCommandTarget.cpp\n                        \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com(\n        \"axscript\",\n        sources=(\n            \"\"\"\n                        {axscript}/AXScript.cpp\n                        {axscript}/GUIDS.cpp                   {axscript}/PyGActiveScript.cpp\n                        {axscript}/PyGActiveScriptError.cpp    {axscript}/PyGActiveScriptParse.cpp\n                        {axscript}/PyGActiveScriptSite.cpp     {axscript}/PyGObjectSafety.cpp\n                        {axscript}/PyIActiveScript.cpp         {axscript}/PyIActiveScriptError.cpp\n                        {axscript}/PyIActiveScriptParse.cpp    {axscript}/PyIActiveScriptParseProcedure.cpp\n                        {axscript}/PyIActiveScriptSite.cpp     {axscript}/PyIMultiInfos.cpp\n                        {axscript}/PyIObjectSafety.cpp         {axscript}/stdafx.cpp\n                        \"\"\".format(**dirs)\n        ).split(),\n        depends=(\n            \"\"\"\n                             {axscript}/AXScript.h\n                             {axscript}/GUIDs.h                {axscript}/PyGActiveScriptError.h\n                             {axscript}/PyIActiveScriptError.h {axscript}/PyIObjectSafety.h\n                             {axscript}/PyIProvideMultipleClassInfo.h\n                             {axscript}/stdafx.h\n                             \"\"\".format(**dirs)\n        ).split(),\n        extra_compile_args=[\"-DPY_BUILD_AXSCRIPT\"],\n        implib_name=\"axscript\",\n        pch_header=\"stdafx.h\",\n    ),\n    WinExt_win32com(\n        \"axdebug\",\n        libraries=\"axscript\",\n        pch_header=\"stdafx.h\",\n        sources=(\n            \"\"\"\n                    {axdebug}/AXDebug.cpp\n                    {axdebug}/PyIActiveScriptDebug.cpp\n                    {axdebug}/PyIActiveScriptErrorDebug.cpp\n                    {axdebug}/PyIActiveScriptSiteDebug.cpp\n                    {axdebug}/PyIApplicationDebugger.cpp\n                    {axdebug}/PyIDebugApplication.cpp\n                    {axdebug}/PyIDebugApplicationNode.cpp\n                    {axdebug}/PyIDebugApplicationNodeEvents.cpp\n                    {axdebug}/PyIDebugApplicationThread.cpp\n                    {axdebug}/PyIDebugCodeContext.cpp\n                    {axdebug}/PyIDebugDocument.cpp\n                    {axdebug}/PyIDebugDocumentContext.cpp\n                    {axdebug}/PyIDebugDocumentHelper.cpp\n                    {axdebug}/PyIDebugDocumentHost.cpp\n                    {axdebug}/PyIDebugDocumentInfo.cpp\n                    {axdebug}/PyIDebugDocumentProvider.cpp\n                    {axdebug}/PyIDebugDocumentText.cpp\n                    {axdebug}/PyIDebugDocumentTextAuthor.cpp\n                    {axdebug}/PyIDebugDocumentTextEvents.cpp\n                    {axdebug}/PyIDebugDocumentTextExternalAuthor.cpp\n                    {axdebug}/PyIDebugExpression.cpp\n                    {axdebug}/PyIDebugExpressionCallBack.cpp\n                    {axdebug}/PyIDebugExpressionContext.cpp\n                    {axdebug}/PyIDebugProperties.cpp\n                    {axdebug}/PyIDebugSessionProvider.cpp\n                    {axdebug}/PyIDebugStackFrame.cpp\n                    {axdebug}/PyIDebugStackFrameSniffer.cpp\n                    {axdebug}/PyIDebugStackFrameSnifferEx.cpp\n                    {axdebug}/PyIDebugSyncOperation.cpp\n                    {axdebug}/PyIEnumDebugApplicationNodes.cpp\n                    {axdebug}/PyIEnumDebugCodeContexts.cpp\n                    {axdebug}/PyIEnumDebugExpressionContexts.cpp\n                    {axdebug}/PyIEnumDebugPropertyInfo.cpp\n                    {axdebug}/PyIEnumDebugStackFrames.cpp\n                    {axdebug}/PyIEnumRemoteDebugApplications.cpp\n                    {axdebug}/PyIEnumRemoteDebugApplicationThreads.cpp\n                    {axdebug}/PyIMachineDebugManager.cpp\n                    {axdebug}/PyIMachineDebugManagerEvents.cpp\n                    {axdebug}/PyIProcessDebugManager.cpp\n                    {axdebug}/PyIProvideExpressionContexts.cpp\n                    {axdebug}/PyIRemoteDebugApplication.cpp\n                    {axdebug}/PyIRemoteDebugApplicationEvents.cpp\n                    {axdebug}/PyIRemoteDebugApplicationThread.cpp\n                    {axdebug}/stdafx.cpp\n                     \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com(\n        \"internet\",\n        pch_header=\"internet_pch.h\",\n        sources=(\n            \"\"\"\n                        {internet}/internet.cpp                   {internet}/PyIDocHostUIHandler.cpp\n                        {internet}/PyIHTMLOMWindowServices.cpp    {internet}/PyIInternetBindInfo.cpp\n                        {internet}/PyIInternetPriority.cpp        {internet}/PyIInternetProtocol.cpp\n                        {internet}/PyIInternetProtocolInfo.cpp    {internet}/PyIInternetProtocolRoot.cpp\n                        {internet}/PyIInternetProtocolSink.cpp    {internet}/PyIInternetSecurityManager.cpp\n                    \"\"\".format(**dirs)\n        ).split(),\n        depends=[\"{internet}/internet_pch.h\".format(**dirs)],\n    ),\n    WinExt_win32com(\n        \"mapi\",\n        libraries=\"advapi32\",\n        pch_header=\"PythonCOM.h\",\n        include_dirs=[\"{mapi}/MapiStubLibrary/include\".format(**dirs)],\n        sources=(\n            \"\"\"\n                        {mapi}/mapi.i                 {mapi}/mapi.cpp\n                        {mapi}/PyIABContainer.i       {mapi}/PyIABContainer.cpp\n                        {mapi}/PyIAddrBook.i          {mapi}/PyIAddrBook.cpp\n                        {mapi}/PyIAttach.i            {mapi}/PyIAttach.cpp\n                        {mapi}/PyIDistList.i          {mapi}/PyIDistList.cpp\n                        {mapi}/PyIMailUser.i          {mapi}/PyIMailUser.cpp\n                        {mapi}/PyIMAPIContainer.i     {mapi}/PyIMAPIContainer.cpp\n                        {mapi}/PyIMAPIFolder.i        {mapi}/PyIMAPIFolder.cpp\n                        {mapi}/PyIMAPIProp.i          {mapi}/PyIMAPIProp.cpp\n                        {mapi}/PyIMAPISession.i       {mapi}/PyIMAPISession.cpp\n                        {mapi}/PyIMAPIStatus.i        {mapi}/PyIMAPIStatus.cpp\n                        {mapi}/PyIMAPITable.i         {mapi}/PyIMAPITable.cpp\n                        {mapi}/PyIMessage.i           {mapi}/PyIMessage.cpp\n                        {mapi}/PyIMsgServiceAdmin.i   {mapi}/PyIMsgServiceAdmin.cpp\n                        {mapi}/PyIMsgServiceAdmin2.i  {mapi}/PyIMsgServiceAdmin2.cpp\n                        {mapi}/PyIProviderAdmin.i     {mapi}/PyIProviderAdmin.cpp\n                        {mapi}/PyIMsgStore.i          {mapi}/PyIMsgStore.cpp\n                        {mapi}/PyIProfAdmin.i         {mapi}/PyIProfAdmin.cpp\n                        {mapi}/PyIProfSect.i          {mapi}/PyIProfSect.cpp\n                        {mapi}/PyIConverterSession.i  {mapi}/PyIConverterSession.cpp\n                        {mapi}/PyIMAPIAdviseSink.cpp\n                        {mapi}/mapiutil.cpp\n                        {mapi}/mapiguids.cpp\n                        {mapi}/MAPIStubLibrary/library/mapiStubLibrary.cpp\n                        {mapi}/MAPIStubLibrary/library/stubutils.cpp\n                        \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com_mapi(\n        \"exchange\",\n        libraries=\"advapi32 legacy_stdio_definitions\",\n        include_dirs=[\"{mapi}/MapiStubLibrary/include\".format(**dirs)],\n        sources=(\n            \"\"\"\n                                  {mapi}/exchange.i         {mapi}/exchange.cpp\n                                  {mapi}/PyIExchangeManageStore.i {mapi}/PyIExchangeManageStore.cpp\n                                  {mapi}/PyIExchangeManageStoreEx.i {mapi}/PyIExchangeManageStoreEx.cpp\n                                  {mapi}/mapiutil.cpp\n                                  {mapi}/exchangeguids.cpp\n                                  {mapi}/MAPIStubLibrary/library/mapiStubLibrary.cpp\n                                  {mapi}/MAPIStubLibrary/library/stubutils.cpp\n                                  \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com(\n        \"shell\",\n        libraries=\"shell32\",\n        pch_header=\"shell_pch.h\",\n        sources=(\n            \"\"\"\n                        {shell}/PyIActiveDesktop.cpp\n                        {shell}/PyIApplicationDestinations.cpp\n                        {shell}/PyIApplicationDocumentLists.cpp\n                        {shell}/PyIAsyncOperation.cpp\n                        {shell}/PyIBrowserFrameOptions.cpp\n                        {shell}/PyICategorizer.cpp\n                        {shell}/PyICategoryProvider.cpp\n                        {shell}/PyIColumnProvider.cpp\n                        {shell}/PyIContextMenu.cpp\n                        {shell}/PyIContextMenu2.cpp\n                        {shell}/PyIContextMenu3.cpp\n                        {shell}/PyICopyHook.cpp\n                        {shell}/PyICurrentItem.cpp\n                        {shell}/PyICustomDestinationList.cpp\n                        {shell}/PyIDefaultExtractIconInit.cpp\n                        {shell}/PyIDeskBand.cpp\n                        {shell}/PyIDisplayItem.cpp\n                        {shell}/PyIDockingWindow.cpp\n                        {shell}/PyIDropTargetHelper.cpp\n                        {shell}/PyIEnumExplorerCommand.cpp\n                        {shell}/PyIEnumIDList.cpp\n                        {shell}/PyIEnumObjects.cpp\n                        {shell}/PyIEnumResources.cpp\n                        {shell}/PyIEnumShellItems.cpp\n                        {shell}/PyIEmptyVolumeCache.cpp\n                        {shell}/PyIEmptyVolumeCacheCallBack.cpp\n                        {shell}/PyIExplorerBrowser.cpp\n                        {shell}/PyIExplorerBrowserEvents.cpp\n                        {shell}/PyIExplorerCommand.cpp\n                        {shell}/PyIExplorerCommandProvider.cpp\n                        {shell}/PyIExplorerPaneVisibility.cpp\n                        {shell}/PyIExtractIcon.cpp\n                        {shell}/PyIExtractIconW.cpp\n                        {shell}/PyIExtractImage.cpp\n                        {shell}/PyIFileOperation.cpp\n                        {shell}/PyIFileOperationProgressSink.cpp\n                        {shell}/PyIFolderView.cpp\n                        {shell}/PyIIdentityName.cpp\n                        {shell}/PyIInputObject.cpp\n                        {shell}/PyIKnownFolder.cpp\n                        {shell}/PyIKnownFolderManager.cpp\n                        {shell}/PyINameSpaceTreeControl.cpp\n                        {shell}/PyIObjectArray.cpp\n                        {shell}/PyIObjectCollection.cpp\n                        {shell}/PyIPersistFolder.cpp\n                        {shell}/PyIPersistFolder2.cpp\n                        {shell}/PyIQueryAssociations.cpp\n                        {shell}/PyIRelatedItem.cpp\n                        {shell}/PyIShellBrowser.cpp\n                        {shell}/PyIShellExtInit.cpp\n                        {shell}/PyIShellFolder.cpp\n                        {shell}/PyIShellFolder2.cpp\n                        {shell}/PyIShellIcon.cpp\n                        {shell}/PyIShellIconOverlay.cpp\n                        {shell}/PyIShellIconOverlayIdentifier.cpp\n                        {shell}/PyIShellIconOverlayManager.cpp\n                        {shell}/PyIShellItem.cpp\n                        {shell}/PyIShellItem2.cpp\n                        {shell}/PyIShellItemArray.cpp\n                        {shell}/PyIShellItemResources.cpp\n                        {shell}/PyIShellLibrary.cpp\n                        {shell}/PyIShellLink.cpp\n                        {shell}/PyIShellLinkDataList.cpp\n                        {shell}/PyIShellView.cpp\n                        {shell}/PyITaskbarList.cpp\n                        {shell}/PyITransferAdviseSink.cpp\n                        {shell}/PyITransferDestination.cpp\n                        {shell}/PyITransferMediumItem.cpp\n                        {shell}/PyITransferSource.cpp\n                        {shell}/PyIUniformResourceLocator.cpp\n                        {shell}/shell.cpp\n\n                        \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com(\n        \"propsys\",\n        libraries=\"propsys\",\n        delay_load_libraries=\"shell32\",\n        sources=(\n            \"\"\"\n                        {propsys}/propsys.cpp\n                        {propsys}/PyIInitializeWithFile.cpp\n                        {propsys}/PyIInitializeWithStream.cpp\n                        {propsys}/PyINamedPropertyStore.cpp\n                        {propsys}/PyIPropertyDescription.cpp\n                        {propsys}/PyIPropertyDescriptionAliasInfo.cpp\n                        {propsys}/PyIPropertyDescriptionList.cpp\n                        {propsys}/PyIPropertyDescriptionSearchInfo.cpp\n                        {propsys}/PyIPropertyEnumType.cpp\n                        {propsys}/PyIPropertyEnumTypeList.cpp\n                        {propsys}/PyIPropertyStore.cpp\n                        {propsys}/PyIPropertyStoreCache.cpp\n                        {propsys}/PyIPropertyStoreCapabilities.cpp\n                        {propsys}/PyIPropertySystem.cpp\n                        {propsys}/PyPROPVARIANT.cpp\n                        {propsys}/PyIPersistSerializedPropStorage.cpp\n                        {propsys}/PyIObjectWithPropertyKey.cpp\n                        {propsys}/PyIPropertyChange.cpp\n                        {propsys}/PyIPropertyChangeArray.cpp\n                        \"\"\".format(**dirs)\n        ).split(),\n        implib_name=\"pypropsys\",\n    ),\n    WinExt_win32com(\n        \"taskscheduler\",\n        libraries=\"mstask\",\n        sources=(\n            \"\"\"\n                        {taskscheduler}/taskscheduler.cpp\n                        {taskscheduler}/PyIProvideTaskPage.cpp\n                        {taskscheduler}/PyIScheduledWorkItem.cpp\n                        {taskscheduler}/PyITask.cpp\n                        {taskscheduler}/PyITaskScheduler.cpp\n                        {taskscheduler}/PyITaskTrigger.cpp\n\n                        \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com(\n        \"bits\",\n        libraries=\"Bits\",\n        pch_header=\"bits_pch.h\",\n        sources=(\n            \"\"\"\n                        {bits}/bits.cpp\n                        {bits}/PyIBackgroundCopyManager.cpp\n                        {bits}/PyIBackgroundCopyCallback.cpp\n                        {bits}/PyIBackgroundCopyError.cpp\n                        {bits}/PyIBackgroundCopyJob.cpp\n                        {bits}/PyIBackgroundCopyJob2.cpp\n                        {bits}/PyIBackgroundCopyJob3.cpp\n                        {bits}/PyIBackgroundCopyFile.cpp\n                        {bits}/PyIBackgroundCopyFile2.cpp\n                        {bits}/PyIEnumBackgroundCopyJobs.cpp\n                        {bits}/PyIEnumBackgroundCopyFiles.cpp\n\n                        \"\"\".format(**dirs)\n        ).split(),\n    ),\n    WinExt_win32com(\n        \"ifilter\",\n        libraries=\"ntquery\",\n        sources=(\"{ifilter}/PyIFilter.cpp\".format(**dirs)).split(),\n        depends=(\"{ifilter}/PyIFilter.h {ifilter}/stdafx.h\".format(**dirs)).split(),\n    ),\n    WinExt_win32com(\n        \"directsound\",\n        pch_header=\"directsound_pch.h\",\n        sources=(\n            \"\"\"\n                        {directsound}/directsound.cpp     {directsound}/PyDSBCAPS.cpp\n                        {directsound}/PyDSBUFFERDESC.cpp  {directsound}/PyDSCAPS.cpp\n                        {directsound}/PyDSCBCAPS.cpp      {directsound}/PyDSCBUFFERDESC.cpp\n                        {directsound}/PyDSCCAPS.cpp       {directsound}/PyIDirectSound.cpp\n                        {directsound}/PyIDirectSoundBuffer.cpp {directsound}/PyIDirectSoundCapture.cpp\n                        {directsound}/PyIDirectSoundCaptureBuffer.cpp\n                        {directsound}/PyIDirectSoundNotify.cpp\n                        \"\"\".format(**dirs)\n        ).split(),\n        depends=(\n            \"\"\"\n                        {directsound}/directsound_pch.h   {directsound}/PyIDirectSound.h\n                        {directsound}/PyIDirectSoundBuffer.h {directsound}/PyIDirectSoundCapture.h\n                        {directsound}/PyIDirectSoundCaptureBuffer.h {directsound}/PyIDirectSoundNotify.h\n                        \"\"\".format(**dirs)\n        ).split(),\n        optional_headers=[\"dsound.h\"],\n        libraries=\"user32 dsound dxguid\",\n    ),\n    WinExt_win32com(\n        \"authorization\",\n        libraries=\"aclui advapi32\",\n        sources=(\n            \"\"\"\n                        {authorization}/authorization.cpp\n                        {authorization}/PyGSecurityInformation.cpp\n                        \"\"\".format(**dirs)\n        ).split(),\n    ),\n]\n\npythonwin_extensions = [\n    WinExt_pythonwin(\n        \"win32ui\",\n        sources=[\n            \"Pythonwin/dbgthread.cpp\",\n            \"Pythonwin/dibapi.cpp\",\n            \"Pythonwin/dllmain.cpp\",\n            \"Pythonwin/pythondoc.cpp\",\n            \"Pythonwin/pythonppage.cpp\",\n            \"Pythonwin/pythonpsheet.cpp\",\n            \"Pythonwin/pythonRichEditCntr.cpp\",\n            \"Pythonwin/pythonRichEditDoc.cpp\",\n            \"Pythonwin/pythonview.cpp\",\n            \"Pythonwin/stdafx.cpp\",\n            \"Pythonwin/win32app.cpp\",\n            \"Pythonwin/win32assoc.cpp\",\n            \"Pythonwin/win32bitmap.cpp\",\n            \"Pythonwin/win32brush.cpp\",\n            \"Pythonwin/win32cmd.cpp\",\n            \"Pythonwin/win32cmdui.cpp\",\n            \"Pythonwin/win32context.cpp\",\n            \"Pythonwin/win32control.cpp\",\n            \"Pythonwin/win32ctledit.cpp\",\n            \"Pythonwin/win32ctrlList.cpp\",\n            \"Pythonwin/win32ctrlRichEdit.cpp\",\n            \"Pythonwin/win32ctrlTree.cpp\",\n            \"Pythonwin/win32dc.cpp\",\n            \"Pythonwin/win32dlg.cpp\",\n            \"Pythonwin/win32dlgbar.cpp\",\n            \"Pythonwin/win32dll.cpp\",\n            \"Pythonwin/win32doc.cpp\",\n            \"win32/src/win32dynamicdialog.cpp\",\n            \"Pythonwin/win32font.cpp\",\n            \"Pythonwin/win32gdi.cpp\",\n            \"Pythonwin/win32ImageList.cpp\",\n            \"Pythonwin/win32menu.cpp\",\n            \"Pythonwin/win32notify.cpp\",\n            \"Pythonwin/win32pen.cpp\",\n            \"Pythonwin/win32prinfo.cpp\",\n            \"Pythonwin/win32prop.cpp\",\n            \"Pythonwin/win32rgn.cpp\",\n            \"Pythonwin/win32RichEdit.cpp\",\n            \"Pythonwin/win32RichEditDocTemplate.cpp\",\n            \"Pythonwin/win32splitter.cpp\",\n            \"Pythonwin/win32template.cpp\",\n            \"Pythonwin/win32thread.cpp\",\n            \"Pythonwin/win32toolbar.cpp\",\n            \"Pythonwin/win32tooltip.cpp\",\n            \"Pythonwin/win32ui.rc\",\n            \"Pythonwin/win32uimodule.cpp\",\n            \"Pythonwin/win32util.cpp\",\n            \"Pythonwin/win32view.cpp\",\n            \"Pythonwin/win32virt.cpp\",\n            \"Pythonwin/win32win.cpp\",\n        ],\n        extra_compile_args=[\"-DBUILD_PYW\"],\n        pch_header=\"stdafx.h\",\n        base_address=dll_base_address,\n        depends=[\n            \"Pythonwin/stdafx.h\",\n            \"Pythonwin/win32uiExt.h\",\n            \"win32/src/PyWinTypes.h\",\n            \"Pythonwin/dibapi.h\",\n            \"Pythonwin/pythoncbar.h\",\n            \"Pythonwin/pythondoc.h\",\n            \"Pythonwin/pythonframe.h\",\n            \"Pythonwin/pythonppage.h\",\n            \"Pythonwin/pythonpsheet.h\",\n            \"Pythonwin/pythonRichEdit.h\",\n            \"Pythonwin/pythonRichEditCntr.h\",\n            \"Pythonwin/pythonRichEditDoc.h\",\n            \"Pythonwin/pythonview.h\",\n            \"Pythonwin/pythonwin.h\",\n            \"Pythonwin/Win32app.h\",\n            \"Pythonwin/win32assoc.h\",\n            \"Pythonwin/win32bitmap.h\",\n            \"Pythonwin/win32brush.h\",\n            \"Pythonwin/win32cmd.h\",\n            \"Pythonwin/win32cmdui.h\",\n            \"Pythonwin/win32control.h\",\n            \"Pythonwin/win32ctrlList.h\",\n            \"Pythonwin/win32ctrlTree.h\",\n            \"Pythonwin/win32dc.h\",\n            \"Pythonwin/win32dlg.h\",\n            \"Pythonwin/win32dlgbar.h\",\n            \"win32/src/win32dynamicdialog.h\",\n            \"Pythonwin/win32dll.h\",\n            \"Pythonwin/win32doc.h\",\n            \"Pythonwin/win32font.h\",\n            \"Pythonwin/win32gdi.h\",\n            \"Pythonwin/win32hl.h\",\n            \"Pythonwin/win32ImageList.h\",\n            \"Pythonwin/win32menu.h\",\n            \"Pythonwin/win32pen.h\",\n            \"Pythonwin/win32prinfo.h\",\n            \"Pythonwin/win32prop.h\",\n            \"Pythonwin/win32rgn.h\",\n            \"Pythonwin/win32RichEdit.h\",\n            \"Pythonwin/win32RichEditDocTemplate.h\",\n            \"Pythonwin/win32splitter.h\",\n            \"Pythonwin/win32template.h\",\n            \"Pythonwin/win32toolbar.h\",\n            \"Pythonwin/win32ui.h\",\n            \"Pythonwin/Win32uiHostGlue.h\",\n            \"Pythonwin/win32win.h\",\n        ],\n        optional_headers=[\"afxres.h\"],\n    ),\n    WinExt_pythonwin(\n        \"win32uiole\",\n        sources=[\n            \"Pythonwin/stdafxole.cpp\",\n            \"Pythonwin/win32oleDlgInsert.cpp\",\n            \"Pythonwin/win32oleDlgs.cpp\",\n            \"Pythonwin/win32uiole.cpp\",\n            \"Pythonwin/win32uioleClientItem.cpp\",\n            \"Pythonwin/win32uioledoc.cpp\",\n        ],\n        depends=[\n            \"Pythonwin/stdafxole.h\",\n            \"Pythonwin/win32oleDlgs.h\",\n            \"Pythonwin/win32uioledoc.h\",\n        ],\n        pch_header=\"stdafxole.h\",\n        optional_headers=[\"afxres.h\"],\n    ),\n    WinExt_pythonwin(\n        \"dde\",\n        sources=[\n            \"Pythonwin/stddde.cpp\",\n            \"Pythonwin/ddetopic.cpp\",\n            \"Pythonwin/ddeconv.cpp\",\n            \"Pythonwin/ddeitem.cpp\",\n            \"Pythonwin/ddemodule.cpp\",\n            \"Pythonwin/ddeserver.cpp\",\n        ],\n        pch_header=\"stdafxdde.h\",\n        depends=[\"win32/src/stddde.h\", \"pythonwin/ddemodule.h\"],\n        optional_headers=[\"afxres.h\"],\n    ),\n]\n# win32ui is large, so we reserve more bytes than normal\ndll_base_address += 0x100000\n\nother_extensions = []\nother_extensions.append(\n    WinExt_ISAPI(\n        \"PyISAPI_loader\",\n        sources=[\n            os.path.join(\"isapi\", \"src\", s)\n            for s in \"\"\"PyExtensionObjects.cpp PyFilterObjects.cpp\n                  pyISAPI.cpp pyISAPI_messages.mc\n                  PythonEng.cpp StdAfx.cpp Utils.cpp\n               \"\"\".split()\n        ],\n        # We keep pyISAPI_messages.h out of the depends list, as it is\n        # generated and we aren't smart enough to say *only* the .cpp etc\n        # depend on it - so the generated .h says the .mc needs to be\n        # rebuilt, which re-creates the .h...\n        depends=[\n            os.path.join(\"isapi\", \"src\", s)\n            for s in \"\"\"ControlBlock.h FilterContext.h PyExtensionObjects.h\n                  PyFilterObjects.h pyISAPI.h\n                  PythonEng.h StdAfx.h Utils.h\n               \"\"\".split()\n        ],\n        pch_header=\"StdAfx.h\",\n        is_regular_dll=1,\n        export_symbols=\"\"\"HttpExtensionProc GetExtensionVersion\n                           TerminateExtension GetFilterVersion\n                           HttpFilterProc TerminateFilter\n                           PyISAPISetOptions WriteEventLogMessage\n                           \"\"\".split(),\n        libraries=\"advapi32\",\n    )\n)\n\nW32_exe_files = [\n    WinExt_pythonservice(\n        \"pythonservice\",\n        sources=[\n            os.path.join(\"win32\", \"src\", s)\n            for s in \"PythonService.cpp PythonService.rc\".split()\n        ],\n        libraries=\"user32 advapi32 ole32 shell32\",\n    ),\n    WinExt_pythonwin_subsys_win(\n        \"Pythonwin\",\n        sources=[\n            \"Pythonwin/pythonwin.cpp\",\n            \"Pythonwin/pythonwin.rc\",\n            \"Pythonwin/stdafxpw.cpp\",\n        ],\n        depends=[\n            \"Pythonwin/Win32uiHostGlue.h\",\n            \"Pythonwin/pythonwin.h\",\n        ],\n        optional_headers=[\"afxres.h\"],\n    ),\n]\n\n# Special definitions for SWIG.\nswig_interface_parents = {\n    # source file base,     \"base class\" for generated COM support\n    \"mapi\": None,  # not a class, but module\n    \"PyIMailUser\": \"IMAPIContainer\",\n    \"PyIABContainer\": \"IMAPIContainer\",\n    \"PyIAddrBook\": \"IMAPIProp\",\n    \"PyIAttach\": \"IMAPIProp\",\n    \"PyIDistList\": \"IMAPIContainer\",\n    \"PyIMailUser\": \"IMAPIContainer\",\n    \"PyIMAPIContainer\": \"IMAPIProp\",\n    \"PyIMAPIFolder\": \"IMAPIContainer\",\n    \"PyIMAPIProp\": \"\",  # '' == default base\n    \"PyIMAPISession\": \"\",\n    \"PyIMAPIStatus\": \"IMAPIProp\",\n    \"PyIMAPITable\": \"\",\n    \"PyIMessage\": \"IMAPIProp\",\n    \"PyIMsgServiceAdmin\": \"\",\n    \"PyIMsgServiceAdmin2\": \"IMsgServiceAdmin\",\n    \"PyIProviderAdmin\": \"\",\n    \"PyIMsgStore\": \"IMAPIProp\",\n    \"PyIProfAdmin\": \"\",\n    \"PyIProfSect\": \"IMAPIProp\",\n    \"PyIConverterSession\": \"\",\n    \"exchange\": None,  # mapi module\n    \"PyIExchangeManageStore\": \"\",\n    \"PyIExchangeManageStoreEx\": \"\",\n    # ADSI\n    \"adsi\": None,  # module\n    \"PyIADsContainer\": \"IDispatch\",\n    \"PyIADsDeleteOps\": \"IDispatch\",\n    \"PyIADsUser\": \"IADs\",\n    \"PyIDirectoryObject\": \"\",\n    \"PyIDirectorySearch\": \"\",\n    \"PyIDsObjectPicker\": \"\",\n    \"PyIADs\": \"IDispatch\",\n}\n\n# .i files that are #included, and hence are not part of the build.  Our .dsp\n# parser isn't smart enough to differentiate these.\nswig_include_files = \"mapilib adsilib\".split()\n\n\ndef expand_modules(module_dir: str | os.PathLike[str]):\n    \"\"\"Helper to allow our script specifications to include wildcards.\"\"\"\n    return [str(path.with_suffix(\"\")) for path in Path(module_dir).rglob(\"*.py\")]\n\n\n# NOTE: somewhat counter-intuitively, a result list a-la:\n#  [('Lib/site-packages\\\\pythonwin', ('pythonwin/license.txt',)),]\n# will 'do the right thing' in terms of installing licence.txt into\n# 'Lib/site-packages/pythonwin/licence.txt'.  We exploit this to\n# get 'com/win32com/whatever' installed to 'win32com/whatever'\ndef convert_data_files(files: Iterable[str]):\n    ret: list[tuple[str, tuple[str]]] = []\n    for file in files:\n        file = os.path.normpath(file)\n        if file.find(\"*\") >= 0:\n            files_use = tuple(\n                str(path)\n                for path in Path(file).parent.rglob(os.path.basename(file))\n                # We never want CVS\n                if not (\"\\\\CVS\\\\\" in file or path.suffix in {\".pyc\", \".pyo\"})\n            )\n            if not files_use:\n                raise RuntimeError(\"No files match '%s'\" % file)\n        else:\n            if not os.path.isfile(file):\n                raise RuntimeError(\"No file '%s'\" % file)\n            files_use = (file,)\n        for fname in files_use:\n            path_use = os.path.dirname(fname)\n            if path_use.startswith(\"com\\\\\"):\n                path_use = path_use[4:]\n            ret.append((path_use, (fname,)))\n    return ret\n\n\ndef convert_optional_data_files(files):\n    ret = []\n    for file in files:\n        try:\n            temp = convert_data_files([file])\n        except RuntimeError as details:\n            if not str(details.args[0]).startswith(\"No file\"):\n                raise\n            logging.info(\"NOTE: Optional file %s not found - skipping\", file)\n        else:\n            ret.append(temp[0])\n    return ret\n\n\n################################################################\nif len(sys.argv) == 1:\n    # distutils will print usage - print our docstring first.\n    print(__doc__)\n    print(\"Standard usage information follows:\")\n\npackages = [\n    \"win32com\",\n    \"win32com.client\",\n    \"win32com.demos\",\n    \"win32com.makegw\",\n    \"win32com.server\",\n    \"win32com.servers\",\n    \"win32com.test\",\n    \"win32comext.adsi\",\n    \"win32comext.axscript\",\n    \"win32comext.axscript.client\",\n    \"win32comext.axscript.server\",\n    \"win32comext.axdebug\",\n    \"win32comext.propsys\",\n    \"win32comext.shell\",\n    \"win32comext.mapi\",\n    \"win32comext.ifilter\",\n    \"win32comext.internet\",\n    \"win32comext.axcontrol\",\n    \"win32comext.taskscheduler\",\n    \"win32comext.directsound\",\n    \"win32comext.directsound.test\",\n    \"win32comext.authorization\",\n    \"win32comext.bits\",\n    \"pythonwin.pywin\",\n    \"pythonwin.pywin.debugger\",\n    \"pythonwin.pywin.dialogs\",\n    \"pythonwin.pywin.docking\",\n    \"pythonwin.pywin.framework\",\n    \"pythonwin.pywin.framework.editor\",\n    \"pythonwin.pywin.framework.editor.color\",\n    \"pythonwin.pywin.idle\",\n    \"pythonwin.pywin.mfc\",\n    \"pythonwin.pywin.scintilla\",\n    \"pythonwin.pywin.tools\",\n    \"isapi\",\n    \"adodbapi\",\n]\n\npy_modules = [*expand_modules(\"win32\\\\lib\"), \"win32\\\\winxpgui\"]\next_modules = (\n    win32_extensions + com_extensions + pythonwin_extensions + other_extensions\n)\n\ncmdclass = {\n    \"install\": my_install,\n    \"build\": my_build,\n    \"build_ext\": my_build_ext,\n    \"install_data\": my_install_data,\n}\n\nclassifiers = [\n    \"Environment :: Win32 (MS Windows)\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: Python Software Foundation License\",\n    \"Operating System :: Microsoft :: Windows\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3.13\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n]\n\ndist = setup(\n    name=\"pywin32\",\n    version=build_id,\n    description=\"Python for Window Extensions\",\n    long_description=(Path(__file__).parent / \"README.md\").read_text(),\n    long_description_content_type=\"text/markdown\",\n    author=\"Mark Hammond (et al)\",\n    author_email=\"mhammond@skippinet.com.au\",\n    url=\"https://github.com/mhammond/pywin32\",\n    license=\"PSF\",\n    classifiers=classifiers,\n    cmdclass=cmdclass,\n    scripts=[\"pywin32_postinstall.py\", \"pywin32_testall.py\"],\n    ext_modules=ext_modules,\n    package_dir={\n        \"win32com\": \"com/win32com\",\n        \"win32comext\": \"com/win32comext\",\n        \"pythonwin\": \"pythonwin\",\n    },\n    packages=packages,\n    py_modules=py_modules,\n    data_files=[(\"\", (os.path.join(gettempdir(), \"pywin32.version.txt\"),))]\n    + convert_optional_data_files(\n        [\n            \"PyWin32.chm\",\n        ]\n    )\n    + convert_data_files(\n        [\n            \"Pythonwin/start_pythonwin.pyw\",\n            \"pythonwin/pywin/*.cfg\",\n            \"pythonwin/pywin/Demos/*.py\",\n            \"pythonwin/pywin/Demos/app/*.py\",\n            \"pythonwin/pywin/Demos/ocx/*.py\",\n            \"pythonwin/license.txt\",\n            \"win32/license.txt\",\n            \"win32/scripts/*.py\",\n            \"win32/test/*.py\",\n            \"win32/test/win32rcparser/test.rc\",\n            \"win32/test/win32rcparser/test.h\",\n            \"win32/test/win32rcparser/python.ico\",\n            \"win32/test/win32rcparser/python.bmp\",\n            \"win32/Demos/*.py\",\n            \"win32/Demos/images/*.bmp\",\n            \"com/win32com/readme.html\",\n            # win32com test utility files.\n            \"com/win32com/test/*.idl\",\n            \"com/win32com/test/*.js\",\n            \"com/win32com/test/*.sct\",\n            \"com/win32com/test/*.txt\",\n            \"com/win32com/test/*.vbs\",\n            \"com/win32com/test/*.xsl\",\n            # win32com docs\n            \"com/win32com/HTML/*.html\",\n            \"com/win32com/HTML/image/*.gif\",\n            \"com/win32comext/adsi/demos/*.py\",\n            # Active Scripting test and demos.\n            \"com/win32comext/axscript/test/*.py\",\n            \"com/win32comext/axscript/test/*.pys\",\n            \"com/win32comext/axscript/test/*.vbs\",\n            \"com/win32comext/axscript/Demos/*.pys\",\n            \"com/win32comext/axscript/Demos/*.htm*\",\n            \"com/win32comext/axscript/Demos/*.gif\",\n            \"com/win32comext/axscript/Demos/*.asp\",\n            \"com/win32comext/mapi/demos/*.py\",\n            \"com/win32comext/propsys/test/*.py\",\n            \"com/win32comext/shell/test/*.py\",\n            \"com/win32comext/shell/demos/servers/*.py\",\n            \"com/win32comext/shell/demos/*.py\",\n            \"com/win32comext/taskscheduler/test/*.py\",\n            \"com/win32comext/ifilter/demo/*.py\",\n            \"com/win32comext/authorization/demos/*.py\",\n            \"com/win32comext/bits/test/*.py\",\n            \"isapi/*.txt\",\n            \"isapi/samples/*.py\",\n            \"isapi/samples/*.txt\",\n            \"isapi/doc/*.html\",\n            \"isapi/test/*.py\",\n            \"isapi/test/*.txt\",\n            \"adodbapi/*.txt\",\n            \"adodbapi/test/*.py\",\n            \"adodbapi/examples/*.py\",\n        ]\n    )\n    +\n    # The headers and .lib files\n    [\n        (\"win32/include\", (\"win32/src/PyWinTypes.h\",)),\n        (\n            \"win32com/include\",\n            (\n                \"com/win32com/src/include/PythonCOM.h\",\n                \"com/win32com/src/include/PythonCOMRegister.h\",\n                \"com/win32com/src/include/PythonCOMServer.h\",\n            ),\n        ),\n    ]\n    +\n    # And data files convert_data_files can't handle.\n    [\n        (\"win32com\", (\"com/License.txt\",)),\n        # pythoncom.py doesn't quite fit anywhere else.\n        # Note we don't get an auto .pyc - but who cares?\n        (\"\", (\"com/pythoncom.py\",)),\n        (\"\", (\"pywin32.pth\",)),\n    ],\n)\n\n# If we did any extension building, and report if we skipped any.\nif \"build_ext\" in dist.command_obj:\n    what_string = \"built\"\n    if \"install\" in dist.command_obj:  # just to be purdy\n        what_string += \"/installed\"\n    # Print the list of extension modules we skipped building.\n    excluded_extensions = dist.command_obj[\"build_ext\"].excluded_extensions\n    if excluded_extensions:\n        skip_whitelist = {\"exchange\", \"axdebug\"}\n        skipped_ex = []\n        print(\"*** NOTE: The following extensions were NOT %s:\" % what_string)\n        for ext, why in excluded_extensions:\n            print(f\" {ext.name}: {why}\")\n            if ext.name not in skip_whitelist:\n                skipped_ex.append(ext.name)\n        print(\"For more details on installing the correct libraries and headers,\")\n        print(\"please execute this script with no arguments (or see the docstring)\")\n        if skipped_ex:\n            print(\n                \"*** Non-zero exit status. Missing for complete release build: %s\"\n                % skipped_ex\n            )\n            sys.exit(1000 + len(skipped_ex))\n    else:\n        print(f\"All extension modules {what_string} OK\")\n"
        },
        {
          "name": "win32",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}