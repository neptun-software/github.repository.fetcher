{
  "metadata": {
    "timestamp": 1736566060197,
    "page": 46,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ggerganov/kbd-audio",
      "stars": 8588,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1064453125,
          "content": "build*/\nbuild-vars.h\ndata_original/*\nchal*\n.cache\n.DS_Store\n.ycm_extra_conf.py\n.clangd\ncompile_commands.json\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.072265625,
          "content": "[submodule \"imgui\"]\n\tpath = imgui\n\turl = https://github.com/ocornut/imgui\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 9.67578125,
          "content": "cmake_minimum_required (VERSION 2.8)\nproject (KBD-Audio)\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS \"on\")\n\n# options\n\noption(BUILD_EXPERIMENTAL \"Build experimental tools\" OFF)\noption(USE_FINDSDL2 \"Use the FindSDL2.cmake script\" OFF)\n\noption(KBD_AUDIO_SANITIZE_THREAD         \"kbd-audio: enable thread sanitizer\" OFF)\noption(KBD_AUDIO_SANITIZE_ADDRESS        \"kbd-audio: enable address sanitizer\" OFF)\noption(KBD_AUDIO_SANITIZE_UNDEFINED      \"kbd-audio: enable undefined sanitizer\" OFF)\n\n# sanitizers\n\nif (KBD_AUDIO_SANITIZE_THREAD)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fsanitize=thread\")\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=thread\")\nendif()\n\nif (KBD_AUDIO_SANITIZE_ADDRESS)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fsanitize=address -fno-omit-frame-pointer\")\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=address -fno-omit-frame-pointer\")\nendif()\n\nif (KBD_AUDIO_SANITIZE_UNDEFINED)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fsanitize=undefined\")\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=undefined\")\nendif()\n\n# sdl2\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)\nif (USE_FINDSDL2)\n    set(CMAKE_MODULE_PATH \"${CMAKE_MODULE_PATH};${CMAKE_CURRENT_SOURCE_DIR}/cmake/sdl2\")\nendif()\n\n# build types\n\ninclude(cmake/GitVars.cmake)\ninclude(cmake/BuildTypes.cmake)\n\nconfigure_file(${CMAKE_SOURCE_DIR}/build-vars.h.in ${CMAKE_SOURCE_DIR}/build-vars.h @ONLY)\n\n# warnings\n\nif (CMAKE_COMPILER_IS_GNUCC OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Wextra -pedantic\")\nendif()\n\nset (CMAKE_CXX_STANDARD 17)\nset (CMAKE_CXX_STANDARD_REQUIRED ON)\n\nif (EMSCRIPTEN)\n    set (CMAKE_CXX_FLAGS \" \\\n    -s USE_SDL=2 \\\n    -s USE_PTHREADS=1 \\\n    \")\n    #-s DISABLE_EXCEPTION_CATCHING=1 \\\n\n    set(CMAKE_EXE_LINKER_FLAGS \" \\\n    --bind \\\n    --use-preload-cache \\\n    -s ASSERTIONS=1 \\\n    -s NO_EXIT_RUNTIME=0 \\\n    -s PTHREAD_POOL_SIZE=16 \\\n    -s INITIAL_MEMORY=536870912 \\\n    \")\nelseif(MINGW)\n    find_package(PkgConfig REQUIRED)\n    pkg_search_module(SDL2 REQUIRED sdl2)\n\n    set(OPENGL_INCLUDE_DIR \"\")\n    set(OPENGL_LIBRARIES \"opengl32\")\nelse()\n    find_package(OpenGL REQUIRED)\n    find_package(SDL2)\n    find_package(FFTW)\nendif()\n\nfind_package(Threads REQUIRED)\n\nif (NOT USE_FINDSDL2 AND NOT SDL2_FOUND AND NOT EMSCRIPTEN)\n    message(WARNING \"Unable to find SDL2 library. It is either not installed or CMake cannot find it.\"\n        \" In the latter case, setting the USE_FINDSDL2 variable might help:\\n\"\n        \"   $ cmake -D USE_FINDSDL2 ..\"\n        )\n\n    message(FATAL_ERROR \"Aborting\")\nendif()\n\nif (NOT FFTW_FOUND)\n    message(WARNING \"FFTW library not available. Some targets will not be built\")\nendif()\n\nstring(STRIP \"${SDL2_LIBRARIES}\" SDL2_LIBRARIES)\n\nif (APPLE)\n    find_library(COREGRAPHICS_LIBRARY CoreGraphics )\n    find_library(COREFOUNDATION_LIBRARY CoreFoundation )\nelse (APPLE)\n    unset(COREGRAPHICS_LIBRARY)\n    unset(COREFOUNDATION_LIBRARY)\nendif (APPLE)\n\ninclude_directories(imgui)\ninclude_directories(imgui/examples)\ninclude_directories(imgui/examples/libs/gl3w)\ninclude_directories(${SDL2_INCLUDE_DIRS})\ninclude_directories(${OPENGL_INCLUDE_DIR})\n\nadd_library(Core STATIC\n    common.cpp\n    audio-logger.cpp\n    )\n\ntarget_include_directories(Core PRIVATE\n    )\n\ntarget_link_libraries(Core PRIVATE\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${SDL2_LIBRARIES}\n    ${COREFOUNDATION_LIBRARY}\n    )\n\n# todo : this is ugly, what's the proper way?\nif (MINGW)\n    target_link_libraries(Core PRIVATE stdc++)\nendif()\n\nif (EMSCRIPTEN)\n    add_library(Gui STATIC\n        common-gui.cpp\n        imgui/imgui.cpp\n        imgui/imgui_draw.cpp\n        imgui/imgui_demo.cpp\n        imgui/imgui_widgets.cpp\n        imgui/examples/imgui_impl_sdl.cpp\n        imgui/examples/imgui_impl_opengl3.cpp\n        )\n\n    target_compile_definitions(Gui PUBLIC\n        IMGUI_USER_CONFIG=\"../imconfig-vtx32.h\"\n        )\nelse()\n    add_library(Gui STATIC\n        common-gui.cpp\n        imgui/imgui.cpp\n        imgui/imgui_draw.cpp\n        imgui/imgui_demo.cpp\n        imgui/imgui_widgets.cpp\n        imgui/examples/libs/gl3w/GL/gl3w.c\n        imgui/examples/imgui_impl_sdl.cpp\n        imgui/examples/imgui_impl_opengl3.cpp\n        )\n\n    # force GL3W loader\n    target_compile_definitions(Gui PUBLIC\n        IMGUI_IMPL_OPENGL_LOADER_GL3W=1\n        IMGUI_USER_CONFIG=\"../imconfig-vtx32.h\"\n        )\n\n    target_link_libraries(Gui PRIVATE\n        ${CMAKE_DL_LIBS}\n        ${SDL2_LIBRARIES}\n        ${OPENGL_LIBRARIES}\n        ${COREFOUNDATION_LIBRARY}\n        )\nendif()\n\nadd_executable(keytap-gui keytap-gui.cpp)\ntarget_link_libraries(keytap-gui PRIVATE Core Gui)\n\nadd_executable(keytap2-gui keytap2-gui.cpp subbreak2.cpp)\ntarget_link_libraries(keytap2-gui PRIVATE Core Gui)\n\nadd_executable(keytap3-gui keytap3-gui.cpp subbreak3.cpp)\ntarget_link_libraries(keytap3-gui PRIVATE Core Gui)\n\nadd_executable(keytap3-app keytap3-app.cpp subbreak3.cpp)\ntarget_link_libraries(keytap3-app PRIVATE Core)\n\nadd_executable(view-full-gui view-full-gui.cpp)\ntarget_link_libraries(view-full-gui PRIVATE Core Gui)\n\nif (EMSCRIPTEN)\n    # view-full-gui\n    set(TARGET view-full-gui)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${TARGET})\n\n    set_target_properties(${TARGET} PROPERTIES LINK_FLAGS \" \\\n    -s TOTAL_MEMORY=536870912 \\\n    -s LZ4=1 \\\n    --preload-file ${PROJECT_SOURCE_DIR}/chal/record@/chal/record/ \\  \\\n    \")\n\n    ## keytap-gui\n    set(TARGET keytap-gui)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${TARGET})\n\n    set_target_properties(${TARGET} PROPERTIES LINK_FLAGS \" \\\n    -s TOTAL_MEMORY=536870912 \\\n    -s FORCE_FILESYSTEM=1 \\\n    \")\n\n    # keytap2-gui\n    set(TARGET keytap2-gui)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${TARGET})\n\n    set_target_properties(${TARGET} PROPERTIES LINK_FLAGS \" \\\n    -s TOTAL_MEMORY=536870912 \\\n    -s FORCE_FILESYSTEM=1 \\\n    -s LZ4=1 \\\n    --preload-file ${PROJECT_SOURCE_DIR}/data/@/data/ \\\n    \")\n\n    configure_file(${CMAKE_SOURCE_DIR}/index-${TARGET}-tmpl.html ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/index.html @ONLY)\n    configure_file(${CMAKE_SOURCE_DIR}/style.css ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/style.css @ONLY)\n\n    # keytap3-app\n    set(TARGET keytap3-app)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${TARGET})\n\n    set_target_properties(${TARGET} PROPERTIES LINK_FLAGS \" \\\n    -s FORCE_FILESYSTEM=1 \\\n    -s LZ4=1 \\\n    --preload-file ${PROJECT_SOURCE_DIR}/data/ggwords-6-gram.dat.binary@/data/ \\\n    \")\n\n    configure_file(${CMAKE_SOURCE_DIR}/index-${TARGET}-tmpl.html ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/index.html @ONLY)\n    configure_file(${CMAKE_SOURCE_DIR}/style.css ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/style.css @ONLY)\n\n    # keytap3-gui\n    set(TARGET keytap3-gui)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${TARGET})\n\n    set_target_properties(${TARGET} PROPERTIES LINK_FLAGS \" \\\n    -s TOTAL_MEMORY=536870912 \\\n    -s FORCE_FILESYSTEM=1 \\\n    -s LZ4=1 \\\n    --preload-file ${PROJECT_SOURCE_DIR}/data/ggwords-6-gram.dat.binary@/data/ \\\n    \")\n\n    configure_file(${CMAKE_SOURCE_DIR}/index-${TARGET}-tmpl.html ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/index.html @ONLY)\n    configure_file(${CMAKE_SOURCE_DIR}/style.css ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/style.css @ONLY)\nendif()\n\nif (NOT EMSCRIPTEN)\n    add_executable(key-detector key-detector.cpp)\n    target_link_libraries(key-detector PRIVATE Core)\n\n    add_executable(keytap keytap.cpp)\n    target_link_libraries(keytap PRIVATE Core)\n\n    add_executable(keytap2 keytap2.cpp)\n    target_link_libraries(keytap2 PRIVATE Core)\n\n    add_executable(keytap3 keytap3.cpp subbreak3.cpp)\n    target_link_libraries(keytap3 PRIVATE Core)\n\n    add_executable(play play.cpp)\n    target_link_libraries(play PRIVATE Core)\n\n    add_executable(play-full play-full.cpp)\n    target_link_libraries(play-full PRIVATE Core)\n\n    if (NOT MINGW)\n        # todo : need to find termios.h alternative for Windows\n        add_executable(record record.cpp)\n        target_link_libraries(record PRIVATE Core)\n    endif()\n\n    add_executable(record-full record-full.cpp)\n    target_link_libraries(record-full PRIVATE Core)\n\n    add_executable(view-gui view-gui.cpp)\n    target_link_libraries(view-gui PRIVATE Core Gui)\n\n    add_executable(compress-n-grams compress-n-grams.cpp subbreak3.cpp)\n    target_link_libraries(compress-n-grams PRIVATE Core)\n\n    #\n    ## Experimental stuff\n\n    if (BUILD_EXPERIMENTAL)\n        if (FFTW_FOUND)\n            add_executable(key-average-gui key-average-gui.cpp)\n            target_include_directories(key-average-gui PRIVATE ${FFTW_INCLUDE_DIRS})\n            target_link_libraries(key-average-gui PRIVATE Core Gui ${FFTW_LIBRARIES})\n        else()\n            message(WARNING \"Skipping 'key-average-gui' target because FFTW is not available\")\n        endif()\n\n        add_executable(keytap3-multi keytap3-multi.cpp subbreak3.cpp)\n        target_link_libraries(keytap3-multi PRIVATE Core)\n\n        add_executable(guess-qp guess-qp.cpp)\n        target_link_libraries(guess-qp PRIVATE Core)\n\n        add_executable(guess-qp2 guess-qp2.cpp)\n        target_link_libraries(guess-qp2 PRIVATE Core)\n\n        add_executable(scale scale.cpp)\n        target_link_libraries(scale PRIVATE Core)\n\n        add_executable(subbreak subbreak.cpp)\n        target_link_libraries(subbreak PRIVATE Core)\n\n        add_executable(non-exact-subbreak non-exact-subbreak.cpp subbreak2.cpp)\n        target_link_libraries(non-exact-subbreak PRIVATE Core)\n\n        add_executable(non-exact-subbreak2 non-exact-subbreak2.cpp subbreak2.cpp)\n        target_link_libraries(non-exact-subbreak2 PRIVATE Core)\n\n        add_executable(generate-clusters generate-clusters.cpp subbreak2.cpp)\n        target_link_libraries(generate-clusters PRIVATE Core)\n\n        add_executable(test-subbreak3 test-subbreak3.cpp subbreak3.cpp)\n        target_link_libraries(test-subbreak3 PRIVATE Core)\n    endif()\n\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2018 Georgi Gerganov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.341796875,
          "content": "kbd-audio\n=====\n[![Actions Status](https://github.com/ggerganov/kbd-audio/workflows/CI/badge.svg)](https://github.com/ggerganov/kbd-audio/actions)\n\nThis is a collection of command-line and GUI tools for capturing and analyzing audio data.\n\n### Keytap\n\nThe most interesting tool is called **keytap** - it can guess pressed keyboard keys only by analyzing the audio captured from the computer's microphone.\n\nCheck this blog post for more details:\n\n[Keytap: description and some random thoughts](https://ggerganov.github.io/jekyll/update/2018/11/30/keytap-description-and-thoughts.html)\n\n[Video: short demo of Keytap in action](https://www.youtube.com/watch?v=2OjzI9m7W10)\n\n[Try it online:](https://ggerganov.github.io/keytap)\n\n<a href=\"https://ggerganov.github.io/keytap\" target=\"_blank\"><img src=\"https://i.imgur.com/FXa60Pr.gif\" style=\"display: inline-block; overflow: hidden; width: 99%;\"></img></a>\n\n### Keytap2\n\nThe **keytap2** tool is another interesting tool for recovering text from audio. It does not require training data - instead it uses statistical information about the frequencies of the letters and n-grams in the English language.\n\nA more detailed description of the tool is available here: [Keytap2 discussion](https://github.com/ggerganov/kbd-audio/discussions/31)\n\n[Video: short demo of Keytap2 in action](https://www.youtube.com/watch?v=jNtw17S6SR0)\n\n[CTF: can you guess the text being typed?](https://ggerganov.github.io/keytap-challenge/)\n\n[Try it online:](https://keytap2.ggerganov.com)\n\n<a href=\"https://keytap2.ggerganov.com\" target=\"_blank\"><img src=\"https://i.imgur.com/nPlLEDN.jpg\" style=\"display: inline-block; overflow: hidden; width: 99%;\"></img></a>\n\n### Keytap3\n\nThis version introduces significant algorithm improvements and better n-gram statistics compared to keytap2. The attack is now fully\nautomated and does not require any manual intervation during the text recovery process.\n\n[Video: short demo of using Keytap3](https://youtu.be/5aphvxpSt3o)\n\n[Video: another example of using Keytap3](https://youtu.be/kCOrxrR-4ak)\n\n[GUI for Keytap3](https://keytap3-gui.ggerganov.com)\n\n[Check if your keyboard is vulnerable to Keytap:](https://keytap3.ggerganov.com)\n\n<a href=\"https://keytap3.ggerganov.com\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/1991296/166096331-ab26f7f8-08e0-48d6-abd7-57017ebf1866.JPEG\" style=\"display: inline-block; overflow: hidden; width: 99%;\"></img></a>\n\n### What people say about Keytap\n\n*\"This works incredibly well.\\\nI hope you realize what you've created (and made available to every person in the world).\"* -- ffpip\n\n*\"I just tried it and it works incredibly well. It kind of makes me want to stop using a mechanical keyboard.\"* -- Karawebnetwork\n\n*\"This attack and Van Eck phreaking are why Edward Snowden, while typing passwords and other sensitive information, would pull a blanket over himself and his laptop.\"* -- aarchi\n\n*\"This is what mechanical keyboard users deserve\"* -- super guy\n\n*\"fuck..\"* -- Lluis Franco\n\n## Build instructions\n\nDependencies:\n\n - **SDL2** - used to capture audio and to open GUI windows [libsdl](https://www.libsdl.org)\n\n       [Ubuntu]\n       $ sudo apt install libsdl2-dev\n\n       [Mac OS with brew]\n       $ brew install sdl2\n\n       [MSYS2]\n       $ pacman -S git cmake make mingw-w64-x86_64-dlfcn mingw-w64-x86_64-gcc mingw-w64-x86_64-SDL2\n\n - **FFTW3** *(optional)* - some of the helper tools perform Fourier transformations [fftw](http://www.fftw.org)\n\n**Linux, FreeBSD, Mac OS, Windows (MSYS2 + MinGW)**\n\n    git clone https://github.com/ggerganov/kbd-audio\n    cd kbd-audio\n    git submodule update --init\n    mkdir build && cd build\n    cmake ..\n    make\n\n## Tools\n\nShort summary of the available tools. If the status of the tool is not **stable**, expect problems and non-optimal results.\n\n| Name                | Type    | Status      |\n| ---                 | ---     | ---         |\n| **record**          | text    | **stable**  |\n| **record-full**     | text    | **stable**  |\n| **play**            | text    | **stable**  |\n| **play-full**       | text    | **stable**  |\n| **view-gui**        | gui     | **stable**  |\n| **view-full-gui**   | gui     | **stable**  |\n| **key-detector**    | text    | **stable**  |\n| **keytap**          | text    | **stable**  |\n| **keytap-gui**      | gui     | **stable**  |\n| **keytap2-gui**     | gui     | **stable**  |\n| **keytap3**         | text    | **stable**  |\n| **keytap3-gui**     | gui     | **stable**  |\n| -                   | *extra* | -           |\n| **guess-qp**        | text    | experiment  |\n| **guess-qp2**       | text    | experiment  |\n| **keytap3-multi**   | text    | experiment  |\n| **scale**           | text    | experiment  |\n| **subreak**         | text    | experiment  |\n| **key-average-gui** | gui     | experiment  |\n| **keytap2**         | text    | experiment  |\n\n## Tool details\n\n* **record-full**\n\n  Record audio to a raw binary file on disk\n\n      ./record-full output.kbd [-cN]\n\n  ---\n\n* **play-full**\n\n  Playback a recording captured via the **record-full** tool\n\n      ./play-full input.kbd [-pN]\n\n  ---\n\n* **record**\n\n  Record audio only while typing. Useful for collecting training data for **keytap**\n\n      ./record output.kbd [-cN] [-CN]\n\n  ---\n\n* **play**\n\n  Playback a recording created via the **record** tool\n\n      ./play input.kbd [-pN]\n\n  ---\n\n* **keytap**\n\n  Detect pressed keys via microphone audio capture in real-time. Uses training data captured via the **record** tool.\n\n      ./keytap input0.kbd [input1.kbd] [input2.kbd] ... [-cN] [-CN] [-pF] [-tF]\n\n  ---\n\n* **keytap-gui**\n\n  Detect pressed keys via microphone audio capture in real-time. Uses training data captured via the **record** tool. GUI version.\n\n      ./keytap-gui input0.kbd [input1.kbd] [input2.kbd] ... [-cN] [-CN]\n\n  Online demo: https://keytap.ggerganov.com\n\n  ---\n\n* **keytap2-gui** record.kbd n-gram-dir [-pN] [-cN] [-CN]\n\n  Detect pressed keys via microphone audio capture. Uses statistical information (n-gram frequencies) about the language. **No training data is required**. The *'record.kbd'* input file has to be generated via the **record-full** tool and contains the audio data that will be analyzed. The *'n-gram-dir'* folder file has to contain n-gram probability files for the corresponding language.\n\n      ./keytap2-gui record.kbd ../data\n\n  Online demo: https://keytap2.ggerganov.com\n\n  ---\n\n* **keytap3**\n\n  Fully automated recovery of unknown text from audio recordings.\n\n      ./keytap3 input.kbd ../data [-cN] [-CN] [-pF] [-tF] [-FN] [-fN]\n\n  Online demo: https://keytap3.ggerganov.com\n\n  ---\n\n* **keytap3-gui**\n\n  GUI version of the **keytap3** tool.\n\n      ./keytap3-gui input.kbd ../data [-cN] [-CN] [-pF] [-tF] [-FN] [-fN]\n\n  Online demo: https://keytap3-gui.ggerganov.com\n\n  ---\n\n* **view-full-gui**\n\n  Visualize waveforms recorded with the **record-full** tool. Can also playback the audio data.\n\n      ./view-full-gui input.kbd [-pN]\n\n  <a href=\"https://i.imgur.com/scjTaXw.png\" target=\"_blank\">![view-full-gui](https://i.imgur.com/scjTaXw.png)</a>\n\n  ---\n\n* **view-gui**\n\n  Visualize training data recorded with the **record** tool. Can also playback the audio data.\n\n      ./view-gui input.kbd [-pN]\n\n  <a href=\"https://i.imgur.com/2binGaZ.png\" target=\"_blank\">![view-full-gui](https://i.imgur.com/2binGaZ.png)</a>\n\n  ---\n\n## Feedback\n\nAny feedback about the performance of the tools is highly appreciated. Please drop a comment [here](https://github.com/ggerganov/kbd-audio/issues/3).\n"
        },
        {
          "name": "audio-logger.cpp",
          "type": "blob",
          "size": 9.658203125,
          "content": "/*! \\file audio-logger.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"audio-logger.h\"\n\n#include <SDL.h>\n#include <SDL_audio.h>\n\n#include <mutex>\n#include <atomic>\n#include <algorithm>\n\nnamespace {\n    void cbAudioReady(void * userData, uint8_t * stream, int32_t /*nbytes*/) {\n        AudioLogger * logger = (AudioLogger *)(userData);\n        logger->addFrame((AudioLogger::Sample *)(stream));\n    }\n}\n\nstruct AudioLogger::Data {\n    Data() : isReady(false) {\n        for (auto & frame : buffer) {\n            frame.fill(0);\n        }\n\n        for (auto & record : records) {\n            record.clear();\n        }\n\n        nFramesToRecord.fill(0);\n    }\n\n    SDL_AudioDeviceID deviceIdIn = 0;\n    //SDL_AudioDeviceID deviceIdOut = 0;\n\n    int32_t sampleSize_bytes = -1;\n\n    int32_t bufferId = 0;\n    std::array<Frame, getBufferSize_frames(kMaxSampleRate, kMaxBufferSize_s)> buffer;\n\n    int32_t nRecords = 0;\n    std::array<int32_t, kMaxRecords> nFramesToRecord;\n    std::array<Record, kMaxRecords> records;\n\n    Parameters parameters;\n    TFilterCoefficients filterCoefficients;\n\n    std::mutex mutex;\n    std::atomic_bool isReady;\n};\n\nAudioLogger::AudioLogger() : data_(new AudioLogger::Data()) {}\n\nAudioLogger::~AudioLogger() {}\n\nbool AudioLogger::install(Parameters && parameters) {\n    auto & data = getData();\n\n    if (parameters.captureId < 0) {\n        fprintf(stderr, \"error : invalid captureId = %d\\n\", parameters.captureId);\n        return false;\n    }\n\n    if (parameters.nChannels < 0) {\n        fprintf(stderr, \"error : invalid nChannels = %d\\n\", parameters.nChannels);\n        return false;\n    }\n\n    if (parameters.sampleRate <= 0) {\n        fprintf(stderr, \"error : invalid sampleRate = %d\\n\", (int) parameters.sampleRate);\n        return false;\n    }\n\n    if (parameters.freqCutoff_Hz <= 0) {\n        fprintf(stderr, \"error : invalid freqCutoff_Hz = %g\\n\", parameters.freqCutoff_Hz);\n        return false;\n    }\n\n    static bool isInitialized = false;\n    if (!isInitialized && SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return false;\n    }\n    isInitialized = true;\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_TRUE);\n    printf(\"Found %d capture devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Capture device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_TRUE));\n    }\n\n    if (parameters.captureId < 0 || parameters.captureId >= nDevices) {\n        fprintf(stderr, \"error : invalid capture device id selected - %d\\n\", parameters.captureId);\n        return false;\n    }\n\n    SDL_AudioSpec captureSpec;\n    SDL_zero(captureSpec);\n\n    captureSpec.freq = parameters.sampleRate;\n    captureSpec.format = AUDIO_F32SYS;\n    captureSpec.channels = parameters.nChannels;\n    captureSpec.samples = kSamplesPerFrame;\n    captureSpec.callback = ::cbAudioReady;\n    captureSpec.userdata = this;\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    printf(\"Attempt to open capture device %d : '%s' ...\\n\", parameters.captureId, SDL_GetAudioDeviceName(parameters.captureId, SDL_TRUE));\n    data.deviceIdIn = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(parameters.captureId, SDL_TRUE), SDL_TRUE, &captureSpec, &obtainedSpec, SDL_AUDIO_ALLOW_CHANNELS_CHANGE);\n    if (!data.deviceIdIn) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for capture: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return false;\n    }\n\n    switch (obtainedSpec.format) {\n        case AUDIO_U8:\n        case AUDIO_S8:\n        case AUDIO_U16SYS:\n        case AUDIO_S16SYS:\n        case AUDIO_S32SYS:\n            {\n                fprintf(stderr, \"error : unsupported sample format %d\\n\", obtainedSpec.format);\n                return false;\n            }\n            break;\n        case AUDIO_F32SYS:\n            {\n                data.sampleSize_bytes = 4;\n            }\n            break;\n    }\n\n    printf(\"Opened capture device succesfully!\\n\");\n    printf(\"    DeviceId:   %d\\n\", data.deviceIdIn);\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d (%d bytes)\\n\", obtainedSpec.format, data.sampleSize_bytes);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    if (obtainedSpec.channels != parameters.nChannels && parameters.nChannels != 0) {\n        printf(\"Warning: obtained number of channels (%d) does not match requested (%d)\\n\",\n               obtainedSpec.channels, parameters.nChannels);\n    }\n\n    SDL_PauseAudioDevice(data.deviceIdIn, 0);\n\n    parameters.nChannels = obtainedSpec.channels;\n\n    switch (parameters.filter) {\n        case EAudioFilter::None:\n            {\n            }\n            break;\n        case EAudioFilter::FirstOrderHighPass:\n            {\n                data.filterCoefficients = ::calculateCoefficientsFirstOrderHighPass(parameters.freqCutoff_Hz, parameters.sampleRate);\n            }\n            break;\n        case EAudioFilter::SecondOrderButterworthHighPass:\n            {\n                data.filterCoefficients = ::calculateCoefficientsSecondOrderButterworthHighPass(parameters.freqCutoff_Hz, parameters.sampleRate);\n            }\n            break;\n    };\n\n    data.parameters = parameters;\n    data.isReady = true;\n\n    // print filter paramters\n    printf(\"    Audio Filter: %d\\n\", parameters.filter);\n    printf(\"    Cutoff frequency: %g Hz\\n\", parameters.freqCutoff_Hz);\n    printf(\"Capturing audio ..\\n\");\n\n    return true;\n}\n\nbool AudioLogger::terminate() {\n    auto & data = getData();\n\n    SDL_PauseAudioDevice(data.deviceIdIn, 1);\n    SDL_CloseAudioDevice(data.deviceIdIn);\n\n    return true;\n}\n\nbool AudioLogger::addFrame(const Sample * stream) {\n    auto & data = getData();\n\n    if (data.isReady == false) return false;\n\n\tif (SDL_GetQueuedAudioSize(data.deviceIdIn) > 32*sizeof(float)*kSamplesPerFrame) {\n\t\tprintf(\"Queue size: %d\\n\", SDL_GetQueuedAudioSize(data.deviceIdIn));\n\t\tSDL_ClearQueuedAudio(data.deviceIdIn);\n\t}\n\n    const float norm = 1.0/data.parameters.nChannels;\n\n    auto & curFrame = data.buffer[data.bufferId];\n\n    for (int i = 0; i < kSamplesPerFrame; ++i) {\n        Sample x = 0;\n        for (int j = 0; j < data.parameters.nChannels; ++j) {\n            x += stream[i*data.parameters.nChannels + j];\n        }\n        curFrame[i] = x*norm;\n    }\n\n    switch (data.parameters.filter) {\n        case EAudioFilter::None:\n            {\n            }\n            break;\n        case EAudioFilter::FirstOrderHighPass:\n            {\n                for (auto & s : curFrame) {\n                    s = ::filterFirstOrderHighPass(data.filterCoefficients, s);\n                }\n            }\n            break;\n        case EAudioFilter::SecondOrderButterworthHighPass:\n            {\n                for (auto & s : curFrame) {\n                    s = ::filterSecondOrderButterworthHighPass(data.filterCoefficients, s);\n                }\n            }\n            break;\n    }\n\n    std::lock_guard<std::mutex> lock(data.mutex);\n\n    for (int r = 0; r < data.nRecords; ++r) {\n        auto & record = data.records[r];\n        auto & nFramesToRecord = data.nFramesToRecord[r];\n\n        if (nFramesToRecord > 0) {\n            record.push_back(curFrame);\n            if (--nFramesToRecord == 0) {\n                if (data.parameters.callback) data.parameters.callback(record);\n                record.clear();\n\n                for (int k = r + 1; k < data.nRecords; ++k) {\n                    data.records[k - 1] = std::move(data.records[k]);\n                    data.nFramesToRecord[k - 1] = data.nFramesToRecord[k];\n                }\n                --data.nRecords;\n                --r;\n            }\n        }\n    }\n\n    if (++data.bufferId >= (int) data.buffer.size()) {\n        data.bufferId = 0;\n    }\n\n    return true;\n}\n\nbool AudioLogger::record(float bufferSize_s, int32_t nPrevFrames) {\n    auto & data = getData();\n\n    if (isValidBufferSize(bufferSize_s) == false) {\n        return false;\n    }\n\n    auto bufferSize_frames = getBufferSize_frames(data.parameters.sampleRate, bufferSize_s);\n\n    if (nPrevFrames >= bufferSize_frames) {\n        fprintf(stderr, \"warning : invalid previous frames in record requested - %d. max allowed is %d s\\n\", nPrevFrames, bufferSize_frames - 1);\n        return false;\n    }\n\n    std::lock_guard<std::mutex> lock(data.mutex);\n\n    if (data.nRecords == kMaxRecords) {\n        fprintf(stderr, \"warning : max number of simultaneous records %d reached\\n\", kMaxRecords);\n        return false;\n    }\n\n    auto & record = data.records[data.nRecords];\n\n    if (record.size() == 0) {\n        int fStart = data.bufferId - nPrevFrames;\n        if (fStart < 0) fStart += data.buffer.size();\n        for (int i = 0; i < nPrevFrames; ++i) {\n            record.push_back(data.buffer[(fStart + i)%data.buffer.size()]);\n        }\n    } else {\n        fprintf(stderr, \"warning : new record requested before last has been processed. should never happen\\n\");\n    }\n\n    data.nFramesToRecord[data.nRecords] = bufferSize_frames - nPrevFrames;\n\n    ++data.nRecords;\n\n    return true;\n}\n\nbool AudioLogger::pause() {\n    auto & data = getData();\n    SDL_PauseAudioDevice(data.deviceIdIn, 1);\n    data.nFramesToRecord.fill(0);\n\n    return true;\n}\n\nbool AudioLogger::resume() {\n    auto & data = getData();\n    SDL_PauseAudioDevice(data.deviceIdIn, 0);\n    return true;\n}\n\nbool AudioLogger::isValidBufferSize(float bufferSize_s) const {\n    if (bufferSize_s <= 0) {\n        fprintf(stderr, \"error : invalid bufferSize_s = %g\\n\", bufferSize_s);\n        return false;\n    }\n\n    if (bufferSize_s > kMaxBufferSize_s) {\n        fprintf(stderr, \"error : invalid record size requested - %g s. max allowed is %g s\\n\", bufferSize_s, kMaxBufferSize_s);\n        return false;\n    }\n\n    return true;\n}\n"
        },
        {
          "name": "audio-logger.h",
          "type": "blob",
          "size": 1.556640625,
          "content": "/*! \\file audio-logger.h\n *  \\brief Audio capture helper class\n *\n *  Used by all kbd-audio tools.\n *  It provides a stream of captured audio via a provided callback.\n *\n *  \\author Georgi Gerganov\n */\n\n#pragma once\n\n#include \"constants.h\"\n#include \"common.h\"\n\n#include <memory>\n#include <array>\n#include <vector>\n#include <functional>\n\nclass AudioLogger {\n    public:\n        using Sample = TSampleF;\n\n        using Frame = std::array<Sample, kSamplesPerFrame>;\n        using Record = std::vector<Frame>;\n        using Callback = std::function<void(const Record & frames)>;\n\n        struct Parameters {\n            Callback callback;\n\n            int32_t captureId = -1;\n            int32_t nChannels = -1;\n\n            int64_t sampleRate = -1;\n\n            // Sample Type\n\n            // todo : support for other sample types\n            enum ESampleType {\n                F32SYS,\n            };\n\n            ESampleType sampleType = F32SYS;\n\n            // Audio Filter\n\n            EAudioFilter filter = FirstOrderHighPass;\n\n            float freqCutoff_Hz = 1000.0f;\n        };\n\n        AudioLogger();\n        ~AudioLogger();\n\n        bool install(Parameters && parameters);\n        bool terminate();\n        bool addFrame(const Sample * stream);\n        bool record(float bufferSize_s, int32_t nPrevFrames);\n\n        bool pause();\n        bool resume();\n\n        bool isValidBufferSize(float bufferSize_s) const;\n\n    private:\n        struct Data;\n        std::unique_ptr<Data> data_;\n        Data & getData() { return *data_; }\n        const Data & getData() const { return *data_; }\n};\n"
        },
        {
          "name": "build-em",
          "type": "tree",
          "content": null
        },
        {
          "name": "build-vars.h.in",
          "type": "blob",
          "size": 0.1474609375,
          "content": "#pragma once\n\nconst char * kGIT_SHA1 = \"@GIT_SHA1@\";\nconst char * kGIT_DATE = \"@GIT_DATE@\";\nconst char * kGIT_COMMIT_SUBJECT = \"@GIT_COMMIT_SUBJECT@\";\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "common-gui.cpp",
          "type": "blob",
          "size": 8.2392578125,
          "content": "/*! \\file common-gui.cpp\n *  \\brief Enter description here.\n */\n\n#include \"common-gui.h\"\n\n#ifdef __EMSCRIPTEN__\n#include \"emscripten.h\"\n#define IMGUI_IMPL_OPENGL_LOADER_GLEW\n#endif\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W)\n#include <GL/gl3w.h>    // Initialize with gl3wInit()\n#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW)\n#include <GL/glew.h>    // Initialize with glewInit()\n#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD)\n#include <glad/glad.h>  // Initialize with gladLoadGL()\n#else\n#include IMGUI_IMPL_OPENGL_LOADER_CUSTOM\n#endif\n\nnamespace Gui {\n\nbool init(const char * windowTitle, int windowSizeX, int windowSizeY, Objects & objects) {\n#if __APPLE__\n    // GL 3.2 Core + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#elif __EMSCRIPTEN__\n    const char* glsl_version = \"#version 100\";\n    //const char* glsl_version = \"#version 300 es\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#endif\n\n    // Create window with graphics context\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_DisplayMode current;\n    SDL_GetCurrentDisplayMode(0, &current);\n\n#ifdef __EMSCRIPTEN__\n    SDL_Renderer *renderer;\n    SDL_CreateWindowAndRenderer(windowSizeX, windowSizeY, SDL_WINDOW_OPENGL, &objects.window, &renderer);\n#else\n    objects.window = SDL_CreateWindow(windowTitle, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, windowSizeX, windowSizeY, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE|SDL_WINDOW_ALLOW_HIGHDPI);\n#endif\n\n    objects.gl_context = SDL_GL_CreateContext(objects.window);\n    SDL_GL_MakeCurrent(objects.window, objects.gl_context);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Initialize OpenGL loader\n#if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W)\n    bool err = gl3wInit() != 0;\n#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW)\n    bool err = glewInit() != GLEW_OK;\n#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD)\n    bool err = gladLoadGL() == 0;\n#else\n    bool err = false; // If you use IMGUI_IMPL_OPENGL_LOADER_CUSTOM, your loader is likely to requires some form of initialization.\n#endif\n    if (err) {\n        fprintf(stderr, \"Failed to initialize OpenGL loader!\\n\");\n        return false;\n    }\n\n    // Setup Dear ImGui binding\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;  // Enable Keyboard Controls\n\n    ImGuiStyle & style = ImGui::GetStyle();\n\n    style.AntiAliasedFill = false;\n    style.AntiAliasedLines = false;\n    style.WindowRounding = 0.0f;\n\n    style.WindowPadding = ImVec2(8, 8);\n    style.WindowRounding = 0.0f;\n    style.FramePadding = ImVec2(4, 3);\n    style.FrameRounding = 0.0f;\n    style.ItemSpacing = ImVec2(8, 4);\n    style.ItemInnerSpacing = ImVec2(4, 4);\n    style.IndentSpacing = 21.0f;\n    style.ScrollbarSize = 16.0f;\n    style.ScrollbarRounding = 9.0f;\n    style.GrabMinSize = 10.0f;\n    style.GrabRounding = 3.0f;\n\n    style.Colors[ImGuiCol_Text]                  = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    style.Colors[ImGuiCol_TextDisabled]          = ImVec4(0.24f, 0.41f, 0.41f, 1.00f);\n    style.Colors[ImGuiCol_WindowBg]              = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);\n    //style.Colors[ImGuiCol_ChildWindowBg]         = ImVec4(0.07f, 0.07f, 0.09f, 1.00f);\n    style.Colors[ImGuiCol_PopupBg]               = ImVec4(0.07f, 0.07f, 0.09f, 1.00f);\n    style.Colors[ImGuiCol_Border]                = ImVec4(0.31f, 0.31f, 0.31f, 0.71f);\n    style.Colors[ImGuiCol_BorderShadow]          = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    style.Colors[ImGuiCol_FrameBg]               = ImVec4(0.00f, 0.39f, 0.39f, 0.39f);\n    style.Colors[ImGuiCol_FrameBgHovered]        = ImVec4(0.26f, 1.00f, 1.00f, 0.39f);\n    style.Colors[ImGuiCol_FrameBgActive]         = ImVec4(0.00f, 0.78f, 0.00f, 1.00f);\n    style.Colors[ImGuiCol_TitleBg]               = ImVec4(0.00f, 0.50f, 0.50f, 0.70f);\n    style.Colors[ImGuiCol_TitleBgCollapsed]      = ImVec4(0.00f, 0.50f, 0.50f, 1.00f);\n    style.Colors[ImGuiCol_TitleBgActive]         = ImVec4(0.00f, 0.70f, 0.70f, 1.00f);\n    style.Colors[ImGuiCol_MenuBarBg]             = ImVec4(0.00f, 0.70f, 0.70f, 1.00f);\n    style.Colors[ImGuiCol_ScrollbarBg]           = ImVec4(0.10f, 0.27f, 0.27f, 1.00f);\n    style.Colors[ImGuiCol_ScrollbarGrab]         = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);\n    style.Colors[ImGuiCol_ScrollbarGrabHovered]  = ImVec4(0.26f, 1.00f, 1.00f, 0.39f);\n    style.Colors[ImGuiCol_ScrollbarGrabActive]   = ImVec4(0.00f, 0.78f, 0.00f, 1.00f);\n    //style.Colors[ImGuiCol_ComboBg]               = ImVec4(0.00f, 0.39f, 0.39f, 1.00f);\n    style.Colors[ImGuiCol_CheckMark]             = ImVec4(0.80f, 0.80f, 0.83f, 0.39f);\n    style.Colors[ImGuiCol_SliderGrab]            = ImVec4(0.80f, 0.80f, 0.83f, 0.39f);\n    style.Colors[ImGuiCol_SliderGrabActive]      = ImVec4(0.00f, 0.78f, 0.00f, 1.00f);\n    style.Colors[ImGuiCol_Button]                = ImVec4(0.13f, 0.55f, 0.55f, 1.00f);\n    style.Colors[ImGuiCol_ButtonHovered]         = ImVec4(0.61f, 1.00f, 0.00f, 0.51f);\n    style.Colors[ImGuiCol_ButtonActive]          = ImVec4(0.00f, 0.78f, 0.00f, 1.00f);\n    style.Colors[ImGuiCol_Header]                = ImVec4(0.79f, 0.51f, 0.00f, 0.51f);\n    style.Colors[ImGuiCol_HeaderHovered]         = ImVec4(0.79f, 0.51f, 0.00f, 0.67f);\n    style.Colors[ImGuiCol_HeaderActive]          = ImVec4(0.79f, 0.51f, 0.00f, 0.67f);\n    //style.Colors[ImGuiCol_Column]                = ImVec4(0.79f, 0.51f, 0.00f, 0.67f);\n    //style.Colors[ImGuiCol_ColumnHovered]         = ImVec4(0.25f, 1.00f, 0.00f, 1.00f);\n    //style.Colors[ImGuiCol_ColumnActive]          = ImVec4(0.79f, 0.51f, 0.00f, 0.67f);\n    style.Colors[ImGuiCol_ResizeGrip]            = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    style.Colors[ImGuiCol_ResizeGripHovered]     = ImVec4(0.26f, 1.00f, 1.00f, 0.39f);\n    style.Colors[ImGuiCol_ResizeGripActive]      = ImVec4(0.00f, 0.78f, 0.00f, 1.00f);\n    //style.Colors[ImGuiCol_CloseButton]           = ImVec4(0.40f, 0.39f, 0.38f, 0.16f);\n    //style.Colors[ImGuiCol_CloseButtonHovered]    = ImVec4(0.26f, 1.00f, 1.00f, 0.39f);\n    //style.Colors[ImGuiCol_CloseButtonActive]     = ImVec4(0.79f, 0.51f, 0.00f, 0.67f);\n    style.Colors[ImGuiCol_PlotLines]             = ImVec4(1.00f, 0.65f, 0.38f, 0.67f);\n    style.Colors[ImGuiCol_PlotLinesHovered]      = ImVec4(0.25f, 1.00f, 0.00f, 1.00f);\n    style.Colors[ImGuiCol_PlotHistogram]         = ImVec4(1.00f, 0.65f, 0.38f, 0.67f);\n    style.Colors[ImGuiCol_PlotHistogramHovered]  = ImVec4(0.25f, 1.00f, 0.00f, 1.00f);\n    style.Colors[ImGuiCol_TextSelectedBg]        = ImVec4(0.25f, 1.00f, 0.00f, 0.43f);\n    style.Colors[ImGuiCol_ModalWindowDarkening]  = ImVec4(1.00f, 0.98f, 0.95f, 0.78f);\n\n    ImGui_ImplSDL2_InitForOpenGL(objects.window, objects.gl_context);\n    ImGui_ImplOpenGL3_Init(glsl_version);\n\n    return true;\n}\n\nbool render(const Objects & objects) {\n    ImGui::Render();\n    SDL_GL_MakeCurrent(objects.window, objects.gl_context);\n    glViewport(0, 0, (int) ImGui::GetIO().DisplaySize.x, (int) ImGui::GetIO().DisplaySize.y);\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n    SDL_GL_SwapWindow(objects.window);\n\n    return true;\n}\n\nbool free(const Objects & objects) {\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplSDL2_Shutdown();\n    ImGui::DestroyContext();\n\n    SDL_GL_DeleteContext(objects.gl_context);\n    SDL_DestroyWindow(objects.window);\n    SDL_Quit();\n\n    return true;\n}\n\n}\n"
        },
        {
          "name": "common-gui.h",
          "type": "blob",
          "size": 0.384765625,
          "content": "/*! \\file common-gui.h\n *  \\brief Enter description here.\n */\n\n#pragma once\n\n#include \"common.h\"\n\n#include <SDL.h>\n\nnamespace Gui {\nstruct Objects {\n    SDL_Window * window = nullptr;\n    SDL_GLContext gl_context = nullptr;\n};\n\nbool init(const char * windowTitle, int windowSizeX, int windowSizeY, Objects & objects);\nbool render(const Objects & objects);\nbool free(const Objects & objects);\n}\n"
        },
        {
          "name": "common.cpp",
          "type": "blob",
          "size": 34.5615234375,
          "content": "/*! \\file common.cpp\n *  \\brief Enter description here.\n */\n\n#include \"common.h\"\n#include \"constants.h\"\n\n#include <cstring>\n#include <cmath>\n#include <thread>\n#include <mutex>\n#include <fstream>\n#include <deque>\n#include <algorithm>\n\n#ifndef pi\n#define  pi 3.1415926535897932384626433832795\n#endif\n\n#ifndef sqrt2\n#define sqrt2 (2.0 * 0.707106781186547524401)\n#endif\n\n#ifndef sqrt2over2\n#define  sqrt2over2  0.707106781186547524401\n#endif\n\nnamespace {\ntemplate <typename TSampleInput, typename TSample>\n    bool readWaveform(std::ifstream & fin, TWaveformT<TSample> & res, int32_t offset, std::streamsize size) {\n        if (std::is_same<TSample, TSampleI16>::value) {\n            std::vector<TSampleInput> buf(size/sizeof(TSampleInput));\n            res.resize(offset + size/sizeof(TSampleInput));\n            fin.read((char *)(buf.data()), size);\n            double amax = calcAbsMax(buf);\n            double iamax = amax != 0.0 ? 1.0/amax : 1.0;\n            for (auto i = 0; i < (int) buf.size(); ++i) res[offset + i] = std::round(std::numeric_limits<TSampleI16>::max()*(buf[i]*iamax));\n        } else if (std::is_same<TSample, TSampleF>::value) {\n            res.resize(offset + size/sizeof(TSample));\n            fin.read((char *)(res.data() + offset), size);\n        } else {\n            return false;\n        }\n        return true;\n    }\n}\n\nconstexpr float iRAND_MAX = 1.0f/float(RAND_MAX);\nfloat frand() { return ((float)rand())*iRAND_MAX; }\n\nfloat frandGaussian(float mu, float sigma) {\n\tstatic const float two_pi = 2.0*3.14159265358979323846;\n\n\tthread_local float z1;\n\tthread_local bool generate;\n\tgenerate = !generate;\n\n\tif (!generate)\n\t   return z1 * sigma + mu;\n\n\tfloat u1 = frand();\n    float u2 = frand();\n\n    float t = sqrt(-2.0f * log(1.0f - u1));\n\n\tfloat z0 = t*cos(two_pi*u2);\n\tz1 = t*sin(two_pi*u2);\n\n\treturn z0 * sigma + mu;\n}\n\nuint64_t t_ms() {\n    return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count(); // duh ..\n}\n\nstd::map<std::string, std::string> parseCmdArguments(int argc, char ** argv) {\n    int last = argc;\n    std::map<std::string, std::string> res;\n    for (int i = 1; i < last; ++i) {\n        if (argv[i][0] == '-') {\n            if (strlen(argv[i]) > 1) {\n                res[std::string(1, argv[i][1])] = strlen(argv[i]) > 2 ? argv[i] + 2 : \"\";\n            }\n        }\n    }\n\n    return res;\n}\n\ntemplate <typename TSampleSrc, typename TSampleDst>\nbool convert(const TWaveformT<TSampleSrc> & src, TWaveformT<TSampleDst> & dst) {\n    static_assert(std::is_same<TSampleSrc, TSampleDst>::value == false, \"Required different sample types\");\n\n    static_assert(std::is_same<TSampleSrc, TSampleF>::value, \"Source sample type not supported\");\n    static_assert(std::is_same<TSampleDst, TSampleI16>::value, \"Destination sample type not supported\");\n\n    dst.resize(src.size());\n\n    double amax = calcAbsMax(src);\n    double iamax = amax != 0.0 ? 1.0/amax : 1.0;\n    for (auto i = 0; i < (int) src.size(); ++i) dst[i] = std::round(std::numeric_limits<TSampleDst>::max()*(src[i]*iamax));\n\n    return true;\n}\n\ntemplate bool convert<TSampleF, TSampleI16>(const TWaveformT<TSampleF> & src, TWaveformT<TSampleI16> & dst);\n\ntemplate <typename TSample>\nvoid filter(TWaveformT<TSample> & waveform, EAudioFilter filterId, float freqCutoff_Hz, int64_t sampleRate) {\n    switch (filterId) {\n        case EAudioFilter::None:\n            {\n                return;\n            }\n            break;\n        case EAudioFilter::FirstOrderHighPass:\n            {\n                auto filterCoefficients = ::calculateCoefficientsFirstOrderHighPass(freqCutoff_Hz, sampleRate);\n                for (auto & s : waveform) {\n                    s = ::filterFirstOrderHighPass(filterCoefficients, s);\n                }\n                return;\n            }\n            break;\n        case EAudioFilter::SecondOrderButterworthHighPass:\n            {\n                auto filterCoefficients = ::calculateCoefficientsSecondOrderButterworthHighPass(freqCutoff_Hz, sampleRate);\n                for (auto & s : waveform) {\n                    s = ::filterSecondOrderButterworthHighPass(filterCoefficients, s);\n                }\n                return;\n            }\n            break;\n    }\n\n    fprintf(stderr, \"Unknown filter type: %d\\n\", filterId);\n}\n\ntemplate void filter<TSampleF>(TWaveformT<TSampleF> & waveform, EAudioFilter filterId, float freqCutoff_Hz, int64_t sampleRate);\n\ntemplate <typename TSample>\ndouble calcAbsMax(const TWaveformT<TSample> & waveform) {\n    double amax = 0.0f;\n    for (auto i = 0; i < (int) waveform.size(); ++i) if (std::abs(waveform[i]) > amax) amax = std::abs(waveform[i]);\n\n    return amax;\n}\n\ntemplate double calcAbsMax<TSampleF>(const TWaveformT<TSampleF> & waveform);\n\ntemplate <typename TSample>\nbool saveToFile(const std::string & fname, TWaveformT<TSample> & waveform) {\n    static_assert(std::is_same<TSample, TSampleF>::value, \"Sample type not supported\");\n\n    std::ofstream fout(fname, std::ios::binary);\n    if (fout.good() == false) {\n        return false;\n    }\n\n    auto totalSize_bytes = sizeof(TSample)*waveform.size();\n\n    fout.write((char *)(waveform.data()), totalSize_bytes);\n    fout.close();\n\n    printf(\"Total data saved: %g MB\\n\", ((float)(totalSize_bytes)/1024.0f/1024.0f));\n\n    return true;\n}\n\ntemplate bool saveToFile<TSampleF>(const std::string & fname, TWaveformT<TSampleF> & waveform);\n\ntemplate <typename TSampleInput, typename TSample>\nbool readFromFile(const std::string & fname, TWaveformT<TSample> & res) {\n    std::ifstream fin(fname, std::ios::binary | std::ios::ate);\n    if (fin.good() == false) {\n        return false;\n    }\n\n    {\n        std::streamsize size = fin.tellg();\n        fin.seekg(0, std::ios::beg);\n\n        static_assert(std::is_same<TSampleInput, TSampleF>::value, \"TSampleInput not supported\");\n        static_assert(std::is_same<TSample, TSampleF>::value ||\n                      std::is_same<TSample, TSampleI16>::value, \"TSample not supported\");\n\n        if (readWaveform<TSampleInput>(fin, res, 0, size) == false) {\n            return false;\n        }\n    }\n\n    fin.close();\n\n    return true;\n}\n\ntemplate bool readFromFile<TSampleF, TSampleI16>(const std::string & fname, TWaveformT<TSampleI16> & res);\ntemplate bool readFromFile<TSampleF, TSampleF>(const std::string & fname, TWaveformT<TSampleF> & res);\n\ntemplate <typename TSampleInput, typename TSample>\nbool readFromFile(const std::string & fname, TWaveformT<TSample> & res, TTrainKeys & trainKeys, int32_t & bufferSize_frames) {\n    trainKeys.clear();\n\n    std::ifstream fin(fname, std::ios::binary);\n    if (fin.good() == false) {\n        return false;\n    }\n\n    bufferSize_frames = 1;\n    fin.read((char *)(&bufferSize_frames), sizeof(bufferSize_frames));\n\n    {\n        static_assert(std::is_same<TSampleInput, TSampleF>::value, \"TSampleInput not supported\");\n        static_assert(std::is_same<TSample, TSampleF>::value ||\n                      std::is_same<TSample, TSampleI16>::value, \"TSample not supported\");\n\n        int32_t offset = 0;\n        std::streamsize size = bufferSize_frames*kSamplesPerFrame*sizeof(TSampleInput);\n        while (true) {\n            TKey keyPressed = 0;\n            fin.read((char *)(&keyPressed), sizeof(keyPressed));\n            if (fin.eof()) break;\n            trainKeys.push_back(keyPressed);\n\n            if (readWaveform<TSampleInput>(fin, res, offset, size) == false) {\n                return false;\n            }\n\n            offset += size/sizeof(TSampleInput);\n            if (fin.eof()) break;\n        }\n    }\n\n    fin.close();\n\n    return true;\n}\n\ntemplate bool readFromFile<TSampleF, TSampleI16>(const std::string & fname, TWaveformT<TSampleI16> & res, TTrainKeys & trainKeys, int32_t & bufferSize_frames);\n\n//\n// filters\n//\n\nTFilterCoefficients calculateCoefficientsFirstOrderHighPass(int fc, int fs) {\n    TFilterCoefficients res;\n\n    float th = 2.0 * pi * fc / fs;\n    float g = cos(th) / (1.0 + sin(th));\n    res.a0 = (1.0 + g) / 2.0;\n    res.a1 = -((1.0 + g) / 2.0);\n    res.a2 = 0.0;\n    res.b1 = -g;\n    res.b2 = 0.0;\n\n    return res;\n}\n\nTFilterCoefficients calculateCoefficientsSecondOrderButterworthHighPass(int fc, int fs) {\n    TFilterCoefficients res;\n\n    float c = tan(pi*fc / fs);\n    res.a0 = 1.0 / (1.0 + sqrt2*c + pow(c, 2.0));\n    res.a1 = -2.0 * res.a0;\n    res.a2 = res.a0;\n    res.b1 = 2.0 * res.a0*(pow(c, 2.0) - 1.0);\n    res.b2 = res.a0 * (1.0 - sqrt2*c + pow(c, 2.0));\n\n    return res;\n}\n\nTSampleF filterFirstOrderHighPass(TFilterCoefficients & coefficients, TSampleF sample) {\n    TSampleF xn = sample;\n    TSampleF yn =\n        coefficients.a0*xn + coefficients.a1*coefficients.xnz1 + coefficients.a2*coefficients.xnz2 -\n                             coefficients.b1*coefficients.ynz1 - coefficients.b2*coefficients.ynz2;\n\n    coefficients.xnz2 = coefficients.xnz1;\n    coefficients.xnz1 = xn;\n    coefficients.ynz2 = coefficients.ynz1;\n    coefficients.ynz1 = yn;\n\n    return yn;\n}\n\nTSampleF filterSecondOrderButterworthHighPass(TFilterCoefficients & coefficients, TSampleF sample) {\n    TSampleF xn = sample;\n    TSampleF yn =\n        coefficients.a0*xn + coefficients.a1*coefficients.xnz1 + coefficients.a2*coefficients.xnz2 -\n                             coefficients.b1*coefficients.ynz1 - coefficients.b2*coefficients.ynz2;\n\n    coefficients.xnz2 = coefficients.xnz1;\n    coefficients.xnz1 = xn;\n    coefficients.ynz2 = coefficients.ynz1;\n    coefficients.ynz1 = yn;\n\n    return yn;\n}\n\n//\n// calcCC\n//\n\nstd::tuple<double, double> calcSum(const TKeyWaveformF & waveform, int is0, int is1) {\n    double sum = 0.0f;\n    double sum2 = 0.0f;\n    for (int is = is0; is < is1; ++is) {\n        auto a0 = waveform[is];\n        sum += a0;\n        sum2 += a0*a0;\n    }\n\n    return std::tuple<double, double>(sum, sum2);\n}\n\ntemplate<>\nstd::tuple<int64_t, int64_t> calcSum(const TWaveformViewT<TSampleMI16> & waveform) {\n    int64_t sum = 0;\n    int64_t sum2 = 0;\n\n    auto samples = waveform.samples;\n    auto n       = waveform.n;\n\n    for (int is = 0; is < n; ++is) {\n        for (int j = 0; j < TSampleMI16::N; j++) {\n            int32_t a0 = samples[is][j];\n            sum += a0;\n            sum2 += a0*a0;\n        }\n    }\n\n    return std::tuple<int64_t, int64_t>(sum, sum2);\n}\n\ntemplate<typename T>\nstd::tuple<int64_t, int64_t> calcSum(const TWaveformViewT<T> & waveform) {\n    int64_t sum = 0;\n    int64_t sum2 = 0;\n\n    auto samples = waveform.samples;\n    auto n       = waveform.n;\n\n    for (int is = 0; is < n; ++is) {\n        int32_t a0 = samples[is];\n        sum += a0;\n        sum2 += a0*a0;\n    }\n\n    return std::tuple<int64_t, int64_t>(sum, sum2);\n}\n\n// calcSum : specializations\n\ntemplate std::tuple<int64_t, int64_t> calcSum<TSampleI16>(const TWaveformViewT<TSampleI16> & waveform);\n\n//\n// calcCC\n//\n\nTValueCC calcCC(\n    const TKeyWaveformF & waveform0,\n    const TKeyWaveformF & waveform1,\n    double sum0, double sum02,\n    int is00, int is0, int is1) {\n    TValueCC cc = -1.0f;\n\n    double sum1 = 0.0f;\n    double sum12 = 0.0f;\n    double sum01 = 0.0f;\n    for (int is = 0; is < is1 - is0; ++is) {\n        auto a0 = waveform0[is00 + is];\n        auto a1 = waveform1[is0 + is];\n\n#ifdef MY_DEBUG\n        if (is00 + is < 0 || is00 + is >= waveform0.size()) printf(\"BUG 0\\n\");\n        if (is0 + is < 0 || is0 + is >= waveform1.size()) {\n            printf(\"BUG 1\\n\");\n            printf(\"%d %d %d\\n\", is0, is, (int) waveform1.size());\n        }\n#endif\n\n        sum1 += a1;\n        sum12 += a1*a1;\n        sum01 += a0*a1;\n    }\n\n    int ncc = (is1 - is0);\n    {\n        double nom = sum01*ncc - sum0*sum1;\n        double den2a = sum02*ncc - sum0*sum0;\n        double den2b = sum12*ncc - sum1*sum1;\n        cc = (nom)/(sqrt(den2a*den2b));\n    }\n\n    return cc;\n}\n\ntemplate<>\nTValueCC calcCC(\n    const TWaveformViewT<TSampleMI16> & waveform0,\n    const TWaveformViewT<TSampleMI16> & waveform1,\n    int64_t sum0, int64_t sum02) {\n    TValueCC cc = -1.0f;\n\n    int64_t sum1 = 0;\n    int64_t sum12 = 0;\n    int64_t sum01 = 0;\n\n    auto samples0 = waveform0.samples;\n    auto n0       = waveform0.n;\n\n    auto samples1 = waveform1.samples;\n    auto n1       = waveform1.n;\n\n#ifdef MY_DEBUG\n    if (n0 != n1) {\n        printf(\"BUG 234f8273\\n\");\n    }\n#endif\n    auto n = std::min(n0, n1);\n\n    for (int64_t is = 0; is < n; ++is) {\n        for (int j = 0; j < TSampleMI16::N; j++) {\n            int32_t a0 = samples0[is][j];\n            int32_t a1 = samples1[is][j];\n\n            sum1 += a1;\n            sum12 += a1*a1;\n            sum01 += a0*a1;\n        }\n    }\n\n    n *= TSampleMI16::N;\n\n    {\n        double nom   = sum01*n - sum0*sum1;\n        double den2a = sum02*n - sum0*sum0;\n        double den2b = sum12*n - sum1*sum1;\n        cc = (nom)/(sqrt(den2a*den2b));\n    }\n\n    return cc;\n}\n\ntemplate<typename T>\nTValueCC calcCC(\n    const TWaveformViewT<T> & waveform0,\n    const TWaveformViewT<T> & waveform1,\n    int64_t sum0, int64_t sum02) {\n    TValueCC cc = -1.0f;\n\n    int64_t sum1 = 0;\n    int64_t sum12 = 0;\n    int64_t sum01 = 0;\n\n    auto samples0 = waveform0.samples;\n    auto n0       = waveform0.n;\n\n    auto samples1 = waveform1.samples;\n    auto n1       = waveform1.n;\n\n#ifdef MY_DEBUG\n    if (n0 != n1) {\n        printf(\"BUG 234f8273\\n\");\n    }\n#endif\n    auto n = std::min(n0, n1);\n\n    for (int64_t is = 0; is < n; ++is) {\n        int32_t a0 = samples0[is];\n        int32_t a1 = samples1[is];\n\n        sum1 += a1;\n        sum12 += a1*a1;\n        sum01 += a0*a1;\n    }\n\n    {\n        double nom = sum01*n - sum0*sum1;\n        double den2a = sum02*n - sum0*sum0;\n        double den2b = sum12*n - sum1*sum1;\n        cc = (nom)/(sqrt(den2a*den2b));\n    }\n\n    return cc;\n}\n\n// calcCC : specializations\n\ntemplate TValueCC calcCC<TSampleI16>(\n    const TWaveformViewT<TSampleI16> & waveform0,\n    const TWaveformViewT<TSampleI16> & waveform1,\n    int64_t sum0, int64_t sum02);\n\n//\n// findBestCC\n//\n\nstd::tuple<TValueCC, TOffset> findBestCC(\n    const TKeyWaveformF & waveform0,\n    const TKeyWaveformF & waveform1,\n    int is0, int is1,\n    int alignWindow) {\n    TOffset besto = -1;\n    TValueCC bestcc = -1.0f;\n\n    int is00 = waveform0.size()/2 - (is1 - is0)/2;\n    auto ret = calcSum(waveform0, is00, is00 + is1 - is0);\n    auto sum0  = std::get<0>(ret);\n    auto sum02 = std::get<1>(ret);\n\n#ifdef __EMSCRIPTEN__\n    int nWorkers = std::min(4, std::max(1, int(std::thread::hardware_concurrency()) - 2));\n#else\n    int nWorkers = std::min(4u, std::thread::hardware_concurrency());\n    std::mutex mutex;\n    std::vector<std::thread> workers(nWorkers);\n    for (int i = 0; i < (int) workers.size(); ++i) {\n        auto & worker = workers[i];\n        worker = std::thread([&, sum0 = sum0, sum02 = sum02, i]() {\n            TOffset cbesto = -1;\n            TValueCC cbestcc = -1.0f;\n\n            for (int o = -alignWindow + i; o <= alignWindow; o += nWorkers) {\n                auto cc = calcCC(waveform0, waveform1, sum0, sum02, is00, is0 + o, is1 + o);\n                if (cc > cbestcc) {\n                    cbesto = o;\n                    cbestcc = cc;\n                }\n            }\n\n            {\n                std::lock_guard<std::mutex> lock(mutex);\n                if (cbestcc > bestcc) {\n                    bestcc = cbestcc;\n                    besto = cbesto;\n                }\n            }\n        });\n    }\n    for (auto & worker : workers) worker.join();\n#endif\n\n    return std::tuple<TValueCC, TOffset>(bestcc, besto);\n}\n\ntemplate<typename T>\nstd::tuple<TValueCC, TOffset> findBestCC(\n    const TWaveformViewT<T> & waveform0,\n    const TWaveformViewT<T> & waveform1,\n    int64_t alignWindow) {\n    TValueCC bestcc = -1.0;\n    TOffset besto = -1;\n\n    //auto samples0 = waveform0.samples;\n    auto n0       = waveform0.n;\n\n    auto samples1 = waveform1.samples;\n\n#ifdef MY_DEBUG\n    auto n1 = waveform1.n;\n    if (n0 + 2*alignWindow != n1) {\n        printf(\"BUG 924830jm92, n0 = %d, a = %d\\n\", (int) n0, (int) alignWindow);\n    }\n#endif\n\n    auto ret = calcSum(waveform0);\n    auto sum0  = std::get<0>(ret);\n    auto sum02 = std::get<1>(ret);\n\n    for (int o = 0; o <= 2*alignWindow; ++o) {\n        auto cc = calcCC(waveform0, { samples1 + o, n0 }, sum0, sum02);\n        if (cc > bestcc) {\n            besto = o - alignWindow;\n            bestcc = cc;\n        }\n    }\n\n    return std::tuple<TValueCC, TOffset>(bestcc, besto);\n}\n\n// findBestCC : specializations\n\ntemplate std::tuple<TValueCC, TOffset> findBestCC<TSampleI16>(\n    const TWaveformViewT<TSampleI16> & waveform0,\n    const TWaveformViewT<TSampleI16> & waveform1,\n    int64_t alignWindow);\n\n//\n// calculateSimilarityMap\n//\n\ntemplate<>\nbool calculateSimilartyMap(\n        const int32_t keyPressWidth_samples,\n        const int32_t alignWindow_samples,\n        const int32_t offsetFromPeak_samples,\n        TKeyPressCollectionT<TSampleMI16> & keyPresses,\n        TSimilarityMap & res) {\n    int nPresses = keyPresses.size();\n\n    int w = keyPressWidth_samples;\n    int a = alignWindow_samples;\n\n    res.clear();\n    res.resize(nPresses);\n    for (auto & x : res) x.resize(nPresses);\n\n#ifdef __EMSCRIPTEN__\n    int nWorkers = std::min(kMaxThreads, std::max(1, int(std::thread::hardware_concurrency()) - 2));\n#else\n    int nWorkers = std::thread::hardware_concurrency();\n#endif\n\n    std::vector<std::thread> workers(nWorkers);\n    for (int iw = 0; iw < (int) workers.size(); ++iw) {\n        auto & worker = workers[iw];\n        worker = std::thread([&](int ith) {\n            for (int i = ith; i < nPresses; i += nWorkers) {\n                res[i][i].cc = 1.0f;\n                res[i][i].offset = 0;\n\n                const auto & waveform0 = keyPresses[i].waveform;\n                const auto & pos0      = keyPresses[i].pos;\n\n                auto & avgcc = keyPresses[i].ccAvg;\n\n                const auto samples0 = waveform0.samples;\n\n                for (int j = i + 1; j < nPresses; ++j) {\n                    if (i == j) continue;\n\n                    const auto waveform1 = keyPresses[j].waveform;\n                    const auto pos1      = keyPresses[j].pos;\n\n                    const auto samples1 = waveform1.samples;\n                    const auto ret = findBestCC(TWaveformViewT<TSampleMI16> { samples0 + pos0 + offsetFromPeak_samples - w,     2*w },\n                                                TWaveformViewT<TSampleMI16> { samples1 + pos1 + offsetFromPeak_samples - w - a, 2*w + 2*a }, a);\n\n                    const auto bestcc     = std::get<0>(ret);\n                    const auto bestoffset = std::get<1>(ret);\n\n                    res[i][j].cc = bestcc;\n                    res[i][j].offset = bestoffset;\n\n                    res[j][i].cc = bestcc;\n                    res[j][i].offset = -bestoffset;\n\n                    avgcc += bestcc;\n                }\n                avgcc /= (nPresses - 1);\n            }\n        }, iw);\n    }\n\n    for (auto & worker : workers) worker.join();\n\n    return true;\n}\n\ntemplate<typename T>\nbool calculateSimilartyMap(\n        const int32_t keyPressWidth_samples,\n        const int32_t alignWindow_samples,\n        const int32_t offsetFromPeak_samples,\n        TKeyPressCollectionT<T> & keyPresses,\n        TSimilarityMap & res) {\n    int nPresses = keyPresses.size();\n\n    int w = keyPressWidth_samples;\n    int a = alignWindow_samples;\n\n    res.clear();\n    res.resize(nPresses);\n    for (auto & x : res) x.resize(nPresses);\n\n#ifdef __EMSCRIPTEN__\n    int nWorkers = std::min(kMaxThreads, std::max(1, int(std::thread::hardware_concurrency()) - 2));\n#else\n    int nWorkers = std::thread::hardware_concurrency();\n#endif\n\n    std::vector<std::thread> workers(nWorkers);\n    for (int iw = 0; iw < (int) workers.size(); ++iw) {\n        auto & worker = workers[iw];\n        worker = std::thread([&](int ith) {\n            for (int i = ith; i < nPresses; i += nWorkers) {\n                res[i][i].cc = 1.0f;\n                res[i][i].offset = 0;\n\n                const auto & waveform0 = keyPresses[i].waveform;\n                const auto & pos0      = keyPresses[i].pos;\n\n                auto & avgcc = keyPresses[i].ccAvg;\n\n                const auto samples0 = waveform0.samples;\n\n                for (int j = i + 1; j < nPresses; ++j) {\n                    if (i == j) continue;\n\n                    const auto waveform1 = keyPresses[j].waveform;\n                    const auto pos1      = keyPresses[j].pos;\n\n                    const auto samples1 = waveform1.samples;\n                    const auto ret = findBestCC(TWaveformViewT<T> { samples0 + pos0 + offsetFromPeak_samples - w,     2*w },\n                                                TWaveformViewT<T> { samples1 + pos1 + offsetFromPeak_samples - w - a, 2*w + 2*a }, a);\n\n                    const auto bestcc     = std::get<0>(ret);\n                    const auto bestoffset = std::get<1>(ret);\n\n                    res[i][j].cc = bestcc;\n                    res[i][j].offset = bestoffset;\n\n                    res[j][i].cc = bestcc;\n                    res[j][i].offset = -bestoffset;\n\n                    avgcc += bestcc;\n                }\n                avgcc /= (nPresses - 1);\n            }\n        }, iw);\n    }\n\n    for (auto & worker : workers) worker.join();\n\n    return true;\n}\n\ntemplate bool calculateSimilartyMap<TSampleI16>(\n        const int32_t keyPressWidth_samples,\n        const int32_t alignWindow_samples,\n        const int32_t offsetFromPeak_samples,\n        TKeyPressCollectionT<TSampleI16> & keyPresses,\n        TSimilarityMap & res);\n\n//\n// findKeyPresses\n//\n\ntemplate<>\nbool findKeyPresses(\n        const TWaveformViewT<TSampleMI16> & waveform,\n        TKeyPressCollectionT<TSampleMI16> & res,\n        TWaveformT<TSampleMI16> & waveformThreshold,\n        TWaveformT<TSampleMI16> & waveformMax,\n        double thresholdBackground,\n        int historySize,\n        int historySizeReset,\n        bool removeLowPower) {\n    res.clear();\n    waveformThreshold.resize(waveform.n);\n    waveformMax.resize(waveform.n);\n\n    int rbBegin = 0;\n    double rbAverage = 0.0;\n    std::vector<double> rbSamples(8*historySize, 0.0);\n\n    int k = historySize;\n    std::deque<int64_t> que(k);\n\n    auto samples = waveform.samples;\n    auto n       = waveform.n;\n\n    TWaveformT<TSampleMI16> waveformAbs(n);\n    for (int64_t i = 0; i < n; ++i) {\n        waveformAbs[i][0] = std::abs(samples[i][0]);\n    }\n\n    for (int64_t i = 0; i < n; ++i) {\n        {\n            int64_t ii = i - k/2;\n            if (ii >= 0) {\n                rbAverage *= rbSamples.size();\n                rbAverage -= rbSamples[rbBegin];\n                double acur = waveformAbs[i][0];\n                rbSamples[rbBegin] = acur;\n                rbAverage += acur;\n                rbAverage /= rbSamples.size();\n                if (++rbBegin >= (int) rbSamples.size()) {\n                    rbBegin = 0;\n                }\n            }\n        }\n\n        if (i < k) {\n            while((!que.empty()) && waveformAbs[i] >= waveformAbs[que.back()]) {\n                que.pop_back();\n            }\n            que.push_back(i);\n        } else {\n            while((!que.empty()) && que.front() <= i - k) {\n                que.pop_front();\n            }\n\n            while((!que.empty()) && waveformAbs[i] >= waveformAbs[que.back()]) {\n                que.pop_back();\n            }\n\n            que.push_back(i);\n\n            int64_t itest = i - k/2;\n            if (itest >= 2*k && itest < n - 2*k && que.front() == itest) {\n                double acur = waveformAbs[itest][0];\n                if (acur > thresholdBackground*rbAverage) {\n                    res.emplace_back(TKeyPressDataT<TSampleMI16> { std::move(waveform), itest, 0.0, -1, -1, '?' });\n                }\n            }\n            waveformThreshold[itest][0] = thresholdBackground*rbAverage;\n            waveformMax[itest] = waveformAbs[que.front()];\n        }\n    }\n\n    if (removeLowPower) {\n        while (true) {\n            auto oldn = res.size();\n\n            double avgPower = 0.0;\n            for (const auto & kp : res) {\n                avgPower += waveformAbs[kp.pos][0];\n            }\n            avgPower /= res.size();\n\n            auto tmp = std::move(res);\n            for (const auto & kp : tmp) {\n                if (waveformAbs[kp.pos][0] > 0.3*avgPower) {\n                    res.push_back(kp);\n                }\n            }\n\n            if (res.size() == oldn) break;\n        }\n    }\n\n    if (res.size() > 1) {\n        TKeyPressCollectionT<TSampleMI16> res2;\n        res2.push_back(res.front());\n\n        for (int i = 1; i < (int) res.size(); ++i) {\n            if (res[i].pos - res2.back().pos > historySizeReset || waveformMax[res[i].pos] > waveformMax[res2.back().pos]) {\n                res2.push_back(res[i]);\n            }\n        }\n\n        std::swap(res, res2);\n    }\n\n    return true;\n}\n\ntemplate<typename T>\nbool findKeyPresses(\n        const TWaveformViewT<T> & waveform,\n        TKeyPressCollectionT<T> & res,\n        TWaveformT<T> & waveformThreshold,\n        TWaveformT<T> & waveformMax,\n        double thresholdBackground,\n        int historySize,\n        int historySizeReset,\n        bool removeLowPower) {\n    res.clear();\n    waveformThreshold.resize(waveform.n);\n    waveformMax.resize(waveform.n);\n\n    int rbBegin = 0;\n    double rbAverage = 0.0;\n    std::vector<double> rbSamples(8*historySize, 0.0);\n\n    int k = historySize;\n    std::deque<int64_t> que(k);\n\n    auto samples = waveform.samples;\n    auto n       = waveform.n;\n\n    TWaveformT<T> waveformAbs(n);\n    for (int64_t i = 0; i < n; ++i) {\n        waveformAbs[i] = std::abs(samples[i]);\n    }\n\n    for (int64_t i = 0; i < n; ++i) {\n        {\n            int64_t ii = i - k/2;\n            if (ii >= 0) {\n                rbAverage *= rbSamples.size();\n                rbAverage -= rbSamples[rbBegin];\n                double acur = waveformAbs[i];\n                rbSamples[rbBegin] = acur;\n                rbAverage += acur;\n                rbAverage /= rbSamples.size();\n                if (++rbBegin >= (int) rbSamples.size()) {\n                    rbBegin = 0;\n                }\n            }\n        }\n\n        if (i < k) {\n            while((!que.empty()) && waveformAbs[i] >= waveformAbs[que.back()]) {\n                que.pop_back();\n            }\n            que.push_back(i);\n        } else {\n            while((!que.empty()) && que.front() <= i - k) {\n                que.pop_front();\n            }\n\n            while((!que.empty()) && waveformAbs[i] >= waveformAbs[que.back()]) {\n                que.pop_back();\n            }\n\n            que.push_back(i);\n\n            int64_t itest = i - k/2;\n            if (itest >= 2*k && itest < n - 2*k && que.front() == itest) {\n                double acur = waveformAbs[itest];\n                if (acur > thresholdBackground*rbAverage) {\n                    res.emplace_back(TKeyPressDataT<T> { std::move(waveform), itest, 0.0, -1, -1, '?' });\n                }\n            }\n            waveformThreshold[itest] = thresholdBackground*rbAverage;\n            waveformMax[itest] = waveformAbs[que.front()];\n        }\n    }\n\n    if (removeLowPower) {\n        while (true) {\n            auto oldn = res.size();\n\n            double avgPower = 0.0;\n            for (const auto & kp : res) {\n                avgPower += waveformAbs[kp.pos];\n            }\n            avgPower /= res.size();\n\n            auto tmp = std::move(res);\n            for (const auto & kp : tmp) {\n                if (waveformAbs[kp.pos] > 0.3*avgPower) {\n                    res.push_back(kp);\n                }\n            }\n\n            if (res.size() == oldn) break;\n        }\n    }\n\n    if (res.size() > 1) {\n        TKeyPressCollectionT<T> res2;\n        res2.push_back(res.front());\n\n        for (int i = 1; i < (int) res.size(); ++i) {\n            if (res[i].pos - res2.back().pos > historySizeReset || waveformMax[res[i].pos] > waveformMax[res2.back().pos]) {\n                res2.push_back(res[i]);\n            }\n        }\n\n        std::swap(res, res2);\n    }\n\n    return true;\n}\n\ntemplate bool findKeyPresses<TSampleI16>(\n        const TWaveformViewT<TSampleI16> & waveform,\n        TKeyPressCollectionT<TSampleI16> & res,\n        TWaveformT<TSampleI16> & waveformThreshold,\n        TWaveformT<TSampleI16> & waveformMax,\n        double thresholdBackground,\n        int historySize,\n        int historySizeReset,\n        bool removeLowPower);\n\ntemplate<typename T>\nbool saveKeyPresses(const std::string & fname, const TKeyPressCollectionT<T> & keyPresses) {\n    std::ofstream fout(fname, std::ios::binary);\n    int n = keyPresses.size();\n    fout.write((char *)(&n), sizeof(n));\n    for (int i = 0; i < n; ++i) {\n        fout.write((char *)(&keyPresses[i].pos), sizeof(keyPresses[i].pos));\n    }\n    fout.close();\n\n    return true;\n}\n\ntemplate bool saveKeyPresses<TSampleI16>(const std::string & fname, const TKeyPressCollectionT<TSampleI16> & keyPresses);\n\ntemplate<typename T>\nbool loadKeyPresses(const std::string & fname, const TWaveformViewT<T> & waveform, TKeyPressCollectionT<T> & keyPresses) {\n    keyPresses.clear();\n\n    std::ifstream fin(fname, std::ios::binary);\n    int n = 0;\n    fin.read((char *)(&n), sizeof(n));\n    keyPresses.resize(n);\n    for (int i = 0; i < n; ++i) {\n        keyPresses[i].waveform = waveform;\n        fin.read((char *)(&keyPresses[i].pos), sizeof(keyPresses[i].pos));\n    }\n    fin.close();\n\n    return true;\n}\n\ntemplate bool loadKeyPresses<TSampleI16>(const std::string & fname, const TWaveformViewT<TSampleI16> & waveform, TKeyPressCollectionT<TSampleI16> & keyPresses);\n\ntemplate<typename T>\nbool dumpKeyPresses(const std::string & fname, const TKeyPressCollectionT<T> & data) {\n    std::ofstream fout(fname);\n    for (auto & k : data) {\n        fout << k.pos << \" 1\" << std::endl;\n    }\n    fout.close();\n    return true;\n}\n\ntemplate bool dumpKeyPresses<TSampleI16>(const std::string & fname, const TKeyPressCollectionT<TSampleI16> & data);\n\ntemplate<typename TSample>\nvoid cbPlayback(void * userData, uint8_t * stream, int len) {\n    TPlaybackDataT<TSample> * data = (TPlaybackDataT<TSample> *)(userData);\n    if (data->playing == false) {\n        int offset = 0;\n        TSample a = 0;\n        while (len > 0) {\n            memcpy(stream + offset*sizeof(a), &a, sizeof(a));\n            len -= sizeof(a);\n            ++offset;\n        }\n        return;\n    }\n    auto end = std::min(data->idx + TPlaybackDataT<TSample>::kSamples/data->slowDown, data->waveform.n);\n    auto idx = data->idx;\n    auto sidx = 0;\n    for (; idx < end; ++idx) {\n        TSample a = data->waveform.samples[idx];\n        memcpy(stream + (sidx)*sizeof(a), &a, sizeof(a));\n        len -= sizeof(a);\n        ++sidx;\n\n        if (data->slowDown == 2) {\n            TSample a2 = data->waveform.samples[idx + 1];\n            a = 0.5*a + 0.5*a2;\n            memcpy(stream + (sidx)*sizeof(a), &a, sizeof(a));\n            len -= sizeof(a);\n            ++sidx;\n        }\n    }\n    while (len > 0) {\n        TSample a = 0;\n        memcpy(stream + (idx - data->idx)*sizeof(a), &a, sizeof(a));\n        len -= sizeof(a);\n        ++idx;\n    }\n    data->idx = idx;\n}\n\ntemplate void cbPlayback<TSampleI16>(void * userData, uint8_t * stream, int len);\n\ntemplate<typename T>\nbool generateLowResWaveform(const TWaveformViewT<T> & waveform, TWaveformT<T> & waveformLowRes, int nWindow) {\n    waveformLowRes.resize(waveform.n);\n\n    int k = nWindow;\n    std::deque<int64_t> que(k);\n\n    //auto [samples, n] = waveform;\n    auto samples = waveform.samples;\n    auto n       = waveform.n;\n\n    TWaveformT<T> waveformAbs(n);\n    for (int64_t i = 0; i < n; ++i) {\n        waveformAbs[i] = std::abs(samples[i]);\n    }\n\n    for (int64_t i = 0; i < n; ++i) {\n        if (i < k) {\n            while((!que.empty()) && waveformAbs[i] >= waveformAbs[que.back()]) {\n                que.pop_back();\n            }\n            que.push_back(i);\n        } else {\n            while((!que.empty()) && que.front() <= i - k) {\n                que.pop_front();\n            }\n\n            while((!que.empty()) && waveformAbs[i] >= waveformAbs[que.back()]) {\n                que.pop_back();\n            }\n\n            que.push_back(i);\n\n            int64_t itest = i - k/2;\n            waveformLowRes[itest] = waveformAbs[que.front()];\n        }\n    }\n\n    return true;\n}\n\ntemplate bool generateLowResWaveform<TSampleI16>(const TWaveformViewT<TSampleI16> & waveform, TWaveformT<TSampleI16> & waveformLowRes, int nWindow);\n\ntemplate<typename T>\nbool adjustKeyPresses(TKeyPressCollectionT<T> & keyPresses, TSimilarityMap & sim) {\n    struct Pair {\n        int i = -1;\n        int j = -1;\n        TValueCC cc = -1.0;\n\n        bool operator < (const Pair & a) const { return cc > a.cc; }\n    };\n\n    bool res = false;\n\n    int n = keyPresses.size();\n\n    std::vector<Pair> ccpairs;\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ccpairs.emplace_back(Pair{i, j, sim[i][j].cc});\n        }\n    }\n\n    int nused = 0;\n    std::vector<bool> used(n, false);\n\n    std::sort(ccpairs.begin(), ccpairs.end());\n\n    int npairs = ccpairs.size();\n    for (int ip = 0; ip < npairs; ++ip) {\n        auto & curpair = ccpairs[ip];\n        int k0 = curpair.i;\n        int k1 = curpair.j;\n        if (used[k0] && used[k1]) continue;\n\n        if (sim[k0][k1].offset != 0) res = true;\n\n        if (used[k1] == false) {\n            keyPresses[k1].pos += sim[k0][k1].offset;\n        } else {\n            keyPresses[k0].pos -= sim[k0][k1].offset;\n        }\n\n        sim[k0][k1].offset = 0;\n        sim[k1][k0].offset = 0;\n\n        if (used[k0] == false) { used[k0] = true; ++nused; }\n        if (used[k1] == false) { used[k1] = true; ++nused; }\n\n        if (nused == n) break;\n    }\n\n    return res;\n}\n\ntemplate bool adjustKeyPresses<TSampleI16>(TKeyPressCollectionT<TSampleI16> & keyPresses, TSimilarityMap & sim);\n\n\ntemplate<typename T>\nbool removeLowSimilarityKeys(TKeyPressCollectionT<T> & keyPresses, TSimilarityMap & sim, double threshold) {\n    const int n = keyPresses.size();\n    if (n != (int) sim.size()) {\n        fprintf(stderr, \"removeLowSimilarityKeys: n != sim.size()\\n\");\n        return false;\n    }\n\n    std::vector<bool> used(n, false);\n\n    for (int i = 0; i < n; ++i) {\n        if (used[i]) continue;\n\n        for (int j = 0 ; j < n; ++j) {\n            if (i == j) continue;\n\n            if (sim[i][j].cc > threshold) {\n                used[i] = true;\n                used[j] = true;\n                break;\n            }\n        }\n    }\n\n    int nRemoved = 0;\n    for (int i = 0; i < n; ++i) {\n        if (used[i]) continue;\n\n        //keyPresses.erase(keyPresses.begin() + i - nRemoved);\n        ++nRemoved;\n    }\n\n    if (nRemoved == 0) {\n        return true;\n    }\n\n    auto keyPresses0 = keyPresses;\n    keyPresses.clear();\n\n    for (int i = 0; i < n; ++i) {\n        if (used[i]) {\n            keyPresses.push_back(keyPresses0[i]);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        auto cur = sim[i];\n        sim[i].clear();\n        for (int j = 0; j < n; ++j) {\n            if (used[j]) {\n                sim[i].push_back(cur[j]);\n            }\n        }\n    }\n\n    auto sim0 = sim;\n    sim.clear();\n    for (int i = 0; i < n; ++i) {\n        if (used[i]) {\n            sim.push_back(sim0[i]);\n        }\n    }\n\n    return true;\n}\n\ntemplate bool removeLowSimilarityKeys<TSampleI16>(TKeyPressCollectionT<TSampleI16> & keyPresses, TSimilarityMap & sim, double threshold);\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 7.884765625,
          "content": "/*! \\file common.h\n *  \\brief Common types and functions\n *  \\author Georgi Gerganov\n */\n\n#pragma once\n\n#include <map>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <chrono>\n\n// types\n\nstruct stMatch;\ntemplate<typename T, int N> struct stSampleMulti;\ntemplate<typename T> struct stWaveformView;\ntemplate<typename T> struct stKeyPressData;\ntemplate<typename T> struct stKeyPressDataNew;\ntemplate<typename T> struct stKeyPressCollection;\ntemplate<typename T> struct stKeyPressCollectionNew;\ntemplate<typename T> struct stPlaybackData;\n\ntemplate<typename T> using TWaveformT              = std::vector<T>;\ntemplate<typename T> using TWaveformViewT          = stWaveformView<T>;\ntemplate<typename T> using TKeyPressDataT          = stKeyPressData<T>;\ntemplate<typename T> using TKeyPressCollectionT    = stKeyPressCollection<T>;\ntemplate<typename T> using TPlaybackDataT          = stPlaybackData<T>;\n\nusing TConfidence   = float;\nusing TValueCC      = double;\nusing TOffset       = int64_t;\nusing TClusterId    = int32_t;\n\nusing TSampleF      = float;\nusing TSampleI16    = int16_t;\nusing TSampleMI16   = stSampleMulti<TSampleI16, 4>;\n\nusing TKey              = int32_t;\nusing TKeyPressPosition = int64_t;\nusing TKeyConfidenceMap = std::map<TKey, TConfidence>;\nusing TTrainKeys        = std::vector<TKey>;\n\nusing TLetter               = int32_t;\nusing TMatch                = stMatch;\nusing TSimilarityMap        = std::vector<std::vector<TMatch>>;\nusing TClusters             = std::vector<TClusterId>;\nusing TClusterToLetterMap   = std::map<TClusterId, TLetter>;\n\n// - i16 samples\n\nusing TWaveformI16              = TWaveformT<TSampleI16>;\nusing TWaveformViewI16          = TWaveformViewT<TSampleI16>;\nusing TKeyPressDataI16          = TKeyPressDataT<TSampleI16>;\nusing TKeyPressCollectionI16    = TKeyPressCollectionT<TSampleI16>;\nusing TPlaybackDataI16          = TPlaybackDataT<TSampleI16>;\n\nusing TWaveformMI16             = TWaveformT<TSampleMI16>;\nusing TWaveformViewMI16         = TWaveformViewT<TSampleMI16>;\nusing TKeyPressDataMI16         = TKeyPressDataT<TSampleMI16>;\nusing TKeyPressCollectionMI16   = TKeyPressCollectionT<TSampleMI16>;\nusing TPlaybackDataMI16         = TPlaybackDataT<TSampleMI16>;\n\n// - float samples\n\nusing TWaveformF    = TWaveformT<TSampleF>;\nusing TKeyWaveformF = std::vector<TSampleF>;\nusing TKeyHistoryF  = std::vector<TKeyWaveformF>;\n\nenum EAudioFilter {\n    None = 0,\n    FirstOrderHighPass,\n    SecondOrderButterworthHighPass,\n};\n\n// structs\nstruct stMatch {\n    TValueCC    cc      = 0.0;\n    TOffset     offset  = 0;\n};\n\ntemplate<typename T, int SIZE>\nstruct stSampleMulti : public std::array<T, SIZE> {\n    static const int N = SIZE;\n    using std::array<T, SIZE>::array;\n};\n\ntemplate<typename T>\nstruct stWaveformView {\n    const T * samples = nullptr;\n    int64_t n         = 0;\n};\n\ntemplate<typename T>\nstruct stKeyPressData {\n    TWaveformViewT<T>   waveform;\n    TKeyPressPosition   pos         = 0;\n    TValueCC            ccAvg       = 0.0;\n    TClusterId          cid         = -1;\n    TKey                bind        = -1;\n    TKey                predicted   = '?';\n};\n\ntemplate<typename T>\nstruct stKeyPressCollection : public std::vector<TKeyPressDataT<T>> {\n    int nClusters = 0;\n};\n\ntemplate<typename T>\nstruct stPlaybackData {\n    static const int kSamples = 1024;\n    bool playing = false;\n    int slowDown = 1;\n    int64_t idx = 0;\n    int64_t offset = 0;\n    TWaveformViewT<T> waveform;\n};\n\nstruct TFilterCoefficients {\n    float a0 = 0.0f;\n    float a1 = 0.0f;\n    float a2 = 0.0f;\n    float b1 = 0.0f;\n    float b2 = 0.0f;\n    float c0 = 0.0f;\n    float d0 = 0.0f;\n\n    float xnz1 = 0.0f;\n    float xnz2 = 0.0f;\n    float ynz1 = 0.0f;\n    float ynz2 = 0.0f;\n};\n\n// helpers\n\nfloat frand();\nfloat frandGaussian(float mu, float sigma);\n\nuint64_t t_ms();\n\ntemplate<typename T>\nstWaveformView<T> getView(const TWaveformT<T> & waveform, int64_t idx) {\n    return { waveform.data() + idx, (int64_t) waveform.size() - idx };\n}\n\ntemplate<typename T>\nstWaveformView<T> getView(const TWaveformT<T> & waveform, int64_t idx, int64_t len) {\n    return { waveform.data() + idx, len };\n}\n\nstd::map<std::string, std::string> parseCmdArguments(int argc, char ** argv);\n\ntemplate <typename T>\nfloat toSeconds(T t0, T t1) {\n    return std::chrono::duration_cast<std::chrono::milliseconds>(t1 - t0).count()/1000.0f;\n}\n\ntemplate <typename TSampleSrc, typename TSampleDst>\nbool convert(const TWaveformT<TSampleSrc> & src, TWaveformT<TSampleDst> & dst);\n\ntemplate <typename TSample>\ndouble calcAbsMax(const TWaveformT<TSample> & waveform);\n\ntemplate <typename TSample>\nvoid filter(TWaveformT<TSample> & waveform, EAudioFilter filterId, float freqCutoff_Hz, int64_t sampleRate);\n\ntemplate <typename TSample>\nbool saveToFile(const std::string & fname, TWaveformT<TSample> & waveform);\n\ntemplate <typename TSampleInput, typename TSample>\nbool readFromFile(const std::string & fname, TWaveformT<TSample> & res);\n\ntemplate <typename TSampleInput, typename TSample>\nbool readFromFile(const std::string & fname, TWaveformT<TSample> & res, TTrainKeys & trainKeys, int32_t & bufferSize_frames);\n\n//\n// filters\n//\n\nTFilterCoefficients calculateCoefficientsFirstOrderHighPass(int fc, int fs);\n\nTFilterCoefficients calculateCoefficientsSecondOrderButterworthHighPass(int fc, int fs);\n\nTSampleF filterFirstOrderHighPass(TFilterCoefficients & coefficients, TSampleF sample);\n\nTSampleF filterSecondOrderButterworthHighPass(TFilterCoefficients & coefficients, TSampleF sample);\n\n//\n// calcSum\n//\n\nstd::tuple<double, double> calcSum(const TKeyWaveformF & waveform, int is0, int is1);\n\ntemplate<typename T>\nstd::tuple<int64_t, int64_t> calcSum(const TWaveformViewT<T> & waveform);\n\n//\n// calcCC\n//\n\nTValueCC calcCC(\n    const TKeyWaveformF & waveform0,\n    const TKeyWaveformF & waveform1,\n    double sum0, double sum02,\n    int is00, int is0, int is1);\n\ntemplate<typename T>\nTValueCC calcCC(\n    const TWaveformViewT<T> & waveform0,\n    const TWaveformViewT<T> & waveform1,\n    int64_t sum0, int64_t sum02);\n\n//\n// findBestCC\n//\n\nstd::tuple<TValueCC, TOffset> findBestCC(\n    const TKeyWaveformF & waveform0,\n    const TKeyWaveformF & waveform1,\n    int is0, int is1,\n    int alignWindow);\n\ntemplate<typename T>\nstd::tuple<TValueCC, TOffset> findBestCC(\n    const TWaveformViewT<T> & waveform0,\n    const TWaveformViewT<T> & waveform1,\n    int64_t alignWindow);\n\n//\n// calculateSimilarityMap\n//\n\ntemplate<typename T>\nbool calculateSimilartyMap(\n        const int32_t keyPressWidth_samples,\n        const int32_t alignWindow_samples,\n        const int32_t offsetFromPeak_samples,\n        TKeyPressCollectionT<T> & keyPresses,\n        TSimilarityMap & res);\n\n//\n// findKeyPresses\n//\n\ntemplate<typename T>\nbool findKeyPresses(\n        const TWaveformViewT<T> & waveform,\n        TKeyPressCollectionT<T> & res,\n        TWaveformT<T> & waveformThreshold,\n        TWaveformT<T> & waveformMax,\n        double thresholdBackground,\n        int historySize,\n        int historySizeReset,\n        bool removeLowPower);\n\ntemplate<typename T>\nbool saveKeyPresses(const std::string & fname, const TKeyPressCollectionT<T> & keyPresses);\n\ntemplate<typename T>\nbool loadKeyPresses(const std::string & fname, const TWaveformViewT<T> & waveform, TKeyPressCollectionT<T> & keyPresses);\n\ntemplate<typename T>\nbool dumpKeyPresses(const std::string & fname, const TKeyPressCollectionT<T> & data);\n\ntemplate<typename T>\nvoid cbPlayback(void * userData, uint8_t * stream, int len);\n\ntemplate<typename T>\nbool generateLowResWaveform(const TWaveformViewT<T> & waveform, TWaveformT<T> & waveformLowRes, int nWindow);\n\ntemplate<typename T>\nbool generateLowResWaveform(const TWaveformT<T> & waveform, TWaveformT<T> & waveformLowRes, int nWindow) {\n    return generateLowResWaveform(getView(waveform, 0), waveformLowRes, nWindow);\n}\n\ntemplate<typename T>\nbool adjustKeyPresses(TKeyPressCollectionT<T> & keyPresses, TSimilarityMap & sim);\n\ntemplate<typename T>\nbool removeLowSimilarityKeys(TKeyPressCollectionT<T> & keyPresses, TSimilarityMap & sim, double threshold);\n"
        },
        {
          "name": "compress-n-grams.cpp",
          "type": "blob",
          "size": 0.46484375,
          "content": "#include \"subbreak3.h\"\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s n-gram.dat n-gram-compressed.dat\\n\", argv[0]);\n    if (argc < 3) {\n        return -1;\n    }\n\n    Cipher::TFreqMap freqMap;\n\n    printf(\"[+] Reading n-grams from '%s'\\n\", argv[1]);\n    if (Cipher::loadFreqMap(argv[1], freqMap) == false) {\n        return -1;\n    }\n\n    printf(\"[+] Writing compressed n-grams to '%s'\\n\", argv[2]);\n    Cipher::saveFreqMapBinary(argv[2], freqMap);\n\n    return 0;\n}\n"
        },
        {
          "name": "constants.h",
          "type": "blob",
          "size": 16.3056640625,
          "content": "/*! \\file constants.h\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#pragma once\n\n#include <map>\n#include <array>\n#include <vector>\n#include <cstdint>\n\n#ifdef __EMSCRIPTEN__\nstatic constexpr int32_t kMaxThreads = 8;\nstatic constexpr int64_t kSamplesPerFrame = 1024;\n#else\nstatic constexpr int64_t kSamplesPerFrame = 512;\n#endif\nstatic constexpr int32_t kTopResultsPerProcessor = 1;\nstatic constexpr int32_t kMaxRecords = 16;\nstatic constexpr int64_t kMaxSampleRate = 96000;\nstatic constexpr float   kMaxBufferSize_s = 5.000f;\nstatic constexpr float   kMaxRecordSize_s = 180.0f;\n\nstatic constexpr int32_t ceil_const(float num) {\n    return (static_cast<float>(static_cast<int32_t>(num)) == num)\n        ? static_cast<int32_t>(num)\n        : static_cast<int32_t>(num) + ((num > 0) ? 1 : 0);\n}\n\n// odd number of frames longer than bufferSize_s\nstatic constexpr int32_t getBufferSize_frames(int64_t sampleRate, float bufferSize_s) {\n    return 2*(ceil_const(float(bufferSize_s*sampleRate)/kSamplesPerFrame)/2) + 1;\n}\n\nstatic constexpr int64_t kSampleRate = 16000;\nstatic constexpr int32_t kMaxRecordSize_frames = getBufferSize_frames(kSampleRate, kMaxRecordSize_s);\n\nstatic constexpr float kBufferSizeTrain_s = 0.300;\nstatic constexpr int32_t kBufferSizeTrain_frames = getBufferSize_frames(kSampleRate, kBufferSizeTrain_s);\nstatic constexpr int64_t kSamplesPerWaveformTrain = kSamplesPerFrame*kBufferSizeTrain_frames;\n\nstatic constexpr uint64_t kBkgrRingBufferSize = 4*1024;\nstatic constexpr int64_t kBkgrStep_samples = 16;\nstatic constexpr int64_t kKeyDuration_samples = 0.005f*kSampleRate;\n\nstatic constexpr float kFreqCutoff_Hz = 100.0f;\nstatic constexpr float kKeyWidth_samples = 512;\nstatic constexpr float kKeyAlign_samples = 128;\nstatic constexpr float kKeyOffset_samples = 128;\n\nstatic constexpr float kFindKeysThreshold = 8.0f;\nstatic constexpr int kFindKeysHistorySize = 512;\nstatic constexpr int kFindKeysHistorySizeReset = 2048;\nstatic constexpr bool kFindKeysRemoveLowPower = true;\n\nstatic std::map<char, std::vector<char>> kNearbyKeys = {\n    { 'a', { 'a', 'q', 'w', 's', 'z', 'x',                               } },\n    { 'b', { 'b', 'f', 'g', 'h', 'v', 'n',                               } },\n    { 'c', { 'c', 's', 'd', 'f', 'x', 'v',                               } },\n    { 'd', { 'd', 'w', 'e', 'r', 's', 'f', 'x', 'c', 'v',                } },\n    { 'e', { 'e', 'w', 'r', 's', 'd', 'f',                               } },\n    //{ 'e', { 'e', '_'                                                    } },\n    { 'f', { 'f', 'e', 'r', 't', 'd', 'g', 'c', 'v', 'b',                } },\n    { 'g', { 'g', 'r', 't', 'y', 'f', 'h', 'v', 'b', 'n',                } },\n    { 'h', { 'h', 't', 'y', 'u', 'g', 'j', 'b', 'n', 'm',                } },\n    { 'i', { 'i', 'u', 'o', 'j', 'k', 'l',                               } },\n    { 'j', { 'j', 'y', 'u', 'i', 'h', 'k', 'n', 'm',                     } },\n    { 'k', { 'k', 'u', 'i', 'o', 'j', 'l', 'm',                          } },\n    { 'l', { 'l', 'i', 'o', 'p', 'k', 'm',                               } },\n    { 'm', { 'm', 'h', 'j', 'k', 'n',                                    } },\n    { 'n', { 'n', 'g', 'h', 'j', 'b', 'm',                               } },\n    { 'o', { 'o', 'i', 'p', 'k', 'l',                                    } },\n    { 'p', { 'p', 'o', 'l',                                              } },\n    { 'q', { 'q', 'w', 'a', 's',                                         } },\n    { 'r', { 'r', 'e', 't', 'd', 'f', 'g',                               } },\n    { 's', { 's', 'q', 'w', 'e', 'a', 'd', 'z', 'x', 'c',                } },\n    { 't', { 't', 'r', 'y', 'f', 'g', 'h',                               } },\n    { 'u', { 'u', 'y', 'i', 'h', 'j', 'k',                               } },\n    { 'v', { 'v', 'd', 'f', 'g', 'c', 'b',                               } },\n    { 'w', { 'w', 'q', 'e', 'a', 's', 'd',                               } },\n    { 'x', { 'x', 'a', 's', 'd', 'z', 'c',                               } },\n    { 'y', { 'y', 't', 'u', 'g', 'h', 'j',                               } },\n    { 'z', { 'z', 'a', 's', 'x',                                         } },\n    { '_', { '_', 'e',                                                   } },\n};\n\nstatic const std::array<int32_t, 256> kCharToInt = {\n    /* { 0,   */   0 /* } */,\n    /* { 1,   */   0 /* } */,\n    /* { 2,   */   0 /* } */,\n    /* { 3,   */   0 /* } */,\n    /* { 4,   */   0 /* } */,\n    /* { 5,   */   0 /* } */,\n    /* { 6,   */   0 /* } */,\n    /* { 7,   */   0 /* } */,\n    /* { 8,   */   0 /* } */,\n    /* { 9,   */   0 /* } */,\n    /* { 10,  */   0 /* } */,\n    /* { 11,  */   0 /* } */,\n    /* { 12,  */   0 /* } */,\n    /* { 13,  */   0 /* } */,\n    /* { 14,  */   0 /* } */,\n    /* { 15,  */   0 /* } */,\n    /* { 16,  */   0 /* } */,\n    /* { 17,  */   0 /* } */,\n    /* { 18,  */   0 /* } */,\n    /* { 19,  */   0 /* } */,\n    /* { 20,  */   0 /* } */,\n    /* { 21,  */   0 /* } */,\n    /* { 22,  */   0 /* } */,\n    /* { 23,  */   0 /* } */,\n    /* { 24,  */   0 /* } */,\n    /* { 25,  */   0 /* } */,\n    /* { 26,  */   0 /* } */,\n    /* { 27,  */   0 /* } */,\n    /* { 28,  */   0 /* } */,\n    /* { 29,  */   0 /* } */,\n    /* { 30,  */   0 /* } */,\n    /* { 31,  */   0 /* } */,\n    /* { 32,  */   0 /* } */,\n    /* { 33,  */   0 /* } */,\n    /* { 34,  */   0 /* } */,\n    /* { 35,  */   0 /* } */,\n    /* { 36,  */   0 /* } */,\n    /* { 37,  */   0 /* } */,\n    /* { 38,  */   0 /* } */,\n    /* { 39,  */   0 /* } */,\n    /* { 40,  */   0 /* } */,\n    /* { 41,  */   0 /* } */,\n    /* { 42,  */   0 /* } */,\n    /* { 43,  */   0 /* } */,\n    /* { 44,  */   0 /* } */,\n    /* { 45,  */   0 /* } */,\n    /* { 46,  */   0 /* } */,\n    /* { 47,  */   0 /* } */,\n    /* { 48,  */   0 /* } */,\n    /* { 49,  */   0 /* } */,\n    /* { 50,  */   0 /* } */,\n    /* { 51,  */   0 /* } */,\n    /* { 52,  */   0 /* } */,\n    /* { 53,  */   0 /* } */,\n    /* { 54,  */   0 /* } */,\n    /* { 55,  */   0 /* } */,\n    /* { 56,  */   0 /* } */,\n    /* { 57,  */   0 /* } */,\n    /* { 58,  */   0 /* } */,\n    /* { 59,  */   0 /* } */,\n    /* { 60,  */   0 /* } */,\n    /* { 61,  */   0 /* } */,\n    /* { 62,  */   0 /* } */,\n    /* { 63,  */   0 /* } */,\n    /* { 64,  */   0 /* } */,\n    /* { 65,  */   1 /* } */,\n    /* { 66,  */   2 /* } */,\n    /* { 67,  */   3 /* } */,\n    /* { 68,  */   4 /* } */,\n    /* { 69,  */   5 /* } */,\n    /* { 70,  */   6 /* } */,\n    /* { 71,  */   7 /* } */,\n    /* { 72,  */   8 /* } */,\n    /* { 73,  */   9 /* } */,\n    /* { 74,  */  10 /* } */,\n    /* { 75,  */  11 /* } */,\n    /* { 76,  */  12 /* } */,\n    /* { 77,  */  13 /* } */,\n    /* { 78,  */  14 /* } */,\n    /* { 79,  */  15 /* } */,\n    /* { 80,  */  16 /* } */,\n    /* { 81,  */  17 /* } */,\n    /* { 82,  */  18 /* } */,\n    /* { 83,  */  19 /* } */,\n    /* { 84,  */  20 /* } */,\n    /* { 85,  */  21 /* } */,\n    /* { 86,  */  22 /* } */,\n    /* { 87,  */  23 /* } */,\n    /* { 88,  */  24 /* } */,\n    /* { 89,  */  25 /* } */,\n    /* { 90,  */  26 /* } */,\n    /* { 91,  */   0 /* } */,\n    /* { 92,  */   0 /* } */,\n    /* { 93,  */   0 /* } */,\n    /* { 94,  */   0 /* } */,\n    /* { 95,  */   0 /* } */,\n    /* { 96,  */   0 /* } */,\n    /* { 97,  */   1 /* } */,\n    /* { 98,  */   2 /* } */,\n    /* { 99,  */   3 /* } */,\n    /* { 100, */   4 /* } */,\n    /* { 101, */   5 /* } */,\n    /* { 102, */   6 /* } */,\n    /* { 103, */   7 /* } */,\n    /* { 104, */   8 /* } */,\n    /* { 105, */   9 /* } */,\n    /* { 106, */  10 /* } */,\n    /* { 107, */  11 /* } */,\n    /* { 108, */  12 /* } */,\n    /* { 109, */  13 /* } */,\n    /* { 110, */  14 /* } */,\n    /* { 111, */  15 /* } */,\n    /* { 112, */  16 /* } */,\n    /* { 113, */  17 /* } */,\n    /* { 114, */  18 /* } */,\n    /* { 115, */  19 /* } */,\n    /* { 116, */  20 /* } */,\n    /* { 117, */  21 /* } */,\n    /* { 118, */  22 /* } */,\n    /* { 119, */  23 /* } */,\n    /* { 120, */  24 /* } */,\n    /* { 121, */  25 /* } */,\n    /* { 122, */  26 /* } */,\n    /* { 123, */   0 /* } */,\n    /* { 124, */   0 /* } */,\n    /* { 125, */   0 /* } */,\n    /* { 126, */   0 /* } */,\n    /* { 127, */   0 /* } */,\n    /* { 128, */   0 /* } */,\n    /* { 129, */   0 /* } */,\n    /* { 130, */   0 /* } */,\n    /* { 131, */   0 /* } */,\n    /* { 132, */   0 /* } */,\n    /* { 133, */   0 /* } */,\n    /* { 134, */   0 /* } */,\n    /* { 135, */   0 /* } */,\n    /* { 136, */   0 /* } */,\n    /* { 137, */   0 /* } */,\n    /* { 138, */   0 /* } */,\n    /* { 139, */   0 /* } */,\n    /* { 140, */   0 /* } */,\n    /* { 141, */   0 /* } */,\n    /* { 142, */   0 /* } */,\n    /* { 143, */   0 /* } */,\n    /* { 144, */   0 /* } */,\n    /* { 145, */   0 /* } */,\n    /* { 146, */   0 /* } */,\n    /* { 147, */   0 /* } */,\n    /* { 148, */   0 /* } */,\n    /* { 149, */   0 /* } */,\n    /* { 150, */   0 /* } */,\n    /* { 151, */   0 /* } */,\n    /* { 152, */   0 /* } */,\n    /* { 153, */   0 /* } */,\n    /* { 154, */   0 /* } */,\n    /* { 155, */   0 /* } */,\n    /* { 156, */   0 /* } */,\n    /* { 157, */   0 /* } */,\n    /* { 158, */   0 /* } */,\n    /* { 159, */   0 /* } */,\n    /* { 160, */   0 /* } */,\n    /* { 161, */   0 /* } */,\n    /* { 162, */   0 /* } */,\n    /* { 163, */   0 /* } */,\n    /* { 164, */   0 /* } */,\n    /* { 165, */   0 /* } */,\n    /* { 166, */   0 /* } */,\n    /* { 167, */   0 /* } */,\n    /* { 168, */   0 /* } */,\n    /* { 169, */   0 /* } */,\n    /* { 170, */   0 /* } */,\n    /* { 171, */   0 /* } */,\n    /* { 172, */   0 /* } */,\n    /* { 173, */   0 /* } */,\n    /* { 174, */   0 /* } */,\n    /* { 175, */   0 /* } */,\n    /* { 176, */   0 /* } */,\n    /* { 177, */   0 /* } */,\n    /* { 178, */   0 /* } */,\n    /* { 179, */   0 /* } */,\n    /* { 180, */   0 /* } */,\n    /* { 181, */   0 /* } */,\n    /* { 182, */   0 /* } */,\n    /* { 183, */   0 /* } */,\n    /* { 184, */   0 /* } */,\n    /* { 185, */   0 /* } */,\n    /* { 186, */   0 /* } */,\n    /* { 187, */   0 /* } */,\n    /* { 188, */   0 /* } */,\n    /* { 189, */   0 /* } */,\n    /* { 190, */   0 /* } */,\n    /* { 191, */   0 /* } */,\n    /* { 192, */   0 /* } */,\n    /* { 193, */   0 /* } */,\n    /* { 194, */   0 /* } */,\n    /* { 195, */   0 /* } */,\n    /* { 196, */   0 /* } */,\n    /* { 197, */   0 /* } */,\n    /* { 198, */   0 /* } */,\n    /* { 199, */   0 /* } */,\n    /* { 200, */   0 /* } */,\n    /* { 201, */   0 /* } */,\n    /* { 202, */   0 /* } */,\n    /* { 203, */   0 /* } */,\n    /* { 204, */   0 /* } */,\n    /* { 205, */   0 /* } */,\n    /* { 206, */   0 /* } */,\n    /* { 207, */   0 /* } */,\n    /* { 208, */   0 /* } */,\n    /* { 209, */   0 /* } */,\n    /* { 210, */   0 /* } */,\n    /* { 211, */   0 /* } */,\n    /* { 212, */   0 /* } */,\n    /* { 213, */   0 /* } */,\n    /* { 214, */   0 /* } */,\n    /* { 215, */   0 /* } */,\n    /* { 216, */   0 /* } */,\n    /* { 217, */   0 /* } */,\n    /* { 218, */   0 /* } */,\n    /* { 219, */   0 /* } */,\n    /* { 220, */   0 /* } */,\n    /* { 221, */   0 /* } */,\n    /* { 222, */   0 /* } */,\n    /* { 223, */   0 /* } */,\n    /* { 224, */   0 /* } */,\n    /* { 225, */   0 /* } */,\n    /* { 226, */   0 /* } */,\n    /* { 227, */   0 /* } */,\n    /* { 228, */   0 /* } */,\n    /* { 229, */   0 /* } */,\n    /* { 230, */   0 /* } */,\n    /* { 231, */   0 /* } */,\n    /* { 232, */   0 /* } */,\n    /* { 233, */   0 /* } */,\n    /* { 234, */   0 /* } */,\n    /* { 235, */   0 /* } */,\n    /* { 236, */   0 /* } */,\n    /* { 237, */   0 /* } */,\n    /* { 238, */   0 /* } */,\n    /* { 239, */   0 /* } */,\n    /* { 240, */   0 /* } */,\n    /* { 241, */   0 /* } */,\n    /* { 242, */   0 /* } */,\n    /* { 243, */   0 /* } */,\n    /* { 244, */   0 /* } */,\n    /* { 245, */   0 /* } */,\n    /* { 246, */   0 /* } */,\n    /* { 247, */   0 /* } */,\n    /* { 248, */   0 /* } */,\n    /* { 249, */   0 /* } */,\n    /* { 250, */   0 /* } */,\n    /* { 251, */   0 /* } */,\n    /* { 252, */   0 /* } */,\n    /* { 253, */   0 /* } */,\n    /* { 254, */   0 /* } */,\n    /* { 255, */   0 /* } */,\n};\n\nstatic const std::map<int, const char *> kKeyText = {\n    { -1,  \"?\" },\n    { 0,   \"?\" },\n    { 1,   \"?\" },\n    { 2,   \"?\" },\n    { 3,   \"?\" },\n    { 4,   \"?\" },\n    { 5,   \"?\" },\n    { 6,   \"?\" },\n    { 7,   \"?\" },\n    { 8,   \"?\" },\n    { 9,   \"?\" },\n    { 10,  \"[enter]\" },\n    { 11,  \"?\" },\n    { 12,  \"?\" },\n    { 13,  \"?\" },\n    { 14,  \"?\" },\n    { 15,  \"?\" },\n    { 16,  \"?\" },\n    { 17,  \"?\" },\n    { 18,  \"?\" },\n    { 19,  \"?\" },\n    { 20,  \"?\" },\n    { 21,  \"?\" },\n    { 22,  \"?\" },\n    { 23,  \"?\" },\n    { 24,  \"?\" },\n    { 25,  \"?\" },\n    { 26,  \"?\" },\n    { 27,  \"?\" },\n    { 28,  \"?\" },\n    { 29,  \"?\" },\n    { 30,  \"?\" },\n    { 31,  \"?\" },\n    { 32,  \"[space]\" },\n    { 33,  \"?\" },\n    { 34,  \"?\" },\n    { 35,  \"?\" },\n    { 36,  \"?\" },\n    { 37,  \"?\" },\n    { 38,  \"?\" },\n    { 39,  \"'\" },\n    { 40,  \"?\" },\n    { 41,  \"?\" },\n    { 42,  \"?\" },\n    { 43,  \"?\" },\n    { 44,  \",\" },\n    { 45,  \"-\" },\n    { 46,  \".\" },\n    { 47,  \"/\" },\n    { 48,  \"0\" },\n    { 49,  \"1\" },\n    { 50,  \"2\" },\n    { 51,  \"3\" },\n    { 52,  \"4\" },\n    { 53,  \"5\" },\n    { 54,  \"6\" },\n    { 55,  \"7\" },\n    { 56,  \"8\" },\n    { 57,  \"9\" },\n    { 58,  \"?\" },\n    { 59,  \";\" },\n    { 60,  \"?\" },\n    { 61,  \"=\" },\n    { 62,  \"?\" },\n    { 63,  \"?\" },\n    { 64,  \"?\" },\n    { 65,  \"?\" },\n    { 66,  \"?\" },\n    { 67,  \"?\" },\n    { 68,  \"?\" },\n    { 69,  \"?\" },\n    { 70,  \"?\" },\n    { 71,  \"?\" },\n    { 72,  \"?\" },\n    { 73,  \"?\" },\n    { 74,  \"?\" },\n    { 75,  \"?\" },\n    { 76,  \"?\" },\n    { 77,  \"?\" },\n    { 78,  \"?\" },\n    { 79,  \"?\" },\n    { 80,  \"?\" },\n    { 81,  \"?\" },\n    { 82,  \"?\" },\n    { 83,  \"?\" },\n    { 84,  \"?\" },\n    { 85,  \"?\" },\n    { 86,  \"?\" },\n    { 87,  \"?\" },\n    { 88,  \"?\" },\n    { 89,  \"?\" },\n    { 90,  \"?\" },\n    { 91,  \"[\" },\n    { 92,  \"\\\\\" },\n    { 93,  \"]\" },\n    { 94,  \"?\" },\n    { 95,  \"?\" },\n    { 96,  \"`\" },\n    { 97,  \"a\" },\n    { 98,  \"b\" },\n    { 99,  \"c\" },\n    { 100, \"d\" },\n    { 101, \"e\" },\n    { 102, \"f\" },\n    { 103, \"g\" },\n    { 104, \"h\" },\n    { 105, \"i\" },\n    { 106, \"j\" },\n    { 107, \"k\" },\n    { 108, \"l\" },\n    { 109, \"m\" },\n    { 110, \"n\" },\n    { 111, \"o\" },\n    { 112, \"p\" },\n    { 113, \"q\" },\n    { 114, \"r\" },\n    { 115, \"s\" },\n    { 116, \"t\" },\n    { 117, \"u\" },\n    { 118, \"v\" },\n    { 119, \"w\" },\n    { 120, \"x\" },\n    { 121, \"y\" },\n    { 122, \"z\" },\n    { 123, \"?\" },\n    { 124, \"?\" },\n    { 125, \"?\" },\n    { 126, \"?\" },\n    { 127, \"[<-]\" },\n    { 128, \"?\" },\n    { 129, \"?\" },\n    { 130, \"?\" },\n    { 131, \"?\" },\n    { 132, \"?\" },\n    { 133, \"?\" },\n    { 134, \"?\" },\n    { 135, \"?\" },\n    { 136, \"?\" },\n    { 137, \"?\" },\n    { 138, \"?\" },\n    { 139, \"?\" },\n    { 140, \"?\" },\n    { 141, \"?\" },\n    { 142, \"?\" },\n    { 143, \"?\" },\n    { 144, \"?\" },\n    { 145, \"?\" },\n    { 146, \"?\" },\n    { 147, \"?\" },\n    { 148, \"?\" },\n    { 149, \"?\" },\n    { 150, \"?\" },\n    { 151, \"?\" },\n    { 152, \"?\" },\n    { 153, \"?\" },\n    { 154, \"?\" },\n    { 155, \"?\" },\n    { 156, \"?\" },\n    { 157, \"?\" },\n    { 158, \"?\" },\n    { 159, \"?\" },\n    { 160, \"?\" },\n    { 161, \"?\" },\n    { 162, \"?\" },\n    { 163, \"?\" },\n    { 164, \"?\" },\n    { 165, \"?\" },\n    { 166, \"?\" },\n    { 167, \"?\" },\n    { 168, \"?\" },\n    { 169, \"?\" },\n    { 170, \"?\" },\n    { 171, \"?\" },\n    { 172, \"?\" },\n    { 173, \"?\" },\n    { 174, \"?\" },\n    { 175, \"?\" },\n    { 176, \"?\" },\n    { 177, \"?\" },\n    { 178, \"?\" },\n    { 179, \"?\" },\n    { 180, \"?\" },\n    { 181, \"?\" },\n    { 182, \"?\" },\n    { 183, \"?\" },\n    { 184, \"?\" },\n    { 185, \"?\" },\n    { 186, \"?\" },\n    { 187, \"?\" },\n    { 188, \"?\" },\n    { 189, \"?\" },\n    { 190, \"?\" },\n    { 191, \"?\" },\n    { 192, \"?\" },\n    { 193, \"?\" },\n    { 194, \"?\" },\n    { 195, \"?\" },\n    { 196, \"?\" },\n    { 197, \"?\" },\n    { 198, \"?\" },\n    { 199, \"?\" },\n    { 200, \"?\" },\n    { 201, \"?\" },\n    { 202, \"?\" },\n    { 203, \"?\" },\n    { 204, \"?\" },\n    { 205, \"?\" },\n    { 206, \"?\" },\n    { 207, \"?\" },\n    { 208, \"?\" },\n    { 209, \"?\" },\n    { 210, \"?\" },\n    { 211, \"?\" },\n    { 212, \"?\" },\n    { 213, \"?\" },\n    { 214, \"?\" },\n    { 215, \"?\" },\n    { 216, \"?\" },\n    { 217, \"?\" },\n    { 218, \"?\" },\n    { 219, \"?\" },\n    { 220, \"?\" },\n    { 221, \"?\" },\n    { 222, \"?\" },\n    { 223, \"?\" },\n    { 224, \"?\" },\n    { 225, \"?\" },\n    { 226, \"?\" },\n    { 227, \"?\" },\n    { 228, \"?\" },\n    { 229, \"?\" },\n    { 230, \"?\" },\n    { 231, \"?\" },\n    { 232, \"?\" },\n    { 233, \"?\" },\n    { 234, \"?\" },\n    { 235, \"?\" },\n    { 236, \"?\" },\n    { 237, \"?\" },\n    { 238, \"?\" },\n    { 239, \"?\" },\n    { 240, \"?\" },\n    { 241, \"?\" },\n    { 242, \"?\" },\n    { 243, \"?\" },\n    { 244, \"?\" },\n    { 245, \"?\" },\n    { 246, \"?\" },\n    { 247, \"?\" },\n    { 248, \"?\" },\n    { 249, \"?\" },\n    { 250, \"?\" },\n    { 251, \"?\" },\n    { 252, \"?\" },\n    { 253, \"?\" },\n    { 254, \"?\" },\n    { 255, \"?\" },\n};\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "dr_wav.h",
          "type": "blob",
          "size": 235.701171875,
          "content": "/*\nWAV audio loader and writer. Choice of public domain or MIT-0. See license statements at the end of this file.\ndr_wav - v0.12.16 - 2020-12-02\n\nDavid Reid - mackron@gmail.com\n\nGitHub: https://github.com/mackron/dr_libs\n*/\n\n/*\nRELEASE NOTES - VERSION 0.12\n============================\nVersion 0.12 includes breaking changes to custom chunk handling.\n\n\nChanges to Chunk Callback\n-------------------------\ndr_wav supports the ability to fire a callback when a chunk is encounted (except for WAVE and FMT chunks). The callback has been updated to include both the\ncontainer (RIFF or Wave64) and the FMT chunk which contains information about the format of the data in the wave file.\n\nPreviously, there was no direct way to determine the container, and therefore no way to discriminate against the different IDs in the chunk header (RIFF and\nWave64 containers encode chunk ID's differently). The `container` parameter can be used to know which ID to use.\n\nSometimes it can be useful to know the data format at the time the chunk callback is fired. A pointer to a `drwav_fmt` object is now passed into the chunk\ncallback which will give you information about the data format. To determine the sample format, use `drwav_fmt_get_format()`. This will return one of the\n`DR_WAVE_FORMAT_*` tokens.\n*/\n\n/*\nIntroduction\n============\nThis is a single file library. To use it, do something like the following in one .c file.\n    \n    ```c\n    #define DR_WAV_IMPLEMENTATION\n    #include \"dr_wav.h\"\n    ```\n\nYou can then #include this file in other parts of the program as you would with any other header file. Do something like the following to read audio data:\n\n    ```c\n    drwav wav;\n    if (!drwav_init_file(&wav, \"my_song.wav\", NULL)) {\n        // Error opening WAV file.\n    }\n\n    drwav_int32* pDecodedInterleavedPCMFrames = malloc(wav.totalPCMFrameCount * wav.channels * sizeof(drwav_int32));\n    size_t numberOfSamplesActuallyDecoded = drwav_read_pcm_frames_s32(&wav, wav.totalPCMFrameCount, pDecodedInterleavedPCMFrames);\n\n    ...\n\n    drwav_uninit(&wav);\n    ```\n\nIf you just want to quickly open and read the audio data in a single operation you can do something like this:\n\n    ```c\n    unsigned int channels;\n    unsigned int sampleRate;\n    drwav_uint64 totalPCMFrameCount;\n    float* pSampleData = drwav_open_file_and_read_pcm_frames_f32(\"my_song.wav\", &channels, &sampleRate, &totalPCMFrameCount, NULL);\n    if (pSampleData == NULL) {\n        // Error opening and reading WAV file.\n    }\n\n    ...\n\n    drwav_free(pSampleData);\n    ```\n\nThe examples above use versions of the API that convert the audio data to a consistent format (32-bit signed PCM, in this case), but you can still output the\naudio data in its internal format (see notes below for supported formats):\n\n    ```c\n    size_t framesRead = drwav_read_pcm_frames(&wav, wav.totalPCMFrameCount, pDecodedInterleavedPCMFrames);\n    ```\n\nYou can also read the raw bytes of audio data, which could be useful if dr_wav does not have native support for a particular data format:\n\n    ```c\n    size_t bytesRead = drwav_read_raw(&wav, bytesToRead, pRawDataBuffer);\n    ```\n\ndr_wav can also be used to output WAV files. This does not currently support compressed formats. To use this, look at `drwav_init_write()`,\n`drwav_init_file_write()`, etc. Use `drwav_write_pcm_frames()` to write samples, or `drwav_write_raw()` to write raw data in the \"data\" chunk.\n\n    ```c\n    drwav_data_format format;\n    format.container = drwav_container_riff;     // <-- drwav_container_riff = normal WAV files, drwav_container_w64 = Sony Wave64.\n    format.format = DR_WAVE_FORMAT_PCM;          // <-- Any of the DR_WAVE_FORMAT_* codes.\n    format.channels = 2;\n    format.sampleRate = 44100;\n    format.bitsPerSample = 16;\n    drwav_init_file_write(&wav, \"data/recording.wav\", &format, NULL);\n\n    ...\n\n    drwav_uint64 framesWritten = drwav_write_pcm_frames(pWav, frameCount, pSamples);\n    ```\n\ndr_wav has seamless support the Sony Wave64 format. The decoder will automatically detect it and it should Just Work without any manual intervention.\n\n\nBuild Options\n=============\n#define these options before including this file.\n\n#define DR_WAV_NO_CONVERSION_API\n  Disables conversion APIs such as `drwav_read_pcm_frames_f32()` and `drwav_s16_to_f32()`.\n\n#define DR_WAV_NO_STDIO\n  Disables APIs that initialize a decoder from a file such as `drwav_init_file()`, `drwav_init_file_write()`, etc.\n\n\n\nNotes\n=====\n- Samples are always interleaved.\n- The default read function does not do any data conversion. Use `drwav_read_pcm_frames_f32()`, `drwav_read_pcm_frames_s32()` and `drwav_read_pcm_frames_s16()`\n  to read and convert audio data to 32-bit floating point, signed 32-bit integer and signed 16-bit integer samples respectively. Tested and supported internal\n  formats include the following:\n  - Unsigned 8-bit PCM\n  - Signed 12-bit PCM\n  - Signed 16-bit PCM\n  - Signed 24-bit PCM\n  - Signed 32-bit PCM\n  - IEEE 32-bit floating point\n  - IEEE 64-bit floating point\n  - A-law and u-law\n  - Microsoft ADPCM\n  - IMA ADPCM (DVI, format code 0x11)\n- dr_wav will try to read the WAV file as best it can, even if it's not strictly conformant to the WAV format.\n*/\n\n#ifndef dr_wav_h\n#define dr_wav_h\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define DRWAV_STRINGIFY(x)      #x\n#define DRWAV_XSTRINGIFY(x)     DRWAV_STRINGIFY(x)\n\n#define DRWAV_VERSION_MAJOR     0\n#define DRWAV_VERSION_MINOR     12\n#define DRWAV_VERSION_REVISION  16\n#define DRWAV_VERSION_STRING    DRWAV_XSTRINGIFY(DRWAV_VERSION_MAJOR) \".\" DRWAV_XSTRINGIFY(DRWAV_VERSION_MINOR) \".\" DRWAV_XSTRINGIFY(DRWAV_VERSION_REVISION)\n\n#include <stddef.h> /* For size_t. */\n\n/* Sized types. */\ntypedef   signed char           drwav_int8;\ntypedef unsigned char           drwav_uint8;\ntypedef   signed short          drwav_int16;\ntypedef unsigned short          drwav_uint16;\ntypedef   signed int            drwav_int32;\ntypedef unsigned int            drwav_uint32;\n#if defined(_MSC_VER)\n    typedef   signed __int64    drwav_int64;\n    typedef unsigned __int64    drwav_uint64;\n#else\n    #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))\n        #pragma GCC diagnostic push\n        #pragma GCC diagnostic ignored \"-Wlong-long\"\n        #if defined(__clang__)\n            #pragma GCC diagnostic ignored \"-Wc++11-long-long\"\n        #endif\n    #endif\n    typedef   signed long long  drwav_int64;\n    typedef unsigned long long  drwav_uint64;\n    #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))\n        #pragma GCC diagnostic pop\n    #endif\n#endif\n#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)\n    typedef drwav_uint64        drwav_uintptr;\n#else\n    typedef drwav_uint32        drwav_uintptr;\n#endif\ntypedef drwav_uint8             drwav_bool8;\ntypedef drwav_uint32            drwav_bool32;\n#define DRWAV_TRUE              1\n#define DRWAV_FALSE             0\n\n#if !defined(DRWAV_API)\n    #if defined(DRWAV_DLL)\n        #if defined(_WIN32)\n            #define DRWAV_DLL_IMPORT  __declspec(dllimport)\n            #define DRWAV_DLL_EXPORT  __declspec(dllexport)\n            #define DRWAV_DLL_PRIVATE static\n        #else\n            #if defined(__GNUC__) && __GNUC__ >= 4\n                #define DRWAV_DLL_IMPORT  __attribute__((visibility(\"default\")))\n                #define DRWAV_DLL_EXPORT  __attribute__((visibility(\"default\")))\n                #define DRWAV_DLL_PRIVATE __attribute__((visibility(\"hidden\")))\n            #else\n                #define DRWAV_DLL_IMPORT\n                #define DRWAV_DLL_EXPORT\n                #define DRWAV_DLL_PRIVATE static\n            #endif\n        #endif\n\n        #if defined(DR_WAV_IMPLEMENTATION) || defined(DRWAV_IMPLEMENTATION)\n            #define DRWAV_API  DRWAV_DLL_EXPORT\n        #else\n            #define DRWAV_API  DRWAV_DLL_IMPORT\n        #endif\n        #define DRWAV_PRIVATE DRWAV_DLL_PRIVATE\n    #else\n        #define DRWAV_API extern\n        #define DRWAV_PRIVATE static\n    #endif\n#endif\n\ntypedef drwav_int32 drwav_result;\n#define DRWAV_SUCCESS                        0\n#define DRWAV_ERROR                         -1   /* A generic error. */\n#define DRWAV_INVALID_ARGS                  -2\n#define DRWAV_INVALID_OPERATION             -3\n#define DRWAV_OUT_OF_MEMORY                 -4\n#define DRWAV_OUT_OF_RANGE                  -5\n#define DRWAV_ACCESS_DENIED                 -6\n#define DRWAV_DOES_NOT_EXIST                -7\n#define DRWAV_ALREADY_EXISTS                -8\n#define DRWAV_TOO_MANY_OPEN_FILES           -9\n#define DRWAV_INVALID_FILE                  -10\n#define DRWAV_TOO_BIG                       -11\n#define DRWAV_PATH_TOO_LONG                 -12\n#define DRWAV_NAME_TOO_LONG                 -13\n#define DRWAV_NOT_DIRECTORY                 -14\n#define DRWAV_IS_DIRECTORY                  -15\n#define DRWAV_DIRECTORY_NOT_EMPTY           -16\n#define DRWAV_END_OF_FILE                   -17\n#define DRWAV_NO_SPACE                      -18\n#define DRWAV_BUSY                          -19\n#define DRWAV_IO_ERROR                      -20\n#define DRWAV_INTERRUPT                     -21\n#define DRWAV_UNAVAILABLE                   -22\n#define DRWAV_ALREADY_IN_USE                -23\n#define DRWAV_BAD_ADDRESS                   -24\n#define DRWAV_BAD_SEEK                      -25\n#define DRWAV_BAD_PIPE                      -26\n#define DRWAV_DEADLOCK                      -27\n#define DRWAV_TOO_MANY_LINKS                -28\n#define DRWAV_NOT_IMPLEMENTED               -29\n#define DRWAV_NO_MESSAGE                    -30\n#define DRWAV_BAD_MESSAGE                   -31\n#define DRWAV_NO_DATA_AVAILABLE             -32\n#define DRWAV_INVALID_DATA                  -33\n#define DRWAV_TIMEOUT                       -34\n#define DRWAV_NO_NETWORK                    -35\n#define DRWAV_NOT_UNIQUE                    -36\n#define DRWAV_NOT_SOCKET                    -37\n#define DRWAV_NO_ADDRESS                    -38\n#define DRWAV_BAD_PROTOCOL                  -39\n#define DRWAV_PROTOCOL_UNAVAILABLE          -40\n#define DRWAV_PROTOCOL_NOT_SUPPORTED        -41\n#define DRWAV_PROTOCOL_FAMILY_NOT_SUPPORTED -42\n#define DRWAV_ADDRESS_FAMILY_NOT_SUPPORTED  -43\n#define DRWAV_SOCKET_NOT_SUPPORTED          -44\n#define DRWAV_CONNECTION_RESET              -45\n#define DRWAV_ALREADY_CONNECTED             -46\n#define DRWAV_NOT_CONNECTED                 -47\n#define DRWAV_CONNECTION_REFUSED            -48\n#define DRWAV_NO_HOST                       -49\n#define DRWAV_IN_PROGRESS                   -50\n#define DRWAV_CANCELLED                     -51\n#define DRWAV_MEMORY_ALREADY_MAPPED         -52\n#define DRWAV_AT_END                        -53\n\n/* Common data formats. */\n#define DR_WAVE_FORMAT_PCM          0x1\n#define DR_WAVE_FORMAT_ADPCM        0x2\n#define DR_WAVE_FORMAT_IEEE_FLOAT   0x3\n#define DR_WAVE_FORMAT_ALAW         0x6\n#define DR_WAVE_FORMAT_MULAW        0x7\n#define DR_WAVE_FORMAT_DVI_ADPCM    0x11\n#define DR_WAVE_FORMAT_EXTENSIBLE   0xFFFE\n\n/* Constants. */\n#ifndef DRWAV_MAX_SMPL_LOOPS\n#define DRWAV_MAX_SMPL_LOOPS        1\n#endif\n\n/* Flags to pass into drwav_init_ex(), etc. */\n#define DRWAV_SEQUENTIAL            0x00000001\n\nDRWAV_API void drwav_version(drwav_uint32* pMajor, drwav_uint32* pMinor, drwav_uint32* pRevision);\nDRWAV_API const char* drwav_version_string(void);\n\ntypedef enum\n{\n    drwav_seek_origin_start,\n    drwav_seek_origin_current\n} drwav_seek_origin;\n\ntypedef enum\n{\n    drwav_container_riff,\n    drwav_container_w64,\n    drwav_container_rf64\n} drwav_container;\n\ntypedef struct\n{\n    union\n    {\n        drwav_uint8 fourcc[4];\n        drwav_uint8 guid[16];\n    } id;\n\n    /* The size in bytes of the chunk. */\n    drwav_uint64 sizeInBytes;\n\n    /*\n    RIFF = 2 byte alignment.\n    W64  = 8 byte alignment.\n    */\n    unsigned int paddingSize;\n} drwav_chunk_header;\n\ntypedef struct\n{\n    /*\n    The format tag exactly as specified in the wave file's \"fmt\" chunk. This can be used by applications\n    that require support for data formats not natively supported by dr_wav.\n    */\n    drwav_uint16 formatTag;\n\n    /* The number of channels making up the audio data. When this is set to 1 it is mono, 2 is stereo, etc. */\n    drwav_uint16 channels;\n\n    /* The sample rate. Usually set to something like 44100. */\n    drwav_uint32 sampleRate;\n\n    /* Average bytes per second. You probably don't need this, but it's left here for informational purposes. */\n    drwav_uint32 avgBytesPerSec;\n\n    /* Block align. This is equal to the number of channels * bytes per sample. */\n    drwav_uint16 blockAlign;\n\n    /* Bits per sample. */\n    drwav_uint16 bitsPerSample;\n\n    /* The size of the extended data. Only used internally for validation, but left here for informational purposes. */\n    drwav_uint16 extendedSize;\n\n    /*\n    The number of valid bits per sample. When <formatTag> is equal to WAVE_FORMAT_EXTENSIBLE, <bitsPerSample>\n    is always rounded up to the nearest multiple of 8. This variable contains information about exactly how\n    many bits are valid per sample. Mainly used for informational purposes.\n    */\n    drwav_uint16 validBitsPerSample;\n\n    /* The channel mask. Not used at the moment. */\n    drwav_uint32 channelMask;\n\n    /* The sub-format, exactly as specified by the wave file. */\n    drwav_uint8 subFormat[16];\n} drwav_fmt;\n\nDRWAV_API drwav_uint16 drwav_fmt_get_format(const drwav_fmt* pFMT);\n\n\n/*\nCallback for when data is read. Return value is the number of bytes actually read.\n\npUserData   [in]  The user data that was passed to drwav_init() and family.\npBufferOut  [out] The output buffer.\nbytesToRead [in]  The number of bytes to read.\n\nReturns the number of bytes actually read.\n\nA return value of less than bytesToRead indicates the end of the stream. Do _not_ return from this callback until\neither the entire bytesToRead is filled or you have reached the end of the stream.\n*/\ntypedef size_t (* drwav_read_proc)(void* pUserData, void* pBufferOut, size_t bytesToRead);\n\n/*\nCallback for when data is written. Returns value is the number of bytes actually written.\n\npUserData    [in]  The user data that was passed to drwav_init_write() and family.\npData        [out] A pointer to the data to write.\nbytesToWrite [in]  The number of bytes to write.\n\nReturns the number of bytes actually written.\n\nIf the return value differs from bytesToWrite, it indicates an error.\n*/\ntypedef size_t (* drwav_write_proc)(void* pUserData, const void* pData, size_t bytesToWrite);\n\n/*\nCallback for when data needs to be seeked.\n\npUserData [in] The user data that was passed to drwav_init() and family.\noffset    [in] The number of bytes to move, relative to the origin. Will never be negative.\norigin    [in] The origin of the seek - the current position or the start of the stream.\n\nReturns whether or not the seek was successful.\n\nWhether or not it is relative to the beginning or current position is determined by the \"origin\" parameter which will be either drwav_seek_origin_start or\ndrwav_seek_origin_current.\n*/\ntypedef drwav_bool32 (* drwav_seek_proc)(void* pUserData, int offset, drwav_seek_origin origin);\n\n/*\nCallback for when drwav_init_ex() finds a chunk.\n\npChunkUserData    [in] The user data that was passed to the pChunkUserData parameter of drwav_init_ex() and family.\nonRead            [in] A pointer to the function to call when reading.\nonSeek            [in] A pointer to the function to call when seeking.\npReadSeekUserData [in] The user data that was passed to the pReadSeekUserData parameter of drwav_init_ex() and family.\npChunkHeader      [in] A pointer to an object containing basic header information about the chunk. Use this to identify the chunk.\ncontainer         [in] Whether or not the WAV file is a RIFF or Wave64 container. If you're unsure of the difference, assume RIFF.\npFMT              [in] A pointer to the object containing the contents of the \"fmt\" chunk.\n\nReturns the number of bytes read + seeked.\n\nTo read data from the chunk, call onRead(), passing in pReadSeekUserData as the first parameter. Do the same for seeking with onSeek(). The return value must\nbe the total number of bytes you have read _plus_ seeked.\n\nUse the `container` argument to discriminate the fields in `pChunkHeader->id`. If the container is `drwav_container_riff` or `drwav_container_rf64` you should\nuse `id.fourcc`, otherwise you should use `id.guid`.\n\nThe `pFMT` parameter can be used to determine the data format of the wave file. Use `drwav_fmt_get_format()` to get the sample format, which will be one of the\n`DR_WAVE_FORMAT_*` identifiers. \n\nThe read pointer will be sitting on the first byte after the chunk's header. You must not attempt to read beyond the boundary of the chunk.\n*/\ntypedef drwav_uint64 (* drwav_chunk_proc)(void* pChunkUserData, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pReadSeekUserData, const drwav_chunk_header* pChunkHeader, drwav_container container, const drwav_fmt* pFMT);\n\ntypedef struct\n{\n    void* pUserData;\n    void* (* onMalloc)(size_t sz, void* pUserData);\n    void* (* onRealloc)(void* p, size_t sz, void* pUserData);\n    void  (* onFree)(void* p, void* pUserData);\n} drwav_allocation_callbacks;\n\n/* Structure for internal use. Only used for loaders opened with drwav_init_memory(). */\ntypedef struct\n{\n    const drwav_uint8* data;\n    size_t dataSize;\n    size_t currentReadPos;\n} drwav__memory_stream;\n\n/* Structure for internal use. Only used for writers opened with drwav_init_memory_write(). */\ntypedef struct\n{\n    void** ppData;\n    size_t* pDataSize;\n    size_t dataSize;\n    size_t dataCapacity;\n    size_t currentWritePos;\n} drwav__memory_stream_write;\n\ntypedef struct\n{\n    drwav_container container;  /* RIFF, W64. */\n    drwav_uint32 format;        /* DR_WAVE_FORMAT_* */\n    drwav_uint32 channels;\n    drwav_uint32 sampleRate;\n    drwav_uint32 bitsPerSample;\n} drwav_data_format;\n\n\n/* See the following for details on the 'smpl' chunk: https://sites.google.com/site/musicgapi/technical-documents/wav-file-format#smpl */\ntypedef struct\n{\n    drwav_uint32 cuePointId;\n    drwav_uint32 type;\n    drwav_uint32 start;\n    drwav_uint32 end;\n    drwav_uint32 fraction;\n    drwav_uint32 playCount;\n} drwav_smpl_loop;\n\n typedef struct\n{\n    drwav_uint32 manufacturer;\n    drwav_uint32 product;\n    drwav_uint32 samplePeriod;\n    drwav_uint32 midiUnityNotes;\n    drwav_uint32 midiPitchFraction;\n    drwav_uint32 smpteFormat;\n    drwav_uint32 smpteOffset;\n    drwav_uint32 numSampleLoops;\n    drwav_uint32 samplerData;\n    drwav_smpl_loop loops[DRWAV_MAX_SMPL_LOOPS];\n} drwav_smpl;\n\ntypedef struct\n{\n    /* A pointer to the function to call when more data is needed. */\n    drwav_read_proc onRead;\n\n    /* A pointer to the function to call when data needs to be written. Only used when the drwav object is opened in write mode. */\n    drwav_write_proc onWrite;\n\n    /* A pointer to the function to call when the wav file needs to be seeked. */\n    drwav_seek_proc onSeek;\n\n    /* The user data to pass to callbacks. */\n    void* pUserData;\n\n    /* Allocation callbacks. */\n    drwav_allocation_callbacks allocationCallbacks;\n\n\n    /* Whether or not the WAV file is formatted as a standard RIFF file or W64. */\n    drwav_container container;\n\n\n    /* Structure containing format information exactly as specified by the wav file. */\n    drwav_fmt fmt;\n\n    /* The sample rate. Will be set to something like 44100. */\n    drwav_uint32 sampleRate;\n\n    /* The number of channels. This will be set to 1 for monaural streams, 2 for stereo, etc. */\n    drwav_uint16 channels;\n\n    /* The bits per sample. Will be set to something like 16, 24, etc. */\n    drwav_uint16 bitsPerSample;\n\n    /* Equal to fmt.formatTag, or the value specified by fmt.subFormat if fmt.formatTag is equal to 65534 (WAVE_FORMAT_EXTENSIBLE). */\n    drwav_uint16 translatedFormatTag;\n\n    /* The total number of PCM frames making up the audio data. */\n    drwav_uint64 totalPCMFrameCount;\n\n\n    /* The size in bytes of the data chunk. */\n    drwav_uint64 dataChunkDataSize;\n    \n    /* The position in the stream of the first byte of the data chunk. This is used for seeking. */\n    drwav_uint64 dataChunkDataPos;\n\n    /* The number of bytes remaining in the data chunk. */\n    drwav_uint64 bytesRemaining;\n\n\n    /*\n    Only used in sequential write mode. Keeps track of the desired size of the \"data\" chunk at the point of initialization time. Always\n    set to 0 for non-sequential writes and when the drwav object is opened in read mode. Used for validation.\n    */\n    drwav_uint64 dataChunkDataSizeTargetWrite;\n\n    /* Keeps track of whether or not the wav writer was initialized in sequential mode. */\n    drwav_bool32 isSequentialWrite;\n\n\n    /* smpl chunk. */\n    drwav_smpl smpl;\n\n\n    /* A hack to avoid a DRWAV_MALLOC() when opening a decoder with drwav_init_memory(). */\n    drwav__memory_stream memoryStream;\n    drwav__memory_stream_write memoryStreamWrite;\n\n    /* Generic data for compressed formats. This data is shared across all block-compressed formats. */\n    struct\n    {\n        drwav_uint64 iCurrentPCMFrame;  /* The index of the next PCM frame that will be read by drwav_read_*(). This is used with \"totalPCMFrameCount\" to ensure we don't read excess samples at the end of the last block. */\n    } compressed;\n    \n    /* Microsoft ADPCM specific data. */\n    struct\n    {\n        drwav_uint32 bytesRemainingInBlock;\n        drwav_uint16 predictor[2];\n        drwav_int32  delta[2];\n        drwav_int32  cachedFrames[4];  /* Samples are stored in this cache during decoding. */\n        drwav_uint32 cachedFrameCount;\n        drwav_int32  prevFrames[2][2]; /* The previous 2 samples for each channel (2 channels at most). */\n    } msadpcm;\n\n    /* IMA ADPCM specific data. */\n    struct\n    {\n        drwav_uint32 bytesRemainingInBlock;\n        drwav_int32  predictor[2];\n        drwav_int32  stepIndex[2];\n        drwav_int32  cachedFrames[16]; /* Samples are stored in this cache during decoding. */\n        drwav_uint32 cachedFrameCount;\n    } ima;\n} drwav;\n\n\n/*\nInitializes a pre-allocated drwav object for reading.\n\npWav                         [out]          A pointer to the drwav object being initialized.\nonRead                       [in]           The function to call when data needs to be read from the client.\nonSeek                       [in]           The function to call when the read position of the client data needs to move.\nonChunk                      [in, optional] The function to call when a chunk is enumerated at initialized time.\npUserData, pReadSeekUserData [in, optional] A pointer to application defined data that will be passed to onRead and onSeek.\npChunkUserData               [in, optional] A pointer to application defined data that will be passed to onChunk.\nflags                        [in, optional] A set of flags for controlling how things are loaded.\n\nReturns true if successful; false otherwise.\n\nClose the loader with drwav_uninit().\n\nThis is the lowest level function for initializing a WAV file. You can also use drwav_init_file() and drwav_init_memory()\nto open the stream from a file or from a block of memory respectively.\n\nPossible values for flags:\n  DRWAV_SEQUENTIAL: Never perform a backwards seek while loading. This disables the chunk callback and will cause this function\n                    to return as soon as the data chunk is found. Any chunks after the data chunk will be ignored.\n\ndrwav_init() is equivalent to \"drwav_init_ex(pWav, onRead, onSeek, NULL, pUserData, NULL, 0);\".\n\nThe onChunk callback is not called for the WAVE or FMT chunks. The contents of the FMT chunk can be read from pWav->fmt\nafter the function returns.\n\nSee also: drwav_init_file(), drwav_init_memory(), drwav_uninit()\n*/\nDRWAV_API drwav_bool32 drwav_init(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_ex(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, drwav_chunk_proc onChunk, void* pReadSeekUserData, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);\n\n/*\nInitializes a pre-allocated drwav object for writing.\n\nonWrite   [in]           The function to call when data needs to be written.\nonSeek    [in]           The function to call when the write position needs to move.\npUserData [in, optional] A pointer to application defined data that will be passed to onWrite and onSeek.\n\nReturns true if successful; false otherwise.\n\nClose the writer with drwav_uninit().\n\nThis is the lowest level function for initializing a WAV file. You can also use drwav_init_file_write() and drwav_init_memory_write()\nto open the stream from a file or from a block of memory respectively.\n\nIf the total sample count is known, you can use drwav_init_write_sequential(). This avoids the need for dr_wav to perform\na post-processing step for storing the total sample count and the size of the data chunk which requires a backwards seek.\n\nSee also: drwav_init_file_write(), drwav_init_memory_write(), drwav_uninit()\n*/\nDRWAV_API drwav_bool32 drwav_init_write(drwav* pWav, const drwav_data_format* pFormat, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_write_sequential(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_write_proc onWrite, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_write_sequential_pcm_frames(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, drwav_write_proc onWrite, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);\n\n/*\nUtility function to determine the target size of the entire data to be written (including all headers and chunks).\n\nReturns the target size in bytes.\n\nUseful if the application needs to know the size to allocate.\n\nOnly writing to the RIFF chunk and one data chunk is currently supported.\n\nSee also: drwav_init_write(), drwav_init_file_write(), drwav_init_memory_write()\n*/\nDRWAV_API drwav_uint64 drwav_target_write_size_bytes(const drwav_data_format* pFormat, drwav_uint64 totalSampleCount);\n\n/*\nUninitializes the given drwav object.\n\nUse this only for objects initialized with drwav_init*() functions (drwav_init(), drwav_init_ex(), drwav_init_write(), drwav_init_write_sequential()).\n*/\nDRWAV_API drwav_result drwav_uninit(drwav* pWav);\n\n\n/*\nReads raw audio data.\n\nThis is the lowest level function for reading audio data. It simply reads the given number of\nbytes of the raw internal sample data.\n\nConsider using drwav_read_pcm_frames_s16(), drwav_read_pcm_frames_s32() or drwav_read_pcm_frames_f32() for\nreading sample data in a consistent format.\n\npBufferOut can be NULL in which case a seek will be performed.\n\nReturns the number of bytes actually read.\n*/\nDRWAV_API size_t drwav_read_raw(drwav* pWav, size_t bytesToRead, void* pBufferOut);\n\n/*\nReads up to the specified number of PCM frames from the WAV file.\n\nThe output data will be in the file's internal format, converted to native-endian byte order. Use\ndrwav_read_pcm_frames_s16/f32/s32() to read data in a specific format.\n\nIf the return value is less than <framesToRead> it means the end of the file has been reached or\nyou have requested more PCM frames than can possibly fit in the output buffer.\n\nThis function will only work when sample data is of a fixed size and uncompressed. If you are\nusing a compressed format consider using drwav_read_raw() or drwav_read_pcm_frames_s16/s32/f32().\n\npBufferOut can be NULL in which case a seek will be performed.\n*/\nDRWAV_API drwav_uint64 drwav_read_pcm_frames(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_le(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_be(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut);\n\n/*\nSeeks to the given PCM frame.\n\nReturns true if successful; false otherwise.\n*/\nDRWAV_API drwav_bool32 drwav_seek_to_pcm_frame(drwav* pWav, drwav_uint64 targetFrameIndex);\n\n\n/*\nWrites raw audio data.\n\nReturns the number of bytes actually written. If this differs from bytesToWrite, it indicates an error.\n*/\nDRWAV_API size_t drwav_write_raw(drwav* pWav, size_t bytesToWrite, const void* pData);\n\n/*\nWrites PCM frames.\n\nReturns the number of PCM frames written.\n\nInput samples need to be in native-endian byte order. On big-endian architectures the input data will be converted to\nlittle-endian. Use drwav_write_raw() to write raw audio data without performing any conversion.\n*/\nDRWAV_API drwav_uint64 drwav_write_pcm_frames(drwav* pWav, drwav_uint64 framesToWrite, const void* pData);\nDRWAV_API drwav_uint64 drwav_write_pcm_frames_le(drwav* pWav, drwav_uint64 framesToWrite, const void* pData);\nDRWAV_API drwav_uint64 drwav_write_pcm_frames_be(drwav* pWav, drwav_uint64 framesToWrite, const void* pData);\n\n\n/* Conversion Utilities */\n#ifndef DR_WAV_NO_CONVERSION_API\n\n/*\nReads a chunk of audio data and converts it to signed 16-bit PCM samples.\n\npBufferOut can be NULL in which case a seek will be performed.\n\nReturns the number of PCM frames actually read.\n\nIf the return value is less than <framesToRead> it means the end of the file has been reached.\n*/\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s16(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s16le(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s16be(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut);\n\n/* Low-level function for converting unsigned 8-bit PCM samples to signed 16-bit PCM samples. */\nDRWAV_API void drwav_u8_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting signed 24-bit PCM samples to signed 16-bit PCM samples. */\nDRWAV_API void drwav_s24_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting signed 32-bit PCM samples to signed 16-bit PCM samples. */\nDRWAV_API void drwav_s32_to_s16(drwav_int16* pOut, const drwav_int32* pIn, size_t sampleCount);\n\n/* Low-level function for converting IEEE 32-bit floating point samples to signed 16-bit PCM samples. */\nDRWAV_API void drwav_f32_to_s16(drwav_int16* pOut, const float* pIn, size_t sampleCount);\n\n/* Low-level function for converting IEEE 64-bit floating point samples to signed 16-bit PCM samples. */\nDRWAV_API void drwav_f64_to_s16(drwav_int16* pOut, const double* pIn, size_t sampleCount);\n\n/* Low-level function for converting A-law samples to signed 16-bit PCM samples. */\nDRWAV_API void drwav_alaw_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting u-law samples to signed 16-bit PCM samples. */\nDRWAV_API void drwav_mulaw_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n\n/*\nReads a chunk of audio data and converts it to IEEE 32-bit floating point samples.\n\npBufferOut can be NULL in which case a seek will be performed.\n\nReturns the number of PCM frames actually read.\n\nIf the return value is less than <framesToRead> it means the end of the file has been reached.\n*/\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_f32(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_f32le(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_f32be(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut);\n\n/* Low-level function for converting unsigned 8-bit PCM samples to IEEE 32-bit floating point samples. */\nDRWAV_API void drwav_u8_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting signed 16-bit PCM samples to IEEE 32-bit floating point samples. */\nDRWAV_API void drwav_s16_to_f32(float* pOut, const drwav_int16* pIn, size_t sampleCount);\n\n/* Low-level function for converting signed 24-bit PCM samples to IEEE 32-bit floating point samples. */\nDRWAV_API void drwav_s24_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting signed 32-bit PCM samples to IEEE 32-bit floating point samples. */\nDRWAV_API void drwav_s32_to_f32(float* pOut, const drwav_int32* pIn, size_t sampleCount);\n\n/* Low-level function for converting IEEE 64-bit floating point samples to IEEE 32-bit floating point samples. */\nDRWAV_API void drwav_f64_to_f32(float* pOut, const double* pIn, size_t sampleCount);\n\n/* Low-level function for converting A-law samples to IEEE 32-bit floating point samples. */\nDRWAV_API void drwav_alaw_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting u-law samples to IEEE 32-bit floating point samples. */\nDRWAV_API void drwav_mulaw_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n\n/*\nReads a chunk of audio data and converts it to signed 32-bit PCM samples.\n\npBufferOut can be NULL in which case a seek will be performed.\n\nReturns the number of PCM frames actually read.\n\nIf the return value is less than <framesToRead> it means the end of the file has been reached.\n*/\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s32(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s32le(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut);\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s32be(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut);\n\n/* Low-level function for converting unsigned 8-bit PCM samples to signed 32-bit PCM samples. */\nDRWAV_API void drwav_u8_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting signed 16-bit PCM samples to signed 32-bit PCM samples. */\nDRWAV_API void drwav_s16_to_s32(drwav_int32* pOut, const drwav_int16* pIn, size_t sampleCount);\n\n/* Low-level function for converting signed 24-bit PCM samples to signed 32-bit PCM samples. */\nDRWAV_API void drwav_s24_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting IEEE 32-bit floating point samples to signed 32-bit PCM samples. */\nDRWAV_API void drwav_f32_to_s32(drwav_int32* pOut, const float* pIn, size_t sampleCount);\n\n/* Low-level function for converting IEEE 64-bit floating point samples to signed 32-bit PCM samples. */\nDRWAV_API void drwav_f64_to_s32(drwav_int32* pOut, const double* pIn, size_t sampleCount);\n\n/* Low-level function for converting A-law samples to signed 32-bit PCM samples. */\nDRWAV_API void drwav_alaw_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n/* Low-level function for converting u-law samples to signed 32-bit PCM samples. */\nDRWAV_API void drwav_mulaw_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount);\n\n#endif  /* DR_WAV_NO_CONVERSION_API */\n\n\n/* High-Level Convenience Helpers */\n\n#ifndef DR_WAV_NO_STDIO\n/*\nHelper for initializing a wave file for reading using stdio.\n\nThis holds the internal FILE object until drwav_uninit() is called. Keep this in mind if you're caching drwav\nobjects because the operating system may restrict the number of file handles an application can have open at\nany given time.\n*/\nDRWAV_API drwav_bool32 drwav_init_file(drwav* pWav, const char* filename, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_ex(drwav* pWav, const char* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_w(drwav* pWav, const wchar_t* filename, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_ex_w(drwav* pWav, const wchar_t* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);\n\n/*\nHelper for initializing a wave file for writing using stdio.\n\nThis holds the internal FILE object until drwav_uninit() is called. Keep this in mind if you're caching drwav\nobjects because the operating system may restrict the number of file handles an application can have open at\nany given time.\n*/\nDRWAV_API drwav_bool32 drwav_init_file_write(drwav* pWav, const char* filename, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential_pcm_frames(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_write_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential_pcm_frames_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks);\n#endif  /* DR_WAV_NO_STDIO */\n\n/*\nHelper for initializing a loader from a pre-allocated memory buffer.\n\nThis does not create a copy of the data. It is up to the application to ensure the buffer remains valid for\nthe lifetime of the drwav object.\n\nThe buffer should contain the contents of the entire wave file, not just the sample data.\n*/\nDRWAV_API drwav_bool32 drwav_init_memory(drwav* pWav, const void* data, size_t dataSize, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_memory_ex(drwav* pWav, const void* data, size_t dataSize, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);\n\n/*\nHelper for initializing a writer which outputs data to a memory buffer.\n\ndr_wav will manage the memory allocations, however it is up to the caller to free the data with drwav_free().\n\nThe buffer will remain allocated even after drwav_uninit() is called. The buffer should not be considered valid\nuntil after drwav_uninit() has been called.\n*/\nDRWAV_API drwav_bool32 drwav_init_memory_write(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_memory_write_sequential(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_bool32 drwav_init_memory_write_sequential_pcm_frames(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks);\n\n\n#ifndef DR_WAV_NO_CONVERSION_API\n/*\nOpens and reads an entire wav file in a single operation.\n\nThe return value is a heap-allocated buffer containing the audio data. Use drwav_free() to free the buffer.\n*/\nDRWAV_API drwav_int16* drwav_open_and_read_pcm_frames_s16(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API float* drwav_open_and_read_pcm_frames_f32(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_int32* drwav_open_and_read_pcm_frames_s32(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\n#ifndef DR_WAV_NO_STDIO\n/*\nOpens and decodes an entire wav file in a single operation.\n\nThe return value is a heap-allocated buffer containing the audio data. Use drwav_free() to free the buffer.\n*/\nDRWAV_API drwav_int16* drwav_open_file_and_read_pcm_frames_s16(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API float* drwav_open_file_and_read_pcm_frames_f32(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_int32* drwav_open_file_and_read_pcm_frames_s32(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_int16* drwav_open_file_and_read_pcm_frames_s16_w(const wchar_t* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API float* drwav_open_file_and_read_pcm_frames_f32_w(const wchar_t* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_int32* drwav_open_file_and_read_pcm_frames_s32_w(const wchar_t* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\n#endif\n/*\nOpens and decodes an entire wav file from a block of memory in a single operation.\n\nThe return value is a heap-allocated buffer containing the audio data. Use drwav_free() to free the buffer.\n*/\nDRWAV_API drwav_int16* drwav_open_memory_and_read_pcm_frames_s16(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API float* drwav_open_memory_and_read_pcm_frames_f32(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\nDRWAV_API drwav_int32* drwav_open_memory_and_read_pcm_frames_s32(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);\n#endif\n\n/* Frees data that was allocated internally by dr_wav. */\nDRWAV_API void drwav_free(void* p, const drwav_allocation_callbacks* pAllocationCallbacks);\n\n/* Converts bytes from a wav stream to a sized type of native endian. */\nDRWAV_API drwav_uint16 drwav_bytes_to_u16(const drwav_uint8* data);\nDRWAV_API drwav_int16 drwav_bytes_to_s16(const drwav_uint8* data);\nDRWAV_API drwav_uint32 drwav_bytes_to_u32(const drwav_uint8* data);\nDRWAV_API drwav_int32 drwav_bytes_to_s32(const drwav_uint8* data);\nDRWAV_API drwav_uint64 drwav_bytes_to_u64(const drwav_uint8* data);\nDRWAV_API drwav_int64 drwav_bytes_to_s64(const drwav_uint8* data);\n\n/* Compares a GUID for the purpose of checking the type of a Wave64 chunk. */\nDRWAV_API drwav_bool32 drwav_guid_equal(const drwav_uint8 a[16], const drwav_uint8 b[16]);\n\n/* Compares a four-character-code for the purpose of checking the type of a RIFF chunk. */\nDRWAV_API drwav_bool32 drwav_fourcc_equal(const drwav_uint8* a, const char* b);\n\n#ifdef __cplusplus\n}\n#endif\n#endif  /* dr_wav_h */\n\n\n/************************************************************************************************************************************************************\n ************************************************************************************************************************************************************\n\n IMPLEMENTATION\n\n ************************************************************************************************************************************************************\n ************************************************************************************************************************************************************/\n#if defined(DR_WAV_IMPLEMENTATION) || defined(DRWAV_IMPLEMENTATION)\n#ifndef dr_wav_c\n#define dr_wav_c\n\n#include <stdlib.h>\n#include <string.h> /* For memcpy(), memset() */\n#include <limits.h> /* For INT_MAX */\n\n#ifndef DR_WAV_NO_STDIO\n#include <stdio.h>\n#include <wchar.h>\n#endif\n\n/* Standard library stuff. */\n#ifndef DRWAV_ASSERT\n#include <assert.h>\n#define DRWAV_ASSERT(expression)           assert(expression)\n#endif\n#ifndef DRWAV_MALLOC\n#define DRWAV_MALLOC(sz)                   malloc((sz))\n#endif\n#ifndef DRWAV_REALLOC\n#define DRWAV_REALLOC(p, sz)               realloc((p), (sz))\n#endif\n#ifndef DRWAV_FREE\n#define DRWAV_FREE(p)                      free((p))\n#endif\n#ifndef DRWAV_COPY_MEMORY\n#define DRWAV_COPY_MEMORY(dst, src, sz)    memcpy((dst), (src), (sz))\n#endif\n#ifndef DRWAV_ZERO_MEMORY\n#define DRWAV_ZERO_MEMORY(p, sz)           memset((p), 0, (sz))\n#endif\n#ifndef DRWAV_ZERO_OBJECT\n#define DRWAV_ZERO_OBJECT(p)               DRWAV_ZERO_MEMORY((p), sizeof(*p))\n#endif\n\n#define drwav_countof(x)                   (sizeof(x) / sizeof(x[0]))\n#define drwav_align(x, a)                  ((((x) + (a) - 1) / (a)) * (a))\n#define drwav_min(a, b)                    (((a) < (b)) ? (a) : (b))\n#define drwav_max(a, b)                    (((a) > (b)) ? (a) : (b))\n#define drwav_clamp(x, lo, hi)             (drwav_max((lo), drwav_min((hi), (x))))\n\n#define DRWAV_MAX_SIMD_VECTOR_SIZE         64  /* 64 for AVX-512 in the future. */\n\n/* CPU architecture. */\n#if defined(__x86_64__) || defined(_M_X64)\n    #define DRWAV_X64\n#elif defined(__i386) || defined(_M_IX86)\n    #define DRWAV_X86\n#elif defined(__arm__) || defined(_M_ARM)\n    #define DRWAV_ARM\n#endif\n\n#ifdef _MSC_VER\n    #define DRWAV_INLINE __forceinline\n#elif defined(__GNUC__)\n    /*\n    I've had a bug report where GCC is emitting warnings about functions possibly not being inlineable. This warning happens when\n    the __attribute__((always_inline)) attribute is defined without an \"inline\" statement. I think therefore there must be some\n    case where \"__inline__\" is not always defined, thus the compiler emitting these warnings. When using -std=c89 or -ansi on the\n    command line, we cannot use the \"inline\" keyword and instead need to use \"__inline__\". In an attempt to work around this issue\n    I am using \"__inline__\" only when we're compiling in strict ANSI mode.\n    */\n    #if defined(__STRICT_ANSI__)\n        #define DRWAV_INLINE __inline__ __attribute__((always_inline))\n    #else\n        #define DRWAV_INLINE inline __attribute__((always_inline))\n    #endif\n#elif defined(__WATCOMC__)\n    #define DRWAV_INLINE __inline\n#else\n    #define DRWAV_INLINE\n#endif\n\n#if defined(SIZE_MAX)\n    #define DRWAV_SIZE_MAX  SIZE_MAX\n#else\n    #if defined(_WIN64) || defined(_LP64) || defined(__LP64__)\n        #define DRWAV_SIZE_MAX  ((drwav_uint64)0xFFFFFFFFFFFFFFFF)\n    #else\n        #define DRWAV_SIZE_MAX  0xFFFFFFFF\n    #endif\n#endif\n\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n    #define DRWAV_HAS_BYTESWAP16_INTRINSIC\n    #define DRWAV_HAS_BYTESWAP32_INTRINSIC\n    #define DRWAV_HAS_BYTESWAP64_INTRINSIC\n#elif defined(__clang__)\n    #if defined(__has_builtin)\n        #if __has_builtin(__builtin_bswap16)\n            #define DRWAV_HAS_BYTESWAP16_INTRINSIC\n        #endif\n        #if __has_builtin(__builtin_bswap32)\n            #define DRWAV_HAS_BYTESWAP32_INTRINSIC\n        #endif\n        #if __has_builtin(__builtin_bswap64)\n            #define DRWAV_HAS_BYTESWAP64_INTRINSIC\n        #endif\n    #endif\n#elif defined(__GNUC__)\n    #if ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))\n        #define DRWAV_HAS_BYTESWAP32_INTRINSIC\n        #define DRWAV_HAS_BYTESWAP64_INTRINSIC\n    #endif\n    #if ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))\n        #define DRWAV_HAS_BYTESWAP16_INTRINSIC\n    #endif\n#endif\n\nDRWAV_API void drwav_version(drwav_uint32* pMajor, drwav_uint32* pMinor, drwav_uint32* pRevision)\n{\n    if (pMajor) {\n        *pMajor = DRWAV_VERSION_MAJOR;\n    }\n\n    if (pMinor) {\n        *pMinor = DRWAV_VERSION_MINOR;\n    }\n\n    if (pRevision) {\n        *pRevision = DRWAV_VERSION_REVISION;\n    }\n}\n\nDRWAV_API const char* drwav_version_string(void)\n{\n    return DRWAV_VERSION_STRING;\n}\n\n/*\nThese limits are used for basic validation when initializing the decoder. If you exceed these limits, first of all: what on Earth are\nyou doing?! (Let me know, I'd be curious!) Second, you can adjust these by #define-ing them before the dr_wav implementation.\n*/\n#ifndef DRWAV_MAX_SAMPLE_RATE\n#define DRWAV_MAX_SAMPLE_RATE       384000\n#endif\n#ifndef DRWAV_MAX_CHANNELS\n#define DRWAV_MAX_CHANNELS          256\n#endif\n#ifndef DRWAV_MAX_BITS_PER_SAMPLE\n#define DRWAV_MAX_BITS_PER_SAMPLE   64\n#endif\n\nstatic const drwav_uint8 drwavGUID_W64_RIFF[16] = {0x72,0x69,0x66,0x66, 0x2E,0x91, 0xCF,0x11, 0xA5,0xD6, 0x28,0xDB,0x04,0xC1,0x00,0x00};    /* 66666972-912E-11CF-A5D6-28DB04C10000 */\nstatic const drwav_uint8 drwavGUID_W64_WAVE[16] = {0x77,0x61,0x76,0x65, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 65766177-ACF3-11D3-8CD1-00C04F8EDB8A */\n/*static const drwav_uint8 drwavGUID_W64_JUNK[16] = {0x6A,0x75,0x6E,0x6B, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};*/    /* 6B6E756A-ACF3-11D3-8CD1-00C04F8EDB8A */\nstatic const drwav_uint8 drwavGUID_W64_FMT [16] = {0x66,0x6D,0x74,0x20, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 20746D66-ACF3-11D3-8CD1-00C04F8EDB8A */\nstatic const drwav_uint8 drwavGUID_W64_FACT[16] = {0x66,0x61,0x63,0x74, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 74636166-ACF3-11D3-8CD1-00C04F8EDB8A */\nstatic const drwav_uint8 drwavGUID_W64_DATA[16] = {0x64,0x61,0x74,0x61, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 61746164-ACF3-11D3-8CD1-00C04F8EDB8A */\nstatic const drwav_uint8 drwavGUID_W64_SMPL[16] = {0x73,0x6D,0x70,0x6C, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 6C706D73-ACF3-11D3-8CD1-00C04F8EDB8A */\n\nstatic DRWAV_INLINE drwav_bool32 drwav__guid_equal(const drwav_uint8 a[16], const drwav_uint8 b[16])\n{\n    int i;\n    for (i = 0; i < 16; i += 1) {\n        if (a[i] != b[i]) {\n            return DRWAV_FALSE;\n        }\n    }\n\n    return DRWAV_TRUE;\n}\n\nstatic DRWAV_INLINE drwav_bool32 drwav__fourcc_equal(const drwav_uint8* a, const char* b)\n{\n    return\n        a[0] == b[0] &&\n        a[1] == b[1] &&\n        a[2] == b[2] &&\n        a[3] == b[3];\n}\n\n\n\nstatic DRWAV_INLINE int drwav__is_little_endian(void)\n{\n#if defined(DRWAV_X86) || defined(DRWAV_X64)\n    return DRWAV_TRUE;\n#elif defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && __BYTE_ORDER == __LITTLE_ENDIAN\n    return DRWAV_TRUE;\n#else\n    int n = 1;\n    return (*(char*)&n) == 1;\n#endif\n}\n\nstatic DRWAV_INLINE drwav_uint16 drwav__bytes_to_u16(const drwav_uint8* data)\n{\n    return (data[0] << 0) | (data[1] << 8);\n}\n\nstatic DRWAV_INLINE drwav_int16 drwav__bytes_to_s16(const drwav_uint8* data)\n{\n    return (short)drwav__bytes_to_u16(data);\n}\n\nstatic DRWAV_INLINE drwav_uint32 drwav__bytes_to_u32(const drwav_uint8* data)\n{\n    return (data[0] << 0) | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n}\n\nstatic DRWAV_INLINE drwav_int32 drwav__bytes_to_s32(const drwav_uint8* data)\n{\n    return (drwav_int32)drwav__bytes_to_u32(data);\n}\n\nstatic DRWAV_INLINE drwav_uint64 drwav__bytes_to_u64(const drwav_uint8* data)\n{\n    return\n        ((drwav_uint64)data[0] <<  0) | ((drwav_uint64)data[1] <<  8) | ((drwav_uint64)data[2] << 16) | ((drwav_uint64)data[3] << 24) |\n        ((drwav_uint64)data[4] << 32) | ((drwav_uint64)data[5] << 40) | ((drwav_uint64)data[6] << 48) | ((drwav_uint64)data[7] << 56);\n}\n\nstatic DRWAV_INLINE drwav_int64 drwav__bytes_to_s64(const drwav_uint8* data)\n{\n    return (drwav_int64)drwav__bytes_to_u64(data);\n}\n\nstatic DRWAV_INLINE void drwav__bytes_to_guid(const drwav_uint8* data, drwav_uint8* guid)\n{\n    int i;\n    for (i = 0; i < 16; ++i) {\n        guid[i] = data[i];\n    }\n}\n\n\nstatic DRWAV_INLINE drwav_uint16 drwav__bswap16(drwav_uint16 n)\n{\n#ifdef DRWAV_HAS_BYTESWAP16_INTRINSIC\n    #if defined(_MSC_VER)\n        return _byteswap_ushort(n);\n    #elif defined(__GNUC__) || defined(__clang__)\n        return __builtin_bswap16(n);\n    #else\n        #error \"This compiler does not support the byte swap intrinsic.\"\n    #endif\n#else\n    return ((n & 0xFF00) >> 8) |\n           ((n & 0x00FF) << 8);\n#endif\n}\n\nstatic DRWAV_INLINE drwav_uint32 drwav__bswap32(drwav_uint32 n)\n{\n#ifdef DRWAV_HAS_BYTESWAP32_INTRINSIC\n    #if defined(_MSC_VER)\n        return _byteswap_ulong(n);\n    #elif defined(__GNUC__) || defined(__clang__)\n        #if defined(DRWAV_ARM) && (defined(__ARM_ARCH) && __ARM_ARCH >= 6) && !defined(DRWAV_64BIT)   /* <-- 64-bit inline assembly has not been tested, so disabling for now. */\n            /* Inline assembly optimized implementation for ARM. In my testing, GCC does not generate optimized code with __builtin_bswap32(). */\n            drwav_uint32 r;\n            __asm__ __volatile__ (\n            #if defined(DRWAV_64BIT)\n                \"rev %w[out], %w[in]\" : [out]\"=r\"(r) : [in]\"r\"(n)   /* <-- This is untested. If someone in the community could test this, that would be appreciated! */\n            #else\n                \"rev %[out], %[in]\" : [out]\"=r\"(r) : [in]\"r\"(n)\n            #endif\n            );\n            return r;\n        #else\n            return __builtin_bswap32(n);\n        #endif\n    #else\n        #error \"This compiler does not support the byte swap intrinsic.\"\n    #endif\n#else\n    return ((n & 0xFF000000) >> 24) |\n           ((n & 0x00FF0000) >>  8) |\n           ((n & 0x0000FF00) <<  8) |\n           ((n & 0x000000FF) << 24);\n#endif\n}\n\nstatic DRWAV_INLINE drwav_uint64 drwav__bswap64(drwav_uint64 n)\n{\n#ifdef DRWAV_HAS_BYTESWAP64_INTRINSIC\n    #if defined(_MSC_VER)\n        return _byteswap_uint64(n);\n    #elif defined(__GNUC__) || defined(__clang__)\n        return __builtin_bswap64(n);\n    #else\n        #error \"This compiler does not support the byte swap intrinsic.\"\n    #endif\n#else\n    /* Weird \"<< 32\" bitshift is required for C89 because it doesn't support 64-bit constants. Should be optimized out by a good compiler. */\n    return ((n & ((drwav_uint64)0xFF000000 << 32)) >> 56) |\n           ((n & ((drwav_uint64)0x00FF0000 << 32)) >> 40) |\n           ((n & ((drwav_uint64)0x0000FF00 << 32)) >> 24) |\n           ((n & ((drwav_uint64)0x000000FF << 32)) >>  8) |\n           ((n & ((drwav_uint64)0xFF000000      )) <<  8) |\n           ((n & ((drwav_uint64)0x00FF0000      )) << 24) |\n           ((n & ((drwav_uint64)0x0000FF00      )) << 40) |\n           ((n & ((drwav_uint64)0x000000FF      )) << 56);\n#endif\n}\n\n\nstatic DRWAV_INLINE drwav_int16 drwav__bswap_s16(drwav_int16 n)\n{\n    return (drwav_int16)drwav__bswap16((drwav_uint16)n);\n}\n\nstatic DRWAV_INLINE void drwav__bswap_samples_s16(drwav_int16* pSamples, drwav_uint64 sampleCount)\n{\n    drwav_uint64 iSample;\n    for (iSample = 0; iSample < sampleCount; iSample += 1) {\n        pSamples[iSample] = drwav__bswap_s16(pSamples[iSample]);\n    }\n}\n\n\nstatic DRWAV_INLINE void drwav__bswap_s24(drwav_uint8* p)\n{\n    drwav_uint8 t;\n    t = p[0];\n    p[0] = p[2];\n    p[2] = t;\n}\n\nstatic DRWAV_INLINE void drwav__bswap_samples_s24(drwav_uint8* pSamples, drwav_uint64 sampleCount)\n{\n    drwav_uint64 iSample;\n    for (iSample = 0; iSample < sampleCount; iSample += 1) {\n        drwav_uint8* pSample = pSamples + (iSample*3);\n        drwav__bswap_s24(pSample);\n    }\n}\n\n\nstatic DRWAV_INLINE drwav_int32 drwav__bswap_s32(drwav_int32 n)\n{\n    return (drwav_int32)drwav__bswap32((drwav_uint32)n);\n}\n\nstatic DRWAV_INLINE void drwav__bswap_samples_s32(drwav_int32* pSamples, drwav_uint64 sampleCount)\n{\n    drwav_uint64 iSample;\n    for (iSample = 0; iSample < sampleCount; iSample += 1) {\n        pSamples[iSample] = drwav__bswap_s32(pSamples[iSample]);\n    }\n}\n\n\nstatic DRWAV_INLINE float drwav__bswap_f32(float n)\n{\n    union {\n        drwav_uint32 i;\n        float f;\n    } x;\n    x.f = n;\n    x.i = drwav__bswap32(x.i);\n\n    return x.f;\n}\n\nstatic DRWAV_INLINE void drwav__bswap_samples_f32(float* pSamples, drwav_uint64 sampleCount)\n{\n    drwav_uint64 iSample;\n    for (iSample = 0; iSample < sampleCount; iSample += 1) {\n        pSamples[iSample] = drwav__bswap_f32(pSamples[iSample]);\n    }\n}\n\n\nstatic DRWAV_INLINE double drwav__bswap_f64(double n)\n{\n    union {\n        drwav_uint64 i;\n        double f;\n    } x;\n    x.f = n;\n    x.i = drwav__bswap64(x.i);\n\n    return x.f;\n}\n\nstatic DRWAV_INLINE void drwav__bswap_samples_f64(double* pSamples, drwav_uint64 sampleCount)\n{\n    drwav_uint64 iSample;\n    for (iSample = 0; iSample < sampleCount; iSample += 1) {\n        pSamples[iSample] = drwav__bswap_f64(pSamples[iSample]);\n    }\n}\n\n\nstatic DRWAV_INLINE void drwav__bswap_samples_pcm(void* pSamples, drwav_uint64 sampleCount, drwav_uint32 bytesPerSample)\n{\n    /* Assumes integer PCM. Floating point PCM is done in drwav__bswap_samples_ieee(). */\n    switch (bytesPerSample)\n    {\n        case 2: /* s16, s12 (loosely packed) */\n        {\n            drwav__bswap_samples_s16((drwav_int16*)pSamples, sampleCount);\n        } break;\n        case 3: /* s24 */\n        {\n            drwav__bswap_samples_s24((drwav_uint8*)pSamples, sampleCount);\n        } break;\n        case 4: /* s32 */\n        {\n            drwav__bswap_samples_s32((drwav_int32*)pSamples, sampleCount);\n        } break;\n        default:\n        {\n            /* Unsupported format. */\n            DRWAV_ASSERT(DRWAV_FALSE);\n        } break;\n    }\n}\n\nstatic DRWAV_INLINE void drwav__bswap_samples_ieee(void* pSamples, drwav_uint64 sampleCount, drwav_uint32 bytesPerSample)\n{\n    switch (bytesPerSample)\n    {\n    #if 0   /* Contributions welcome for f16 support. */\n        case 2: /* f16 */\n        {\n            drwav__bswap_samples_f16((drwav_float16*)pSamples, sampleCount);\n        } break;\n    #endif\n        case 4: /* f32 */\n        {\n            drwav__bswap_samples_f32((float*)pSamples, sampleCount);\n        } break;\n        case 8: /* f64 */\n        {\n            drwav__bswap_samples_f64((double*)pSamples, sampleCount);\n        } break;\n        default:\n        {\n            /* Unsupported format. */\n            DRWAV_ASSERT(DRWAV_FALSE);\n        } break;\n    }\n}\n\nstatic DRWAV_INLINE void drwav__bswap_samples(void* pSamples, drwav_uint64 sampleCount, drwav_uint32 bytesPerSample, drwav_uint16 format)\n{\n    switch (format)\n    {\n        case DR_WAVE_FORMAT_PCM:\n        {\n            drwav__bswap_samples_pcm(pSamples, sampleCount, bytesPerSample);\n        } break;\n\n        case DR_WAVE_FORMAT_IEEE_FLOAT:\n        {\n            drwav__bswap_samples_ieee(pSamples, sampleCount, bytesPerSample);\n        } break;\n\n        case DR_WAVE_FORMAT_ALAW:\n        case DR_WAVE_FORMAT_MULAW:\n        {\n            drwav__bswap_samples_s16((drwav_int16*)pSamples, sampleCount);\n        } break;\n\n        case DR_WAVE_FORMAT_ADPCM:\n        case DR_WAVE_FORMAT_DVI_ADPCM:\n        default:\n        {\n            /* Unsupported format. */\n            DRWAV_ASSERT(DRWAV_FALSE);\n        } break;\n    }\n}\n\n\nstatic void* drwav__malloc_default(size_t sz, void* pUserData)\n{\n    (void)pUserData;\n    return DRWAV_MALLOC(sz);\n}\n\nstatic void* drwav__realloc_default(void* p, size_t sz, void* pUserData)\n{\n    (void)pUserData;\n    return DRWAV_REALLOC(p, sz);\n}\n\nstatic void drwav__free_default(void* p, void* pUserData)\n{\n    (void)pUserData;\n    DRWAV_FREE(p);\n}\n\n\nstatic void* drwav__malloc_from_callbacks(size_t sz, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pAllocationCallbacks == NULL) {\n        return NULL;\n    }\n\n    if (pAllocationCallbacks->onMalloc != NULL) {\n        return pAllocationCallbacks->onMalloc(sz, pAllocationCallbacks->pUserData);\n    }\n\n    /* Try using realloc(). */\n    if (pAllocationCallbacks->onRealloc != NULL) {\n        return pAllocationCallbacks->onRealloc(NULL, sz, pAllocationCallbacks->pUserData);\n    }\n\n    return NULL;\n}\n\nstatic void* drwav__realloc_from_callbacks(void* p, size_t szNew, size_t szOld, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pAllocationCallbacks == NULL) {\n        return NULL;\n    }\n\n    if (pAllocationCallbacks->onRealloc != NULL) {\n        return pAllocationCallbacks->onRealloc(p, szNew, pAllocationCallbacks->pUserData);\n    }\n\n    /* Try emulating realloc() in terms of malloc()/free(). */\n    if (pAllocationCallbacks->onMalloc != NULL && pAllocationCallbacks->onFree != NULL) {\n        void* p2;\n\n        p2 = pAllocationCallbacks->onMalloc(szNew, pAllocationCallbacks->pUserData);\n        if (p2 == NULL) {\n            return NULL;\n        }\n\n        if (p != NULL) {\n            DRWAV_COPY_MEMORY(p2, p, szOld);\n            pAllocationCallbacks->onFree(p, pAllocationCallbacks->pUserData);\n        }\n\n        return p2;\n    }\n\n    return NULL;\n}\n\nstatic void drwav__free_from_callbacks(void* p, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (p == NULL || pAllocationCallbacks == NULL) {\n        return;\n    }\n\n    if (pAllocationCallbacks->onFree != NULL) {\n        pAllocationCallbacks->onFree(p, pAllocationCallbacks->pUserData);\n    }\n}\n\n\nstatic drwav_allocation_callbacks drwav_copy_allocation_callbacks_or_defaults(const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pAllocationCallbacks != NULL) {\n        /* Copy. */\n        return *pAllocationCallbacks;\n    } else {\n        /* Defaults. */\n        drwav_allocation_callbacks allocationCallbacks;\n        allocationCallbacks.pUserData = NULL;\n        allocationCallbacks.onMalloc  = drwav__malloc_default;\n        allocationCallbacks.onRealloc = drwav__realloc_default;\n        allocationCallbacks.onFree    = drwav__free_default;\n        return allocationCallbacks;\n    }\n}\n\n\nstatic DRWAV_INLINE drwav_bool32 drwav__is_compressed_format_tag(drwav_uint16 formatTag)\n{\n    return\n        formatTag == DR_WAVE_FORMAT_ADPCM ||\n        formatTag == DR_WAVE_FORMAT_DVI_ADPCM;\n}\n\nstatic unsigned int drwav__chunk_padding_size_riff(drwav_uint64 chunkSize)\n{\n    return (unsigned int)(chunkSize % 2);\n}\n\nstatic unsigned int drwav__chunk_padding_size_w64(drwav_uint64 chunkSize)\n{\n    return (unsigned int)(chunkSize % 8);\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s16__msadpcm(drwav* pWav, drwav_uint64 samplesToRead, drwav_int16* pBufferOut);\nstatic drwav_uint64 drwav_read_pcm_frames_s16__ima(drwav* pWav, drwav_uint64 samplesToRead, drwav_int16* pBufferOut);\nstatic drwav_bool32 drwav_init_write__internal(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount);\n\nstatic drwav_result drwav__read_chunk_header(drwav_read_proc onRead, void* pUserData, drwav_container container, drwav_uint64* pRunningBytesReadOut, drwav_chunk_header* pHeaderOut)\n{\n    if (container == drwav_container_riff || container == drwav_container_rf64) {\n        drwav_uint8 sizeInBytes[4];\n\n        if (onRead(pUserData, pHeaderOut->id.fourcc, 4) != 4) {\n            return DRWAV_AT_END;\n        }\n\n        if (onRead(pUserData, sizeInBytes, 4) != 4) {\n            return DRWAV_INVALID_FILE;\n        }\n\n        pHeaderOut->sizeInBytes = drwav__bytes_to_u32(sizeInBytes);\n        pHeaderOut->paddingSize = drwav__chunk_padding_size_riff(pHeaderOut->sizeInBytes);\n        *pRunningBytesReadOut += 8;\n    } else {\n        drwav_uint8 sizeInBytes[8];\n\n        if (onRead(pUserData, pHeaderOut->id.guid, 16) != 16) {\n            return DRWAV_AT_END;\n        }\n\n        if (onRead(pUserData, sizeInBytes, 8) != 8) {\n            return DRWAV_INVALID_FILE;\n        }\n\n        pHeaderOut->sizeInBytes = drwav__bytes_to_u64(sizeInBytes) - 24;    /* <-- Subtract 24 because w64 includes the size of the header. */\n        pHeaderOut->paddingSize = drwav__chunk_padding_size_w64(pHeaderOut->sizeInBytes);\n        *pRunningBytesReadOut += 24;\n    }\n\n    return DRWAV_SUCCESS;\n}\n\nstatic drwav_bool32 drwav__seek_forward(drwav_seek_proc onSeek, drwav_uint64 offset, void* pUserData)\n{\n    drwav_uint64 bytesRemainingToSeek = offset;\n    while (bytesRemainingToSeek > 0) {\n        if (bytesRemainingToSeek > 0x7FFFFFFF) {\n            if (!onSeek(pUserData, 0x7FFFFFFF, drwav_seek_origin_current)) {\n                return DRWAV_FALSE;\n            }\n            bytesRemainingToSeek -= 0x7FFFFFFF;\n        } else {\n            if (!onSeek(pUserData, (int)bytesRemainingToSeek, drwav_seek_origin_current)) {\n                return DRWAV_FALSE;\n            }\n            bytesRemainingToSeek = 0;\n        }\n    }\n\n    return DRWAV_TRUE;\n}\n\nstatic drwav_bool32 drwav__seek_from_start(drwav_seek_proc onSeek, drwav_uint64 offset, void* pUserData)\n{\n    if (offset <= 0x7FFFFFFF) {\n        return onSeek(pUserData, (int)offset, drwav_seek_origin_start);\n    }\n\n    /* Larger than 32-bit seek. */\n    if (!onSeek(pUserData, 0x7FFFFFFF, drwav_seek_origin_start)) {\n        return DRWAV_FALSE;\n    }\n    offset -= 0x7FFFFFFF;\n\n    for (;;) {\n        if (offset <= 0x7FFFFFFF) {\n            return onSeek(pUserData, (int)offset, drwav_seek_origin_current);\n        }\n\n        if (!onSeek(pUserData, 0x7FFFFFFF, drwav_seek_origin_current)) {\n            return DRWAV_FALSE;\n        }\n        offset -= 0x7FFFFFFF;\n    }\n\n    /* Should never get here. */\n    /*return DRWAV_TRUE; */\n}\n\n\nstatic drwav_bool32 drwav__read_fmt(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, drwav_container container, drwav_uint64* pRunningBytesReadOut, drwav_fmt* fmtOut)\n{\n    drwav_chunk_header header;\n    drwav_uint8 fmt[16];\n\n    if (drwav__read_chunk_header(onRead, pUserData, container, pRunningBytesReadOut, &header) != DRWAV_SUCCESS) {\n        return DRWAV_FALSE;\n    }\n\n\n    /* Skip non-fmt chunks. */\n    while (((container == drwav_container_riff || container == drwav_container_rf64) && !drwav__fourcc_equal(header.id.fourcc, \"fmt \")) || (container == drwav_container_w64 && !drwav__guid_equal(header.id.guid, drwavGUID_W64_FMT))) {\n        if (!drwav__seek_forward(onSeek, header.sizeInBytes + header.paddingSize, pUserData)) {\n            return DRWAV_FALSE;\n        }\n        *pRunningBytesReadOut += header.sizeInBytes + header.paddingSize;\n\n        /* Try the next header. */\n        if (drwav__read_chunk_header(onRead, pUserData, container, pRunningBytesReadOut, &header) != DRWAV_SUCCESS) {\n            return DRWAV_FALSE;\n        }\n    }\n\n\n    /* Validation. */\n    if (container == drwav_container_riff || container == drwav_container_rf64) {\n        if (!drwav__fourcc_equal(header.id.fourcc, \"fmt \")) {\n            return DRWAV_FALSE;\n        }\n    } else {\n        if (!drwav__guid_equal(header.id.guid, drwavGUID_W64_FMT)) {\n            return DRWAV_FALSE;\n        }\n    }\n\n\n    if (onRead(pUserData, fmt, sizeof(fmt)) != sizeof(fmt)) {\n        return DRWAV_FALSE;\n    }\n    *pRunningBytesReadOut += sizeof(fmt);\n\n    fmtOut->formatTag      = drwav__bytes_to_u16(fmt + 0);\n    fmtOut->channels       = drwav__bytes_to_u16(fmt + 2);\n    fmtOut->sampleRate     = drwav__bytes_to_u32(fmt + 4);\n    fmtOut->avgBytesPerSec = drwav__bytes_to_u32(fmt + 8);\n    fmtOut->blockAlign     = drwav__bytes_to_u16(fmt + 12);\n    fmtOut->bitsPerSample  = drwav__bytes_to_u16(fmt + 14);\n\n    fmtOut->extendedSize       = 0;\n    fmtOut->validBitsPerSample = 0;\n    fmtOut->channelMask        = 0;\n    memset(fmtOut->subFormat, 0, sizeof(fmtOut->subFormat));\n\n    if (header.sizeInBytes > 16) {\n        drwav_uint8 fmt_cbSize[2];\n        int bytesReadSoFar = 0;\n\n        if (onRead(pUserData, fmt_cbSize, sizeof(fmt_cbSize)) != sizeof(fmt_cbSize)) {\n            return DRWAV_FALSE;    /* Expecting more data. */\n        }\n        *pRunningBytesReadOut += sizeof(fmt_cbSize);\n\n        bytesReadSoFar = 18;\n\n        fmtOut->extendedSize = drwav__bytes_to_u16(fmt_cbSize);\n        if (fmtOut->extendedSize > 0) {\n            /* Simple validation. */\n            if (fmtOut->formatTag == DR_WAVE_FORMAT_EXTENSIBLE) {\n                if (fmtOut->extendedSize != 22) {\n                    return DRWAV_FALSE;\n                }\n            }\n\n            if (fmtOut->formatTag == DR_WAVE_FORMAT_EXTENSIBLE) {\n                drwav_uint8 fmtext[22];\n                if (onRead(pUserData, fmtext, fmtOut->extendedSize) != fmtOut->extendedSize) {\n                    return DRWAV_FALSE;    /* Expecting more data. */\n                }\n\n                fmtOut->validBitsPerSample = drwav__bytes_to_u16(fmtext + 0);\n                fmtOut->channelMask        = drwav__bytes_to_u32(fmtext + 2);\n                drwav__bytes_to_guid(fmtext + 6, fmtOut->subFormat);\n            } else {\n                if (!onSeek(pUserData, fmtOut->extendedSize, drwav_seek_origin_current)) {\n                    return DRWAV_FALSE;\n                }\n            }\n            *pRunningBytesReadOut += fmtOut->extendedSize;\n\n            bytesReadSoFar += fmtOut->extendedSize;\n        }\n\n        /* Seek past any leftover bytes. For w64 the leftover will be defined based on the chunk size. */\n        if (!onSeek(pUserData, (int)(header.sizeInBytes - bytesReadSoFar), drwav_seek_origin_current)) {\n            return DRWAV_FALSE;\n        }\n        *pRunningBytesReadOut += (header.sizeInBytes - bytesReadSoFar);\n    }\n\n    if (header.paddingSize > 0) {\n        if (!onSeek(pUserData, header.paddingSize, drwav_seek_origin_current)) {\n            return DRWAV_FALSE;\n        }\n        *pRunningBytesReadOut += header.paddingSize;\n    }\n\n    return DRWAV_TRUE;\n}\n\n\nstatic size_t drwav__on_read(drwav_read_proc onRead, void* pUserData, void* pBufferOut, size_t bytesToRead, drwav_uint64* pCursor)\n{\n    size_t bytesRead;\n\n    DRWAV_ASSERT(onRead != NULL);\n    DRWAV_ASSERT(pCursor != NULL);\n\n    bytesRead = onRead(pUserData, pBufferOut, bytesToRead);\n    *pCursor += bytesRead;\n    return bytesRead;\n}\n\n#if 0\nstatic drwav_bool32 drwav__on_seek(drwav_seek_proc onSeek, void* pUserData, int offset, drwav_seek_origin origin, drwav_uint64* pCursor)\n{\n    DRWAV_ASSERT(onSeek != NULL);\n    DRWAV_ASSERT(pCursor != NULL);\n\n    if (!onSeek(pUserData, offset, origin)) {\n        return DRWAV_FALSE;\n    }\n\n    if (origin == drwav_seek_origin_start) {\n        *pCursor = offset;\n    } else {\n        *pCursor += offset;\n    }\n\n    return DRWAV_TRUE;\n}\n#endif\n\n\n\nstatic drwav_uint32 drwav_get_bytes_per_pcm_frame(drwav* pWav)\n{\n    /*\n    The bytes per frame is a bit ambiguous. It can be either be based on the bits per sample, or the block align. The way I'm doing it here\n    is that if the bits per sample is a multiple of 8, use floor(bitsPerSample*channels/8), otherwise fall back to the block align.\n    */\n    if ((pWav->bitsPerSample & 0x7) == 0) {\n        /* Bits per sample is a multiple of 8. */\n        return (pWav->bitsPerSample * pWav->fmt.channels) >> 3;\n    } else {\n        return pWav->fmt.blockAlign;\n    }\n}\n\nDRWAV_API drwav_uint16 drwav_fmt_get_format(const drwav_fmt* pFMT)\n{\n    if (pFMT == NULL) {\n        return 0;\n    }\n\n    if (pFMT->formatTag != DR_WAVE_FORMAT_EXTENSIBLE) {\n        return pFMT->formatTag;\n    } else {\n        return drwav__bytes_to_u16(pFMT->subFormat);    /* Only the first two bytes are required. */\n    }\n}\n\nstatic drwav_bool32 drwav_preinit(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pReadSeekUserData, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pWav == NULL || onRead == NULL || onSeek == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    DRWAV_ZERO_MEMORY(pWav, sizeof(*pWav));\n    pWav->onRead    = onRead;\n    pWav->onSeek    = onSeek;\n    pWav->pUserData = pReadSeekUserData;\n    pWav->allocationCallbacks = drwav_copy_allocation_callbacks_or_defaults(pAllocationCallbacks);\n\n    if (pWav->allocationCallbacks.onFree == NULL || (pWav->allocationCallbacks.onMalloc == NULL && pWav->allocationCallbacks.onRealloc == NULL)) {\n        return DRWAV_FALSE;    /* Invalid allocation callbacks. */\n    }\n\n    return DRWAV_TRUE;\n}\n\nstatic drwav_bool32 drwav_init__internal(drwav* pWav, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags)\n{\n    /* This function assumes drwav_preinit() has been called beforehand. */\n\n    drwav_uint64 cursor;    /* <-- Keeps track of the byte position so we can seek to specific locations. */\n    drwav_bool32 sequential;\n    drwav_uint8 riff[4];\n    drwav_fmt fmt;\n    unsigned short translatedFormatTag;\n    drwav_bool32 foundDataChunk;\n    drwav_uint64 dataChunkSize = 0; /* <-- Important! Don't explicitly set this to 0 anywhere else. Calculation of the size of the data chunk is performed in different paths depending on the container. */\n    drwav_uint64 sampleCountFromFactChunk = 0;  /* Same as dataChunkSize - make sure this is the only place this is initialized to 0. */\n    drwav_uint64 chunkSize;\n\n    cursor = 0;\n    sequential = (flags & DRWAV_SEQUENTIAL) != 0;\n\n    /* The first 4 bytes should be the RIFF identifier. */\n    if (drwav__on_read(pWav->onRead, pWav->pUserData, riff, sizeof(riff), &cursor) != sizeof(riff)) {\n        return DRWAV_FALSE;\n    }\n\n    /*\n    The first 4 bytes can be used to identify the container. For RIFF files it will start with \"RIFF\" and for\n    w64 it will start with \"riff\".\n    */\n    if (drwav__fourcc_equal(riff, \"RIFF\")) {\n        pWav->container = drwav_container_riff;\n    } else if (drwav__fourcc_equal(riff, \"riff\")) {\n        int i;\n        drwav_uint8 riff2[12];\n\n        pWav->container = drwav_container_w64;\n\n        /* Check the rest of the GUID for validity. */\n        if (drwav__on_read(pWav->onRead, pWav->pUserData, riff2, sizeof(riff2), &cursor) != sizeof(riff2)) {\n            return DRWAV_FALSE;\n        }\n\n        for (i = 0; i < 12; ++i) {\n            if (riff2[i] != drwavGUID_W64_RIFF[i+4]) {\n                return DRWAV_FALSE;\n            }\n        }\n    } else if (drwav__fourcc_equal(riff, \"RF64\")) {\n        pWav->container = drwav_container_rf64;\n    } else {\n        return DRWAV_FALSE;   /* Unknown or unsupported container. */\n    }\n\n\n    if (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64) {\n        drwav_uint8 chunkSizeBytes[4];\n        drwav_uint8 wave[4];\n\n        /* RIFF/WAVE */\n        if (drwav__on_read(pWav->onRead, pWav->pUserData, chunkSizeBytes, sizeof(chunkSizeBytes), &cursor) != sizeof(chunkSizeBytes)) {\n            return DRWAV_FALSE;\n        }\n\n        if (pWav->container == drwav_container_riff) {\n            if (drwav__bytes_to_u32(chunkSizeBytes) < 36) {\n                return DRWAV_FALSE;    /* Chunk size should always be at least 36 bytes. */\n            }\n        } else {\n            if (drwav__bytes_to_u32(chunkSizeBytes) != 0xFFFFFFFF) {\n                return DRWAV_FALSE;    /* Chunk size should always be set to -1/0xFFFFFFFF for RF64. The actual size is retrieved later. */\n            }\n        }\n\n        if (drwav__on_read(pWav->onRead, pWav->pUserData, wave, sizeof(wave), &cursor) != sizeof(wave)) {\n            return DRWAV_FALSE;\n        }\n\n        if (!drwav__fourcc_equal(wave, \"WAVE\")) {\n            return DRWAV_FALSE;    /* Expecting \"WAVE\". */\n        }\n    } else {\n        drwav_uint8 chunkSizeBytes[8];\n        drwav_uint8 wave[16];\n\n        /* W64 */\n        if (drwav__on_read(pWav->onRead, pWav->pUserData, chunkSizeBytes, sizeof(chunkSizeBytes), &cursor) != sizeof(chunkSizeBytes)) {\n            return DRWAV_FALSE;\n        }\n\n        if (drwav__bytes_to_u64(chunkSizeBytes) < 80) {\n            return DRWAV_FALSE;\n        }\n\n        if (drwav__on_read(pWav->onRead, pWav->pUserData, wave, sizeof(wave), &cursor) != sizeof(wave)) {\n            return DRWAV_FALSE;\n        }\n\n        if (!drwav__guid_equal(wave, drwavGUID_W64_WAVE)) {\n            return DRWAV_FALSE;\n        }\n    }\n\n\n    /* For RF64, the \"ds64\" chunk must come next, before the \"fmt \" chunk. */\n    if (pWav->container == drwav_container_rf64) {\n        drwav_uint8 sizeBytes[8];\n        drwav_uint64 bytesRemainingInChunk;\n        drwav_chunk_header header;\n        drwav_result result = drwav__read_chunk_header(pWav->onRead, pWav->pUserData, pWav->container, &cursor, &header);\n        if (result != DRWAV_SUCCESS) {\n            return DRWAV_FALSE;\n        }\n\n        if (!drwav__fourcc_equal(header.id.fourcc, \"ds64\")) {\n            return DRWAV_FALSE; /* Expecting \"ds64\". */\n        }\n\n        bytesRemainingInChunk = header.sizeInBytes + header.paddingSize;\n\n        /* We don't care about the size of the RIFF chunk - skip it. */\n        if (!drwav__seek_forward(pWav->onSeek, 8, pWav->pUserData)) {\n            return DRWAV_FALSE;\n        }\n        bytesRemainingInChunk -= 8;\n        cursor += 8;\n\n\n        /* Next 8 bytes is the size of the \"data\" chunk. */\n        if (drwav__on_read(pWav->onRead, pWav->pUserData, sizeBytes, sizeof(sizeBytes), &cursor) != sizeof(sizeBytes)) {\n            return DRWAV_FALSE;\n        }\n        bytesRemainingInChunk -= 8;\n        dataChunkSize = drwav__bytes_to_u64(sizeBytes);\n\n\n        /* Next 8 bytes is the same count which we would usually derived from the FACT chunk if it was available. */\n        if (drwav__on_read(pWav->onRead, pWav->pUserData, sizeBytes, sizeof(sizeBytes), &cursor) != sizeof(sizeBytes)) {\n            return DRWAV_FALSE;\n        }\n        bytesRemainingInChunk -= 8;\n        sampleCountFromFactChunk = drwav__bytes_to_u64(sizeBytes);\n\n\n        /* Skip over everything else. */\n        if (!drwav__seek_forward(pWav->onSeek, bytesRemainingInChunk, pWav->pUserData)) {\n            return DRWAV_FALSE;\n        }\n        cursor += bytesRemainingInChunk;\n    }\n\n\n    /* The next bytes should be the \"fmt \" chunk. */\n    if (!drwav__read_fmt(pWav->onRead, pWav->onSeek, pWav->pUserData, pWav->container, &cursor, &fmt)) {\n        return DRWAV_FALSE;    /* Failed to read the \"fmt \" chunk. */\n    }\n\n    /* Basic validation. */\n    if ((fmt.sampleRate    == 0 || fmt.sampleRate    > DRWAV_MAX_SAMPLE_RATE)     ||\n        (fmt.channels      == 0 || fmt.channels      > DRWAV_MAX_CHANNELS)        ||\n        (fmt.bitsPerSample == 0 || fmt.bitsPerSample > DRWAV_MAX_BITS_PER_SAMPLE) ||\n        fmt.blockAlign == 0) {\n        return DRWAV_FALSE; /* Probably an invalid WAV file. */\n    }\n\n\n    /* Translate the internal format. */\n    translatedFormatTag = fmt.formatTag;\n    if (translatedFormatTag == DR_WAVE_FORMAT_EXTENSIBLE) {\n        translatedFormatTag = drwav__bytes_to_u16(fmt.subFormat + 0);\n    }\n\n\n    /*\n    We need to enumerate over each chunk for two reasons:\n      1) The \"data\" chunk may not be the next one\n      2) We may want to report each chunk back to the client\n    \n    In order to correctly report each chunk back to the client we will need to keep looping until the end of the file.\n    */\n    foundDataChunk = DRWAV_FALSE;\n\n    /* The next chunk we care about is the \"data\" chunk. This is not necessarily the next chunk so we'll need to loop. */\n    for (;;)\n    {\n        drwav_chunk_header header;\n        drwav_result result = drwav__read_chunk_header(pWav->onRead, pWav->pUserData, pWav->container, &cursor, &header);\n        if (result != DRWAV_SUCCESS) {\n            if (!foundDataChunk) {\n                return DRWAV_FALSE;\n            } else {\n                break;  /* Probably at the end of the file. Get out of the loop. */\n            }\n        }\n\n        /* Tell the client about this chunk. */\n        if (!sequential && onChunk != NULL) {\n            drwav_uint64 callbackBytesRead = onChunk(pChunkUserData, pWav->onRead, pWav->onSeek, pWav->pUserData, &header, pWav->container, &fmt);\n\n            /*\n            dr_wav may need to read the contents of the chunk, so we now need to seek back to the position before\n            we called the callback.\n            */\n            if (callbackBytesRead > 0) {\n                if (!drwav__seek_from_start(pWav->onSeek, cursor, pWav->pUserData)) {\n                    return DRWAV_FALSE;\n                }\n            }\n        }\n        \n\n        if (!foundDataChunk) {\n            pWav->dataChunkDataPos = cursor;\n        }\n\n        chunkSize = header.sizeInBytes;\n        if (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64) {\n            if (drwav__fourcc_equal(header.id.fourcc, \"data\")) {\n                foundDataChunk = DRWAV_TRUE;\n                if (pWav->container != drwav_container_rf64) {  /* The data chunk size for RF64 will always be set to 0xFFFFFFFF here. It was set to it's true value earlier. */\n                    dataChunkSize = chunkSize;\n                }\n            }\n        } else {\n            if (drwav__guid_equal(header.id.guid, drwavGUID_W64_DATA)) {\n                foundDataChunk = DRWAV_TRUE;\n                dataChunkSize = chunkSize;\n            }\n        }\n\n        /*\n        If at this point we have found the data chunk and we're running in sequential mode, we need to break out of this loop. The reason for\n        this is that we would otherwise require a backwards seek which sequential mode forbids.\n        */\n        if (foundDataChunk && sequential) {\n            break;\n        }\n\n        /* Optional. Get the total sample count from the FACT chunk. This is useful for compressed formats. */\n        if (pWav->container == drwav_container_riff) {\n            if (drwav__fourcc_equal(header.id.fourcc, \"fact\")) {\n                drwav_uint32 sampleCount;\n                if (drwav__on_read(pWav->onRead, pWav->pUserData, &sampleCount, 4, &cursor) != 4) {\n                    return DRWAV_FALSE;\n                }\n                chunkSize -= 4;\n\n                if (!foundDataChunk) {\n                    pWav->dataChunkDataPos = cursor;\n                }\n\n                /*\n                The sample count in the \"fact\" chunk is either unreliable, or I'm not understanding it properly. For now I am only enabling this\n                for Microsoft ADPCM formats.\n                */\n                if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n                    sampleCountFromFactChunk = sampleCount;\n                } else {\n                    sampleCountFromFactChunk = 0;\n                }\n            }\n        } else if (pWav->container == drwav_container_w64) {\n            if (drwav__guid_equal(header.id.guid, drwavGUID_W64_FACT)) {\n                if (drwav__on_read(pWav->onRead, pWav->pUserData, &sampleCountFromFactChunk, 8, &cursor) != 8) {\n                    return DRWAV_FALSE;\n                }\n                chunkSize -= 8;\n\n                if (!foundDataChunk) {\n                    pWav->dataChunkDataPos = cursor;\n                }\n            }\n        } else if (pWav->container == drwav_container_rf64) {\n            /* We retrieved the sample count from the ds64 chunk earlier so no need to do that here. */\n        }\n\n        /* \"smpl\" chunk. */\n        if (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64) {\n            if (drwav__fourcc_equal(header.id.fourcc, \"smpl\")) {\n                drwav_uint8 smplHeaderData[36];    /* 36 = size of the smpl header section, not including the loop data. */\n                if (chunkSize >= sizeof(smplHeaderData)) {\n                    drwav_uint64 bytesJustRead = drwav__on_read(pWav->onRead, pWav->pUserData, smplHeaderData, sizeof(smplHeaderData), &cursor);\n                    chunkSize -= bytesJustRead;\n\n                    if (bytesJustRead == sizeof(smplHeaderData)) {\n                        drwav_uint32 iLoop;\n\n                        pWav->smpl.manufacturer      = drwav__bytes_to_u32(smplHeaderData+0);\n                        pWav->smpl.product           = drwav__bytes_to_u32(smplHeaderData+4);\n                        pWav->smpl.samplePeriod      = drwav__bytes_to_u32(smplHeaderData+8);\n                        pWav->smpl.midiUnityNotes    = drwav__bytes_to_u32(smplHeaderData+12);\n                        pWav->smpl.midiPitchFraction = drwav__bytes_to_u32(smplHeaderData+16);\n                        pWav->smpl.smpteFormat       = drwav__bytes_to_u32(smplHeaderData+20);\n                        pWav->smpl.smpteOffset       = drwav__bytes_to_u32(smplHeaderData+24);\n                        pWav->smpl.numSampleLoops    = drwav__bytes_to_u32(smplHeaderData+28);\n                        pWav->smpl.samplerData       = drwav__bytes_to_u32(smplHeaderData+32);\n\n                        for (iLoop = 0; iLoop < pWav->smpl.numSampleLoops && iLoop < drwav_countof(pWav->smpl.loops); ++iLoop) {\n                            drwav_uint8 smplLoopData[24];  /* 24 = size of a loop section in the smpl chunk. */\n                            bytesJustRead = drwav__on_read(pWav->onRead, pWav->pUserData, smplLoopData, sizeof(smplLoopData), &cursor);\n                            chunkSize -= bytesJustRead;\n\n                            if (bytesJustRead == sizeof(smplLoopData)) {\n                                pWav->smpl.loops[iLoop].cuePointId = drwav__bytes_to_u32(smplLoopData+0);\n                                pWav->smpl.loops[iLoop].type       = drwav__bytes_to_u32(smplLoopData+4);\n                                pWav->smpl.loops[iLoop].start      = drwav__bytes_to_u32(smplLoopData+8);\n                                pWav->smpl.loops[iLoop].end        = drwav__bytes_to_u32(smplLoopData+12);\n                                pWav->smpl.loops[iLoop].fraction   = drwav__bytes_to_u32(smplLoopData+16);\n                                pWav->smpl.loops[iLoop].playCount  = drwav__bytes_to_u32(smplLoopData+20);\n                            } else {\n                                break;  /* Break from the smpl loop for loop. */\n                            }\n                        }\n                    }\n                } else {\n                    /* Looks like invalid data. Ignore the chunk. */\n                }\n            }\n        } else {\n            if (drwav__guid_equal(header.id.guid, drwavGUID_W64_SMPL)) {\n                /*\n                This path will be hit when a W64 WAV file contains a smpl chunk. I don't have a sample file to test this path, so a contribution\n                is welcome to add support for this.\n                */\n            }\n        }\n\n        /* Make sure we seek past the padding. */\n        chunkSize += header.paddingSize;\n        if (!drwav__seek_forward(pWav->onSeek, chunkSize, pWav->pUserData)) {\n            break;\n        }\n        cursor += chunkSize;\n\n        if (!foundDataChunk) {\n            pWav->dataChunkDataPos = cursor;\n        }\n    }\n\n    /* If we haven't found a data chunk, return an error. */\n    if (!foundDataChunk) {\n        return DRWAV_FALSE;\n    }\n\n    /* We may have moved passed the data chunk. If so we need to move back. If running in sequential mode we can assume we are already sitting on the data chunk. */\n    if (!sequential) {\n        if (!drwav__seek_from_start(pWav->onSeek, pWav->dataChunkDataPos, pWav->pUserData)) {\n            return DRWAV_FALSE;\n        }\n        cursor = pWav->dataChunkDataPos;\n    }\n    \n\n    /* At this point we should be sitting on the first byte of the raw audio data. */\n\n    pWav->fmt                 = fmt;\n    pWav->sampleRate          = fmt.sampleRate;\n    pWav->channels            = fmt.channels;\n    pWav->bitsPerSample       = fmt.bitsPerSample;\n    pWav->bytesRemaining      = dataChunkSize;\n    pWav->translatedFormatTag = translatedFormatTag;\n    pWav->dataChunkDataSize   = dataChunkSize;\n\n    if (sampleCountFromFactChunk != 0) {\n        pWav->totalPCMFrameCount = sampleCountFromFactChunk;\n    } else {\n        pWav->totalPCMFrameCount = dataChunkSize / drwav_get_bytes_per_pcm_frame(pWav);\n\n        if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n            drwav_uint64 totalBlockHeaderSizeInBytes;\n            drwav_uint64 blockCount = dataChunkSize / fmt.blockAlign;\n\n            /* Make sure any trailing partial block is accounted for. */\n            if ((blockCount * fmt.blockAlign) < dataChunkSize) {\n                blockCount += 1;\n            }\n\n            /* We decode two samples per byte. There will be blockCount headers in the data chunk. This is enough to know how to calculate the total PCM frame count. */\n            totalBlockHeaderSizeInBytes = blockCount * (6*fmt.channels);\n            pWav->totalPCMFrameCount = ((dataChunkSize - totalBlockHeaderSizeInBytes) * 2) / fmt.channels;\n        }\n        if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n            drwav_uint64 totalBlockHeaderSizeInBytes;\n            drwav_uint64 blockCount = dataChunkSize / fmt.blockAlign;\n\n            /* Make sure any trailing partial block is accounted for. */\n            if ((blockCount * fmt.blockAlign) < dataChunkSize) {\n                blockCount += 1;\n            }\n\n            /* We decode two samples per byte. There will be blockCount headers in the data chunk. This is enough to know how to calculate the total PCM frame count. */\n            totalBlockHeaderSizeInBytes = blockCount * (4*fmt.channels);\n            pWav->totalPCMFrameCount = ((dataChunkSize - totalBlockHeaderSizeInBytes) * 2) / fmt.channels;\n\n            /* The header includes a decoded sample for each channel which acts as the initial predictor sample. */\n            pWav->totalPCMFrameCount += blockCount;\n        }\n    }\n\n    /* Some formats only support a certain number of channels. */\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM || pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n        if (pWav->channels > 2) {\n            return DRWAV_FALSE;\n        }\n    }\n\n#ifdef DR_WAV_LIBSNDFILE_COMPAT\n    /*\n    I use libsndfile as a benchmark for testing, however in the version I'm using (from the Windows installer on the libsndfile website),\n    it appears the total sample count libsndfile uses for MS-ADPCM is incorrect. It would seem they are computing the total sample count\n    from the number of blocks, however this results in the inclusion of extra silent samples at the end of the last block. The correct\n    way to know the total sample count is to inspect the \"fact\" chunk, which should always be present for compressed formats, and should\n    always include the sample count. This little block of code below is only used to emulate the libsndfile logic so I can properly run my\n    correctness tests against libsndfile, and is disabled by default.\n    */\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n        drwav_uint64 blockCount = dataChunkSize / fmt.blockAlign;\n        pWav->totalPCMFrameCount = (((blockCount * (fmt.blockAlign - (6*pWav->channels))) * 2)) / fmt.channels;  /* x2 because two samples per byte. */\n    }\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n        drwav_uint64 blockCount = dataChunkSize / fmt.blockAlign;\n        pWav->totalPCMFrameCount = (((blockCount * (fmt.blockAlign - (4*pWav->channels))) * 2) + (blockCount * pWav->channels)) / fmt.channels;\n    }\n#endif\n\n    return DRWAV_TRUE;\n}\n\nDRWAV_API drwav_bool32 drwav_init(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_ex(pWav, onRead, onSeek, NULL, pUserData, NULL, 0, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_ex(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, drwav_chunk_proc onChunk, void* pReadSeekUserData, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (!drwav_preinit(pWav, onRead, onSeek, pReadSeekUserData, pAllocationCallbacks)) {\n        return DRWAV_FALSE;\n    }\n\n    return drwav_init__internal(pWav, onChunk, pChunkUserData, flags);\n}\n\n\nstatic drwav_uint32 drwav__riff_chunk_size_riff(drwav_uint64 dataChunkSize)\n{\n    drwav_uint64 chunkSize = 4 + 24 + dataChunkSize + drwav__chunk_padding_size_riff(dataChunkSize); /* 4 = \"WAVE\". 24 = \"fmt \" chunk. */\n    if (chunkSize > 0xFFFFFFFFUL) {\n        chunkSize = 0xFFFFFFFFUL;\n    }\n\n    return (drwav_uint32)chunkSize; /* Safe cast due to the clamp above. */\n}\n\nstatic drwav_uint32 drwav__data_chunk_size_riff(drwav_uint64 dataChunkSize)\n{\n    if (dataChunkSize <= 0xFFFFFFFFUL) {\n        return (drwav_uint32)dataChunkSize;\n    } else {\n        return 0xFFFFFFFFUL;\n    }\n}\n\nstatic drwav_uint64 drwav__riff_chunk_size_w64(drwav_uint64 dataChunkSize)\n{\n    drwav_uint64 dataSubchunkPaddingSize = drwav__chunk_padding_size_w64(dataChunkSize);\n\n    return 80 + 24 + dataChunkSize + dataSubchunkPaddingSize;   /* +24 because W64 includes the size of the GUID and size fields. */\n}\n\nstatic drwav_uint64 drwav__data_chunk_size_w64(drwav_uint64 dataChunkSize)\n{\n    return 24 + dataChunkSize;        /* +24 because W64 includes the size of the GUID and size fields. */\n}\n\nstatic drwav_uint64 drwav__riff_chunk_size_rf64(drwav_uint64 dataChunkSize)\n{\n    drwav_uint64 chunkSize = 4 + 36 + 24 + dataChunkSize + drwav__chunk_padding_size_riff(dataChunkSize); /* 4 = \"WAVE\". 36 = \"ds64\" chunk. 24 = \"fmt \" chunk. */\n    if (chunkSize > 0xFFFFFFFFUL) {\n        chunkSize = 0xFFFFFFFFUL;\n    }\n\n    return chunkSize;\n}\n\nstatic drwav_uint64 drwav__data_chunk_size_rf64(drwav_uint64 dataChunkSize)\n{\n    return dataChunkSize;\n}\n\n\nstatic size_t drwav__write(drwav* pWav, const void* pData, size_t dataSize)\n{\n    DRWAV_ASSERT(pWav          != NULL);\n    DRWAV_ASSERT(pWav->onWrite != NULL);\n\n    /* Generic write. Assumes no byte reordering required. */\n    return pWav->onWrite(pWav->pUserData, pData, dataSize);\n}\n\nstatic size_t drwav__write_u16ne_to_le(drwav* pWav, drwav_uint16 value)\n{\n    DRWAV_ASSERT(pWav          != NULL);\n    DRWAV_ASSERT(pWav->onWrite != NULL);\n\n    if (!drwav__is_little_endian()) {\n        value = drwav__bswap16(value);\n    }\n\n    return drwav__write(pWav, &value, 2);\n}\n\nstatic size_t drwav__write_u32ne_to_le(drwav* pWav, drwav_uint32 value)\n{\n    DRWAV_ASSERT(pWav          != NULL);\n    DRWAV_ASSERT(pWav->onWrite != NULL);\n\n    if (!drwav__is_little_endian()) {\n        value = drwav__bswap32(value);\n    }\n\n    return drwav__write(pWav, &value, 4);\n}\n\nstatic size_t drwav__write_u64ne_to_le(drwav* pWav, drwav_uint64 value)\n{\n    DRWAV_ASSERT(pWav          != NULL);\n    DRWAV_ASSERT(pWav->onWrite != NULL);\n\n    if (!drwav__is_little_endian()) {\n        value = drwav__bswap64(value);\n    }\n\n    return drwav__write(pWav, &value, 8);\n}\n\n\nstatic drwav_bool32 drwav_preinit_write(drwav* pWav, const drwav_data_format* pFormat, drwav_bool32 isSequential, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pWav == NULL || onWrite == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    if (!isSequential && onSeek == NULL) {\n        return DRWAV_FALSE; /* <-- onSeek is required when in non-sequential mode. */\n    }\n\n    /* Not currently supporting compressed formats. Will need to add support for the \"fact\" chunk before we enable this. */\n    if (pFormat->format == DR_WAVE_FORMAT_EXTENSIBLE) {\n        return DRWAV_FALSE;\n    }\n    if (pFormat->format == DR_WAVE_FORMAT_ADPCM || pFormat->format == DR_WAVE_FORMAT_DVI_ADPCM) {\n        return DRWAV_FALSE;\n    }\n\n    DRWAV_ZERO_MEMORY(pWav, sizeof(*pWav));\n    pWav->onWrite   = onWrite;\n    pWav->onSeek    = onSeek;\n    pWav->pUserData = pUserData;\n    pWav->allocationCallbacks = drwav_copy_allocation_callbacks_or_defaults(pAllocationCallbacks);\n\n    if (pWav->allocationCallbacks.onFree == NULL || (pWav->allocationCallbacks.onMalloc == NULL && pWav->allocationCallbacks.onRealloc == NULL)) {\n        return DRWAV_FALSE;    /* Invalid allocation callbacks. */\n    }\n\n    pWav->fmt.formatTag = (drwav_uint16)pFormat->format;\n    pWav->fmt.channels = (drwav_uint16)pFormat->channels;\n    pWav->fmt.sampleRate = pFormat->sampleRate;\n    pWav->fmt.avgBytesPerSec = (drwav_uint32)((pFormat->bitsPerSample * pFormat->sampleRate * pFormat->channels) / 8);\n    pWav->fmt.blockAlign = (drwav_uint16)((pFormat->channels * pFormat->bitsPerSample) / 8);\n    pWav->fmt.bitsPerSample = (drwav_uint16)pFormat->bitsPerSample;\n    pWav->fmt.extendedSize = 0;\n    pWav->isSequentialWrite = isSequential;\n\n    return DRWAV_TRUE;\n}\n\nstatic drwav_bool32 drwav_init_write__internal(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount)\n{\n    /* The function assumes drwav_preinit_write() was called beforehand. */\n\n    size_t runningPos = 0;\n    drwav_uint64 initialDataChunkSize = 0;\n    drwav_uint64 chunkSizeFMT;\n\n    /*\n    The initial values for the \"RIFF\" and \"data\" chunks depends on whether or not we are initializing in sequential mode or not. In\n    sequential mode we set this to its final values straight away since they can be calculated from the total sample count. In non-\n    sequential mode we initialize it all to zero and fill it out in drwav_uninit() using a backwards seek.\n    */\n    if (pWav->isSequentialWrite) {\n        initialDataChunkSize = (totalSampleCount * pWav->fmt.bitsPerSample) / 8;\n\n        /*\n        The RIFF container has a limit on the number of samples. drwav is not allowing this. There's no practical limits for Wave64\n        so for the sake of simplicity I'm not doing any validation for that.\n        */\n        if (pFormat->container == drwav_container_riff) {\n            if (initialDataChunkSize > (0xFFFFFFFFUL - 36)) {\n                return DRWAV_FALSE; /* Not enough room to store every sample. */\n            }\n        }\n    }\n\n    pWav->dataChunkDataSizeTargetWrite = initialDataChunkSize;\n\n\n    /* \"RIFF\" chunk. */\n    if (pFormat->container == drwav_container_riff) {\n        drwav_uint32 chunkSizeRIFF = 28 + (drwav_uint32)initialDataChunkSize;   /* +28 = \"WAVE\" + [sizeof \"fmt \" chunk] */\n        runningPos += drwav__write(pWav, \"RIFF\", 4);\n        runningPos += drwav__write_u32ne_to_le(pWav, chunkSizeRIFF);\n        runningPos += drwav__write(pWav, \"WAVE\", 4);\n    } else if (pFormat->container == drwav_container_w64) {\n        drwav_uint64 chunkSizeRIFF = 80 + 24 + initialDataChunkSize;            /* +24 because W64 includes the size of the GUID and size fields. */\n        runningPos += drwav__write(pWav, drwavGUID_W64_RIFF, 16);\n        runningPos += drwav__write_u64ne_to_le(pWav, chunkSizeRIFF);\n        runningPos += drwav__write(pWav, drwavGUID_W64_WAVE, 16);\n    } else if (pFormat->container == drwav_container_rf64) {\n        runningPos += drwav__write(pWav, \"RF64\", 4);\n        runningPos += drwav__write_u32ne_to_le(pWav, 0xFFFFFFFF);               /* Always 0xFFFFFFFF for RF64. Set to a proper value in the \"ds64\" chunk. */\n        runningPos += drwav__write(pWav, \"WAVE\", 4);\n    }\n\n    \n    /* \"ds64\" chunk (RF64 only). */\n    if (pFormat->container == drwav_container_rf64) {\n        drwav_uint32 initialds64ChunkSize = 28;                                 /* 28 = [Size of RIFF (8 bytes)] + [Size of DATA (8 bytes)] + [Sample Count (8 bytes)] + [Table Length (4 bytes)]. Table length always set to 0. */\n        drwav_uint64 initialRiffChunkSize = 8 + initialds64ChunkSize + initialDataChunkSize;    /* +8 for the ds64 header. */\n\n        runningPos += drwav__write(pWav, \"ds64\", 4);\n        runningPos += drwav__write_u32ne_to_le(pWav, initialds64ChunkSize);     /* Size of ds64. */\n        runningPos += drwav__write_u64ne_to_le(pWav, initialRiffChunkSize);     /* Size of RIFF. Set to true value at the end. */\n        runningPos += drwav__write_u64ne_to_le(pWav, initialDataChunkSize);     /* Size of DATA. Set to true value at the end. */\n        runningPos += drwav__write_u64ne_to_le(pWav, totalSampleCount);         /* Sample count. */\n        runningPos += drwav__write_u32ne_to_le(pWav, 0);                        /* Table length. Always set to zero in our case since we're not doing any other chunks than \"DATA\". */\n    }\n\n\n    /* \"fmt \" chunk. */\n    if (pFormat->container == drwav_container_riff || pFormat->container == drwav_container_rf64) {\n        chunkSizeFMT = 16;\n        runningPos += drwav__write(pWav, \"fmt \", 4);\n        runningPos += drwav__write_u32ne_to_le(pWav, (drwav_uint32)chunkSizeFMT);\n    } else if (pFormat->container == drwav_container_w64) {\n        chunkSizeFMT = 40;\n        runningPos += drwav__write(pWav, drwavGUID_W64_FMT, 16);\n        runningPos += drwav__write_u64ne_to_le(pWav, chunkSizeFMT);\n    }\n\n    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.formatTag);\n    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.channels);\n    runningPos += drwav__write_u32ne_to_le(pWav, pWav->fmt.sampleRate);\n    runningPos += drwav__write_u32ne_to_le(pWav, pWav->fmt.avgBytesPerSec);\n    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.blockAlign);\n    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.bitsPerSample);\n\n    pWav->dataChunkDataPos = runningPos;\n\n    /* \"data\" chunk. */\n    if (pFormat->container == drwav_container_riff) {\n        drwav_uint32 chunkSizeDATA = (drwav_uint32)initialDataChunkSize;\n        runningPos += drwav__write(pWav, \"data\", 4);\n        runningPos += drwav__write_u32ne_to_le(pWav, chunkSizeDATA);\n    } else if (pFormat->container == drwav_container_w64) {\n        drwav_uint64 chunkSizeDATA = 24 + initialDataChunkSize;     /* +24 because W64 includes the size of the GUID and size fields. */\n        runningPos += drwav__write(pWav, drwavGUID_W64_DATA, 16);\n        runningPos += drwav__write_u64ne_to_le(pWav, chunkSizeDATA);\n    } else if (pFormat->container == drwav_container_rf64) {\n        runningPos += drwav__write(pWav, \"data\", 4);\n        runningPos += drwav__write_u32ne_to_le(pWav, 0xFFFFFFFF);   /* Always set to 0xFFFFFFFF for RF64. The true size of the data chunk is specified in the ds64 chunk. */\n    }\n\n    /*\n    The runningPos variable is incremented in the section above but is left unused which is causing some static analysis tools to detect it\n    as a dead store. I'm leaving this as-is for safety just in case I want to expand this function later to include other tags and want to\n    keep track of the running position for whatever reason. The line below should silence the static analysis tools.\n    */\n    (void)runningPos;\n\n    /* Set some properties for the client's convenience. */\n    pWav->container = pFormat->container;\n    pWav->channels = (drwav_uint16)pFormat->channels;\n    pWav->sampleRate = pFormat->sampleRate;\n    pWav->bitsPerSample = (drwav_uint16)pFormat->bitsPerSample;\n    pWav->translatedFormatTag = (drwav_uint16)pFormat->format;\n\n    return DRWAV_TRUE;\n}\n\n\nDRWAV_API drwav_bool32 drwav_init_write(drwav* pWav, const drwav_data_format* pFormat, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (!drwav_preinit_write(pWav, pFormat, DRWAV_FALSE, onWrite, onSeek, pUserData, pAllocationCallbacks)) {\n        return DRWAV_FALSE;\n    }\n\n    return drwav_init_write__internal(pWav, pFormat, 0);               /* DRWAV_FALSE = Not Sequential */\n}\n\nDRWAV_API drwav_bool32 drwav_init_write_sequential(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_write_proc onWrite, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (!drwav_preinit_write(pWav, pFormat, DRWAV_TRUE, onWrite, NULL, pUserData, pAllocationCallbacks)) {\n        return DRWAV_FALSE;\n    }\n\n    return drwav_init_write__internal(pWav, pFormat, totalSampleCount); /* DRWAV_TRUE = Sequential */\n}\n\nDRWAV_API drwav_bool32 drwav_init_write_sequential_pcm_frames(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, drwav_write_proc onWrite, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pFormat == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    return drwav_init_write_sequential(pWav, pFormat, totalPCMFrameCount*pFormat->channels, onWrite, pUserData, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_uint64 drwav_target_write_size_bytes(const drwav_data_format* pFormat, drwav_uint64 totalSampleCount)\n{\n    /* Casting totalSampleCount to drwav_int64 for VC6 compatibility. No issues in practice because nobody is going to exhaust the whole 63 bits. */\n    drwav_uint64 targetDataSizeBytes = (drwav_uint64)((drwav_int64)totalSampleCount * pFormat->channels * pFormat->bitsPerSample/8.0);\n    drwav_uint64 riffChunkSizeBytes;\n    drwav_uint64 fileSizeBytes = 0;\n\n    if (pFormat->container == drwav_container_riff) {\n        riffChunkSizeBytes = drwav__riff_chunk_size_riff(targetDataSizeBytes);\n        fileSizeBytes = (8 + riffChunkSizeBytes);   /* +8 because WAV doesn't include the size of the ChunkID and ChunkSize fields. */\n    } else if (pFormat->container == drwav_container_w64) {\n        riffChunkSizeBytes = drwav__riff_chunk_size_w64(targetDataSizeBytes);\n        fileSizeBytes = riffChunkSizeBytes;\n    } else if (pFormat->container == drwav_container_rf64) {\n        riffChunkSizeBytes = drwav__riff_chunk_size_rf64(targetDataSizeBytes);\n        fileSizeBytes = (8 + riffChunkSizeBytes);   /* +8 because WAV doesn't include the size of the ChunkID and ChunkSize fields. */\n    }\n\n    return fileSizeBytes;\n}\n\n\n#ifndef DR_WAV_NO_STDIO\n\n/* drwav_result_from_errno() is only used for fopen() and wfopen() so putting it inside DR_WAV_NO_STDIO for now. If something else needs this later we can move it out. */\n#include <errno.h>\nstatic drwav_result drwav_result_from_errno(int e)\n{\n    switch (e)\n    {\n        case 0: return DRWAV_SUCCESS;\n    #ifdef EPERM\n        case EPERM: return DRWAV_INVALID_OPERATION;\n    #endif\n    #ifdef ENOENT\n        case ENOENT: return DRWAV_DOES_NOT_EXIST;\n    #endif\n    #ifdef ESRCH\n        case ESRCH: return DRWAV_DOES_NOT_EXIST;\n    #endif\n    #ifdef EINTR\n        case EINTR: return DRWAV_INTERRUPT;\n    #endif\n    #ifdef EIO\n        case EIO: return DRWAV_IO_ERROR;\n    #endif\n    #ifdef ENXIO\n        case ENXIO: return DRWAV_DOES_NOT_EXIST;\n    #endif\n    #ifdef E2BIG\n        case E2BIG: return DRWAV_INVALID_ARGS;\n    #endif\n    #ifdef ENOEXEC\n        case ENOEXEC: return DRWAV_INVALID_FILE;\n    #endif\n    #ifdef EBADF\n        case EBADF: return DRWAV_INVALID_FILE;\n    #endif\n    #ifdef ECHILD\n        case ECHILD: return DRWAV_ERROR;\n    #endif\n    #ifdef EAGAIN\n        case EAGAIN: return DRWAV_UNAVAILABLE;\n    #endif\n    #ifdef ENOMEM\n        case ENOMEM: return DRWAV_OUT_OF_MEMORY;\n    #endif\n    #ifdef EACCES\n        case EACCES: return DRWAV_ACCESS_DENIED;\n    #endif\n    #ifdef EFAULT\n        case EFAULT: return DRWAV_BAD_ADDRESS;\n    #endif\n    #ifdef ENOTBLK\n        case ENOTBLK: return DRWAV_ERROR;\n    #endif\n    #ifdef EBUSY\n        case EBUSY: return DRWAV_BUSY;\n    #endif\n    #ifdef EEXIST\n        case EEXIST: return DRWAV_ALREADY_EXISTS;\n    #endif\n    #ifdef EXDEV\n        case EXDEV: return DRWAV_ERROR;\n    #endif\n    #ifdef ENODEV\n        case ENODEV: return DRWAV_DOES_NOT_EXIST;\n    #endif\n    #ifdef ENOTDIR\n        case ENOTDIR: return DRWAV_NOT_DIRECTORY;\n    #endif\n    #ifdef EISDIR\n        case EISDIR: return DRWAV_IS_DIRECTORY;\n    #endif\n    #ifdef EINVAL\n        case EINVAL: return DRWAV_INVALID_ARGS;\n    #endif\n    #ifdef ENFILE\n        case ENFILE: return DRWAV_TOO_MANY_OPEN_FILES;\n    #endif\n    #ifdef EMFILE\n        case EMFILE: return DRWAV_TOO_MANY_OPEN_FILES;\n    #endif\n    #ifdef ENOTTY\n        case ENOTTY: return DRWAV_INVALID_OPERATION;\n    #endif\n    #ifdef ETXTBSY\n        case ETXTBSY: return DRWAV_BUSY;\n    #endif\n    #ifdef EFBIG\n        case EFBIG: return DRWAV_TOO_BIG;\n    #endif\n    #ifdef ENOSPC\n        case ENOSPC: return DRWAV_NO_SPACE;\n    #endif\n    #ifdef ESPIPE\n        case ESPIPE: return DRWAV_BAD_SEEK;\n    #endif\n    #ifdef EROFS\n        case EROFS: return DRWAV_ACCESS_DENIED;\n    #endif\n    #ifdef EMLINK\n        case EMLINK: return DRWAV_TOO_MANY_LINKS;\n    #endif\n    #ifdef EPIPE\n        case EPIPE: return DRWAV_BAD_PIPE;\n    #endif\n    #ifdef EDOM\n        case EDOM: return DRWAV_OUT_OF_RANGE;\n    #endif\n    #ifdef ERANGE\n        case ERANGE: return DRWAV_OUT_OF_RANGE;\n    #endif\n    #ifdef EDEADLK\n        case EDEADLK: return DRWAV_DEADLOCK;\n    #endif\n    #ifdef ENAMETOOLONG\n        case ENAMETOOLONG: return DRWAV_PATH_TOO_LONG;\n    #endif\n    #ifdef ENOLCK\n        case ENOLCK: return DRWAV_ERROR;\n    #endif\n    #ifdef ENOSYS\n        case ENOSYS: return DRWAV_NOT_IMPLEMENTED;\n    #endif\n    #ifdef ENOTEMPTY\n        case ENOTEMPTY: return DRWAV_DIRECTORY_NOT_EMPTY;\n    #endif\n    #ifdef ELOOP\n        case ELOOP: return DRWAV_TOO_MANY_LINKS;\n    #endif\n    #ifdef ENOMSG\n        case ENOMSG: return DRWAV_NO_MESSAGE;\n    #endif\n    #ifdef EIDRM\n        case EIDRM: return DRWAV_ERROR;\n    #endif\n    #ifdef ECHRNG\n        case ECHRNG: return DRWAV_ERROR;\n    #endif\n    #ifdef EL2NSYNC\n        case EL2NSYNC: return DRWAV_ERROR;\n    #endif\n    #ifdef EL3HLT\n        case EL3HLT: return DRWAV_ERROR;\n    #endif\n    #ifdef EL3RST\n        case EL3RST: return DRWAV_ERROR;\n    #endif\n    #ifdef ELNRNG\n        case ELNRNG: return DRWAV_OUT_OF_RANGE;\n    #endif\n    #ifdef EUNATCH\n        case EUNATCH: return DRWAV_ERROR;\n    #endif\n    #ifdef ENOCSI\n        case ENOCSI: return DRWAV_ERROR;\n    #endif\n    #ifdef EL2HLT\n        case EL2HLT: return DRWAV_ERROR;\n    #endif\n    #ifdef EBADE\n        case EBADE: return DRWAV_ERROR;\n    #endif\n    #ifdef EBADR\n        case EBADR: return DRWAV_ERROR;\n    #endif\n    #ifdef EXFULL\n        case EXFULL: return DRWAV_ERROR;\n    #endif\n    #ifdef ENOANO\n        case ENOANO: return DRWAV_ERROR;\n    #endif\n    #ifdef EBADRQC\n        case EBADRQC: return DRWAV_ERROR;\n    #endif\n    #ifdef EBADSLT\n        case EBADSLT: return DRWAV_ERROR;\n    #endif\n    #ifdef EBFONT\n        case EBFONT: return DRWAV_INVALID_FILE;\n    #endif\n    #ifdef ENOSTR\n        case ENOSTR: return DRWAV_ERROR;\n    #endif\n    #ifdef ENODATA\n        case ENODATA: return DRWAV_NO_DATA_AVAILABLE;\n    #endif\n    #ifdef ETIME\n        case ETIME: return DRWAV_TIMEOUT;\n    #endif\n    #ifdef ENOSR\n        case ENOSR: return DRWAV_NO_DATA_AVAILABLE;\n    #endif\n    #ifdef ENONET\n        case ENONET: return DRWAV_NO_NETWORK;\n    #endif\n    #ifdef ENOPKG\n        case ENOPKG: return DRWAV_ERROR;\n    #endif\n    #ifdef EREMOTE\n        case EREMOTE: return DRWAV_ERROR;\n    #endif\n    #ifdef ENOLINK\n        case ENOLINK: return DRWAV_ERROR;\n    #endif\n    #ifdef EADV\n        case EADV: return DRWAV_ERROR;\n    #endif\n    #ifdef ESRMNT\n        case ESRMNT: return DRWAV_ERROR;\n    #endif\n    #ifdef ECOMM\n        case ECOMM: return DRWAV_ERROR;\n    #endif\n    #ifdef EPROTO\n        case EPROTO: return DRWAV_ERROR;\n    #endif\n    #ifdef EMULTIHOP\n        case EMULTIHOP: return DRWAV_ERROR;\n    #endif\n    #ifdef EDOTDOT\n        case EDOTDOT: return DRWAV_ERROR;\n    #endif\n    #ifdef EBADMSG\n        case EBADMSG: return DRWAV_BAD_MESSAGE;\n    #endif\n    #ifdef EOVERFLOW\n        case EOVERFLOW: return DRWAV_TOO_BIG;\n    #endif\n    #ifdef ENOTUNIQ\n        case ENOTUNIQ: return DRWAV_NOT_UNIQUE;\n    #endif\n    #ifdef EBADFD\n        case EBADFD: return DRWAV_ERROR;\n    #endif\n    #ifdef EREMCHG\n        case EREMCHG: return DRWAV_ERROR;\n    #endif\n    #ifdef ELIBACC\n        case ELIBACC: return DRWAV_ACCESS_DENIED;\n    #endif\n    #ifdef ELIBBAD\n        case ELIBBAD: return DRWAV_INVALID_FILE;\n    #endif\n    #ifdef ELIBSCN\n        case ELIBSCN: return DRWAV_INVALID_FILE;\n    #endif\n    #ifdef ELIBMAX\n        case ELIBMAX: return DRWAV_ERROR;\n    #endif\n    #ifdef ELIBEXEC\n        case ELIBEXEC: return DRWAV_ERROR;\n    #endif\n    #ifdef EILSEQ\n        case EILSEQ: return DRWAV_INVALID_DATA;\n    #endif\n    #ifdef ERESTART\n        case ERESTART: return DRWAV_ERROR;\n    #endif\n    #ifdef ESTRPIPE\n        case ESTRPIPE: return DRWAV_ERROR;\n    #endif\n    #ifdef EUSERS\n        case EUSERS: return DRWAV_ERROR;\n    #endif\n    #ifdef ENOTSOCK\n        case ENOTSOCK: return DRWAV_NOT_SOCKET;\n    #endif\n    #ifdef EDESTADDRREQ\n        case EDESTADDRREQ: return DRWAV_NO_ADDRESS;\n    #endif\n    #ifdef EMSGSIZE\n        case EMSGSIZE: return DRWAV_TOO_BIG;\n    #endif\n    #ifdef EPROTOTYPE\n        case EPROTOTYPE: return DRWAV_BAD_PROTOCOL;\n    #endif\n    #ifdef ENOPROTOOPT\n        case ENOPROTOOPT: return DRWAV_PROTOCOL_UNAVAILABLE;\n    #endif\n    #ifdef EPROTONOSUPPORT\n        case EPROTONOSUPPORT: return DRWAV_PROTOCOL_NOT_SUPPORTED;\n    #endif\n    #ifdef ESOCKTNOSUPPORT\n        case ESOCKTNOSUPPORT: return DRWAV_SOCKET_NOT_SUPPORTED;\n    #endif\n    #ifdef EOPNOTSUPP\n        case EOPNOTSUPP: return DRWAV_INVALID_OPERATION;\n    #endif\n    #ifdef EPFNOSUPPORT\n        case EPFNOSUPPORT: return DRWAV_PROTOCOL_FAMILY_NOT_SUPPORTED;\n    #endif\n    #ifdef EAFNOSUPPORT\n        case EAFNOSUPPORT: return DRWAV_ADDRESS_FAMILY_NOT_SUPPORTED;\n    #endif\n    #ifdef EADDRINUSE\n        case EADDRINUSE: return DRWAV_ALREADY_IN_USE;\n    #endif\n    #ifdef EADDRNOTAVAIL\n        case EADDRNOTAVAIL: return DRWAV_ERROR;\n    #endif\n    #ifdef ENETDOWN\n        case ENETDOWN: return DRWAV_NO_NETWORK;\n    #endif\n    #ifdef ENETUNREACH\n        case ENETUNREACH: return DRWAV_NO_NETWORK;\n    #endif\n    #ifdef ENETRESET\n        case ENETRESET: return DRWAV_NO_NETWORK;\n    #endif\n    #ifdef ECONNABORTED\n        case ECONNABORTED: return DRWAV_NO_NETWORK;\n    #endif\n    #ifdef ECONNRESET\n        case ECONNRESET: return DRWAV_CONNECTION_RESET;\n    #endif\n    #ifdef ENOBUFS\n        case ENOBUFS: return DRWAV_NO_SPACE;\n    #endif\n    #ifdef EISCONN\n        case EISCONN: return DRWAV_ALREADY_CONNECTED;\n    #endif\n    #ifdef ENOTCONN\n        case ENOTCONN: return DRWAV_NOT_CONNECTED;\n    #endif\n    #ifdef ESHUTDOWN\n        case ESHUTDOWN: return DRWAV_ERROR;\n    #endif\n    #ifdef ETOOMANYREFS\n        case ETOOMANYREFS: return DRWAV_ERROR;\n    #endif\n    #ifdef ETIMEDOUT\n        case ETIMEDOUT: return DRWAV_TIMEOUT;\n    #endif\n    #ifdef ECONNREFUSED\n        case ECONNREFUSED: return DRWAV_CONNECTION_REFUSED;\n    #endif\n    #ifdef EHOSTDOWN\n        case EHOSTDOWN: return DRWAV_NO_HOST;\n    #endif\n    #ifdef EHOSTUNREACH\n        case EHOSTUNREACH: return DRWAV_NO_HOST;\n    #endif\n    #ifdef EALREADY\n        case EALREADY: return DRWAV_IN_PROGRESS;\n    #endif\n    #ifdef EINPROGRESS\n        case EINPROGRESS: return DRWAV_IN_PROGRESS;\n    #endif\n    #ifdef ESTALE\n        case ESTALE: return DRWAV_INVALID_FILE;\n    #endif\n    #ifdef EUCLEAN\n        case EUCLEAN: return DRWAV_ERROR;\n    #endif\n    #ifdef ENOTNAM\n        case ENOTNAM: return DRWAV_ERROR;\n    #endif\n    #ifdef ENAVAIL\n        case ENAVAIL: return DRWAV_ERROR;\n    #endif\n    #ifdef EISNAM\n        case EISNAM: return DRWAV_ERROR;\n    #endif\n    #ifdef EREMOTEIO\n        case EREMOTEIO: return DRWAV_IO_ERROR;\n    #endif\n    #ifdef EDQUOT\n        case EDQUOT: return DRWAV_NO_SPACE;\n    #endif\n    #ifdef ENOMEDIUM\n        case ENOMEDIUM: return DRWAV_DOES_NOT_EXIST;\n    #endif\n    #ifdef EMEDIUMTYPE\n        case EMEDIUMTYPE: return DRWAV_ERROR;\n    #endif\n    #ifdef ECANCELED\n        case ECANCELED: return DRWAV_CANCELLED;\n    #endif\n    #ifdef ENOKEY\n        case ENOKEY: return DRWAV_ERROR;\n    #endif\n    #ifdef EKEYEXPIRED\n        case EKEYEXPIRED: return DRWAV_ERROR;\n    #endif\n    #ifdef EKEYREVOKED\n        case EKEYREVOKED: return DRWAV_ERROR;\n    #endif\n    #ifdef EKEYREJECTED\n        case EKEYREJECTED: return DRWAV_ERROR;\n    #endif\n    #ifdef EOWNERDEAD\n        case EOWNERDEAD: return DRWAV_ERROR;\n    #endif\n    #ifdef ENOTRECOVERABLE\n        case ENOTRECOVERABLE: return DRWAV_ERROR;\n    #endif\n    #ifdef ERFKILL\n        case ERFKILL: return DRWAV_ERROR;\n    #endif\n    #ifdef EHWPOISON\n        case EHWPOISON: return DRWAV_ERROR;\n    #endif\n        default: return DRWAV_ERROR;\n    }\n}\n\nstatic drwav_result drwav_fopen(FILE** ppFile, const char* pFilePath, const char* pOpenMode)\n{\n#if _MSC_VER && _MSC_VER >= 1400\n    errno_t err;\n#endif\n\n    if (ppFile != NULL) {\n        *ppFile = NULL;  /* Safety. */\n    }\n\n    if (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) {\n        return DRWAV_INVALID_ARGS;\n    }\n\n#if _MSC_VER && _MSC_VER >= 1400\n    err = fopen_s(ppFile, pFilePath, pOpenMode);\n    if (err != 0) {\n        return drwav_result_from_errno(err);\n    }\n#else\n#if defined(_WIN32) || defined(__APPLE__)\n    *ppFile = fopen(pFilePath, pOpenMode);\n#else\n    #if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64 && defined(_LARGEFILE64_SOURCE)\n        *ppFile = fopen64(pFilePath, pOpenMode);\n    #else\n        *ppFile = fopen(pFilePath, pOpenMode);\n    #endif\n#endif\n    if (*ppFile == NULL) {\n        drwav_result result = drwav_result_from_errno(errno);\n        if (result == DRWAV_SUCCESS) {\n            result = DRWAV_ERROR;   /* Just a safety check to make sure we never ever return success when pFile == NULL. */\n        }\n\n        return result;\n    }\n#endif\n\n    return DRWAV_SUCCESS;\n}\n\n/*\n_wfopen() isn't always available in all compilation environments.\n\n    * Windows only.\n    * MSVC seems to support it universally as far back as VC6 from what I can tell (haven't checked further back).\n    * MinGW-64 (both 32- and 64-bit) seems to support it.\n    * MinGW wraps it in !defined(__STRICT_ANSI__).\n    * OpenWatcom wraps it in !defined(_NO_EXT_KEYS).\n\nThis can be reviewed as compatibility issues arise. The preference is to use _wfopen_s() and _wfopen() as opposed to the wcsrtombs()\nfallback, so if you notice your compiler not detecting this properly I'm happy to look at adding support.\n*/\n#if defined(_WIN32)\n    #if defined(_MSC_VER) || defined(__MINGW64__) || (!defined(__STRICT_ANSI__) && !defined(_NO_EXT_KEYS))\n        #define DRWAV_HAS_WFOPEN\n    #endif\n#endif\n\nstatic drwav_result drwav_wfopen(FILE** ppFile, const wchar_t* pFilePath, const wchar_t* pOpenMode, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (ppFile != NULL) {\n        *ppFile = NULL;  /* Safety. */\n    }\n\n    if (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) {\n        return DRWAV_INVALID_ARGS;\n    }\n\n#if defined(DRWAV_HAS_WFOPEN)\n    {\n        /* Use _wfopen() on Windows. */\n    #if defined(_MSC_VER) && _MSC_VER >= 1400\n        errno_t err = _wfopen_s(ppFile, pFilePath, pOpenMode);\n        if (err != 0) {\n            return drwav_result_from_errno(err);\n        }\n    #else\n        *ppFile = _wfopen(pFilePath, pOpenMode);\n        if (*ppFile == NULL) {\n            return drwav_result_from_errno(errno);\n        }\n    #endif\n        (void)pAllocationCallbacks;\n    }\n#else\n    /*\n    Use fopen() on anything other than Windows. Requires a conversion. This is annoying because fopen() is locale specific. The only real way I can\n    think of to do this is with wcsrtombs(). Note that wcstombs() is apparently not thread-safe because it uses a static global mbstate_t object for\n    maintaining state. I've checked this with -std=c89 and it works, but if somebody get's a compiler error I'll look into improving compatibility.\n    */\n    {\n        mbstate_t mbs;\n        size_t lenMB;\n        const wchar_t* pFilePathTemp = pFilePath;\n        char* pFilePathMB = NULL;\n        char pOpenModeMB[32] = {0};\n\n        /* Get the length first. */\n        DRWAV_ZERO_OBJECT(&mbs);\n        lenMB = wcsrtombs(NULL, &pFilePathTemp, 0, &mbs);\n        if (lenMB == (size_t)-1) {\n            return drwav_result_from_errno(errno);\n        }\n\n        pFilePathMB = (char*)drwav__malloc_from_callbacks(lenMB + 1, pAllocationCallbacks);\n        if (pFilePathMB == NULL) {\n            return DRWAV_OUT_OF_MEMORY;\n        }\n\n        pFilePathTemp = pFilePath;\n        DRWAV_ZERO_OBJECT(&mbs);\n        wcsrtombs(pFilePathMB, &pFilePathTemp, lenMB + 1, &mbs);\n\n        /* The open mode should always consist of ASCII characters so we should be able to do a trivial conversion. */\n        {\n            size_t i = 0;\n            for (;;) {\n                if (pOpenMode[i] == 0) {\n                    pOpenModeMB[i] = '\\0';\n                    break;\n                }\n\n                pOpenModeMB[i] = (char)pOpenMode[i];\n                i += 1;\n            }\n        }\n\n        *ppFile = fopen(pFilePathMB, pOpenModeMB);\n\n        drwav__free_from_callbacks(pFilePathMB, pAllocationCallbacks);\n    }\n\n    if (*ppFile == NULL) {\n        return DRWAV_ERROR;\n    }\n#endif\n\n    return DRWAV_SUCCESS;\n}\n\n\nstatic size_t drwav__on_read_stdio(void* pUserData, void* pBufferOut, size_t bytesToRead)\n{\n    return fread(pBufferOut, 1, bytesToRead, (FILE*)pUserData);\n}\n\nstatic size_t drwav__on_write_stdio(void* pUserData, const void* pData, size_t bytesToWrite)\n{\n    return fwrite(pData, 1, bytesToWrite, (FILE*)pUserData);\n}\n\nstatic drwav_bool32 drwav__on_seek_stdio(void* pUserData, int offset, drwav_seek_origin origin)\n{\n    return fseek((FILE*)pUserData, offset, (origin == drwav_seek_origin_current) ? SEEK_CUR : SEEK_SET) == 0;\n}\n\nDRWAV_API drwav_bool32 drwav_init_file(drwav* pWav, const char* filename, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_file_ex(pWav, filename, NULL, NULL, 0, pAllocationCallbacks);\n}\n\n\nstatic drwav_bool32 drwav_init_file__internal_FILE(drwav* pWav, FILE* pFile, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav_bool32 result;\n\n    result = drwav_preinit(pWav, drwav__on_read_stdio, drwav__on_seek_stdio, (void*)pFile, pAllocationCallbacks);\n    if (result != DRWAV_TRUE) {\n        fclose(pFile);\n        return result;\n    }\n\n    result = drwav_init__internal(pWav, onChunk, pChunkUserData, flags);\n    if (result != DRWAV_TRUE) {\n        fclose(pFile);\n        return result;\n    }\n\n    return DRWAV_TRUE;\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_ex(drwav* pWav, const char* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    FILE* pFile;\n    if (drwav_fopen(&pFile, filename, \"rb\") != DRWAV_SUCCESS) {\n        return DRWAV_FALSE;\n    }\n\n    /* This takes ownership of the FILE* object. */\n    return drwav_init_file__internal_FILE(pWav, pFile, onChunk, pChunkUserData, flags, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_w(drwav* pWav, const wchar_t* filename, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_file_ex_w(pWav, filename, NULL, NULL, 0, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_ex_w(drwav* pWav, const wchar_t* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    FILE* pFile;\n    if (drwav_wfopen(&pFile, filename, L\"rb\", pAllocationCallbacks) != DRWAV_SUCCESS) {\n        return DRWAV_FALSE;\n    }\n\n    /* This takes ownership of the FILE* object. */\n    return drwav_init_file__internal_FILE(pWav, pFile, onChunk, pChunkUserData, flags, pAllocationCallbacks);\n}\n\n\nstatic drwav_bool32 drwav_init_file_write__internal_FILE(drwav* pWav, FILE* pFile, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav_bool32 result;\n\n    result = drwav_preinit_write(pWav, pFormat, isSequential, drwav__on_write_stdio, drwav__on_seek_stdio, (void*)pFile, pAllocationCallbacks);\n    if (result != DRWAV_TRUE) {\n        fclose(pFile);\n        return result;\n    }\n\n    result = drwav_init_write__internal(pWav, pFormat, totalSampleCount);\n    if (result != DRWAV_TRUE) {\n        fclose(pFile);\n        return result;\n    }\n\n    return DRWAV_TRUE;\n}\n\nstatic drwav_bool32 drwav_init_file_write__internal(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    FILE* pFile;\n    if (drwav_fopen(&pFile, filename, \"wb\") != DRWAV_SUCCESS) {\n        return DRWAV_FALSE;\n    }\n\n    /* This takes ownership of the FILE* object. */\n    return drwav_init_file_write__internal_FILE(pWav, pFile, pFormat, totalSampleCount, isSequential, pAllocationCallbacks);\n}\n\nstatic drwav_bool32 drwav_init_file_write_w__internal(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    FILE* pFile;\n    if (drwav_wfopen(&pFile, filename, L\"wb\", pAllocationCallbacks) != DRWAV_SUCCESS) {\n        return DRWAV_FALSE;\n    }\n\n    /* This takes ownership of the FILE* object. */\n    return drwav_init_file_write__internal_FILE(pWav, pFile, pFormat, totalSampleCount, isSequential, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_write(drwav* pWav, const char* filename, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_file_write__internal(pWav, filename, pFormat, 0, DRWAV_FALSE, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_file_write__internal(pWav, filename, pFormat, totalSampleCount, DRWAV_TRUE, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential_pcm_frames(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pFormat == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    return drwav_init_file_write_sequential(pWav, filename, pFormat, totalPCMFrameCount*pFormat->channels, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_write_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_file_write_w__internal(pWav, filename, pFormat, 0, DRWAV_FALSE, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_file_write_w__internal(pWav, filename, pFormat, totalSampleCount, DRWAV_TRUE, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_file_write_sequential_pcm_frames_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pFormat == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    return drwav_init_file_write_sequential_w(pWav, filename, pFormat, totalPCMFrameCount*pFormat->channels, pAllocationCallbacks);\n}\n#endif  /* DR_WAV_NO_STDIO */\n\n\nstatic size_t drwav__on_read_memory(void* pUserData, void* pBufferOut, size_t bytesToRead)\n{\n    drwav* pWav = (drwav*)pUserData;\n    size_t bytesRemaining;\n\n    DRWAV_ASSERT(pWav != NULL);\n    DRWAV_ASSERT(pWav->memoryStream.dataSize >= pWav->memoryStream.currentReadPos);\n\n    bytesRemaining = pWav->memoryStream.dataSize - pWav->memoryStream.currentReadPos;\n    if (bytesToRead > bytesRemaining) {\n        bytesToRead = bytesRemaining;\n    }\n\n    if (bytesToRead > 0) {\n        DRWAV_COPY_MEMORY(pBufferOut, pWav->memoryStream.data + pWav->memoryStream.currentReadPos, bytesToRead);\n        pWav->memoryStream.currentReadPos += bytesToRead;\n    }\n\n    return bytesToRead;\n}\n\nstatic drwav_bool32 drwav__on_seek_memory(void* pUserData, int offset, drwav_seek_origin origin)\n{\n    drwav* pWav = (drwav*)pUserData;\n    DRWAV_ASSERT(pWav != NULL);\n\n    if (origin == drwav_seek_origin_current) {\n        if (offset > 0) {\n            if (pWav->memoryStream.currentReadPos + offset > pWav->memoryStream.dataSize) {\n                return DRWAV_FALSE; /* Trying to seek too far forward. */\n            }\n        } else {\n            if (pWav->memoryStream.currentReadPos < (size_t)-offset) {\n                return DRWAV_FALSE; /* Trying to seek too far backwards. */\n            }\n        }\n\n        /* This will never underflow thanks to the clamps above. */\n        pWav->memoryStream.currentReadPos += offset;\n    } else {\n        if ((drwav_uint32)offset <= pWav->memoryStream.dataSize) {\n            pWav->memoryStream.currentReadPos = offset;\n        } else {\n            return DRWAV_FALSE; /* Trying to seek too far forward. */\n        }\n    }\n    \n    return DRWAV_TRUE;\n}\n\nstatic size_t drwav__on_write_memory(void* pUserData, const void* pDataIn, size_t bytesToWrite)\n{\n    drwav* pWav = (drwav*)pUserData;\n    size_t bytesRemaining;\n\n    DRWAV_ASSERT(pWav != NULL);\n    DRWAV_ASSERT(pWav->memoryStreamWrite.dataCapacity >= pWav->memoryStreamWrite.currentWritePos);\n\n    bytesRemaining = pWav->memoryStreamWrite.dataCapacity - pWav->memoryStreamWrite.currentWritePos;\n    if (bytesRemaining < bytesToWrite) {\n        /* Need to reallocate. */\n        void* pNewData;\n        size_t newDataCapacity = (pWav->memoryStreamWrite.dataCapacity == 0) ? 256 : pWav->memoryStreamWrite.dataCapacity * 2;\n\n        /* If doubling wasn't enough, just make it the minimum required size to write the data. */\n        if ((newDataCapacity - pWav->memoryStreamWrite.currentWritePos) < bytesToWrite) {\n            newDataCapacity = pWav->memoryStreamWrite.currentWritePos + bytesToWrite;\n        }\n\n        pNewData = drwav__realloc_from_callbacks(*pWav->memoryStreamWrite.ppData, newDataCapacity, pWav->memoryStreamWrite.dataCapacity, &pWav->allocationCallbacks);\n        if (pNewData == NULL) {\n            return 0;\n        }\n\n        *pWav->memoryStreamWrite.ppData = pNewData;\n        pWav->memoryStreamWrite.dataCapacity = newDataCapacity;\n    }\n\n    DRWAV_COPY_MEMORY(((drwav_uint8*)(*pWav->memoryStreamWrite.ppData)) + pWav->memoryStreamWrite.currentWritePos, pDataIn, bytesToWrite);\n\n    pWav->memoryStreamWrite.currentWritePos += bytesToWrite;\n    if (pWav->memoryStreamWrite.dataSize < pWav->memoryStreamWrite.currentWritePos) {\n        pWav->memoryStreamWrite.dataSize = pWav->memoryStreamWrite.currentWritePos;\n    }\n\n    *pWav->memoryStreamWrite.pDataSize = pWav->memoryStreamWrite.dataSize;\n\n    return bytesToWrite;\n}\n\nstatic drwav_bool32 drwav__on_seek_memory_write(void* pUserData, int offset, drwav_seek_origin origin)\n{\n    drwav* pWav = (drwav*)pUserData;\n    DRWAV_ASSERT(pWav != NULL);\n\n    if (origin == drwav_seek_origin_current) {\n        if (offset > 0) {\n            if (pWav->memoryStreamWrite.currentWritePos + offset > pWav->memoryStreamWrite.dataSize) {\n                offset = (int)(pWav->memoryStreamWrite.dataSize - pWav->memoryStreamWrite.currentWritePos);  /* Trying to seek too far forward. */\n            }\n        } else {\n            if (pWav->memoryStreamWrite.currentWritePos < (size_t)-offset) {\n                offset = -(int)pWav->memoryStreamWrite.currentWritePos;  /* Trying to seek too far backwards. */\n            }\n        }\n\n        /* This will never underflow thanks to the clamps above. */\n        pWav->memoryStreamWrite.currentWritePos += offset;\n    } else {\n        if ((drwav_uint32)offset <= pWav->memoryStreamWrite.dataSize) {\n            pWav->memoryStreamWrite.currentWritePos = offset;\n        } else {\n            pWav->memoryStreamWrite.currentWritePos = pWav->memoryStreamWrite.dataSize;  /* Trying to seek too far forward. */\n        }\n    }\n    \n    return DRWAV_TRUE;\n}\n\nDRWAV_API drwav_bool32 drwav_init_memory(drwav* pWav, const void* data, size_t dataSize, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_memory_ex(pWav, data, dataSize, NULL, NULL, 0, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_memory_ex(drwav* pWav, const void* data, size_t dataSize, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (data == NULL || dataSize == 0) {\n        return DRWAV_FALSE;\n    }\n\n    if (!drwav_preinit(pWav, drwav__on_read_memory, drwav__on_seek_memory, pWav, pAllocationCallbacks)) {\n        return DRWAV_FALSE;\n    }\n\n    pWav->memoryStream.data = (const drwav_uint8*)data;\n    pWav->memoryStream.dataSize = dataSize;\n    pWav->memoryStream.currentReadPos = 0;\n\n    return drwav_init__internal(pWav, onChunk, pChunkUserData, flags);\n}\n\n\nstatic drwav_bool32 drwav_init_memory_write__internal(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (ppData == NULL || pDataSize == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    *ppData = NULL; /* Important because we're using realloc()! */\n    *pDataSize = 0;\n\n    if (!drwav_preinit_write(pWav, pFormat, isSequential, drwav__on_write_memory, drwav__on_seek_memory_write, pWav, pAllocationCallbacks)) {\n        return DRWAV_FALSE;\n    }\n\n    pWav->memoryStreamWrite.ppData = ppData;\n    pWav->memoryStreamWrite.pDataSize = pDataSize;\n    pWav->memoryStreamWrite.dataSize = 0;\n    pWav->memoryStreamWrite.dataCapacity = 0;\n    pWav->memoryStreamWrite.currentWritePos = 0;\n\n    return drwav_init_write__internal(pWav, pFormat, totalSampleCount);\n}\n\nDRWAV_API drwav_bool32 drwav_init_memory_write(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_memory_write__internal(pWav, ppData, pDataSize, pFormat, 0, DRWAV_FALSE, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_memory_write_sequential(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    return drwav_init_memory_write__internal(pWav, ppData, pDataSize, pFormat, totalSampleCount, DRWAV_TRUE, pAllocationCallbacks);\n}\n\nDRWAV_API drwav_bool32 drwav_init_memory_write_sequential_pcm_frames(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pFormat == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    return drwav_init_memory_write_sequential(pWav, ppData, pDataSize, pFormat, totalPCMFrameCount*pFormat->channels, pAllocationCallbacks);\n}\n\n\n\nDRWAV_API drwav_result drwav_uninit(drwav* pWav)\n{\n    drwav_result result = DRWAV_SUCCESS;\n\n    if (pWav == NULL) {\n        return DRWAV_INVALID_ARGS;\n    }\n\n    /*\n    If the drwav object was opened in write mode we'll need to finalize a few things:\n      - Make sure the \"data\" chunk is aligned to 16-bits for RIFF containers, or 64 bits for W64 containers.\n      - Set the size of the \"data\" chunk.\n    */\n    if (pWav->onWrite != NULL) {\n        drwav_uint32 paddingSize = 0;\n\n        /* Padding. Do not adjust pWav->dataChunkDataSize - this should not include the padding. */\n        if (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64) {\n            paddingSize = drwav__chunk_padding_size_riff(pWav->dataChunkDataSize);\n        } else {\n            paddingSize = drwav__chunk_padding_size_w64(pWav->dataChunkDataSize);\n        }\n        \n        if (paddingSize > 0) {\n            drwav_uint64 paddingData = 0;\n            drwav__write(pWav, &paddingData, paddingSize);  /* Byte order does not matter for this. */\n        }\n\n        /*\n        Chunk sizes. When using sequential mode, these will have been filled in at initialization time. We only need\n        to do this when using non-sequential mode.\n        */\n        if (pWav->onSeek && !pWav->isSequentialWrite) {\n            if (pWav->container == drwav_container_riff) {\n                /* The \"RIFF\" chunk size. */\n                if (pWav->onSeek(pWav->pUserData, 4, drwav_seek_origin_start)) {\n                    drwav_uint32 riffChunkSize = drwav__riff_chunk_size_riff(pWav->dataChunkDataSize);\n                    drwav__write_u32ne_to_le(pWav, riffChunkSize);\n                }\n\n                /* the \"data\" chunk size. */\n                if (pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos + 4, drwav_seek_origin_start)) {\n                    drwav_uint32 dataChunkSize = drwav__data_chunk_size_riff(pWav->dataChunkDataSize);\n                    drwav__write_u32ne_to_le(pWav, dataChunkSize);\n                }\n            } else if (pWav->container == drwav_container_w64) {\n                /* The \"RIFF\" chunk size. */\n                if (pWav->onSeek(pWav->pUserData, 16, drwav_seek_origin_start)) {\n                    drwav_uint64 riffChunkSize = drwav__riff_chunk_size_w64(pWav->dataChunkDataSize);\n                    drwav__write_u64ne_to_le(pWav, riffChunkSize);\n                }\n\n                /* The \"data\" chunk size. */\n                if (pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos + 16, drwav_seek_origin_start)) {\n                    drwav_uint64 dataChunkSize = drwav__data_chunk_size_w64(pWav->dataChunkDataSize);\n                    drwav__write_u64ne_to_le(pWav, dataChunkSize);\n                }\n            } else if (pWav->container == drwav_container_rf64) {\n                /* We only need to update the ds64 chunk. The \"RIFF\" and \"data\" chunks always have their sizes set to 0xFFFFFFFF for RF64. */\n                int ds64BodyPos = 12 + 8;\n\n                /* The \"RIFF\" chunk size. */\n                if (pWav->onSeek(pWav->pUserData, ds64BodyPos + 0, drwav_seek_origin_start)) {\n                    drwav_uint64 riffChunkSize = drwav__riff_chunk_size_rf64(pWav->dataChunkDataSize);\n                    drwav__write_u64ne_to_le(pWav, riffChunkSize);\n                }\n\n                /* The \"data\" chunk size. */\n                if (pWav->onSeek(pWav->pUserData, ds64BodyPos + 8, drwav_seek_origin_start)) {\n                    drwav_uint64 dataChunkSize = drwav__data_chunk_size_rf64(pWav->dataChunkDataSize);\n                    drwav__write_u64ne_to_le(pWav, dataChunkSize);\n                }\n            }\n        }\n\n        /* Validation for sequential mode. */\n        if (pWav->isSequentialWrite) {\n            if (pWav->dataChunkDataSize != pWav->dataChunkDataSizeTargetWrite) {\n                result = DRWAV_INVALID_FILE;\n            }\n        }\n    }\n\n#ifndef DR_WAV_NO_STDIO\n    /*\n    If we opened the file with drwav_open_file() we will want to close the file handle. We can know whether or not drwav_open_file()\n    was used by looking at the onRead and onSeek callbacks.\n    */\n    if (pWav->onRead == drwav__on_read_stdio || pWav->onWrite == drwav__on_write_stdio) {\n        fclose((FILE*)pWav->pUserData);\n    }\n#endif\n\n    return result;\n}\n\n\n\nDRWAV_API size_t drwav_read_raw(drwav* pWav, size_t bytesToRead, void* pBufferOut)\n{\n    size_t bytesRead;\n\n    if (pWav == NULL || bytesToRead == 0) {\n        return 0;\n    }\n\n    if (bytesToRead > pWav->bytesRemaining) {\n        bytesToRead = (size_t)pWav->bytesRemaining;\n    }\n\n    if (pBufferOut != NULL) {\n        bytesRead = pWav->onRead(pWav->pUserData, pBufferOut, bytesToRead);\n    } else {\n        /* We need to seek. If we fail, we need to read-and-discard to make sure we get a good byte count. */\n        bytesRead = 0;\n        while (bytesRead < bytesToRead) {\n            size_t bytesToSeek = (bytesToRead - bytesRead);\n            if (bytesToSeek > 0x7FFFFFFF) {\n                bytesToSeek = 0x7FFFFFFF;\n            }\n\n            if (pWav->onSeek(pWav->pUserData, (int)bytesToSeek, drwav_seek_origin_current) == DRWAV_FALSE) {\n                break;\n            }\n\n            bytesRead += bytesToSeek;\n        }\n\n        /* When we get here we may need to read-and-discard some data. */\n        while (bytesRead < bytesToRead) {\n            drwav_uint8 buffer[4096];\n            size_t bytesSeeked;\n            size_t bytesToSeek = (bytesToRead - bytesRead);\n            if (bytesToSeek > sizeof(buffer)) {\n                bytesToSeek = sizeof(buffer);\n            }\n\n            bytesSeeked = pWav->onRead(pWav->pUserData, buffer, bytesToSeek);\n            bytesRead += bytesSeeked;\n\n            if (bytesSeeked < bytesToSeek) {\n                break;  /* Reached the end. */\n            }\n        }\n    }\n\n    pWav->bytesRemaining -= bytesRead;\n    return bytesRead;\n}\n\n\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_le(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut)\n{\n    drwav_uint32 bytesPerFrame;\n    drwav_uint64 bytesToRead;   /* Intentionally uint64 instead of size_t so we can do a check that we're not reading too much on 32-bit builds. */\n\n    if (pWav == NULL || framesToRead == 0) {\n        return 0;\n    }\n\n    /* Cannot use this function for compressed formats. */\n    if (drwav__is_compressed_format_tag(pWav->translatedFormatTag)) {\n        return 0;\n    }\n\n    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    /* Don't try to read more samples than can potentially fit in the output buffer. */\n    bytesToRead = framesToRead * bytesPerFrame;\n    if (bytesToRead > DRWAV_SIZE_MAX) {\n        bytesToRead = (DRWAV_SIZE_MAX / bytesPerFrame) * bytesPerFrame; /* Round the number of bytes to read to a clean frame boundary. */\n    }\n\n    /*\n    Doing an explicit check here just to make it clear that we don't want to be attempt to read anything if there's no bytes to read. There\n    *could* be a time where it evaluates to 0 due to overflowing.\n    */\n    if (bytesToRead == 0) {\n        return 0;\n    }\n\n    return drwav_read_raw(pWav, (size_t)bytesToRead, pBufferOut) / bytesPerFrame;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_be(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut)\n{\n    drwav_uint64 framesRead = drwav_read_pcm_frames_le(pWav, framesToRead, pBufferOut);\n\n    if (pBufferOut != NULL) {\n        drwav__bswap_samples(pBufferOut, framesRead*pWav->channels, drwav_get_bytes_per_pcm_frame(pWav)/pWav->channels, pWav->translatedFormatTag);\n    }\n\n    return framesRead;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut)\n{\n    if (drwav__is_little_endian()) {\n        return drwav_read_pcm_frames_le(pWav, framesToRead, pBufferOut);\n    } else {\n        return drwav_read_pcm_frames_be(pWav, framesToRead, pBufferOut);\n    }\n}\n\n\n\nDRWAV_API drwav_bool32 drwav_seek_to_first_pcm_frame(drwav* pWav)\n{\n    if (pWav->onWrite != NULL) {\n        return DRWAV_FALSE; /* No seeking in write mode. */\n    }\n\n    if (!pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos, drwav_seek_origin_start)) {\n        return DRWAV_FALSE;\n    }\n\n    if (drwav__is_compressed_format_tag(pWav->translatedFormatTag)) {\n        pWav->compressed.iCurrentPCMFrame = 0;\n\n        /* Cached data needs to be cleared for compressed formats. */\n        if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n            DRWAV_ZERO_OBJECT(&pWav->msadpcm);\n        } else if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n            DRWAV_ZERO_OBJECT(&pWav->ima);\n        } else {\n            DRWAV_ASSERT(DRWAV_FALSE);  /* If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here. */\n        }\n    }\n    \n    pWav->bytesRemaining = pWav->dataChunkDataSize;\n    return DRWAV_TRUE;\n}\n\nDRWAV_API drwav_bool32 drwav_seek_to_pcm_frame(drwav* pWav, drwav_uint64 targetFrameIndex)\n{\n    /* Seeking should be compatible with wave files > 2GB. */\n\n    if (pWav == NULL || pWav->onSeek == NULL) {\n        return DRWAV_FALSE;\n    }\n\n    /* No seeking in write mode. */\n    if (pWav->onWrite != NULL) {\n        return DRWAV_FALSE;\n    }\n\n    /* If there are no samples, just return DRWAV_TRUE without doing anything. */\n    if (pWav->totalPCMFrameCount == 0) {\n        return DRWAV_TRUE;\n    }\n\n    /* Make sure the sample is clamped. */\n    if (targetFrameIndex >= pWav->totalPCMFrameCount) {\n        targetFrameIndex  = pWav->totalPCMFrameCount - 1;\n    }\n\n    /*\n    For compressed formats we just use a slow generic seek. If we are seeking forward we just seek forward. If we are going backwards we need\n    to seek back to the start.\n    */\n    if (drwav__is_compressed_format_tag(pWav->translatedFormatTag)) {\n        /* TODO: This can be optimized. */\n        \n        /*\n        If we're seeking forward it's simple - just keep reading samples until we hit the sample we're requesting. If we're seeking backwards,\n        we first need to seek back to the start and then just do the same thing as a forward seek.\n        */\n        if (targetFrameIndex < pWav->compressed.iCurrentPCMFrame) {\n            if (!drwav_seek_to_first_pcm_frame(pWav)) {\n                return DRWAV_FALSE;\n            }\n        }\n\n        if (targetFrameIndex > pWav->compressed.iCurrentPCMFrame) {\n            drwav_uint64 offsetInFrames = targetFrameIndex - pWav->compressed.iCurrentPCMFrame;\n\n            drwav_int16 devnull[2048];\n            while (offsetInFrames > 0) {\n                drwav_uint64 framesRead = 0;\n                drwav_uint64 framesToRead = offsetInFrames;\n                if (framesToRead > drwav_countof(devnull)/pWav->channels) {\n                    framesToRead = drwav_countof(devnull)/pWav->channels;\n                }\n\n                if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n                    framesRead = drwav_read_pcm_frames_s16__msadpcm(pWav, framesToRead, devnull);\n                } else if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n                    framesRead = drwav_read_pcm_frames_s16__ima(pWav, framesToRead, devnull);\n                } else {\n                    DRWAV_ASSERT(DRWAV_FALSE);  /* If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here. */\n                }\n\n                if (framesRead != framesToRead) {\n                    return DRWAV_FALSE;\n                }\n\n                offsetInFrames -= framesRead;\n            }\n        }\n    } else {\n        drwav_uint64 totalSizeInBytes;\n        drwav_uint64 currentBytePos;\n        drwav_uint64 targetBytePos;\n        drwav_uint64 offset;\n\n        totalSizeInBytes = pWav->totalPCMFrameCount * drwav_get_bytes_per_pcm_frame(pWav);\n        DRWAV_ASSERT(totalSizeInBytes >= pWav->bytesRemaining);\n\n        currentBytePos = totalSizeInBytes - pWav->bytesRemaining;\n        targetBytePos  = targetFrameIndex * drwav_get_bytes_per_pcm_frame(pWav);\n\n        if (currentBytePos < targetBytePos) {\n            /* Offset forwards. */\n            offset = (targetBytePos - currentBytePos);\n        } else {\n            /* Offset backwards. */\n            if (!drwav_seek_to_first_pcm_frame(pWav)) {\n                return DRWAV_FALSE;\n            }\n            offset = targetBytePos;\n        }\n\n        while (offset > 0) {\n            int offset32 = ((offset > INT_MAX) ? INT_MAX : (int)offset);\n            if (!pWav->onSeek(pWav->pUserData, offset32, drwav_seek_origin_current)) {\n                return DRWAV_FALSE;\n            }\n\n            pWav->bytesRemaining -= offset32;\n            offset -= offset32;\n        }\n    }\n\n    return DRWAV_TRUE;\n}\n\n\nDRWAV_API size_t drwav_write_raw(drwav* pWav, size_t bytesToWrite, const void* pData)\n{\n    size_t bytesWritten;\n\n    if (pWav == NULL || bytesToWrite == 0 || pData == NULL) {\n        return 0;\n    }\n\n    bytesWritten = pWav->onWrite(pWav->pUserData, pData, bytesToWrite);\n    pWav->dataChunkDataSize += bytesWritten;\n\n    return bytesWritten;\n}\n\n\nDRWAV_API drwav_uint64 drwav_write_pcm_frames_le(drwav* pWav, drwav_uint64 framesToWrite, const void* pData)\n{\n    drwav_uint64 bytesToWrite;\n    drwav_uint64 bytesWritten;\n    const drwav_uint8* pRunningData;\n\n    if (pWav == NULL || framesToWrite == 0 || pData == NULL) {\n        return 0;\n    }\n\n    bytesToWrite = ((framesToWrite * pWav->channels * pWav->bitsPerSample) / 8);\n    if (bytesToWrite > DRWAV_SIZE_MAX) {\n        return 0;\n    }\n\n    bytesWritten = 0;\n    pRunningData = (const drwav_uint8*)pData;\n\n    while (bytesToWrite > 0) {\n        size_t bytesJustWritten;\n        drwav_uint64 bytesToWriteThisIteration;\n\n        bytesToWriteThisIteration = bytesToWrite;\n        DRWAV_ASSERT(bytesToWriteThisIteration <= DRWAV_SIZE_MAX);  /* <-- This is checked above. */\n\n        bytesJustWritten = drwav_write_raw(pWav, (size_t)bytesToWriteThisIteration, pRunningData);\n        if (bytesJustWritten == 0) {\n            break;\n        }\n\n        bytesToWrite -= bytesJustWritten;\n        bytesWritten += bytesJustWritten;\n        pRunningData += bytesJustWritten;\n    }\n\n    return (bytesWritten * 8) / pWav->bitsPerSample / pWav->channels;\n}\n\nDRWAV_API drwav_uint64 drwav_write_pcm_frames_be(drwav* pWav, drwav_uint64 framesToWrite, const void* pData)\n{\n    drwav_uint64 bytesToWrite;\n    drwav_uint64 bytesWritten;\n    drwav_uint32 bytesPerSample;\n    const drwav_uint8* pRunningData;\n\n    if (pWav == NULL || framesToWrite == 0 || pData == NULL) {\n        return 0;\n    }\n\n    bytesToWrite = ((framesToWrite * pWav->channels * pWav->bitsPerSample) / 8);\n    if (bytesToWrite > DRWAV_SIZE_MAX) {\n        return 0;\n    }\n\n    bytesWritten = 0;\n    pRunningData = (const drwav_uint8*)pData;\n\n    bytesPerSample = drwav_get_bytes_per_pcm_frame(pWav) / pWav->channels;\n    \n    while (bytesToWrite > 0) {\n        drwav_uint8 temp[4096];\n        drwav_uint32 sampleCount;\n        size_t bytesJustWritten;\n        drwav_uint64 bytesToWriteThisIteration;\n\n        bytesToWriteThisIteration = bytesToWrite;\n        DRWAV_ASSERT(bytesToWriteThisIteration <= DRWAV_SIZE_MAX);  /* <-- This is checked above. */\n\n        /*\n        WAV files are always little-endian. We need to byte swap on big-endian architectures. Since our input buffer is read-only we need\n        to use an intermediary buffer for the conversion.\n        */\n        sampleCount = sizeof(temp)/bytesPerSample;\n\n        if (bytesToWriteThisIteration > ((drwav_uint64)sampleCount)*bytesPerSample) {\n            bytesToWriteThisIteration = ((drwav_uint64)sampleCount)*bytesPerSample;\n        }\n\n        DRWAV_COPY_MEMORY(temp, pRunningData, (size_t)bytesToWriteThisIteration);\n        drwav__bswap_samples(temp, sampleCount, bytesPerSample, pWav->translatedFormatTag);\n\n        bytesJustWritten = drwav_write_raw(pWav, (size_t)bytesToWriteThisIteration, temp);\n        if (bytesJustWritten == 0) {\n            break;\n        }\n\n        bytesToWrite -= bytesJustWritten;\n        bytesWritten += bytesJustWritten;\n        pRunningData += bytesJustWritten;\n    }\n\n    return (bytesWritten * 8) / pWav->bitsPerSample / pWav->channels;\n}\n\nDRWAV_API drwav_uint64 drwav_write_pcm_frames(drwav* pWav, drwav_uint64 framesToWrite, const void* pData)\n{\n    if (drwav__is_little_endian()) {\n        return drwav_write_pcm_frames_le(pWav, framesToWrite, pData);\n    } else {\n        return drwav_write_pcm_frames_be(pWav, framesToWrite, pData);\n    }\n}\n\n\nstatic drwav_uint64 drwav_read_pcm_frames_s16__msadpcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint64 totalFramesRead = 0;\n\n    DRWAV_ASSERT(pWav != NULL);\n    DRWAV_ASSERT(framesToRead > 0);\n\n    /* TODO: Lots of room for optimization here. */\n\n    while (framesToRead > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {\n        /* If there are no cached frames we need to load a new block. */\n        if (pWav->msadpcm.cachedFrameCount == 0 && pWav->msadpcm.bytesRemainingInBlock == 0) {\n            if (pWav->channels == 1) {\n                /* Mono. */\n                drwav_uint8 header[7];\n                if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {\n                    return totalFramesRead;\n                }\n                pWav->msadpcm.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);\n\n                pWav->msadpcm.predictor[0]     = header[0];\n                pWav->msadpcm.delta[0]         = drwav__bytes_to_s16(header + 1);\n                pWav->msadpcm.prevFrames[0][1] = (drwav_int32)drwav__bytes_to_s16(header + 3);\n                pWav->msadpcm.prevFrames[0][0] = (drwav_int32)drwav__bytes_to_s16(header + 5);\n                pWav->msadpcm.cachedFrames[2]  = pWav->msadpcm.prevFrames[0][0];\n                pWav->msadpcm.cachedFrames[3]  = pWav->msadpcm.prevFrames[0][1];\n                pWav->msadpcm.cachedFrameCount = 2;\n            } else {\n                /* Stereo. */\n                drwav_uint8 header[14];\n                if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {\n                    return totalFramesRead;\n                }\n                pWav->msadpcm.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);\n\n                pWav->msadpcm.predictor[0] = header[0];\n                pWav->msadpcm.predictor[1] = header[1];\n                pWav->msadpcm.delta[0] = drwav__bytes_to_s16(header + 2);\n                pWav->msadpcm.delta[1] = drwav__bytes_to_s16(header + 4);\n                pWav->msadpcm.prevFrames[0][1] = (drwav_int32)drwav__bytes_to_s16(header + 6);\n                pWav->msadpcm.prevFrames[1][1] = (drwav_int32)drwav__bytes_to_s16(header + 8);\n                pWav->msadpcm.prevFrames[0][0] = (drwav_int32)drwav__bytes_to_s16(header + 10);\n                pWav->msadpcm.prevFrames[1][0] = (drwav_int32)drwav__bytes_to_s16(header + 12);\n\n                pWav->msadpcm.cachedFrames[0] = pWav->msadpcm.prevFrames[0][0];\n                pWav->msadpcm.cachedFrames[1] = pWav->msadpcm.prevFrames[1][0];\n                pWav->msadpcm.cachedFrames[2] = pWav->msadpcm.prevFrames[0][1];\n                pWav->msadpcm.cachedFrames[3] = pWav->msadpcm.prevFrames[1][1];\n                pWav->msadpcm.cachedFrameCount = 2;\n            }\n        }\n\n        /* Output anything that's cached. */\n        while (framesToRead > 0 && pWav->msadpcm.cachedFrameCount > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {\n            if (pBufferOut != NULL) {\n                drwav_uint32 iSample = 0;\n                for (iSample = 0; iSample < pWav->channels; iSample += 1) {\n                    pBufferOut[iSample] = (drwav_int16)pWav->msadpcm.cachedFrames[(drwav_countof(pWav->msadpcm.cachedFrames) - (pWav->msadpcm.cachedFrameCount*pWav->channels)) + iSample];\n                }\n\n                pBufferOut += pWav->channels;\n            }\n\n            framesToRead    -= 1;\n            totalFramesRead += 1;\n            pWav->compressed.iCurrentPCMFrame += 1;\n            pWav->msadpcm.cachedFrameCount -= 1;\n        }\n\n        if (framesToRead == 0) {\n            return totalFramesRead;\n        }\n\n\n        /*\n        If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next\n        loop iteration which will trigger the loading of a new block.\n        */\n        if (pWav->msadpcm.cachedFrameCount == 0) {\n            if (pWav->msadpcm.bytesRemainingInBlock == 0) {\n                continue;\n            } else {\n                static drwav_int32 adaptationTable[] = { \n                    230, 230, 230, 230, 307, 409, 512, 614, \n                    768, 614, 512, 409, 307, 230, 230, 230 \n                };\n                static drwav_int32 coeff1Table[] = { 256, 512, 0, 192, 240, 460,  392 };\n                static drwav_int32 coeff2Table[] = { 0,  -256, 0, 64,  0,  -208, -232 };\n\n                drwav_uint8 nibbles;\n                drwav_int32 nibble0;\n                drwav_int32 nibble1;\n\n                if (pWav->onRead(pWav->pUserData, &nibbles, 1) != 1) {\n                    return totalFramesRead;\n                }\n                pWav->msadpcm.bytesRemainingInBlock -= 1;\n\n                /* TODO: Optimize away these if statements. */\n                nibble0 = ((nibbles & 0xF0) >> 4); if ((nibbles & 0x80)) { nibble0 |= 0xFFFFFFF0UL; }\n                nibble1 = ((nibbles & 0x0F) >> 0); if ((nibbles & 0x08)) { nibble1 |= 0xFFFFFFF0UL; }\n\n                if (pWav->channels == 1) {\n                    /* Mono. */\n                    drwav_int32 newSample0;\n                    drwav_int32 newSample1;\n\n                    newSample0  = ((pWav->msadpcm.prevFrames[0][1] * coeff1Table[pWav->msadpcm.predictor[0]]) + (pWav->msadpcm.prevFrames[0][0] * coeff2Table[pWav->msadpcm.predictor[0]])) >> 8;\n                    newSample0 += nibble0 * pWav->msadpcm.delta[0];\n                    newSample0  = drwav_clamp(newSample0, -32768, 32767);\n\n                    pWav->msadpcm.delta[0] = (adaptationTable[((nibbles & 0xF0) >> 4)] * pWav->msadpcm.delta[0]) >> 8;\n                    if (pWav->msadpcm.delta[0] < 16) {\n                        pWav->msadpcm.delta[0] = 16;\n                    }\n\n                    pWav->msadpcm.prevFrames[0][0] = pWav->msadpcm.prevFrames[0][1];\n                    pWav->msadpcm.prevFrames[0][1] = newSample0;\n\n\n                    newSample1  = ((pWav->msadpcm.prevFrames[0][1] * coeff1Table[pWav->msadpcm.predictor[0]]) + (pWav->msadpcm.prevFrames[0][0] * coeff2Table[pWav->msadpcm.predictor[0]])) >> 8;\n                    newSample1 += nibble1 * pWav->msadpcm.delta[0];\n                    newSample1  = drwav_clamp(newSample1, -32768, 32767);\n\n                    pWav->msadpcm.delta[0] = (adaptationTable[((nibbles & 0x0F) >> 0)] * pWav->msadpcm.delta[0]) >> 8;\n                    if (pWav->msadpcm.delta[0] < 16) {\n                        pWav->msadpcm.delta[0] = 16;\n                    }\n\n                    pWav->msadpcm.prevFrames[0][0] = pWav->msadpcm.prevFrames[0][1];\n                    pWav->msadpcm.prevFrames[0][1] = newSample1;\n\n\n                    pWav->msadpcm.cachedFrames[2] = newSample0;\n                    pWav->msadpcm.cachedFrames[3] = newSample1;\n                    pWav->msadpcm.cachedFrameCount = 2;\n                } else {\n                    /* Stereo. */\n                    drwav_int32 newSample0;\n                    drwav_int32 newSample1;\n\n                    /* Left. */\n                    newSample0  = ((pWav->msadpcm.prevFrames[0][1] * coeff1Table[pWav->msadpcm.predictor[0]]) + (pWav->msadpcm.prevFrames[0][0] * coeff2Table[pWav->msadpcm.predictor[0]])) >> 8;\n                    newSample0 += nibble0 * pWav->msadpcm.delta[0];\n                    newSample0  = drwav_clamp(newSample0, -32768, 32767);\n\n                    pWav->msadpcm.delta[0] = (adaptationTable[((nibbles & 0xF0) >> 4)] * pWav->msadpcm.delta[0]) >> 8;\n                    if (pWav->msadpcm.delta[0] < 16) {\n                        pWav->msadpcm.delta[0] = 16;\n                    }\n\n                    pWav->msadpcm.prevFrames[0][0] = pWav->msadpcm.prevFrames[0][1];\n                    pWav->msadpcm.prevFrames[0][1] = newSample0;\n\n\n                    /* Right. */\n                    newSample1  = ((pWav->msadpcm.prevFrames[1][1] * coeff1Table[pWav->msadpcm.predictor[1]]) + (pWav->msadpcm.prevFrames[1][0] * coeff2Table[pWav->msadpcm.predictor[1]])) >> 8;\n                    newSample1 += nibble1 * pWav->msadpcm.delta[1];\n                    newSample1  = drwav_clamp(newSample1, -32768, 32767);\n\n                    pWav->msadpcm.delta[1] = (adaptationTable[((nibbles & 0x0F) >> 0)] * pWav->msadpcm.delta[1]) >> 8;\n                    if (pWav->msadpcm.delta[1] < 16) {\n                        pWav->msadpcm.delta[1] = 16;\n                    }\n\n                    pWav->msadpcm.prevFrames[1][0] = pWav->msadpcm.prevFrames[1][1];\n                    pWav->msadpcm.prevFrames[1][1] = newSample1;\n\n                    pWav->msadpcm.cachedFrames[2] = newSample0;\n                    pWav->msadpcm.cachedFrames[3] = newSample1;\n                    pWav->msadpcm.cachedFrameCount = 1;\n                }\n            }\n        }\n    }\n\n    return totalFramesRead;\n}\n\n\nstatic drwav_uint64 drwav_read_pcm_frames_s16__ima(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint64 totalFramesRead = 0;\n    drwav_uint32 iChannel;\n\n    static drwav_int32 indexTable[16] = {\n        -1, -1, -1, -1, 2, 4, 6, 8,\n        -1, -1, -1, -1, 2, 4, 6, 8\n    };\n\n    static drwav_int32 stepTable[89] = {\n        7,     8,     9,     10,    11,    12,    13,    14,    16,    17, \n        19,    21,    23,    25,    28,    31,    34,    37,    41,    45, \n        50,    55,    60,    66,    73,    80,    88,    97,    107,   118, \n        130,   143,   157,   173,   190,   209,   230,   253,   279,   307,\n        337,   371,   408,   449,   494,   544,   598,   658,   724,   796,\n        876,   963,   1060,  1166,  1282,  1411,  1552,  1707,  1878,  2066, \n        2272,  2499,  2749,  3024,  3327,  3660,  4026,  4428,  4871,  5358,\n        5894,  6484,  7132,  7845,  8630,  9493,  10442, 11487, 12635, 13899, \n        15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767 \n    };\n\n    DRWAV_ASSERT(pWav != NULL);\n    DRWAV_ASSERT(framesToRead > 0);\n\n    /* TODO: Lots of room for optimization here. */\n\n    while (framesToRead > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {\n        /* If there are no cached samples we need to load a new block. */\n        if (pWav->ima.cachedFrameCount == 0 && pWav->ima.bytesRemainingInBlock == 0) {\n            if (pWav->channels == 1) {\n                /* Mono. */\n                drwav_uint8 header[4];\n                if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {\n                    return totalFramesRead;\n                }\n                pWav->ima.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);\n\n                if (header[2] >= drwav_countof(stepTable)) {\n                    pWav->onSeek(pWav->pUserData, pWav->ima.bytesRemainingInBlock, drwav_seek_origin_current);\n                    pWav->ima.bytesRemainingInBlock = 0;\n                    return totalFramesRead; /* Invalid data. */\n                }\n\n                pWav->ima.predictor[0] = drwav__bytes_to_s16(header + 0);\n                pWav->ima.stepIndex[0] = header[2];\n                pWav->ima.cachedFrames[drwav_countof(pWav->ima.cachedFrames) - 1] = pWav->ima.predictor[0];\n                pWav->ima.cachedFrameCount = 1;\n            } else {\n                /* Stereo. */\n                drwav_uint8 header[8];\n                if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {\n                    return totalFramesRead;\n                }\n                pWav->ima.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);\n\n                if (header[2] >= drwav_countof(stepTable) || header[6] >= drwav_countof(stepTable)) {\n                    pWav->onSeek(pWav->pUserData, pWav->ima.bytesRemainingInBlock, drwav_seek_origin_current);\n                    pWav->ima.bytesRemainingInBlock = 0;\n                    return totalFramesRead; /* Invalid data. */\n                }\n\n                pWav->ima.predictor[0] = drwav__bytes_to_s16(header + 0);\n                pWav->ima.stepIndex[0] = header[2];\n                pWav->ima.predictor[1] = drwav__bytes_to_s16(header + 4);\n                pWav->ima.stepIndex[1] = header[6];\n\n                pWav->ima.cachedFrames[drwav_countof(pWav->ima.cachedFrames) - 2] = pWav->ima.predictor[0];\n                pWav->ima.cachedFrames[drwav_countof(pWav->ima.cachedFrames) - 1] = pWav->ima.predictor[1];\n                pWav->ima.cachedFrameCount = 1;\n            }\n        }\n\n        /* Output anything that's cached. */\n        while (framesToRead > 0 && pWav->ima.cachedFrameCount > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {\n            if (pBufferOut != NULL) {\n                drwav_uint32 iSample;\n                for (iSample = 0; iSample < pWav->channels; iSample += 1) {\n                    pBufferOut[iSample] = (drwav_int16)pWav->ima.cachedFrames[(drwav_countof(pWav->ima.cachedFrames) - (pWav->ima.cachedFrameCount*pWav->channels)) + iSample];\n                }\n                pBufferOut += pWav->channels;\n            }\n\n            framesToRead    -= 1;\n            totalFramesRead += 1;\n            pWav->compressed.iCurrentPCMFrame += 1;\n            pWav->ima.cachedFrameCount -= 1;\n        }\n\n        if (framesToRead == 0) {\n            return totalFramesRead;\n        }\n\n        /*\n        If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next\n        loop iteration which will trigger the loading of a new block.\n        */\n        if (pWav->ima.cachedFrameCount == 0) {\n            if (pWav->ima.bytesRemainingInBlock == 0) {\n                continue;\n            } else {\n                /*\n                From what I can tell with stereo streams, it looks like every 4 bytes (8 samples) is for one channel. So it goes 4 bytes for the\n                left channel, 4 bytes for the right channel.\n                */\n                pWav->ima.cachedFrameCount = 8;\n                for (iChannel = 0; iChannel < pWav->channels; ++iChannel) {\n                    drwav_uint32 iByte;\n                    drwav_uint8 nibbles[4];\n                    if (pWav->onRead(pWav->pUserData, &nibbles, 4) != 4) {\n                        pWav->ima.cachedFrameCount = 0;\n                        return totalFramesRead;\n                    }\n                    pWav->ima.bytesRemainingInBlock -= 4;\n\n                    for (iByte = 0; iByte < 4; ++iByte) {\n                        drwav_uint8 nibble0 = ((nibbles[iByte] & 0x0F) >> 0);\n                        drwav_uint8 nibble1 = ((nibbles[iByte] & 0xF0) >> 4);\n\n                        drwav_int32 step      = stepTable[pWav->ima.stepIndex[iChannel]];\n                        drwav_int32 predictor = pWav->ima.predictor[iChannel];\n\n                        drwav_int32      diff  = step >> 3;\n                        if (nibble0 & 1) diff += step >> 2;\n                        if (nibble0 & 2) diff += step >> 1;\n                        if (nibble0 & 4) diff += step;\n                        if (nibble0 & 8) diff  = -diff;\n\n                        predictor = drwav_clamp(predictor + diff, -32768, 32767);\n                        pWav->ima.predictor[iChannel] = predictor;\n                        pWav->ima.stepIndex[iChannel] = drwav_clamp(pWav->ima.stepIndex[iChannel] + indexTable[nibble0], 0, (drwav_int32)drwav_countof(stepTable)-1);\n                        pWav->ima.cachedFrames[(drwav_countof(pWav->ima.cachedFrames) - (pWav->ima.cachedFrameCount*pWav->channels)) + (iByte*2+0)*pWav->channels + iChannel] = predictor;\n\n\n                        step      = stepTable[pWav->ima.stepIndex[iChannel]];\n                        predictor = pWav->ima.predictor[iChannel];\n\n                                         diff  = step >> 3;\n                        if (nibble1 & 1) diff += step >> 2;\n                        if (nibble1 & 2) diff += step >> 1;\n                        if (nibble1 & 4) diff += step;\n                        if (nibble1 & 8) diff  = -diff;\n\n                        predictor = drwav_clamp(predictor + diff, -32768, 32767);\n                        pWav->ima.predictor[iChannel] = predictor;\n                        pWav->ima.stepIndex[iChannel] = drwav_clamp(pWav->ima.stepIndex[iChannel] + indexTable[nibble1], 0, (drwav_int32)drwav_countof(stepTable)-1);\n                        pWav->ima.cachedFrames[(drwav_countof(pWav->ima.cachedFrames) - (pWav->ima.cachedFrameCount*pWav->channels)) + (iByte*2+1)*pWav->channels + iChannel] = predictor;\n                    }\n                }\n            }\n        }\n    }\n\n    return totalFramesRead;\n}\n\n\n#ifndef DR_WAV_NO_CONVERSION_API\nstatic unsigned short g_drwavAlawTable[256] = {\n    0xEA80, 0xEB80, 0xE880, 0xE980, 0xEE80, 0xEF80, 0xEC80, 0xED80, 0xE280, 0xE380, 0xE080, 0xE180, 0xE680, 0xE780, 0xE480, 0xE580, \n    0xF540, 0xF5C0, 0xF440, 0xF4C0, 0xF740, 0xF7C0, 0xF640, 0xF6C0, 0xF140, 0xF1C0, 0xF040, 0xF0C0, 0xF340, 0xF3C0, 0xF240, 0xF2C0, \n    0xAA00, 0xAE00, 0xA200, 0xA600, 0xBA00, 0xBE00, 0xB200, 0xB600, 0x8A00, 0x8E00, 0x8200, 0x8600, 0x9A00, 0x9E00, 0x9200, 0x9600, \n    0xD500, 0xD700, 0xD100, 0xD300, 0xDD00, 0xDF00, 0xD900, 0xDB00, 0xC500, 0xC700, 0xC100, 0xC300, 0xCD00, 0xCF00, 0xC900, 0xCB00, \n    0xFEA8, 0xFEB8, 0xFE88, 0xFE98, 0xFEE8, 0xFEF8, 0xFEC8, 0xFED8, 0xFE28, 0xFE38, 0xFE08, 0xFE18, 0xFE68, 0xFE78, 0xFE48, 0xFE58, \n    0xFFA8, 0xFFB8, 0xFF88, 0xFF98, 0xFFE8, 0xFFF8, 0xFFC8, 0xFFD8, 0xFF28, 0xFF38, 0xFF08, 0xFF18, 0xFF68, 0xFF78, 0xFF48, 0xFF58, \n    0xFAA0, 0xFAE0, 0xFA20, 0xFA60, 0xFBA0, 0xFBE0, 0xFB20, 0xFB60, 0xF8A0, 0xF8E0, 0xF820, 0xF860, 0xF9A0, 0xF9E0, 0xF920, 0xF960, \n    0xFD50, 0xFD70, 0xFD10, 0xFD30, 0xFDD0, 0xFDF0, 0xFD90, 0xFDB0, 0xFC50, 0xFC70, 0xFC10, 0xFC30, 0xFCD0, 0xFCF0, 0xFC90, 0xFCB0, \n    0x1580, 0x1480, 0x1780, 0x1680, 0x1180, 0x1080, 0x1380, 0x1280, 0x1D80, 0x1C80, 0x1F80, 0x1E80, 0x1980, 0x1880, 0x1B80, 0x1A80, \n    0x0AC0, 0x0A40, 0x0BC0, 0x0B40, 0x08C0, 0x0840, 0x09C0, 0x0940, 0x0EC0, 0x0E40, 0x0FC0, 0x0F40, 0x0CC0, 0x0C40, 0x0DC0, 0x0D40, \n    0x5600, 0x5200, 0x5E00, 0x5A00, 0x4600, 0x4200, 0x4E00, 0x4A00, 0x7600, 0x7200, 0x7E00, 0x7A00, 0x6600, 0x6200, 0x6E00, 0x6A00, \n    0x2B00, 0x2900, 0x2F00, 0x2D00, 0x2300, 0x2100, 0x2700, 0x2500, 0x3B00, 0x3900, 0x3F00, 0x3D00, 0x3300, 0x3100, 0x3700, 0x3500, \n    0x0158, 0x0148, 0x0178, 0x0168, 0x0118, 0x0108, 0x0138, 0x0128, 0x01D8, 0x01C8, 0x01F8, 0x01E8, 0x0198, 0x0188, 0x01B8, 0x01A8, \n    0x0058, 0x0048, 0x0078, 0x0068, 0x0018, 0x0008, 0x0038, 0x0028, 0x00D8, 0x00C8, 0x00F8, 0x00E8, 0x0098, 0x0088, 0x00B8, 0x00A8, \n    0x0560, 0x0520, 0x05E0, 0x05A0, 0x0460, 0x0420, 0x04E0, 0x04A0, 0x0760, 0x0720, 0x07E0, 0x07A0, 0x0660, 0x0620, 0x06E0, 0x06A0, \n    0x02B0, 0x0290, 0x02F0, 0x02D0, 0x0230, 0x0210, 0x0270, 0x0250, 0x03B0, 0x0390, 0x03F0, 0x03D0, 0x0330, 0x0310, 0x0370, 0x0350\n};\n\nstatic unsigned short g_drwavMulawTable[256] = {\n    0x8284, 0x8684, 0x8A84, 0x8E84, 0x9284, 0x9684, 0x9A84, 0x9E84, 0xA284, 0xA684, 0xAA84, 0xAE84, 0xB284, 0xB684, 0xBA84, 0xBE84, \n    0xC184, 0xC384, 0xC584, 0xC784, 0xC984, 0xCB84, 0xCD84, 0xCF84, 0xD184, 0xD384, 0xD584, 0xD784, 0xD984, 0xDB84, 0xDD84, 0xDF84, \n    0xE104, 0xE204, 0xE304, 0xE404, 0xE504, 0xE604, 0xE704, 0xE804, 0xE904, 0xEA04, 0xEB04, 0xEC04, 0xED04, 0xEE04, 0xEF04, 0xF004, \n    0xF0C4, 0xF144, 0xF1C4, 0xF244, 0xF2C4, 0xF344, 0xF3C4, 0xF444, 0xF4C4, 0xF544, 0xF5C4, 0xF644, 0xF6C4, 0xF744, 0xF7C4, 0xF844, \n    0xF8A4, 0xF8E4, 0xF924, 0xF964, 0xF9A4, 0xF9E4, 0xFA24, 0xFA64, 0xFAA4, 0xFAE4, 0xFB24, 0xFB64, 0xFBA4, 0xFBE4, 0xFC24, 0xFC64, \n    0xFC94, 0xFCB4, 0xFCD4, 0xFCF4, 0xFD14, 0xFD34, 0xFD54, 0xFD74, 0xFD94, 0xFDB4, 0xFDD4, 0xFDF4, 0xFE14, 0xFE34, 0xFE54, 0xFE74, \n    0xFE8C, 0xFE9C, 0xFEAC, 0xFEBC, 0xFECC, 0xFEDC, 0xFEEC, 0xFEFC, 0xFF0C, 0xFF1C, 0xFF2C, 0xFF3C, 0xFF4C, 0xFF5C, 0xFF6C, 0xFF7C, \n    0xFF88, 0xFF90, 0xFF98, 0xFFA0, 0xFFA8, 0xFFB0, 0xFFB8, 0xFFC0, 0xFFC8, 0xFFD0, 0xFFD8, 0xFFE0, 0xFFE8, 0xFFF0, 0xFFF8, 0x0000, \n    0x7D7C, 0x797C, 0x757C, 0x717C, 0x6D7C, 0x697C, 0x657C, 0x617C, 0x5D7C, 0x597C, 0x557C, 0x517C, 0x4D7C, 0x497C, 0x457C, 0x417C, \n    0x3E7C, 0x3C7C, 0x3A7C, 0x387C, 0x367C, 0x347C, 0x327C, 0x307C, 0x2E7C, 0x2C7C, 0x2A7C, 0x287C, 0x267C, 0x247C, 0x227C, 0x207C, \n    0x1EFC, 0x1DFC, 0x1CFC, 0x1BFC, 0x1AFC, 0x19FC, 0x18FC, 0x17FC, 0x16FC, 0x15FC, 0x14FC, 0x13FC, 0x12FC, 0x11FC, 0x10FC, 0x0FFC, \n    0x0F3C, 0x0EBC, 0x0E3C, 0x0DBC, 0x0D3C, 0x0CBC, 0x0C3C, 0x0BBC, 0x0B3C, 0x0ABC, 0x0A3C, 0x09BC, 0x093C, 0x08BC, 0x083C, 0x07BC, \n    0x075C, 0x071C, 0x06DC, 0x069C, 0x065C, 0x061C, 0x05DC, 0x059C, 0x055C, 0x051C, 0x04DC, 0x049C, 0x045C, 0x041C, 0x03DC, 0x039C, \n    0x036C, 0x034C, 0x032C, 0x030C, 0x02EC, 0x02CC, 0x02AC, 0x028C, 0x026C, 0x024C, 0x022C, 0x020C, 0x01EC, 0x01CC, 0x01AC, 0x018C, \n    0x0174, 0x0164, 0x0154, 0x0144, 0x0134, 0x0124, 0x0114, 0x0104, 0x00F4, 0x00E4, 0x00D4, 0x00C4, 0x00B4, 0x00A4, 0x0094, 0x0084, \n    0x0078, 0x0070, 0x0068, 0x0060, 0x0058, 0x0050, 0x0048, 0x0040, 0x0038, 0x0030, 0x0028, 0x0020, 0x0018, 0x0010, 0x0008, 0x0000\n};\n\nstatic DRWAV_INLINE drwav_int16 drwav__alaw_to_s16(drwav_uint8 sampleIn)\n{\n    return (short)g_drwavAlawTable[sampleIn];\n}\n\nstatic DRWAV_INLINE drwav_int16 drwav__mulaw_to_s16(drwav_uint8 sampleIn)\n{\n    return (short)g_drwavMulawTable[sampleIn];\n}\n\n\n\nstatic void drwav__pcm_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)\n{\n    unsigned int i;\n\n    /* Special case for 8-bit sample data because it's treated as unsigned. */\n    if (bytesPerSample == 1) {\n        drwav_u8_to_s16(pOut, pIn, totalSampleCount);\n        return;\n    }\n\n\n    /* Slightly more optimal implementation for common formats. */\n    if (bytesPerSample == 2) {\n        for (i = 0; i < totalSampleCount; ++i) {\n           *pOut++ = ((const drwav_int16*)pIn)[i];\n        }\n        return;\n    }\n    if (bytesPerSample == 3) {\n        drwav_s24_to_s16(pOut, pIn, totalSampleCount);\n        return;\n    }\n    if (bytesPerSample == 4) {\n        drwav_s32_to_s16(pOut, (const drwav_int32*)pIn, totalSampleCount);\n        return;\n    }\n\n\n    /* Anything more than 64 bits per sample is not supported. */\n    if (bytesPerSample > 8) {\n        DRWAV_ZERO_MEMORY(pOut, totalSampleCount * sizeof(*pOut));\n        return;\n    }\n\n\n    /* Generic, slow converter. */\n    for (i = 0; i < totalSampleCount; ++i) {\n        drwav_uint64 sample = 0;\n        unsigned int shift  = (8 - bytesPerSample) * 8;\n\n        unsigned int j;\n        for (j = 0; j < bytesPerSample; j += 1) {\n            DRWAV_ASSERT(j < 8);\n            sample |= (drwav_uint64)(pIn[j]) << shift;\n            shift  += 8;\n        }\n\n        pIn += j;\n        *pOut++ = (drwav_int16)((drwav_int64)sample >> 48);\n    }\n}\n\nstatic void drwav__ieee_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)\n{\n    if (bytesPerSample == 4) {\n        drwav_f32_to_s16(pOut, (const float*)pIn, totalSampleCount);\n        return;\n    } else if (bytesPerSample == 8) {\n        drwav_f64_to_s16(pOut, (const double*)pIn, totalSampleCount);\n        return;\n    } else {\n        /* Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float. */\n        DRWAV_ZERO_MEMORY(pOut, totalSampleCount * sizeof(*pOut));\n        return;\n    }\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s16__pcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint32 bytesPerFrame;\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n\n    /* Fast path. */\n    if ((pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM && pWav->bitsPerSample == 16) || pBufferOut == NULL) {\n        return drwav_read_pcm_frames(pWav, framesToRead, pBufferOut);\n    }\n    \n    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n    \n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav__pcm_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s16__ieee(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n    drwav_uint32 bytesPerFrame;\n\n    if (pBufferOut == NULL) {\n        return drwav_read_pcm_frames(pWav, framesToRead, NULL);\n    }\n\n    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n    \n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav__ieee_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s16__alaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n    drwav_uint32 bytesPerFrame;\n\n    if (pBufferOut == NULL) {\n        return drwav_read_pcm_frames(pWav, framesToRead, NULL);\n    }\n\n    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n    \n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_alaw_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s16__mulaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n    drwav_uint32 bytesPerFrame;\n\n    if (pBufferOut == NULL) {\n        return drwav_read_pcm_frames(pWav, framesToRead, NULL);\n    }\n\n    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_mulaw_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s16(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    if (pWav == NULL || framesToRead == 0) {\n        return 0;\n    }\n\n    if (pBufferOut == NULL) {\n        return drwav_read_pcm_frames(pWav, framesToRead, NULL);\n    }\n\n    /* Don't try to read more samples than can potentially fit in the output buffer. */\n    if (framesToRead * pWav->channels * sizeof(drwav_int16) > DRWAV_SIZE_MAX) {\n        framesToRead = DRWAV_SIZE_MAX / sizeof(drwav_int16) / pWav->channels;\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM) {\n        return drwav_read_pcm_frames_s16__pcm(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_IEEE_FLOAT) {\n        return drwav_read_pcm_frames_s16__ieee(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ALAW) {\n        return drwav_read_pcm_frames_s16__alaw(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_MULAW) {\n        return drwav_read_pcm_frames_s16__mulaw(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n        return drwav_read_pcm_frames_s16__msadpcm(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n        return drwav_read_pcm_frames_s16__ima(pWav, framesToRead, pBufferOut);\n    }\n\n    return 0;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s16le(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, framesToRead, pBufferOut);\n    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_FALSE) {\n        drwav__bswap_samples_s16(pBufferOut, framesRead*pWav->channels);\n    }\n\n    return framesRead;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s16be(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)\n{\n    drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, framesToRead, pBufferOut);\n    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_TRUE) {\n        drwav__bswap_samples_s16(pBufferOut, framesRead*pWav->channels);\n    }\n\n    return framesRead;\n}\n\n\nDRWAV_API void drwav_u8_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    int r;\n    size_t i;\n    for (i = 0; i < sampleCount; ++i) {\n        int x = pIn[i];\n        r = x << 8;\n        r = r - 32768;\n        pOut[i] = (short)r;\n    }\n}\n\nDRWAV_API void drwav_s24_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    int r;\n    size_t i;\n    for (i = 0; i < sampleCount; ++i) {\n        int x = ((int)(((unsigned int)(((const drwav_uint8*)pIn)[i*3+0]) << 8) | ((unsigned int)(((const drwav_uint8*)pIn)[i*3+1]) << 16) | ((unsigned int)(((const drwav_uint8*)pIn)[i*3+2])) << 24)) >> 8;\n        r = x >> 8;\n        pOut[i] = (short)r;\n    }\n}\n\nDRWAV_API void drwav_s32_to_s16(drwav_int16* pOut, const drwav_int32* pIn, size_t sampleCount)\n{\n    int r;\n    size_t i;\n    for (i = 0; i < sampleCount; ++i) {\n        int x = pIn[i];\n        r = x >> 16;\n        pOut[i] = (short)r;\n    }\n}\n\nDRWAV_API void drwav_f32_to_s16(drwav_int16* pOut, const float* pIn, size_t sampleCount)\n{\n    int r;\n    size_t i;\n    for (i = 0; i < sampleCount; ++i) {\n        float x = pIn[i];\n        float c;\n        c = ((x < -1) ? -1 : ((x > 1) ? 1 : x));\n        c = c + 1;\n        r = (int)(c * 32767.5f);\n        r = r - 32768;\n        pOut[i] = (short)r;\n    }\n}\n\nDRWAV_API void drwav_f64_to_s16(drwav_int16* pOut, const double* pIn, size_t sampleCount)\n{\n    int r;\n    size_t i;\n    for (i = 0; i < sampleCount; ++i) {\n        double x = pIn[i];\n        double c;\n        c = ((x < -1) ? -1 : ((x > 1) ? 1 : x));\n        c = c + 1;\n        r = (int)(c * 32767.5);\n        r = r - 32768;\n        pOut[i] = (short)r;\n    }\n}\n\nDRWAV_API void drwav_alaw_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n    for (i = 0; i < sampleCount; ++i) {\n        pOut[i] = drwav__alaw_to_s16(pIn[i]);\n    }\n}\n\nDRWAV_API void drwav_mulaw_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n    for (i = 0; i < sampleCount; ++i) {\n        pOut[i] = drwav__mulaw_to_s16(pIn[i]);\n    }\n}\n\n\n\nstatic void drwav__pcm_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount, unsigned int bytesPerSample)\n{\n    unsigned int i;\n\n    /* Special case for 8-bit sample data because it's treated as unsigned. */\n    if (bytesPerSample == 1) {\n        drwav_u8_to_f32(pOut, pIn, sampleCount);\n        return;\n    }\n\n    /* Slightly more optimal implementation for common formats. */\n    if (bytesPerSample == 2) {\n        drwav_s16_to_f32(pOut, (const drwav_int16*)pIn, sampleCount);\n        return;\n    }\n    if (bytesPerSample == 3) {\n        drwav_s24_to_f32(pOut, pIn, sampleCount);\n        return;\n    }\n    if (bytesPerSample == 4) {\n        drwav_s32_to_f32(pOut, (const drwav_int32*)pIn, sampleCount);\n        return;\n    }\n\n\n    /* Anything more than 64 bits per sample is not supported. */\n    if (bytesPerSample > 8) {\n        DRWAV_ZERO_MEMORY(pOut, sampleCount * sizeof(*pOut));\n        return;\n    }\n\n\n    /* Generic, slow converter. */\n    for (i = 0; i < sampleCount; ++i) {\n        drwav_uint64 sample = 0;\n        unsigned int shift  = (8 - bytesPerSample) * 8;\n\n        unsigned int j;\n        for (j = 0; j < bytesPerSample; j += 1) {\n            DRWAV_ASSERT(j < 8);\n            sample |= (drwav_uint64)(pIn[j]) << shift;\n            shift  += 8;\n        }\n\n        pIn += j;\n        *pOut++ = (float)((drwav_int64)sample / 9223372036854775807.0);\n    }\n}\n\nstatic void drwav__ieee_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount, unsigned int bytesPerSample)\n{\n    if (bytesPerSample == 4) {\n        unsigned int i;\n        for (i = 0; i < sampleCount; ++i) {\n            *pOut++ = ((const float*)pIn)[i];\n        }\n        return;\n    } else if (bytesPerSample == 8) {\n        drwav_f64_to_f32(pOut, (const double*)pIn, sampleCount);\n        return;\n    } else {\n        /* Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float. */\n        DRWAV_ZERO_MEMORY(pOut, sampleCount * sizeof(*pOut));\n        return;\n    }\n}\n\n\nstatic drwav_uint64 drwav_read_pcm_frames_f32__pcm(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n\n    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav__pcm_to_f32(pBufferOut, sampleData, (size_t)framesRead*pWav->channels, bytesPerFrame/pWav->channels);\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_f32__msadpcm(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    /*\n    We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't\n    want to duplicate that code.\n    */\n    drwav_uint64 totalFramesRead = 0;\n    drwav_int16 samples16[2048];\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_s16_to_f32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_f32__ima(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    /*\n    We're just going to borrow the implementation from the drwav_read_s16() since IMA-ADPCM is a little bit more complicated than other formats and I don't\n    want to duplicate that code.\n    */\n    drwav_uint64 totalFramesRead = 0;\n    drwav_int16 samples16[2048];\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_s16_to_f32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_f32__ieee(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n    drwav_uint32 bytesPerFrame;\n\n    /* Fast path. */\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_IEEE_FLOAT && pWav->bitsPerSample == 32) {\n        return drwav_read_pcm_frames(pWav, framesToRead, pBufferOut);\n    }\n    \n    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav__ieee_to_f32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_f32__alaw(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_alaw_to_f32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_f32__mulaw(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n\n    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_mulaw_to_f32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_f32(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    if (pWav == NULL || framesToRead == 0) {\n        return 0;\n    }\n\n    if (pBufferOut == NULL) {\n        return drwav_read_pcm_frames(pWav, framesToRead, NULL);\n    }\n\n    /* Don't try to read more samples than can potentially fit in the output buffer. */\n    if (framesToRead * pWav->channels * sizeof(float) > DRWAV_SIZE_MAX) {\n        framesToRead = DRWAV_SIZE_MAX / sizeof(float) / pWav->channels;\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM) {\n        return drwav_read_pcm_frames_f32__pcm(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n        return drwav_read_pcm_frames_f32__msadpcm(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_IEEE_FLOAT) {\n        return drwav_read_pcm_frames_f32__ieee(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ALAW) {\n        return drwav_read_pcm_frames_f32__alaw(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_MULAW) {\n        return drwav_read_pcm_frames_f32__mulaw(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n        return drwav_read_pcm_frames_f32__ima(pWav, framesToRead, pBufferOut);\n    }\n\n    return 0;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_f32le(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    drwav_uint64 framesRead = drwav_read_pcm_frames_f32(pWav, framesToRead, pBufferOut);\n    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_FALSE) {\n        drwav__bswap_samples_f32(pBufferOut, framesRead*pWav->channels);\n    }\n\n    return framesRead;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_f32be(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)\n{\n    drwav_uint64 framesRead = drwav_read_pcm_frames_f32(pWav, framesToRead, pBufferOut);\n    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_TRUE) {\n        drwav__bswap_samples_f32(pBufferOut, framesRead*pWav->channels);\n    }\n\n    return framesRead;\n}\n\n\nDRWAV_API void drwav_u8_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n#ifdef DR_WAV_LIBSNDFILE_COMPAT\n    /*\n    It appears libsndfile uses slightly different logic for the u8 -> f32 conversion to dr_wav, which in my opinion is incorrect. It appears\n    libsndfile performs the conversion something like \"f32 = (u8 / 256) * 2 - 1\", however I think it should be \"f32 = (u8 / 255) * 2 - 1\" (note\n    the divisor of 256 vs 255). I use libsndfile as a benchmark for testing, so I'm therefore leaving this block here just for my automated\n    correctness testing. This is disabled by default.\n    */\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = (pIn[i] / 256.0f) * 2 - 1;\n    }\n#else\n    for (i = 0; i < sampleCount; ++i) {\n        float x = pIn[i];\n        x = x * 0.00784313725490196078f;    /* 0..255 to 0..2 */\n        x = x - 1;                          /* 0..2 to -1..1 */\n\n        *pOut++ = x;\n    }\n#endif\n}\n\nDRWAV_API void drwav_s16_to_f32(float* pOut, const drwav_int16* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = pIn[i] * 0.000030517578125f;\n    }\n}\n\nDRWAV_API void drwav_s24_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        double x;\n        drwav_uint32 a = ((drwav_uint32)(pIn[i*3+0]) <<  8);\n        drwav_uint32 b = ((drwav_uint32)(pIn[i*3+1]) << 16);\n        drwav_uint32 c = ((drwav_uint32)(pIn[i*3+2]) << 24);\n\n        x = (double)((drwav_int32)(a | b | c) >> 8);\n        *pOut++ = (float)(x * 0.00000011920928955078125);\n    }\n}\n\nDRWAV_API void drwav_s32_to_f32(float* pOut, const drwav_int32* pIn, size_t sampleCount)\n{\n    size_t i;\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = (float)(pIn[i] / 2147483648.0);\n    }\n}\n\nDRWAV_API void drwav_f64_to_f32(float* pOut, const double* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = (float)pIn[i];\n    }\n}\n\nDRWAV_API void drwav_alaw_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = drwav__alaw_to_s16(pIn[i]) / 32768.0f;\n    }\n}\n\nDRWAV_API void drwav_mulaw_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = drwav__mulaw_to_s16(pIn[i]) / 32768.0f;\n    }\n}\n\n\n\nstatic void drwav__pcm_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)\n{\n    unsigned int i;\n\n    /* Special case for 8-bit sample data because it's treated as unsigned. */\n    if (bytesPerSample == 1) {\n        drwav_u8_to_s32(pOut, pIn, totalSampleCount);\n        return;\n    }\n\n    /* Slightly more optimal implementation for common formats. */\n    if (bytesPerSample == 2) {\n        drwav_s16_to_s32(pOut, (const drwav_int16*)pIn, totalSampleCount);\n        return;\n    }\n    if (bytesPerSample == 3) {\n        drwav_s24_to_s32(pOut, pIn, totalSampleCount);\n        return;\n    }\n    if (bytesPerSample == 4) {\n        for (i = 0; i < totalSampleCount; ++i) {\n           *pOut++ = ((const drwav_int32*)pIn)[i];\n        }\n        return;\n    }\n\n\n    /* Anything more than 64 bits per sample is not supported. */\n    if (bytesPerSample > 8) {\n        DRWAV_ZERO_MEMORY(pOut, totalSampleCount * sizeof(*pOut));\n        return;\n    }\n\n\n    /* Generic, slow converter. */\n    for (i = 0; i < totalSampleCount; ++i) {\n        drwav_uint64 sample = 0;\n        unsigned int shift  = (8 - bytesPerSample) * 8;\n\n        unsigned int j;\n        for (j = 0; j < bytesPerSample; j += 1) {\n            DRWAV_ASSERT(j < 8);\n            sample |= (drwav_uint64)(pIn[j]) << shift;\n            shift  += 8;\n        }\n\n        pIn += j;\n        *pOut++ = (drwav_int32)((drwav_int64)sample >> 32);\n    }\n}\n\nstatic void drwav__ieee_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)\n{\n    if (bytesPerSample == 4) {\n        drwav_f32_to_s32(pOut, (const float*)pIn, totalSampleCount);\n        return;\n    } else if (bytesPerSample == 8) {\n        drwav_f64_to_s32(pOut, (const double*)pIn, totalSampleCount);\n        return;\n    } else {\n        /* Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float. */\n        DRWAV_ZERO_MEMORY(pOut, totalSampleCount * sizeof(*pOut));\n        return;\n    }\n}\n\n\nstatic drwav_uint64 drwav_read_pcm_frames_s32__pcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n    drwav_uint32 bytesPerFrame;\n\n    /* Fast path. */\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM && pWav->bitsPerSample == 32) {\n        return drwav_read_pcm_frames(pWav, framesToRead, pBufferOut);\n    }\n    \n    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav__pcm_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s32__msadpcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    /*\n    We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't\n    want to duplicate that code.\n    */\n    drwav_uint64 totalFramesRead = 0;\n    drwav_int16 samples16[2048];\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_s16_to_s32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s32__ima(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    /*\n    We're just going to borrow the implementation from the drwav_read_s16() since IMA-ADPCM is a little bit more complicated than other formats and I don't\n    want to duplicate that code.\n    */\n    drwav_uint64 totalFramesRead = 0;\n    drwav_int16 samples16[2048];\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_s16_to_s32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s32__ieee(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n\n    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav__ieee_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s32__alaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n\n    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_alaw_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nstatic drwav_uint64 drwav_read_pcm_frames_s32__mulaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    drwav_uint64 totalFramesRead;\n    drwav_uint8 sampleData[4096];\n\n    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);\n    if (bytesPerFrame == 0) {\n        return 0;\n    }\n\n    totalFramesRead = 0;\n\n    while (framesToRead > 0) {\n        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);\n        if (framesRead == 0) {\n            break;\n        }\n\n        drwav_mulaw_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));\n\n        pBufferOut      += framesRead*pWav->channels;\n        framesToRead    -= framesRead;\n        totalFramesRead += framesRead;\n    }\n\n    return totalFramesRead;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s32(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    if (pWav == NULL || framesToRead == 0) {\n        return 0;\n    }\n\n    if (pBufferOut == NULL) {\n        return drwav_read_pcm_frames(pWav, framesToRead, NULL);\n    }\n\n    /* Don't try to read more samples than can potentially fit in the output buffer. */\n    if (framesToRead * pWav->channels * sizeof(drwav_int32) > DRWAV_SIZE_MAX) {\n        framesToRead = DRWAV_SIZE_MAX / sizeof(drwav_int32) / pWav->channels;\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM) {\n        return drwav_read_pcm_frames_s32__pcm(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {\n        return drwav_read_pcm_frames_s32__msadpcm(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_IEEE_FLOAT) {\n        return drwav_read_pcm_frames_s32__ieee(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ALAW) {\n        return drwav_read_pcm_frames_s32__alaw(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_MULAW) {\n        return drwav_read_pcm_frames_s32__mulaw(pWav, framesToRead, pBufferOut);\n    }\n\n    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {\n        return drwav_read_pcm_frames_s32__ima(pWav, framesToRead, pBufferOut);\n    }\n\n    return 0;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s32le(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    drwav_uint64 framesRead = drwav_read_pcm_frames_s32(pWav, framesToRead, pBufferOut);\n    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_FALSE) {\n        drwav__bswap_samples_s32(pBufferOut, framesRead*pWav->channels);\n    }\n\n    return framesRead;\n}\n\nDRWAV_API drwav_uint64 drwav_read_pcm_frames_s32be(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)\n{\n    drwav_uint64 framesRead = drwav_read_pcm_frames_s32(pWav, framesToRead, pBufferOut);\n    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_TRUE) {\n        drwav__bswap_samples_s32(pBufferOut, framesRead*pWav->channels);\n    }\n\n    return framesRead;\n}\n\n\nDRWAV_API void drwav_u8_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = ((int)pIn[i] - 128) << 24;\n    }\n}\n\nDRWAV_API void drwav_s16_to_s32(drwav_int32* pOut, const drwav_int16* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = pIn[i] << 16;\n    }\n}\n\nDRWAV_API void drwav_s24_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        unsigned int s0 = pIn[i*3 + 0];\n        unsigned int s1 = pIn[i*3 + 1];\n        unsigned int s2 = pIn[i*3 + 2];\n\n        drwav_int32 sample32 = (drwav_int32)((s0 << 8) | (s1 << 16) | (s2 << 24));\n        *pOut++ = sample32;\n    }\n}\n\nDRWAV_API void drwav_f32_to_s32(drwav_int32* pOut, const float* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = (drwav_int32)(2147483648.0 * pIn[i]);\n    }\n}\n\nDRWAV_API void drwav_f64_to_s32(drwav_int32* pOut, const double* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = (drwav_int32)(2147483648.0 * pIn[i]);\n    }\n}\n\nDRWAV_API void drwav_alaw_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i = 0; i < sampleCount; ++i) {\n        *pOut++ = ((drwav_int32)drwav__alaw_to_s16(pIn[i])) << 16;\n    }\n}\n\nDRWAV_API void drwav_mulaw_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t sampleCount)\n{\n    size_t i;\n\n    if (pOut == NULL || pIn == NULL) {\n        return;\n    }\n\n    for (i= 0; i < sampleCount; ++i) {\n        *pOut++ = ((drwav_int32)drwav__mulaw_to_s16(pIn[i])) << 16;\n    }\n}\n\n\n\nstatic drwav_int16* drwav__read_pcm_frames_and_close_s16(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)\n{\n    drwav_uint64 sampleDataSize;\n    drwav_int16* pSampleData;\n    drwav_uint64 framesRead;\n\n    DRWAV_ASSERT(pWav != NULL);\n\n    sampleDataSize = pWav->totalPCMFrameCount * pWav->channels * sizeof(drwav_int16);\n    if (sampleDataSize > DRWAV_SIZE_MAX) {\n        drwav_uninit(pWav);\n        return NULL;    /* File's too big. */\n    }\n\n    pSampleData = (drwav_int16*)drwav__malloc_from_callbacks((size_t)sampleDataSize, &pWav->allocationCallbacks); /* <-- Safe cast due to the check above. */\n    if (pSampleData == NULL) {\n        drwav_uninit(pWav);\n        return NULL;    /* Failed to allocate memory. */\n    }\n\n    framesRead = drwav_read_pcm_frames_s16(pWav, (size_t)pWav->totalPCMFrameCount, pSampleData);\n    if (framesRead != pWav->totalPCMFrameCount) {\n        drwav__free_from_callbacks(pSampleData, &pWav->allocationCallbacks);\n        drwav_uninit(pWav);\n        return NULL;    /* There was an error reading the samples. */\n    }\n\n    drwav_uninit(pWav);\n\n    if (sampleRate) {\n        *sampleRate = pWav->sampleRate;\n    }\n    if (channels) {\n        *channels = pWav->channels;\n    }\n    if (totalFrameCount) {\n        *totalFrameCount = pWav->totalPCMFrameCount;\n    }\n\n    return pSampleData;\n}\n\nstatic float* drwav__read_pcm_frames_and_close_f32(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)\n{\n    drwav_uint64 sampleDataSize;\n    float* pSampleData;\n    drwav_uint64 framesRead;\n\n    DRWAV_ASSERT(pWav != NULL);\n\n    sampleDataSize = pWav->totalPCMFrameCount * pWav->channels * sizeof(float);\n    if (sampleDataSize > DRWAV_SIZE_MAX) {\n        drwav_uninit(pWav);\n        return NULL;    /* File's too big. */\n    }\n\n    pSampleData = (float*)drwav__malloc_from_callbacks((size_t)sampleDataSize, &pWav->allocationCallbacks); /* <-- Safe cast due to the check above. */\n    if (pSampleData == NULL) {\n        drwav_uninit(pWav);\n        return NULL;    /* Failed to allocate memory. */\n    }\n\n    framesRead = drwav_read_pcm_frames_f32(pWav, (size_t)pWav->totalPCMFrameCount, pSampleData);\n    if (framesRead != pWav->totalPCMFrameCount) {\n        drwav__free_from_callbacks(pSampleData, &pWav->allocationCallbacks);\n        drwav_uninit(pWav);\n        return NULL;    /* There was an error reading the samples. */\n    }\n\n    drwav_uninit(pWav);\n\n    if (sampleRate) {\n        *sampleRate = pWav->sampleRate;\n    }\n    if (channels) {\n        *channels = pWav->channels;\n    }\n    if (totalFrameCount) {\n        *totalFrameCount = pWav->totalPCMFrameCount;\n    }\n\n    return pSampleData;\n}\n\nstatic drwav_int32* drwav__read_pcm_frames_and_close_s32(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)\n{\n    drwav_uint64 sampleDataSize;\n    drwav_int32* pSampleData;\n    drwav_uint64 framesRead;\n\n    DRWAV_ASSERT(pWav != NULL);\n\n    sampleDataSize = pWav->totalPCMFrameCount * pWav->channels * sizeof(drwav_int32);\n    if (sampleDataSize > DRWAV_SIZE_MAX) {\n        drwav_uninit(pWav);\n        return NULL;    /* File's too big. */\n    }\n\n    pSampleData = (drwav_int32*)drwav__malloc_from_callbacks((size_t)sampleDataSize, &pWav->allocationCallbacks); /* <-- Safe cast due to the check above. */\n    if (pSampleData == NULL) {\n        drwav_uninit(pWav);\n        return NULL;    /* Failed to allocate memory. */\n    }\n\n    framesRead = drwav_read_pcm_frames_s32(pWav, (size_t)pWav->totalPCMFrameCount, pSampleData);\n    if (framesRead != pWav->totalPCMFrameCount) {\n        drwav__free_from_callbacks(pSampleData, &pWav->allocationCallbacks);\n        drwav_uninit(pWav);\n        return NULL;    /* There was an error reading the samples. */\n    }\n\n    drwav_uninit(pWav);\n\n    if (sampleRate) {\n        *sampleRate = pWav->sampleRate;\n    }\n    if (channels) {\n        *channels = pWav->channels;\n    }\n    if (totalFrameCount) {\n        *totalFrameCount = pWav->totalPCMFrameCount;\n    }\n\n    return pSampleData;\n}\n\n\n\nDRWAV_API drwav_int16* drwav_open_and_read_pcm_frames_s16(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init(&wav, onRead, onSeek, pUserData, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s16(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API float* drwav_open_and_read_pcm_frames_f32(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init(&wav, onRead, onSeek, pUserData, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_f32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API drwav_int32* drwav_open_and_read_pcm_frames_s32(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init(&wav, onRead, onSeek, pUserData, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\n#ifndef DR_WAV_NO_STDIO\nDRWAV_API drwav_int16* drwav_open_file_and_read_pcm_frames_s16(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_file(&wav, filename, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s16(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API float* drwav_open_file_and_read_pcm_frames_f32(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_file(&wav, filename, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_f32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API drwav_int32* drwav_open_file_and_read_pcm_frames_s32(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_file(&wav, filename, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\n\nDRWAV_API drwav_int16* drwav_open_file_and_read_pcm_frames_s16_w(const wchar_t* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_file_w(&wav, filename, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s16(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API float* drwav_open_file_and_read_pcm_frames_f32_w(const wchar_t* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_file_w(&wav, filename, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_f32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API drwav_int32* drwav_open_file_and_read_pcm_frames_s32_w(const wchar_t* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_file_w(&wav, filename, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n#endif\n\nDRWAV_API drwav_int16* drwav_open_memory_and_read_pcm_frames_s16(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_memory(&wav, data, dataSize, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s16(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API float* drwav_open_memory_and_read_pcm_frames_f32(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_memory(&wav, data, dataSize, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_f32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n\nDRWAV_API drwav_int32* drwav_open_memory_and_read_pcm_frames_s32(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    drwav wav;\n\n    if (channelsOut) {\n        *channelsOut = 0;\n    }\n    if (sampleRateOut) {\n        *sampleRateOut = 0;\n    }\n    if (totalFrameCountOut) {\n        *totalFrameCountOut = 0;\n    }\n\n    if (!drwav_init_memory(&wav, data, dataSize, pAllocationCallbacks)) {\n        return NULL;\n    }\n\n    return drwav__read_pcm_frames_and_close_s32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);\n}\n#endif  /* DR_WAV_NO_CONVERSION_API */\n\n\nDRWAV_API void drwav_free(void* p, const drwav_allocation_callbacks* pAllocationCallbacks)\n{\n    if (pAllocationCallbacks != NULL) {\n        drwav__free_from_callbacks(p, pAllocationCallbacks);\n    } else {\n        drwav__free_default(p, NULL);\n    }\n}\n\nDRWAV_API drwav_uint16 drwav_bytes_to_u16(const drwav_uint8* data)\n{\n    return drwav__bytes_to_u16(data);\n}\n\nDRWAV_API drwav_int16 drwav_bytes_to_s16(const drwav_uint8* data)\n{\n    return drwav__bytes_to_s16(data);\n}\n\nDRWAV_API drwav_uint32 drwav_bytes_to_u32(const drwav_uint8* data)\n{\n    return drwav__bytes_to_u32(data);\n}\n\nDRWAV_API drwav_int32 drwav_bytes_to_s32(const drwav_uint8* data)\n{\n    return drwav__bytes_to_s32(data);\n}\n\nDRWAV_API drwav_uint64 drwav_bytes_to_u64(const drwav_uint8* data)\n{\n    return drwav__bytes_to_u64(data);\n}\n\nDRWAV_API drwav_int64 drwav_bytes_to_s64(const drwav_uint8* data)\n{\n    return drwav__bytes_to_s64(data);\n}\n\n\nDRWAV_API drwav_bool32 drwav_guid_equal(const drwav_uint8 a[16], const drwav_uint8 b[16])\n{\n    return drwav__guid_equal(a, b);\n}\n\nDRWAV_API drwav_bool32 drwav_fourcc_equal(const drwav_uint8* a, const char* b)\n{\n    return drwav__fourcc_equal(a, b);\n}\n\n#endif  /* dr_wav_c */\n#endif  /* DR_WAV_IMPLEMENTATION */\n\n/*\nRELEASE NOTES - v0.11.0\n=======================\nVersion 0.11.0 has breaking API changes.\n\nImproved Client-Defined Memory Allocation\n-----------------------------------------\nThe main change with this release is the addition of a more flexible way of implementing custom memory allocation routines. The\nexisting system of DRWAV_MALLOC, DRWAV_REALLOC and DRWAV_FREE are still in place and will be used by default when no custom\nallocation callbacks are specified.\n\nTo use the new system, you pass in a pointer to a drwav_allocation_callbacks object to drwav_init() and family, like this:\n\n    void* my_malloc(size_t sz, void* pUserData)\n    {\n        return malloc(sz);\n    }\n    void* my_realloc(void* p, size_t sz, void* pUserData)\n    {\n        return realloc(p, sz);\n    }\n    void my_free(void* p, void* pUserData)\n    {\n        free(p);\n    }\n\n    ...\n\n    drwav_allocation_callbacks allocationCallbacks;\n    allocationCallbacks.pUserData = &myData;\n    allocationCallbacks.onMalloc  = my_malloc;\n    allocationCallbacks.onRealloc = my_realloc;\n    allocationCallbacks.onFree    = my_free;\n    drwav_init_file(&wav, \"my_file.wav\", &allocationCallbacks);\n\nThe advantage of this new system is that it allows you to specify user data which will be passed in to the allocation routines.\n\nPassing in null for the allocation callbacks object will cause dr_wav to use defaults which is the same as DRWAV_MALLOC,\nDRWAV_REALLOC and DRWAV_FREE and the equivalent of how it worked in previous versions.\n\nEvery API that opens a drwav object now takes this extra parameter. These include the following:\n\n    drwav_init()\n    drwav_init_ex()\n    drwav_init_file()\n    drwav_init_file_ex()\n    drwav_init_file_w()\n    drwav_init_file_w_ex()\n    drwav_init_memory()\n    drwav_init_memory_ex()\n    drwav_init_write()\n    drwav_init_write_sequential()\n    drwav_init_write_sequential_pcm_frames()\n    drwav_init_file_write()\n    drwav_init_file_write_sequential()\n    drwav_init_file_write_sequential_pcm_frames()\n    drwav_init_file_write_w()\n    drwav_init_file_write_sequential_w()\n    drwav_init_file_write_sequential_pcm_frames_w()\n    drwav_init_memory_write()\n    drwav_init_memory_write_sequential()\n    drwav_init_memory_write_sequential_pcm_frames()\n    drwav_open_and_read_pcm_frames_s16()\n    drwav_open_and_read_pcm_frames_f32()\n    drwav_open_and_read_pcm_frames_s32()\n    drwav_open_file_and_read_pcm_frames_s16()\n    drwav_open_file_and_read_pcm_frames_f32()\n    drwav_open_file_and_read_pcm_frames_s32()\n    drwav_open_file_and_read_pcm_frames_s16_w()\n    drwav_open_file_and_read_pcm_frames_f32_w()\n    drwav_open_file_and_read_pcm_frames_s32_w()\n    drwav_open_memory_and_read_pcm_frames_s16()\n    drwav_open_memory_and_read_pcm_frames_f32()\n    drwav_open_memory_and_read_pcm_frames_s32()\n\nEndian Improvements\n-------------------\nPreviously, the following APIs returned little-endian audio data. These now return native-endian data. This improves compatibility\non big-endian architectures.\n\n    drwav_read_pcm_frames()\n    drwav_read_pcm_frames_s16()\n    drwav_read_pcm_frames_s32()\n    drwav_read_pcm_frames_f32()\n    drwav_open_and_read_pcm_frames_s16()\n    drwav_open_and_read_pcm_frames_s32()\n    drwav_open_and_read_pcm_frames_f32()\n    drwav_open_file_and_read_pcm_frames_s16()\n    drwav_open_file_and_read_pcm_frames_s32()\n    drwav_open_file_and_read_pcm_frames_f32()\n    drwav_open_file_and_read_pcm_frames_s16_w()\n    drwav_open_file_and_read_pcm_frames_s32_w()\n    drwav_open_file_and_read_pcm_frames_f32_w()\n    drwav_open_memory_and_read_pcm_frames_s16()\n    drwav_open_memory_and_read_pcm_frames_s32()\n    drwav_open_memory_and_read_pcm_frames_f32()\n\nAPIs have been added to give you explicit control over whether or not audio data is read or written in big- or little-endian byte\norder:\n\n    drwav_read_pcm_frames_le()\n    drwav_read_pcm_frames_be()\n    drwav_read_pcm_frames_s16le()\n    drwav_read_pcm_frames_s16be()\n    drwav_read_pcm_frames_f32le()\n    drwav_read_pcm_frames_f32be()\n    drwav_read_pcm_frames_s32le()\n    drwav_read_pcm_frames_s32be()\n    drwav_write_pcm_frames_le()\n    drwav_write_pcm_frames_be()\n\nRemoved APIs\n------------\nThe following APIs were deprecated in version 0.10.0 and have now been removed:\n\n    drwav_open()\n    drwav_open_ex()\n    drwav_open_write()\n    drwav_open_write_sequential()\n    drwav_open_file()\n    drwav_open_file_ex()\n    drwav_open_file_write()\n    drwav_open_file_write_sequential()\n    drwav_open_memory()\n    drwav_open_memory_ex()\n    drwav_open_memory_write()\n    drwav_open_memory_write_sequential()\n    drwav_close()\n\n\n\nRELEASE NOTES - v0.10.0\n=======================\nVersion 0.10.0 has breaking API changes. There are no significant bug fixes in this release, so if you are affected you do\nnot need to upgrade.\n\nRemoved APIs\n------------\nThe following APIs were deprecated in version 0.9.0 and have been completely removed in version 0.10.0:\n\n    drwav_read()\n    drwav_read_s16()\n    drwav_read_f32()\n    drwav_read_s32()\n    drwav_seek_to_sample()\n    drwav_write()\n    drwav_open_and_read_s16()\n    drwav_open_and_read_f32()\n    drwav_open_and_read_s32()\n    drwav_open_file_and_read_s16()\n    drwav_open_file_and_read_f32()\n    drwav_open_file_and_read_s32()\n    drwav_open_memory_and_read_s16()\n    drwav_open_memory_and_read_f32()\n    drwav_open_memory_and_read_s32()\n    drwav::totalSampleCount\n\nSee release notes for version 0.9.0 at the bottom of this file for replacement APIs.\n\nDeprecated APIs\n---------------\nThe following APIs have been deprecated. There is a confusing and completely arbitrary difference between drwav_init*() and\ndrwav_open*(), where drwav_init*() initializes a pre-allocated drwav object, whereas drwav_open*() will first allocated a\ndrwav object on the heap and then initialize it. drwav_open*() has been deprecated which means you must now use a pre-\nallocated drwav object with drwav_init*(). If you need the previous functionality, you can just do a malloc() followed by\na called to one of the drwav_init*() APIs.\n\n    drwav_open()\n    drwav_open_ex()\n    drwav_open_write()\n    drwav_open_write_sequential()\n    drwav_open_file()\n    drwav_open_file_ex()\n    drwav_open_file_write()\n    drwav_open_file_write_sequential()\n    drwav_open_memory()\n    drwav_open_memory_ex()\n    drwav_open_memory_write()\n    drwav_open_memory_write_sequential()\n    drwav_close()\n\nThese APIs will be removed completely in a future version. The rationale for this change is to remove confusion between the\ntwo different ways to initialize a drwav object.\n*/\n\n/*\nREVISION HISTORY\n================\nv0.12.16 - 2020-12-02\n  - Fix a bug when trying to read more bytes than can fit in a size_t.\n\nv0.12.15 - 2020-11-21\n  - Fix compilation with OpenWatcom.\n\nv0.12.14 - 2020-11-13\n  - Minor code clean up.\n\nv0.12.13 - 2020-11-01\n  - Improve compiler support for older versions of GCC.\n\nv0.12.12 - 2020-09-28\n  - Add support for RF64.\n  - Fix a bug in writing mode where the size of the RIFF chunk incorrectly includes the header section.\n\nv0.12.11 - 2020-09-08\n  - Fix a compilation error on older compilers.\n\nv0.12.10 - 2020-08-24\n  - Fix a bug when seeking with ADPCM formats.\n\nv0.12.9 - 2020-08-02\n  - Simplify sized types.\n\nv0.12.8 - 2020-07-25\n  - Fix a compilation warning.\n\nv0.12.7 - 2020-07-15\n  - Fix some bugs on big-endian architectures.\n  - Fix an error in s24 to f32 conversion.\n\nv0.12.6 - 2020-06-23\n  - Change drwav_read_*() to allow NULL to be passed in as the output buffer which is equivalent to a forward seek.\n  - Fix a buffer overflow when trying to decode invalid IMA-ADPCM files.\n  - Add include guard for the implementation section.\n\nv0.12.5 - 2020-05-27\n  - Minor documentation fix.\n\nv0.12.4 - 2020-05-16\n  - Replace assert() with DRWAV_ASSERT().\n  - Add compile-time and run-time version querying.\n    - DRWAV_VERSION_MINOR\n    - DRWAV_VERSION_MAJOR\n    - DRWAV_VERSION_REVISION\n    - DRWAV_VERSION_STRING\n    - drwav_version()\n    - drwav_version_string()\n\nv0.12.3 - 2020-04-30\n  - Fix compilation errors with VC6.\n\nv0.12.2 - 2020-04-21\n  - Fix a bug where drwav_init_file() does not close the file handle after attempting to load an erroneous file.\n\nv0.12.1 - 2020-04-13\n  - Fix some pedantic warnings.\n\nv0.12.0 - 2020-04-04\n  - API CHANGE: Add container and format parameters to the chunk callback.\n  - Minor documentation updates.\n\nv0.11.5 - 2020-03-07\n  - Fix compilation error with Visual Studio .NET 2003.\n\nv0.11.4 - 2020-01-29\n  - Fix some static analysis warnings.\n  - Fix a bug when reading f32 samples from an A-law encoded stream.\n\nv0.11.3 - 2020-01-12\n  - Minor changes to some f32 format conversion routines.\n  - Minor bug fix for ADPCM conversion when end of file is reached.\n\nv0.11.2 - 2019-12-02\n  - Fix a possible crash when using custom memory allocators without a custom realloc() implementation.\n  - Fix an integer overflow bug.\n  - Fix a null pointer dereference bug.\n  - Add limits to sample rate, channels and bits per sample to tighten up some validation.\n\nv0.11.1 - 2019-10-07\n  - Internal code clean up.\n\nv0.11.0 - 2019-10-06\n  - API CHANGE: Add support for user defined memory allocation routines. This system allows the program to specify their own memory allocation\n    routines with a user data pointer for client-specific contextual data. This adds an extra parameter to the end of the following APIs:\n    - drwav_init()\n    - drwav_init_ex()\n    - drwav_init_file()\n    - drwav_init_file_ex()\n    - drwav_init_file_w()\n    - drwav_init_file_w_ex()\n    - drwav_init_memory()\n    - drwav_init_memory_ex()\n    - drwav_init_write()\n    - drwav_init_write_sequential()\n    - drwav_init_write_sequential_pcm_frames()\n    - drwav_init_file_write()\n    - drwav_init_file_write_sequential()\n    - drwav_init_file_write_sequential_pcm_frames()\n    - drwav_init_file_write_w()\n    - drwav_init_file_write_sequential_w()\n    - drwav_init_file_write_sequential_pcm_frames_w()\n    - drwav_init_memory_write()\n    - drwav_init_memory_write_sequential()\n    - drwav_init_memory_write_sequential_pcm_frames()\n    - drwav_open_and_read_pcm_frames_s16()\n    - drwav_open_and_read_pcm_frames_f32()\n    - drwav_open_and_read_pcm_frames_s32()\n    - drwav_open_file_and_read_pcm_frames_s16()\n    - drwav_open_file_and_read_pcm_frames_f32()\n    - drwav_open_file_and_read_pcm_frames_s32()\n    - drwav_open_file_and_read_pcm_frames_s16_w()\n    - drwav_open_file_and_read_pcm_frames_f32_w()\n    - drwav_open_file_and_read_pcm_frames_s32_w()\n    - drwav_open_memory_and_read_pcm_frames_s16()\n    - drwav_open_memory_and_read_pcm_frames_f32()\n    - drwav_open_memory_and_read_pcm_frames_s32()\n    Set this extra parameter to NULL to use defaults which is the same as the previous behaviour. Setting this NULL will use\n    DRWAV_MALLOC, DRWAV_REALLOC and DRWAV_FREE.\n  - Add support for reading and writing PCM frames in an explicit endianness. New APIs:\n    - drwav_read_pcm_frames_le()\n    - drwav_read_pcm_frames_be()\n    - drwav_read_pcm_frames_s16le()\n    - drwav_read_pcm_frames_s16be()\n    - drwav_read_pcm_frames_f32le()\n    - drwav_read_pcm_frames_f32be()\n    - drwav_read_pcm_frames_s32le()\n    - drwav_read_pcm_frames_s32be()\n    - drwav_write_pcm_frames_le()\n    - drwav_write_pcm_frames_be()\n  - Remove deprecated APIs.\n  - API CHANGE: The following APIs now return native-endian data. Previously they returned little-endian data.\n    - drwav_read_pcm_frames()\n    - drwav_read_pcm_frames_s16()\n    - drwav_read_pcm_frames_s32()\n    - drwav_read_pcm_frames_f32()\n    - drwav_open_and_read_pcm_frames_s16()\n    - drwav_open_and_read_pcm_frames_s32()\n    - drwav_open_and_read_pcm_frames_f32()\n    - drwav_open_file_and_read_pcm_frames_s16()\n    - drwav_open_file_and_read_pcm_frames_s32()\n    - drwav_open_file_and_read_pcm_frames_f32()\n    - drwav_open_file_and_read_pcm_frames_s16_w()\n    - drwav_open_file_and_read_pcm_frames_s32_w()\n    - drwav_open_file_and_read_pcm_frames_f32_w()\n    - drwav_open_memory_and_read_pcm_frames_s16()\n    - drwav_open_memory_and_read_pcm_frames_s32()\n    - drwav_open_memory_and_read_pcm_frames_f32()\n\nv0.10.1 - 2019-08-31\n  - Correctly handle partial trailing ADPCM blocks.\n\nv0.10.0 - 2019-08-04\n  - Remove deprecated APIs.\n  - Add wchar_t variants for file loading APIs:\n      drwav_init_file_w()\n      drwav_init_file_ex_w()\n      drwav_init_file_write_w()\n      drwav_init_file_write_sequential_w()\n  - Add drwav_target_write_size_bytes() which calculates the total size in bytes of a WAV file given a format and sample count.\n  - Add APIs for specifying the PCM frame count instead of the sample count when opening in sequential write mode:\n      drwav_init_write_sequential_pcm_frames()\n      drwav_init_file_write_sequential_pcm_frames()\n      drwav_init_file_write_sequential_pcm_frames_w()\n      drwav_init_memory_write_sequential_pcm_frames()\n  - Deprecate drwav_open*() and drwav_close():\n      drwav_open()\n      drwav_open_ex()\n      drwav_open_write()\n      drwav_open_write_sequential()\n      drwav_open_file()\n      drwav_open_file_ex()\n      drwav_open_file_write()\n      drwav_open_file_write_sequential()\n      drwav_open_memory()\n      drwav_open_memory_ex()\n      drwav_open_memory_write()\n      drwav_open_memory_write_sequential()\n      drwav_close()\n  - Minor documentation updates.\n\nv0.9.2 - 2019-05-21\n  - Fix warnings.\n\nv0.9.1 - 2019-05-05\n  - Add support for C89.\n  - Change license to choice of public domain or MIT-0.\n\nv0.9.0 - 2018-12-16\n  - API CHANGE: Add new reading APIs for reading by PCM frames instead of samples. Old APIs have been deprecated and\n    will be removed in v0.10.0. Deprecated APIs and their replacements:\n      drwav_read()                     -> drwav_read_pcm_frames()\n      drwav_read_s16()                 -> drwav_read_pcm_frames_s16()\n      drwav_read_f32()                 -> drwav_read_pcm_frames_f32()\n      drwav_read_s32()                 -> drwav_read_pcm_frames_s32()\n      drwav_seek_to_sample()           -> drwav_seek_to_pcm_frame()\n      drwav_write()                    -> drwav_write_pcm_frames()\n      drwav_open_and_read_s16()        -> drwav_open_and_read_pcm_frames_s16()\n      drwav_open_and_read_f32()        -> drwav_open_and_read_pcm_frames_f32()\n      drwav_open_and_read_s32()        -> drwav_open_and_read_pcm_frames_s32()\n      drwav_open_file_and_read_s16()   -> drwav_open_file_and_read_pcm_frames_s16()\n      drwav_open_file_and_read_f32()   -> drwav_open_file_and_read_pcm_frames_f32()\n      drwav_open_file_and_read_s32()   -> drwav_open_file_and_read_pcm_frames_s32()\n      drwav_open_memory_and_read_s16() -> drwav_open_memory_and_read_pcm_frames_s16()\n      drwav_open_memory_and_read_f32() -> drwav_open_memory_and_read_pcm_frames_f32()\n      drwav_open_memory_and_read_s32() -> drwav_open_memory_and_read_pcm_frames_s32()\n      drwav::totalSampleCount          -> drwav::totalPCMFrameCount\n  - API CHANGE: Rename drwav_open_and_read_file_*() to drwav_open_file_and_read_*().\n  - API CHANGE: Rename drwav_open_and_read_memory_*() to drwav_open_memory_and_read_*().\n  - Add built-in support for smpl chunks.\n  - Add support for firing a callback for each chunk in the file at initialization time.\n    - This is enabled through the drwav_init_ex(), etc. family of APIs.\n  - Handle invalid FMT chunks more robustly.\n\nv0.8.5 - 2018-09-11\n  - Const correctness.\n  - Fix a potential stack overflow.\n\nv0.8.4 - 2018-08-07\n  - Improve 64-bit detection.\n\nv0.8.3 - 2018-08-05\n  - Fix C++ build on older versions of GCC.\n\nv0.8.2 - 2018-08-02\n  - Fix some big-endian bugs.\n\nv0.8.1 - 2018-06-29\n  - Add support for sequential writing APIs.\n  - Disable seeking in write mode.\n  - Fix bugs with Wave64.\n  - Fix typos.\n\nv0.8 - 2018-04-27\n  - Bug fix.\n  - Start using major.minor.revision versioning.\n\nv0.7f - 2018-02-05\n  - Restrict ADPCM formats to a maximum of 2 channels.\n\nv0.7e - 2018-02-02\n  - Fix a crash.\n\nv0.7d - 2018-02-01\n  - Fix a crash.\n\nv0.7c - 2018-02-01\n  - Set drwav.bytesPerSample to 0 for all compressed formats.\n  - Fix a crash when reading 16-bit floating point WAV files. In this case dr_wav will output silence for\n    all format conversion reading APIs (*_s16, *_s32, *_f32 APIs).\n  - Fix some divide-by-zero errors.\n\nv0.7b - 2018-01-22\n  - Fix errors with seeking of compressed formats.\n  - Fix compilation error when DR_WAV_NO_CONVERSION_API\n\nv0.7a - 2017-11-17\n  - Fix some GCC warnings.\n\nv0.7 - 2017-11-04\n  - Add writing APIs.\n\nv0.6 - 2017-08-16\n  - API CHANGE: Rename dr_* types to drwav_*.\n  - Add support for custom implementations of malloc(), realloc(), etc.\n  - Add support for Microsoft ADPCM.\n  - Add support for IMA ADPCM (DVI, format code 0x11).\n  - Optimizations to drwav_read_s16().\n  - Bug fixes.\n\nv0.5g - 2017-07-16\n  - Change underlying type for booleans to unsigned.\n\nv0.5f - 2017-04-04\n  - Fix a minor bug with drwav_open_and_read_s16() and family.\n\nv0.5e - 2016-12-29\n  - Added support for reading samples as signed 16-bit integers. Use the _s16() family of APIs for this.\n  - Minor fixes to documentation.\n\nv0.5d - 2016-12-28\n  - Use drwav_int* and drwav_uint* sized types to improve compiler support.\n\nv0.5c - 2016-11-11\n  - Properly handle JUNK chunks that come before the FMT chunk.\n\nv0.5b - 2016-10-23\n  - A minor change to drwav_bool8 and drwav_bool32 types.\n\nv0.5a - 2016-10-11\n  - Fixed a bug with drwav_open_and_read() and family due to incorrect argument ordering.\n  - Improve A-law and mu-law efficiency.\n\nv0.5 - 2016-09-29\n  - API CHANGE. Swap the order of \"channels\" and \"sampleRate\" parameters in drwav_open_and_read*(). Rationale for this is to\n    keep it consistent with dr_audio and dr_flac.\n\nv0.4b - 2016-09-18\n  - Fixed a typo in documentation.\n\nv0.4a - 2016-09-18\n  - Fixed a typo.\n  - Change date format to ISO 8601 (YYYY-MM-DD)\n\nv0.4 - 2016-07-13\n  - API CHANGE. Make onSeek consistent with dr_flac.\n  - API CHANGE. Rename drwav_seek() to drwav_seek_to_sample() for clarity and consistency with dr_flac.\n  - Added support for Sony Wave64.\n\nv0.3a - 2016-05-28\n  - API CHANGE. Return drwav_bool32 instead of int in onSeek callback.\n  - Fixed a memory leak.\n\nv0.3 - 2016-05-22\n  - Lots of API changes for consistency.\n\nv0.2a - 2016-05-16\n  - Fixed Linux/GCC build.\n\nv0.2 - 2016-05-11\n  - Added support for reading data as signed 32-bit PCM for consistency with dr_flac.\n\nv0.1a - 2016-05-07\n  - Fixed a bug in drwav_open_file() where the file handle would not be closed if the loader failed to initialize.\n\nv0.1 - 2016-05-04\n  - Initial versioned release.\n*/\n\n/*\nThis software is available as a choice of the following licenses. Choose\nwhichever you prefer.\n\n===============================================================================\nALTERNATIVE 1 - Public Domain (www.unlicense.org)\n===============================================================================\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n\n===============================================================================\nALTERNATIVE 2 - MIT No Attribution\n===============================================================================\nCopyright 2020 David Reid\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n"
        },
        {
          "name": "generate-clusters.cpp",
          "type": "blob",
          "size": 2.548828125,
          "content": "/*! \\file generate-clusters.cpp\n *  \\brief Generate clusters given a similarity matrix using metropolis-hastings algorithm\n *  \\author Georgi Gerganov\n */\n\n#include \"subbreak2.h\"\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s n-gram.txt\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    //srand(time(0));\n\n    Cipher::TFreqMap freqMap;\n    if (Cipher::loadFreqMap(argv[1], freqMap) == false) {\n        return -1;\n    }\n\n    std::string plain;\n\n    plain = R\"(\nas far as services go, only two steady contributors of revenue\nstreams keep swelling without apple having to charge\nsubscription fees. one is the money paid by google parent alphabet\nfor searches made through apple products such as the safari browser and siri.\n    )\";\n\n    Cipher::TParameters params;\n    TSimilarityMap ccMap;\n\n    Cipher::generateSimilarityMap(params, plain, ccMap);\n\n    TSimilarityMap logMap;\n    TSimilarityMap logMapInv;\n    Cipher::normalizeSimilarityMap(params, ccMap, logMap, logMapInv);\n\n    Cipher::TResult result;\n    Cipher::generateClustersInitialGuess(params, ccMap, result.clusters);\n\n    auto pCur = Cipher::calcPClusters(params, ccMap, logMap, logMapInv, result.clusters, result.clMap);\n    while (true) {\n        auto clustersNew = result.clusters;\n        Cipher::mutateClusters(params, clustersNew);\n        auto pNew = Cipher::calcPClusters(params, ccMap, logMap, logMapInv, clustersNew, result.clMap);\n\n        //printf(\"pNew = %g, pCur = %g\\n\", pNew, pCur);\n\n        auto u = frand();\n        //auto alpha = pNew/pCur;\n        auto alpha = std::exp((pNew - pCur));\n\n        //printf(\"alpha = %g\\n\", alpha);\n\n        if (u <= alpha) {\n            result.clusters = clustersNew;\n            pCur = pNew;\n\n            int n = plain.size();\n            int nMatch = 0;\n            for (int j = 0; j < n - 1; ++j) {\n                for (int i = j + 1; i < n; ++i) {\n                    if ((plain[i] == plain[j] && result.clusters[i] == result.clusters[j]) ||\n                        (plain[i] != plain[j] && result.clusters[i] != result.clusters[j])) {\n                        ++nMatch;\n                    }\n                }\n            }\n\n            float pMatch = float(nMatch)/((n*(n-1))/2);\n\n            printf(\"pCur = %g, pMatch = %g, alpha = %g\\n\", pCur, pMatch, alpha);\n\n            static int cnt = 99;\n            if (++cnt >= 100 && pMatch > 0.94) {\n                cnt = 0;\n                params.nSubbreakIterations = 1000;\n                TClusterToLetterMap clMap;\n                Cipher::subbreak(params, freqMap, result);\n            }\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "guess-qp.cpp",
          "type": "blob",
          "size": 16.2470703125,
          "content": "/*! \\file guess-qp.cpp\n *  \\brief Basic tool to attempt to recognize the 'q' and 'p' keys\n *  \\author Georgi Gerganov\n */\n\n#ifdef __EMSCRIPTEN__\n#include \"build_timestamp.h\"\n#include \"emscripten/emscripten.h\"\n#endif\n\n#include \"constants.h\"\n#include \"audio-logger.h\"\n\n#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include <map>\n#include <cmath>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <vector>\n\nstatic int g_predictedKey = -1;\nstatic bool g_isInitialized = false;\n\nstatic std::function<int()> g_init;\nstatic std::function<void()> g_update;\nstatic std::function<void(int)> g_handleKey;\n\nint init() {\n    if (g_isInitialized) return 1;\n\n    return g_init();\n}\n\nvoid update() {\n    if (g_isInitialized == false) return;\n\n    g_update();\n}\n\n// JS interface\nextern \"C\" {\n    int doInit() {\n        return init();\n    }\n\n    void keyPressedCallback(int key) {\n        g_handleKey(key);\n    }\n\n    int getPredictedKey() {\n        return g_predictedKey;\n    }\n}\n\nint main(int, char**) {\n#ifdef __EMSCRIPTEN__\n    constexpr float kBufferSize_s = 1.0f;\n    constexpr uint64_t kSampleRate = 12000;\n#else\n    constexpr float kBufferSize_s = 0.1f;\n    constexpr uint64_t kSampleRate = 48000;\n#endif\n\n    constexpr uint64_t kBufferSize_frames = getBufferSize_frames(kSampleRate, kBufferSize_s);\n\n    using ValueCC = float;\n    using Offset = int;\n\n    using TKey = int;\n    using TKeyWaveform = std::array<AudioLogger::Frame, kBufferSize_frames>;\n    using TKeyHistory = std::vector<TKeyWaveform>;\n\n    TKey keyPressed = -1;\n    std::map<TKey, TKeyHistory> keySoundHistoryAmpl;\n    std::map<TKey, TKeyWaveform> keySoundAverageAmpl;\n\n    int timesToPressQ = 5;\n    int timesToPressP = 5;\n\n    bool printStatus = true;\n    bool isReadyToPredict = false;\n\n    AudioLogger audioLogger;\n\n    auto calcCC = [](const TKeyWaveform & waveform0, const TKeyWaveform & waveform1, int nSamplesPerFrame, int scmp0, int scmp1, int alignWindow) {\n        Offset besto = -1;\n        ValueCC bestcc = 0.0f;\n\n        for (int o = -alignWindow; o < alignWindow; ++o) {\n            float cc = 0.0f;\n\n            float sum0 = 0.0f, sum02 = 0.0f, sum1 = 0.0f, sum12 = 0.0f, sum01 = 0.0f;\n            for (int is = scmp0; is < scmp1; ++is) {\n                int is0 = is;\n                int f0 = is0/nSamplesPerFrame;\n                int s0 = is0 - f0*nSamplesPerFrame;\n\n                int is1 = is + o;\n                int f1 = is1/nSamplesPerFrame;\n                int s1 = is1 - f1*nSamplesPerFrame;\n\n                auto a0 = waveform0[f0][s0];\n                sum0 += a0;\n                sum02 += a0*a0;\n\n                auto a1 = waveform1[f1][s1];\n                sum1 += a1;\n                sum12 += a1*a1;\n\n                sum01 += a0*a1;\n            }\n\n            int ncc = scmp1 - scmp0;\n            {\n                float nom = sum01*ncc - sum0*sum1;\n                float den2a = sum02*ncc - sum0*sum0;\n                float den2b = sum12*ncc - sum1*sum1;\n                cc = (nom)/(sqrt(den2a*den2b));\n            }\n\n            if (cc > bestcc) {\n                besto = o;\n                bestcc = cc;\n            }\n        }\n\n        return std::tuple<ValueCC, Offset>{ bestcc, besto };\n    };\n\n    AudioLogger::Callback cbAudio = [&](const AudioLogger::Record & frames) {\n        if (frames.size() != keySoundAverageAmpl[keyPressed].size()) {\n            printf(\"Unexpected number of frames - %d, expected - %d. Should never happen\\n\",\n                   (int) frames.size(), (int) keySoundAverageAmpl[keyPressed].size());\n            return;\n        }\n\n        const int nFrames = frames.size();\n\n        if (isReadyToPredict) {\n            TKeyWaveform ampl;\n            for (int k = 0; k < nFrames; ++k) {\n                ampl[k] = frames[k];\n            }\n\n            int nFramesPerWaveform = ampl.size();\n            int nSamplesPerFrame = kSamplesPerFrame;\n            int centerSample = nFramesPerWaveform*nSamplesPerFrame/2;\n            int alignWindow = centerSample/2;\n\n            int scmp0 = centerSample - nSamplesPerFrame/4;\n            int scmp1 = centerSample + nSamplesPerFrame/4;\n\n            auto resq = calcCC(keySoundAverageAmpl['q'], ampl, nSamplesPerFrame, scmp0, scmp1, alignWindow);\n            auto resp = calcCC(keySoundAverageAmpl['p'], ampl, nSamplesPerFrame, scmp0, scmp1, alignWindow);\n\n            char res = resq > resp ? 'q' : 'p';\n\n            printf(\"    Prediction: '%c'        ('q' %8.5g vs %8.5g 'p')    (offsets    %5d %5d)\\n\",\n                   res, std::get<0>(resq), std::get<0>(resp), std::get<1>(resq), std::get<1>(resp));\n\n            g_predictedKey = res;\n        } else {\n            auto & history = keySoundHistoryAmpl[keyPressed];\n            history.push_back(TKeyWaveform());\n            auto & ampl = history.back();\n            for (int k = 0; k < nFrames; ++k) {\n                ampl[k] = frames[k];\n            }\n\n            if (keyPressed == 'q' && timesToPressQ > 0) {\n                --timesToPressQ;\n                printStatus = true;\n            } else if (keyPressed == 'p' && timesToPressP > 0) {\n                --timesToPressP;\n                printStatus = true;\n            }\n        }\n\n        keyPressed = -1;\n    };\n\n    g_init = [&]() {\n        AudioLogger::Parameters parameters;\n        parameters.callback = std::move(cbAudio);\n        parameters.captureId = 0;\n        parameters.nChannels = 1;\n        parameters.sampleRate = kSampleRate;\n        parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n        if (audioLogger.install(std::move(parameters)) == false) {\n            fprintf(stderr, \"Failed to install audio logger\\n\");\n            return -1;\n        }\n\n        printf(\"[+] Collecting training data\\n\");\n        g_isInitialized = true;\n        return 0;\n    };\n\n    g_handleKey = [&](int key) {\n        if (keyPressed == -1) {\n            g_predictedKey = -1;\n            keyPressed = key;\n            audioLogger.record(kBufferSize_s, 3);\n        }\n    };\n\n#ifdef __EMSCRIPTEN__\n#else\n    std::thread keyReader = std::thread([&]() {\n        struct termios oldt, newt;\n        tcgetattr ( STDIN_FILENO, &oldt );\n        newt = oldt;\n        newt.c_lflag &= ~( ICANON | ECHO );\n        tcsetattr ( STDIN_FILENO, TCSANOW, &newt );\n        while (true) {\n            int key = getchar();\n            g_handleKey(key);\n        }\n        tcsetattr ( STDIN_FILENO, TCSANOW, &oldt );\n    });\n#endif\n\n    g_update = [&]() {\n        if (timesToPressQ > 0 || timesToPressP > 0) {\n            if (printStatus) {\n                if (timesToPressQ > 0) {\n                    printf(\"    - press the letter 'q' %d more times\\n\", timesToPressQ);\n                } else if (timesToPressP > 0) {\n                    printf(\"    - press the letter 'p' %d more times\\n\", timesToPressP);\n                }\n                printStatus = false;\n            }\n\n            return;\n        }\n\n        if (isReadyToPredict == false) {\n            printf(\"[+] Training\\n\");\n\n            auto trainKey = [&](TKey key) {\n                auto & history = keySoundHistoryAmpl[key];\n\n                int nWaveforms = history.size();\n                int nFramesPerWaveform = history[0].size();\n                int nSamplesPerFrame = kSamplesPerFrame;\n\n                printf(\"    - Training key '%c'\\n\", key);\n                printf(\"    - History size = %d key waveforms\\n\", nWaveforms);\n                printf(\"    - Frames per key waveform   = %d\\n\", nFramesPerWaveform);\n                printf(\"    - Total frames available    = %d\\n\", nWaveforms*nFramesPerWaveform);\n                printf(\"    - Samples per frame         = %d\\n\", nSamplesPerFrame);\n                printf(\"    - Total samples available   = %d\\n\", nWaveforms*nFramesPerWaveform*nSamplesPerFrame);\n\n                printf(\"    - Estimating waveform peaks ...\\n\");\n                std::vector<int> peakSum;\n                std::vector<int> peakMax;\n\n                peakSum.clear();\n                peakMax.clear();\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int isum = -1;\n                    float asum = 0.0f;\n                    float aisum = 0.0f;\n\n                    int imax = -1;\n                    float amax = 0.0f;\n\n                    const auto & waveform = history[iwaveform];\n\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            int icur = iframe*nSamplesPerFrame + isample;\n                            float acur = std::abs(waveform[iframe][isample]);\n                            float acur2 = acur*acur;\n\n                            asum += acur2;\n                            aisum += acur2*icur;\n\n                            if (acur > amax) {\n                                amax = acur;\n                                imax = icur;\n                            }\n                        }\n                    }\n\n                    isum = aisum/asum;\n\n                    peakSum.push_back(isum);\n                    peakMax.push_back(imax);\n                    printf(\"        Estimated peak: %d (method - sum), %d (method - max)\\n\", isum, imax);\n                }\n\n                auto calcStdev = [](const std::vector<int> & data) {\n                    float sum = 0.0f;\n                    float sum2 = 0.0f;\n                    for (const auto & p : data) {\n                        sum += p;\n                        sum2 += p*p;\n                    }\n                    sum /= data.size();\n                    sum2 /= data.size();\n                    return sqrt(sum2 - sum*sum);\n                };\n\n                float stdevSum = calcStdev(peakSum);\n                float stdevMax = calcStdev(peakMax);\n\n                printf(\"    - Stdev of estimated peaks: %g (sum) vs %g (max)\\n\", stdevSum, stdevMax);\n\n                const auto & peakUsed = peakMax;\n                printf(\"    - Using 'max' estimation\\n\");\n\n                int centerSample = nFramesPerWaveform*nSamplesPerFrame/2;\n\n                printf(\"    - Centering waveforms at sample %d\\n\", centerSample);\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int offset = peakUsed[iwaveform] - centerSample;\n                    printf(\"        Offset for waveform %d = %d\\n\", iwaveform, offset);\n\n                    auto newWaveform = TKeyWaveform();\n                    auto & waveform = history[iwaveform];\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            int icur = iframe*nSamplesPerFrame + isample;\n                            int iorg = icur + offset;\n\n                            if (iorg >= 0 && iorg < nFramesPerWaveform*nSamplesPerFrame) {\n                                int f = iorg/nSamplesPerFrame;\n                                int s = iorg - f*nSamplesPerFrame;\n                                newWaveform[iframe][isample] = waveform[f][s];\n                            } else {\n                                newWaveform[iframe][isample] = 0.0f;\n                            }\n                        }\n                    }\n\n                    waveform = std::move(newWaveform);\n                }\n\n                int alignToWaveform = nWaveforms/2;\n                int alignWindow = centerSample/2;\n                printf(\"    - Aligning all waveforms to waveform %d using cross correlation\\n\", alignToWaveform);\n                printf(\"      Align window = %d\\n\", alignWindow);\n\n                int scmp0 = centerSample - nSamplesPerFrame/4;\n                int scmp1 = centerSample + nSamplesPerFrame/4;\n\n                float sum0 = 0.0f;\n                float sum02 = 0.0f;\n\n                const auto & waveform0 = history[alignToWaveform];\n\n                for (int is = scmp0; is < scmp1; ++is) {\n                    int f = is/nSamplesPerFrame;\n                    int s = is - f*nSamplesPerFrame;\n\n                    auto a = waveform0[f][s];\n                    sum0 += a;\n                    sum02 += a*a;\n                }\n\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    if (iwaveform == alignToWaveform) continue;\n\n                    auto & waveform1 = history[iwaveform];\n\n                    int besto = 0;\n                    float bestcc = 0.0f;\n\n                    for (int o = -alignWindow; o < alignWindow; ++o) {\n                        float cc = 0.0f;\n\n                        float sum1 = 0.0f, sum12 = 0.0f, sum01 = 0.0f;\n                        for (int is = scmp0; is < scmp1; ++is) {\n                            int is1 = is + o;\n                            int f1 = is1/nSamplesPerFrame;\n                            int s1 = is1 - f1*nSamplesPerFrame;\n\n                            auto a1 = waveform1[f1][s1];\n                            sum1 += a1;\n                            sum12 += a1*a1;\n\n                            int is0 = is;\n                            int f0 = is0/nSamplesPerFrame;\n                            int s0 = is0 - f0*nSamplesPerFrame;\n\n                            auto a0 = waveform0[f0][s0];\n                            sum01 += a0*a1;\n                        }\n\n                        int ncc = scmp1 - scmp0;\n                        {\n                            float nom = sum01*ncc - sum0*sum1;\n                            float den2a = sum02*ncc - sum0*sum0;\n                            float den2b = sum12*ncc - sum1*sum1;\n                            cc = (nom)/(sqrt(den2a*den2b));\n                        }\n\n                        if (cc > bestcc) {\n                            besto = o;\n                            bestcc = cc;\n                        }\n                    }\n\n                    printf(\"        Best offset for waveform %d = %d (cc = %g)\\n\", iwaveform, besto, bestcc);\n\n                    auto newWaveform = TKeyWaveform();\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            int icur = iframe*nSamplesPerFrame + isample;\n                            int iorg = icur + besto;\n\n                            if (iorg >= 0 && iorg < nFramesPerWaveform*nSamplesPerFrame) {\n                                int f = iorg/nSamplesPerFrame;\n                                int s = iorg - f*nSamplesPerFrame;\n                                newWaveform[iframe][isample] = waveform1[f][s];\n                            } else {\n                                newWaveform[iframe][isample] = 0.0f;\n                            }\n                        }\n                    }\n\n                    waveform1 = std::move(newWaveform);\n                }\n\n                printf(\"    - Calculating average waveform\\n\");\n                auto & avgWaveform = keySoundAverageAmpl[key];\n                for (auto & f : avgWaveform) f.fill(0.0f);\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    auto & waveform = history[iwaveform];\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            avgWaveform[iframe][isample] += waveform[iframe][isample];\n                        }\n                    }\n                }\n\n                {\n                    float norm = 1.0f/(nFramesPerWaveform*nSamplesPerFrame);\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            avgWaveform[iframe][isample] *= norm;\n                        }\n                    }\n                }\n\n                printf(\"\\n\");\n            };\n\n            trainKey('q');\n            trainKey('p');\n            isReadyToPredict = true;\n\n            printf(\"[+] Ready to predict. Keep pressing 'q' or 'p' and the program will guess which key was pressed\\n\");\n            printf(\"    based on the captured audio from the microphone.\\n\");\n            printf(\"[+] Predicting\\n\");\n        }\n    };\n\n#ifdef __EMSCRIPTEN__\n    printf(\"Build time: %s\\n\", BUILD_TIMESTAMP);\n    printf(\"Press the Init button to start\\n\");\n    emscripten_set_main_loop(update, 60, 1);\n#else\n    init();\n    while (true) {\n        update();\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n#endif\n\n    return 0;\n}\n"
        },
        {
          "name": "guess-qp2.cpp",
          "type": "blob",
          "size": 17.4814453125,
          "content": "/*! \\file guess-qp2.cpp\n *  \\brief Basic tool to attempt to recognize the 'q' and 'p' keys\n *  \\author Georgi Gerganov\n */\n\n#ifdef __EMSCRIPTEN__\n#include \"build_timestamp.h\"\n#include \"emscripten/emscripten.h\"\n#endif\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"audio-logger.h\"\n\n#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include <map>\n#include <cmath>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <vector>\n\nstatic int g_predictedKey = -1;\nstatic bool g_isInitialized = false;\n\nstatic std::function<int()> g_init;\nstatic std::function<void()> g_update;\nstatic std::function<void(int)> g_handleKey;\n\nint init() {\n    if (g_isInitialized) return 1;\n\n    return g_init();\n}\n\nvoid update() {\n    if (g_isInitialized == false) return;\n\n    g_update();\n}\n\nusing TKeyWaveform = TKeyWaveformF;\nusing TKeyHistory = TKeyHistoryF;\n\n// JS interface\nextern \"C\" {\n    int doInit() {\n        return init();\n    }\n\n    void keyPressedCallback(int key) {\n        g_handleKey(key);\n    }\n\n    int getPredictedKey() {\n        return g_predictedKey;\n    }\n}\n\nint main(int, char**) {\n    TKey keyPressed = -1;\n    std::map<TKey, TKeyHistory> keySoundHistoryAmpl;\n    std::map<TKey, TKeyWaveform> keySoundAverageAmpl;\n\n    int timesToPressQ = 5;\n    int timesToPressP = 5;\n\n    bool doRecord = false;\n    bool printStatus = true;\n    bool isReadyToPredict = false;\n\n    // rig buffer\n    int rbBegin = 0;\n    float rbAverage = 0.0f;\n    std::array<float, kBkgrRingBufferSize> rbSamples;\n    rbSamples.fill(0.0f);\n\n    int lastkey = -1;\n    double lastcc = -1.0f;\n    float thresholdCC = 0.35f;\n\n    AudioLogger audioLogger;\n\n    AudioLogger::Callback cbAudio = [&](const AudioLogger::Record & frames) {\n        const int nFrames = frames.size();\n\n        if (isReadyToPredict) {\n\n            std::vector<int> positionsToPredict;\n\n            {\n                float amax = 0.0f;\n                for (int f = 0; f < (int) frames.size(); ++f) {\n                    for (int s = 0; s < (int) frames[f].size(); s += kBkgrStep_samples) {\n                        rbAverage *= rbSamples.size();\n                        rbAverage -= rbSamples[rbBegin];\n                        auto acur = std::abs(frames[f][s]);\n                        rbSamples[rbBegin] = acur;\n                        if (acur > amax) amax = acur;\n                        rbAverage += acur;\n                        rbAverage /= rbSamples.size();\n                        if (++rbBegin >= (int) rbSamples.size()) rbBegin = 0;\n                    }\n                }\n\n                int skip_samples = 0;\n                for (int f = nFrames/2 - 1; f <= nFrames/2 + 1; ++f) {\n                    for (int s = 0; s < (int) frames[f].size(); ++s) {\n                        if (s + skip_samples >= (int) frames[f].size()) {\n                            skip_samples -= frames[f].size() - s;\n                            s += skip_samples;\n                            continue;\n                        } else {\n                            s += skip_samples;\n                            skip_samples = 0;\n                        }\n                        auto acur = frames[f][s];\n                        if (acur > 10.0f*rbAverage) {\n                            skip_samples = kKeyDuration_samples;\n                            positionsToPredict.push_back(f*kSamplesPerFrame + s);\n                            //printf(\"Key press detected\\n\");\n                        }\n                    }\n                }\n\n                //printf(\"Average = %10.8f, max = %10.8f\\n\", rbAverage, amax);\n            }\n\n            if (positionsToPredict.size() > 0) {\n                TKeyWaveform ampl(nFrames*kSamplesPerFrame);\n                for (int k = 0; k < nFrames; ++k) {\n                    std::copy(frames[k].begin(), frames[k].end(), ampl.begin() + k*kSamplesPerFrame);\n                }\n\n                int alignWindow = 0.10*kSamplesPerWaveformTrain;\n\n                for (int ipos = 0; ipos < (int) positionsToPredict.size() ; ++ipos) {\n                    int scmp0 = positionsToPredict[ipos] - 0.25*kSamplesPerWaveformTrain;\n                    int scmp1 = positionsToPredict[ipos] + 0.25*kSamplesPerWaveformTrain;\n\n                    auto resq = findBestCC(keySoundAverageAmpl['q'], ampl, scmp0, scmp1, alignWindow);\n                    auto resp = findBestCC(keySoundAverageAmpl['p'], ampl, scmp0, scmp1, alignWindow);\n\n                    char res = std::get<0>(resq) > std::get<0>(resp) ? 'q' : 'p';\n\n                    auto curcc = std::max(std::get<0>(resp), std::get<0>(resq));\n                    if (curcc > thresholdCC) {\n                        if (lastkey != res || lastcc != curcc) {\n                            printf(\"    Prediction: '%c'        ('q' %8.5g vs %8.5g 'p')    (offsets    %5ld %5ld)\\n\",\n                                   res, std::get<0>(resq), std::get<0>(resp), std::get<1>(resq), std::get<1>(resp));\n                            lastkey = res;\n                            lastcc = curcc;\n                        }\n                    }\n\n                    g_predictedKey = res;\n                }\n            }\n\n            doRecord = true;\n        } else {\n            auto & history = keySoundHistoryAmpl[keyPressed];\n            history.push_back(TKeyWaveform(nFrames*kSamplesPerFrame));\n            auto & ampl = history.back();\n            for (int k = 0; k < nFrames; ++k) {\n                std::copy(frames[k].begin(), frames[k].end(), ampl.begin() + k*kSamplesPerFrame);\n            }\n\n            if (keyPressed == 'q' && timesToPressQ > 0) {\n                --timesToPressQ;\n                printStatus = true;\n            } else if (keyPressed == 'p' && timesToPressP > 0) {\n                --timesToPressP;\n                printStatus = true;\n            }\n        }\n\n        keyPressed = -1;\n    };\n\n    g_init = [&]() {\n        AudioLogger::Parameters parameters;\n        parameters.callback = std::move(cbAudio);\n        parameters.captureId = 0;\n        parameters.nChannels = 1;\n        parameters.sampleRate = kSampleRate;\n        parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n        if (audioLogger.install(std::move(parameters)) == false) {\n            fprintf(stderr, \"Failed to install audio logger\\n\");\n            return -1;\n        }\n\n        printf(\"[+] Collecting training data\\n\");\n        g_isInitialized = true;\n        return 0;\n    };\n\n    g_handleKey = [&](int key) {\n        if (keyPressed == -1 && isReadyToPredict == false) {\n            g_predictedKey = -1;\n            keyPressed = key;\n            audioLogger.record(kBufferSizeTrain_s, 3);\n        }\n    };\n\n#ifdef __EMSCRIPTEN__\n#else\n    std::thread keyReader = std::thread([&]() {\n        struct termios oldt, newt;\n        tcgetattr ( STDIN_FILENO, &oldt );\n        newt = oldt;\n        newt.c_lflag &= ~( ICANON | ECHO );\n        tcsetattr ( STDIN_FILENO, TCSANOW, &newt );\n        while (true) {\n            int key = getchar();\n            g_handleKey(key);\n        }\n        tcsetattr ( STDIN_FILENO, TCSANOW, &oldt );\n    });\n#endif\n\n    g_update = [&]() {\n        if (timesToPressQ > 0 || timesToPressP > 0) {\n            if (printStatus) {\n                if (timesToPressQ > 0) {\n                    printf(\"    - press the letter 'q' %d more times\\n\", timesToPressQ);\n                } else if (timesToPressP > 0) {\n                    printf(\"    - press the letter 'p' %d more times\\n\", timesToPressP);\n                }\n                printStatus = false;\n            }\n\n            return;\n        }\n\n        if (isReadyToPredict == false) {\n            printf(\"[+] Training\\n\");\n\n            auto trainKey = [&](TKey key) {\n                auto & history = keySoundHistoryAmpl[key];\n\n                int nWaveforms = history.size();\n                int nFramesPerWaveform = history[0].size()/kSamplesPerFrame;\n                int nSamplesPerFrame = kSamplesPerFrame;\n\n                printf(\"    - Training key '%c'\\n\", key);\n                printf(\"    - History size = %d key waveforms\\n\", nWaveforms);\n                printf(\"    - Frames per key waveform   = %d\\n\", nFramesPerWaveform);\n                printf(\"    - Total frames available    = %d\\n\", nWaveforms*nFramesPerWaveform);\n                printf(\"    - Samples per frame         = %d\\n\", nSamplesPerFrame);\n                printf(\"    - Total samples available   = %d\\n\", nWaveforms*nFramesPerWaveform*nSamplesPerFrame);\n\n                printf(\"    - Estimating waveform peaks ...\\n\");\n                std::vector<int> peakSum;\n                std::vector<int> peakMax;\n\n                peakSum.clear();\n                peakMax.clear();\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int isum = -1;\n                    float asum = 0.0f;\n                    float aisum = 0.0f;\n\n                    int imax = -1;\n                    float amax = 0.0f;\n\n                    const auto & waveform = history[iwaveform];\n\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            int icur = iframe*nSamplesPerFrame + isample;\n                            float acur = std::abs(waveform[iframe*kSamplesPerFrame + isample]);\n                            float acur2 = acur*acur;\n\n                            asum += acur2;\n                            aisum += acur2*icur;\n\n                            if (acur > amax) {\n                                amax = acur;\n                                imax = icur;\n                            }\n                        }\n                    }\n\n                    isum = aisum/asum;\n\n                    peakSum.push_back(isum);\n                    peakMax.push_back(imax);\n                    printf(\"        Estimated peak: %d (method - sum), %d (method - max)\\n\", isum, imax);\n                }\n\n                auto calcStdev = [](const std::vector<int> & data) {\n                    double sum = 0.0f;\n                    double sum2 = 0.0f;\n                    for (const auto & p : data) {\n                        int64_t v = p;\n                        sum += v;\n                        sum2 += v*v;\n                    }\n                    sum /= data.size();\n                    sum2 /= data.size();\n                    return sqrt(sum2 - sum*sum);\n                };\n\n                float stdevSum = calcStdev(peakSum);\n                float stdevMax = calcStdev(peakMax);\n\n                printf(\"    - Stdev of estimated peaks: %g (sum) vs %g (max)\\n\", stdevSum, stdevMax);\n\n                const auto & peakUsed = peakMax;\n                printf(\"    - Using 'max' estimation\\n\");\n\n                int centerSample = nFramesPerWaveform*nSamplesPerFrame/2;\n\n                printf(\"    - Centering waveforms at sample %d\\n\", centerSample);\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int offset = peakUsed[iwaveform] - centerSample;\n                    printf(\"        Offset for waveform %d = %d\\n\", iwaveform, offset);\n\n                    auto & waveform = history[iwaveform];\n                    auto newWaveform = TKeyWaveform(waveform.size());\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            int icur = iframe*nSamplesPerFrame + isample;\n                            int iorg = icur + offset;\n\n                            if (iorg >= 0 && iorg < nFramesPerWaveform*nSamplesPerFrame) {\n                                int f = iorg/nSamplesPerFrame;\n                                int s = iorg - f*nSamplesPerFrame;\n                                newWaveform[iframe*kSamplesPerFrame + isample] = waveform[f*kSamplesPerFrame + s];\n                            } else {\n                                newWaveform[iframe*kSamplesPerFrame + isample] = 0.0f;\n                            }\n                        }\n                    }\n\n                    waveform = std::move(newWaveform);\n                }\n\n                int alignToWaveform = nWaveforms/2;\n                int alignWindow = centerSample/2;\n                printf(\"    - Aligning all waveforms to waveform %d using cross correlation\\n\", alignToWaveform);\n                printf(\"      Align window = %d\\n\", alignWindow);\n\n                int scmp0 = centerSample - nSamplesPerFrame/4;\n                int scmp1 = centerSample + nSamplesPerFrame/4;\n\n                float sum0 = 0.0f;\n                float sum02 = 0.0f;\n\n                const auto & waveform0 = history[alignToWaveform];\n\n                for (int is = scmp0; is < scmp1; ++is) {\n                    int f = is/nSamplesPerFrame;\n                    int s = is - f*nSamplesPerFrame;\n\n                    auto a = waveform0[f*kSamplesPerFrame + s];\n                    sum0 += a;\n                    sum02 += a*a;\n                }\n\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    if (iwaveform == alignToWaveform) continue;\n\n                    auto & waveform1 = history[iwaveform];\n\n                    int besto = 0;\n                    float bestcc = 0.0f;\n\n                    for (int o = -alignWindow; o < alignWindow; ++o) {\n                        float cc = 0.0f;\n\n                        float sum1 = 0.0f, sum12 = 0.0f, sum01 = 0.0f;\n                        for (int is = scmp0; is < scmp1; ++is) {\n                            int is1 = is + o;\n                            int f1 = is1/nSamplesPerFrame;\n                            int s1 = is1 - f1*nSamplesPerFrame;\n\n                            auto a1 = waveform1[f1*kSamplesPerFrame + s1];\n                            sum1 += a1;\n                            sum12 += a1*a1;\n\n                            int is0 = is;\n                            int f0 = is0/nSamplesPerFrame;\n                            int s0 = is0 - f0*nSamplesPerFrame;\n\n                            auto a0 = waveform0[f0*kSamplesPerFrame + s0];\n                            sum01 += a0*a1;\n                        }\n\n                        int ncc = scmp1 - scmp0;\n                        {\n                            float nom = sum01*ncc - sum0*sum1;\n                            float den2a = sum02*ncc - sum0*sum0;\n                            float den2b = sum12*ncc - sum1*sum1;\n                            cc = (nom)/(sqrt(den2a*den2b));\n                        }\n\n                        if (cc > bestcc) {\n                            besto = o;\n                            bestcc = cc;\n                        }\n                    }\n\n                    printf(\"        Best offset for waveform %d = %d (cc = %g)\\n\", iwaveform, besto, bestcc);\n\n                    auto newWaveform = TKeyWaveform(nFramesPerWaveform*nSamplesPerFrame);\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            int icur = iframe*nSamplesPerFrame + isample;\n                            int iorg = icur + besto;\n\n                            if (iorg >= 0 && iorg < nFramesPerWaveform*nSamplesPerFrame) {\n                                int f = iorg/nSamplesPerFrame;\n                                int s = iorg - f*nSamplesPerFrame;\n                                newWaveform[iframe*kSamplesPerFrame + isample] = waveform1[f*kSamplesPerFrame + s];\n                            } else {\n                                newWaveform[iframe*kSamplesPerFrame + isample] = 0.0f;\n                            }\n                        }\n                    }\n\n                    waveform1 = std::move(newWaveform);\n                }\n\n                printf(\"    - Calculating average waveform\\n\");\n                auto & avgWaveform = keySoundAverageAmpl[key];\n                avgWaveform.resize(nFramesPerWaveform*nSamplesPerFrame);\n                for (auto & f : avgWaveform) f = 0.0f;\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    auto & waveform = history[iwaveform];\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            avgWaveform[iframe*kSamplesPerFrame + isample] += waveform[iframe*kSamplesPerFrame + isample];\n                        }\n                    }\n                }\n\n                {\n                    float norm = 1.0f/(nFramesPerWaveform*nSamplesPerFrame);\n                    for (int iframe = 0; iframe < nFramesPerWaveform; ++iframe) {\n                        for (int isample = 0; isample < nSamplesPerFrame; ++isample) {\n                            avgWaveform[iframe*kSamplesPerFrame + isample] *= norm;\n                        }\n                    }\n                }\n\n                printf(\"\\n\");\n            };\n\n            trainKey('q');\n            trainKey('p');\n            isReadyToPredict = true;\n            doRecord = true;\n\n            printf(\"[+] Ready to predict. Keep pressing 'q' or 'p' and the program will guess which key was pressed\\n\");\n            printf(\"    based on the captured audio from the microphone.\\n\");\n            printf(\"[+] Predicting\\n\");\n        }\n\n        if (doRecord) {\n            doRecord = false;\n            audioLogger.record(kBufferSizeTrain_s, getBufferSize_frames(kSampleRate, kBufferSizeTrain_s) - 1);\n        }\n    };\n\n#ifdef __EMSCRIPTEN__\n    printf(\"Build time: %s\\n\", BUILD_TIMESTAMP);\n    printf(\"Press the Init button to start\\n\");\n    emscripten_set_main_loop(update, 60, 1);\n#else\n    init();\n    while (true) {\n        update();\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n#endif\n\n    return 0;\n}\n"
        },
        {
          "name": "imconfig-vtx32.h",
          "type": "blob",
          "size": 4.7900390625,
          "content": "//-----------------------------------------------------------------------------\n// COMPILE-TIME OPTIONS FOR DEAR IMGUI\n// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.\n// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.\n//-----------------------------------------------------------------------------\n// A) You may edit imconfig.h (and not overwrite it when updating imgui, or maintain a patch/branch with your modifications to imconfig.h)\n// B) or add configuration directives in your own file and compile with #define IMGUI_USER_CONFIG \"myfilename.h\"\n// If you do so you need to make sure that configuration settings are defined consistently _everywhere_ dear imgui is used, which include\n// the imgui*.cpp files but also _any_ of your code that uses imgui. This is because some compile-time options have an affect on data structures.\n// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.\n// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.\n//-----------------------------------------------------------------------------\n\n#pragma once\n\n//---- Define assertion handler. Defaults to calling assert().\n//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)\n//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts\n\n//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows.\n//#define IMGUI_API __declspec( dllexport )\n//#define IMGUI_API __declspec( dllimport )\n\n//---- Don't define obsolete functions/enums names. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.\n//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n\n//---- Don't implement demo windows functionality (ShowDemoWindow()/ShowStyleEditor()/ShowUserGuide() methods will be empty)\n//---- It is very strongly recommended to NOT disable the demo windows during development. Please read the comments in imgui_demo.cpp.\n//#define IMGUI_DISABLE_DEMO_WINDOWS\n\n//---- Don't implement some functions to reduce linkage requirements.\n//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.\n//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.\n//#define IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS             // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself if you don't want to link with vsnprintf.\n//#define IMGUI_DISABLE_MATH_FUNCTIONS                      // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 wrapper so you can implement them yourself. Declare your prototypes in imconfig.h.\n//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().\n\n//---- Include imgui_user.h at the end of imgui.h as a convenience\n//#define IMGUI_INCLUDE_IMGUI_USER_H\n\n//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)\n//#define IMGUI_USE_BGRA_PACKED_COLOR\n\n//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version\n// By default the embedded implementations are declared static and not available outside of imgui cpp files.\n//#define IMGUI_STB_TRUETYPE_FILENAME   \"my_folder/stb_truetype.h\"\n//#define IMGUI_STB_RECT_PACK_FILENAME  \"my_folder/stb_rect_pack.h\"\n//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\n//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\n\n//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.\n// This will be inlined as part of ImVec2 and ImVec4 class declarations.\n/*\n#define IM_VEC2_CLASS_EXTRA                                                 \\\n        ImVec2(const MyVec2& f) { x = f.x; y = f.y; }                       \\\n        operator MyVec2() const { return MyVec2(x,y); }\n\n#define IM_VEC4_CLASS_EXTRA                                                 \\\n        ImVec4(const MyVec4& f) { x = f.x; y = f.y; z = f.z; w = f.w; }     \\\n        operator MyVec4() const { return MyVec4(x,y,z,w); }\n*/\n\n//---- Use 32-bit vertex indices (default is 16-bit) to allow meshes with more than 64K vertices. Render function needs to support it.\n#define ImDrawIdx unsigned int\n\n//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.\n/*\nnamespace ImGui\n{\n    void MyFunction(const char* name, const MyMatrix44& v);\n}\n*/\n"
        },
        {
          "name": "imgui",
          "type": "commit",
          "content": null
        },
        {
          "name": "index-keytap2-gui-tmpl.html",
          "type": "blob",
          "size": 13.68359375,
          "content": "<!doctype html>\n<html lang=\"en-us\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Keytap2</title>\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"/>\n\n        <meta name=\"twitter:card\" content=\"summary\">\n        <meta name=\"twitter:title\" content=\"Keytap2\" />\n        <meta name=\"twitter:description\" content=\"Acoustic keyboard eavesdropping based on language n-gram frequencies\" />\n        <meta name=\"twitter:image\" content=\"https://keytap2.ggerganov.com/keytap2.png\" />\n\n        <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png\">\n        <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\">\n        <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/favicon-16x16.png\">\n        <link rel=\"manifest\" href=\"/site.webmanifest\">\n\n        <meta name=\"msapplication-TileColor\" content=\"#ffffff\">\n        <meta name=\"msapplication-TileImage\" content=\"/ms-icon-144x144.png\">\n        <meta name=\"theme-color\" content=\"#ffffff\">\n\n        <link rel=\"stylesheet\" href=\"style.css\">\n    </head>\n    <body>\n        <div id=\"main-controls\">\n            <div id=\"description\">\n                <h2>Keytap2 - acoustic keyboard eavesdropping based on language n-gram frequencies</h2>\n\n                <span class=\"text-body\">\n                    This is a proof-of-concept of an attack for recovering the contents of an unknown text just by analyzing the audio from the keyboard strokes.<br>\n                    <b>No prior training is required.</b>\n\n                    <br><br>\n\n                    This tool runs entirely in your browser. No data is sent or stored to a server.\n\n                    <br><br>\n\n                    Assumptions and requirements:\n                    <ul>\n                        <li>The text is in English</li>\n                        <li>At least 100 characters of meaningful text are typed</li>\n                        <li>Only letters (\"a\" - \"z\") and the \"Space\" keys are pressed (i.e. no Backspace, Shift, numbers, etc.)</li>\n                        <li>Noisy mechanical keyboard</li>\n                        <li>Microphone in the vicinity of the keyboard</li>\n                    </ul>\n\n                    <br>\n\n                    Here is a video demonstrating this type of attack: <a class=\"nav-link2\" href=\"https://youtu.be/jNtw17S6SR0\">Demo (~5 min YouTube video)</a>\n\n                    <br><br>\n\n                    For training-based acoustic eavesdropping, make sure to checkout <a class=\"nav-link2\" href=\"https://ggerganov.github.io/keytap\">Keytap</a>\n\n                    <br><br>\n\n                    To run this program in the browser you will need support for pthreads with WebAssembly (i.e. Chrome or Firefox Nightly).<br>\n                    To enable WebAssembly pthreads and SharedArrayBuffer support, check this <a class=\"nav-link2\" href=\"https://github.com/kripken/emscripten/wiki/Pthreads-with-WebAssembly/\">page</a>.<br>\n                    <br>\n                    Press the \"Init\" button to start:\n                </span>\n\n                <div align=\"center\">\n                    <button onClick=\"doInit()\" id=\"butInit\" style=\"width:60px;height:30px;\" disabled>Init</button>\n                    <br><br>\n                    <div class=\"nav-link2\" id=\"download-info\">Downloading WASM module and n-gram stats. Please wait ...</div>\n                </div>\n            </div>\n            <canvas class=\"emscripten\" id=\"canvas\" oncontextmenu=\"event.preventDefault()\" hidden></canvas>\n        </div>\n\n        <div id=\"footer\" class=\"cell-version\">\n            <span>\n                Build time: <span class=\"nav-link\">@GIT_DATE@</span> |\n                Commit hash: <a class=\"nav-link\" href=\"https://github.com/ggerganov/kbd-audio/commit/@GIT_SHA1@\">@GIT_SHA1@</a> |\n                Commit subject: <span class=\"nav-link\">@GIT_COMMIT_SUBJECT@</span> |\n            </span>\n        </div>\n        <div id=\"footer2\" class=\"cell-about\">\n            <a class=\"nav-link\" href=\"https://github.com/ggerganov/kbd-audio\"><span class=\"d-none d-sm-inline\">View on GitHub </span>\n                <svg version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"octicon octicon-mark-github\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"></path></svg>\n            </a>\n        </div>\n\n        <script type='text/javascript'>\n            window.mobilecheck = function() {\n                var check = false;\n                (function(a){if(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);\n                return check;\n            };\n\n            var isMobile = mobilecheck();\n            var isInitialized = false;\n\n            var screenX = -1;\n            var screenY = -1;\n\n            var oldOutputId = 0;\n\n            window.setInterval(function(){\n                    if (isMobile) {\n                        document.getElementById(\"footer\").innerHTML = '';\n                        document.getElementById(\"footer2\").innerHTML = '';\n                    }\n                    if (isInitialized == false) return;\n                    var w = window,\n                        d = document,\n                        e = d.documentElement,\n                        g = d.getElementsByTagName('body')[0],\n                        x = w.innerWidth || e.clientWidth || g.clientWidth,\n                        y = w.innerHeight|| e.clientHeight|| g.clientHeight;\n                    Module._set_window_size(0.99*x, y - 1.40*document.getElementById('footer').clientHeight);\n            }, 500);\n\n            function checkLoop() {\n                var outputId = Module._get_output_id();\n                if (outputId != oldOutputId) {\n                    offerFileAsDownload('record.kbd', 'mime/type');\n                    oldOutputId = outputId;\n                }\n\n                setTimeout(checkLoop, 100);\n            }\n\n            function onkeydown(event) {\n                if (event.keyCode >= 112 && event.keyCode <= 123) {\n                    event.stopImmediatePropagation();\n                }\n            }\n\n            function init() {\n                document.getElementById(\"butInit\").disabled = false;\n                document.getElementById(\"download-info\").innerHTML = \"WASM module initialized!\";\n\n                window.addEventListener('keydown', onkeydown, true);\n\n                document.getElementById(\"canvas\").addEventListener(\"dragover\", (event) => {\n                    event.preventDefault();\n                });\n\n                document.getElementById(\"canvas\").addEventListener(\"drop\", (event) => {\n                    event.preventDefault();\n\n                    dropHandler(event);\n                });\n\n                setTimeout(checkLoop, 100);\n                //window.requestAnimationFrame(renderFrame);\n            }\n\n            function doInit() {\n                let constraints = {\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1,\n                        echoCancellation: false,\n                        autoGainControl: false,\n                        noiseSuppression: false\n                    }\n                };\n\n                let mediaInput = navigator.mediaDevices.getUserMedia( constraints );\n\n                if (isInitialized == false) {\n                    Module._do_init();\n                    document.getElementById(\"butInit\").disabled = true;\n                    document.getElementById(\"description\").hidden = true;\n                    isInitialized = true;\n                }\n\n                var x = document.getElementById(\"canvas\");\n                x.hidden = false;\n            }\n\n            //function renderFrame() {\n            //    window.requestAnimationFrame(renderFrame);\n            //}\n\n            function dropHandler(event) {\n                // Prevent default behavior (Prevent file from being opened)\n                event.preventDefault();\n\n                // fetch FileList object\n                var files = event.target.files || event.dataTransfer.files;\n\n                // process all File objects\n                for (var i = 0, f; f = files[i]; i++) {\n                    ParseFile(f);\n                }\n            }\n\n            function ParseFile(file) {\n                console.log(\n                        \"<p>File information: <strong>\" + file.name +\n                        \"</strong> type: <strong>\" + file.type +\n                        \"</strong> size: <strong>\" + file.size +\n                        \"</strong> bytes</p>\"\n                );\n\n                var reader = new FileReader();\n                reader.onload = function(event) {\n                    var buf = new Uint8Array(reader.result);\n                    var stream = FS.open(\"record.kbd\", \"w\");\n                    FS.write(stream, buf, 0, buf.length, 0);\n                    FS.close(stream);\n\n                    Module._do_reload();\n                }\n                reader.readAsArrayBuffer(file);\n            }\n\n            function offerFileAsDownload(filename, mime) {\n                mime = mime || \"application/octet-stream\";\n\n                let content = FS.readFile(filename);\n                console.log(`Offering download of \"${filename}\", with ${content.length} bytes...`);\n\n                var a = document.createElement('a');\n                a.download = filename;\n                a.href = URL.createObjectURL(new Blob([content], {type: mime}));\n                a.style.display = 'none';\n\n                document.body.appendChild(a);\n                a.click();\n                setTimeout(() => {\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(a.href);\n                }, 2000);\n            }\n\n            var Module = {\n                arguments: [\"record.kbd\", \"./data\"],\n                preRun: [(function() {\n                }) ],\n                postRun: [(function () {\n                    init();\n                })\n                ],\n                canvas: (function() {\n                    var canvas = document.getElementById('canvas');\n                    //canvas.style.marginLeft = \"-230px\";\n                    canvas.addEventListener(\"webglcontextlost\", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);\n\n                    return canvas;\n                })(),\n                print: (function() {\n                    return function(text) {\n                        text = Array.prototype.slice.call(arguments).join(' ');\n                        console.log(text);\n                    };\n                })(),\n                printErr: function(text) {\n                    text = Array.prototype.slice.call(arguments).join(' ');\n                    console.error(text);\n                },\n                setStatus: function(text) {\n                    console.log(\"status: \" + text);\n                },\n                monitorRunDependencies: function(left) {\n                }\n            };\n            window.onerror = function() {\n                document.getElementById(\"download-info\").innerHTML = \"Failed to initialize the WASM module. Your browser might not be supported.\";\n                document.getElementById('download-info').style.color='red';\n                console.log(\"onerror: \" + event);\n            };\n\n        </script>\n\n        <script async type=\"text/javascript\" src=\"@TARGET@.js\"></script>\n    </body>\n</html>\n"
        },
        {
          "name": "index-keytap3-app-tmpl.html",
          "type": "blob",
          "size": 12.7919921875,
          "content": "<!doctype html>\n<html lang=\"en-us\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Keytap3</title>\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"/>\n\n        <meta name=\"twitter:card\" content=\"summary\">\n        <meta name=\"twitter:title\" content=\"Keytap3\" />\n        <meta name=\"twitter:description\" content=\"Acoustic keyboard eavesdropping based on language n-gram frequencies\" />\n        <meta name=\"twitter:image\" content=\"https://keytap3.ggerganov.com/keytap3.png\" />\n\n        <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png\">\n        <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\">\n        <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/favicon-16x16.png\">\n        <link rel=\"manifest\" href=\"/site.webmanifest\">\n\n        <meta name=\"msapplication-TileColor\" content=\"#ffffff\">\n        <meta name=\"msapplication-TileImage\" content=\"/ms-icon-144x144.png\">\n        <meta name=\"theme-color\" content=\"#ffffff\">\n\n        <link rel=\"stylesheet\" href=\"style.css\">\n    </head>\n    <body>\n        <div id=\"main-controls\">\n            <div id=\"description\">\n                <h2>Keytap3 - acoustic keyboard eavesdropping</h2>\n\n                <span class=\"text-body\">\n                    This is a proof-of-concept of an attack for recovering the contents of an unknown text just by analyzing the audio from the keyboard strokes.<br>\n                    <b>No prior training is required.</b>\n\n                    <br><br>\n\n                    This tool runs entirely in your browser. No data is sent or stored to a server.\n\n                    <br><br>\n\n                    Press the \"Init\" button to start:\n                </span>\n\n                <div align=\"center\">\n                    <button onClick=\"doInit(100)\" id=\"butInit100\" style=\"width:60px;height:30px;\" disabled>Init 100</button>\n                    <button onClick=\"doInit(200)\" id=\"butInit200\" style=\"width:60px;height:30px;\" disabled>Init 200</button>\n                    <button onClick=\"doInit(300)\" id=\"butInit300\" style=\"width:60px;height:30px;\" disabled>Init 300</button>\n                    <br><br>\n                    <div class=\"nav-link2\" id=\"download-info\">Downloading WASM module and n-gram stats. Please wait ...</div>\n                </div>\n            </div>\n            <textarea id=\"output\"></textarea>\n        </div>\n\n        <div id=\"footer\" class=\"cell-version\">\n            <span>\n                Build time: <span class=\"nav-link\">@GIT_DATE@</span> |\n                Commit hash: <a class=\"nav-link\" href=\"https://github.com/ggerganov/kbd-audio/commit/@GIT_SHA1@\">@GIT_SHA1@</a> |\n                Commit subject: <span class=\"nav-link\">@GIT_COMMIT_SUBJECT@</span> |\n            </span>\n        </div>\n        <div id=\"footer2\" class=\"cell-about\">\n            <a class=\"nav-link\" href=\"https://github.com/ggerganov/kbd-audio\"><span class=\"d-none d-sm-inline\">View on GitHub </span>\n                <svg version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"octicon octicon-mark-github\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"></path></svg>\n            </a>\n        </div>\n\n        <script type='text/javascript'>\n            window.mobilecheck = function() {\n                var check = false;\n                (function(a){if(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);\n                return check;\n            };\n\n            var isMobile = mobilecheck();\n            var isInitialized = false;\n\n            var screenX = -1;\n            var screenY = -1;\n\n            var oldOutputId = 0;\n\n            window.setInterval(function(){\n                    if (isMobile) {\n                        document.getElementById(\"footer\").innerHTML = '';\n                        document.getElementById(\"footer2\").innerHTML = '';\n                    }\n                    if (isInitialized == false) return;\n                    //var w = window,\n                    //    d = document,\n                    //    e = d.documentElement,\n                    //    g = d.getElementsByTagName('body')[0],\n                    //    x = w.innerWidth || e.clientWidth || g.clientWidth,\n                    //    y = w.innerHeight|| e.clientHeight|| g.clientHeight;\n                    //Module._set_window_size(0.99*x, y - 1.40*document.getElementById('footer').clientHeight);\n            }, 500);\n\n            function checkLoop() {\n                //var outputId = Module.getData();\n                //if (outputId != oldOutputId) {\n                //    offerFileAsDownload('record.kbd', 'mime/type');\n                //    oldOutputId = outputId;\n                //}\n\n                // parse \"cmd [num1] [float]\"\n                var data = Module.getData();\n                var parts = data.split(' ');\n                var cmd = parts[0];\n\n                if (cmd == \"recording\") {\n                    var num1 = parseInt(parts[1]);\n                    var num2 = parseFloat(parts[2]);\n                }\n\n                setTimeout(checkLoop, 100);\n            }\n\n            function onkeydown(event) {\n                if (event.keyCode >= 112 && event.keyCode <= 123) {\n                    event.stopImmediatePropagation();\n                }\n            }\n\n            function init() {\n                document.getElementById(\"butInit100\").disabled = false;\n                document.getElementById(\"butInit200\").disabled = false;\n                document.getElementById(\"butInit300\").disabled = false;\n                document.getElementById(\"download-info\").innerHTML = \"WASM module initialized!\";\n\n                window.addEventListener('keydown', onkeydown, true);\n\n                setTimeout(checkLoop, 100);\n            }\n\n            function doInit(nKeysToCapture) {\n                let constraints = {\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1,\n                        echoCancellation: false,\n                        autoGainControl: false,\n                        noiseSuppression: false\n                    }\n                };\n\n                let mediaInput = navigator.mediaDevices.getUserMedia( constraints );\n\n                if (isInitialized == false) {\n                    Module.doInit();\n                    Module.setData(\"start \" + nKeysToCapture);\n                    document.getElementById(\"butInit100\").disabled = true;\n                    document.getElementById(\"butInit200\").disabled = true;\n                    document.getElementById(\"butInit300\").disabled = true;\n                    document.getElementById(\"description\").hidden = true;\n                    isInitialized = true;\n                }\n            }\n\n            //function renderFrame() {\n            //    window.requestAnimationFrame(renderFrame);\n            //}\n\n            function dropHandler(event) {\n                // Prevent default behavior (Prevent file from being opened)\n                event.preventDefault();\n\n                // fetch FileList object\n                var files = event.target.files || event.dataTransfer.files;\n\n                // process all File objects\n                for (var i = 0, f; f = files[i]; i++) {\n                    ParseFile(f);\n                }\n            }\n\n            function ParseFile(file) {\n                console.log(\n                        \"<p>File information: <strong>\" + file.name +\n                        \"</strong> type: <strong>\" + file.type +\n                        \"</strong> size: <strong>\" + file.size +\n                        \"</strong> bytes</p>\"\n                );\n\n                var reader = new FileReader();\n                reader.onload = function(event) {\n                    var buf = new Uint8Array(reader.result);\n                    var stream = FS.open(\"record.kbd\", \"w\");\n                    FS.write(stream, buf, 0, buf.length, 0);\n                    FS.close(stream);\n\n                    Module._do_reload();\n                }\n                reader.readAsArrayBuffer(file);\n            }\n\n            function offerFileAsDownload(filename, mime) {\n                mime = mime || \"application/octet-stream\";\n\n                let content = FS.readFile(filename);\n                console.log(`Offering download of \"${filename}\", with ${content.length} bytes...`);\n\n                var a = document.createElement('a');\n                a.download = filename;\n                a.href = URL.createObjectURL(new Blob([content], {type: mime}));\n                a.style.display = 'none';\n\n                document.body.appendChild(a);\n                a.click();\n                setTimeout(() => {\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(a.href);\n                }, 2000);\n            }\n\n            var Module = {\n                arguments: [\"record.kbd\", \"data\", \"300\"],\n                preRun: [(function() {\n                }) ],\n                postRun: [(function () {\n                    init();\n                })\n                ],\n                print: (function() {\n                    var element = document.getElementById('output');\n                    if (element) element.alue = ''; // clear browser cache\n                    return function(text) {\n                        if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');\n                        console.log(text);\n                        if (element) {\n                            element.value += text + \"\\n\";\n                            element.scrollTop = element.scrollHeight; // focus on bottom\n                        }\n                    };\n                })(),\n                printErr: function(text) {\n                    text = Array.prototype.slice.call(arguments).join(' ');\n                    console.error(text);\n                },\n                setStatus: function(text) {\n                    console.log(\"status: \" + text);\n                },\n                monitorRunDependencies: function(left) {\n                }\n            };\n            window.onerror = function() {\n                document.getElementById(\"download-info\").innerHTML = \"Failed to initialize the WASM module. Your browser might not be supported.\";\n                document.getElementById('download-info').style.color='red';\n                console.log(\"onerror: \" + event);\n            };\n\n        </script>\n\n        <script async type=\"text/javascript\" src=\"keytap3-app.js\"></script>\n    </body>\n</html>\n"
        },
        {
          "name": "index-keytap3-gui-tmpl.html",
          "type": "blob",
          "size": 12.2998046875,
          "content": "<!doctype html>\n<html lang=\"en-us\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Keytap3</title>\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"/>\n\n        <meta name=\"twitter:card\" content=\"summary\">\n        <meta name=\"twitter:title\" content=\"Keytap3\" />\n        <meta name=\"twitter:description\" content=\"Acoustic keyboard eavesdropping based on language n-gram frequencies\" />\n        <meta name=\"twitter:image\" content=\"https://keytap3.ggerganov.com/keytap3.png\" />\n\n        <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png\">\n        <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\">\n        <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/favicon-16x16.png\">\n        <link rel=\"manifest\" href=\"/site.webmanifest\">\n\n        <meta name=\"msapplication-TileColor\" content=\"#ffffff\">\n        <meta name=\"msapplication-TileImage\" content=\"/ms-icon-144x144.png\">\n        <meta name=\"theme-color\" content=\"#ffffff\">\n\n        <link rel=\"stylesheet\" href=\"style.css\">\n    </head>\n    <body>\n        <div id=\"main-controls\">\n            <div id=\"description\">\n                <h2>Keytap3 - acoustic keyboard eavesdropping</h2>\n\n                <span class=\"text-body\">\n                    This is a GUI for <a class=\"nav-link2\" href=\"https://keytap3.ggerganov.com\">Keytap3</a><br>\n\n                    <br>\n\n                    This tool runs entirely in your browser. No data is sent or stored to a server.\n\n                    <br><br>\n\n                    Press the \"Init\" button to start:\n\n                    <br><br>\n                </span>\n\n                <div align=\"center\">\n                    <button onClick=\"doInit()\" id=\"butInit\" style=\"width:60px;height:30px;\" disabled>Init</button>\n                    <br><br>\n                    <div class=\"nav-link2\" id=\"download-info\">Downloading WASM module and n-gram stats. Please wait ...</div>\n                </div>\n            </div>\n            <canvas class=\"emscripten\" id=\"canvas\" oncontextmenu=\"event.preventDefault()\" hidden></canvas>\n        </div>\n\n        <div id=\"footer\" class=\"cell-version\">\n            <span>\n                Build time: <span class=\"nav-link\">@GIT_DATE@</span> |\n                Commit hash: <a class=\"nav-link\" href=\"https://github.com/ggerganov/kbd-audio/commit/@GIT_SHA1@\">@GIT_SHA1@</a> |\n                Commit subject: <span class=\"nav-link\">@GIT_COMMIT_SUBJECT@</span> |\n            </span>\n        </div>\n        <div id=\"footer2\" class=\"cell-about\">\n            <a class=\"nav-link\" href=\"https://github.com/ggerganov/kbd-audio\"><span class=\"d-none d-sm-inline\">View on GitHub </span>\n                <svg version=\"1.1\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" class=\"octicon octicon-mark-github\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"></path></svg>\n            </a>\n        </div>\n\n        <script type='text/javascript'>\n            window.mobilecheck = function() {\n                var check = false;\n                (function(a){if(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);\n                return check;\n            };\n\n            var isMobile = mobilecheck();\n            var isInitialized = false;\n\n            var screenX = -1;\n            var screenY = -1;\n\n            var oldOutputId = 0;\n\n            window.setInterval(function(){\n                    if (isMobile) {\n                        document.getElementById(\"footer\").innerHTML = '';\n                        document.getElementById(\"footer2\").innerHTML = '';\n                    }\n                    if (isInitialized == false) return;\n                    var w = window,\n                        d = document,\n                        e = d.documentElement,\n                        g = d.getElementsByTagName('body')[0],\n                        x = w.innerWidth || e.clientWidth || g.clientWidth,\n                        y = w.innerHeight|| e.clientHeight|| g.clientHeight;\n                    Module._set_window_size(0.99*x, y - 1.40*document.getElementById('footer').clientHeight);\n            }, 500);\n\n            function checkLoop() {\n                var outputId = Module._get_output_id();\n                if (outputId != oldOutputId) {\n                    offerFileAsDownload('record.kbd', 'mime/type');\n                    oldOutputId = outputId;\n                }\n\n                setTimeout(checkLoop, 100);\n            }\n\n            function onkeydown(event) {\n                if (event.keyCode >= 112 && event.keyCode <= 123) {\n                    event.stopImmediatePropagation();\n                }\n            }\n\n            function init() {\n                document.getElementById(\"butInit\").disabled = false;\n                document.getElementById(\"download-info\").innerHTML = \"WASM module initialized!\";\n\n                window.addEventListener('keydown', onkeydown, true);\n\n                document.getElementById(\"canvas\").addEventListener(\"dragover\", (event) => {\n                    event.preventDefault();\n                });\n\n                document.getElementById(\"canvas\").addEventListener(\"drop\", (event) => {\n                    event.preventDefault();\n\n                    dropHandler(event);\n                });\n\n                setTimeout(checkLoop, 100);\n                //window.requestAnimationFrame(renderFrame);\n            }\n\n            function doInit() {\n                let constraints = {\n                    audio: {\n                        sampleRate: 16000,\n                        channelCount: 1,\n                        echoCancellation: false,\n                        autoGainControl: false,\n                        noiseSuppression: false\n                    }\n                };\n\n                let mediaInput = navigator.mediaDevices.getUserMedia( constraints );\n\n                if (isInitialized == false) {\n                    Module._do_init();\n                    document.getElementById(\"butInit\").disabled = true;\n                    document.getElementById(\"description\").hidden = true;\n                    isInitialized = true;\n                }\n\n                var x = document.getElementById(\"canvas\");\n                x.hidden = false;\n            }\n\n            //function renderFrame() {\n            //    window.requestAnimationFrame(renderFrame);\n            //}\n\n            function dropHandler(event) {\n                // Prevent default behavior (Prevent file from being opened)\n                event.preventDefault();\n\n                // fetch FileList object\n                var files = event.target.files || event.dataTransfer.files;\n\n                // process all File objects\n                for (var i = 0, f; f = files[i]; i++) {\n                    ParseFile(f);\n                }\n            }\n\n            function ParseFile(file) {\n                console.log(\n                        \"<p>File information: <strong>\" + file.name +\n                        \"</strong> type: <strong>\" + file.type +\n                        \"</strong> size: <strong>\" + file.size +\n                        \"</strong> bytes</p>\"\n                );\n\n                var reader = new FileReader();\n                reader.onload = function(event) {\n                    var buf = new Uint8Array(reader.result);\n                    var stream = FS.open(\"record.kbd\", \"w\");\n                    FS.write(stream, buf, 0, buf.length, 0);\n                    FS.close(stream);\n\n                    Module._do_reload();\n                }\n                reader.readAsArrayBuffer(file);\n            }\n\n            function offerFileAsDownload(filename, mime) {\n                mime = mime || \"application/octet-stream\";\n\n                let content = FS.readFile(filename);\n                console.log(`Offering download of \"${filename}\", with ${content.length} bytes...`);\n\n                var a = document.createElement('a');\n                a.download = filename;\n                a.href = URL.createObjectURL(new Blob([content], {type: mime}));\n                a.style.display = 'none';\n\n                document.body.appendChild(a);\n                a.click();\n                setTimeout(() => {\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(a.href);\n                }, 2000);\n            }\n\n            var Module = {\n                arguments: [\"record.kbd\", \"./data\"],\n                preRun: [(function() {\n                }) ],\n                postRun: [(function () {\n                    init();\n                })\n                ],\n                canvas: (function() {\n                    var canvas = document.getElementById('canvas');\n                    //canvas.style.marginLeft = \"-230px\";\n                    canvas.addEventListener(\"webglcontextlost\", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);\n\n                    return canvas;\n                })(),\n                print: (function() {\n                    return function(text) {\n                        text = Array.prototype.slice.call(arguments).join(' ');\n                        console.log(text);\n                    };\n                })(),\n                printErr: function(text) {\n                    text = Array.prototype.slice.call(arguments).join(' ');\n                    console.error(text);\n                },\n                setStatus: function(text) {\n                    console.log(\"status: \" + text);\n                },\n                monitorRunDependencies: function(left) {\n                }\n            };\n            window.onerror = function() {\n                document.getElementById(\"download-info\").innerHTML = \"Failed to initialize the WASM module. Your browser might not be supported.\";\n                document.getElementById('download-info').style.color='red';\n                console.log(\"onerror: \" + event);\n            };\n\n        </script>\n\n        <script async type=\"text/javascript\" src=\"@TARGET@.js\"></script>\n    </body>\n</html>\n"
        },
        {
          "name": "key-average-gui.cpp",
          "type": "blob",
          "size": 13.8115234375,
          "content": "/*! \\file key-average-gui.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"audio-logger.h\"\n\n#include \"fftw3.h\"\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#include <SDL.h>\n#include <GL/gl3w.h>\n\n#include <map>\n#include <mutex>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n#include <chrono>\n\nint main(int argc, char ** argv) {\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_TIMER) != 0) {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int captureId = argm[\"c\"].empty() ? 0 : std::stoi(argm[\"c\"]);\n    int nChannels = argm[\"C\"].empty() ? 0 : std::stoi(argm[\"C\"]);\n\n    printf(\"Usage: %s output.kbd [-cN]\\n\", argv[0]);\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - number N of capture channels N\\n\");\n    printf(\"\\n\");\n\n    int windowSizeX = 1280;\n    int windowSizeY = 800;\n\n#if __APPLE__\n    // GL 3.2 Core + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#endif\n\n    // Create window with graphics context\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_DisplayMode current;\n    SDL_GetCurrentDisplayMode(0, &current);\n    SDL_Window* window = SDL_CreateWindow(\"Average key stroke audio information\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, windowSizeX, windowSizeY, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Initialize OpenGL loader\n    bool err = gl3wInit() != 0;\n    if (err) {\n        fprintf(stderr, \"Failed to initialize OpenGL loader!\\n\");\n        return 1;\n    }\n\n    // Setup Dear ImGui binding\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;  // Enable Keyboard Controls\n\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL3_Init(glsl_version);\n\n    // Setup style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsClassic();\n\n    // Project specific\n    std::mutex mutex;\n\n    printf(\"sizeof fftwf_complex = %d\\n\", (int) sizeof(fftwf_complex));\n    fftwf_complex * fftIn = (fftwf_complex*) fftwf_malloc(sizeof(fftwf_complex)*kSamplesPerFrame);\n    fftwf_complex * fftOut = (fftwf_complex*) fftwf_malloc(sizeof(fftwf_complex)*kSamplesPerFrame);\n    fftwf_plan fftPlan = fftwf_plan_dft_1d(kSamplesPerFrame, fftIn, fftOut, FFTW_FORWARD, FFTW_ESTIMATE);\n\n    using TKey = int;\n    using TKeyWaveform = std::array<AudioLogger::Frame, kBufferSizeTrain_frames>;\n\n    TKey keyPressed = -1;\n    std::map<TKey, TKeyWaveform> keySoundAverageAmpl;\n    std::map<TKey, TKeyWaveform> keySoundAverageFreq;\n\n    std::vector<float> similarityForOffset(4*kSamplesPerFrame);\n\n    AudioLogger audioLogger;\n    AudioLogger::Callback cbAudio = [&](const AudioLogger::Record & framesOriginal) {\n        //auto t1 = std::chrono::high_resolution_clock::now();\n        //printf(\"Received: %d\\n\", (int) std::chrono::duration_cast<std::chrono::milliseconds>(t1 - t0).count());\n\n        auto frames = framesOriginal;\n\n        int nFrames = frames.size();\n        bool exist = keySoundAverageAmpl.find(keyPressed) != keySoundAverageAmpl.end();\n        exist = false;\n        if (exist) {\n            int kmax = 0;\n            int imax = 0;\n            float amax = 0.0f;\n\n            int n = kSamplesPerFrame;\n            for (int k = 0; k < nFrames; ++k) {\n                auto & curFrame = frames[k];\n                for (int i = 0; i < n; ++i) {\n                    float a = std::abs(curFrame[i]);\n                    if (a > amax) {\n                        kmax = k;\n                        imax = i;\n                        amax = a;\n                    }\n                }\n            }\n\n            int besto = 0;\n            float bestcc = 0.0f;\n            float bestccq = 0.0f;\n            float bestccp = 0.0f;\n\n            std::fill(similarityForOffset.begin(), similarityForOffset.end(), 0);\n\n            for (int o = -n; o < n; ++o) {\n                int w = n;\n\n                int s00 = kmax*n + imax - w;\n                int s01 = kmax*n + imax + w;\n                if (s00 < 0 || s01 >= nFrames*n) continue;\n\n                int s10 = kmax*n + imax + o - w;\n                int s11 = kmax*n + imax + o + w;\n                if (s10 < 0 || s11 >= nFrames*n) continue;\n\n                float cc = 0.0f;\n                float ccq = 0.0f;\n                float ccp = 0.0f;\n\n                float suma = 0.0f, suma2 = 0.0f, sumb = 0.0f, sumb2 = 0.0f, sumab = 0.0f;\n                float sumaq = 0.0f, suma2q = 0.0f, sumabq = 0.0f;\n                float sumap = 0.0f, suma2p = 0.0f, sumabp = 0.0f;\n                for (int s0 = s00; s0 < s01; ++s0) {\n                    int k0 = s0/n;\n                    int i0 = s0%n;\n\n                    int s1 = s0 + o;\n                    int k1 = s1/n;\n                    int i1 = s1%n;\n\n                    sumb += frames[k1][i1];\n                    sumb2 += frames[k1][i1]*frames[k1][i1];\n\n                    suma += keySoundAverageAmpl[keyPressed][k0][i0];\n                    suma2 += keySoundAverageAmpl[keyPressed][k0][i0]*keySoundAverageAmpl[keyPressed][k0][i0];\n                    sumab += frames[k1][i1]*keySoundAverageAmpl[keyPressed][k0][i0];\n                    sumaq += keySoundAverageAmpl['q'][k0][i0];\n                    suma2q += keySoundAverageAmpl['q'][k0][i0]*keySoundAverageAmpl['q'][k0][i0];\n                    sumabq += frames[k1][i1]*keySoundAverageAmpl['q'][k0][i0];\n                    sumap += keySoundAverageAmpl['p'][k0][i0];\n                    suma2p += keySoundAverageAmpl['p'][k0][i0]*keySoundAverageAmpl['p'][k0][i0];\n                    sumabp += frames[k1][i1]*keySoundAverageAmpl['p'][k0][i0];\n\n                    //cc += frames[k1][i1]*keySoundAverageAmpl[keyPressed][k0][i0];\n                    //ccq += frames[k1][i1]*keySoundAverageAmpl['q'][k0][i0];\n                    //ccp += frames[k1][i1]*keySoundAverageAmpl['p'][k0][i0];\n                }\n\n                int ncc = s01 - s00;\n                {\n                    float nom = sumab*ncc - suma*sumb;\n                    float den2a = suma2*ncc - suma*suma;\n                    float den2b = sumb2*ncc - sumb*sumb;\n                    cc = (nom)/(sqrt(den2a*den2b));\n                }\n\n                {\n                    float nom = sumabq*ncc - sumaq*sumb;\n                    float den2a = suma2q*ncc - sumaq*sumaq;\n                    float den2b = sumb2*ncc - sumb*sumb;\n                    ccq = (nom)/(sqrt(den2a*den2b));\n                }\n\n                {\n                    float nom = sumab*ncc - sumap*sumb;\n                    float den2a = suma2p*ncc - sumap*sumap;\n                    float den2b = sumb2*ncc - sumb*sumb;\n                    ccp = (nom)/(sqrt(den2a*den2b));\n                }\n\n                similarityForOffset[o + 2*n] = cc;\n\n                if (cc > bestcc) {\n                    besto = o;\n                    bestcc = cc;\n                }\n\n                if (ccq > bestccq) {\n                    bestccq = ccq;\n                }\n\n                if (ccp > bestccp) {\n                    bestccp = ccp;\n                }\n            }\n\n            printf(\"besto = %d\\n\", besto);\n            printf(\"more similar to '%c'\\n\", (bestccq > bestccp) ? 'q' : 'p');\n\n            if (besto > 0) {\n                for (int s0 = 0; s0 < nFrames*n; ++s0) {\n                    int k0 = s0/n;\n                    int i0 = s0%n;\n\n                    int s1 = s0 + besto;\n                    int k1 = s1/n;\n                    int i1 = s1%n;\n                    frames[k0][i0] = s1 < nFrames*n ? frames[k1][i1] : 0.0f;\n                }\n            } else {\n                for (int s0 = nFrames*n - 1; s0 >= 0; --s0) {\n                    int k0 = s0/n;\n                    int i0 = s0%n;\n\n                    int s1 = s0 + besto;\n                    int k1 = s1/n;\n                    int i1 = s1%n;\n                    frames[k0][i0] = s1 >= 0 ? frames[k1][i1] : 0.0f;\n                }\n            }\n        }\n\n        std::lock_guard<std::mutex> lock(mutex);\n\n        int fid = 0;\n        auto & buffersAmpl = keySoundAverageAmpl[keyPressed];\n        auto & buffersFreq = keySoundAverageFreq[keyPressed];\n        for (int k = 0; k < nFrames; ++k) {\n            for (auto i = 0; i < kSamplesPerFrame; ++i) {\n                buffersAmpl[fid][i] = frames[k][i];\n                fftIn[i][0] = buffersAmpl[fid][i];\n                fftIn[i][1] = 0;\n            }\n            fftwf_execute(fftPlan);\n            for (auto i = 0; i < kSamplesPerFrame; ++i) {\n                buffersFreq[fid][i] = fftOut[i][0]*fftOut[i][0] + fftOut[i][1]*fftOut[i][1];\n            }\n            for (auto i = 1; i < kSamplesPerFrame/2; ++i) {\n                buffersFreq[fid][i] += buffersFreq[fid][kSamplesPerFrame - i];\n            }\n\n            if (++fid >= (int) buffersAmpl.size()) break;\n        }\n\n        keyPressed = -1;\n    };\n\n    AudioLogger::Parameters parameters;\n    parameters.callback = std::move(cbAudio);\n    parameters.captureId = captureId;\n    parameters.nChannels = nChannels;\n    parameters.sampleRate = kSampleRate;\n    parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n    if (audioLogger.install(std::move(parameters)) == false) {\n        fprintf(stderr, \"Failed to install audio logger\\n\");\n        return -1;\n    }\n\n    bool done = false;\n\n    // Main loop\n    while (!done) {\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            switch (event.type) {\n                case SDL_KEYDOWN:\n                    if (keyPressed == -1) {\n                        //auto t1 = std::chrono::high_resolution_clock::now();\n                        //printf(\"Event: %d\\n\", (int) std::chrono::duration_cast<std::chrono::milliseconds>(t1 - t0).count());\n                        keyPressed = event.key.keysym.sym;\n                        audioLogger.record(kBufferSizeTrain_s, 3);\n                    }\n                    break;\n                case SDL_QUIT:\n                    done = true;\n                    break;\n                case SDL_WINDOWEVENT:\n                    if (event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(window)) done = true;\n                    break;\n            };\n        }\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplSDL2_NewFrame(window);\n        ImGui::NewFrame();\n\n        ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_Once);\n        ImGui::SetNextWindowSize(ImVec2(windowSizeX, windowSizeY), ImGuiCond_Once);\n        ImGui::Begin(\"Average Key Waveform\");\n        ImGui::Text(\"Frames in buffer: %d\\n\", (int) kBufferSizeTrain_frames);\n        {\n            std::lock_guard<std::mutex> lock(mutex);\n\n            ImGui::PlotLines(\n                \"##Similarity for offset\",\n                similarityForOffset.data(), similarityForOffset.size(),\n                0, \"Similarity for offset\", FLT_MAX, FLT_MAX, ImVec2(windowSizeX, 0.1f*windowSizeY));\n\n            for (const auto & ampl : keySoundAverageAmpl) {\n                struct SampleGetter {\n                    static float f(void * data, int i) {\n                        int fid = i/kSamplesPerFrame;\n                        int sid = i - fid*kSamplesPerFrame;\n                        const auto & frames = *(TKeyWaveform *)(data);\n                        const auto & frame = frames[fid];\n                        return frame[sid];\n                    }\n                };\n\n                float (*getter)(void *, int) = SampleGetter::f;\n\n                std::string skey(\" \");\n                skey[0] = ampl.first;\n                ImGui::PlotLines(\n                    (\"##\" + skey).c_str(),\n                    getter, (void *)(intptr_t)(&ampl.second), ampl.second.size()*kSamplesPerFrame,\n                    0, skey.c_str(), FLT_MAX, FLT_MAX, ImVec2(windowSizeX, 0.1f*windowSizeY));\n\n                int nFrames = keySoundAverageFreq[ampl.first].size();\n                for (int fid = 0; fid < (int) keySoundAverageFreq[ampl.first].size(); ++fid) {\n                    const auto & freq = keySoundAverageFreq[ampl.first][fid];\n                    ImGui::PlotHistogram(\n                        (\"##\" + skey + \" frame \" + std::to_string(fid)).c_str(),\n                        freq.data(), freq.size()/2,\n                        0, (\"frame \" + std::to_string(fid)).c_str(), 0.0f, 50.0f, ImVec2(0.95f*windowSizeX/nFrames, 0.1f*windowSizeY));\n                    ImGui::SameLine();\n                }\n                ImGui::Text(\"%s\", \"\");\n            }\n        }\n        ImGui::End();\n\n        ImGui::Render();\n        SDL_GL_MakeCurrent(window, gl_context);\n        glViewport(0, 0, (int) io.DisplaySize.x, (int) io.DisplaySize.y);\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n        SDL_GL_SwapWindow(window);\n    }\n\n    // Cleanup\n    if (fftPlan) fftwf_destroy_plan(fftPlan);\n    if (fftIn) fftwf_free(fftIn);\n    if (fftOut) fftwf_free(fftOut);\n\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplSDL2_Shutdown();\n    ImGui::DestroyContext();\n\n    SDL_GL_DeleteContext(gl_context);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n\n    return 0;\n}\n"
        },
        {
          "name": "key-detector.cpp",
          "type": "blob",
          "size": 3.33984375,
          "content": "/*! \\file key-detector.cpp\n *  \\brief Capture audio until N keystrokes are detected\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"audio-logger.h\"\n\n#include <array>\n#include <cmath>\n#include <cstdio>\n#include <chrono>\n#include <thread>\n#include <fstream>\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s output.kbd nkeys [-cN] [-CN]\\n\", argv[0]);\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - number N of capture channels N\\n\");\n    printf(\"\\n\");\n\n    if (argc < 3) {\n        return -127;\n    }\n\n    const auto argm = parseCmdArguments(argc, argv);\n    const int captureId = argm.count(\"c\") == 0 ? 0 : std::stoi(argm.at(\"c\"));\n    const int nChannels = argm.count(\"C\") == 0 ? 0 : std::stoi(argm.at(\"C\"));\n\n    const int nKeysToCapture = atoi(argv[2]);\n\n    int nKeysHave = 0;\n    bool doRecord = true;\n    bool doneRecording = false;\n    size_t totalSize_bytes = 0;\n\n    TWaveformF waveformF;\n    TWaveformI16 waveformI16;\n    TKeyPressCollectionT<TSampleI16> keyPresses;\n\n    AudioLogger audioLogger;\n\n    AudioLogger::Callback cbAudio = [&](const auto & frames) {\n        for (auto & frame : frames) {\n            waveformF.insert(waveformF.end(), frame.begin(), frame.end());\n        }\n\n        {\n            // apply default filtering, because keypress detection without it is impossible\n            auto waveformFFiltered = waveformF;\n            ::filter(waveformFFiltered, EAudioFilter::FirstOrderHighPass, kFreqCutoff_Hz, kSampleRate);\n\n            if (convert(waveformFFiltered, waveformI16) == false) {\n                printf(\"Conversion failed\\n\");\n            }\n        }\n\n        TWaveformI16 waveformMax;\n        TWaveformI16 waveformThreshold;\n        if (findKeyPresses(getView(waveformI16, 0), keyPresses, waveformThreshold, waveformMax, 8.0, 512, 2*1024, true) == false) {\n            printf(\"Failed to detect keypresses\\n\");\n        }\n\n        if (nKeysHave < (int) keyPresses.size()) {\n            nKeysHave = keyPresses.size();\n            printf(\"Detected %d keys\\n\", nKeysHave);\n        }\n\n        if (nKeysToCapture <= (int) keyPresses.size()) {\n            doneRecording = true;\n        } else {\n            doRecord = true;\n        }\n    };\n\n    AudioLogger::Parameters parameters;\n    parameters.callback = std::move(cbAudio);\n    parameters.captureId = captureId;\n    parameters.nChannels = nChannels;\n    parameters.sampleRate = kSampleRate;\n    parameters.filter = EAudioFilter::None;\n    //parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n    if (audioLogger.install(std::move(parameters)) == false) {\n        fprintf(stderr, \"Failed to install audio logger\\n\");\n        return -1;\n    }\n\n    while (true) {\n        if (doRecord) {\n            doRecord = false;\n            audioLogger.record(0.5f, 0);\n        } else {\n            std::this_thread::sleep_for(std::chrono::milliseconds(1));\n        }\n\n        if (doneRecording) break;\n    }\n\n    printf(\"\\n\\n Done recording\\n\");\n\n    std::ofstream fout(argv[1], std::ios::binary);\n    if (fout.good() == false) {\n        fprintf(stderr, \"Failed to open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n\n    totalSize_bytes = sizeof(waveformF[0])*waveformF.size();\n    fout.write((char *)(waveformF.data()), sizeof(waveformF[0])*waveformF.size());\n    fout.close();\n\n    printf(\"Total data saved: %g MB\\n\", ((float)(totalSize_bytes)/1024.0f/1024.0f));\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap-gui.cpp",
          "type": "blob",
          "size": 39.4111328125,
          "content": "/*! \\file guess_all_gui.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#ifdef __EMSCRIPTEN__\n#include \"emscripten.h\"\n#else\n#define EMSCRIPTEN_KEEPALIVE\n#endif\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"common-gui.h\"\n#include \"audio-logger.h\"\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#include <SDL.h>\n\n#include <map>\n#include <mutex>\n#include <cmath>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <vector>\n#include <deque>\n#include <fstream>\n\n//#define MY_DEBUG\n//#define OUTPUT_WAVEFORMS\n\n// constants\n\nstatic const std::vector<float> kRowOffset = { 0.0f, 1.5f, 1.8f, 2.1f, 5.5f };\nstatic const std::vector<std::vector<int>> kKeyboard = {\n    { '`', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 127},\n    { 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\\\', },\n    { 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\\'', '\\n' },\n    { 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', },\n    { ' ', },\n};\n\n// types\n\nstruct TrainStats {\n    int nWaveformsUsed = 0;\n    int nWaveformsTotal = 0;\n    TValueCC averageCC = 0.0f;\n};\n\n// globals\n\nstatic bool g_isInitialized = false;\n\nstatic std::function<int()> g_init;\nstatic std::function<void()> g_update;\nstatic std::function<bool()> g_mainUpdate;\nstatic std::function<void(int)> g_handleKey;\n\nint init() {\n    if (g_isInitialized) return 1;\n\n    return g_init();\n}\n\nvoid update() {\n    if (g_isInitialized == false) return;\n\n    g_update();\n}\n\nvoid mainUpdate(void *) {\n    g_mainUpdate();\n}\n\n// JS interface\nextern \"C\" {\n    EMSCRIPTEN_KEEPALIVE\n        int doInit() {\n            return init();\n        }\n\n    EMSCRIPTEN_KEEPALIVE\n        void keyPressedCallback(int key) {\n            g_handleKey(key);\n        }\n}\n\nint main(int argc, char ** argv) {\n\tprintf(\"hardware_concurrency = %d\\n\", (int) std::thread::hardware_concurrency());\n\n    printf(\"Usage: %s input.kbd [input2.kbd ...] [-cN] [-CN]\\n\", argv[0]);\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - select number N of capture channels to use\\n\");\n    printf(\"\\n\");\n\n    if (argc < 2) {\n#ifndef __EMSCRIPTEN__\n        return -127;\n#endif\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int captureId = argm[\"c\"].empty() ? 0 : std::stoi(argm[\"c\"]);\n    int nChannels = argm[\"C\"].empty() ? 0 : std::stoi(argm[\"C\"]);\n\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) != 0) {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    std::ifstream frecord;\n    std::map<int, std::ifstream> fins;\n    for (int i = 0; i < argc - 1; ++i) {\n        if (argv[i + 1][0] == '-') continue;\n        printf(\"Opening file '%s'\\n\", argv[i + 1]);\n        fins[i] = std::ifstream(argv[i + 1], std::ios::binary);\n        if (fins[i].good() == false) {\n            printf(\"Failed to open input file: '%s'\\n\", argv[i + 1]);\n            return -2;\n        }\n\n        {\n            int bufferSize_frames = 1;\n            fins[i].read((char *)(&bufferSize_frames), sizeof(bufferSize_frames));\n            if (bufferSize_frames != kBufferSizeTrain_frames) {\n                printf(\"Buffer size in file (%d) does not match the expected one (%d)\\n\", bufferSize_frames, (int) kBufferSizeTrain_frames);\n                return -1;\n            }\n        }\n    }\n\n#ifdef __EMSCRIPTEN__\n    int windowSizeX = 740;\n    int windowSizeY = 700;\n#else\n    int windowSizeX = 800;\n    int windowSizeY = 900;\n#endif\n\n    Gui::Objects guiObjects;\n    if (Gui::init(\"View-full\", windowSizeX, windowSizeY, guiObjects) == false) {\n        return -6;\n    }\n\n    TKey keyPressed = -1;\n    TKeyConfidenceMap keyConfidence;\n    TKeyConfidenceMap keyConfidenceDisplay;\n    std::map<TKey, TKeyHistoryF> keySoundHistoryAmpl;\n    std::map<TKey, TKeyWaveformF> keySoundAverageAmpl;\n\n    int ntest = 0;\n\n    bool doRecord = false;\n    bool isReadyToPredict = false;\n    bool processingInput = true;\n    bool processingRecord = false;\n    bool finishApp = false;\n    bool waitForQueueDuringPlayback = true;\n\n    int curFile = 0;\n\n    int predictedKey = -1;\n    TKeyWaveformF predictedAmpl(kSamplesPerWaveformTrain, 0);\n    int predictedHistoryBegin = 0;\n    std::array<std::vector<int>, 24> predictedHistory;\n    predictedHistory.fill({});\n    std::map<TKey, TrainStats> trainStats;\n\n    float amplMin = 0.0f;\n    float amplMax = 0.0f;\n    float thresholdCC = 0.35f;\n    float thresholdBackground = 10.0f;\n    TValueCC predictedCC = -1.0f;\n    auto tLastDetectedKeyStroke = std::chrono::high_resolution_clock::now();\n\n    // ring buffer\n    int rbBegin = 0;\n    double rbAverage = 0.0f;\n    std::array<double, kBkgrRingBufferSize> rbSamples;\n    rbSamples.fill(0.0f);\n\n    // Train data\n    bool isAcquiringTrainData = (argc == 1) ? true : false;\n    std::map<int, int> nTimes;\n    size_t totalSize_bytes = 0;\n    std::ofstream foutTrain(\"train_default.kbd\", std::ios::binary);\n    {\n        int x = kBufferSizeTrain_frames;\n        foutTrain.write((char *)(&x), sizeof(x));\n    }\n\n    AudioLogger audioLogger;\n\n    struct WorkData {\n        TKeyWaveformF ampl;\n        std::vector<int> positionsToPredict;\n    };\n\n    std::mutex mutex;\n    std::deque<WorkData> workQueue;\n    std::thread worker([&]() {\n        int lastkey = -1;\n        double lastcc = -1.0f;\n\n        while (finishApp == false) {\n            bool process = false;\n            WorkData workData;\n            {\n                std::lock_guard<std::mutex> lock(mutex);\n                while (workQueue.size() > 30 && processingRecord == false) {\n                    workQueue.pop_front();\n                    printf(\"pop\\n\");\n                }\n\n                if (workQueue.size() > 0) {\n                    workData = std::move(workQueue.front());\n                    workQueue.pop_front();\n                    process = true;\n                }\n            }\n            if (process) {\n                const auto & ampl = workData.ampl;\n                const auto & positionsToPredict = workData.positionsToPredict;\n\n                int alignWindow = 0.10*kSamplesPerWaveformTrain;\n\n                for (int ipos = 0; ipos < (int) positionsToPredict.size() ; ++ipos) {\n                    auto curPos = positionsToPredict[ipos];\n                    int scmp0 = curPos - 0.25*kSamplesPerWaveformTrain;\n                    int scmp1 = curPos + 0.25*kSamplesPerWaveformTrain;\n\n                    char res = -1;\n                    TValueCC maxcc = -1.0f;\n                    TOffset offs = 0;\n                    TKeyConfidenceMap keyConfidenceTmp;\n                    for (const auto & ka : keySoundAverageAmpl) {\n                        //auto [bestcc, bestoffset] = findBestCC(keySoundAverageAmpl[ka.first], ampl, scmp0, scmp1, alignWindow);\n                        auto ret = findBestCC(keySoundAverageAmpl[ka.first], ampl, scmp0, scmp1, alignWindow);\n                        auto bestcc     = std::get<0>(ret);\n                        auto bestoffset = std::get<1>(ret);\n\n                        if (bestcc > maxcc) {\n                            res = ka.first;\n                            maxcc = bestcc;\n                            offs = bestoffset;\n                        }\n                        keyConfidenceTmp[ka.first] = bestcc;\n                    }\n\n                    if (maxcc > thresholdCC) {\n                        if (lastkey != res || lastcc != maxcc) {\n                            printf(\"    Prediction: '%c'        (%8.5g), ntest = %d\\n\", res, maxcc, ntest);\n                            predictedKey = res;\n                            predictedCC = maxcc;\n                            predictedHistory[predictedHistoryBegin].clear();\n                            predictedHistory[predictedHistoryBegin].push_back(predictedKey);\n                            for (auto & c : keyConfidenceTmp) {\n                                keyConfidence[c.first] = c.second/maxcc;\n                                keyConfidenceDisplay[c.first] = std::pow(c.second/maxcc, 4.0f);\n                                if (c.first != predictedKey && c.second/maxcc > 0.9f) {\n                                    predictedHistory[predictedHistoryBegin].push_back(c.first);\n                                }\n                            }\n                            if (++predictedHistoryBegin >= (int) predictedHistory.size()) predictedHistoryBegin = 0;\n                            std::fill(predictedAmpl.begin(), predictedAmpl.end(), 0);\n                            for (int i = 0; i < kSamplesPerWaveformTrain; ++i) {\n                                int idx = curPos + offs - kSamplesPerWaveformTrain/2 + i;\n                                if (idx < 0 || idx >= (int) ampl.size()) continue;\n                                predictedAmpl[i] = ampl[idx];\n                            }\n                        }\n                        lastkey = res;\n                        lastcc = maxcc;\n                    }\n                    ++ntest;\n                }\n\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(1));\n            }\n        }\n    });\n\n    AudioLogger::Callback cbAudio = [&](const AudioLogger::Record & frames) {\n        if (isAcquiringTrainData) {\n            foutTrain.write((char *)(&keyPressed), sizeof(keyPressed));\n            for (const auto & frame : frames) {\n                totalSize_bytes += sizeof(frame[0])*frame.size();\n                foutTrain.write((char *)(frame.data()), sizeof(frame[0])*frame.size());\n                foutTrain.flush();\n            }\n            ++nTimes[keyPressed];\n\n            printf(\"Last recorded key - %3d '%s'. Total times recorded so far - %3d. Total data saved: %g MB\\n\",\n                   keyPressed, kKeyText.at(keyPressed), nTimes[keyPressed], ((float)(totalSize_bytes)/1024.0f/1024.0f));\n\n            keyPressed = -1;\n            return;\n        }\n\n        if (frames.size() != kBufferSizeTrain_frames && isReadyToPredict == false) {\n            printf(\"Unexpected number of frames - %d, expected - %d. Should never happen\\n\",\n                   (int) frames.size(), (int) kBufferSizeTrain_frames);\n            return;\n        }\n\n        const int nFrames = frames.size();\n\n        if (isReadyToPredict) {\n\n            std::vector<int> positionsToPredict;\n\n            {\n                float amax = 0.0f;\n                for (int f = 0; f < (int) frames.size(); ++f) {\n                    for (int s = 0; s < (int) frames[f].size(); s += kBkgrStep_samples) {\n                        rbAverage *= rbSamples.size();\n                        rbAverage -= rbSamples[rbBegin];\n                        auto acur = std::abs(frames[f][s]);\n                        rbSamples[rbBegin] = acur;\n                        if (acur > amax) amax = acur;\n                        rbAverage += acur;\n                        rbAverage /= rbSamples.size();\n                        if (++rbBegin >= (int) rbSamples.size()) rbBegin = 0;\n                    }\n                }\n\n                int nFrames = frames.size();\n\n                auto _acc = [](const AudioLogger::Record & r, int id) { return std::abs(r[id/kSamplesPerFrame][id%kSamplesPerFrame]); };\n\n                int k = kSamplesPerFrame;\n                std::deque<int> que(k);\n                for (int i = 0; i < nFrames*kSamplesPerFrame; ++i) {\n                    if (i < k) {\n                        while((!que.empty()) && _acc(frames, i) >= _acc(frames, que.back())) {\n                            que.pop_back();\n                        }\n                        que.push_back(i);\n                    } else {\n                        while((!que.empty()) && que.front() <= i - k) {\n                            que.pop_front();\n                        }\n\n                        while((!que.empty()) && _acc(frames, i) >= _acc(frames, que.back())) {\n                            que.pop_back();\n                        }\n\n                        que.push_back(i);\n\n                        int itest = i - k/2;\n                        if (itest >= (0.5*kSamplesPerWaveformTrain - 0.50*kSamplesPerFrame) && itest < (0.5*kSamplesPerWaveformTrain + 0.5*kSamplesPerFrame) && que.front() == itest) {\n                            auto acur = _acc(frames, itest);\n                            if (acur > thresholdBackground*rbAverage){\n                                positionsToPredict.push_back(itest);\n                                tLastDetectedKeyStroke = std::chrono::high_resolution_clock::now();\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (positionsToPredict.size() > 0) {\n                WorkData workData;\n                auto & ampl = workData.ampl;\n                ampl.resize(nFrames*kSamplesPerFrame);\n                for (int k = 0; k < nFrames; ++k) {\n                    std::copy(frames[k].begin(), frames[k].end(), ampl.begin() + k*kSamplesPerFrame);\n                }\n                workData.positionsToPredict = positionsToPredict;\n\n                {\n                    std::lock_guard<std::mutex> lock(mutex);\n                    workQueue.push_back(std::move(workData));\n                }\n            }\n\n            doRecord = true;\n        } else {\n            auto & history = keySoundHistoryAmpl[keyPressed];\n            history.push_back(TKeyWaveformF());\n            auto & ampl = history.back();\n            ampl.resize(nFrames*kSamplesPerFrame);\n            for (int k = 0; k < nFrames; ++k) {\n                std::copy(frames[k].begin(), frames[k].end(), ampl.begin() + k*kSamplesPerFrame);\n            }\n        }\n\n        keyPressed = -1;\n    };\n\n    g_init = [&]() {\n        AudioLogger::Parameters parameters;\n        parameters.callback = cbAudio;\n        parameters.captureId = captureId;\n        parameters.nChannels = nChannels;\n        parameters.sampleRate = kSampleRate;\n        parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n        if (audioLogger.install(std::move(parameters)) == false) {\n            fprintf(stderr, \"Failed to install audio logger\\n\");\n            return -1;\n        }\n\n        printf(\"[+] Collecting training data\\n\");\n        g_isInitialized = true;\n        return 0;\n    };\n\n    g_handleKey = [&](int key) {\n        if (keyPressed == -1 && isReadyToPredict == false) {\n            predictedKey = -1;\n            keyPressed = key;\n            audioLogger.record(kBufferSizeTrain_s, 2);\n        }\n    };\n\n    g_update = [&]() {\n        if (isAcquiringTrainData) {\n            return;\n        }\n\n        if (processingInput) {\n            if (keyPressed == -1) {\n                AudioLogger::Frame frame;\n                AudioLogger::Record record;\n                fins[curFile].read((char *)(&keyPressed), sizeof(keyPressed));\n                if (fins[curFile].eof()) {\n                    ++curFile;\n                    if (curFile >= (int) fins.size()) {\n                        processingInput = false;\n                    }\n                } else {\n                    printf(\"%c\", keyPressed);\n                    fflush(stdout);\n                    for (int i = 0; i < kBufferSizeTrain_frames; ++i) {\n                        fins[curFile].read((char *)(frame.data()), sizeof(AudioLogger::Sample)*frame.size());\n                        record.push_back(frame);\n                    }\n                    cbAudio(record);\n                }\n            }\n            return;\n        }\n\n        if (processingRecord) {\n            if (frecord.eof()) {\n                if (workQueue.size() == 0) {\n                    printf(\"[+] Done. Continuing capturing microphone audio \\n\");\n                    processingRecord = false;\n                    audioLogger.resume();\n                }\n\n                return;\n            }\n            if (keyPressed == -1 && ((waitForQueueDuringPlayback == false) || (waitForQueueDuringPlayback && workQueue.size() < 3))) {\n                AudioLogger::Frame frame;\n                static AudioLogger::Record record;\n                keyPressed = 32;\n                int nRead = kBufferSizeTrain_frames;\n                if (record.size() > kBufferSizeTrain_frames - 1) {\n                    record.erase(record.begin());\n                    nRead = 1;\n                }\n                for (int i = 0; i < nRead; ++i) {\n                    frecord.read((char *)(frame.data()), sizeof(AudioLogger::Sample)*frame.size());\n                    if (frecord.eof()) {\n                        printf(\"[+] Waiting for work queue to get processed. Remaining jobs = %d \\n\", (int) workQueue.size());\n                        record.clear();\n                        break;\n                    } else {\n                        record.push_back(frame);\n                    }\n                }\n                if (record.size() == kBufferSizeTrain_frames) {\n                    cbAudio(record);\n                } else {\n                    printf(\"    Skipping partial buffer of size %d frames\\n\", (int) record.size());\n                }\n            }\n            return;\n        }\n\n        if (isReadyToPredict == false) {\n            printf(\"[+] Training\\n\");\n\n            std::vector<TKey> failedToTrain;\n\n            auto trainKey = [&](TKey key) {\n                auto & history = keySoundHistoryAmpl[key];\n\n                int nWaveforms = history.size();\n                int nFramesPerWaveform = kBufferSizeTrain_frames;\n\n                printf(\"    - Training key '%c'\\n\", key);\n                printf(\"    - History size = %d key waveforms\\n\", nWaveforms);\n                printf(\"    - Frames per key waveform   = %d\\n\", nFramesPerWaveform);\n                printf(\"    - Total frames available    = %d\\n\", nWaveforms*nFramesPerWaveform);\n                printf(\"    - Samples per frame         = %d\\n\", (int) kSamplesPerFrame);\n                printf(\"    - Total samples available   = %d\\n\", (int) (nWaveforms*nFramesPerWaveform*kSamplesPerFrame));\n\n                printf(\"    - Estimating waveform peaks ...\\n\");\n                std::vector<int> peakSum;\n                std::vector<int> peakMax;\n\n                peakSum.clear();\n                peakMax.clear();\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int isum = -1;\n                    double asum = 0.0f;\n                    double aisum = 0.0f;\n\n                    int imax = -1;\n                    double amax = 0.0f;\n\n                    const auto & waveform = history[iwaveform];\n\n                    for (int icur = 0; icur < kSamplesPerWaveformTrain; ++icur) {\n                        double acur = std::abs(waveform[icur]);\n                        double acur2 = acur*acur;\n\n                        asum += acur2;\n                        aisum += acur2*icur;\n\n                        if (acur > amax) {\n                            amax = acur;\n                            imax = icur;\n                        }\n                    }\n\n                    isum = aisum/asum;\n\n                    peakSum.push_back(isum);\n                    peakMax.push_back(imax);\n                    //printf(\"        Estimated peak: %d (method - sum), %d (method - max)\\n\", isum, imax);\n                }\n\n                auto calcStdev = [](const std::vector<int> & data) {\n                    double sum = 0.0f;\n                    double sum2 = 0.0f;\n                    for (const auto & p : data) {\n                        int64_t v = p;\n                        sum += v;\n                        sum2 += v*v;\n                    }\n                    sum /= data.size();\n                    sum2 /= data.size();\n                    return sqrt(sum2 - sum*sum);\n                };\n\n                double stdevSum = calcStdev(peakSum);\n                double stdevMax = calcStdev(peakMax);\n\n                printf(\"    - Stdev of estimated peaks: %g (sum) vs %g (max)\\n\", stdevSum, stdevMax);\n\n                const auto & peakUsed = peakMax;\n                printf(\"    - Using 'max' estimation\\n\");\n\n                int centerSample = kSamplesPerWaveformTrain/2;\n\n                printf(\"    - Centering waveforms at sample %d\\n\", centerSample);\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int offset = peakUsed[iwaveform] - centerSample;\n                    //printf(\"        Offset for waveform %-4d = %-4d\\n\", iwaveform, offset);\n\n                    auto newWaveform = TKeyWaveformF();\n                    newWaveform.resize(kSamplesPerWaveformTrain);\n                    auto & waveform = history[iwaveform];\n                    for (int icur = 0; icur < kSamplesPerWaveformTrain; ++icur) {\n                        int iorg = icur + offset;\n\n                        if (iorg >= 0 && iorg < kSamplesPerWaveformTrain) {\n                            newWaveform[icur] = waveform[iorg];\n                        } else {\n                            newWaveform[icur] = 0.0f;\n                        }\n                    }\n\n                    waveform = std::move(newWaveform);\n                }\n\n                int alignWindow = 0.025*kSamplesPerWaveformTrain;\n                printf(\"    - Calculating CC pairs\\n\");\n                printf(\"      Align window = %d\\n\", alignWindow);\n\n                int bestw = -1;\n                int ntrain = 0;\n                double bestccsum = -1.0f;\n                //double bestosum = 1e10;\n                std::map<int, std::map<int, std::tuple<TValueCC, TOffset>>> ccs;\n\n                for (int alignToWaveform = 0; alignToWaveform < nWaveforms; ++alignToWaveform) {\n                    ccs[alignToWaveform][alignToWaveform] = std::tuple<TValueCC, TOffset>(1.0f, 0);\n\n                    int is0 = centerSample - 0.25*kSamplesPerWaveformTrain;\n                    int is1 = centerSample + 0.25*kSamplesPerWaveformTrain;\n\n                    const auto & waveform0 = history[alignToWaveform];\n\n                    for (int iwaveform = alignToWaveform + 1; iwaveform < nWaveforms; ++iwaveform) {\n                        const auto & waveform1 = history[iwaveform];\n                        //auto [bestcc, bestoffset] = findBestCC(waveform0, waveform1, is0, is1, alignWindow);\n                        auto ret = findBestCC(waveform0, waveform1, is0, is1, alignWindow);\n                        auto bestcc     = std::get<0>(ret);\n                        auto bestoffset = std::get<1>(ret);\n\n                        ccs[iwaveform][alignToWaveform] = std::tuple<TValueCC, TOffset>(bestcc, bestoffset);\n                        ccs[alignToWaveform][iwaveform] = std::tuple<TValueCC, TOffset>(bestcc, -bestoffset);\n                    }\n\n                    int curntrain = 0;\n                    double curccsum = 0.0;\n                    double curosum = 0.0;\n                    for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                        //auto [cc, offset] = ccs[iwaveform][alignToWaveform];\n                        auto cc     = std::get<0>(ccs[iwaveform][alignToWaveform]);\n                        auto offset = std::get<1>(ccs[iwaveform][alignToWaveform]);\n\n                        if (std::abs(offset) > 0.1*kSamplesPerWaveformTrain) continue;\n                        ++curntrain;\n                        curccsum += cc*cc;\n                        curosum += offset*offset;\n                    }\n\n                    if (curccsum > bestccsum) {\n                    //if (curosum < bestosum) {\n                        ntrain = curntrain;\n                        bestw = alignToWaveform;\n                        bestccsum = curccsum;\n                        //bestosum = curosum;\n                    }\n                }\n                bestccsum = sqrt(bestccsum/ntrain);\n\n                trainStats[key].nWaveformsUsed = ntrain;\n                trainStats[key].nWaveformsTotal = nWaveforms;\n                trainStats[key].averageCC = bestccsum;\n\n                printf(\"    - Aligning all waveforms to waveform %d, (cost = %g)\\n\", bestw, bestccsum);\n#ifdef OUTPUT_WAVEFORMS\n                std::ofstream fout(std::string(\"waveform_one_\") + std::to_string(key) + \".plot\");\n                for (auto & v : history[bestw]) fout << v << std::endl;\n                fout << std::endl;\n#endif\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    if (iwaveform == bestw) continue;\n\n                    auto & waveform1 = history[iwaveform];\n                    //auto [cc, offset] = ccs[iwaveform][bestw];\n                    //auto cc     = std::get<0>(ccs[iwaveform][bestw]);\n                    auto offset = std::get<1>(ccs[iwaveform][bestw]);\n\n                    auto newWaveform = TKeyWaveformF();\n                    newWaveform.resize(kSamplesPerWaveformTrain);\n                    for (int icur = 0; icur < kSamplesPerWaveformTrain; ++icur) {\n                        int iorg = icur + offset;\n\n                        if (iorg >= 0 && iorg < kSamplesPerWaveformTrain) {\n                            newWaveform[icur] = waveform1[iorg];\n                        } else {\n                            newWaveform[icur] = 0.0f;\n                        }\n                    }\n\n                    waveform1 = std::move(newWaveform);\n#ifdef OUTPUT_WAVEFORMS\n                    for (auto & v : waveform1) fout << v << std::endl;\n                    fout << std::endl;\n#endif\n                }\n\n                printf(\"    - Calculating average waveform\\n\");\n                double ccsum = 0.0f;\n                double norm = 0.0f;\n                auto & avgWaveform = keySoundAverageAmpl[key];\n                avgWaveform.resize(kSamplesPerWaveformTrain);\n                std::fill(avgWaveform.begin(), avgWaveform.end(), 0.0f);\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    //auto [cc, offset] = ccs[iwaveform][bestw];\n                    auto cc     = std::get<0>(ccs[iwaveform][bestw]);\n                    auto offset = std::get<1>(ccs[iwaveform][bestw]);\n\n                    //if (std::abs(offset) > 5) continue;\n                    printf(\"        Adding waveform %d - cc = %g, offset = %d\\n\", iwaveform, cc, (int) offset);\n                    ccsum += cc*cc;\n                    norm += cc*cc;\n                    auto & waveform = history[iwaveform];\n                    for (int is = 0; is < kSamplesPerWaveformTrain; ++is) {\n                        avgWaveform[is] += cc*cc*waveform[is];\n                    }\n                }\n\n                norm = 1.0f/(norm);\n                for (int is = 0; is < kSamplesPerWaveformTrain; ++is) {\n                    avgWaveform[is] *= norm;\n                    if (avgWaveform[is] > amplMax) amplMax = avgWaveform[is];\n                    if (avgWaveform[is] < amplMin) amplMin = avgWaveform[is];\n                }\n\n#ifdef OUTPUT_WAVEFORMS\n                {\n                    std::ofstream fout(std::string(\"waveform_avg_\") + std::to_string(key) + \".plot\");\n                    for (auto & v : avgWaveform) fout << v << std::endl;\n                }\n#endif\n\n                if (ccsum*norm < 0.50f || (1.0f/norm < nWaveforms/3)) {\n                    failedToTrain.push_back(key);\n                }\n\n                printf(\"\\n\");\n            };\n\n            for (const auto & kh : keySoundHistoryAmpl) {\n                if (kh.second.size() > 2) {\n                    trainKey(kh.first);\n                } else {\n                    printf(\"[!] Key '%s' does not have enough training data. Need at least 3 presses\\n\", kKeyText.at(kh.first));\n                    failedToTrain.push_back(kh.first);\n                }\n            }\n            printf(\"Failed to train the following keys: \");\n            for (auto & k : failedToTrain) printf(\"'%c' \", k);\n            printf(\"\\n\");\n            isReadyToPredict = true;\n            doRecord = true;\n\n            amplMax = std::max(amplMax, -amplMin);\n            amplMin = -std::max(amplMax, -amplMin);\n\n            for (auto & kh : keySoundAverageAmpl) {\n                float curAmplMax = 0.0f;\n                for (const auto & v : kh.second) if (std::abs(v) > curAmplMax) curAmplMax = std::abs(v);\n                for (auto & v : kh.second) v = (v/curAmplMax)*amplMax;\n            }\n\n            audioLogger.resume();\n\n            printf(\"[+] Ready to predict. Keep pressing keys and the program will guess which key was pressed\\n\");\n            printf(\"    based on the captured audio from the microphone.\\n\");\n            printf(\"[+] Predicting\\n\");\n        }\n\n        if (doRecord) {\n            doRecord = false;\n            audioLogger.record(kBufferSizeTrain_s, getBufferSize_frames(kSampleRate, kBufferSizeTrain_s) - 1);\n        }\n    };\n\n    g_mainUpdate = [&]() {\n        if (finishApp) return false;\n\n        update();\n\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            switch (event.type) {\n                case SDL_QUIT:\n                    finishApp = true;\n                    break;\n                case SDL_WINDOWEVENT:\n                    if (event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(guiObjects.window)) {\n                        finishApp = true;\n                    }\n                    break;\n            };\n        }\n\n        SDL_GetWindowSize(guiObjects.window, &windowSizeX, &windowSizeY);\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplSDL2_NewFrame(guiObjects.window);\n        ImGui::NewFrame();\n\n        ImGui::SetNextWindowPos(ImVec2(0, 0));\n        ImGui::SetNextWindowSize(ImVec2(windowSizeX, windowSizeY));\n        ImGui::Begin(\"Main\", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove);\n        if (isAcquiringTrainData == true) {\n            ImGui::Text(\"Collecting training data. Type some text in the box below.\");\n            ImGui::Text(\"The more text you type, the higher the chance for correct prediction later.\");\n            ImGui::Text(\"Click the 'Predict' button when ready\");\n            static char buf[1024];\n            ImGui::InputTextMultiline(\"##TrainingData\", buf, 1024, { ImGui::GetContentRegionAvailWidth(), 520 });\n            if (ImGui::Button(\"Predict\", ImGui::GetContentRegionAvail())) {\n                audioLogger.pause();\n                std::this_thread::sleep_for(std::chrono::milliseconds(500));\n                foutTrain.close();\n                fins[0] = std::ifstream(\"train_default.kbd\", std::ios::binary);\n                if (fins[0].good()) {\n                    int bufferSize_frames = 1;\n                    fins[0].read((char *)(&bufferSize_frames), sizeof(bufferSize_frames));\n                    if (bufferSize_frames != kBufferSizeTrain_frames) {\n                        printf(\"Buffer size in file (%d) does not match the expected one (%d)\\n\", bufferSize_frames, (int) kBufferSizeTrain_frames);\n                    }\n                }\n                processingInput = true;\n                isAcquiringTrainData = false;\n                audioLogger.resume();\n            }\n        } else if (isReadyToPredict == false) {\n            ImGui::Text(\"Training ... Please wait\");\n        } else {\n#ifndef __EMSCRIPTEN__\n            {\n                static char inp[128] = { \"record.kbd\" };\n                ImGui::InputText(\"Audio file\", inp, 128);\n                ImGui::SameLine();\n                if (ImGui::Button(\"Load\")) {\n                    printf(\"[+] Replaying audio from file '%s' ...\\n\", inp);\n                    frecord = std::ifstream(inp, std::ios::binary);\n                    if (frecord.good()) {\n                        audioLogger.pause();\n                        processingRecord = true;\n                        ntest = 0;\n                    }\n                }\n                ImGui::SameLine();\n                ImGui::Checkbox(\"##waitForQueue\", &waitForQueueDuringPlayback);\n                if (ImGui::IsItemHovered()) {\n                    ImGui::BeginTooltip();\n                    ImGui::Text(\"If selected - wait for old playback data to get processed before pushing new data\");\n                    ImGui::EndTooltip();\n                }\n            }\n#endif\n            ImGui::Text(\"Last predicted key:       %s (%8.6f)\\n\", kKeyText.at(predictedKey), predictedCC);\n            ImGui::SliderFloat(\"Threshold CC\", &thresholdCC, 0.1f, 1.0f);\n            auto tNow = std::chrono::high_resolution_clock::now();\n            ImGui::Text(\"Last detected key stroke: %5.3f seconds ago\\n\",\n                        (float)(std::chrono::duration_cast<std::chrono::milliseconds>(tNow - tLastDetectedKeyStroke).count()/1000.0f));\n            ImGui::Text(\"Average background level: %16.13f\\n\", rbAverage);\n            ImGui::SliderFloat(\"Threshold background\", &thresholdBackground, 0.1f, 300.0f);\n            ImGui::Text(\"Tasks in queue: %d\\n\", (int) workQueue.size());\n            ImGui::Text(\"\\n\");\n\n            static bool displayConfidence = false;\n            ImGui::Checkbox(\"Display confidence\", &displayConfidence);\n\n            auto drawList = ImGui::GetWindowDrawList();\n\n            auto p0 = ImGui::GetCursorScreenPos();\n            auto p1 = p0;\n            float ox = 0.0f;\n            float oy = p0.y;\n            float bx = 32.0f;\n            float by = 32.0f;\n\n            for (int rid = 0; rid < (int) kKeyboard.size(); ++rid) {\n                const auto & row = kKeyboard[rid];\n                ox = p0.x + kRowOffset[rid]*bx;\n                for (const auto & button : row) {\n                    int key = button;\n                    auto & confDisplay = keyConfidenceDisplay[key];\n                    p1.x = ox;\n                    p1.y = oy;\n                    auto p2 = p1;\n                    auto tw = ImGui::CalcTextSize(kKeyText.at(key));\n                    p2.x += bx + tw.x;\n                    p2.y += by;\n                    ox += bx + tw.x;\n                    drawList->AddRectFilled(p1, p2, ImGui::ColorConvertFloat4ToU32({ 0.2f, 1.0f, 0.2f, confDisplay }), 0.0f, 0);\n                    drawList->AddRect(p1, p2, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 1.0f, 1.0f }), 0.0f, 0, 1.0f);\n                    if (displayConfidence) {\n                        ImGui::SetCursorScreenPos({0.5f*(p1.x + p2.x - tw.x), 0.5f*(p1.y + p2.y - tw.y) - 0.5f*tw.y});\n                    } else {\n                        ImGui::SetCursorScreenPos({0.5f*(p1.x + p2.x - tw.x), 0.5f*(p1.y + p2.y - tw.y)});\n                    }\n                    if (key == predictedKey) {\n                        ImGui::TextColored({1.0f, 0.0f, 0.0f, 1.0f}, \"%s\", kKeyText.at(key));\n                    } else {\n                        if (keySoundAverageAmpl.find(key) == keySoundAverageAmpl.end()) {\n                            ImGui::TextDisabled(\"%s\", kKeyText.at(key));\n                        } else {\n                            ImGui::Text(\"%s\", kKeyText.at(key));\n                        }\n                    }\n                    if (displayConfidence) {\n                        ImGui::SetWindowFontScale(0.90f);\n                        static auto tcw = ImGui::CalcTextSize(\"0.123\");\n                        ImGui::SetCursorScreenPos({0.5f*(p1.x + p2.x - tcw.x), 0.5f*(p1.y + p2.y - tw.y) + 0.5f*tw.y});\n                        ImGui::Text(\"%4.3f\", keyConfidence[key]);\n                        ImGui::SetWindowFontScale(1.0f);\n                    }\n                    confDisplay *= 0.99f;\n                }\n                oy += by;\n            }\n\n            ImGui::SetCursorScreenPos({p0.x, oy + ImGui::GetTextLineHeightWithSpacing()});\n\n            ImGui::TextDisabled(\"Last %d predicted keys:\", (int) predictedHistory.size());\n            ImGui::SameLine();\n            if (ImGui::Button(\"Clear\")) {\n                predictedHistory.fill({});\n            }\n            int nBestPredictions = 3;\n            for (int ip = 0; ip < nBestPredictions; ++ip) {\n                for (int i = 0; i < (int) predictedHistory.size(); ++i) {\n                    int idx = (predictedHistoryBegin + i)%predictedHistory.size();\n                    int maxLen = 1;\n                    for (auto l : predictedHistory[idx]) if ((int) strlen(kKeyText.at(l)) > maxLen) maxLen = strlen(kKeyText.at(l));\n                    static std::map<int, const char *> kws = {\n                        {0,  \"\"},\n                        {1,  \" \"},\n                        {2,  \"  \"},\n                        {3,  \"   \"},\n                        {4,  \"    \"},\n                        {5,  \"     \"},\n                        {6,  \"      \"},\n                        {7,  \"       \"},\n                        {8,  \"        \"},\n                        {9,  \"         \"},\n                        {10, \"          \"},\n                    };\n                    if ((int) predictedHistory[idx].size() > ip) {\n                        auto t = kKeyText.at(predictedHistory[idx][ip]);\n                        ImGui::Text(\"%s%s\", t, kws[maxLen - strlen(t)]);\n                        ImGui::SameLine();\n                    } else {\n                        ImGui::Text(\"%s\", kws.at(maxLen)); ImGui::SameLine();\n                    }\n                }\n                ImGui::Text(\"\\n\");\n            }\n            ImGui::Text(\"\\n\\n\");\n\n            if (ImGui::CollapsingHeader(\"Last prediction\", 0)) {\n                if (predictedKey != -1) {\n                    auto savePos = ImGui::GetCursorScreenPos();\n                    {\n                        const auto & ampl = keySoundAverageAmpl[predictedKey];\n                        ImGui::PlotLines((std::string(\"##\") + kKeyText.at(predictedKey)).c_str(), ampl.data(), ampl.size(), 0, kKeyText.at(predictedKey), amplMin, amplMax, { ImGui::GetContentRegionAvailWidth(), 400.0f });\n                    }\n                    ImGui::SetCursorScreenPos(savePos);\n                    {\n                        ImGui::PushStyleColor(ImGuiCol_PlotLines, {1.0f, 0.0f, 0.0f, 0.5f});\n                        ImGui::PushStyleColor(ImGuiCol_FrameBg, {0.0f, 0.0f, 0.0f, 0.0f});\n                        ImGui::PlotLines((std::string(\"##\") + kKeyText.at(predictedKey)).c_str(), predictedAmpl.data(), predictedAmpl.size(), 0, kKeyText.at(predictedKey), amplMin, amplMax, { ImGui::GetContentRegionAvailWidth(), 400.0f });\n                        ImGui::PopStyleColor(2);\n                    }\n                }\n            }\n\n            if (ImGui::CollapsingHeader(\"Average key sound\", 0)) {\n                for (const auto & key : keySoundAverageAmpl) {\n                    ImGui::PlotLines((std::string(\"##\") + kKeyText.at(key.first)).c_str(), key.second.data(), key.second.size(), 0, kKeyText.at(key.first), amplMin, amplMax, { ImGui::GetContentRegionAvailWidth(), 100.0f });\n                }\n            }\n\n            if (ImGui::CollapsingHeader(\"Training statistics\", ImGuiTreeNodeFlags_DefaultOpen)) {\n                for (const auto & key : trainStats) {\n                    if (key.second.nWaveformsUsed < 0.75*key.second.nWaveformsTotal) {\n                        ImGui::TextColored({1.0f, 1.0f, 0.0f, (float) key.second.averageCC},\n                                           \"Key: %8s   Average CC: %8.6f   Waveforms: %3d / %3d\",\n                                           kKeyText.at(key.first), key.second.averageCC,\n                                           key.second.nWaveformsUsed, key.second.nWaveformsTotal);\n                        if (ImGui::IsItemHovered()) {\n                            ImGui::BeginTooltip();\n                            ImGui::Text(\"Predictions for this key might not be very accurate. Provide more training data\");\n                            ImGui::EndTooltip();\n                        }\n                    } else {\n                        ImGui::TextColored({1.0f, 1.0f, 1.0f, (float) key.second.averageCC},\n                                           \"Key: %8s   Average CC: %8.6f   Waveforms: %3d / %3d\",\n                                           kKeyText.at(key.first), key.second.averageCC,\n                                           key.second.nWaveformsUsed, key.second.nWaveformsTotal);\n                    }\n                }\n            }\n        }\n\n        ImGui::End();\n\n        Gui::render(guiObjects);\n\n        return true;\n    };\n\n    init();\n#ifdef __EMSCRIPTEN__\n    emscripten_set_main_loop_arg(mainUpdate, NULL, 0, true);\n#else\n    while (true) {\n        if (g_mainUpdate() == false) break;\n    }\n#endif\n\n    worker.join();\n\n    printf(\"[+] Terminated\\n\");\n\n    Gui::free(guiObjects);\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap.cpp",
          "type": "blob",
          "size": 23.5087890625,
          "content": "/*! \\file keytap.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"audio-logger.h\"\n\n#include <map>\n#include <mutex>\n#include <cmath>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <vector>\n#include <deque>\n#include <fstream>\n\n//#define MY_DEBUG\n//#define OUTPUT_WAVEFORMS\n\n// globals\n\nstatic int g_predictedKey = -1;\nstatic bool g_isInitialized = false;\n\nstatic std::function<int()> g_init;\nstatic std::function<void()> g_update;\nstatic std::function<bool()> g_mainUpdate;\nstatic std::function<void(int)> g_handleKey;\n\nint init() {\n    if (g_isInitialized) return 1;\n\n    return g_init();\n}\n\nvoid update() {\n    if (g_isInitialized == false) return;\n\n    g_update();\n}\n\nvoid mainUpdate() {\n    g_mainUpdate();\n}\n\n// JS interface\nextern \"C\" {\n    int doInit() {\n        return init();\n    }\n\n    void keyPressedCallback(int key) {\n        g_handleKey(key);\n    }\n\n    int getPredictedKey() {\n        return g_predictedKey;\n    }\n}\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s input.kbd [input2.kbd ...] [-cN] [-pF] [-tF]\\n\", argv[0]);\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - select number N of capture channels to use\\n\");\n    printf(\"    -pF - prediction threshold: CC > F\\n\");\n    printf(\"    -tF - background threshold: ampl > F*avg_background\\n\");\n    printf(\"\\n\");\n\n    if (argc < 2) {\n        return -127;\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int captureId = argm[\"c\"].empty() ? 0 : std::stoi(argm[\"c\"]);\n    int nChannels = argm[\"C\"].empty() ? 0 : std::stoi(argm[\"C\"]);\n\n    std::map<int, std::ifstream> fins;\n    for (int i = 0; i < argc - 1; ++i) {\n        if (argv[i + 1][0] == '-') continue;\n        printf(\"Opening file '%s'\\n\", argv[i + 1]);\n        fins[i] = std::ifstream(argv[i + 1], std::ios::binary);\n        if (fins[i].good() == false) {\n            printf(\"Failed to open input file: '%s'\\n\", argv[i + 1]);\n            return -2;\n        }\n\n        {\n            int bufferSize_frames = 1;\n            fins[i].read((char *)(&bufferSize_frames), sizeof(bufferSize_frames));\n            if (bufferSize_frames != kBufferSizeTrain_frames) {\n                printf(\"Buffer size in file (%d) does not match the expected one (%d)\\n\", bufferSize_frames, (int) kBufferSizeTrain_frames);\n                return -1;\n            }\n        }\n    }\n\n    TKey keyPressed = -1;\n    std::map<TKey, TKeyHistoryF> keySoundHistoryAmpl;\n    std::map<TKey, TKeyWaveformF> keySoundAverageAmpl;\n\n    int ntest = 0;\n\n    bool doRecord = false;\n    bool isReadyToPredict = false;\n    bool finishApp = false;\n    bool processingInput = true;\n\n    int curFile = 0;\n\n    float amplMin = 0.0f;\n    float amplMax = 0.0f;\n    float thresholdCC = argm[\"p\"].empty() ? 0.35f : std::stof(argm[\"p\"]);\n    float thresholdBackground = argm[\"t\"].empty() ? 10.0f : std::stof(argm[\"t\"]);\n\n    // ring buffer\n    int rbBegin = 0;\n    float rbAverage = 0.0f;\n    std::array<float, kBkgrRingBufferSize> rbSamples;\n    rbSamples.fill(0.0f);\n\n    // Train data\n    bool isAcquiringTrainData = false;\n    std::map<int, int> nTimes;\n    size_t totalSize_bytes = 0;\n    std::ofstream foutTrain(\"train_default.kbd\", std::ios::binary);\n    {\n        int x = kBufferSizeTrain_frames;\n        foutTrain.write((char *)(&x), sizeof(x));\n    }\n\n    AudioLogger audioLogger;\n\n    struct WorkData {\n        TKeyWaveformF ampl;\n        std::vector<int> positionsToPredict;\n    };\n\n    std::mutex mutex;\n    std::deque<WorkData> workQueue;\n    std::thread worker([&]() {\n        int lastkey = -1;\n        double lastcc = -1.0f;\n\n        while (finishApp == false) {\n            bool process = false;\n            WorkData workData;\n            {\n                std::lock_guard<std::mutex> lock(mutex);\n                while (workQueue.size() > 30) {\n                    workQueue.pop_front();\n                    printf(\"pop\\n\");\n                }\n\n                if (workQueue.size() > 0) {\n                    workData = std::move(workQueue.front());\n                    workQueue.pop_front();\n                    process = true;\n                }\n            }\n            if (process) {\n                const auto & ampl = workData.ampl;\n                const auto & positionsToPredict = workData.positionsToPredict;\n\n                //int alignWindow = kSamplesPerFrame/2;\n                int alignWindow = 64;\n\n                for (int ipos = 0; ipos < (int) positionsToPredict.size(); ++ipos) {\n                    auto curPos = positionsToPredict[ipos];\n                    int scmp0 = curPos - kSamplesPerFrame;\n                    int scmp1 = curPos + kSamplesPerFrame;\n\n                    char res = -1;\n                    TValueCC maxcc = -1.0f;\n                    //TOffset offs = 0;\n                    TKeyConfidenceMap keyConfidenceTmp;\n                    for (const auto & ka : keySoundAverageAmpl) {\n                        //auto [bestcc, bestoffset] = findBestCC(keySoundAverageAmpl[ka.first], ampl, scmp0, scmp1, alignWindow);\n                        auto ret = findBestCC(keySoundAverageAmpl[ka.first], ampl, scmp0, scmp1, alignWindow);\n                        auto bestcc     = std::get<0>(ret);\n                        //auto bestoffset = std::get<1>(ret);\n\n                        if (bestcc > maxcc) {\n                            res = ka.first;\n                            maxcc = bestcc;\n                            //offs = bestoffset;\n                        }\n                        keyConfidenceTmp[ka.first] = bestcc;\n                    }\n\n                    if (maxcc > thresholdCC) {\n                        if (lastkey != res || lastcc != maxcc) {\n                            printf(\"    Prediction: '%c'        (%8.5g), ntest = %d\\n\", res, maxcc, ntest);\n                        }\n                        lastkey = res;\n                        lastcc = maxcc;\n                    }\n                    ++ntest;\n                }\n\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(1));\n            }\n        }\n    });\n\n    AudioLogger::Callback cbAudio = [&](const AudioLogger::Record & frames) {\n        if (isAcquiringTrainData) {\n            foutTrain.write((char *)(&keyPressed), sizeof(keyPressed));\n            for (const auto & frame : frames) {\n                totalSize_bytes += sizeof(frame[0])*frame.size();\n                foutTrain.write((char *)(frame.data()), sizeof(frame[0])*frame.size());\n                foutTrain.flush();\n            }\n            ++nTimes[keyPressed];\n\n            printf(\"Last recorded key - %3d '%s'. Total times recorded so far - %3d. Total data saved: %g MB\\n\",\n                   keyPressed, kKeyText.at(keyPressed), nTimes[keyPressed], ((float)(totalSize_bytes)/1024.0f/1024.0f));\n\n            keyPressed = -1;\n            return;\n        }\n\n        if (frames.size() != kBufferSizeTrain_frames && isReadyToPredict == false) {\n            printf(\"Unexpected number of frames - %d, expected - %d. Should never happen\\n\",\n                   (int) frames.size(), (int) kBufferSizeTrain_frames);\n            return;\n        }\n\n        const int nFrames = frames.size();\n\n        if (isReadyToPredict) {\n\n            std::vector<int> positionsToPredict;\n\n            {\n                float amax = 0.0f;\n                for (int f = 0; f < (int) frames.size(); ++f) {\n                    for (int s = 0; s < (int) frames[f].size(); s += kBkgrStep_samples) {\n                        rbAverage *= rbSamples.size();\n                        rbAverage -= rbSamples[rbBegin];\n                        auto acur = std::abs(frames[f][s]);\n                        rbSamples[rbBegin] = acur;\n                        if (acur > amax) amax = acur;\n                        rbAverage += acur;\n                        rbAverage /= rbSamples.size();\n                        if (++rbBegin >= (int) rbSamples.size()) rbBegin = 0;\n                    }\n                }\n\n                int nFrames = frames.size();\n\n                auto _acc = [](const AudioLogger::Record & r, int id) { return std::abs(r[id/kSamplesPerFrame][id%kSamplesPerFrame]); };\n\n                int k = kSamplesPerFrame;\n                std::deque<int> que(k);\n                for (int i = 0; i < nFrames*kSamplesPerFrame; ++i) {\n                    if (i < k) {\n                        while((!que.empty()) && _acc(frames, i) >= _acc(frames, que.back())) {\n                            que.pop_back();\n                        }\n                        que.push_back(i);\n                    } else {\n                        while((!que.empty()) && que.front() <= i - k) {\n                            que.pop_front();\n                        }\n\n                        while((!que.empty()) && _acc(frames, i) >= _acc(frames, que.back())) {\n                            que.pop_back();\n                        }\n\n                        que.push_back(i);\n\n                        int itest = i - k/2;\n                        if (itest >= (0.5*kSamplesPerWaveformTrain - kSamplesPerFrame) && itest < (0.5*kSamplesPerWaveformTrain + kSamplesPerFrame) && que.front() == itest) {\n                            auto acur = _acc(frames, itest);\n                            if (acur > thresholdBackground*rbAverage){\n                                positionsToPredict.push_back(itest);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (positionsToPredict.size() > 0) {\n                WorkData workData;\n                auto & ampl = workData.ampl;\n                ampl.resize(nFrames*kSamplesPerFrame);\n                for (int k = 0; k < nFrames; ++k) {\n                    std::copy(frames[k].begin(), frames[k].end(), ampl.begin() + k*kSamplesPerFrame);\n                }\n                workData.positionsToPredict = positionsToPredict;\n\n                {\n                    std::lock_guard<std::mutex> lock(mutex);\n                    workQueue.push_back(std::move(workData));\n                }\n            }\n\n            doRecord = true;\n        } else {\n            auto & history = keySoundHistoryAmpl[keyPressed];\n            history.push_back(TKeyWaveformF());\n            auto & ampl = history.back();\n            ampl.resize(nFrames*kSamplesPerFrame);\n            for (int k = 0; k < nFrames; ++k) {\n                std::copy(frames[k].begin(), frames[k].end(), ampl.begin() + k*kSamplesPerFrame);\n            }\n        }\n\n        keyPressed = -1;\n    };\n\n    g_init = [&]() {\n        AudioLogger::Parameters parameters;\n        parameters.callback = cbAudio;\n        parameters.captureId = captureId;\n        parameters.nChannels = nChannels;\n        parameters.sampleRate = kSampleRate;\n        parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n        if (audioLogger.install(std::move(parameters)) == false) {\n            fprintf(stderr, \"Failed to install audio logger\\n\");\n            return -1;\n        }\n\n        printf(\"[+] Collecting training data\\n\");\n        g_isInitialized = true;\n        return 0;\n    };\n\n    g_handleKey = [&](int key) {\n        if (keyPressed == -1 && isReadyToPredict == false) {\n            g_predictedKey = -1;\n            keyPressed = key;\n            audioLogger.record(kBufferSizeTrain_s, 3);\n        }\n    };\n\n    g_update = [&]() {\n        if (isAcquiringTrainData) {\n            return;\n        }\n\n        if (processingInput) {\n            if (keyPressed == -1) {\n                AudioLogger::Frame frame;\n                AudioLogger::Record record;\n                fins[curFile].read((char *)(&keyPressed), sizeof(keyPressed));\n                if (fins[curFile].eof()) {\n                    ++curFile;\n                    if (curFile >= (int) fins.size()) {\n                        processingInput = false;\n                    }\n                } else {\n                    printf(\"%c\", keyPressed);\n                    fflush(stdout);\n                    for (int i = 0; i < kBufferSizeTrain_frames; ++i) {\n                        fins[curFile].read((char *)(frame.data()), sizeof(AudioLogger::Sample)*frame.size());\n                        record.push_back(frame);\n                    }\n                    cbAudio(record);\n                }\n            }\n            return;\n        }\n\n        if (isReadyToPredict == false) {\n            printf(\"[+] Training\\n\");\n\n            std::vector<TKey> failedToTrain;\n\n            auto trainKey = [&](TKey key) {\n                auto & history = keySoundHistoryAmpl[key];\n\n                int nWaveforms = history.size();\n                int nFramesPerWaveform = kBufferSizeTrain_frames;\n\n                printf(\"    - Training key '%c'\\n\", key);\n                printf(\"    - History size = %d key waveforms\\n\", nWaveforms);\n                printf(\"    - Frames per key waveform   = %d\\n\", nFramesPerWaveform);\n                printf(\"    - Total frames available    = %d\\n\", nWaveforms*nFramesPerWaveform);\n                printf(\"    - Samples per frame         = %d\\n\", (int) kSamplesPerFrame);\n                printf(\"    - Total samples available   = %d\\n\", (int) (nWaveforms*nFramesPerWaveform*kSamplesPerFrame));\n\n                printf(\"    - Estimating waveform peaks ...\\n\");\n                std::vector<int> peakSum;\n                std::vector<int> peakMax;\n\n                peakSum.clear();\n                peakMax.clear();\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int isum = -1;\n                    double asum = 0.0f;\n                    double aisum = 0.0f;\n\n                    int imax = -1;\n                    double amax = 0.0f;\n\n                    const auto & waveform = history[iwaveform];\n\n                    for (int icur = 0; icur < kSamplesPerWaveformTrain; ++icur) {\n                        double acur = std::abs(waveform[icur]);\n                        double acur2 = acur*acur;\n\n                        asum += acur2;\n                        aisum += acur2*icur;\n\n                        if (acur > amax) {\n                            amax = acur;\n                            imax = icur;\n                        }\n                    }\n\n                    isum = aisum/asum;\n\n                    peakSum.push_back(isum);\n                    peakMax.push_back(imax);\n                    //printf(\"        Estimated peak: %d (method - sum), %d (method - max)\\n\", isum, imax);\n                }\n\n                auto calcStdev = [](const std::vector<int> & data) {\n                    double sum = 0.0f;\n                    double sum2 = 0.0f;\n                    for (const auto & p : data) {\n                        int64_t v = p;\n                        sum += v;\n                        sum2 += v*v;\n                    }\n                    sum /= data.size();\n                    sum2 /= data.size();\n                    return sqrt(sum2 - sum*sum);\n                };\n\n                double stdevSum = calcStdev(peakSum);\n                double stdevMax = calcStdev(peakMax);\n\n                printf(\"    - Stdev of estimated peaks: %g (sum) vs %g (max)\\n\", stdevSum, stdevMax);\n\n                const auto & peakUsed = peakMax;\n                printf(\"    - Using 'max' estimation\\n\");\n\n                int centerSample = kSamplesPerWaveformTrain/2;\n\n                printf(\"    - Centering waveforms at sample %d\\n\", centerSample);\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    int offset = peakUsed[iwaveform] - centerSample;\n                    //printf(\"        Offset for waveform %-4d = %-4d\\n\", iwaveform, offset);\n\n                    auto newWaveform = TKeyWaveformF();\n                    newWaveform.resize(kSamplesPerWaveformTrain);\n                    auto & waveform = history[iwaveform];\n                    for (int icur = 0; icur < kSamplesPerWaveformTrain; ++icur) {\n                        int iorg = icur + offset;\n\n                        if (iorg >= 0 && iorg < kSamplesPerWaveformTrain) {\n                            newWaveform[icur] = waveform[iorg];\n                        } else {\n                            newWaveform[icur] = 0.0f;\n                        }\n                    }\n\n                    waveform = std::move(newWaveform);\n                }\n\n                int alignWindow = 64;\n                printf(\"    - Calculating CC pairs\\n\");\n                printf(\"      Align window = %d\\n\", alignWindow);\n\n                int bestw = -1;\n                int ntrain = 0;\n                double bestccsum = -1.0f;\n                //double bestosum = 1e10;\n                std::map<int, std::map<int, std::tuple<TValueCC, TOffset>>> ccs;\n\n                for (int alignToWaveform = 0; alignToWaveform < nWaveforms; ++alignToWaveform) {\n                    ccs[alignToWaveform][alignToWaveform] = std::tuple<TValueCC, TOffset>(1.0f, 0);\n\n                    int is0 = centerSample - kSamplesPerFrame;\n                    int is1 = centerSample + kSamplesPerFrame;\n\n                    const auto & waveform0 = history[alignToWaveform];\n\n                    for (int iwaveform = alignToWaveform + 1; iwaveform < nWaveforms; ++iwaveform) {\n                        const auto & waveform1 = history[iwaveform];\n                        //auto [bestcc, bestoffset] = findBestCC(waveform0, waveform1, is0, is1, alignWindow);\n                        auto ret = findBestCC(waveform0, waveform1, is0, is1, alignWindow);\n                        auto bestcc     = std::get<0>(ret);\n                        auto bestoffset = std::get<1>(ret);\n\n                        ccs[iwaveform][alignToWaveform] = std::tuple<TValueCC, TOffset>(bestcc, bestoffset);\n                        ccs[alignToWaveform][iwaveform] = std::tuple<TValueCC, TOffset>(bestcc, -bestoffset);\n                    }\n\n                    int curntrain = 0;\n                    double curccsum = 0.0;\n                    double curosum = 0.0;\n                    for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                        //auto [cc, offset] = ccs[iwaveform][alignToWaveform];\n                        auto cc     = std::get<0>(ccs[iwaveform][alignToWaveform]);\n                        auto offset = std::get<1>(ccs[iwaveform][alignToWaveform]);\n\n                        if (std::abs(offset) > 50) continue;\n                        ++curntrain;\n                        curccsum += cc*cc;\n                        curosum += offset*offset;\n                    }\n\n                    if (curccsum > bestccsum) {\n                    //if (curosum < bestosum) {\n                        ntrain = curntrain;\n                        bestw = alignToWaveform;\n                        bestccsum = curccsum;\n                        //bestosum = curosum;\n                    }\n                }\n                bestccsum = sqrt(bestccsum/ntrain);\n\n                printf(\"    - Aligning all waveforms to waveform %d, (cost = %g)\\n\", bestw, bestccsum);\n#ifdef OUTPUT_WAVEFORMS\n                std::ofstream fout(std::string(\"waveform_one_\") + std::to_string(key) + \".plot\");\n                for (auto & v : history[bestw]) fout << v << std::endl;\n                fout << std::endl;\n#endif\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    if (iwaveform == bestw) continue;\n\n                    auto & waveform1 = history[iwaveform];\n                    //auto [cc, offset] = ccs[iwaveform][bestw];\n                    //auto cc     = std::get<0>(ccs[iwaveform][bestw]);\n                    auto offset = std::get<1>(ccs[iwaveform][bestw]);\n\n                    auto newWaveform = TKeyWaveformF();\n                    newWaveform.resize(kSamplesPerWaveformTrain);\n                    for (int icur = 0; icur < kSamplesPerWaveformTrain; ++icur) {\n                        int iorg = icur + offset;\n\n                        if (iorg >= 0 && iorg < kSamplesPerWaveformTrain) {\n                            newWaveform[icur] = waveform1[iorg];\n                        } else {\n                            newWaveform[icur] = 0.0f;\n                        }\n                    }\n\n                    waveform1 = std::move(newWaveform);\n#ifdef OUTPUT_WAVEFORMS\n                    for (auto & v : waveform1) fout << v << std::endl;\n                    fout << std::endl;\n#endif\n                }\n\n                printf(\"    - Calculating average waveform\\n\");\n                double ccsum = 0.0f;\n                double norm = 0.0f;\n                auto & avgWaveform = keySoundAverageAmpl[key];\n                avgWaveform.resize(kSamplesPerWaveformTrain);\n                std::fill(avgWaveform.begin(), avgWaveform.end(), 0.0f);\n                for (int iwaveform = 0; iwaveform < nWaveforms; ++iwaveform) {\n                    //auto [cc, offset] = ccs[iwaveform][bestw];\n                    auto cc     = std::get<0>(ccs[iwaveform][bestw]);\n                    auto offset = std::get<1>(ccs[iwaveform][bestw]);\n\n                    //if (std::abs(offset) > 5) continue;\n                    printf(\"        Adding waveform %d - cc = %g, offset = %ld\\n\", iwaveform, cc, offset);\n                    ccsum += cc*cc;\n                    norm += cc*cc;\n                    auto & waveform = history[iwaveform];\n                    for (int is = 0; is < kSamplesPerWaveformTrain; ++is) {\n                        avgWaveform[is] += cc*cc*waveform[is];\n                    }\n                }\n\n                norm = 1.0f/(norm);\n                for (int is = 0; is < kSamplesPerWaveformTrain; ++is) {\n                    avgWaveform[is] *= norm;\n                    if (avgWaveform[is] > amplMax) amplMax = avgWaveform[is];\n                    if (avgWaveform[is] < amplMin) amplMin = avgWaveform[is];\n                }\n\n#ifdef OUTPUT_WAVEFORMS\n                {\n                    std::ofstream fout(std::string(\"waveform_avg_\") + std::to_string(key) + \".plot\");\n                    for (auto & v : avgWaveform) fout << v << std::endl;\n                }\n#endif\n\n                if (ccsum*norm < 0.50f || (1.0f/norm < nWaveforms/3.0)) {\n                    failedToTrain.push_back(key);\n                }\n\n                printf(\"\\n\");\n            };\n\n            for (const auto & kh : keySoundHistoryAmpl) {\n                if (kh.second.size() > 2) {\n                    trainKey(kh.first);\n                } else {\n                    printf(\"[!] Key '%s' does not have enough training data. Need at least 3 presses\\n\", kKeyText.at(kh.first));\n                    failedToTrain.push_back(kh.first);\n                }\n            }\n            printf(\"Failed to train the following keys: \");\n            for (auto & k : failedToTrain) printf(\"'%c' \", k);\n            printf(\"\\n\");\n            isReadyToPredict = true;\n            doRecord = true;\n\n            amplMax = std::max(amplMax, -amplMin);\n            amplMin = -std::max(amplMax, -amplMin);\n\n            for (auto & kh : keySoundAverageAmpl) {\n                float curAmplMax = 0.0f;\n                for (const auto & v : kh.second) if (std::abs(v) > curAmplMax) curAmplMax = std::abs(v);\n                for (auto & v : kh.second) v = (v/curAmplMax)*amplMax;\n            }\n\n            audioLogger.resume();\n\n            printf(\"[+] Ready to predict. Keep pressing keys and the program will guess which key was pressed\\n\");\n            printf(\"    based on the captured audio from the microphone.\\n\");\n            printf(\"[+] Predicting\\n\");\n        }\n\n        if (doRecord) {\n            doRecord = false;\n            audioLogger.record(kBufferSizeTrain_s, getBufferSize_frames(kSampleRate, kBufferSizeTrain_s) - 1);\n        }\n    };\n\n    g_mainUpdate = [&]() {\n        if (finishApp) return false;\n\n        update();\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n        return true;\n    };\n\n    init();\n#ifdef __EMSCRIPTEN__\n    emscripten_set_main_loop(mainUpdate, 60, 1);\n#else\n    while (true) {\n        if (g_mainUpdate() == false) break;\n    }\n#endif\n\n    worker.join();\n\n    printf(\"[+] Terminated\");\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap2-gui-old.cpp",
          "type": "blob",
          "size": 44.9677734375,
          "content": "/*! \\file keytap2-gui.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"subbreak.h\"\n#include \"subbreak2.h\"\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#include <SDL.h>\n#include <GL/gl3w.h>\n\n#include <chrono>\n#include <cstdio>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <algorithm>\n\n//#define MY_DEBUG\n\nint g_windowSizeX = 1920;\nint g_windowSizeY = 1200;\n\nstruct stParameters;\n\nusing TParameters           = stParameters;\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TKeyPressData         = TKeyPressDataI16;\nusing TKeyPressCollection   = TKeyPressCollectionI16;\nusing TPlaybackData         = TPlaybackDataI16;\n\nenum Approach {\n    ClusterG = 0,\n    DBSCAN,\n    NonExactSubstitutionCipher0,\n\n    COUNT,\n};\n\nstd::string getApproachStr(Approach approach) {\n    std::string res = \"-\";\n    switch (approach) {\n        case ClusterG:\n            res = \"ClusterG clustering + Substition Cipher attack\";\n            break;\n        case DBSCAN:\n            res = \"DBSCAN clustering + Substition Cipher attack\";\n            break;\n        case NonExactSubstitutionCipher0:\n            res = \"Non-Exact Substitution Cipher attack\";\n            break;\n        case COUNT:\n            break;\n    };\n    return res;\n}\n\nstruct stParameters {\n    int keyPressWidth_samples   = 256;\n    int sampleRate              = kSampleRate;\n    int offsetFromPeak_samples  = keyPressWidth_samples/2;\n    int alignWindow_samples     = 256;\n    float thresholdClustering   = 0.5f;\n    int nMinKeysInCluster       = 3;\n    std::string fnameLetterMask = \"\";\n\n    Approach approach = ClusterG;\n\n    // simulated annealing\n    int saMaxIterations = 1000000;\n    float temp0 = 1e8;\n    float coolingRate = 0.99995;\n\n    Cipher::TParameters cipher;\n};\n\nbool clusterDBSCAN(const TSimilarityMap & sim, TValueCC epsCC, int minPts, TKeyPressCollection & keyPresses) {\n    int n = keyPresses.size();\n    for (int i = 0; i < n; ++i) {\n        auto & cid = keyPresses[i].cid;\n\n        cid = -1;\n    }\n\n    int curId = n + 1;\n\n    curId = 0;\n\n    for (int i = 0; i < n; ++i) {\n        auto & cid = keyPresses[i].cid;\n\n        if (cid != -1) continue;\n        std::vector<int> nbi;\n        for (int j = 0; j < n; ++j) {\n            auto & cc = sim[i][j].cc;\n\n            if (cc > epsCC) nbi.push_back(j);\n        }\n\n        if ((int) nbi.size() < minPts) {\n            cid = 0;\n            continue;\n        }\n\n        cid = ++curId;\n        for (int q = 0; q < (int) nbi.size(); ++q) {\n            auto & qcid = keyPresses[nbi[q]].cid;\n\n            if (qcid == 0) qcid = curId;\n            if (qcid != -1) continue;\n            qcid = curId;\n\n            std::vector<int> nbq;\n            for (int j = 0; j < n; ++j) {\n                auto & cc = sim[nbi[q]][j].cc;\n\n                if (cc > epsCC) nbq.push_back(j);\n            }\n\n            if ((int) nbq.size() >= minPts) {\n                nbi.insert(nbi.end(), nbq.begin(), nbq.end());\n            }\n        }\n    }\n\n    {\n        int nclusters = 0;\n        std::map<int, bool> used;\n        for (const auto & kp : keyPresses) {\n            if (used[kp.cid] == false) {\n                used[kp.cid] = true;\n                ++nclusters;\n            }\n        }\n\n        keyPresses.nClusters = nclusters;\n    }\n\n    {\n        int curId = 0;\n        int n = keyPresses.size();\n        std::vector<int> newcid(n, 0);\n        for (int i = 0; i < n; ++i) {\n            if (newcid[i] != 0) continue;\n            ++curId;\n            for (int j = 0; j < n; ++j) {\n                if (keyPresses[i].cid == keyPresses[j].cid) {\n                    newcid[j] = curId;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            keyPresses[i].cid = newcid[i];\n        }\n    }\n\n    return true;\n}\n\nbool clusterG(const TSimilarityMap & sim, TKeyPressCollection & keyPresses, TValueCC threshold) {\n    struct Pair {\n        int i = -1;\n        int j = -1;\n        TValueCC cc = -1.0;\n\n        bool operator < (const Pair & a) const { return cc > a.cc; }\n    };\n\n    int n = keyPresses.size();\n\n    int nclusters = 0;\n    for (int i = 0; i < n; ++i) {\n        keyPresses[i].cid = i + 1;\n        ++nclusters;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (keyPresses[i].bind < 0) continue;\n        for (int j = 0; j < n; ++j) {\n            if (keyPresses[j].bind == keyPresses[i].bind) {\n                if (keyPresses[j].cid != keyPresses[i].cid) {\n                    keyPresses[j].cid = keyPresses[i].cid;\n                    --nclusters;\n                }\n            }\n        }\n    }\n\n    std::vector<Pair> ccpairs;\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ccpairs.emplace_back(Pair{i, j, sim[i][j].cc});\n        }\n    }\n\n    std::sort(ccpairs.begin(), ccpairs.end());\n\n    printf(\"[+] Top 10 pairs\\n\");\n    for (int i = 0; i < 10; ++i) {\n        printf(\"    Pair %d: %d %d %g\\n\", i, ccpairs[i].i, ccpairs[i].j, ccpairs[i].cc);\n    }\n\n    int npairs = ccpairs.size();\n    for (int ip = 0; ip < npairs; ++ip) {\n        auto & curpair = ccpairs[ip];\n        if (frand() > curpair.cc) continue;\n        if (curpair.cc < threshold) break;\n\n        auto ci = keyPresses[curpair.i].cid;\n        auto cj = keyPresses[curpair.j].cid;\n\n        int bindi = -1;\n        int bindj = -1;\n        for (int k = 0; k < n; ++k) {\n            if (keyPresses[k].cid == ci && keyPresses[k].bind > -1) bindi = keyPresses[k].bind;\n            if (keyPresses[k].cid == cj && keyPresses[k].bind > -1) bindj = keyPresses[k].bind;\n        }\n\n        if (bindi != bindj && bindi > -1 && bindj > -1) continue;\n\n        if (ci == cj) continue;\n        auto cnew = std::min(ci, cj);\n        int nsum = 0;\n        int nsumi = 0;\n        int nsumj = 0;\n        double sumcc = 0.0;\n        double sumcci = 0.0;\n        double sumccj = 0.0;\n        for (int k = 0; k < n; ++k) {\n            auto & ck = keyPresses[k].cid;\n            for (int q = 0; q < n; ++q) {\n                if (q == k) continue;\n                auto & cq = keyPresses[q].cid;\n                if ((ck == ci || ck == cj) && (cq == ci || cq == cj)) {\n                    sumcc += sim[k][q].cc;\n                    ++nsum;\n                }\n                if (ck == ci && cq == ci) {\n                    sumcci += sim[k][q].cc;\n                    ++nsumi;\n                }\n                if (ck == cj && cq == cj) {\n                    sumccj += sim[k][q].cc;\n                    ++nsumj;\n                }\n            }\n        }\n        sumcc /= nsum;\n        if (nsumi > 0) sumcci /= nsumi;\n        if (nsumj > 0) sumccj /= nsumj;\n        //printf(\"Merge avg n = %4d, cc = %8.5f, ni = %4d, cci = %8.5f, nj = %4d, ccj = %8.5f\\n\", nsum, sumcc, nsumi, sumcci, nsumj, sumccj);\n\n        //if (sumcc < 1.000*curpair.cc) continue;\n        //if (sumcc > 0.75*sumccj && sumcc > 0.75*sumcci) {\n        if (sumcc > 0.4*(sumcci + sumccj)) {\n        } else {\n            continue;\n        }\n\n        for (int k = 0; k < n; ++k) {\n            auto & ck = keyPresses[k].cid;\n            if (ck == ci || ck == cj) ck = cnew;\n        }\n        --nclusters;\n    }\n\n    keyPresses.nClusters = nclusters;\n\n    {\n        int curId = 0;\n        int n = keyPresses.size();\n        std::vector<int> newcid(n, 0);\n        for (int i = 0; i < n; ++i) {\n            if (newcid[i] != 0) continue;\n            ++curId;\n            for (int j = 0; j < n; ++j) {\n                if (keyPresses[i].cid == keyPresses[j].cid) {\n                    newcid[j] = curId;\n                }\n            }\n        }\n        if (curId != nclusters) {\n            printf(\"Something is wrong. curId = %d, nclusters = %d\\n\", curId, nclusters);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            keyPresses[i].cid = newcid[i];\n        }\n    }\n\n    return true;\n}\n\nbool adjustKeyPresses(const TParameters & , TKeyPressCollection & keyPresses, TSimilarityMap & sim) {\n    struct Pair {\n        int i = -1;\n        int j = -1;\n        TValueCC cc = -1.0;\n\n        bool operator < (const Pair & a) const { return cc > a.cc; }\n    };\n\n    int n = keyPresses.size();\n\n    std::vector<Pair> ccpairs;\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ccpairs.emplace_back(Pair{i, j, sim[i][j].cc});\n        }\n    }\n\n    int nused = 0;\n    std::vector<bool> used(n, false);\n\n    std::sort(ccpairs.begin(), ccpairs.end());\n\n    int npairs = ccpairs.size();\n    for (int ip = 0; ip < npairs; ++ip) {\n        auto & curpair = ccpairs[ip];\n        int k0 = curpair.i;\n        int k1 = curpair.j;\n        if (used[k0] && used[k1]) continue;\n\n        if (used[k1] == false) {\n            keyPresses[k1].pos += sim[k0][k1].offset;\n        } else {\n            keyPresses[k0].pos -= sim[k0][k1].offset;\n        }\n\n        if (used[k0] == false) { used[k0] = true; ++nused; }\n        if (used[k1] == false) { used[k1] = true; ++nused; }\n\n        if (nused == n) break;\n    }\n\n    return true;\n}\n\nfloat plotWaveform(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return waveform->samples[i];\n}\n\nfloat plotWaveformInverse(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return -waveform->samples[i];\n}\n\nSDL_AudioDeviceID g_deviceIdOut = 0;\nTPlaybackData g_playbackData;\n\nbool renderKeyPresses(TParameters & params, const char * fnameInput, const TWaveform & waveform, TKeyPressCollection & keyPresses) {\n    ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_Once);\n    ImGui::SetNextWindowSize(ImVec2(g_windowSizeX, 350.0f), ImGuiCond_Once);\n    if (ImGui::Begin(\"Key Presses\")) {\n        int viewMin = 512;\n        int viewMax = waveform.size();\n\n        bool ignoreDelete = false;\n\n        static int nview = waveform.size();\n        static int offset = (waveform.size() - nview)/2;\n        static float amin = std::numeric_limits<TSample>::min();\n        static float amax = std::numeric_limits<TSample>::max();\n        static float dragOffset = 0.0f;\n        static float scrollSize = 18.0f;\n\n        static auto nviewPrev = nview + 1;\n\n        static TWaveform waveformLowRes = waveform;\n        static TWaveform waveformThreshold = waveform;\n\n        auto wview = getView(waveformLowRes, offset, nview);\n        auto tview = getView(waveformThreshold, offset, nview);\n        auto wsize = ImVec2(ImGui::GetContentRegionAvailWidth(), 250.0);\n\n        auto mpos = ImGui::GetIO().MousePos;\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.3f, 0.3f, 0.3f, 0.3f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveform, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.1f, 0.1f, 0.1f, 0.0f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveformInverse, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n        ImGui::PushStyleColor(ImGuiCol_PlotLines, { 0.0f, 1.0f, 0.0f, 0.5f });\n        ImGui::PlotLines(\"##WaveformThreshold\", plotWaveform, &tview, nview, 0, \"\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n        ImGui::PushStyleColor(ImGuiCol_PlotLines, { 0.0f, 1.0f, 0.0f, 0.5f });\n        ImGui::PlotLines(\"##WaveformThreshold\", plotWaveformInverse, &tview, nview, 0, \"\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::InvisibleButton(\"##WaveformIB\",wsize);\n        if (ImGui::IsItemHovered()) {\n            auto w = ImGui::GetIO().MouseWheel;\n            auto nview_old = nview;\n            nview *= (10.0 + w)/10.0;\n            nview = std::min(std::max(viewMin, nview), viewMax);\n            if (w != 0.0) {\n                offset = std::max(0.0f, offset + ((mpos.x - savePos.x)/wsize.x)*(nview_old - nview));\n            }\n\n            if (ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0) == false) {\n                dragOffset = offset;\n            }\n\n            if (ImGui::IsMouseDragging(0)) {\n                offset = dragOffset - ImGui::GetMouseDragDelta(0).x*nview/wsize.x;\n            }\n\n            if (ImGui::IsMouseReleased(0) && ImGui::GetIO().KeyCtrl) {\n                int i = 0;\n                int64_t pos = offset + nview*(mpos.x - savePos.x)/wsize.x;\n                for (i = 0; i < (int) keyPresses.size(); ++i) {\n                    int64_t p0 = keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples;\n                    int64_t p1 = keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples;\n                    int64_t pmin = std::min(std::min(keyPresses[i].pos, p0), p1);\n                    int64_t pmax = std::max(std::max(keyPresses[i].pos, p0), p1);\n                    if (pmin > pos) {\n                        ignoreDelete = true;\n                        TKeyPressData entry;\n                        entry.pos = pos;\n                        entry.waveform = getView(waveform, 0);\n                        keyPresses.insert(keyPresses.begin() + i, entry);\n                        break;\n                    }\n                    if (pos >= pmin && pos <= pmax) break;\n                }\n                if (i == (int) keyPresses.size() && ignoreDelete == false) {\n                    ignoreDelete = true;\n                    TKeyPressData entry;\n                    entry.pos = pos;\n                    entry.waveform = getView(waveform, 0);\n                    keyPresses.push_back(entry);\n                }\n            }\n        }\n        if (ImGui::BeginPopupContextWindow()) {\n            ImGui::SliderInt(\"View  \", &nview, viewMin, viewMax);\n            ImGui::DragInt  (\"Offset\", &offset, 0.01*nview, 0, waveform.size() - nview);\n            ImGui::SliderFloat(\"Amplitude Min\", &amin, -32000, 0);\n            ImGui::SliderFloat(\"Amplitude Max\", &amax, 0, 32000);\n            ImGui::EndPopup();\n        }\n\n        ImGui::InvisibleButton(\"##WaveformScrollIB\", {wsize.x, scrollSize});\n        drawList->AddRect({savePos.x, savePos.y + wsize.y}, {savePos.x + wsize.x, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n        drawList->AddRectFilled({savePos.x + wsize.x*(1.f*offset)/viewMax, savePos.y + wsize.y}, {savePos.x + wsize.x*(1.f*offset + nview)/viewMax, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n\n        auto savePos2 = ImGui::GetCursorScreenPos();\n\n        static bool scrolling = false;\n        if (ImGui::IsItemHovered()) {\n            if (ImGui::IsMouseDown(0)) {\n                scrolling = true;\n            }\n        }\n\n        if (scrolling) {\n            offset = ((mpos.x - savePos.x)/wsize.x)*viewMax - nview/2;\n        }\n\n        if (ImGui::IsMouseDown(0) == false) {\n            scrolling = false;\n        }\n\n        offset = std::max(0, std::min((int) offset, (int) waveform.size() - nview));\n        for (int i = 0; i < (int) keyPresses.size(); ++i) {\n            if (keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples < offset) continue;\n            if (keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples >= offset + nview) break;\n\n            {\n                float x0 = ((float)(keyPresses[i].pos - offset))/nview;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                ImVec2 p1 = { savePos.x + x0*wsize.x, savePos.y + wsize.y };\n\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 0.8f }), 1.0f);\n            }\n\n            {\n                float x0 = ((float)(keyPresses[i].pos - offset))/nview;\n                float x1 = ((float)(keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples - offset))/nview;\n                float x2 = ((float)(keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples - offset))/nview;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                ImVec2 p1 = { savePos.x + x1*wsize.x, savePos.y };\n                ImVec2 p2 = { savePos.x + x2*wsize.x, savePos.y + wsize.y };\n\n                float xmin = std::min(std::min(p0.x, p1.x), p2.x);\n                float xmax = std::max(std::max(p0.x, p1.x), p2.x);\n\n                bool isHovered = (mpos.x > xmin && mpos.x < xmax && mpos.y > p1.y && mpos.y < p2.y);\n\n                float col = isHovered ? 0.7f : 0.3f;\n                drawList->AddRectFilled(p1, p2, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, col }));\n\n                if (isHovered) {\n                    if (ImGui::IsMouseReleased(0) && ImGui::GetIO().KeyCtrl && ignoreDelete == false) {\n                        keyPresses.erase(keyPresses.begin() + i);\n                        --i;\n                    }\n                }\n\n                if (nview < 64.0*wsize.x) {\n                    ImGui::SetCursorScreenPos({ savePos.x + 0.5f*((x1 + x2)*wsize.x - ImGui::CalcTextSize(std::to_string(i).c_str()).x), savePos.y + wsize.y - ImGui::GetTextLineHeightWithSpacing() });\n                    ImGui::Text(\"%d\", i);\n                }\n\n            }\n\n            {\n                float x0 = ((float)(g_playbackData.offset + g_playbackData.idx - offset))/nview;\n\n                ImVec2 p0 = {savePos.x + x0*wsize.x, savePos.y};\n                ImVec2 p1 = {savePos.x + x0*wsize.x, savePos.y + wsize.y};\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 0.0f, 0.3f }));\n            }\n        }\n        for (int i = 0; i < (int) keyPresses.size(); ++i) {\n            {\n                float x0 = ((float)(keyPresses[i].pos))/viewMax;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y + wsize.y };\n                ImVec2 p1 = { savePos.x + x0*wsize.x, savePos.y + wsize.y + scrollSize };\n\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 0.3f }));\n            }\n        }\n\n        ImGui::SetCursorScreenPos(savePos2);\n\n        //auto io = ImGui::GetIO();\n        //ImGui::Text(\"Keys pressed:\");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text(\"%d\", i); }\n\n        static bool recalculate = true;\n        static bool playHalfSpeed = false;\n        static int historySize = 6*1024;\n        static float thresholdBackground = 10.0;\n        ImGui::PushItemWidth(100.0);\n\n        ImGui::Checkbox(\"x0.5\", &playHalfSpeed);\n        ImGui::SameLine();\n        if (g_playbackData.playing) {\n            if (ImGui::Button(\"Stop\") || ImGui::IsKeyPressed(44)) { // space\n                g_playbackData.playing = false;\n                g_playbackData.idx = g_playbackData.waveform.n - TPlaybackData::kSamples;\n            }\n        } else {\n            if (ImGui::Button(\"Play\") || ImGui::IsKeyPressed(44)) { // space\n                g_playbackData.playing = true;\n                g_playbackData.slowDown = playHalfSpeed ? 2 : 1;\n                g_playbackData.idx = 0;\n                g_playbackData.offset = offset;\n                g_playbackData.waveform = getView(waveform, offset, std::min((int) (10*params.sampleRate), nview));\n                SDL_PauseAudioDevice(g_deviceIdOut, 0);\n            }\n        }\n\n        if (g_playbackData.idx >= g_playbackData.waveform.n) {\n            g_playbackData.playing = false;\n            SDL_ClearQueuedAudio(g_deviceIdOut);\n            SDL_PauseAudioDevice(g_deviceIdOut, 1);\n        }\n\n        ImGui::SameLine();\n        ImGui::SliderFloat(\"Threshold background\", &thresholdBackground, 0.1f, 50.0f) && (recalculate = true);\n        ImGui::SameLine();\n        ImGui::SliderInt(\"History Size\", &historySize, 512, 1024*16) && (recalculate = true);\n        ImGui::SameLine();\n        if (ImGui::Button(\"Recalculate\") || recalculate) {\n            findKeyPresses(getView(waveform, 0), keyPresses, waveformThreshold, thresholdBackground, historySize);\n            recalculate = false;\n        }\n\n        static std::string filename = std::string(fnameInput) + \".keys\";\n        ImGui::SameLine();\n        ImGui::Text(\"%s\", filename.c_str());\n\n        ImGui::SameLine();\n        if (ImGui::Button(\"Save\")) {\n            saveKeyPresses(filename.c_str(), keyPresses);\n        }\n\n        ImGui::SameLine();\n        if (ImGui::Button(\"Load\")) {\n            loadKeyPresses(filename.c_str(), getView(waveform, 0), keyPresses);\n        }\n\n        ImGui::SameLine();\n        ImGui::DragInt(\"Key width\", &params.keyPressWidth_samples, 8, 0, params.sampleRate/10);\n        ImGui::SameLine();\n        ImGui::DragInt(\"Peak offset\", &params.offsetFromPeak_samples, 8, -params.sampleRate/10, params.sampleRate/10);\n        ImGui::SameLine();\n        ImGui::DragInt(\"Align window\", &params.alignWindow_samples, 8, 0, params.sampleRate/10);\n\n        ImGui::Text(\"Letter mask: %s\", params.fnameLetterMask.c_str());\n        ImGui::SameLine();\n        if (ImGui::Button(\"Filter\")) {\n            std::ifstream fin(params.fnameLetterMask.c_str());\n            int idx = 0;\n            while (true) {\n                char a;\n                fin.read((char *)(&a), sizeof(a));\n                if (fin.eof()) break;\n                if (a != '.') {\n                    keyPresses.erase(keyPresses.begin() + idx);\n                    --idx;\n                }\n                ++idx;\n                if (idx >= (int) keyPresses.size()) break;\n            }\n        }\n\n        ImGui::PopItemWidth();\n\n        if (nview != nviewPrev) {\n            generateLowResWaveform(waveform, waveformLowRes, std::max(1.0f, nview/wsize.x));\n            nviewPrev = nview;\n        }\n\n    }\n    ImGui::End();\n\n    return false;\n}\n\nbool renderSimilarity(TParameters & params, TKeyPressCollection & keyPresses, TSimilarityMap & similarityMap) {\n    ImGui::SetNextWindowPos(ImVec2(0, 350.0f), ImGuiCond_Once);\n    ImGui::SetNextWindowSize(ImVec2(0.5f*g_windowSizeX, g_windowSizeY - 350.0f), ImGuiCond_Once);\n    if (ImGui::Begin(\"Similarity\")) {\n        auto wsize = ImGui::GetContentRegionAvail();\n\n        static float bsize = 4.0f;\n        static float threshold = 0.3f;\n        ImGui::PushItemWidth(100.0);\n        if (ImGui::Button(\"Calculate\") || ImGui::IsKeyPressed(6)) { // c\n            calculateSimilartyMap(params.keyPressWidth_samples, params.alignWindow_samples, params.offsetFromPeak_samples, keyPresses, similarityMap);\n        }\n\n        int n = similarityMap.size();\n        ImGui::SameLine();\n        ImGui::SliderFloat(\"Size\", &bsize, 1.5f, 24.0f);\n        ImGui::SameLine();\n        if (ImGui::Button(\"Fit\")) {\n            bsize = (std::min(wsize.x, wsize.y) - 24.0)/n;\n        }\n        ImGui::SameLine();\n        ImGui::SliderFloat(\"Threshold\", &threshold, 0.0f, 1.0f);\n        ImGui::SameLine();\n        if (ImGui::Button(\"Adjust\")) {\n            adjustKeyPresses(params, keyPresses, similarityMap);\n        }\n        ImGui::PopItemWidth();\n\n        ImGui::BeginChild(\"Canvas\", { 0, 0 }, 1, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_AlwaysVerticalScrollbar);\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n\n        int hoveredId = -1;\n        if (n > 0) {\n            ImGui::InvisibleButton(\"SimilarityMapIB\", { n*bsize, n*bsize });\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    float col = similarityMap[i][j].cc;\n                    ImVec2 p0 = {savePos.x + j*bsize, savePos.y + i*bsize};\n                    ImVec2 p1 = {savePos.x + (j + 1)*bsize - 1.0f, savePos.y + (i + 1)*bsize - 1.0f};\n                    if (similarityMap[i][j].cc > threshold) {\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, col}));\n                    }\n                    if (ImGui::IsMouseHoveringRect(p0, {p1.x + 1.0f, p1.y + 1.0f})) {\n                        if (i == j) hoveredId = i;\n                        if (ImGui::IsMouseDown(0) == false) {\n                            ImGui::BeginTooltip();\n                            ImGui::Text(\"[%3d, %3d]\\n\", keyPresses[i].cid, keyPresses[j].cid);\n                            ImGui::Text(\"[%3d, %3d] = %5.4g\\n\", i, j, similarityMap[i][j].cc);\n                            for (int k = 0; k < n; ++k) {\n                                if (similarityMap[i][k].cc > 0.5) ImGui::Text(\"Offset [%3d, %3d] = %d\\n\", i, k, (int) similarityMap[i][k].offset);\n                            }\n                            ImGui::Separator();\n                            for (int k = 0; k < n; ++k) {\n                                if (similarityMap[k][i].cc > 0.5) ImGui::Text(\"Offset [%3d, %3d] = %d\\n\", k, i, (int) similarityMap[k][i].offset);\n                            }\n                            ImGui::EndTooltip();\n                        }\n                    }\n                }\n            }\n\n            if (hoveredId >= 0) {\n                for (int i = 0; i < n; ++i) {\n                    if (keyPresses[i].cid == keyPresses[hoveredId].cid) {\n                        ImVec2 p0 = {savePos.x + i*bsize, savePos.y + i*bsize};\n                        ImVec2 p1 = {savePos.x + (i + 1)*bsize - 1.0f, savePos.y + (i + 1)*bsize - 1.0f};\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({1.0f, 0.0f, 0.0f, 1.0f}));\n                    }\n                }\n            }\n        }\n\n        ImGui::EndChild();\n    }\n    ImGui::End();\n    return false;\n}\n\nbool renderClusters(TParameters & params, const Cipher::TFreqMap & freqMap, TKeyPressCollection & keyPresses, TSimilarityMap & similarityMap) {\n    ImGui::SetNextWindowPos(ImVec2(0.5f*g_windowSizeX, 350.0f), ImGuiCond_Once);\n    ImGui::SetNextWindowSize(ImVec2(0.5f*g_windowSizeX, g_windowSizeY - 350.0f - 300.0f), ImGuiCond_Once);\n    if (ImGui::Begin(\"Clusters\")) {\n        if (ImGui::BeginCombo(\"Approach\", getApproachStr(params.approach).c_str())) {\n            for (int i = 0; i < Approach::COUNT; ++i) {\n                if (ImGui::Selectable(getApproachStr((Approach)(i)).c_str(), params.approach == (Approach)(i))) {\n                    params.approach = (Approach)(i);\n                }\n            }\n            ImGui::EndCombo();\n        }\n\n        if (params.approach == Approach::DBSCAN) {\n            ImGui::SliderFloat(\"Threshold\", &params.thresholdClustering, 0.0f, 1.0f);\n            ImGui::SliderInt(\"N min\", &params.nMinKeysInCluster, 0, 8);\n        }\n        if (params.approach == Approach::ClusterG) {\n            ImGui::SliderFloat(\"Threshold\", &params.thresholdClustering, 0.0f, 1.0f);\n        }\n        if (params.approach == Approach::NonExactSubstitutionCipher0) {\n            ImGui::SliderInt(\"Min Clusters\", &params.cipher.minClusters, 2, 27);\n            ImGui::SliderInt(\"Max Clusters\", &params.cipher.maxClusters, 3, 80);\n            ImGui::SliderFloat(\"English letter frequency weight\", &params.cipher.wEnglishFreq, 0.0f, 20.0f);\n            ImGui::SliderFloat(\"Language model weight\", &params.cipher.wLanguageModel, 0.0f, 2.0f);\n            ImGui::SliderInt(\"Iterations\", &params.cipher.saMaxIterations, 1000, 50000000);\n        }\n\n        ImGui::Text(\"Clusters: %d\\n\", keyPresses.nClusters);\n        if (ImGui::Button(\"Guess spaces\")) {\n            for (auto & key : keyPresses) {\n                key.bind = -1;\n            }\n\n            float step = 0.05f;\n            for (float thold = step; thold < 0.9f; thold += step) {\n                clusterG(similarityMap, keyPresses, thold);\n                if (keyPresses.nClusters > 10) break;\n            }\n\n            int nIters = 1e4;\n            int nUnique = 27;\n            std::string enc = \"\";\n            std::string decrypted = \"\";\n\n            int n = keyPresses.size();\n            enc.resize(n);\n            kN = std::max(nUnique, keyPresses.nClusters);\n            std::vector<int> hint(kN + 1, -1);\n            for (int i = 0; i < n; ++i) {\n                enc[i] = keyPresses[i].cid;\n            }\n            printText(enc);\n            TFreqMap oldFreqMap;\n            auto & len  = std::get<0>(oldFreqMap);\n            auto & fmap = std::get<1>(oldFreqMap);\n            len = freqMap.len;\n            pMin = freqMap.pmin;\n            fmap = freqMap.prob;\n\n            guessSpaces(oldFreqMap, enc, decrypted, nIters, hint);\n            for (int i = 0; i < n; ++i) {\n                if (decrypted[i] < 'a' || decrypted[i] > 'z') {\n                    keyPresses[i].bind = 26;\n                }\n            }\n        }\n\n        if (params.approach == Approach::NonExactSubstitutionCipher0) {\n        } else {\n            ImGui::SameLine();\n            if (ImGui::Button(\"Calculate\") || ImGui::IsKeyPressed(23)) { // t\n                if (params.approach == Approach::ClusterG) {\n                    clusterG(similarityMap, keyPresses, params.thresholdClustering);\n                } else if (params.approach == Approach::DBSCAN) {\n                    clusterDBSCAN(similarityMap, params.thresholdClustering, params.nMinKeysInCluster, keyPresses);\n                }\n\n                float cost = 0.0f;\n                for (int i = 0; i < (int)(keyPresses.size()); ++i) {\n                    for (int j = i+1; j < (int)(keyPresses.size()); ++j) {\n                        if (keyPresses[i].cid == keyPresses[j].cid) {\n                            cost += 1.0f - similarityMap[i][j].cc;\n                        }\n                    }\n                }\n                printf(\"clustering cost = %g\\n\", cost);\n            }\n        }\n\n        ImGui::BeginChildFrame(ImGui::GetID(\"Hints\"), ImGui::GetContentRegionAvail());\n\n        int n = keyPresses.size();\n        ImGui::Text(\"Clusters: %d\\n\", keyPresses.nClusters);\n        ImGui::Text(\" id : cid : predicted : bind\");\n        for (int i = 0; i < n; ++i) {\n            ImGui::Text(\"%3d : %3d : %9c : \", i, keyPresses[i].cid, keyPresses[i].predicted);\n            ImGui::SameLine();\n            ImGui::PushID(i);\n\n            if (ImGui::Button(\"Bind\")) {\n                if (keyPresses[i].predicted >= 'a' && keyPresses[i].predicted <= 'z') {\n                    keyPresses[i].bind = keyPresses[i].predicted - 'a';\n                }\n            }\n            ImGui::SameLine();\n            ImGui::PushItemWidth(100.0);\n            char buf[2] = \"-\";\n            buf[0] = keyPresses[i].bind >= 0 ? (keyPresses[i].bind < 26 ? keyPresses[i].bind + 'a' : '+') : '-';\n            if (ImGui::BeginCombo(\"##bind\", buf, 0)) {\n                if (ImGui::Selectable(\"-\", keyPresses[i].bind < 0)) {\n                    keyPresses[i].bind = -1;\n                }\n                if (ImGui::Selectable(\"+\", keyPresses[i].bind < 0)) {\n                    keyPresses[i].bind = 26;\n                }\n                for (int j = 'a'; j <= 'z'; ++j) {\n                    char buf2[2] = { (char) j, 0 };\n                    if (ImGui::Selectable(buf2, j == keyPresses[i].bind + 'a')) {\n                        keyPresses[i].bind = j - 'a';\n                    }\n                }\n                ImGui::EndCombo();\n            }\n            ImGui::PopItemWidth();\n            ImGui::SameLine();\n            int w = 32;\n            auto cw = ImGui::CalcTextSize(\"a\");\n            for (int j = std::max(0, i - w); j <= std::min(n - 1, i + w); ++j) {\n                if (j == i && keyPresses[j].bind >= 0) {\n                    if (keyPresses[j].bind == 26) {\n                        ImGui::TextColored({ 0.0f, 1.0f, 0.0f, 1.0f }, \"%c\", '.');\n                    } else {\n                        ImGui::TextColored({ 0.0f, 1.0f, 0.0f, 1.0f }, \"%c\", keyPresses[j].bind + 'a');\n                    }\n                } else {\n                    ImGui::Text(\"%c\", keyPresses[j].predicted);\n                }\n                ImGui::SameLine();\n                auto pos = ImGui::GetCursorScreenPos();\n                ImGui::SetCursorScreenPos({ pos.x - cw.x, pos.y });\n            }\n            ImGui::Text(\"%s\", \"\");\n            ImGui::PopID();\n        }\n\n        ImGui::EndChildFrame();\n    }\n    ImGui::End();\n    return false;\n}\n\nbool renderSolution(TParameters & params, const Cipher::TFreqMap & freqMap, TKeyPressCollection & keyPresses, const TSimilarityMap & similarityMap) {\n    static std::string decrypted = \"\";\n\n    ImGui::SetNextWindowPos(ImVec2(0.5f*g_windowSizeX, g_windowSizeY - 300.0f), ImGuiCond_Once);\n    ImGui::SetNextWindowSize(ImVec2(0.5f*g_windowSizeX, 300.0f), ImGuiCond_Once);\n    if (ImGui::Begin(\"Solution\")) {\n        if (params.approach == Approach::NonExactSubstitutionCipher0) {\n            if (ImGui::Button(\"Calculate\")) {\n                TClusterToLetterMap clMap;\n\n                int n = keyPresses.size();\n\n                // todo : consider removing\n                TSimilarityMap ccMap = similarityMap;\n                for (int k0 = 0; k0 < n; ++k0){\n                    for (int k1 = 0; k1 < n; ++k1){\n                        ccMap[k0][k1].cc = 0.5f*(similarityMap[k0][k1].cc + similarityMap[k1][k0].cc);\n                    }\n                }\n\n                std::vector<int> hint(n, -1);\n                for (int i = 0; i < n; ++i) {\n                    if (keyPresses[i].bind < 0) continue;\n                    hint[i] = keyPresses[i].bind + 1;\n                }\n\n                TSimilarityMap logMap;\n                TSimilarityMap logMapInv;\n                Cipher::normalizeSimilarityMap(params.cipher, ccMap, logMap, logMapInv);\n\n                TClusters clusters;\n                Cipher::generateClustersInitialGuess(params.cipher, ccMap, clusters);\n\n                auto clustersNew = clusters;\n                Cipher::mutateClusters(params.cipher, clustersNew);\n                auto pCur = Cipher::calcPClusters(params.cipher, ccMap, logMap, logMapInv, clustersNew);\n                while (true) {\n                    clustersNew = clusters;\n                    Cipher::mutateClusters(params.cipher, clustersNew);\n                    auto pNew = Cipher::calcPClusters(params.cipher, ccMap, logMap, logMapInv, clustersNew);\n\n                    auto u = frand();\n                    //auto alpha = pNew/pCur;\n                    auto alpha = std::exp((pNew - pCur));\n\n                    //printf(\"pNew = %g, pCur = %g, alpha = %g\\n\", pNew, pCur, alpha);\n\n                    if (u <= alpha) {\n                        clusters = clustersNew;\n                        pCur = pNew;\n\n                        //printf(\"pCur = %g, alpha = %g\\n\", pCur, alpha);\n\n                        static int cnt = 99;\n                        if (++cnt >= 10) {\n                            cnt = 0;\n                            params.cipher.nSubbreakIterations = 2000;\n                            Cipher::subbreak(params.cipher, freqMap, clusters, clMap, hint);\n                        }\n                    }\n                }\n\n                //Cipher::doSimulatedAnnealing3(params.cipher, ccMap, clusters, hint);\n                //Cipher::doSimulatedAnnealing4(params.cipher, freqMap, clusters, clMap, hint);\n                //Cipher::doSimulatedAnnealing5(params.cipher, freqMap, ccMap, clusters, clMap, hint);\n                //Cipher::subbreak(params.cipher, freqMap, clusters, clMap, hint);\n\n                decrypted = \"\";\n                for (int i = 0; i < n; ++i) {\n                    keyPresses[i].cid = clusters[i];\n                    if (clMap[clusters[i]] > 0 && clMap[clusters[i]] <= 26) {\n                        keyPresses[i].predicted = 'a' + clMap[clusters[i]]-1;\n                        printf(\"%c\", 'a'+clMap[clusters[i]]-1);\n                        decrypted += 'a'+clMap[clusters[i]]-1;\n                    } else {\n                        keyPresses[i].predicted = '.';\n                        printf(\".\");\n                        decrypted += '.';\n                    }\n                }\n                printf(\"\\n\");\n\n                float cost = 0.0f;\n                for (int i = 0; i < (int)(keyPresses.size()); ++i) {\n                    for (int j = i+1; j < (int)(keyPresses.size()); ++j) {\n                        if (keyPresses[i].cid == keyPresses[j].cid) {\n                            cost += 1.0f - similarityMap[i][j].cc;\n                        }\n                    }\n                }\n                printf(\"clustering cost = %g\\n\", cost);\n            }\n        } else {\n            static int nIters = 1e4;\n            static int nUnique = 27;\n            static std::string enc = \"\";\n\n            ImGui::SliderInt(\"Iterations\", &nIters, 0, 1e5);\n            if (ImGui::Button(\"Calculate\")) {\n                int n = keyPresses.size();\n                enc.resize(n);\n                kN = std::max(nUnique, keyPresses.nClusters);\n                std::vector<int> hint(kN + 1, -1);\n                for (int i = 0; i < n; ++i) {\n                    enc[i] = keyPresses[i].cid;\n                    if (keyPresses[i].bind != -1) {\n                        hint[keyPresses[i].cid] = keyPresses[i].bind + 1;\n                    }\n                }\n                printText(enc);\n                TFreqMap oldFreqMap;\n                auto & len  = std::get<0>(oldFreqMap);\n                auto & fmap = std::get<1>(oldFreqMap);\n                len = freqMap.len;\n                pMin = freqMap.pmin;\n                fmap = freqMap.prob;\n\n                decrypt(oldFreqMap, enc, decrypted, nIters, hint);\n                for (int i = 0; i < n; ++i) keyPresses[i].predicted = decrypted[i];\n                printf(\"Done\\n\");\n            }\n        }\n\n        ImGui::PushTextWrapPos(ImGui::GetContentRegionAvailWidth());\n        ImGui::Text(\"%s\", decrypted.c_str());\n        ImGui::PopTextWrapPos();\n    }\n    ImGui::End();\n\n    return false;\n}\n\nbool prepareAudioOut(const TParameters & params) {\n    if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_FALSE);\n    printf(\"Found %d playback devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Playback device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_FALSE));\n    }\n\n    SDL_AudioSpec playbackSpec;\n    SDL_zero(playbackSpec);\n\n    playbackSpec.freq = params.sampleRate;\n    playbackSpec.format = std::is_same<TSample, int16_t>::value ? AUDIO_S16 : AUDIO_S32;\n    playbackSpec.channels = 1;\n    playbackSpec.samples = TPlaybackData::kSamples;\n    playbackSpec.callback = cbPlayback<TSample>;\n    playbackSpec.userdata = &g_playbackData;\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    g_deviceIdOut = SDL_OpenAudioDevice(NULL, SDL_FALSE, &playbackSpec, &obtainedSpec, 0);\n    if (!g_deviceIdOut) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for playback: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return false;\n    }\n\n    printf(\"Opened playback device %d\\n\", g_deviceIdOut);\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d\\n\", obtainedSpec.format);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    SDL_PauseAudioDevice(g_deviceIdOut, 1);\n\n    return true;\n}\n\nint main(int argc, char ** argv) {\n    srand(time(0));\n\n    printf(\"Usage: %s recrod.kbd n-gram.txt [letter.mask]\\n\", argv[0]);\n    if (argc < 3) {\n        return -1;\n    }\n\n    TParameters params;\n    TWaveform waveformInput;\n    TKeyPressCollection keyPresses;\n    TSimilarityMap similarityMap;\n\n    if (argc > 3) {\n        printf(\"Setting letter mask file '%s'\\n\", argv[3]);\n        params.fnameLetterMask = argv[3];\n    }\n\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) != 0) {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    if (prepareAudioOut(params) == false) {\n        printf(\"Error: failed to initialize audio playback\\n\");\n        return -2;\n    }\n\n    printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n    if (readFromFile<TSampleF>(argv[1], waveformInput) == false) {\n        printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n        return -1;\n    }\n\n    Cipher::TFreqMap freqMap;\n    if (Cipher::loadFreqMap(argv[2], freqMap) == false) {\n        return -1;\n    }\n\n#if __APPLE__\n    // GL 3.2 Core + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#elif __EMSCRIPTEN__\n    const char* glsl_version = \"#version 100\";\n    //const char* glsl_version = \"#version 300 es\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#endif\n\n    // Create window with graphics context\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_DisplayMode current;\n    SDL_GetCurrentDisplayMode(0, &current);\n    SDL_Window* window = SDL_CreateWindow(\"Keytap\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, g_windowSizeX, g_windowSizeY, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE|SDL_WINDOW_ALLOW_HIGHDPI);\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Initialize OpenGL loader\n    bool err = gl3wInit() != 0;\n    if (err) {\n        fprintf(stderr, \"Failed to initialize OpenGL loader!\\n\");\n        return 1;\n    }\n\n    // Setup Dear ImGui binding\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;  // Enable Keyboard Controls\n\n    ImGui::GetStyle().AntiAliasedFill = false;\n    ImGui::GetStyle().AntiAliasedLines = false;\n\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL3_Init(glsl_version);\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) waveformInput.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*waveformInput.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) waveformInput.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(waveformInput.size())/params.sampleRate);\n\n    bool finishApp = false;\n    while (finishApp == false) {\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            switch (event.type) {\n                case SDL_QUIT:\n                    finishApp = true;\n                    break;\n                case SDL_KEYDOWN:\n                    if (event.key.keysym.sym == SDLK_ESCAPE) {\n                        finishApp = true;\n                    }\n                    break;\n                case SDL_WINDOWEVENT:\n                    if (event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(window)) finishApp = true;\n                    break;\n            };\n        }\n\n        SDL_GetWindowSize(window, &g_windowSizeX, &g_windowSizeY);\n\n        auto tStart = std::chrono::high_resolution_clock::now();\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplSDL2_NewFrame(window);\n        ImGui::NewFrame();\n\n        for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i)) {\n            printf(\"Key pressed: %d\\n\", i);\n        }\n\n        renderKeyPresses(params, argv[1], waveformInput, keyPresses);\n        renderSimilarity(params, keyPresses, similarityMap);\n        renderClusters(params, freqMap, keyPresses, similarityMap);\n        renderSolution(params, freqMap, keyPresses, similarityMap);\n\n        ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\n\n        ImGui::Render();\n        SDL_GL_MakeCurrent(window, gl_context);\n        glViewport(0, 0, (int) io.DisplaySize.x, (int) io.DisplaySize.y);\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n        SDL_GL_SwapWindow(window);\n\n        // stupid hack to limit frame-rate to ~60 fps on Mojave\n        auto tEnd = std::chrono::high_resolution_clock::now();\n        auto tus = std::chrono::duration_cast<std::chrono::microseconds>(tEnd - tStart).count();\n        while (tus < 1e6/60.0) {\n            std::this_thread::sleep_for(std::chrono::microseconds(std::max(100, (int) (0.5*(1e6/60.0 - tus)))));\n            tEnd = std::chrono::high_resolution_clock::now();\n            tus = std::chrono::duration_cast<std::chrono::microseconds>(tEnd - tStart).count();\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap2-gui.cpp",
          "type": "blob",
          "size": 71.3251953125,
          "content": "/*! \\file keytap2-gui.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#ifdef __EMSCRIPTEN__\n#include \"emscripten.h\"\n#else\n#define EMSCRIPTEN_KEEPALIVE\n#endif\n\n#include \"build-vars.h\"\n#include \"constants.h\"\n#include \"common.h\"\n#include \"common-gui.h\"\n#include \"subbreak2.h\"\n#include \"audio-logger.h\"\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#include <SDL.h>\n\n#include <atomic>\n#include <cstdio>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <queue>\n#include <functional>\n#include <condition_variable>\n\nstatic std::function<bool()> g_doInit;\nstatic std::function<bool()> g_doReload;\nstatic std::function<void(int, int)> g_setWindowSize;\nstatic std::function<int()> g_getOutputRecordId;\nstatic std::function<bool()> g_mainUpdate;\n\nvoid mainUpdate(void *) {\n    g_mainUpdate();\n}\n\n// JS interface\n\nextern \"C\" {\n    EMSCRIPTEN_KEEPALIVE\n        int do_init() {\n            return g_doInit();\n        }\n\n    EMSCRIPTEN_KEEPALIVE\n        int do_reload() {\n            return g_doReload();\n        }\n\n    EMSCRIPTEN_KEEPALIVE\n        void set_window_size(int sizeX, int sizeY) {\n            g_setWindowSize(sizeX, sizeY);\n        }\n\n    EMSCRIPTEN_KEEPALIVE\n        int get_output_id() {\n            return g_getOutputRecordId();\n        }\n}\n\n#ifdef __EMSCRIPTEN__\n    int g_windowSizeX = 1400;\n    int g_windowSizeY = 900;\n#else\n    int g_windowSizeX = 1920;\n    int g_windowSizeY = 1200;\n#endif\n\nstruct stParameters;\n\nusing TParameters           = stParameters;\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TKeyPressData         = TKeyPressDataI16;\nusing TKeyPressCollection   = TKeyPressCollectionI16;\nusing TPlaybackData         = TPlaybackDataI16;\n\nSDL_AudioDeviceID g_deviceIdOut = 0;\nTPlaybackData g_playbackData;\n\nstruct stParameters {\n    int32_t playbackId              = 0;\n\n    int32_t keyPressWidth_samples   = 256;\n    int32_t offsetFromPeak_samples  = keyPressWidth_samples/2;\n    int32_t alignWindow_samples     = 256;\n\n    std::vector<int>    valuesClusters = { 50, };\n    std::vector<float>  valuesPNonAlphabetic = { 0.05, 0.02, 0.01, };\n    std::vector<float>  valuesWEnglishFreq = { 20.0 };\n\n    int32_t nProcessors() const {\n        return valuesClusters.size()*valuesPNonAlphabetic.size()*valuesWEnglishFreq.size();\n    }\n\n    int32_t valueForProcessorClusters(int idx) const {\n      return valuesClusters[idx/(valuesPNonAlphabetic.size()*valuesWEnglishFreq.size())];\n    }\n\n    float valueForProcessorPNonAlphabetic(int idx) const {\n        return valuesPNonAlphabetic[(idx/valuesWEnglishFreq.size())%valuesPNonAlphabetic.size()];\n    }\n\n    float valueForProcessorWEnglishFreq(int idx) const {\n        return valuesWEnglishFreq[idx%valuesWEnglishFreq.size()];\n    }\n\n    Cipher::TParameters cipher;\n};\n\nstruct stStateUI {\n    bool doUpdate = false;\n\n    struct Flags {\n        bool recalculateSimilarityMap = false;\n        bool resetOptimization = false;\n        bool changeProcessing = false;\n        bool applyClusters = false;\n        bool applyWEnglishFreq = false;\n        bool applyHints = false;\n\n        void clear() { memset(this, 0, sizeof(Flags)); }\n    } flags;\n\n    bool autoHint = false;\n    bool processing = true;\n    bool recording = false;\n    bool audioCapture = false;\n    bool calculatingSimilarityMap = false;\n\n    // key presses window\n    bool scrolling = false;\n    bool recalculateKeyPresses = false;\n\n    int nview = -1;\n    int offset = -1;\n    int viewMin = 512;\n    int viewMax = 512;\n    int nviewPrev = -1;\n    int lastSize = -1;\n    int lastKeyPresses = 0;\n\n    float amin = std::numeric_limits<TSample>::min();\n    float amax = std::numeric_limits<TSample>::max();\n\n    float dragOffset = 0.0f;\n    float scrollSize = 18.0f;\n\n    TWaveform waveformLowRes;\n    TWaveform waveformThreshold;\n    TWaveform waveformMax;\n\n    // window sizes\n    float windowHeightTitleBar = 0;\n    float windowHeightKeyPesses = 0;\n    float windowHeightResults = 0;\n    float windowHeightSimilarity = 0;\n\n    bool openAboutWindow = false;\n    bool openParametersWindow = false;\n    bool loadRecord = false;\n    bool loadKeyPresses = false;\n    bool rescaleWaveform = true;\n\n    int outputRecordId = 0;\n\n    double maxSample = 0.0;\n\n    std::string fnameRecord = \"default.kbd\";\n    std::string fnameKeyPressess = \"default.kbd.keys\";\n\n    TParameters params;\n    TWaveformF waveformOriginal;\n    TWaveform waveformInput;\n    TKeyPressCollection keyPresses;\n    TSimilarityMap similarityMap;\n\n    Cipher::THint suggestions;\n\n    struct ProcessorResults : std::vector<Cipher::TResult> {\n        int id = 0;\n    };\n\n    std::map<int, ProcessorResults> results;\n};\n\nstruct stStateCore {\n    struct Flags {\n        bool calculatingSimilarityMap = false;\n        bool updateSimilarityMap = false;\n        bool updateResult[128];\n\n        void clear() { memset(this, 0, sizeof(Flags)); }\n    } flags;\n\n    bool processing = true;\n\n    Cipher::TFreqMap * freqMap[3];\n    TParameters params;\n    TSimilarityMap similarityMap;\n    TKeyPressCollection keyPresses;\n\n    std::map<int, Cipher::Processor> processors;\n};\n\nstruct stStateCapture {\n    struct Flags {\n        bool updateRecord = false;\n\n        void clear() { memset(this, 0, sizeof(Flags)); }\n    } flags;\n\n    AudioLogger::Record recordNew;\n};\n\ntemplate<typename T>\nstruct TripleBuffer : public T {\n    bool update(bool force = false) {\n        std::lock_guard<std::mutex> lock(mutex);\n        hasChanged = true || force;\n        this->flags.clear();\n\n        return true;\n    }\n\n    bool changed() {\n        std::lock_guard<std::mutex> lock(mutex);\n        return hasChanged;\n    }\n\n    const T & get() {\n        std::lock_guard<std::mutex> lock(mutex);\n        if (hasChanged) {\n            out = buffer;\n            hasChanged = false;\n        }\n\n        return out;\n    }\nprivate:\n    bool hasChanged = false;\n\n    T buffer;\n    T out;\n\n    mutable std::mutex mutex;\n};\n\ntemplate<> bool TripleBuffer<stStateUI>::update(bool force) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged && force == false) return false;\n\n    hasChanged = true;\n\n    buffer.flags = this->flags;\n\n    if (this->flags.recalculateSimilarityMap || this->flags.resetOptimization) {\n        buffer.params = this->params;\n        buffer.keyPresses = this->keyPresses;\n    }\n\n    if (this->flags.changeProcessing) {\n        buffer.processing = this->processing;\n    }\n\n    if (this->flags.applyClusters) {\n        buffer.params = this->params;\n    }\n\n    if (this->flags.applyWEnglishFreq) {\n        buffer.params = this->params;\n    }\n\n    if (this->flags.applyHints) {\n        buffer.keyPresses = this->keyPresses;\n    }\n\n    this->flags.clear();\n\n    return true;\n}\n\ntemplate<> bool TripleBuffer<stStateCore>::update(bool force) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged && force == false) return false;\n\n    hasChanged = true;\n\n    buffer.flags = this->flags;\n\n    if (this->flags.updateSimilarityMap) {\n        buffer.similarityMap = this->similarityMap;\n    }\n\n    for (int i = 0; i < this->params.nProcessors(); ++i) {\n        if (this->flags.updateResult[i]) {\n            buffer.processors[i] = this->processors[i];\n        }\n    }\n\n    this->flags.clear();\n\n    return true;\n}\n\ntemplate<> const stStateCapture & TripleBuffer<stStateCapture>::get() {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged) {\n        out = std::move(buffer);\n        hasChanged = false;\n    }\n\n    return out;\n}\n\ntemplate<> bool TripleBuffer<stStateCapture>::update(bool force) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged && force == false) return false;\n\n    hasChanged = true;\n\n    buffer.flags = this->flags;\n\n    if (this->flags.updateRecord) {\n        buffer.recordNew.insert(\n                buffer.recordNew.end(),\n                make_move_iterator(this->recordNew.begin()),\n                make_move_iterator(this->recordNew.end()));\n        this->recordNew.clear();\n    }\n\n    this->flags.clear();\n\n    return true;\n}\n\nstd::atomic<bool> g_doRecord;\nAudioLogger audioLogger;\nTripleBuffer<stStateUI> stateUI;\nTripleBuffer<stStateCore> stateCore;\nTripleBuffer<stStateCapture> stateCapture;\n\nfloat plotWaveform(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return waveform->samples[i];\n}\n\nfloat plotWaveformInverse(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return -waveform->samples[i];\n}\n\nbool renderKeyPresses(stStateUI & stateUI, const TWaveform & waveform, TKeyPressCollection & keyPresses) {\n    auto & params = stateUI.params;\n\n    bool & scrolling = stateUI.scrolling;\n    bool & recalculateKeyPresses = stateUI.recalculateKeyPresses;\n\n    int & nview = stateUI.nview;\n    int & viewMin = stateUI.viewMin;\n    int & viewMax = stateUI.viewMax;\n    int & offset = stateUI.offset;\n    int & lastSize = stateUI.lastSize;\n    int & lastKeyPresses = stateUI.lastKeyPresses;\n\n    float & amin = stateUI.amin;\n    float & amax = stateUI.amax;\n\n    float & dragOffset = stateUI.dragOffset;\n    float & scrollSize = stateUI.scrollSize;\n\n    auto & nviewPrev = stateUI.nviewPrev;\n\n    TWaveform & waveformLowRes = stateUI.waveformLowRes;\n    TWaveform & waveformThreshold = stateUI.waveformThreshold;\n    TWaveform & waveformMax = stateUI.waveformMax;\n\n    if (nview < 0) nview = waveform.size();\n    if (offset < 0) offset = (waveform.size() - nview)/2;\n\n    if (stateUI.recording) {\n        if (nview < 1024*kSamplesPerFrame && scrolling == false) {\n            nview = std::min((int) (1024*kSamplesPerFrame), (int) waveform.size());\n        }\n    }\n\n    if (lastSize != (int) waveform.size()) {\n        viewMax = waveform.size();\n        lastSize = waveform.size();\n        nviewPrev = nview + 1;\n\n        if (scrolling == false) {\n            offset = waveform.size() - nview;\n        }\n    }\n\n#ifndef __EMSCRIPTEN__\n    if ((int) keyPresses.size() >= lastKeyPresses + 10) {\n        lastKeyPresses = keyPresses.size();\n\n        stateUI.similarityMap.clear();\n        stateUI.flags.recalculateSimilarityMap = true;\n        stateUI.doUpdate = true;\n    }\n#endif\n\n    ImGui::SetNextWindowPos(ImVec2(0, stateUI.windowHeightTitleBar), ImGuiCond_Once);\n    if (stateUI.windowHeightKeyPesses == 0.0f) {\n        ImGui::SetNextWindowSize(ImVec2(g_windowSizeX, 250.0f), ImGuiCond_Always);\n    } else {\n        ImGui::SetNextWindowSize(ImVec2(g_windowSizeX, stateUI.windowHeightKeyPesses), ImGuiCond_Always);\n    }\n    if (ImGui::Begin(\"Key Presses\", nullptr, ImGuiWindowFlags_NoMove)) {\n        bool ignoreDelete = false;\n\n        auto wsize = ImVec2(ImGui::GetContentRegionAvailWidth(), ImGui::GetContentRegionAvail().y - 3*ImGui::GetTextLineHeightWithSpacing());\n\n        if (nview != nviewPrev) {\n            generateLowResWaveform(waveform, waveformLowRes, std::max(1.0f, nview/wsize.x));\n            nviewPrev = nview;\n        }\n\n        auto wview = getView(waveformLowRes, offset, nview);\n\n        auto mpos = ImGui::GetIO().MousePos;\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.3f, 0.3f, 0.3f, 0.3f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveform, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.1f, 0.1f, 0.1f, 0.0f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveformInverse, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n\n        if (waveform.size() == waveformThreshold.size() && waveform.size() == waveformMax.size()) {\n            auto tview = getView(waveformThreshold, offset, nview);\n            auto mview = getView(waveformMax, offset, nview);\n\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 1.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformThreshold\", plotWaveform, &tview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 1.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformThreshold\", plotWaveformInverse, &tview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 0.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformMax\", plotWaveform, &mview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 0.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformMax\", plotWaveformInverse, &mview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n        }\n        ImGui::SetCursorScreenPos(savePos);\n\n        ImGui::InvisibleButton(\"##WaveformIB\",wsize);\n        if (ImGui::IsItemHovered()) {\n            auto w = ImGui::GetIO().MouseWheel;\n            auto nview_old = nview;\n            nview *= (10.0 + w)/10.0;\n            nview = std::min(std::max(viewMin, nview), viewMax);\n            if (w != 0.0) {\n                offset = std::max(0.0f, offset + ((mpos.x - savePos.x)/wsize.x)*(nview_old - nview));\n            }\n\n            if (ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0) == false) {\n                dragOffset = offset;\n            }\n\n            if (ImGui::IsMouseDragging(0)) {\n                offset = dragOffset - ImGui::GetMouseDragDelta(0).x*nview/wsize.x;\n            }\n\n            if ((ImGui::IsMouseReleased(0) && ImGui::GetIO().KeyCtrl) || ImGui::IsMouseDoubleClicked(0)) {\n                int i = 0;\n                int64_t pos = offset + nview*(mpos.x - savePos.x)/wsize.x;\n                for (i = 0; i < (int) keyPresses.size(); ++i) {\n                    int64_t p0 = keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples;\n                    int64_t p1 = keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples;\n                    int64_t pmin = std::min(std::min(keyPresses[i].pos, p0), p1);\n                    int64_t pmax = std::max(std::max(keyPresses[i].pos, p0), p1);\n                    if (pmin > pos) {\n                        ignoreDelete = true;\n                        TKeyPressData entry;\n                        entry.pos = pos;\n                        entry.waveform = getView(waveform, 0);\n                        keyPresses.insert(keyPresses.begin() + i, entry);\n                        break;\n                    }\n                    if (pos >= pmin && pos <= pmax) break;\n                }\n                if (i == (int) keyPresses.size() && ignoreDelete == false) {\n                    ignoreDelete = true;\n                    TKeyPressData entry;\n                    entry.pos = pos;\n                    entry.waveform = getView(waveform, 0);\n                    keyPresses.push_back(entry);\n                }\n            }\n        }\n        if (ImGui::BeginPopupContextWindow()) {\n            ImGui::SliderInt(\"View  \", &nview, viewMin, viewMax);\n            ImGui::DragInt  (\"Offset\", &offset, 0.01*nview, 0, waveform.size() - nview);\n            ImGui::SliderFloat(\"Amplitude Min\", &amin, -32000, 0);\n            ImGui::SliderFloat(\"Amplitude Max\", &amax, 0, 32000);\n            ImGui::EndPopup();\n        }\n\n        ImGui::InvisibleButton(\"##WaveformScrollIB\", {wsize.x, scrollSize});\n        drawList->AddRect({savePos.x, savePos.y + wsize.y}, {savePos.x + wsize.x, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n        drawList->AddRectFilled({savePos.x + wsize.x*(1.f*offset)/viewMax, savePos.y + wsize.y}, {savePos.x + wsize.x*(1.f*offset + nview)/viewMax, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n\n        auto savePos2 = ImGui::GetCursorScreenPos();\n\n        if (ImGui::IsItemHovered()) {\n            if (ImGui::IsMouseDown(0)) {\n                scrolling = true;\n            }\n        }\n\n        if (scrolling) {\n            offset = ((mpos.x - savePos.x)/wsize.x)*viewMax - nview/2;\n        }\n\n        if (ImGui::IsMouseDown(0) == false) {\n            scrolling = false;\n        }\n\n        offset = std::max(0, std::min((int) offset, (int) waveform.size() - nview));\n        for (int i = 0; i < (int) keyPresses.size(); ++i) {\n            if (keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples < offset) continue;\n            if (keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples >= offset + nview) break;\n\n            {\n                float x0 = ((float)(keyPresses[i].pos - offset))/nview;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                ImVec2 p1 = { savePos.x + x0*wsize.x, savePos.y + wsize.y };\n\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 0.8f }), 1.0f);\n            }\n\n            {\n                float x0 = ((float)(keyPresses[i].pos - offset))/nview;\n                float x1 = ((float)(keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples - offset))/nview;\n                float x2 = ((float)(keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples - offset))/nview;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                ImVec2 p1 = { savePos.x + x1*wsize.x, savePos.y };\n                ImVec2 p2 = { savePos.x + x2*wsize.x, savePos.y + wsize.y };\n\n                float xmin = std::min(std::min(p0.x, p1.x), p2.x);\n                float xmax = std::max(std::max(p0.x, p1.x), p2.x);\n\n                bool isHovered = (mpos.x > xmin && mpos.x < xmax && mpos.y > p1.y && mpos.y < p2.y);\n\n                float col = isHovered ? 0.7f : 0.3f;\n                drawList->AddRectFilled(p1, p2, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, col }));\n\n                if (isHovered) {\n                    if (((ImGui::IsMouseReleased(0) && ImGui::GetIO().KeyCtrl) || ImGui::IsMouseDoubleClicked(0)) && ignoreDelete == false) {\n                        keyPresses.erase(keyPresses.begin() + i);\n                        --i;\n                    }\n                }\n\n                if (nview < 64.0*wsize.x) {\n                    ImGui::SetCursorScreenPos({ savePos.x + 0.5f*((x1 + x2)*wsize.x - ImGui::CalcTextSize(std::to_string(i).c_str()).x), savePos.y + wsize.y - ImGui::GetTextLineHeightWithSpacing() });\n                    ImGui::Text(\"%d\", i);\n                }\n\n            }\n\n            {\n                float x0 = ((float)(g_playbackData.offset + g_playbackData.idx - offset))/nview;\n\n                ImVec2 p0 = {savePos.x + x0*wsize.x, savePos.y};\n                ImVec2 p1 = {savePos.x + x0*wsize.x, savePos.y + wsize.y};\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 0.0f, 0.3f }));\n            }\n        }\n        for (int i = 0; i < (int) keyPresses.size(); ++i) {\n            {\n                float x0 = ((float)(keyPresses[i].pos))/viewMax;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y + wsize.y };\n                ImVec2 p1 = { savePos.x + x0*wsize.x, savePos.y + wsize.y + scrollSize };\n\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 0.3f }));\n            }\n        }\n\n        ImGui::SetCursorScreenPos(savePos2);\n\n        //auto io = ImGui::GetIO();\n        //ImGui::Text(\"Keys pressed:\");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text(\"%d\", i); }\n\n        static bool playHalfSpeed = false;\n        static int historySize = 2*1024;\n        static float thresholdBackground = 8.0;\n        ImGui::PushItemWidth(100.0);\n\n        if (stateUI.recording == false) {\n            if (stateUI.audioCapture) {\n                if (ImGui::Button(\"   Record\")) {\n                    if (float(stateUI.waveformInput.size()/kSampleRate) < kMaxRecordSize_s) {\n                        audioLogger.resume();\n                        stateUI.recording = true;\n                        g_doRecord = true;\n                    }\n                }\n                {\n                    auto savePos = ImGui::GetCursorScreenPos();\n                    auto p = savePos;\n                    p.x += 0.90f*ImGui::CalcTextSize(\"  \").x;\n                    p.y -= 0.56f*ImGui::GetFrameHeightWithSpacing();\n                    ImGui::GetWindowDrawList()->AddCircleFilled(p, 6.0, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 1.0f }));\n                    ImGui::SetCursorScreenPos(savePos);\n                }\n\n                ImGui::SameLine();\n            }\n\n            ImGui::Checkbox(\"x0.5\", &playHalfSpeed);\n            ImGui::SameLine();\n            if (g_playbackData.playing) {\n                if (ImGui::Button(\"Stop\") || (ImGui::IsKeyPressed(44) && ImGui::GetIO().KeyCtrl)) { // Ctrl + space\n                    g_playbackData.playing = false;\n                    g_playbackData.idx = g_playbackData.waveform.n - TPlaybackData::kSamples;\n                }\n            } else {\n                if (ImGui::Button(\"Play\") || (ImGui::IsKeyPressed(44) && ImGui::GetIO().KeyCtrl)) { // Ctrl + space\n                    g_playbackData.playing = true;\n                    g_playbackData.slowDown = playHalfSpeed ? 2 : 1;\n                    g_playbackData.idx = 0;\n                    g_playbackData.offset = offset;\n                    g_playbackData.waveform = getView(waveform, offset, std::min((int) (10*kSampleRate), nview));\n                    SDL_PauseAudioDevice(g_deviceIdOut, 0);\n                }\n            }\n\n            if (g_playbackData.idx >= g_playbackData.waveform.n - kSamplesPerFrame) {\n                g_playbackData.playing = false;\n                SDL_ClearQueuedAudio(g_deviceIdOut);\n#ifndef __EMSCRIPTEN__\n                SDL_PauseAudioDevice(g_deviceIdOut, 1);\n#endif\n            }\n\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"Threshold background\", &thresholdBackground, 0.1f, 50.0f) && (recalculateKeyPresses = true);\n            ImGui::SameLine();\n            ImGui::SliderInt(\"History Size\", &historySize, 512, 1024*16) && (recalculateKeyPresses = true);\n            ImGui::SameLine();\n            if (ImGui::Button(\"Recalculate\")) {\n                recalculateKeyPresses = true;\n            }\n\n            ImGui::SameLine();\n            ImGui::DragInt(\"Key width\", &params.keyPressWidth_samples, 8, 0, kSampleRate/10);\n            ImGui::SameLine();\n            ImGui::DragInt(\"Peak offset\", &params.offsetFromPeak_samples, 8, -kSampleRate/10, kSampleRate/10);\n            ImGui::SameLine();\n            ImGui::DragInt(\"Align window\", &params.alignWindow_samples, 8, 0, kSampleRate/10);\n\n            ImGui::PopItemWidth();\n        } else {\n            if (g_doRecord) {\n                g_doRecord = false;\n                audioLogger.record(0.2f, 0);\n            }\n\n            if (ImGui::Button(\"   Stop Recording\")) {\n                audioLogger.pause();\n                g_doRecord = false;\n\n                stateUI.recalculateKeyPresses = true;\n                stateUI.lastSize = stateUI.lastSize - 1;\n                stateUI.recording = false;\n                stateUI.rescaleWaveform = true;\n            }\n            {\n                auto savePos = ImGui::GetCursorScreenPos();\n                auto p0 = savePos;\n                p0.x += 0.90f*ImGui::CalcTextSize(\"  \").x;\n                p0.y -= 0.56f*ImGui::GetFrameHeightWithSpacing();\n\n                auto p1 = p0;\n                p0.x -= 4.0f;\n                p0.y -= 4.0f;\n                p1.x += 4.0f;\n                p1.y += 4.0f;\n\n                ImGui::GetWindowDrawList()->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 1.0f, 1.0f }));\n                ImGui::SetCursorScreenPos(savePos);\n            }\n\n            ImGui::SameLine();\n            ImGui::Text(\"Record length: %4.2f s (max : %4.2f s)\", (float)(stateUI.waveformInput.size())/kSampleRate, kMaxRecordSize_s);\n        }\n\n        if (recalculateKeyPresses) {\n            findKeyPresses(getView(waveform, 0), keyPresses, waveformThreshold, waveformMax, thresholdBackground, 512, historySize, true);\n            recalculateKeyPresses = false;\n        }\n\n        stateUI.windowHeightKeyPesses = ImGui::GetWindowHeight();\n    } else {\n        stateUI.windowHeightKeyPesses = ImGui::GetTextLineHeightWithSpacing();\n    }\n    ImGui::End();\n\n    return false;\n}\n\nbool renderResults(stStateUI & stateUI) {\n    float curHeight = std::min(g_windowSizeY - stateUI.windowHeightTitleBar - stateUI.windowHeightKeyPesses, (12 + stateUI.results.size()*kTopResultsPerProcessor)*ImGui::GetTextLineHeightWithSpacing());\n    ImGui::SetNextWindowPos(ImVec2(0, stateUI.windowHeightTitleBar + stateUI.windowHeightKeyPesses), ImGuiCond_Always);\n    ImGui::SetNextWindowSize(ImVec2(1.0f*g_windowSizeX, curHeight), ImGuiCond_Always);\n    if (ImGui::Begin(\"Results\", nullptr, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoMove)) {\n        auto drawList = ImGui::GetWindowDrawList();\n\n        if (ImGui::Button(\"Calculate Key Similarity\")) {\n            stateUI.similarityMap.clear();\n            stateUI.flags.recalculateSimilarityMap = true;\n            stateUI.doUpdate = true;\n        }\n\n        if (stateUI.similarityMap.size() > 0 && stateUI.calculatingSimilarityMap == false) {\n            ImGui::SameLine();\n            if (stateUI.processing) {\n                if (ImGui::Button(\"Pause\") || (ImGui::IsKeyPressed(44) && !ImGui::GetIO().KeyCtrl)) { // space\n                    stateUI.processing = false;\n                    stateUI.flags.changeProcessing = true;\n                    stateUI.doUpdate = true;\n                }\n            } else {\n                if (ImGui::Button(\"Resume\") || (ImGui::IsKeyPressed(44) && !ImGui::GetIO().KeyCtrl)) { // space\n                    stateUI.processing = true;\n                    stateUI.flags.changeProcessing = true;\n                    stateUI.doUpdate = true;\n                }\n            }\n\n            ImGui::SameLine();\n            if (ImGui::Button(\"Reset\")) { // c\n                stateUI.results.clear();\n                if (stateUI.autoHint) {\n                    for (auto & keyPress : stateUI.keyPresses) {\n                        keyPress.bind = -1;\n                    }\n                }\n                stateUI.flags.resetOptimization = true;\n                stateUI.doUpdate = true;\n            }\n\n            //ImGui::SameLine();\n            //if (ImGui::Button(\"Apply Suggestions\")) {\n            //    int n = stateUI.suggestions.size();\n            //    for (int i = 0; i < n; ++i) {\n            //        if (stateUI.suggestions[i] < 0) {\n            //            stateUI.keyPresses[i].bind = -1;\n            //            continue;\n            //        }\n            //        if (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) {\n            //            stateUI.keyPresses[i].bind = stateUI.suggestions[i] - 1;\n            //        } else {\n            //            stateUI.keyPresses[i].bind = 26;\n            //        }\n            //    }\n\n            //    stateUI.flags.applyHints = true;\n            //    stateUI.doUpdate = true;\n            //}\n\n            ImGui::SameLine();\n            if (ImGui::Button(\"Clear Hints\")) {\n                for (auto & keyPress : stateUI.keyPresses) {\n                    keyPress.bind = -1;\n                }\n                stateUI.flags.applyHints = true;\n                stateUI.doUpdate = true;\n            }\n        } else {\n            if (stateUI.calculatingSimilarityMap) {\n                ImGui::SameLine();\n                ImGui::TextColored({0.3f, 1.0f, 0.4f, 1.0f}, \"Calculating similarity map ...\");\n            }\n        }\n\n        ImGui::PushItemWidth(200.0);\n\n        if (ImGui::SliderInt(\"Clusters\", &stateUI.params.valuesClusters[0], 30, 150.0)) {\n            stateUI.flags.applyClusters = true;\n            stateUI.doUpdate = true;\n        }\n\n        ImGui::SameLine();\n        if (ImGui::Checkbox(\"Auto\", &stateUI.autoHint)) {\n        }\n        if (ImGui::IsItemHovered()) {\n            ImGui::BeginTooltip();\n            ImGui::Text(\"If checked, hints will be updated automatically based on the suggestions\");\n            ImGui::EndTooltip();\n        }\n\n        if (stateUI.results.size() > 0) {\n            int nPerAutoHint = 10;\n            auto id0 = stateUI.results.begin()->second.id%stateUI.params.cipher.nMHIters;\n            auto id1 = (stateUI.results.begin()->second.id/stateUI.params.cipher.nMHIters)%nPerAutoHint;\n            if (stateUI.processing) stateUI.results.begin()->second.id++;\n            ImGui::SameLine();\n            auto progress = float(id1)/nPerAutoHint;\n            ImGui::ProgressBar(progress, { 100.0, ImGui::GetTextLineHeightWithSpacing() });\n            if (stateUI.processing && id0 == 0 && id1 == 0) {\n                for (auto & result : stateUI.results) {\n                    for (auto & item : result.second) {\n                        item.p *= 1.01;\n                    }\n                }\n                if (stateUI.autoHint && stateUI.results.begin()->second.id > 10000) {\n                    int n = stateUI.suggestions.size();\n                    for (int i = 0; i < n; ++i) {\n                        if (frand() > 0.2) {\n                            stateUI.keyPresses[i].bind = -1;\n                            continue;\n                        }\n                        if (stateUI.suggestions[i] < 0) {\n                            stateUI.keyPresses[i].bind = -1;\n                            continue;\n                        }\n\n                        //if (stateUI.suggestions[i] == 0 || stateUI.suggestions[i] == 5) {\n                        //    stateUI.keyPresses[i].bind = rand()%2 == 0 ? 26 : 4;\n                        //    continue;\n                        //}\n\n                        //if (stateUI.suggestions[i] == 0 || stateUI.suggestions[i] == 5) {\n                        //    stateUI.keyPresses[i].bind = -1;\n                        //    continue;\n                        //}\n\n                        if (frand() > 0.0) {\n                            if (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) {\n                                stateUI.keyPresses[i].bind = stateUI.suggestions[i] - 1;\n                            } else {\n                                stateUI.keyPresses[i].bind = 26;\n                            }\n                        } else {\n                            char c0 = (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) ?\n                                'a' + stateUI.suggestions[i] - 1 : '_';\n\n                            int idx = rand()%kNearbyKeys.at(c0).size();\n                            char c1 = kNearbyKeys.at(c0)[idx];\n\n                            if (c1 == '_') {\n                                stateUI.keyPresses[i].bind = 26;\n                            } else {\n                                stateUI.keyPresses[i].bind = c1 - 'a';\n                            }\n                        }\n                    }\n                    stateUI.flags.applyHints = true;\n                    stateUI.flags.applyWEnglishFreq = true;\n                    stateUI.doUpdate = true;\n                }\n            }\n        }\n\n        //ImGui::SameLine();\n        //if (ImGui::SliderFloat(\"English weight\", &stateUI.params.valuesWEnglishFreq[0], 1.0, 100.0, \"%.6f\", 2.0)) {\n        //    stateUI.flags.applyWEnglishFreq = true;\n        //    stateUI.doUpdate = true;\n        //}\n\n        ImGui::PopItemWidth();\n\n        ImGui::BeginChild(\"##currentResults\", { 0, 0 }, 1, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);\n\n        ImGui::Separator();\n        ImGui::Text(\" Suggestions\");\n        {\n            int n = stateUI.suggestions.size();\n            if (n > 0) {\n                ImGui::SameLine();\n                auto charSize = ImGui::CalcTextSize(\"a\");\n                auto curPos = ImGui::GetCursorScreenPos();\n                ImGui::InvisibleButton(\"\", ImVec2{charSize.x*n, 1.0f});\n                ImGui::SetCursorScreenPos(curPos);\n                for (int i = 0; i < n; ++i) {\n                    char c = ' ';\n                    if (stateUI.suggestions[i] < 0) {\n                        ImGui::Text(\" \");\n                    } else {\n                        c = '_';\n                        if (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) {\n                            c = 'a'+stateUI.suggestions[i] - 1;\n                        }\n                        ImGui::TextColored({ 1.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                    }\n                    if (ImGui::IsItemHovered()) {\n                        ImGui::BeginTooltip();\n                        ImGui::Text(\"Suggestion for key press %d: '%c'\", i, c);\n                        ImGui::EndTooltip();\n                    }\n                    if (i < n - 1) {\n                        curPos.x += charSize.x;\n                        ImGui::SetCursorScreenPos(curPos);\n                    }\n                }\n            }\n        }\n\n        ImGui::Text(\"       Hints\");\n        {\n            int n = stateUI.keyPresses.size();\n            if (n > 0) {\n                ImGui::SameLine();\n                auto charSize = ImGui::CalcTextSize(\"a\");\n                auto curPos = ImGui::GetCursorScreenPos();\n                ImGui::InvisibleButton(\"\", ImVec2{charSize.x*n, 1.0f});\n                ImGui::SetCursorScreenPos(curPos);\n                for (int i = 0; i < n; ++i) {\n                    if (stateUI.keyPresses[i].bind < 0) {\n                        ImGui::Text(\".\");\n                    } else {\n                        char c = '_';\n                        if (stateUI.keyPresses[i].bind >= 0 && stateUI.keyPresses[i].bind < 26) {\n                            c = 'a'+stateUI.keyPresses[i].bind;\n                        }\n                        ImGui::TextColored({ 0.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                    }\n                    if (ImGui::IsItemHovered()) {\n                        auto p0 = curPos;\n                        auto p1 = p0;\n                        p1.x += charSize.x;\n                        p1.y += charSize.y;\n                        drawList->AddRect(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 1.0f}));\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 0.6f}));\n\n                        if (ImGui::IsMouseDown(0)) {\n                            stateUI.nview = 16*1024;\n                            stateUI.offset = stateUI.keyPresses[i].pos - stateUI.nview/2;\n                        }\n\n                        if (ImGui::IsMouseDown(1)) {\n                            stateUI.keyPresses[i].bind = -1;\n                            stateUI.flags.applyHints = true;\n                            stateUI.doUpdate = true;\n                        }\n\n                        if (ImGui::IsMouseDown(2)) {\n                            stateUI.keyPresses[i].bind = 26;\n                            stateUI.flags.applyHints = true;\n                            stateUI.doUpdate = true;\n                        }\n\n                        for (int k = 0; k < 26; ++k) {\n                            if (ImGui::IsKeyPressed(4 + k)) {\n                                stateUI.keyPresses[i].bind = k;\n                            }\n                        }\n\n                        ImGui::BeginTooltip();\n                        ImGui::Text(\"Key press: %d\", i);\n                        ImGui::Text(\" - Left click to focus\");\n                        ImGui::Text(\" - Right click to remove hint\");\n                        ImGui::Text(\" - Middle click to put a space as hint\");\n                        ImGui::EndTooltip();\n                    }\n                    if (i < n - 1) {\n                        curPos.x += charSize.x;\n                        ImGui::SetCursorScreenPos(curPos);\n                    }\n                }\n            }\n        }\n\n        ImGui::Text(\"%2s. %8s\", \"#\", \"Prob\");\n        ImGui::Separator();\n\n        for (const auto & items : stateUI.results) {\n            ImGui::Separator();\n            const auto & id = items.first;\n            for (const auto & item : items.second) {\n                const auto & result = item;\n\n                ImGui::PushID(id);\n                ImGui::Text(\"%2d. %8.3f\", id, result.p);\n                if (ImGui::IsItemHovered()) {\n                    ImGui::BeginTooltip();\n                    ImGui::Text(\"Processor   %d\", id);\n                    ImGui::Text(\"Cluster-to-letter map:\");\n                    {\n                        int i = 0;\n                        for (auto& pair : result.clMap) {\n                            char c = '_';\n                            if (pair.second > 0 && pair.second <= 26) {\n                                c = 'a' + pair.second - 1;\n                            }\n                            ImGui::Text(\"%3d: %c  \", pair.first, c);\n                            if (++i % 10 != 0) ImGui::SameLine();\n                        }\n                    }\n                    ImGui::EndTooltip();\n                }\n                if (result.clMap.empty() == false) {\n                    ImGui::SameLine();\n                    int n = std::min(result.clusters.size(), stateUI.keyPresses.size());\n                    auto charSize = ImGui::CalcTextSize(\"a\");\n                    auto curPos = ImGui::GetCursorScreenPos();\n                    if (n > 0) {\n                        ImGui::InvisibleButton(\"\", ImVec2{charSize.x*n, 1.0f});\n                        ImGui::SetCursorScreenPos(curPos);\n                        for (int i = 0; i < n; ++i) {\n                            auto cluster = result.clusters[i];\n                            if (result.clMap.find(cluster) == result.clMap.end()) {\n                                ImGui::Text(\"%c\", '?');\n                            } else {\n                                auto let = result.clMap.at(result.clusters[i]);\n\n                                char c = '.';\n                                if (let > 0 && let <= 26) {\n                                    c = 'a'+let - 1;\n                                }\n\n                                if (stateUI.keyPresses[i].bind == let - 1) {\n                                    ImGui::TextColored({ 0.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                                } else if (stateUI.suggestions[i] == let) {\n                                    ImGui::TextColored({ 1.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                                } else {\n                                    ImGui::Text(\"%c\", c);\n                                }\n\n                                if (ImGui::IsItemHovered()) {\n                                    auto p0 = curPos;\n                                    auto p1 = p0;\n                                    p1.x += charSize.x;\n                                    p1.y += charSize.y;\n                                    drawList->AddRect(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 1.0f}));\n                                    drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 0.6f}));\n                                    if (ImGui::IsMouseDown(0) && ImGui::GetIO().KeyCtrl) {\n                                        for (int j = 0; j < n; ++j) {\n                                            auto let2 = result.clMap.at(result.clusters[j]);\n                                            if (let2 > 0 && let2 <= 26) {\n                                                if (stateUI.keyPresses[j].bind == 26) {\n                                                    stateUI.keyPresses[j].bind = -1;\n                                                }\n                                            } else {\n                                                stateUI.keyPresses[j].bind = 26;\n                                            }\n                                        }\n                                        stateUI.flags.applyHints = true;\n                                        stateUI.doUpdate = true;\n                                    } else if (ImGui::IsMouseDown(0)) {\n                                        if (let > 0 && let <= 26) {\n                                            stateUI.keyPresses[i].bind = let - 1;\n                                        } else {\n                                            stateUI.keyPresses[i].bind = 26;\n                                        }\n                                        stateUI.flags.applyHints = true;\n                                        stateUI.doUpdate = true;\n                                    } else if (ImGui::IsMouseDown(1)) {\n                                        stateUI.keyPresses[i].bind = -1;\n                                    }\n                                    ImGui::BeginTooltip();\n                                    ImGui::Text(\"Key presss: %d, letter - %d\", i, let);\n                                    ImGui::Text(\" - Left click to set as hint\");\n                                    ImGui::Text(\" - Ctrl + left click to set only the spaces as hint\");\n                                    ImGui::EndTooltip();\n                                }\n                            }\n\n                            if (i < n - 1) {\n                                curPos.x += charSize.x;\n                                ImGui::SetCursorScreenPos(curPos);\n                            }\n                        }\n                    }\n                }\n                ImGui::PopID();\n            }\n        }\n\n        ImGui::EndChild();\n\n        stateUI.windowHeightResults = ImGui::GetWindowHeight();\n    } else {\n        stateUI.windowHeightResults = ImGui::GetTextLineHeightWithSpacing();\n    }\n\n    ImGui::End();\n    return true;\n}\n\nbool renderSimilarity(const TKeyPressCollection & keyPresses, const TSimilarityMap & similarityMap) {\n    int offsetY = stateUI.windowHeightTitleBar + stateUI.windowHeightKeyPesses + stateUI.windowHeightResults;\n    ImGui::SetNextWindowPos(ImVec2(0, offsetY), ImGuiCond_Always);\n    ImGui::SetNextWindowSize(ImVec2(1.0f*g_windowSizeX, g_windowSizeY - offsetY), ImGuiCond_Always);\n    if (ImGui::Begin(\"Similarity\", nullptr, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoMove)) {\n        auto wsize = ImGui::GetContentRegionAvail();\n\n        static float bsize = 10.0f;\n        static float threshold = 0.0f;\n        ImGui::PushItemWidth(100.0);\n\n        int n = similarityMap.size();\n        ImGui::SameLine();\n        ImGui::SliderFloat(\"Size\", &bsize, 1.5f, 24.0f);\n        ImGui::SameLine();\n        if (ImGui::Button(\"Fit\")) {\n            bsize = (std::min(wsize.x, wsize.y) - 24.0)/n;\n        }\n        ImGui::SameLine();\n        ImGui::SliderFloat(\"Threshold\", &threshold, 0.0f, 1.0f);\n        ImGui::PopItemWidth();\n\n        ImGui::BeginChild(\"Canvas\", { 0, 0 }, 1, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_AlwaysVerticalScrollbar);\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n\n        int hoveredId = -1;\n        if (n > 0) {\n            ImGui::InvisibleButton(\"SimilarityMapIB\", { n*bsize, n*bsize });\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    float col = similarityMap[i][j].cc;\n                    ImVec2 p0 = {savePos.x + j*bsize, savePos.y + i*bsize};\n                    ImVec2 p1 = {savePos.x + (j + 1)*bsize - 1.0f, savePos.y + (i + 1)*bsize - 1.0f};\n                    if (similarityMap[i][j].cc > threshold) {\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32(ImVec4{1.0f - col, col, 0.0f, col}));\n                    }\n                    if (ImGui::IsMouseHoveringRect(p0, {p1.x + 1.0f, p1.y + 1.0f})) {\n                        if (i == j) hoveredId = i;\n                        if (ImGui::IsMouseDown(0) == false) {\n                            ImGui::BeginTooltip();\n                            //ImGui::Text(\"[%3d, %3d]\\n\", keyPresses[i].cid, keyPresses[j].cid);\n                            ImGui::Text(\"[%3d, %3d] = %5.4g\\n\", i, j, similarityMap[i][j].cc);\n                            //for (int k = 0; k < n; ++k) {\n                            //    if (similarityMap[i][k].cc > 0.5) ImGui::Text(\"Offset [%3d, %3d] = %d\\n\", i, k, (int) similarityMap[i][k].offset);\n                            //}\n                            //ImGui::Separator();\n                            //for (int k = 0; k < n; ++k) {\n                            //    if (similarityMap[k][i].cc > 0.5) ImGui::Text(\"Offset [%3d, %3d] = %d\\n\", k, i, (int) similarityMap[k][i].offset);\n                            //}\n                            ImGui::EndTooltip();\n                        }\n                    }\n                }\n            }\n\n            if (hoveredId >= 0) {\n                for (int i = 0; i < n; ++i) {\n                    if (keyPresses[i].cid == keyPresses[hoveredId].cid) {\n                        ImVec2 p0 = {savePos.x + i*bsize, savePos.y + i*bsize};\n                        ImVec2 p1 = {savePos.x + (i + 1)*bsize - 1.0f, savePos.y + (i + 1)*bsize - 1.0f};\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({1.0f, 0.0f, 0.0f, 1.0f}));\n                    }\n                }\n            }\n        } else {\n            ImGui::TextColored({1.0f, 0.3f, 0.4f, 1.0f}, \"Waiting for similarity map to be available!\");\n        }\n\n        ImGui::EndChild();\n\n        stateUI.windowHeightSimilarity = ImGui::GetWindowHeight();\n    } else {\n        stateUI.windowHeightSimilarity = ImGui::GetTextLineHeightWithSpacing();\n    }\n    ImGui::End();\n    return false;\n}\n\nbool prepareAudioOut(const TParameters & params) {\n    if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_FALSE);\n    printf(\"Found %d playback devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Playback device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_FALSE));\n    }\n\n    if (params.playbackId < 0 || params.playbackId >= nDevices) {\n        printf(\"Invalid playback device id selected - %d\\n\", params.playbackId);\n        return false;\n    }\n\n    SDL_AudioSpec playbackSpec;\n    SDL_zero(playbackSpec);\n\n    playbackSpec.freq = kSampleRate;\n    playbackSpec.format = std::is_same<TSample, int16_t>::value ? AUDIO_S16 : AUDIO_S32;\n    playbackSpec.channels = 1;\n    playbackSpec.samples = TPlaybackData::kSamples;\n    playbackSpec.callback = cbPlayback<TSample>;\n    playbackSpec.userdata = &g_playbackData;\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    g_deviceIdOut = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(params.playbackId, SDL_FALSE), SDL_FALSE, &playbackSpec, &obtainedSpec, 0);\n    if (!g_deviceIdOut) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for playback: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return false;\n    }\n\n    printf(\"Opened playback device succesfully!\\n\");\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d\\n\", obtainedSpec.format);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    SDL_PauseAudioDevice(g_deviceIdOut, 1);\n\n    return true;\n}\n\nint main(int argc, char ** argv) {\n    srand(time(0));\n\n    printf(\"Build: %s, (%s)\\n\", kGIT_DATE, kGIT_SHA1);\n    printf(\"Usage: %s record.kbd n-gram-dir [-pN] [-cN] [-CN] [-FN] [-fN]\\n\", argv[0]);\n    printf(\"    -pN - select playback device N\\n\");\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - select number N of capture channels to use\\n\");\n    printf(\"    -FN - select filter type, (0 - none, 1 - first order high-pass, 2 - second order high-pass)\\n\");\n    printf(\"    -fN - cutoff frequency in Hz\\n\");\n\n    if (argc < 3) {\n        return -1;\n    }\n\n    const auto argm = parseCmdArguments(argc, argv);\n    const int playbackId    = argm.count(\"p\") == 0 ? 0 : std::stoi(argm.at(\"p\"));\n    const int captureId     = argm.count(\"c\") == 0 ? 0 : std::stoi(argm.at(\"c\"));\n    const int nChannels     = argm.count(\"C\") == 0 ? 0 : std::stoi(argm.at(\"C\"));\n    const int filterId      = argm.count(\"F\") == 0 ? EAudioFilter::FirstOrderHighPass : std::stoi(argm.at(\"F\"));\n    const int freqCutoff_Hz = argm.count(\"f\") == 0 ? kFreqCutoff_Hz : std::stoi(argm.at(\"f\"));\n\n    stateUI.params.playbackId = playbackId;\n    stateUI.fnameRecord = argv[1];\n    stateUI.fnameKeyPressess = stateUI.fnameRecord + \".keys\";\n\n    stateUI.waveformInput.reserve(kSamplesPerFrame*kMaxRecordSize_frames);\n    stateUI.waveformOriginal.reserve(kSamplesPerFrame*kMaxRecordSize_frames);\n\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) != 0) {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -2;\n    }\n\n    AudioLogger::Callback cbAudio = [&](const AudioLogger::Record & frames) {\n        stateCapture.recordNew.insert(\n                stateCapture.recordNew.end(),\n                frames.begin(),\n                frames.end());\n\n        stateCapture.flags.updateRecord = true;\n        stateCapture.update();\n\n        g_doRecord = true;\n\n        return;\n    };\n\n    g_doInit = [&]() {\n        if (prepareAudioOut(stateUI.params) == false) {\n            printf(\"Error: failed to initialize audio playback\\n\");\n            return false;\n        }\n\n        AudioLogger::Parameters parameters;\n        parameters.callback = cbAudio;\n        parameters.captureId = captureId;\n        parameters.nChannels = nChannels;\n        parameters.sampleRate = kSampleRate;\n        parameters.filter = (EAudioFilter) filterId;\n        parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n        if (audioLogger.install(std::move(parameters)) == false) {\n            fprintf(stderr, \"Failed to initialize audio capture\\n\");\n        } else {\n            audioLogger.pause();\n            stateUI.audioCapture = true;\n\n            printf(\"[+] Audio capture initilized succesfully\\n\");\n        }\n\n        return true;\n    };\n\n    g_doReload = [&]() {\n        stateUI.loadRecord = true;\n\n        return true;\n    };\n\n    g_getOutputRecordId = [&]() {\n        return stateUI.outputRecordId;\n    };\n\n    printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n    if (readFromFile<TSampleF>(argv[1], stateUI.waveformOriginal) == false) {\n        printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n        //return -4;\n    } else {\n        printf(\"[+] Filtering waveform with filter type = %d and cutoff frequency = %d Hz\\n\", filterId, freqCutoff_Hz);\n        ::filter(stateUI.waveformOriginal, (EAudioFilter) filterId, freqCutoff_Hz, kSampleRate);\n\n        printf(\"[+] Converting waveform to i16 format ...\\n\");\n        if (convert(stateUI.waveformOriginal, stateUI.waveformInput) == false) {\n            printf(\"Conversion failed\\n\");\n            return -4;\n        }\n\n        stateUI.recalculateKeyPresses = true;\n        stateUI.maxSample = calcAbsMax(stateUI.waveformOriginal);\n    }\n\n    Cipher::TFreqMap freqMap3;\n    Cipher::TFreqMap freqMap4;\n    Cipher::TFreqMap freqMap5;\n\n    if (Cipher::loadFreqMap((std::string(argv[2]) + \"/./english_trigrams.txt\").c_str(), freqMap3) == false) {\n        return -5;\n    }\n    if (Cipher::loadFreqMap((std::string(argv[2]) + \"/./english_quadgrams.txt\").c_str(), freqMap4) == false) {\n        return -5;\n    }\n    if (Cipher::loadFreqMap((std::string(argv[2]) + \"/./english_quintgrams.txt\").c_str(), freqMap5) == false) {\n        return -5;\n    }\n    stateCore.freqMap[0] = &freqMap3;\n    stateCore.freqMap[1] = &freqMap4;\n    stateCore.freqMap[2] = &freqMap5;\n\n    Gui::Objects guiObjects;\n    if (Gui::init(\"Keytap2\", g_windowSizeX, g_windowSizeY, guiObjects) == false) {\n        return -6;\n    }\n\n    g_setWindowSize = [&](int sizeX, int sizeY) {\n        SDL_SetWindowSize(guiObjects.window, sizeX, sizeY);\n    };\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) stateUI.waveformInput.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*stateUI.waveformInput.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) stateUI.waveformInput.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(stateUI.waveformInput.size())/kSampleRate);\n\n    bool finishApp = false;\n    g_mainUpdate = [&]() {\n        if (finishApp) return false;\n\n        if (stateCore.changed()) {\n            auto stateCoreNew = stateCore.get();\n\n            stateUI.calculatingSimilarityMap = stateCoreNew.flags.calculatingSimilarityMap;\n\n            if (stateCoreNew.flags.updateSimilarityMap) {\n                stateUI.similarityMap = stateCoreNew.similarityMap;\n            }\n\n            bool recalcSuggestions = false;\n            for (int i = 0; i < stateCoreNew.params.nProcessors(); ++i) {\n                if (stateCoreNew.flags.updateResult[i]) {\n                    recalcSuggestions = true;\n                    if (stateCoreNew.processors[i].getResult().id != stateUI.results[i].id) {\n                        stateUI.results[i].id = stateCoreNew.processors[i].getResult().id;\n                        if (stateUI.results[i].size() < kTopResultsPerProcessor) {\n                            stateUI.results[i].push_back(stateCoreNew.processors[i].getResult());\n                        } else if (stateCoreNew.processors[i].getResult().p > stateUI.results[i].back().p) {\n                            stateUI.results[i].back() = stateCoreNew.processors[i].getResult();\n\n                            int k = kTopResultsPerProcessor - 1;\n                            while (k > 0) {\n                                if (stateUI.results[i][k-1].p < stateUI.results[i][k].p) {\n                                    std::swap(stateUI.results[i][k-1], stateUI.results[i][k]);\n                                } else {\n                                    break;\n                                }\n                                --k;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (recalcSuggestions) {\n                int n = stateUI.keyPresses.size();\n                stateUI.suggestions.resize(n);\n\n                for (int i = 0; i < n; ++i) {\n                    int c = 0;\n                    std::map<int, int> cnt;\n                    for (const auto & result : stateUI.results) {\n                        const auto & item = result.second.front();\n                        if (n != (int) item.clusters.size()) continue;\n                        if (item.clMap.find(item.clusters[i]) == item.clMap.end()) continue;\n                        if (i <= (int) item.clusters.size()) {\n                            ++cnt[item.clMap.at(item.clusters[i])];\n                            ++c;\n                        }\n                    }\n                    bool hasSuggestion = false;\n                    for (auto & s : cnt) {\n                        if (s.second > 0.5*c) {\n                            stateUI.suggestions[i] = s.first;\n                            hasSuggestion = true;\n                        }\n                    }\n                    if (hasSuggestion == false) {\n                        stateUI.suggestions[i] = -1;\n                    }\n                }\n            }\n        }\n\n        if (stateCapture.changed()) {\n            auto stateCaptureNew = stateCapture.get();\n\n            if (stateCaptureNew.flags.updateRecord) {\n                for (auto & frame : stateCaptureNew.recordNew) {\n                    stateUI.waveformOriginal.insert(stateUI.waveformOriginal.end(), frame.begin(), frame.end());\n                }\n\n                int nold = stateUI.waveformInput.size();\n                float scale = float(std::numeric_limits<TSample>::max())/(stateUI.maxSample == 0.0 ? 1.0f : stateUI.maxSample);\n                stateUI.waveformInput.resize(stateUI.waveformOriginal.size());\n                for (int i = nold; i < (int) stateUI.waveformInput.size(); ++i) {\n                    stateUI.waveformInput[i] = scale*stateUI.waveformOriginal[i];\n                }\n            }\n        }\n\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            switch (event.type) {\n                case SDL_QUIT:\n                    finishApp = true;\n                    break;\n                case SDL_KEYDOWN:\n                    if (event.key.keysym.sym == SDLK_ESCAPE) {\n                        finishApp = true;\n                    }\n                    break;\n                case SDL_DROPFILE:\n                    {\n                        char * path = event.drop.file;\n                        stateUI.fnameRecord = path;\n                        stateUI.loadRecord = true;\n                        SDL_free(path);\n                    }\n                    break;\n                case SDL_WINDOWEVENT:\n                    if (event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(guiObjects.window)) {\n                        finishApp = true;\n                    }\n                    break;\n            };\n        }\n\n        SDL_GetWindowSize(guiObjects.window, &g_windowSizeX, &g_windowSizeY);\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplSDL2_NewFrame(guiObjects.window);\n        ImGui::NewFrame();\n\n        stateUI.windowHeightTitleBar = ImGui::GetTextLineHeightWithSpacing();\n\n        if (ImGui::BeginMainMenuBar())\n        {\n            if (ImGui::BeginMenu(\"File\"))\n            {\n                ImGui::Separator();\n                ImGui::TextDisabled(\"Record: %s\", stateUI.fnameRecord.c_str());\n                ImGui::Separator();\n                if (ImGui::MenuItem(\"Save Record\")) {\n                    saveToFile(stateUI.fnameRecord, stateUI.waveformOriginal);\n                    stateUI.outputRecordId++;\n                }\n                if (ImGui::MenuItem(\"Load Record\")) {\n                    stateUI.loadRecord = true;\n                }\n\n                ImGui::Separator();\n                ImGui::TextDisabled(\"Key Presses: %s\", stateUI.fnameKeyPressess.c_str());\n                ImGui::Separator();\n                if (ImGui::MenuItem(\"Save Key Presses\")) {\n                    saveKeyPresses(stateUI.fnameKeyPressess.c_str(), stateUI.keyPresses);\n                }\n                if (ImGui::MenuItem(\"Load Key Presses\")) {\n                    stateUI.loadKeyPresses = true;\n                }\n\n                ImGui::EndMenu();\n            }\n            if (ImGui::BeginMenu(\"Help\")) {\n                if (ImGui::MenuItem(\"Parameters\")) {\n                    stateUI.openParametersWindow = true;\n                }\n                if (ImGui::MenuItem(\"About\")) {\n                    stateUI.openAboutWindow = true;\n                }\n                ImGui::EndMenu();\n            }\n            ImGui::EndMainMenuBar();\n        }\n\n        if (stateUI.openAboutWindow) {\n            ImGui::OpenPopup(\"About\");\n            stateUI.openAboutWindow = false;\n        }\n        ImGui::SetNextWindowSize({512, -1}, ImGuiCond_Once);\n        if (ImGui::BeginPopupModal(\"About\", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar)) {\n            ImGui::Text(\"%s\", \"\");\n            {\n                const char * text = \"Keytap2 : v0.1 [%s]    \";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                ImGui::Text(text, kGIT_SHA1);\n            }\n            ImGui::Text(\"%s\", \"\");\n            {\n                const char * text = \"author : Georgi Gerganov\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                ImGui::Text(\"%s\", text);\n            }\n            {\n                const char * text = \"source code : https://github.com/ggerganov/kbd-audio\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                ImGui::Text(\"%s\", text);\n            }\n            ImGui::Text(\"%s\", \"\");\n            {\n                const char * text = \"Close\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                if (ImGui::Button(text)) {\n                    ImGui::CloseCurrentPopup();\n                }\n            }\n            ImGui::Text(\"%s\", \"\");\n            ImGui::EndPopup();\n        }\n\n        if (stateUI.openParametersWindow) {\n            ImGui::OpenPopup(\"Parameters\");\n            stateUI.openParametersWindow = false;\n        }\n        ImGui::SetNextWindowSize({320, -1}, ImGuiCond_Once);\n        if (ImGui::BeginPopupModal(\"Parameters\", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar)) {\n            ImGui::Text(\"%s\", \"\");\n            ImGui::Text(\"Sample rate            : %d\\n\", (int) kSampleRate);\n            ImGui::Text(\"Samples per frame      : %d\\n\", (int) kSamplesPerFrame);\n            ImGui::Text(\"Hardware concurrency   : %d\\n\", (int) std::thread::hardware_concurrency());\n            ImGui::Text(\"Max record size        : %g s\\n\", kMaxRecordSize_s);\n            ImGui::Text(\"Freq cutoff            : %g Hz\\n\", kFreqCutoff_Hz);\n            ImGui::Text(\"Subbreak Processors    : %d\\n\", stateUI.params.nProcessors());\n            ImGui::Text(\"%s\", \"\");\n\n            {\n                const char * text = \"Close\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                if (ImGui::Button(text)) {\n                    ImGui::CloseCurrentPopup();\n                }\n            }\n            ImGui::Text(\"%s\", \"\");\n            ImGui::EndPopup();\n        }\n\n\n        if (stateUI.loadRecord) {\n            printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n            if (readFromFile<TSampleF>(stateUI.fnameRecord, stateUI.waveformOriginal) == false) {\n                printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n            } else {\n                printf(\"[+] Converting waveform to i16 format ...\\n\");\n                if (convert(stateUI.waveformOriginal, stateUI.waveformInput) == false) {\n                    printf(\"Conversion failed\\n\");\n                } else {\n                    stateUI.nview = -1;\n                    stateUI.recalculateKeyPresses = true;\n                    stateUI.maxSample = calcAbsMax(stateUI.waveformOriginal);\n                    stateUI.flags.recalculateSimilarityMap = true;\n                    stateUI.doUpdate = true;\n                }\n            }\n\n            stateUI.loadRecord = false;\n        }\n\n        if (stateUI.loadKeyPresses) {\n            loadKeyPresses(stateUI.fnameKeyPressess.c_str(), getView(stateUI.waveformInput, 0), stateUI.keyPresses);\n            stateUI.loadKeyPresses = false;\n        }\n\n        if (stateUI.rescaleWaveform) {\n            if (convert(stateUI.waveformOriginal, stateUI.waveformInput) == false) {\n                fprintf(stderr, \"error : recording failed\\n\");\n            }\n            stateUI.maxSample = calcAbsMax(stateUI.waveformOriginal);\n\n            stateUI.rescaleWaveform = false;\n        }\n\n        if (float(stateUI.waveformInput.size())/kSampleRate >= kMaxRecordSize_s) {\n            stateUI.waveformInput.resize((kMaxRecordSize_frames - 1)*kSamplesPerFrame);\n            audioLogger.pause();\n            g_doRecord = false;\n\n            stateUI.recalculateKeyPresses = true;\n            stateUI.lastSize = stateUI.lastSize - 1;\n            stateUI.recording = false;\n            stateUI.rescaleWaveform = true;\n        }\n\n        for (int i = 0; i < IM_ARRAYSIZE(ImGui::GetIO().KeysDown); i++) if (ImGui::IsKeyPressed(i)) {\n            //printf(\"Key pressed: %d\\n\", i);\n        }\n\n        renderKeyPresses(stateUI, stateUI.waveformInput, stateUI.keyPresses);\n        renderResults(stateUI);\n        renderSimilarity(stateUI.keyPresses, stateUI.similarityMap);\n\n        Gui::render(guiObjects);\n\n        if (stateUI.doUpdate) {\n            stateUI.update();\n            stateUI.doUpdate = false;\n        }\n\n        return true;\n    };\n\n    std::thread workerCore([&]() {\n        while (finishApp == false) {\n            if (stateUI.changed()) {\n                auto stateUINew = stateUI.get();\n\n                if (stateUINew.flags.recalculateSimilarityMap || stateUINew.flags.resetOptimization) {\n                    if (stateUINew.keyPresses.size() < 3) continue;\n\n                    stateCore.params = stateUINew.params;\n                    stateCore.keyPresses = stateUINew.keyPresses;\n\n                    printf(\"[+] Recalculating similarity map ...\\n\");\n\n                    if (stateUINew.flags.recalculateSimilarityMap) {\n                        stateCore.flags.calculatingSimilarityMap = true;\n                        stateCore.update(true);\n\n                        calculateSimilartyMap(\n                                stateUINew.params.keyPressWidth_samples,\n                                stateUINew.params.alignWindow_samples,\n                                stateUINew.params.offsetFromPeak_samples,\n                                stateCore.keyPresses,\n                                stateCore.similarityMap);\n\n                        int nTries = 3;\n                        while (adjustKeyPresses(stateCore.keyPresses, stateCore.similarityMap) && --nTries) {\n                            calculateSimilartyMap(\n                                    stateUINew.params.keyPressWidth_samples,\n                                    stateUINew.params.alignWindow_samples,\n                                    stateUINew.params.offsetFromPeak_samples,\n                                    stateCore.keyPresses,\n                                    stateCore.similarityMap);\n                        }\n\n                        printf(\"[+] Similarity map recalculated\\n\");\n\n                        stateCore.flags.calculatingSimilarityMap = false;\n                        stateCore.flags.updateSimilarityMap = true;\n                        stateCore.update(true);\n                    }\n\n                    int n = stateCore.params.nProcessors();\n                    for (int i = 0; i < n; ++i) {\n                        int nClusters = stateCore.params.valueForProcessorClusters(i);\n                        double p = stateCore.params.valueForProcessorPNonAlphabetic(i);\n                        double w = stateCore.params.valueForProcessorWEnglishFreq(i);\n\n                        Cipher::TParameters params;\n                        params.maxClusters = nClusters;\n                        stateCore.processors[i] = Cipher::Processor();\n                        stateCore.processors[i].init(\n                                params,\n                                *stateCore.freqMap[i%3],\n                                stateCore.similarityMap);\n\n                        stateCore.processors[i].setPNonAlphabetic(std::log(p));\n                        stateCore.processors[i].setWEnglishFreq(w);\n\n                        printf(\"[+] Processor %d initialized: cluster = %d, p = %g, w = %g\\n\", i, nClusters, p, w);\n                    }\n                }\n\n                if (stateUINew.flags.changeProcessing) {\n                    stateCore.processing = stateUINew.processing;\n                }\n\n                if (stateUINew.flags.applyClusters) {\n                    stateCore.params = stateUINew.params;\n\n                    int n = stateCore.params.nProcessors();\n                    for (int i = 0; i < n; ++i) {\n                        int nClusters = stateCore.params.valueForProcessorClusters(i);\n                        double p = stateCore.params.valueForProcessorPNonAlphabetic(i);\n                        double w = stateCore.params.valueForProcessorWEnglishFreq(i);\n\n                        Cipher::TParameters params;\n                        params.maxClusters = nClusters;\n                        stateCore.processors[i].init(\n                                params,\n                                *stateCore.freqMap[i%3],\n                                stateCore.similarityMap);\n\n                        stateCore.processors[i].setPNonAlphabetic(std::log(p));\n                        stateCore.processors[i].setWEnglishFreq(w);\n                    }\n                }\n\n                if (stateUINew.flags.applyWEnglishFreq) {\n                    stateCore.params = stateUINew.params;\n\n                    int n = stateCore.params.nProcessors();\n                    for (int i = 0; i < n; ++i) {\n                        double w = stateCore.params.valueForProcessorWEnglishFreq(i);\n                        stateCore.processors[i].setWEnglishFreq(w);\n                    }\n                }\n\n                if (stateUINew.flags.applyHints) {\n                    stateCore.keyPresses = stateUINew.keyPresses;\n                }\n            }\n\n            if (stateCore.processing && stateCore.keyPresses.size() >= 3) {\n                {\n                    int n = stateCore.keyPresses.size();\n                    stateCore.params.cipher.hint.clear();\n                    stateCore.params.cipher.hint.resize(n, -1);\n                    for (int i = 0; i < n; ++i) {\n                        if (stateCore.keyPresses[i].bind < 0) continue;\n                        stateCore.params.cipher.hint[i] = stateCore.keyPresses[i].bind + 1;\n                    }\n                }\n\n#ifdef __EMSCRIPTEN__\n                static int iter = 0;\n                {\n                    int p = iter%stateCore.params.nProcessors();\n                    stateCore.processors[p].setHint(stateCore.params.cipher.hint);\n                    stateCore.processors[p].compute();\n\n                    stateCore.flags.updateResult[p] = true;\n                    stateCore.update();\n\n                    ++iter;\n                }\n#else\n                int nFinished = 0;\n                int nWorkers = std::min(stateCore.params.nProcessors(), (int) std::thread::hardware_concurrency()/2);\n\n                std::mutex mutex;\n                std::condition_variable cv;\n                std::vector<std::thread> workers(nWorkers);\n                for (int iw = 0; iw < (int) workers.size(); ++iw) {\n                    auto & worker = workers[iw];\n                    worker = std::thread([&](int ith) {\n                        int n = stateCore.params.nProcessors();\n                        for (int i = ith; i < n; i += nWorkers) {\n                            stateCore.processors[i].setHint(stateCore.params.cipher.hint);\n                            stateCore.processors[i].compute();\n\n                            stateCore.flags.updateResult[i] = true;\n                            stateCore.update();\n                        }\n                        {\n                            std::lock_guard<std::mutex> lock(mutex);\n                            ++nFinished;\n                            cv.notify_one();\n                        }\n                    }, iw);\n                    worker.detach();\n                }\n\n                std::unique_lock<std::mutex> lock(mutex);\n                cv.wait(lock, [&]() { return nFinished == nWorkers; });\n#endif\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(1));\n            }\n        }\n    });\n\n#ifdef __EMSCRIPTEN__\n    emscripten_set_main_loop_arg(mainUpdate, NULL, 0, true);\n#else\n    if (g_doInit() == false) {\n        printf(\"Error: failed to initialize audio playback\\n\");\n        return -2;\n    }\n\n    while (true) {\n        if (g_mainUpdate() == false) break;\n    }\n\n    workerCore.join();\n\n    printf(\"[+] Terminated\\n\");\n\n    Gui::free(guiObjects);\n#endif\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap2.cpp",
          "type": "blob",
          "size": 11.9287109375,
          "content": "/*! \\file keytap2.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"common.h\"\n\n#include <chrono>\n#include <cstdio>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define MY_DEBUG\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TKeyPressData         = TKeyPressDataI16;\nusing TKeyPressCollection   = TKeyPressCollectionI16;\n\nbool clusterDBSCAN(const TSimilarityMap & sim, TValueCC epsCC, int minPts, TKeyPressCollection & keyPresses) {\n    int n = keyPresses.size();\n    for (int i = 0; i < n; ++i) {\n        auto & cid = keyPresses[i].cid;\n\n        cid = -1;\n    }\n\n    int curId = 0;\n\n    for (int i = 0; i < n; ++i) {\n        auto & cid = keyPresses[i].cid;\n\n        if (cid != -1) continue;\n        std::vector<int> nbi;\n        for (int j = 0; j < n; ++j) {\n            auto & cc = sim[i][j].cc;\n\n            if (cc > epsCC) nbi.push_back(j);\n        }\n\n        if ((int) nbi.size() < minPts) {\n            cid = 0;\n            continue;\n        }\n\n        cid = ++curId;\n        for (int q = 0; q < (int) nbi.size(); ++q) {\n            auto & qcid = keyPresses[nbi[q]].cid;\n\n            if (qcid == 0) qcid = curId;\n            if (qcid != -1) continue;\n            qcid = curId;\n\n            std::vector<int> nbq;\n            for (int j = 0; j < n; ++j) {\n                auto & cc = sim[nbi[q]][j].cc;\n\n                if (cc > epsCC) nbq.push_back(j);\n            }\n\n            if ((int) nbq.size() >= minPts) {\n                nbi.insert(nbi.end(), nbq.begin(), nbq.end());\n            }\n        }\n    }\n\n    return true;\n}\n\nbool clusterSimple(const TSimilarityMap & sim, TValueCC tholdCC, TKeyPressCollection & keyPresses) {\n    int n = keyPresses.size();\n    for (int i = 0; i < n; ++i) {\n        auto & cid = keyPresses[i].cid;\n\n        cid = 0;\n    }\n\n    int curId = 0;\n\n    int nIter = 1000000;\n    for (int iter = 0; iter < nIter; ++iter) {\n        int i = rand()%n;\n        int j = rand()%n;\n        while (i == j) {\n            i = rand()%n;\n            j = rand()%n;\n        }\n\n        auto & icid = keyPresses[i].cid;\n        auto & jcid = keyPresses[j].cid;\n\n        //if (icid != 0 && jcid != 0) continue;\n\n        auto & cc = sim[i][j].cc;\n\n        if (cc < tholdCC) continue;\n        auto r = frand();\n        if (r < cc) {\n            if (icid == jcid && icid == 0) {\n                icid = jcid = ++curId;\n            } else if (icid == 0) {\n                icid = jcid;\n            } else {\n                jcid = icid;\n            }\n        }\n\n        //if (icid == jcid) {\n        //    //if (std::pow(r, 1.0) > cc) {\n        //    //    icid = i + 1;\n        //    //    jcid = j + 1;\n        //    //}\n        //} else {\n        //    if (std::pow(r, 1.0) < cc) {\n        //        icid = jcid;\n        //    }\n        //}\n    }\n\n    for (int i = 0; i < n; ++i) {\n        auto & icid = keyPresses[i].cid;\n\n        if (icid == 0) icid = ++curId;\n        icid = -icid;\n    }\n\n    curId = 0;\n    for (int i = 0; i < n; ++i) {\n        auto & icid = keyPresses[i].cid;\n\n        if (icid > 0) continue;\n        for (int j = i; j < n; ++j) {\n            auto & jcid = keyPresses[j].cid;\n\n            if (jcid == icid) {\n                jcid = curId;\n            }\n        }\n        ++curId;\n    }\n\n    return true;\n}\n\nbool clusterG(const TSimilarityMap & sim, TKeyPressCollection & keyPresses) {\n    struct Pair {\n        int i = -1;\n        int j = -1;\n        TValueCC cc = -1.0;\n\n        bool operator < (const Pair & a) const { return cc > a.cc; }\n    };\n\n    int n = keyPresses.size();\n\n    int nclusters = 0;\n    for (int i = 0; i < n; ++i) {\n        auto & ci = keyPresses[i].cid;\n\n        ci = i + 1;\n        ++nclusters;\n    }\n\n    std::vector<Pair> ccpairs;\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            auto & cc = sim[i][j].cc;\n\n            ccpairs.emplace_back(Pair{i, j, cc});\n        }\n    }\n\n    std::sort(ccpairs.begin(), ccpairs.end());\n\n    printf(\"[+] Top 10 pairs\\n\");\n    for (int i = 0; i < 10; ++i) {\n        printf(\"    Pair %d: %d %d %g\\n\", i, ccpairs[i].i, ccpairs[i].j, ccpairs[i].cc);\n    }\n\n    int npairs = ccpairs.size();\n    for (int ip = 0; ip < npairs; ++ip) {\n        auto & curpair = ccpairs[ip];\n        //if (frand() > curpair.cc) continue;\n        if (curpair.cc < 0.50) break;\n\n        auto ci = keyPresses[curpair.i].cid;\n        auto cj = keyPresses[curpair.j].cid;\n\n        if (ci == cj) continue;\n        auto cnew = std::min(ci, cj);\n        int nsum = 0;\n        int nsumi = 0;\n        int nsumj = 0;\n        double sumcc = 0.0;\n        double sumcci = 0.0;\n        double sumccj = 0.0;\n        for (int k = 0; k < n; ++k) {\n            auto ck = keyPresses[k].cid;\n\n            for (int q = 0; q < n; ++q) {\n                if (q == k) continue;\n                auto cq = keyPresses[q].cid;\n\n                if ((ck == ci || ck == cj) && (cq == ci || cq == cj)) {\n                    auto & cc     = sim[k][q].cc;\n                    //auto & offset = sim[k][q].offset;\n\n                    sumcc += cc;\n                    ++nsum;\n                }\n                if (ck == ci && cq == ci) {\n                    auto & cc     = sim[k][q].cc;\n                    //auto & offset = sim[k][q].offset;\n\n                    sumcci += cc;\n                    ++nsumi;\n                }\n                if (ck == cj && cq == cj) {\n                    auto & cc     = sim[k][q].cc;\n                    //auto & offset = sim[k][q].offset;\n\n                    sumccj += cc;\n                    ++nsumj;\n                }\n            }\n        }\n        sumcc /= nsum;\n        if (nsumi > 0) sumcci /= nsumi;\n        if (nsumj > 0) sumccj /= nsumj;\n        printf(\"Merge avg n = %4d, cc = %8.5f, ni = %4d, cci = %8.5f, nj = %4d, ccj = %8.5f\\n\", nsum, sumcc, nsumi, sumcci, nsumj, sumccj);\n\n        //if (sumcc < 1.000*curpair.cc) continue;\n        //if (sumcc > 0.75*sumccj && sumcc > 0.75*sumcci) {\n        if (sumcc > 0.4*(sumcci + sumccj)) {\n        } else {\n            continue;\n        }\n\n        for (int k = 0; k < n; ++k) {\n            auto & ck = keyPresses[k].cid;\n\n            if (ck == ci || ck == cj) ck = cnew;\n        }\n        --nclusters;\n\n        printf(\"Clusters %3d %5.4f:\", nclusters, curpair.cc);\n        for (int k = 0; k < n; ++k) {\n            auto & ck = keyPresses[k].cid;\n\n            printf(\" %3d\", ck);\n        }\n        printf(\"\\n\");\n    }\n\n    return true;\n}\n\nbool clusterG2(TSimilarityMap & sim, TKeyPressCollection & keyPresses) {\n    struct Pair {\n        int i = -1;\n        int j = -1;\n        TValueCC cc = -1.0;\n\n        bool operator < (const Pair & a) const { return cc > a.cc; }\n    };\n\n    int n = keyPresses.size();\n\n    int nclusters = 0;\n    for (int i = 0; i < n; ++i) {\n        auto & ci = keyPresses[i].cid;\n\n        ci = i + 1;\n        ++nclusters;\n    }\n\n    std::vector<double> nsum(n + 1, 1.0);\n    std::vector<Pair> ccpairs;\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            auto & cc = sim[i][j].cc;\n\n            ccpairs.emplace_back(Pair{i, j, cc});\n        }\n    }\n\n    std::sort(ccpairs.begin(), ccpairs.end());\n\n    printf(\"[+] Top 10 pairs\\n\");\n    for (int i = 0; i < 10; ++i) {\n        printf(\"    Pair %d: %d %d %g\\n\", i, ccpairs[i].i, ccpairs[i].j, ccpairs[i].cc);\n    }\n\n    int npairs = ccpairs.size();\n    for (int ip = 0; ip < npairs; ++ip) {\n        auto & curpair = ccpairs[ip];\n        if (frand() > curpair.cc) continue;\n        if (curpair.cc < 0.50) break;\n\n        auto & ci = keyPresses[curpair.i].cid;\n        auto & cj = keyPresses[curpair.j].cid;\n\n        if (ci == cj) continue;\n        auto cnew = std::min(ci, cj);\n        for (int k = 0; k < n; ++k) {\n            auto & ck = keyPresses[k].cid;\n\n            if (ck == ci || ck == cj) ck = cnew;\n        }\n        --nclusters;\n\n        printf(\"Clusters %3d %5.4f:\", nclusters, curpair.cc);\n        for (int k = 0; k < n; ++k) {\n            auto & ck = keyPresses[k].cid;\n\n            printf(\" %3d\", ck);\n        }\n        printf(\"\\n\");\n\n        if (nclusters == 56) break;\n    }\n\n    return true;\n}\n\nint main(int argc, char ** argv) {\n    srand(time(0));\n\n    printf(\"Usage: %s record.kbd\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    int64_t sampleRate = 24000;\n\n    TWaveform waveformInput;\n    printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n    if (readFromFile<TSampleF>(argv[1], waveformInput) == false) {\n        printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n        return -1;\n    }\n\n    //{\n    //    std::ofstream fout(\"waveform.plot\");\n    //    for (auto & a : waveformInput) {\n    //        fout << a << std::endl;\n    //    }\n    //    fout.close();\n    //}\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) waveformInput.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*waveformInput.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) waveformInput.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(waveformInput.size())/sampleRate);\n\n    TKeyPressCollection keyPresses;\n    TWaveform waveformThreshold;\n    TWaveform waveformMax;\n    {\n        auto tStart = std::chrono::high_resolution_clock::now();\n        printf(\"[+] Searching for key presses\\n\");\n        if (findKeyPresses(getView(waveformInput, 0), keyPresses, waveformThreshold, waveformMax, 8.0, 512, 2*1024, true) == false) {\n            printf(\"Failed to detect keypresses\\n\");\n            return -2;\n        }\n        auto tEnd = std::chrono::high_resolution_clock::now();\n        printf(\"[+] Detected a total of %d potential key presses\\n\", (int) keyPresses.size());\n        for (auto & k : keyPresses) {\n            auto & pos = k.pos;\n\n            printf(\"    position - %d\\n\", (int) pos);\n        }\n        printf(\"[+] Search took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n\n        dumpKeyPresses(\"key_presses.plot\", keyPresses);\n    }\n\n    //keyPresses.erase(keyPresses.begin(), keyPresses.begin() + keyPresses.size()/2);\n\n    TSimilarityMap similarityMap;\n    {\n        auto tStart = std::chrono::high_resolution_clock::now();\n        printf(\"[+] Calculating CC similarity map\\n\");\n        if (calculateSimilartyMap(256, 256, 0, keyPresses, similarityMap) == false) {\n            printf(\"Failed to calculate similariy map\\n\");\n            return -3;\n        }\n        auto tEnd = std::chrono::high_resolution_clock::now();\n        printf(\"[+] Calculation took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n    }\n\n    int n = keyPresses.size();\n    for (int i = 0; i < n; ++i) {\n        auto & avgcc = keyPresses[i].ccAvg;\n\n        printf(\"    Average CC for keypress %4d - %6.3f\\n\", i, avgcc);\n    }\n\n    printf(\"%5d \", -1);\n    for (int j = 0; j < n; ++j) {\n        printf(\"%4d \", j);\n    }\n    printf(\"\\n\");\n    printf(\"--------------------------------------------------------------------------------------------------------------------------------------\\n\");\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%2d  | \", i);\n        for (int j = 0; j < n; ++j) {\n            auto cc     = similarityMap[i][j].cc;\n            //auto offset = similarityMap[i][j].offset;\n\n            if (cc > -0.45) {\n                printf(\"%4.0f \", cc*100);\n            } else {\n                printf(\"     \");\n            }\n            //printf(\"%3d - %3d -> %4.3f, %3d\\n\", i, j, cc, (int) offset);\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\");\n\n    //clusterDBSCAN(similarityMap, 0.8, 1, keyPresses);\n    //clusterSimple(similarityMap, 0.50, keyPresses);\n    clusterG(similarityMap, keyPresses);\n\n    for (const auto & k : keyPresses) {\n        auto & cid = k.cid;\n\n        //printf(\"%c\", 'a' + cid - 1);\n        printf(\"%d \", cid);\n    }\n    printf(\"\\n\");\n\n    for (const auto & k : keyPresses) {\n        auto & cid = k.cid;\n\n        printf(\"%c\", 'a' + cid - 1);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap3-app.cpp",
          "type": "blob",
          "size": 25.6884765625,
          "content": "/*! \\file keytap3-app.cpp\n *  \\brief keytap3.cpp and key-detector.cpp combined in single app\n *\n *  Used to create the keytap3 web-page\n *\n *  \\author Georgi Gerganov\n */\n\n#include \"build-vars.h\"\n#include \"common.h\"\n#include \"constants.h\"\n#include \"subbreak3.h\"\n#include \"audio-logger.h\"\n\n#define DR_WAV_IMPLEMENTATION\n#include \"dr_wav.h\"\n\n#include <chrono>\n#include <cstdio>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <thread>\n#include <atomic>\n#include <mutex>\n#include <sstream>\n\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#include <emscripten/bind.h>\n#else\n#define EMSCRIPTEN_KEEPALIVE\n#endif\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TKeyPressData         = TKeyPressDataI16;\nusing TKeyPressCollection   = TKeyPressCollectionI16;\n\nstruct StateIdle {\n};\n\nstruct StateRecording {\n    int captureId = 0;\n    int nChannels = 1;\n    int filterId = EAudioFilter::FirstOrderHighPass;\n    int freqCutoff_Hz = kFreqCutoff_Hz;\n\n    int nKeysToCapture = 100;\n\n    int nKeysHave = 0;\n    bool isStarted = false;\n    std::atomic_bool interrupt = false;\n    std::atomic_bool doRecord = false;\n    std::atomic_bool doneRecording = false;\n    std::atomic_bool doneCutoffSearch = false;\n    size_t totalSize_bytes = 0;\n\n    std::string pathOutput = \"record.kbd\";\n\n    std::mutex mutex;\n\n    TWaveformF waveformF;\n    TWaveformF waveformFWork;\n    TWaveformI16 waveformI16;\n    TKeyPressCollectionT<TSampleI16> keyPresses;\n\n    AudioLogger audioLogger;\n    AudioLogger::Callback cbAudio;\n\n    bool init() {\n        if (isStarted) {\n            return false;\n        }\n\n        nKeysHave = 0;\n        isStarted = true;\n        interrupt = false;\n        doRecord = true;\n        doneRecording = false;\n        doneCutoffSearch = false;\n        totalSize_bytes = 0;\n\n        waveformF.clear();\n        waveformI16.clear();\n        keyPresses.clear();\n\n        AudioLogger::Callback cbAudio = [&](const auto & frames) {\n            const auto tStart = std::chrono::high_resolution_clock::now();\n\n            {\n                std::lock_guard lock(mutex);\n                for (auto & frame : frames) {\n                    waveformF.insert(waveformF.end(), frame.begin(), frame.end());\n                }\n\n                if (interrupt) {\n                    doneRecording = true;\n                    printf(\"\\n[!] Recording interrupted\\n\");\n                    return;\n                }\n                if (nKeysToCapture <= nKeysHave && !doneRecording) {\n                    doneRecording = true;\n                    printf(\"\\n[+] Done recording\\n\");\n                } else {\n                    doRecord = true;\n                }\n            }\n\n            const auto tEnd = std::chrono::high_resolution_clock::now();\n            const auto tDiff = std::chrono::duration_cast<std::chrono::milliseconds>(tEnd - tStart).count();\n\n            if (tDiff > 3) {\n                printf(\"[!] Audio callback took %ld ms\\n\", (long) tDiff);\n            }\n        };\n\n        AudioLogger::Parameters parameters;\n        parameters.callback = std::move(cbAudio);\n        parameters.captureId = captureId;\n        parameters.nChannels = nChannels;\n        parameters.sampleRate = kSampleRate;\n        parameters.filter = EAudioFilter::None;\n        parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n        if (audioLogger.install(std::move(parameters)) == false) {\n            fprintf(stderr, \"Failed to install audio logger\\n\");\n            return false;\n        }\n\n        return true;\n    }\n\n    void update() {\n        if (!isStarted) return;\n\n        if (doRecord) {\n            doRecord = false;\n            audioLogger.record(1.0f, 0);\n        }\n    }\n\n    void updateWorker(std::string & dataOutput, float tElapsed_s) {\n        {\n            std::lock_guard lock(mutex);\n            waveformFWork = waveformF;\n        }\n        {\n            auto freqCutoffCur_Hz = freqCutoff_Hz;\n\n            if (tElapsed_s < 0.0f && freqCutoffCur_Hz == 0) {\n                const auto tStart = std::chrono::high_resolution_clock::now();\n\n                freqCutoffCur_Hz = Cipher::findBestCutoffFreq(waveformFWork, EAudioFilter::FirstOrderHighPass, kSampleRate, 100.0f, 1000.0f, 100.0f);\n\n                const auto tEnd = std::chrono::high_resolution_clock::now();\n                printf(\"[+] Found best freqCutoff = %d Hz, took %4.3f seconds\\n\", freqCutoffCur_Hz, toSeconds(tStart, tEnd));\n            } else {\n                freqCutoffCur_Hz = kFreqCutoff_Hz;\n            }\n\n            // apply default filtering, because keypress detection without it is impossible\n            auto waveformFFiltered = waveformFWork;\n            ::filter(waveformFFiltered, EAudioFilter::FirstOrderHighPass, freqCutoffCur_Hz, kSampleRate);\n\n            if (convert(waveformFFiltered, waveformI16) == false) {\n                printf(\"Conversion failed\\n\");\n            }\n        }\n\n        TWaveformI16 waveformMax;\n        TWaveformI16 waveformThreshold;\n        if (findKeyPresses(getView(waveformI16, 0), keyPresses, waveformThreshold, waveformMax,\n                           kFindKeysThreshold, kFindKeysHistorySize, kFindKeysHistorySizeReset, kFindKeysRemoveLowPower) == false) {\n            printf(\"Failed to detect keypresses\\n\");\n        }\n\n        {\n            std::lock_guard lock(mutex);\n\n            float cpm = 0.0f;\n            if (keyPresses.size() > 0) {\n                int idx = 0;\n                while (idx < (int) keyPresses.size() && keyPresses[idx].pos < ((int) waveformF.size() - 10*kSampleRate)) {\n                    ++idx;\n                }\n                cpm = 60.0f*(nKeysHave - idx)/std::min(10.0f, (float) waveformF.size()/kSampleRate);\n                dataOutput = \"recording \" + std::to_string(nKeysHave) + \" \" + std::to_string(cpm);\n            }\n\n            if (nKeysHave < (int) keyPresses.size()) {\n                nKeysHave = keyPresses.size();\n\n                printf(\"    Detected %d keys. %d left. Average typing speed: %5.2f cpm\\n\", nKeysHave, nKeysToCapture - nKeysHave, cpm);\n            }\n\n            if (tElapsed_s > 2*60.0f) {\n                printf(\"[!] Recording limit reached\\n\");\n                doneRecording = true;\n            }\n        }\n    }\n};\n\nstruct StateDecoding {\n    std::string pathData = \"./data\";\n    std::atomic_bool interrupt = false;\n    TWaveform waveformInput;\n    Cipher::TFreqMap freqMap6;\n};\n\nstruct State {\n    enum EState {\n        Loading,\n        Idle,\n        Recording,\n        Decoding,\n    };\n\n    EState state = Loading;\n\n    std::string dataOutput;\n\n    StateIdle      idle;\n    StateRecording recording;\n    StateDecoding  decoding;\n\n    std::thread worker;\n    std::atomic_bool workDone = false;\n\n    void init() {\n    }\n\n    void deinit() {\n    }\n};\n\nnamespace {\n\n//\n// App Interface\n//\n\nstruct AppInterface {\n    std::function<bool()>                     doInit;\n    std::function<void(const std::string & )> setData;\n    std::function<std::string()>              getData;\n\n    std::function<bool()> mainLoop;\n\n    bool init(State & state);\n} g_appInterface;\n\n#ifdef __EMSCRIPTEN__\n\n// need this wrapper of the main loop for the emscripten_set_main_loop_arg() call\nvoid mainLoop(void *) {\n    g_appInterface.mainLoop();\n}\n\n//\n// JS interface\n//\n\n// These functions are used to pass data back and forth between the JS and the C++ code\n// using the app interface\n\nEMSCRIPTEN_BINDINGS(ggweb) {\n    emscripten::function(\"doInit\",        emscripten::optional_override([]() -> int                   { return g_appInterface.doInit(); }));\n    emscripten::function(\"setData\",       emscripten::optional_override([](const std::string & input) { g_appInterface.setData(input); }));\n    emscripten::function(\"getData\",       emscripten::optional_override([]() -> std::string           { return g_appInterface.getData(); }));\n}\n\n#endif\n\nbool AppInterface::init(State & state) {\n    doInit = [&]() {\n        state.init();\n\n        return true;\n    };\n\n    setData = [&](const std::string & data) {\n        //printf(\"Received some data from the JS layer: %s\\n\", data.c_str());\n\n        std::stringstream ss(data);\n\n        std::string cmd;\n        ss >> cmd;\n\n        if (cmd == \"start\") {\n            if (state.state == State::Idle) {\n                int nKeysToCapture = 0;\n                if (ss >> nKeysToCapture) {\n                    state.recording.nKeysToCapture = nKeysToCapture;\n                } else {\n                    printf(\"[!] Failed to parse nKeysToCapture. Using: %d\\n\", state.recording.nKeysToCapture);\n                }\n\n                printf(\"[+] Starting recording. nKeysToCapture: %d\\n\", state.recording.nKeysToCapture);\n                state.state = State::Recording;\n            }\n        } else if (cmd == \"stop\") {\n            if (state.state == State::Recording) {\n                state.recording.interrupt = true;\n            }\n            if (state.state == State::Decoding) {\n                state.decoding.interrupt = true;\n            }\n        } else {\n            printf(\"Unknown cmd: %s\\n\", cmd.c_str());\n        }\n    };\n\n    getData = [&]() {\n        const auto res = state.dataOutput;\n        state.dataOutput.clear();\n        return res;\n    };\n\n    mainLoop = [&]() {\n        switch (state.state) {\n            case State::Loading:\n                {\n                    if (state.worker.joinable() == false) {\n                        state.dataOutput = \"loading\";\n                        state.worker = std::thread([&]() {\n                            const auto tStart = std::chrono::high_resolution_clock::now();\n\n                            const auto filename = state.decoding.pathData + \"/./ggwords-6-gram.dat.binary\";\n                            printf(\"[+] Loading n-grams from '%s'\\n\", filename.c_str());\n\n                            if (Cipher::loadFreqMapBinary(filename.c_str(), state.decoding.freqMap6) == false) {\n                                printf(\"[E] Failed to load n-grams\\n\");\n                                return;\n                            }\n\n                            const auto tEnd = std::chrono::high_resolution_clock::now();\n\n                            printf(\"[+] Loading took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n                            state.workDone = true;\n                        });\n                    }\n\n                    if (state.workDone) {\n                        state.worker.join();\n                        state.state = State::Idle;\n                        state.dataOutput = \"loaded\";\n                    }\n                } break;\n            case State::Idle:\n                {\n                } break;\n            case State::Recording:\n                {\n                    state.recording.init();\n                    state.recording.update();\n\n                    if (state.worker.joinable() == false) {\n                        state.dataOutput = \"recording 0 0\";\n                        state.worker = std::thread([&]() {\n                            const auto tStart = std::chrono::high_resolution_clock::now();\n\n                            while (state.recording.doneRecording == false) {\n                                const auto tNow = std::chrono::high_resolution_clock::now();\n                                const float tElapsed_s = std::chrono::duration<float>(tNow - tStart).count();\n\n                                state.recording.updateWorker(state.dataOutput, tElapsed_s);\n\n                                std::this_thread::sleep_for(std::chrono::milliseconds(500));\n                            }\n\n                            const auto tEnd = std::chrono::high_resolution_clock::now();\n\n                            printf(\"[+] Recording took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n\n                            printf(\"[+] Finding best cutoff frequency ..\\n\");\n                            state.recording.updateWorker(state.dataOutput, -1.0f);\n\n                            state.recording.doneCutoffSearch = true;\n                        });\n                    }\n\n                    if (state.recording.doneCutoffSearch) {\n                        state.recording.audioLogger.terminate();\n                        state.recording.isStarted = false;\n                        state.worker.join();\n\n                        // write record.kbd\n                        {\n                            std::ofstream fout(state.recording.pathOutput, std::ios::binary);\n                            if (fout.good() == false) {\n                                fprintf(stderr, \"Failed to open file '%s'\\n\", state.recording.pathOutput.c_str());\n                                return false;\n                            }\n\n                            state.recording.totalSize_bytes = sizeof(state.recording.waveformF[0])*state.recording.waveformF.size();\n                            fout.write((char *)(state.recording.waveformF.data()), sizeof(state.recording.waveformF[0])*state.recording.waveformF.size());\n                            fout.close();\n\n                            printf(\"[+] Total data saved: %g MB\\n\", ((float)(state.recording.totalSize_bytes)/1024.0f/1024.0f));\n                        }\n\n                        // write record.wav\n                        {\n                            drwav_data_format format;\n                            format.container = drwav_container_riff;\n                            format.format = DR_WAVE_FORMAT_PCM;\n                            format.channels = 1;\n                            format.sampleRate = kSampleRate;\n                            format.bitsPerSample = 16;\n\n                            printf(\"[+] Writing WAV data ...\\n\");\n\n                            drwav wav;\n                            drwav_init_file_write(&wav, \"record.wav\", &format, NULL);\n                            drwav_uint64 framesWritten = drwav_write_pcm_frames(&wav, state.recording.waveformI16.size(), state.recording.waveformI16.data());\n\n                            printf(\"[+] WAV frames written = %d\\n\", (int) framesWritten);\n\n                            drwav_uninit(&wav);\n                        }\n\n                        state.dataOutput = \"decoding\";\n\n                        state.decoding.waveformInput = state.recording.waveformI16;\n                        state.state = State::Decoding;\n                        printf(\"[+] Starting decoding\\n\");\n                    }\n                } break;\n            case State::Decoding:\n                {\n                    if (state.worker.joinable() == false) {\n                        state.workDone = false;\n                        state.decoding.interrupt = false;\n                        state.worker = std::thread([&]() {\n                            TKeyPressCollection keyPresses;\n                            {\n                                const auto tStart = std::chrono::high_resolution_clock::now();\n\n                                printf(\"[+] Searching for key presses\\n\");\n\n                                TWaveform waveformMax;\n                                TWaveform waveformThreshold;\n                                if (findKeyPresses(getView(state.decoding.waveformInput, 0), keyPresses, waveformThreshold, waveformMax,\n                                                   kFindKeysThreshold, kFindKeysHistorySize, kFindKeysHistorySizeReset, kFindKeysRemoveLowPower) == false) {\n                                    printf(\"Failed to detect keypresses\\n\");\n                                    return;\n                                }\n\n                                const auto tEnd = std::chrono::high_resolution_clock::now();\n\n                                printf(\"[+] Detected a total of %d potential key presses\\n\", (int) keyPresses.size());\n                                printf(\"[+] Search took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n                            }\n\n                            int n = keyPresses.size();\n\n                            TSimilarityMap similarityMap;\n                            {\n                                const auto tStart = std::chrono::high_resolution_clock::now();\n\n                                printf(\"[+] Calculating CC similarity map\\n\");\n\n                                if (calculateSimilartyMap(kKeyWidth_samples, kKeyAlign_samples, kKeyWidth_samples - kKeyOffset_samples, keyPresses, similarityMap) == false) {\n                                    printf(\"Failed to calculate similariy map\\n\");\n                                    return;\n                                }\n\n                                const auto tEnd = std::chrono::high_resolution_clock::now();\n\n                                printf(\"[+] Calculation took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n\n                                {\n                                    const auto tStart = std::chrono::high_resolution_clock::now();\n\n                                    printf(\"[+] Removing low-similarity keys\\n\");\n\n                                    const int n0 = keyPresses.size();\n\n                                    if (removeLowSimilarityKeys(keyPresses, similarityMap, 0.3f) == false) {\n                                        printf(\"Failed to remove low-similarity keys\\n\");\n                                        return;\n                                    }\n\n                                    const int n1 = keyPresses.size();\n\n                                    const auto tEnd = std::chrono::high_resolution_clock::now();\n\n                                    printf(\"[+] Removed %d low-similarity keys, took %4.3f seconds\\n\", n0 - n1, toSeconds(tStart, tEnd));\n                                }\n\n                                n = keyPresses.size();\n\n                                if (n > 0) {\n                                    const int ncc = std::min(32, n);\n                                    for (int j = 0; j < ncc; ++j) {\n                                        printf(\"%2d: \", j);\n                                        for (int i = 0; i < ncc; ++i) {\n                                            printf(\"%6.3f \", similarityMap[j][i].cc);\n                                        }\n                                        printf(\"\\n\");\n                                    }\n                                    printf(\"\\n\");\n\n                                    auto minCC = similarityMap[0][1].cc;\n                                    auto maxCC = similarityMap[0][1].cc;\n                                    for (int j = 0; j < n - 1; ++j) {\n                                        for (int i = j + 1; i < n; ++i) {\n                                            minCC = std::min(minCC, similarityMap[j][i].cc);\n                                            maxCC = std::max(maxCC, similarityMap[j][i].cc);\n                                        }\n                                    }\n\n                                    printf(\"[+] Similarity map: min = %g, max = %g\\n\", minCC, maxCC);\n                                }\n                            }\n\n                            if (n > 0) {\n                                const int nThread = std::min(8, std::max(1, int(std::thread::hardware_concurrency()) - 2));\n\n                                printf(\"[+] Attempting to recover the text from the recording, nThreads = %d\\n\", nThread);\n\n                                for (int iMain = 0; iMain < 16; ++iMain) {\n                                    Cipher::Processor processor;\n\n                                    Cipher::TParameters params;\n                                    params.maxClusters = 30;\n                                    params.wEnglishFreq = 30.0;\n                                    params.fSpread = 0.5 + 0.1*iMain;\n                                    params.nHypothesesToKeep = std::max(100, 500 - 2*std::min(200, std::max(0, ((int) keyPresses.size() - 100))));\n                                    processor.init(params, state.decoding.freqMap6, similarityMap);\n\n\n                                    std::vector<Cipher::TResult> clusterings;\n\n                                    // clustering\n                                    {\n                                        const auto tStart = std::chrono::high_resolution_clock::now();\n\n                                        for (int nIter = 0; nIter < 8; ++nIter) {\n                                            auto clusteringsCur = processor.getClusterings(2);\n\n                                            for (int i = 0; i < (int) clusteringsCur.size(); ++i) {\n                                                clusterings.push_back(std::move(clusteringsCur[i]));\n                                            }\n\n                                            params.maxClusters = 30 + 8*(nIter + 1);\n                                            processor.init(params, state.decoding.freqMap6, similarityMap);\n                                        }\n\n                                        const auto tEnd = std::chrono::high_resolution_clock::now();\n                                        printf(\"[+] Clustering took %4.3f seconds, fSpread = %g\\n\", toSeconds(tStart, tEnd), params.fSpread);\n                                    }\n\n                                    params.hint.clear();\n                                    params.hint.resize(n, -1);\n\n                                    // beam search\n                                    {\n                                        std::vector<std::thread> workers(std::min(nThread, (int) clusterings.size()));\n\n                                        std::mutex mutexPrint;\n                                        for (int i = 0; i < nThread; ++i) {\n                                            workers[i] = std::thread([&, i]() {\n                                                for (int j = i; j < (int) clusterings.size(); j += nThread) {\n                                                    Cipher::beamSearch(params, state.decoding.freqMap6, clusterings[j]);\n                                                    mutexPrint.lock();\n                                                    printf(\" \");\n                                                    Cipher::printDecoded(clusterings[j].clusters, clusterings[j].clMap, params.hint);\n                                                    printf(\" [%8.3f %8.3f]\\n\", clusterings[j].p, clusterings[j].pClusters);\n                                                    mutexPrint.unlock();\n\n                                                    if (state.decoding.interrupt) {\n                                                        break;\n                                                    }\n                                                }\n                                            });\n                                        }\n\n                                        for (auto& worker : workers) {\n                                            worker.join();\n                                        }\n\n                                        if (state.decoding.interrupt) {\n                                            printf(\"\\n[!] Analysis interrupted\\n\");\n                                            break;\n                                        }\n                                    }\n                                }\n                            } else {\n                                printf(\"[!] No keys found\\n\");\n                            }\n\n                            printf(\"[+] Done\\n\");\n                            state.dataOutput = \"done\";\n                            state.workDone = true;\n                        });\n                    }\n\n                    if (state.workDone) {\n                        state.worker.join();\n                        state.state = State::Idle;\n                    }\n                } break;\n            default:\n                break;\n        };\n\n        return true;\n    };\n\n    return true;\n}\n\n}\n\n\nint main(int argc, char ** argv) {\n    printf(\"Build info: %s, %s, %s\\n\", kGIT_DATE, kGIT_SHA1, kGIT_COMMIT_SUBJECT);\n    printf(\"Usage: %s record.kbd n-gram-dir nkeys [-cN] [-CN] [-FN] [-fN]\\n\", argv[0]);\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - number N of capture channels N\\n\");\n    printf(\"    -FN - select filter type, (0 - none, 1 - first order high-pass, 2 - second order high-pass)\\n\");\n    printf(\"    -fN - cutoff frequency in Hz\\n\");\n\n    if (argc < 4) {\n        return -1;\n    }\n\n    const auto argm = parseCmdArguments(argc, argv);\n    const int captureId     = argm.count(\"c\") == 0 ? 0 : std::stoi(argm.at(\"c\"));\n    const int nChannels     = argm.count(\"C\") == 0 ? 0 : std::stoi(argm.at(\"C\"));\n    const int filterId      = argm.count(\"F\") == 0 ? EAudioFilter::FirstOrderHighPass : std::stoi(argm.at(\"F\"));\n    const int freqCutoff_Hz = argm.count(\"f\") == 0 ? 0 : std::stoi(argm.at(\"f\"));\n\n    const int nKeysToCapture = atoi(argv[3]);\n\n    State state;\n\n    state.recording.captureId = captureId;\n    state.recording.nChannels = nChannels;\n    state.recording.filterId = filterId;\n    state.recording.freqCutoff_Hz = freqCutoff_Hz;\n    state.recording.nKeysToCapture = nKeysToCapture;\n    state.recording.pathOutput = argv[1];\n\n    state.decoding.pathData = argv[2];\n\n    // initialize the application interface\n    if (g_appInterface.init(state) == false) {\n        fprintf(stderr, \"Error: failed to initialize app interface.\\n\");\n        return -4;\n    }\n\n#ifdef __EMSCRIPTEN__\n    // main - emscripten\n    {\n        emscripten_set_main_loop_arg(mainLoop, NULL, 0, true);\n    }\n#else\n    // main - native\n    {\n        if (g_appInterface.doInit() == false) {\n            printf(\"Error: failed to initialize\\n\");\n            return -5;\n        }\n\n        int nLoops = 500;\n\n        // main loop\n        while (true) {\n            if (g_appInterface.mainLoop() == false) {\n                printf(\"Main loop exited\\n\");\n                break;\n            }\n\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n            ++nLoops;\n            if (nLoops % 1000 == 0) {\n                printf(\"State: %d\\n\", (int) state.state);\n                g_appInterface.setData(\"start\");\n            }\n        }\n\n        // cleanup\n        {\n            state.deinit();\n        }\n    }\n#endif\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap3-gui.cpp",
          "type": "blob",
          "size": 73.3076171875,
          "content": "#ifdef __EMSCRIPTEN__\n#include \"emscripten.h\"\n#else\n#define EMSCRIPTEN_KEEPALIVE\n#endif\n\n#include \"build-vars.h\"\n#include \"constants.h\"\n#include \"common.h\"\n#include \"common-gui.h\"\n#include \"subbreak3.h\"\n#include \"audio-logger.h\"\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#include <SDL.h>\n\n#include <atomic>\n#include <cstdio>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <queue>\n#include <functional>\n#include <condition_variable>\n\nstatic std::function<bool()> g_doInit;\nstatic std::function<bool()> g_doReload;\nstatic std::function<void(int, int)> g_setWindowSize;\nstatic std::function<int()> g_getOutputRecordId;\nstatic std::function<bool()> g_mainUpdate;\n\nvoid mainUpdate(void *) {\n    g_mainUpdate();\n}\n\n// JS interface\n\nextern \"C\" {\n    EMSCRIPTEN_KEEPALIVE\n        int do_init() {\n            return g_doInit();\n        }\n\n    EMSCRIPTEN_KEEPALIVE\n        int do_reload() {\n            return g_doReload();\n        }\n\n    EMSCRIPTEN_KEEPALIVE\n        void set_window_size(int sizeX, int sizeY) {\n            g_setWindowSize(sizeX, sizeY);\n        }\n\n    EMSCRIPTEN_KEEPALIVE\n        int get_output_id() {\n            return g_getOutputRecordId();\n        }\n}\n\n#ifdef __EMSCRIPTEN__\n    int g_windowSizeX = 1400;\n    int g_windowSizeY = 900;\n#else\n    int g_windowSizeX = 1920;\n    int g_windowSizeY = 1200;\n#endif\n\nstruct stParameters;\n\nusing TParameters           = stParameters;\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TKeyPressData         = TKeyPressDataI16;\nusing TKeyPressCollection   = TKeyPressCollectionI16;\nusing TPlaybackData         = TPlaybackDataI16;\n\nSDL_AudioDeviceID g_deviceIdOut = 0;\nTPlaybackData g_playbackData;\n\nstruct stParameters {\n    int32_t playbackId              = 0;\n\n    int32_t keyPressWidth_samples   = kKeyWidth_samples;\n    int32_t offsetFromPeak_samples  = kKeyWidth_samples - kKeyOffset_samples;\n    int32_t alignWindow_samples     = kKeyAlign_samples;\n\n    float wEnglish = 30.0f;\n    int nHypothesesToKeep = 500;\n\n    std::vector<int>   valuesClusters = { 40, 60, 80, 100, };\n    std::vector<float> valuesFSpread  = { 0.5f, 0.75f, 1.0f, 1.5f, 2.0f, };\n\n    int32_t nProcessors() const {\n        return valuesClusters.size()*valuesFSpread.size();\n    }\n\n    int32_t valueForProcessorClusters(int idx) const {\n      return valuesClusters[idx/(valuesFSpread.size())];\n    }\n\n    float valueForProcessorFSpread(int idx) const {\n        return valuesFSpread[idx%valuesFSpread.size()];\n    }\n\n    Cipher::TParameters cipher;\n};\n\nstruct stStateUI {\n    bool doUpdate = false;\n\n    struct Flags {\n        bool recalculateSimilarityMap = false;\n        bool resetOptimization = false;\n        bool changeProcessing = false;\n        bool applyParameters = false;\n        bool applyHints = false;\n\n        void clear() { memset(this, 0, sizeof(Flags)); }\n    } flags;\n\n    bool autoHint = false;\n    bool processing = true;\n    bool recording = false;\n    bool audioCapture = false;\n    bool calculatingSimilarityMap = false;\n\n    // key presses window\n    bool scrolling = false;\n    bool recalculateKeyPresses = false;\n\n    int nview = -1;\n    int offset = -1;\n    int viewMin = 512;\n    int viewMax = 512;\n    int nviewPrev = -1;\n    int lastSize = -1;\n    int lastKeyPresses = 0;\n\n    float amin = std::numeric_limits<TSample>::min();\n    float amax = std::numeric_limits<TSample>::max();\n\n    float dragOffset = 0.0f;\n    float scrollSize = 18.0f;\n\n    TWaveform waveformLowRes;\n    TWaveform waveformThreshold;\n    TWaveform waveformMax;\n\n    // window sizes\n    float windowHeightTitleBar = 0;\n    float windowHeightKeyPesses = 0;\n    float windowHeightResults = 0;\n    float windowHeightSimilarity = 0;\n\n    bool openAboutWindow = false;\n    bool openParametersWindow = false;\n    bool loadRecord = false;\n    bool loadKeyPresses = false;\n    bool findBestCutoffFreq = false;\n    bool rescaleWaveform = true;\n\n    int outputRecordId = 0;\n\n    double maxSample = 0.0;\n\n    std::string fnameRecord = \"default.kbd\";\n    std::string fnameKeyPressess = \"default.kbd.keys\";\n\n    TParameters params;\n    TWaveformF waveformOriginal;\n    TWaveform waveformInput;\n    TKeyPressCollection keyPresses;\n    TSimilarityMap similarityMap;\n\n    Cipher::THint suggestions;\n\n    struct ProcessorResults : std::vector<Cipher::TResult> {\n        int id = 0;\n    };\n\n    std::map<int, ProcessorResults> results;\n};\n\nstruct stStateCore {\n    struct Flags {\n        bool calculatingSimilarityMap = false;\n        bool updateSimilarityMap = false;\n        bool updateResult[128];\n\n        void clear() { memset(this, 0, sizeof(Flags)); }\n    } flags;\n\n    bool processing = true;\n\n    Cipher::TFreqMap * freqMap[3];\n    TParameters params;\n    TSimilarityMap similarityMap;\n    TKeyPressCollection keyPresses;\n\n    std::map<int, Cipher::Processor> processors;\n};\n\nstruct stStateCapture {\n    struct Flags {\n        bool updateRecord = false;\n\n        void clear() { memset(this, 0, sizeof(Flags)); }\n    } flags;\n\n    AudioLogger::Record recordNew;\n};\n\ntemplate<typename T>\nstruct TripleBuffer : public T {\n    bool update(bool force = false) {\n        std::lock_guard<std::mutex> lock(mutex);\n        hasChanged = true || force;\n        this->flags.clear();\n\n        return true;\n    }\n\n    bool changed() {\n        std::lock_guard<std::mutex> lock(mutex);\n        return hasChanged;\n    }\n\n    const T & get() {\n        std::lock_guard<std::mutex> lock(mutex);\n        if (hasChanged) {\n            out = buffer;\n            hasChanged = false;\n        }\n\n        return out;\n    }\nprivate:\n    bool hasChanged = false;\n\n    T buffer;\n    T out;\n\n    mutable std::mutex mutex;\n};\n\ntemplate<> bool TripleBuffer<stStateUI>::update(bool force) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged && force == false) return false;\n\n    hasChanged = true;\n\n    buffer.flags = this->flags;\n\n    if (this->flags.recalculateSimilarityMap || this->flags.resetOptimization) {\n        buffer.params = this->params;\n        buffer.keyPresses = this->keyPresses;\n    }\n\n    if (this->flags.changeProcessing) {\n        buffer.processing = this->processing;\n    }\n\n    if (this->flags.applyParameters) {\n        buffer.params = this->params;\n    }\n\n    if (this->flags.applyHints) {\n        buffer.keyPresses = this->keyPresses;\n    }\n\n    this->flags.clear();\n\n    return true;\n}\n\ntemplate<> bool TripleBuffer<stStateCore>::update(bool force) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged && force == false) return false;\n\n    hasChanged = true;\n\n    buffer.flags = this->flags;\n\n    if (this->flags.updateSimilarityMap) {\n        buffer.similarityMap = this->similarityMap;\n    }\n\n    for (int i = 0; i < this->params.nProcessors(); ++i) {\n        if (this->flags.updateResult[i]) {\n            buffer.processors[i] = this->processors[i];\n        }\n    }\n\n    this->flags.clear();\n\n    return true;\n}\n\ntemplate<> const stStateCapture & TripleBuffer<stStateCapture>::get() {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged) {\n        out = std::move(buffer);\n        hasChanged = false;\n    }\n\n    return out;\n}\n\ntemplate<> bool TripleBuffer<stStateCapture>::update(bool force) {\n    std::lock_guard<std::mutex> lock(mutex);\n    if (hasChanged && force == false) return false;\n\n    hasChanged = true;\n\n    buffer.flags = this->flags;\n\n    if (this->flags.updateRecord) {\n        buffer.recordNew.insert(\n                buffer.recordNew.end(),\n                make_move_iterator(this->recordNew.begin()),\n                make_move_iterator(this->recordNew.end()));\n        this->recordNew.clear();\n    }\n\n    this->flags.clear();\n\n    return true;\n}\n\nstd::atomic<bool> g_doRecord;\nAudioLogger audioLogger;\nTripleBuffer<stStateUI> stateUI;\nTripleBuffer<stStateCore> stateCore;\nTripleBuffer<stStateCapture> stateCapture;\n\nfloat plotWaveform(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return waveform->samples[i];\n}\n\nfloat plotWaveformInverse(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return -waveform->samples[i];\n}\n\nbool renderKeyPresses(stStateUI & stateUI, const TWaveform & waveform, TKeyPressCollection & keyPresses) {\n    auto & params = stateUI.params;\n\n    bool & scrolling = stateUI.scrolling;\n    bool & recalculateKeyPresses = stateUI.recalculateKeyPresses;\n\n    int & nview = stateUI.nview;\n    int & viewMin = stateUI.viewMin;\n    int & viewMax = stateUI.viewMax;\n    int & offset = stateUI.offset;\n    int & lastSize = stateUI.lastSize;\n    int & lastKeyPresses = stateUI.lastKeyPresses;\n\n    float & amin = stateUI.amin;\n    float & amax = stateUI.amax;\n\n    float & dragOffset = stateUI.dragOffset;\n    float & scrollSize = stateUI.scrollSize;\n\n    auto & nviewPrev = stateUI.nviewPrev;\n\n    TWaveform & waveformLowRes = stateUI.waveformLowRes;\n    TWaveform & waveformThreshold = stateUI.waveformThreshold;\n    TWaveform & waveformMax = stateUI.waveformMax;\n\n    if (nview < 0) nview = waveform.size();\n    if (offset < 0) offset = (waveform.size() - nview)/2;\n\n    if (stateUI.recording) {\n        if (nview < 1024*kSamplesPerFrame && scrolling == false) {\n            nview = std::min((int) (1024*kSamplesPerFrame), (int) waveform.size());\n        }\n    }\n\n    if (lastSize != (int) waveform.size()) {\n        viewMax = waveform.size();\n        lastSize = waveform.size();\n        nviewPrev = nview + 1;\n\n        if (scrolling == false) {\n            offset = waveform.size() - nview;\n        }\n    }\n\n#if 0\n    if ((int) keyPresses.size() >= lastKeyPresses + 10) {\n        lastKeyPresses = keyPresses.size();\n\n        stateUI.similarityMap.clear();\n        stateUI.flags.recalculateSimilarityMap = true;\n        stateUI.doUpdate = true;\n    }\n#endif\n\n    ImGui::SetNextWindowPos(ImVec2(0, stateUI.windowHeightTitleBar), ImGuiCond_Once);\n    if (stateUI.windowHeightKeyPesses == 0.0f) {\n        ImGui::SetNextWindowSize(ImVec2(g_windowSizeX, 250.0f), ImGuiCond_Always);\n    } else {\n        ImGui::SetNextWindowSize(ImVec2(g_windowSizeX, stateUI.windowHeightKeyPesses), ImGuiCond_Always);\n    }\n    if (ImGui::Begin(\"Key Presses\", nullptr, ImGuiWindowFlags_NoMove)) {\n        bool ignoreDelete = false;\n\n        auto wsize = ImVec2(ImGui::GetContentRegionAvailWidth(), ImGui::GetContentRegionAvail().y - 3*ImGui::GetTextLineHeightWithSpacing());\n\n        if (nview != nviewPrev) {\n            generateLowResWaveform(waveform, waveformLowRes, std::max(1.0f, nview/wsize.x));\n            nviewPrev = nview;\n        }\n\n        auto wview = getView(waveformLowRes, offset, nview);\n\n        auto mpos = ImGui::GetIO().MousePos;\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.3f, 0.3f, 0.3f, 0.3f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveform, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.1f, 0.1f, 0.1f, 0.0f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveformInverse, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n\n        if (waveform.size() == waveformThreshold.size() && waveform.size() == waveformMax.size()) {\n            auto tview = getView(waveformThreshold, offset, nview);\n            auto mview = getView(waveformMax, offset, nview);\n\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 1.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformThreshold\", plotWaveform, &tview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 1.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformThreshold\", plotWaveformInverse, &tview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 0.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformMax\", plotWaveform, &mview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n            ImGui::SetCursorScreenPos(savePos);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.0f, 0.0f, 0.0f, 0.0f });\n            ImGui::PushStyleColor(ImGuiCol_PlotLines, { 0.0f, 1.0f, 0.0f, 0.5f });\n            ImGui::PlotLines(\"##WaveformMax\", plotWaveformInverse, &mview, nview, 0, \"\", amin, amax, wsize);\n            ImGui::PopStyleColor(2);\n        }\n        ImGui::SetCursorScreenPos(savePos);\n\n        ImGui::InvisibleButton(\"##WaveformIB\",wsize);\n        if (ImGui::IsItemHovered()) {\n            auto w = ImGui::GetIO().MouseWheel;\n            auto nview_old = nview;\n            nview *= (10.0 + w)/10.0;\n            nview = std::min(std::max(viewMin, nview), viewMax);\n            if (w != 0.0) {\n                offset = std::max(0.0f, offset + ((mpos.x - savePos.x)/wsize.x)*(nview_old - nview));\n            }\n\n            if (ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0) == false) {\n                dragOffset = offset;\n            }\n\n            if (ImGui::IsMouseDragging(0)) {\n                offset = dragOffset - ImGui::GetMouseDragDelta(0).x*nview/wsize.x;\n            }\n\n            if ((ImGui::IsMouseReleased(0) && ImGui::GetIO().KeyCtrl) || ImGui::IsMouseDoubleClicked(0)) {\n                int i = 0;\n                int64_t pos = offset + nview*(mpos.x - savePos.x)/wsize.x;\n                for (i = 0; i < (int) keyPresses.size(); ++i) {\n                    int64_t p0 = keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples;\n                    int64_t p1 = keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples;\n                    int64_t pmin = std::min(std::min(keyPresses[i].pos, p0), p1);\n                    int64_t pmax = std::max(std::max(keyPresses[i].pos, p0), p1);\n                    if (pmin > pos) {\n                        ignoreDelete = true;\n                        TKeyPressData entry;\n                        entry.pos = pos;\n                        entry.waveform = getView(waveform, 0);\n                        keyPresses.insert(keyPresses.begin() + i, entry);\n                        break;\n                    }\n                    if (pos >= pmin && pos <= pmax) break;\n                }\n                if (i == (int) keyPresses.size() && ignoreDelete == false) {\n                    ignoreDelete = true;\n                    TKeyPressData entry;\n                    entry.pos = pos;\n                    entry.waveform = getView(waveform, 0);\n                    keyPresses.push_back(entry);\n                }\n            }\n        }\n        if (ImGui::BeginPopupContextWindow()) {\n            ImGui::SliderInt(\"View  \", &nview, viewMin, viewMax);\n            ImGui::DragInt  (\"Offset\", &offset, 0.01*nview, 0, waveform.size() - nview);\n            ImGui::SliderFloat(\"Amplitude Min\", &amin, -32000, 0);\n            ImGui::SliderFloat(\"Amplitude Max\", &amax, 0, 32000);\n            ImGui::EndPopup();\n        }\n\n        ImGui::InvisibleButton(\"##WaveformScrollIB\", {wsize.x, scrollSize});\n        drawList->AddRect({savePos.x, savePos.y + wsize.y}, {savePos.x + wsize.x, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n        drawList->AddRectFilled({savePos.x + wsize.x*(1.f*offset)/viewMax, savePos.y + wsize.y}, {savePos.x + wsize.x*(1.f*offset + nview)/viewMax, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n\n        auto savePos2 = ImGui::GetCursorScreenPos();\n\n        if (ImGui::IsItemHovered()) {\n            if (ImGui::IsMouseDown(0)) {\n                scrolling = true;\n            }\n        }\n\n        if (scrolling) {\n            offset = ((mpos.x - savePos.x)/wsize.x)*viewMax - nview/2;\n        }\n\n        if (ImGui::IsMouseDown(0) == false) {\n            scrolling = false;\n        }\n\n        offset = std::max(0, std::min((int) offset, (int) waveform.size() - nview));\n        for (int i = 0; i < (int) keyPresses.size(); ++i) {\n            if (keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples < offset) continue;\n            if (keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples >= offset + nview) break;\n\n            {\n                float x0 = ((float)(keyPresses[i].pos - offset))/nview;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                ImVec2 p1 = { savePos.x + x0*wsize.x, savePos.y + wsize.y };\n\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 0.8f }), 1.0f);\n            }\n\n            {\n                float x0 = ((float)(keyPresses[i].pos - offset))/nview;\n                float x1 = ((float)(keyPresses[i].pos + params.offsetFromPeak_samples - params.keyPressWidth_samples - offset))/nview;\n                float x2 = ((float)(keyPresses[i].pos + params.offsetFromPeak_samples + params.keyPressWidth_samples - offset))/nview;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                ImVec2 p1 = { savePos.x + x1*wsize.x, savePos.y };\n                ImVec2 p2 = { savePos.x + x2*wsize.x, savePos.y + wsize.y };\n\n                float xmin = std::min(std::min(p0.x, p1.x), p2.x);\n                float xmax = std::max(std::max(p0.x, p1.x), p2.x);\n\n                bool isHovered = (mpos.x > xmin && mpos.x < xmax && mpos.y > p1.y && mpos.y < p2.y);\n\n                float col = isHovered ? 0.7f : 0.3f;\n                drawList->AddRectFilled(p1, p2, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, col }));\n\n                if (isHovered) {\n                    if (((ImGui::IsMouseReleased(0) && ImGui::GetIO().KeyCtrl) || ImGui::IsMouseDoubleClicked(0)) && ignoreDelete == false) {\n                        keyPresses.erase(keyPresses.begin() + i);\n                        --i;\n                    }\n                }\n\n                if (nview < 64.0*wsize.x) {\n                    ImGui::SetCursorScreenPos({ savePos.x + 0.5f*((x1 + x2)*wsize.x - ImGui::CalcTextSize(std::to_string(i).c_str()).x), savePos.y + wsize.y - ImGui::GetTextLineHeightWithSpacing() });\n                    ImGui::Text(\"%d\", i);\n                }\n\n            }\n\n            {\n                float x0 = ((float)(g_playbackData.offset + g_playbackData.idx - offset))/nview;\n\n                ImVec2 p0 = {savePos.x + x0*wsize.x, savePos.y};\n                ImVec2 p1 = {savePos.x + x0*wsize.x, savePos.y + wsize.y};\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 0.0f, 0.3f }));\n            }\n        }\n        for (int i = 0; i < (int) keyPresses.size(); ++i) {\n            {\n                float x0 = ((float)(keyPresses[i].pos))/viewMax;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y + wsize.y };\n                ImVec2 p1 = { savePos.x + x0*wsize.x, savePos.y + wsize.y + scrollSize };\n\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 0.3f }));\n            }\n        }\n\n        ImGui::SetCursorScreenPos(savePos2);\n\n        //auto io = ImGui::GetIO();\n        //ImGui::Text(\"Keys pressed:\");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text(\"%d\", i); }\n\n        static bool playHalfSpeed = false;\n        static int historySizeReset = kFindKeysHistorySizeReset;\n        static float thresholdBackground = kFindKeysThreshold;\n        ImGui::PushItemWidth(100.0);\n\n        if (stateUI.recording == false) {\n            if (stateUI.audioCapture) {\n                if (ImGui::Button(\"   Record\")) {\n                    if (float(stateUI.waveformInput.size()/kSampleRate) < kMaxRecordSize_s) {\n                        audioLogger.resume();\n                        stateUI.recording = true;\n                        g_doRecord = true;\n                    }\n                }\n                {\n                    auto savePos = ImGui::GetCursorScreenPos();\n                    auto p = savePos;\n                    p.x += 0.90f*ImGui::CalcTextSize(\"  \").x;\n                    p.y -= 0.56f*ImGui::GetFrameHeightWithSpacing();\n                    ImGui::GetWindowDrawList()->AddCircleFilled(p, 6.0, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 1.0f }));\n                    ImGui::SetCursorScreenPos(savePos);\n                }\n\n                ImGui::SameLine();\n            }\n\n            ImGui::Checkbox(\"x0.5\", &playHalfSpeed);\n            ImGui::SameLine();\n            if (g_playbackData.playing) {\n                if (ImGui::Button(\"Stop\") || (ImGui::IsKeyPressed(44) && ImGui::GetIO().KeyCtrl)) { // Ctrl + space\n                    g_playbackData.playing = false;\n                    g_playbackData.idx = g_playbackData.waveform.n - TPlaybackData::kSamples;\n                }\n            } else {\n                if (ImGui::Button(\"Play\") || (ImGui::IsKeyPressed(44) && ImGui::GetIO().KeyCtrl)) { // Ctrl + space\n                    g_playbackData.playing = true;\n                    g_playbackData.slowDown = playHalfSpeed ? 2 : 1;\n                    g_playbackData.idx = 0;\n                    g_playbackData.offset = offset;\n                    g_playbackData.waveform = getView(waveform, offset, std::min((int) (10*kSampleRate), nview));\n                    SDL_PauseAudioDevice(g_deviceIdOut, 0);\n                }\n            }\n\n            if (g_playbackData.idx >= g_playbackData.waveform.n - kSamplesPerFrame) {\n                g_playbackData.playing = false;\n                SDL_ClearQueuedAudio(g_deviceIdOut);\n#ifndef __EMSCRIPTEN__\n                SDL_PauseAudioDevice(g_deviceIdOut, 1);\n#endif\n            }\n\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"Threshold background\", &thresholdBackground, 0.1f, 50.0f) && (recalculateKeyPresses = true);\n            ImGui::SameLine();\n            ImGui::SliderInt(\"History Size\", &historySizeReset, 512, 1024*16) && (recalculateKeyPresses = true);\n            ImGui::SameLine();\n            if (ImGui::Button(\"Recalculate\")) {\n                recalculateKeyPresses = true;\n            }\n\n            ImGui::SameLine();\n            ImGui::DragInt(\"Key width\", &params.keyPressWidth_samples, 8, 0, kSampleRate/10);\n            ImGui::SameLine();\n            ImGui::DragInt(\"Peak offset\", &params.offsetFromPeak_samples, 8, -kSampleRate/10, kSampleRate/10);\n            ImGui::SameLine();\n            ImGui::DragInt(\"Align window\", &params.alignWindow_samples, 8, 0, kSampleRate/10);\n\n            ImGui::PopItemWidth();\n        } else {\n            if (g_doRecord) {\n                g_doRecord = false;\n                audioLogger.record(0.2f, 0);\n            }\n\n            if (ImGui::Button(\"   Stop Recording\")) {\n                audioLogger.pause();\n                g_doRecord = false;\n\n                stateUI.recalculateKeyPresses = true;\n                stateUI.lastSize = stateUI.lastSize - 1;\n                stateUI.recording = false;\n                stateUI.findBestCutoffFreq = true;\n                stateUI.rescaleWaveform = true;\n            }\n            {\n                auto savePos = ImGui::GetCursorScreenPos();\n                auto p0 = savePos;\n                p0.x += 0.90f*ImGui::CalcTextSize(\"  \").x;\n                p0.y -= 0.56f*ImGui::GetFrameHeightWithSpacing();\n\n                auto p1 = p0;\n                p0.x -= 4.0f;\n                p0.y -= 4.0f;\n                p1.x += 4.0f;\n                p1.y += 4.0f;\n\n                ImGui::GetWindowDrawList()->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 1.0f, 1.0f }));\n                ImGui::SetCursorScreenPos(savePos);\n            }\n\n            ImGui::SameLine();\n            ImGui::Text(\"Record length: %4.2f s (max : %4.2f s)\", (float)(stateUI.waveformInput.size())/kSampleRate, kMaxRecordSize_s);\n        }\n\n        if (recalculateKeyPresses) {\n            findKeyPresses(getView(waveform, 0), keyPresses, waveformThreshold, waveformMax, thresholdBackground, kFindKeysHistorySize, historySizeReset, kFindKeysRemoveLowPower);\n            recalculateKeyPresses = false;\n        }\n\n        stateUI.windowHeightKeyPesses = ImGui::GetWindowHeight();\n    } else {\n        stateUI.windowHeightKeyPesses = ImGui::GetTextLineHeightWithSpacing();\n    }\n    ImGui::End();\n\n    return false;\n}\n\nbool renderResults(stStateUI & stateUI) {\n    float curHeight = std::min(g_windowSizeY - stateUI.windowHeightTitleBar - stateUI.windowHeightKeyPesses, (12 + std::min(8lu, stateUI.results.size())*kTopResultsPerProcessor)*ImGui::GetTextLineHeightWithSpacing());\n    ImGui::SetNextWindowPos(ImVec2(0, stateUI.windowHeightTitleBar + stateUI.windowHeightKeyPesses), ImGuiCond_Always);\n    ImGui::SetNextWindowSize(ImVec2(1.0f*g_windowSizeX, curHeight), ImGuiCond_Always);\n    if (ImGui::Begin(\"Results\", nullptr, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoMove)) {\n        auto drawList = ImGui::GetWindowDrawList();\n\n        if (ImGui::Button(\"Calculate Key Similarity\")) {\n            stateUI.similarityMap.clear();\n            stateUI.flags.recalculateSimilarityMap = true;\n            stateUI.doUpdate = true;\n        }\n\n        if (stateUI.similarityMap.size() > 0 && stateUI.calculatingSimilarityMap == false) {\n            ImGui::SameLine();\n            if (stateUI.processing) {\n                if (ImGui::Button(\"Pause\") || (ImGui::IsKeyPressed(44) && !ImGui::GetIO().KeyCtrl)) { // space\n                    stateUI.processing = false;\n                    stateUI.flags.changeProcessing = true;\n                    stateUI.doUpdate = true;\n                }\n            } else {\n                if (ImGui::Button(\"Resume\") || (ImGui::IsKeyPressed(44) && !ImGui::GetIO().KeyCtrl)) { // space\n                    stateUI.processing = true;\n                    stateUI.flags.changeProcessing = true;\n                    stateUI.doUpdate = true;\n                }\n            }\n\n            ImGui::SameLine();\n            if (ImGui::Button(\"Reset\")) { // c\n                stateUI.results.clear();\n                if (stateUI.autoHint) {\n                    for (auto & keyPress : stateUI.keyPresses) {\n                        keyPress.bind = -1;\n                    }\n                }\n                stateUI.flags.resetOptimization = true;\n                stateUI.doUpdate = true;\n            }\n\n            //ImGui::SameLine();\n            //if (ImGui::Button(\"Apply Suggestions\")) {\n            //    int n = stateUI.suggestions.size();\n            //    for (int i = 0; i < n; ++i) {\n            //        if (stateUI.suggestions[i] < 0) {\n            //            stateUI.keyPresses[i].bind = -1;\n            //            continue;\n            //        }\n            //        if (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) {\n            //            stateUI.keyPresses[i].bind = stateUI.suggestions[i] - 1;\n            //        } else {\n            //            stateUI.keyPresses[i].bind = 26;\n            //        }\n            //    }\n\n            //    stateUI.flags.applyHints = true;\n            //    stateUI.doUpdate = true;\n            //}\n\n            ImGui::SameLine();\n            if (ImGui::Button(\"Clear Hints\")) {\n                for (auto & keyPress : stateUI.keyPresses) {\n                    keyPress.bind = -1;\n                }\n                stateUI.flags.applyHints = true;\n                stateUI.doUpdate = true;\n            }\n        } else {\n            if (stateUI.calculatingSimilarityMap) {\n                ImGui::SameLine();\n                ImGui::TextColored({0.3f, 1.0f, 0.4f, 1.0f}, \"Calculating similarity map ...\");\n            }\n        }\n\n        ImGui::PushItemWidth(200.0);\n\n        //if (ImGui::SliderInt(\"Clusters\", &stateUI.params.valuesClusters[0], 30, 150.0)) {\n        //    stateUI.flags.applyParameters = true;\n        //    stateUI.doUpdate = true;\n        //}\n\n        //if (ImGui::SliderFloat(\"Spread\", &stateUI.params.fSpread, 0.1f, 3.0f)) {\n        //    stateUI.flags.applyParameters = true;\n        //    stateUI.doUpdate = true;\n        //}\n\n        ImGui::SameLine();\n        if (ImGui::SliderInt(\"Keep\", &stateUI.params.nHypothesesToKeep, 20, 2000)) {\n            stateUI.flags.applyParameters = true;\n            stateUI.doUpdate = true;\n        }\n\n        //ImGui::SameLine();\n        //if (ImGui::Checkbox(\"Auto\", &stateUI.autoHint)) {\n        //}\n        //if (ImGui::IsItemHovered()) {\n        //    ImGui::BeginTooltip();\n        //    ImGui::Text(\"If checked, hints will be updated automatically based on the suggestions\");\n        //    ImGui::EndTooltip();\n        //}\n\n        if (stateUI.results.size() > 0) {\n            int nPerAutoHint = 10;\n            auto id0 = stateUI.results.begin()->second.id%stateUI.params.cipher.nIters;\n            auto id1 = (stateUI.results.begin()->second.id/stateUI.params.cipher.nIters)%nPerAutoHint;\n            if (stateUI.processing) stateUI.results.begin()->second.id++;\n            ImGui::SameLine();\n            auto progress = float(id1)/nPerAutoHint;\n            ImGui::ProgressBar(progress, { 100.0, ImGui::GetTextLineHeightWithSpacing() });\n            if (stateUI.processing && id0 == 0 && id1 == 0) {\n                // Important!\n                // This decays the goodnes of found solutions in order to observe new solutions\n                for (auto & result : stateUI.results) {\n                    for (auto & item : result.second) {\n                        item.p *= 1.01;\n                    }\n                }\n                if (stateUI.autoHint && stateUI.results.begin()->second.id > 10000) {\n                    int n = stateUI.suggestions.size();\n                    for (int i = 0; i < n; ++i) {\n                        if (frand() > 0.2) {\n                            stateUI.keyPresses[i].bind = -1;\n                            continue;\n                        }\n                        if (stateUI.suggestions[i] < 0) {\n                            stateUI.keyPresses[i].bind = -1;\n                            continue;\n                        }\n\n                        //if (stateUI.suggestions[i] == 0 || stateUI.suggestions[i] == 5) {\n                        //    stateUI.keyPresses[i].bind = rand()%2 == 0 ? 26 : 4;\n                        //    continue;\n                        //}\n\n                        //if (stateUI.suggestions[i] == 0 || stateUI.suggestions[i] == 5) {\n                        //    stateUI.keyPresses[i].bind = -1;\n                        //    continue;\n                        //}\n\n                        if (frand() > 0.0) {\n                            if (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) {\n                                stateUI.keyPresses[i].bind = stateUI.suggestions[i] - 1;\n                            } else {\n                                stateUI.keyPresses[i].bind = 26;\n                            }\n                        } else {\n                            char c0 = (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) ?\n                                'a' + stateUI.suggestions[i] - 1 : '_';\n\n                            int idx = rand()%kNearbyKeys.at(c0).size();\n                            char c1 = kNearbyKeys.at(c0)[idx];\n\n                            if (c1 == '_') {\n                                stateUI.keyPresses[i].bind = 26;\n                            } else {\n                                stateUI.keyPresses[i].bind = c1 - 'a';\n                            }\n                        }\n                    }\n                    stateUI.flags.applyHints = true;\n                    stateUI.doUpdate = true;\n                }\n            }\n        }\n\n        ImGui::PopItemWidth();\n\n        ImGui::BeginChild(\"##currentResults\", { 0, 0 }, 1, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);\n\n        ImGui::Separator();\n        ImGui::Text(\"          %8s\", \"Suggestions\");\n        {\n            int n = stateUI.suggestions.size();\n            if (n > 0) {\n                ImGui::SameLine();\n                auto charSize = ImGui::CalcTextSize(\"a\");\n                auto curPos = ImGui::GetCursorScreenPos();\n                ImGui::InvisibleButton(\"\", ImVec2{charSize.x*n, 1.0f});\n                ImGui::SetCursorScreenPos(curPos);\n                for (int i = 0; i < n; ++i) {\n                    char c = ' ';\n                    if (stateUI.suggestions[i] < 0) {\n                        ImGui::Text(\" \");\n                    } else {\n                        c = '_';\n                        if (stateUI.suggestions[i] > 0 && stateUI.suggestions[i] <= 26) {\n                            c = 'a' + stateUI.suggestions[i] - 1;\n                        }\n                        ImGui::TextColored({ 1.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                    }\n                    if (ImGui::IsItemHovered()) {\n                        ImGui::BeginTooltip();\n                        ImGui::Text(\"Suggestion for key press %d: '%c'\", i, c);\n                        ImGui::EndTooltip();\n                    }\n                    if (i < n - 1) {\n                        curPos.x += charSize.x;\n                        ImGui::SetCursorScreenPos(curPos);\n                    }\n                }\n            }\n        }\n\n        ImGui::Text(\"             %8s\", \"Hints\");\n        {\n            int n = stateUI.keyPresses.size();\n            if (n > 0) {\n                ImGui::SameLine();\n                auto charSize = ImGui::CalcTextSize(\"a\");\n                auto curPos = ImGui::GetCursorScreenPos();\n                ImGui::InvisibleButton(\"\", ImVec2{charSize.x*n, 1.0f});\n                ImGui::SetCursorScreenPos(curPos);\n                for (int i = 0; i < n; ++i) {\n                    if (stateUI.keyPresses[i].bind < 0) {\n                        ImGui::Text(\".\");\n                    } else {\n                        char c = '_';\n                        if (stateUI.keyPresses[i].bind >= 0 && stateUI.keyPresses[i].bind < 26) {\n                            c = 'a' + stateUI.keyPresses[i].bind;\n                        }\n                        ImGui::TextColored({ 0.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                    }\n                    if (ImGui::IsItemHovered()) {\n                        auto p0 = curPos;\n                        auto p1 = p0;\n                        p1.x += charSize.x;\n                        p1.y += charSize.y;\n                        drawList->AddRect(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 1.0f}));\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 0.6f}));\n\n                        if (ImGui::IsMouseDown(0)) {\n                            stateUI.nview = 16*1024;\n                            stateUI.offset = stateUI.keyPresses[i].pos - stateUI.nview/2;\n                        }\n\n                        if (ImGui::IsMouseDown(1)) {\n                            stateUI.keyPresses[i].bind = -1;\n                            stateUI.flags.applyHints = true;\n                            stateUI.doUpdate = true;\n                        }\n\n                        if (ImGui::IsMouseDown(2)) {\n                            stateUI.keyPresses[i].bind = 26;\n                            stateUI.flags.applyHints = true;\n                            stateUI.doUpdate = true;\n                        }\n\n                        for (int k = 0; k < 26; ++k) {\n                            if (ImGui::IsKeyPressed(4 + k)) {\n                                stateUI.keyPresses[i].bind = k;\n                            }\n                        }\n\n                        ImGui::BeginTooltip();\n                        ImGui::Text(\"Key press: %d\", i);\n                        ImGui::Text(\" - Left click to focus\");\n                        ImGui::Text(\" - Right click to remove hint\");\n                        ImGui::Text(\" - Middle click to put a space as hint\");\n                        ImGui::EndTooltip();\n                    }\n                    if (i < n - 1) {\n                        curPos.x += charSize.x;\n                        ImGui::SetCursorScreenPos(curPos);\n                    }\n                }\n            }\n        }\n\n        ImGui::Text(\"%2s. %8s %8s\", \"#\", \"Prob\", \"Clust\");\n        ImGui::Separator();\n\n        for (const auto & items : stateUI.results) {\n            ImGui::Separator();\n            const auto & id = items.first;\n            for (const auto & item : items.second) {\n                const auto & result = item;\n\n                ImGui::PushID(id);\n                ImGui::Text(\"%2d. %8.3f %8.3f\", id, result.p, result.pClusters);\n                if (ImGui::IsItemHovered()) {\n                    ImGui::BeginTooltip();\n                    ImGui::Text(\"Processor   %d\", id);\n                    ImGui::Text(\"Cluster-to-letter map:\");\n                    {\n                        int i = 0;\n                        for (auto& pair : result.clMap) {\n                            char c = '_';\n                            if (pair.second > 0 && pair.second <= 26) {\n                                c = 'a' + pair.second - 1;\n                            }\n                            ImGui::Text(\"%3d: %c  \", pair.first, c);\n                            if (++i % 10 != 0) ImGui::SameLine();\n                        }\n                    }\n                    ImGui::EndTooltip();\n                }\n                if (result.clMap.empty() == false) {\n                    ImGui::SameLine();\n                    int n = std::min(result.clusters.size(), stateUI.keyPresses.size());\n                    auto charSize = ImGui::CalcTextSize(\"a\");\n                    auto curPos = ImGui::GetCursorScreenPos();\n                    if (n > 0) {\n                        ImGui::InvisibleButton(\"\", ImVec2{charSize.x*n, 1.0f});\n                        ImGui::SetCursorScreenPos(curPos);\n                        for (int i = 0; i < n; ++i) {\n                            auto cluster = result.clusters[i];\n                            if (result.clMap.find(cluster) == result.clMap.end()) {\n                                ImGui::Text(\"%c\", '?');\n                            } else {\n                                auto let = result.clMap.at(result.clusters[i]);\n\n                                char c = '.';\n                                if (let > 0 && let <= 26) {\n                                    c = 'a' + let - 1;\n                                } else if (let == 27) {\n                                    c = '_';\n                                }\n\n                                if (stateUI.keyPresses[i].bind == let - 1) {\n                                    ImGui::TextColored({ 0.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                                } else if (stateUI.suggestions[i] == let) {\n                                    ImGui::TextColored({ 1.0f, 1.0f, 0.0f, 1.0f }, \"%c\", c);\n                                } else {\n                                    ImGui::Text(\"%c\", c);\n                                }\n\n                                if (ImGui::IsItemHovered()) {\n                                    auto p0 = curPos;\n                                    auto p1 = p0;\n                                    p1.x += charSize.x;\n                                    p1.y += charSize.y;\n                                    drawList->AddRect(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 1.0f}));\n                                    drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({0.0f, 1.0f, 0.0f, 0.6f}));\n                                    if (ImGui::IsMouseDown(0) && ImGui::GetIO().KeyCtrl) {\n                                        for (int j = 0; j < n; ++j) {\n                                            auto let2 = result.clMap.at(result.clusters[j]);\n                                            if (let2 > 0 && let2 <= 26) {\n                                                if (stateUI.keyPresses[j].bind == 26) {\n                                                    stateUI.keyPresses[j].bind = -1;\n                                                }\n                                            } else {\n                                                stateUI.keyPresses[j].bind = 26;\n                                            }\n                                        }\n                                        stateUI.flags.applyHints = true;\n                                        stateUI.doUpdate = true;\n                                    } else if (ImGui::IsMouseDown(0)) {\n                                        if (let > 0 && let <= 26) {\n                                            stateUI.keyPresses[i].bind = let - 1;\n                                        } else {\n                                            stateUI.keyPresses[i].bind = 26;\n                                        }\n                                        stateUI.flags.applyHints = true;\n                                        stateUI.doUpdate = true;\n                                    } else if (ImGui::IsMouseDown(1)) {\n                                        stateUI.keyPresses[i].bind = -1;\n                                    }\n                                    ImGui::BeginTooltip();\n                                    ImGui::Text(\"Key presss: %d, letter - %d\", i, let);\n                                    ImGui::Text(\" - Left click to set as hint\");\n                                    ImGui::Text(\" - Ctrl + left click to set only the spaces as hint\");\n                                    ImGui::EndTooltip();\n                                }\n                            }\n\n                            if (i < n - 1) {\n                                curPos.x += charSize.x;\n                                ImGui::SetCursorScreenPos(curPos);\n                            }\n                        }\n                    }\n                }\n                ImGui::PopID();\n            }\n        }\n\n        ImGui::EndChild();\n\n        stateUI.windowHeightResults = ImGui::GetWindowHeight();\n    } else {\n        stateUI.windowHeightResults = ImGui::GetTextLineHeightWithSpacing();\n    }\n\n    ImGui::End();\n    return true;\n}\n\nbool renderSimilarity(const TKeyPressCollection & keyPresses, const TSimilarityMap & similarityMap) {\n    int offsetY = stateUI.windowHeightTitleBar + stateUI.windowHeightKeyPesses + stateUI.windowHeightResults;\n    ImGui::SetNextWindowPos(ImVec2(0, offsetY), ImGuiCond_Always);\n    ImGui::SetNextWindowSize(ImVec2(1.0f*g_windowSizeX, g_windowSizeY - offsetY), ImGuiCond_Always);\n    if (ImGui::Begin(\"Similarity\", nullptr, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoMove)) {\n        auto wsize = ImGui::GetContentRegionAvail();\n\n        static float bsize = 10.0f;\n        static float threshold = 0.0f;\n        ImGui::PushItemWidth(100.0);\n\n        int n = similarityMap.size();\n        ImGui::SameLine();\n        ImGui::SliderFloat(\"Size\", &bsize, 1.5f, 24.0f);\n        ImGui::SameLine();\n        if (ImGui::Button(\"Fit\")) {\n            bsize = (std::min(wsize.x, wsize.y) - 24.0)/n;\n        }\n        ImGui::SameLine();\n        ImGui::SliderFloat(\"Threshold\", &threshold, 0.0f, 1.0f);\n        ImGui::PopItemWidth();\n\n        ImGui::BeginChild(\"Canvas\", { 0, 0 }, 1, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_AlwaysVerticalScrollbar);\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n\n        int hoveredId = -1;\n        if (n > 0) {\n            ImGui::InvisibleButton(\"SimilarityMapIB\", { n*bsize, n*bsize });\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    float col = similarityMap[i][j].cc;\n                    ImVec2 p0 = {savePos.x + j*bsize, savePos.y + i*bsize};\n                    ImVec2 p1 = {savePos.x + (j + 1)*bsize - 1.0f, savePos.y + (i + 1)*bsize - 1.0f};\n                    if (similarityMap[i][j].cc > threshold) {\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32(ImVec4{1.0f - col, col, 0.0f, col}));\n                    }\n                    if (ImGui::IsMouseHoveringRect(p0, {p1.x + 1.0f, p1.y + 1.0f})) {\n                        if (i == j) hoveredId = i;\n                        if (ImGui::IsMouseDown(0) == false) {\n                            ImGui::BeginTooltip();\n                            //ImGui::Text(\"[%3d, %3d]\\n\", keyPresses[i].cid, keyPresses[j].cid);\n                            ImGui::Text(\"[%3d, %3d] = %5.4g\\n\", i, j, similarityMap[i][j].cc);\n                            //for (int k = 0; k < n; ++k) {\n                            //    if (similarityMap[i][k].cc > 0.5) ImGui::Text(\"Offset [%3d, %3d] = %d\\n\", i, k, (int) similarityMap[i][k].offset);\n                            //}\n                            //ImGui::Separator();\n                            //for (int k = 0; k < n; ++k) {\n                            //    if (similarityMap[k][i].cc > 0.5) ImGui::Text(\"Offset [%3d, %3d] = %d\\n\", k, i, (int) similarityMap[k][i].offset);\n                            //}\n                            ImGui::EndTooltip();\n                        }\n                    }\n                }\n            }\n\n            if (hoveredId >= 0) {\n                for (int i = 0; i < n; ++i) {\n                    if (keyPresses[i].cid == keyPresses[hoveredId].cid) {\n                        ImVec2 p0 = {savePos.x + i*bsize, savePos.y + i*bsize};\n                        ImVec2 p1 = {savePos.x + (i + 1)*bsize - 1.0f, savePos.y + (i + 1)*bsize - 1.0f};\n                        drawList->AddRectFilled(p0, p1, ImGui::ColorConvertFloat4ToU32({1.0f, 0.0f, 0.0f, 1.0f}));\n                    }\n                }\n            }\n        } else {\n            ImGui::TextColored({1.0f, 0.3f, 0.4f, 1.0f}, \"Waiting for similarity map to be available!\");\n        }\n\n        ImGui::EndChild();\n\n        stateUI.windowHeightSimilarity = ImGui::GetWindowHeight();\n    } else {\n        stateUI.windowHeightSimilarity = ImGui::GetTextLineHeightWithSpacing();\n    }\n    ImGui::End();\n    return false;\n}\n\nbool prepareAudioOut(const TParameters & params) {\n    if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_FALSE);\n    printf(\"Found %d playback devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Playback device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_FALSE));\n    }\n\n    if (params.playbackId < 0 || params.playbackId >= nDevices) {\n        printf(\"Invalid playback device id selected - %d\\n\", params.playbackId);\n        return false;\n    }\n\n    SDL_AudioSpec playbackSpec;\n    SDL_zero(playbackSpec);\n\n    playbackSpec.freq = kSampleRate;\n    playbackSpec.format = std::is_same<TSample, int16_t>::value ? AUDIO_S16 : AUDIO_S32;\n    playbackSpec.channels = 1;\n    playbackSpec.samples = TPlaybackData::kSamples;\n    playbackSpec.callback = cbPlayback<TSample>;\n    playbackSpec.userdata = &g_playbackData;\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    g_deviceIdOut = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(params.playbackId, SDL_FALSE), SDL_FALSE, &playbackSpec, &obtainedSpec, 0);\n    if (!g_deviceIdOut) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for playback: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return false;\n    }\n\n    printf(\"Opened playback device succesfully!\\n\");\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d\\n\", obtainedSpec.format);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    SDL_PauseAudioDevice(g_deviceIdOut, 1);\n\n    return true;\n}\n\nint main(int argc, char ** argv) {\n    srand(time(0));\n\n    printf(\"Build: %s, (%s)\\n\", kGIT_DATE, kGIT_SHA1);\n    printf(\"Usage: %s record.kbd n-gram-dir [-pN] [-cN] [-CN] [-FN] [-fN]\\n\", argv[0]);\n    printf(\"    -pN - select playback device N\\n\");\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - select number N of capture channels to use\\n\");\n    printf(\"    -FN - select filter type, (0 - none, 1 - first order high-pass, 2 - second order high-pass)\\n\");\n    printf(\"    -fN - cutoff frequency in Hz\\n\");\n\n    if (argc < 3) {\n        return -1;\n    }\n\n    const auto argm = parseCmdArguments(argc, argv);\n    const int playbackId    = argm.count(\"p\") == 0 ? 0 : std::stoi(argm.at(\"p\"));\n    const int captureId     = argm.count(\"c\") == 0 ? 0 : std::stoi(argm.at(\"c\"));\n    const int nChannels     = argm.count(\"C\") == 0 ? 0 : std::stoi(argm.at(\"C\"));\n    const int filterId      = argm.count(\"F\") == 0 ? EAudioFilter::FirstOrderHighPass : std::stoi(argm.at(\"F\"));\n    const int freqCutoff_Hz = argm.count(\"f\") == 0 ? 0 : std::stoi(argm.at(\"f\"));\n\n    stateUI.params.playbackId = playbackId;\n    stateUI.fnameRecord = argv[1];\n    stateUI.fnameKeyPressess = stateUI.fnameRecord + \".keys\";\n\n    stateUI.waveformInput.reserve(kSamplesPerFrame*kMaxRecordSize_frames);\n    stateUI.waveformOriginal.reserve(kSamplesPerFrame*kMaxRecordSize_frames);\n\n    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0) {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -2;\n    }\n\n    AudioLogger::Callback cbAudio = [&](const AudioLogger::Record & frames) {\n        stateCapture.recordNew.insert(\n                stateCapture.recordNew.end(),\n                frames.begin(),\n                frames.end());\n\n        stateCapture.flags.updateRecord = true;\n        stateCapture.update();\n\n        g_doRecord = true;\n\n        return;\n    };\n\n    g_doInit = [&]() {\n        if (prepareAudioOut(stateUI.params) == false) {\n            printf(\"Error: failed to initialize audio playback\\n\");\n            return false;\n        }\n\n        AudioLogger::Parameters parameters;\n        parameters.callback = cbAudio;\n        parameters.captureId = captureId;\n        parameters.nChannels = nChannels;\n        parameters.sampleRate = kSampleRate;\n        parameters.filter = EAudioFilter::None;\n        parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n        if (audioLogger.install(std::move(parameters)) == false) {\n            fprintf(stderr, \"Failed to initialize audio capture\\n\");\n        } else {\n            audioLogger.pause();\n            stateUI.audioCapture = true;\n\n            printf(\"[+] Audio capture initilized succesfully\\n\");\n        }\n\n        return true;\n    };\n\n    g_doReload = [&]() {\n        stateUI.loadRecord = true;\n\n        return true;\n    };\n\n    g_getOutputRecordId = [&]() {\n        return stateUI.outputRecordId;\n    };\n\n    printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n    if (readFromFile<TSampleF>(argv[1], stateUI.waveformOriginal) == false) {\n        printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n        //return -4;\n    } else {\n        auto freqCutoffCur_Hz = freqCutoff_Hz;\n        if (freqCutoffCur_Hz == 0) {\n            const auto tStart = std::chrono::high_resolution_clock::now();\n\n            freqCutoffCur_Hz = Cipher::findBestCutoffFreq(stateUI.waveformOriginal, (EAudioFilter) filterId, kSampleRate, 100.0f, 1000.0f, 100.0f);\n\n            const auto tEnd = std::chrono::high_resolution_clock::now();\n            printf(\"[+] Found best freqCutoff = %d Hz, took %4.3f seconds\\n\", freqCutoffCur_Hz, toSeconds(tStart, tEnd));\n        }\n\n        printf(\"[+] Filtering waveform with filter type = %d and cutoff frequency = %d Hz\\n\", filterId, freqCutoffCur_Hz);\n        ::filter(stateUI.waveformOriginal, (EAudioFilter) filterId, freqCutoffCur_Hz, kSampleRate);\n\n        printf(\"[+] Converting waveform to i16 format ...\\n\");\n        if (convert(stateUI.waveformOriginal, stateUI.waveformInput) == false) {\n            printf(\"Conversion failed\\n\");\n            return -4;\n        }\n\n        stateUI.recalculateKeyPresses = true;\n        stateUI.maxSample = calcAbsMax(stateUI.waveformOriginal);\n    }\n\n    Cipher::TFreqMap freqMap6;\n\n    if (Cipher::loadFreqMapBinary((std::string(argv[2]) + \"/./ggwords-6-gram.dat.binary\").c_str(), freqMap6) == false) {\n        return -5;\n    }\n\n    stateCore.freqMap[0] = &freqMap6;\n    stateCore.freqMap[1] = &freqMap6;\n    stateCore.freqMap[2] = &freqMap6;\n\n    Gui::Objects guiObjects;\n    if (Gui::init(\"Keytap3\", g_windowSizeX, g_windowSizeY, guiObjects) == false) {\n        return -6;\n    }\n\n    g_setWindowSize = [&](int sizeX, int sizeY) {\n        SDL_SetWindowSize(guiObjects.window, sizeX, sizeY);\n    };\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) stateUI.waveformInput.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*stateUI.waveformInput.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) stateUI.waveformInput.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(stateUI.waveformInput.size())/kSampleRate);\n\n    bool finishApp = false;\n    g_mainUpdate = [&]() {\n        if (finishApp) return false;\n\n        if (stateCore.changed()) {\n            auto stateCoreNew = stateCore.get();\n\n            stateUI.calculatingSimilarityMap = stateCoreNew.flags.calculatingSimilarityMap;\n\n            if (stateCoreNew.flags.updateSimilarityMap) {\n                stateUI.similarityMap = stateCoreNew.similarityMap;\n            }\n\n            bool recalcSuggestions = false;\n            for (int i = 0; i < stateCoreNew.params.nProcessors(); ++i) {\n                if (stateCoreNew.flags.updateResult[i]) {\n                    recalcSuggestions = true;\n                    if (stateCoreNew.processors[i].getResult().id != stateUI.results[i].id) {\n                        stateUI.results[i].id = stateCoreNew.processors[i].getResult().id;\n                        if (stateUI.results[i].size() < kTopResultsPerProcessor) {\n                            stateUI.results[i].push_back(stateCoreNew.processors[i].getResult());\n                        } else if (stateCoreNew.processors[i].getResult().p > stateUI.results[i].back().p) {\n                            stateUI.results[i].back() = stateCoreNew.processors[i].getResult();\n                        }\n\n                        int k = stateUI.results[i].size() - 1;\n                        while (k > 0) {\n                            if (stateUI.results[i][k-1].p < stateUI.results[i][k].p) {\n                                std::swap(stateUI.results[i][k-1], stateUI.results[i][k]);\n                            }\n                            --k;\n                        }\n                    }\n                }\n            }\n\n            recalcSuggestions = false;\n            if (recalcSuggestions) {\n                int n = stateUI.keyPresses.size();\n                stateUI.suggestions.resize(n);\n\n                for (int i = 0; i < n; ++i) {\n                    int c = 0;\n                    std::map<int, int> cnt;\n                    for (const auto & result : stateUI.results) {\n                        const auto & item = result.second.front();\n                        if (n != (int) item.clusters.size()) continue;\n                        if (item.clMap.find(item.clusters[i]) == item.clMap.end()) continue;\n                        if (i <= (int) item.clusters.size()) {\n                            ++cnt[item.clMap.at(item.clusters[i])];\n                            ++c;\n                        }\n                    }\n                    bool hasSuggestion = false;\n                    for (auto & s : cnt) {\n                        if (s.second > 0.5*c) {\n                            stateUI.suggestions[i] = s.first;\n                            hasSuggestion = true;\n                        }\n                    }\n                    if (hasSuggestion == false) {\n                        stateUI.suggestions[i] = -1;\n                    }\n                }\n            } else {\n                int n = stateUI.keyPresses.size();\n                stateUI.suggestions.resize(n);\n            }\n        }\n\n        if (stateCapture.changed()) {\n            auto stateCaptureNew = stateCapture.get();\n\n            if (stateCaptureNew.flags.updateRecord) {\n                for (auto & frame : stateCaptureNew.recordNew) {\n                    stateUI.waveformOriginal.insert(stateUI.waveformOriginal.end(), frame.begin(), frame.end());\n                }\n\n                int nold = stateUI.waveformInput.size();\n                float scale = float(std::numeric_limits<TSample>::max())/(stateUI.maxSample == 0.0 ? 1.0f : stateUI.maxSample);\n                stateUI.waveformInput.resize(stateUI.waveformOriginal.size());\n                for (int i = nold; i < (int) stateUI.waveformInput.size(); ++i) {\n                    stateUI.waveformInput[i] = scale*stateUI.waveformOriginal[i];\n                }\n            }\n        }\n\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            switch (event.type) {\n                case SDL_QUIT:\n                    finishApp = true;\n                    break;\n                case SDL_KEYDOWN:\n                    if (event.key.keysym.sym == SDLK_ESCAPE) {\n                        finishApp = true;\n                    }\n                    break;\n                case SDL_DROPFILE:\n                    {\n                        char * path = event.drop.file;\n                        stateUI.fnameRecord = path;\n                        stateUI.loadRecord = true;\n                        SDL_free(path);\n                    }\n                    break;\n                case SDL_WINDOWEVENT:\n                    if (event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(guiObjects.window)) {\n                        finishApp = true;\n                    }\n                    break;\n            };\n        }\n\n        SDL_GetWindowSize(guiObjects.window, &g_windowSizeX, &g_windowSizeY);\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplSDL2_NewFrame(guiObjects.window);\n        ImGui::NewFrame();\n\n        stateUI.windowHeightTitleBar = ImGui::GetTextLineHeightWithSpacing();\n\n        if (ImGui::BeginMainMenuBar())\n        {\n            if (ImGui::BeginMenu(\"File\"))\n            {\n                ImGui::Separator();\n                ImGui::TextDisabled(\"Record: %s\", stateUI.fnameRecord.c_str());\n                ImGui::Separator();\n                if (ImGui::MenuItem(\"Save Record\")) {\n                    saveToFile(stateUI.fnameRecord, stateUI.waveformOriginal);\n                    stateUI.outputRecordId++;\n                }\n                if (ImGui::MenuItem(\"Load Record\")) {\n                    stateUI.loadRecord = true;\n                }\n\n                ImGui::Separator();\n                ImGui::TextDisabled(\"Key Presses: %s\", stateUI.fnameKeyPressess.c_str());\n                ImGui::Separator();\n                if (ImGui::MenuItem(\"Save Key Presses\")) {\n                    saveKeyPresses(stateUI.fnameKeyPressess.c_str(), stateUI.keyPresses);\n                }\n                if (ImGui::MenuItem(\"Load Key Presses\")) {\n                    stateUI.loadKeyPresses = true;\n                }\n\n                ImGui::EndMenu();\n            }\n            if (ImGui::BeginMenu(\"Help\")) {\n                if (ImGui::MenuItem(\"Parameters\")) {\n                    stateUI.openParametersWindow = true;\n                }\n                if (ImGui::MenuItem(\"About\")) {\n                    stateUI.openAboutWindow = true;\n                }\n                ImGui::EndMenu();\n            }\n            ImGui::EndMainMenuBar();\n        }\n\n        if (stateUI.openAboutWindow) {\n            ImGui::OpenPopup(\"About\");\n            stateUI.openAboutWindow = false;\n        }\n        ImGui::SetNextWindowSize({512, -1}, ImGuiCond_Once);\n        if (ImGui::BeginPopupModal(\"About\", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar)) {\n            ImGui::Text(\"%s\", \"\");\n            {\n                const char * text = \"Keytap3 : v0.1 [%s]    \";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                ImGui::Text(text, kGIT_SHA1);\n            }\n            ImGui::Text(\"%s\", \"\");\n            {\n                const char * text = \"author : Georgi Gerganov\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                ImGui::Text(\"%s\", text);\n            }\n            {\n                const char * text = \"source code : https://github.com/ggerganov/kbd-audio\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                ImGui::Text(\"%s\", text);\n            }\n            ImGui::Text(\"%s\", \"\");\n            {\n                const char * text = \"Close\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                if (ImGui::Button(text)) {\n                    ImGui::CloseCurrentPopup();\n                }\n            }\n            ImGui::Text(\"%s\", \"\");\n            ImGui::EndPopup();\n        }\n\n        if (stateUI.openParametersWindow) {\n            ImGui::OpenPopup(\"Parameters\");\n            stateUI.openParametersWindow = false;\n        }\n        ImGui::SetNextWindowSize({320, -1}, ImGuiCond_Once);\n        if (ImGui::BeginPopupModal(\"Parameters\", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar)) {\n            ImGui::Text(\"%s\", \"\");\n            ImGui::Text(\"Sample rate            : %d\\n\", (int) kSampleRate);\n            ImGui::Text(\"Samples per frame      : %d\\n\", (int) kSamplesPerFrame);\n            ImGui::Text(\"Hardware concurrency   : %d\\n\", (int) std::thread::hardware_concurrency());\n            ImGui::Text(\"Max record size        : %g s\\n\", kMaxRecordSize_s);\n            ImGui::Text(\"Freq cutoff            : %g Hz\\n\", kFreqCutoff_Hz);\n            ImGui::Text(\"Subbreak Processors    : %d\\n\", stateUI.params.nProcessors());\n            ImGui::Text(\"%s\", \"\");\n\n            {\n                const char * text = \"Close\";\n                ImGui::Text(\"%s\", \"\");\n                ImGui::SameLine(0.5f*ImGui::GetContentRegionAvailWidth() - 0.45f*ImGui::CalcTextSize(text).x);\n                if (ImGui::Button(text)) {\n                    ImGui::CloseCurrentPopup();\n                }\n            }\n            ImGui::Text(\"%s\", \"\");\n            ImGui::EndPopup();\n        }\n\n\n        if (stateUI.loadRecord) {\n            printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n            if (readFromFile<TSampleF>(stateUI.fnameRecord, stateUI.waveformOriginal) == false) {\n                printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n            } else {\n                auto freqCutoffCur_Hz = freqCutoff_Hz;\n                if (freqCutoffCur_Hz == 0) {\n                    const auto tStart = std::chrono::high_resolution_clock::now();\n\n                    freqCutoffCur_Hz = Cipher::findBestCutoffFreq(stateUI.waveformOriginal, (EAudioFilter) filterId, kSampleRate, 100.0f, 1000.0f, 100.0f);\n\n                    const auto tEnd = std::chrono::high_resolution_clock::now();\n                    printf(\"[+] Found best freqCutoff = %d Hz, took %4.3f seconds\\n\", freqCutoffCur_Hz, toSeconds(tStart, tEnd));\n                }\n\n                printf(\"[+] Filtering waveform with filter type = %d and cutoff frequency = %d Hz\\n\", filterId, freqCutoffCur_Hz);\n                ::filter(stateUI.waveformOriginal, (EAudioFilter) filterId, freqCutoffCur_Hz, kSampleRate);\n\n                printf(\"[+] Converting waveform to i16 format ...\\n\");\n                if (convert(stateUI.waveformOriginal, stateUI.waveformInput) == false) {\n                    printf(\"Conversion failed\\n\");\n                } else {\n                    stateUI.nview = -1;\n                    stateUI.recalculateKeyPresses = true;\n                    stateUI.maxSample = calcAbsMax(stateUI.waveformOriginal);\n                    stateUI.flags.recalculateSimilarityMap = true;\n                    stateUI.doUpdate = true;\n                }\n            }\n\n            stateUI.loadRecord = false;\n        }\n\n        if (stateUI.loadKeyPresses) {\n            loadKeyPresses(stateUI.fnameKeyPressess.c_str(), getView(stateUI.waveformInput, 0), stateUI.keyPresses);\n            stateUI.loadKeyPresses = false;\n        }\n\n        if (stateUI.findBestCutoffFreq) {\n            auto freqCutoffCur_Hz = freqCutoff_Hz;\n            if (freqCutoffCur_Hz == 0) {\n                const auto tStart = std::chrono::high_resolution_clock::now();\n\n                freqCutoffCur_Hz = Cipher::findBestCutoffFreq(stateUI.waveformOriginal, (EAudioFilter) filterId, kSampleRate, 100.0f, 1000.0f, 100.0f);\n\n                const auto tEnd = std::chrono::high_resolution_clock::now();\n                printf(\"[+] Found best freqCutoff = %d Hz, took %4.3f seconds\\n\", freqCutoffCur_Hz, toSeconds(tStart, tEnd));\n            }\n\n            printf(\"[+] Filtering waveform with filter type = %d and cutoff frequency = %d Hz\\n\", filterId, freqCutoffCur_Hz);\n            ::filter(stateUI.waveformOriginal, (EAudioFilter) filterId, freqCutoffCur_Hz, kSampleRate);\n\n            stateUI.findBestCutoffFreq = false;\n        }\n\n        if (stateUI.rescaleWaveform) {\n            if (convert(stateUI.waveformOriginal, stateUI.waveformInput) == false) {\n                fprintf(stderr, \"error : recording failed\\n\");\n            }\n            stateUI.maxSample = calcAbsMax(stateUI.waveformOriginal);\n\n            stateUI.rescaleWaveform = false;\n        }\n\n        if (float(stateUI.waveformInput.size())/kSampleRate >= kMaxRecordSize_s) {\n            stateUI.waveformInput.resize((kMaxRecordSize_frames - 1)*kSamplesPerFrame);\n            audioLogger.pause();\n            g_doRecord = false;\n\n            stateUI.recalculateKeyPresses = true;\n            stateUI.lastSize = stateUI.lastSize - 1;\n            stateUI.recording = false;\n            stateUI.rescaleWaveform = true;\n        }\n\n        for (int i = 0; i < IM_ARRAYSIZE(ImGui::GetIO().KeysDown); i++) if (ImGui::IsKeyPressed(i)) {\n            //printf(\"Key pressed: %d\\n\", i);\n        }\n\n        renderKeyPresses(stateUI, stateUI.waveformInput, stateUI.keyPresses);\n        renderResults(stateUI);\n        renderSimilarity(stateUI.keyPresses, stateUI.similarityMap);\n\n        Gui::render(guiObjects);\n\n        if (stateUI.doUpdate) {\n            stateUI.update();\n            stateUI.doUpdate = false;\n        }\n\n        return true;\n    };\n\n    std::thread workerCore([&]() {\n        while (finishApp == false) {\n            if (stateUI.changed()) {\n                auto stateUINew = stateUI.get();\n\n                if (stateUINew.flags.recalculateSimilarityMap || stateUINew.flags.resetOptimization) {\n                    if (stateUINew.keyPresses.size() < 3) continue;\n\n                    stateCore.params = stateUINew.params;\n                    stateCore.keyPresses = stateUINew.keyPresses;\n\n                    printf(\"[+] Recalculating similarity map ...\\n\");\n\n                    if (stateUINew.flags.recalculateSimilarityMap) {\n                        stateCore.flags.calculatingSimilarityMap = true;\n                        stateCore.update(true);\n\n                        calculateSimilartyMap(\n                                stateUINew.params.keyPressWidth_samples,\n                                stateUINew.params.alignWindow_samples,\n                                stateUINew.params.offsetFromPeak_samples,\n                                stateCore.keyPresses,\n                                stateCore.similarityMap);\n\n                        int nTries = 3;\n                        while (adjustKeyPresses(stateCore.keyPresses, stateCore.similarityMap) && --nTries) {\n                            calculateSimilartyMap(\n                                    stateUINew.params.keyPressWidth_samples,\n                                    stateUINew.params.alignWindow_samples,\n                                    stateUINew.params.offsetFromPeak_samples,\n                                    stateCore.keyPresses,\n                                    stateCore.similarityMap);\n                        }\n\n                        printf(\"[+] Similarity map recalculated\\n\");\n\n                        stateCore.flags.calculatingSimilarityMap = false;\n                        stateCore.flags.updateSimilarityMap = true;\n                        stateCore.update(true);\n                    }\n\n                    int n = stateCore.params.nProcessors();\n                    for (int i = 0; i < n; ++i) {\n                        const auto nClusters = stateCore.params.valueForProcessorClusters(i);\n                        const auto wEnglish = stateCore.params.wEnglish;\n                        const auto fSpread = stateCore.params.valueForProcessorFSpread(i);\n                        const auto nHypothesesToKeep = stateCore.params.nHypothesesToKeep;\n\n                        Cipher::TParameters params;\n                        params.maxClusters = nClusters;\n                        params.wEnglishFreq = wEnglish;\n                        params.fSpread = fSpread;\n                        params.nHypothesesToKeep = nHypothesesToKeep;\n                        stateCore.processors[i] = Cipher::Processor();\n                        stateCore.processors[i].init(\n                                params,\n                                *stateCore.freqMap[i%3],\n                                stateCore.similarityMap);\n\n                        printf(\"[+] Processor %d initialized: cluster = %d, wEnglish = %g, fSpread = %g, nHypothesesToKeep = %d\\n\",\n                                i, nClusters, wEnglish, fSpread, nHypothesesToKeep);\n                    }\n                }\n\n                if (stateUINew.flags.changeProcessing) {\n                    stateCore.processing = stateUINew.processing;\n                }\n\n                if (stateUINew.flags.applyParameters) {\n                    stateCore.params = stateUINew.params;\n\n                    int n = stateCore.params.nProcessors();\n                    for (int i = 0; i < n; ++i) {\n                        const auto nClusters = stateCore.params.valueForProcessorClusters(i);\n                        const auto wEnglish = stateCore.params.valueForProcessorFSpread(i);\n                        const auto fSpread = stateCore.params.valueForProcessorFSpread(i);\n                        const auto nHypothesesToKeep = stateCore.params.nHypothesesToKeep;\n\n                        Cipher::TParameters params;\n                        params.maxClusters = nClusters;\n                        params.wEnglishFreq = wEnglish;\n                        params.fSpread = fSpread;\n                        params.nHypothesesToKeep = nHypothesesToKeep;\n                        stateCore.processors[i].init(\n                                params,\n                                *stateCore.freqMap[i%3],\n                                stateCore.similarityMap);\n                    }\n                }\n\n                if (stateUINew.flags.applyHints) {\n                    stateCore.keyPresses = stateUINew.keyPresses;\n                }\n            }\n\n            if (stateCore.processing && stateCore.keyPresses.size() >= 3) {\n                {\n                    int n = stateCore.keyPresses.size();\n                    stateCore.params.cipher.hint.clear();\n                    stateCore.params.cipher.hint.resize(n, -1);\n                    for (int i = 0; i < n; ++i) {\n                        if (stateCore.keyPresses[i].bind < 0) continue;\n                        stateCore.params.cipher.hint[i] = stateCore.keyPresses[i].bind + 1;\n                    }\n                }\n\n#ifdef __EMSCRIPTEN__\n                static int iter = 0;\n                {\n                    int p = iter%stateCore.params.nProcessors();\n                    stateCore.processors[p].setHint(stateCore.params.cipher.hint);\n                    stateCore.processors[p].compute();\n\n                    stateCore.flags.updateResult[p] = true;\n                    stateCore.update();\n\n                    ++iter;\n                }\n#else\n                int nFinished = 0;\n                int nWorkers = std::min(stateCore.params.nProcessors(), (int) std::thread::hardware_concurrency()/2);\n\n                std::mutex mutex;\n                std::condition_variable cv;\n                std::vector<std::thread> workers(nWorkers);\n                for (int iw = 0; iw < (int) workers.size(); ++iw) {\n                    auto & worker = workers[iw];\n                    worker = std::thread([&](int ith) {\n                        int n = stateCore.params.nProcessors();\n                        for (int i = ith; i < n; i += nWorkers) {\n                            stateCore.processors[i].setHint(stateCore.params.cipher.hint);\n                            stateCore.processors[i].compute();\n\n                            stateCore.flags.updateResult[i] = true;\n                            stateCore.update();\n                        }\n                        {\n                            std::lock_guard<std::mutex> lock(mutex);\n                            ++nFinished;\n                            cv.notify_one();\n                        }\n                    }, iw);\n                    worker.detach();\n                }\n\n                std::unique_lock<std::mutex> lock(mutex);\n                cv.wait(lock, [&]() { return nFinished == nWorkers; });\n#endif\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(1));\n            }\n        }\n    });\n\n#ifdef __EMSCRIPTEN__\n    emscripten_set_main_loop_arg(mainUpdate, NULL, 0, true);\n#else\n    if (g_doInit() == false) {\n        printf(\"Error: failed to initialize audio playback\\n\");\n        return -2;\n    }\n\n    while (true) {\n        if (g_mainUpdate() == false) break;\n    }\n\n    workerCore.join();\n\n    printf(\"[+] Terminated\\n\");\n\n    Gui::free(guiObjects);\n#endif\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap3-multi.cpp",
          "type": "blob",
          "size": 6.4970703125,
          "content": "/*! \\file keytap3-multi.cpp\n *  \\brief Same as keytap3.cpp but using multi-samples\n *  \\author Georgi Gerganov\n */\n\n#include \"common.h\"\n#include \"constants.h\"\n#include \"subbreak3.h\"\n\n#include <chrono>\n#include <cstdio>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define MY_DEBUG\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\n\nint main(int argc, char ** argv) {\n    srand(time(0));\n\n    printf(\"Usage: %s record.kbd n-gram-dir [-FN] [-fN]\\n\", argv[0]);\n    printf(\"    -FN - select filter type, (0 - none, 1 - first order high-pass, 2 - second order high-pass)\\n\");\n    printf(\"    -fN - cutoff frequency in Hz\\n\");\n    if (argc < 3) {\n        return -1;\n    }\n\n    const int64_t sampleRate = kSampleRate;\n\n    const auto argm = parseCmdArguments(argc, argv);\n    const int filterId      = argm.count(\"F\") == EAudioFilter::FirstOrderHighPass ? 0 : std::stoi(argm.at(\"F\"));\n    const int freqCutoff_Hz = argm.count(\"f\") == kFreqCutoff_Hz ? 0 : std::stoi(argm.at(\"f\"));\n\n    TWaveformMI16 waveformInputMI16;\n    {\n        TWaveformF waveformInputF;\n        printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n        if (readFromFile<TSampleF>(argv[1], waveformInputF) == false) {\n            printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n            return -1;\n        } else {\n            for (int j = 0; j < TSampleMI16::N; ++j) {\n                TWaveformI16 waveformInputI16;\n\n                printf(\"[+] Filtering waveform with filter type = %d and cutoff frequency = %d Hz\\n\", filterId, freqCutoff_Hz + j*200);\n                auto filtered = waveformInputF;\n                ::filter(filtered, (EAudioFilter) (j%2 + filterId), freqCutoff_Hz + j*200, kSampleRate);\n\n                //{\n                //    auto tmp = filtered;\n                //    for (int i = j; i < (int) filtered.size() - j; ++i) {\n                //        float sum = 0.0f;\n                //        for (int w = -j; w <= j; ++w) {\n                //            sum += (tmp[i + w]);\n                //        }\n                //        filtered[i] = sum / (2 * j + 1);\n                //    }\n                //}\n\n                printf(\"[+] Converting waveform to i16 format ...\\n\");\n                if (convert(filtered, waveformInputI16) == false) {\n                    printf(\"Conversion failed\\n\");\n                    return -4;\n                }\n\n                waveformInputMI16.resize(waveformInputI16.size());\n                for (size_t i = 0; i < waveformInputI16.size(); ++i) {\n                    waveformInputMI16[i][j] = waveformInputI16[i];\n                }\n            }\n        }\n    }\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) waveformInputMI16.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*waveformInputMI16.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) waveformInputMI16.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(waveformInputMI16.size())/sampleRate);\n\n    TKeyPressCollectionMI16 keyPresses;\n    {\n        const auto tStart = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Searching for key presses\\n\");\n\n        TWaveformMI16 waveformMax;\n        TWaveformMI16 waveformThreshold;\n        if (findKeyPresses(getView(waveformInputMI16, 0), keyPresses, waveformThreshold, waveformMax, 8.0, 512, 2*1024, true) == false) {\n            printf(\"Failed to detect keypresses\\n\");\n            return -2;\n        }\n\n        const auto tEnd = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Detected a total of %d potential key presses\\n\", (int) keyPresses.size());\n        printf(\"[+] Search took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n    }\n\n    TSimilarityMap similarityMap;\n    {\n        const auto tStart = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Calculating CC similarity map\\n\");\n\n        if (calculateSimilartyMap(256, 32, 128, keyPresses, similarityMap) == false) {\n            printf(\"Failed to calculate similariy map\\n\");\n            return -3;\n        }\n\n        const auto tEnd = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Calculation took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n\n        {\n            const auto nPrint = std::min(16, (int) keyPresses.size());\n            for (int j = 0; j < nPrint; ++j) {\n                printf(\"%2d: \", j);\n                for (int i = 0; i < nPrint; ++i) {\n                    printf(\"%6.3f \", similarityMap[j][i].cc);\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    Cipher::TFreqMap freqMap6;\n    {\n        const auto tStart = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Loading n-grams from '%s'\\n\", argv[2]);\n\n        if (Cipher::loadFreqMapBinary((std::string(argv[2]) + \"/ggwords-6-gram.dat.binary\").c_str(), freqMap6) == false) {\n            return -5;\n        }\n\n        const auto tEnd = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Loading took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n    }\n\n    {\n        Cipher::Processor processor;\n\n        Cipher::TParameters params;\n        params.maxClusters = 40;\n        params.nIters = 1;\n        params.nInitialIters = 0;\n        params.wEnglishFreq = 10.0f;\n        processor.init(params, freqMap6, similarityMap);\n\n        double lastP = -1000.0;\n        int nNoImprovement = 0;\n\n        printf(\"[+] Attempting to recover the text from the recording ...\\n\");\n\n        while (true) {\n            processor.compute();\n\n            {\n                const auto & result = processor.getResult();\n                if (result.p < -100.0f) continue;\n\n                if (lastP < result.p) {\n                    lastP = result.p;\n                    nNoImprovement = 0;\n                    printf(\"%8.3f %8.3f \", result.p, result.pClusters);\n                    Cipher::printDecoded(result.clusters, result.clMap, {});\n                } else {\n                    nNoImprovement++;\n                }\n\n            }\n\n            if (nNoImprovement < 1000) {\n                continue;\n            }\n\n            //printf(\"[+] Restarting\\n\");\n\n            lastP = -1000.0;\n            nNoImprovement = 0;\n\n            params.maxClusters = 40 + rand()%50;\n            params.nInitialIters = 100 + rand()%5000;\n            params.wEnglishFreq = 2.0f + rand()%50;\n            processor.init(params, freqMap6, similarityMap);\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "keytap3.cpp",
          "type": "blob",
          "size": 8.3125,
          "content": "/*! \\file keytap3.cpp\n *  \\brief Fully automated acoustic keyboard eavesdropping\n *  \\author Georgi Gerganov\n */\n\n#include \"common.h\"\n#include \"constants.h\"\n#include \"subbreak3.h\"\n\n#include <chrono>\n#include <cstdio>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#include <mutex>\n#include <thread>\n\n#define MY_DEBUG\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TKeyPressData         = TKeyPressDataI16;\nusing TKeyPressCollection   = TKeyPressCollectionI16;\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s record.kbd n-gram-dir [-FN] [-fN]\\n\", argv[0]);\n    printf(\"    -FN - select filter type, (0 - none, 1 - first order high-pass, 2 - second order high-pass)\\n\");\n    printf(\"    -fN - cutoff frequency in Hz\\n\");\n    if (argc < 3) {\n        return -1;\n    }\n\n    const int64_t sampleRate = kSampleRate;\n\n    const auto argm = parseCmdArguments(argc, argv);\n    const int filterId      = argm.count(\"F\") == 0 ? EAudioFilter::FirstOrderHighPass : std::stoi(argm.at(\"F\"));\n\n    int freqCutoff_Hz = argm.count(\"f\") == 0 ? 0 : std::stoi(argm.at(\"f\"));\n\n    Cipher::TFreqMap freqMap6;\n    {\n        const auto tStart = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Loading n-grams from '%s'\\n\", argv[2]);\n\n        if (Cipher::loadFreqMapBinary((std::string(argv[2]) + \"/ggwords-6-gram.dat.binary\").c_str(), freqMap6) == false) {\n            return -5;\n        }\n\n        const auto tEnd = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Loading took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n    }\n\n    // Main algorithm\n\n    TWaveform waveformInput;\n    {\n        TWaveformF waveformInputF;\n        printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n        if (readFromFile<TSampleF>(argv[1], waveformInputF) == false) {\n            printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n            return -1;\n        } else {\n            if (freqCutoff_Hz == 0) {\n                const auto tStart = std::chrono::high_resolution_clock::now();\n\n                freqCutoff_Hz = Cipher::findBestCutoffFreq(waveformInputF, (EAudioFilter) filterId, kSampleRate, 100.0f, 1000.0f, 100.0f);\n\n                const auto tEnd = std::chrono::high_resolution_clock::now();\n                printf(\"[+] Found best freqCutoff = %d Hz, took %4.3f seconds\\n\", freqCutoff_Hz, toSeconds(tStart, tEnd));\n            }\n\n            printf(\"[+] Filtering waveform with filter type = %d and cutoff frequency = %d Hz\\n\", filterId, freqCutoff_Hz);\n            ::filter(waveformInputF, (EAudioFilter) filterId, freqCutoff_Hz, kSampleRate);\n\n            printf(\"[+] Converting waveform to i16 format ...\\n\");\n            if (convert(waveformInputF, waveformInput) == false) {\n                printf(\"Conversion failed\\n\");\n                return -4;\n            }\n        }\n    }\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) waveformInput.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*waveformInput.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) waveformInput.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(waveformInput.size())/sampleRate);\n\n    TKeyPressCollection keyPresses;\n    {\n        const auto tStart = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Searching for key presses\\n\");\n\n        TWaveform waveformMax;\n        TWaveform waveformThreshold;\n        if (findKeyPresses(getView(waveformInput, 0), keyPresses, waveformThreshold, waveformMax,\n                           kFindKeysThreshold, kFindKeysHistorySize, kFindKeysHistorySizeReset, kFindKeysRemoveLowPower) == false) {\n            printf(\"Failed to detect keypresses\\n\");\n            return -2;\n        }\n\n        const auto tEnd = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Detected a total of %d potential key presses\\n\", (int) keyPresses.size());\n        printf(\"[+] Search took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n    }\n\n    int n = keyPresses.size();\n\n    TSimilarityMap similarityMap;\n    {\n        const auto tStart = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Calculating CC similarity map\\n\");\n\n        if (calculateSimilartyMap(kKeyWidth_samples, kKeyAlign_samples, kKeyWidth_samples - kKeyOffset_samples, keyPresses, similarityMap) == false) {\n            printf(\"Failed to calculate similariy map\\n\");\n            return -3;\n        }\n\n        const auto tEnd = std::chrono::high_resolution_clock::now();\n\n        printf(\"[+] Calculation took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n\n        {\n            const auto tStart = std::chrono::high_resolution_clock::now();\n\n            printf(\"[+] Removing low-similarity keys\\n\");\n\n            const int n0 = keyPresses.size();\n\n            if (removeLowSimilarityKeys(keyPresses, similarityMap, 0.3f) == false) {\n                printf(\"Failed to remove low-similarity keys\\n\");\n                return -4;\n            }\n\n            const int n1 = keyPresses.size();\n\n            const auto tEnd = std::chrono::high_resolution_clock::now();\n\n            printf(\"[+] Removed %d low-similarity keys, took %4.3f seconds\\n\", n0 - n1, toSeconds(tStart, tEnd));\n        }\n\n        n = keyPresses.size();\n\n        const int ncc = std::min(32, n);\n        for (int j = 0; j < ncc; ++j) {\n            printf(\"%2d: \", j);\n            for (int i = 0; i < ncc; ++i) {\n                printf(\"%6.3f \", similarityMap[j][i].cc);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n\n        auto minCC = similarityMap[0][1].cc;\n        auto maxCC = similarityMap[0][1].cc;\n        for (int j = 0; j < n - 1; ++j) {\n            for (int i = j + 1; i < n; ++i) {\n                minCC = std::min(minCC, similarityMap[j][i].cc);\n                maxCC = std::max(maxCC, similarityMap[j][i].cc);\n            }\n        }\n\n        printf(\"[+] Similarity map: min = %g, max = %g\\n\", minCC, maxCC);\n    }\n\n    printf(\"[+] Attempting to recover the text from the recording ...\\n\");\n\n    for (int iMain = 0; iMain < 16; ++iMain) {\n        Cipher::Processor processor;\n\n        Cipher::TParameters params;\n        params.maxClusters = 30;\n        params.wEnglishFreq = 30.0;\n        params.fSpread = 0.5 + 0.1*iMain;\n        params.nHypothesesToKeep = std::max(100, 500 - 2*std::min(200, std::max(0, ((int) keyPresses.size() - 100))));\n        processor.init(params, freqMap6, similarityMap);\n\n        std::vector<Cipher::TResult> clusterings;\n\n        // clustering\n        {\n            const auto tStart = std::chrono::high_resolution_clock::now();\n\n            for (int nIter = 0; nIter < 16; ++nIter) {\n                auto clusteringsCur = processor.getClusterings(2);\n\n                for (int i = 0; i < (int) clusteringsCur.size(); ++i) {\n                    clusterings.push_back(std::move(clusteringsCur[i]));\n                }\n\n                params.maxClusters = 30 + 4*(nIter + 1);\n                processor.init(params, freqMap6, similarityMap);\n            }\n\n            const auto tEnd = std::chrono::high_resolution_clock::now();\n            printf(\"[+] Clustering took %4.3f seconds\\n\", toSeconds(tStart, tEnd));\n        }\n\n        params.hint.clear();\n        params.hint.resize(n, -1);\n\n        // beam search\n        int nThread = std::min((int) std::thread::hardware_concurrency(), (int) clusterings.size());\n        {\n            std::vector<std::thread> workers(nThread);\n\n            std::mutex mutexPrint;\n            for (int i = 0; i < nThread; ++i) {\n                workers[i] = std::thread([&, i]() {\n                    for (int j = i; j < (int) clusterings.size(); j += nThread) {\n                        Cipher::beamSearch(params, freqMap6, clusterings[j]);\n                        mutexPrint.lock();\n                        printf(\" \");\n                        Cipher::printDecoded(clusterings[j].clusters, clusterings[j].clMap, params.hint);\n                        printf(\" [%8.3f %8.3f]\\n\", clusterings[j].p, clusterings[j].pClusters);\n                        mutexPrint.unlock();\n                    }\n                });\n            }\n\n            for (auto& worker : workers) {\n                worker.join();\n            }\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "non-exact-subbreak.cpp",
          "type": "blob",
          "size": 2.37109375,
          "content": "/*! \\file non-exact-subbreak.cpp\n *  \\brief New attempt at breaking non-exact substitution cipher\n *  \\author Georgi Gerganov\n */\n\n#include \"subbreak2.h\"\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s n-gram.txt\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    srand(time(0));\n\n    Cipher::TParameters params;\n\n    Cipher::TFreqMap freqMap;\n    if (Cipher::loadFreqMap(argv[1], freqMap) == false) {\n        return -1;\n    }\n\n    std::string plain;\n\n    plain = R\"(\nAs far as services go, only two steady contributors of revenue\nstreams keep swelling without Apple having to charge\nsubscription fees. One is the money paid by Google parent Alphabet\nfor searches made through Apple products such as the Safari browser and Siri.\n    )\";\n\n    plain = R\"(as far as services go only two stead8y contributo23rs of revenue\nstreams ke1ep swelling witho7ut Apple having to charge\nsubscription fees one is the4 money paid by google parent Alph-abet\nfor sear3ches made through apple prod6u4cts such as the Safa=ri browser a0nd Siri)\";\n\n    plain = R\"(and shipping at Formosa and Luzon, the Third Fleet entered the South China Sea and aircraft from its carriers attacked Japanese shipping off)\";\n\n    plain = R\"(resolutions and the protection of people's rights\" and was rejected by 85% of voters.[1] The third was on a popular initiative on the)\";\n\n    plain = R\"(The length of the forewings is about 8.7 mm. The ground colour of the forewings is whitish, strigulated (finely streaked) and suffused with pale orange)\";\n\n    //plain = R\"(\n    //As far as services go, only two steady contributors of revenue\n    //streams keep swelling without Apple having to charge\n    //subscription fees. One is the money paid by Google parent Alphabet\n    //for searches made through Apple products such as the Safari browser and Siri\n    //)\";\n\n    //std::string x;\n    //for (int i = 0; i < (int) plain.size(); ++i) {\n    //    while (rand()%1000 < 250) {\n    //        x += rand()%10 + '1';\n    //    }\n    //    x += plain[i];\n    //}\n\n    //printf(\"x = '%s'\\n\", x.c_str());\n    //plain = x;\n\n    TClusters enc;\n    Cipher::encryptExact(params, plain, enc);\n\n    params.maxClusters = 27;\n    for (auto & c : enc) {\n        params.maxClusters = std::max(params.maxClusters, c + 1);\n    }\n\n    Cipher::TResult result;\n    Cipher::subbreak(params, freqMap, result);\n\n    Cipher::printText(enc, result.clMap);\n\n    return 0;\n}\n"
        },
        {
          "name": "non-exact-subbreak2.cpp",
          "type": "blob",
          "size": 1.06640625,
          "content": "/*! \\file non-exact-subbreak2.cpp\n *  \\brief New attempt at breaking non-exact substitution cipher\n *  \\author Georgi Gerganov\n */\n\n#include \"subbreak2.h\"\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s n-gram.txt\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    srand(time(0));\n\n    Cipher::TParameters params;\n\n    Cipher::TFreqMap freqMap;\n    if (Cipher::loadFreqMap(argv[1], freqMap) == false) {\n        return -1;\n    }\n\n    std::string plain;\n\n    plain = R\"(\nAs far as services go, only two steady contributors of revenue\nstreams keep swelling without Apple having to charge\nsubscription fees. One is the money paid by Google parent Alphabet\nfor searches made through Apple products such as the Safari browser and Siri.\n    )\";\n\n    TClusters enc;\n    Cipher::encryptExact(params, plain, enc);\n\n    params.maxClusters = 27;\n    for (auto & c : enc) {\n        params.maxClusters = std::max(params.maxClusters, c + 1);\n    }\n\n    Cipher::TResult result;\n    Cipher::subbreak(params, freqMap, result);\n\n    Cipher::printText(enc, result.clMap);\n\n    return 0;\n}\n"
        },
        {
          "name": "play-full.cpp",
          "type": "blob",
          "size": 2.720703125,
          "content": "/*! \\file play-full.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n\n#include <SDL.h>\n#include <SDL_audio.h>\n\n#include <fstream>\n\nbool g_terminate = false;\n\nvoid cbPlayback(void * userdata, uint8_t * stream, int len) {\n    std::ifstream * fin = (std::ifstream *)(userdata);\n    if (fin->eof()) {\n        g_terminate = true;\n        return;\n    }\n    fflush(stdout);\n    fin->read((char *)(stream), len); // todo\n    if (fin->eof()) g_terminate = true;\n}\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s input.kbd [-pN]\\n\", argv[0]);\n    printf(\"    -pN - select playback device N\\n\");\n    printf(\"\\n\");\n\n    if (argc < 2) {\n        return -127;\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int playbackId = argm[\"p\"].empty() ? 0 : std::stoi(argm[\"p\"]);\n\n    std::ifstream fin(argv[1], std::ios::binary);\n    if (fin.good() == false) {\n        fprintf(stderr, \"Failed to open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n\n    if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_FALSE);\n    printf(\"Found %d playback devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Playback device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_FALSE));\n    }\n\n    SDL_AudioSpec playbackSpec;\n    SDL_zero(playbackSpec);\n\n    playbackSpec.freq = kSampleRate;\n    playbackSpec.format = AUDIO_F32SYS;\n    playbackSpec.channels = 1;\n    playbackSpec.samples = kSamplesPerFrame;\n    playbackSpec.callback = cbPlayback;\n    playbackSpec.userdata = (void *)(&fin);\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    printf(\"Attempt to open playback device %d : '%s' ...\\n\", playbackId, SDL_GetAudioDeviceName(playbackId, SDL_FALSE));\n    auto deviceIdOut = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(playbackId, SDL_FALSE), SDL_FALSE, &playbackSpec, &obtainedSpec, SDL_AUDIO_ALLOW_CHANNELS_CHANGE);\n    if (!deviceIdOut) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for playback: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return -2;\n    }\n\n    int sampleSize_bytes = 4; // todo\n\n    printf(\"Opened playback device succesfully!\\n\");\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d (%d bytes)\\n\", obtainedSpec.format, sampleSize_bytes);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    SDL_PauseAudioDevice(deviceIdOut, 0);\n\n    while (g_terminate == false) {\n        SDL_Delay(100);\n    }\n\n    fin.close();\n\n    SDL_CloseAudio();\n\n    return 0;\n}\n"
        },
        {
          "name": "play.cpp",
          "type": "blob",
          "size": 3.12109375,
          "content": "/*! \\file play.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n\n#include <SDL.h>\n#include <SDL_audio.h>\n\n#include <fstream>\n\nbool g_terminate = false;\n\nvoid cbPlayback(void * userdata, uint8_t * stream, int len) {\n    std::ifstream * fin = (std::ifstream *)(userdata);\n    int keyPressed = -1;\n    fin->read((char *)(&keyPressed), sizeof(keyPressed));\n    if (fin->eof()) {\n        g_terminate = true;\n        return;\n    }\n    printf(\"%c\", keyPressed);\n    fflush(stdout);\n    fin->read((char *)(stream), len); // todo\n    if (fin->eof()) g_terminate = true;\n}\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s input.kbd [-pN]\\n\", argv[0]);\n    printf(\"    -pN - select playback device N\\n\");\n    printf(\"\\n\");\n\n    if (argc < 2) {\n        return -127;\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int playbackId = argm[\"p\"].empty() ? 0 : std::stoi(argm[\"p\"]);\n\n    std::ifstream fin(argv[1], std::ios::binary);\n    if (fin.good() == false) {\n        fprintf(stderr, \"Failed to open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n\n    int bufferSize_frames = 1;\n    fin.read((char *)(&bufferSize_frames), sizeof(bufferSize_frames));\n    printf(\"Buffer size = %d frames\\n\", bufferSize_frames);\n\n    if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_FALSE);\n    printf(\"Found %d playback devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Playback device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_FALSE));\n    }\n\n    if (playbackId < 0 || playbackId >= nDevices) {\n        printf(\"Invalid playback device id selected - %d\\n\", playbackId);\n        return -1;\n    }\n\n    SDL_AudioSpec playbackSpec;\n    SDL_zero(playbackSpec);\n\n    playbackSpec.freq = kSampleRate;\n    playbackSpec.format = AUDIO_F32SYS;\n    playbackSpec.channels = 1;\n    playbackSpec.samples = bufferSize_frames*kSamplesPerFrame;\n    playbackSpec.callback = cbPlayback;\n    playbackSpec.userdata = (void *)(&fin);\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    printf(\"Attempt to open playback device %d : '%s' ...\\n\", playbackId, SDL_GetAudioDeviceName(playbackId, SDL_FALSE));\n    auto deviceIdOut = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(playbackId, SDL_FALSE), SDL_FALSE, &playbackSpec, &obtainedSpec, 0);\n    if (!deviceIdOut) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for playback: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return -2;\n    }\n\n    int sampleSize_bytes = 4; // todo\n\n    printf(\"Opened playback device succesfully!\\n\");\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d (%d bytes)\\n\", obtainedSpec.format, sampleSize_bytes);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    SDL_PauseAudioDevice(deviceIdOut, 0);\n\n    while(g_terminate == false) {\n        SDL_Delay(100);\n    }\n\n    fin.close();\n\n    SDL_CloseAudio();\n\n    return 0;\n}\n"
        },
        {
          "name": "record-full.cpp",
          "type": "blob",
          "size": 1.9921875,
          "content": "/*! \\file record-full.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"audio-logger.h\"\n\n#include <fstream>\n#include <chrono>\n#include <thread>\n\nbool g_terminate = false;\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s output.kbd [-cN]\\n\", argv[0]);\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - number N of capture channels N\\n\");\n    printf(\"\\n\");\n\n    if (argc < 2) {\n        return -127;\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int captureId = argm[\"c\"].empty() ? 0 : std::stoi(argm[\"c\"]);\n    int nChannels = argm[\"C\"].empty() ? 0 : std::stoi(argm[\"C\"]);\n\n    bool doRecord = true;\n    size_t totalSize_bytes = 0;\n\n    std::ofstream fout(argv[1], std::ios::binary);\n    if (fout.good() == false) {\n        fprintf(stderr, \"Failed to open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n\n    AudioLogger audioLogger;\n    AudioLogger::Callback cbAudio = [&](const auto & frames) {\n        doRecord = true;\n\n        for (const auto & frame : frames) {\n            totalSize_bytes += sizeof(frame[0])*frame.size();\n            fout.write((char *)(frame.data()), sizeof(frame[0])*frame.size());\n            fout.flush();\n        }\n\n        printf(\"Total data saved: %g MB\\n\", ((float)(totalSize_bytes)/1024.0f/1024.0f));\n    };\n\n    AudioLogger::Parameters parameters;\n    parameters.callback = std::move(cbAudio);\n    parameters.captureId = captureId;\n    parameters.nChannels = nChannels;\n    parameters.sampleRate = kSampleRate;\n    parameters.filter = EAudioFilter::None;\n    parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n    if (audioLogger.install(std::move(parameters)) == false) {\n        fprintf(stderr, \"Failed to install audio logger\\n\");\n        return -1;\n    }\n\n    while (true) {\n        if (doRecord) {\n            doRecord = false;\n            audioLogger.record(0.5f, 0);\n        } else {\n            std::this_thread::sleep_for(std::chrono::milliseconds(1));\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "record.cpp",
          "type": "blob",
          "size": 3.3212890625,
          "content": "/*! \\file record.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"constants.h\"\n#include \"common.h\"\n#include \"audio-logger.h\"\n\n#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include <map>\n#include <cstdio>\n#include <chrono>\n#include <thread>\n#include <deque>\n#include <fstream>\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s output.kbd [-cN]\\n\", argv[0]);\n    printf(\"    -cN - select capture device N\\n\");\n    printf(\"    -CN - number N of capture channels N\\n\");\n    printf(\"\\n\");\n\n    if (argc < 2) {\n        return -127;\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int captureId = argm[\"c\"].empty() ? 0 : std::stoi(argm[\"c\"]);\n    int nChannels = argm[\"C\"].empty() ? 0 : std::stoi(argm[\"C\"]);\n\n    auto tStart = std::chrono::high_resolution_clock::now();\n    auto tEnd = std::chrono::high_resolution_clock::now();\n\n    size_t totalSize_bytes = 0;\n    std::deque<int> keyPressedQueue;\n    std::map<int, int> nTimes;\n    printf(\"Recording %d frames per key press\\n\", kBufferSizeTrain_frames);\n\n    std::ofstream fout(argv[1], std::ios::binary);\n    fout.write((char *)(&kBufferSizeTrain_frames), sizeof(kBufferSizeTrain_frames));\n\n    AudioLogger audioLogger;\n    AudioLogger::Callback cbAudio = [&](const auto & frames) {\n        tEnd = std::chrono::high_resolution_clock::now();\n\n        int keyPressed = keyPressedQueue.front();\n        keyPressedQueue.pop_front();\n\n        fout.write((char *)(&keyPressed), sizeof(keyPressed));\n        for (const auto & frame : frames) {\n            totalSize_bytes += sizeof(frame[0])*frame.size();\n            fout.write((char *)(frame.data()), sizeof(frame[0])*frame.size());\n            fout.flush();\n        }\n        ++nTimes[keyPressed];\n\n        printf(\"Last recorded key - %3d '%s'. Total times recorded so far - %3d. Total data saved: %g MB\\n\",\n               keyPressed, kKeyText.at(keyPressed), nTimes[keyPressed], ((float)(totalSize_bytes)/1024.0f/1024.0f));\n\n        keyPressed = -1;\n    };\n\n    AudioLogger::Parameters parameters;\n    parameters.callback = std::move(cbAudio);\n    parameters.captureId = captureId;\n    parameters.nChannels = nChannels;\n    parameters.sampleRate = kSampleRate;\n    parameters.freqCutoff_Hz = kFreqCutoff_Hz;\n\n    if (audioLogger.install(std::move(parameters)) == false) {\n        fprintf(stderr, \"Failed to install audio logger\\n\");\n        return -1;\n    }\n\n    printf(\"\\n\");\n    printf(\"To stop capturing press Ctrl+C\\n\");\n    printf(\"On some systems (e.g. MacOS), this may not work. In this case, you have to kill the process manually\\n\");\n    printf(\"\\n\");\n\n    std::thread keyReader = std::thread([&]() {\n        struct termios oldt, newt;\n        tcgetattr ( STDIN_FILENO, &oldt );\n        newt = oldt;\n        newt.c_lflag &= ~( ICANON | ECHO );\n        tcsetattr ( STDIN_FILENO, TCSANOW, &newt );\n        while (true) {\n            int key = getchar();\n            tStart = std::chrono::high_resolution_clock::now();\n            keyPressedQueue.push_back(key);\n            if (audioLogger.record(kBufferSizeTrain_s, 2) == false) {\n                fprintf(stderr, \"error : failed to record\\n\");\n            }\n        }\n        tcsetattr ( STDIN_FILENO, TCSANOW, &oldt );\n    });\n\n    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    keyReader.join();\n\n    fout.close();\n\n    return 0;\n}\n"
        },
        {
          "name": "scale.cpp",
          "type": "blob",
          "size": 1.62109375,
          "content": "/*! \\file scale.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include <fstream>\n#include <cstdlib>\n#include <vector>\n\nbool g_terminate = false;\n\nint main(int argc, char ** argv) {\n    if (argc < 5) {\n        fprintf(stderr, \"Usage: %s input.kbd output.kbd nf0 nf1\\n\", argv[0]);\n        return -127;\n    }\n\n    int nf0 = atoi(argv[3]);\n    int nf1 = atoi(argv[4]);\n\n    if (nf0%2 == 0) {\n        printf(\"nf0 must be odd\\n\");\n        return -1;\n    }\n\n    if (nf1%2 == 0) {\n        printf(\"nf1 must be odd\\n\");\n        return -1;\n    }\n\n    std::ifstream fin(argv[1], std::ios::binary);\n    std::ofstream fout(argv[2], std::ios::binary);\n\n    int bufferSize_frames = 1;\n    fin.read((char *)(&bufferSize_frames), sizeof(bufferSize_frames));\n\n    if (bufferSize_frames != nf0) {\n        printf(\"Invalid number nf0 = %d.  Expected %d for this file\\n\", nf0, bufferSize_frames);\n        return -1;\n    }\n\n    fout.write((char *)(&nf1), sizeof(nf1));\n\n    int nadd = (nf1 - nf0)/2;\n    printf(\"nadd = %d\\n\", nadd);\n\n    while (true) {\n        int key = -1;\n        fin.read((char *)(&key), sizeof(key));\n        if (fin.eof()) break;\n        fout.write((char *)(&key), sizeof(key));\n\n        std::vector<char> f0(4*1024);\n        std::fill(f0.begin(), f0.end(), 0);\n        std::vector<char> buf(nf0*4*1024);\n        fin.read((char *)(buf.data()), buf.size());\n        for (int i = 0; i < nadd; ++i) fout.write((char *)(f0.data()), f0.size());\n        fout.write((char *)(buf.data()), buf.size());\n        for (int i = 0; i < nadd; ++i) fout.write((char *)(f0.data()), f0.size());\n    }\n\n    fin.close();\n    fout.close();\n\n    return 0;\n}\n"
        },
        {
          "name": "style.css",
          "type": "blob",
          "size": 1.4638671875,
          "content": "html {\n    margin: 0px;\n    height: 100%;\n}\nbody {\n    margin: 0px;\n    height: 100%;\n    color: rgba(255, 255, 255, 1.00);\n    background-color: black;\n    -webkit-font-smoothing: subpixel-antialiased;\n    font-smoothing: subpixel-antialiased;\n}\n#main-controls {\n    margin: 0;\n    padding: 0;\n    height: 95%;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n}\n#description {\n    margin: 10px;\n    padding: 10px;\n}\n.text-body {\n    color: rgba(255, 255, 255, 1.00);\n}\n.cell-version {\n    padding-left: 4px;\n    padding-top: 0.5em;\n    text-align: left;\n    display: inline-block;\n    float: left;\n    color: rgba(255, 255, 255, 0.75);\n}\n.cell-about {\n    padding-right: 24px;\n    padding-top: 0.5em;\n    text-align: right;\n    display: inline-block;\n    float: right;\n}\n.nav-link {\n    text-decoration: none;\n    color: rgba(255, 255, 255, 1.0);\n}\n.nav-link2 {\n    text-decoration: none;\n    color: rgba(0, 255, 0, 1.0);\n}\nsvg {\n    -webkit-filter: invert(100%); /* safari 6.0 - 9.0 */\n    filter: invert(100%);\n}\n#output {\n\twidth: 100%;\n\theight: 100%;\n\tmargin: 0 auto;\n\tmargin-top: 10px;\n\tborder-left: 0px;\n\tborder-right: 0px;\n\tpadding-left: 0px;\n\tpadding-right: 0px;\n\tdisplay: block;\n\tbackground-color: black;\n\tcolor: white;\n\tfont-size:10px;\n\tfont-family: 'Lucida Console', Monaco, monospace;\n\toutline: none;\n    white-space: pre;\n    overflow-wrap: normal;\n    overflow-x: scroll;\n}\n"
        },
        {
          "name": "subbreak.cpp",
          "type": "blob",
          "size": 1.6015625,
          "content": "/*! \\file subbreak.cpp\n *  \\brief Substitution cipher breaker\n *  \\author Georgi Gerganov\n */\n\n#include \"subbreak.h\"\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s n-gram.txt\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    srand(time(0));\n\n    TFreqMap freqMap;\n    if (loadFreqMap(argv[1], freqMap) == false) {\n        return -1;\n    }\n\n    printf(\"[+] Score of 'XZZS'        = %g\\n\", calcScore(freqMap, \"XZZS\"));\n    printf(\"[+] Score of 'HELLO WORLD' = %g\\n\", calcScore(freqMap, \"HELLO WORLD\"));\n\n    TAlphabet alphabet;\n    std::string plain = R\"(\nAs far as services go, only two steady contributors of revenue\nstreams keep swelling without Apple having to charge\nsubscription fees. One is the money paid by Google parent Alphabet\nfor searches made through Apple products such as the Safari browser and Siri.\n    )\";\n\n    std::string enc;\n    encrypt(plain, alphabet, enc);\n\n    printf(\"[+] Alphabet: 'abcdefghijklmnopqrstuvwxyz'\\n\");\n    printf(\"[+] Alphabet: '\");\n    for (int i = 'a'; i <= 'z'; ++i) {\n        auto c = ::myCharToInt[i];\n        printf(\"%c\", i - c + alphabet[c]);\n    }\n    printf(\"'\\n\");\n\n    printf(\"[+] Plain:    '%s'\\n\", plain.c_str());\n    {\n        TAlphabet sola = alphabet;\n        for (int i = 0; i <= kN; ++i) {\n            sola[alphabet[i]] = i;\n        }\n        std::string solt = enc;\n        translate(sola, enc, solt);\n        printf(\"[+] Sol: \");\n        printText(solt);\n        printf(\"[+] Score = %g\\n\", calcScore(freqMap, solt));\n    }\n    printf(\"[+] Enc:      \");\n    printText(enc);\n\n    std::string decrypted;\n    decrypt(freqMap, enc, decrypted);\n\n    return 0;\n}\n"
        },
        {
          "name": "subbreak.h",
          "type": "blob",
          "size": 12.55078125,
          "content": "/*! \\file subbreak.h\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#pragma once\n\n#include \"constants.h\"\n\n#include <cmath>\n#include <cstdio>\n#include <fstream>\n#include <map>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing TCode = int32_t;\nusing TProb = double;\nusing TGramLen = int;\nusing TFreqMap = std::tuple<TGramLen, std::vector<TProb>>;\nusing TAlphabet = std::vector<char>;\n\nint kN = 27;\ndouble pMin = -100;\nstd::array<int32_t, 256> myCharToInt = ::kCharToInt;\n\nTCode calcCode(const char * data, int n) {\n    TCode res = 0;\n    do { res <<= 5; res += myCharToInt[*data++]; } while (--n > 0);\n    return res;\n}\n\ntemplate <typename T>\nvoid shuffle(T & t, int start = -1, int end = -1, const std::vector<int> & hint = {}) {\n    if (start == -1) start = 0;\n    if (end == -1) end = t.size();\n\n    for (int i = end - 1; i > start; --i) {\n        int i0 = i;\n        int i1 = rand()%(i - start + 1)+start;\n        if (hint.size() > 0 && (hint[i0] != -1 || hint[i1] != -1)) {\n            continue;\n        }\n        std::swap(t[i0], t[i1]);\n    }\n}\n\nbool loadFreqMap(const char * fname, TFreqMap & res) {\n    // auto & [len, fmap] = res;\n    auto & len  = std::get<0>(res);\n    auto & fmap = std::get<1>(res);\n\n    len = 0;\n    fmap.clear();\n\n    printf(\"[+] Loading n-gram file '%s'\\n\", fname);\n    std::ifstream fin(fname);\n\n    if (fin.good() == false) {\n        printf(\"    Failed to open file\\n\");\n        return false;\n    }\n\n    std::string gram;\n    int32_t nfreq = 0;\n    int64_t nTotal = 0;\n\n    while (true) {\n        fin >> gram >> nfreq;\n        if (fin.eof()) break;\n\n        nTotal += nfreq;\n    }\n\n    fin.clear();\n    fin.seekg(0);\n\n    while (true) {\n        fin >> gram >> nfreq;\n        if (fin.eof()) break;\n\n        if (len == 0) {\n            len = gram.size();\n            fmap.resize(1 << (5*len), 1.0);\n        } else if (len != (int) gram.size()) {\n            printf(\"Error: loaded n-grams with vaying lengths\\n\");\n            return false;\n        }\n\n        TCode idx = ::calcCode(gram.data(), len);\n        if (fmap[idx] < 0.5) {\n            printf(\"Error: duplicate n-gram '%s'\\n\", gram.c_str());\n            return false;\n        }\n        fmap[idx] = std::log10(((double)(nfreq))/nTotal);\n    }\n    printf(\"    Total n-grams loaded = %g\\n\", (double) nTotal);\n\n    //pMin = std::log(1000.0/nTotal);\n    pMin = std::log(100.01/nTotal);\n    printf(\"    P-min = %g\\n\", pMin);\n    for (auto & p : fmap) {\n        if (p >= 0.5) p = pMin;\n    }\n\n    return true;\n}\n\nTAlphabet getAlphabetRandom(const std::vector<int> & hint = {}) {\n    TAlphabet res;\n\n    if (hint.size() == 0) {\n        for (int i = 0; i <= kN; ++i) res.push_back(i);\n    } else {\n        std::map<int, bool> used;\n        for (auto & h : hint) if (h >= 1 && h <= 27) used[h] = true;\n        res.push_back(0);\n        int curi = 1;\n        for (int i = 1; i <= kN; ++i) {\n            if (hint[i] < 1 || hint[i] > 27) {\n                while (used[curi]) ++curi;\n                res.push_back(curi);\n                ++curi;\n            } else {\n                res.push_back(hint[i]);\n            }\n        }\n    }\n\n    shuffle(res, 1, -1, hint);\n\n    return res;\n}\n\nbool encrypt(const std::string & plain, TAlphabet & alphabet, std::string & enc) {\n    myCharToInt = kCharToInt;\n    {\n        int k = 26;\n        for (auto & p : plain) {\n            if (k == kN) break;\n            if (myCharToInt[p] == 0) {\n                myCharToInt[p] = ++k;\n            }\n        }\n        kN = k;\n        printf(\"[+] Unique symbols = %d\\n\", k);\n    }\n\n    alphabet = getAlphabetRandom();\n\n    enc = plain;\n    int n = plain.length();\n    for (int i = 0; i < n; ++i) {\n        auto c = ::myCharToInt[plain[i]];\n        enc[i] = alphabet[c];\n    }\n\n    return true;\n}\n\nbool translate(const TAlphabet & alphabet, const std::string & src, std::string & dst) {\n    if (dst.size() != src.size()) return false;\n\n    for (int i = 0; i < (int) src.size(); ++i) {\n        auto c = src[i];\n        dst[i] = (c > 0 && c <= kN) ? alphabet[c] : '.';\n    }\n\n    return true;\n}\n\nTProb calcScore0(const TFreqMap & freqMap, const std::string & txt) {\n    TProb res = 0.0;\n\n    int len = txt.size();\n    //const auto & [n, fmap] = freqMap;\n    const auto & n    = std::get<0>(freqMap);\n    const auto & fmap = std::get<1>(freqMap);\n\n    int i1 = 0;\n    int cnt = 0;\n\n    int k = n;\n    TCode curc = 0;\n\n    while (k > 0) {\n        if (i1 >= len) {\n            return -1e100;\n        }\n        auto c = txt[i1++];\n        if (c > 0 && c <= 26) {\n            curc <<= 5;\n            curc += c;\n            --k;\n        } else {\n            res += pMin;\n        }\n    }\n\n    TCode mask = (1 << 5*(n-1)) - 1;\n\n    res += fmap[curc];\n    ++cnt;\n    while (true) {\n        curc &= mask;\n\n        while (true) {\n            if (i1 >= len) goto finish;\n            auto c = txt[i1++];\n            if (c > 0 && c <= 26) {\n                curc <<= 5;\n                curc += c;\n                break;\n            } else {\n                res += pMin;\n            }\n        }\n\n        res += fmap[curc];\n        ++cnt;\n    }\n\nfinish:\n    return cnt > 0.3*len ? res/cnt : -1e100;\n    //return res/len;\n}\n\nTProb calcScore1(const TFreqMap & freqMap, const std::string & txt) {\n    TProb res = 0.0;\n\n    int len = txt.size();\n    //const auto & [n, fmap] = freqMap;\n    const auto & n    = std::get<0>(freqMap);\n    const auto & fmap = std::get<1>(freqMap);\n\n    int i1 = 0;\n\n    int k = n;\n    TCode curc = 0;\n    while (k > 0) {\n        if (i1 >= len) return -1e100;\n        auto c = txt[i1++];\n        curc <<= 5;\n        curc += c;\n        --k;\n    }\n\n    TCode mask = (1 << 5*(n-1)) - 1;\n\n    res += fmap[curc];\n    while (true) {\n        curc &= mask;\n\n        if (i1 >= len) return res;\n        auto c = txt[i1++];\n        curc <<= 5;\n        curc += c;\n\n        res += fmap[curc];\n    }\n\n    return res;\n}\n\nTProb calcScoreForSpaces(const TFreqMap & freqMap, const std::string & txt) {\n    TProb res = 0.0;\n\n    int len = txt.size();\n    //const auto & [n, fmap] = freqMap;\n    const auto & n    = std::get<0>(freqMap);\n    const auto & fmap = std::get<1>(freqMap);\n\n    int i1 = 0;\n    int cnt = 0;\n\n    int k = n;\n    TCode curc = 0;\n    TCode mask = (1 << 5*n) - 1;\n\n    while (k > 0) {\n        if (i1 >= len) {\n            return -1e100;\n        }\n        auto c = txt[i1++];\n        if (c > 0 && c <= 26) {\n            curc <<= 5;\n            curc += c;\n            curc &= mask;\n            --k;\n        } else {\n            k = n;\n            res += pMin;\n        }\n    }\n\n    res += fmap[curc];\n    ++cnt;\n    while (true) {\n        while (true) {\n            if (i1 >= len) goto finish;\n            auto c = txt[i1++];\n            if (c > 0 && c <= 26) {\n                curc <<= 5;\n                curc += c;\n                curc &= mask;\n                if (k == 0) break;\n                if (--k == 0) break;\n            } else {\n                k = n;\n                res += pMin;\n            }\n        }\n\n        res += fmap[curc];\n        ++cnt;\n    }\n\nfinish:\n    //return cnt > 0.3*len ? res/cnt : -1e100;\n    return res/len;\n}\n\nauto calcScore = calcScore0;\n\nvoid printText(const std::string & t) {\n    for (auto & c : t) {\n        if (c >= 1 && c <= 26) printf(\"%c\", 'a' + c - 1); else printf(\".\");\n    }\n    printf(\"\\n\");\n}\n\nvoid printText(const std::string & t, std::string & res) {\n    res = t;\n    int i = 0;\n    for (auto & c : t) {\n        if (c >= 1 && c <= 26) res[i] = 'a' + c - 1; else res[i] = ' ';\n        ++i;\n    }\n}\n\nbool decrypt(const TFreqMap & freqMap, const std::string & enc, std::string & res, int nMainIters = 1e9, const std::vector<int> & hint = {}) {\n    TAlphabet besta = getAlphabetRandom(hint);\n\n    auto lena = kN;\n\n    auto cure = enc;\n    auto beste = enc;\n    translate(besta, enc, cure);\n    auto bestp = calcScore(freqMap, cure);\n    printf(\"Initial prob: %g\\n\", bestp);\n\n    auto bestbestp = bestp;\n\n    int nIters = 0;\n    while (nMainIters--) {\n        if (++nIters > 10000) {\n            besta = getAlphabetRandom(hint);\n            translate(besta, enc, cure);\n            bestp = calcScore(freqMap, cure);\n            printf(\"reset\\n\");\n            nIters = 0;\n        }\n\n        auto itera = besta;\n\t\tint nswaps = kN > 26 ? 3 : 0;\n        for (int i = 0; i < nswaps; ++i) {\n            int a0 = rand()%lena + 1;\n            int a1 = rand()%lena + 1;\n            while (a0 == a1 || a0 > 26 || a1 <= 26) {\n                a0 = rand()%lena + 1;\n                a1 = rand()%lena + 1;\n            }\n\n            if (hint.size() > 0 && (hint[a0] != -1 || hint[a1] != -1)) {\n            } else {\n                std::swap(itera[a0], itera[a1]);\n            }\n        }\n\n        translate(itera, enc, cure);\n        auto iterp = calcScore(freqMap, cure);\n        auto cura = itera;\n        for (int i = 0; i < 100; ++i) {\n            int a0 = rand()%26 + 1;\n            int a1 = rand()%26 + 1;\n            while (a0 == a1) {\n                a0 = rand()%26 + 1;\n                a1 = rand()%26 + 1;\n            }\n\n            if (hint.size() > 0 && (hint[a0] != -1 || hint[a1] != -1)) {\n                continue;\n            }\n\n            std::swap(cura[a0], cura[a1]);\n\n            translate(cura, enc, cure);\n            auto curp = calcScore(freqMap, cure);\n            if (curp > iterp) {\n                iterp = curp;\n                itera = cura;\n                i = 0;\n            } else {\n                std::swap(cura[a0], cura[a1]);\n            }\n        }\n\n        if (iterp > bestp) {\n            besta = itera;\n            bestp = iterp;\n\n            if (bestp > bestbestp) {\n                bestbestp = bestp;\n                translate(besta, enc, beste);\n                printf(\"[+] Best score = %g\\n\", bestp);\n                printf(\"    Alphabet:  '\");\n                for (int i = 'a'; i <= 'z'; ++i) {\n                    auto c = ::myCharToInt[i];\n                    printf(\"%c\", i - c + besta[c]);\n                }\n                printf(\"'\\n\");\n                printText(beste);\n                printf(\"\\n\");\n            }\n            nIters = 0;\n        }\n    }\n\n    printText(beste, res);\n\n    return true;\n}\n\nbool guessSpaces(const TFreqMap & freqMap, const std::string & enc, std::string & res, int nMainIters = 1e9, const std::vector<int> & hint = {}) {\n    TAlphabet besta = getAlphabetRandom(hint);\n\n    auto lena = kN;\n\n    auto cure = enc;\n    auto beste = enc;\n    translate(besta, enc, cure);\n    auto bestp = calcScoreForSpaces(freqMap, cure);\n    printf(\"Initial prob: %g\\n\", bestp);\n\n    auto bestbestp = bestp;\n\n    int nIters = 0;\n    while (nMainIters--) {\n        if (++nIters > 10000) {\n            besta = getAlphabetRandom(hint);\n            translate(besta, enc, cure);\n            bestp = calcScoreForSpaces(freqMap, cure);\n            printf(\"reset\\n\");\n            nIters = 0;\n        }\n\n        auto itera = besta;\n\t\tint nswaps = kN > 26 ? 3 : 0;\n        for (int i = 0; i < nswaps; ++i) {\n            int a0 = rand()%lena + 1;\n            int a1 = rand()%lena + 1;\n            while (a0 == a1 || a0 > 26 || a1 <= 26) {\n                a0 = rand()%lena + 1;\n                a1 = rand()%lena + 1;\n            }\n\n            if (hint.size() > 0 && (hint[a0] != -1 || hint[a1] != -1)) {\n            } else {\n                std::swap(itera[a0], itera[a1]);\n            }\n        }\n\n        translate(itera, enc, cure);\n        auto iterp = calcScoreForSpaces(freqMap, cure);\n        auto cura = itera;\n        for (int i = 0; i < 100; ++i) {\n            int a0 = rand()%26 + 1;\n            int a1 = rand()%26 + 1;\n            while (a0 == a1) {\n                a0 = rand()%26 + 1;\n                a1 = rand()%26 + 1;\n            }\n\n            if (hint.size() > 0 && (hint[a0] != -1 || hint[a1] != -1)) {\n                continue;\n            }\n\n            std::swap(cura[a0], cura[a1]);\n\n            translate(cura, enc, cure);\n            auto curp = calcScoreForSpaces(freqMap, cure);\n            if (curp > iterp) {\n                iterp = curp;\n                itera = cura;\n                i = 0;\n            } else {\n                std::swap(cura[a0], cura[a1]);\n            }\n        }\n\n        if (iterp > bestp) {\n            besta = itera;\n            bestp = iterp;\n\n            if (bestp > bestbestp) {\n                bestbestp = bestp;\n                translate(besta, enc, beste);\n                printf(\"[+] Best score = %g\\n\", bestp);\n                printf(\"    Alphabet:  '\");\n                for (int i = 'a'; i <= 'z'; ++i) {\n                    auto c = ::myCharToInt[i];\n                    printf(\"%c\", i - c + besta[c]);\n                }\n                printf(\"'\\n\");\n                printText(beste);\n                printf(\"\\n\");\n            }\n            nIters = 0;\n        }\n    }\n\n    printText(beste, res);\n\n    return true;\n}\n\n"
        },
        {
          "name": "subbreak2.cpp",
          "type": "blob",
          "size": 52.763671875,
          "content": "/*! \\file subbreak2.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"subbreak2.h\"\n\n#include <array>\n#include <cstdlib>\n#include <fstream>\n#include <chrono>\n#include <cassert>\n#include <algorithm>\n\nnamespace {\n\n    static const std::array<float, 27> kEnglishLetterFreq = {\n        0.000, // space\n        8.167, // a\n        1.492, // b\n        2.782, // c\n        4.253,\n        12.702,\n        2.228,\n        2.015,\n        6.094,\n        6.966,\n        0.153,\n        0.772,\n        4.025,\n        2.406,\n        6.749,\n        7.507,\n        1.929,\n        0.095,\n        5.987,\n        6.327,\n        9.056,\n        2.758,\n        0.978,\n        2.360,\n        0.150,\n        1.974,\n        0.074,\n    };\n\n    static const std::array<float, 27> kEnglishLetterWithSpacesFreq = {\n        11.505, // space\n        7.228,  // a\n        1.320,  // b\n        2.462,  // c\n        3.764,\n        11.239,\n        1.972,\n        1.783,\n        5.393,\n        6.165,\n        0.135,\n        0.683,\n        3.562,\n        2.129,\n        5.973,\n        6.644,\n        1.707,\n        0.084,\n        5.298,\n        5.599,\n        8.014,\n        2.441,\n        0.866,\n        2.089,\n        0.133,\n        1.747,\n        0.065,\n    };\n\n    static const std::array<TLetter, 256> kCharToLetter = {\n        /* { 0,   */   0 /* } */,\n        /* { 1,   */   0 /* } */,\n        /* { 2,   */   0 /* } */,\n        /* { 3,   */   0 /* } */,\n        /* { 4,   */   0 /* } */,\n        /* { 5,   */   0 /* } */,\n        /* { 6,   */   0 /* } */,\n        /* { 7,   */   0 /* } */,\n        /* { 8,   */   0 /* } */,\n        /* { 9,   */   0 /* } */,\n        /* { 10,  */   0 /* } */,\n        /* { 11,  */   0 /* } */,\n        /* { 12,  */   0 /* } */,\n        /* { 13,  */   0 /* } */,\n        /* { 14,  */   0 /* } */,\n        /* { 15,  */   0 /* } */,\n        /* { 16,  */   0 /* } */,\n        /* { 17,  */   0 /* } */,\n        /* { 18,  */   0 /* } */,\n        /* { 19,  */   0 /* } */,\n        /* { 20,  */   0 /* } */,\n        /* { 21,  */   0 /* } */,\n        /* { 22,  */   0 /* } */,\n        /* { 23,  */   0 /* } */,\n        /* { 24,  */   0 /* } */,\n        /* { 25,  */   0 /* } */,\n        /* { 26,  */   0 /* } */,\n        /* { 27,  */   0 /* } */,\n        /* { 28,  */   0 /* } */,\n        /* { 29,  */   0 /* } */,\n        /* { 30,  */   0 /* } */,\n        /* { 31,  */   0 /* } */,\n        /* { 32,  */   0 /* } */,\n        /* { 33,  */   0 /* } */,\n        /* { 34,  */   0 /* } */,\n        /* { 35,  */   0 /* } */,\n        /* { 36,  */   0 /* } */,\n        /* { 37,  */   0 /* } */,\n        /* { 38,  */   0 /* } */,\n        /* { 39,  */   0 /* } */,\n        /* { 40,  */   0 /* } */,\n        /* { 41,  */   0 /* } */,\n        /* { 42,  */   0 /* } */,\n        /* { 43,  */   0 /* } */,\n        /* { 44,  */   0 /* } */,\n        /* { 45,  */   0 /* } */,\n        /* { 46,  */   0 /* } */,\n        /* { 47,  */   0 /* } */,\n        /* { 48,  */   0 /* } */,\n        /* { 49,  */   0 /* } */,\n        /* { 50,  */   0 /* } */,\n        /* { 51,  */   0 /* } */,\n        /* { 52,  */   0 /* } */,\n        /* { 53,  */   0 /* } */,\n        /* { 54,  */   0 /* } */,\n        /* { 55,  */   0 /* } */,\n        /* { 56,  */   0 /* } */,\n        /* { 57,  */   0 /* } */,\n        /* { 58,  */   0 /* } */,\n        /* { 59,  */   0 /* } */,\n        /* { 60,  */   0 /* } */,\n        /* { 61,  */   0 /* } */,\n        /* { 62,  */   0 /* } */,\n        /* { 63,  */   0 /* } */,\n        /* { 64,  */   0 /* } */,\n        /* { 65,  */   1 /* } */,\n        /* { 66,  */   2 /* } */,\n        /* { 67,  */   3 /* } */,\n        /* { 68,  */   4 /* } */,\n        /* { 69,  */   5 /* } */,\n        /* { 70,  */   6 /* } */,\n        /* { 71,  */   7 /* } */,\n        /* { 72,  */   8 /* } */,\n        /* { 73,  */   9 /* } */,\n        /* { 74,  */  10 /* } */,\n        /* { 75,  */  11 /* } */,\n        /* { 76,  */  12 /* } */,\n        /* { 77,  */  13 /* } */,\n        /* { 78,  */  14 /* } */,\n        /* { 79,  */  15 /* } */,\n        /* { 80,  */  16 /* } */,\n        /* { 81,  */  17 /* } */,\n        /* { 82,  */  18 /* } */,\n        /* { 83,  */  19 /* } */,\n        /* { 84,  */  20 /* } */,\n        /* { 85,  */  21 /* } */,\n        /* { 86,  */  22 /* } */,\n        /* { 87,  */  23 /* } */,\n        /* { 88,  */  24 /* } */,\n        /* { 89,  */  25 /* } */,\n        /* { 90,  */  26 /* } */,\n        /* { 91,  */   0 /* } */,\n        /* { 92,  */   0 /* } */,\n        /* { 93,  */   0 /* } */,\n        /* { 94,  */   0 /* } */,\n        /* { 95,  */   0 /* } */,\n        /* { 96,  */   0 /* } */,\n        /* { 97,  */   1 /* } */,\n        /* { 98,  */   2 /* } */,\n        /* { 99,  */   3 /* } */,\n        /* { 100, */   4 /* } */,\n        /* { 101, */   5 /* } */,\n        /* { 102, */   6 /* } */,\n        /* { 103, */   7 /* } */,\n        /* { 104, */   8 /* } */,\n        /* { 105, */   9 /* } */,\n        /* { 106, */  10 /* } */,\n        /* { 107, */  11 /* } */,\n        /* { 108, */  12 /* } */,\n        /* { 109, */  13 /* } */,\n        /* { 110, */  14 /* } */,\n        /* { 111, */  15 /* } */,\n        /* { 112, */  16 /* } */,\n        /* { 113, */  17 /* } */,\n        /* { 114, */  18 /* } */,\n        /* { 115, */  19 /* } */,\n        /* { 116, */  20 /* } */,\n        /* { 117, */  21 /* } */,\n        /* { 118, */  22 /* } */,\n        /* { 119, */  23 /* } */,\n        /* { 120, */  24 /* } */,\n        /* { 121, */  25 /* } */,\n        /* { 122, */  26 /* } */,\n        /* { 123, */   0 /* } */,\n        /* { 124, */   0 /* } */,\n        /* { 125, */   0 /* } */,\n        /* { 126, */   0 /* } */,\n        /* { 127, */   0 /* } */,\n        /* { 128, */   0 /* } */,\n        /* { 129, */   0 /* } */,\n        /* { 130, */   0 /* } */,\n        /* { 131, */   0 /* } */,\n        /* { 132, */   0 /* } */,\n        /* { 133, */   0 /* } */,\n        /* { 134, */   0 /* } */,\n        /* { 135, */   0 /* } */,\n        /* { 136, */   0 /* } */,\n        /* { 137, */   0 /* } */,\n        /* { 138, */   0 /* } */,\n        /* { 139, */   0 /* } */,\n        /* { 140, */   0 /* } */,\n        /* { 141, */   0 /* } */,\n        /* { 142, */   0 /* } */,\n        /* { 143, */   0 /* } */,\n        /* { 144, */   0 /* } */,\n        /* { 145, */   0 /* } */,\n        /* { 146, */   0 /* } */,\n        /* { 147, */   0 /* } */,\n        /* { 148, */   0 /* } */,\n        /* { 149, */   0 /* } */,\n        /* { 150, */   0 /* } */,\n        /* { 151, */   0 /* } */,\n        /* { 152, */   0 /* } */,\n        /* { 153, */   0 /* } */,\n        /* { 154, */   0 /* } */,\n        /* { 155, */   0 /* } */,\n        /* { 156, */   0 /* } */,\n        /* { 157, */   0 /* } */,\n        /* { 158, */   0 /* } */,\n        /* { 159, */   0 /* } */,\n        /* { 160, */   0 /* } */,\n        /* { 161, */   0 /* } */,\n        /* { 162, */   0 /* } */,\n        /* { 163, */   0 /* } */,\n        /* { 164, */   0 /* } */,\n        /* { 165, */   0 /* } */,\n        /* { 166, */   0 /* } */,\n        /* { 167, */   0 /* } */,\n        /* { 168, */   0 /* } */,\n        /* { 169, */   0 /* } */,\n        /* { 170, */   0 /* } */,\n        /* { 171, */   0 /* } */,\n        /* { 172, */   0 /* } */,\n        /* { 173, */   0 /* } */,\n        /* { 174, */   0 /* } */,\n        /* { 175, */   0 /* } */,\n        /* { 176, */   0 /* } */,\n        /* { 177, */   0 /* } */,\n        /* { 178, */   0 /* } */,\n        /* { 179, */   0 /* } */,\n        /* { 180, */   0 /* } */,\n        /* { 181, */   0 /* } */,\n        /* { 182, */   0 /* } */,\n        /* { 183, */   0 /* } */,\n        /* { 184, */   0 /* } */,\n        /* { 185, */   0 /* } */,\n        /* { 186, */   0 /* } */,\n        /* { 187, */   0 /* } */,\n        /* { 188, */   0 /* } */,\n        /* { 189, */   0 /* } */,\n        /* { 190, */   0 /* } */,\n        /* { 191, */   0 /* } */,\n        /* { 192, */   0 /* } */,\n        /* { 193, */   0 /* } */,\n        /* { 194, */   0 /* } */,\n        /* { 195, */   0 /* } */,\n        /* { 196, */   0 /* } */,\n        /* { 197, */   0 /* } */,\n        /* { 198, */   0 /* } */,\n        /* { 199, */   0 /* } */,\n        /* { 200, */   0 /* } */,\n        /* { 201, */   0 /* } */,\n        /* { 202, */   0 /* } */,\n        /* { 203, */   0 /* } */,\n        /* { 204, */   0 /* } */,\n        /* { 205, */   0 /* } */,\n        /* { 206, */   0 /* } */,\n        /* { 207, */   0 /* } */,\n        /* { 208, */   0 /* } */,\n        /* { 209, */   0 /* } */,\n        /* { 210, */   0 /* } */,\n        /* { 211, */   0 /* } */,\n        /* { 212, */   0 /* } */,\n        /* { 213, */   0 /* } */,\n        /* { 214, */   0 /* } */,\n        /* { 215, */   0 /* } */,\n        /* { 216, */   0 /* } */,\n        /* { 217, */   0 /* } */,\n        /* { 218, */   0 /* } */,\n        /* { 219, */   0 /* } */,\n        /* { 220, */   0 /* } */,\n        /* { 221, */   0 /* } */,\n        /* { 222, */   0 /* } */,\n        /* { 223, */   0 /* } */,\n        /* { 224, */   0 /* } */,\n        /* { 225, */   0 /* } */,\n        /* { 226, */   0 /* } */,\n        /* { 227, */   0 /* } */,\n        /* { 228, */   0 /* } */,\n        /* { 229, */   0 /* } */,\n        /* { 230, */   0 /* } */,\n        /* { 231, */   0 /* } */,\n        /* { 232, */   0 /* } */,\n        /* { 233, */   0 /* } */,\n        /* { 234, */   0 /* } */,\n        /* { 235, */   0 /* } */,\n        /* { 236, */   0 /* } */,\n        /* { 237, */   0 /* } */,\n        /* { 238, */   0 /* } */,\n        /* { 239, */   0 /* } */,\n        /* { 240, */   0 /* } */,\n        /* { 241, */   0 /* } */,\n        /* { 242, */   0 /* } */,\n        /* { 243, */   0 /* } */,\n        /* { 244, */   0 /* } */,\n        /* { 245, */   0 /* } */,\n        /* { 246, */   0 /* } */,\n        /* { 247, */   0 /* } */,\n        /* { 248, */   0 /* } */,\n        /* { 249, */   0 /* } */,\n        /* { 250, */   0 /* } */,\n        /* { 251, */   0 /* } */,\n        /* { 252, */   0 /* } */,\n        /* { 253, */   0 /* } */,\n        /* { 254, */   0 /* } */,\n        /* { 255, */   0 /* } */,\n    };\n\n// generate k random distinct ints in [0..n)\n[[maybe_unused]]\nstd::vector<int> subset(int k, int n) {\n    std::vector<int> res(k);\n    for (int i = 0; i < k; ++i) res[i] = i;\n\n    for (int i = k; i < n; ++i) {\n        const int j = rand()%(i + 1);\n        if (j < k) {\n            res[j] = i;\n        }\n    }\n\n    return res;\n}\n\ntemplate <typename T>\nvoid shuffle(T & t, int start = -1, int end = -1, const Cipher::THint & hint = {}) {\n    if (start == -1) start = 0;\n    if (end == -1) end = t.size();\n\n    for (int i = end - 1; i > start; --i) {\n        int i0 = i;\n        int i1 = rand()%(i - start + 1)+start;\n        if (hint.size() > 0 && (hint[i0] != -1 || hint[i1] != -1)) {\n            continue;\n        }\n        std::swap(t[i0], t[i1]);\n    }\n}\n\nvoid calcHelpers(\n        const Cipher::TParameters & params,\n        const TClusterToLetterMap & clMap,\n        const TClusters & clusters,\n        Cipher::TPlainText & plainText,\n        Cipher::TLetterCount & letterCount,\n        Cipher::TClusterCount & clusterCount,\n        Cipher::TClusterPos & clusterPos,\n        int & nLetters,\n        float & letterFreqCost) {\n\n    int n = clusters.size();\n    plainText.resize(n);\n    letterCount.resize(n);\n    std::fill(letterCount.begin(), letterCount.end(), 0);\n\n    if (clusterCount.size() == 0) {\n        clusterCount.resize(params.maxClusters, 0);\n        clusterPos.resize(params.maxClusters);\n\n        for (int i = 0; i < n; ++i) {\n            ++clusterCount[clusters[i]];\n            clusterPos[clusters[i]].push_back(i);\n        }\n    }\n\n    nLetters = 0;\n    for (int i = 0; i < n; ++i) {\n        plainText[i] = clMap.at(clusters[i]);\n        if (plainText[i] > 0 && plainText[i] <= 26) {\n            ++letterCount[plainText[i]];\n            ++nLetters;\n        } else if (params.includeSpaces) {\n            ++letterCount[0];\n            ++nLetters;\n        }\n    }\n\n    letterFreqCost = 0.0;\n    {\n        auto & freq = params.includeSpaces ? kEnglishLetterWithSpacesFreq : kEnglishLetterFreq;\n        for (int i = 0; i < 27; ++i) {\n            float curf = 0.01*freq[i] - ((float)(letterCount[i]))/((float)(nLetters));\n            letterFreqCost += curf*curf;\n        }\n    }\n\n    letterFreqCost /= 27.0;\n    letterFreqCost = sqrt(letterFreqCost);\n}\n\nvoid updateHelpers(\n        const Cipher::TParameters & params,\n        const Cipher::TClusterCount & clusterCount,\n        const Cipher::TClusterPos & clusterPos,\n        const int nLetters,\n        int c0, int c1,\n        TClusterToLetterMap & clMap,\n        Cipher::TPlainText & plainText,\n        Cipher::TLetterCount & letterCount,\n        float & letterFreqCost) {\n\n    int p0 = clMap.at(c0);\n    int p1 = clMap.at(c1);\n\n    int nc0 = clusterCount[c0];\n    int nc1 = clusterCount[c1];\n\n    letterCount[p0] += nc1 - nc0;\n    letterCount[p1] += nc0 - nc1;\n\n    clMap.at(c0) = p1;\n    clMap.at(c1) = p0;\n\n    for (auto & i : clusterPos[c0]) plainText[i] = p1;\n    for (auto & i : clusterPos[c1]) plainText[i] = p0;\n\n    letterFreqCost = 0.0;\n    {\n        auto & freq = params.includeSpaces ? kEnglishLetterWithSpacesFreq : kEnglishLetterFreq;\n        for (int i = 0; i < 27; ++i) {\n            float curf = 0.01*freq[i] - ((float)(letterCount[i]))/((float)(nLetters));\n            letterFreqCost += curf*curf;\n        }\n    }\n\n    letterFreqCost /= 27.0;\n    letterFreqCost = sqrt(letterFreqCost);\n}\n\n}\n\nnamespace Cipher {\n    TCode calcCode(const char * data, int n) {\n        TCode res = 0;\n        do { res <<= 5; res += kCharToLetter[*data++]; } while (--n > 0);\n        return res;\n    }\n\n    bool loadFreqMap(const char * fname, TFreqMap & res) {\n        auto & len = res.len;\n        auto & prob = res.prob;\n\n        len = 0;\n        prob.clear();\n\n        printf(\"[+] Loading n-gram file '%s'\\n\", fname);\n        std::ifstream fin(fname);\n\n        if (fin.good() == false) {\n            printf(\"    Failed to open file\\n\");\n            return false;\n        }\n\n        std::string gram;\n        int32_t nfreq = 0;\n        res.nTotal = 0;\n\n        while (true) {\n            fin >> gram >> nfreq;\n            if (fin.eof()) break;\n\n            res.nTotal += nfreq;\n        }\n\n        fin.clear();\n        fin.seekg(0);\n\n        while (true) {\n            fin >> gram >> nfreq;\n            if (fin.eof()) break;\n\n            if (len == 0) {\n                len = gram.size();\n                prob.resize(1 << (5*len), 1.0);\n            } else if (len != (int) gram.size()) {\n                printf(\"Error: loaded n-grams with vaying lengths\\n\");\n                return false;\n            }\n\n            TCode idx = calcCode(gram.data(), len);\n            if (prob[idx] < 0.5) {\n                printf(\"Error: duplicate n-gram '%s'\\n\", gram.c_str());\n                return false;\n            }\n            prob[idx] = std::log10(((double)(nfreq))/res.nTotal);\n        }\n        printf(\"    Total n-grams loaded = %g\\n\", (double) res.nTotal);\n\n        res.pmin = std::log(10000000.01/res.nTotal);\n        printf(\"    P-min = %g\\n\", res.pmin);\n        for (auto & p : prob) {\n            if (p >= 0.5) p = res.pmin;\n        }\n\n        return true;\n    }\n\n    bool encryptExact(const TParameters & , const std::string & text, TClusters & clusters) {\n        auto myCharToLetter = kCharToLetter;\n\n\t\tint k = 26;\n        {\n            for (auto & p : text) {\n                if (myCharToLetter[p] == 0) {\n                    myCharToLetter[p] = ++k;\n                }\n            }\n            printf(\"[encryptExact] Unique symbols = %d\\n\", k);\n        }\n\n\t\tstd::vector<TClusterId> alphabetTransformation(k);\n\t\tfor (int i = 0; i < (int) alphabetTransformation.size(); ++i) {\n\t\t\talphabetTransformation[i] = i;\n\t\t}\n\n\t\tshuffle(alphabetTransformation);\n\n\t\tclusters.resize(text.size());\n\n\t\tfor (int i = 0; i < (int) text.size(); ++i) {\n\t\t\tassert(myCharToLetter[text[i]] > 0);\n\t\t\tclusters[i] = alphabetTransformation[myCharToLetter[text[i]] - 1] + 1;\n\t\t\tprintf(\"%d - %d\\n\", i, clusters[i]);\n\t\t\tassert(clusters[i] > 0 && clusters[i] <= k);\n\t\t}\n\n        return true;\n    }\n\n\tbool generateSimilarityMap(const TParameters & params, const std::string & text, TSimilarityMap & ccMap) {\n\t\tint n = text.size();\n\n\t\tccMap.clear();\n        ccMap.resize(n);\n        for (auto & x : ccMap) x.resize(n);\n\n\t\tstd::vector<float> waveformAccuracy(n);\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfloat pError = frand();\n\t\t\tif (pError < params.waveformDetectionErrorP) {\n\t\t\t\twaveformAccuracy[i] = 1.0 - params.waveformDetectionErrorMin - frand()*(params.waveformDetectionErrorSig);\n\t\t\t} else {\n\t\t\t\twaveformAccuracy[i] = 1.0 - params.waveformDeviationMin - frand()*(params.waveformDeviationSig);\n\t\t\t}\n\n\t\t\twaveformAccuracy[i] += 2.0f*(0.5f - frand())*params.similarityNoiseSig;\n\t\t\twaveformAccuracy[i] = std::max(0.0f, waveformAccuracy[i]);\n\t\t\twaveformAccuracy[i] = std::min(1.0f, waveformAccuracy[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tccMap[i][j].cc = 1.0;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (text[i] != text[j]) {\n\t\t\t\t\tfloat sim = params.similarityMismatchAvg + 2.0f*(0.5f - frand())*params.similarityMismatchSig;\n\n\t\t\t\t\tccMap[i][j].cc = sim;\n\t\t\t\t\tccMap[j][i].cc = sim;\n\t\t\t\t} else {\n\t\t\t\t\tfloat sim = waveformAccuracy[i]*waveformAccuracy[j];\n\n\t\t\t\t\tccMap[i][j].cc = sim;\n\t\t\t\t\tccMap[j][i].cc = sim;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n    bool generateClusters(const TParameters & params, int n, TClusters & clusters) {\n        clusters.clear();\n        clusters.resize(n);\n\n        std::map<int, bool> used;\n        for (int i = 0; i < n; ++i) {\n            if (params.hint[i] < 0) continue;\n            clusters[i] = params.hint[i];\n            used[params.hint[i]] = true;\n        }\n\n        int cid = 0;\n        for (int i = 0; i < n; ++i) {\n            if (params.hint[i] >= 0) continue;\n            //clusters[i] = rand()%params.maxClusters;\n            while (used[cid]) {\n                if (++cid >= params.maxClusters) cid = 0;\n            }\n            clusters[i] = cid;\n            if (++cid >= params.maxClusters) cid = 0;\n        }\n\n        return true;\n    }\n\n    bool printClusterGoodness(const std::string & text, const TClusters & clusters) {\n        int len = text.length();\n        int ncorrect = 0;\n        int ntotal = 0;\n        for (int i = 0; i < len; ++i) {\n            for (int j = i + 1; j < len; ++j) {\n                bool ism0 = (text[i] == text[j]);\n                bool ism1 = (clusters[i] == clusters[j]);\n                if ((ism0 && ism1) || (!ism0 && !ism1)) {\n                    ++ncorrect;\n                }\n                ++ntotal;\n            }\n        }\n\n        printf(\"[+] Cluster goodness = %g\\n\", ((float)(ncorrect))/ntotal);\n\n        return true;\n    }\n\n    float costF(const TSimilarityMap & ccMap, const TClusters & clusters) {\n        int len = clusters.size();\n        float res = 0.0f;\n        for (int i = 0; i < len; ++i) {\n            for (int j = i + 1; j < len; ++j) {\n                if (clusters[i] == clusters[j]) {\n                    res += 1.0f - ccMap[i][j].cc;\n                }\n            }\n        }\n\n        return -res;\n    }\n\n    float costFUpdate(const TSimilarityMap & ccMap, const TClusters & clusters, int i, int cid, float c0) {\n        int len = clusters.size();\n        float res = -c0;\n        for (int j = 0; j < len; ++j) {\n            if (cid == clusters[j]) {\n                res -= 1.0f - ccMap[i][j].cc;\n            }\n            if (clusters[i] == clusters[j]) {\n                res += 1.0f - ccMap[i][j].cc;\n            }\n        }\n\n        return -res;\n    }\n\n    TProb calcScore0(const TParameters & params, const TFreqMap & freqMap, const TClusters & txt, const TClusterToLetterMap & clMap) {\n        const int n = txt.size();\n        const auto & len  = freqMap.len;\n        const auto & prob = freqMap.prob;\n\n        int nlet = 0;\n        std::array<int, 27> letCount;\n        letCount.fill(0);\n        std::vector<TLetter> plain(n);\n        for (int i = 0; i < n; ++i) {\n            plain[i] = clMap.at(txt[i]);\n            if (plain[i] > 0 && plain[i] <= 26) {\n                ++letCount[plain[i]];\n                ++nlet;\n            } else if (params.includeSpaces) {\n                ++letCount[0];\n                ++nlet;\n            }\n        }\n\n        float letFreqCost = 0.0;\n        {\n            auto & freq = params.includeSpaces ? kEnglishLetterWithSpacesFreq : kEnglishLetterFreq;\n            for (int i = 0; i < 27; ++i) {\n                float curf = 0.01*freq[i] - ((float)(letCount[i]))/((float)(nlet));\n                letFreqCost += curf*curf;\n            }\n        }\n\n        letFreqCost /= 27.0;\n        letFreqCost = sqrt(letFreqCost);\n        //printf(\"letFreqCost = %g\\n\", letFreqCost);\n\n        int i1 = 0;\n        int k = len;\n        TCode curc = 0;\n        TCode mask = (1 << 5*(len-1)) - 1;\n\n        TProb res = 0.0;\n\n        while (k > 0) {\n            if (i1 >= n) return -1e100;\n            auto c = plain[i1++];\n            if (c > 0 && c <= 26) {\n                curc <<= 5;\n                curc += c;\n                --k;\n            } else {\n                res += params.pNonAlphabetic;\n            }\n        }\n\n        res += prob[curc];\n        while (true) {\n            curc &= mask;\n\n            while (true) {\n                if (i1 >= n) return res/n - params.wEnglishFreq*letFreqCost;\n                auto c = plain[i1++];\n                if (c > 0 && c <= 26) {\n                    curc <<= 5;\n                    curc += c;\n                    break;\n                } else {\n                    res += params.pNonAlphabetic;\n                }\n            }\n\n            res += prob[curc];\n        }\n\n        return res/n - params.wEnglishFreq*letFreqCost;\n    }\n\n    TProb calcScore1(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            const std::vector<TLetter> & plain,\n            const float letFreqCost) {\n        TProb res = 0.0;\n\n        const int n = plain.size();\n        const auto & len  = freqMap.len;\n        const auto & prob = freqMap.prob;\n\n        //printf(\"letFreqCost = %g\\n\", letFreqCost);\n\n        int i1 = 0;\n        int k = len;\n        TCode curc = 0;\n        TCode mask = (1 << 5*(len-1)) - 1;\n\n        while (k > 0) {\n            if (i1 >= n) return -1e100;\n            auto c = plain[i1++];\n            if (c > 0 && c <= 26) {\n                curc <<= 5;\n                curc += c;\n                --k;\n            } else {\n                res += params.pNonAlphabetic;\n            }\n        }\n\n        res += prob[curc];\n        while (true) {\n            curc &= mask;\n\n            while (true) {\n                if (i1 >= n) return res/n - params.wEnglishFreq*letFreqCost;\n                auto c = plain[i1++];\n                if (c > 0 && c <= 26) {\n                    curc <<= 5;\n                    curc += c;\n                    break;\n                } else {\n                    res += params.pNonAlphabetic;\n                }\n            }\n\n            res += prob[curc];\n        }\n\n        return res/n - params.wEnglishFreq*letFreqCost;\n    }\n\n    bool doSimulatedAnnealing3(\n        const TParameters & params,\n        const TSimilarityMap & ccMap,\n        TClusters & clusters\n        ) {\n\n        int n = clusters.size();\n\n        int ncc = 0;\n        float ccavg = 0.0;\n        for (int j = 0; j < n; ++j) {\n            for (int i = j + 1; i < n; ++i) {\n                ccavg += ccMap[j][i].cc;\n                ++ncc;\n            }\n        }\n        ccavg /= ncc;\n        printf(\"Average cc = %g\\n\", ccavg);\n\n        float temp = params.temp0;\n        float cost0 = costF(ccMap, clusters);\n\n        auto clustersNew = clusters;\n        auto clustersBest = clusters;\n\n        bool hintMerge = false;\n\n        int nRepeat = 0;\n        float costOld = cost0;\n\n        for (int iter = 0; iter < params.saMaxIterations; ++iter) {\n            if (iter%5000 == 0) {\n                printf(\"Iter %5d : temp = %16.4f, cost0 = %8.4f\\n\", iter, temp, cost0);\n            }\n\n            if (costOld == cost0) {\n                if (++nRepeat == 0.1*params.saMaxIterations) {\n                    printf(\"No improvement for long time. Aborting\\n\");\n                    iter = 0.95*params.saMaxIterations + 1;\n                }\n            } else {\n                nRepeat = 0;\n                costOld = cost0;\n            }\n\n            bool doMerge = iter > 0.95*params.saMaxIterations;\n\n            if (doMerge) {\n                if (hintMerge == false) {\n                    bool isValid = true;\n                    std::map<TClusterId, int> ch;\n                    for (int k = 0; k < n; ++k) {\n                        if (params.hint[k] < 0) continue;\n                        int cid = clusters[k];\n                        if (ch.find(cid) != ch.end()) {\n                            if (ch[cid] != params.hint[k]) {\n                                isValid = false;\n                                break;\n                            }\n                        } else {\n                            ch[cid] = params.hint[k];\n                        }\n                    }\n                    printf(\"IsValid = %d\\n\", isValid);\n\n                    for (int k0 = 0; k0 < n; ++k0) {\n                        if (params.hint[k0] < 0) continue;\n                        for (int k1 = k0 + 1; k1 < n; ++k1) {\n                            if (params.hint[k1] < 0) continue;\n                            if (params.hint[k0] != params.hint[k1]) continue;\n\n                            if (clusters[k0] != clusters[k1]) {\n                                printf(\"Merging clusters %d and %d based on hint\\n\", clusters[k0], clusters[k1]);\n\n                                int cid0 = clusters[k0];\n                                int cid1 = clusters[k1];\n\n                                for (int i = 0; i < n; ++i) {\n                                    if (clusters[i] == cid1) {\n                                        clusters[i] = cid0;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    cost0 = costF(ccMap, clusters);\n                    hintMerge = true;\n                }\n\n                clustersNew = clusters;\n\n                int i0 = rand()%n;\n                int i1 = rand()%n;\n                while (clusters[i0] == clusters[i1] || ccMap[i0][i1].cc < ccavg) {\n                    i0 = rand()%n;\n                    i1 = rand()%n;\n                }\n\n                int cid0 = clusters[i0];\n                int cid1 = clusters[i1];\n\n                std::map<int, int> csize;\n                for (const auto & c : clusters) {\n                    ++csize[c];\n                }\n                int nonzero = csize.size();\n\n                if (nonzero <= params.minClusters) {\n                    printf(\"Reached min number of clusters. Done\\n\");\n                    break;\n                }\n\n                break;\n\n                int n0 = csize[cid0];\n                int n1 = csize[cid1];\n\n                --nonzero;\n\n                for (int i = 0; i < n; ++i) {\n                    if (clustersNew[i] == cid1) {\n                        clustersNew[i] = cid0;\n                    }\n                }\n\n                float cost1 = costF(ccMap, clustersNew);\n                cost1 += 1.0f*n0*n1*(1.0f - ccavg);\n\n                float delta = cost1 - cost0;\n                if (delta > 0 || (std::exp(delta/temp) > frand())) {\n                    printf(\"merge %d size %d      -  %d size %d\\n\", cid0, n0, cid1, n1);\n                    cost0 = cost1 - 1.0f*n0*n1*(1.0f - ccavg);\n                    clusters = clustersNew;\n                }\n            } else {\n                clustersNew = clusters;\n                clustersBest = clusters;\n\n                float costBest = -1e10;\n                float costCur = cost0;\n                for (int k = 0; k < params.nChangePerIteration; ++k) {\n                    int i = rand()%n;\n                    while (params.hint[i] >= 0) {\n                        i = rand()%n;\n                    }\n\n                    int cid = clustersNew[i];\n                    while (cid == clustersNew[i]) {\n                        clustersNew[i] = rand()%params.maxClusters;\n                    }\n\n                    costCur = costFUpdate(ccMap, clustersNew, i, cid, costCur);\n\n                    if (costCur > costBest) {\n                        costBest = costCur;\n                        clustersBest = clustersNew;\n                    }\n                }\n\n                float cost1 = costBest;\n\n                float delta = cost1 - cost0;\n                if (delta > 0 || (std::exp(delta/temp) > frand())) {\n                    cost0 = cost1;\n                    clusters = clustersBest;\n                }\n            }\n\n            temp *= params.coolingRate;\n        }\n\n        return true;\n    }\n\n    bool doSimulatedAnnealing4(\n        const TParameters & params,\n        const TFreqMap & freqMap,\n        const TClusters & clusters,\n        TClusterToLetterMap & clMap\n        ) {\n\n        int n = clusters.size();\n\n        clMap.clear();\n        std::map<TLetter, bool> used;\n        std::map<TClusterId, bool> fixed;\n        for (int i = 0; i < (int) params.hint.size(); ++i) {\n            if (params.hint[i] < 0) continue;\n            //if (used[params.hint[i]]) continue;\n            if (fixed[clusters[i]]) continue;\n\n            clMap[clusters[i]] = params.hint[i];\n            used[params.hint[i]] = true;\n            fixed[clusters[i]] = true;\n            printf(\"Fixed %d\\n\", clusters[i]);\n        }\n\n        {\n            int ii = 0;\n            for (int i = 0; i < params.maxClusters; ++i) {\n                if (fixed[i]) continue;\n                while (used[ii]) ++ii;\n                clMap[i] = ii++;\n            }\n        }\n\n        float temp = params.temp0;\n        float cost0 = calcScore0(params, freqMap, clusters, clMap);\n\n        auto clMapSave = clMap;\n        auto clMapBest = clMap;\n\n        for (int iter = 0; iter < params.saMaxIterations; ++iter) {\n            if (iter%5000 == 0) {\n                printf(\"Iter %5d : temp = %16.4f, cost0 = %8.4f\\n\", iter, temp, cost0);\n                for (int i = 0; i < n; ++i) {\n                    if (clMap[clusters[i]] > 0 && clMap[clusters[i]] <= 26) {\n                        printf(\"%c\", 'a'+clMap[clusters[i]]-1);\n                    } else {\n                        printf(\".\");\n                    }\n                }\n                printf(\"\\n\");\n            }\n\n            clMapSave = clMap;\n            clMapBest = clMap;\n\n            float costBest = -1e10;\n\n            for (int k = 0; k < 1; ++k) {\n                {\n                    int i2 = rand()%params.maxClusters;\n                    int i3 = rand()%params.maxClusters;\n                    while (i2 == i3 || fixed[i2] || fixed[i3]) {\n                        i2 = rand()%params.maxClusters;\n                        i3 = rand()%params.maxClusters;\n                    }\n                    std::swap(clMap[i2], clMap[i3]);\n                }\n\n                int i2 = rand()%params.maxClusters;\n                while (fixed[i2]) {\n                    i2 = rand()%params.maxClusters;\n                }\n                int letterNew = rand()%27;\n                while (clMap[i2] == letterNew) {\n                    letterNew = rand()%27;\n                }\n\n                clMap[i2] = letterNew;\n\n                float costCur = calcScore0(params, freqMap, clusters, clMap);\n                if (costCur > costBest) {\n                    costBest = costCur;\n                    clMapBest = clMap;\n                }\n            }\n\n            //float costBest = -1e10;\n            //for (int k = 0; k < 1; ++k) {\n            //    int i2 = rand()%params.maxClusters;\n            //    int i3 = rand()%params.maxClusters;\n            //    while (i2 == i3 || fixed[i2] || fixed[i3]) {\n            //        i2 = rand()%params.maxClusters;\n            //        i3 = rand()%params.maxClusters;\n            //    }\n            //    std::swap(clMap[i2], clMap[i3]);\n\n            //    float costCur = calcScore0(params, freqMap, clusters, clMap);\n\n            //    if (costCur > costBest) {\n            //        costBest = costCur;\n            //        clMapBest = clMap;\n            //    }\n            //}\n\n            clMap = clMapBest;\n\n            float cost1 = costBest;\n\n            float delta = cost1 - cost0;\n            if (delta > 0 || (std::exp(delta/temp) > frand())) {\n                cost0 = cost1;\n            } else {\n                clMap = clMapSave;\n            }\n\n            temp *= params.coolingRate;\n        }\n\n        for (auto & cl : clMap) {\n            printf(\"%d - %c\\n\", cl.first, 'a' + cl.second - 1);\n        }\n\n        for (int i = 0; i < 27; ++i) {\n            printf(\"    %c - \", 'a' + i - 1);\n            for (auto & cl : clMap) {\n                if (cl.second == i) {\n                    printf(\"%d \", cl.first);\n                }\n            }\n            printf(\"\\n\");\n        }\n\n        return true;\n    }\n\n    bool doSimulatedAnnealing5(\n        const TParameters & params,\n        const TFreqMap & freqMap,\n        const TSimilarityMap & ccMap,\n        TClusters & clusters,\n        TClusterToLetterMap & clMap\n        ) {\n\n        int n = clusters.size();\n\n        int ncc = 0;\n        float ccavg = 0.0;\n        for (int j = 0; j < n; ++j) {\n            for (int i = j + 1; i < n; ++i) {\n                ccavg += ccMap[j][i].cc;\n                ++ncc;\n            }\n        }\n        ccavg /= ncc;\n        printf(\"Average cc = %g\\n\", ccavg);\n\n        clMap.clear();\n        std::map<TLetter, bool> used;\n        std::map<TClusterId, bool> fixed;\n        for (int i = 0; i < (int) params.hint.size(); ++i) {\n            if (params.hint[i] < 0) continue;\n            //if (used[params.hint[i]]) continue;\n            if (fixed[clusters[i]]) continue;\n\n            clMap[clusters[i]] = params.hint[i];\n            used[params.hint[i]] = true;\n            fixed[clusters[i]] = true;\n            printf(\"Fixed %d\\n\", clusters[i]);\n        }\n\n        {\n            int ii = 0;\n            for (int i = 0; i < params.maxClusters; ++i) {\n                if (fixed[i]) continue;\n                while (used[ii]) ++ii;\n                clMap[i] = ii++;\n            }\n        }\n\n        float wlm = params.wLanguageModel;\n        float temp = params.temp0;\n        float cost0CL = costF(ccMap, clusters);\n        float cost0LM = calcScore0(params, freqMap, clusters, clMap);\n        float cost0 = cost0CL + wlm*cost0LM;\n\n        int nRepeat = 0;\n        float costOld = cost0;\n\n        auto tStart = std::chrono::high_resolution_clock::now();\n\n        for (int iter = 0; iter < params.saMaxIterations; ++iter) {\n            if (iter%10000 == 0) {\n                auto tEnd = std::chrono::high_resolution_clock::now();\n                float iterPerT = (float)(iter)/((float)(std::chrono::duration_cast<std::chrono::milliseconds>(tEnd - tStart).count()));\n\n                printf(\"Speed: %6.2f iter/ms, Iter %5d : temp = %16.4f, cost0 = %8.4f, costCL = %8.4f, costLM = %8.4f\\n\",\n                       iterPerT, iter, temp, cost0, cost0CL, cost0LM);\n                for (int i = 0; i < (int) clusters.size(); ++i) { printf(\"%c\", 'a'+clMap[clusters[i]]-1); }\n                printf(\"\\n\");\n            }\n\n            if (costOld == cost0) {\n                //if (++nRepeat == 0.005*params.saMaxIterations) {\n                //    printf(\"Heating\\n\");\n                //    temp *= 100.1f;\n                //}\n                if (++nRepeat == 0.01*params.saMaxIterations) {\n                    printf(\"No improvement for long time. Aborting\\n\");\n                    iter = params.saMaxIterations + 1;\n                }\n            } else {\n                nRepeat = 0;\n                costOld = cost0;\n            }\n\n            int cid = -1;\n            int i1l = -1;\n            int i = rand()%n;\n            int i1 = rand()%params.maxClusters;\n            int i2 = rand()%params.maxClusters;\n            int i3 = rand()%params.maxClusters;\n\n            float costCurCL = cost0CL;\n            float costCurLM = cost0LM;\n\n            {\n                while (params.hint[i] >= 0) {\n                    i = rand()%n;\n                }\n\n                cid = clusters[i];\n                while (cid == clusters[i]) {\n                    clusters[i] = rand()%params.maxClusters;\n                }\n\n                costCurCL = costFUpdate(ccMap, clusters, i, cid, cost0CL);\n\n                float cost1 = costCurCL + wlm*cost0LM;\n                float delta = cost1 - cost0;\n                if (delta > 0 || (std::exp(0.01f*(delta/temp)) > frand())) {\n                    cost0CL = costCurCL;\n                    cost0 = cost1;\n                } else {\n                    clusters[i] = cid;\n                }\n            }\n\n            {\n                while (i2 == i3 || fixed[i2] || fixed[i3]) {\n                    i2 = rand()%params.maxClusters;\n                    i3 = rand()%params.maxClusters;\n                }\n                std::swap(clMap[i2], clMap[i3]);\n\n                while (fixed[i1]) {\n                    i1 = rand()%params.maxClusters;\n                }\n                i1l = clMap[i1];\n                int letterNew = rand()%27;\n                while (clMap[i1] == letterNew) {\n                    letterNew = rand()%27;\n                }\n\n                clMap[i1] = letterNew;\n\n                costCurLM = calcScore0(params, freqMap, clusters, clMap);\n\n                float cost1 = cost0CL + wlm*costCurLM;\n                float delta = cost1 - cost0;\n                if (delta > 0 || (std::exp(0.01f*(delta/temp)) > frand())) {\n                    cost0LM = costCurLM;\n                    cost0 = cost1;\n                } else {\n                    clMap[i1] = i1l;\n                    std::swap(clMap[i2], clMap[i3]);\n                }\n            }\n\n            temp *= params.coolingRate;\n        }\n\n        return true;\n    }\n\n    void getRandomCLMap(\n        const TParameters & params,\n        const TClusters & clusters,\n        TClusterToLetterMap & clMap) {\n\n        clMap.clear();\n\n        for (int i = 0; i < params.maxClusters; ++i) {\n            clMap[i] = rand()%27;\n        }\n\n        std::map<int, std::vector<int>> options;\n        for (int i = 0; i < (int) params.hint.size(); ++i) {\n            if (params.hint[i] < 0) continue;\n            options[clusters[i]].push_back(params.hint[i]);\n        }\n\n        for (auto & option : options) {\n            int n = option.second.size();\n            clMap[option.first] = option.second[rand()%n];\n        }\n    }\n\n    bool subbreak(\n        const TParameters & params,\n        const TFreqMap & freqMap,\n        TResult & result) {\n        const auto & clusters = result.clusters;\n        auto & clMap = result.clMap;\n        auto & minBestP = result.p;\n\n        std::map<TLetter, bool> fixed;\n        for (int i = 0; i < (int) params.hint.size(); ++i) {\n            if (params.hint[i] < 0) continue;\n            fixed[clusters[i]] = true;\n        }\n\n        auto besta = clMap;\n        getRandomCLMap(params, clusters, besta);\n        float bestp = calcScore0(params, freqMap, clusters, besta);\n\n        int nIters = 0;\n        int nMainIters = params.nSubbreakIterations;\n        while (nMainIters--) {\n            if (++nIters > 100) {\n                getRandomCLMap(params, clusters, besta);\n                bestp = calcScore0(params, freqMap, clusters, besta);\n                nIters = 0;\n            }\n\n            auto itera = besta;\n\n            int nswaps = 3;\n            for (int i = 0; i < nswaps; ++i) {\n                int a0 = rand()%params.maxClusters;\n                int a1 = rand()%params.maxClusters;\n                while (a0 == a1 || fixed[a0] || fixed[a1]) {\n                    a0 = rand()%params.maxClusters;\n                    a1 = rand()%params.maxClusters;\n                }\n\n                std::swap(itera[a0], itera[a1]);\n            }\n\n            auto iterp = calcScore0(params, freqMap, clusters, itera);\n            auto cura = itera;\n            for (int i = 0; i < 5; ++i) {\n                int a0 = rand()%params.maxClusters;\n                int a1 = rand()%params.maxClusters;\n                while (a0 == a1 || fixed[a0] || fixed[a1]) {\n                    a0 = rand()%params.maxClusters;\n                    a1 = rand()%params.maxClusters;\n                }\n\n                std::swap(cura[a0], cura[a1]);\n\n                auto curp = calcScore0(params, freqMap, clusters, cura);\n                if (curp > iterp) {\n                    iterp = curp;\n                    itera = cura;\n                    i = 0;\n                } else {\n\t\t\t\t\tstd::swap(cura[a0], cura[a1]);\n                }\n            }\n\n            if (iterp > bestp) {\n                besta = itera;\n                bestp = iterp;\n\n                if (bestp > minBestP) {\n                    minBestP = bestp;\n                    clMap = besta;\n                }\n                nIters = 0;\n            }\n        }\n\n        return true;\n    }\n\n    bool subbreak1(\n        const TParameters & params,\n        const TFreqMap & freqMap,\n        TResult & result) {\n\n        // helpers\n        TPlainText plainText;\n        TLetterCount letterCount;\n        TClusterCount clusterCount;\n        TClusterPos clusterPos;\n\n        int nLetters = 0;\n        float letterFreqCost = 0.0f;\n\n        const auto & clusters = result.clusters;\n        auto & clMap = result.clMap;\n        auto & minBestP = result.p;\n\n        auto besta = clMap;\n        getRandomCLMap(params, clusters, besta);\n\n        std::map<TLetter, bool> fixed;\n        for (int i = 0; i < (int) params.hint.size(); ++i) {\n            if (params.hint[i] < 0) continue;\n            fixed[clusters[i]] = true;\n        }\n\n        ::calcHelpers(params, besta, clusters, plainText, letterCount, clusterCount, clusterPos, nLetters, letterFreqCost);\n        float bestp = calcScore1(params, freqMap, plainText, letterFreqCost);\n\n        int nIters = 0;\n        int nMainIters = params.nSubbreakIterations;\n        while (nMainIters--) {\n            if (++nIters > 100) {\n                getRandomCLMap(params, clusters, besta);\n\n                ::calcHelpers(params, besta, clusters, plainText, letterCount, clusterCount, clusterPos, nLetters, letterFreqCost);\n                bestp = calcScore1(params, freqMap, plainText, letterFreqCost);\n\n                nIters = 0;\n            }\n\n            auto itera = besta;\n\n            int nswaps = 3;\n            for (int i = 0; i < nswaps; ++i) {\n                int a0 = rand()%params.maxClusters;\n                int a1 = rand()%params.maxClusters;\n                while (a0 == a1) {\n                    a0 = rand()%params.maxClusters;\n                    a1 = rand()%params.maxClusters;\n                }\n\n                if (fixed[a0] || fixed[a1]) {\n                } else {\n                    //std::swap(itera[a0], itera[a1]);\n                    ::updateHelpers(params, clusterCount, clusterPos, nLetters, a0, a1, itera, plainText, letterCount, letterFreqCost);\n                }\n            }\n\n            auto iterp = calcScore1(params, freqMap, plainText, letterFreqCost);\n\n            auto cura = itera;\n            for (int i = 0; i < 10; ++i) {\n                int a0 = rand()%params.maxClusters;\n                int a1 = rand()%params.maxClusters;\n                while (a0 == a1) {\n                    a0 = rand()%params.maxClusters;\n                    a1 = rand()%params.maxClusters;\n                }\n\n                //std::swap(cura[a0], cura[a1]);\n                ::updateHelpers(params, clusterCount, clusterPos, nLetters, a0, a1, cura, plainText, letterCount, letterFreqCost);\n                auto curp = calcScore1(params, freqMap, plainText, letterFreqCost);\n\n                if (curp > iterp) {\n                    iterp = curp;\n                    itera = cura;\n                    i = 0;\n                } else {\n\t\t\t\t\t//std::swap(cura[a0], cura[a1]);\n                    ::updateHelpers(params, clusterCount, clusterPos, nLetters, a0, a1, cura, plainText, letterCount, letterFreqCost);\n                }\n            }\n\n            if (iterp > bestp) {\n                besta = itera;\n                bestp = iterp;\n\n                if (bestp > minBestP) {\n                    minBestP = bestp;\n                    clMap = besta;\n                }\n                nIters = 0;\n            }\n        }\n\n        return true;\n    }\n\n    bool generateClustersInitialGuess(\n            const TParameters & params,\n            const TSimilarityMap & ccMap,\n            TClusters & clusters) {\n        int n = ccMap.size();\n\n        int nClusters = n;\n        clusters.resize(n);\n        for (int i = 0; i < n; ++i) {\n            clusters[i] = i;\n        }\n\n        struct Pair {\n            int i;\n            int j;\n            double cc;\n\n            bool operator < (const Pair & a) const { return cc > a.cc; }\n        };\n\n        std::vector<Pair> ccPairs;\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                ccPairs.emplace_back(Pair{i, j, ccMap[i][j].cc});\n            }\n        }\n\n        std::sort(ccPairs.begin(), ccPairs.end());\n\n        {\n            std::vector<bool> used(n);\n\n            for (int k = 0; k < (int) ccPairs.size(); ++k) {\n                int i = ccPairs[k].i;\n                int j = ccPairs[k].j;\n\n                if (clusters[i] == clusters[j]) continue;\n\n                int cidi = clusters[i];\n                int cidj = clusters[j];\n\n                if (used[cidi] || used[cidj]) continue;\n\n                if (cidi > cidj) {\n                    std::swap(cidi, cidj);\n                }\n\n                for (int p = 0; p < n; ++p) {\n                    if (clusters[p] == cidj) {\n                        clusters[p] = cidi;\n                    }\n                }\n                used[cidj] = true;\n                --nClusters;\n\n                if (nClusters <= params.maxClusters) break;\n            }\n        }\n\n        {\n            int cnt = 0;\n            std::map<int, int> used;\n            for (auto & cid : clusters) {\n                if (used[cid] > 0) continue;\n                used[cid] = ++cnt;\n            }\n\n            for (auto & cid : clusters) {\n                cid = used[cid] - 1;\n            }\n        }\n\n        printf(\"nClusters = %d\\n\", nClusters);\n        for (auto & cid : clusters) {\n            assert(cid >= 0 && cid < params.maxClusters);\n        }\n\n        return true;\n    }\n\n    bool mutateClusters(const TParameters & params, TClusters & clusters) {\n        int n = clusters.size();\n\n        //for (int i = 0; i < 3; ++i) {\n        //    int i0 = rand()%n;\n        //    int i1 = rand()%n;\n        //    std::swap(clusters[i0], clusters[i1]);\n        //}\n\n        for (int i = 0; i < 1; ++i) {\n            int idx = rand()%n;\n            clusters[idx] = rand()%params.maxClusters;\n            //auto p = clusters[idx];\n            //while (clusters[idx] == p) {\n            //    clusters[idx] = rand()%params.maxClusters;\n            //}\n        }\n\n        //std::map<int, bool> used;\n        //for (int i = 0; i < n; ++i) {\n        //    if (hint[i] < 0) continue;\n        //    clusters[i] = hint[i];\n        //    used[hint[i]] = true;\n        //}\n\n        return true;\n    }\n\n    double calcPClusters(\n            const TParameters & ,\n            const TSimilarityMap & ,\n            const TSimilarityMap & logMap,\n            const TSimilarityMap & logMapInv,\n            const TClusters & clusters,\n            const TClusterToLetterMap &) {\n\n        double res = 0.0;\n        int n = clusters.size();\n\n        for (int j = 0; j < n - 1; ++j) {\n            for (int i = j + 1; i < n; ++i) {\n                if (clusters[i] == clusters[j]) {\n                //if (clMap.at(clusters[i]) == clMap.at(clusters[j])) {\n                    res += logMap[j][i].cc;\n                } else {\n                    res += logMapInv[j][i].cc;\n                }\n            }\n        }\n\n        //if (clMap.empty()) {\n        //    for (int j = 0; j < n - 1; ++j) {\n        //        for (int i = j + 1; i < n; ++i) {\n        //            if (clusters[i] == clusters[j]) {\n        //                res += logMap[j][i].cc;\n        //            } else {\n        //                res += logMapInv[j][i].cc;\n        //            }\n        //        }\n        //    }\n        //    res *= 2.0;\n        //} else {\n        //    for (int j = 0; j < n - 1; ++j) {\n        //        for (int i = j + 1; i < n; ++i) {\n        //            if (clMap.at(clusters[i]) == clMap.at(clusters[j])) {\n        //                res += logMap[j][i].cc;\n        //            } else {\n        //                res += logMapInv[j][i].cc;\n        //            }\n        //        }\n        //    }\n        //}\n\n        return res;\n    }\n\n    bool normalizeSimilarityMap(\n            const TParameters & ,\n            TSimilarityMap & ccMap,\n            TSimilarityMap & logMap,\n            TSimilarityMap & logMapInv) {\n        int n = ccMap.size();\n\n        double ccMin = std::numeric_limits<double>::max();\n        double ccMax = std::numeric_limits<double>::min();\n\n        for (int j = 0; j < n - 1; ++j) {\n            for (int i = j + 1; i < n; ++i) {\n                ccMin = std::min(ccMin, ccMap[j][i].cc);\n                ccMax = std::max(ccMax, ccMap[j][i].cc);\n            }\n        }\n\n        ccMin -= 1e-6;\n        ccMax += 1e-6;\n\n        printf(\"ccMax = %g, ccMin = %g\\n\", ccMax, ccMin);\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i < n; ++i) {\n                if (i == j) {\n                    ccMap[j][i].cc = 1.0;\n                    continue;\n                }\n\n                auto & v = ccMap[j][i].cc;\n                v = (v - ccMin)/(ccMax - ccMin);\n                //v = 1.0 - std::exp(-1.1f*v);\n            }\n        }\n\n        logMap = ccMap;\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i < n; ++i) {\n                if (i == j) {\n                    logMap[j][i].cc = 0.0;\n                    continue;\n                }\n\n                auto & v = logMap[j][i].cc;\n                v = std::log(v);\n            }\n        }\n\n        logMapInv = ccMap;\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i < n; ++i) {\n                if (i == j) {\n                    logMap[j][i].cc = -1e6;\n                    continue;\n                }\n\n                auto & v = logMapInv[j][i].cc;\n                v = std::log(1.0 - v);\n            }\n        }\n\n        return true;\n    }\n\n    void printText(const TClusters & t) {\n        for (auto & c : t) {\n            if (c >= 1 && c <= 26) printf(\"%c\", 'a' + c - 1); else printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n\n    void printText(const TClusters & t, const TClusterToLetterMap & clMap) {\n        for (auto & cc : t) {\n\t\t\tauto c = clMap.at(cc);\n            if (c >= 1 && c <= 26) printf(\"%c\", 'a' + c - 1); else printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n\n    //\n    // Processor\n    //\n\n    Processor::Processor() {\n    }\n\n    bool Processor::init(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            const TSimilarityMap & similarityMap) {\n        m_params = params;\n        m_freqMap = &freqMap;\n        m_similarityMap = similarityMap;\n\n        normalizeSimilarityMap(m_params, m_similarityMap, m_logMap, m_logMapInv);\n        generateClustersInitialGuess(m_params, m_similarityMap, m_curResult.clusters);\n\n        auto clustersNew = m_curResult.clusters;\n\n        Cipher::mutateClusters(m_params, clustersNew);\n        m_pCur = calcPClusters(m_params, m_similarityMap, m_logMap, m_logMapInv, clustersNew, m_curResult.clMap);\n\n        return true;\n    }\n\n    bool Processor::setPNonAlphabetic(TProb p) {\n        m_params.pNonAlphabetic = p;\n\n        return true;\n    }\n\n    bool Processor::setWEnglishFreq(float w) {\n        m_params.wEnglishFreq = w;\n        m_curResult.p *= 1.001;\n        m_pCur *= 1.001;\n\n        return true;\n    }\n\n    bool Processor::setHint(const THint & hint) {\n        m_params.hint = hint;\n\n        return true;\n    }\n\n    bool Processor::compute() {\n        auto clustersNew = m_curResult.clusters;\n\n        for (int iter = 0; iter < m_params.nMHIters; ++iter) {\n            clustersNew = m_curResult.clusters;\n            Cipher::mutateClusters(m_params, clustersNew);\n            auto pNew = calcPClusters(m_params, m_similarityMap, m_logMap, m_logMapInv, clustersNew, m_curResult.clMap);\n\n            auto u = frand();\n            //auto alpha = pNew/pCur;\n            auto alpha = pNew > m_pCur ? 1.0 : std::exp((pNew - m_pCur));\n\n            //printf(\"pNew = %g, pCur = %g, alpha = %g\\n\", pNew, pCur, alpha);\n\n            if (u <= alpha) {\n                m_curResult.clusters = clustersNew;\n                m_pCur = pNew;\n\n                if (++m_nMHInitialIters > m_params.nMHInitialIters) {\n                    m_curResult.p *= 1.0001;\n                    auto saveHint = m_params.hint;\n                    for (auto & hint : m_params.hint) {\n                        if (hint < 0) continue;\n                        if (frand() > 0.10) {\n                            hint = -1;\n                        }\n                    }\n                    Cipher::subbreak(m_params, *m_freqMap, m_curResult);\n                    m_params.hint = saveHint;\n                }\n            } else {\n                m_pCur *= 1.00001;\n                //auto x = m_params.nSubbreakIterations;\n                //m_params.nSubbreakIterations = 100;\n                //Cipher::subbreak(m_params, *m_freqMap, m_curResult);\n                //m_params.nSubbreakIterations = x;\n            }\n\n            ++m_curResult.id;\n        }\n\n        return true;\n    }\n\n    const TResult & Processor::getResult() const {\n        return m_curResult;\n    }\n\n    const TSimilarityMap & Processor::getSimilarityMap() const {\n        return m_similarityMap;\n    }\n\n}\n"
        },
        {
          "name": "subbreak2.h",
          "type": "blob",
          "size": 4.9482421875,
          "content": "/*! \\file subbreak2.h\n *  \\brief Breaking non-exact substitution ciphers\n *  \\author Georgi Gerganov\n */\n\n#pragma once\n\n#include \"common.h\"\n\n#include <map>\n#include <cmath>\n#include <vector>\n#include <string>\n\nnamespace Cipher {\n\n    using TCode = int32_t;\n    using TProb = double;\n    using TGramLen = int32_t;\n    using THint = std::vector<int32_t>;\n    using TPlainText = std::vector<TLetter>;\n    using TLetterCount = std::vector<int>;\n    using TClusterCount = std::vector<int>;\n    using TClusterPos = std::vector<std::vector<int>>;\n\n    struct TParameters {\n        // clustering params\n        int minClusters = 23;\n        int maxClusters = 30;\n        int nIterationsPerUpdate = 100000;\n        int nChangePerIteration = 1;\n\n        // simulated annealing params\n        int saMaxIterations = 20000000;\n        float temp0 = 1e0;\n        float coolingRate = 0.999995;\n\n        // subbreak params\n        int nSubbreakIterations = 300;\n        TProb pNonAlphabetic = 0.0;\n\n        // Metropolis–Hastings params\n        int nMHInitialIters = 100;\n        int nMHIters = 100;\n\n        // language model\n        bool includeSpaces = true;\n        float wEnglishFreq = 10.0f;\n        float wLanguageModel = 1.0f;\n\n        // simulation parameters\n        float waveformDeviationMin = 0.1f;\n        float waveformDeviationSig = 0.2f;\n        float waveformDetectionErrorP = 0.10f;\n        float waveformDetectionErrorMin = 0.5f;\n        float waveformDetectionErrorSig = 0.4f;\n        float similarityNoiseSig = 0.1f;\n        float similarityMismatchAvg = 0.3f;\n        float similarityMismatchSig = 0.2f;\n\n        THint hint = {};\n    };\n\n    struct TFreqMap {\n        TGramLen len = -1;\n        TProb pmin = 0.0;\n        int64_t nTotal = 0;\n        std::vector<TProb> prob;\n    };\n\n    struct TResult {\n        int32_t id = 0;\n        TProb p = -100.0;\n        TClusterToLetterMap clMap;\n        TClusters clusters;\n    };\n\n    TCode calcCode(const char * data, int n);\n    bool loadFreqMap(const char * fname, TFreqMap & res);\n\n    bool encryptExact(const TParameters & params, const std::string & text, TClusters & clusters);\n    bool generateSimilarityMap(const TParameters & params, const std::string & text, TSimilarityMap & ccMap);\n\n    bool generateClusters(const TParameters & params, int n, TClusters & clusters);\n    bool printClusterGoodness(const std::string & text, const TClusters & clusters);\n\n    float costF(const TSimilarityMap & ccMap, const TClusters & clusters);\n    float costFUpdate(const TSimilarityMap & ccMap, const TClusters & clusters, int i, int cid, float c0);\n\n    bool doSimulatedAnnealing3(\n            const TParameters & params,\n            const TSimilarityMap & ccMap,\n            TClusters & clusters);\n\n    bool doSimulatedAnnealing4(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            const TClusters & clusters,\n            TClusterToLetterMap & clMap);\n\n    bool doSimulatedAnnealing5(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            const TSimilarityMap & ccMap,\n            TClusters & clusters,\n            TClusterToLetterMap & clMap);\n\n    bool subbreak(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            TResult & result);\n\n    bool subbreak1(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            TResult & result);\n\n    bool generateClustersInitialGuess(\n            const TParameters & params,\n            const TSimilarityMap & ccMap,\n            TClusters & clusters);\n\n    bool mutateClusters(const TParameters & params, TClusters & clusters);\n\n    double calcPClusters(\n            const TParameters & ,\n            const TSimilarityMap & ,\n            const TSimilarityMap & logMap,\n            const TSimilarityMap & logMapInv,\n            const TClusters & clusters,\n            const TClusterToLetterMap & clMap);\n\n    bool normalizeSimilarityMap(\n            const TParameters & ,\n            TSimilarityMap & ccMap,\n            TSimilarityMap & logMap,\n            TSimilarityMap & logMapInv);\n\n    void printText(const TClusters & t);\n    void printText(const TClusters & t, const TClusterToLetterMap & clMap);\n\n    class Processor {\n    public:\n        Processor();\n\n        bool init(\n                const TParameters & params,\n                const TFreqMap & freqMap,\n                const TSimilarityMap & similarityMap);\n\n        bool setPNonAlphabetic(TProb p);\n        bool setWEnglishFreq(float w);\n        bool setHint(const THint & hint);\n\n        bool compute();\n\n        int getIters() const { return m_nMHInitialIters; }\n        const TResult & getResult() const;\n        const TSimilarityMap & getSimilarityMap() const;\n\n    private:\n        TParameters m_params;\n        const TFreqMap* m_freqMap = nullptr;\n        TSimilarityMap m_similarityMap;\n        TSimilarityMap m_logMap;\n        TSimilarityMap m_logMapInv;\n\n        int m_nMHInitialIters = 0;\n        double m_pCur = 0.0f;\n\n        TResult m_curResult;\n    };\n}\n"
        },
        {
          "name": "subbreak3.cpp",
          "type": "blob",
          "size": 41.3876953125,
          "content": "/*! \\file subbreak3.cpp\n *  \\brief Enter description here.\n *  \\author Georgi Gerganov\n */\n\n#include \"subbreak3.h\"\n#include \"constants.h\"\n\n#include <array>\n#include <cstdlib>\n#include <fstream>\n#include <chrono>\n#include <cassert>\n#include <algorithm>\n\nnamespace {\n\n    static const std::array<float, 28> kEnglishLetterWithSpacesFreq = {\n        0.000,  // unused\n        7.228,  // a\n        1.320,  // b\n        2.462,  // c\n        3.764,\n        11.239,\n        1.972,\n        1.783,\n        5.393,\n        6.165,\n        0.135,\n        0.683,\n        3.562,\n        2.129,\n        5.973,\n        6.644,\n        1.707,\n        0.084,\n        5.298,\n        5.599,\n        8.014,\n        2.441,\n        0.866,\n        2.089,\n        0.133,\n        1.747,\n        0.065,\n        11.505, // space\n    };\n\n    static const std::array<TLetter, 256> kCharToLetter = {\n        /* { 0,   */   0 /* } */,\n        /* { 1,   */   0 /* } */,\n        /* { 2,   */   0 /* } */,\n        /* { 3,   */   0 /* } */,\n        /* { 4,   */   0 /* } */,\n        /* { 5,   */   0 /* } */,\n        /* { 6,   */   0 /* } */,\n        /* { 7,   */   0 /* } */,\n        /* { 8,   */   0 /* } */,\n        /* { 9,   */   0 /* } */,\n        /* { 10,  */   0 /* } */,\n        /* { 11,  */   0 /* } */,\n        /* { 12,  */   0 /* } */,\n        /* { 13,  */   0 /* } */,\n        /* { 14,  */   0 /* } */,\n        /* { 15,  */   0 /* } */,\n        /* { 16,  */   0 /* } */,\n        /* { 17,  */   0 /* } */,\n        /* { 18,  */   0 /* } */,\n        /* { 19,  */   0 /* } */,\n        /* { 20,  */   0 /* } */,\n        /* { 21,  */   0 /* } */,\n        /* { 22,  */   0 /* } */,\n        /* { 23,  */   0 /* } */,\n        /* { 24,  */   0 /* } */,\n        /* { 25,  */   0 /* } */,\n        /* { 26,  */   0 /* } */,\n        /* { 27,  */   0 /* } */,\n        /* { 28,  */   0 /* } */,\n        /* { 29,  */   0 /* } */,\n        /* { 30,  */   0 /* } */,\n        /* { 31,  */   0 /* } */,\n        /* { 32,  */  27 /* } */,\n        /* { 33,  */   0 /* } */,\n        /* { 34,  */   0 /* } */,\n        /* { 35,  */   0 /* } */,\n        /* { 36,  */   0 /* } */,\n        /* { 37,  */   0 /* } */,\n        /* { 38,  */   0 /* } */,\n        /* { 39,  */   0 /* } */,\n        /* { 40,  */   0 /* } */,\n        /* { 41,  */   0 /* } */,\n        /* { 42,  */   0 /* } */,\n        /* { 43,  */   0 /* } */,\n        /* { 44,  */   0 /* } */,\n        /* { 45,  */   0 /* } */,\n        /* { 46,  */   0 /* } */,\n        /* { 47,  */   0 /* } */,\n        /* { 48,  */   0 /* } */,\n        /* { 49,  */   0 /* } */,\n        /* { 50,  */   0 /* } */,\n        /* { 51,  */   0 /* } */,\n        /* { 52,  */   0 /* } */,\n        /* { 53,  */   0 /* } */,\n        /* { 54,  */   0 /* } */,\n        /* { 55,  */   0 /* } */,\n        /* { 56,  */   0 /* } */,\n        /* { 57,  */   0 /* } */,\n        /* { 58,  */   0 /* } */,\n        /* { 59,  */   0 /* } */,\n        /* { 60,  */   0 /* } */,\n        /* { 61,  */   0 /* } */,\n        /* { 62,  */   0 /* } */,\n        /* { 63,  */   0 /* } */,\n        /* { 64,  */   0 /* } */,\n        /* { 65,  */   1 /* } */,\n        /* { 66,  */   2 /* } */,\n        /* { 67,  */   3 /* } */,\n        /* { 68,  */   4 /* } */,\n        /* { 69,  */   5 /* } */,\n        /* { 70,  */   6 /* } */,\n        /* { 71,  */   7 /* } */,\n        /* { 72,  */   8 /* } */,\n        /* { 73,  */   9 /* } */,\n        /* { 74,  */  10 /* } */,\n        /* { 75,  */  11 /* } */,\n        /* { 76,  */  12 /* } */,\n        /* { 77,  */  13 /* } */,\n        /* { 78,  */  14 /* } */,\n        /* { 79,  */  15 /* } */,\n        /* { 80,  */  16 /* } */,\n        /* { 81,  */  17 /* } */,\n        /* { 82,  */  18 /* } */,\n        /* { 83,  */  19 /* } */,\n        /* { 84,  */  20 /* } */,\n        /* { 85,  */  21 /* } */,\n        /* { 86,  */  22 /* } */,\n        /* { 87,  */  23 /* } */,\n        /* { 88,  */  24 /* } */,\n        /* { 89,  */  25 /* } */,\n        /* { 90,  */  26 /* } */,\n        /* { 91,  */   0 /* } */,\n        /* { 92,  */   0 /* } */,\n        /* { 93,  */   0 /* } */,\n        /* { 94,  */   0 /* } */,\n        /* { 95,  */  27 /* } */,\n        /* { 96,  */   0 /* } */,\n        /* { 97,  */   1 /* } */,\n        /* { 98,  */   2 /* } */,\n        /* { 99,  */   3 /* } */,\n        /* { 100, */   4 /* } */,\n        /* { 101, */   5 /* } */,\n        /* { 102, */   6 /* } */,\n        /* { 103, */   7 /* } */,\n        /* { 104, */   8 /* } */,\n        /* { 105, */   9 /* } */,\n        /* { 106, */  10 /* } */,\n        /* { 107, */  11 /* } */,\n        /* { 108, */  12 /* } */,\n        /* { 109, */  13 /* } */,\n        /* { 110, */  14 /* } */,\n        /* { 111, */  15 /* } */,\n        /* { 112, */  16 /* } */,\n        /* { 113, */  17 /* } */,\n        /* { 114, */  18 /* } */,\n        /* { 115, */  19 /* } */,\n        /* { 116, */  20 /* } */,\n        /* { 117, */  21 /* } */,\n        /* { 118, */  22 /* } */,\n        /* { 119, */  23 /* } */,\n        /* { 120, */  24 /* } */,\n        /* { 121, */  25 /* } */,\n        /* { 122, */  26 /* } */,\n        /* { 123, */   0 /* } */,\n        /* { 124, */   0 /* } */,\n        /* { 125, */   0 /* } */,\n        /* { 126, */   0 /* } */,\n        /* { 127, */   0 /* } */,\n        /* { 128, */   0 /* } */,\n        /* { 129, */   0 /* } */,\n        /* { 130, */   0 /* } */,\n        /* { 131, */   0 /* } */,\n        /* { 132, */   0 /* } */,\n        /* { 133, */   0 /* } */,\n        /* { 134, */   0 /* } */,\n        /* { 135, */   0 /* } */,\n        /* { 136, */   0 /* } */,\n        /* { 137, */   0 /* } */,\n        /* { 138, */   0 /* } */,\n        /* { 139, */   0 /* } */,\n        /* { 140, */   0 /* } */,\n        /* { 141, */   0 /* } */,\n        /* { 142, */   0 /* } */,\n        /* { 143, */   0 /* } */,\n        /* { 144, */   0 /* } */,\n        /* { 145, */   0 /* } */,\n        /* { 146, */   0 /* } */,\n        /* { 147, */   0 /* } */,\n        /* { 148, */   0 /* } */,\n        /* { 149, */   0 /* } */,\n        /* { 150, */   0 /* } */,\n        /* { 151, */   0 /* } */,\n        /* { 152, */   0 /* } */,\n        /* { 153, */   0 /* } */,\n        /* { 154, */   0 /* } */,\n        /* { 155, */   0 /* } */,\n        /* { 156, */   0 /* } */,\n        /* { 157, */   0 /* } */,\n        /* { 158, */   0 /* } */,\n        /* { 159, */   0 /* } */,\n        /* { 160, */   0 /* } */,\n        /* { 161, */   0 /* } */,\n        /* { 162, */   0 /* } */,\n        /* { 163, */   0 /* } */,\n        /* { 164, */   0 /* } */,\n        /* { 165, */   0 /* } */,\n        /* { 166, */   0 /* } */,\n        /* { 167, */   0 /* } */,\n        /* { 168, */   0 /* } */,\n        /* { 169, */   0 /* } */,\n        /* { 170, */   0 /* } */,\n        /* { 171, */   0 /* } */,\n        /* { 172, */   0 /* } */,\n        /* { 173, */   0 /* } */,\n        /* { 174, */   0 /* } */,\n        /* { 175, */   0 /* } */,\n        /* { 176, */   0 /* } */,\n        /* { 177, */   0 /* } */,\n        /* { 178, */   0 /* } */,\n        /* { 179, */   0 /* } */,\n        /* { 180, */   0 /* } */,\n        /* { 181, */   0 /* } */,\n        /* { 182, */   0 /* } */,\n        /* { 183, */   0 /* } */,\n        /* { 184, */   0 /* } */,\n        /* { 185, */   0 /* } */,\n        /* { 186, */   0 /* } */,\n        /* { 187, */   0 /* } */,\n        /* { 188, */   0 /* } */,\n        /* { 189, */   0 /* } */,\n        /* { 190, */   0 /* } */,\n        /* { 191, */   0 /* } */,\n        /* { 192, */   0 /* } */,\n        /* { 193, */   0 /* } */,\n        /* { 194, */   0 /* } */,\n        /* { 195, */   0 /* } */,\n        /* { 196, */   0 /* } */,\n        /* { 197, */   0 /* } */,\n        /* { 198, */   0 /* } */,\n        /* { 199, */   0 /* } */,\n        /* { 200, */   0 /* } */,\n        /* { 201, */   0 /* } */,\n        /* { 202, */   0 /* } */,\n        /* { 203, */   0 /* } */,\n        /* { 204, */   0 /* } */,\n        /* { 205, */   0 /* } */,\n        /* { 206, */   0 /* } */,\n        /* { 207, */   0 /* } */,\n        /* { 208, */   0 /* } */,\n        /* { 209, */   0 /* } */,\n        /* { 210, */   0 /* } */,\n        /* { 211, */   0 /* } */,\n        /* { 212, */   0 /* } */,\n        /* { 213, */   0 /* } */,\n        /* { 214, */   0 /* } */,\n        /* { 215, */   0 /* } */,\n        /* { 216, */   0 /* } */,\n        /* { 217, */   0 /* } */,\n        /* { 218, */   0 /* } */,\n        /* { 219, */   0 /* } */,\n        /* { 220, */   0 /* } */,\n        /* { 221, */   0 /* } */,\n        /* { 222, */   0 /* } */,\n        /* { 223, */   0 /* } */,\n        /* { 224, */   0 /* } */,\n        /* { 225, */   0 /* } */,\n        /* { 226, */   0 /* } */,\n        /* { 227, */   0 /* } */,\n        /* { 228, */   0 /* } */,\n        /* { 229, */   0 /* } */,\n        /* { 230, */   0 /* } */,\n        /* { 231, */   0 /* } */,\n        /* { 232, */   0 /* } */,\n        /* { 233, */   0 /* } */,\n        /* { 234, */   0 /* } */,\n        /* { 235, */   0 /* } */,\n        /* { 236, */   0 /* } */,\n        /* { 237, */   0 /* } */,\n        /* { 238, */   0 /* } */,\n        /* { 239, */   0 /* } */,\n        /* { 240, */   0 /* } */,\n        /* { 241, */   0 /* } */,\n        /* { 242, */   0 /* } */,\n        /* { 243, */   0 /* } */,\n        /* { 244, */   0 /* } */,\n        /* { 245, */   0 /* } */,\n        /* { 246, */   0 /* } */,\n        /* { 247, */   0 /* } */,\n        /* { 248, */   0 /* } */,\n        /* { 249, */   0 /* } */,\n        /* { 250, */   0 /* } */,\n        /* { 251, */   0 /* } */,\n        /* { 252, */   0 /* } */,\n        /* { 253, */   0 /* } */,\n        /* { 254, */   0 /* } */,\n        /* { 255, */   0 /* } */,\n    };\n\ntemplate <typename T>\nvoid shuffle(T & t, int start = -1, int end = -1, const Cipher::THint & hint = {}) {\n    if (start == -1) start = 0;\n    if (end == -1) end = t.size();\n\n    for (int i = end - 1; i > start; --i) {\n        int i0 = i;\n        int i1 = rand()%(i - start + 1)+start;\n        if (hint.size() > 0 && (hint[i0] != -1 || hint[i1] != -1)) {\n            continue;\n        }\n        std::swap(t[i0], t[i1]);\n    }\n}\n\n}\n\nnamespace Cipher {\n    TCode calcCode(const char * data, int n) {\n        TCode res = 0;\n        do { res <<= 5; res += kCharToLetter[*data++]; } while (--n > 0);\n        return res;\n    }\n\n    bool loadFreqMap(const char * fname, TFreqMap & res, double pmin) {\n        auto & len = res.len;\n        auto & prob = res.prob;\n\n        len = 0;\n        prob.clear();\n\n        printf(\"[+] Loading n-gram file '%s'\\n\", fname);\n        std::ifstream fin(fname);\n\n        if (fin.good() == false) {\n            printf(\"    Failed to open file\\n\");\n            return false;\n        }\n\n        std::string gram;\n        int64_t nfreq = 0;\n        res.nTotal = 0;\n\n        std::unordered_map<TCode, int64_t> pi64;\n\n        while (true) {\n            fin >> gram >> nfreq;\n            if (fin.eof()) break;\n\n            if (len == 0) {\n                len = gram.size();\n            } else if (len != (int) gram.size()) {\n                printf(\"Error: loaded n-grams with vaying lengths\\n\");\n                return false;\n            }\n\n            TCode idx = calcCode(gram.data(), len);\n            if (pi64[idx] > 0) {\n                printf(\"Error: duplicate n-gram '%s'\\n\", gram.c_str());\n                return false;\n            }\n            pi64[idx] = nfreq;\n            res.nTotal += nfreq;\n        }\n        printf(\"    Total n-grams loaded = %g\\n\", (double) res.nTotal);\n\n        // compute wildcard frequencies\n        {\n            const auto tStart = std::chrono::steady_clock::now();\n\n            std::vector<int32_t> masks((1 << len) - 1);\n            for (int m = 0; m < (int) masks.size(); ++m) {\n                auto & mask = masks[m];\n\n                mask = 0;\n                int32_t l = 0b11111;\n                int32_t mm = m;\n                for (int i = 0; i < len; ++i) {\n                    if (mm & 1) {\n                        mask |= l;\n                    }\n                    mm >>= 1;\n                    l <<= 5;\n                }\n\n                // print mask in binary\n                printf(\"    Mask %2d: \", m);\n                for (int i = 0; i < 5*len; ++i) {\n                    printf(\"%d\", (mask >> (5*len - 1 - i)) & 1);\n                }\n                printf(\"\\n\");\n            }\n\n            {\n                std::unordered_map<TCode, int64_t> pwild;\n                for (const auto & [i, p] : pi64) {\n                    if (p == 0) {\n                        printf(\"i = %d, p == 0 - should not happen\\n\", i);\n                        return false;\n                    }\n\n                    for (const auto & mask : masks) {\n                        pwild[i & mask] += p;\n                    }\n                }\n\n                printf(\"Size of pwild = %d\\n\", (int) pwild.size());\n\n                for (auto & [i, p] : pwild) {\n                    pi64[i] = p;\n                }\n\n                printf(\"Size of pi64 = %d\\n\", (int) pi64.size());\n            }\n\n            if (pi64[0] != res.nTotal) {\n                printf(\"Error: wildcard probability mismatch - p[0] = %ld, expected %ld\\n\", (long) pi64[0], (long) res.nTotal);\n                return false;\n            }\n\n            const auto tEnd = std::chrono::steady_clock::now();\n            const auto tDiff = std::chrono::duration_cast<std::chrono::milliseconds>(tEnd - tStart).count();\n            printf(\"    Wildcard probabilities computed in %g ms\\n\", (double) tDiff);\n        }\n\n        // compute probabilities\n        {\n            const auto tStart = std::chrono::steady_clock::now();\n\n            res.pmin = std::log10(pmin);\n            printf(\"    P-min = %g\\n\", res.pmin);\n\n            for (auto & [i, p] : pi64) {\n                if (p == 0) {\n                    printf(\"i = %d, p == 0 - should not happen\\n\", i);\n                    return false;\n                } else {\n                    double pp = double(p)/res.nTotal;\n                    if (pp < pmin) {\n                        prob[i] = res.pmin;\n                    } else {\n                        prob[i] = std::log10(pp);\n                    }\n                }\n            }\n\n            const auto tEnd = std::chrono::steady_clock::now();\n            const auto tDiff = std::chrono::duration_cast<std::chrono::milliseconds>(tEnd - tStart).count();\n            printf(\"    Probability computation time = %g ms\\n\", (double) tDiff);\n        }\n\n        return true;\n    }\n\n    bool saveFreqMapBinary(const char * fname, const TFreqMap & freqMap) {\n        std::ofstream fout(fname, std::ios::binary);\n        if (fout.good() == false) {\n            printf(\"    Failed to open file '%s'\\n\", fname);\n            return false;\n        }\n\n        fout.write((const char *) &freqMap.len,    sizeof(freqMap.len));\n        fout.write((const char *) &freqMap.nTotal, sizeof(freqMap.nTotal));\n        fout.write((const char *) &freqMap.pmin,   sizeof(freqMap.pmin));\n\n        { int32_t n = freqMap.prob.size(); fout.write((const char *) &n, sizeof(n)); }\n\n        {\n            std::map<TCode, TProb> sorted(freqMap.prob.begin(), freqMap.prob.end());\n\n            std::vector<TCode> keys;\n            for (const auto & [i, p] : sorted) {\n                if (p == freqMap.pmin) {\n                    continue;\n                }\n                keys.push_back(i);\n            }\n\n            int32_t is = 0;\n            while (is < (int) keys.size()) {\n                fout.write((const char *) &keys[is],         sizeof(keys[is]));\n                fout.write((const char *) &sorted[keys[is]], sizeof(sorted[keys[is]]));\n\n                if (is == (int) keys.size() - 1) break;\n\n                int32_t ie = is + 1;\n                while (keys[ie] - keys[ie - 1] < 256) {\n                    ++ie;\n                    if (ie == (int) keys.size()) break;\n                    if (ie == is + 255) break;\n                }\n\n                uint8_t n = (uint8_t) (ie - is - 1);\n                fout.write((const char *) &n, sizeof(n));\n                if (n > 0) {\n                    for (int i = is + 1; i < ie; ++i) {\n                        uint8_t d = (uint8_t) (keys[i] - keys[i - 1]);\n                        fout.write((const char *) &d,               sizeof(d));\n                        fout.write((const char *) &sorted[keys[i]], sizeof(sorted[keys[i]]));\n                    }\n                }\n\n                is = ie;\n            }\n        }\n\n        return true;\n    }\n\n    bool loadFreqMapBinary(const char * fname, TFreqMap & freqMap) {\n        std::ifstream fin(fname, std::ios::binary);\n        if (fin.good() == false) {\n            printf(\"    Failed to open file '%s'\\n\", fname);\n            return false;\n        }\n\n        fin.read((char *) &freqMap.len,    sizeof(freqMap.len));\n        fin.read((char *) &freqMap.nTotal, sizeof(freqMap.nTotal));\n        fin.read((char *) &freqMap.pmin,   sizeof(freqMap.pmin));\n\n        {\n            int32_t n;\n            fin.read((char *) &n, sizeof(n));\n\n            TCode curi;\n            TProb curp;\n\n            while (n > 0) {\n                fin.read((char *) &curi, sizeof(curi));\n                fin.read((char *) &curp, sizeof(curp));\n                freqMap.prob[curi] = curp;\n\n                uint8_t n8;\n                fin.read((char *) &n8, sizeof(n8));\n\n                if (n8 > 0) {\n                    for (int i = 0; i < n8; ++i) {\n                        uint8_t d;\n                        fin.read((char *) &d,    sizeof(d));\n                        fin.read((char *) &curp, sizeof(curp));\n                        freqMap.prob[curi + d] = curp;\n                        curi += d;\n                    }\n\n                    n -= n8;\n                }\n\n                --n;\n            }\n        }\n\n        return true;\n    }\n\n    bool encryptExact(const TParameters & , const std::string & text, TClusters & clusters) {\n        auto myCharToLetter = kCharToLetter;\n\n\t\tint k = 27;\n        {\n            for (auto & p : text) {\n                if (myCharToLetter[p] == 0) {\n                    myCharToLetter[p] = ++k;\n                }\n            }\n            printf(\"[encryptExact] Unique symbols = %d\\n\", k);\n        }\n\n\t\tstd::vector<TClusterId> alphabetTransformation(k);\n\t\tfor (int i = 0; i < (int) alphabetTransformation.size(); ++i) {\n\t\t\talphabetTransformation[i] = i;\n\t\t}\n\n\t\tshuffle(alphabetTransformation);\n\n\t\tclusters.resize(text.size());\n\n\t\tfor (int i = 0; i < (int) text.size(); ++i) {\n\t\t\tassert(myCharToLetter[text[i]] > 0);\n\t\t\tclusters[i] = alphabetTransformation[myCharToLetter[text[i]] - 1] + 1;\n\t\t\tassert(clusters[i] > 0 && clusters[i] <= k);\n\t\t}\n\n        return true;\n    }\n\n    TProb calcScore(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            const std::vector<TLetter> & plain,\n                  std::vector<TProb> & memo) {\n        TProb res = 0.0;\n\n        const int n = plain.size();\n        const auto & len  = freqMap.len;\n        const auto & prob = freqMap.prob;\n\n        int nlet = 0;\n        std::array<int, 28> letCount;\n        letCount.fill(0);\n        for (int i = 0; i < n; ++i) {\n            if (plain[i] >= 0 && plain[i] <= 27) {\n                ++letCount[plain[i]];\n                ++nlet;\n            }\n        }\n\n        float letFreqCost = 0.0;\n        {\n            auto & freq = kEnglishLetterWithSpacesFreq;\n            for (int i = 0; i <= 27; ++i) {\n                float curf = 0.01*freq[i] - ((float)(letCount[i]))/((float)(nlet));\n                letFreqCost += curf*curf;\n            }\n        }\n\n        letFreqCost /= 28.0;\n        letFreqCost = sqrt(letFreqCost);\n\n        int i1 = 0;\n        int k = len;\n        TCode curc = 0;\n        TCode mask = (1 << 5*(len-1)) - 1;\n\n        while (k > 0) {\n            if (i1 >= n) return -1e100;\n            auto c = plain[i1++];\n            curc <<= 5;\n            curc += c;\n            --k;\n        }\n\n        if (memo[i1 - 1] > 0.5) {\n            memo[i1 - 1] = prob.find(curc) == prob.end() ? freqMap.pmin : prob.at(curc);\n        }\n        res += memo[i1 - 1];\n\n        while (true) {\n            curc &= mask;\n\n            auto c = plain[i1++];\n            curc <<= 5;\n            curc += c;\n\n            if (memo[i1 - 1] > 0.5) {\n                memo[i1 - 1] = prob.find(curc) == prob.end() ? freqMap.pmin : prob.at(curc);\n            }\n            res += memo[i1 - 1];\n\n            if (i1 >= n) break;\n        }\n\n        return res/n - params.wEnglishFreq*letFreqCost;\n    }\n\n    TClusterToLetterMap getNullCLMap(const TClusters & clusters) {\n        TClusterToLetterMap result;\n\n        for (int i = 0; i < (int) clusters.size(); ++i) {\n            result[clusters[i]] = 0;\n        }\n\n        return result;\n    }\n\n    void translate(\n            const TClusterToLetterMap & clMap,\n            const TClusters & clusters,\n            std::vector<TLetter> & plain) {\n        plain.clear();\n        for (int i = 0; i < (int) clusters.size(); ++i) {\n            plain.push_back(clMap.at(clusters[i]));\n        }\n    }\n\n    bool beamSearch(\n        const TParameters & params,\n        const TFreqMap & freqMap,\n        TResult & result) {\n        const auto & clusters = result.clusters;\n\n        struct THypothesis {\n            TProb p;\n            TClusterToLetterMap clMap;\n            std::vector<TLetter> plain;\n            std::vector<int> nused;\n            std::vector<TProb> memo;\n        };\n\n        const int N = clusters.size();\n        const int nSymbols = 27;\n        const int nHypothesesToKeep = params.nHypothesesToKeep;\n\n        int nCur = 0;\n        std::vector<THypothesis> hypothesesCur;\n        std::vector<THypothesis> hypothesesNew;\n        hypothesesCur.resize(nHypothesesToKeep);\n        hypothesesNew.resize(nHypothesesToKeep*nSymbols);\n\n        {\n            auto & hcur = hypothesesCur[0];\n            hcur = { 0.0, getNullCLMap(clusters), {}, std::vector<int>(nSymbols + 1, 0), {}};\n            for (int i = 0; i < (int) params.hint.size(); ++i) {\n                if (params.hint[i] != -1) {\n                    if (frand() > 0.5) {\n                        hcur.clMap[clusters[i]] = params.hint[i];\n                    }\n                }\n            }\n            translate(hcur.clMap, clusters, hcur.plain);\n            hcur.memo.resize(N, 1.0);\n            hcur.p = calcScore(params, freqMap, hcur.plain, hcur.memo);\n            ++nCur;\n        }\n\n        // sorted clusters by frequency\n        std::vector<std::pair<TClusterId, std::vector<int>>> sorted;\n\n        {\n            std::map<TClusterId, std::vector<int>> counts;\n            for (int i = 0; i < (int) clusters.size(); ++i) {\n                counts[clusters[i]].push_back(i);\n            }\n\n            for (auto & kv : counts) {\n                sorted.push_back(std::make_pair(kv.first, kv.second));\n            }\n            std::sort(sorted.begin(), sorted.end(), [](const auto & a, const auto & b) {\n                return a.second.size() > b.second.size();\n            });\n        }\n\n        for (int i = 0; i < (int) sorted.size(); ++i) {\n            auto & kvSorted = sorted[i];\n            if (kvSorted.second.empty()) break;\n\n            //printf(\"Processing cluster %2d ('%c') - count = %d\\n\", kvSorted.first, getEncodedChar(kvSorted.first), (int) kvSorted.second.size());\n\n            if (hypothesesCur[0].clMap.at(kvSorted.first) != 0) {\n                continue;\n            }\n\n            int nNew = 0;\n            for (int j = 0; j < nCur; ++j) {\n                const auto & hcur = hypothesesCur[j];\n\n                for (int a = 1; a <= nSymbols; ++a) {\n                    // TODO: maybe become parameter\n                    // how many clusters can map to the same symbol\n                    if (hcur.nused[a] > 20) continue;\n\n                    auto & hnew = hypothesesNew[nNew++];\n\n                    hnew = hcur;\n                    hnew.nused[a]++;\n                    for (int k = 0; k < (int) kvSorted.second.size(); ++k) {\n                        const auto idx = kvSorted.second[k];\n                        hnew.plain[idx] = a;\n\n                        const auto idx0 = std::max(0, idx - freqMap.len + 1);\n                        const auto idx1 = std::min(N - 1, idx + freqMap.len - 1);\n                        std::fill(hnew.memo.begin() + idx0, hnew.memo.begin() + idx1 + 1, 1.0);\n                    }\n                    hnew.clMap[kvSorted.first] = a;\n                    hnew.p = calcScore(params, freqMap, hnew.plain, hnew.memo);\n                }\n            }\n\n            // sort hypothesesNew by p\n            {\n                std::vector<std::pair<int, TProb>> sortedNew;\n                for (int j = 0; j < nNew; ++j) {\n                    sortedNew.push_back(std::make_pair(j, hypothesesNew[j].p));\n                }\n                std::sort(sortedNew.begin(), sortedNew.end(), [](const auto & a, const auto & b) {\n                    return a.second > b.second;\n                });\n\n                //printf(\"Top p = %g\\n\", (double) hypothesesNew[sortedNew[0].first].p);\n                //printDecoded(clusters, hypothesesNew[sortedNew[0].first].clMap);\n\n                nCur = std::min(nHypothesesToKeep, nNew);\n                for (int j = 0; j < nCur; ++j) {\n                    hypothesesCur[j] = std::move(hypothesesNew[sortedNew[j].first]);\n                }\n            }\n        }\n\n        result.clMap = hypothesesCur[0].clMap;\n        result.p = hypothesesCur[0].p;\n\n        return true;\n    }\n\n    bool refineNearby(\n        const TParameters & params,\n        const TFreqMap & freqMap,\n        TResult & result) {\n\n        const int N = result.clusters.size();\n\n        struct THypothesis {\n            TProb p;\n            TClusterToLetterMap clMap;\n            std::vector<TLetter> plain;\n            std::vector<TProb> memo;\n        };\n\n        {\n            THypothesis hcur;\n            hcur = { 0.0, result.clMap, {}, {}};\n            translate(hcur.clMap, result.clusters, hcur.plain);\n            for (int i = 0; i < (int) params.hint.size(); ++i) {\n                if (params.hint[i] != -1) {\n                    hcur.plain[i] = params.hint[i];\n                }\n            }\n            hcur.memo.resize(N, 1.0);\n            hcur.p = calcScore(params, freqMap, hcur.plain, hcur.memo);\n\n            THypothesis hbest = hcur;\n            while (true) {\n                bool converged = true;\n\n                hcur = hbest;\n                for (int i = 0; i < N; ++i) {\n                    if (hcur.plain[i] < 1 || hcur.plain[i] > 26) continue;\n                    auto hnew = hcur;\n                    for (int k = 1; k < (int) kNearbyKeys.at('a' + hcur.plain[i] - 1).size(); ++k) {\n                        hnew.plain[i] = kNearbyKeys.at('a' + hcur.plain[i] - 1)[k] - 'a' + 1;\n                        const auto idx0 = std::max(0, i - freqMap.len + 1);\n                        const auto idx1 = std::min(N - 1, i + freqMap.len - 1);\n                        std::fill(hnew.memo.begin() + idx0, hnew.memo.begin() + idx1 + 1, 1.0);\n                        hnew.p = calcScore(params, freqMap, hnew.plain, hnew.memo);\n                        if (hbest.p < hnew.p) {\n                            hbest = hnew;\n                            converged = false;\n                        }\n                    }\n                }\n\n                if (converged) break;\n            }\n\n            printPlain(hbest.plain);\n            printf(\" [%8.3f %8.3f]\", (double) hbest.p, (double) result.p);\n        }\n\n        return true;\n    }\n\n    bool generateClustersInitialGuess(\n            const TParameters & params,\n            const TSimilarityMap & ccMap,\n            TClusters & clusters) {\n        int n = ccMap.size();\n\n        int nClusters = n;\n        clusters.resize(n);\n        for (int i = 0; i < n; ++i) {\n            clusters[i] = i;\n        }\n\n        struct Pair {\n            int i;\n            int j;\n            double cc;\n\n            bool operator < (const Pair & a) const { return cc > a.cc; }\n        };\n\n        std::vector<Pair> ccPairs;\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                ccPairs.emplace_back(Pair{i, j, ccMap[i][j].cc});\n            }\n        }\n\n        std::sort(ccPairs.begin(), ccPairs.end());\n\n        {\n            std::vector<bool> used(n);\n\n            for (int k = 0; k < (int) ccPairs.size(); ++k) {\n                int i = ccPairs[k].i;\n                int j = ccPairs[k].j;\n\n                if (clusters[i] == clusters[j]) continue;\n\n                int cidi = clusters[i];\n                int cidj = clusters[j];\n\n                if (used[cidi] || used[cidj]) continue;\n\n                if (cidi > cidj) {\n                    std::swap(cidi, cidj);\n                }\n\n                for (int p = 0; p < n; ++p) {\n                    if (clusters[p] == cidj) {\n                        clusters[p] = cidi;\n                    }\n                }\n                used[cidj] = true;\n                --nClusters;\n\n                if (nClusters <= params.maxClusters) break;\n            }\n        }\n\n        {\n            int cnt = 0;\n            std::map<int, int> used;\n            for (auto & cid : clusters) {\n                if (used[cid] > 0) continue;\n                used[cid] = ++cnt;\n            }\n\n            for (auto & cid : clusters) {\n                cid = used[cid] - 1;\n            }\n        }\n\n        //printf(\"nClusters = %d\\n\", nClusters);\n        for (auto & cid : clusters) {\n            assert(cid >= 0 && cid < params.maxClusters);\n        }\n\n        return true;\n    }\n\n    bool mutateClusters(const TParameters & params, TClusters & clusters) {\n        int n = clusters.size();\n\n        for (int i = 0; i < 1; ++i) {\n            int idx = rand()%n;\n\n            auto old = clusters[idx];\n            do {\n                clusters[idx] = 1 + rand()%(params.maxClusters - 1);\n            } while (clusters[idx] == old);\n        }\n\n        return true;\n    }\n\n    double calcPClusters(\n            const TParameters & ,\n            const TSimilarityMap & ,\n            const TSimilarityMap & logMap,\n            const TSimilarityMap & logMapInv,\n            const TClusters & clusters,\n            const TClusterToLetterMap & ) {\n\n        double res = 0.0;\n        int n = clusters.size();\n\n        for (int j = 0; j < n - 1; ++j) {\n            for (int i = j + 1; i < n; ++i) {\n                if (clusters[i] == clusters[j]) {\n                    res += logMap[j][i].cc;\n                } else {\n                    res += logMapInv[j][i].cc;\n                }\n            }\n        }\n\n        return res/((n*(n-1))/2.0);\n    }\n\n    bool normalizeSimilarityMap(\n            const TParameters & params,\n            TSimilarityMap & ccMap,\n            TSimilarityMap & logMap,\n            TSimilarityMap & logMapInv) {\n        int n = ccMap.size();\n\n        double ccMin = std::numeric_limits<double>::max();\n        double ccMax = std::numeric_limits<double>::min();\n\n        for (int j = 0; j < n - 1; ++j) {\n            for (int i = j + 1; i < n; ++i) {\n                ccMin = std::min(ccMin, ccMap[j][i].cc);\n                ccMax = std::max(ccMax, ccMap[j][i].cc);\n            }\n        }\n\n        ccMin -= 1e-6;\n        ccMax += 1e-6;\n\n        //printf(\"ccMax = %g, ccMin = %g\\n\", ccMax, ccMin);\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i < n; ++i) {\n                if (i == j) {\n                    ccMap[j][i].cc = 1.0;\n                    continue;\n                }\n\n                auto & v = ccMap[j][i].cc;\n                v = (v - ccMin)/(ccMax - ccMin);\n                v = std::pow(v, params.fSpread);\n                //if (v < 0.50) {\n                //    v = 1e-6;\n                //}\n                //v = 1.0 - std::exp(-1.1f*v);\n            }\n        }\n\n        logMap = ccMap;\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i < n; ++i) {\n                if (i == j) {\n                    logMap[j][i].cc = 0.0;\n                    continue;\n                }\n\n                auto & v = logMap[j][i].cc;\n                v = std::log(v);\n            }\n        }\n\n        logMapInv = ccMap;\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i < n; ++i) {\n                if (i == j) {\n                    logMap[j][i].cc = -1e6;\n                    continue;\n                }\n\n                auto & v = logMapInv[j][i].cc;\n                v = std::log(1.0 - v);\n            }\n        }\n\n        return true;\n    }\n\n    char getEncodedChar(TClusterId cid) {\n        if (cid >= 1 && cid <= 26) {\n            return 'a' + cid - 1;\n        } else if (cid == 27) {\n            return '_';\n        }\n\n        return 'A' + cid - 28;\n    }\n\n    TLetter decode(const TClusters & t, int idx, const TClusterToLetterMap & clMap, const THint & hint) {\n        const auto & cid = t[idx];\n        auto let = clMap.at(cid);\n        if ((int) hint.size() > idx && hint[idx] != -1) {\n            let = hint[idx];\n        }\n\n        return let;\n    }\n\n    void printEncoded(const TClusters & t) {\n        for (const auto & cid : t) {\n            printf(\"%c\", getEncodedChar(cid));\n        }\n    }\n\n    void printDecoded(const TClusters & t, const TClusterToLetterMap & clMap, const THint & hint) {\n        for (int i = 0; i < (int) t.size(); ++i) {\n            const auto let = decode(t, i, clMap, hint);\n\n            if (let >= 1 && let <= 26) {\n                printf(\"%c\", 'a' + let - 1);\n            } else if (let == 27) {\n                printf(\"_\");\n            } else {\n                printf(\".\");\n            }\n        }\n    }\n\n    void printPlain(const std::vector<TLetter> & t) {\n        for (int i = 0; i < (int) t.size(); ++i) {\n            const auto let = t[i];\n\n            if (let >= 1 && let <= 26) {\n                printf(\"%c\", 'a' + let - 1);\n            } else if (let == 27) {\n                printf(\"_\");\n            } else {\n                printf(\".\");\n            }\n        }\n    }\n\n    //\n    // Processor\n    //\n\n    Processor::Processor() {\n    }\n\n    bool Processor::init(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            const TSimilarityMap & similarityMap) {\n        m_params = params;\n        m_freqMap = &freqMap;\n        m_similarityMap = similarityMap;\n        m_curResult = {};\n\n        normalizeSimilarityMap(m_params, m_similarityMap, m_logMap, m_logMapInv);\n        generateClustersInitialGuess(m_params, m_similarityMap, m_curResult.clusters);\n\n        //Cipher::beamSearch(m_params, *m_freqMap, m_curResult);\n        m_nInitialIters = 0;\n        m_pCur = calcPClusters(m_params, m_similarityMap, m_logMap, m_logMapInv, m_curResult.clusters, m_curResult.clMap);\n        m_curResult.pClusters = m_pCur;\n        m_pZero = m_pCur;\n\n        return true;\n    }\n\n    bool Processor::setHint(const THint & hint) {\n        m_params.hint = hint;\n\n        return true;\n    }\n\n    std::vector<TResult> Processor::getClusterings(int nClusterings) {\n        const auto p0 = m_curResult.pClusters;\n        //printf(\"    [getClusterings] p0 = %g\\n\", p0);\n\n        int nNoImprovement = 0;\n        int nTotalIterations = 0;\n        auto clustersNew = m_curResult.clusters;\n        const int n = clustersNew.size();\n\n        std::vector<TResult> all;\n        all.push_back(m_curResult);\n\n        // simulated annealing\n        double T = m_params.temp0;\n        const double TMin = 0.000001;\n        const double alpha = m_params.coolingRate;\n        const double pScale = ((n*(n-1))/2.0);\n\n        while (true) {\n            clustersNew = m_curResult.clusters;\n\n            // mutate\n            int idxChanged = -1;\n            {\n                idxChanged = rand()%n;\n\n                auto old = clustersNew[idxChanged];\n                do {\n                    clustersNew[idxChanged] = 1 + rand()%(m_params.maxClusters - 1);\n                } while (clustersNew[idxChanged] == old);\n            }\n\n            // compute pNew\n            auto pNew = m_pCur*pScale;\n            {\n                const int j = idxChanged;\n                for (int i = 0; i < n; ++i) {\n                    if (i == j) {\n                        continue;\n                    }\n\n                    if (m_curResult.clusters[i] == m_curResult.clusters[j]) {\n                        pNew -= m_logMap[j][i].cc;\n                    } else {\n                        pNew -= m_logMapInv[j][i].cc;\n                    }\n\n                    if (clustersNew[i] == clustersNew[j]) {\n                        pNew += m_logMap[j][i].cc;\n                    } else {\n                        pNew += m_logMapInv[j][i].cc;\n                    }\n                }\n\n                pNew /= pScale;\n            }\n\n            // check if we should accept the new value\n            if (pNew >= m_pCur) {\n                m_curResult.clusters = clustersNew;\n                m_curResult.pClusters = pNew;\n                m_pCur = pNew;\n            } else {\n                // accept with probability\n                const auto pAccept = std::exp((pNew - m_pCur)/T);\n                if (pAccept > frand()) {\n                    //printf(\"    [getClusterings] N = %5d, T = %8.8f, pNew = %g, pCur = %g, pAccept = %g\\n\", nNoImprovement, T, pNew, m_pCur, pAccept);\n                    m_curResult.clusters = clustersNew;\n                    m_curResult.pClusters = pNew;\n                    m_pCur = pNew;\n                }\n            }\n\n            // check if we should stop\n            if (m_pCur > all.back().pClusters) {\n                all.push_back(m_curResult);\n                nNoImprovement = 0;\n            } else {\n                nNoImprovement += 1;\n            }\n\n            // update temperature\n            nTotalIterations++;\n            if (nTotalIterations % 1000 == 0) {\n                T = T * alpha;\n                if (T < TMin) {\n                    T = TMin;\n                }\n                //printf(\"    [getClusterings] T = %g\\n\", T);\n            }\n\n            if (nNoImprovement > 1000 && T < 2*TMin) {\n                break;\n            }\n        }\n\n        //printf(\"    [getClusterings] nTotalIterations = %d\\n\", nTotalIterations);\n        //printf(\"    [getClusterings] pFinal = %g\\n\", m_curResult.pClusters);\n\n        const auto pClustersBest = all.back().pClusters;\n\n        std::vector<TResult> result;\n        {\n            result.push_back(all.back());\n\n            for (int i = 1; i < nClusterings; ++i) {\n                int jBest = -1;\n                double pDiffMax = -1.0;\n                for (int j = 5*all.size()/6; j < (int) all.size(); ++j) {\n                    if (all[j].pClusters < 1.1*pClustersBest) {\n                        continue;\n                    }\n                    double pDiffMin = std::numeric_limits<double>::max();\n                    for (int k = 0; k < (int) result.size(); ++k) {\n                        double pDiff = std::fabs(all[j].pClusters - result[k].pClusters);\n                        if (pDiffMin > pDiff) {\n                            pDiffMin = pDiff;\n                        }\n                    }\n                    if (pDiffMax < pDiffMin) {\n                        pDiffMax = pDiffMin;\n                        jBest = j;\n                    }\n                }\n\n                if (pDiffMax < 0.005 || jBest == -1) {\n                    break;\n                }\n\n                result.push_back(all[jBest]);\n            }\n        }\n\n        std::sort(result.begin(), result.end(), [](const TResult & a, const TResult & b) {\n            return a.pClusters > b.pClusters;\n        });\n\n        return result;\n    }\n\n    bool Processor::compute() {\n        auto clusterings = getClusterings(1);\n        m_curResult = clusterings[0];\n        Cipher::beamSearch(m_params, *m_freqMap, m_curResult);\n        m_curResult.id++;\n\n        return true;\n    }\n\n    const TResult & Processor::getResult() const {\n        return m_curResult;\n    }\n\n    const TSimilarityMap & Processor::getSimilarityMap() const {\n        return m_similarityMap;\n    }\n\n    float findBestCutoffFreq(const TWaveformF & waveform, EAudioFilter filterId, int64_t sampleRate, float minCutoffFreq_Hz, float maxCutoffFreq_Hz, float step_Hz) {\n        double pClustersBest = -1e10;\n        float freqCutoffBest_Hz = minCutoffFreq_Hz;\n\n        for (float freqCutoff_Hz = minCutoffFreq_Hz; freqCutoff_Hz <= maxCutoffFreq_Hz; freqCutoff_Hz += step_Hz) {\n            TWaveformI16 waveformInput;\n            TWaveformF waveformFiltered = waveform;\n            filter(waveformFiltered, (EAudioFilter) filterId, freqCutoff_Hz, sampleRate);\n\n            if (convert(waveformFiltered, waveformInput) == false) {\n                fprintf(stderr, \"%s:%d: convert() failed\\n\", __FILE__, __LINE__);\n                return minCutoffFreq_Hz;\n            }\n\n            TKeyPressCollectionI16 keyPresses;\n            {\n                TWaveformI16 waveformMax;\n                TWaveformI16 waveformThreshold;\n                if (findKeyPresses(getView(waveformInput, 0), keyPresses, waveformThreshold, waveformMax,\n                                   kFindKeysThreshold, kFindKeysHistorySize, kFindKeysHistorySizeReset, kFindKeysRemoveLowPower) == false) {\n                    fprintf(stderr, \"%s:%d: findKeyPresses() failed\\n\", __FILE__, __LINE__);\n                    return minCutoffFreq_Hz;\n                }\n            }\n\n            TSimilarityMap similarityMap;\n            if (calculateSimilartyMap(kKeyWidth_samples, kKeyAlign_samples, kKeyWidth_samples - kKeyOffset_samples, keyPresses, similarityMap) == false) {\n                fprintf(stderr, \"%s:%d: calculateSimilartyMap() failed\\n\", __FILE__, __LINE__);\n                return minCutoffFreq_Hz;\n            }\n\n            {\n                Cipher::TFreqMap freqMap; // not used for anything\n                Cipher::Processor processor;\n\n                Cipher::TParameters params;\n                params.maxClusters = 50;\n                params.wEnglishFreq = 20.0;\n                processor.init(params, freqMap, similarityMap);\n\n                auto clusteringsCur = processor.getClusterings(1);\n                if (clusteringsCur[0].pClusters > pClustersBest) {\n                    pClustersBest = clusteringsCur[0].pClusters;\n                    freqCutoffBest_Hz = freqCutoff_Hz;\n                }\n                printf(\"    [findBestCutoffFreq] freqCutoff_Hz = %g, pClusters = %g\\n\", freqCutoff_Hz, clusteringsCur[0].pClusters);\n            }\n        }\n\n        return freqCutoffBest_Hz;\n    }\n\n}\n"
        },
        {
          "name": "subbreak3.h",
          "type": "blob",
          "size": 4.0810546875,
          "content": "/*! \\file subbreak3.h\n *  \\brief Breaking non-exact substitution ciphers\n *  \\author Georgi Gerganov\n */\n\n#pragma once\n\n#include \"common.h\"\n\n#include <map>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nnamespace Cipher {\n\n    using TCode = int32_t;\n    using TProb = float;\n    using TGramLen = int32_t;\n    using THint = std::vector<int32_t>;\n    using TPlainText = std::vector<TLetter>;\n    using TLetterCount = std::vector<int>;\n    using TClusterCount = std::vector<int>;\n    using TClusterPos = std::vector<std::vector<int>>;\n\n    struct TParameters {\n        // clustering params\n        int minClusters = 23;\n        int maxClusters = 32;\n        int nInitialIters = 1000;\n        int nIters = 100;\n        double fSpread = 1.0;\n\n        // simulated annealing params\n        float temp0 = 0.0001;\n        float coolingRate = 0.95;\n\n        // language model\n        float wEnglishFreq = 10.0f;\n\n        // beam search\n        int nHypothesesToKeep = 500;\n\n        THint hint = {};\n    };\n\n    struct TFreqMap {\n        TGramLen len = -1;\n        int64_t nTotal = 0;\n        TProb pmin = 0;\n        std::unordered_map<TCode, TProb> prob;\n    };\n\n    struct TResult {\n        int32_t id = 0;\n        TProb p = -999.0;\n        double pClusters = -999.0;\n        TClusterToLetterMap clMap;\n        TClusters clusters;\n    };\n\n    TCode calcCode(const char * data, int n);\n\n    // n-grams with lower probability than pmin are assigned cost = log10(pmin)\n    bool loadFreqMap(const char * fname, TFreqMap & res, double pmin = 0.000001);\n\n    bool saveFreqMapBinary(const char * fname, const TFreqMap & res);\n    bool loadFreqMapBinary(const char * fname, TFreqMap & res);\n\n    bool encryptExact(const TParameters & params, const std::string & text, TClusters & clusters);\n\n    bool beamSearch(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            TResult & result);\n\n    bool refineNearby(\n            const TParameters & params,\n            const TFreqMap & freqMap,\n            TResult & result);\n\n    bool generateClustersInitialGuess(\n            const TParameters & params,\n            const TSimilarityMap & ccMap,\n            TClusters & clusters);\n\n    bool mutateClusters(const TParameters & params, TClusters & clusters);\n\n    double calcPClusters(\n            const TParameters & ,\n            const TSimilarityMap & ,\n            const TSimilarityMap & logMap,\n            const TSimilarityMap & logMapInv,\n            const TClusters & clusters,\n            const TClusterToLetterMap & clMap);\n\n    bool normalizeSimilarityMap(\n            const TParameters & ,\n            TSimilarityMap & ccMap,\n            TSimilarityMap & logMap,\n            TSimilarityMap & logMapInv);\n\n    char getEncodedChar(TClusterId);\n\n    TLetter decode(const TClusters & t, int idx, const TClusterToLetterMap & clMap, const THint & hint);\n\n    void printEncoded(const TClusters & t);\n    void printDecoded(const TClusters & t, const TClusterToLetterMap & clMap, const THint & hint);\n    void printPlain(const std::vector<TLetter> & t);\n\n    class Processor {\n    public:\n        Processor();\n\n        bool init(\n                const TParameters & params,\n                const TFreqMap & freqMap,\n                const TSimilarityMap & similarityMap);\n\n        bool setHint(const THint & hint);\n\n        std::vector<TResult> getClusterings(int nClusterings);\n        bool compute();\n\n        int getIters() const { return m_nInitialIters; }\n        const TResult & getResult() const;\n        const TSimilarityMap & getSimilarityMap() const;\n\n    private:\n        TParameters m_params;\n        const TFreqMap* m_freqMap = nullptr;\n        TSimilarityMap m_similarityMap;\n        TSimilarityMap m_logMap;\n        TSimilarityMap m_logMapInv;\n\n        int m_nInitialIters = 0;\n        double m_pCur = 0.0f;\n        double m_pZero = 0.0f;\n\n        TResult m_curResult;\n    };\n\n    float findBestCutoffFreq(\n            const TWaveformF & waveform,\n            EAudioFilter filterId,\n            int64_t sampleRate,\n            float minCutoffFreq_Hz,\n            float maxCutoffFreq_Hz,\n            float step_Hz);\n}\n"
        },
        {
          "name": "test-subbreak3.cpp",
          "type": "blob",
          "size": 1.7001953125,
          "content": "#include \"subbreak3.h\"\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s n-gram.txt\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    Cipher::TFreqMap freqMap;\n\n    if (Cipher::loadFreqMapBinary((std::string(argv[1]) + \".binary\").c_str(), freqMap) == false) {\n        if (Cipher::loadFreqMap(argv[1], freqMap) == false) {\n            return -1;\n        }\n\n        Cipher::saveFreqMapBinary((std::string(argv[1]) + \".binary\").c_str(), freqMap);\n    }\n\n    //if (Cipher::loadFreqMap(argv[1], freqMap) == false) {\n    //    return -1;\n    //}\n\n    std::string plain = R\"(\nDave found joy in the daily routine of life. He awoke at the same time, ate the same breakfast and drove the same commute. He worked at a job that never seemed to change and he got home at 6 pm sharp every night. It was who he had been for the last ten years and he had no idea that was all about to change.\n    )\";\n\n    Cipher::TParameters params;\n    Cipher::TResult result;\n\n    Cipher::encryptExact(params, plain, result.clusters);\n    Cipher::printEncoded(result.clusters);\n\n    {\n        std::map<TClusterId, char> answer;\n        for (int i = 0; i < (int) result.clusters.size(); ++i) {\n            answer[result.clusters[i]] = plain[i];\n        }\n\n        for (auto & p : answer) {\n            printf(\"  answer: '%c' -> '%c'\\n\", Cipher::getEncodedChar(p.first), p.second);\n        }\n    }\n\n    {\n        auto tStart = std::chrono::high_resolution_clock::now();\n\n        Cipher::beamSearch(params, freqMap, result);\n\n        auto tEnd = std::chrono::high_resolution_clock::now();\n        auto tDiff = std::chrono::duration_cast<std::chrono::milliseconds>(tEnd - tStart);\n        printf(\"Time: %ld ms\\n\", tDiff.count());\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "view-full-gui.cpp",
          "type": "blob",
          "size": 13.216796875,
          "content": "/*! \\file view-full-gui.cpp\n *  \\brief Visualize data recorded with record-full\n *  \\author Georgi Gerganov\n */\n\n#ifdef __EMSCRIPTEN__\n#include \"emscripten.h\"\n#else\n#define EMSCRIPTEN_KEEPALIVE\n#endif\n\n#include \"common.h\"\n#include \"common-gui.h\"\n#include \"constants.h\"\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#include <SDL.h>\n\n#include <chrono>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <thread>\n#include <functional>\n\nstatic std::function<bool()> g_doInit;\nstatic std::function<bool()> g_mainUpdate;\n\nvoid mainUpdate(void *) {\n    g_mainUpdate();\n}\n\n// JS interface\n\nextern \"C\" {\n    EMSCRIPTEN_KEEPALIVE\n        int doInit() {\n            return g_doInit();\n        }\n}\n\n// globals\n#ifdef __EMSCRIPTEN__\nint g_windowSizeX = 1200;\nint g_windowSizeY = 400;\n#else\nint g_windowSizeX = 1600;\nint g_windowSizeY = 400;\n#endif\n\nstruct stParameters;\n\nusing TParameters           = stParameters;\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TPlaybackData         = TPlaybackDataI16;\n\nSDL_AudioDeviceID g_deviceIdOut = 0;\nTPlaybackData g_playbackData;\n\nstruct stParameters {\n    int playbackId              = 0;\n    int keyPressWidth_samples   = 256;\n    int sampleRate              = kSampleRate;\n    int offsetFromPeak          = keyPressWidth_samples/2;\n    int alignWindow             = 256;\n    float thresholdClustering   = 0.5f;\n};\n\nfloat plotWaveform(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return waveform->samples[i];\n}\n\nfloat plotWaveformInverse(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return -waveform->samples[i];\n}\n\nbool renderWaveform(TParameters & , const TWaveform & waveform) {\n    ImGui::SetNextWindowPos(ImVec2(0, 0));\n    ImGui::SetNextWindowSize(ImVec2(g_windowSizeX, g_windowSizeY));\n    if (ImGui::Begin(\"Waveform\", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove)) {\n        int viewMin = 512;\n        int viewMax = waveform.size();\n\n        static int nview = waveform.size();\n        static int offset = (waveform.size() - nview)/2;\n        static float amin = std::numeric_limits<TSample>::min();\n        static float amax = std::numeric_limits<TSample>::max();\n        static float dragOffset = 0.0f;\n        static float scrollSize = 18.0f;\n\n        static auto nviewPrev = nview + 1;\n\n        static TWaveform waveformLowRes = waveform;\n        static TWaveform waveformThreshold = waveform;\n\n        auto wview = getView(waveformLowRes, offset, nview);\n        auto wsize = ImGui::GetContentRegionAvail();\n        wsize.y -= 50.0f;\n\n        auto mpos = ImGui::GetIO().MousePos;\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.3f, 0.3f, 0.3f, 0.3f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveformInverse, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.1f, 0.1f, 0.1f, 0.0f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveform, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::InvisibleButton(\"##WaveformIB\",wsize);\n        if (ImGui::IsItemHovered()) {\n            auto w = ImGui::GetIO().MouseWheel;\n            auto nview_old = nview;\n            nview *= (10.0 + w)/10.0;\n            nview = std::min(std::max(viewMin, nview), viewMax);\n            if (w != 0.0) {\n                offset = std::max(0.0f, offset + ((mpos.x - savePos.x)/wsize.x)*(nview_old - nview));\n            }\n\n            if (ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0) == false) {\n                dragOffset = offset;\n            }\n\n            if (ImGui::IsMouseDragging(0)) {\n                offset = dragOffset - ImGui::GetMouseDragDelta(0).x*nview/wsize.x;\n            }\n        }\n        if (ImGui::BeginPopupContextWindow()) {\n            ImGui::SliderInt(\"View  \", &nview, viewMin, viewMax);\n            ImGui::DragInt  (\"Offset\", &offset, 0.01*nview, 0, waveform.size() - nview);\n            ImGui::SliderFloat(\"Amplitude Min\", &amin, std::numeric_limits<TSample>::min(), 0);\n            ImGui::SliderFloat(\"Amplitude Max\", &amax, 0, std::numeric_limits<TSample>::max());\n            ImGui::EndPopup();\n        }\n\n        ImGui::InvisibleButton(\"##WaveformScrollIB\", {wsize.x, scrollSize});\n        drawList->AddRect({savePos.x, savePos.y + wsize.y}, {savePos.x + wsize.x, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n        drawList->AddRectFilled({savePos.x + wsize.x*(1.f*offset)/viewMax, savePos.y + wsize.y}, {savePos.x + wsize.x*(1.f*offset + nview)/viewMax, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n\n        auto savePos2 = ImGui::GetCursorScreenPos();\n\n        static bool scrolling = false;\n        if (ImGui::IsItemHovered()) {\n            if (ImGui::IsMouseDown(0)) {\n                scrolling = true;\n            }\n        }\n\n        if (scrolling) {\n            offset = ((mpos.x - savePos.x)/wsize.x)*viewMax - nview/2;\n        }\n\n        if (ImGui::IsMouseDown(0) == false) {\n            scrolling = false;\n        }\n\n        offset = std::max(0, std::min((int) offset, (int) waveform.size() - nview));\n\n        {\n            float x0 = ((float)(g_playbackData.offset + g_playbackData.idx - offset))/nview;\n\n            ImVec2 p0 = {savePos.x + x0*wsize.x, savePos.y};\n            ImVec2 p1 = {savePos.x + x0*wsize.x, savePos.y + wsize.y};\n            drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 0.0f, 0.3f }));\n        }\n\n        ImGui::SetCursorScreenPos(savePos2);\n\n        //auto io = ImGui::GetIO();\n        //ImGui::Text(\"Keys pressed:\");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text(\"%d\", i); }\n\n        static bool playHalfSpeed = false;\n        ImGui::PushItemWidth(100.0);\n\n        ImGui::Checkbox(\"x0.5\", &playHalfSpeed);\n        ImGui::SameLine();\n        if (g_playbackData.playing) {\n            if (ImGui::Button(\"Stop\") || ImGui::IsKeyPressed(44)) { // space\n                g_playbackData.playing = false;\n                g_playbackData.idx = g_playbackData.waveform.n - TPlaybackData::kSamples;\n            }\n        } else {\n            if (ImGui::Button(\"Play\") || ImGui::IsKeyPressed(44)) { // space\n                g_playbackData.playing = true;\n                g_playbackData.slowDown = playHalfSpeed ? 2 : 1;\n                g_playbackData.idx = 0;\n                g_playbackData.offset = offset;\n                g_playbackData.waveform = getView(waveform, offset, nview);\n                SDL_PauseAudioDevice(g_deviceIdOut, 0);\n            }\n        }\n\n        if (g_playbackData.idx >= g_playbackData.waveform.n) {\n            g_playbackData.playing = false;\n            SDL_ClearQueuedAudio(g_deviceIdOut);\n#ifndef __EMSCRIPTEN__\n            SDL_PauseAudioDevice(g_deviceIdOut, 1);\n#endif\n        }\n\n        ImGui::PopItemWidth();\n\n        if (nview != nviewPrev) {\n            generateLowResWaveform(waveform, waveformLowRes, std::max(1.0f, nview/wsize.x));\n            nviewPrev = nview;\n        }\n    }\n    ImGui::End();\n\n    return false;\n}\n\nbool prepareAudioOut(const TParameters & params) {\n    if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_FALSE);\n    printf(\"Found %d playback devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Playback device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_FALSE));\n    }\n\n    if (params.playbackId < 0 || params.playbackId >= nDevices) {\n        printf(\"Invalid playback device id selected - %d\\n\", params.playbackId);\n        return false;\n    }\n\n    SDL_AudioSpec playbackSpec;\n    SDL_zero(playbackSpec);\n\n    playbackSpec.freq = params.sampleRate;\n    playbackSpec.format = std::is_same<TSample, int16_t>::value ? AUDIO_S16 : AUDIO_S32;\n    playbackSpec.channels = 1;\n    playbackSpec.samples = TPlaybackData::kSamples;\n    playbackSpec.callback = cbPlayback<TSample>;\n    playbackSpec.userdata = &g_playbackData;\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    g_deviceIdOut = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(params.playbackId, SDL_FALSE), SDL_FALSE, &playbackSpec, &obtainedSpec, 0);\n    if (!g_deviceIdOut) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for playback: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return false;\n    }\n\n    printf(\"Opened playback device succesfully!\\n\");\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d\\n\", obtainedSpec.format);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    SDL_PauseAudioDevice(g_deviceIdOut, 1);\n\n    return true;\n}\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s input.kbd [-pN] [-FN] [-fN]\\n\", argv[0]);\n    printf(\"    -pN - select playback device N\\n\");\n    printf(\"    -FN - select filter type, (0 - none, 1 - first order high-pass, 2 - second order high-pass)\\n\");\n    printf(\"    -fN - cutoff frequency in Hz\\n\");\n    printf(\"\\n\");\n\n    printf(\"Usage: %s record.kbd\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    const auto argm = parseCmdArguments(argc, argv);\n    const int playbackId    = argm.count(\"p\") == 0 ? 0 : std::stoi(argm.at(\"p\"));\n    const int filterId      = argm.count(\"F\") == 0 ? EAudioFilter::FirstOrderHighPass : std::stoi(argm.at(\"F\"));\n    const int freqCutoff_Hz = argm.count(\"f\") == 0 ? kFreqCutoff_Hz : std::stoi(argm.at(\"f\"));\n\n    TParameters params;\n    TWaveform waveformInput;\n\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) != 0) {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -2;\n    }\n\n    params.playbackId = playbackId;\n\n    g_doInit = [&]() {\n        return prepareAudioOut(params);\n    };\n\n    {\n        TWaveformF waveformInputF;\n        printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n        if (readFromFile<TSampleF>(argv[1], waveformInputF) == false) {\n            printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n            return -1;\n        } else {\n            printf(\"[+] Filtering waveform with filter type = %d and cutoff frequency = %d Hz\\n\", filterId, freqCutoff_Hz);\n            ::filter(waveformInputF, (EAudioFilter) filterId, freqCutoff_Hz, kSampleRate);\n\n            printf(\"[+] Converting waveform to i16 format ...\\n\");\n            if (convert(waveformInputF, waveformInput) == false) {\n                printf(\"Conversion failed\\n\");\n                return -4;\n            }\n        }\n    }\n\n    Gui::Objects guiObjects;\n    if (Gui::init(\"View-full\", g_windowSizeX, g_windowSizeY, guiObjects) == false) {\n        return -6;\n    }\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) waveformInput.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*waveformInput.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) waveformInput.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(waveformInput.size())/params.sampleRate);\n\n    bool finishApp = false;\n    g_mainUpdate = [&]() {\n        if (finishApp) return false;\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            switch (event.type) {\n                case SDL_QUIT:\n                    finishApp = true;\n                    break;\n                case SDL_KEYDOWN:\n                    if (event.key.keysym.sym == SDLK_ESCAPE) {\n                        finishApp = true;\n                    }\n                    break;\n                case SDL_WINDOWEVENT:\n                    if (event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(guiObjects.window)) {\n                        finishApp = true;\n                    }\n                    break;\n            };\n        }\n\n        SDL_GetWindowSize(guiObjects.window, &g_windowSizeX, &g_windowSizeY);\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplSDL2_NewFrame(guiObjects.window);\n        ImGui::NewFrame();\n\n        renderWaveform(params, waveformInput);\n\n        ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\n\n        Gui::render(guiObjects);\n\n        return true;\n    };\n\n#ifdef __EMSCRIPTEN__\n    emscripten_set_main_loop_arg(mainUpdate, NULL, 0, true);\n#else\n    if (g_doInit() == false) {\n        printf(\"Error: failed to initialize audio playback\\n\");\n        return -2;\n    }\n\n    while (true) {\n        if (g_mainUpdate() == false) break;\n    }\n#endif\n\n    printf(\"[+] Terminated\\n\");\n\n    Gui::free(guiObjects);\n\n    return 0;\n}\n"
        },
        {
          "name": "view-gui.cpp",
          "type": "blob",
          "size": 15.9072265625,
          "content": "/*! \\file view-gui.cpp\n *  \\brief Visualize training data recorded with 'record'\n *  \\author Georgi Gerganov\n */\n\n#include \"common.h\"\n#include \"constants.h\"\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl.h\"\n#include \"imgui_impl_opengl3.h\"\n\n#include <SDL.h>\n#include <GL/gl3w.h>\n\n#include <chrono>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <thread>\n#include <algorithm>\n\n#define MY_DEBUG\n\n// globals\nint g_windowSizeX = 1600;\nint g_windowSizeY = 400;\n\nstruct stParameters;\n\nusing TParameters           = stParameters;\n\nusing TSampleInput          = TSampleF;\nusing TSample               = TSampleI16;\nusing TWaveform             = TWaveformI16;\nusing TWaveformView         = TWaveformViewI16;\nusing TPlaybackData         = TPlaybackDataI16;\n\nstruct stParameters {\n    int playbackId              = 0;\n    int keyPressWidth_samples   = 256;\n    int sampleRate              = kSampleRate;\n    int offsetFromPeak          = keyPressWidth_samples/2;\n    int alignWindow             = 256;\n    float thresholdClustering   = 0.5f;\n};\n\nfloat plotWaveform(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return waveform->samples[i];\n}\n\nfloat plotWaveformInverse(void * data, int i) {\n    TWaveformView * waveform = (TWaveformView *)data;\n    return -waveform->samples[i];\n}\n\nSDL_AudioDeviceID g_deviceIdOut = 0;\nTPlaybackData g_playbackData;\n\nbool renderWaveform(TParameters & params, const TWaveform & waveform, const TTrainKeys & trainKeys) {\n    ImGui::SetNextWindowPos(ImVec2(0, 0));\n    ImGui::SetNextWindowSize(ImVec2(g_windowSizeX, g_windowSizeY));\n    if (ImGui::Begin(\"Waveform\", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove)) {\n        int viewMin = 512;\n        int viewMax = waveform.size();\n\n        static int nview = waveform.size();\n        static int offset = (waveform.size() - nview)/2;\n        static float amin = std::numeric_limits<TSample>::min();\n        static float amax = std::numeric_limits<TSample>::max();\n        static float dragOffset = 0.0f;\n        static float scrollSize = 18.0f;\n\n        static auto nviewPrev = nview + 1;\n\n        static TWaveform waveformLowRes = waveform;\n        static TWaveform waveformThreshold = waveform;\n\n        auto wview = getView(waveformLowRes, offset, nview);\n        auto wsize = ImGui::GetContentRegionAvail();\n        wsize.y -= 50.0f;\n\n        auto mpos = ImGui::GetIO().MousePos;\n        auto savePos = ImGui::GetCursorScreenPos();\n        auto drawList = ImGui::GetWindowDrawList();\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.3f, 0.3f, 0.3f, 0.3f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveformInverse, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::PushStyleColor(ImGuiCol_FrameBg, { 0.1f, 0.1f, 0.1f, 0.0f });\n        ImGui::PushStyleColor(ImGuiCol_PlotHistogram, { 1.0f, 1.0f, 1.0f, 1.0f });\n        ImGui::PlotHistogram(\"##Waveform\", plotWaveform, &wview, nview, 0, \"Waveform\", amin, amax, wsize);\n        ImGui::PopStyleColor(2);\n        ImGui::SetCursorScreenPos(savePos);\n        ImGui::InvisibleButton(\"##WaveformIB\",wsize);\n        if (ImGui::IsItemHovered()) {\n            auto w = ImGui::GetIO().MouseWheel;\n            auto nview_old = nview;\n            nview *= (10.0 + w)/10.0;\n            nview = std::min(std::max(viewMin, nview), viewMax);\n            if (w != 0.0) {\n                offset = std::max(0.0f, offset + ((mpos.x - savePos.x)/wsize.x)*(nview_old - nview));\n            }\n\n            if (ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0) == false) {\n                dragOffset = offset;\n            }\n\n            if (ImGui::IsMouseDragging(0)) {\n                offset = dragOffset - ImGui::GetMouseDragDelta(0).x*nview/wsize.x;\n            }\n        }\n        if (ImGui::BeginPopupContextWindow()) {\n            ImGui::SliderInt(\"View  \", &nview, viewMin, viewMax);\n            ImGui::DragInt  (\"Offset\", &offset, 0.01*nview, 0, waveform.size() - nview);\n            ImGui::SliderFloat(\"Amplitude Min\", &amin, std::numeric_limits<TSample>::min(), 0);\n            ImGui::SliderFloat(\"Amplitude Max\", &amax, 0, std::numeric_limits<TSample>::max());\n            ImGui::EndPopup();\n        }\n\n        ImGui::InvisibleButton(\"##WaveformScrollIB\", {wsize.x, scrollSize});\n        drawList->AddRect({savePos.x, savePos.y + wsize.y}, {savePos.x + wsize.x, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n        drawList->AddRectFilled({savePos.x + wsize.x*(1.f*offset)/viewMax, savePos.y + wsize.y}, {savePos.x + wsize.x*(1.f*offset + nview)/viewMax, savePos.y + wsize.y + scrollSize}, ImGui::ColorConvertFloat4ToU32({1.0f, 1.0f, 1.0f, 1.0f}));\n\n        auto savePos2 = ImGui::GetCursorScreenPos();\n\n        static bool scrolling = false;\n        if (ImGui::IsItemHovered()) {\n            if (ImGui::IsMouseDown(0)) {\n                scrolling = true;\n            }\n        }\n\n        if (scrolling) {\n            offset = ((mpos.x - savePos.x)/wsize.x)*viewMax - nview/2;\n        }\n\n        if (ImGui::IsMouseDown(0) == false) {\n            scrolling = false;\n        }\n\n        offset = std::max(0, std::min((int) offset, (int) waveform.size() - nview));\n\n        for (int i = 0; i < (int) trainKeys.size(); ++i) {\n            int pos = i*kSamplesPerFrame*kBufferSizeTrain_frames + 0.5*kBufferSizeTrain_frames*kSamplesPerFrame;\n            if (pos + params.offsetFromPeak + params.keyPressWidth_samples < offset) continue;\n            if (pos + params.offsetFromPeak - params.keyPressWidth_samples >= offset + nview) break;\n\n            {\n                float x0 = ((float)(pos - offset))/nview;\n\n                ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                ImVec2 p1 = { savePos.x + x0*wsize.x, savePos.y + wsize.y };\n\n                drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 0.0f, 0.0f, 0.8f }), 1.0f);\n            }\n\n            {\n                //float x0 = ((float)(pos - offset))/nview;\n                float x1 = ((float)(pos + params.offsetFromPeak - params.keyPressWidth_samples - offset))/nview;\n                float x2 = ((float)(pos + params.offsetFromPeak + params.keyPressWidth_samples - offset))/nview;\n\n                //ImVec2 p0 = { savePos.x + x0*wsize.x, savePos.y };\n                //ImVec2 p1 = { savePos.x + x1*wsize.x, savePos.y };\n                //ImVec2 p2 = { savePos.x + x2*wsize.x, savePos.y + wsize.y };\n\n                if (nview < 64.0*wsize.x) {\n                    ImGui::SetCursorScreenPos({ savePos.x + 0.5f*((x1 + x2)*wsize.x - ImGui::CalcTextSize(std::to_string(i).c_str()).x), savePos.y + wsize.y - ImGui::GetTextLineHeightWithSpacing() });\n                    ImGui::Text(\"%d - %s\", i, kKeyText.at(trainKeys[i]));\n                }\n\n            }\n        }\n\n        {\n            float x0 = ((float)(g_playbackData.offset + g_playbackData.idx - offset))/nview;\n\n            ImVec2 p0 = {savePos.x + x0*wsize.x, savePos.y};\n            ImVec2 p1 = {savePos.x + x0*wsize.x, savePos.y + wsize.y};\n            drawList->AddLine(p0, p1, ImGui::ColorConvertFloat4ToU32({ 1.0f, 1.0f, 0.0f, 0.3f }));\n        }\n\n        ImGui::SetCursorScreenPos(savePos2);\n\n        //auto io = ImGui::GetIO();\n        //ImGui::Text(\"Keys pressed:\");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text(\"%d\", i); }\n\n        static bool playHalfSpeed = false;\n        ImGui::PushItemWidth(100.0);\n\n        ImGui::Checkbox(\"x0.5\", &playHalfSpeed);\n        ImGui::SameLine();\n        if (g_playbackData.playing) {\n            if (ImGui::Button(\"Stop\") || ImGui::IsKeyPressed(44)) { // space\n                g_playbackData.idx = g_playbackData.waveform.n - 1;\n            }\n        } else {\n            if (ImGui::Button(\"Play\") || ImGui::IsKeyPressed(44)) { // space\n                g_playbackData.playing = true;\n                g_playbackData.slowDown = playHalfSpeed ? 2 : 1;\n                g_playbackData.idx = 0;\n                g_playbackData.offset = offset;\n                g_playbackData.waveform = getView(waveform, offset, nview);\n                SDL_PauseAudioDevice(g_deviceIdOut, 0);\n            }\n        }\n\n        if (g_playbackData.idx >= g_playbackData.waveform.n) {\n            g_playbackData.playing = false;\n            SDL_ClearQueuedAudio(g_deviceIdOut);\n            SDL_PauseAudioDevice(g_deviceIdOut, 1);\n        }\n\n        ImGui::PopItemWidth();\n\n        if (nview != nviewPrev) {\n            generateLowResWaveform(waveform, waveformLowRes, std::max(1.0f, nview/wsize.x));\n            nviewPrev = nview;\n        }\n    }\n    ImGui::End();\n\n    return false;\n}\n\nbool prepareAudioOut(const TParameters & params) {\n    if (SDL_Init(SDL_INIT_AUDIO) < 0) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    int nDevices = SDL_GetNumAudioDevices(SDL_FALSE);\n    printf(\"Found %d playback devices:\\n\", nDevices);\n    for (int i = 0; i < nDevices; i++) {\n        printf(\"    - Playback device #%d: '%s'\\n\", i, SDL_GetAudioDeviceName(i, SDL_FALSE));\n    }\n\n    if (params.playbackId < 0 || params.playbackId >= nDevices) {\n        printf(\"Invalid playback device id selected - %d\\n\", params.playbackId);\n        return false;\n    }\n\n    SDL_AudioSpec playbackSpec;\n    SDL_zero(playbackSpec);\n\n    playbackSpec.freq = params.sampleRate;\n    playbackSpec.format = std::is_same<TSample, int16_t>::value ? AUDIO_S16 : AUDIO_S32;\n    playbackSpec.channels = 1;\n    playbackSpec.samples = TPlaybackData::kSamples;\n    playbackSpec.callback = cbPlayback<TSample>;\n    playbackSpec.userdata = &g_playbackData;\n\n    SDL_AudioSpec obtainedSpec;\n    SDL_zero(obtainedSpec);\n\n    g_deviceIdOut = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(params.playbackId, SDL_FALSE), SDL_FALSE, &playbackSpec, &obtainedSpec, 0);\n    if (!g_deviceIdOut) {\n        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't open an audio device for playback: %s!\\n\", SDL_GetError());\n        SDL_Quit();\n        return false;\n    }\n\n    printf(\"Opened playback device succesfully!\\n\");\n    printf(\"    Frequency:  %d\\n\", obtainedSpec.freq);\n    printf(\"    Format:     %d\\n\", obtainedSpec.format);\n    printf(\"    Channels:   %d\\n\", obtainedSpec.channels);\n    printf(\"    Samples:    %d\\n\", obtainedSpec.samples);\n\n    SDL_PauseAudioDevice(g_deviceIdOut, 1);\n\n    return true;\n}\n\nint main(int argc, char ** argv) {\n    printf(\"Usage: %s input.kbd [-pN]\\n\", argv[0]);\n    printf(\"    -pN - select playback device N\\n\");\n    printf(\"\\n\");\n\n    printf(\"Usage: %s record.kbd\\n\", argv[0]);\n    if (argc < 2) {\n        return -1;\n    }\n\n    auto argm = parseCmdArguments(argc, argv);\n    int playbackId = argm[\"p\"].empty() ? 0 : std::stoi(argm[\"p\"]);\n\n    TParameters params;\n    TWaveform waveformInput;\n    TTrainKeys trainKeys;\n\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) != 0) {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    params.playbackId = playbackId;\n\n    if (prepareAudioOut(params) == false) {\n        printf(\"Error: failed to initialize audio playback\\n\");\n        return -2;\n    }\n\n    printf(\"[+] Loading recording from '%s'\\n\", argv[1]);\n    {\n        int32_t bufferSize_frames = 0;\n        if (readFromFile<TSampleF>(argv[1], waveformInput, trainKeys, bufferSize_frames) == false) {\n            printf(\"Specified file '%s' does not exist\\n\", argv[1]);\n            return -1;\n        }\n\n        if (bufferSize_frames != kBufferSizeTrain_frames) {\n            printf(\"Buffer size in file (%d) does not match the expected one (%d)\\n\", bufferSize_frames, (int) kBufferSizeTrain_frames);\n            return -1;\n        }\n    }\n\n#if __APPLE__\n    // GL 3.2 Core + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#endif\n\n    // Create window with graphics context\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_DisplayMode current;\n    SDL_GetCurrentDisplayMode(0, &current);\n    SDL_Window* window = SDL_CreateWindow(\"View\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, g_windowSizeX, g_windowSizeY, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE|SDL_WINDOW_ALLOW_HIGHDPI);\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Initialize OpenGL loader\n    bool err = gl3wInit() != 0;\n    if (err) {\n        fprintf(stderr, \"Failed to initialize OpenGL loader!\\n\");\n        return 1;\n    }\n\n    // Setup Dear ImGui binding\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;  // Enable Keyboard Controls\n\n    ImGui::GetStyle().AntiAliasedFill = false;\n    ImGui::GetStyle().AntiAliasedLines = false;\n\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL3_Init(glsl_version);\n\n    printf(\"[+] Loaded recording: of %d samples (sample size = %d bytes)\\n\", (int) waveformInput.size(), (int) sizeof(TSample));\n    printf(\"    Size in memory:          %g MB\\n\", (float)(sizeof(TSample)*waveformInput.size())/1024/1024);\n    printf(\"    Sample size:             %d\\n\", (int) sizeof(TSample));\n    printf(\"    Total number of samples: %d\\n\", (int) waveformInput.size());\n    printf(\"    Recording length:        %g seconds\\n\", (float)(waveformInput.size())/params.sampleRate);\n\n    bool finishApp = false;\n    while (finishApp == false) {\n        SDL_Event event;\n        while (SDL_PollEvent(&event)) {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            switch (event.type) {\n                case SDL_QUIT:\n                    finishApp = true;\n                    break;\n                case SDL_KEYDOWN:\n                    if (event.key.keysym.sym == SDLK_ESCAPE) {\n                        finishApp = true;\n                    }\n                    break;\n                case SDL_WINDOWEVENT:\n                    if (event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(window)) finishApp = true;\n                    break;\n            };\n        }\n\n        SDL_GetWindowSize(window, &g_windowSizeX, &g_windowSizeY);\n\n        auto tStart = std::chrono::high_resolution_clock::now();\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplSDL2_NewFrame(window);\n        ImGui::NewFrame();\n\n        renderWaveform(params, waveformInput, trainKeys);\n\n        ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\n\n        ImGui::Render();\n        SDL_GL_MakeCurrent(window, gl_context);\n        glViewport(0, 0, (int) io.DisplaySize.x, (int) io.DisplaySize.y);\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n        SDL_GL_SwapWindow(window);\n\n        // stupid hack to limit frame-rate to ~60 fps on Mojave\n        auto tEnd = std::chrono::high_resolution_clock::now();\n        auto tus = std::chrono::duration_cast<std::chrono::microseconds>(tEnd - tStart).count();\n        while (tus < 1e6/60.0) {\n            std::this_thread::sleep_for(std::chrono::microseconds(std::max(100, (int) (0.5*(1e6/60.0 - tus)))));\n            tEnd = std::chrono::high_resolution_clock::now();\n            tus = std::chrono::duration_cast<std::chrono::microseconds>(tEnd - tStart).count();\n        }\n    }\n\n    return 0;\n}\n"
        }
      ]
    }
  ]
}